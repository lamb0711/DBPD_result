Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Takes care of RegionAttributes, AttributesMutator, and some no-brainer method
- * implementations.
+ * Takes care of RegionAttributes, AttributesMutator, and some no-brainer method implementations.
-public abstract class AbstractRegion implements Region, RegionAttributes,
-                                                AttributesMutator, CacheStatistics,
-                                                DataSerializableFixedID, RegionEntryContext,
-                                                Extensible<Region<?,?>>
-{
+public abstract class AbstractRegion implements Region, RegionAttributes, AttributesMutator,
+    CacheStatistics, DataSerializableFixedID, RegionEntryContext, Extensible<Region<?, ?>> {
-  
+
-   * Identifies the static order in which this region was created in relation
-   * to other regions or other instances of this region during the life of
-   * this JVM.
+   * Identifies the static order in which this region was created in relation to other regions or
+   * other instances of this region during the life of this JVM.
-   * Used to synchronize WRITES to cacheListeners.
-   * Always do copy on write.
+   * Used to synchronize WRITES to cacheListeners. Always do copy on write.
-   * NOTE: care must be taken to never modify the array of cacheListeners in
-   * place. Instead allocate a new array and modify it.
-   * This field is volatile so that it can be read w/o getting clSync.
+   * NOTE: care must be taken to never modify the array of cacheListeners in place. Instead allocate
+   * a new array and modify it. This field is volatile so that it can be read w/o getting clSync.
-  
+
-  //merge42004: revision 42004 has not defined isPdxTypesRegion. It has come to cheetah branch from merge revision 39860. This is getting used in method getRemoteDsIds.
-  
+  // merge42004: revision 42004 has not defined isPdxTypesRegion. It has come to cheetah branch from
+  // merge revision 39860. This is getting used in method getRemoteDsIds.
+
-  
+
-  
+
-  
+
-  
+
+   * 
-  //Asif : The ThreadLocal is used to identify if the thread is an
-  //index creation thread. This identification helps skip the synchronization
+  // Asif : The ThreadLocal is used to identify if the thread is an
+  // index creation thread. This identification helps skip the synchronization
-  //if the value is "REMOVED" token. This prevents the dead lock , in case the
+  // if the value is "REMOVED" token. This prevents the dead lock , in case the
-  private static final boolean trackHits = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreHits");
-  private static final boolean trackMisses = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreMisses");
+  private static final boolean trackHits =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreHits");
+  private static final boolean trackMisses =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreMisses");
-  
+
-  
+
-  
+
-  protected ExtensionPoint<Region<?,?>> extensionPoint = new SimpleExtensionPoint<Region<?,?>>(this, this);
-  
+  protected ExtensionPoint<Region<?, ?>> extensionPoint =
+      new SimpleExtensionPoint<Region<?, ?>>(this, this);
+
-  protected AbstractRegion(GemFireCacheImpl cache, RegionAttributes attrs,
-      String regionName, InternalRegionArguments internalRegionArgs) {
+  protected AbstractRegion(GemFireCacheImpl cache, RegionAttributes attrs, String regionName,
+      InternalRegionArguments internalRegionArgs) {
-  AbstractRegion(GemFireCacheImpl cache, int serialNumber, boolean isPdxTypeRegion, long lastAccessedTime, long lastModifiedTime ) {
+  AbstractRegion(GemFireCacheImpl cache, int serialNumber, boolean isPdxTypeRegion,
+      long lastAccessedTime, long lastModifiedTime) {
-  
+
-   * configure this region to ignore or not ignore in-progress JTA transactions.
-   * Setting this to true will cause cache operations to no longer notice JTA
-   * transactions. The default setting is false
+   * configure this region to ignore or not ignore in-progress JTA transactions. Setting this to
+   * true will cause cache operations to no longer notice JTA transactions. The default setting is
+   * false
-   * @deprecated in 5.0 and later releases, use the region attribute ignoreJTA
-   *             to configure this
+   * @deprecated in 5.0 and later releases, use the region attribute ignoreJTA to configure this
-  public void setIgnoreJTA(boolean ignore)
-  {
+  public void setIgnoreJTA(boolean ignore) {
-  public final void create(Object key, Object value) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+  public final void create(Object key, Object value)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-  public final Object destroy(Object key) throws TimeoutException,
-      EntryNotFoundException, CacheWriterException
-  {
+  public final Object destroy(Object key)
+      throws TimeoutException, EntryNotFoundException, CacheWriterException {
-  public Object get(Object name) throws CacheLoaderException,
-      TimeoutException
-  {
+  public Object get(Object name) throws CacheLoaderException, TimeoutException {
-  public Object put(Object name, Object value) throws TimeoutException,
-      CacheWriterException
-  {
+  public Object put(Object name, Object value) throws TimeoutException, CacheWriterException {
-      throws CacheLoaderException, TimeoutException
-  {
+      throws CacheLoaderException, TimeoutException {
-  public final void localDestroyRegion()
-  {
+  public final void localDestroyRegion() {
-   * @param key  the key to find
+   * @param key the key to find
-  abstract Object get(Object key, Object aCallbackArgument,
-      boolean generateCallbacks, EntryEventImpl clientEvent) throws TimeoutException, CacheLoaderException;
+  abstract Object get(Object key, Object aCallbackArgument, boolean generateCallbacks,
+      EntryEventImpl clientEvent) throws TimeoutException, CacheLoaderException;
-  public final void destroyRegion() throws CacheWriterException,
-      TimeoutException
-  {
+  public final void destroyRegion() throws CacheWriterException, TimeoutException {
-  public final void invalidate(Object key) throws TimeoutException,
-      EntryNotFoundException
-  {
+  public final void invalidate(Object key) throws TimeoutException, EntryNotFoundException {
-  public final void localInvalidate(Object key) throws EntryNotFoundException
-  {
+  public final void localInvalidate(Object key) throws EntryNotFoundException {
-  public final void localInvalidateRegion()
-  {
+  public final void localInvalidateRegion() {
-  public final void invalidateRegion() throws TimeoutException
-  {
+  public final void invalidateRegion() throws TimeoutException {
-   * The default Region implementation will generate EvenTID in the EntryEvent
-   * object. This method is overridden in special Region objects like HARegion
-   * or SingleWriteSingleReadRegionQueue.SingleReadWriteMetaRegion to return
-   * false as the event propagation from those regions do not need EventID
-   * objects. This method is made abstract to directly use it in clear operations.
-   *(clear and localclear)
+   * The default Region implementation will generate EvenTID in the EntryEvent object. This method
+   * is overridden in special Region objects like HARegion or
+   * SingleWriteSingleReadRegionQueue.SingleReadWriteMetaRegion to return false as the event
+   * propagation from those regions do not need EventID objects. This method is made abstract to
+   * directly use it in clear operations. (clear and localclear)
+   * 
-  public void clear()
-  {
+  public void clear() {
-    RegionEventImpl regionEvent = new RegionEventImpl(this,
-        Operation.REGION_CLEAR, null, false, getMyId(),generateEventID());
+    RegionEventImpl regionEvent = new RegionEventImpl(this, Operation.REGION_CLEAR, null, false,
+        getMyId(), generateEventID());
-  public void localClear()
-  {
+  public void localClear() {
-    RegionEventImpl event = new RegionEventImpl(this,
-        Operation.REGION_LOCAL_CLEAR, null, false, getMyId(),generateEventID()/* generate EventID */);
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_LOCAL_CLEAR, null, false,
+        getMyId(), generateEventID()/* generate EventID */);
-    return keys.isEmpty()? new HashMap(): basicGetAll(keys, callback);
+    return keys.isEmpty() ? new HashMap() : basicGetAll(keys, callback);
-    buf.append("[path='")
-       .append(getFullPath())
-       .append("';scope=")
-       .append(getScope())
-       .append("';dataPolicy=")
-       .append(this.dataPolicy);
+    buf.append("[path='").append(getFullPath()).append("';scope=").append(getScope())
+        .append("';dataPolicy=").append(this.dataPolicy);
-  public CacheLoader getCacheLoader()
-  {
-    //checkReadiness();
+  public CacheLoader getCacheLoader() {
+    // checkReadiness();
-  public CacheWriter getCacheWriter()
-  {
-    //checkReadiness();
+  public CacheWriter getCacheWriter() {
+    // checkReadiness();
-   * Return a cache loader if this region has one.
-   * Note if region's loader is used to implement bridge then null is returned.
+   * Return a cache loader if this region has one. Note if region's loader is used to implement
+   * bridge then null is returned.
+   * 
+
-   * Return a cache writer if this region has one.
-   * Note if region's writer is used to implement bridge then null is returned.
+   * Return a cache writer if this region has one. Note if region's writer is used to implement
+   * bridge then null is returned.
+   * 
-  
-  public Class getKeyConstraint()
-  {
-    //checkReadiness();
+
+  public Class getKeyConstraint() {
+    // checkReadiness();
-  public Class getValueConstraint()
-  {
+  public Class getValueConstraint() {
-  
+
-    this.regionTimeToLiveAtts = new ExpirationAttributes(this.regionTimeToLive, this.regionTimeToLiveExpirationAction);
+    this.regionTimeToLiveAtts =
+        new ExpirationAttributes(this.regionTimeToLive, this.regionTimeToLiveExpirationAction);
-  public ExpirationAttributes getRegionTimeToLive()
-  {
+  public ExpirationAttributes getRegionTimeToLive() {
-  
+
-    this.regionIdleTimeoutAtts = new ExpirationAttributes(this.regionIdleTimeout, this.regionIdleTimeoutExpirationAction);
+    this.regionIdleTimeoutAtts =
+        new ExpirationAttributes(this.regionIdleTimeout, this.regionIdleTimeoutExpirationAction);
-  public ExpirationAttributes getRegionIdleTimeout()
-  {
+  public ExpirationAttributes getRegionIdleTimeout() {
-  
+
-  
+
-    this.entryTimeToLiveAtts = new ExpirationAttributes(this.entryTimeToLive, this.entryTimeToLiveExpirationAction);
+    this.entryTimeToLiveAtts =
+        new ExpirationAttributes(this.entryTimeToLive, this.entryTimeToLiveExpirationAction);
-  public ExpirationAttributes getEntryTimeToLive()
-  {
+  public ExpirationAttributes getEntryTimeToLive() {
-  
+
-  
+
-    this.entryIdleTimeoutAtts = new ExpirationAttributes(this.entryIdleTimeout, this.entryIdleTimeoutExpirationAction);
+    this.entryIdleTimeoutAtts =
+        new ExpirationAttributes(this.entryIdleTimeout, this.entryIdleTimeoutExpirationAction);
-  public ExpirationAttributes getEntryIdleTimeout()
-  {
+  public ExpirationAttributes getEntryIdleTimeout() {
-  
+
-    if (this.dataPolicy.isNormal() || this.dataPolicy.isPreloaded()
-        || this.dataPolicy.isEmpty() || this.dataPolicy.withPartitioning()) {
+    if (this.dataPolicy.isNormal() || this.dataPolicy.isPreloaded() || this.dataPolicy.isEmpty()
+        || this.dataPolicy.withPartitioning()) {
-    }
-    else if (this.dataPolicy.withReplication()) {
+    } else if (this.dataPolicy.withReplication()) {
-    }
-    else {
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_NO_MIRROR_TYPE_CORRESPONDS_TO_DATA_POLICY_0.toLocalizedString(this.dataPolicy));
+    } else {
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_NO_MIRROR_TYPE_CORRESPONDS_TO_DATA_POLICY_0
+              .toLocalizedString(this.dataPolicy));
-  
-  public String getPoolName()
-  {
-    //checkReadiness();
+
+  public String getPoolName() {
+    // checkReadiness();
-  
-  public DataPolicy getDataPolicy()
-  {
-    //checkReadiness();
+
+  public DataPolicy getDataPolicy() {
+    // checkReadiness();
-  public Scope getScope()
-  {
-    //checkReadiness();
+  public Scope getScope() {
+    // checkReadiness();
-  public CacheListener getCacheListener()
-  {
-    //checkReadiness();
+  public CacheListener getCacheListener() {
+    // checkReadiness();
-    }
-    else {
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_MORE_THAN_ONE_CACHE_LISTENER_EXISTS.toLocalizedString());
+    } else {
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_MORE_THAN_ONE_CACHE_LISTENER_EXISTS.toLocalizedString());
-  
+
-    return (this.cache.getAllGatewaySenders().size() > 0
-        && this.allGatewaySenderIds.size() > 0);
+    return (this.cache.getAllGatewaySenders().size() > 0 && this.allGatewaySenderIds.size() > 0);
-    if (sz > 0
-        && (allGatewaySenders = this.cache.getGatewaySenders()).size() > 0) {
+    if (sz > 0 && (allGatewaySenders = this.cache.getGatewaySenders()).size() > 0) {
-        if (sender.isRunning()
-            && this.gatewaySenderIds.contains(sender.getId())) {
+        if (sender.isRunning() && this.gatewaySenderIds.contains(sender.getId())) {
-    if (sz > 0
-        && (allAsyncQueues = this.cache.getAsyncEventQueues()).size() > 0) {
+    if (sz > 0 && (allAsyncQueues = this.cache.getAsyncEventQueues()).size() > 0) {
-        //merge42004:In cheetah asyncEventQueue has isRunning Method. It has come from merging branches. A mail regarding the asyncEventQueue is sent to Barry to get more clarification. We need to sort this out.
-        if (/*asyncQueue.isRunning()
-            &&*/ this.asyncEventQueueIds.contains(asyncQueue.getId())) {
+        // merge42004:In cheetah asyncEventQueue has isRunning Method. It has come from merging
+        // branches. A mail regarding the asyncEventQueue is sent to Barry to get more
+        // clarification. We need to sort this out.
+        if (/*
+             * asyncQueue.isRunning() &&
+             */ this.asyncEventQueueIds.contains(asyncQueue.getId())) {
-            /*// ParalleGatewaySender with DR is not allowed
-            if (this.partitionAttributes == null && sender.isParallel()) {
-              throw new IllegalStateException(LocalizedStrings
-                  .AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
-                      .toLocalizedString(sender.getId()));
-            }*/
+            /*
+             * // ParalleGatewaySender with DR is not allowed if (this.partitionAttributes == null
+             * && sender.isParallel()) { throw new IllegalStateException(LocalizedStrings
+             * .AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+             * .toLocalizedString(sender.getId())); }
+             */
-        }
-        else { // this else is for PDX region
+        } else { // this else is for PDX region
-//  protected final void initAllGatewaySenderIds() {
-//    HashSet<String> senderIds = new HashSet<String>();
-//    this.allGatewaySenderIds = senderIds;
-//    if (getGatewaySenderIds().isEmpty() && getAsyncEventQueueIds().isEmpty()) {
-//      return Collections.emptySet(); // fix for bug 45774
-//    }
-//    Set<String> tmp = new CopyOnWriteArraySet<String>();
-//    tmp.addAll(this.getGatewaySenderIds());
-//    for(String asyncQueueId : this.getAsyncEventQueueIds()){
-//      tmp.add(AsyncEventQueueImpl.getSenderIdFromAsyncEventQueueId(asyncQueueId));
-//    }
-//    return tmp;
-//  }
-  
+  // protected final void initAllGatewaySenderIds() {
+  // HashSet<String> senderIds = new HashSet<String>();
+  // this.allGatewaySenderIds = senderIds;
+  // if (getGatewaySenderIds().isEmpty() && getAsyncEventQueueIds().isEmpty()) {
+  // return Collections.emptySet(); // fix for bug 45774
+  // }
+  // Set<String> tmp = new CopyOnWriteArraySet<String>();
+  // tmp.addAll(this.getGatewaySenderIds());
+  // for(String asyncQueueId : this.getAsyncEventQueueIds()){
+  // tmp.add(AsyncEventQueueImpl.getSenderIdFromAsyncEventQueueId(asyncQueueId));
+  // }
+  // return tmp;
+  // }
+
-  
+
-  public CacheListener[] getCacheListeners()
-  {
+  public CacheListener[] getCacheListeners() {
-    }
-    else {
+    } else {
-  private final void storeCacheListenersField(CacheListener[] value)
-  {
+  private final void storeCacheListenersField(CacheListener[] value) {
-      }
-      else {
+      } else {
-   * Fetches the value in the cacheListeners field. NOTE: callers should not
-   * modify the contents of the returned array.
+   * Fetches the value in the cacheListeners field. NOTE: callers should not modify the contents of
+   * the returned array.
-  protected final CacheListener[] fetchCacheListenersField()
-  {
+  protected final CacheListener[] fetchCacheListenersField() {
-  public int getInitialCapacity()
-  {
-    //checkReadiness();
+  public int getInitialCapacity() {
+    // checkReadiness();
-  public float getLoadFactor()
-  {
-    //checkReadiness();
+  public float getLoadFactor() {
+    // checkReadiness();
-  public boolean isLockGrantor()
-  {
-    //checkReadiness();
+  public boolean isLockGrantor() {
+    // checkReadiness();
-   * RegionAttributes implementation. Returns true if multicast can be used by
-   * the cache for this region
+   * RegionAttributes implementation. Returns true if multicast can be used by the cache for this
+   * region
-  public boolean getMulticastEnabled()
-  {
-    //checkReadiness();
+  public boolean getMulticastEnabled() {
+    // checkReadiness();
-  public boolean getStatisticsEnabled()
-  {
-    //checkReadiness();
+  public boolean getStatisticsEnabled() {
+    // checkReadiness();
-  public boolean getIgnoreJTA()
-  {
-    //checkRediness();
+  public boolean getIgnoreJTA() {
+    // checkRediness();
-  public int getConcurrencyLevel()
-  {
-    //checkReadiness();
+  public int getConcurrencyLevel() {
+    // checkReadiness();
-  
+
-  public boolean getPersistBackup()
-  {
-    //checkReadiness();
+  public boolean getPersistBackup() {
+    // checkReadiness();
-  public boolean getEarlyAck()
-  {
-    //checkReadiness();
+  public boolean getEarlyAck() {
+    // checkReadiness();
-  public boolean getPublisher()
-  {
+  public boolean getPublisher() {
+
-  public boolean getEnableAsyncConflation()
-  {
+  public boolean getEnableAsyncConflation() {
-  public DiskWriteAttributes getDiskWriteAttributes()
-  {
-    //checkReadiness();
+  public DiskWriteAttributes getDiskWriteAttributes() {
+    // checkReadiness();
-  
+
-  public boolean getIndexMaintenanceSynchronous()
-  {
+  public boolean getIndexMaintenanceSynchronous() {
-  public PartitionAttributes getPartitionAttributes()
-  {
+  public PartitionAttributes getPartitionAttributes() {
-  public MembershipAttributes getMembershipAttributes()
-  {
+  public MembershipAttributes getMembershipAttributes() {
-  public SubscriptionAttributes getSubscriptionAttributes()
-  {
+  public SubscriptionAttributes getSubscriptionAttributes() {
-  
+
-  public IndexManager getIndexManager()
-  {
+  public IndexManager getIndexManager() {
-   * This method call is guarded by imSync lock created for each region.
-   * Set IndexManger for region.
+   * This method call is guarded by imSync lock created for each region. Set IndexManger for region.
-  public IndexManager setIndexManager(IndexManager indexManager)
-  {
+  public IndexManager setIndexManager(IndexManager indexManager) {
+   * 
-  //Asif : The ThreadLocal is used to identify if the thread is an
-  //index creation thread. This is used to fix Bug # 33336. The value
+  // Asif : The ThreadLocal is used to identify if the thread is an
+  // index creation thread. This is used to fix Bug # 33336. The value
-  public void setFlagForIndexCreationThread(boolean bool)
-  {
+  public void setFlagForIndexCreationThread(boolean bool) {
-  //Asif : The boolean is used in AbstractRegionEntry to skip the synchronized
+  // Asif : The boolean is used in AbstractRegionEntry to skip the synchronized
-  boolean isIndexCreationThread()
-  {
-    Boolean bool = (Boolean)this.isIndexCreator.get();
+  boolean isIndexCreationThread() {
+    Boolean bool = (Boolean) this.isIndexCreator.get();
-  public Region getRegion()
-  {
+  public Region getRegion() {
-  //   /**
-  //    * A CacheListener implementation that delegates to an array of listeners.
-  //    */
-  //   public static class ArrayCacheListener implements CacheListener {
-  //     private final CacheListener [] listeners;
-  //     /**
-  //      * Creates a cache listener given the list of listeners it will delegate to.
-  //      */
-  //     public ArrayCacheListener(CacheListener[] listeners) {
-  //       this.listeners = listeners;
-  //     }
-  //   }
-  public CacheListener setCacheListener(CacheListener aListener)
-  {
+  // /**
+  // * A CacheListener implementation that delegates to an array of listeners.
+  // */
+  // public static class ArrayCacheListener implements CacheListener {
+  // private final CacheListener [] listeners;
+  // /**
+  // * Creates a cache listener given the list of listeners it will delegate to.
+  // */
+  // public ArrayCacheListener(CacheListener[] listeners) {
+  // this.listeners = listeners;
+  // }
+  // }
+  public CacheListener setCacheListener(CacheListener aListener) {
-        throw new IllegalStateException(LocalizedStrings.AbstractRegion_MORE_THAN_ONE_CACHE_LISTENER_EXISTS.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AbstractRegion_MORE_THAN_ONE_CACHE_LISTENER_EXISTS
+                .toLocalizedString());
-      this.cacheListeners = new CacheListener[] { aListener };
+      this.cacheListeners = new CacheListener[] {aListener};
-    }
-    else { // we have no old listeners
+    } else { // we have no old listeners
-  
-  public void removeGatewaySenderId(String gatewaySenderId){
+
+  public void removeGatewaySenderId(String gatewaySenderId) {
-  
+
-  
+
-  
+
-      tmp.add(AsyncEventQueueImpl
-          .getSenderIdFromAsyncEventQueueId(asyncQueueId));
+      tmp.add(AsyncEventQueueImpl.getSenderIdFromAsyncEventQueueId(asyncQueueId));
-  public void addCacheListener(CacheListener cl)
-  {
+  public void addCacheListener(CacheListener cl) {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_ADDCACHELISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_ADDCACHELISTENER_PARAMETER_WAS_NULL.toLocalizedString());
-        this.cacheListeners = new CacheListener[] { wcl };
+        this.cacheListeners = new CacheListener[] {wcl};
-      }
-      else {
+      } else {
-          this.cacheListeners = (CacheListener[])
-              ArrayUtils.insert(oldListeners, oldListeners.length, wcl);
+          this.cacheListeners =
+              (CacheListener[]) ArrayUtils.insert(oldListeners, oldListeners.length, wcl);
-  
+
-   * We wrap RegionMembershipListeners in a container when adding them at
-   * runtime, so that we can properly initialize their membership set prior
-   * to delivering events to them.
+   * We wrap RegionMembershipListeners in a container when adding them at runtime, so that we can
+   * properly initialize their membership set prior to delivering events to them.
+   * 
-      return new WrappedRegionMembershipListener((RegionMembershipListener)cl);
+      return new WrappedRegionMembershipListener((RegionMembershipListener) cl);
-  
+
-    synchronized(clSync) { 
+    synchronized (clSync) {
-          WrappedRegionMembershipListener wrml = (WrappedRegionMembershipListener)cl;
+          WrappedRegionMembershipListener wrml = (WrappedRegionMembershipListener) cl;
-              initMbrs = (DistributedMember[])initialMembers
-                          .toArray(new DistributedMember[initialMembers.size()]);
+              initMbrs = (DistributedMember[]) initialMembers
+                  .toArray(new DistributedMember[initialMembers.size()]);
-  
-  public void initCacheListeners(CacheListener[] addedListeners)
-  {
+
+  public void initCacheListeners(CacheListener[] addedListeners) {
-      for (int i=0; i<addedListeners.length; i++) {
+      for (int i = 0; i < addedListeners.length; i++) {
-      }
-      else { // we have some listeners to add
+      } else { // we have some listeners to add
-          throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_INITCACHELISTENERS_PARAMETER_HAD_A_NULL_ELEMENT.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.AbstractRegion_INITCACHELISTENERS_PARAMETER_HAD_A_NULL_ELEMENT
+                  .toLocalizedString());
-        System.arraycopy(listenersToAdd, 0, newListeners, 0,
-            newListeners.length);
+        System.arraycopy(listenersToAdd, 0, newListeners, 0, newListeners.length);
-    }
-    else { // we had some listeners to add
+    } else { // we had some listeners to add
-      }
-      else {
+      } else {
-  public void removeCacheListener(CacheListener cl)
-  {
+  public void removeCacheListener(CacheListener cl) {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_REMOVECACHELISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_REMOVECACHELISTENER_PARAMETER_WAS_NULL
+              .toLocalizedString());
-          }
-          else {
+          } else {
-  public synchronized CacheWriter setCacheWriter(CacheWriter cacheWriter)
-  {
+  public synchronized CacheWriter setCacheWriter(CacheWriter cacheWriter) {
-  private synchronized void assignCacheWriter(CacheWriter cacheWriter)
-  {
+  private synchronized void assignCacheWriter(CacheWriter cacheWriter) {
-    if ((this.dataPolicy.withReplication()
-         || this.dataPolicy.withPartitioning())
-        && (ea == ExpirationAction.LOCAL_DESTROY
-            || ea == ExpirationAction.LOCAL_INVALIDATE)) {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_0_ACTION_IS_INCOMPATIBLE_WITH_THIS_REGIONS_DATA_POLICY.toLocalizedString(mode));
+    if ((this.dataPolicy.withReplication() || this.dataPolicy.withPartitioning())
+        && (ea == ExpirationAction.LOCAL_DESTROY || ea == ExpirationAction.LOCAL_INVALIDATE)) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_0_ACTION_IS_INCOMPATIBLE_WITH_THIS_REGIONS_DATA_POLICY
+              .toLocalizedString(mode));
-  
-  public ExpirationAttributes setEntryIdleTimeout(
-      ExpirationAttributes idleTimeout) {
+
+  public ExpirationAttributes setEntryIdleTimeout(ExpirationAttributes idleTimeout) {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_CANNOT_SET_IDLE_TIMEOUT_WHEN_STATISTICS_ARE_DISABLED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_CANNOT_SET_IDLE_TIMEOUT_WHEN_STATISTICS_ARE_DISABLED
+              .toLocalizedString());
-  
+
-        LocalizedStrings.AbstractRegion_CANNOT_SET_IDLE_TIMEOUT_WHEN_STATISTICS_ARE_DISABLED.toLocalizedString());
+          LocalizedStrings.AbstractRegion_CANNOT_SET_IDLE_TIMEOUT_WHEN_STATISTICS_ARE_DISABLED
+              .toLocalizedString());
-  public ExpirationAttributes setEntryTimeToLive(ExpirationAttributes timeToLive)
-  {
+  public ExpirationAttributes setEntryTimeToLive(ExpirationAttributes timeToLive) {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_CANNOT_SET_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_CANNOT_SET_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED
+              .toLocalizedString());
-  
+
-        LocalizedStrings.AbstractRegion_CANNOT_SET_CUSTOM_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED.toLocalizedString());
+          LocalizedStrings.AbstractRegion_CANNOT_SET_CUSTOM_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED
+              .toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_INVALIDATE_REGION_NOT_SUPPORTED_FOR_PR.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_INVALIDATE_REGION_NOT_SUPPORTED_FOR_PR
+                .toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_DESTROY_REGION_NOT_SUPPORTED_FOR_PR.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_DESTROY_REGION_NOT_SUPPORTED_FOR_PR
+                .toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_0_ACTION_IS_INCOMPATIBLE_WITH_THIS_REGIONS_DATA_POLICY.toLocalizedString("idleTimeout"));
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_0_ACTION_IS_INCOMPATIBLE_WITH_THIS_REGIONS_DATA_POLICY
+              .toLocalizedString("idleTimeout"));
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_CANNOT_SET_IDLE_TIMEOUT_WHEN_STATISTICS_ARE_DISABLED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_CANNOT_SET_IDLE_TIMEOUT_WHEN_STATISTICS_ARE_DISABLED
+              .toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_0_ACTION_IS_INCOMPATIBLE_WITH_THIS_REGIONS_DATA_POLICY.toLocalizedString("timeToLive"));
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractRegion_0_ACTION_IS_INCOMPATIBLE_WITH_THIS_REGIONS_DATA_POLICY
+              .toLocalizedString("timeToLive"));
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_CANNOT_SET_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_CANNOT_SET_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED
+              .toLocalizedString());
-  public void becomeLockGrantor()
-  {
+  public void becomeLockGrantor() {
-      throw new IllegalStateException(LocalizedStrings.AbstractRegion_CANNOT_SET_LOCK_GRANTOR_WHEN_SCOPE_IS_NOT_GLOBAL.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AbstractRegion_CANNOT_SET_LOCK_GRANTOR_WHEN_SCOPE_IS_NOT_GLOBAL
+              .toLocalizedString());
-  public CacheStatistics getStatistics()
-  {
+  public CacheStatistics getStatistics() {
-      throw new StatisticsDisabledException(LocalizedStrings.AbstractRegion_STATISTICS_DISABLED_FOR_REGION_0.toLocalizedString(getFullPath()));
+      throw new StatisticsDisabledException(
+          LocalizedStrings.AbstractRegion_STATISTICS_DISABLED_FOR_REGION_0
+              .toLocalizedString(getFullPath()));
-   * The logical lastModifiedTime of a region is the most recent
-   * lastModifiedTime of the region and all its subregions. This implementation
-   * trades performance of stat retrieval for performance of get/put, which is
-   * more critical.
+   * The logical lastModifiedTime of a region is the most recent lastModifiedTime of the region and
+   * all its subregions. This implementation trades performance of stat retrieval for performance of
+   * get/put, which is more critical.
-  public synchronized long getLastModifiedTime()
-  {
+  public synchronized long getLastModifiedTime() {
-    int oldLevel = LocalRegion
-        .setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
+    int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
-          LocalRegion r = (LocalRegion)subIt.next();
+          LocalRegion r = (LocalRegion) subIt.next();
-        }
-        catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException e) {
-    }
-    finally {
+    } finally {
-  protected long basicGetLastModifiedTime()
-  {
+  protected long basicGetLastModifiedTime() {
-  protected long basicGetLastAccessedTime()
-  {
+  protected long basicGetLastAccessedTime() {
-  protected void basicSetLastModifiedTime(long t)
-  {
+  protected void basicSetLastModifiedTime(long t) {
-  protected void basicSetLastAccessedTime(long t)
-  {
+  protected void basicSetLastAccessedTime(long t) {
-   * The logical lastAccessedTime of a region is the most recent
-   * lastAccessedTime of the region and all its subregions. This implementation
-   * trades performance of stat retrieval for performance of get/put, which is
-   * more critical.
+   * The logical lastAccessedTime of a region is the most recent lastAccessedTime of the region and
+   * all its subregions. This implementation trades performance of stat retrieval for performance of
+   * get/put, which is more critical.
-  public synchronized long getLastAccessedTime()
-  {
+  public synchronized long getLastAccessedTime() {
-    int oldLevel = LocalRegion
-        .setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
+    int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
-          LocalRegion r = (LocalRegion)subIt.next();
+          LocalRegion r = (LocalRegion) subIt.next();
-        }
-        catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException e) {
-    }
-    finally {
+    } finally {
-   * Update the lastAccessedTime and lastModifiedTimes to reflects those in the
-   * subregions
+   * Update the lastAccessedTime and lastModifiedTimes to reflects those in the subregions
-  protected synchronized void updateStats()
-  {
+  protected synchronized void updateStats() {
-    int oldLevel = LocalRegion
-        .setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
+    int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
-          LocalRegion r = (LocalRegion)subIt.next();
+          LocalRegion r = (LocalRegion) subIt.next();
-            mostRecentAccessed = Math.max(mostRecentAccessed, r
-                .getLastAccessedTime());
-            mostRecentModified = Math.max(mostRecentModified, r
-                .getLastModifiedTime());
+            mostRecentAccessed = Math.max(mostRecentAccessed, r.getLastAccessedTime());
+            mostRecentModified = Math.max(mostRecentModified, r.getLastModifiedTime());
-        }
-        catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException e) {
-    }
-    finally {
+    } finally {
-  protected void setLastModifiedTime(long time)
-  {
-    //checkReadiness();
+  protected void setLastModifiedTime(long time) {
+    // checkReadiness();
-  protected void setLastAccessedTime(long time, boolean hit)
-  {
+  protected void setLastAccessedTime(long time, boolean hit) {
-  public final float getHitRatio()
-  {
-    //checkReadiness();
+  public final float getHitRatio() {
+    // checkReadiness();
-    return total == 0L ? 0.0f : ((float)hits / total);
+    return total == 0L ? 0.0f : ((float) hits / total);
-  public long getHitCount()
-  {
-    //checkReadiness();
+  public long getHitCount() {
+    // checkReadiness();
-  public long getMissCount()
-  {
-    //checkReadiness();
+  public long getMissCount() {
+    // checkReadiness();
-  public void resetCounts()
-  {
-    //checkReadiness();
+  public void resetCounts() {
+    // checkReadiness();
-  protected void closeCacheCallback(CacheCallback cb)
-  {
+  protected void closeCacheCallback(CacheCallback cb) {
-      }
-      catch (RuntimeException ex) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.AbstractRegion_CACHECALLBACK_CLOSE_EXCEPTION), ex);
+      } catch (RuntimeException ex) {
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.AbstractRegion_CACHECALLBACK_CLOSE_EXCEPTION),
+            ex);
-  protected void cacheLoaderChanged(CacheLoader oldLoader)
-  {
+  protected void cacheLoaderChanged(CacheLoader oldLoader) {
-   * Called if when we go from no listeners to at least one or from at least one
-   * to no listeners
+   * Called if when we go from no listeners to at least one or from at least one to no listeners
-   * @param nowHasListener
-   *          true if we now have at least one listener; false if we now have no
-   *          listeners
+   * @param nowHasListener true if we now have at least one listener; false if we now have no
+   *        listeners
-  protected void cacheListenersChanged(boolean nowHasListener)
-  {
+  protected void cacheListenersChanged(boolean nowHasListener) {
-  protected void cacheWriterChanged(CacheWriter oldWriter)
-  {
+  protected void cacheWriterChanged(CacheWriter oldWriter) {
-  protected void timeToLiveChanged(ExpirationAttributes oldTimeToLive)
-  {
-  }
+  protected void timeToLiveChanged(ExpirationAttributes oldTimeToLive) {}
-  protected void idleTimeoutChanged(ExpirationAttributes oldIdleTimeout)
-  {
-  }
+  protected void idleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {}
-  protected void regionTimeToLiveChanged(ExpirationAttributes oldTimeToLive)
-  {
-  }
+  protected void regionTimeToLiveChanged(ExpirationAttributes oldTimeToLive) {}
-  protected void regionIdleTimeoutChanged(ExpirationAttributes oldIdleTimeout)
-  {
-  };
+  protected void regionIdleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {};
-  protected final boolean isProxy()
-  {
+  protected final boolean isProxy() {
-   * Returns true if this region has no storage and is only interested in what
-   * it contains (which is nothing)
+   * Returns true if this region has no storage and is only interested in what it contains (which is
+   * nothing)
-  protected final boolean isCacheContentProxy()
-  {
+  protected final boolean isCacheContentProxy() {
-    return isProxy()
-        && getSubscriptionAttributes().getInterestPolicy().isCacheContent();
+    return isProxy() && getSubscriptionAttributes().getInterestPolicy().isCacheContent();
-  final boolean isAllEvents()
-  {
+  final boolean isAllEvents() {
-  protected void updateEntryExpiryPossible()
-  {
-    this.entryExpiryPossible = !isProxy()
-        && (this.entryTimeToLive > 0 
-            || this.entryIdleTimeout > 0 
-            || this.customEntryIdleTimeout != null
-            || this.customEntryTimeToLive != null
-            );
+  protected void updateEntryExpiryPossible() {
+    this.entryExpiryPossible = !isProxy() && (this.entryTimeToLive > 0 || this.entryIdleTimeout > 0
+        || this.customEntryIdleTimeout != null || this.customEntryTimeToLive != null);
-  protected boolean isEntryExpiryPossible()
-  {
+  protected boolean isEntryExpiryPossible() {
-  
+
-    if(this.entryIdleTimeoutExpirationAction != null) {
+    if (this.entryIdleTimeoutExpirationAction != null) {
-    if(this.entryTimeToLiveExpirationAction != null) {
+    if (this.entryTimeToLiveExpirationAction != null) {
-  
+
-  private void setAttributes(RegionAttributes attrs,String regionName, InternalRegionArguments internalRegionArgs)
-  {
+  private void setAttributes(RegionAttributes attrs, String regionName,
+      InternalRegionArguments internalRegionArgs) {
-    
+
-    // fix bug #52033 by invoking setOffHeap now (localMaxMemory may now be the temporary placeholder for off-heap until DistributedSystem is created
+    // fix bug #52033 by invoking setOffHeap now (localMaxMemory may now be the temporary
+    // placeholder for off-heap until DistributedSystem is created
-      PartitionAttributesImpl impl = (PartitionAttributesImpl)pa;
+      PartitionAttributesImpl impl = (PartitionAttributesImpl) pa;
-    this.evictionAttributes = new EvictionAttributesImpl((EvictionAttributesImpl)attrs
-        .getEvictionAttributes());
-    if (attrs.getPartitionAttributes() != null
-        && this.evictionAttributes != null
+    this.evictionAttributes =
+        new EvictionAttributesImpl((EvictionAttributesImpl) attrs.getEvictionAttributes());
+    if (attrs.getPartitionAttributes() != null && this.evictionAttributes != null
-        && attrs.getPartitionAttributes().getLocalMaxMemory() != 0
-        && this.evictionAttributes.getMaximum() != attrs
-            .getPartitionAttributes().getLocalMaxMemory()) {
+        && attrs.getPartitionAttributes().getLocalMaxMemory() != 0 && this.evictionAttributes
+            .getMaximum() != attrs.getPartitionAttributes().getLocalMaxMemory()) {
-          new Object[] { regionName,this.evictionAttributes.getMaximum(),
-              attrs.getPartitionAttributes().getLocalMaxMemory() }));
-      this.evictionAttributes.setMaximum(attrs.getPartitionAttributes()
-          .getLocalMaxMemory());
+          new Object[] {regionName, this.evictionAttributes.getMaximum(),
+              attrs.getPartitionAttributes().getLocalMaxMemory()}));
+      this.evictionAttributes.setMaximum(attrs.getPartitionAttributes().getLocalMaxMemory());
-    //final boolean isNotPartitionedRegion = !(attrs.getPartitionAttributes() != null || attrs
-    //            .getDataPolicy().withPartitioning());
-    
-    //if (isNotPartitionedRegion && this.evictionAttributes != null
-    if (this.evictionAttributes != null
-        && !this.evictionAttributes.getAlgorithm().isNone()) {
-      this.setEvictionController(this.evictionAttributes
-          .createEvictionController(this, attrs.getOffHeap()));
+    // final boolean isNotPartitionedRegion = !(attrs.getPartitionAttributes() != null || attrs
+    // .getDataPolicy().withPartitioning());
+
+    // if (isNotPartitionedRegion && this.evictionAttributes != null
+    if (this.evictionAttributes != null && !this.evictionAttributes.getAlgorithm().isNone()) {
+      this.setEvictionController(
+          this.evictionAttributes.createEvictionController(this, attrs.getOffHeap()));
-    this.regionTimeToLiveExpirationAction = attrs.getRegionTimeToLive()
-        .getAction();
+    this.regionTimeToLiveExpirationAction = attrs.getRegionTimeToLive().getAction();
-    this.regionIdleTimeoutExpirationAction = attrs.getRegionIdleTimeout()
-        .getAction();
+    this.regionIdleTimeoutExpirationAction = attrs.getRegionIdleTimeout().getAction();
-    this.entryTimeToLiveExpirationAction = attrs.getEntryTimeToLive()
-        .getAction();
+    this.entryTimeToLiveExpirationAction = attrs.getEntryTimeToLive().getAction();
-    this.entryIdleTimeoutExpirationAction = attrs.getEntryIdleTimeout()
-        .getAction();
+    this.entryIdleTimeoutExpirationAction = attrs.getEntryIdleTimeout().getAction();
-    this.concurrencyChecksEnabled =  attrs.getConcurrencyChecksEnabled() && supportsConcurrencyChecks();
+    this.concurrencyChecksEnabled =
+        attrs.getConcurrencyChecksEnabled() && supportsConcurrencyChecks();
-        throw new IllegalStateException(LocalizedStrings.
-            AbstractRegion_THE_CONNECTION_POOL_0_HAS_NOT_BEEN_CREATED.toLocalizedString(this.poolName));
+        throw new IllegalStateException(
+            LocalizedStrings.AbstractRegion_THE_CONNECTION_POOL_0_HAS_NOT_BEEN_CREATED
+                .toLocalizedString(this.poolName));
-        throw new IllegalStateException("Region must have empty data-policy "
-            + "when multiuser-authentication is true.");
+        throw new IllegalStateException(
+            "Region must have empty data-policy " + "when multiuser-authentication is true.");
-    
+
-    if(!attrs.getConcurrencyChecksEnabled() 
-        && attrs.getDataPolicy().withPersistence()
+    if (!attrs.getConcurrencyChecksEnabled() && attrs.getDataPolicy().withPersistence()
-      throw new IllegalStateException(LocalizedStrings.AttributesFactory_CONCURRENCY_CHECKS_MUST_BE_ENABLED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AttributesFactory_CONCURRENCY_CHECKS_MUST_BE_ENABLED
+              .toLocalizedString());
-  
+
-   * Returns the pool this region is using or null if it does not have one
-   * or the pool does not exist.
+   * Returns the pool this region is using or null if it does not have one or the pool does not
+   * exist.
+   * 
-      result = (PoolImpl)PoolManager.find(getPoolName());
+      result = (PoolImpl) PoolManager.find(getPoolName());
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-  public Object selectValue(String predicate) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+  public Object selectValue(String predicate) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-      throw new FunctionDomainException(LocalizedStrings.AbstractRegion_SELECTVALUE_EXPECTS_RESULTS_OF_SIZE_1_BUT_FOUND_RESULTS_OF_SIZE_0.toLocalizedString(Integer.valueOf(result.size())));
+      throw new FunctionDomainException(
+          LocalizedStrings.AbstractRegion_SELECTVALUE_EXPECTS_RESULTS_OF_SIZE_1_BUT_FOUND_RESULTS_OF_SIZE_0
+              .toLocalizedString(Integer.valueOf(result.size())));
-  public Set entrySet(boolean recursive)
-  {
+  public Set entrySet(boolean recursive) {
-  public EvictionAttributes getEvictionAttributes()
-  {
+  public EvictionAttributes getEvictionAttributes() {
-  public EvictionAttributesMutator getEvictionAttributesMutator()
-  {
+  public EvictionAttributesMutator getEvictionAttributesMutator() {
-  public void setEvictionController(LRUAlgorithm evictionController)
-  {
+  public void setEvictionController(LRUAlgorithm evictionController) {
-  public LRUAlgorithm getEvictionController()
-  {
+  public LRUAlgorithm getEvictionController() {
-   * Throws RegionAccessException if required roles are missing and the
-   * LossAction is NO_ACCESS
+   * Throws RegionAccessException if required roles are missing and the LossAction is NO_ACCESS
-   * @throws RegionAccessException
-   *           if required roles are missing and the LossAction is NO_ACCESS
+   * @throws RegionAccessException if required roles are missing and the LossAction is NO_ACCESS
-  protected void checkForNoAccess()
-  {
-  }
+  protected void checkForNoAccess() {}
-   * Throws RegionAccessException is required roles are missing and the
-   * LossAction is either NO_ACCESS or LIMITED_ACCESS.
+   * Throws RegionAccessException is required roles are missing and the LossAction is either
+   * NO_ACCESS or LIMITED_ACCESS.
-   * @throws RegionAccessException
-   *           if required roles are missing and the LossAction is either
-   *           NO_ACCESS or LIMITED_ACCESS
+   * @throws RegionAccessException if required roles are missing and the LossAction is either
+   *         NO_ACCESS or LIMITED_ACCESS
-  protected void checkForLimitedOrNoAccess()
-  {
-  }
+  protected void checkForLimitedOrNoAccess() {}
-   * Makes sure that the data was distributed to every required role. If it was
-   * not it either queues the data for later delivery or it throws an exception.
+   * Makes sure that the data was distributed to every required role. If it was not it either queues
+   * the data for later delivery or it throws an exception.
-   * @param data
-   *          the data that needs to be reliably distributed
-   * @param successfulRecipients
-   *          the successful recipients
-   * @throws RoleException
-   *           if a required role was not sent the message and the LossAction is
-   *           either NO_ACCESS or LIMITED_ACCESS.
+   * @param data the data that needs to be reliably distributed
+   * @param successfulRecipients the successful recipients
+   * @throws RoleException if a required role was not sent the message and the LossAction is either
+   *         NO_ACCESS or LIMITED_ACCESS.
-      Set successfulRecipients)
-  {
+      Set successfulRecipients) {
-  public boolean requiresReliabilityCheck()
-  {
+  public boolean requiresReliabilityCheck() {
-   * Returns the serial number which identifies the static order in which this
-   * region was created in relation to other regions or other instances of
-   * this region during the life of this JVM.
+   * Returns the serial number which identifies the static order in which this region was created in
+   * relation to other regions or other instances of this region during the life of this JVM.
-  public /*final*/ GemFireCacheImpl getCache() {
+  public /* final */ GemFireCacheImpl getCache() {
-  
+
-  
+
-    DataSerializer.writeRegion(this, out); 
+    DataSerializer.writeRegion(this, out);
-  
-  public void setCloningEnabled(boolean cloningEnable){
+
+  public void setCloningEnabled(boolean cloningEnable) {
-  
+
-  
+
-  
+
-  
+
-  * @since GemFire 8.1
-  */
+   * @since GemFire 8.1
+   */

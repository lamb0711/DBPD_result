GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

-import org.apache.geode.redis.internal.RegionProvider;
-  private RegionProvider regionProvider;
-  public static void register(RegionProvider regionProvider) {
+  public static void register() {
-    FunctionService.registerFunction(new CommandFunction(stripedExecutor, regionProvider));
+    FunctionService.registerFunction(new CommandFunction(stripedExecutor));
-  public CommandFunction(StripedExecutor stripedExecutor,
-      RegionProvider regionProvider) {
+  public CommandFunction(StripedExecutor stripedExecutor) {
-    this.regionProvider = regionProvider;
+      case DEL:
+        callable = () -> new RedisKeyInRegion(localRegion).del(key);
+        break;
+      case EXISTS:
+        callable = () -> new RedisKeyInRegion(localRegion).exists(key);
+        break;
+      case TYPE:
+        callable = () -> new RedisKeyInRegion(localRegion).type(key);
+        break;
+      case PEXPIREAT: {
+        long timestamp = (long) args[1];
+        callable =
+            () -> new RedisKeyInRegion(localRegion).pexpireat(key, timestamp);
+        break;
+      }
+      case PERSIST:
+        callable = () -> new RedisKeyInRegion(localRegion).persist(key);
+        break;
+      case PTTL:
+        callable = () -> new RedisKeyInRegion(localRegion).pttl(key);
+        break;
+      case GETSET: {
+        ByteArrayWrapper value = (ByteArrayWrapper) args[1];
+        callable = () -> new RedisStringInRegion(localRegion).getset(key, value);
+        break;
+      }
+      case INCR:
+        callable = () -> new RedisStringInRegion(localRegion).incr(key);
+        break;
+      case DECR:
+        callable = () -> new RedisStringInRegion(localRegion).decr(key);
+        break;
+      case INCRBY: {
+        long increment = (long) args[1];
+        callable = () -> new RedisStringInRegion(localRegion).incrby(key, increment);
+        break;
+      }
+      case DECRBY: {
+        long decrement = (long) args[1];
+        callable = () -> new RedisStringInRegion(localRegion).decrby(key, decrement);
+        break;
+      }
-      case DEL:
-        callable = () -> new RedisKeyInRegion(localRegion, regionProvider).del(key);
-        break;
-      case EXISTS:
-        callable = () -> new RedisKeyInRegion(localRegion, regionProvider).exists(key);
-        break;

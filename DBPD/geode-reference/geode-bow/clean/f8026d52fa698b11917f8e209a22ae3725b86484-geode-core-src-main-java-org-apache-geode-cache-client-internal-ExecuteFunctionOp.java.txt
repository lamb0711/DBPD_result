GEODE-6588: Cleanup generics and static analyzer warnings.

+
-      AbstractOp reexecOp = null;
+      AbstractOp reexecOp;
-      AbstractOp reexecOp = null;
+      AbstractOp reexecOp;
-  public static void reexecute(ExecutablePool pool, Function function,
+  private static void reexecute(ExecutablePool pool, Function function,
-    boolean reexecute = true;
+    boolean reexecute;
-  public static void reexecute(ExecutablePool pool, String functionId,
+  private static void reexecute(ExecutablePool pool, String functionId,
-    boolean reexecute = true;
+    boolean reexecute;
-  static List constructAndGetFunctionTasks(final PoolImpl pool, final Function function,
+  private static List constructAndGetFunctionTasks(final PoolImpl pool, final Function function,
-    final List<SingleHopOperationCallable> tasks = new ArrayList<SingleHopOperationCallable>();
+    final List<SingleHopOperationCallable> tasks = new ArrayList<>();
-  static List constructAndGetFunctionTasks(final PoolImpl pool, final String functionId,
+  private static List constructAndGetFunctionTasks(final PoolImpl pool, final String functionId,
-    final List<SingleHopOperationCallable> tasks = new ArrayList<SingleHopOperationCallable>();
+    final List<SingleHopOperationCallable> tasks = new ArrayList<>();
-    public ExecuteFunctionOpImpl(Function function, Object args,
-        MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
-        boolean isFnSerializationReqd, byte isReexecute, String[] groups, boolean allMembers,
-        boolean ignoreFailedMembers) {
+    ExecuteFunctionOpImpl(Function function, Object args, MemberMappedArgument memberMappedArg,
+        byte hasResult, ResultCollector rc, boolean isFnSerializationReqd, byte isReexecute,
+        String[] groups, boolean allMembers, boolean ignoreFailedMembers) {
-      this.flags = getByteArrayForFlags(allMembers, ignoreFailedMembers);
-      getMessage().addBytesPart(this.flags);
+      flags = getByteArrayForFlags(allMembers, ignoreFailedMembers);
+      getMessage().addBytesPart(flags);
-      this.functionId = function.getId();
+      functionId = function.getId();
-    public ExecuteFunctionOpImpl(String functionId, Object args2,
+    ExecuteFunctionOpImpl(String functionId, Object args2,
-        boolean isFnSerializationReqd, boolean isHA, boolean optimizeForWrite, byte isReexecute,
+        boolean isFnSerializationReqd, boolean isHA, boolean optimizeForWrite,
+        byte isReexecute,
-      byte fnState = AbstractExecution.getFunctionState(isHA, hasResult == (byte) 1 ? true : false,
+      byte fnState = AbstractExecution.getFunctionState(isHA, hasResult == (byte) 1,
-      this.flags = getByteArrayForFlags(allMembers, ignoreFailedMembers);
-      getMessage().addBytesPart(this.flags);
+      flags = getByteArrayForFlags(allMembers, ignoreFailedMembers);
+      getMessage().addBytesPart(flags);
-      this.args = args2;
+      args = args2;
-    public ExecuteFunctionOpImpl(ExecuteFunctionOpImpl op, byte isReexecute) {
+    ExecuteFunctionOpImpl(ExecuteFunctionOpImpl op, byte isReexecute) {
-      this.resultCollector = op.resultCollector;
-      this.function = op.function;
-      this.functionId = op.functionId;
-      this.hasResult = op.hasResult;
-      this.args = op.args;
-      this.memberMappedArg = op.memberMappedArg;
-      this.isFnSerializationReqd = op.isFnSerializationReqd;
-      this.groups = op.groups;
-      this.flags = op.flags;
+      resultCollector = op.resultCollector;
+      function = op.function;
+      functionId = op.functionId;
+      hasResult = op.hasResult;
+      args = op.args;
+      memberMappedArg = op.memberMappedArg;
+      isFnSerializationReqd = op.isFnSerializationReqd;
+      groups = op.groups;
+      flags = op.flags;
-      addBytes(isReexecute, this.hasResult);
-      if (this.isFnSerializationReqd) {
+      addBytes(isReexecute, hasResult);
+      if (isFnSerializationReqd) {
-      getMessage().addObjPart(this.args);
-      getMessage().addObjPart(this.memberMappedArg);
-      getMessage().addObjPart(this.groups);
-      getMessage().addBytesPart(this.flags);
+      getMessage().addObjPart(args);
+      getMessage().addObjPart(memberMappedArg);
+      getMessage().addObjPart(groups);
+      getMessage().addBytesPart(flags);
-      if (this.flags != null && this.flags.length > 1) {
-        if (this.flags[IGNORE_FAILED_MEMBERS_INDEX] == 1) {
+      if (flags != null && flags.length > 1) {
+        if (flags[IGNORE_FAILED_MEMBERS_INDEX] == 1) {
-                  this.resultCollector.addResult(memberID, cause);
-                  FunctionStats.getFunctionStats(this.functionId).incResultsReceived();
-                  continue;
+                  resultCollector.addResult(memberID, cause);
+                  FunctionStats.getFunctionStats(functionId).incResultsReceived();
-                FunctionStats.getFunctionStats(this.functionId).incResultsReceived();
+                FunctionStats.getFunctionStats(functionId).incResultsReceived();
-              FunctionException ex = ((FunctionException) obj);
-              throw ex;
+              throw ((FunctionException) obj);
-              String s =
-                  ": While performing a remote execute Function" + ((Throwable) obj).getMessage();
-              throw new ServerOperationException(s, (Throwable) obj);
+              final Throwable t = (Throwable) obj;
+              throw new ServerOperationException(
+                  ": While performing a remote execute Function" + t.getMessage(), t);
-                Integer.valueOf(executeFunctionResponseMsg.getMessageType())));
+                executeFunctionResponseMsg.getMessageType()));
-
-  public static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",
-      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();

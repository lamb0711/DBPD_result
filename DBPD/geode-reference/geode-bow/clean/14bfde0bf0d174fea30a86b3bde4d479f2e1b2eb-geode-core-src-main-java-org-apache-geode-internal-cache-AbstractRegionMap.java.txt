Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-          LocalizedMessage.create(LocalizedStrings.AbstractRegionMap_ATTEMPT_TO_REMOVE_TOMBSTONE),
+          "Internal product error: attempt to directly remove a versioned tombstone from region entry map",
-          LocalizedMessage.create(LocalizedStrings.AbstractRegionMap_ATTEMPT_TO_REMOVE_TOMBSTONE),
+          "Internal product error: attempt to directly remove a versioned tombstone from region entry map",
+    final boolean locked = owner.lockWhenRegionIsInitializing();
+    } finally {
+      if (locked) {
+        owner.unlockWhenRegionIsInitializing();
+      }
+
+    // Fix for Bug #44431. We do NOT want to update the region and wait
+    // later for index INIT as region.clear() can cause inconsistency if
+    // happened in parallel as it also does index INIT.
+    IndexManager oqlIndexManager = owner.getIndexManager();
+    if (oqlIndexManager != null) {
+      oqlIndexManager.waitForIndexInit();
+    }
+    lockForCacheModification(owner, event);
+    final boolean locked = owner.lockWhenRegionIsInitializing();
-      // Fix for Bug #44431. We do NOT want to update the region and wait
-      // later for index INIT as region.clear() can cause inconsistency if
-      // happened in parallel as it also does index INIT.
-      IndexManager oqlIndexManager = owner.getIndexManager();
-      if (oqlIndexManager != null) {
-        oqlIndexManager.waitForIndexInit();
-      }
-      lockForCacheModification(owner, event);
+      if (locked) {
+        owner.unlockWhenRegionIsInitializing();
+      }
+    final boolean locked = owner.lockWhenRegionIsInitializing();
+      if (locked) {
+        owner.unlockWhenRegionIsInitializing();
+      }
+    final boolean locked = owner.lockWhenRegionIsInitializing();
+      if (locked) {
+        owner.unlockWhenRegionIsInitializing();
+      }
+

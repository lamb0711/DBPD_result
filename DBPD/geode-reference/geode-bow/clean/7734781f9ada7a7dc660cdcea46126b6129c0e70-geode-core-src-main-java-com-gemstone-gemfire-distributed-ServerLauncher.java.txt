GEODE-1025: Replacing direct dependency on spring data gemfire with an SPI

Removing the direct use of Spring Data Gemfire from within the geode
code. Replacing it with a SPI that allows the user to override the
behavior of ServerLauncher.start with their own implementation that
creates a cache.

Spring Data Gemfire can provide an implementation that bootstraps the
cache using spring, if spring-xml-location is specified.

Users should implement ServerLauncherCacheProvider. The cache will be
created by the first provider that returns a non null cache. If no
providers create a cache, the cache will be created by the
ServerLauncher itself.

It would be nice to move the spring-xml-location parameter itself into
the interface, but this is hard to do because gfsh determines the
parameters to start-server by looking at the arguments in the command
class. So I left spring-xml-location alone.

+import java.util.ServiceLoader;
-import com.gemstone.gemfire.distributed.AbstractLauncher.Status;
+import com.gemstone.gemfire.distributed.internal.DefaultServerLauncherCacheProvider;
-import com.gemstone.gemfire.internal.util.CollectionUtils;
-import org.springframework.data.gemfire.support.SpringContextBootstrappingInitializer;
-
-public final class ServerLauncher extends AbstractLauncher<String> {
+public class ServerLauncher extends AbstractLauncher<String> {
+  private static final ServerLauncherCacheProvider DEFAULT_CACHE_PROVIDER = new DefaultServerLauncherCacheProvider();
+
-  final CacheConfig getCacheConfig() {
+  public final CacheConfig getCacheConfig() {
-          this.cache = (isSpringXmlLocationSpecified() ? startWithSpring() : startWithGemFireApi(gemfireProperties));
+          this.cache = createCache(gemfireProperties);
-  private Cache startWithSpring() {
-    System.setProperty(DistributionConfig.GEMFIRE_PREFIX + DistributionConfig.NAME_NAME, getMemberName());
-
-    new SpringContextBootstrappingInitializer().init(CollectionUtils.createProperties(Collections.singletonMap(
-      SpringContextBootstrappingInitializer.CONTEXT_CONFIG_LOCATIONS_PARAMETER, getSpringXmlLocation())));
-
-    return SpringContextBootstrappingInitializer.getApplicationContext().getBean(Cache.class);
-  }
-
-  private Cache startWithGemFireApi(final Properties gemfireProperties ) {
-    final CacheConfig cacheConfig = getCacheConfig();
-    final CacheFactory cacheFactory = new CacheFactory(gemfireProperties);
-
-    if (cacheConfig.pdxPersistentUserSet) {
-      cacheFactory.setPdxPersistent(cacheConfig.isPdxPersistent());
+  private Cache createCache(Properties gemfireProperties) {
+    ServiceLoader<ServerLauncherCacheProvider> loader = ServiceLoader.load(ServerLauncherCacheProvider.class);
+    for(ServerLauncherCacheProvider provider : loader) {
+      Cache cache = provider.createCache(gemfireProperties, this);
+      if(cache != null) {
+        return cache;
+      }
-
-    if (cacheConfig.pdxDiskStoreUserSet) {
-      cacheFactory.setPdxDiskStore(cacheConfig.getPdxDiskStore());
-    }
-
-    if (cacheConfig.pdxIgnoreUnreadFieldsUserSet) {
-      cacheFactory.setPdxIgnoreUnreadFields(cacheConfig.getPdxIgnoreUnreadFields());
-    }
-
-    if (cacheConfig.pdxReadSerializedUserSet) {
-      cacheFactory.setPdxReadSerialized(cacheConfig.isPdxReadSerialized());
-    }
-
-    if (cacheConfig.pdxSerializerUserSet) {
-      cacheFactory.setPdxSerializer(cacheConfig.getPdxSerializer());
-    }
-
-    return cacheFactory.create();
+    
+    return DEFAULT_CACHE_PROVIDER.createCache(gemfireProperties, this);

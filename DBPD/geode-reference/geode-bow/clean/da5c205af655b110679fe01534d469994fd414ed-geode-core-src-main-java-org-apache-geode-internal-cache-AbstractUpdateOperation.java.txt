GEODE-7643: Gateway unprocessedTokensMap appears to grow without bounds with replicated regions and peer accessors (#4447)

* Allow LocalRegion.virtualPut to throw ConcurrentCacheModificationException

Added throwsConcurrentModifiaction boolean argument to LocalRegion.virtualPut() to determine if the exception should be thrown
Added invokeCallbacks boolean argument to LocalRegion.virtualPut() to determine if bridge clients and gateway senders should be notified of the event
Fixed issue with inheriting new virtualPut implementations
Added DUnit test to confirm fix

Co-authored-by: Benjamin Ross <bross@pivotal.io>
Co-authored-by: Donal Evans <doevans@pivotal.io>

+      boolean invokeCallbacks = true;
+
-          if (rgn.basicUpdate(ev, true /* ifNew */, false/* ifOld */, lastMod,
-              overwriteDestroyed)) {
-            rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
-            // we did a create, or replayed a create event
-            doUpdate = false;
-            updated = true;
-          } else { // already exists. If it was blocked by the DESTROYED token, then
-            // do no update.
+          try {
+            boolean firstBasicUpdateSuccess =
+                rgn.basicUpdate(ev, true, false, lastMod, overwriteDestroyed, true, true);
+            if (firstBasicUpdateSuccess) {
+              rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
+              // we did a create, or replayed a create event
+              doUpdate = false;
+              updated = true;
+            } else {
+              // already exists. If it was blocked by the DESTROYED token, then
+              // do no update.
+              doUpdate = checkIfToUpdateAfterCreateFailed(rgn, ev);
+            }
+          } catch (ConcurrentCacheModificationException ex) {
+            invokeCallbacks = false;
-            if (rgn.basicUpdate(ev, false/* ifNew */, true/* ifOld */, lastMod,
-                overwriteDestroyed)) {
+            boolean secondBasicUpdateSuccess;
+            try {
+              secondBasicUpdateSuccess =
+                  rgn.basicUpdate(ev, false, true, lastMod, overwriteDestroyed,
+                      invokeCallbacks, true);
+            } catch (ConcurrentCacheModificationException ex) {
+              secondBasicUpdateSuccess = false;
+              invokeCallbacks = false;
+            }
+            if (secondBasicUpdateSuccess) {
-            } else { // key not here or blocked by DESTROYED token
+            } else {
+              // key not here, blocked by DESTROYED token or ConcurrentCacheModificationException
+              // thrown during second update attempt
-                overwriteDestroyed = true;
-                rgn.basicUpdate(ev, false /* ifNew */, false/* ifOld */, lastMod,
-                    overwriteDestroyed);
-                rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
-                updated = true;
+                boolean thirdBasicUpdateSuccess =
+                    rgn.basicUpdate(ev, false, false, lastMod, true, invokeCallbacks, false);
+                if (thirdBasicUpdateSuccess) {
+                  rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
+                  updated = true;
+                }

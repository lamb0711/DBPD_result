 GEODE-4240: Fix testCreateBuckets on windows (#3660)

* Move gemfire config to properties file
* Reformat code to improve readability
* Add directory option to ProcessWrapper to inject TemporaryFolder

The -J-Dgemfire.locator="" with quotes was breaking the next argument
on windows. Moving the config to properties file works around this.

+import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import java.io.OutputStream;
-import java.util.concurrent.TimeUnit;
- * Wraps spawned {@link java.lang.Process} to capture output and provide interaction with the
- * process.
+ * Wraps spawned {@link Process} to capture output and provide interaction with the process.
+  private final File directory;
-  private boolean starting = false;
-  private boolean started = false;
-  private boolean stopped = false;
-  private boolean interrupted = false;
+  private boolean starting;
+  private boolean started;
+  private boolean stopped;
+  private boolean interrupted;
-      final long timeoutMillis) {
+      final long timeoutMillis, final File directory) {
+    this.directory = directory;
-    this.lineBuffer = new LinkedBlockingQueue<>();
-    this.allLines = Collections.synchronizedList(new ArrayList<>());
+    lineBuffer = new LinkedBlockingQueue<>();
+    allLines = Collections.synchronizedList(new ArrayList<>());
-    this.lineBuffer.offer(line);
-    this.allLines.add(line);
+    allLines.add(line);
+    lineBuffer.offer(line);
-    synchronized (this.exitValue) {
+    synchronized (exitValue) {
-    synchronized (this.exitValue) {
+    synchronized (exitValue) {
-      synchronized (this.exitValue) {
-        done = (this.process != null || this.processException != null)
-            && (this.started || this.exitValue.get() > -1 || this.interrupted);
+      synchronized (exitValue) {
+        done = (process != null || processException != null)
+            && (started || exitValue.get() > -1 || interrupted);
-    synchronized (this.exitValue) {
-      if (this.interrupted) { // TODO: do we want to do this?
+    synchronized (exitValue) {
+      if (interrupted) {
-      return this.exitValue.get() == -1 && this.started && !this.stopped && !this.interrupted
-          && this.processThread.isAlive();
+      return exitValue.get() == -1 && started && !stopped && !interrupted
+          && processThread.isAlive();
-    if (this.process != null) {
-      this.process.destroy();
+    if (process != null) {
+      process.destroy();
-    synchronized (this.exitValue) {
+    synchronized (exitValue) {
-      return this.exitValue.get();
+      return exitValue.get();
-    final Iterator<String> iterator = this.allLines.iterator();
+    final Iterator<String> iterator = allLines.iterator();
-      sb.append(iterator.next() + "\n");
+      sb.append(iterator.next() + System.lineSeparator());
-    final PrintStream ps = new PrintStream(this.process.getOutputStream());
+    final PrintStream ps = new PrintStream(process.getOutputStream());
-      final String line = lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
+      final String line = lineBuffer.poll(timeoutMillis, MILLISECONDS);
-            + line + "\". Output: " + this.allLines);
+            + line + "\". Output: " + allLines);
-    final Pattern pattern = Pattern.compile(patternString);
+    final Pattern pattern = Pattern.compile(patternString);
-      final String line = this.lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
+      final String line = lineBuffer.poll(timeoutMillis, MILLISECONDS);
-      } else {
-        logger.debug(
-            "ProcessWrapper:waitForOutputToMatch Did not match pattern \"{}\" against output \"{}\"",
-            patternString, line);
+      logger.debug(
+          "ProcessWrapper:waitForOutputToMatch Did not match pattern \"{}\" against output \"{}\"",
+          patternString, line);
-    return execute(null, new File(System.getProperty("user.dir")));
+    return execute(null, directory);
-    return execute(properties, new File(System.getProperty("user.dir")));
+    return execute(properties, directory);
-    synchronized (this.exitValue) {
-      if (this.starting) {
+    synchronized (exitValue) {
+      if (starting) {
-      this.starting = true;
-      this.processThread = new Thread(new Runnable() {
-        @Override
-        public void run() {
-          start(properties, workingDirectory);
-        }
-      }, "ProcessWrapper Process Thread");
+      starting = true;
+      processThread =
+          new Thread(() -> start(properties, workingDirectory), "ProcessWrapper Process Thread");
-    this.processThread.start();
+    processThread.start();
-    synchronized (this.exitValue) {
-      if (this.processException != null) {
-        logger.error("ProcessWrapper:execute failed with " + this.processException);
-        this.processException.printStackTrace();
+    synchronized (exitValue) {
+      if (processException != null) {
+        logger.error("ProcessWrapper:execute failed with " + processException);
+        processException.printStackTrace();
-    if (this.useMainLauncher) {
-      sendInput(); // to trigger MainLauncher delegation to inner main
+    if (useMainLauncher) {
+      // to trigger MainLauncher delegation to inner main
+      sendInput();
-    final List<String> jvmArgumentsList = new ArrayList<String>();
+    final List<String> jvmArgumentsList = new ArrayList<>();
-    if (this.headless) {
+    if (headless) {
-    if (this.jvmArguments != null) {
-      for (String jvmArgument : this.jvmArguments) {
-        jvmArgumentsList.add(jvmArgument);
-      }
+    if (jvmArguments != null) {
+      Collections.addAll(jvmArgumentsList, jvmArguments);
-      synchronized (this.exitValue) {
+      synchronized (exitValue) {
-        this.process = new ProcessBuilder(command).directory(workingDirectory).start();
+        process = new ProcessBuilder(command).directory(workingDirectory).start();
-            this.process.getInputStream(), this);
+            process.getInputStream(), this);
-            this.process.getErrorStream(), this);
+            process.getErrorStream(), this);
-        this.stdout = stdOut;
-        this.stderr = stdErr;
-        this.outputReader = new ProcessOutputReader(this.process, stdOut, stdErr);
-        this.started = true;
+        stdout = stdOut;
+        stderr = stdErr;
+        outputReader = new ProcessOutputReader(process, stdOut, stdErr);
+        started = true;
-      this.outputReader.start();
-      this.outputReader.waitFor(PROCESS_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      boolean exited = process.waitFor(PROCESS_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      outputReader.start();
+      outputReader.waitFor(PROCESS_TIMEOUT_MILLIS, MILLISECONDS);
+      boolean exited = process.waitFor(PROCESS_TIMEOUT_MILLIS, MILLISECONDS);
-      synchronized (this.exitValue) {
-        this.exitValue.set(exited ? process.exitValue() : 0);
-        this.stopped = exited;
+      synchronized (exitValue) {
+        exitValue.set(exited ? process.exitValue() : 0);
+        stopped = exited;
-      synchronized (this.exitValue) {
-        this.interrupted = true;
-        this.processException = e;
+      synchronized (exitValue) {
+        interrupted = true;
+        processException = e;
-      synchronized (this.exitValue) {
-        this.processException = t;
+      synchronized (exitValue) {
+        processException = t;
-    final int bits = Integer.getInteger("sun.arch.data.model", 0).intValue();
-    if (bits == 64 && !(System.getProperty("os.name").toLowerCase().contains("windows"))
+    final int bits = Integer.getInteger("sun.arch.data.model", 0);
+    if (bits == 64 && !System.getProperty("os.name").toLowerCase().contains("windows")
-    if (this.useMainLauncher) {
+    if (useMainLauncher) {
-    final String[] command = argumentList.toArray(new String[argumentList.size()]);
-    return command;
+    return argumentList.toArray(new String[0]);
-    synchronized (this.exitValue) {
-      if (!this.starting) {
+    synchronized (exitValue) {
+      if (!starting) {
-    synchronized (this.exitValue) {
-      if (!this.stopped) {
+    synchronized (exitValue) {
+      if (!stopped) {
-    if (this.processException != null) {
-      throw new RuntimeException("Failed to launch process", this.processException);
+    if (processException != null) {
+      throw new RuntimeException("Failed to launch process", processException);
-    synchronized (this.exitValue) {
-      return this.processThread;
+    synchronized (exitValue) {
+      return processThread;
-    return this.process;
+    return process;
-    for (String jar : entries) {
-      Path absPath = Paths.get(jar).toAbsolutePath();
-      Path relPath = locationPath.relativize(absPath);
-      if (absPath.toFile().isDirectory()) {
-        manifestEntries.add(relPath.toString() + "/");
+    for (String jarEntry : entries) {
+      Path jarEntryAbsolutePath = Paths.get(jarEntry).toAbsolutePath();
+      Path jarEntryRelativizedPath = locationPath.relativize(jarEntryAbsolutePath);
+      if (jarEntryAbsolutePath.toFile().isDirectory()) {
+        manifestEntries.add(jarEntryRelativizedPath + File.separator);
-        manifestEntries.add(relPath.toString());
+        manifestEntries.add(jarEntryRelativizedPath.toString());
-    Attributes global = manifest.getMainAttributes();
-    global.put(Attributes.Name.MANIFEST_VERSION, "1.0.0");
-    global.put(new Attributes.Name("Class-Path"), String.join(" ", manifestEntries));
+    Attributes attributes = manifest.getMainAttributes();
+    attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0.0");
+    attributes.put(new Attributes.Name("Class-Path"), String.join(" ", manifestEntries));
-    Path manifestJar = Paths.get(location, "manifest-" + uuid + ".jar");
-    JarOutputStream jos = null;
-    try {
-      File jarFile = manifestJar.toFile();
-      jarFile.deleteOnExit();
-      OutputStream os = new FileOutputStream(jarFile);
-      jos = new JarOutputStream(os, manifest);
-    } catch (IOException e) {
-      e.printStackTrace();
-    } finally {
-      if (jos != null) {
-        jos.close();
-      }
+    Path manifestJarPath = Paths.get(location, "manifest-" + uuid + ".jar");
+    File manifestJarFile = manifestJarPath.toFile();
+    manifestJarFile.deleteOnExit();
+
+    try (JarOutputStream jos =
+        new JarOutputStream(new FileOutputStream(manifestJarFile), manifest)) {
+      // the above try-with-resource writes the manifest to the manifestJarFile
-    return manifestJar.toString();
+    return manifestJarPath.toFile().getAbsolutePath();
-    private String[] jvmArguments = null;
+
+    private String[] jvmArguments;
-    private String[] mainArguments = null;
+    private String[] mainArguments;
-    private boolean inline = false;
-
-    public Builder() {
-      // nothing
-    }
+    private boolean inline;
+    private File directory = new File(System.getProperty("user.dir"));
+    public Builder directory(final File directory) {
+      this.directory = directory;
+      return this;
+    }
+
-          timeoutMillis);
+          timeoutMillis, directory);

Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-   * The underlying map (may hold reference to a Region or a HashMap) for this
-   * HARegionQueue instance (and also shared by all the HARegionQueue instances
-   * associated with the same CacheClientNotifier).
+   * The underlying map (may hold reference to a Region or a ConcurrentHashMap)
+   * for this HARegionQueue instance (and also shared by all the HARegionQueue
+   * instances associated with the same CacheClientNotifier).
-   * Adds an object at the queue's tail. The implemetation supports concurrent
+   * Adds an object at the queue's tail. The implementation supports concurrent
-   * 
+   * @return boolean 
-  public void put(Object object) throws CacheException, InterruptedException {
+  public boolean put(Object object) throws CacheException, InterruptedException {
+    
+    //basicPut() invokes dace.putObject() to put onto HARegionQueue
+    //However, dace.putObject could return true even though 
+    //the event is not put onto the HARegionQueue due to eliding events etc. 
+    //So it is not reliable to be used whether offheap ref ownership is passed over to 
+    //the queue (if and when HARegionQueue uses offheap). The probable 
+    //solution could be that to let dace.putObject() to increase offheap REF count
+    //when it puts the event onto the region queue. Also always release (dec)
+    //the offheap REF count from the caller.
+    return true;
-    // TODO : Dinesh : verify whether (batchSize * 2) is needed or not
-    List batch = new ArrayList(batchSize * 2);
+    List batch = new ArrayList(limit);
-          event = (Conflatable)this.haContainer.get(event);
+          HAEventWrapper hw = (HAEventWrapper) event;
+          if (hw.getClientUpdateMessage() != null) {
+            event = hw.getClientUpdateMessage();
+          } else {
+            event = (Conflatable) this.haContainer.get(event);
+          }
+          
+          
-              CqNameToOp cqNames = ((ClientUpdateMessage)event).getClientCq(clientProxyID);
+              CqNameToOp cqNames = ((ClientUpdateMessage) event).getClientCq(clientProxyID);
-                for (String cqName: cqNames.getNames()) {
-                  InternalCqQuery cq = ((InternalCqQuery)cqService.getClientCqFromServer(clientProxyID, cqName));
+                for (String cqName : cqNames.getNames()) {
+                  InternalCqQuery cq = ((InternalCqQuery) cqService.getClientCqFromServer(clientProxyID, cqName));
-      }
-      catch (Exception e) {
-       //catch exceptions that arise due to maintaining cq stats
-        //as maintaining cq stats should not affect the system.
+      } catch (Exception e) {
+        // catch exceptions that arise due to maintaining cq stats
+        // as maintaining cq stats should not affect the system.
-      container = new HAContainerMap(new HashMap());
+      container = new HAContainerMap(new ConcurrentHashMap());
-      container = new HAContainerMap(new HashMap());
+      container = new HAContainerMap(new ConcurrentHashMap());
-          Map.Entry entry = null;
-          synchronized (this.haContainer) {
-            entry = (Map.Entry)((HAContainerWrapper)this.haContainer)
+          //synchronized (this.haContainer) {
+          HAEventWrapper original = null;
+          do {
+            ClientUpdateMessageImpl old = (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer).putIfAbsent(haEventWrapper,
+                haEventWrapper.getClientUpdateMessage());
+            if (old != null) {
+              original = (HAEventWrapper) ((HAContainerWrapper) this.haContainer).getKey(haEventWrapper);
+              if (original == null) {
+                continue;
+              }
+              synchronized (original) {
+                // assert the entry is still present
+                if (((HAContainerWrapper) this.haContainer).getKey(original) != null) {
+                  original.incAndGetReferenceCount();
+                  addClientCQsAndInterestList(old, haEventWrapper, this.haContainer, this.regionName);
+                  haEventWrapper = original;
+                } else {
+                  original = null;
+                }
+              }
+            } else {
+              synchronized (haEventWrapper) {
+                haEventWrapper.incAndGetReferenceCount();
+                haEventWrapper.setHAContainer(this.haContainer);
+                if (!haEventWrapper.getPutInProgress()) {
+                  // This means that this is a GII'ed event. Hence we must
+                  // explicitly set 'clientUpdateMessage' to null.
+                  haEventWrapper.setClientUpdateMessage(null);
+                }
+                haEventWrapper.setIsRefFromHAContainer(true);
+              }
+              break;
+            }
+          } while (original == null);
+          /*  entry = (Map.Entry)((HAContainerWrapper)this.haContainer)
-          }
+          }//haContainer synchronized ends
-          }
+          }*/
-  public static void addClientCQsAndInterestList(Map.Entry entry,
-      HAEventWrapper haEventWrapper, Map haContainer, String regionName) {
+  public static void addClientCQsAndInterestList(ClientUpdateMessageImpl msg, HAEventWrapper haEventWrapper, Map haContainer, String regionName) {
-    ClientProxyMembershipID proxyID = ((HAContainerWrapper)haContainer)
-        .getProxyID(regionName);
+    ClientProxyMembershipID proxyID = ((HAContainerWrapper) haContainer).getProxyID(regionName);
-        ((ClientUpdateMessageImpl)entry.getValue()).addClientCqs(proxyID,
-            clientCQ);
+        msg.addClientCqs(proxyID, clientCQ);
-    ClientUpdateMessageImpl clientMsg = (ClientUpdateMessageImpl)haEventWrapper
-        .getClientUpdateMessage();
+    ClientUpdateMessageImpl clientMsg = (ClientUpdateMessageImpl) haEventWrapper.getClientUpdateMessage();
-      ((ClientUpdateMessageImpl)entry.getValue()).addClientInterestList(
-          proxyID, true);
-    }
-    else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
-      ((ClientUpdateMessageImpl)entry.getValue()).addClientInterestList(
-          proxyID, false);
+      msg.addClientInterestList(proxyID, true);
+    } else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
+      msg.addClientInterestList(proxyID, false);
-    Conflatable cum = null;
+    Conflatable msg = null;
-      cum = (Conflatable)HARegionQueue.this.haContainer.get(wrapper);
-      if (cum != null) {
+      msg = (Conflatable)HARegionQueue.this.haContainer.get(wrapper);
+      if (msg != null) {
-      cum = conflatable;
+      msg = conflatable;
-    return cum;
+    return msg;
-      synchronized (this.haContainer) {
+      synchronized (wrapper) {

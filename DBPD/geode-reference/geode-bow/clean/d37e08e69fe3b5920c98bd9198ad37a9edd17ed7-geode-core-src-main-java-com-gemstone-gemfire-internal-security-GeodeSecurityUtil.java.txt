GEODE-1571: Allow AuthInit to take either a constructor or a static factory method

* Allow AuthInit to take either a constructor or a static factory method
* add more javadoc
* simplify security check
* fix test failures

+import java.lang.reflect.Method;
+import org.apache.geode.security.GeodePermission;
+import org.apache.geode.security.GeodePermission.Operation;
+import org.apache.geode.security.GeodePermission.Resource;
+import org.apache.geode.security.PostProcessor;
+import org.apache.geode.security.SecurityManager;
-import org.apache.shiro.UnavailableSecurityManagerException;
-import org.apache.geode.security.GeodePermission;
-import org.apache.geode.security.GeodePermission.Operation;
-import org.apache.geode.security.GeodePermission.Resource;
-import org.apache.geode.security.PostProcessor;
-import org.apache.geode.security.SecurityManager;
-    if (!isSecured()) {
+    if (!isIntegratedSecure) {
-    if (!isSecured()) {
+    if (!isIntegratedSecure) {
-  private static boolean isSecured() {
-    try {
-      SecurityUtils.getSecurityManager();
-    }
-    catch (UnavailableSecurityManagerException e) {
-      return false;
-    }
-    return true;
-  }
-
+  private static boolean isSecure;
+  private static boolean isIntegratedSecure;
+    String clientAuthenticatorConfig = securityProps.getProperty(SECURITY_CLIENT_AUTHENTICATOR);
+      isSecure = true;
+      isIntegratedSecure = true;
-
-      securityManager = getObjectOfType(securityConfig, SecurityManager.class);
+      securityManager = getObjectOfTypeFromClassName(securityConfig, SecurityManager.class);
+      isSecure = true;
+      isIntegratedSecure = true;
+    }
+    else if( !StringUtils.isBlank(clientAuthenticatorConfig)) {
+      isSecure = true;
+      isIntegratedSecure = false;
+      isSecure = false;
+      isIntegratedSecure = false;
-      postProcessor = getObjectOfType(customPostProcessor, PostProcessor.class);
+      postProcessor = getObjectOfTypeFromClassName(customPostProcessor, PostProcessor.class);
+    isSecure = false;
+    isIntegratedSecure = false;
-    Subject subject = getSubject();
-    return (subject != null && postProcessor != null);
+    return (isIntegratedSecure && postProcessor != null);
-  public static <T> T getObjectOfType(String className, Class<T> expectedClazz) {
+  /**
+   * this method would never return null, it either throws an exception or returns an object
+   * @param className
+   * @param expectedClazz
+   * @param <T>
+   * @return
+   */
+  public static <T> T getObjectOfTypeFromClassName(String className, Class<T> expectedClazz) {
-      throw new GemFireSecurityException(ex.toString(), ex);
+      throw new GemFireSecurityException("Instance could not be obtained, "+ex.toString(), ex);
-      throw new GemFireSecurityException("Expecting a "+expectedClazz.getName()+" class.");
+      throw new GemFireSecurityException("Instance could not be obtained. Expecting a "+expectedClazz.getName()+" class.");
-      throw new GemFireSecurityException("Error instantiating "+actualClass.getName(), e);
+      throw new GemFireSecurityException("Instance could not be obtained. Error instantiating "+actualClass.getName(), e);
+  /**
+   * this method would never return null, it either throws an exception or returns an object
+   * @param factoryMethodName
+   * @param expectedClazz
+   * @param <T>
+   * @return
+   */
+  public static <T> T getObjectOfTypeFromFactoryMethod(String factoryMethodName, Class<T> expectedClazz){
+    T actualObject = null;
+    try {
+      Method factoryMethod = ClassLoadUtil.methodFromName(factoryMethodName);
+      actualObject = (T)factoryMethod.invoke(null, (Object[])null);
+    } catch (Exception e) {
+      throw new GemFireSecurityException("Instance could not be obtained from "+factoryMethodName, e);
+    }
+
+    if(actualObject == null){
+      throw new GemFireSecurityException("Instance could not be obtained from "+factoryMethodName);
+    }
+
+    return actualObject;
+  }
+
+  /**
+   * this method would never return null, it either throws an exception or returns an object
+   * @param classOrMethod
+   * @param expectedClazz
+   * @param <T>
+   * @return an object of type expectedClazz. This method would never return null. It either returns an non-null
+   * object or throws exception.
+   */
+  public static <T> T getObjectOfType(String classOrMethod, Class<T> expectedClazz) {
+    T object = null;
+    try{
+      object = getObjectOfTypeFromClassName(classOrMethod, expectedClazz);
+    }
+    catch (Exception e){
+      object = getObjectOfTypeFromFactoryMethod(classOrMethod, expectedClazz);
+    }
+    return object;
+  }
+
-  public static boolean isSecurityRequired(Properties securityProps){
-    String authenticator = securityProps.getProperty(SECURITY_CLIENT_AUTHENTICATOR);
-    String securityManager = securityProps.getProperty(SECURITY_MANAGER);
-    return !StringUtils.isEmpty(authenticator) || !StringUtils.isEmpty(securityManager);
+  public static boolean isSecurityRequired(){
+    return isSecure;
-  public static boolean isIntegratedSecurity(Properties securityProps){
-    String securityManager = securityProps.getProperty(SECURITY_MANAGER);
-    return !StringUtils.isEmpty(securityManager);
+  public static boolean isIntegratedSecurity(){
+    return isIntegratedSecure;

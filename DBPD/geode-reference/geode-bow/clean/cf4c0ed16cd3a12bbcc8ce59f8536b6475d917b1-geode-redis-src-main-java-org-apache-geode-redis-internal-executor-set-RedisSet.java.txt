GEODE-8089: change redis set ops to use functions (#5058)

* scard now uses function
* sismember now uses function
* srandmember now uses a function
* spop now uses a function
* sscan now uses a function
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptySet;
+
-import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.regex.Pattern;
+import org.apache.geode.redis.internal.Coder;
-  public static Set<ByteArrayWrapper> members(Region<ByteArrayWrapper, RedisSet> region,
+  public static Set<ByteArrayWrapper> smembers(Region<ByteArrayWrapper, RedisSet> region,
-      return Collections.emptySet();
+      return emptySet();
+  public static int scard(Region<ByteArrayWrapper, RedisSet> region, ByteArrayWrapper key) {
+    RedisSet redisSet = region.get(key);
+    if (redisSet != null) {
+      return redisSet.size();
+    } else {
+      return 0;
+    }
+  }
+
+  public static boolean sismember(Region<ByteArrayWrapper, RedisSet> region,
+      ByteArrayWrapper key, ByteArrayWrapper member) {
+    RedisSet redisSet = region.get(key);
+    if (redisSet != null) {
+      return redisSet.contains(member);
+    } else {
+      return false;
+    }
+  }
+
+  public static Collection<ByteArrayWrapper> srandmember(Region<ByteArrayWrapper, RedisSet> region,
+      ByteArrayWrapper key, int count) {
+    RedisSet redisSet = region.get(key);
+    if (redisSet != null) {
+      return redisSet.srandmember(count);
+    } else {
+      return emptyList();
+    }
+  }
+
+  public static Collection<ByteArrayWrapper> spop(Region<ByteArrayWrapper, RedisSet> region,
+      ByteArrayWrapper key, int popCount) {
+    RedisSet redisSet = region.get(key);
+    if (redisSet != null) {
+      return redisSet.doSpop(region, key, popCount);
+    } else {
+      return emptyList();
+    }
+  }
+
+  public static List<Object> sscan(Region<ByteArrayWrapper, RedisSet> region,
+      ByteArrayWrapper key, Pattern matchPattern, int count, int cursor) {
+    RedisSet RedisSet = region.get(key);
+    if (RedisSet != null) {
+      return RedisSet.doSscan(matchPattern, count, cursor);
+    } else {
+      return emptyList();
+    }
+  }
+
+
+  private synchronized List<Object> doSscan(Pattern matchPattern, int count, int cursor) {
+    List<Object> returnList = new ArrayList<>();
+    int size = members.size();
+    int beforeCursor = 0;
+    int numElements = 0;
+    int i = -1;
+    for (ByteArrayWrapper value : members) {
+      i++;
+      if (beforeCursor < cursor) {
+        beforeCursor++;
+        continue;
+      } else if (numElements < count) {
+        if (matchPattern != null) {
+          String valueAsString = Coder.bytesToString(value.toBytes());
+          if (matchPattern.matcher(valueAsString).matches()) {
+            returnList.add(value);
+            numElements++;
+          }
+        } else {
+          returnList.add(value);
+          numElements++;
+        }
+      } else {
+        break;
+      }
+    }
+
+    if (i == size - 1) {
+      returnList.add(0, String.valueOf(0));
+    } else {
+      returnList.add(0, String.valueOf(i));
+    }
+    return returnList;
+  }
+
+  private synchronized Collection<ByteArrayWrapper> doSpop(
+      Region<ByteArrayWrapper, RedisSet> region, ByteArrayWrapper key, int popCount) {
+    int originalSize = size();
+    if (originalSize == 0) {
+      return emptyList();
+    }
+
+    if (popCount >= originalSize) {
+      // TODO: need to also cause key to be removed from the metaregion
+      region.remove(key, this);
+      return this.members;
+    }
+
+    ArrayList<ByteArrayWrapper> popped = new ArrayList<>();
+    ByteArrayWrapper[] setMembers = members.toArray(new ByteArrayWrapper[originalSize]);
+    Random rand = new Random();
+    while (popped.size() < popCount) {
+      int idx = rand.nextInt(originalSize);
+      ByteArrayWrapper memberToPop = setMembers[idx];
+      if (memberToPop != null) {
+        setMembers[idx] = null;
+        popped.add(memberToPop);
+        members.remove(memberToPop);
+      }
+    }
+    if (!popped.isEmpty()) {
+      this.deltasAreAdds = false;
+      this.deltas = popped;
+      try {
+        region.put(key, this);
+      } finally {
+        this.deltas = null;
+      }
+    }
+    return popped;
+  }
+
+  private synchronized Collection<ByteArrayWrapper> srandmember(int count) {
+    int membersSize = members.size();
+
+    if (membersSize <= count && count != 1) {
+      return new ArrayList<>(members);
+    }
+
+    Random rand = new Random();
+
+    ByteArrayWrapper[] entries = members.toArray(new ByteArrayWrapper[membersSize]);
+
+    if (count == 1) {
+      ByteArrayWrapper randEntry = entries[rand.nextInt(entries.length)];
+      // Note using ArrayList because Collections.singleton has serialization issues.
+      ArrayList<ByteArrayWrapper> result = new ArrayList<>(1);
+      result.add(randEntry);
+      return result;
+    }
+    Set<ByteArrayWrapper> result = new HashSet<>();
+    // Note that rand.nextInt can return duplicates when "count" is high
+    // so we need to use a Set to collect the results.
+    while (result.size() < count) {
+      ByteArrayWrapper s = entries[rand.nextInt(entries.length)];
+      result.add(s);
+    }
+    return result;
+  }
+
-  synchronized Set<ByteArrayWrapper> members() {
+  private synchronized Set<ByteArrayWrapper> members() {

GEODE-6603: Create StoppableCountDownLatch unit tests (#3413)

* Create StoppableCountDownLatchTest and fixup any issues uncovered by
testing.
* Remove unused class StoppableCountDownOrUpLatch.
* Improve ExecutorServiceRule for StoppableCountDownLatchTest.

+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+
-import org.apache.geode.distributed.internal.DistributionConfig;
-  /**
-   * This is how often waiters will wake up to check for cancellation
-   */
-  static final long RETRY_TIME = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "stoppable-retry-interval", 2000).longValue();
+  static final String RETRY_TIME_MILLIS_PROPERTY = GEMFIRE_PREFIX + "stoppable-retry-interval";
+  static final long RETRY_TIME_MILLIS_DEFAULT = 2000;
+  private final CountDownLatch delegate;
-  /**
-   * The underlying latch
-   */
-  private final CountDownLatch latch;
-
-  /**
-   * The cancellation criterion
-   */
+   * This is how often waiters will wake up to check for cancellation
+   */
+  private final long retryIntervalNanos;
+
+  private final NanoTimer nanoTimer;
+
+  /**
+   * @param stopper the CancelCriterion to check before awaiting
-  public StoppableCountDownLatch(CancelCriterion stopper, int count) {
+  public StoppableCountDownLatch(final CancelCriterion stopper, final int count) {
+    this(stopper, count,
+        MILLISECONDS.toNanos(Long.getLong(RETRY_TIME_MILLIS_PROPERTY, RETRY_TIME_MILLIS_DEFAULT)),
+        System::nanoTime);
+  }
+
+  StoppableCountDownLatch(final CancelCriterion stopper, final int count,
+      final long retryIntervalNanos, final NanoTimer nanoTimer) {
-    this.latch = new CountDownLatch(count);
+    delegate = new CountDownLatch(count);
+    this.retryIntervalNanos = retryIntervalNanos;
+    this.nanoTimer = nanoTimer;
-    for (;;) {
+    do {
-      if (latch.await(RETRY_TIME, TimeUnit.MILLISECONDS)) {
-        break;
-      }
-    }
-  }
-
-  /**
-   * @param msTimeout how long to wait in milliseconds
-   *
-   * @return true if it was unlatched
-   */
-  public boolean await(long msTimeout) throws InterruptedException {
-    stopper.checkCancelInProgress(null);
-    return latch.await(msTimeout, TimeUnit.MILLISECONDS);
+    } while (!delegate.await(retryIntervalNanos, NANOSECONDS));
-    return latch.await(timeout, unit);
-  }
-
-  public synchronized void countDown() {
-    latch.countDown();
+    long timeoutNanos = unit.toNanos(timeout);
+    if (timeoutNanos > retryIntervalNanos) {
+      return awaitWithCheck(timeoutNanos);
+    }
+    return delegate.await(timeoutNanos, NANOSECONDS);
-   * @return the current count
+   * @param timeoutMillis how long to wait in milliseconds
+   *
+   * @return true if it was unlatched
+  public boolean await(final long timeoutMillis) throws InterruptedException {
+    stopper.checkCancelInProgress(null);
+    long timeoutNanos = MILLISECONDS.toNanos(timeoutMillis);
+    if (timeoutNanos > retryIntervalNanos) {
+      return awaitWithCheck(timeoutNanos);
+    }
+    return delegate.await(timeoutNanos, NANOSECONDS);
+  }
+
+  public void countDown() {
+    delegate.countDown();
+  }
+
-    return latch.getCount();
+    return delegate.getCount();
-  /**
-   * @return a string identifying this latch, as well as its state
-   */
-    return "(Stoppable) " + latch.toString();
+    return "(Stoppable) " + delegate;
+  }
+
+  long retryIntervalNanos() {
+    return retryIntervalNanos;
+  }
+
+  private boolean awaitWithCheck(final long timeoutNanos) throws InterruptedException {
+    long startNanos = nanoTimer.nanoTime();
+    boolean unlatched;
+    do {
+      stopper.checkCancelInProgress(null);
+      unlatched = delegate.await(retryIntervalNanos, NANOSECONDS);
+    } while (!unlatched && nanoTimer.nanoTime() - startNanos < timeoutNanos);
+    return unlatched;
+  }
+
+  @FunctionalInterface
+  interface NanoTimer {
+    long nanoTime();

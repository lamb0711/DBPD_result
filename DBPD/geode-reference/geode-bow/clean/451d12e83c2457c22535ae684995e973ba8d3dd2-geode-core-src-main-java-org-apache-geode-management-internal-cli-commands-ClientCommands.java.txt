GEODE-2919: Provide finer grained security

 - For full details, see https://cwiki.apache.org/confluence/display/GEODE/Finer+grained+security

-import org.apache.geode.cache.CacheFactory;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.management.ObjectName;
+
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
+
-import org.apache.geode.management.internal.cli.functions.ContunuousQueryFunction;
-import org.apache.geode.management.internal.cli.functions.ContunuousQueryFunction.ClientInfo;
+import org.apache.geode.management.internal.cli.functions.ContinuousQueryFunction;
+import org.apache.geode.management.internal.cli.functions.ContinuousQueryFunction.ClientInfo;
-import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.springframework.shell.core.CommandMarker;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import javax.management.ObjectName;
-    Result result = null;
+    Result result;
-      Map<String, List<String>> clientServerMap = new HashMap<String, List<String>>();
+      Map<String, List<String>> clientServerMap = new HashMap<>();
-        for (String clietName : listOfClient) {
+        for (String clientName : listOfClient) {
-          if (clientServerMap.containsKey(clietName)) {
-            List<String> listServers = clientServerMap.get(clietName);
+          if (clientServerMap.containsKey(clientName)) {
+            List<String> listServers = clientServerMap.get(clientName);
-            List<String> listServer = new ArrayList<String>();
+            List<String> listServer = new ArrayList<>();
-            clientServerMap.put(clietName, listServer);
+            clientServerMap.put(clientName, listServer);
-      Iterator<Entry<String, List<String>>> it = clientServerMap.entrySet().iterator();
-      while (it.hasNext()) {
-        Map.Entry<String, List<String>> pairs = (Map.Entry<String, List<String>>) it.next();
-        String client = (String) pairs.getKey();
-        List<String> servers = (List<String>) pairs.getValue();
+      for (Entry<String, List<String>> pairs : clientServerMap.entrySet()) {
+        String client = pairs.getKey();
+        List<String> servers = pairs.getValue();
-    Result result = null;
+    Result result;
-            new ArrayList<String>(Arrays.asList((String[]) serverMbean.getClientIds()));
+            new ArrayList<>(Arrays.asList((String[]) serverMbean.getClientIds()));
-      List<String> primaryServers = new ArrayList<String>();
-      List<String> secondaryServers = new ArrayList<String>();
+      List<String> primaryServers = new ArrayList<>();
+      List<String> secondaryServers = new ArrayList<>();
-        ContunuousQueryFunction contunuousQueryFunction = new ContunuousQueryFunction();
-        FunctionService.registerFunction(contunuousQueryFunction);
+        ContinuousQueryFunction continuousQueryFunction = new ContinuousQueryFunction();
+        FunctionService.registerFunction(continuousQueryFunction);
-            .executeFunction(contunuousQueryFunction, clientId, dsMembers).getResult();
-        for (int i = 0; i < resultList.size(); i++) {
+            .executeFunction(continuousQueryFunction, clientId, dsMembers).getResult();
+        for (Object aResultList : resultList) {
-            Object object = resultList.get(i);
+            Object object = aResultList;
-          .info("Error in decribe clients. stack trace" + CliUtil.stackTraceAsString(e));
+          .info("Error in describe clients. stack trace" + CliUtil.stackTraceAsString(e));
-    LogWrapper.getInstance().info("decribe client result " + result);
+    LogWrapper.getInstance().info("describe client result " + result);
-        Iterator<Entry<String, String>> it = poolStats.entrySet().iterator();
-        while (it.hasNext()) {
-          Entry<String, String> entry = it.next();
+        for (Entry<String, String> entry : poolStats.entrySet()) {
-          LogWrapper.getInstance().info("decribe client clientHealthStatus min conn="
+          LogWrapper.getInstance().info("describe client clientHealthStatus min conn="
-          LogWrapper.getInstance().info("decribe client clientHealthStatus max conn ="
+          LogWrapper.getInstance().info("describe client clientHealthStatus max conn ="
-          LogWrapper.getInstance().info("decribe client clientHealthStatus redundancy ="
+          LogWrapper.getInstance().info("describe client clientHealthStatus redundancy ="
-          LogWrapper.getInstance().info("decribe client clientHealthStatus CQs ="
+          LogWrapper.getInstance().info("describe client clientHealthStatus CQs ="
-          poolStatsResultTable.accumulate(CliStrings.DESCRIBE_CLIENT_REDUDANCY,
+          poolStatsResultTable.accumulate(CliStrings.DESCRIBE_CLIENT_REDUNDANCY,

Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.cache.CustomEvictionAttributes;
-import com.gemstone.gemfire.cache.util.BridgeClient;
+  private String hdfsStoreName;
+  private boolean hdfsWriteOnly = false;
+  /**
+   * True if usage of off-heap memory is enabled for this region.
+   * @since 9.0
+   */
+  private boolean offHeap;
+
+	this.hdfsStoreName = attrs.getHDFSStoreName();
+    
+    this.offHeap = attrs.getOffHeap();
+ 	if (! equal(this.hdfsStoreName, other.getHDFSStoreName())) {
+      //TODO:HDFS write a new exception string
+      throw new RuntimeException(" HDFS Store name does not match");
+    }
+    if (this.offHeap != other.getOffHeap()) {
+      throw new RuntimeException(LocalizedStrings.RegionAttributesCreation_ENABLE_OFF_HEAP_MEMORY_IS_NOT_THE_SAME.toLocalizedString());
+    }
-    if (cacheLoader instanceof BridgeClient && !hasCacheWriter()) {
-      // fix for bug 36247
-      setCacheWriter((BridgeClient)cacheLoader);
-    }
-    if (cacheWriter instanceof BridgeClient && !hasCacheLoader()) {
-      // fix for bug 36247
-      setCacheLoader((BridgeClient)cacheWriter);
-    }
+    if (!hasHDFSStoreName()) {
+      if (parentIsUserSpecified) {
+        if (parentWithHas.hasHDFSStoreName()) {
+          setHDFSStoreName(parent.getHDFSStoreName());
+        }
+      } else {
+        setHDFSStoreName(parent.getHDFSStoreName());
+      }
+    }
+    if (!hasHDFSWriteOnly()) {
+      if (parentIsUserSpecified) {
+        if (parentWithHas.hasHDFSWriteOnly()) {
+          setHDFSWriteOnly(parent.getHDFSWriteOnly());
+        }
+      } else {
+        setHDFSWriteOnly(parent.getHDFSWriteOnly());
+      }
+    }
-  
-  
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public CustomEvictionAttributes getCustomEvictionAttributes() {
+    // TODO: HDFS: no support for configuring this from XML yet
+    return null;
+  }
+
+  public void setOffHeap(boolean offHeap) {
+    this.offHeap = offHeap;
+    setHasOffHeap(true);
+  }
+  
+  public boolean getOffHeap() {
+    return this.offHeap;
+  }
+  
+  public String getHDFSStoreName() {
+    return this.hdfsStoreName;
+  }
+  public void setHDFSStoreName(String hdfsStoreName) {
+    //TODO:HDFS : throw an exception if a disk store is already configured
+    // and vice versa
+    this.hdfsStoreName = hdfsStoreName;
+    setHasHDFSStoreName(true);
+  }
+  public void setHDFSWriteOnly(boolean writeOnly) {
+    this.hdfsWriteOnly= writeOnly;
+    setHasHDFSWriteOnly(true);
+  }
+  public boolean getHDFSWriteOnly() {
+    return hdfsWriteOnly;
+  }

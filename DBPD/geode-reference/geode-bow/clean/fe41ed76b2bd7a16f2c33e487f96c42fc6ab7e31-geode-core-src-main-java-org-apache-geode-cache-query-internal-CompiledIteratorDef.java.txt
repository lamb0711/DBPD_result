GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import java.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
-import org.apache.geode.cache.*;
-import org.apache.geode.cache.query.*;
-import org.apache.geode.cache.query.internal.parse.*;
-import org.apache.geode.cache.query.types.*;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.query.AmbiguousNameException;
+import org.apache.geode.cache.query.FunctionDomainException;
+import org.apache.geode.cache.query.NameResolutionException;
+import org.apache.geode.cache.query.QueryExecutionTimeoutException;
+import org.apache.geode.cache.query.QueryInvocationTargetException;
+import org.apache.geode.cache.query.QueryService;
+import org.apache.geode.cache.query.RegionNotFoundException;
+import org.apache.geode.cache.query.SelectResults;
+import org.apache.geode.cache.query.TypeMismatchException;
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import org.apache.geode.cache.query.types.CollectionType;
+import org.apache.geode.cache.query.types.MapType;
+import org.apache.geode.cache.query.types.ObjectType;
-/**
- */
-    // Rahul : generate from clause should take care of bucket region substitution if
+    // generate from clause should take care of bucket region substitution if
-    /**
-     * Asif : If the type of RunTimeIterator is still ObjectType & if the RuneTimeIterator is
-     * independent of any iterator of the scopes less than or equal to its own scope, we can
-     * evaluate the collection via RuntimeIterator. This will initialize the Collection of
-     * RuntimeIterator , which is OK. The code in RuntimeIterator will be rectified such that the
-     * ElementType of that RuntimeIterator is taken from the collection
-     * 
+    /*
+     * If the type of RunTimeIterator is still ObjectType & if the RuneTimeIterator is independent
+     * of any iterator of the scopes less than or equal to its own scope, we can evaluate the
+     * collection via RuntimeIterator. This will initialize the Collection of RuntimeIterator ,
+     * which is OK. The code in RuntimeIterator will be rectified such that the ElementType of that
+     * RuntimeIterator is taken from the collection
-    SelectResults sr = prepareIteratorDef(coll, this.elementType, context);
-    return sr;
+    return prepareIteratorDef(coll, this.elementType, context);
-   * TODO:Asif : We need to implement the belwo method of computeDependencies Once we come to
-   * implement changes for partitioned region querying, as in that case if first iterator itself is
-   * a Select Query , then ideally we cannot call that CompiledIteratorDef independent ( which will
-   * be the case at present). When we use this commented function we will also need to take care of
+   * TODO: We need to implement the belwo method of computeDependencies Once we come to implement
+   * changes for partitioned region querying, as in that case if first iterator itself is a Select
+   * Query , then ideally we cannot call that CompiledIteratorDef independent ( which will be the
+   * case at present). When we use this commented function we will also need to take care of
-   * 
-   * public Set computeDependencies(ExecutionContext context) throws TypeMismatchException,
-   * AmbiguousNameException { //Asif : If a CompiledIteratorDef has a collection expression which
-   * boils down to //a CompiledRegion or CompiledBindArgumnet , then its dependency is empty . In
-   * such cases // we will assume that the current CompiledIteratorDef has a dependency on itself.
-   * // This will be required once we start the changes for partitionedRegion Querying //But when we
-   * are doing check of whether the CompiledIteratorDef is dependent on its // own RuntimeIterator
-   * we will still return false. Set set = this.collectionExpr.computeDependencies(context); Set
-   * retSet = null; if(set.isEmpty()){ retSet =
-   * context.addDependency(this,this.getRuntimeIterator(context)); }else { retSet =
-   * context.addDependencies(this, set); } return retSet; }
-  // @todo ericz this method is overly complex, duplicating logic already
+  // TODO: this method is overly complex, duplicating logic already
-    // @todo primitive arrays?
+    // TODO: primitive arrays?
-    StringBuffer sbuff = new StringBuffer();
+    StringBuilder sbuff = new StringBuilder();
-  boolean isDependentOnAnyIterator(ExecutionContext context) {
-    return context.isDependentOnAnyIterator(this);
-  }
-
-   * 
-   * @param context
-    // Asif : Get the list of all iterators on which the colelction expression
+    // Get the list of all iterators on which the colelction expression
-    // Set indpRitrs = new HashSet();
-    // context.computeUtlimateDependencies(this, indpRitrs);
-    // Asif:If dependent on self then also assume it to be dependent
+
+    // If dependent on self then also assume it to be dependent
-    // Asif : Get the list of all iterators on which the colelction expression
+    // Get the list of all iterators on which the colelction expression
-

Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.  
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.internal.offheap.Chunk;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.pdx.internal.PdxString;
-    entriesSet = new HashIndexSet(entryToValuesMap, entryToOldKeysMap, internalIndexStats);
+    entriesSet = new HashIndexSet();
-            entriesSet.remove(oldKey, entry, true);
+            removeFromEntriesSet(oldKey, entry, true);
-      this.entriesSet.add(newKey, entry);
+      
+      // Before adding the entry with new value, remove it from reverse map and
+      // using the oldValue remove entry from the forward map.
+      // Reverse-map is used based on the system property
+      Object oldKey = getOldKey(entry);
+      
+      int indexSlot = this.entriesSet.add(newKey, entry);
+      
+      if (indexSlot >= 0) {
+        // Update the reverse map
+        if (IndexManager.isObjectModificationInplace()) {
+          this.entryToValuesMap.put(entry, newKey);
+        }
+        if (newKey != null && oldKey != null) {
+          removeFromEntriesSet(oldKey, entry, false, indexSlot);
+        }
+        // Update Stats after real addition
+        internalIndexStats.incNumValues(1);
+
+      }
+  
+  private Object getOldKey(RegionEntry entry) throws TypeMismatchException {
+    Object oldKey = null;
+    if (IndexManager.isObjectModificationInplace() && this.entryToValuesMap.containsKey(entry)) {
+      oldKey = this.entryToValuesMap.get(entry);
+    } else if (!IndexManager.isObjectModificationInplace() && this.entryToOldKeysMap != null) {
+      Map oldKeyMap = this.entryToOldKeysMap.get();
+      if (oldKeyMap != null) {
+        oldKey = TypeUtils.indexKeyFor(oldKeyMap.get(entry));
+      }
+    }
+    return oldKey;
+  }
-    boolean found = false;
-      found = this.entriesSet.remove(newKey, entry, updateReverseMap);       
+      removeFromEntriesSet(newKey, entry, updateReverseMap);
+  
+  private void removeFromEntriesSet(Object newKey, RegionEntry entry, boolean updateReverseMap) {
+    removeFromEntriesSet(newKey, entry, updateReverseMap, -1);
+  }
+  
+  private void removeFromEntriesSet(Object newKey, RegionEntry entry, boolean updateReverseMap, int ignoreThisSlot) {
+    if (this.entriesSet.remove(newKey, entry, ignoreThisSlot)) {
+      if (updateReverseMap && IndexManager.isObjectModificationInplace()) {
+        entryToValuesMap.remove(entry);
+      }
+      internalIndexStats.incNumValues(-1);
+    }
+  }
-    this.entriesSet.setHashIndexStrategy(new HashStrategy(
-        (IMQEvaluator) evaluator));
+    this.entriesSet.setEvaluator((HashIndex.IMQEvaluator)evaluator);
-        
+          key = ((HashIndex.IMQEvaluator)evaluator).evaluateKey(obj);
+  // TODO OFFHEAP: may return PdxInstance
-      Object o = entry.getValueInVMOrDiskWithoutFaultIn((LocalRegion) getRegion()); // OFFHEAP: incrc, deserialize, decrc
+      Object o = entry.getValueOffHeapOrDiskWithoutFaultIn((LocalRegion) getRegion());
-        if (o instanceof CachedDeserializable) {
-          return ((CachedDeserializable) o).getDeserializedForReading();
+        if (o instanceof Chunk) {
+          Chunk ohval = (Chunk) o;
+          try {
+            o = ohval.getDeserializedForReading();
+          } finally {
+            ohval.release();
+          }
+        } else if (o instanceof CachedDeserializable) {
+          o = ((CachedDeserializable)o).getDeserializedForReading();
-	int numKeys = (int) this.internalIndexStats.getNumberOfKeys();
-	if (numKeys > 0) {
-		this.internalIndexStats.incNumKeys(-numKeys);
-	}
-	int numValues = (int) this.internalIndexStats.getNumberOfValues();
-	if (numValues > 0) {
-		this.internalIndexStats.incNumValues(-numValues);
-	}
-	int updates = (int) this.internalIndexStats.getNumUpdates();
-	if (updates > 0) {
-		this.internalIndexStats.incNumUpdates(updates);
-	}
-	this.initializeIndex(true);
+    if (IndexManager.isObjectModificationInplace()) {
+      entryToValuesMap.clear();
+    }
+    int numKeys = (int) this.internalIndexStats.getNumberOfKeys();
+    if (numKeys > 0) {
+      this.internalIndexStats.incNumKeys(-numKeys);
+    }
+    int numValues = (int) this.internalIndexStats.getNumberOfValues();
+    if (numValues > 0) {
+      this.internalIndexStats.incNumValues(-numValues);
+    }
+    int updates = (int) this.internalIndexStats.getNumUpdates();
+    if (updates > 0) {
+      this.internalIndexStats.incNumUpdates(updates);
+    }
+    this.initializeIndex(true);
-    Object evaluateKey(Object object) {
+    public Object evaluateKey(Object object) {
+      
+      
+      if (key == null) {
+        key = IndexManager.NULL;
+      }
-        Object key0 = ((Object[])arg0)[1];
-        Object key1 = ((Object[])arg1)[1];
+        Object key0 = ((Object[])arg0)[0];
+        Object key1 = ((Object[])arg1)[0];
-
-  private class HashStrategy implements HashIndexStrategy {
-
-    private AttributeDescriptor attDesc;
-
-    private IMQEvaluator evaluator;
-    
-    public HashStrategy(IMQEvaluator evaluator) {
-      this.evaluator = evaluator;
-    }
-
-    public final int computeHashCode(Object o) {
-      return computeHashCode(o, false);
-    }
-
-    public final int computeHashCode(Object o, boolean reevaluateKey) {
-      if (reevaluateKey) {
-        return computeKey(o).hashCode();
-      }
-      return o.hashCode();
-    }
-
-    public final Object computeKey(Object o) {
-      Object key = evaluator.evaluateKey(o);
-      if (key == null) {
-        key = IndexManager.NULL;
-      }
-      return key;
-    }
-
-    public final boolean equalsOnAdd(Object o1, Object o2) {
-      if (o1 == null) {
-        return o2 == null;
-      }
-      try {
-        return TypeUtils.compare(o1, o2, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
-      }
-      catch (TypeMismatchException e) {
-        return o1.equals(o2);
-      }
-    }
-
-    /*
-     * expects object o to be a region entry
-     */
-    public boolean equalsOnGet(Object indexKey, Object o) {
-      Object fieldValue = evaluator.evaluateKey(o);
-     
-      if (fieldValue == null && indexKey == IndexManager.NULL) {
-        return true;
-      } else {
-        try {
-         return TypeUtils.compare(fieldValue, indexKey, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
-        }
-        catch (TypeMismatchException e) {
-          return fieldValue.equals(indexKey);
-        }
-      }
-    }
-  }
-
+  
-  public String printAll() {
-    return this.entriesSet.printAll();
-  }
+//  public String printAll() {
+//    return this.entriesSet.printAll();
+//  }

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class contains static methods for manipulating files and directories,
- * such as recursively copying or deleting files.
+ * This class contains static methods for manipulating files and directories, such as recursively
+ * copying or deleting files.
- * TODO A lot of this functionality is probably duplicating apache commons io,
- * maybe we should switch to that.
+ * TODO A lot of this functionality is probably duplicating apache commons io, maybe we should
+ * switch to that.
-  public static final long MAX_TRANSFER_SIZE = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "FileUtil.MAX_TRANSFER_SIZE", 1024 * 1024).longValue();
-  public static final boolean USE_NIO = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "FileUtil.USE_OLD_IO");
+  public static final long MAX_TRANSFER_SIZE =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "FileUtil.MAX_TRANSFER_SIZE", 1024 * 1024)
+          .longValue();
+  public static final boolean USE_NIO =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "FileUtil.USE_OLD_IO");
-   * Copy a file from the source file to the destination file.
-   * If the source is a directory, it will be copied recursively.
+   * Copy a file from the source file to the destination file. If the source is a directory, it will
+   * be copied recursively.
-   * Note that unlike unix cp, if the destination is directory,
-   * the source *contents* will be copied to the destination *contents*, 
-   * not as a subdirectory of dest.
+   * Note that unlike unix cp, if the destination is directory, the source *contents* will be copied
+   * to the destination *contents*, not as a subdirectory of dest.
-    if(source.isDirectory()) {
+    if (source.isDirectory()) {
-      for(File child: listFiles(source)) {
+      for (File child : listFiles(source)) {
-      if(source.exists()) {
+      if (source.exists()) {
-        if(dest.isDirectory()) {
+        if (dest.isDirectory()) {
-            if(USE_NIO) {
+            if (USE_NIO) {
-  
+
-   * Basically just like {@link File#listFiles()} but instead of returning null
-   * returns an empty array. This fixes bug 43729
+   * Basically just like {@link File#listFiles()} but instead of returning null returns an empty
+   * array. This fixes bug 43729
+
+
+   * 
-  private static void nioCopy(FileOutputStream fos, FileInputStream fis)
-      throws IOException {
+  private static void nioCopy(FileOutputStream fos, FileInputStream fis) throws IOException {
-    while(true) {
+    while (true) {
-      
+
-      if(offset >= length) {
+      if (offset >= length) {
+   * 
-  throws IOException {
+      throws IOException {
-    while((read = fis.read(buffer)) > 0) {
+    while ((read = fis.read(buffer)) > 0) {
-   * @throws IOException
-   *           if the file or directory couldn't be deleted. Unlike File.delete,
-   *           which just returns false.
+   * @throws IOException if the file or directory couldn't be deleted. Unlike File.delete, which
+   *         just returns false.
-    if(!file.exists())
+    if (!file.exists())
-    if(file.isDirectory()) {
-      for(File child: listFiles(file)) {
+    if (file.isDirectory()) {
+      for (File child : listFiles(file)) {
-  
+
-   * Recursively delete a file or directory.
-   * A description of any files or directories
-   * that can not be deleted will be added to failures
-   * if failures is non-null.
-   * This method tries to delete as much as possible.
+   * Recursively delete a file or directory. A description of any files or directories that can not
+   * be deleted will be added to failures if failures is non-null. This method tries to delete as
+   * much as possible.
-    if(!file.exists())
+    if (!file.exists())
-    if(file.isDirectory()) {
-      for(File child: listFiles(file)) {
+    if (file.isDirectory()) {
+      for (File child : listFiles(file)) {
-    try{
+    try {
-        failures.append("Could not delete ")
-            .append(file)
-            .append(" due to ")
-            .append(e.getMessage())
+        failures.append("Could not delete ").append(file).append(" due to ").append(e.getMessage())
-   * Find the file whose name matches the given regular
-   * expression. The regex is matched against the absolute
-   * path of the file.
+   * Find the file whose name matches the given regular expression. The regex is matched against the
+   * absolute path of the file.
-    if(baseFile.getAbsolutePath().matches(regex)) {
+    if (baseFile.getAbsolutePath().matches(regex)) {
-    if(baseFile.exists() && baseFile.isDirectory()) {
-      for(File child: listFiles(baseFile)) {
-        File foundFile =  find(child, regex);
-        if(foundFile != null) {
+    if (baseFile.exists() && baseFile.isDirectory()) {
+      for (File child : listFiles(baseFile)) {
+        File foundFile = find(child, regex);
+        if (foundFile != null) {
-  
+
-   * Find a files in a given base directory that match
-   * a the given regex. The regex is matched against the
-   * full path of the file.
+   * Find a files in a given base directory that match a the given regex. The regex is matched
+   * against the full path of the file.
-  
+
-   * Destroys all files that match the given regex that
-   * are in the given directory.
-   * If a destroy fails it is ignored and an attempt is
-   * made to destroy any other files that match.
+   * Destroys all files that match the given regex that are in the given directory. If a destroy
+   * fails it is ignored and an attempt is made to destroy any other files that match.
-    if(baseFile.exists() && baseFile.isDirectory()) {
-      for(File child: listFiles(baseFile)) {
+    if (baseFile.exists() && baseFile.isDirectory()) {
+      for (File child : listFiles(baseFile)) {
-    if(baseFile.getAbsolutePath().matches(regex)) {
+    if (baseFile.getAbsolutePath().matches(regex)) {
-    if(baseFile.exists() && baseFile.isDirectory()) {
-      for(File child: listFiles(baseFile)) {
+    if (baseFile.exists() && baseFile.isDirectory()) {
+      for (File child : listFiles(baseFile)) {
-   * Convert a file into a relative path from a given parent. This is useful if
-   * you want to write out the file name into that parent directory.
+   * Convert a file into a relative path from a given parent. This is useful if you want to write
+   * out the file name into that parent directory.
-   * @param parent
-   *          The parent directory.
-   * @param file
-   *          The file we want to covert to a relative file.
-   * @return A file, such that new File(parent, returnValue) == file. Note that
-   *         if file does not have the parent in it's path, an the absolute
-   *         version if the file is returned.
+   * @param parent The parent directory.
+   * @param file The file we want to covert to a relative file.
+   * @return A file, such that new File(parent, returnValue) == file. Note that if file does not
+   *         have the parent in it's path, an the absolute version if the file is returned.
+   * 
-        while((read = is.read(buffer)) > 0) {
+        while ((read = is.read(buffer)) > 0) {
-    
+
-  
+
-   * A safer version of File.mkdirs, which works around
-   * a race in the 1.5 JDK where two VMs creating the same 
-   * directory chain at the same time could end up in one
-   * VM failing to create a subdirectory.
+   * A safer version of File.mkdirs, which works around a race in the 1.5 JDK where two VMs creating
+   * the same directory chain at the same time could end up in one VM failing to create a
+   * subdirectory.
+   * 
-    if(! parentFile.exists()) {
+    if (!parentFile.exists()) {
-    //As long as someone successfully created the parent file
-    //go ahead and create the child directory.
-    if(parentFile.exists()) {
+    // As long as someone successfully created the parent file
+    // go ahead and create the child directory.
+    if (parentFile.exists()) {
-  
+

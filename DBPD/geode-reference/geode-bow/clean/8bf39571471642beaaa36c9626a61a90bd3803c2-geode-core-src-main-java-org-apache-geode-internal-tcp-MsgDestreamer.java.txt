Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** <p>MsgDestreamer supports destreaming a streamed message from a tcp Connection
- * that arrives in chunks.
- * This allows us to receive a message without needing to
- * read it completely into a buffer before we can start deserializing it.
-
-    @since GemFire 5.0.2
-   
-    */
+/**
+ * <p>
+ * MsgDestreamer supports destreaming a streamed message from a tcp Connection that arrives in
+ * chunks. This allows us to receive a message without needing to read it completely into a buffer
+ * before we can start deserializing it.
+ * 
+ * @since GemFire 5.0.2
+ * 
+ */
-   * If an exception occurs during deserialization of the message it will be
-   * recorded here.
+   * If an exception occurs during deserialization of the message it will be recorded here.
-  
+
-  
+
+
-    if (this.t.isClosed() || Thread.interrupted()) throw new InterruptedException();
+    if (this.t.isClosed() || Thread.interrupted())
+      throw new InterruptedException();
-        if (this.t.isClosed() || Thread.interrupted()) throw new InterruptedException();
+        if (this.t.isClosed() || Thread.interrupted())
+          throw new InterruptedException();
-  
-//   private final String me = "MsgDestreamer<" + System.identityHashCode(this) + ">";
-//   public String toString() {
-//     return this.me;
-//   }
-//     private void logit(String s) {
-//       LogWriterI18n l = getLogger();
-//       if (l != null) {
-//         l.fine(this + ": " + s);
-//       }
-//     }
-//     private LogWriterI18n getLogger() {
-//       LogWriterI18n result = null;
-//       DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
-//       if (ds != null) {
-//         result = ds.getLogWriter();
-//       }
-//       return result;
-//     }
-    
+  // private final String me = "MsgDestreamer<" + System.identityHashCode(this) + ">";
+
+  // public String toString() {
+  // return this.me;
+  // }
+  // private void logit(String s) {
+  // LogWriterI18n l = getLogger();
+  // if (l != null) {
+  // l.fine(this + ": " + s);
+  // }
+  // }
+  // private LogWriterI18n getLogger() {
+  // LogWriterI18n result = null;
+  // DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
+  // if (ds != null) {
+  // result = ds.getLogWriter();
+  // }
+  // return result;
+  // }
+
+   * 
-//       logit("addChunk bb length=" + length);
+      // logit("addChunk bb length=" + length);
+
+   * 
-//       logit("addChunk length=" + b.length);
+      // logit("addChunk length=" + b.length);
+
+
-   * @throws IOException
-   *         A problem occured while deserializing the message.
-   * @throws ClassNotFoundException
-   *         The class of an object read from <code>in</code> could
-   *         not be found
+   * 
+   * @throws IOException A problem occured while deserializing the message.
+   * @throws ClassNotFoundException The class of an object read from <code>in</code> could not be
+   *         found
-    throws InterruptedException, IOException, ClassNotFoundException
-  {
-//    if (Thread.interrupted()) throw new InterruptedException(); not necessary done in waitUntilDone
-    //this.t.join();
+      throws InterruptedException, IOException, ClassNotFoundException {
+    // if (Thread.interrupted()) throw new InterruptedException(); not necessary done in
+    // waitUntilDone
+    // this.t.join();
-//       logit("failed with" + this.failure);
+      // logit("failed with" + this.failure);
-        throw (ClassNotFoundException)this.failure;
+        throw (ClassNotFoundException) this.failure;
-        throw (IOException)this.failure;
+        throw (IOException) this.failure;
-        IOException io =  new IOException(LocalizedStrings.MsgDestreamer_FAILURE_DURING_MESSAGE_DESERIALIZATION.toLocalizedString());
+        IOException io =
+            new IOException(LocalizedStrings.MsgDestreamer_FAILURE_DURING_MESSAGE_DESERIALIZATION
+                .toLocalizedString());
-//       logit("result =" + this.result);
+      // logit("result =" + this.result);
+
-   * Returns the reply processor id for the current failed message.
-   * Returns 0 if it does not have one.
-   * Note this method should only be called after getMessage has thrown an exception.
+   * Returns the reply processor id for the current failed message. Returns 0 if it does not have
+   * one. Note this method should only be called after getMessage has thrown an exception.
+
+
+
+
-//     private final String me = "DestreamerThread<" + System.identityHashCode(this) + ">";
-//     public String toString() {
-//       return this.me;
-//     }
+    // private final String me = "DestreamerThread<" + System.identityHashCode(this) + ">";
+    // public String toString() {
+    // return this.me;
+    // }
+
-          DataInputStream dis = v == null ? new DataInputStream(this.is)
-              : new VersionedDataInputStream(this.is, v);
+          DataInputStream dis =
+              v == null ? new DataInputStream(this.is) : new VersionedDataInputStream(this.is, v);
-          setResult((DistributionMessage)InternalDataSerializer.readDSFID(dis));
+          setResult((DistributionMessage) InternalDataSerializer.readDSFID(dis));
-        } 
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable ex) {
+        } catch (Throwable ex) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
+
+
-   * This input stream waits for data to be available.
-   * Once it is provided, by a call to addChunk, it will stream the
-   * data in from that chunk, signal that is has completed, and then wait for
+   * This input stream waits for data to be available. Once it is provided, by a call to addChunk,
+   * it will stream the data in from that chunk, signal that is has completed, and then wait for
-    
+
-      
+
-      /* (non-Javadoc)
+      /*
+       * (non-Javadoc)
+       * 
-      /* (non-Javadoc)
+      /*
+       * (non-Javadoc)
+       * 
-    
+
-//   public String toString() {
-//     return this.owner.me;
-//   }
-//     private void logit(String s) {
-//       LogWriterI18n l = getLogger();
-//       if (l != null) {
-//         l.fine(this + ": " + s);
-//       }
-//     }
+    // public String toString() {
+    // return this.owner.me;
+    // }
+    // private void logit(String s) {
+    // LogWriterI18n l = getLogger();
+    // if (l != null) {
+    // l.fine(this + ": " + s);
+    // }
+    // }
-//     private LogWriterI18n getLogger() {
-//       LogWriterI18n result = null;
-//       DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
-//       if (ds != null) {
-//         result = ds.getLogWriter();
-//       }
-//       return result;
-//     }
-    
+    // private LogWriterI18n getLogger() {
+    // LogWriterI18n result = null;
+    // DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
+    // if (ds != null) {
+    // result = ds.getLogWriter();
+    // }
+    // return result;
+    // }
+
-    
+
-      if (isClosed() || Thread.interrupted()) throw new InterruptedException();
+      if (isClosed() || Thread.interrupted())
+        throw new InterruptedException();
-          if (isClosed() || Thread.interrupted()) throw new InterruptedException();
-          //logit("about to dataMon wait");
+          if (isClosed() || Thread.interrupted())
+            throw new InterruptedException();
+          // logit("about to dataMon wait");
-          //logit("after dataMon wait");
-          if (isClosed() || Thread.interrupted()) throw new InterruptedException();
+          // logit("after dataMon wait");
+          if (isClosed() || Thread.interrupted())
+            throw new InterruptedException();
+
-//         if (bb != null) {
-//           logit("MDIS: providing bb with " +
-//                 bb.remaining() + " bytes");
-//         }
+        // if (bb != null) {
+        // logit("MDIS: providing bb with " +
+        // bb.remaining() + " bytes");
+        // }
-        //logit("dataMon notify bb=" + bb);
+        // logit("dataMon notify bb=" + bb);
-    
+
-      if (isClosed() || Thread.interrupted()) throw new InterruptedException();
+      if (isClosed() || Thread.interrupted())
+        throw new InterruptedException();
-          if (isClosed() || Thread.interrupted()) throw new InterruptedException();
-          //logit("about to doneMon wait");
+          if (isClosed() || Thread.interrupted())
+            throw new InterruptedException();
+          // logit("about to doneMon wait");
-          //logit("after doneMon wait");
-          if (isClosed() || Thread.interrupted()) throw new InterruptedException();
+          // logit("after doneMon wait");
+          if (isClosed() || Thread.interrupted())
+            throw new InterruptedException();
+
-        //logit("doneMon notify");
+        // logit("doneMon notify");
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
-            }
-            finally {
+            } finally {
-//           logit("received new bb with " +
-//                 myData.remaining() + " bytes");
+          // logit("received new bb with " +
+          // myData.remaining() + " bytes");
-    
+
+
-     * See the InputStream read method for javadocs.
-     * Note that if an attempt
-     * to read past the end of the wrapped ByteBuffer is done this method
-     * throws BufferUnderflowException
+     * See the InputStream read method for javadocs. Note that if an attempt to read past the end of
+     * the wrapped ByteBuffer is done this method throws BufferUnderflowException
-//       logit("read result=" + result);
+      // logit("read result=" + result);
-  
-    /* this method is not thread safe
-     * See the InputStream read method for javadocs.
-     * Note that if an attempt
-     * to read past the end of the wrapped ByteBuffer is done this method
-     * throws BufferUnderflowException
+
+    /*
+     * this method is not thread safe See the InputStream read method for javadocs. Note that if an
+     * attempt to read past the end of the wrapped ByteBuffer is done this method throws
+     * BufferUnderflowException
-//       logit("read[] read=" + bytesToRead);
+      // logit("read[] read=" + bytesToRead);
-    
+
+

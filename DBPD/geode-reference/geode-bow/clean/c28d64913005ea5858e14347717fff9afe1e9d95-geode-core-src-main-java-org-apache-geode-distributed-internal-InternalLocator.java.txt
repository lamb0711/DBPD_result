Merge branch 'release/1.4.0'

-import org.apache.geode.internal.cache.tier.sockets.ClientProtocolService;
-import org.apache.geode.management.internal.configuration.handlers.ConfigurationRequestHandler;
-import org.apache.geode.management.internal.configuration.messages.ConfigurationRequest;
- * 
+ *
-   * locator state file
-   */
-  private File stateFile;
-
-  /**
-  // TODO: return value of removeLocator is never used
-  private static boolean removeLocator(InternalLocator locator) {
+  private static void removeLocator(InternalLocator locator) {
-      return false;
+      return;
-      if (locator != null && locator.equals(InternalLocator.locator)) {
+      if (locator.equals(InternalLocator.locator)) {
-        return true;
-      return false;
-   * 
+   *
-   * @param stateFile the file that state should be read from / written to for recovery
-  public static InternalLocator createLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      String hostnameForClients, Properties distributedSystemProperties,
-      boolean startDistributedSystem) {
+  public static InternalLocator createLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, String hostnameForClients,
+      Properties distributedSystemProperties, boolean startDistributedSystem) {
-          new InternalLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+          new InternalLocator(port, logFile, logger, securityLogger, bindAddress,
-   * 
+   *
-  public static InternalLocator startLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      boolean startDistributedSystem, Properties dsProperties, String hostnameForClients)
-      throws IOException {
+  public static InternalLocator startLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, boolean startDistributedSystem,
+      Properties dsProperties, String hostnameForClients) throws IOException {
-      newLocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+      newLocator = createLocator(port, logFile, logger, securityLogger, bindAddress,
-      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero
-      // port in a variable to use here
-        newLocator.startPeerLocation(startDistributedSystem);
+        newLocator.startPeerLocation();
+
-            // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
-   * 
+   *
-   * 
+   *
-   * @param stateF the file that state should be read from / written to for recovery
-  private InternalLocator(int port, File logF, File stateF, InternalLogWriter logWriter,
+  private InternalLocator(int port, File logF, InternalLogWriter logWriter,
-    if (stateF == null) {
-      this.stateFile = new File("locator" + port + "view.dat");
-    } else {
-      this.stateFile = stateF;
-    }
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  // Reset the file names with the correct port number if startLocatorAndDS was called with port
-  // number 0
-  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port) {
-    this.stateFile = new File("locator" + port + "view.dat");
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  }
-
+    if (myCache == null) {
+      return GemFireCacheImpl.getInstance();
+    }
-   * <p>
-   * TODO: parameter withDS is never used
-   * @param withDS true if a distributed system has been or will be started
-   *
+   * @return returns the port that the locator to which the locator is bound
-  void startPeerLocation(boolean withDS) throws IOException {
+  int startPeerLocation() throws IOException {
-    boolean locatorsAreCoordinators = false;
+    boolean locatorsAreCoordinators;
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
-        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats,
-        securityUDPDHAlgo);
+    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, locatorsProp,
+        locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats, securityUDPDHAlgo);
+    int boundPort = this.server.getPort();
+    File productUseFile = new File("locator" + boundPort + "views.log");
+    productUseLog = new ProductUseLog(productUseFile);
+
+    return boundPort;
-  public PrimaryHandler getPrimaryHandler() {
-    return this.handler;
-  }
-
-   * 
+   *
-  public static InternalLocator startLocator(int locatorPort, File logFile, File stateFile,
+  public static InternalLocator startLocator(int locatorPort, File logFile,
-    return startLocator(locatorPort, logFile, stateFile, logger, logger1, addr, true, dsProperties,
-        s);
-  }
-
-  class SharedConfigurationRunnable implements Runnable {
-
-    private final InternalLocator locator = InternalLocator.this;
-
-    @Override
-    public void run() {
-      try {
-        if (this.locator.sharedConfig == null) {
-          // locator.sharedConfig will already be created in case of auto-reconnect
-          this.locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
-        }
-        this.locator.sharedConfig.initSharedConfiguration(this.locator.loadFromSharedConfigDir());
-        this.locator.installSharedConfigDistribution();
-        logger.info(
-            "Cluster configuration service start up completed successfully and is now running ....");
-      } catch (CancelException | LockServiceDestroyedException e) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("Cluster configuration start up was cancelled", e);
-        }
-      } catch (Exception e) {
-        logger.error(e.getMessage(), e);
-      }
-    }
+    return startLocator(locatorPort, logFile, logger, logger1, addr, true, dsProperties, s);
-   * 
+   *
-    startSharedConfigurationService(internalCache);
+    startSharedConfigurationService();
-   * 
+   *
-   * 
+   *
-    this.productUseLog.monitorUse(distributedSystem);
-
+    // the product use is not guaranteed to be initialized until the server is started, so
+    // the last thing we do is tell it to start logging
+    this.productUseLog.monitorUse(distributedSystem);
-   * 
+   *
-    this.productUseLog.close();
+    if (this.productUseLog != null) {
+      this.productUseLog.close();
+    }
-   * 
+   *
-   * 
+   *
-      if (isSharedConfigurationEnabled()) {
-        this.sharedConfig = new ClusterConfigurationService(newCache);
-      }
+
-      this.isSharedConfigurationStarted = true;
-      if (isSharedConfigurationEnabled()) {
-        ExecutorService es = newCache.getDistributionManager().getThreadPool();
-        es.execute(new SharedConfigurationRunnable());
-      }
+      startSharedConfigurationService();
-    return this.myDs;
+    if (myDs == null) {
+      return InternalDistributedSystem.getAnyInstance();
+    }
+
+    return myDs;
-   * 
+   *
-      // TODO: this for-loop is probably not necessary as the if to break is always true
-      for (int i = 0; i < MAX_RETRIES; i++) {
-        if (locator.sharedConfig != null) {
-          SharedConfigurationStatus status = locator.sharedConfig.getStatus();
-          if (status != SharedConfigurationStatus.STARTED
-              || status != SharedConfigurationStatus.NOT_STARTED) {
-            break;
-          }
-        }
-        Thread.sleep(SLEEPTIME);
-      }
+
-    // GEODE-2253 test condition
-    private boolean hasWaitedForHandlerInitialization = false;
-              this.hasWaitedForHandlerInitialization = true;
-    /**
-     * GEODE-2253 test condition - has this handler waited for a subordinate handler to be
-     * installed?
-     */
-    public boolean hasWaitedForHandlerInitialization() {
-      return this.hasWaitedForHandlerInitialization;
-    }
-
-
-      ClientProtocolService clientProtocolService = this.server.getClientProtocolService();
-      if (clientProtocolService != null) {
-        clientProtocolService.initializeStatistics("LocatorStats", sys);
-      }
-   * 
+   *
-  private void startSharedConfigurationService(InternalCache internalCache) {
+  private void startSharedConfigurationService() {
-    if (this.config.getEnableClusterConfiguration() && !this.isSharedConfigurationStarted) {
-      if (!isDedicatedLocator()) {
-        logger.info("Cluster configuration service not enabled as it is only supported "
-            + "in dedicated locators");
-        return;
-      }
-
-      ExecutorService es = internalCache.getDistributionManager().getThreadPool();
-      es.execute(new SharedConfigurationRunnable());
-    } else {
+    if (!config.getEnableClusterConfiguration()) {
+      return;
+    }
+
+    if (isSharedConfigurationStarted) {
+      logger.info("Cluster configuration service is already started.");
+      return;
+    }
+
+    if (!isDedicatedLocator()) {
+      logger.info("Cluster configuration service not enabled as it is only supported "
+          + "in dedicated locators");
+      return;
+    }
+
+    try {
+      if (locator.sharedConfig == null) {
+        // locator.sharedConfig will already be created in case of auto-reconnect
+        locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
+      }
+      locator.sharedConfig.initSharedConfiguration(locator.loadFromSharedConfigDir());
+      logger.info(
+          "Cluster configuration service start up completed successfully and is now running ....");
+      isSharedConfigurationStarted = true;
+    } catch (CancelException | LockServiceDestroyedException e) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Cluster configuration start up was cancelled", e);
+      }
+    } catch (Exception e) {
+      logger.error(e.getMessage(), e);
-  /**
-   * Creates and installs the handler {@link ConfigurationRequestHandler}
-   */
-  private void installSharedConfigDistribution() {
-    if (!this.handler.isHandled(ConfigurationRequest.class)) {
-      this.handler.addHandler(ConfigurationRequest.class,
-          new ConfigurationRequestHandler(this.sharedConfig));
-      logger.info("ConfigRequestHandler installed");
-    }
-  }
-

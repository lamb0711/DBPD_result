GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+
+import org.apache.geode.cache.query.CqQuery;
-  public static final int interestListIndexForUpdatesAsInvalidates = 2;
-  public static final int durableInterestListIndexForUpdatesAsInvalidates = 3;
+  private static final int interestListIndexForUpdatesAsInvalidates = 2;
+  private static final int durableInterestListIndexForUpdatesAsInvalidates = 3;
-  private final ConcurrentMap cqs /* <CqQuery,Boolean> */ = new ConcurrentHashMap();
+  private final ConcurrentMap<CqQuery, Boolean> cqs = new ConcurrentHashMap<>();
-  public List getInterestList(String regionName, int interestType) {
+  public List<Object> getInterestList(String regionName, int interestType) {
-    ArrayList result = new ArrayList();
+    ArrayList<Object> result = new ArrayList<>();
-  public void addSingleInterest(LocalRegion r, Object key, int interestType,
-      InterestResultPolicy pol, boolean isDurable, boolean receiveUpdatesAsInvalidates) {
+  void addSingleInterest(LocalRegion r, Object key, int interestType,
+      InterestResultPolicy pol, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates) {
-  public boolean removeSingleInterest(LocalRegion r, Object key, int interestType,
+  boolean removeSingleInterest(LocalRegion r, Object key, int interestType,
-  public void addInterestList(LocalRegion r, List keys, InterestResultPolicy pol, boolean isDurable,
+  void addInterestList(LocalRegion r, List keys, InterestResultPolicy pol, boolean isDurable,
-    for (int i = 0; i < keys.size(); i++) {
-      rie.getInterests().put(keys.get(i), pol);
+    for (Object key : keys) {
+      rie.getInterests().put(key, pol);
-    this.cqs.put(cqi, Boolean.valueOf(isDurable));
+    this.cqs.put(cqi, isDurable);
-  public void removeCq(InternalCqQuery cqi, boolean isDurable) {
+  public void removeCq(InternalCqQuery cqi) {
-  public Map getCqsMap() {
+  Map getCqsMap() {
-  public void unregisterRegion(ServerRegionProxy srp, boolean keepalive) {
+  void unregisterRegion(ServerRegionProxy srp, boolean keepalive) {
-  public boolean removeInterestList(LocalRegion r, List keys, boolean isDurable,
+  boolean removeInterestList(LocalRegion r, List keys, boolean isDurable,
-    for (int i = 0; i < keys.size(); i++) {
-      Object key = keys.get(i);
+    for (Object key : keys) {
-  public ConcurrentMap getRegionToInterestsMap(int interestType, boolean isDurable,
+  ConcurrentMap<String, RegionInterestEntry> getRegionToInterestsMap(int interestType,
+      boolean isDurable,
-    ConcurrentMap mapOfInterest = null;
-
-        mapOfInterest = fil.keysOfInterest;
-        break;
+        return fil.keysOfInterest;
-        mapOfInterest = fil.regexOfInterest;
-        break;
+        return fil.regexOfInterest;
-        mapOfInterest = fil.filtersOfInterest;
-        break;
+        return fil.filtersOfInterest;
-        mapOfInterest = fil.cqsOfInterest;
-        break;
+        return fil.cqsOfInterest;
-        mapOfInterest = fil.queriesOfInterest;
-        break;
+        return fil.queriesOfInterest;
-    return mapOfInterest;
-    ConcurrentMap mapOfInterest =
+    ConcurrentMap<String, RegionInterestEntry> mapOfInterest =
-    RegionInterestEntry result = (RegionInterestEntry) mapOfInterest.get(regionName);
+    RegionInterestEntry result = mapOfInterest.get(regionName);
-      result = (RegionInterestEntry) mapOfInterest.putIfAbsent(regionName, rie);
+      result = mapOfInterest.putIfAbsent(regionName, rie);
-    final ConcurrentMap keysOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> keysOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap regexOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> regexOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap filtersOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> filtersOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap queriesOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> queriesOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap cqsOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> cqsOfInterest = new ConcurrentHashMap<>();
-    private final ConcurrentMap interests;
+    private final ConcurrentMap<Object, InterestResultPolicy> interests;
-      this.interests = new ConcurrentHashMap();
+      this.interests = new ConcurrentHashMap<>();
-    public ConcurrentMap getInterests() {
+    public ConcurrentMap<Object, InterestResultPolicy> getInterests() {

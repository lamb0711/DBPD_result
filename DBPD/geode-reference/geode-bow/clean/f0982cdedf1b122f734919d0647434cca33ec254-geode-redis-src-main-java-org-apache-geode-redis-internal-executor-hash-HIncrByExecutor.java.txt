Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)

This reverts commit 2f6bf013368df5a4b5efe68162a4953f9a88bbf2.
-import java.util.Map;
-import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.cache.Region;
+import org.apache.geode.redis.internal.RedisDataType;
-/**
- * <pre>
- *
- * Implementation of the HINCRBY command to increment the number stored at field
- * in the hash stored at key by increment value.
- *
- * Examples:
- *
- * redis> HSET myhash field 5
- * (integer) 1
- * redis> HINCRBY myhash field 1
- * (integer) 6
- * redis> HINCRBY myhash field -1
- * (integer) 5
- * redis> HINCRBY myhash field -10
- * (integer) -5
- *
- *
- * </pre>
- */
-  private static final String ERROR_FIELD_NOT_USABLE = "The value at this field is not an integer";
+  private final String ERROR_FIELD_NOT_USABLE = "The value at this field is not an integer";
-  private static final String ERROR_INCREMENT_NOT_USABLE =
-      "The increment on this key must be numeric";
+  private final String ERROR_INCREMENT_NOT_USABLE = "The increment on this key must be numeric";
-  private static final String ERROR_OVERFLOW =
-      "This incrementation cannot be performed due to overflow";
+  private final String ERROR_OVERFLOW = "This incrementation cannot be performed due to overflow";
-  private static final int FIELD_INDEX = 2;
+  private final int FIELD_INDEX = 2;
-  private static final int INCREMENT_INDEX = 3;
+  private final int INCREMENT_INDEX = 3;
-    long value;
+    Region<ByteArrayWrapper, ByteArrayWrapper> keyRegion =
+        getOrCreateRegion(context, key, RedisDataType.REDIS_HASH);
-    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
-      Map<ByteArrayWrapper, ByteArrayWrapper> map = getMap(context, key);
+    byte[] byteField = commandElems.get(FIELD_INDEX);
+    ByteArrayWrapper field = new ByteArrayWrapper(byteField);
-      byte[] byteField = commandElems.get(FIELD_INDEX);
-      ByteArrayWrapper field = new ByteArrayWrapper(byteField);
+    /*
+     * Put incrememnt as value if field doesn't exist
+     */
-      /*
-       * Put increment as value if field doesn't exist
-       */
+    ByteArrayWrapper oldValue = keyRegion.get(field);
-      ByteArrayWrapper oldValue = map.get(field);
-
-      if (oldValue == null) {
-        map.put(field, new ByteArrayWrapper(incrArray));
-
-        saveMap(map, context, key);
-
-        command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), increment));
-
-        return;
-      }
-
-      /*
-       * If the field did exist then increment the field
-       */
-      try {
-        value = Long.parseLong(oldValue.toString());
-      } catch (NumberFormatException e) {
-        command.setResponse(
-            Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_FIELD_NOT_USABLE));
-        return;
-      }
-
-      /*
-       * Check for overflow
-       */
-      if ((value >= 0 && increment > (Long.MAX_VALUE - value))
-          || (value <= 0 && increment < (Long.MIN_VALUE - value))) {
-        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
-        return;
-      }
-
-      value += increment;
-
-      map.put(field, new ByteArrayWrapper(Coder.longToBytes(value)));
-
-      saveMap(map, context, key);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-      command.setResponse(
-          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
-      return;
-    } catch (TimeoutException e) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
-          "Timeout acquiring lock. Please try again."));
+    if (oldValue == null) {
+      keyRegion.put(field, new ByteArrayWrapper(incrArray));
+      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), increment));
+
+    /*
+     * If the field did exist then increment the field
+     */
+
+    long value;
+
+    try {
+      value = Long.parseLong(oldValue.toString());
+    } catch (NumberFormatException e) {
+      command.setResponse(
+          Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_FIELD_NOT_USABLE));
+      return;
+    }
+
+    /*
+     * Check for overflow
+     */
+    if ((value >= 0 && increment > (Long.MAX_VALUE - value))
+        || (value <= 0 && increment < (Long.MIN_VALUE - value))) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
+      return;
+    }
+
+    value += increment;
+    // String newValue = String.valueOf(value);
+
+    keyRegion.put(field, new ByteArrayWrapper(Coder.longToBytes(value)));
+

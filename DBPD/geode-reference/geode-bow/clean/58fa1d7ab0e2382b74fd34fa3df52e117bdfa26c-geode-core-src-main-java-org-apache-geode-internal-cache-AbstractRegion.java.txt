Merge remote-tracking branch 'upstream/develop' into develop

+import java.util.concurrent.locks.ReentrantReadWriteLock;
-
+  private final ReentrantReadWriteLock readWriteLockForCacheLoader = new ReentrantReadWriteLock();
+  private final ReentrantReadWriteLock readWriteLockForCacheWriter = new ReentrantReadWriteLock();
+  /**
+   * All access to cacheLoader must be protected by readWriteLockForCacheLoader
+   */
+  /**
+   * All access to cacheWriter must be protected by readWriteLockForCacheWriter
+   */
-    if (attrs.getPartitionAttributes() != null && this.evictionAttributes != null
-        && this.evictionAttributes.getAlgorithm().isLRUMemory()
-        && attrs.getPartitionAttributes().getLocalMaxMemory() != 0 && this.evictionAttributes
+    if (attrs.getPartitionAttributes() != null && this.evictionAttributes.getAlgorithm()
+        .isLRUMemory() && attrs.getPartitionAttributes().getLocalMaxMemory() != 0
+        && this.evictionAttributes
-    return this.cacheLoader;
+    readWriteLockForCacheLoader.readLock().lock();
+    try {
+      return this.cacheLoader;
+    } finally {
+      readWriteLockForCacheLoader.readLock().unlock();
+    }
-    return this.cacheWriter;
+    readWriteLockForCacheWriter.readLock().lock();
+    try {
+      return this.cacheWriter;
+    } finally {
+      readWriteLockForCacheWriter.readLock().unlock();
+    }
-  public synchronized CacheLoader setCacheLoader(CacheLoader cacheLoader) {
-    checkReadiness();
-    CacheLoader oldLoader = this.cacheLoader;
-    assignCacheLoader(cacheLoader);
-    cacheLoaderChanged(oldLoader);
-    return oldLoader;
+  public CacheLoader setCacheLoader(CacheLoader cacheLoader) {
+    readWriteLockForCacheLoader.writeLock().lock();
+    try {
+      checkReadiness();
+      CacheLoader oldLoader = this.cacheLoader;
+      this.cacheLoader = cacheLoader;
+      cacheLoaderChanged(oldLoader);
+      return oldLoader;
+    } finally {
+      readWriteLockForCacheLoader.writeLock().unlock();
+    }
-  private synchronized void assignCacheLoader(CacheLoader cl) {
-    this.cacheLoader = cl;
+  private void assignCacheLoader(CacheLoader cl) {
+    readWriteLockForCacheLoader.writeLock().lock();
+    try {
+      this.cacheLoader = cl;
+    } finally {
+      readWriteLockForCacheLoader.writeLock().unlock();
+    }
-  public synchronized CacheWriter setCacheWriter(CacheWriter cacheWriter) {
-    checkReadiness();
-    CacheWriter oldWriter = this.cacheWriter;
-    assignCacheWriter(cacheWriter);
-    cacheWriterChanged(oldWriter);
-    return oldWriter;
+  public CacheWriter setCacheWriter(CacheWriter cacheWriter) {
+    readWriteLockForCacheWriter.writeLock().lock();
+    try {
+      checkReadiness();
+      CacheWriter oldWriter = this.cacheWriter;
+      this.cacheWriter = cacheWriter;
+      cacheWriterChanged(oldWriter);
+      return oldWriter;
+    } finally {
+      readWriteLockForCacheWriter.writeLock().unlock();
+    }
-  private synchronized void assignCacheWriter(CacheWriter cacheWriter) {
-    this.cacheWriter = cacheWriter;
+  private void assignCacheWriter(CacheWriter cacheWriter) {
+    readWriteLockForCacheWriter.writeLock().lock();
+    try {
+      this.cacheWriter = cacheWriter;
+    } finally {
+      readWriteLockForCacheWriter.writeLock().unlock();
+    }
-    if (this.cacheLoader != oldLoader) {
-      closeCacheCallback(oldLoader);
+    readWriteLockForCacheLoader.readLock().lock();
+    try {
+      if (this.cacheLoader != oldLoader) {
+        closeCacheCallback(oldLoader);
+      }
+    } finally {
+      readWriteLockForCacheLoader.readLock().unlock();
+
-    if (this.cacheWriter != oldWriter) {
-      closeCacheCallback(oldWriter);
+    readWriteLockForCacheWriter.readLock().lock();
+    try {
+      if (this.cacheWriter != oldWriter) {
+        closeCacheCallback(oldWriter);
+      }
+    } finally {
+      readWriteLockForCacheWriter.readLock().unlock();

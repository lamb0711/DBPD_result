Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.  
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteOrder;
+
+import com.gemstone.gemfire.internal.ByteBufferWriter;
+import com.gemstone.gemfire.internal.HeapDataOutputStream;
+import com.gemstone.gemfire.internal.offheap.Chunk;
+import com.gemstone.gemfire.internal.offheap.UnsafeMemoryChunk;
-  private ByteBuffer buffer;
+  /**
+   * This interface is used to wrap either a ByteBuffer or an offheap Chunk
+   * as the source of bytes for a ByteBufferInputStream.
+   * 
+   * @author dschneider
+   *
+   */
+  public static interface ByteSource {
+    int position();
+    int limit();
+    int capacity();
+    int remaining();
+
+    void position(int newPosition);
+    void limit(int endOffset);
+
+    void get(byte[] b);
+    void get(byte[] b, int off, int len);
+    byte get();
+    byte get(int pos);
+    short getShort();
+    short getShort(int pos);
+    char getChar();
+    char getChar(int pos);
+    int getInt();
+    int getInt(int pos);
+    long getLong();
+    long getLong(int pos);
+    float getFloat();
+    float getFloat(int pos);
+    double getDouble();
+    double getDouble(int pos);
+
+    boolean hasArray();
+    byte[] array();
+    int arrayOffset();
+
+    ByteSource duplicate();
+    ByteSource slice(int length);
+    ByteSource slice(int pos, int limit);
+    
+    /**
+     * Returns the ByteBuffer that this ByteSource wraps; null if no ByteBuffer
+     */
+    ByteBuffer getBackingByteBuffer();
+
+    void sendTo(ByteBuffer out);
+    void sendTo(DataOutput out) throws IOException;
+  }
+  
+  public static class ByteSourceFactory {
+    public static ByteSource wrap(byte[] bytes) {
+      return new ByteBufferByteSource(ByteBuffer.wrap(bytes));
+    }
+    public static ByteSource create(ByteBuffer bb) {
+      return new ByteBufferByteSource(bb);
+    }
+    public static ByteSource create(Chunk chunk) {
+      // Since I found a way to create a DirectByteBuffer (using reflection) from a Chunk
+      // we might not even need the ByteSource abstraction any more.
+      // But it is possible that createByteBuffer will not work on a different jdk so keep it for now.
+      ByteBuffer bb = chunk.createDirectByteBuffer();
+      if (bb != null) {
+        return create(bb);
+      } else {
+        return new OffHeapByteSource(chunk);
+      }
+    }
+  }
+  
+  public static class ByteBufferByteSource implements ByteSource {
+    private final ByteBuffer bb;
+    public ByteBufferByteSource(ByteBuffer bb) {
+      this.bb = bb;
+    }
+    /**
+     * Returns the current hash code of this byte source.
+     *
+     * <p> The hash code of a byte source depends only upon its remaining
+     * elements; that is, upon the elements from <tt>position()</tt> up to, and
+     * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
+     *
+     * <p> Because byte source hash codes are content-dependent, it is inadvisable
+     * to use byte sources as keys in hash maps or similar data structures unless it
+     * is known that their contents will not change.  </p>
+     *
+     * @return  The current hash code of this byte source
+     */
+    @Override
+    public int hashCode() {
+      int h = 1;
+      int p = position();
+      for (int i = limit() - 1; i >= p; i--) {
+        h = 31 * h + (int)get(i);
+      }
+      return h;
+    }
+    @Override
+    public boolean equals(Object ob) {
+      if (this == ob) {
+        return true;
+      }
+      if (!(ob instanceof ByteSource)) {
+        return false;
+      }
+      ByteSource that = (ByteSource)ob;
+      if (this.remaining() != that.remaining()) {
+        return false;
+      }
+      int p = this.position();
+      for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
+        if (this.get(i) != that.get(j)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    @Override
+    public ByteSource duplicate() {
+      return ByteSourceFactory.create(this.bb.duplicate());
+    }
+    @Override
+    public byte get() {
+      return this.bb.get();
+    }
+    @Override
+    public void get(byte[] b, int off, int len) {
+      this.bb.get(b, off, len);
+    }
+    @Override
+    public int remaining() {
+      return this.bb.remaining();
+    }
+    @Override
+    public int position() {
+      return this.bb.position();
+    }
+    @Override
+    public byte get(int pos) {
+      return this.bb.get(pos);
+    }
+    @Override
+    public char getChar() {
+      return this.bb.getChar();
+    }
+    @Override
+    public char getChar(int pos) {
+      return this.bb.getChar(pos);
+    }
+    @Override
+    public double getDouble() {
+      return this.bb.getDouble();
+    }
+    @Override
+    public double getDouble(int pos) {
+      return this.bb.getDouble(pos);
+    }
+    @Override
+    public float getFloat() {
+      return this.bb.getFloat();
+    }
+    @Override
+    public float getFloat(int pos) {
+      return this.bb.getFloat(pos);
+    }
+    @Override
+    public void get(byte[] b) {
+      this.bb.get(b);
+    }
+    @Override
+    public int getInt() {
+      return this.bb.getInt();
+    }
+    @Override
+    public int getInt(int pos) {
+      return this.bb.getInt(pos);
+    }
+    @Override
+    public long getLong() {
+      return this.bb.getLong();
+    }
+    @Override
+    public long getLong(int pos) {
+      return this.bb.getLong(pos);
+    }
+    @Override
+    public short getShort() {
+      return this.bb.getShort();
+    }
+    @Override
+    public short getShort(int pos) {
+      return this.bb.getShort(pos);
+    }
+    @Override
+    public int limit() {
+      return this.bb.limit();
+    }
+    @Override
+    public void position(int newPosition) {
+      this.bb.position(newPosition);
+    }
+    @Override
+    public boolean hasArray() {
+      return this.bb.hasArray();
+    }
+    @Override
+    public byte[] array() {
+      return this.bb.array();
+    }
+    @Override
+    public int arrayOffset() {
+      return this.bb.arrayOffset();
+    }
+    @Override
+    public void limit(int endOffset) {
+      this.bb.limit(endOffset);
+    }
+    @Override
+    public ByteSource slice(int length) {
+      if (length < 0) {
+        throw new IllegalArgumentException();
+      }
+      ByteBuffer dup = this.bb.duplicate();
+      dup.limit(dup.position() + length);
+      return ByteSourceFactory.create(dup.slice());
+    }
+    @Override
+    public ByteSource slice(int pos, int limit) {
+      ByteBuffer dup = this.bb.duplicate();
+      dup.limit(limit);
+      dup.position(pos);
+      return ByteSourceFactory.create(dup.slice());
+    }
+    @Override
+    public int capacity() {
+      return this.bb.capacity();
+    }
+    @Override
+    public void sendTo(ByteBuffer out) {
+      out.put(this.bb);
+    }
+    @Override
+    public void sendTo(DataOutput out) throws IOException {
+      int len = remaining();
+      if (len == 0) return;
+      if (out instanceof ByteBufferWriter) {
+        ((ByteBufferWriter) out).write(this.bb);
+        return;
+      }
+      if (this.bb.hasArray()) {
+        byte[] bytes = this.bb.array();
+        int offset = this.bb.arrayOffset() + this.bb.position();
+        out.write(bytes, offset, len);
+        this.bb.position(this.bb.limit());
+      } else {
+        while (len > 0) {
+          out.writeByte(get());
+          len--;
+        }
+      }
+    }
+    @Override
+    public ByteBuffer getBackingByteBuffer() {
+      return this.bb;
+    }
+  }
+  
+  public static class OffHeapByteSource implements ByteSource {
+    private int position;
+    private int limit;
+    private final Chunk chunk;
+
+    public OffHeapByteSource(Chunk c) {
+      this.chunk = c;
+      this.position = 0;
+      this.limit = capacity();
+    }
+    private OffHeapByteSource(OffHeapByteSource other) {
+      this.chunk = other.chunk;
+      this.position = other.position;
+      this.limit = other.limit;
+    }
+    
+    /**
+     * Returns the current hash code of this byte source.
+     *
+     * <p> The hash code of a byte source depends only upon its remaining
+     * elements; that is, upon the elements from <tt>position()</tt> up to, and
+     * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
+     *
+     * <p> Because byte source hash codes are content-dependent, it is inadvisable
+     * to use byte sources as keys in hash maps or similar data structures unless it
+     * is known that their contents will not change.  </p>
+     *
+     * @return  The current hash code of this byte source
+     */
+    @Override
+    public int hashCode() {
+      int h = 1;
+      int p = position();
+      for (int i = limit() - 1; i >= p; i--) {
+        h = 31 * h + (int)get(i);
+      }
+      return h;
+    }
+     
+    @Override
+    public boolean equals(Object ob) {
+      if (this == ob) {
+        return true;
+      }
+      if (!(ob instanceof ByteSource)) {
+        return false;
+      }
+      ByteSource that = (ByteSource)ob;
+      if (this.remaining() != that.remaining()) {
+        return false;
+      }
+      int p = this.position();
+      for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
+        if (this.get(i) != that.get(j)) {
+          return false;
+        }
+      }
+      return true;
+    }
+    
+    @Override
+    public int remaining() {
+      return this.limit - this.position;
+    }
+
+    @Override
+    public int position() {
+      return this.position;
+    }
+
+    @Override
+    public int limit() {
+      return this.limit;
+    }
+
+    @Override
+    public void position(int newPosition) {
+      if ((newPosition > this.limit) || (newPosition < 0)) {
+        throw new IllegalArgumentException();
+      }
+      this.position = newPosition;
+    }
+    
+    @Override
+    public void limit(int newLimit) {
+      if ((newLimit > capacity()) || (newLimit < 0)) {
+        throw new IllegalArgumentException();
+      }
+      this.limit = newLimit;
+      if (this.position > this.limit) {
+        this.position = this.limit;
+      }
+    }
+    
+    @Override
+    public int capacity() {
+      return this.chunk.getDataSize();
+    }
+
+    private final int nextGetIndex() {
+      int p = this.position;
+      if (p >= this.limit) {
+        throw new BufferUnderflowException();
+      }
+      this.position += 1;
+      return p;
+    }
+
+    private final int nextGetIndex(int nb) {
+      int p = this.position;
+      if (this.limit - p < nb) {
+        throw new BufferUnderflowException();
+      }
+      this.position += nb;
+      return p;
+    }
+
+    /**
+     * Checks the given index against the limit, throwing an {@link
+     * IndexOutOfBoundsException} if it is not smaller than the limit
+     * or is smaller than zero.
+     */
+    private final void checkIndex(int i) {
+      if ((i < 0) || (i >= this.limit)) {
+        throw new IndexOutOfBoundsException();
+      }
+    }
+
+    private final void checkIndex(int i, int nb) {
+      if ((i < 0) || (nb > this.limit - i)) {
+        throw new IndexOutOfBoundsException();
+      }
+    }
+    private static void checkBounds(int off, int len, int size) {
+      if ((off | len | (off + len) | (size - (off + len))) < 0) {
+        throw new IndexOutOfBoundsException();
+      }
+    }
+    
+    @Override
+    public void get(byte[] b) {
+      basicGet(b, 0, b.length);
+    }
+    @Override
+    public void get(byte[] dst, int offset, int length) {
+      checkBounds(offset, length, dst.length);
+      basicGet(dst, offset, length);
+    }
+    private void basicGet(byte[] dst, int offset, int length) {
+      if (length > remaining()) {
+        throw new BufferUnderflowException();
+      }
+      int p = this.position;
+      this.position += length;
+      this.chunk.readBytes(p, dst, offset, length);
+    }
+
+    @Override
+    public byte get() {
+      return this.chunk.readByte(nextGetIndex());
+    }
+    @Override
+    public byte get(int pos) {
+      checkIndex(pos);
+      return this.chunk.readByte(pos);
+    }
+
+    /**
+     * Return true if the hardware supported unaligned reads from memory.
+     */
+    private static boolean determineUnaligned() {
+      try {
+        Class c = Class.forName("java.nio.Bits");
+        Method m = c.getDeclaredMethod("unaligned");
+        m.setAccessible(true);
+        return (boolean) m.invoke(null);
+      } catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+        return false;
+        //throw new IllegalStateException("Could not invoke java.nio.Bits.unaligned()", e);
+      }
+    }
+    private static final boolean unaligned = determineUnaligned();
+    
+    @Override
+    public short getShort() {
+      return basicGetShort(this.nextGetIndex(2));
+    }
+    @Override
+    public short getShort(int pos) {
+      this.checkIndex(pos, 2);
+      return basicGetShort(pos);
+    }
+    private short basicGetShort(int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 2);
+      if (unaligned) {
+        short result = UnsafeMemoryChunk.readAbsoluteShort(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Short.reverseBytes(result);
+        }
+        return result;
+      } else {
+        int ch1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        int ch2 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (short)((ch1 << 8) + (ch2 << 0));
+      }
+    }
+
+    @Override
+    public char getChar() {
+      return basicGetChar(this.nextGetIndex(2));
+    }
+    @Override
+    public char getChar(int pos) {
+      this.checkIndex(pos, 2);
+      return basicGetChar(pos);
+    }
+    private char basicGetChar(int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 2);
+      if (unaligned) {
+        char result = UnsafeMemoryChunk.readAbsoluteChar(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Character.reverseBytes(result);
+        }
+        return result;
+      } else {
+        int ch1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        int ch2 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (char)((ch1 << 8) + (ch2 << 0));
+      }
+    }
+
+    @Override
+    public int getInt() {
+      return basicGetInt(this.nextGetIndex(4));
+    }
+    @Override
+    public int getInt(int pos) {
+      this.checkIndex(pos, 4);
+      return basicGetInt(pos);
+    }
+    
+    private int basicGetInt(final int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 4);
+      if (unaligned) {
+        int result = UnsafeMemoryChunk.readAbsoluteInt(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Integer.reverseBytes(result);
+        }
+        return result;
+      } else {
+        byte b0 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b2 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b3 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (b0 << 24) + ((b1 & 255) << 16) + ((b2 & 255) << 8) + ((b3 & 255) << 0);
+      }
+    }
+
+    @Override
+    public long getLong() {
+      return basicGetLong(this.nextGetIndex(8));
+    }
+    @Override
+    public long getLong(int pos) {
+      this.checkIndex(pos, 8);
+      return basicGetLong(pos);
+    }
+    private long basicGetLong(final int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 8);
+      if (unaligned) {
+        long result = UnsafeMemoryChunk.readAbsoluteLong(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Long.reverseBytes(result);
+        }
+        return result;
+      } else {
+        byte b0 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b2 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b3 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b4 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b5 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b6 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b7 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (((long)b0 << 56) +
+            ((long)(b1 & 255) << 48) +
+            ((long)(b2 & 255) << 40) +
+            ((long)(b3 & 255) << 32) +
+            ((long)(b4 & 255) << 24) +
+            ((b5 & 255) << 16) +
+            ((b6 & 255) <<  8) +
+            ((b7 & 255) <<  0));
+      }
+    }
+
+    @Override
+    public float getFloat() {
+      return basicGetFloat(this.nextGetIndex(4));
+    }
+    @Override
+    public float getFloat(int pos) {
+      this.checkIndex(pos, 4);
+      return basicGetFloat(pos);
+   }
+    private float basicGetFloat(int pos) {
+      return Float.intBitsToFloat(basicGetInt(pos));
+    }
+
+    @Override
+    public double getDouble() {
+      return basicGetDouble(this.nextGetIndex(8));
+    }
+    @Override
+    public double getDouble(int pos) {
+      this.checkIndex(pos, 8);
+      return basicGetDouble(pos);
+    }
+    private double basicGetDouble(int pos) {
+      return Double.longBitsToDouble(basicGetLong(pos));
+    }
+
+    @Override
+    public boolean hasArray() {
+      return false;
+    }
+
+    @Override
+    public byte[] array() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int arrayOffset() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ByteSource duplicate() {
+      return new OffHeapByteSource(this);
+    }
+
+    @Override
+    public ByteSource slice(int length) {
+      if (length < 0) {
+        throw new IllegalArgumentException();
+      }
+      return slice(this.position, this.position + length);
+    }
+
+    @Override
+    public ByteSource slice(int pos, int limit) {
+      if ((limit > capacity()) || (limit < 0)) {
+        throw new IllegalArgumentException();
+      }
+      if ((pos > limit) || (pos < 0)) {
+        throw new IllegalArgumentException();
+      }
+      return new OffHeapByteSource(this.chunk.slice(pos, limit));
+    }
+
+    @Override
+    public void sendTo(ByteBuffer out) {
+      int len = remaining();
+      while (len > 0) {
+        out.put(get());
+        len--;
+      }
+      // We will not even create an instance of this class if createByteBuffer works on this platform.
+//      if (len > 0) {
+//        ByteBuffer bb = this.chunk.createByteBuffer();
+//        bb.position(position());
+//        bb.limit(limit());
+//        out.put(bb);
+//        position(limit());
+//      }
+    }
+    
+    @Override
+    public void sendTo(DataOutput out) throws IOException {
+      int len = remaining();
+      while (len > 0) {
+        out.writeByte(get());
+        len--;
+      }
+    }
+    @Override
+    public ByteBuffer getBackingByteBuffer() {
+      return null;
+    }
+  }
+  
+  private ByteSource buffer;
-  public final void setBuffer(ByteBuffer buffer) {
+  public ByteBufferInputStream(Chunk blob) {
+    this.buffer = ByteSourceFactory.create(blob);
+  }
+
+  public final void setBuffer(ByteSource buffer) {
-
+  
+  public final void setBuffer(ByteBuffer bb) {
+    if (bb == null) {
+      throw new NullPointerException();
+    }
+    setBuffer(ByteSourceFactory.create(bb));
+  }
+  
-  @Override
-  public boolean markSupported() {
-    return true;
-  }
-
-  @Override
-  public void mark(int limit) {
-    this.buffer.mark();
-  }
-
-  @Override
-  public void reset() {
-    this.buffer.reset();
-  }
+  // GemFire does not use mark or reset so I changed this class
+  // to just inherit from InputStream which does not support mark/reset.
+  // That way we do not need to add support for them to the new ByteSource class.
+  
+//  @Override
+//  public boolean markSupported() {
+//    return true;
+//  }
+//
+//  @Override
+//  public void mark(int limit) {
+//    this.buffer.mark();
+//  }
+//
+//  @Override
+//  public void reset() {
+//    this.buffer.reset();
+//  }
-    byte[] bytes;
-    int offset;
-    int len = size();
-    if (this.buffer.hasArray()) {
-      bytes = this.buffer.array();
-      offset = this.buffer.arrayOffset();
-    } else {
-      this.buffer.position(0);
-      bytes = new byte[len];
-      offset = 0;
-      this.buffer.get(bytes);
-    }
-    out.write(bytes, offset, len);
-  }
+    this.buffer.position(0);
+    this.buffer.sendTo(out);
+ }
-    out.put(this.buffer);
+    this.buffer.sendTo(out);
-  public ByteBuffer slice() {
-    return this.buffer.slice();
+  public ByteSource slice(int length) {
+    return this.buffer.slice(length);
-  public ByteBuffer slice(int startOffset, int endOffset) {
-    // We make a duplicate so we will have our own position, limit, and mark
-    ByteBuffer bb = this.buffer.duplicate();
-    bb.position(startOffset);
-    bb.limit(endOffset);
-    return bb.slice();
+  public ByteSource slice(int startOffset, int endOffset) {
+    return this.buffer.slice(startOffset, endOffset);
-      this.buffer = ByteBuffer.wrap(bytes, position, limit-position);
+      setBuffer(ByteBuffer.wrap(bytes, position, limit-position));
-  public ByteBuffer getBuffer() {
+  public ByteSource getBuffer() {
-  
-  

Merge branch 'release/1.4.0'

+import java.io.ByteArrayInputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.function.Function;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.internal.cache.lru.Sizeable;
+import org.apache.geode.internal.cache.entries.OffHeapRegionEntry;
+import org.apache.geode.internal.size.Sizeable;
-import org.apache.logging.log4j.Logger;
-
-import java.io.ByteArrayInputStream;
-import java.io.DataInput;
-import java.io.DataInputStream;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.util.function.Function;
-  public final static Object SUSPECT_TOKEN = new Object();
+  public static final Object SUSPECT_TOKEN = new Object();
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-      Object ov = basicGetOldValue();
-      if (ov == null) {
-        return null;
-      } else if (ov == Token.NOT_AVAILABLE) {
-        return AbstractRegion.handleNotAvailable(ov);
-      }
-      boolean doCopyOnRead = getRegion().isCopyOnRead();
+      Object ov = handleNotAvailableOldValue();
+        boolean doCopyOnRead = getRegion().isCopyOnRead();
+   * returns the old value after handling one this is NOT_AVAILABLE. If the old value is
+   * NOT_AVAILABLE then it may try to read it from disk. If it can't read an unavailable old value
+   * from disk then it will return null instead of NOT_AVAILABLE.
+   */
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
+  private Object handleNotAvailableOldValue() {
+    @Unretained
+    Object result = basicGetOldValue();
+    if (result != Token.NOT_AVAILABLE) {
+      return result;
+    }
+    if (getReadOldValueFromDisk()) {
+      try {
+        result = this.region.getValueInVMOrDiskWithoutFaultIn(getKey());
+      } catch (EntryNotFoundException ex) {
+        result = null;
+      }
+    }
+    result = AbstractRegion.handleNotAvailable(result);
+    return result;
+  }
+
+  /**
+   * If true then when getOldValue is called if the NOT_AVAILABLE is found then an attempt will be
+   * made to read the old value from disk without faulting it in. Should only be set to true when
+   * product is calling a method on a CacheWriter.
+   */
+  private boolean readOldValueFromDisk;
+
+  public boolean getReadOldValueFromDisk() {
+    return this.readOldValueFromDisk;
+  }
+
+  public void setReadOldValueFromDisk(boolean v) {
+    this.readOldValueFromDisk = v;
+  }
+
+  /**
-   * 
+   *
-  private void basicSetOldValue(@Unretained(ENTRY_EVENT_OLD_VALUE) Object v) {
+  void basicSetOldValue(@Unretained(ENTRY_EVENT_OLD_VALUE) Object v) {
-    if (v == curOldValue)
+    if (v == curOldValue) {
+    }
-    if (v == this.oldValue)
+    if (v == this.oldValue) {
-
+    }
-  private Object basicGetOldValue() {
+  Object basicGetOldValue() {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-   * 
+   *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  protected boolean areOldValuesEnabled() {
+    return EVENT_OLD_VALUE;
+  }
-   * 
+   *
-        if (requireOldValue || EVENT_OLD_VALUE || this.region instanceof HARegion // fix for bug
-                                                                                  // 37909
+        if (requireOldValue || areOldValuesEnabled() || this.region instanceof HARegion // fix for
+                                                                                        // bug
+        // 37909
-            ov = reentry._getValueRetain(owner, true);
+            ov = reentry.getValueRetain(owner, true);
-            ov = reentry._getValueRetain(owner, true);
+            ov = reentry.getValueRetain(owner, true);
-      if (mustBeAvailable || oldVal == null || EVENT_OLD_VALUE) {
+      if (mustBeAvailable || oldVal == null || areOldValuesEnabled()) {
-  /** @return false if entry doesn't exist */
-  public boolean setOldValueFromRegion() {
+  public void setOldValueFromRegion() {
-      if (re == null)
-        return false;
+      if (re == null) {
+        return;
+      }
-      Object v = re._getValueRetain(this.region, true);
+      Object v = re.getValueRetain(this.region, true);
+      if (v == null) {
+        v = Token.NOT_AVAILABLE;
+      }
-        return setOldValue(v);
+        setOldValue(v);
-      return false;
-  /**
-   * @return false if value 'v' indicates that entry does not exist
-   */
-  public boolean setOldValue(Object v) {
-    return setOldValue(v, false);
+  public void setOldValue(Object v) {
+    setOldValue(v, false);
-   * @param force true if the old value should be forcibly set, used for HARegions, methods like
-   *        putIfAbsent, etc., where the old value must be available.
-   * @return false if value 'v' indicates that entry does not exist
+   * @param force true if the old value should be forcibly set, methods like putIfAbsent, etc.,
+   *        where the old value must be available.
-  public boolean setOldValue(Object v, boolean force) {
-    if (v == null || Token.isRemoved(v)) {
-      return false;
-    } else {
-      if (Token.isInvalid(v)) {
+  public void setOldValue(Object v, boolean force) {
+    if (v != null) {
+      if (Token.isInvalidOrRemoved(v)) {
-      } else {
-        if (force || (this.region instanceof HARegion) // fix for bug 37909
-        ) {
-          // set oldValue to "v".
-        } else if (EVENT_OLD_VALUE) {
-          // TODO Rusty add compression support here
-          // set oldValue to "v".
-        } else {
-          v = Token.NOT_AVAILABLE;
-        }
+      } else if (shouldOldValueBeUnavailable(v, force)) {
+        v = Token.NOT_AVAILABLE;
-      retainAndSetOldValue(v);
-      return true;
+    retainAndSetOldValue(v);
+  }
+
+  private boolean shouldOldValueBeUnavailable(Object v, boolean force) {
+    if (force) {
+      return false;
+    }
+    if (areOldValuesEnabled()) {
+      return false;
+    }
+    if (this.region instanceof HARegion) {
+      return false;
+    }
+    return true;
-   * 
+   *
+        ov = AbstractRegion.handleNotAvailable(ov);
-  private static abstract class EventFlags {
+  private abstract static class EventFlags {
-   * 
+   *
-  void invokeCallbacks(LocalRegion rgn, boolean skipListeners, boolean notifyGateways) {
+  public void invokeCallbacks(InternalRegion rgn, boolean skipListeners, boolean notifyGateways) {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *

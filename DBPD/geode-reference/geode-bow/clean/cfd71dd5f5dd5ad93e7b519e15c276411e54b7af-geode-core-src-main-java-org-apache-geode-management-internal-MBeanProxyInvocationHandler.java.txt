GEODE-6682: Create unit tests for MBeanProxyInvocationHandler (#4213)

Create MBeanProxyInvocationHandlerTest

Cleanup related management classes:
* MBeanProxyInvocationHandler
* MXBeanProxyInvocationHandler
* OpenTypeUtil
* OpenTypeConverter
-import java.beans.IntrospectionException;
+import java.io.InvalidObjectException;
+import javax.management.ListenerNotFoundException;
+import javax.management.openmbean.OpenDataException;
+import org.apache.geode.annotations.VisibleForTesting;
-
-
- *
- *
-
-
-  /**
-   * Name of the MBean
-   */
-  private ObjectName objectName;
-
-  /**
-   * The monitoring region where this Object resides.
-   */
-  private Region<String, Object> monitoringRegion;
-
-  /**
-   * The member to which this proxy belongs
-   */
-
-  private DistributedMember member;
-
-
-  /**
-   * emitter is a helper class for sending notifications on behalf of the proxy
-   */
+  private final ObjectName objectName;
+  private final Region<String, Object> monitoringRegion;
+  private final DistributedMember member;
-
+  private final boolean isMXBean;
-  private boolean isMXBean;
+  private MXBeanProxyInvocationHandler mxBeanProxyInvocationHandler;
-  private MXBeanProxyInvocationHandler mxbeanInvocationRef;
-
-
-
-  /**
-   *
-   * @param member member to which this MBean belongs
-   * @param monitoringRegion corresponding MonitoringRegion
-   * @param objectName ObjectName of the MBean
-   * @param interfaceClass on which interface the proxy to be exposed
-   */
-  public static Object newProxyInstance(DistributedMember member,
-      Region<String, Object> monitoringRegion, ObjectName objectName,
-      FederationComponent federationComponent, Class interfaceClass)
-      throws ClassNotFoundException, IntrospectionException {
+  static Object newProxyInstance(DistributedMember member, Region<String, Object> monitoringRegion,
+      ObjectName objectName, FederationComponent federationComponent, Class interfaceClass) {
-    InvocationHandler handler =
+    InvocationHandler invocationHandler =
-
-        interfaces, handler);
+        interfaces, invocationHandler);
-  /**
-   *
-   * @param member member to which this MBean belongs
-   * @param objectName ObjectName of the MBean
-   * @param monitoringRegion corresponding MonitoringRegion
-   */
-      Region<String, Object> monitoringRegion, boolean isMXBean)
-      throws IntrospectionException, ClassNotFoundException {
+      Region<String, Object> monitoringRegion, boolean isMXBean) {
+    this(member, objectName, monitoringRegion, isMXBean, new NotificationBroadcasterSupport(),
+        new ProxyInterfaceImpl());
+  }
+
+  @VisibleForTesting
+  MBeanProxyInvocationHandler(DistributedMember member, ObjectName objectName,
+      Region<String, Object> monitoringRegion, boolean isMXBean,
+      NotificationBroadcasterSupport emitter, ProxyInterface proxyImpl) {
-    this.emitter = new NotificationBroadcasterSupport();
-    this.proxyImpl = new ProxyInterfaceImpl();
-
+    this.emitter = emitter;
+    this.proxyImpl = proxyImpl;
+   * <p>
-   * Notification emmitter methods are also delegated to the function service
+   * <p>
+   * Notification emitter methods are also delegated to the function service
-  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-
+  public Object invoke(Object proxy, Method method, Object[] arguments)
+      throws MBeanException, ListenerNotFoundException, InvalidObjectException, OpenDataException {
-    final Class methodClass = method.getDeclaringClass();
-
-
+    Class methodClass = method.getDeclaringClass();
-        || methodClass.equals(NotificationEmitter.class))
-      return invokeBroadcasterMethod(proxy, method, args);
+        || methodClass.equals(NotificationEmitter.class)) {
+      return invokeBroadcasterMethod(method, arguments);
+    }
-    final String methodName = method.getName();
-    final Class[] paramTypes = method.getParameterTypes();
-    final Class returnType = method.getReturnType();
+    String methodName = method.getName();
+    Class[] parameterTypes = method.getParameterTypes();
+    Class returnType = method.getReturnType();
-
-
-    final int nargs = (args == null) ? 0 : args.length;
+    int argumentCount = arguments == null ? 0 : arguments.length;
-      proxyImpl.setLastRefreshedTime((Long) args[0]);
+      proxyImpl.setLastRefreshedTime((Long) arguments[0]);
-
-      sendNotification(args[0]);
+      sendNotification(arguments[0]);
-    if (shouldDoLocally(proxy, method)) {
-      return doLocally(proxy, method, args);
+    if (shouldDoLocally(method)) {
+      return doLocally(method, arguments);
-      return p.invoke(proxy, method, args);
+      return p.invoke(proxy, method, arguments);
-    if (methodName.startsWith("get") && methodName.length() > 3 && nargs == 0
+    if (methodName.startsWith("get") && methodName.length() > 3 && argumentCount == 0
-    if (methodName.startsWith("is") && methodName.length() > 2 && nargs == 0
+    if (methodName.startsWith("is") && methodName.length() > 2 && argumentCount == 0
-    final String[] signature = new String[paramTypes.length];
-    for (int i = 0; i < paramTypes.length; i++)
-      signature[i] = paramTypes[i].getName();
-
-    if (methodName.startsWith("set") && methodName.length() > 3 && nargs == 1
-        && returnType.equals(Void.TYPE)) {
-      return delegateToFucntionService(objectName, methodName, args, signature);
-
+    String[] signature = new String[parameterTypes.length];
+    for (int i = 0; i < parameterTypes.length; i++) {
+      signature[i] = parameterTypes[i].getName();
-    return delegateToFucntionService(objectName, methodName, args, signature);
-
-  }
-
-
-
-  /**
-   * As this proxy may behave as an notification emitter it delegates to the member
-   * NotificationBroadcasterSupport object
-   *
-   */
-  private void sendNotification(Object notification) {
-    emitter.sendNotification((Notification) notification);
+    return delegateToFunctionService(objectName, methodName, arguments, signature);
-   * FederataionComponent being the carrier.
-   *
+   * FederationComponent being the carrier.
-  protected Object delegateToObjectState(String attributeName) throws Throwable {
-
-
-    Object returnObj;
+  Object delegateToObjectState(String attributeName) throws MBeanException {
-      FederationComponent fedComp =
+      FederationComponent federation =
-      returnObj = fedComp.getValue(attributeName);
-    } catch (IllegalArgumentException e) {
-      throw new MBeanException(e);
+      return federation.getValue(attributeName);
-    } catch (Throwable th) {
+    } catch (Throwable t) {
-      throw new MBeanException(new Exception(th.getLocalizedMessage()));
+      throw new MBeanException(new Exception(t.getLocalizedMessage()));
-    return returnObj;
-   *
-   * @param objectName ObjectName of the MBean
-   * @param methodName method name
-   * @param args arguments to the methods
-   * @param signature signature of the method
-   * @return result Object
-  protected Object delegateToFucntionService(ObjectName objectName, String methodName,
-      Object[] args, String[] signature) throws Throwable {
+  Object delegateToFunctionService(ObjectName objectName, String methodName, Object[] arguments,
+      String[] signature) throws MBeanException {
+    Object[] functionArguments = new Object[5];
+    functionArguments[0] = objectName;
+    functionArguments[1] = methodName;
+    functionArguments[2] = signature;
+    functionArguments[3] = arguments;
+    functionArguments[4] = member.getName();
-    Object[] functionArgs = new Object[5];
-    functionArgs[0] = objectName;
-    functionArgs[1] = methodName;
-    functionArgs[2] = signature;
-    functionArgs[3] = args;
-    functionArgs[4] = member.getName();
-    List<Object> result = null;
+    List<Object> result;
-
-      ResultCollector rc = FunctionService.onMember(member).setArguments(functionArgs)
+      ResultCollector resultCollector = FunctionService.onMember(member)
+          .setArguments(functionArguments)
-      result = (List<Object>) rc.getResult();
-      // Exceptions of ManagementFunctions
-
-
+      result = (List<Object>) resultCollector.getResult();
-        logger.debug(" Exception while Executing Funtion {}", e.getMessage(), e);
+        logger.debug(" Exception while Executing Function {}", e.getMessage(), e);
-    } catch (Throwable th) {
+    } catch (Throwable t) {
-        logger.debug(" Exception while Executing Funtion {}", th.getMessage(), th);
+        logger.debug(" Error while Executing Function {}", t.getMessage(), t);
-
-  private Object checkErrors(Object lastResult) throws Throwable {
+  /**
+   * As this proxy may behave as an notification emitter it delegates to the member
+   * NotificationBroadcasterSupport object
+   */
+  private void sendNotification(Object notification) {
+    emitter.sendNotification((Notification) notification);
+  }
-
+  private Object checkErrors(Object lastResult) throws MBeanException {
-      throw (Exception) lastResult;
+      throw (MBeanException) lastResult;
-
+   * <p>
-   *
-   * @param proxy the proxy object
-   * @param method method to be invoked
-   * @param args method arguments
-   * @return result value if any
-  private Object invokeBroadcasterMethod(Object proxy, Method method, Object[] args)
-      throws Throwable {
-    final String methodName = method.getName();
-    final int nargs = (args == null) ? 0 : args.length;
+  private Object invokeBroadcasterMethod(Method method, Object[] arguments)
+      throws MBeanException, ListenerNotFoundException {
+    String methodName = method.getName();
+    int argumentCount = arguments == null ? 0 : arguments.length;
-    final Class[] paramTypes = method.getParameterTypes();
-    final String[] signature = new String[paramTypes.length];
+    Class[] parameterTypes = method.getParameterTypes();
+    String[] signature = new String[parameterTypes.length];
-    if (methodName.equals("addNotificationListener")) {
+    switch (methodName) {
+      case "addNotificationListener": {
+        // The various throws of IllegalArgumentException here should not happen, since we know what
+        // the methods in NotificationBroadcaster and NotificationEmitter are.
-      /*
-       * The various throws of IllegalArgumentException here should not happen, since we know what
-       * the methods in NotificationBroadcaster and NotificationEmitter are.
-       */
+        if (argumentCount != 3) {
+          throw new IllegalArgumentException(
+              "Bad arg count to addNotificationListener: " + argumentCount);
+        }
-      if (nargs != 3) {
-        final String msg = "Bad arg count to addNotificationListener: " + nargs;
-        throw new IllegalArgumentException(msg);
-      }
-      /*
-       * Other inconsistencies will produce ClassCastException below.
-       */
+        // Other inconsistencies will produce ClassCastException below.
-      NotificationListener listener = (NotificationListener) args[0];
-      NotificationFilter filter = (NotificationFilter) args[1];
-      Object handback = args[2];
-      emitter.addNotificationListener(listener, filter, handback);
-      delegateToFucntionService(objectName, methodName, null, signature);
-      return null;
-
-    } else if (methodName.equals("removeNotificationListener")) {
-      /*
-       * NullPointerException if method with no args, but that shouldn't happen because removeNL
-       * does have args.
-       */
-      NotificationListener listener = (NotificationListener) args[0];
-
-      switch (nargs) {
-        case 1:
-          emitter.removeNotificationListener(listener);
-          /**
-           * No need to send listener and filter details to other members. We only need to send a
-           * message saying remove the listner registered for this object on your side. Fixes Bug[
-           * #47075 ]
-           */
-          delegateToFucntionService(objectName, methodName, null, signature);
-          return null;
-
-        case 3:
-          NotificationFilter filter = (NotificationFilter) args[1];
-          Object handback = args[2];
-          emitter.removeNotificationListener(listener, filter, handback);
-
-          delegateToFucntionService(objectName, methodName, null, signature);
-          return null;
-
-        default:
-          final String msg = "Bad arg count to removeNotificationListener: " + nargs;
-          throw new IllegalArgumentException(msg);
+        NotificationListener listener = (NotificationListener) arguments[0];
+        NotificationFilter filter = (NotificationFilter) arguments[1];
+        Object handback = arguments[2];
+        emitter.addNotificationListener(listener, filter, handback);
+        delegateToFunctionService(objectName, methodName, null, signature);
+        return null;
-    } else if (methodName.equals("getNotificationInfo")) {
+      case "removeNotificationListener": {
+        // NullPointerException if method with no args, but that shouldn't happen because
+        // removeNotificationListener does have args.
+        NotificationListener listener = (NotificationListener) arguments[0];
-      if (args != null) {
-        throw new IllegalArgumentException("getNotificationInfo has " + "args");
+        switch (argumentCount) {
+          case 1:
+            emitter.removeNotificationListener(listener);
+
+            // No need to send listener and filter details to other members. We only need to send a
+            // message saying remove the listener registered for this object on your side.
+
+            delegateToFunctionService(objectName, methodName, null, signature);
+            return null;
+
+          case 3:
+            NotificationFilter filter = (NotificationFilter) arguments[1];
+            Object handback = arguments[2];
+            emitter.removeNotificationListener(listener, filter, handback);
+
+            delegateToFunctionService(objectName, methodName, null, signature);
+            return null;
+
+          default:
+            throw new IllegalArgumentException(
+                "Bad arg count to removeNotificationListener: " + argumentCount);
+        }
-      if (!MBeanJMXAdapter.mbeanServer.isRegistered(objectName)) {
-        return new MBeanNotificationInfo[0];
-      }
+      case "getNotificationInfo":
+        if (arguments != null) {
+          throw new IllegalArgumentException("getNotificationInfo has " + "args");
+        }
-      /**
-       * MBean info is delegated to function service as intention is to get the info of the actual
-       * mbean rather than the proxy
-       */
+        if (!MBeanJMXAdapter.mbeanServer.isRegistered(objectName)) {
+          return new MBeanNotificationInfo[0];
+        }
+        // MBean info is delegated to function service as intention is to get the info of the actual
+        // mbean rather than the proxy
-      Object obj = delegateToFucntionService(objectName, methodName, args, signature);
-      if (obj instanceof String) {
-        return new MBeanNotificationInfo[0];
-      }
-      MBeanInfo info = (MBeanInfo) obj;
-      return info.getNotifications();
+        Object obj = delegateToFunctionService(objectName, methodName, arguments, signature);
+        if (obj instanceof String) {
+          return new MBeanNotificationInfo[0];
+        }
+        MBeanInfo info = (MBeanInfo) obj;
+        return info.getNotifications();
-    } else {
-      throw new IllegalArgumentException("Bad method name: " + methodName);
+      default:
+        throw new IllegalArgumentException("Bad method name: " + methodName);
+  private boolean shouldDoLocally(Method method) {
+    String methodName = method.getName();
+    if ((methodName.equals("hashCode") || methodName.equals("toString"))
+        && method.getParameterTypes().length == 0) {
+      return true;
+    }
+    return methodName.equals("equals")
+        && Arrays.equals(method.getParameterTypes(), new Class[] {Object.class});
+  }
+  private Object doLocally(Method method, Object[] arguments) {
+    String methodName = method.getName();
+    FederationComponent federation =
+        (FederationComponent) monitoringRegion.get(objectName.toString());
+
+    switch (methodName) {
+      case "equals":
+        return federation.equals(arguments[0]);
+      case "toString":
+        return federation.toString();
+      case "hashCode":
+        return federation.hashCode();
+    }
+
+    throw new IllegalArgumentException("Unexpected method name: " + methodName);
+  }
+
+  private MXBeanProxyInvocationHandler findMXBeanProxy(ObjectName objectName,
+      Class<?> mbeanInterface, MBeanProxyInvocationHandler handler) {
+    if (mxBeanProxyInvocationHandler == null) {
+      synchronized (this) {
+        try {
+          mxBeanProxyInvocationHandler =
+              new MXBeanProxyInvocationHandler(objectName, mbeanInterface, handler);
+        } catch (IllegalArgumentException e) {
+          String message =
+              "Cannot make MXBean proxy for " + mbeanInterface.getName() + ": " + e.getMessage();
+          throw new IllegalArgumentException(message, e.getCause());
+        }
+      }
+    }
+    return mxBeanProxyInvocationHandler;
+  }
-   *
-   *
-  private class ProxyInterfaceImpl implements ProxyInterface {
-    /**
-     * last refreshed time of the proxy
-     */
-    private long lastRefreshedTime;
+  private static class ProxyInterfaceImpl implements ProxyInterface {
-    /**
-     * Constructore
-     */
-    public ProxyInterfaceImpl() {
-      this.lastRefreshedTime = System.currentTimeMillis();
+    private volatile long lastRefreshedTime;
+
+    private ProxyInterfaceImpl() {
+      lastRefreshedTime = System.currentTimeMillis();
-    /**
-     * Last refreshed time
-     */
-    /**
-     * sets the proxy refresh time
-     */
-
-
-  private boolean shouldDoLocally(Object proxy, Method method) {
-    final String methodName = method.getName();
-    if ((methodName.equals("hashCode") || methodName.equals("toString"))
-        && method.getParameterTypes().length == 0)
-      return true;
-    if (methodName.equals("equals")
-        && Arrays.equals(method.getParameterTypes(), new Class[] {Object.class}))
-      return true;
-    return false;
-  }
-
-  private Object doLocally(Object proxy, Method method, Object[] args) {
-    final String methodName = method.getName();
-    FederationComponent fedComp = (FederationComponent) monitoringRegion.get(objectName.toString());
-    if (methodName.equals("equals")) {
-
-      return fedComp.equals(args[0]);
-
-    } else if (methodName.equals("toString")) {
-      return fedComp.toString();
-    } else if (methodName.equals("hashCode")) {
-      return fedComp.hashCode();
-    }
-
-    throw new RuntimeException("Unexpected method name: " + methodName);
-  }
-
-  private MXBeanProxyInvocationHandler findMXBeanProxy(ObjectName objectName,
-      Class<?> mxbeanInterface, MBeanProxyInvocationHandler handler) throws Throwable {
-    MXBeanProxyInvocationHandler proxyRef = mxbeanInvocationRef;
-
-    if (mxbeanInvocationRef == null) {
-      synchronized (this) {
-        try {
-          mxbeanInvocationRef =
-              new MXBeanProxyInvocationHandler(objectName, mxbeanInterface, handler);
-        } catch (IllegalArgumentException e) {
-          String msg =
-              "Cannot make MXBean proxy for " + mxbeanInterface.getName() + ": " + e.getMessage();
-          throw new IllegalArgumentException(msg, e.getCause());
-        }
-
-      }
-
-    }
-    return mxbeanInvocationRef;
-  }
-

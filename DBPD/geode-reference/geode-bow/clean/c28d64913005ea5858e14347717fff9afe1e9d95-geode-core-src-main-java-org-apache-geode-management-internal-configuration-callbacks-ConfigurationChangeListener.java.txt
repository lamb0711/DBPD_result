Merge branch 'release/1.4.0'

-import org.apache.commons.io.FileUtils;
-import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.cache.EntryEvent;
-import org.apache.geode.cache.util.CacheListenerAdapter;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.management.internal.configuration.domain.Configuration;
-
+import java.util.Optional;
+import org.apache.commons.io.FileUtils;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.EntryEvent;
+import org.apache.geode.cache.GemFireCache;
+import org.apache.geode.cache.util.CacheListenerAdapter;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.management.internal.configuration.domain.Configuration;
+
+  // Don't process the event locally. The action of adding or removing a jar should already have
+  // been performed by DeployCommand or UndeployCommand.
-    addOrRemoveJarFromFilesystem(event);
+    if (event.isOriginRemote()) {
+      addOrRemoveJarFromFilesystem(event);
+    }
-    addOrRemoveJarFromFilesystem(event);
+    if (event.isOriginRemote()) {
+      addOrRemoveJarFromFilesystem(event);
+    }
-  // when a new jar is added, if it does not exist in the current locator, download it from
-  // another locator.
-  // when a jar is removed, if it exists in the current locator, remove it.
+  // Here we first remove any jars which are not used anymore and then we re-add all of the
+  // necessary jars again. This may appear a bit blunt but it also accounts for the situation
+  // where a jar is only being updated - i.e. the name does not change, only the content.
-    Configuration newConfig = (Configuration) event.getNewValue();
-    Configuration oldConfig = (Configuration) event.getOldValue();
+    Configuration newConfig = event.getNewValue();
+    Configuration oldConfig = event.getOldValue();
-    Set<String> jarsAdded = new HashSet<>(newJars);
+
-
-    jarsAdded.removeAll(oldJars);
-    if (!jarsAdded.isEmpty() && !jarsRemoved.isEmpty()) {
-      throw new IllegalStateException(
-          "We don't expect to have jars both added and removed in one event");
-    }
-
-    for (String jarAdded : jarsAdded) {
-      if (!jarExistsInFilesystem(group, jarAdded)) {
-        try {
-          sharedConfig.downloadJarFromOtherLocators(group, jarAdded);
-        } catch (Exception e) {
-          logger.error("Unable to add jar: " + jarAdded, e);
-        }
-      }
-    }
-
+
+    String triggerMemberId = (String) event.getCallbackArgument();
+    DistributedMember locator = getDistributedMember(triggerMemberId);
+    for (String jarAdded : newJars) {
+      try {
+        sharedConfig.downloadJarFromLocator(group, jarAdded, locator);
+      } catch (Exception e) {
+        logger.error("Unable to add jar: " + jarAdded, e);
+      }
+    }
-  private boolean jarExistsInFilesystem(String groupName, String jarName) {
-    return sharedConfig.getPathToJarOnThisLocator(groupName, jarName).toFile().exists();
-  }
+  private DistributedMember getDistributedMember(String memberName) {
+    InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();
+    Set<DistributedMember> locators = new HashSet<>(
+        cache.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration().keySet());
+    Optional<DistributedMember> locator =
+        locators.stream().filter(x -> x.getId().equals(memberName)).findFirst();
+    return locator.get();
+  }

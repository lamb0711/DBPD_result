Merge branch 'release/1.8.0'

-import java.util.concurrent.ThreadFactory;
-import org.apache.geode.internal.ScheduledThreadPoolExecutorWithKeepAlive;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
-          LocalizedStrings.PoolImpl_DISTRIBUTED_SYSTEM_MUST_BE_CREATED_BEFORE_CREATING_POOL
-              .toLocalizedString());
+          "Distributed System must be created before creating pool");
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PoolImpl_STATISTIC_SAMPLING_MUST_BE_ENABLED_FOR_SAMPLING_RATE_OF_0_TO_TAKE_AFFECT,
-          this.statisticInterval));
+      logger.info("statistic-sampling must be enabled for sampling rate of {} to take affect",
+          this.statisticInterval);
-    backgroundProcessor = new ScheduledThreadPoolExecutorWithKeepAlive(BACKGROUND_TASK_POOL_SIZE,
-        BACKGROUND_TASK_POOL_KEEP_ALIVE, TimeUnit.MILLISECONDS, new ThreadFactory() {
-          AtomicInteger threadNum = new AtomicInteger();
-
-          public Thread newThread(final Runnable r) {
-            Thread result = new Thread(r, timerName + threadNum.incrementAndGet());
-            result.setDaemon(true);
-            return result;
-          }
-        }, this.threadMonitoring);
-    ((ScheduledThreadPoolExecutorWithKeepAlive) backgroundProcessor)
-        .setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
-    ((ScheduledThreadPoolExecutorWithKeepAlive) backgroundProcessor)
-        .setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
-
+    backgroundProcessor = LoggingExecutors.newScheduledThreadPool(timerName,
+        BACKGROUND_TASK_POOL_SIZE, BACKGROUND_TASK_POOL_KEEP_ALIVE, threadMonitoring);
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.PoolImpl_POOL_0_STARTED_WITH_MULTIUSER_SECURE_MODE_ENABLED_1,
-        new Object[] {this.name, this.multiuserSecureModeEnabled}));
+    logger.info("Pool {} started with multiuser-authentication={}",
+        new Object[] {this.name, this.multiuserSecureModeEnabled});
-                    LocalizedStrings.PoolImpl_CACHE_MUST_BE_CREATED_BEFORE_CREATING_POOL
-                        .toLocalizedString());
+                    "Cache must be created before creating pool");
-            LocalizedStrings.PoolImpl_POOL_COULD_NOT_BE_DESTROYED_BECAUSE_IT_IS_STILL_IN_USE_BY_0_REGIONS
-                .toLocalizedString(cnt));
+            String.format("Pool could not be destroyed because it is still in use by %s regions",
+                cnt));
-      logger.info(
-          LocalizedMessage.create(LocalizedStrings.PoolImpl_DESTROYING_CONNECTION_POOL_0, name));
+      logger.info("Destroying connection pool {}", name);
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
+            logger.warn("Timeout waiting for background tasks to complete.");
-        logger.error(LocalizedMessage.create(
-            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_BACKGROUNDPROCESSOR), e);
+        logger.error("Error encountered while stopping backgroundProcessor.", e);
-        logger.error(LocalizedMessage
-            .create(LocalizedStrings.PoolImpl_INTERRUPTED_WHILE_STOPPING_BACKGROUNDPROCESSOR), e);
+        logger.error("Interrupted while stopping backgroundProcessor", e);
-        logger.error(LocalizedMessage.create(
-            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_SOURCE), e);
+        logger.error("Error encountered while stopping connection source.", e);
-            LocalizedMessage.create(
-                LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_SUBSCRIPTION_MANAGER),
+            "Error encountered while stopping subscription manager",
-        logger.error(LocalizedMessage.create(
-            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_MANAGER), e);
+        logger.error("Error encountered while stopping connection manager.", e);
-        logger.error(LocalizedMessage.create(
-            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_ENDPOINT_MANAGER), e);
+        logger.error("Error encountered while stopping endpoint manager", e);
-        logger.error(
-            LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_WHILE_CLOSING_STATISTICS), e);
+        logger.error("Error while closing statistics", e);
-          LocalizedStrings.PoolImpl__0_IS_NOT_THE_SAME_AS_1_BECAUSE_IT_SHOULD_HAVE_BEEN_A_POOLIMPL
-              .toLocalizedString(new Object[] {this, obj}));
+          String.format("%s is not the same as %s because it should have been a PoolImpl",
+              new Object[] {this, obj}));
-          LocalizedStrings.PoolImpl_0_ARE_DIFFERENT.toLocalizedString("names"));
+          String.format("Pool %s are different", "names"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("socketConnectimeout"));
+          String.format("Pool %s is different", "socketConnectimeout"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("connectionTimeout"));
+          String.format("Pool %s is different", "connectionTimeout"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("connectionLifetime"));
+          String.format("Pool %s is different", "connectionLifetime"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("socketBufferSize"));
+          String.format("Pool %s is different", "socketBufferSize"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("threadLocalConnections"));
+          String.format("Pool %s is different", "threadLocalConnections"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("readTimeout"));
+          String.format("Pool %s is different", "readTimeout"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("MinConnections"));
+          String.format("Pool %s is different", "MinConnections"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("MaxConnections"));
+          String.format("Pool %s is different", "MaxConnections"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("RetryAttempts"));
+          String.format("Pool %s is different", "RetryAttempts"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("IdleTimeout"));
+          String.format("Pool %s is different", "IdleTimeout"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("PingInterval"));
+          String.format("Pool %s is different", "PingInterval"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("StatisticInterval"));
+          String.format("Pool %s is different", "StatisticInterval"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("subscriptionAckInterval"));
+          String.format("Pool %s is different", "subscriptionAckInterval"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("subscriptionEnabled"));
+          String.format("Pool %s is different", "subscriptionEnabled"));
-      throw new RuntimeException(LocalizedStrings.PoolImpl_0_IS_DIFFERENT
-          .toLocalizedString("subscriptionMessageTrackingTimeout"));
+      throw new RuntimeException(String.format("Pool %s is different",
+          "subscriptionMessageTrackingTimeout"));
-      throw new RuntimeException(LocalizedStrings.PoolImpl_0_IS_DIFFERENT
-          .toLocalizedString("subscriptionRedundancyLevel"));
+      throw new RuntimeException(String.format("Pool %s is different",
+          "subscriptionRedundancyLevel"));
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("serverGroup"));
+          String.format("Pool %s is different", "serverGroup"));
-          LocalizedStrings.PoolImpl_0_ARE_DIFFERENT.toLocalizedString("locators"));
+          String.format("Pool %s are different", "locators"));
-          LocalizedStrings.PoolImpl_0_ARE_DIFFERENT.toLocalizedString("servers"));
+          String.format("Pool %s are different", "servers"));
-   * Test hook that returns an unnmodifiable list of the current blacklisted servers
+   * Test hook that returns an unnmodifiable list of the current denylisted servers
-  public Set getBlacklistedServers() {
-    return connectionFactory.getBlackList().getBadServers();
+  public Set getDenylistedServers() {
+    return connectionFactory.getDenyList().getBadServers();
-        logger.error(LocalizedMessage
-            .create(LocalizedStrings.PoolImpl_UNEXPECTED_ERROR_IN_POOL_TASK_0, this), t);
+        logger.error(String.format("Unexpected error in pool task <%s>", this), t);
-            LocalizedStrings.PoolImpl_CACHE_MUST_BE_CREATED_BEFORE_CREATING_POOL
-                .toLocalizedString());
+            "Cache must be created before creating pool");
-              LocalizedStrings.PoolImpl_CACHE_MUST_BE_CREATED_BEFORE_CREATING_POOL
-                  .toLocalizedString());
+              "Cache must be created before creating pool");
-                LocalizedStrings.PoolImpl_CACHE_MUST_BE_CREATED_BEFORE_CREATING_POOL
-                    .toLocalizedString());
+                "Cache must be created before creating pool");
-            LocalizedStrings.MultiUserSecurityEnabled_USE_POOL_API.toLocalizedString());
+            "Use Pool APIs for doing operations when multiuser-secure-mode-enabled is set to true.");
-            LocalizedStrings.MultiUserSecurityEnabled_USE_POOL_API.toLocalizedString());
+            "Use Pool APIs for doing operations when multiuser-secure-mode-enabled is set to true.");
-          LocalizedStrings.PoolManagerImpl_ONLY_DURABLE_CLIENTS_SHOULD_CALL_GETPENDINGEVENTCOUNT
-              .toLocalizedString());
+          "Only durable clients should call getPendingEventCount()");
-          LocalizedStrings.PoolManagerImpl_GETPENDINGEVENTCOUNT_SHOULD_BE_CALLED_BEFORE_INVOKING_READYFOREVENTS
-              .toLocalizedString());
+          "getPendingEventCount() should be called before invoking readyForEvents().");

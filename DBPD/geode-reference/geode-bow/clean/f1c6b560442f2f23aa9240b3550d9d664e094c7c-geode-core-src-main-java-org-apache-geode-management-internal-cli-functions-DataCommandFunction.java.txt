GEODE-5011: Convert 'Data' commands to ResultModel (#1945)


+import java.io.IOException;
-import java.util.concurrent.atomic.AtomicInteger;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
-import org.json.JSONArray;
-import org.apache.geode.cache.query.internal.StructImpl;
-import org.apache.geode.cache.query.internal.Undefined;
-import org.apache.geode.management.internal.cli.json.GfJsonException;
-import org.apache.geode.management.internal.cli.json.GfJsonObject;
+import org.apache.geode.pdx.JSONFormatter;
-    AtomicInteger nestedObjectCount = new AtomicInteger(0);
-        select_SelectResults((SelectResults) results, principal, list, nestedObjectCount, cache);
+        select_SelectResults((SelectResults) results, principal, list, cache);
-    } catch (FunctionDomainException | GfJsonException | QueryInvocationTargetException
-        | NameResolutionException | TypeMismatchException e) {
+    } catch (FunctionDomainException | QueryInvocationTargetException | NameResolutionException
+        | TypeMismatchException e) {
-    String str = toJson(results);
-    GfJsonObject jsonBean;
-    try {
-      jsonBean = new GfJsonObject(str);
-    } catch (GfJsonException e) {
-      logger.info("Exception occurred:", e);
-      jsonBean = new GfJsonObject();
-      try {
-        jsonBean.put("msg", e.getMessage());
-      } catch (GfJsonException e1) {
-        logger.warn("Ignored GfJsonException:", e1);
-      }
-    }
-    if (logger.isDebugEnabled()) {
-      logger.debug("BeanResults : Adding bean json string : {}", jsonBean);
-    }
-    list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_BEAN, jsonBean.toString()));
+    list.add(createSelectResultRow(results));
-      List<SelectResultRow> list, AtomicInteger nestedObjectCount, InternalCache cache)
-      throws GfJsonException {
+      List<SelectResultRow> list, InternalCache cache) {
-      if (object instanceof Struct) {
-        StructImpl impl = (StructImpl) object;
-        GfJsonObject jsonStruct = getJSONForStruct(impl, nestedObjectCount);
-        if (logger.isDebugEnabled()) {
-          logger.debug("SelectResults : Adding select json string : {}", jsonStruct);
-        }
-        list.add(
-            new SelectResultRow(DataCommandResult.ROW_TYPE_STRUCT_RESULT, jsonStruct.toString()));
-      } else if (JsonUtil.isPrimitiveOrWrapper(object.getClass())) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("SelectResults : Adding select primitive : {}", object);
-        }
-        list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_PRIMITIVE, object));
-      } else {
-        if (logger.isDebugEnabled()) {
-          logger.debug("SelectResults : Bean Results class is {}", object.getClass());
-        }
-        String str = toJson(object);
-        GfJsonObject jsonBean;
-        try {
-          jsonBean = new GfJsonObject(str);
-        } catch (GfJsonException e) {
-          logger.error(e.getMessage(), e);
-          jsonBean = new GfJsonObject();
-          try {
-            jsonBean.put("msg", e.getMessage());
-          } catch (GfJsonException e1) {
-            logger.warn("Ignored GfJsonException:", e1);
-          }
-        }
-        if (logger.isDebugEnabled()) {
-          logger.debug("SelectResults : Adding bean json string : {}", jsonBean);
-        }
-        list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_BEAN, jsonBean.toString()));
-      }
+      list.add(createSelectResultRow(object));
-  private String toJson(Object object) {
-    if (object instanceof Undefined) {
-      return "{\"Value\":\"UNDEFINED\"}";
-    } else if (object instanceof PdxInstance) {
-      return pdxToJson((PdxInstance) object);
+  private SelectResultRow createSelectResultRow(Object object) {
+    int rowType;
+    if (object instanceof Struct) {
+      rowType = DataCommandResult.ROW_TYPE_STRUCT_RESULT;
+    } else if (JsonUtil.isPrimitiveOrWrapper(object.getClass())) {
+      rowType = DataCommandResult.ROW_TYPE_PRIMITIVE;
-      return JsonUtil.objectToJsonNestedChkCDep(object, NESTED_JSON_LENGTH);
+      rowType = DataCommandResult.ROW_TYPE_BEAN;
-  }
-  private GfJsonObject getJSONForStruct(StructImpl impl, AtomicInteger ai) throws GfJsonException {
-    String fields[] = impl.getFieldNames();
-    Object[] values = impl.getFieldValues();
-    GfJsonObject jsonObject = new GfJsonObject();
-    for (int i = 0; i < fields.length; i++) {
-      Object value = values[i];
-      if (value != null) {
-        if (JsonUtil.isPrimitiveOrWrapper(value.getClass())) {
-          jsonObject.put(fields[i], value);
-        } else {
-          jsonObject.put(fields[i], toJson(value));
-        }
-      } else {
-        jsonObject.put(fields[i], "null");
-      }
-    }
-    return jsonObject;
+    return new SelectResultRow(rowType, object);
-          Object array[] = getJSONForNonPrimitiveObject(value);
+          Object array[] = getClassAndJson(value);
-        Object array[] = getJSONForNonPrimitiveObject(value);
+        Object array[] = getClassAndJson(value);
-        return DataCommandResult.createGetInfoResult(key, null, null,
+        return DataCommandResult.createGetInfoResult(key, getClassAndJson(null)[1], null,
-          keyInfo.addLocation(new Object[] {region.getFullPath(), true,
-              getJSONForNonPrimitiveObject(value)[1], isPrimary, "" + bucketId});
+          keyInfo.addLocation(new Object[] {region.getFullPath(), true, getClassAndJson(value)[1],
+              isPrimary, "" + bucketId});
-            keyInfo.addLocation(new Object[] {region.getFullPath(), true,
-                getJSONForNonPrimitiveObject(value)[1], false, null});
+            keyInfo.addLocation(
+                new Object[] {region.getFullPath(), true, getClassAndJson(value)[1], false, null});
-      Object array[] = getJSONForNonPrimitiveObject(returnValue);
+      Object array[] = getClassAndJson(returnValue);
-    if (JsonUtil.isPrimitiveOrWrapper(klass)) {
-      try {
-        if (klass.equals(Byte.class)) {
-          return Byte.parseByte(string);
-        } else if (klass.equals(Short.class)) {
-          return Short.parseShort(string);
-        } else if (klass.equals(Integer.class)) {
-          return Integer.parseInt(string);
-        } else if (klass.equals(Long.class)) {
-          return Long.parseLong(string);
-        } else if (klass.equals(Double.class)) {
-          return Double.parseDouble(string);
-        } else if (klass.equals(Boolean.class)) {
-          return Boolean.parseBoolean(string);
-        } else if (klass.equals(Float.class)) {
-          return Float.parseFloat(string);
-        }
-        return null;
-      } catch (NumberFormatException e) {
-        throw new IllegalArgumentException(
-            "Failed to convert input key to " + klassString + " Msg : " + e.getMessage());
-      }
+    Object resultObject;
+    try {
+      ObjectMapper mapper = new ObjectMapper();
+      mapper.enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);
+      resultObject = mapper.readValue(string, klass);
+    } catch (IOException e) {
+      throw new IllegalArgumentException(
+          "Failed to convert input key to " + klassString + " Msg : " + e.getMessage());
-    return getObjectFromJson(string, klass);
+    return resultObject;
-  @SuppressWarnings({"rawtypes"})
-  public static Object[] getJSONForNonPrimitiveObject(Object obj) {
+  private Object[] getClassAndJson(Object obj) {
+
-      array[1] = "<NULL>";
-      return array;
-    } else {
-      array[0] = obj.getClass().getCanonicalName();
-      Class klass = obj.getClass();
-      if (JsonUtil.isPrimitiveOrWrapper(klass)) {
-        array[1] = obj;
-      } else if (obj instanceof PdxInstance) {
-        String str = pdxToJson((PdxInstance) obj);
-        array[1] = str;
-      } else {
-        GfJsonObject object = new GfJsonObject(obj, true);
-        Iterator keysIterator = object.keys();
-        while (keysIterator.hasNext()) {
-          String key = (String) keysIterator.next();
-          Object value = object.get(key);
-          if (GfJsonObject.isJSONKind(value)) {
-            GfJsonObject jsonVal = new GfJsonObject(value);
-            try {
-              if (jsonVal.has("type-class")) {
-                object.put(key, jsonVal.get("type-class"));
-              } else {
-                // Its Map Value
-                object.put(key, "a Map");
-              }
-            } catch (GfJsonException e) {
-              throw new RuntimeException(e);
-            }
-          } else if (value instanceof JSONArray) {
-            // Its a collection either a set or list
-            try {
-              object.put(key, "a Collection");
-            } catch (GfJsonException e) {
-              throw new RuntimeException(e);
-            }
-          }
-        }
-        String str = object.toString();
-        array[1] = str;
-      }
+      array[1] = null;
-  }
-  private static String pdxToJson(PdxInstance obj) {
-    if (obj != null) {
-      try {
-        GfJsonObject json = new GfJsonObject();
-        for (String field : obj.getFieldNames()) {
-          Object fieldValue = obj.getField(field);
-          if (fieldValue != null) {
-            if (JsonUtil.isPrimitiveOrWrapper(fieldValue.getClass())) {
-              json.put(field, fieldValue);
-            } else {
-              json.put(field, fieldValue.getClass());
-            }
-          }
-        }
-        return json.toString();
-      } catch (GfJsonException e) {
-        return null;
-      }
+    array[0] = obj.getClass().getCanonicalName();
+
+    if (obj instanceof PdxInstance) {
+      array[1] = JSONFormatter.toJSON((PdxInstance) obj);
+      return array;
-    return null;
-  }
-  public static <V> V getObjectFromJson(String json, Class<V> klass) {
-    String newString = json.replaceAll("'", "\"");
-    if (newString.charAt(0) == '(') {
-      int len = newString.length();
-      StringBuilder sb = new StringBuilder();
-      sb.append("{").append(newString.substring(1, len - 1)).append("}");
-      newString = sb.toString();
+    ObjectMapper mapper = new ObjectMapper();
+    try {
+      array[1] = mapper.writeValueAsString(obj);
+    } catch (JsonProcessingException e) {
+      array[1] = e.getMessage();
-    return JsonUtil.jsonToObject(newString, klass);
-  }
+    return array;
+  }

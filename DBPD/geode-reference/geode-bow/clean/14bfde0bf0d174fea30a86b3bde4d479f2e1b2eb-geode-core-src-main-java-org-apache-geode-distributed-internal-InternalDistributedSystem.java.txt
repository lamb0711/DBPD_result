Merge branch 'release/1.8.0'

-import org.apache.geode.i18n.LogWriterI18n;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
+import org.apache.geode.internal.logging.LoggingThread;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+   * A value of Boolean.TRUE will identify a thread being used to execute
+   * disconnectListeners. {@link #addDisconnectListener} will not throw ShutdownException if the
+   * value is Boolean.TRUE.
+   */
+  final ThreadLocal<Boolean> isDisconnectThread = new ThreadLocal() {
+    @Override
+    public Boolean initialValue() {
+      return Boolean.FALSE;
+    }
+  };
+
+  /**
-   * A Constant that matches the ThreadGroup name of the shutdown hook. This constant is used to
-   * insure consistency with LoggingThreadGroup. Due to Bug 38407, be careful about moving this to
-   * another class.
+   * Due to Bug 38407, be careful about moving this to another class.
-        // bug44365 - logwriters accumulate, causing mem leak
-        LoggingThreadGroup.cleanUpThreadGroups();
-  public static LogWriterI18n getLoggerI18n() {
+  public static LogWriter getLogger() {
-      return sys.logWriter.convertToLogWriterI18n();
+      return sys.logWriter;
-      // bridge server and will need to enforce the member limit
+      // cache server and will need to enforce the member limit
-            LocalizedStrings.InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION
-                .toLocalizedString(),
+            "Problem in initializing keys for client authentication",
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+            logger.warn(
+                "System memory appears to be over committed by {} bytes.  You may experience instability, performance issues, or terminated processes due to the Linux OOM killer.",
+                size - avail);
-                LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT
-                    .toLocalizedString(avail, size));
+                String.format(
+                    "Insufficient free memory (%s) when attempting to lock %s bytes.  Either reduce the amount of heap or off-heap memory requested or free up additional system memory.  You may also specify -Dgemfire.Cache.ALLOW_MEMORY_OVERCOMMIT=true on the command-line to override the constraint check.",
+                    avail, size));
-            LocalizedStrings.InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED
-                .toLocalizedString(),
+            "Distributed system has disconnected during startup.",
-        if (!quorumChecker.checkForQuorum(3 * this.config.getMemberTimeout())) {
+        if (!quorumChecker.checkForQuorum(3L * this.config.getMemberTimeout())) {
-          LocalizedStrings.InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE
-              .toLocalizedString(),
+          "Problem starting a locator service",
-          LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED
-              .toLocalizedString(),
+          "This connection to a distributed system has been disconnected.",
-        LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(), false);
+        "normal disconnect", false);
-  private void runDisconnect(final DisconnectListener dc, ThreadGroup tg) {
+  private void runDisconnect(final DisconnectListener dc) {
-          disconnectListenerThread.set(Boolean.TRUE);
+          isDisconnectThread.set(Boolean.TRUE);
-    Thread t = new Thread(tg, r, dc.toString());
+    Thread t = new LoggingThread(dc.toString(), false, r);
-      logger.warn(
-          LocalizedMessage.create(
-              LocalizedStrings.InternalDistributedSystem_INTERRUPTED_WHILE_PROCESSING_DISCONNECT_LISTENER),
+      logger.warn("Interrupted while processing disconnect listener",
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_STILL_RUNNING__0, dc));
+      logger.warn("Disconnect listener still running: {}", dc);
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_IGNORED_ITS_INTERRUPT__0,
-            dc));
+        logger.warn("Disconnect listener ignored its interrupt: {}",
+            dc);
-  public boolean isDisconnectListenerThread() {
-    Boolean disconnectListenerThreadBoolean = (Boolean) this.disconnectListenerThread.get();
+  public boolean isDisconnectThread() {
+    return this.isDisconnectThread.get();
+  }
-    return disconnectListenerThreadBoolean != null
-        && disconnectListenerThreadBoolean.booleanValue();
+  public void setIsDisconnectThread() {
+    this.isDisconnectThread.set(Boolean.TRUE);
-   * @param tg the thread group to run the listener in
-  private void runDisconnectForReconnect(final DisconnectListener dc, ThreadGroup tg) {
+  private void runDisconnectForReconnect(final DisconnectListener dc) {
-   * A logging thread group for the disconnect and shutdown listeners
-   */
-  private final ThreadGroup disconnectListenerThreadGroup =
-      LoggingThreadGroup.createThreadGroup("Disconnect Listeners");
-
-  /**
-        runDisconnectForReconnect(listener, disconnectListenerThreadGroup);
+        runDisconnectForReconnect(listener);
-        runDisconnect(listener, disconnectListenerThreadGroup);
+        runDisconnect(listener);
-        logger.fatal(LocalizedMessage
-            .create(LocalizedStrings.InternalDistributedSystem_SHUTDOWNLISTENER__0__THREW, s), t);
+        logger.fatal(String.format("ShutdownListener < %s > threw...", s), t);
-      // Run the disconnect
-      runDisconnect(dcListener, disconnectListenerThreadGroup);
+      runDisconnect(dcListener);
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.InternalDistributedSystem_DISCONNECTLISTENERSHUTDOWN_THREW), t);
+          logger.fatal("DisconnectListener/Shutdown threw...", t);
-          getLogWriter().convertToLogWriterI18n()
-              .warning(LocalizedStrings.InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED, e);
+          getLogWriter()
+              .warning("Disconnect wait interrupted", e);
-            disconnectListenerThread.set(Boolean.TRUE); // bug #42663 - this must be set while
-                                                        // closing the cache
+            isDisconnectThread.set(Boolean.TRUE); // bug #42663 - this must be set while
+                                                  // closing the cache
-                  LocalizedMessage.create(
-                      LocalizedStrings.InternalDistributedSystem_EXCEPTION_TRYING_TO_CLOSE_CACHE),
+                  "Exception trying to close cache",
-              disconnectListenerThread.set(Boolean.FALSE);
+              isDisconnectThread.set(Boolean.FALSE);
-      // NOTE: no logging after this point :-)
-
-      LoggingThreadGroup.cleanUpThreadGroups(); // bug35388 - logwriters accumulate, causing mem
-                                                // leak
-        LocalizedStrings.PureStatSampler_COULD_NOT_FIND_STATISTICS_INSTANCE.toLocalizedString());
+        "Could not find statistics instance");
-          sys.getLogWriter().convertToLogWriterI18n()
-              .severe(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW, t);
+          sys.getLogWriter()
+              .severe("ConnectListener threw...", t);
-        logger.fatal(LocalizedMessage
-            .create(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW), t);
+        logger.fatal("ConnectListener threw...", t);
-      Boolean disconnectListenerThreadBoolean = (Boolean) disconnectListenerThread.get();
+      boolean disconnectThreadBoolean = isDisconnectThread.get();
-      if (disconnectListenerThreadBoolean == null
-          || !disconnectListenerThreadBoolean.booleanValue()) {
+      if (!disconnectThreadBoolean) {
-              LocalizedStrings.InternalDistributedSystem_NO_LISTENERS_PERMITTED_AFTER_SHUTDOWN_0
-                  .toLocalizedString(reason),
+              String.format("No listeners permitted after shutdown: %s",
+                  reason),
-   * A non-null value of Boolean.TRUE will identify a thread being used to execute
-   * disconnectListeners. {@link #addDisconnectListener} will not throw ShutdownException if the
-   * value is Boolean.TRUE.
-   */
-  final ThreadLocal disconnectListenerThread = new ThreadLocal();
-
-  /**
-        LocalizedStrings.InternalDistributedSystem_NOT_IMPLEMENTED_YET.toLocalizedString());
+        "Not implemented yet");
-    ThreadGroup tg = LoggingThreadGroup.createThreadGroup(SHUTDOWN_HOOK_NAME);
-        tmp_shutdownHook = new Thread(tg, new Runnable() {
-          public void run() {
-            DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
-            setThreadsSocketPolicy(true /* conserve sockets */);
-            if (ds != null && ds.isConnected()) {
-              LogWriterI18n log = ((InternalDistributedSystem) ds).getInternalLogWriter();
-              log.info(LocalizedStrings.InternalDistributedSystem_shutdownHook_shuttingdown);
-              DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
-                  .getDurableClientAttributes();
-              boolean isDurableClient = false;
+        tmp_shutdownHook = new LoggingThread(SHUTDOWN_HOOK_NAME, false, () -> {
+          DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
+          setThreadsSocketPolicy(true /* conserve sockets */);
+          if (ds != null && ds.isConnected()) {
+            logger.info("VM is exiting - shutting down distributed system");
+            DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
+                .getDurableClientAttributes();
+            boolean isDurableClient = false;
-              if (dca != null) {
-                isDurableClient = (!(dca.getId() == null || dca.getId().isEmpty()));
-              }
-
-              ((InternalDistributedSystem) ds).disconnect(false,
-                  LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(),
-                  isDurableClient/* keep alive drive from this */);
-              // this was how we wanted to do it for 5.7, but there were shutdown
-              // issues in PR/dlock (see bug 39287)
-              // InternalDistributedSystem ids = (InternalDistributedSystem)ds;
-              // if (ids.getDistributionManager() != null &&
-              // ids.getDistributionManager().getMembershipManager() != null) {
-              // ids.getDistributionManager().getMembershipManager()
-              // .uncleanShutdown("VM is exiting", null);
-              // }
+            if (dca != null) {
+              isDurableClient = (!(dca.getId() == null || dca.getId().isEmpty()));
+
+            ((InternalDistributedSystem) ds).disconnect(false,
+                "normal disconnect",
+                isDurableClient/* keep alive drive from this */);
+            // this was how we wanted to do it for 5.7, but there were shutdown
+            // issues in PR/dlock (see bug 39287)
+            // InternalDistributedSystem ids = (InternalDistributedSystem)ds;
+            // if (ids.getDistributionManager() != null &&
+            // ids.getDistributionManager().getMembershipManager() != null) {
+            // ids.getDistributionManager().getMembershipManager()
+            // .uncleanShutdown("VM is exiting", null);
+            // }
-        }, SHUTDOWN_HOOK_NAME);
+        });
-    // new Exception("stack trace"));
+    // new Exception("stack trace");
-                  LocalizedStrings.InternalDistributedSystem_SOME_REQUIRED_ROLES_MISSING
-                      .toLocalizedString());
+                  "Some required roles missing");
-                  LocalizedStrings.InternalDistributedSystem_SOME_REQUIRED_ROLES_MISSING
-                      .toLocalizedString());
+                  "Some required roles missing");
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.InternalDistributedSystem_WAITING_THREAD_FOR_RECONNECT_GOT_INTERRUPTED));
+          logger.warn("Waiting thread for reconnect got interrupted.");
-        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING,
-            new Object[] {reconnectAttemptCounter}));
+        logger.info(
+            "Attempting to reconnect to the distributed system.  This is attempt #{}.",
+            reconnectAttemptCounter);
-        int savNumOfTries = reconnectAttemptCounter;
+        int saveNumberOfTries = reconnectAttemptCounter;
-            logger.warn(
-                LocalizedMessage.create(
-                    LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT),
+            logger.warn("Exception occurred while trying to connect the system during reconnect",
-          logger.warn(
-              LocalizedMessage.create(
-                  LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT),
+          logger.warn("Exception occurred while trying to connect the system during reconnect",
-          reconnectAttemptCounter = savNumOfTries;
+          reconnectAttemptCounter = saveNumberOfTries;
-              createAndStartCacheServers(cacheServerCreation, cache);
-
-              if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {
-                reconnectAttemptCounter = 0;
-              } else {
-                // this try failed. The new cache will call reconnect again
+              if (!cache.isClosed()) {
+                createAndStartCacheServers(cacheServerCreation, cache);
+                if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {
+                  reconnectAttemptCounter = 0;
+                }
+
+              // If this reconnect is for required-roles the algorithm is recursive and we
+              // shouldn't retry at this level
+              if (!forcedDisconnect) {
+                break;
+              }
-              logger.warn(
-                  LocalizedMessage.create(
-                      LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CREATE_THE_CACHE_DURING_RECONNECT),
+              logger.warn("Exception occurred while trying to create the cache during reconnect",
-            Thread.sleep(config.getMemberTimeout() * 3);
+            Thread.sleep(config.getMemberTimeout() * 3L);
-
-        notifyReconnectListeners(this, this.reconnectDS, false);
+        if (reconnectDS.isConnected()) {
+          notifyReconnectListeners(this, this.reconnectDS, false);
+        }
-    } else {
+    } else if (reconnectDS != null && reconnectDS.isConnected()) {
-            LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0.toLocalizedString(server),
+            String.format("While starting cache server %s", server),
-            LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
-                .toLocalizedString(sb.toString()));
+            String.format(
+                "A connection to a distributed system already exists in this VM.  It has the following configuration:%s",
+                sb.toString()));
-            LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
-                .toLocalizedString(sb.toString()),
+            String.format(
+                "A connection to a distributed system already exists in this VM.  It has the following configuration:%s",
+                sb.toString()),
-      return LocalizedStrings.InternalDistributedSystem_NO_DISTRIBUTION_MANAGER.toLocalizedString();
+      return "no distribution manager";
-    // new Exception("stack trace"));
+    // new Exception("stack trace");

Removing TCPConduit's Stub ID class

This removes the Stub identifier class from TCPConduit.  This simplifies the
code since the DistributedMember IDs are propagated to all of the methods
that require identifiers and these IDs have all of the information Stubs
had.

The MembershipManager is also simplified since it doesn't have to keep
complicated mappings between Stubs and DistributedMembers.

-import com.gemstone.gemfire.internal.tcp.Stub;
-    Stub stub;
-        sb.append("connect; member = <" + member + ">; stub = " + stub);
+        sb.append("connect; member = <" + member + ">");
-     * @param id the stub
-    StartupEvent(final InternalDistributedMember member, final Stub id) {
+    StartupEvent(final InternalDistributedMember member) {
-      this.stub = id;
-   * a map keyed on InternalDistributedMember, values are Stubs that represent direct
-   * channels to other systems
-   * 
-   * Accesses must be under the read or write lock of {@link #latestViewLock}.
-   */
-  protected final Map<InternalDistributedMember, Stub> memberToStubMap = 
-      new ConcurrentHashMap<InternalDistributedMember, Stub>();
-
-  /**
-   * a map of direct channels (Stub) to InternalDistributedMember. key instanceof Stub
-   * value instanceof InternalDistributedMember
-   * 
-   * Accesses must be under the read or write lock of {@link #latestViewLock}.
-   */
-  protected final Map<Stub, InternalDistributedMember> stubToMemberMap = 
-      new ConcurrentHashMap<Stub, InternalDistributedMember>();
-  
-  /**
-        // fix for bug #42006, lingering old identity
-        Object oldStub = this.memberToStubMap.remove(m);
-        if (oldStub != null) {
-          this.stubToMemberMap.remove(oldStub);
-        }
-
-      Stub stub = directChannel.getLocalStub();
-      memberToStubMap.put(address, stub);
-      stubToMemberMap.put(stub, address);
-   * @param stub its stub
-    Stub stub = new Stub(member.getInetAddress(), member.getDirectChannelPort(), member.getVmViewId());
-        startupMessages.add(new StartupEvent(member, stub));
+        startupMessages.add(new StartupEvent(member));
-    processSurpriseConnect(member, stub);
+    processSurpriseConnect(member);
-   * @param stub the member's stub
-  public boolean addSurpriseMember(DistributedMember dm, 
-      Stub stub) {
+  public boolean addSurpriseMember(DistributedMember dm) {
-    Stub s = null;
-        // fix for bug #42006, lingering old identity
-        Object oldStub = this.memberToStubMap.remove(member);
-        if (oldStub != null) {
-          this.stubToMemberMap.remove(oldStub);
-        }
-
-        s = stub == null ? getStubForMember(member) : stub;
-        // Make sure that channel information is consistent
-        addChannel(member, s);
-
-          shunned = !addSurpriseMember(m, getStubForMember(m));
+          shunned = !addSurpriseMember(m);
-      throw new MemberShunnedException(getStubForMember(m));
+      throw new MemberShunnedException(m);
-   * @param stub
-      InternalDistributedMember member, 
-      Stub stub) 
+      InternalDistributedMember member) 
-    addSurpriseMember(member, stub);
+    addSurpriseMember(member);
-      processSurpriseConnect(o.member, o.stub);
+      processSurpriseConnect(o.member);
-  public boolean memberExists(InternalDistributedMember m) {
+  public boolean memberExists(DistributedMember m) {
-    // could we guarantee not to allocate objects?  We're using Darrel's 
-    // factory, so it's possible that an unsafe implementation could be
-    // introduced here.
-//    stubToMemberMap.clear();
-//    memberToStubMap.clear();
-    
-        Set keySet = memberToStubMap.keySet();
+        List<InternalDistributedMember> keySet = latestView.getMembers();
-  /**
-   * Get or create stub for given member
-   */
-  public Stub getStubForMember(InternalDistributedMember m)
-  {
-    if (shutdownInProgress) {
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.GroupMembershipService_DISTRIBUTEDSYSTEM_IS_SHUTTING_DOWN.toLocalizedString(), services.getShutdownCause());
-    }
-
-    if (services.getConfig().getDistributionConfig().getDisableTcp()) {
-      return new Stub(m.getInetAddress(), m.getPort(), m.getVmViewId());
-    }
-    
-    // Return existing one if it is already in place
-    Stub result;
-    result = (Stub)memberToStubMap.get(m);
-    if (result != null)
-      return result;
-
-    latestViewLock.writeLock().lock();
-    try {
-      // Do all of this work in a critical region to prevent
-      // members from slipping in during shutdown
-      if (shutdownInProgress())
-        return null; // don't try to create a stub during shutdown
-      if (isShunned(m))
-        return null; // don't let zombies come back to life
-      
-      // OK, create one.  Update the table to reflect the creation.
-      result = directChannel.createConduitStub(m);
-      addChannel(m, result);
-    } finally {
-      latestViewLock.writeLock().unlock();
-    }
-   return result;
-  }
-
-  public InternalDistributedMember getMemberForStub(Stub s, boolean validated)
-  {
-    latestViewLock.writeLock().lock();
-    try {
-      if (shutdownInProgress) {
-        throw new DistributedSystemDisconnectedException(LocalizedStrings.GroupMembershipService_DISTRIBUTEDSYSTEM_IS_SHUTTING_DOWN.toLocalizedString(), services.getShutdownCause());
-      }
-      InternalDistributedMember result = (InternalDistributedMember)
-          stubToMemberMap.get(s);
-      if (result != null) {
-        if (validated && !this.latestView.contains(result)) {
-          // Do not return this member unless it is in the current view.
-          if (!surpriseMembers.containsKey(result)) {
-            // if not a surprise member, this stub is lingering and should be removed
-            stubToMemberMap.remove(s);
-            memberToStubMap.remove(result);
-          }
-          result = null;
-          // fall through to see if there is a newer member using the same direct port
-        }
-      }
-      if (result == null) {
-        // it may have not been added to the stub->idm map yet, so check the current view
-        for (InternalDistributedMember idm: latestView.getMembers()) {
-          if (GMSUtil.compareAddresses(idm.getInetAddress(), s.getInetAddress()) == 0
-              && idm.getDirectChannelPort() == s.getPort()) {
-            addChannel(idm, s);
-            return idm;
-          }
-        }
-      }
-      return result;
-    } finally {
-      latestViewLock.writeLock().unlock();
-    }
-  }
-
-  /**
-   * Add a mapping from the given member to the given stub. Must
-   * be called with {@link #latestViewLock} held.
-   * 
-   * @param member
-   * @param theChannel
-   */
-  protected void addChannel(InternalDistributedMember member, Stub theChannel)
-  {
-    if (theChannel != null) {
-      // Don't overwrite existing stub information with a null
-      this.memberToStubMap.put(member, theChannel);
-
-      // Can't create reverse mapping if the stub is null
-      this.stubToMemberMap.put(theChannel, member);
-    }
-  }
-
-    // Clean up the maps
-    Stub theChannel = (Stub)memberToStubMap.remove(member);
-    if (theChannel != null) {
-      this.stubToMemberMap.remove(theChannel);
-    }
-    
-  public Map getMessageState(DistributedMember member, boolean includeMulticast) {
+  public Map getChannelStates(DistributedMember member, boolean includeMulticast) {
-    Stub stub = (Stub)memberToStubMap.get(member);
-    if (stub != null && dc != null) {
-      dc.getChannelStates(stub, result);
+    if (dc != null) {
+      dc.getChannelStates(member, result);
-    Stub stub;
-    latestViewLock.writeLock().lock();
-    try {
-      stub = (Stub)memberToStubMap.get(otherMember);
-    } finally {
-      latestViewLock.writeLock().unlock();
-    }
-    if (dc != null && stub != null) {
-      dc.waitForChannelState(stub, state);
+    if (dc != null) {
+      dc.waitForChannelState(otherMember, channelState);
-    Stub stub = new Stub(idm.getInetAddress(), idm.getPort(), idm.getVmViewId());
-        if (dc.hasReceiversFor(stub)) {
+        if (dc.hasReceiversFor(idm)) {

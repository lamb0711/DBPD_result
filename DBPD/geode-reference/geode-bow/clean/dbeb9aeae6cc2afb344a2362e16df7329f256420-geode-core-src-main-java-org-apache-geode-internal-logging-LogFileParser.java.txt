Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Parses a log file written by a {@link
- * org.apache.geode.i18n.LogWriterI18n} into {@link
- * LogFileParser.LogEntry}s.  It behaves sort of like an {@link
- * java.util.StringTokenizer}. 
+ * Parses a log file written by a {@link org.apache.geode.i18n.LogWriterI18n} into
+ * {@link LogFileParser.LogEntry}s. It behaves sort of like an {@link java.util.StringTokenizer}.
-public class LogFileParser  {
+public class LogFileParser {
-  
-  private static final boolean NEWLINE_AFTER_HEADER = Boolean.getBoolean("mergelogs.NEWLINE_AFTER_HEADER");
+
+  private static final boolean NEWLINE_AFTER_HEADER =
+      Boolean.getBoolean("mergelogs.NEWLINE_AFTER_HEADER");
-  
-  /** Text that signifies the start of a JRockit-style thread dump */
-  private static final String FULL_THREAD_DUMP =
-    "===== FULL THREAD DUMP ===============";
-  ///////////////////////  Instance Fields  ///////////////////////
+  /** Text that signifies the start of a JRockit-style thread dump */
+  private static final String FULL_THREAD_DUMP = "===== FULL THREAD DUMP ===============";
+
+  /////////////////////// Instance Fields ///////////////////////
-  
+
-//  private Pattern pattern;
+  // private Pattern pattern;
-  
+
-  
+
-   * StringBuffer containing white space that is the same length as
-   * logFileName plus ": ", in a monospace font when tabs are 8 chars long
+   * StringBuffer containing white space that is the same length as logFileName plus ": ", in a
+   * monospace font when tabs are 8 chars long
-  
+
-  //////////////////////  Constructors  //////////////////////
+  ////////////////////// Constructors //////////////////////
-   * Creates a new <code>LogFileParser</code> that reads a log from a
-   * given <code>BufferedReader</code>.  Blanks are not suppressed, and
-   * non-timestamped lines are emitted as-is.
+   * Creates a new <code>LogFileParser</code> that reads a log from a given
+   * <code>BufferedReader</code>. Blanks are not suppressed, and non-timestamped lines are emitted
+   * as-is.
-   * @param logFileName
-   *        The name of the log file being parsed.  This is appended
-   *        to the entry.  If <code>logFileName</code> is
-   *        <code>null</code> nothing will be appended.
-   * @param br
-   *        Where to read the log from
+   * @param logFileName The name of the log file being parsed. This is appended to the entry. If
+   *        <code>logFileName</code> is <code>null</code> nothing will be appended.
+   * @param br Where to read the log from
-  
+
-   * Creates a new <code>LogFileParser</code> that reads a log from a
-   * given <code>BufferedReader</code>.
+   * Creates a new <code>LogFileParser</code> that reads a log from a given
+   * <code>BufferedReader</code>.
-   * @param logFileName
-   *        The name of the log file being parsed.  This is appended
-   *        to the entry.  If <code>logFileName</code> is
-   *        <code>null</code> nothing will be appended.
-   * @param br
-   *        Where to read the log from
-   * @param tabOut
-   *        Whether to add white-space to non-timestamped lines to align them
-   *        with lines containing file names.
-   * @param suppressBlanks
-   *        whether to suppress blank lines
+   * @param logFileName The name of the log file being parsed. This is appended to the entry. If
+   *        <code>logFileName</code> is <code>null</code> nothing will be appended.
+   * @param br Where to read the log from
+   * @param tabOut Whether to add white-space to non-timestamped lines to align them with lines
+   *        containing file names.
+   * @param suppressBlanks whether to suppress blank lines
-  public LogFileParser(String logFileName, BufferedReader br,
-      boolean tabOut, boolean suppressBlanks) {
+  public LogFileParser(String logFileName, BufferedReader br, boolean tabOut,
+      boolean suppressBlanks) {
-//    this.pattern = 
-//      Pattern.compile("\\[\\w+ (\\d\\d\\d\\d/\\d\\d/\\d\\d \\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d) .*");
+    // this.pattern =
+    // Pattern.compile("\\[\\w+ (\\d\\d\\d\\d/\\d\\d/\\d\\d \\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d) .*");
-      int numTabs = (logFileName.length()+2) / 8;
-      for (int i=0; i<numTabs; i++) {
+      int numTabs = (logFileName.length() + 2) / 8;
+      for (int i = 0; i < numTabs; i++) {
-      for (int i=((logFileName.length()+2)%8); i>0; i--) {
+      for (int i = ((logFileName.length() + 2) % 8); i > 0; i--) {
-    }
-    else {
+    } else {
-  ////////////////////  Instance Methods  ////////////////////
+  //////////////////// Instance Methods ////////////////////
-   * Returns whether or not there are any more entries in the file to
-   * be parser.
+   * Returns whether or not there are any more entries in the file to be parser.
-  /** copy the timestamp out of a log entry, if there is one, and return it.
-   *  if there isn't a timestamp, return null
+  /**
+   * copy the timestamp out of a log entry, if there is one, and return it. if there isn't a
+   * timestamp, return null
-      if (line.charAt(0) == '2' &&
-          line.charAt(1) == '0' &&
-          line.charAt(4) == '-' &&
-          line.charAt(7) == '-') {
+      if (line.charAt(0) == '2' && line.charAt(1) == '0' && line.charAt(4) == '-'
+          && line.charAt(7) == '-') {
-        if ((line.charAt(1) == 'i' &&
-             line.charAt(2) == 'n' &&
-             line.charAt(3) == 'f' /*&&
-             line.charAt(4) == 'o'*/)   ||
-             
-            (line.charAt(1) == 'f' &&
-             line.charAt(2) == 'i' &&
-             line.charAt(3) == 'n' /*&&
-             line.charAt(4) == 'e'*/)   ||
-             
-            (line.charAt(1) == 'w' &&
-             line.charAt(2) == 'a' &&
-             line.charAt(3) == 'r' /*&&
-             line.charAt(4) == 'n' &&
-             line.charAt(5) == 'i' &&
-             line.charAt(6) == 'n' &&
-             line.charAt(7) == 'g'*/)   ||
-             
-            (line.charAt(1) == 'd' &&
-             line.charAt(2) == 'e' &&
-             line.charAt(3) == 'b'/* &&
-             line.charAt(4) == 'u' &&
-             line.charAt(5) == 'g'*/)   ||
-             
-            (line.charAt(1) == 't' &&
-             line.charAt(2) == 'r' &&
-             line.charAt(3) == 'a' /*&&
-             line.charAt(4) == 'c' &&
-             line.charAt(5) == 'e'*/)   ||
-             
-            (line.charAt(1) == 's' &&
-             line.charAt(2) == 'e' &&
-             line.charAt(3) == 'v' /*&&
-             line.charAt(4) == 'e' &&
-             line.charAt(5) == 'r' &&
-             line.charAt(6) == 'e'*/)   ||
-             
-            (line.charAt(1) == 'c' &&
-             line.charAt(2) == 'o' &&
-             line.charAt(3) == 'n' /*&&
-             line.charAt(4) == 'f' &&
-             line.charAt(5) == 'i' &&
-             line.charAt(6) == 'g'*/)   ||
-             
-            (line.charAt(1) == 'e' &&
-             line.charAt(2) == 'r' &&
-             line.charAt(3) == 'r' /*&&
-             line.charAt(4) == 'o' &&
-             line.charAt(5) == 'r'*/)   ||
-             
-             (line.charAt(1) == 's' &&
-              line.charAt(2) == 'e' &&
-              line.charAt(3) == 'c' &&
-              line.charAt(4) == 'u' &&
-              line.charAt(5) == 'r')) {
+        if ((line.charAt(1) == 'i' && line.charAt(2) == 'n'
+            && line.charAt(3) == 'f' /*
+                                      * && line.charAt(4) == 'o'
+                                      */) ||
+
+            (line.charAt(1) == 'f' && line.charAt(2) == 'i'
+                && line.charAt(3) == 'n' /*
+                                          * && line.charAt(4) == 'e'
+                                          */)
+            ||
+
+            (line.charAt(1) == 'w' && line.charAt(2) == 'a'
+                && line.charAt(3) == 'r' /*
+                                          * && line.charAt(4) == 'n' && line.charAt(5) == 'i' &&
+                                          * line.charAt(6) == 'n' && line.charAt(7) == 'g'
+                                          */)
+            ||
+
+            (line.charAt(1) == 'd' && line.charAt(2) == 'e'
+                && line.charAt(3) == 'b'/*
+                                         * && line.charAt(4) == 'u' && line.charAt(5) == 'g'
+                                         */)
+            ||
+
+            (line.charAt(1) == 't' && line.charAt(2) == 'r'
+                && line.charAt(3) == 'a' /*
+                                          * && line.charAt(4) == 'c' && line.charAt(5) == 'e'
+                                          */)
+            ||
+
+            (line.charAt(1) == 's' && line.charAt(2) == 'e'
+                && line.charAt(3) == 'v' /*
+                                          * && line.charAt(4) == 'e' && line.charAt(5) == 'r' &&
+                                          * line.charAt(6) == 'e'
+                                          */)
+            ||
+
+            (line.charAt(1) == 'c' && line.charAt(2) == 'o'
+                && line.charAt(3) == 'n' /*
+                                          * && line.charAt(4) == 'f' && line.charAt(5) == 'i' &&
+                                          * line.charAt(6) == 'g'
+                                          */)
+            ||
+
+            (line.charAt(1) == 'e' && line.charAt(2) == 'r'
+                && line.charAt(3) == 'r' /*
+                                          * && line.charAt(4) == 'o' && line.charAt(5) == 'r'
+                                          */)
+            ||
+
+            (line.charAt(1) == 's' && line.charAt(2) == 'e' && line.charAt(3) == 'c'
+                && line.charAt(4) == 'u' && line.charAt(5) == 'r')) {
-            result = line.substring(sidx+1, endIdx+1);
+            result = line.substring(sidx + 1, endIdx + 1);
-  
+
-   * Returns the next entry in the log file.  The last entry will be
-   * an instance of {@link LogFileParser.LastLogEntry}.
+   * Returns the next entry in the log file. The last entry will be an instance of
+   * {@link LogFileParser.LastLogEntry}.
-        while (lend > 1  &&  Character.isWhitespace(lineStr.charAt(lend-1))) {
+        while (lend > 1 && Character.isWhitespace(lineStr.charAt(lend - 1))) {
-          //System.out.println(this.logFileName + ": skipping line '" + lineStr + "'");
+          // System.out.println(this.logFileName + ": skipping line '" + lineStr + "'");
-      
+
-//      Matcher matcher = pattern.matcher(line);
+      // Matcher matcher = pattern.matcher(line);
-          
-      // See if we've found the beginning of a new log entry.  If so, bundle
+
+      // See if we've found the beginning of a new log entry. If so, bundle
-            if (line.charAt(start) != ' ')         // info & fine
-              if (line.charAt(++start) != ' ')     // finer & error
-                if (line.charAt(++start) != ' ')   // finest, severe, config
+            if (line.charAt(start) != ' ') // info & fine
+              if (line.charAt(++start) != ' ') // finer & error
+                if (line.charAt(++start) != ' ') // finest, severe, config
-              line.delete(start+25, start+29);  // time zone
-              line.delete(start, start+11);     // date
+              line.delete(start + 25, start + 29); // time zone
+              line.delete(start, start + 11); // date
-                int idx2 = line.indexOf("<", + 12);
-                if (idx2 > start+13) {
-                  line.delete(start+13, idx2-1);
+                int idx2 = line.indexOf("<", +12);
+                if (idx2 > start + 13) {
+                  line.delete(start + 13, idx2 - 1);
-              idx = line.indexOf("]", idx+4);
-              if (idx+1 < line.length()) {
-                line.insert(idx+1, "\n ");
+              idx = line.indexOf("]", idx + 4);
+              if (idx + 1 < line.length()) {
+                line.insert(idx + 1, "\n ");
-        }
-        else {
+        } else {
-      }
-      else if (line.indexOf(FULL_THREAD_DUMP) != -1) {
+      } else if (line.indexOf(FULL_THREAD_DUMP) != -1) {
-          
+
-      }
-      else {
+      } else {
-      // The file didn't contain any log entries.  Just use the
+      // The file didn't contain any log entries. Just use the
-//      Date now = new Date();
+      // Date now = new Date();
-      LocalLogWriter tempLogger =
-        new LocalLogWriter(InternalLogWriter.ALL_LEVEL, pw);
+      LocalLogWriter tempLogger = new LocalLogWriter(InternalLogWriter.ALL_LEVEL, pw);
-  //////////////////////  Main Program  ///////////////////////
+  ////////////////////// Main Program ///////////////////////
-   * Main program that simply parses a log file and prints out the
-   * entries.  It is used for testing purposes.
+   * Main program that simply parses a log file and prints out the entries. It is used for testing
+   * purposes.
-    BufferedReader br =
-      new BufferedReader(new FileReader(logFileName));
+    BufferedReader br = new BufferedReader(new FileReader(logFileName));
-  //////////////////////  Inner Classes  //////////////////////
+  ////////////////////// Inner Classes //////////////////////
-   * A parsed entry in a log file.  Note that we maintain the entry's
-   * timestamp as a <code>String</code>. 
-   * {@link java.text.DateFormat#parse(java.lang.String) Parsing} it was too expensive.
+   * A parsed entry in a log file. Note that we maintain the entry's timestamp as a
+   * <code>String</code>. {@link java.text.DateFormat#parse(java.lang.String) Parsing} it was too
+   * expensive.
-  static class LogEntry  {
+  static class LogEntry {
-    
+
-    ////////////////////  Constructors  ////////////////////
+    //////////////////// Constructors ////////////////////
-    ////////////////////  Instance Methods  ////////////////////
+    //////////////////// Instance Methods ////////////////////
-    
+
-     * Writes the contents of this log entry to a
-     * <code>PrintWriter</code>. 
+     * Writes the contents of this log entry to a <code>PrintWriter</code>.
-   * The last log entry read from a log file.  We use a separate class
-   * to avoid the overhead of an extra <code>boolean</code> field in
-   * each {@link LogFileParser.LogEntry}.
+   * The last log entry read from a log file. We use a separate class to avoid the overhead of an
+   * extra <code>boolean</code> field in each {@link LogFileParser.LogEntry}.
-  static class LastLogEntry extends LogEntry  {
+  static class LastLogEntry extends LogEntry {
-    }    
+    }

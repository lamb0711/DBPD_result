Merge branch 'release/1.3.0'

-import java.io.IOException;
-import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Optional;
-import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.lucene.internal.LuceneIndexImpl;
-import org.apache.geode.cache.lucene.internal.LuceneIndexStats;
-import org.apache.geode.cache.lucene.internal.LuceneServiceImpl;
-import org.apache.logging.log4j.Logger;
-import org.apache.lucene.search.Query;
-
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionException;
-import org.apache.geode.cache.lucene.LuceneQueryException;
-import org.apache.geode.cache.lucene.LuceneQueryProvider;
-import org.apache.geode.cache.lucene.LuceneService;
-import org.apache.geode.cache.lucene.LuceneServiceProvider;
-import org.apache.geode.cache.lucene.internal.repository.IndexRepository;
-import org.apache.geode.cache.lucene.internal.repository.IndexResultCollector;
-import org.apache.geode.cache.lucene.internal.repository.RepositoryManager;
+import org.apache.geode.cache.lucene.internal.LuceneServiceImpl;
-import org.apache.geode.internal.cache.BucketNotFoundException;
-import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.security.ResourcePermission;
-public class WaitUntilFlushedFunction implements Function, InternalEntity {
+public class WaitUntilFlushedFunction implements Function<Object>, InternalEntity {
-  private static final Logger logger = LogService.getLogger();
-
-    LuceneService service = LuceneServiceProvider.get(cache);
-    LuceneIndexImpl index = (LuceneIndexImpl) service.getIndex(indexName, region.getFullPath());
-
-      throw new IllegalArgumentException(
+      throw new IllegalStateException(
+
+  @Override
+  public Collection<ResourcePermission> getRequiredPermissions(String regionName) {
+    ResourcePermission read = new ResourcePermission(ResourcePermission.Resource.DATA,
+        ResourcePermission.Operation.READ, regionName);
+    return Collections.singleton(read);
+  }

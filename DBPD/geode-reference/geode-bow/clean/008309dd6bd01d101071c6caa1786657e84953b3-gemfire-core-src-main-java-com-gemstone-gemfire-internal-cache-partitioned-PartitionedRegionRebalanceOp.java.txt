Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.CancelException;
+import com.gemstone.gemfire.internal.cache.partitioned.rebalance.ParallelBucketOperator;
+  private static final int MAX_PARALLEL_OPERATIONS = Integer.getInteger("gemfire.MAX_PARALLEL_BUCKET_RECOVERIES", 8);
+  private final boolean DEBUG = Boolean.getBoolean("gemfire.LOG_REBALANCE");
+  
-      BucketOperatorWrapper operator = getBucketOperator(detailsMap);
-      model = buildModel(operator, detailsMap, resourceManager);
-      for(PartitionRebalanceDetailsImpl details : operator.getDetailSet()) {
+      BucketOperatorWrapper serialOperator = getBucketOperator(detailsMap);
+      ParallelBucketOperator parallelOperator = new ParallelBucketOperator(MAX_PARALLEL_OPERATIONS, cache.getDistributionManager().getWaitingThreadPool(), serialOperator);
+      model = buildModel(parallelOperator, detailsMap, resourceManager);
+      for(PartitionRebalanceDetailsImpl details : serialOperator.getDetailSet()) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Rebalancing {} detected membership changes. Refetching details", leaderRegion);
-          }
+          debug("Rebalancing {} detected membership changes. Refetching details", leaderRegion);
+          model.waitForOperations();
-          model = buildModel(operator, detailsMap, resourceManager);
+          model = buildModel(parallelOperator, detailsMap, resourceManager);
-      if (logger.isDebugEnabled()) {
-        logger.debug("Rebalancing {} complete. Model:{}\n", leaderRegion, model);
-      }
+      debug("Rebalancing {} complete. Model:{}\n", leaderRegion, model);
-      for(PartitionRebalanceDetailsImpl details : operator.getDetailSet()) {
+      for(PartitionRebalanceDetailsImpl details : serialOperator.getDetailSet()) {
-      return Collections.<PartitionRebalanceInfo>unmodifiableSet(operator.getDetailSet());
+      return Collections.<PartitionRebalanceInfo>unmodifiableSet(serialOperator.getDetailSet());
+        } catch (CancelException e) {
+          // lock service has been destroyed
-    boolean enforceLocalMaxMemory = !leaderRegion.isEntryEvictionPossible();
-    Set<InternalDistributedMember> criticalMembers = resourceManager.getHeapCriticalMembers();
+    Set<InternalDistributedMember> criticalMembers = resourceManager.getResourceAdvisor().adviseCritialMembers();;
+    
+    debug("Building Model for rebalancing " + leaderRegion
+        + ". redundantCopies=" + redundantCopies + ", totalNumBuckets="
+        + totalNumberOfBuckets + ", criticalMembers=" + criticalMembers
+        + ", simulate=" + simulate);
+
+    
-        totalNumberOfBuckets, comparor, enforceLocalMaxMemory, 
-        criticalMembers, leaderRegion);
+        totalNumberOfBuckets, comparor, criticalMembers, leaderRegion);
-      if (isDebugEnabled) {
-        logger.debug("Added Region to model region={} details=", region);
-      }
-      for(PartitionMemberInfo memberDetails: details.getPartitionMemberInfo()) {
-        if (isDebugEnabled) {
-          logger.debug("Member: {} LOAD={}", memberDetails.getDistributedMember(), ((InternalPartitionDetails) memberDetails).getPRLoad());
-        }
-      }
-      Set<InternalPartitionDetails> memberDetailSet = 
-          details.getInternalPartitionDetails();
+      
-      model.addRegion(region.getFullPath(), memberDetailSet, offlineDetails);
+      boolean enforceLocalMaxMemory = !region.isEntryEvictionPossible();
+
+      debug("Added Region to model region=" + region + ", offlineDetails=" + offlineDetails 
+          + ", enforceLocalMaxMemory=" + enforceLocalMaxMemory);
+
+      for(PartitionMemberInfo memberDetails: details.getPartitionMemberInfo()) {
+        debug(
+            "For Region: " + region + ", Member: " + memberDetails.getDistributedMember() + "LOAD="
+                + ((InternalPartitionDetails) memberDetails).getPRLoad() 
+                +", equivalentMembers=" 
+                + dm.getMembersInSameZone((InternalDistributedMember) memberDetails.getDistributedMember()));
+      }
+      Set<InternalPartitionDetails> memberDetailSet = 
+          details.getInternalPartitionDetails();
+      
+      model.addRegion(region.getFullPath(), memberDetailSet, offlineDetails, enforceLocalMaxMemory);
+    debug("Rebalancing {} starting. Model:\n{}", leaderRegion, model);
+    
+  private void debug(String message, Object ...params) {
+    if(logger.isDebugEnabled()) {
+      logger.debug(message, params);
+    } else if(logger.isInfoEnabled() && DEBUG) {
+      logger.info(message, params);
+    }
+    
+  }
+
-        InternalDistributedMember whoSuspected) {
+        InternalDistributedMember whoSuspected, String reason) {
+    @Override
+    @Override
-    public boolean createRedundantBucket(
+    @Override
+    public void createRedundantBucket(
-        Map<String, Long> colocatedRegionBytes) {
-      return createRedundantBucketForRegion(targetMember, bucketId,
+        Map<String, Long> colocatedRegionBytes, Completion completion) {
+      boolean result = false;
+      try {
+        result = createRedundantBucketForRegion(targetMember, bucketId,
+      } finally {
+        if(result) {
+          completion.onSuccess();
+        } else {
+          completion.onFailure();
+        }
+      }
+    }
+    
+    @Override
+    public void waitForOperations() {
+      //do nothing, all operations are synchronous
+    @Override
-    
+    @Override
-    public boolean createRedundantBucket(
-        InternalDistributedMember targetMember, int i, 
-        Map<String, Long> colocatedRegionBytes) {
-      boolean result = false;
-      long elapsed = 0;
-      long totalBytes = 0;
-      
+    @Override
+    public void createRedundantBucket(
+        final InternalDistributedMember targetMember, final int i, 
+        final Map<String, Long> colocatedRegionBytes, final Completion completion) {
-      try {
-        long start = System.nanoTime();
-        result = delegate.createRedundantBucket(targetMember, i,  
-            colocatedRegionBytes);
-        elapsed= System.nanoTime() - start;
-        if (result) {
+      
+      final long start = System.nanoTime();
+      delegate.createRedundantBucket(targetMember, i,  
+          colocatedRegionBytes, new Completion() {
+
+        @Override
+        public void onSuccess() {
+          long totalBytes = 0;
+          long elapsed= System.nanoTime() - start;
-        } else {
+
+          if(stats != null) {
+            stats.endBucketCreate(regionCount, true, totalBytes, elapsed);
+          }
+
+        }
+
+        @Override
+        public void onFailure() {
+          long elapsed= System.nanoTime() - start;
+
+
+          if(stats != null) {
+            stats.endBucketCreate(regionCount, false, 0, elapsed);
+          }
-      } finally {
-        if(stats != null) {
-          stats.endBucketCreate(regionCount, result, totalBytes, elapsed);
-        }
-      }
-      
-      return result;
+      });
+    @Override
+    @Override
+    
+    @Override
+    public void waitForOperations() {
+      delegate.waitForOperations();
+    }

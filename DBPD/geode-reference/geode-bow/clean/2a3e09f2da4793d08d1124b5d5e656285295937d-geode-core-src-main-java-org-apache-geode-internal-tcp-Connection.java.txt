GEODE-7832: Remove Connection Semaphores (#4754)

Removed the semaphores and related methods from DirectChannel and
Connection classes. They were used to constrain messaging when some
undocumented system properties were set.
-import java.util.concurrent.Semaphore;
-import org.apache.geode.distributed.internal.direct.DirectChannel;
-import org.apache.geode.internal.util.concurrent.ReentrantSemaphore;
-  private static final ThreadLocal<Boolean> isReaderThread = withInitial(() -> FALSE);
-
-  /**
-   * The maximum number of concurrent senders sending a message to a single recipient.
-   */
-  private static final int MAX_SENDERS = Integer
-      .getInteger("p2p.maxConnectionSenders", DirectChannel.DEFAULT_CONCURRENCY_LEVEL);
-  /**
-   * This semaphore is used to throttle how many threads will try to do sends on this connection
-   * concurrently. A thread must acquire this semaphore before it is allowed to start serializing
-   * its message.
-   */
-  private final Semaphore senderSem = new ReentrantSemaphore(MAX_SENDERS);
-
-  public static void makeReaderThread() {
-    // mark this thread as a reader thread
-    makeReaderThread(true);
-  }
-
-  private static void makeReaderThread(boolean v) {
-    isReaderThread.set(v);
-  }
-
-  // return true if this thread is a reader thread
-  private static boolean isReaderThread() {
-    return isReaderThread.get();
-  }
-
-          closeSenderSem();
-    makeReaderThread(isReceiver);
+
-  public void acquireSendPermission() throws ConnectionException {
-    if (!connected) {
-      throw new ConnectionException("connection is closed");
-    }
-    if (isReaderThread()) {
-      // reader threads send replies and we always want to permit those without waiting
-      return;
-    }
-    boolean interrupted = false;
-    try {
-      for (;;) {
-        owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-        try {
-          senderSem.acquire();
-          break;
-        } catch (InterruptedException ex) {
-          interrupted = true;
-        }
-      }
-    } finally {
-      if (interrupted) {
-        Thread.currentThread().interrupt();
-      }
-    }
-    if (!connected) {
-      senderSem.release();
-      owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-      throw new ConnectionException("connection is closed");
-    }
-  }
-
-  public void releaseSendPermission() {
-    if (isReaderThread()) {
-      return;
-    }
-    senderSem.release();
-  }
-
-  private void closeSenderSem() {
-    // All we need to do is increase the number of permits by one
-    // just in case 1 or more connections are currently waiting to acquire.
-    // One of them will get the permit, then find out the connection is closed
-    // and release the permit until all the connections currently waiting to acquire
-    // will complete by throwing a ConnectionException.
-    releaseSendPermission();
-  }
-

Merge branch 'release/1.5.0'

+import org.apache.geode.SystemFailure;
-import org.apache.geode.internal.protocol.Failure;
-import org.apache.geode.internal.protocol.MessageExecutionContext;
-import org.apache.geode.internal.protocol.OperationContext;
-import org.apache.geode.internal.protocol.ProtocolErrorCode;
-import org.apache.geode.internal.protocol.Result;
-import org.apache.geode.internal.protocol.protobuf.v1.utilities.ProtobufResponseUtilities;
-import org.apache.geode.internal.protocol.serialization.SerializationService;
-import org.apache.geode.internal.protocol.state.ConnectionTerminatingStateProcessor;
-import org.apache.geode.internal.protocol.state.exception.ConnectionStateException;
-import org.apache.geode.internal.protocol.state.exception.OperationNotAuthorizedException;
+import org.apache.geode.internal.protocol.protobuf.v1.serialization.exception.DecodingException;
+import org.apache.geode.internal.protocol.protobuf.v1.serialization.exception.EncodingException;
+import org.apache.geode.internal.protocol.protobuf.v1.state.ProtobufConnectionTerminatingStateProcessor;
+import org.apache.geode.internal.protocol.protobuf.v1.state.exception.ConnectionStateException;
+import org.apache.geode.internal.protocol.protobuf.v1.state.exception.OperationNotAuthorizedException;
-
-  private final SerializationService serializationService;
+  private final ProtobufSerializationService serializationService;
-  public ProtobufOpsProcessor(SerializationService serializationService,
+  public ProtobufOpsProcessor(ProtobufSerializationService serializationService,
-  public ClientProtocol.Response process(ClientProtocol.Request request,
+  public ClientProtocol.Message process(ClientProtocol.Message request,
-    ClientProtocol.Request.RequestAPICase requestType = request.getRequestAPICase();
+    ClientProtocol.Message.MessageTypeCase requestType = request.getMessageTypeCase();
-    OperationContext operationContext =
+    ProtobufOperationContext operationContext =
-      messageExecutionContext.getConnectionStateProcessor()
-          .validateOperation(messageExecutionContext, operationContext);
+      messageExecutionContext.getConnectionStateProcessor().validateOperation(request,
+          serializationService, messageExecutionContext, operationContext);
-    } catch (OperationNotAuthorizedException e) {
-      // Don't move to a terminating state for authorization state failures
-      logger.warn(e.getMessage());
-      result = Failure.of(ProtobufResponseUtilities.makeErrorResponse(e));
-    } catch (ConnectionStateException e) {
-      logger.warn(e.getMessage());
-      messageExecutionContext
-          .setConnectionStateProcessor(new ConnectionTerminatingStateProcessor());
-      result = Failure.of(ProtobufResponseUtilities.makeErrorResponse(e));
+    } catch (VirtualMachineError error) {
+      SystemFailure.initiateFailure(error);
+      throw error;
+    } catch (Throwable t) {
+      logger.warn("Failure for request " + request, t);
+      SystemFailure.checkFailure();
+      result = Failure.of(t);
+
+      if (t instanceof ConnectionStateException) {
+        messageExecutionContext
+            .setConnectionStateProcessor(new ProtobufConnectionTerminatingStateProcessor());
+      }
-    return ((ClientProtocol.Response.Builder) result.map(operationContext.getToResponse(),
+    return ((ClientProtocol.Message.Builder) result.map(operationContext.getToResponse(),
-  private Result processOperation(ClientProtocol.Request request, MessageExecutionContext context,
-      ClientProtocol.Request.RequestAPICase requestType, OperationContext operationContext)
-      throws ConnectionStateException {
+  private Result processOperation(ClientProtocol.Message request, MessageExecutionContext context,
+      ClientProtocol.Message.MessageTypeCase requestType, ProtobufOperationContext operationContext)
+      throws ConnectionStateException, EncodingException, DecodingException {
+
+    long startTime = context.getStatistics().startOperation();
-      return Failure.of(ProtobufResponseUtilities.makeErrorResponse(
-          ProtocolErrorCode.INVALID_REQUEST, "Invalid execution context found for operation."));
+      logger.error(exception);
+      return Failure.of(BasicTypes.ErrorCode.INVALID_REQUEST,
+          "Invalid execution context found for operation.");
+    } finally {
+      context.getStatistics().endOperation(startTime);

GEODE_5402 Disk recovery hangs after killing members (#2148)

GEODE-5402 Fix issue where disk recovery hangs when all members are waiting for other members to proceed.

+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import org.apache.geode.annotations.TestingOnly;
+import org.apache.geode.internal.CopyOnWriteHashSet;
+import org.apache.geode.internal.cache.persistence.PersistentStateQueryMessage.PersistentStateQueryReplyProcessor;
+  private final PersistentStateQueryMessageSenderFactory persistentStateQueryMessageSenderFactory;
+
+    this(cacheDistributionAdvisor, distributedLockService, persistentMemberView, regionPath,
+        diskRegionStats, persistentMemberManager, new PersistentStateQueryMessageSenderFactory());
+  }
+
+  @TestingOnly
+  PersistenceAdvisorImpl(CacheDistributionAdvisor cacheDistributionAdvisor,
+      DistributedLockService distributedLockService, PersistentMemberView persistentMemberView,
+      String regionPath, DiskRegionStats diskRegionStats,
+      PersistentMemberManager persistentMemberManager,
+      PersistentStateQueryMessageSenderFactory persistentStateQueryMessageSenderFactory) {
+    this.persistentStateQueryMessageSenderFactory = persistentStateQueryMessageSenderFactory;
-    equalMembers = new HashSet<>(persistentMemberView.getOfflineAndEqualMembers());
+    equalMembers = new CopyOnWriteHashSet<>(persistentMemberView.getOfflineAndEqualMembers());
-    return PersistentStateQueryMessage.send(members,
-        cacheDistributionAdvisor.getDistributionManager(), regionPath,
-        persistentMemberView.getMyPersistentID(), persistentMemberView.getMyInitializingID());
+    return fetchPersistentStateQueryResults(members,
+        cacheDistributionAdvisor.getDistributionManager(), persistentMemberView.getMyPersistentID(),
+        persistentMemberView.getMyInitializingID());
+  }
+
+  private PersistentStateQueryResults fetchPersistentStateQueryResults(
+      Set<InternalDistributedMember> members, DistributionManager dm,
+      PersistentMemberID persistentMemberID, PersistentMemberID initializingMemberId) {
+    PersistentStateQueryReplyProcessor replyProcessor = persistentStateQueryMessageSenderFactory
+        .createPersistentStateQueryReplyProcessor(dm, members);
+    PersistentStateQueryMessage message =
+        persistentStateQueryMessageSenderFactory.createPersistentStateQueryMessage(regionPath,
+            persistentMemberID, initializingMemberId, replyProcessor.getProcessorId());
+    return message.send(members, dm, replyProcessor);
-              && !id.diskStoreId.equals(getDiskStoreID())) {
+              && !id.getDiskStoreId().equals(getDiskStoreID())) {
-              && !id.diskStoreId.equals(getDiskStoreID())) {
+              && !id.getDiskStoreId().equals(getDiskStoreID())) {
-          runningDiskStores.add(mem.diskStoreId);
+          runningDiskStores.add(mem.getDiskStoreId());
-        equalMembers.removeIf(id -> !runningDiskStores.contains(id.diskStoreId));
+        for (PersistentMemberID id : equalMembers) {
+          if (!runningDiskStores.contains(id.getDiskStoreId())) {
+            equalMembers.remove(id);
+          }
+        }
-    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates.stateOnPeers
+    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates
+        .getStateOnPeers()
-      PersistentMemberID remoteId = remoteStates.persistentIds.get(member);
+      PersistentMemberID remoteId = remoteStates.getPersistentIds().get(member);
-      PersistentStateQueryResults results = PersistentStateQueryMessage.send(members,
-          cacheDistributionAdvisor.getDistributionManager(), regionPath, myPersistentID,
-          myInitializingId);
+      PersistentStateQueryResults results = fetchPersistentStateQueryResults(members,
+          cacheDistributionAdvisor.getDistributionManager(), myPersistentID, myInitializingId);
-        for (Entry<InternalDistributedMember, Set<PersistentMemberID>> entry : results.onlineMemberMap
+        for (Entry<InternalDistributedMember, Set<PersistentMemberID>> entry : results
+            .getOnlineMemberMap()
-          PersistentMemberID persistentID = results.persistentIds.get(memberId);
-          PersistentMemberID initializingID = results.initializingIds.get(memberId);
+          PersistentMemberID persistentID = results.getPersistentIds().get(memberId);
+          PersistentMemberID initializingID = results.getInitializingIds().get(memberId);
-                  && !peerOnlineMember.diskStoreId.equals(getDiskStoreID())
+                  && !peerOnlineMember.getDiskStoreId().equals(getDiskStoreID())
+      removeOlderMembers(membersToWaitFor);
-      for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : results.stateOnPeers
-          .entrySet()) {
+      for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : results
+          .getStateOnPeers().entrySet()) {
-        PersistentMemberID persistentID = results.persistentIds.get(memberId);
-        PersistentMemberID initializingID = results.initializingIds.get(memberId);
-        DiskStoreID diskStoreID = results.diskStoreIds.get(memberId);
+        PersistentMemberID persistentID = results.getPersistentIds().get(memberId);
+        PersistentMemberID initializingID = results.getInitializingIds().get(memberId);
+        DiskStoreID diskStoreID = results.getDiskStoreIds().get(memberId);
-          removeNewerPersistentID(membersToWaitFor, initializingID);
+          removeByDiskStoreID(membersToWaitFor, diskStoreID, false);
-          removeByDiskStoreID(membersToWaitFor, diskStoreID);
-          removeByDiskStoreID(offlineMembers, diskStoreID);
+          removeByDiskStoreID(membersToWaitFor, diskStoreID, true);
+          removeByDiskStoreID(offlineMembers, diskStoreID, true);
-
+   * Given a set of persistent members, if the same member occurs more than once in the set but
+   * with different timestamps, remove the older ones leaving only the most recent.
+   *
+   * @param persistentMemberSet The set of persistent members, possibly modified by this method.
+   */
+  protected void removeOlderMembers(Set<PersistentMemberID> persistentMemberSet) {
+    Map<DiskStoreID, PersistentMemberID> mostRecentMap = new HashMap<>();
+    List<PersistentMemberID> idsToRemove = new ArrayList<>();
+    for (PersistentMemberID persistentMember : persistentMemberSet) {
+      DiskStoreID diskStoreId = persistentMember.getDiskStoreId();
+      PersistentMemberID mostRecent = mostRecentMap.get(diskStoreId);
+      if (mostRecent == null) {
+        mostRecentMap.put(diskStoreId, persistentMember);
+      } else {
+        PersistentMemberID older = persistentMember;
+        boolean persistentMemberIsNewer =
+            !persistentMember.isOlderOrEqualVersionOf(mostRecent);
+        if (persistentMemberIsNewer) {
+          older = mostRecent;
+          mostRecentMap.put(diskStoreId, persistentMember);
+        }
+        idsToRemove.add(older);
+      }
+    }
+    persistentMemberSet.removeAll(idsToRemove);
+  }
+
+  /**
-      DiskStoreID diskStoreID) {
+      DiskStoreID diskStoreID, boolean updateAdvisor) {
-      if (id.diskStoreId.equals(diskStoreID)) {
+      if (id.getDiskStoreId().equals(diskStoreID)) {
-              "{}-{}: Not waiting for {} because it no longer has this region in it's disk store",
+              "{}-{}: Not waiting for {} because it no longer has this region in its disk store",
-        memberRemoved(id, false);
+        if (updateAdvisor) {
+          memberRemoved(id, false);
+        }

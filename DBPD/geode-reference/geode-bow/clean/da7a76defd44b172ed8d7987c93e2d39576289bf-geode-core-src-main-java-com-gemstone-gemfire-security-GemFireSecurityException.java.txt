Merge branch 'develop' into feature/GEODE-17-2

-
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import javax.naming.NamingException;
+
-private static final long serialVersionUID = 3814254578203076926L;
+
+  private static final long serialVersionUID = 3814254578203076926L;
+
+  private Throwable cause;
-   * Constructs instance of <code>SecurityException</code> with error message.
-   * 
-   * @param message
-   *                the error message
+   * Constructs a new exception with the specified detail message.
+   *
+   * @param  message the detail message (which is saved for later retrieval
+   *         by the {@link #getMessage()} method).  (A <tt>null</tt> value
+   *         is permitted.)
-  public GemFireSecurityException(String message) {
-    super(message);
+  public GemFireSecurityException(final String message) {
+    this(message, null);
-   * Constructs instance of <code>SecurityException</code> with error message
-   * and cause.
-   * 
-   * @param message
-   *                the error message
-   * @param cause
-   *                a <code>Throwable</code> that is a cause of this exception
+   * Constructs a new exception with the specified cause.
+   *
+   * <p>Note that the detail message associated with {@code cause} <i>is</i>
+   * automatically used as this exception's detail message.
+   *
+   * @param  cause the cause (which is saved for later retrieval by the
+   *         {@link #getCause()} method).  (A <tt>null</tt> value is
+   *         permitted, and indicates that the cause is nonexistent or
+   *         unknown.)
-  public GemFireSecurityException(String message, Throwable cause) {
-    super(message, cause);
+  public GemFireSecurityException(final Throwable cause) {
+    this(cause != null ? cause.getMessage() : null, cause);
+  /**
+   * Constructs a new exception with the specified detail message and cause.
+   *
+   * <p>If {@code message} is null, then the detail message associated with
+   * {@code cause} <i>is</i> automatically used as this exception's detail
+   * message.
+   *
+   * @param  message the detail message (which is saved for later retrieval
+   *         by the {@link #getMessage()} method).  (A <tt>null</tt> value
+   *         is permitted.)
+   * @param  cause the cause (which is saved for later retrieval by the
+   *         {@link #getCause()} method).  (A <tt>null</tt> value is
+   *         permitted, and indicates that the cause is nonexistent or
+   *         unknown.)
+   */
+  public GemFireSecurityException(final String message, final Throwable cause) {
+    super(message != null ? message : (cause != null ? cause.getMessage() : null));
+    this.cause = cause;
+  }
+
+  @Override
+  public final synchronized Throwable getCause() {
+    return (this.cause == this ? null : this.cause);
+  }
+
+  /**
+   * Returns true if the provided {@code object} implements {@code Serializable}.
+   *
+   * @param  object the {@code object} to test for implementing {@code Serializable}.
+   * @return true if the provided {@code object} implements {@code Serializable}.
+   */
+  protected final boolean isSerializable(final Object object) {
+    if (object == null) {
+      return true;
+    }
+    return Serializable.class.isInstance(object);
+  }
+
+  /**
+   * Returns {@link NamingException#getResolvedObj()} if the {@code cause}
+   * is a {@code NamingException}. Returns <tt>null</tt> for any other type
+   * of {@code cause}.
+   *
+   * @return {@code NamingException#getResolvedObj()} if the {@code cause}
+   *         is a {@code NamingException}.
+   */
+  protected final Object getResolvedObj() {
+    final Throwable thisCause = this.cause;
+    if (thisCause != null && NamingException.class.isInstance(thisCause)) {
+      return ((NamingException) thisCause).getResolvedObj();
+    }
+    return null;
+  }
+
+  private synchronized void writeObject(final ObjectOutputStream out) throws IOException {
+    final Object resolvedObj = getResolvedObj();
+    if (isSerializable(resolvedObj)) {
+      out.defaultWriteObject();
+    } else {
+      final NamingException namingException = (NamingException) getCause();
+      namingException.setResolvedObj(null);
+      try {
+        out.defaultWriteObject();
+      } finally {
+        namingException.setResolvedObj(resolvedObj);
+      }
+    }
+  }

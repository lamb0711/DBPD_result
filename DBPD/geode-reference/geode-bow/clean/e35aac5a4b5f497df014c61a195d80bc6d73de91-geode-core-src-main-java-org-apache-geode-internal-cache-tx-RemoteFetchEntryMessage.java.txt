Merge branch 'release/1.5.0'

-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Collections;
-import org.apache.geode.admin.OperationCancelledException;
-import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
+import org.apache.geode.internal.cache.EntrySnapshot;
+import org.apache.geode.internal.cache.KeyInfo;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.NonLocalRegionEntry;
+import org.apache.geode.internal.cache.RemoteOperationException;
- * {@link org.apache.geode.internal.cache.RemoteFetchEntryMessage.FetchEntryReplyMessage}.
+ * {@link org.apache.geode.internal.cache.tx.RemoteFetchEntryMessage.FetchEntryReplyMessage}.
-   * @param key the object to which the value should be feteched
+   * @param key the object to which the value should be fetched
-    FetchEntryResponse p =
-        new FetchEntryResponse(r.getSystem(), Collections.singleton(recipient), r, key);
+    FetchEntryResponse p = new FetchEntryResponse(r.getSystem(), recipient, r, key);
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
-  }
-
-  @Override
-  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+  protected boolean operateOnRegion(ClusterDistributionManager dm, LocalRegion r, long startTime)
-    // RemoteFetchEntryMessage is used in refreshing client caches during interest list recovery,
-    // so don't be too verbose or hydra tasks may time out
-
-    if (!(r instanceof PartitionedRegion)) {
-      r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-    }
+    r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-      Region.Entry re = r.getDataView().getEntry(keyInfo, r, true);
+      Region.Entry<?, ?> re = r.getDataView().getEntry(keyInfo, r, true);
-      // r.getPrStats().endRemoteOperationMessagesProcessing(startTime);
-    } catch (PrimaryBucketException pbe) {
-      FetchEntryReplyMessage.send(getSender(), getProcessorId(), null, dm, new ReplyException(pbe));
-        EntrySnapshot value, DM dm, ReplyException re) {
+        EntrySnapshot value, DistributionManager dm, ReplyException re) {
-    public void process(final DM dm, final ReplyProcessor21 processor) {
+    public void process(final DistributionManager dm, final ReplyProcessor21 processor) {
-        // since the Entry object shares state with the PartitionedRegion,
-        // we have to find the region and ask it to create a new Entry instance
-        // to be populated from the DataInput
-        FetchEntryResponse processor =
-            (FetchEntryResponse) ReplyProcessor21.getProcessor(this.processorId);
-        if (processor == null) {
-          throw new OperationCancelledException("This operation was cancelled (null processor)");
-        }
-        this.value = new EntrySnapshot(in, processor.region);
+        // EntrySnapshot.setRegion is called later
+        this.value = new EntrySnapshot(in, null);
-   * {@link org.apache.geode.internal.cache.RemoteFetchEntryMessage.FetchEntryReplyMessage}
+   * {@link org.apache.geode.internal.cache.tx.RemoteFetchEntryMessage.FetchEntryReplyMessage}
-    public FetchEntryResponse(InternalDistributedSystem ds, Set recipients, LocalRegion theRegion,
-        Object key) {
-      super(ds, recipients);
+    public FetchEntryResponse(InternalDistributedSystem ds, InternalDistributedMember recipient,
+        LocalRegion theRegion, Object key) {
+      super(ds, recipient);
+          if (this.returnValue != null) {
+            this.returnValue.setRegion(this.region);
+          }
-     * @throws EntryNotFoundException
-     * @throws EntryNotFoundException
-        // waitForRepliesUninterruptibly();
-        waitForCacheException();
-      } catch (RemoteOperationException e) {
-        e.checkKey(key);
-        final String msg = "FetchEntryResponse got remote RemoteOperationException; rethrowing";
-        logger.debug(msg, e);
-        throw e;
-      } catch (EntryNotFoundException e) {
-        throw e;
-      } catch (TransactionException e) {
-        throw e;
-      } catch (RegionDestroyedException e) {
+        waitForRemoteResponse();
+      } catch (EntryNotFoundException | TransactionException e) {
-        logger.debug("FetchEntryResponse got remote CacheException; forcing reattempt.", ce);
-        throw new RemoteOperationException(
-            LocalizedStrings.RemoteFetchEntryMessage_FETCHENTRYRESPONSE_GOT_REMOTE_CACHEEXCEPTION_FORCING_REATTEMPT
-                .toLocalizedString(),
+        logger.debug("FetchEntryResponse failed with remote CacheException", ce);
+        throw new RemoteOperationException("FetchEntryResponse failed with remote CacheException",

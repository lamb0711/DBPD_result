Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.cache.query.internal.parse.OQLLexer;
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import org.apache.geode.cache.query.internal.parse.OQLParser;
-import antlr.collections.AST;
-import antlr.debug.misc.ASTFrame;
-
-import org.apache.geode.cache.query.QueryException;
-import org.apache.geode.cache.query.internal.parse.OQLLexer;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.cache.query.internal.parse.OQLParser;
-import org.apache.geode.i18n.LogWriterI18n;
- * @version     $Revision: 1.1 $s
+ * @version $Revision: 1.1 $s
-  
-  private Stack stack = new Stack ();
-  private Map imports = new HashMap ();
+
+  private Stack stack = new Stack();
+  private Map imports = new HashMap();
-    
-  /* compile the string into a Query (returns the root CompiledValue)
+
+  /*
+   * compile the string into a Query (returns the root CompiledValue)
-  public CompiledValue compileQuery(String oqlSource) {  
+  public CompiledValue compileQuery(String oqlSource) {
-      OQLLexer lexer = new OQLLexer (new StringReader (oqlSource));
-      OQLParser parser = new OQLParser (lexer);
+      OQLLexer lexer = new OQLLexer(new StringReader(oqlSource));
+      OQLParser parser = new OQLParser(lexer);
-      parser.setASTNodeClass ("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
-      parser.queryProgram ();
-      GemFireAST n = (GemFireAST)parser.getAST ();
+      parser.setASTNodeClass("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
+      parser.queryProgram();
+      GemFireAST n = (GemFireAST) parser.getAST();
-    } catch (Exception ex){ // This is to make sure that we are wrapping any antlr exception with GemFire Exception. 
-      throw new QueryInvalidException(LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()), ex);
+    } catch (Exception ex) { // This is to make sure that we are wrapping any antlr exception with
+                             // GemFire Exception.
+      throw new QueryInvalidException(
+          LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()),
+          ex);
-    Assert.assertTrue (stackSize () == 1, "stack size = " + stackSize ());
-    return (CompiledValue)pop ();
+    Assert.assertTrue(stackSize() == 1, "stack size = " + stackSize());
+    return (CompiledValue) pop();
-  
+
-      OQLLexer lexer = new OQLLexer (new StringReader (fromClause));
-      OQLParser parser = new OQLParser (lexer);
+      OQLLexer lexer = new OQLLexer(new StringReader(fromClause));
+      OQLParser parser = new OQLParser(lexer);
-      parser.setASTNodeClass ("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
-      parser.loneFromClause ();
-      GemFireAST n = (GemFireAST)parser.getAST ();
+      parser.setASTNodeClass("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
+      parser.loneFromClause();
+      GemFireAST n = (GemFireAST) parser.getAST();
-    } catch (Exception ex){ // This is to make sure that we are wrapping any antlr exception with GemFire Exception. 
-      throw new QueryInvalidException(LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()), ex);
+    } catch (Exception ex) { // This is to make sure that we are wrapping any antlr exception with
+                             // GemFire Exception.
+      throw new QueryInvalidException(
+          LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()),
+          ex);
-    Assert.assertTrue (stackSize () == 1, "stack size = " + stackSize ());
-    return (List)pop ();
+    Assert.assertTrue(stackSize() == 1, "stack size = " + stackSize());
+    return (List) pop();
-  
+
-      OQLLexer lexer = new OQLLexer (new StringReader (projectionAttributes));
-      OQLParser parser = new OQLParser (lexer);
+      OQLLexer lexer = new OQLLexer(new StringReader(projectionAttributes));
+      OQLParser parser = new OQLParser(lexer);
-      parser.setASTNodeClass ("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
-      parser.loneProjectionAttributes ();
-      GemFireAST n = (GemFireAST)parser.getAST ();
+      parser.setASTNodeClass("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
+      parser.loneProjectionAttributes();
+      GemFireAST n = (GemFireAST) parser.getAST();
-      if (n.getType () == TOK_STAR) {
+      if (n.getType() == TOK_STAR) {
-    } catch (Exception ex){ // This is to make sure that we are wrapping any antlr exception with GemFire Exception. 
-      throw new QueryInvalidException(LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()), ex);
+    } catch (Exception ex) { // This is to make sure that we are wrapping any antlr exception with
+                             // GemFire Exception.
+      throw new QueryInvalidException(
+          LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()),
+          ex);
-    Assert.assertTrue(stackSize () == 1,
-        "stack size = " + stackSize () +
-        ";stack=" + this.stack);
-    return (List)pop ();
+    Assert.assertTrue(stackSize() == 1, "stack size = " + stackSize() + ";stack=" + this.stack);
+    return (List) pop();
-  
+
-   * Yogesh: compiles order by clause and push into the stack  
+   * Yogesh: compiles order by clause and push into the stack
+   * 
-  	List list = new ArrayList(); 
-  	for (int i = 0; i < numOfChildren; i++) {
-  	  CompiledSortCriterion csc = (CompiledSortCriterion)this.stack.pop();
-  	  list.add(0, csc);
-  	}
-  	push(list) ;
+    List list = new ArrayList();
+    for (int i = 0; i < numOfChildren; i++) {
+      CompiledSortCriterion csc = (CompiledSortCriterion) this.stack.pop();
+      list.add(0, csc);
+    }
+    push(list);
-  
+
+
+   * 
-  	
-  	CompiledValue obj = (CompiledValue)this.stack.pop();
-  	boolean criterion = false;
-  	if (sortCriterion.equals("desc")) 
-  	  criterion = true; 	
-  	CompiledSortCriterion csc = new CompiledSortCriterion(criterion, obj);
-  	push(csc);
-    
+
+    CompiledValue obj = (CompiledValue) this.stack.pop();
+    boolean criterion = false;
+    if (sortCriterion.equals("desc"))
+      criterion = true;
+    CompiledSortCriterion csc = new CompiledSortCriterion(criterion, obj);
+    push(csc);
+
-  
-  public void compileLimit(String limitNum) {  
+
+  public void compileLimit(String limitNum) {
-  
-  /** Processes import statements only. This compiler instance remembers the imports
-   *  and can be used to compile other strings with this context info
+
+  /**
+   * Processes import statements only. This compiler instance remembers the imports and can be used
+   * to compile other strings with this context info
-      OQLLexer lexer = new OQLLexer (new StringReader (imports));
-      OQLParser parser = new OQLParser (lexer);
+      OQLLexer lexer = new OQLLexer(new StringReader(imports));
+      OQLParser parser = new OQLParser(lexer);
-      parser.setASTNodeClass ("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
+      parser.setASTNodeClass("org.apache.geode.cache.query.internal.parse.ASTUnsupported");
-      GemFireAST n = (GemFireAST)parser.getAST ();
+      GemFireAST n = (GemFireAST) parser.getAST();
-    } catch (Exception ex){ // This is to make sure that we are wrapping any antlr exception with GemFire Exception. 
-      throw new QueryInvalidException(LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()), ex);
+    } catch (Exception ex) { // This is to make sure that we are wrapping any antlr exception with
+                             // GemFire Exception.
+      throw new QueryInvalidException(
+          LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString(ex.getMessage()),
+          ex);
-    Assert.assertTrue(stackSize() == 0,
-        "stack size = " + stackSize() +
-        ";stack=" + this.stack);
+    Assert.assertTrue(stackSize() == 0, "stack size = " + stackSize() + ";stack=" + this.stack);
-  
+
-    
+
-    List<CompiledSortCriterion> orderByAttrs = (List<CompiledSortCriterion>) queryComponents
-        .remove(OQLLexerTokenTypes.LITERAL_order);
+    List<CompiledSortCriterion> orderByAttrs =
+        (List<CompiledSortCriterion>) queryComponents.remove(OQLLexerTokenTypes.LITERAL_order);
-    List iterators = (List) queryComponents
-        .remove(OQLLexerTokenTypes.LITERAL_from);
-    List projAttrs = (List) queryComponents
-        .remove(OQLLexerTokenTypes.PROJECTION_ATTRS);
+    List iterators = (List) queryComponents.remove(OQLLexerTokenTypes.LITERAL_from);
+    List projAttrs = (List) queryComponents.remove(OQLLexerTokenTypes.PROJECTION_ATTRS);
-    /*String aggrExpr = (String) queryComponents
-        .remove(OQLLexerTokenTypes.LITERAL_count);*/
-    
+    /*
+     * String aggrExpr = (String) queryComponents .remove(OQLLexerTokenTypes.LITERAL_count);
+     */
+
-    String distinct = (String) queryComponents
-        .remove(OQLLexerTokenTypes.LITERAL_distinct);
-   List<String> hints = null;
+    String distinct = (String) queryComponents.remove(OQLLexerTokenTypes.LITERAL_distinct);
+    List<String> hints = null;
-    List<CompiledValue> groupByClause = (List<CompiledValue>) queryComponents
-        .remove(OQLLexerTokenTypes.LITERAL_group);
+    List<CompiledValue> groupByClause =
+        (List<CompiledValue>) queryComponents.remove(OQLLexerTokenTypes.LITERAL_group);
-      throw new QueryInvalidException(
-          "Unexpected/unsupported query clauses found");
+      throw new QueryInvalidException("Unexpected/unsupported query clauses found");
-    LinkedHashMap<Integer, CompiledAggregateFunction> aggMap = identifyAggregateExpressions(projAttrs);
+    LinkedHashMap<Integer, CompiledAggregateFunction> aggMap =
+        identifyAggregateExpressions(projAttrs);
-    if(isCountOnly) {
+    if (isCountOnly) {
-    CompiledSelect select = createSelect(distinct != null,
-        isCountOnly, where, iterators, projAttrs, orderByAttrs, limit,
-        hints, groupByClause, aggMap);
+    CompiledSelect select = createSelect(distinct != null, isCountOnly, where, iterators, projAttrs,
+        orderByAttrs, limit, hints, groupByClause, aggMap);
-  
-  private boolean checkForCountOnly(
-      Map<Integer, CompiledAggregateFunction> aggregateMap, List projAttribs, List<CompiledValue> groupBy) {
-    if (aggregateMap != null && aggregateMap.size() == 1
-        && projAttribs.size() == 1 && groupBy == null) {
-      for (Map.Entry<Integer, CompiledAggregateFunction> entry : aggregateMap
-          .entrySet()) {
+
+  private boolean checkForCountOnly(Map<Integer, CompiledAggregateFunction> aggregateMap,
+      List projAttribs, List<CompiledValue> groupBy) {
+    if (aggregateMap != null && aggregateMap.size() == 1 && projAttribs.size() == 1
+        && groupBy == null) {
+      for (Map.Entry<Integer, CompiledAggregateFunction> entry : aggregateMap.entrySet()) {
-        if (caf.getFunctionType() == OQLLexerTokenTypes.COUNT
-            && caf.getParameter() == null) {
+        if (caf.getFunctionType() == OQLLexerTokenTypes.COUNT && caf.getParameter() == null) {
-  
+
-      List<String> hints,List<CompiledValue> groupByClause, LinkedHashMap<Integer, 
-      CompiledAggregateFunction> aggMap    ) {
-    if(isCountOnly || (groupByClause == null  && aggMap == null) 
-        || (aggMap == null  && orderByAttrs == null)) {
-      return  new CompiledSelect(isDistinct,
-          isCountOnly, where, iterators, projAttrs, orderByAttrs, limit,
-          hints, groupByClause);
-    }else {
-      return new CompiledGroupBySelect(isDistinct,
-          isCountOnly, where, iterators, projAttrs, orderByAttrs, limit,
-          hints, groupByClause, aggMap);
+      List<String> hints, List<CompiledValue> groupByClause,
+      LinkedHashMap<Integer, CompiledAggregateFunction> aggMap) {
+    if (isCountOnly || (groupByClause == null && aggMap == null)
+        || (aggMap == null && orderByAttrs == null)) {
+      return new CompiledSelect(isDistinct, isCountOnly, where, iterators, projAttrs, orderByAttrs,
+          limit, hints, groupByClause);
+    } else {
+      return new CompiledGroupBySelect(isDistinct, isCountOnly, where, iterators, projAttrs,
+          orderByAttrs, limit, hints, groupByClause, aggMap);
-  
-  private LinkedHashMap<Integer, CompiledAggregateFunction> identifyAggregateExpressions(List projAttribs) {
-    if(projAttribs != null) {
-      LinkedHashMap<Integer, CompiledAggregateFunction> mapping = new LinkedHashMap<Integer,CompiledAggregateFunction>();
+
+  private LinkedHashMap<Integer, CompiledAggregateFunction> identifyAggregateExpressions(
+      List projAttribs) {
+    if (projAttribs != null) {
+      LinkedHashMap<Integer, CompiledAggregateFunction> mapping =
+          new LinkedHashMap<Integer, CompiledAggregateFunction>();
-      for(Object o : projAttribs) {
-        CompiledValue proj =(CompiledValue) ((Object[])o)[1];
-        if( proj.getType() == OQLLexerTokenTypes.AGG_FUNC) {
-          mapping.put(index, (CompiledAggregateFunction)proj);
+      for (Object o : projAttribs) {
+        CompiledValue proj = (CompiledValue) ((Object[]) o)[1];
+        if (proj.getType() == OQLLexerTokenTypes.AGG_FUNC) {
+          mapping.put(index, (CompiledAggregateFunction) proj);
-    }else {
+    } else {
-    
+
-  public void projection () {
+
+  public void projection() {
-    CompiledID id = (CompiledID)pop ();
-    CompiledValue expr = (CompiledValue)pop ();
-    push (new Object[] {id == null ? null : id.getId (), expr});
+    CompiledID id = (CompiledID) pop();
+    CompiledValue expr = (CompiledValue) pop();
+    push(new Object[] {id == null ? null : id.getId(), expr});
-  
-  public void aggregateFunction (CompiledValue expr, int aggFuncType, boolean distinctOnly) {
-    push (new CompiledAggregateFunction(expr, aggFuncType, distinctOnly));
+
+  public void aggregateFunction(CompiledValue expr, int aggFuncType, boolean distinctOnly) {
+    push(new CompiledAggregateFunction(expr, aggFuncType, distinctOnly));
-  
-  public void iteratorDef () {
-    // find type id  and colln on the stack
-    
-    ObjectType type = assembleType(); // can be null    
-    CompiledID id = (CompiledID)TypeUtils.checkCast(pop(), CompiledID.class); // can be null
-    CompiledValue colln = (CompiledValue)TypeUtils.checkCast(pop(), CompiledValue.class);
-    
+
+  public void iteratorDef() {
+    // find type id and colln on the stack
+
+    ObjectType type = assembleType(); // can be null
+    CompiledID id = (CompiledID) TypeUtils.checkCast(pop(), CompiledID.class); // can be null
+    CompiledValue colln = (CompiledValue) TypeUtils.checkCast(pop(), CompiledValue.class);
+
-    
-    push (new CompiledIteratorDef (id == null ? null : id.getId (),
-                                   type, colln));
+
+    push(new CompiledIteratorDef(id == null ? null : id.getId(), type, colln));
-  
-  
-  public void undefinedExpr (boolean is_defined) {
-    CompiledValue value = (CompiledValue)pop ();
-    push (new CompiledUndefined (value, is_defined));
+
+
+  public void undefinedExpr(boolean is_defined) {
+    CompiledValue value = (CompiledValue) pop();
+    push(new CompiledUndefined(value, is_defined));
-  
-  public void function (int function, int numOfChildren) {
-    CompiledValue [] cvArr = new CompiledValue[numOfChildren];
-    for(int i = numOfChildren - 1; i >= 0; i-- ) {
-      cvArr[i] = (CompiledValue) pop(); 
+
+  public void function(int function, int numOfChildren) {
+    CompiledValue[] cvArr = new CompiledValue[numOfChildren];
+    for (int i = numOfChildren - 1; i >= 0; i--) {
+      cvArr[i] = (CompiledValue) pop();
-  
-  public void inExpr () {
-    CompiledValue collnExpr = (CompiledValue)TypeUtils.checkCast (pop (), CompiledValue.class);
-    CompiledValue elm = (CompiledValue)TypeUtils.checkCast (pop (), CompiledValue.class);
-    push (new CompiledIn (elm, collnExpr));
+
+  public void inExpr() {
+    CompiledValue collnExpr = (CompiledValue) TypeUtils.checkCast(pop(), CompiledValue.class);
+    CompiledValue elm = (CompiledValue) TypeUtils.checkCast(pop(), CompiledValue.class);
+    push(new CompiledIn(elm, collnExpr));
-  
-  public void constructObject (Class clazz) {
+
+  public void constructObject(Class clazz) {
-    Assert.assertTrue (clazz == ResultsSet.class);
-    List argList = (List)TypeUtils.checkCast (pop (), List.class);
-    push (new CompiledConstruction (clazz, argList));
+    Assert.assertTrue(clazz == ResultsSet.class);
+    List argList = (List) TypeUtils.checkCast(pop(), List.class);
+    push(new CompiledConstruction(clazz, argList));
-  
-  public void pushId (String id) {
-    push (new CompiledID (id));
+
+  public void pushId(String id) {
+    push(new CompiledID(id));
-  
-  public void pushRegion (String regionPath) {
-    push (new CompiledRegion (regionPath));
+
+  public void pushRegion(String regionPath) {
+    push(new CompiledRegion(regionPath));
-  
-  public void appendPathComponent (String id) {
-    CompiledValue rcvr = (CompiledValue)pop ();
-    push (new CompiledPath (rcvr, id));
+
+  public void appendPathComponent(String id) {
+    CompiledValue rcvr = (CompiledValue) pop();
+    push(new CompiledPath(rcvr, id));
-  
-  
-  public void pushBindArgument (int i) {
-    push (new CompiledBindArgument (i));
+
+
+  public void pushBindArgument(int i) {
+    push(new CompiledBindArgument(i));
-  
-  
-  public void pushLiteral (Object obj) {
-    push (new CompiledLiteral (obj));
+
+
+  public void pushLiteral(Object obj) {
+    push(new CompiledLiteral(obj));
-  
-  public void pushNull () // used as a placeholder for a missing clause
+
+  public void pushNull() // used as a placeholder for a missing clause
-    push (null);
+    push(null);
-  
-  
-  public void combine (int num) {
-    List list = new ArrayList ();
-    for (int i =0; i < num; i++) {
-      list.add (0,pop ());
+
+
+  public void combine(int num) {
+    List list = new ArrayList();
+    for (int i = 0; i < num; i++) {
+      list.add(0, pop());
-    push (list);
+    push(list);
-  
-  
-  public void methodInvocation () {
+
+
+  public void methodInvocation() {
-    List argList = (List)TypeUtils.checkCast (pop (), List.class);
-    CompiledID methodName = (CompiledID)TypeUtils.checkCast (pop (), CompiledID.class);
-    CompiledValue rcvr = (CompiledValue)TypeUtils.checkCast (pop (), CompiledValue.class);
-    push (new CompiledOperation (rcvr, methodName.getId (), argList));
+    List argList = (List) TypeUtils.checkCast(pop(), List.class);
+    CompiledID methodName = (CompiledID) TypeUtils.checkCast(pop(), CompiledID.class);
+    CompiledValue rcvr = (CompiledValue) TypeUtils.checkCast(pop(), CompiledValue.class);
+    push(new CompiledOperation(rcvr, methodName.getId(), argList));
-  
-  public void indexOp()
-  {
+
+  public void indexOp() {
-    final CompiledValue rcvr = (CompiledValue)TypeUtils.checkCast(pop(),
-        CompiledValue.class);
+    final CompiledValue rcvr = (CompiledValue) TypeUtils.checkCast(pop(), CompiledValue.class);
-      final List indexList = (List)TypeUtils.checkCast(indexParams, List.class);
+      final List indexList = (List) TypeUtils.checkCast(indexParams, List.class);
-            LocalizedStrings.QCompiler_ONLY_ONE_INDEX_EXPRESSION_SUPPORTED
-                .toLocalizedString());
+            LocalizedStrings.QCompiler_ONLY_ONE_INDEX_EXPRESSION_SUPPORTED.toLocalizedString());
-        indexExpr = (CompiledValue)TypeUtils.checkCast(indexList.get(0),
-            CompiledValue.class);
+        indexExpr = (CompiledValue) TypeUtils.checkCast(indexList.get(0), CompiledValue.class);
-        indexExpr = (CompiledValue)TypeUtils.checkCast(indexList.get(0),
-            CompiledValue.class);
+        indexExpr = (CompiledValue) TypeUtils.checkCast(indexList.get(0), CompiledValue.class);
-      }
-      else {
+      } else {
-        
+
-      }    
-    }else {
-      if(!this.isForIndexCompilation) {
-        throw new QueryInvalidException(
-            LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0.toLocalizedString("* use incorrect")); 
+      }
+    } else {
+      if (!this.isForIndexCompilation) {
+        throw new QueryInvalidException(LocalizedStrings.QCompiler_SYNTAX_ERROR_IN_QUERY_0
+            .toLocalizedString("* use incorrect"));
-  
- 
+
+
-   * Creates appropriate CompiledValue for the like predicate based on the
-   * sargability of the String or otherwise. It also works on the last character
-   * to see if the sargable like predicate results in a CompiledJunction or a
-   * Comparison. Currently we are supporting only the '%' terminated "like"
-   * predicate.
+   * Creates appropriate CompiledValue for the like predicate based on the sargability of the String
+   * or otherwise. It also works on the last character to see if the sargable like predicate results
+   * in a CompiledJunction or a Comparison. Currently we are supporting only the '%' terminated
+   * "like" predicate.
-   * @param var
-   *                The CompiledValue representing the variable
-   * @param patternOrBindParam
-   *                The CompiledLiteral reprsenting the pattern of the like
-   *                predicate
+   * @param var The CompiledValue representing the variable
+   * @param patternOrBindParam The CompiledLiteral reprsenting the pattern of the like predicate
-    if(!(patternOrBindParam.getType() == CompiledBindArgument.QUERY_PARAM)) {
-      CompiledLiteral pattern = (CompiledLiteral)patternOrBindParam;
+    if (!(patternOrBindParam.getType() == CompiledBindArgument.QUERY_PARAM)) {
+      CompiledLiteral pattern = (CompiledLiteral) patternOrBindParam;
-        throw new UnsupportedOperationException("Null values are not supported with LIKE predicate.");
+        throw new UnsupportedOperationException(
+            "Null values are not supported with LIKE predicate.");
-    // From 6.6 Like is enhanced to support special character (% and _) at any 
+    // From 6.6 Like is enhanced to support special character (% and _) at any
-    return new CompiledLike(var,patternOrBindParam);
-  }  
-  
+    return new CompiledLike(var, patternOrBindParam);
+  }
+
-    CompiledValue v2 = (CompiledValue)pop();
-    CompiledValue v1 = (CompiledValue)pop();
+    CompiledValue v2 = (CompiledValue) pop();
+    CompiledValue v1 = (CompiledValue) pop();
-  
-  
-  
-  public void compare (int opKind) {
-    CompiledValue v2 = (CompiledValue)pop ();
-    CompiledValue v1 = (CompiledValue)pop ();
-    push (new CompiledComparison (v1, v2, opKind));
-  }
-  
-  public void or (int numTerms) {
-    junction (numTerms, LITERAL_or);
-  }
-  
-  public void and (int numTerms) {
-    junction (numTerms, LITERAL_and);
-  }
-  
-  private void junction (int numTerms, int operator) {
-            /* if any of the operands are junctions with same operator as this one
-             * then flatten */
-    List operands = new ArrayList (numTerms);
-    for (int i = 0; i < numTerms; i++) {
-      CompiledValue operand = (CompiledValue)pop ();
-      // flatten if we can
-      if (operand instanceof CompiledJunction &&
-              ((CompiledJunction)operand).getOperator () == operator) {
-        CompiledJunction junction = (CompiledJunction)operand;
-        List jOperands = junction.getOperands ();
-        for (int j = 0; j < jOperands.size (); j++)
-          operands.add (jOperands.get (j));
-      } else
-        operands.add (operand);
-    }
-    
-    push (new CompiledJunction (
-            (CompiledValue[])operands.toArray (new CompiledValue[operands.size ()]),
-            operator));
-  }
-  
-  
-  
-  public void not () {
-    Object obj = this.stack.peek ();
-    Assert.assertTrue (obj instanceof CompiledValue);
-    
-    if (obj instanceof Negatable)
-      ((Negatable)obj).negate ();
-    else
-      push(new CompiledNegation ((CompiledValue)pop ()));
-  }
-  
-  public void unaryMinus() {
-    Object obj = this.stack.peek ();
-    Assert.assertTrue (obj instanceof CompiledValue);
-    push(new CompiledUnaryMinus ((CompiledValue)pop ()));
-  } 
-  
+
+
+  public void compare(int opKind) {
+    CompiledValue v2 = (CompiledValue) pop();
+    CompiledValue v1 = (CompiledValue) pop();
+    push(new CompiledComparison(v1, v2, opKind));
+  }
+
+  public void or(int numTerms) {
+    junction(numTerms, LITERAL_or);
+  }
+
+  public void and(int numTerms) {
+    junction(numTerms, LITERAL_and);
+  }
+
+  private void junction(int numTerms, int operator) {
+    /*
+     * if any of the operands are junctions with same operator as this one then flatten
+     */
+    List operands = new ArrayList(numTerms);
+    for (int i = 0; i < numTerms; i++) {
+      CompiledValue operand = (CompiledValue) pop();
+      // flatten if we can
+      if (operand instanceof CompiledJunction
+          && ((CompiledJunction) operand).getOperator() == operator) {
+        CompiledJunction junction = (CompiledJunction) operand;
+        List jOperands = junction.getOperands();
+        for (int j = 0; j < jOperands.size(); j++)
+          operands.add(jOperands.get(j));
+      } else
+        operands.add(operand);
+    }
+
+    push(new CompiledJunction(
+        (CompiledValue[]) operands.toArray(new CompiledValue[operands.size()]), operator));
+  }
+
+
+
+  public void not() {
+    Object obj = this.stack.peek();
+    Assert.assertTrue(obj instanceof CompiledValue);
+
+    if (obj instanceof Negatable)
+      ((Negatable) obj).negate();
+    else
+      push(new CompiledNegation((CompiledValue) pop()));
+  }
+
+  public void unaryMinus() {
+    Object obj = this.stack.peek();
+    Assert.assertTrue(obj instanceof CompiledValue);
+    push(new CompiledUnaryMinus((CompiledValue) pop()));
+
+  }
+
-    AbstractCompiledValue cmpVal = (AbstractCompiledValue)
-        TypeUtils.checkCast(pop(), AbstractCompiledValue.class);
+    AbstractCompiledValue cmpVal =
+        (AbstractCompiledValue) TypeUtils.checkCast(pop(), AbstractCompiledValue.class);
-  
-  
+
+
-    ObjectType objType = (ObjectType)TypeUtils.checkCast(pop(), ObjectType.class);
+    ObjectType objType = (ObjectType) TypeUtils.checkCast(pop(), ObjectType.class);
-      
+
-        //pop the key type
+        // pop the key type
-  
+
-  
+
-  
+
-    ArrayList list = new ArrayList(); 
+    ArrayList list = new ArrayList();
-      String hi = (String)this.stack.pop();
+      String hi = (String) this.stack.pop();
-    //setHints(list);
+    // setHints(list);
-  
+
-  public void importName (String qualifiedName, String asName) {
+  public void importName(String qualifiedName, String asName) {
-      int idx = qualifiedName.lastIndexOf ('.');
+      int idx = qualifiedName.lastIndexOf('.');
-        asName = qualifiedName.substring (idx + 1);
+        asName = qualifiedName.substring(idx + 1);
-  
-  
-  public Object pop () {
-    Object obj = this.stack.pop ();
+
+
+  public Object pop() {
+    Object obj = this.stack.pop();
-  
-  public void push (Object obj) {
+
+  public void push(Object obj) {
-    this.stack.push (obj);
+    this.stack.push(obj);
-  
-  public int stackSize () {
-    return this.stack.size ();
+
+  public int stackSize() {
+    return this.stack.size();
-  
-  public ObjectType resolveType (String typeName) {
+
+  public ObjectType resolveType(String typeName) {
-      as = (String)this.imports.get (typeName);
+      as = (String) this.imports.get(typeName);
-    if (as != null) typeName = as;
-    
+    if (as != null)
+      typeName = as;
+
-      throw new QueryInvalidException(LocalizedStrings.QCompiler_TYPE_NOT_FOUND_0.toLocalizedString(typeName), e);
+      throw new QueryInvalidException(
+          LocalizedStrings.QCompiler_TYPE_NOT_FOUND_0.toLocalizedString(typeName), e);
+
-    public MapIndexOperation (CompiledValue rcvr, List<CompiledValue> indexList ) {
-     this.rcvr = rcvr;
-     this.indexList = indexList;
+
+    public MapIndexOperation(CompiledValue rcvr, List<CompiledValue> indexList) {
+      this.rcvr = rcvr;
+      this.indexList = indexList;
-    public CompiledValue getRecieverSansIndexArgs()
-    {
-      return rcvr; 
-    }         
-    
-    public CompiledValue getMapLookupKey()
-    {
-       throw new UnsupportedOperationException("Function invocation not expected");
+
+    public CompiledValue getRecieverSansIndexArgs() {
+      return rcvr;
-              
-    public List<CompiledValue> getIndexingKeys()
-    {            
-      return (List<CompiledValue>)indexList;
+
+    public CompiledValue getMapLookupKey() {
+      throw new UnsupportedOperationException("Function invocation not expected");
-    
-    public Object evaluate(ExecutionContext context)
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException
-    {
+
+    public List<CompiledValue> getIndexingKeys() {
+      return (List<CompiledValue>) indexList;
+    }
+
+    public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+        TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
-    public int getType()
-    {
+
+    public int getType() {
-  
+

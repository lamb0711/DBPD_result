sweeper now holds a lock while processing tombstone queue

-          // TODO call sweeper.clearCurrentTombstone
+          sweeper.clearCurrentTombstone();
-      if (t.region.getRegionMap().removeTombstone(t.entry, t, false, true) && isBucket) {
+      boolean tombstoneWasStillInRegionMap = t.region.getRegionMap().removeTombstone(t.entry, t, false, true);
+      if (tombstoneWasStillInRegionMap && isBucket) {
-          // TODO: shouldn't we call sweeper.clearTombstone()?
+          sweeper.clearCurrentTombstone();
-    private long forceExpirationCount = 0;
+    private int forceExpirationCount = 0;
-      this.currentTombstoneLock.lock();
+      lock();
+    public void lock() {
+      this.currentTombstoneLock.lock();
+    }
-        final Set<DistributedRegion> regionsAffected = new HashSet<DistributedRegion>();
-        //Update the GC RVV for all of the affected regions.
-        //We need to do this so that we can persist the GC RVV before
-        //we start removing entries from the map.
-        for (Tombstone t: expired) {
-          t.region.getVersionVector().recordGCVersion(t.getMemberID(), t.getRegionVersion());
-          regionsAffected.add((DistributedRegion)t.region);
-        }
-        
-        for (DistributedRegion r: regionsAffected) {
-          //Remove any exceptions from the RVV that are older than the GC version
-          r.getVersionVector().pruneOldExceptions();
+        {
+          final Set<DistributedRegion> regionsAffected = new HashSet<DistributedRegion>();
+          //Update the GC RVV for all of the affected regions.
+          //We need to do this so that we can persist the GC RVV before
+          //we start removing entries from the map.
+          for (Tombstone t: expired) {
+            t.region.getVersionVector().recordGCVersion(t.getMemberID(), t.getRegionVersion());
+            regionsAffected.add((DistributedRegion)t.region);
+          }
-          //Persist the GC RVV to disk. This needs to happen BEFORE we remove
-          //the entries from map, to prevent us from removing a tombstone
-          //from disk that has a version greater than the persisted
-          //GV RVV.
-          if(r.getDataPolicy().withPersistence()) {
-            r.getDiskRegion().writeRVVGC(r);
+          for (DistributedRegion r: regionsAffected) {
+            //Remove any exceptions from the RVV that are older than the GC version
+            r.getVersionVector().pruneOldExceptions();
+
+            //Persist the GC RVV to disk. This needs to happen BEFORE we remove
+            //the entries from map, to prevent us from removing a tombstone
+            //from disk that has a version greater than the persisted
+            //GV RVV.
+            if(r.getDataPolicy().withPersistence()) {
+              r.getDiskRegion().writeRVVGC(r);
+            }
-        final Map<LocalRegion, Set<Object>> reapedKeys = new HashMap<LocalRegion, Set<Object>>();
+        final Map<DistributedRegion, Set<Object>> reapedKeys = new HashMap<>();
-          if (t.region.getRegionMap().removeTombstone(t.entry, t, false, true) && t.region.isUsedForPartitionedRegionBucket()) {
-            Set<Object> keys = reapedKeys.get(t.region);
+          DistributedRegion tr = (DistributedRegion) t.region;
+          boolean tombstoneWasStillInRegionMap = tr.getRegionMap().removeTombstone(t.entry, t, false, true);
+          if (tombstoneWasStillInRegionMap && tr.isUsedForPartitionedRegionBucket()) {
+            Set<Object> keys = reapedKeys.get(tr);
-              reapedKeys.put(t.region, keys);
+              reapedKeys.put(tr, keys);
-        // do messaging in a pool so this thread is not stuck trying to
-        // communicate with other members
-        cache.getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
-          public void run() {
-            try {
-              // this thread should not reference other sweeper state, which is not synchronized
-              for (DistributedRegion r: regionsAffected) {
-                r.distributeTombstoneGC(reapedKeys.get(r));
+        if (!reapedKeys.isEmpty()) {
+          // do messaging in a pool so this thread is not stuck trying to
+          // communicate with other members
+          cache.getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
+            public void run() {
+              try {
+                // this thread should not reference other sweeper state, which is not synchronized
+                for (Map.Entry<DistributedRegion, Set<Object>> mapEntry: reapedKeys.entrySet()) {
+                  DistributedRegion r = mapEntry.getKey();
+                  Set<Object> rKeysReaped = mapEntry.getValue();
+                  r.distributeTombstoneGC(rKeysReaped);
+                }
+              } finally {
+                batchExpirationInProgress = false;
-            } finally {
-              batchExpirationInProgress = false;
-          }
-        });
-        batchScheduled = true;
+          });
+          batchScheduled = true;
+        }
-      Tombstone myTombstone = null;
-          if (myTombstone == null) {
-            myTombstone = setCurrentToNextTombstone();
-          }
-          long sleepTime = 0;
-          boolean expireMyTombstone = false;
-          if (myTombstone == null) {
-            sleepTime = expiryTime;
-          } else {
-            long msTillMyTombstoneExpires = myTombstone.getVersionTimeStamp() + expiryTime - now;
-            if (forceExpirationCount > 0) {
-              if (msTillMyTombstoneExpires > 0 && msTillMyTombstoneExpires <= minimumRetentionMs) {
+          Tombstone myTombstone = lockAndGetCurrentTombstone();
+          boolean needsUnlock = true;
+          try {
+            if (myTombstone == null) {
+              myTombstone = tombstones.poll();
+              if (myTombstone != null) {
+                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                  logger.trace(LogMarker.TOMBSTONE, "current tombstone is {}", myTombstone);
+                }
+                currentTombstone = myTombstone;
+              } else {
+                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                  logger.trace(LogMarker.TOMBSTONE, "queue is empty - will sleep");
+                }
+                forceExpirationCount = 0;
+              }
+            }
+            long sleepTime = 0;
+            boolean expireMyTombstone = false;
+            if (myTombstone == null) {
+              sleepTime = expiryTime;
+            } else {
+              long msTillMyTombstoneExpires = myTombstone.getVersionTimeStamp() + expiryTime - now;
+              if (forceExpirationCount > 0) {
+                if (msTillMyTombstoneExpires > 0 && msTillMyTombstoneExpires <= minimumRetentionMs) {
+                  sleepTime = msTillMyTombstoneExpires;
+                } else {
+                  forceExpirationCount--;
+                  expireMyTombstone = true;
+                }
+              } else if (msTillMyTombstoneExpires > 0) {
-                forceExpirationCount--;
-            } else if (msTillMyTombstoneExpires > 0) {
-              sleepTime = msTillMyTombstoneExpires;
-            } else {
-              expireMyTombstone = true;
-          }
-          if (expireMyTombstone) {
-            try {
-              if (batchMode) {
-                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                  logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", myTombstone);
-                }
-                expiredTombstones.add(myTombstone);
-              } else {
-                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                  logger.trace(LogMarker.TOMBSTONE, "removing expired tombstone {}", myTombstone);
-                }
-                queueSize.addAndGet(-myTombstone.getSize());
-                myTombstone.region.getRegionMap().removeTombstone(myTombstone.entry, myTombstone, false, true);
-              }
-              myTombstone = null;
-              clearCurrentTombstone();
-            } catch (CancelException e) {
-              return;
-            } catch (Exception e) {
-              logger.warn(LocalizedMessage.create(LocalizedStrings.GemFireCacheImpl_TOMBSTONE_ERROR), e);
-              myTombstone = null;
-              clearCurrentTombstone();
-            }
-          }
-          if (sleepTime > 0) {
-            // initial sleeps could be very long, so we reduce the interval to allow
-            // this thread to periodically sweep up tombstones for resurrected entries
-            sleepTime = Math.min(sleepTime, scanInterval);
-            if (sleepTime > minimumScanTime  &&  (now - lastScanTime) > scanInterval) {
-              lastScanTime = now;
-              long start = now;
-              // see if any have been superseded
-              for (Iterator<Tombstone> it = getQueue().iterator(); it.hasNext(); ) {
-                Tombstone test = it.next();
-                if (it.hasNext()) {
-                  if (test.region.getRegionMap().isTombstoneNotNeeded(test.entry, test.getEntryVersion())) {
-                    it.remove();
-                    this.queueSize.addAndGet(-test.getSize());
-                    if (test == myTombstone) {
-                      myTombstone = null;
-                      clearCurrentTombstone();
-                      sleepTime = 0;
-                    }
-                  } else if (batchMode && test != myTombstone && (test.getVersionTimeStamp()+expiryTime) <= now) {
-                    it.remove();
-                    this.queueSize.addAndGet(-test.getSize());
-                    if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                      logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", test);
-                    }
-                    expiredTombstones.add(test);
-                    sleepTime = 0;
+            if (expireMyTombstone) {
+              try {
+                if (batchMode) {
+                  if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                    logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", myTombstone);
+                  expiredTombstones.add(myTombstone);
+                } else {
+                  if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                    logger.trace(LogMarker.TOMBSTONE, "removing expired tombstone {}", myTombstone);
+                  }
+                  queueSize.addAndGet(-myTombstone.getSize());
+                  myTombstone.region.getRegionMap().removeTombstone(myTombstone.entry, myTombstone, false, true);
+                myTombstone = null;
+                clearCurrentTombstone();
+              } catch (CancelException e) {
+                return;
+              } catch (Exception e) {
+                logger.warn(LocalizedMessage.create(LocalizedStrings.GemFireCacheImpl_TOMBSTONE_ERROR), e);
+                myTombstone = null;
+                clearCurrentTombstone();
-              // now check the batch of timed-out tombstones, if there is one
-              if (batchMode) {
-                for (Iterator<Tombstone> it = expiredTombstones.iterator(); it.hasNext(); ) {
+            }
+            if (sleepTime > 0) {
+              // initial sleeps could be very long, so we reduce the interval to allow
+              // this thread to periodically sweep up tombstones for resurrected entries
+              sleepTime = Math.min(sleepTime, scanInterval);
+              if (sleepTime > minimumScanTime  &&  (now - lastScanTime) > scanInterval) {
+                lastScanTime = now;
+                long start = now;
+                // see if any have been superseded
+                for (Iterator<Tombstone> it = getQueue().iterator(); it.hasNext(); ) {
+                  } else if (batchMode && (test.getVersionTimeStamp()+expiryTime) <= now) {
+                    it.remove();
+                    if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                      logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", test);
+                    }
+                    expiredTombstones.add(test);
+                    sleepTime = 0;
+                    if (test == myTombstone) {
+                      myTombstone = null;
+                      clearCurrentTombstone();
+                    }
+                // now check the batch of timed-out tombstones, if there is one
+                if (batchMode) {
+                  for (Iterator<Tombstone> it = expiredTombstones.iterator(); it.hasNext(); ) {
+                    Tombstone test = it.next();
+                    if (test.region.getRegionMap().isTombstoneNotNeeded(test.entry, test.getEntryVersion())) {
+                      if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                        logger.trace(LogMarker.TOMBSTONE, "removing obsolete tombstone: {}", test);
+                      }
+                      it.remove();
+                      this.queueSize.addAndGet(-test.getSize());
+                      if (test == myTombstone) {
+                        myTombstone = null;
+                        clearCurrentTombstone();
+                        sleepTime = 0;
+                      }
+                    }
+                  }
+                }
+                if (sleepTime > 0) {
+                  long elapsed = this.cache.cacheTimeMillis() - start;
+                  sleepTime = sleepTime - elapsed;
+                  if (sleepTime <= 0) {
+                    minimumScanTime = elapsed;
+                    continue;
+                  }
+                }
+              }
+              // test hook:  if there are expired tombstones and nothing else is expiring soon,
+              // perform distributed tombstone GC
+              if (batchMode && IDLE_EXPIRATION && sleepTime >= expiryTime) {
+                if (this.expiredTombstones.size() > 0) {
+                  expireBatch();
+                }
-                long elapsed = this.cache.cacheTimeMillis() - start;
-                sleepTime = sleepTime - elapsed;
-                if (sleepTime <= 0) {
-                  minimumScanTime = elapsed;
-                  continue;
-                }
-              }
-            }
-            // test hook:  if there are expired tombstones and nothing else is expiring soon,
-            // perform distributed tombstone GC
-            if (batchMode && IDLE_EXPIRATION && sleepTime >= expiryTime) {
-              if (this.expiredTombstones.size() > 0) {
-                expireBatch();
-              }
-            }
-            if (sleepTime > 0) {
-              try {
-                sleepTime = Math.min(sleepTime, maximumSleepTime);
-                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                  logger.trace(LogMarker.TOMBSTONE, "sleeping for {}", sleepTime);
-                }
-                synchronized(this) {
-                  if(isStopped) {
-                    return;
+                try {
+                  sleepTime = Math.min(sleepTime, maximumSleepTime);
+                  if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                    logger.trace(LogMarker.TOMBSTONE, "sleeping for {}", sleepTime);
-                  this.wait(sleepTime);
+                  needsUnlock = false;
+                  unlock();
+                  synchronized(this) {
+                    if(isStopped) {
+                      return;
+                    }
+                    this.wait(sleepTime);
+                  }
+                } catch (InterruptedException e) {
+                  return;
-              } catch (InterruptedException e) {
-                return;
+            } // sleepTime > 0
+          } finally {
+            if (needsUnlock) {
+              unlock();
-          } // sleepTime > 0
+          }
-      currentTombstoneLock.lock();
+      assert this.currentTombstoneLock.isHeldByCurrentThread();
-      currentTombstoneLock.unlock();
-
-    /**
-     * Returns the new currentTombstone taken from the tombstones queue; null if no next tombstone
-     */
-    private Tombstone setCurrentToNextTombstone() {
-      Tombstone result;
-      currentTombstoneLock.lock();
-      try {
-        result = tombstones.poll();
-        if (result != null) {
-          if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-            logger.trace(LogMarker.TOMBSTONE, "current tombstone is {}", result);
-          }
-          currentTombstone = result;
-        } else {
-          if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-            logger.trace(LogMarker.TOMBSTONE, "queue is empty - will sleep");
-          }
-          forceExpirationCount = 0;
-        }
-      } finally {
-        currentTombstoneLock.unlock();
-      }
-      return result;
-    }
-    

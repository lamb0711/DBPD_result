Merge branch 'feature/GEODE-8' into develop

+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
+
+import com.gemstone.gemfire.internal.cache.control.InternalResourceManager.ResourceType;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySender;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySenderEventProcessor;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
-   * A reference counter to protected the heapThresholdReached boolean
+   * A reference counter to protected the memoryThresholdReached boolean
-  private final Set<DistributedMember> heapThresholdReachedMembers =
+  private final Set<DistributedMember> memoryThresholdReachedMembers =
+  private ConcurrentParallelGatewaySenderQueue hdfsQueue;
+
-        cache.getResourceManager().addResourceListener(this);
+        cache.getResourceManager().addResourceListener(ResourceType.MEMORY, this);
-    if (this.entries.size() > 0) {
-      this.entries.clear(null);
+    if (!this.entries.isEmpty()) {
+      closeEntries();
-        this.entries.clear(rvv);
+        clearEntries(rvv);
+    profile.isOffHeap = getOffHeap();
+  @Retained
-        boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones)
+        boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones, boolean allowReadFromHDFS)
+    @Retained Object result = null;
+    boolean incrementUseCountForSqlf = false;
+    try {
+        try {
-          event = new EntryEventImpl(this, op, key, value,
+          event = EntryEventImpl.create(this, op, key, value,
+        } finally {
+          holder.release();
+        }
-      event = new EntryEventImpl(this, op, key, null /*newValue*/,
+      event = EntryEventImpl.create(this, op, key, null /*newValue*/,
-    if (event.hasNewValue() && !isHeapThresholdReachedForLoad()) {
+    if (event.hasNewValue() && !isMemoryThresholdReachedForLoad()) {
-          
+          incrementUseCountForSqlf = GemFireCacheImpl.sqlfSystem() ;
-    Object result;
+    
-      result = event.getRawNewValue();
-      // fix for bug 42895
-      if (!(result instanceof CachedDeserializable)) {
+      if (event.hasDelta()) {
-      }
+      } else {
+        result = event.getRawNewValueAsHeapObject();
+      }    
-      result = event.getNewValue();
+      result = event.getNewValue();     
+    }
+    //For SQLFire , we need to increment the use count so that returned
+    //object has use count 2
+    if( incrementUseCountForSqlf && result instanceof Chunk) {
+      ((Chunk)result).retain();
+    } finally {
+      if (event != null) {
+        event.release();        
+      }
+    }
+  }
+  
+  protected ConcurrentParallelGatewaySenderQueue getHDFSQueue() {
+    if (this.hdfsQueue == null) {
+      String asyncQId = this.getPartitionedRegion().getHDFSEventQueueName();
+      final AsyncEventQueueImpl asyncQ =  (AsyncEventQueueImpl)this.getCache().getAsyncEventQueue(asyncQId);
+      final AbstractGatewaySender gatewaySender = (AbstractGatewaySender)asyncQ.getSender();
+      AbstractGatewaySenderEventProcessor ep = gatewaySender.getEventProcessor();
+      if (ep == null) return null;
+      hdfsQueue = (ConcurrentParallelGatewaySenderQueue)ep.getQueue();
+    }
+    return hdfsQueue;
-  protected void setHeapThresholdFlag(MemoryEvent event) {
+  protected void setMemoryThresholdFlag(MemoryEvent event) {
-      if (event.getType().isCriticalUp()) {
-        setHeapThresholdReachedCounterTrue(event.getMember());
-      } else if (event.getType().isCriticalDown() || event.getType().isCriticalDisabled()) {
+      if (event.getState().isCritical()
+          && !event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+        setMemoryThresholdReachedCounterTrue(event.getMember());
+      } else if (!event.getState().isCritical()
+          && event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
-    synchronized(this.heapThresholdReachedMembers) {
-      this.heapThresholdReachedMembers.remove(member);
-      if (this.heapThresholdReachedMembers.size() == 0) {
-        heapThresholdReached.set(false);
+    synchronized(this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.remove(member);
+      if (this.memoryThresholdReachedMembers.size() == 0) {
+        memoryThresholdReached.set(false);
-  public Set<DistributedMember> getHeapThresholdReachedMembers() {
-    synchronized (this.heapThresholdReachedMembers) {
-      return Collections.unmodifiableSet(this.heapThresholdReachedMembers);
+  public Set<DistributedMember> getMemoryThresholdReachedMembers() {
+    synchronized (this.memoryThresholdReachedMembers) {
+      return Collections.unmodifiableSet(this.memoryThresholdReachedMembers);
-  public void initialCriticalMembers(boolean localHeapIsCritical,
+  public void initialCriticalMembers(boolean localMemoryIsCritical,
-        setHeapThresholdReachedCounterTrue(idm);
+        setMemoryThresholdReachedCounterTrue(idm);
-  private void setHeapThresholdReachedCounterTrue(final DistributedMember idm) {
-    synchronized(this.heapThresholdReachedMembers) {
-      this.heapThresholdReachedMembers.add(idm);
-      if (this.heapThresholdReachedMembers.size() > 0) {
-        heapThresholdReached.set(true);
+  private void setMemoryThresholdReachedCounterTrue(final DistributedMember idm) {
+    synchronized(this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.add(idm);
+      if (this.memoryThresholdReachedMembers.size() > 0) {
+        memoryThresholdReached.set(true);

GEODE-6773 Adding register driver, deregister driver and list drivers gfsh commands (#3657)

Co-authored-by: Benjamin Ross <bross@pivotal.io>
Co-authored-by: Donal Evans <doevans@pivotal.io>

+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.List;
+  public void deregisterDriver(String driverClassName) throws SQLException {
+    Enumeration<Driver> driverEnumeration = getDrivers();
+    Driver driver;
+    while (driverEnumeration.hasMoreElements()) {
+      driver = driverEnumeration.nextElement();
+      if (compareDriverClassName(driver, driverClassName)) {
+        deregisterDriverWithDriverManager(driver);
+      }
+    }
+  }
+
+  public List<Driver> getRegisteredDrivers() {
+    Enumeration<Driver> drivers = DriverManager.getDrivers();
+    return Collections.list(drivers);
+  }
+
+  public List<String> getRegisteredDriverNames() {
+    List<String> listOfDriverNames = new ArrayList<>();
+    for (Driver driver : getRegisteredDrivers()) {
+      if (driver instanceof DriverWrapper) {
+        listOfDriverNames.add(((DriverWrapper) driver).getWrappedDriverName());
+      } else {
+        listOfDriverNames.add(driver.getClass().getName());
+      }
+    }
+    return listOfDriverNames;
+
+  }
+
+  Enumeration<Driver> getDrivers() {
+    return DriverManager.getDrivers();
+  }
+
+  boolean compareDriverClassName(Driver driver, String driverClassName) {
+    if (driver instanceof DriverWrapper) {
+      return ((DriverWrapper) driver).getWrappedDriverName().equals(driverClassName);
+    } else {
+      return driver.getClass().getName().equals(driverClassName);
+    }
+  }
+
-  // DriverManager only uses a driver loaded by system ClassLoader
+  void deregisterDriverWithDriverManager(Driver driver) throws SQLException {
+    DriverManager.deregisterDriver(driver);
+  }
+
+  /**
+   * <p>
+   * Driver Wrapper encapsulates a driver class with a wrapper which is loaded by the system class
+   * loader. Since driver classes may be added to the clusters class path after startup and may not
+   * be available in the system class loader
+   * we use this wrapper to allow the DriverManager to load these drivers.
+   * </p>
+   */
+    public String getWrappedDriverName() {
+      return this.jdbcDriver.getClass().getName();
+    }
+
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implementation of {@link NativeCalls} interface that encapsulates native C
- * calls via JNA. To obtain an instance of JNA based implementation for the
- * current platform, use {@link NativeCallsJNAImpl#getInstance()}.
+ * Implementation of {@link NativeCalls} interface that encapsulates native C calls via JNA. To
+ * obtain an instance of JNA based implementation for the current platform, use
+ * {@link NativeCallsJNAImpl#getInstance()}.
- * BridJ is supposed to be cleaner, faster but it does not support Solaris/SPARC
- * yet and its not a mature library yet, so not using it. Can revisit once this
- * changes.
+ * BridJ is supposed to be cleaner, faster but it does not support Solaris/SPARC yet and its not a
+ * mature library yet, so not using it. Can revisit once this changes.
-  private NativeCallsJNAImpl() {
-  }
+  private NativeCallsJNAImpl() {}
-   * Get an instance of JNA based implementation of {@link NativeCalls} for the
-   * current platform.
+   * Get an instance of JNA based implementation of {@link NativeCalls} for the current platform.
-    public static native int kill(int processId, int signal)
-        throws LastErrorException;
+    public static native int kill(int processId, int signal) throws LastErrorException;
-    public static native int setsockopt(int sockfd, int level, int optName,
-        IntByReference optVal, int optSize) throws LastErrorException;
+    public static native int setsockopt(int sockfd, int level, int optName, IntByReference optVal,
+        int optSize) throws LastErrorException;
-    
+
-     * holds a reference of {@link SignalHandler} installed in
-     * {@link #daemonize} for SIGHUP to avoid it being GCed. Assumes that the
-     * NativeCalls instance itself is a singleton and never GCed.
+     * holds a reference of {@link SignalHandler} installed in {@link #daemonize} for SIGHUP to
+     * avoid it being GCed. Assumes that the NativeCalls instance itself is a singleton and never
+     * GCed.
-     * the {@link RehashServerOnSIGHUP} instance sent to
-     * {@link #daemonize}
+     * the {@link RehashServerOnSIGHUP} instance sent to {@link #daemonize}
-    public synchronized void setEnvironment(final String name,
-        final String value) {
+    public synchronized void setEnvironment(final String name, final String value) {
-        throw new UnsupportedOperationException(
-            "setEnvironment() for name=NULL");
+        throw new UnsupportedOperationException("setEnvironment() for name=NULL");
-        }
-        else {
+        } else {
-        cause = new NativeErrorException(le.getMessage(), le.getErrorCode(),
-            le.getCause());
+        cause = new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause());
-        throw new IllegalArgumentException("setEnvironment: given name=" + name
-            + " (value=" + value + ')', cause);
+        throw new IllegalArgumentException(
+            "setEnvironment: given name=" + name + " (value=" + value + ')', cause);
-        }
-        else {
+        } else {
-        throw new UnsupportedOperationException(
-            "getEnvironment() for name=NULL");
+        throw new UnsupportedOperationException("getEnvironment() for name=NULL");
-    public void daemonize(RehashServerOnSIGHUP callback)
-        throws UnsupportedOperationException {
+    public void daemonize(RehashServerOnSIGHUP callback) throws UnsupportedOperationException {
-          err = new UnsupportedOperationException(
-              "Failed in setsid() in daemonize() due to " + le.getMessage()
-                  + " (errno=" + le.getErrorCode() + ')');
+          err = new UnsupportedOperationException("Failed in setsid() in daemonize() due to "
+              + le.getMessage() + " (errno=" + le.getErrorCode() + ')');
-    public void preBlow(String path, long maxSize, boolean preAllocate)
-        throws IOException {
-      final org.apache.geode.LogWriter logger; 
+    public void preBlow(String path, long maxSize, boolean preAllocate) throws IOException {
+      final org.apache.geode.LogWriter logger;
-      }
-      else {
+      } else {
-      
+
-            logger.fine("DEBUG preBlow super.preBlow 2 called as path = "
-                + path + " not on local file system");
+            logger.fine("DEBUG preBlow super.preBlow 2 called as path = " + path
+                + " not on local file system");
-          logger.fine("DEBUG preBlow posix_fallocate called for path = " + path + " and ret = 0 maxsize = " + maxSize);
+          logger.fine("DEBUG preBlow posix_fallocate called for path = " + path
+              + " and ret = 0 maxsize = " + maxSize);
-          logger.fine("DEBUG preBlow posix_fallocate called for path = " + path + " and ret = " + le.getErrorCode() + " maxsize = " + maxSize);
+          logger.fine("DEBUG preBlow posix_fallocate called for path = " + path + " and ret = "
+              + le.getErrorCode() + " maxsize = " + maxSize);
-        }
-        else {
+        } else {
-    protected void fallocateFD(int fd, long offset, long len)
-        throws LastErrorException {
+    protected void fallocateFD(int fd, long offset, long len) throws LastErrorException {
-    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock,
-        InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
-        throws UnsupportedOperationException {
+    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock, InputStream sockStream,
+        Map<TCPSocketOptions, Object> optValueMap) throws UnsupportedOperationException {
-    protected int setPlatformSocketOption(int sockfd, int level, int optName,
-        TCPSocketOptions opt, Integer optVal, int optSize)
-        throws NativeErrorException {
+    protected int setPlatformSocketOption(int sockfd, int level, int optName, TCPSocketOptions opt,
+        Integer optVal, int optSize) throws NativeErrorException {
-        return setsockopt(sockfd, level, optName,
-            new IntByReference(optVal.intValue()), optSize);
+        return setsockopt(sockfd, level, optName, new IntByReference(optVal.intValue()), optSize);
-        throw new NativeErrorException(le.getMessage(), le.getErrorCode(),
-            le.getCause());
+        throw new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause());
-    
+
-    
+
-    public static native int creat64(String path, int flags)
-        throws LastErrorException;
+    public static native int creat64(String path, int flags) throws LastErrorException;
-    protected int getPlatformOption(TCPSocketOptions opt)
-        throws UnsupportedOperationException {
+    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-        case ENOPROTOOPT: return true;
-        case ENOPROTOOPT_ALPHA: return true;
-        case ENOPROTOOPT_MIPS: return true;
-        case ENOPROTOOPT_PARISC: return true;
-        default: return false;
+        case ENOPROTOOPT:
+          return true;
+        case ENOPROTOOPT_ALPHA:
+          return true;
+        case ENOPROTOOPT_MIPS:
+          return true;
+        case ENOPROTOOPT_PARISC:
+          return true;
+        default:
+          return false;
-    
+
-      }
-      else {
+      } else {
-    
+
-    
+
-        return Arrays.asList(new String[] { "fsid" });
+        return Arrays.asList(new String[] {"fsid"});
-        return Arrays.asList(new String[] { "fspare" });
+        return Arrays.asList(new String[] {"fspare"});
-          }
-          else {
+          } else {
-      public static native int statfs(String path, StatFS statfs)
-          throws LastErrorException;
+      public static native int statfs(String path, StatFS statfs) throws LastErrorException;
-        return Arrays.asList(new String[] { "f_type", "f_bsize", "f_blocks",
-            "f_bfree", "f_bavail", "f_files", "f_ffree", "f_fsid", "f_namelen",
-            "f_frsize", "f_spare" });
+        return Arrays.asList(new String[] {"f_type", "f_bsize", "f_blocks", "f_bfree", "f_bavail",
+            "f_files", "f_ffree", "f_fsid", "f_namelen", "f_frsize", "f_spare"});
-      // CIFS_MAGIC_NUMBER, CODA_SUPER_MAGIC, NCP_SUPER_MAGIC, NFS_SUPER_MAGIC, SMB_SUPER_MAGIC, TMPFS_MAGIC
-      // 0xFF534D42       , 0x73757245      , 0x564c         , 0x6969         , 0x517B         , 0x01021994
-      // 4283649346       , 1937076805      , 22092          , 26985          , 20859          , 16914836
-      private static int[] REMOTE_TYPES= new int[] { /*4283649346,*/ 1937076805, 22092, 26985, 20859, 16914836 };
-      
+      // CIFS_MAGIC_NUMBER, CODA_SUPER_MAGIC, NCP_SUPER_MAGIC, NFS_SUPER_MAGIC, SMB_SUPER_MAGIC,
+      // TMPFS_MAGIC
+      // 0xFF534D42 , 0x73757245 , 0x564c , 0x6969 , 0x517B , 0x01021994
+      // 4283649346 , 1937076805 , 22092 , 26985 , 20859 , 16914836
+      private static int[] REMOTE_TYPES =
+          new int[] { /* 4283649346, */ 1937076805, 22092, 26985, 20859, 16914836};
+
-        for(int i=0; i<REMOTE_TYPES.length; i++) {
+        for (int i = 0; i < REMOTE_TYPES.length; i++) {
-      
+
-        
+
-        return Arrays.asList(new String[] { "fspare" });
+        return Arrays.asList(new String[] {"fspare"});
-      // CIFS_MAGIC_NUMBER, CODA_SUPER_MAGIC, NCP_SUPER_MAGIC, NFS_SUPER_MAGIC, SMB_SUPER_MAGIC, TMPFS_MAGIC
-      // 0xFF534D42       , 0x73757245      , 0x564c         , 0x6969         , 0x517B         , 0x01021994
-      // 4283649346       , 1937076805      , 22092          , 26985          , 20859          , 16914836
-      private static long[] REMOTE_TYPES= new long[] { 4283649346l, 1937076805l, 22092l, 26985l, 20859l, 16914836l };
-      
+      // CIFS_MAGIC_NUMBER, CODA_SUPER_MAGIC, NCP_SUPER_MAGIC, NFS_SUPER_MAGIC, SMB_SUPER_MAGIC,
+      // TMPFS_MAGIC
+      // 0xFF534D42 , 0x73757245 , 0x564c , 0x6969 , 0x517B , 0x01021994
+      // 4283649346 , 1937076805 , 22092 , 26985 , 20859 , 16914836
+      private static long[] REMOTE_TYPES =
+          new long[] {4283649346l, 1937076805l, 22092l, 26985l, 20859l, 16914836l};
+
-          }
-          else {
+          } else {
-      public static native int statfs(String path, StatFS64 statfs)
-          throws LastErrorException;
+      public static native int statfs(String path, StatFS64 statfs) throws LastErrorException;
-        return Arrays.asList(new String[] { "f_type", "f_bsize", "f_blocks",
-            "f_bfree", "f_bavail", "f_files", "f_ffree", "f_fsid", "f_namelen",
-            "f_frsize", "f_spare" });
+        return Arrays.asList(new String[] {"f_type", "f_bsize", "f_blocks", "f_bfree", "f_bavail",
+            "f_files", "f_ffree", "f_fsid", "f_namelen", "f_frsize", "f_spare"});
-      
+
-        for(int i=0; i<REMOTE_TYPES.length; i++) {
+        for (int i = 0; i < REMOTE_TYPES.length; i++) {
-      
+
-        
+
-     * Get the file store type of a path.
-     * for example, /dev/sdd1(store name) /w2-gst-dev40d(mount point) ext4(type)
+     * Get the file store type of a path. for example, /dev/sdd1(store name) /w2-gst-dev40d(mount
+     * point) ext4(type)
+     * 
-     * This will return whether the path passed in as arg is
-     * part of a local file system or a remote file system.
-     * This method is mainly used by the DiskCapacityMonitor thread
-     * and we don't want to monitor remote fs available space as
-     * due to network problems/firewall issues the call to getUsableSpace
-     * can hang. See bug #49155. On platforms other than Linux this will
-     * return false even if it on local file system for now.
+     * This will return whether the path passed in as arg is part of a local file system or a remote
+     * file system. This method is mainly used by the DiskCapacityMonitor thread and we don't want
+     * to monitor remote fs available space as due to network problems/firewall issues the call to
+     * getUsableSpace can hang. See bug #49155. On platforms other than Linux this will return false
+     * even if it on local file system for now.
-      final org.apache.geode.LogWriter logger; 
+      final org.apache.geode.LogWriter logger;
-      }
-      else {
+      } else {
-//        if (logger != null && logger.fineEnabled()) {
-//          logger.info("DEBUG isOnLocalFileSystem returning false 1 for path = " + path);
-//        }
+        // if (logger != null && logger.fineEnabled()) {
+        // logger.info("DEBUG isOnLocalFileSystem returning false 1 for path = " + path);
+        // }
-//            if (logger != null && logger.fineEnabled()) {
-//              logger.info("DEBUG 64 isOnLocalFileSystem returning " + stat.isTypeLocal() + " for path = " + path);
-//            }
+            // if (logger != null && logger.fineEnabled()) {
+            // logger.info("DEBUG 64 isOnLocalFileSystem returning " + stat.isTypeLocal() + " for
+            // path = " + path);
+            // }
-          }
-          else {
+          } else {
-//            if (logger != null && logger.fineEnabled()) {
-//              logger.fine("DEBUG 32 isOnLocalFileSystem returning " + stat.isTypeLocal() + " for path = " + path);
-//            }
+            // if (logger != null && logger.fineEnabled()) {
+            // logger.fine("DEBUG 32 isOnLocalFileSystem returning " + stat.isTypeLocal() + " for
+            // path = " + path);
+            // }
-           // ignoring it as NFS mounted can give this exception
-           // and we just want to retry to remove transient problem.
+          // ignoring it as NFS mounted can give this exception
+          // and we just want to retry to remove transient problem.
-            logger.fine("DEBUG isOnLocalFileSystem got ex = "+ le + " msg = " + le.getMessage());
+            logger.fine("DEBUG isOnLocalFileSystem got ex = " + le + " msg = " + le.getMessage());
-      for (String type:FallocateFileSystems) {
+      for (String type : FallocateFileSystems) {
-    protected void fallocateFD(int fd, long offset, long len)
-        throws LastErrorException {
+    protected void fallocateFD(int fd, long offset, long len) throws LastErrorException {
-    protected int getPlatformOption(TCPSocketOptions opt)
-        throws UnsupportedOperationException {
+    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-    protected int setPlatformSocketOption(int sockfd, int level, int optName,
-        TCPSocketOptions opt, Integer optVal, int optSize)
-        throws NativeErrorException {
+    protected int setPlatformSocketOption(int sockfd, int level, int optName, TCPSocketOptions opt,
+        Integer optVal, int optSize) throws NativeErrorException {
-            final IntByReference timeout = new IntByReference(
-                optVal.intValue() * 1000);
+            final IntByReference timeout = new IntByReference(optVal.intValue() * 1000);
-              return setsockopt(sockfd, level,
-                  OPT_TCP_KEEPALIVE_ABORT_THRESHOLD, timeout, optSize);
-            }
-            else {
+              return setsockopt(sockfd, level, OPT_TCP_KEEPALIVE_ABORT_THRESHOLD, timeout, optSize);
+            } else {
-        throw new NativeErrorException(le.getMessage(), le.getErrorCode(),
-            le.getCause());
+        throw new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause());
-    protected int getPlatformOption(TCPSocketOptions opt)
-        throws UnsupportedOperationException {
+    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-    protected int getPlatformOption(TCPSocketOptions opt)
-        throws UnsupportedOperationException {
+    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-        return Arrays.asList(new String[] { "onoff", "keepalivetime",
-            "keepaliveinterval" });
+        return Arrays.asList(new String[] {"onoff", "keepalivetime", "keepaliveinterval"});
-    public static native int WSAIoctl(NativeLong sock, int controlCode,
-        TcpKeepAlive value, int valueSize, Pointer outValue, int outValueSize,
-        IntByReference bytesReturned, Pointer overlapped,
-        Pointer completionRoutine) throws LastErrorException;
+    public static native int WSAIoctl(NativeLong sock, int controlCode, TcpKeepAlive value,
+        int valueSize, Pointer outValue, int outValueSize, IntByReference bytesReturned,
+        Pointer overlapped, Pointer completionRoutine) throws LastErrorException;
-        kernel32Options.put(Library.OPTION_CALLING_CONVENTION,
-            StdCallLibrary.STDCALL_CONVENTION);
-        kernel32Options.put(Library.OPTION_FUNCTION_MAPPER,
-            StdCallLibrary.FUNCTION_MAPPER);
-        final NativeLibrary kernel32Lib = NativeLibrary.getInstance("kernel32",
-            kernel32Options);
+        kernel32Options.put(Library.OPTION_CALLING_CONVENTION, StdCallLibrary.STDCALL_CONVENTION);
+        kernel32Options.put(Library.OPTION_FUNCTION_MAPPER, StdCallLibrary.FUNCTION_MAPPER);
+        final NativeLibrary kernel32Lib = NativeLibrary.getInstance("kernel32", kernel32Options);
-      public static native boolean SetEnvironmentVariableA(String name,
-          String value) throws LastErrorException;
+      public static native boolean SetEnvironmentVariableA(String name, String value)
+          throws LastErrorException;
-      public static native int GetEnvironmentVariableA(String name,
-          byte[] pvalue, int psize);
+      public static native int GetEnvironmentVariableA(String name, byte[] pvalue, int psize);
-      public static native Pointer OpenProcess(int desiredAccess,
-          boolean inheritHandle, int processId) throws LastErrorException;
+      public static native Pointer OpenProcess(int desiredAccess, boolean inheritHandle,
+          int processId) throws LastErrorException;
-      public static native boolean TerminateProcess(Pointer processHandle,
-          int exitCode) throws LastErrorException;
+      public static native boolean TerminateProcess(Pointer processHandle, int exitCode)
+          throws LastErrorException;
-      public static native boolean CloseHandle(Pointer handle)
-          throws LastErrorException;
+      public static native boolean CloseHandle(Pointer handle) throws LastErrorException;
-    private static final Map<String, String> javaEnv =
-        getModifiableJavaEnvWIN();
+    private static final Map<String, String> javaEnv = getModifiableJavaEnvWIN();
-    public synchronized void setEnvironment(final String name,
-        final String value) {
+    public synchronized void setEnvironment(final String name, final String value) {
-        throw new UnsupportedOperationException(
-            "setEnvironment() for name=NULL");
+        throw new UnsupportedOperationException("setEnvironment() for name=NULL");
-        }
-        else {
-          cause = new NativeErrorException(le.getMessage(), le.getErrorCode(),
-              le.getCause());
+        } else {
+          cause = new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause());
-        throw new IllegalArgumentException("setEnvironment: given name=" + name
-            + " (value=" + value + ')', cause);
+        throw new IllegalArgumentException(
+            "setEnvironment: given name=" + name + " (value=" + value + ')', cause);
-        }
-        else {
+        } else {
-        throw new UnsupportedOperationException(
-            "getEnvironment() for name=NULL");
+        throw new UnsupportedOperationException("getEnvironment() for name=NULL");
-          }
-          else if (psize <= 0) {
+          } else if (psize <= 0) {
-      }
-      else {
+      } else {
-        final Pointer procHandle = Kernel32.OpenProcess(
-            Kernel32.PROCESS_QUERY_INFORMATION, false, processId);
+        final Pointer procHandle =
+            Kernel32.OpenProcess(Kernel32.PROCESS_QUERY_INFORMATION, false, processId);
-        if (procHandle == null || (hval = Pointer.nativeValue(procHandle)) ==
-            Kernel32.INVALID_HANDLE || hval == 0) {
+        if (procHandle == null
+            || (hval = Pointer.nativeValue(procHandle)) == Kernel32.INVALID_HANDLE || hval == 0) {
-        }
-        else {
+        } else {
-          final boolean result = Kernel32.GetExitCodeProcess(procHandle, status)
-              && status != null && status.getValue() == Kernel32.STILL_ACTIVE;
+          final boolean result = Kernel32.GetExitCodeProcess(procHandle, status) && status != null
+              && status.getValue() == Kernel32.STILL_ACTIVE;
-        final Pointer procHandle = Kernel32.OpenProcess(
-            Kernel32.PROCESS_TERMINATE, false, processId);
+        final Pointer procHandle =
+            Kernel32.OpenProcess(Kernel32.PROCESS_TERMINATE, false, processId);
-        if (procHandle == null || (hval = Pointer.nativeValue(procHandle)) ==
-            Kernel32.INVALID_HANDLE || hval == 0) {
+        if (procHandle == null
+            || (hval = Pointer.nativeValue(procHandle)) == Kernel32.INVALID_HANDLE || hval == 0) {
-        }
-        else {
+        } else {
-      throw new IllegalStateException(
-          "daemonize() not applicable for Windows platform");
+      throw new IllegalStateException("daemonize() not applicable for Windows platform");
-    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock,
-        InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
-        throws UnsupportedOperationException {
+    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock, InputStream sockStream,
+        Map<TCPSocketOptions, Object> optValueMap) throws UnsupportedOperationException {
-              + (value != null ? value.getClass().getName() : "NULL") + " for "
-              + opt);
+              + (value != null ? value.getClass().getName() : "NULL") + " for " + opt);
-            optValue.keepalivetime = ((Integer)value).intValue() * 1000;
+            optValue.keepalivetime = ((Integer) value).intValue() * 1000;
-            optValue.keepaliveinterval = ((Integer)value).intValue() * 1000;
+            optValue.keepaliveinterval = ((Integer) value).intValue() * 1000;
-            error = new UnsupportedOperationException(
-                getUnsupportedSocketOptionMessage(opt));
+            error = new UnsupportedOperationException(getUnsupportedSocketOptionMessage(opt));
-        if (WSAIoctl(new NativeLong(sockfd), SIO_KEEPALIVE_VALS, optValue,
-            optSize, null, 0, nBytes, null, null) != 0) {
+        if (WSAIoctl(new NativeLong(sockfd), SIO_KEEPALIVE_VALS, optValue, optSize, null, 0, nBytes,
+            null, null) != 0) {
-          error = new SocketException(getOSType() + ": error setting options: "
-              + optValueMap);
+          error = new SocketException(getOSType() + ": error setting options: " + optValueMap);
-          error = new UnsupportedOperationException(
-              getUnsupportedSocketOptionMessage(errorOpt),
-              new NativeErrorException(le.getMessage(), le.getErrorCode(),
-                  le.getCause()));
-        }
-        else {
-          final SocketException se = new SocketException(getOSType()
-              + ": failed to set options: " + optValueMap);
+          error = new UnsupportedOperationException(getUnsupportedSocketOptionMessage(errorOpt),
+              new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause()));
+        } else {
+          final SocketException se =
+              new SocketException(getOSType() + ": failed to set options: " + optValueMap);
-      return errorOpt != null ? Collections.singletonMap(errorOpt, error)
-          : null;
+      return errorOpt != null ? Collections.singletonMap(errorOpt, error) : null;

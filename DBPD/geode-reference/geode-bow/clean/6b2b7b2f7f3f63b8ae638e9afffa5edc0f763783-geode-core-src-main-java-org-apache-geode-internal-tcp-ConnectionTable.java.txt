GEODE-2684 Connection & ConnectionTable cleanup

removed dead code and indirect access of TcpConduit through the
connection table.

-/*
- * Note: We no longer use InputMultiplexer If InputMux is reinstated then the manager needs to be
- * initialized and all lines that have a NOMUX preface should be uncommented
- * 
- */
-  /** a random number generator for secondary connection selection */
-  // static java.util.Random random = new java.util.Random();
-
+
-  protected final TCPConduit owner;
-  // ARB: temp making this protected to provide access to Connection.
-  // private final TCPConduit owner;
+  private final TCPConduit owner;
-  // public static void setThreadOwnsResourcesRegistration(
-  // Boolean newValue) {
-  // threadWantsOwnResources.set(newValue);
-  // }
-  // private Map connections = new HashMap();
-  /* NOMUX: private InputMuxManager inputMuxManager; */
-  // private int lowWater;
-  // private int highWater;
+  public TCPConduit getOwner() {
+    return owner;
+  }
-  // private static boolean TRACK_SERVER_CONNECTIONS =
-  // System.getProperty("p2p.bidirectional", "true").equals("true");
-    /*
-     * NOMUX: if (TCPConduit.useNIO) { inputMuxManager = new InputMuxManager(this);
-     * inputMuxManager.start(c.logger); }
-     */
-    // Stub id = conn.getRemoteId();
-    // cleanupHighWater();
-  // /** returns the connection associated with the given key, or null if
-  // no such connection exists */
-  // protected Connection basicGet(Serializable id) {
-  // synchronized (this.orderedConnectionMap) {
-  // return (Connection) this.orderedConnectionMap.get(id);
-  // }
-  // }
-
-  // protected Connection get(Serializable id) throws java.io.IOException {
-  // return get(id, false);
-  // }
-
-   * unordered or conserve-sockets note that unordered connections are currently always shared
+   * unordered or conserve-sockets=true note that unordered connections are currently always shared
-   * @param threadOwnsResources whether unordered conn is owned by the current thread
+   * @param scheduleTimeout whether unordered connection should time out
-  private Connection getUnorderedOrConserveSockets(DistributedMember id,
-      boolean threadOwnsResources, boolean preserveOrder, long startTime, long ackTimeout,
-      long ackSATimeout) throws IOException, DistributedSystemDisconnectedException {
+  private Connection getSharedConnection(DistributedMember id, boolean scheduleTimeout,
+      boolean preserveOrder, long startTime, long ackTimeout, long ackSATimeout)
+      throws IOException, DistributedSystemDisconnectedException {
-      if (!preserveOrder && threadOwnsResources) {
+      if (!preserveOrder && scheduleTimeout) {
-            logger.debug("getUnorderedOrConserveSockets {} myAddr={} theirAddr={}", result,
+            logger.debug("getSharedConnection {} myAddr={} theirAddr={}", result,
-            logger.debug("getUnorderedOrConserveSockets: Connect failed");
+            logger.debug("getSharedConnection: Connect failed");
-  Connection getOrderedAndOwned(DistributedMember id, long startTime, long ackTimeout,
+  Connection getThreadOwnedConnection(DistributedMember id, long startTime, long ackTimeout,
-      result = getUnorderedOrConserveSockets(id, threadOwnsResources, preserveOrder, startTime,
-          ackTimeout, ackSATimeout);
+      result = getSharedConnection(id, threadOwnsResources, preserveOrder, startTime, ackTimeout,
+          ackSATimeout);
-      result = getOrderedAndOwned(id, startTime, ackTimeout, ackSATimeout);
+      result = getThreadOwnedConnection(id, startTime, ackTimeout, ackSATimeout);

GEODE-6176: Make FunctionService testable with internal delegates

Introduce new internal FunctionExecutionService API interfaces:
* FunctionExecutionService
* InternalFunctionExecutionService

Implement interfaces with:
* InternalFunctionExecutionServiceImpl

Collapse FunctionServiceManager into InternalFunctionExecutionServiceImpl

Change the two static API classes to delegate to an instance of
InternalFunctionExecutionServiceImpl:
* FunctionService (User API) -- only has private internal changes
* InternalFunctionService -- now extends FunctionService

Geode classes that use the static API classes directly can now be
changed to depend on one of the two interfaces using constructor
injection to facilitate unit testing without PowerMock.

-import org.apache.geode.cache.execute.internal.FunctionServiceManager;
-import org.apache.geode.distributed.DistributedSystemDisconnectedException;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.execute.FunctionExecutionService;
+import org.apache.geode.internal.cache.execute.InternalFunctionExecutionServiceImpl;
-  private static final FunctionServiceManager functionSvcMgr = new FunctionServiceManager();
-  FunctionService() {}
+  private static final FunctionService INSTANCE =
+      new FunctionService(new InternalFunctionExecutionServiceImpl());
+
+  private final FunctionExecutionService functionExecutionService;
+
+  /**
+   * Protected visibility to allow InternalFunctionService to extend FunctionService.
+   */
+  protected FunctionService(FunctionExecutionService functionExecutionService) {
+    this.functionExecutionService = functionExecutionService;
+  }
-    return functionSvcMgr.onRegion(region);
+    return getFunctionExecutionService().onRegion(region);
-    return functionSvcMgr.onServer(pool);
+    return getFunctionExecutionService().onServer(pool);
-    return functionSvcMgr.onServers(pool);
+    return getFunctionExecutionService().onServers(pool);
-    return functionSvcMgr.onServer(regionService);
+    return getFunctionExecutionService().onServer(regionService);
-    return functionSvcMgr.onServers(regionService);
+    return getFunctionExecutionService().onServers(regionService);
-   *
-    return functionSvcMgr.onMember(getDistributedSystem(), distributedMember);
+    return getFunctionExecutionService().onMember(distributedMember);
-    return functionSvcMgr.onMembers(getDistributedSystem(), groups);
+    return getFunctionExecutionService().onMembers(groups);
-    return functionSvcMgr.onMembers(getDistributedSystem(), distributedMembers);
+    return getFunctionExecutionService().onMembers(distributedMembers);
-    return functionSvcMgr.onMember(getDistributedSystem(), groups);
+    return getFunctionExecutionService().onMember(groups);
-    return functionSvcMgr.getFunction(functionId);
+    return getFunctionExecutionService().getFunction(functionId);
-    functionSvcMgr.registerFunction(function);
+    getFunctionExecutionService().registerFunction(function);
-    functionSvcMgr.unregisterFunction(functionId);
+    getFunctionExecutionService().unregisterFunction(functionId);
-    return functionSvcMgr.isRegistered(functionId);
+    return getFunctionExecutionService().isRegistered(functionId);
-
-    return functionSvcMgr.getRegisteredFunctions();
+    return getFunctionExecutionService().getRegisteredFunctions();
-  private static DistributedSystem getDistributedSystem() {
-    DistributedSystem system = InternalDistributedSystem.getConnectedInstance();
-    if (system == null) {
-      throw new DistributedSystemDisconnectedException(
-          "This connection to a distributed system has been disconnected.");
-    }
-    return system;
+  private static FunctionExecutionService getFunctionExecutionService() {
+    return INSTANCE.functionExecutionService;

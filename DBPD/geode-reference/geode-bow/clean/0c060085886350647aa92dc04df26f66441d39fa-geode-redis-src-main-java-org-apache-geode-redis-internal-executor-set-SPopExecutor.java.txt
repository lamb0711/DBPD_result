GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4781)

* Revert "Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)"

This reverts commit f0982cdedf1b122f734919d0647434cca33ec254.

* Fix sporadic test failures for concurrent HSetNX
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.redis.internal.CoderException;
+import org.apache.geode.redis.internal.RedisConstants;
+    int popCount = 1;
-    if (commandElems.size() < 2) {
+    if (commandElems.size() < 2 || commandElems.size() > 3) {
+    if (commandElems.size() == 3) {
+      try {
+        popCount = Integer.parseInt(new String(commandElems.get(2)));
+      } catch (NumberFormatException nex) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ArityDef.SPOP));
+        return;
+      }
+    }
+
-    @SuppressWarnings("unchecked")
-    Region<ByteArrayWrapper, Boolean> keyRegion =
-        (Region<ByteArrayWrapper, Boolean>) context.getRegionProvider().getRegion(key);
-    if (keyRegion == null || keyRegion.isEmpty()) {
-      command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
+
+    List<ByteArrayWrapper> popped = new ArrayList<>();
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      Region<ByteArrayWrapper, Set<ByteArrayWrapper>> region = getRegion(context);
+
+      Set<ByteArrayWrapper> set = region.get(key);
+
+      if (set == null || set.isEmpty()) {
+        command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
+        return;
+      }
+
+      Random rand = new Random();
+
+      Set<Integer> randomIndexes = new HashSet<>();
+      while (randomIndexes.size() < popCount) {
+        randomIndexes.add(rand.nextInt(set.size()));
+      }
+
+      int counter = 0;
+      for (ByteArrayWrapper entry : set) {
+        if (randomIndexes.contains(counter)) {
+          popped.add(entry);
+        }
+        counter++;
+      }
+
+      set.removeAll(popped);
+
+      // save the updated set
+      region.put(key, set);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      command.setResponse(
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
-    Random rand = new Random();
-
-    ByteArrayWrapper[] entries = keyRegion.keySet().toArray(new ByteArrayWrapper[keyRegion.size()]);
-
-    ByteArrayWrapper pop = entries[rand.nextInt(entries.length)];
-
-    keyRegion.remove(pop);
-    if (keyRegion.isEmpty()) {
-      context.getRegionProvider().removeKey(key);
+    try {
+      if (popCount == 1) {
+        command
+            .setResponse(Coder.getBulkStringResponse(context.getByteBufAllocator(), popped.get(0)));
+      } else {
+        command.setResponse(Coder.getArrayResponse(context.getByteBufAllocator(), popped));
+      }
+    } catch (CoderException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          RedisConstants.SERVER_ERROR_MESSAGE));
-
-    respondBulkStrings(command, context, pop);

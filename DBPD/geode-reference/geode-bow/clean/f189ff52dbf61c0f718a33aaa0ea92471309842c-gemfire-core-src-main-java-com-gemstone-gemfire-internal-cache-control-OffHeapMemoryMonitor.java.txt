Merge remote-tracking branch 'origin/develop' into feature/GEODE-11

-/*=========================================================================
- * Copyright (c) 2002-2013 VMware, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. VMware products are covered by
- * more patents listed at http://www.vmware.com/go/patents.
- *========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+  private Thread memoryListenerThread;
-      Thread memoryListenerThread = new Thread(group, this.offHeapMemoryUsageListener);
-      memoryListenerThread.setName(memoryListenerThread.getName() + " OffHeapMemoryListener");
-      memoryListenerThread.setPriority(Thread.MAX_PRIORITY);
-      memoryListenerThread.setDaemon(true);
-      memoryListenerThread.start();
+      Thread t = new Thread(group, this.offHeapMemoryUsageListener);
+      t.setName(t.getName() + " OffHeapMemoryListener");
+      t.setPriority(Thread.MAX_PRIORITY);
+      t.setDaemon(true);
+      t.start();
+      this.memoryListenerThread = t;
+    stopMonitoring(false);
+  }
+  public void stopMonitoring(boolean waitForThread) {
+      if (waitForThread && this.memoryListenerThread != null) {
+        try {
+          this.memoryListenerThread.join();
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      this.memoryListenerThread = null;
+  public volatile OffHeapMemoryMonitorObserver testHook;
+  
+  /**
+   * Used by unit tests to be notified when OffHeapMemoryMonitor
+   * does something.
+   */
+  public static interface OffHeapMemoryMonitorObserver {
+    /**
+     * Called at the beginning of updateMemoryUsed.
+     * @param bytesUsed the number of bytes of off-heap memory currently used
+     * @param willSendEvent true if an event will be sent to the OffHeapMemoryUsageListener. 
+     */
+    public void beginUpdateMemoryUsed(long bytesUsed, boolean willSendEvent);
+    public void afterNotifyUpdateMemoryUsed(long bytesUsed);
+    /**
+     * Called at the beginning of updateStateAndSendEvent.
+     * @param bytesUsed the number of bytes of off-heap memory currently used
+     * @param willSendEvent true if an event will be sent to the OffHeapMemoryUsageListener. 
+     */
+    public void beginUpdateStateAndSendEvent(long bytesUsed, boolean willSendEvent);
+    public void updateStateAndSendEventBeforeProcess(long bytesUsed, MemoryEvent event);
+    public void updateStateAndSendEventBeforeAbnormalProcess(long bytesUsed, MemoryEvent event);
+    public void updateStateAndSendEventIgnore(long bytesUsed, MemoryState oldState, MemoryState newState, long mostRecentBytesUsed,
+        boolean deliverNextAbnormalEvent);
+  }
-    if (!mightSendEvent(bytesUsed)) {
+    final boolean willSendEvent = mightSendEvent(bytesUsed);
+    final OffHeapMemoryMonitorObserver _testHook = this.testHook;
+    if (_testHook != null) {
+      _testHook.beginUpdateMemoryUsed(bytesUsed, willSendEvent);
+    }
+    if (!willSendEvent) {
+    if (_testHook != null) {
+      _testHook.afterNotifyUpdateMemoryUsed(bytesUsed);
+    }
+      final OffHeapMemoryMonitorObserver _testHook = this.testHook;
+        if (_testHook != null) {
+          _testHook.updateStateAndSendEventBeforeProcess(bytesUsed, event);
+        }
+        if (_testHook != null) {
+          _testHook.updateStateAndSendEventBeforeAbnormalProcess(bytesUsed, event);
+        }
+      } else {
+        if (_testHook != null) {
+          _testHook.updateStateAndSendEventIgnore(bytesUsed, oldState, newState, mre.getBytesUsed(), this.deliverNextAbnormalEvent);
+        }
+        
-          if (lastOffHeapMemoryUsed == this.offHeapMemoryUsed && !this.stopRequested) {
-            try {
+          long newOffHeapMemoryUsed = this.offHeapMemoryUsed;
+          if (this.stopRequested) {
+            // no need to wait since we are stopping
+          } else if (lastOffHeapMemoryUsed != newOffHeapMemoryUsed) {
+            // no need to wait since memory used has changed
+            // This fixes a race like bug GEODE-500
+            lastOffHeapMemoryUsed = newOffHeapMemoryUsed;
+          } else {
+            // wait for memory used to change
+            try {  
-                if (this.offHeapMemoryUsed == lastOffHeapMemoryUsed) {
+                newOffHeapMemoryUsed = this.offHeapMemoryUsed;
+                if (newOffHeapMemoryUsed == lastOffHeapMemoryUsed) {
+                  // TODO: don't we need a "break" here?
+                  //       As it is we set deliverNextAbnormalEvent
+                  //       but then go back to sleep in wait.
+                  //       We need to call updateStateAndSendEvent
+                  //       which tests deliverNextAbnormalEvent.
+                  // But just adding a break is probably not enough.
+                  // We only set deliverNextAbnormalEvent if the wait
+                  // timed out which means that the amount of offHeapMemoryUsed
+                  // did not change.
+                  // But in updateStateAndSendEvent we only deliver an
+                  // abnormal event if the amount of memory changed.
+                  // This code needs to be reviewed with Swapnil but
+                  // it looks to Darrel like deliverNextAbnormalEvent
+                  // can be removed.
-                  lastOffHeapMemoryUsed = this.offHeapMemoryUsed;
+                  lastOffHeapMemoryUsed = newOffHeapMemoryUsed;
-              } while (true);
+              } while (!this.stopRequested);

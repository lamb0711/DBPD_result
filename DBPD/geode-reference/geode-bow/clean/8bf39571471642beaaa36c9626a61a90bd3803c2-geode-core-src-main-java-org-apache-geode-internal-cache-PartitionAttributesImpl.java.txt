Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Internal implementation of PartitionAttributes. New attributes existing   
- * only in this class and not in {@link PartitionAttributes} are for internal
- * use only.
- *  
+ * Internal implementation of PartitionAttributes. New attributes existing only in this class and
+ * not in {@link PartitionAttributes} are for internal use only.
+ * 
-public class PartitionAttributesImpl implements PartitionAttributes,
-      Cloneable, DataSerializable
-{
+public class PartitionAttributesImpl implements PartitionAttributes, Cloneable, DataSerializable {
-  
+
-   * the number of redundant copies to keep of each datum */
+   * the number of redundant copies to keep of each datum
+   */
-  
-  /** maximum global size of the partitioned region, in megabytes
+
+  /**
+   * maximum global size of the partitioned region, in megabytes
-  /** local settings
-   *  GLOBAL_MAX_MEMORY_PROPERTY - deprecated, use setTotalMaxMemory
-   *  GLOBAL_MAX_BUCKETS_PROPERTY - deprecated, use setTotalNumBuckets
+  /**
+   * local settings GLOBAL_MAX_MEMORY_PROPERTY - deprecated, use setTotalMaxMemory
+   * GLOBAL_MAX_BUCKETS_PROPERTY - deprecated, use setTotalNumBuckets
-  /** non-local settings
-   *  LOCAL_MAX_MEMORY_PROPERTY - deprecated, use setLocalMaxMemory
+  /**
+   * non-local settings LOCAL_MAX_MEMORY_PROPERTY - deprecated, use setLocalMaxMemory
-  
+
-   * This is used to artificially set the amount of available off-heap memory
-   * when no distributed system is available. This value works the same way as
-   * specifying off-heap as a GemFire property, so "100m" = 100 megabytes,
-   * "100g" = 100 gigabytes, etc.
+   * This is used to artificially set the amount of available off-heap memory when no distributed
+   * system is available. This value works the same way as specifying off-heap as a GemFire
+   * property, so "100m" = 100 megabytes, "100g" = 100 gigabytes, etc.
-  /** Used to determine how to calculate the default local max memory.
-   * This was made transient since we do not support p2p backwards compat changes to values stored in a region
-   * and our PR implementation stores this object in the internal PRRoot internal region.
+  /**
+   * Used to determine how to calculate the default local max memory. This was made transient since
+   * we do not support p2p backwards compat changes to values stored in a region and our PR
+   * implementation stores this object in the internal PRRoot internal region.
-  
+
-    
+
-   * Specifies the partition region name with which this newly created
-   * partitione region is colocated
+   * Specifies the partition region name with which this newly created partitione region is
+   * colocated
-  
+
-   * Specifies how long existing members will wait before
-   * recoverying redundancy
+   * Specifies how long existing members will wait before recoverying redundancy
-   /**
-   * Specifies how new members will wait before
-   * recoverying redundancy
+  /**
+   * Specifies how new members will wait before recoverying redundancy
-  
+
-                                      String.valueOf(this.totalNumBuckets));
+        String.valueOf(this.totalNumBuckets));
-    
+
-                                      String.valueOf(maximumMB));
+        String.valueOf(maximumMB));
-    
+
-                                     String.valueOf(this.localMaxMemory));
+        String.valueOf(this.localMaxMemory));
-    
+
-  
+
-  
+
-    /**
-     * Constructs an instance of <code>PartitionAttributes</code> with default
-     * settings.
-     * 
-     * @see PartitionAttributesFactory
-     */
-    public PartitionAttributesImpl() {
-    }
+  /**
+   * Constructs an instance of <code>PartitionAttributes</code> with default settings.
+   * 
+   * @see PartitionAttributesFactory
+   */
+  public PartitionAttributesImpl() {}
-    public PartitionResolver getPartitionResolver() {
-      return this.partitionResolver;
-    }
+  public PartitionResolver getPartitionResolver() {
+    return this.partitionResolver;
+  }
-    }
-    else {
+    } else {
+
-  //    public ExpirationAttributes getEntryTimeToLive()
-  //    {
-  //      return new ExpirationAttributes(this.entryTimeToLiveExpiration.getTimeout(),
-  //          this.entryTimeToLiveExpiration.getAction());
-  //    }
+  // public ExpirationAttributes getEntryTimeToLive()
+  // {
+  // return new ExpirationAttributes(this.entryTimeToLiveExpiration.getTimeout(),
+  // this.entryTimeToLiveExpiration.getAction());
+  // }
-  //    public ExpirationAttributes getEntryIdleTimeout()
-  //    {
-  //      return new ExpirationAttributes(this.entryIdleTimeoutExpiration.getTimeout(),
-  //          this.entryIdleTimeoutExpiration.getAction());
-  //    }
+  // public ExpirationAttributes getEntryIdleTimeout()
+  // {
+  // return new ExpirationAttributes(this.entryIdleTimeoutExpiration.getTimeout(),
+  // this.entryIdleTimeoutExpiration.getAction());
+  // }
-    
+
-    
+
-  
+
-   * Returns localMaxMemory that must not be a temporary placeholder for
-   * offHeapLocalMaxMemory if off-heap. This must return the true final value
-   * of localMaxMemory which requires the DistributedSystem to be created if
-   * off-heap. See bug #52003.
+   * Returns localMaxMemory that must not be a temporary placeholder for offHeapLocalMaxMemory if
+   * off-heap. This must return the true final value of localMaxMemory which requires the
+   * DistributedSystem to be created if off-heap. See bug #52003.
-   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the DistributedSystem has not yet been created)
+   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the
+   *         DistributedSystem has not yet been created)
+
-   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the DistributedSystem has not yet been created)
+   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the
+   *         DistributedSystem has not yet been created)
-    if (this.offHeap && !this.localMaxMemoryExists) { // real value does NOT yet exist so throw IllegalStateException
-      throw new IllegalStateException("Attempting to use localMaxMemory for off-heap but value is not yet known (default value is equal to off-heap-memory-size)");
+    if (this.offHeap && !this.localMaxMemoryExists) { // real value does NOT yet exist so throw
+                                                      // IllegalStateException
+      throw new IllegalStateException(
+          "Attempting to use localMaxMemory for off-heap but value is not yet known (default value is equal to off-heap-memory-size)");
-  
+
-   * Returns localMaxMemory for validation of attributes before Region is 
-   * created (possibly before DistributedSystem is created). Returned value may 
-   * be the temporary placeholder representing offHeapLocalMaxMemory which 
-   * cannot be calculated until the DistributedSystem is created. See bug 
-   * #52003.
+   * Returns localMaxMemory for validation of attributes before Region is created (possibly before
+   * DistributedSystem is created). Returned value may be the temporary placeholder representing
+   * offHeapLocalMaxMemory which cannot be calculated until the DistributedSystem is created. See
+   * bug #52003.
-   * @see #OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER 
+   * @see #OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER
-    
+
+
-  
+
-  
+
-  
+
-      return (PartitionListener[])EMPTY_PARTITION_LISTENERS;
-    }
-    else {
+      return (PartitionListener[]) EMPTY_PARTITION_LISTENERS;
+    } else {
-          return (PartitionListener[])EMPTY_PARTITION_LISTENERS;
-        }
-        else {
+          return (PartitionListener[]) EMPTY_PARTITION_LISTENERS;
+        } else {
-    
+
-    }
-    catch (CloneNotSupportedException e) {
+    } catch (CloneNotSupportedException e) {
-        LocalizedStrings.PartitionAttributesImpl_CLONENOTSUPPORTEDEXCEPTION_THROWN_IN_CLASS_THAT_IMPLEMENTS_CLONEABLE.toLocalizedString());
+          LocalizedStrings.PartitionAttributesImpl_CLONENOTSUPPORTEDEXCEPTION_THROWN_IN_CLASS_THAT_IMPLEMENTS_CLONEABLE
+              .toLocalizedString());
-  
+
-  public String toString()
-  {
+  public String toString() {
-    return s.append("PartitionAttributes@")
-      .append(System.identityHashCode(this))
-      .append("[redundantCopies=").append(getRedundantCopies())
-      .append(";localMaxMemory=").append(getLocalMaxMemory())
-      .append(";totalMaxMemory=").append(this.totalMaxMemory)
-      .append(";totalNumBuckets=").append(this.totalNumBuckets)
-      .append(";partitionResolver=").append(this.partitionResolver)
-      .append(";colocatedWith=").append(this.colocatedRegionName)
-      .append(";recoveryDelay=").append(this.recoveryDelay)
-      .append(";startupRecoveryDelay=").append(this.startupRecoveryDelay)
-      .append(";FixedPartitionAttributes=").append(this.fixedPAttrs)
-      .append(";partitionListeners=").append(this.partitionListeners)
-      .append("]") .toString();
+    return s.append("PartitionAttributes@").append(System.identityHashCode(this))
+        .append("[redundantCopies=").append(getRedundantCopies()).append(";localMaxMemory=")
+        .append(getLocalMaxMemory()).append(";totalMaxMemory=").append(this.totalMaxMemory)
+        .append(";totalNumBuckets=").append(this.totalNumBuckets).append(";partitionResolver=")
+        .append(this.partitionResolver).append(";colocatedWith=").append(this.colocatedRegionName)
+        .append(";recoveryDelay=").append(this.recoveryDelay).append(";startupRecoveryDelay=")
+        .append(this.startupRecoveryDelay).append(";FixedPartitionAttributes=")
+        .append(this.fixedPAttrs).append(";partitionListeners=").append(this.partitionListeners)
+        .append("]").toString();
-   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the DistributedSystem has not yet been created)
+   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the
+   *         DistributedSystem has not yet been created)
-    out.writeInt(getLocalMaxMemory()); // call the gettor to force it to be computed in the offheap case
+    out.writeInt(getLocalMaxMemory()); // call the gettor to force it to be computed in the offheap
+                                       // case
-  
+
-    this.localProperties = (Properties)DataSerializer.readObject(in);
-    this.globalProperties = (Properties)DataSerializer.readObject(in);
+    this.localProperties = (Properties) DataSerializer.readObject(in);
+    this.globalProperties = (Properties) DataSerializer.readObject(in);
-    
+
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-    if (this == obj) { 
+    if (this == obj) {
-    
-  if (! (obj instanceof PartitionAttributesImpl)) {
-    return false;
-  }
-    
-  PartitionAttributesImpl other = (PartitionAttributesImpl) obj;
-    
+
+    if (!(obj instanceof PartitionAttributesImpl)) {
+      return false;
+    }
+
+    PartitionAttributesImpl other = (PartitionAttributesImpl) obj;
+
-        || getLocalMaxMemory() != other.getLocalMaxMemory()
-        || this.offHeap != other.getOffHeap()
+        || getLocalMaxMemory() != other.getLocalMaxMemory() || this.offHeap != other.getOffHeap()
-//          || ! this.localProperties.equals(other.getLocalProperties())
-//          || ! this.globalProperties.equals(other.getGlobalProperties())
+        // || ! this.localProperties.equals(other.getLocalProperties())
+        // || ! this.globalProperties.equals(other.getGlobalProperties())
-        || (this.partitionResolver != null && !this.partitionResolver
-          .equals(other.getPartitionResolver()))
+        || (this.partitionResolver != null
+            && !this.partitionResolver.equals(other.getPartitionResolver()))
-        || (this.colocatedRegionName != null && !this.colocatedRegionName
-          .equals(other.getColocatedWith()))
-        ||((this.fixedPAttrs == null) != (other.getFixedPartitionAttributes()== null))
-        ||(this.fixedPAttrs != null && !this.fixedPAttrs.equals(other.getFixedPartitionAttributes()))
-        ) {
-      //throw new RuntimeException("this="+this.toString() + "   other=" + other.toString());
+        || (this.colocatedRegionName != null
+            && !this.colocatedRegionName.equals(other.getColocatedWith()))
+        || ((this.fixedPAttrs == null) != (other.getFixedPartitionAttributes() == null))
+        || (this.fixedPAttrs != null
+            && !this.fixedPAttrs.equals(other.getFixedPartitionAttributes()))) {
+      // throw new RuntimeException("this="+this.toString() + " other=" + other.toString());
-     
+
-  public int hashCode()
-  {
+  public int hashCode() {
-   * Set local properties 
+   * Set local properties
+   * 
-      setLocalMaxMemory(Integer.parseInt((String)localProps.get(PartitionAttributesFactory.LOCAL_MAX_MEMORY_PROPERTY)));
+      setLocalMaxMemory(Integer
+          .parseInt((String) localProps.get(PartitionAttributesFactory.LOCAL_MAX_MEMORY_PROPERTY)));
-   * @deprecated use {@link #setTotalMaxMemory(long)} and 
-   *  {@link #setTotalNumBuckets(int)} in GemFire 5.1 and later releases
+   * 
+   * @deprecated use {@link #setTotalMaxMemory(long)} and {@link #setTotalNumBuckets(int)} in
+   *             GemFire 5.1 and later releases
-        setTotalMaxMemory(Integer.parseInt(propVal)); 
-      }
-      catch (RuntimeException e) {
+        setTotalMaxMemory(Integer.parseInt(propVal));
+      } catch (RuntimeException e) {
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-      this.fixedPAttrs.add((FixedPartitionAttributesImpl)fpa);
+      this.fixedPAttrs.add((FixedPartitionAttributesImpl) fpa);
-    }
-    else {
-      this.fixedPAttrs.add((FixedPartitionAttributesImpl)fpa);
+    } else {
+      this.fixedPAttrs.add((FixedPartitionAttributesImpl) fpa);
-  
+
-   * Validates that the attributes are consistent with each other. The following
-   * rules are checked and enforced:
+   * Validates that the attributes are consistent with each other. The following rules are checked
+   * and enforced:
-   * NOTE: validation that depends on more than one attribute can not be done in this method.
-   * That validation needs to be done in validateWhenAllAttributesAreSet
+   * NOTE: validation that depends on more than one attribute can not be done in this method. That
+   * validation needs to be done in validateWhenAllAttributesAreSet
-   * @throws IllegalStateException
-   *           if the attributes are not consistent with each other.
+   * @throws IllegalStateException if the attributes are not consistent with each other.
-  public void validateAttributes()
-  {
+  public void validateAttributes() {
-        LocalizedStrings.PartitionAttributesImpl_REDUNDANTCOPIES_0_IS_AN_ILLEGAL_VALUE_PLEASE_CHOOSE_A_VALUE_BETWEEN_0_AND_3
-          .toLocalizedString(Integer.valueOf(this.redundancy)));
+          LocalizedStrings.PartitionAttributesImpl_REDUNDANTCOPIES_0_IS_AN_ILLEGAL_VALUE_PLEASE_CHOOSE_A_VALUE_BETWEEN_0_AND_3
+              .toLocalizedString(Integer.valueOf(this.redundancy)));
-    for (Iterator it=this.getLocalProperties().keySet().iterator(); it.hasNext(); ) {
-      String propName = (String)it.next();
+    for (Iterator it = this.getLocalProperties().keySet().iterator(); it.hasNext();) {
+      String propName = (String) it.next();
-          LocalizedStrings.PartitionAttributesImpl_UNKNOWN_LOCAL_PROPERTY_0
-            .toLocalizedString(propName));
+            LocalizedStrings.PartitionAttributesImpl_UNKNOWN_LOCAL_PROPERTY_0
+                .toLocalizedString(propName));
-    for (Iterator it=this.getGlobalProperties().keySet().iterator(); it.hasNext(); ) {
-      String propName = (String)it.next();
+    for (Iterator it = this.getGlobalProperties().keySet().iterator(); it.hasNext();) {
+      String propName = (String) it.next();
-          LocalizedStrings.PartitionAttributesImpl_UNKNOWN_GLOBAL_PROPERTY_0
-           .toLocalizedString(propName));
+            LocalizedStrings.PartitionAttributesImpl_UNKNOWN_GLOBAL_PROPERTY_0
+                .toLocalizedString(propName));
-      throw new IllegalStateException(
-          "RecoveryDelay "
-              + this.recoveryDelay
-              + " is an illegal value, please choose a value that is greater than or equal to -1");
+      throw new IllegalStateException("RecoveryDelay " + this.recoveryDelay
+          + " is an illegal value, please choose a value that is greater than or equal to -1");
-      throw new IllegalStateException(
-          "StartupRecoveryDelay "
-              + this.startupRecoveryDelay
-              + " is an illegal value, please choose a value that is greater than or equal to -1");
+      throw new IllegalStateException("StartupRecoveryDelay " + this.startupRecoveryDelay
+          + " is an illegal value, please choose a value that is greater than or equal to -1");
-        List<FixedPartitionAttributesImpl> duplicateFPAattrsList = new ArrayList<FixedPartitionAttributesImpl>();
-        Set<FixedPartitionAttributes> fpAttrsSet = new HashSet<FixedPartitionAttributes>();
-        for (FixedPartitionAttributesImpl fpa : this.fixedPAttrs) {
-          if (fpa == null || fpa.getPartitionName() == null) {
-            throw new IllegalStateException(
-                LocalizedStrings.PartitionAttributesImpl_FIXED_PARTITION_NAME_CANNOT_BE_NULL
-                    .toString());
-          }
-          if (fpAttrsSet.contains(fpa)) {
-            duplicateFPAattrsList.add(fpa);
-          }
-          else {
-            fpAttrsSet.add(fpa);
-          }
-        }
-        if (duplicateFPAattrsList.size() != 0) {
+      List<FixedPartitionAttributesImpl> duplicateFPAattrsList =
+          new ArrayList<FixedPartitionAttributesImpl>();
+      Set<FixedPartitionAttributes> fpAttrsSet = new HashSet<FixedPartitionAttributes>();
+      for (FixedPartitionAttributesImpl fpa : this.fixedPAttrs) {
+        if (fpa == null || fpa.getPartitionName() == null) {
-              LocalizedStrings.PartitionAttributesImpl_PARTITION_NAME_0_CAN_BE_ADDED_ONLY_ONCE_IN_FIXED_PARTITION_ATTRIBUTES
-                  .toString(duplicateFPAattrsList.toString()));
+              LocalizedStrings.PartitionAttributesImpl_FIXED_PARTITION_NAME_CANNOT_BE_NULL
+                  .toString());
+        if (fpAttrsSet.contains(fpa)) {
+          duplicateFPAattrsList.add(fpa);
+        } else {
+          fpAttrsSet.add(fpa);
+        }
+      }
+      if (duplicateFPAattrsList.size() != 0) {
+        throw new IllegalStateException(
+            LocalizedStrings.PartitionAttributesImpl_PARTITION_NAME_0_CAN_BE_ADDED_ONLY_ONCE_IN_FIXED_PARTITION_ATTRIBUTES
+                .toString(duplicateFPAattrsList.toString()));
+      }
-  
+
-   * This validation should only be done once the region attributes
-   * that owns this pa is ready to be created.
-   * Need to do it this late because of bug 45749.
+   * This validation should only be done once the region attributes that owns this pa is ready to be
+   * created. Need to do it this late because of bug 45749.
-   * This method used to be called when the RegionAttributes were created.
-   * But this was too early since the region we are colocated with might not exist (yet).
-   * So it is now called when the PR using these attributes is created.
-   * See bug 47197.
+   * This method used to be called when the RegionAttributes were created. But this was too early
+   * since the region we are colocated with might not exist (yet). So it is now called when the PR
+   * using these attributes is created. See bug 47197.
-      Region<?,?> region = cache.getRegion(this.colocatedRegionName);
+      Region<?, ?> region = cache.getRegion(this.colocatedRegionName);
-          throw new IllegalStateException(LocalizedStrings.
-              PartitionAttributesImpl_REGION_SPECIFIED_IN_COLOCATEDWITH_IS_NOT_PRESENT_IT_SHOULD_BE_CREATED_BEFORE_SETTING_COLOCATED_WITH_THIS_REGION
-              .toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.PartitionAttributesImpl_REGION_SPECIFIED_IN_COLOCATEDWITH_IS_NOT_PRESENT_IT_SHOULD_BE_CREATED_BEFORE_SETTING_COLOCATED_WITH_THIS_REGION
+                  .toLocalizedString());
-          throw new IllegalStateException(LocalizedStrings.
-              PartitionAttributesImpl_SETTING_THE_ATTRIBUTE_COLOCATEDWITH_IS_SUPPORTED_ONLY_FOR_PARTITIONEDREGIONS
-              .toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.PartitionAttributesImpl_SETTING_THE_ATTRIBUTE_COLOCATEDWITH_IS_SUPPORTED_ONLY_FOR_PARTITIONEDREGIONS
+                  .toLocalizedString());
-        PartitionedRegion colocatedRegion = (PartitionedRegion)region;
-        if (this.getTotalNumBuckets() != colocatedRegion
-            .getPartitionAttributes().getTotalNumBuckets()) {
-          throw new IllegalStateException(LocalizedStrings.
-              PartitionAttributesImpl_CURRENT_PARTITIONEDREGIONS_TOTALNUMBUCKETS_SHOULD_BE_SAME_AS_TOTALNUMBUCKETS_OF_COLOCATED_PARTITIONEDREGION
-              .toLocalizedString());
+        PartitionedRegion colocatedRegion = (PartitionedRegion) region;
+        if (this.getTotalNumBuckets() != colocatedRegion.getPartitionAttributes()
+            .getTotalNumBuckets()) {
+          throw new IllegalStateException(
+              LocalizedStrings.PartitionAttributesImpl_CURRENT_PARTITIONEDREGIONS_TOTALNUMBUCKETS_SHOULD_BE_SAME_AS_TOTALNUMBUCKETS_OF_COLOCATED_PARTITIONEDREGION
+                  .toLocalizedString());
-        if (this.getRedundancy() != colocatedRegion.getPartitionAttributes()
-            .getRedundantCopies()) {
-          throw new IllegalStateException(LocalizedStrings.
-              PartitionAttributesImpl_CURRENT_PARTITIONEDREGIONS_REDUNDANCY_SHOULD_BE_SAME_AS_THE_REDUNDANCY_OF_COLOCATED_PARTITIONEDREGION
-              .toLocalizedString());
+        if (this.getRedundancy() != colocatedRegion.getPartitionAttributes().getRedundantCopies()) {
+          throw new IllegalStateException(
+              LocalizedStrings.PartitionAttributesImpl_CURRENT_PARTITIONEDREGIONS_REDUNDANCY_SHOULD_BE_SAME_AS_THE_REDUNDANCY_OF_COLOCATED_PARTITIONEDREGION
+                  .toLocalizedString());
-  
+
-   * Added for bug 45749.
-   * The attributes in pa are merged into this.
-   * Only attributes explicitly set in pa will be merged into this.
-   * Any attribute set in pa will take precedence over an attribute in this.
+   * Added for bug 45749. The attributes in pa are merged into this. Only attributes explicitly set
+   * in pa will be merged into this. Any attribute set in pa will take precedence over an attribute
+   * in this.
+   * 
-  
+
-  public void setAll(@SuppressWarnings("rawtypes")
-  PartitionAttributes pa) {
+  public void setAll(@SuppressWarnings("rawtypes") PartitionAttributes pa) {
-  
+
-   * Only used for testing. Sets the amount of available off-heap memory when no
-   * distributed system is available. This method must be called before any
-   * instances of PartitionAttributesImpl are created. Specify the value the
-   * same way the off-heap memory property is specified. So, "100m" = 100
-   * megabytes, etc.
+   * Only used for testing. Sets the amount of available off-heap memory when no distributed system
+   * is available. This method must be called before any instances of PartitionAttributesImpl are
+   * created. Specify the value the same way the off-heap memory property is specified. So, "100m" =
+   * 100 megabytes, etc.
-   * @param newTestAvailableOffHeapMemory The new test value for available
-   * off-heap memory.
+   * @param newTestAvailableOffHeapMemory The new test value for available off-heap memory.
-  
+
-   * By default the partition can use up to 100% of the allocated off-heap
-   * memory.
+   * By default the partition can use up to 100% of the allocated off-heap memory.
-    
+
-      availableOffHeapMemoryInMB = OffHeapStorage.parseOffHeapMemorySize(testAvailableOffHeapMemory) / (1024 * 1024);
+      availableOffHeapMemoryInMB =
+          OffHeapStorage.parseOffHeapMemorySize(testAvailableOffHeapMemory) / (1024 * 1024);
-      return OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER; // fix 52033: return non-negative, non-zero temporary placeholder for offHeapLocalMaxMemory
+      return OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER; // fix 52033: return non-negative, non-zero
+                                                    // temporary placeholder for
+                                                    // offHeapLocalMaxMemory
-      String offHeapSizeConfigValue = InternalDistributedSystem.getAnyInstance().getOriginalConfig().getOffHeapMemorySize();
-      availableOffHeapMemoryInMB = OffHeapStorage.parseOffHeapMemorySize(offHeapSizeConfigValue) / (1024 * 1024);
+      String offHeapSizeConfigValue =
+          InternalDistributedSystem.getAnyInstance().getOriginalConfig().getOffHeapMemorySize();
+      availableOffHeapMemoryInMB =
+          OffHeapStorage.parseOffHeapMemorySize(offHeapSizeConfigValue) / (1024 * 1024);
-    
+
-      logger.warn(LocalizedMessage.create(LocalizedStrings.PartitionAttributesImpl_REDUCED_LOCAL_MAX_MEMORY_FOR_PARTITION_ATTRIBUTES_WHEN_SETTING_FROM_AVAILABLE_OFF_HEAP_MEMORY_SIZE));
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.PartitionAttributesImpl_REDUCED_LOCAL_MAX_MEMORY_FOR_PARTITION_ATTRIBUTES_WHEN_SETTING_FROM_AVAILABLE_OFF_HEAP_MEMORY_SIZE));
-    
+
-  
+
-    
+

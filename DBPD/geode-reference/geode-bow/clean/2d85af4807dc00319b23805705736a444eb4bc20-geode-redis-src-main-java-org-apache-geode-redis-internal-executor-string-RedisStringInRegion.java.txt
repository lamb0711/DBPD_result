GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+import org.apache.geode.redis.internal.Coder;
+import org.apache.geode.redis.internal.executor.RedisKeyInRegion;
-public class RedisStringInRegion implements RedisStringCommands {
-  private final Region<ByteArrayWrapper, RedisData> region;
+public class RedisStringInRegion extends RedisKeyInRegion implements RedisStringCommands {
-  @SuppressWarnings("unchecked")
-    this.region = region;
+    super(region);
-    RedisString redisString = checkType(region.get(key));
+    RedisString redisString = getRedisString(key);
-    RedisString redisString = checkType(region.get(key));
+    RedisString redisString = getRedisString(key);
-      if (options.getExists().equals(SetOptions.Exists.NX)) {
-        return setnx(key, value);
+      if (options.isNX()) {
+        return setnx(key, value, options);
-      if (options.getExists().equals(SetOptions.Exists.XX) && region.get(key) == null) {
+      if (options.isXX() && getRedisData(key) == null) {
-    RedisString redisString = checkTypeIsString(region.get(key));
+    RedisString redisString = getRedisStringForSet(key);
+    if (redisString == null) {
+      redisString = new RedisString(value);
+    } else {
+      redisString.set(value);
+    }
+    handleSetExpiration(redisString, options);
+    region.put(key, redisString);
+    return true;
+  }
+
+  @Override
+  public long incr(ByteArrayWrapper key) {
+    RedisString redisString = getRedisString(key);
+
+    if (redisString == null) {
+      byte[] newValue = {Coder.NUMBER_1_BYTE};
+      redisString = new RedisString(new ByteArrayWrapper(newValue));
+      region.put(key, redisString);
+      return 1;
+    }
+
+    return redisString.incr(region, key);
+  }
+
+  @Override
+  public long decr(ByteArrayWrapper key) {
+    RedisString redisString = getRedisString(key);
+
+    if (redisString == null) {
+      redisString = new RedisString(new ByteArrayWrapper(Coder.stringToBytes("-1")));
+      region.put(key, redisString);
+      return -1;
+    }
+
+    return redisString.decr(region, key);
+  }
+
+  @Override
+  public ByteArrayWrapper getset(ByteArrayWrapper key, ByteArrayWrapper value) {
+    ByteArrayWrapper result = null;
+    RedisString redisString = getRedisString(key);
+      result = redisString.get();
+      redisString.persistNoDelta();
+    return result;
+  }
+
+  @Override
+  public long incrby(ByteArrayWrapper key, long increment) {
+    RedisString redisString = getRedisString(key);
+
+    if (redisString == null) {
+      byte[] newValue = Coder.stringToBytes(Long.toString(increment));
+      redisString = new RedisString(new ByteArrayWrapper(newValue));
+      region.put(key, redisString);
+      return increment;
+    }
+
+    return redisString.incrby(region, key, increment);
+  }
+
+  @Override
+  public long decrby(ByteArrayWrapper key, long decrement) {
+    RedisString redisString = getRedisString(key);
+
+    if (redisString == null) {
+      byte[] newValue = Coder.stringToBytes(Long.toString(-decrement));
+      redisString = new RedisString(new ByteArrayWrapper(newValue));
+      region.put(key, redisString);
+      return -decrement;
+    }
+
+    return redisString.decrby(region, key, decrement);
+  }
+
+  private boolean setnx(ByteArrayWrapper key, ByteArrayWrapper value, SetOptions options) {
+    if (getRedisData(key) != null) {
+      return false;
+    }
+    RedisString redisString = new RedisString(value);
+    handleSetExpiration(redisString, options);
+    region.put(key, redisString);
-  private boolean setnx(ByteArrayWrapper key, ByteArrayWrapper value) {
-    if (region.get(key) != null) {
-      return false;
+  private void handleSetExpiration(RedisString redisString, SetOptions options) {
+    long setExpiration = options == null ? 0L : options.getExpiration();
+    if (setExpiration != 0) {
+      long now = System.currentTimeMillis();
+      long timestamp = now + setExpiration;
+      redisString.setExpirationTimestampNoDelta(timestamp);
+    } else if (options == null || !options.isKeepTTL()) {
+      redisString.persistNoDelta();
-    region.put(key, new RedisString(value));
-    return true;
-  private RedisString checkTypeIsString(RedisData redisData) {
-    if (redisData == null || redisData.getType() != REDIS_STRING) {
-      return null;
-    }
-    return (RedisString) redisData;
+  private RedisString getRedisString(ByteArrayWrapper key) {
+    return checkType(getRedisData(key));
-  private RedisString checkExists(RedisData redisData) {
-    if (redisData == null) {
+  private RedisString getRedisStringForSet(ByteArrayWrapper key) {
+    RedisData redisData = getRedisData(key);
+    if (redisData == null || redisData.getType() != REDIS_STRING) {

Revert GEODE-2644 because offline diskstore commands generate info level logs

GFSH forks the offline diskstore commands in a JVM using log4j2-cli.xml
which sets the log level to WARN. However, the forked JVM creates a
Cache which then starts generating info level statements to STDOUT.

Revert "GEODE-2644: Remove log level from MonitorQueryUnderContentionBenchmark"
This reverts commit 6691d310e1263966991e584f712156d919dabecf.

Revert "GEODE-2644: Update session state caching dependencies for logging"
This reverts commit 688f58a4a75cc1297faa1dda201b971346c3a9fe.

Revert "GEODE-5637: Fix flaky SingleHopClientExecutorWithLoggingIntegrationTest"
This reverts commit 0a8f3dffa1ebaa618fafecc15bbc92ba8ba83696.

Revert "GEODE-2644: Make LogWriterAppender optional and support log4j2.xml"
This reverts commit 591f3f7840ce38c6100bff2040f396ad2469175e.

Revert "GEODE-2644: Expand DistributedSystemMXBean tests"
This reverts commit cd2bba13e2fb7e79f7634053a6c612050b328e11.

Revert "GEODE-2644: Make AlertAppender optional and support log4j2.xml"
This reverts commit 02c3cae1d38098259ff6aa4635c6e74f795bdc50.

Revert "GEODE-2644: Add LogConfig and StatisticsConfig for logging"
This reverts commit a77c94b349b3ed7fc873fc29f6852f9936843790.

Revert "GEODE-2644: Add AlertingTest JUnit Category"
This reverts commit 731cd2a7d35b086d34f8bbcb94a83c40739ae8ee.

Revert "GEODE-2644: Add LogFileAssert and LogLevelAssert assertions"
This reverts commit 5e61da5301469cdbd71ac186573f56c38e9a6cf0.

Revert "GEODE-2644: Cleanup logging related files"
This reverts commit 763e4177f201eff9b140654e6858152a1a184b8c.

Revert "GEODE-2644: Define interfaces for new Log4j2 Appenders"
This reverts commit efd8a14027195b6dae1dd3e4d53a33696ed318bb.

-import static org.apache.geode.internal.logging.InternalLogWriter.ALL_LEVEL;
-
-  private static final StandardErrorPrinter stderr = new StandardErrorPrinter(ALL_LEVEL);
+  private static final StandardErrorPrinter stderr =
+      new StandardErrorPrinter(InternalLogWriter.ALL_LEVEL);
-  private static final Collection<LoggingThreadGroup> loggingThreadGroups = new ArrayList<>();
+  private static final Collection<LoggingThreadGroup> loggingThreadGroups =
+      new ArrayList<LoggingThreadGroup>();
+   *        author David Whitlock
-        LoggingThreadGroup group2 = iter.next();
+        LoggingThreadGroup group2 = (LoggingThreadGroup) iter.next();
+   *        author David Whitlock
-        LoggingThreadGroup group2 = iter.next();
+        LoggingThreadGroup group2 = (LoggingThreadGroup) iter.next();
+  // /**
+  // * @deprecated Only for use by hydra for backwards compatability reasons.
+  // * Returns a <code>ThreadGroup</code> whose {@link
+  // * ThreadGroup#uncaughtException} method logs to both {#link
+  // * System#err} and the given <code>LogWriterI18n</code>.
+  // *
+  // * @param name
+  // * The name of the <code>ThreadGroup</code>
+  // * @param logger
+  // * A <code>LogWriter</code> to log uncaught exceptions to. It
+  // * is okay for this argument to be <code>null</code>.
+  // *
+  // * author kbanks
+  // * @since GemFire 6.0
+  // */
+  // @Deprecated public static LoggingThreadGroup createThreadGroup(final String name,
+  // final LogWriter logger) {
+  // return createThreadGroup(name,
+  // logger != null ? logger.convertToLogWriterI18n() : null);
+  // }
+
-      for (LoggingThreadGroup loggingThreadGroup : loggingThreadGroups) {
-        if (!loggingThreadGroup.getName().equals(InternalDistributedSystem.SHUTDOWN_HOOK_NAME)
-            && !loggingThreadGroup.getName().equals("GemFireConnectionFactory Shutdown Hook")) {
-          loggingThreadGroup.cleanup();
+      LoggingThreadGroup group;
+      Iterator<?> itr = loggingThreadGroups.iterator();
+      while (itr.hasNext()) {
+        group = (LoggingThreadGroup) itr.next();
+        if (!group.getName().equals(InternalDistributedSystem.SHUTDOWN_HOOK_NAME)
+            && !group.getName().equals("GemFireConnectionFactory Shutdown Hook")) {
+          group.cleanup();
-  private final Object dispatchLock = new Object();
+  private Object dispatchLock = new Object();
-    synchronized (dispatchLock) {
+    synchronized (this.dispatchLock) {
-        if (logger != null) {
-          logger.info(String.format(msg, msgArgs));
+        if (this.logger != null) {
+          this.logger.info(String.format(msg, msgArgs));
-        if (logWriter != null) {
-          logWriter.info(String.format(msg, msgArgs));
+        if (this.logWriter != null) {
+          this.logWriter.info(String.format(msg, msgArgs));
-        if (logger != null) {
-          logger.fatal(String.format("Uncaught exception in thread %s", t), ex);
+        if (this.logger != null) {
+          this.logger.fatal(String.format("Uncaught exception in thread %s", t), ex);
-        if (logWriter != null) {
-          logWriter.severe(String.format("Uncaught exception in thread %s", t), ex);
+        if (this.logWriter != null) {
+          this.logWriter.severe(String.format("Uncaught exception in thread %s", t), ex);
-      uncaughtExceptionsCount++;
+      // if (!(ex instanceof RuntimeException) && (ex instanceof Exception)) {
+      // something's fishy - checked exceptions shouldn't get here
+      // this.logger.severe("stack trace showing origin of uncaught checked exception", new
+      // Exception("stack trace");
+      // }
+      this.uncaughtExceptionsCount++;
-    synchronized (dispatchLock) {
-      uncaughtExceptionsCount = 0;
+    synchronized (this.dispatchLock) {
+      this.uncaughtExceptionsCount = 0;
-    synchronized (dispatchLock) {
+    synchronized (this.dispatchLock) {
-    logger = null;
-    logWriter = null;
+    this.logger = null;
+    this.logWriter = null;

Merge branch 'release/1.3.0'

-import java.io.BufferedReader;
-import java.io.IOException;
+import static org.apache.commons.lang.Validate.isTrue;
+import static org.apache.commons.lang.Validate.notNull;
+
-import java.io.InputStreamReader;
-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.internal.logging.LogService;
-  private static final int DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS = 5000;
-  private static final Logger logger = LogService.getLogger();
+
+  private static final int DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLIS = 5000;
+    notNull(builder, "Invalid builder '" + builder + "' specified");
+
+
-  @Override
-  public void run() {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    if (isDebugEnabled) {
-      logger.debug("Running {}", this);
-    }
-    BufferedReader reader = null;
-    try {
-      reader = new BufferedReader(new InputStreamReader(inputStream));
-      String line;
-      while ((line = reader.readLine()) != null) {
-        this.inputListener.notifyInputLine(line);
-      }
-    } catch (IOException e) {
-      if (isDebugEnabled) {
-        logger.debug("Failure reading from buffered input stream: {}", e.getMessage(), e);
-      }
-    } finally {
-      try {
-        reader.close();
-      } catch (IOException e) {
-        if (isDebugEnabled) {
-          logger.debug("Failure closing buffered input stream reader: {}", e.getMessage(), e);
-        }
-      }
-      if (isDebugEnabled) {
-        logger.debug("Terminating {}", this);
-      }
-    }
-  }
-
-      if (this.thread == null) {
-        this.thread = new Thread(this, createThreadName());
-        this.thread.setDaemon(true);
-        this.thread.start();
-      } else if (this.thread.isAlive()) {
+      if (thread == null) {
+        thread = new Thread(this, createThreadName());
+        thread.setDaemon(true);
+        thread.start();
+      } else if (thread.isAlive()) {
-      if (this.thread != null && this.thread.isAlive()) {
-        this.thread.interrupt();
-      } else if (this.thread != null) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} has already been stopped", this);
-        }
-      } else {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} has not been started", this);
-        }
+      if (thread != null && thread.isAlive()) {
+        thread.interrupt();
-    Runnable delayedStop = new Runnable() {
-      @Override
-      public void run() {
-        try {
-          Thread.sleep(delayMillis);
-        } catch (InterruptedException e) {
-        } finally {
-          stop();
-        }
+    Runnable delayedStop = () -> {
+      try {
+        Thread.sleep(delayMillis);
+      } catch (InterruptedException ignored) {
+      } finally {
+        stop();
+
-      if (this.thread != null) {
-        return this.thread.isAlive();
+      if (thread != null) {
+        return thread.isAlive();
-  public void join() throws InterruptedException {
+  public ProcessStreamReader join() throws InterruptedException {
+    return this;
-  public void join(final long millis) throws InterruptedException {
+  public ProcessStreamReader join(final long millis) throws InterruptedException {
+    return this;
-  public void join(final long millis, final int nanos) throws InterruptedException {
+  public ProcessStreamReader join(final long millis, final int nanos) throws InterruptedException {
+    return this;
-    final StringBuilder sb = new StringBuilder(getClass().getSimpleName());
+    StringBuilder sb = new StringBuilder(getClass().getSimpleName());
-    sb.append(" alive=").append(isRunning()); // this.thread == null ? false :
-                                              // this.thread.isAlive());
-    sb.append(" listener=").append(this.inputListener);
+    sb.append(" alive=").append(isRunning());
+    sb.append(" listener=").append(inputListener);
-    return getClass().getSimpleName() + "@" + Integer.toHexString(hashCode());
+    return getClass().getSimpleName() + '@' + Integer.toHexString(hashCode());
-  public static interface InputListener {
-    public void notifyInputLine(String line);
+  public interface InputListener {
+    void notifyInputLine(final String line);
-  public static enum ReadingMode {
-    BLOCKING, NON_BLOCKING;
+  public enum ReadingMode {
+    BLOCKING, NON_BLOCKING
-  public static String waitAndCaptureProcessStandardOutputStream(final Process process) {
-    return waitAndCaptureProcessStandardOutputStream(process,
-        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
-  }
-
-  public static String waitAndCaptureProcessStandardOutputStream(final Process process,
+  private static String waitAndCaptureProcessStandardOutputStream(final Process process,
+    notNull(process, "Invalid process '" + process + "' specified");
+
-        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
+        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLIS);
-      final InputStream processInputStream, long waitTimeMilliseconds) {
-    final StringBuffer buffer = new StringBuffer();
+      final InputStream processInputStream, final long waitTimeMilliseconds) {
+    StringBuffer buffer = new StringBuffer();
-      final long endTime = (System.currentTimeMillis() + waitTimeMilliseconds);
+      long endTime = System.currentTimeMillis() + waitTimeMilliseconds;
-   * 
+   *
-    protected Process process;
-    protected InputStream inputStream;
-    protected InputListener inputListener;
-    protected long continueReadingMillis = 0;
-    protected ReadingMode readingMode = ReadingMode.BLOCKING;
+
+    final Process process;
+    InputStream inputStream;
+    InputListener inputListener;
+    long continueReadingMillis = 0;
+    ReadingMode readingMode = ReadingMode.BLOCKING;
-      if (process == null) {
-        throw new NullPointerException("process may not be null");
-      }
-      if (inputStream == null) {
-        throw new NullPointerException("inputStream may not be null");
-      }
-      if (continueReadingMillis < 0) {
-        throw new IllegalArgumentException("continueReadingMillis must zero or positive");
-      }
-      switch (this.readingMode) {
+      notNull(process, "Invalid process '" + process + "' specified");
+      notNull(inputStream, "Invalid inputStream '" + inputStream + "' specified");
+      isTrue(continueReadingMillis >= 0,
+          "Invalid continueReadingMillis '" + continueReadingMillis + "' specified");
+
+      switch (readingMode) {

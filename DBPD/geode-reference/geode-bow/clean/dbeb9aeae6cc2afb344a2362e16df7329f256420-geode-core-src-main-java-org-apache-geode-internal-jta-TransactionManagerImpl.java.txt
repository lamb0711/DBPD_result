Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  protected SortedSet gtxSet = Collections.synchronizedSortedSet(new TreeSet(
-      new GlobalTransactionComparator()));
+  protected SortedSet gtxSet =
+      Collections.synchronizedSortedSet(new TreeSet(new GlobalTransactionComparator()));
-  static final int DEFAULT_TRANSACTION_TIMEOUT = Integer.getInteger("jta.defaultTimeout", 600).intValue();
+  static final int DEFAULT_TRANSACTION_TIMEOUT =
+      Integer.getInteger("jta.defaultTimeout", 600).intValue();
-  //TODO:Asif .Not yet used this exception code
-//  private static final int EXCEPTION_IN_NOTIFY_AFTER_COMPLETION = 6;
+  // TODO:Asif .Not yet used this exception code
+  // private static final int EXCEPTION_IN_NOTIFY_AFTER_COMPLETION = 6;
-   * to enable VERBOSE = true pass System parameter jta.VERBOSE = true
-   * while running the test. 
+   * to enable VERBOSE = true pass System parameter jta.VERBOSE = true while running the test.
-   * checks if the TransactionManager is active 
+   * checks if the TransactionManager is active
-    ThreadGroup group =
-      LoggingThreadGroup.createThreadGroup(LocalizedStrings.TransactionManagerImpl_CLEAN_UP_THREADS.toLocalizedString());
+    ThreadGroup group = LoggingThreadGroup.createThreadGroup(
+        LocalizedStrings.TransactionManagerImpl_CLEAN_UP_THREADS.toLocalizedString());
-        transactionManager = new TransactionManagerImpl();
+      transactionManager = new TransactionManagerImpl();
-   * Create a new transaction and associate it with the current thread if none
-   * exists with the current thread else throw an exception since nested
-   * transactions are not supported
+   * Create a new transaction and associate it with the current thread if none exists with the
+   * current thread else throw an exception since nested transactions are not supported
-   * Create a global transaction and associate the transaction created with the
-   * global transaction
+   * Create a global transaction and associate the transaction created with the global transaction
-   * @throws NotSupportedException - Thrown if the thread is already associated
-   *             with a transaction and the Transaction Manager implementation
-   *             does not support nested transactions.
-   * @throws SystemException - Thrown if the transaction manager encounters an
-   *             unexpected error condition.
+   * @throws NotSupportedException - Thrown if the thread is already associated with a transaction
+   *         and the Transaction Manager implementation does not support nested transactions.
+   * @throws SystemException - Thrown if the transaction manager encounters an unexpected error
+   *         condition.
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_BEGIN_NESTED_TRANSACTION_IS_NOT_SUPPORTED.toLocalizedString();
-      if (VERBOSE) log.fine(exception);
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_BEGIN_NESTED_TRANSACTION_IS_NOT_SUPPORTED
+              .toLocalizedString();
+      if (VERBOSE)
+        log.fine(exception);
-    }
-    catch (Exception e) {
-      String exception = LocalizedStrings.TransactionManagerImpl_BEGIN__SYSTEMEXCEPTION_DUE_TO_0.toLocalizedString(new Object[] {e});
-      if (log.severeEnabled()) log.severe(LocalizedStrings.TransactionManagerImpl_BEGIN__SYSTEMEXCEPTION_DUE_TO_0, new Object[] {e});
+    } catch (Exception e) {
+      String exception = LocalizedStrings.TransactionManagerImpl_BEGIN__SYSTEMEXCEPTION_DUE_TO_0
+          .toLocalizedString(new Object[] {e});
+      if (log.severeEnabled())
+        log.severe(LocalizedStrings.TransactionManagerImpl_BEGIN__SYSTEMEXCEPTION_DUE_TO_0,
+            new Object[] {e});
-   * GlobalTransaction.commit(). When this method completes, the thread is no
-   * longer associated with a transaction.
+   * GlobalTransaction.commit(). When this method completes, the thread is no longer associated with
+   * a transaction.
-   * @throws RollbackException - Thrown to indicate that the transaction has
-   *             been rolled back rather than committed.
-   * @throws HeuristicMixedException - Thrown to indicate that a heuristic
-   *             decision was made and that some relevant updates have been
-   *             committed while others have been rolled back.
-   * @throws HeuristicRollbackException - Thrown to indicate that a heuristic
-   *             decision was made and that all relevant updates have been
-   *             rolled back.
-   * @throws java.lang.SecurityException - Thrown to indicate that the thread
-   *             is not allowed to commit the transaction.
-   * @throws java.lang.IllegalStateException - Thrown if the current thread is
-   *             not associated with a transaction.
-   * @throws SystemException - Thrown if the transaction manager encounters an
-   *             unexpected error condition.
+   * @throws RollbackException - Thrown to indicate that the transaction has been rolled back rather
+   *         than committed.
+   * @throws HeuristicMixedException - Thrown to indicate that a heuristic decision was made and
+   *         that some relevant updates have been committed while others have been rolled back.
+   * @throws HeuristicRollbackException - Thrown to indicate that a heuristic decision was made and
+   *         that all relevant updates have been rolled back.
+   * @throws java.lang.SecurityException - Thrown to indicate that the thread is not allowed to
+   *         commit the transaction.
+   * @throws java.lang.IllegalStateException - Thrown if the current thread is not associated with a
+   *         transaction.
+   * @throws SystemException - Thrown if the transaction manager encounters an unexpected error
+   *         condition.
-    if (!isActive) { 
-      throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); 
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_IS_NULL_CANNOT_COMMIT_A_NULL_TRANSACTION.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_IS_NULL_CANNOT_COMMIT_A_NULL_TRANSACTION
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_GLOBAL_TRANSACTION_IS_NULL_CANNOT_COMMIT_A_NULL_GLOBAL_TRANSACTION.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_GLOBAL_TRANSACTION_IS_NULL_CANNOT_COMMIT_A_NULL_GLOBAL_TRANSACTION
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-    //ensure only one thread can commit. Use a synchronized block
-    //Asif
+    // ensure only one thread can commit. Use a synchronized block
+    // Asif
-        }
-        else if (status == Status.STATUS_MARKED_ROLLBACK) {
+        } else if (status == Status.STATUS_MARKED_ROLLBACK) {
-        }
-        else {
-          String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_NOT_ACTIVE_CANNOT_BE_COMMITTED_TRANSACTION_STATUS_0.toLocalizedString(Integer.valueOf(status));
+        } else {
+          String exception =
+              LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_NOT_ACTIVE_CANNOT_BE_COMMITTED_TRANSACTION_STATUS_0
+                  .toLocalizedString(Integer.valueOf(status));
-          if (VERBOSE) writer.fine(exception);
+          if (VERBOSE)
+            writer.fine(exception);
-    }
-    else {
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_IS_NOT_ACTIVE_AND_CANNOT_BE_COMMITTED.toLocalizedString();
+    } else {
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_IS_NOT_ACTIVE_AND_CANNOT_BE_COMMITTED
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-    //Only one thread can call commit (the first thread to do reach the block
+    // Only one thread can call commit (the first thread to do reach the block
-    //Before commiting the notifications to be done before the done are called
+    // Before commiting the notifications to be done before the done are called
-    //removed from the map and also the tread to transaction.
+    // removed from the map and also the tread to transaction.
-    //  Asif : Store the thrown Exception in case of commit .
-    //Reuse it for thrwing later.
-    //Asif TODO:Verify if it is a good practise
+    // Asif : Store the thrown Exception in case of commit .
+    // Reuse it for thrwing later.
+    // Asif TODO:Verify if it is a good practise
-    }
-    catch (Exception ge) {
-      //Asif : Just mark the Tranxn to setRollbackOnly to ensure Rollback
+    } catch (Exception ge) {
+      // Asif : Just mark the Tranxn to setRollbackOnly to ensure Rollback
-    //TODO:Asif In case the status of transaction is marked as
+    // TODO:Asif In case the status of transaction is marked as
-    //will be harmless
+    // will be harmless
-          //Asif: Catch any exception encountered during commit
+          // Asif: Catch any exception encountered during commit
-          }
-          catch (RollbackException rbe) {
+          } catch (RollbackException rbe) {
-          }
-          catch (SystemException se) {
+          } catch (SystemException se) {
-        }
-        else if (status == Status.STATUS_ROLLING_BACK) {
+        } else if (status == Status.STATUS_ROLLING_BACK) {
-            if (isClean) cozOfException = MARKED_ROLLBACK;
-          }
-          catch (SystemException se) {
+            if (isClean)
+              cozOfException = MARKED_ROLLBACK;
+          } catch (SystemException se) {
-    }
-    else {
+    } else {
-      }
-      catch (SystemException se) {
+      } catch (SystemException se) {
-      ((TransactionImpl) transactionImpl).notifyAfterCompletion(status = gtx
-          .getStatus());
-    }
-    catch (Exception ge) {
+      ((TransactionImpl) transactionImpl).notifyAfterCompletion(status = gtx.getStatus());
+    } catch (Exception ge) {
-          writer.info(LocalizedStrings.TransactionManagerImpl_EXCEPTION_IN_NOTIFY_AFTER_COMPLETION_DUE_TO__0, ge.getMessage(), ge);
+        writer.info(
+            LocalizedStrings.TransactionManagerImpl_EXCEPTION_IN_NOTIFY_AFTER_COMPLETION_DUE_TO__0,
+            ge.getMessage(), ge);
-          String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_ROLLED_BACK_BECAUSE_OF_EXCEPTION_IN_NOTIFYBEFORECOMPLETION_FUNCTION_CALL_ACTUAL_EXCEPTION_0.toLocalizedString();
+          String exception =
+              LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_ROLLED_BACK_BECAUSE_OF_EXCEPTION_IN_NOTIFYBEFORECOMPLETION_FUNCTION_CALL_ACTUAL_EXCEPTION_0
+                  .toLocalizedString();
-          if (VERBOSE) writer.fine(exception, e);
+          if (VERBOSE)
+            writer.fine(exception, e);
-          String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_ROLLED_BACK_BECAUSE_A_USER_MARKED_IT_FOR_ROLLBACK.toLocalizedString();
+          String exception =
+              LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_ROLLED_BACK_BECAUSE_A_USER_MARKED_IT_FOR_ROLLBACK
+                  .toLocalizedString();
-          if (VERBOSE) writer.fine(exception, e);
+          if (VERBOSE)
+            writer.fine(exception, e);
-          if (VERBOSE) writer.fine(e);
+          if (VERBOSE)
+            writer.fine(e);
-          if (VERBOSE) writer.fine(e);
+          if (VERBOSE)
+            writer.fine(e);
-   * Rolls back the transaction associated with the current thread by calling
-   * the GlobalTransaction.rollback(). When this method completes, the thread
-   * is no longer associated with a transaction.
+   * Rolls back the transaction associated with the current thread by calling the
+   * GlobalTransaction.rollback(). When this method completes, the thread is no longer associated
+   * with a transaction.
-   * @throws java.lang.SecurityException - Thrown to indicate that the thread
-   *             is not allowed to commit the transaction.
-   * @throws java.lang.IllegalStateException - Thrown if the current thread is
-   *             not associated with a transaction.
-   * @throws SystemException - Thrown if the transaction manager encounters an
-   *             unexpected error condition.
+   * @throws java.lang.SecurityException - Thrown to indicate that the thread is not allowed to
+   *         commit the transaction.
+   * @throws java.lang.IllegalStateException - Thrown if the current thread is not associated with a
+   *         transaction.
+   * @throws SystemException - Thrown if the transaction manager encounters an unexpected error
+   *         condition.
-  public void rollback() throws IllegalStateException, SecurityException,
-      SystemException {
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
-//    boolean isRollingBack = false;
+  public void rollback() throws IllegalStateException, SecurityException, SystemException {
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
+    // boolean isRollingBack = false;
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_NO_TRANSACTION_EXISTS.toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_NO_TRANSACTION_EXISTS
+              .toLocalizedString();
+      if (VERBOSE)
+        writer.fine(exception);
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_NO_GLOBAL_TRANSACTION_EXISTS.toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_NO_GLOBAL_TRANSACTION_EXISTS
+              .toLocalizedString();
+      if (VERBOSE)
+        writer.fine(exception);
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_STATUS_DOES_NOT_ALLOW_ROLLBACK_TRANSACTIONAL_STATUS_0.toLocalizedString(Integer.valueOf(status));
-      if (VERBOSE) writer.fine(exception);
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_STATUS_DOES_NOT_ALLOW_ROLLBACK_TRANSACTIONAL_STATUS_0
+              .toLocalizedString(Integer.valueOf(status));
+      if (VERBOSE)
+        writer.fine(exception);
-    //ensure only one thread proceeds from here
+    // ensure only one thread proceeds from here
-        String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_ALREADY_IN_A_ROLLING_BACK_STATE_TRANSACTIONAL_STATUS_0.toLocalizedString(Integer.valueOf(status));
-        if (VERBOSE) writer.fine(exception);
+        String exception =
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_ALREADY_IN_A_ROLLING_BACK_STATE_TRANSACTIONAL_STATUS_0
+                .toLocalizedString(Integer.valueOf(status));
+        if (VERBOSE)
+          writer.fine(exception);
-      }
-      else {
-        String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_STATUS_DOES_NOT_ALLOW_ROLLBACK.toLocalizedString();
-        if (VERBOSE) writer.fine(exception);
+      } else {
+        String exception =
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_STATUS_DOES_NOT_ALLOW_ROLLBACK
+                .toLocalizedString();
+        if (VERBOSE)
+          writer.fine(exception);
-    //Only one thread can call rollback (the first thread to do reach the
+    // Only one thread can call rollback (the first thread to do reach the
-    //Before rollback the notifications to be done before the done are called
+    // Before rollback the notifications to be done before the done are called
-    //removed from the map and also the tread to transaction.
+    // removed from the map and also the tread to transaction.
-    //TODO remove all threads-transactions (from the map)
-    //for transactions participating in the global transaction
+    // TODO remove all threads-transactions (from the map)
+    // for transactions participating in the global transaction
-    }
-    catch (SystemException se1) {
+    } catch (SystemException se1) {
-      ((TransactionImpl) transactionImpl)
-          .notifyAfterCompletion(gtx.getStatus());
-    }
-    catch (Exception e1) {
+      ((TransactionImpl) transactionImpl).notifyAfterCompletion(gtx.getStatus());
+    } catch (Exception e1) {
-          writer.info(LocalizedStrings.TransactionManagerImpl_EXCEPTION_IN_NOTIFY_AFTER_COMPLETION_DUE_TO__0, e1.getMessage(), e1);
+        writer.info(
+            LocalizedStrings.TransactionManagerImpl_EXCEPTION_IN_NOTIFY_AFTER_COMPLETION_DUE_TO__0,
+            e1.getMessage(), e1);
-      if (VERBOSE) writer.fine(se);
+      if (VERBOSE)
+        writer.fine(se);
-   * Set the Global Transaction status (Associated with the current thread) to
-   * be RollBackOnly
+   * Set the Global Transaction status (Associated with the current thread) to be RollBackOnly
-   * Becauce we are using one phase commit, we are not considering Prepared and
-   * preparing states.
+   * Becauce we are using one phase commit, we are not considering Prepared and preparing states.
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETROLLBACKONLY_NO_GLOBAL_TRANSACTION_EXISTS.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETROLLBACKONLY_NO_GLOBAL_TRANSACTION_EXISTS
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-        ; //Dont do anything
+        ; // Dont do anything
-        String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETROLLBACKONLY_TRANSACTION_CANNOT_BE_MARKED_FOR_ROLLBACK_TRANSCATION_STATUS_0.toLocalizedString(Integer.valueOf(status));
+        String exception =
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETROLLBACKONLY_TRANSACTION_CANNOT_BE_MARKED_FOR_ROLLBACK_TRANSCATION_STATUS_0
+                .toLocalizedString(Integer.valueOf(status));
-        if (VERBOSE) writer.fine(exception);
+        if (VERBOSE)
+          writer.fine(exception);
-    //Asif : Log after exiting synch block
+    // Asif : Log after exiting synch block
-    if (VERBOSE) writer.fine("Transaction Set to Rollback only");
+    if (VERBOSE)
+      writer.fine("Transaction Set to Rollback only");
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETTRANSACTIONTIMEOUT_NO_GLOBAL_TRANSACTION_EXISTS.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETTRANSACTIONTIMEOUT_NO_GLOBAL_TRANSACTION_EXISTS
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-    if(newExpiry > 0 ){
-    //long expirationTime = System.currentTimeMillis() + (seconds * 1000);
-    gtxSet.remove(gtx);
-    //  Asif :Lets blindly remove the current gtx from the TreeMap &
-    // Add only if status is neither Rolledback, Unknown , committed or no
-    // transaction or GTX not
-    // expired, which gurantees that the client thread will be returning &
-    // cleaning up .so we
-    //don't add it
-    int status = gtx.getStatus();
-    if (status != Status.STATUS_NO_TRANSACTION
-        && status != Status.STATUS_COMMITTED
-        && status != Status.STATUS_ROLLEDBACK && !gtx.isExpired()) {
-      //Asif : Take a lock on GTX while setting the new Transaction timeout
-      // value,
-      // so that cleaner thread sees the new value immediately else due to
-      // volatility issue
-      // we may have inconsistent values of time out
-      boolean toAdd = false;
-      synchronized (gtx) {
-        if (!gtx.isExpired()) {
-          gtx.setTimeoutValue(newExpiry);
-          toAdd = true;
-        }
-      }
-      //Asif : It is possible that in the window between we set the new
-      //timeout value in current GTX & add it to the gtxSet , the currentGtx
-      //is expired by the cleaner thread as there is no safeguard for it.
-      //We allow it to happen that is add the expired GTx to the TreeSet.
-      //Since a notify will be issued , the cleaner thread wil take care
-      // of it.
-      if (toAdd) {
-        synchronized (gtxSet) {
-          gtxSet.add(gtx);
-          if (gtxSet.first() == gtx) {
-            gtxSet.notify();
+    if (newExpiry > 0) {
+      // long expirationTime = System.currentTimeMillis() + (seconds * 1000);
+      gtxSet.remove(gtx);
+      // Asif :Lets blindly remove the current gtx from the TreeMap &
+      // Add only if status is neither Rolledback, Unknown , committed or no
+      // transaction or GTX not
+      // expired, which gurantees that the client thread will be returning &
+      // cleaning up .so we
+      // don't add it
+      int status = gtx.getStatus();
+      if (status != Status.STATUS_NO_TRANSACTION && status != Status.STATUS_COMMITTED
+          && status != Status.STATUS_ROLLEDBACK && !gtx.isExpired()) {
+        // Asif : Take a lock on GTX while setting the new Transaction timeout
+        // value,
+        // so that cleaner thread sees the new value immediately else due to
+        // volatility issue
+        // we may have inconsistent values of time out
+        boolean toAdd = false;
+        synchronized (gtx) {
+          if (!gtx.isExpired()) {
+            gtx.setTimeoutValue(newExpiry);
+            toAdd = true;
+        // Asif : It is possible that in the window between we set the new
+        // timeout value in current GTX & add it to the gtxSet , the currentGtx
+        // is expired by the cleaner thread as there is no safeguard for it.
+        // We allow it to happen that is add the expired GTx to the TreeSet.
+        // Since a notify will be issued , the cleaner thread wil take care
+        // of it.
+        if (toAdd) {
+          synchronized (gtxSet) {
+            gtxSet.add(gtx);
+            if (gtxSet.first() == gtx) {
+              gtxSet.notify();
+            }
+          }
+        }
+      } else {
+        String exception =
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETTRANSACTIONTIMEOUT_TRANSACTION_HAS_EITHER_EXPIRED_OR_ROLLEDBACK_OR_COMITTED
+                .toLocalizedString();
+        LogWriterI18n writer = TransactionUtils.getLogWriterI18n();
+        if (VERBOSE)
+          writer.fine(exception);
+        throw new SystemException(exception);
-    else {
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETTRANSACTIONTIMEOUT_TRANSACTION_HAS_EITHER_EXPIRED_OR_ROLLEDBACK_OR_COMITTED.toLocalizedString();
-      LogWriterI18n writer = TransactionUtils.getLogWriterI18n();
-      if (VERBOSE) writer.fine(exception);
-      throw new SystemException(exception);
-    }
-    }
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
-    
-    if(null != txn) {
+
+    if (null != txn) {
-          writer.info(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPLSUSPENDTRANSACTION_SUSPENDED);
+        writer.info(
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPLSUSPENDTRANSACTION_SUSPENDED);
-  public void resume(Transaction txn) throws InvalidTransactionException,
-      IllegalStateException, SystemException {
-    if (!isActive) { throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); }
+  public void resume(Transaction txn)
+      throws InvalidTransactionException, IllegalStateException, SystemException {
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
+    }
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_CANNOT_RESUME_A_NULL_TRANSACTION.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_CANNOT_RESUME_A_NULL_TRANSACTION
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_CANNOT_RESUME_A_NULL_TRANSACTION.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_CANNOT_RESUME_A_NULL_TRANSACTION
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-          writer.info(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPLRESUMETRANSACTION_RESUMED);
-    }
-    catch (Exception e) {
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_ERROR_IN_LISTING_THREAD_TO_TRANSACTION_MAP_DUE_TO_0.toLocalizedString(e);
+        writer.info(
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPLRESUMETRANSACTION_RESUMED);
+    } catch (Exception e) {
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_ERROR_IN_LISTING_THREAD_TO_TRANSACTION_MAP_DUE_TO_0
+              .toLocalizedString(e);
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-    if (!isActive) { 
-      throw new SystemException(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString()); 
+    if (!isActive) {
+      throw new SystemException(
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGER_INVALID.toLocalizedString());
-  GlobalTransaction getGlobalTransaction(Transaction txn)
-      throws SystemException {
+  GlobalTransaction getGlobalTransaction(Transaction txn) throws SystemException {
-      String exception = LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_GETGLOBALTRANSACTION_NO_TRANSACTION_EXISTS.toLocalizedString();
+      String exception =
+          LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPL_GETGLOBALTRANSACTION_NO_TRANSACTION_EXISTS
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-  //Asif : This method is used only for testing purposes
+  // Asif : This method is used only for testing purposes
-  //Asif : This method is used only for testing purposes
+  // Asif : This method is used only for testing purposes
-  //Asif : Remove the mapping of tranxn to Global Tranxn.
-  //Previously thsi task was being done in GlobalTranxn
+  // Asif : Remove the mapping of tranxn to Global Tranxn.
+  // Previously thsi task was being done in GlobalTranxn
-      while (toContinueRunning) { //Asif :Ensure that we do not get out of
+      while (toContinueRunning) { // Asif :Ensure that we do not get out of
-          //without a GTX object
+          // without a GTX object
-            if (!toContinueRunning) continue;
+            if (!toContinueRunning)
+              continue;
-          //Asif : Check whether current GTX has timed out or not
+          // Asif : Check whether current GTX has timed out or not
-                //Asif: Expire the GTX .Do not worry if some GTX comes
+                // Asif: Expire the GTX .Do not worry if some GTX comes
-                //TODO: Do the clean up from all Maps
+                // TODO: Do the clean up from all Maps
-              }
-              else {
+              } else {
-                //Asif: There will not be any need for synchronizing
-                //  on currentGTX as we are already taking lokc on gtxSet.
+                // Asif: There will not be any need for synchronizing
+                // on currentGTX as we are already taking lokc on gtxSet.
-                //if the thread is in this block . thus we are safe
+                // if the thread is in this block . thus we are safe
-                //synchronized (currentGtx) {
+                // synchronized (currentGtx) {
-                  //Asif : Make the thread wait for stipluated
+                  // Asif : Make the thread wait for stipluated
-                }
-                else {
+                } else {
-                  //Asif It is possibel that GTX is already expired but
+                  // Asif It is possibel that GTX is already expired but
-                  //Asif Clean the objects
+                  // Asif Clean the objects
-                  }
-                  else {
+                  } else {
-                //}
-                //Asif : It is OK if we release the lock on Current GTX
+                // }
+                // Asif : It is OK if we release the lock on Current GTX
-                //bcoz as we have still the the lock on gtxSet, even if
+                // bcoz as we have still the the lock on gtxSet, even if
-                //transaction set time out gets modified by other client
+                // transaction set time out gets modified by other client
-                //So in case of new tiemout value, if it is such that
+                // So in case of new tiemout value, if it is such that
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-          return; 
-        }
-        catch (CancelException e) {
-          // this thread is shutdown by doing an interrupt so this is expected
-          //logger.fine("TransactionTimeOutThread: encountered exception", e);
-        }
-        catch (Exception e) {
+        } catch (CancelException e) {
+          // this thread is shutdown by doing an interrupt so this is expected
+          // logger.fine("TransactionTimeOutThread: encountered exception", e);
+          return;
+        } catch (Exception e) {
-              LocalizedStrings.TransactionManagerImpl_TRANSACTIONTIMEOUTTHREAD__RUN_EXCEPTION_OCCURRED_WHILE_INSPECTING_GTX_FOR_EXPIRY, e);
+                LocalizedStrings.TransactionManagerImpl_TRANSACTIONTIMEOUTTHREAD__RUN_EXCEPTION_OCCURRED_WHILE_INSPECTING_GTX_FOR_EXPIRY,
+                e);
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-          writer
-              .info(LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPLCLEANUPEXCEPTION_WHILE_CLEANING_THREAD_BEFORE_RE_STATRUP);
+        writer.info(
+            LocalizedStrings.TransactionManagerImpl_TRANSACTIONMANAGERIMPLCLEANUPEXCEPTION_WHILE_CLEANING_THREAD_BEFORE_RE_STATRUP);
-/*    try {
-      transactionManager.cleanUpThread.join();
-    }
-    catch (Exception e) {
-      e.printStackTrace();
-    }*/
+    /*
+     * try { transactionManager.cleanUpThread.join(); } catch (Exception e) { e.printStackTrace(); }
+     */

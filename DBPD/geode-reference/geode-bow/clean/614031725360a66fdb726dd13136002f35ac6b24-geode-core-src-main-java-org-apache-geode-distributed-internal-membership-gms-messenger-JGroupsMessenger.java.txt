GEODE-2865 data loss in initial-image replication with multicast

The state-flush algorithm relies on MembershipManager.waitForMessageState()
to ensure that all operations have been received and applied to the cache
prior to state replication starting.  For multicast there was a flaw in
the algorithm caused by two things: 1) cache operations were being sent
out-of-band, allowing them to be processed out of order with the state-
flush message, and 2) JGroupsMessenger was only waiting for the messages
to be dispatched by NAKACK2, which isn't necessarily the same as being
dispatched to the DistributionManager Executor that processes the message.

Cache operation messages are now sent in-band.

JGroupsMessenger now tracks NAKACK2 (multicast) sequence numbers of
messages dispatched to the DistributionManager and this is used in
waitForMessageState() to make sure the messages have been queued.
If multicast is enabled we now flush the serial executor to in
waitForMessageState() to make sure that all messages queued in it have
been applied to the region.

-import static org.apache.geode.internal.DataSerializableFixedID.JOIN_REQUEST;
-import static org.apache.geode.internal.DataSerializableFixedID.JOIN_RESPONSE;
+import static org.apache.geode.internal.DataSerializableFixedID.JOIN_REQUEST;
+import static org.apache.geode.internal.DataSerializableFixedID.JOIN_RESPONSE;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import org.apache.geode.DataSerializer;
+import org.apache.geode.ForcedDisconnectException;
+import org.apache.geode.GemFireConfigException;
+import org.apache.geode.GemFireIOException;
+import org.apache.geode.SystemConnectException;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.distributed.DistributedSystemDisconnectedException;
+import org.apache.geode.distributed.DurableClientAttributes;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.distributed.internal.DistributionMessage;
+import org.apache.geode.distributed.internal.DistributionStats;
+import org.apache.geode.distributed.internal.HighPriorityDistributionMessage;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.distributed.internal.membership.MemberAttributes;
+import org.apache.geode.distributed.internal.membership.NetView;
+import org.apache.geode.distributed.internal.membership.QuorumChecker;
+import org.apache.geode.distributed.internal.membership.gms.GMSMember;
+import org.apache.geode.distributed.internal.membership.gms.Services;
+import org.apache.geode.distributed.internal.membership.gms.interfaces.MessageHandler;
+import org.apache.geode.distributed.internal.membership.gms.interfaces.Messenger;
+import org.apache.geode.distributed.internal.membership.gms.locator.FindCoordinatorRequest;
+import org.apache.geode.distributed.internal.membership.gms.locator.FindCoordinatorResponse;
+import org.apache.geode.distributed.internal.membership.gms.messages.JoinRequestMessage;
+import org.apache.geode.distributed.internal.membership.gms.messages.JoinResponseMessage;
+import org.apache.geode.internal.ClassPathLoader;
+import org.apache.geode.internal.HeapDataOutputStream;
+import org.apache.geode.internal.InternalDataSerializer;
+import org.apache.geode.internal.OSProcess;
+import org.apache.geode.internal.Version;
+import org.apache.geode.internal.VersionedDataInputStream;
+import org.apache.geode.internal.admin.remote.RemoteTransportConfig;
+import org.apache.geode.internal.cache.DirectReplyMessage;
+import org.apache.geode.internal.cache.DistributedCacheOperation;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.logging.log4j.AlertAppender;
+import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.tcp.MemberShunnedException;
+import org.apache.logging.log4j.Logger;
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.JChannel;
+import org.jgroups.Message;
+import org.jgroups.Message.Flag;
+import org.jgroups.Message.TransientFlag;
+import org.jgroups.ReceiverAdapter;
+import org.jgroups.View;
+import org.jgroups.ViewId;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.UDP;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.NakAckHeader2;
+import org.jgroups.stack.IpAddress;
+import org.jgroups.util.Digest;
+import org.jgroups.util.UUID;
-import org.apache.logging.log4j.Logger;
-import org.jgroups.Address;
-import org.jgroups.Event;
-import org.jgroups.JChannel;
-import org.jgroups.Message;
-import org.jgroups.Message.Flag;
-import org.jgroups.Message.TransientFlag;
-import org.jgroups.ReceiverAdapter;
-import org.jgroups.View;
-import org.jgroups.ViewId;
-import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.protocols.UDP;
-import org.jgroups.protocols.pbcast.NAKACK2;
-import org.jgroups.stack.IpAddress;
-import org.jgroups.util.Digest;
-import org.jgroups.util.UUID;
-
-import org.apache.geode.DataSerializer;
-import org.apache.geode.ForcedDisconnectException;
-import org.apache.geode.GemFireConfigException;
-import org.apache.geode.GemFireIOException;
-import org.apache.geode.SystemConnectException;
-import org.apache.geode.distributed.DistributedSystemDisconnectedException;
-import org.apache.geode.distributed.DurableClientAttributes;
-import org.apache.geode.distributed.internal.*;
-import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
-import org.apache.geode.distributed.internal.membership.MemberAttributes;
-import org.apache.geode.distributed.internal.membership.NetView;
-import org.apache.geode.distributed.internal.membership.QuorumChecker;
-import org.apache.geode.distributed.internal.membership.gms.GMSMember;
-import org.apache.geode.distributed.internal.membership.gms.Services;
-import org.apache.geode.distributed.internal.membership.gms.interfaces.MessageHandler;
-import org.apache.geode.distributed.internal.membership.gms.interfaces.Messenger;
-import org.apache.geode.distributed.internal.membership.gms.locator.FindCoordinatorRequest;
-import org.apache.geode.distributed.internal.membership.gms.locator.FindCoordinatorResponse;
-import org.apache.geode.distributed.internal.membership.gms.messages.JoinRequestMessage;
-import org.apache.geode.distributed.internal.membership.gms.messages.JoinResponseMessage;
-import org.apache.geode.internal.ClassPathLoader;
-import org.apache.geode.internal.HeapDataOutputStream;
-import org.apache.geode.internal.InternalDataSerializer;
-import org.apache.geode.internal.OSProcess;
-import org.apache.geode.internal.net.SocketCreator;
-import org.apache.geode.internal.Version;
-import org.apache.geode.internal.VersionedDataInputStream;
-import org.apache.geode.internal.admin.remote.RemoteTransportConfig;
-import org.apache.geode.internal.cache.DirectReplyMessage;
-import org.apache.geode.internal.cache.DistributedCacheOperation;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.AlertAppender;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-import org.apache.geode.internal.tcp.MemberShunnedException;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-
+  /** tracks multicast messages that have been scheduled for processing */
+  protected final Map<DistributedMember, MessageTracker> scheduledMcastSeqnos = new HashMap<>();
+
+  protected short nackack2HeaderId;
+
+    nackack2HeaderId = ClassConfigurator.getProtocolId(NAKACK2.class);
+
+    synchronized (scheduledMcastSeqnos) {
+      for (DistributedMember mbr : v.getCrashedMembers()) {
+        scheduledMcastSeqnos.remove(mbr);
+      }
+      for (DistributedMember mbr : v.getShutdownMembers()) {
+        scheduledMcastSeqnos.remove(mbr);
+      }
+    }
-    NAKACK2 nakack = (NAKACK2) myChannel.getProtocolStack().findProtocol("NAKACK2");
-    if (nakack != null && seqno != null) {
-      waitForMessageState(nakack, sender, seqno);
+    if (seqno == null) {
+      return;
-  }
-
-  /**
-   * wait for the mcast state from the given member to reach the given seqno
-   */
-  protected void waitForMessageState(NAKACK2 nakack, InternalDistributedMember sender, Long seqno)
-      throws InterruptedException {
-    JGAddress jgSender = new JGAddress(sender);
-
-      Digest digest = nakack.getDigest(jgSender);
-      if (digest == null) {
-        return;
-      }
-      long[] senderSeqnos = digest.get(jgSender);
-      if (senderSeqnos == null) {
-        break;
+      long highSeqno = 0;
+      synchronized (scheduledMcastSeqnos) {
+        MessageTracker tracker = scheduledMcastSeqnos.get(sender);
+        if (tracker == null) { // no longer in the membership view
+          break;
+        }
+        highSeqno = tracker.get();
+
-            sender, senderSeqnos[0], seqno);
+            sender, highSeqno, seqno);
-      if (senderSeqnos[0] >= seqno.longValue()) {
+      if (highSeqno >= seqno.longValue()) {
-        received = String.valueOf(senderSeqnos[0]);
+        received = String.valueOf(highSeqno);
-    // GemFire uses its own reply processors so there is no need
-    // to maintain message order
-    msg.setFlag(Flag.OOB);
+      msg.setFlag(Flag.OOB);
+
-          logger.trace("JGroupsMessenger dispatching {} from {}", msg, msg.getSender());
+
+          if (logger.isTraceEnabled()) {
+            logger.trace("JGroupsMessenger dispatching {} from {}", msg, msg.getSender());
+          }
+
+          // record the scheduling of broadcast messages
+          NakAckHeader2 header = (NakAckHeader2) jgmsg.getHeader(nackack2HeaderId);
+          if (header != null && !jgmsg.isFlagSet(Flag.OOB)) {
+            recordScheduledSeqno(msg.getSender(), header.getSeqno());
+          }
+
+
+    private void recordScheduledSeqno(DistributedMember member, long seqno) {
+      synchronized (scheduledMcastSeqnos) {
+        MessageTracker counter = scheduledMcastSeqnos.get(member);
+        if (counter == null) {
+          counter = new MessageTracker(seqno);
+          scheduledMcastSeqnos.put(member, counter);
+        }
+        counter.record(seqno);
+      }
+    }
+
+
+  static class MessageTracker {
+    long highestSeqno;
+
+    MessageTracker(long seqno) {
+      highestSeqno = seqno;
+    }
+
+    long get() {
+      return highestSeqno;
+    }
+
+    void record(long seqno) {
+      if (seqno > highestSeqno) {
+        highestSeqno = seqno;
+      }
+    }
+  }

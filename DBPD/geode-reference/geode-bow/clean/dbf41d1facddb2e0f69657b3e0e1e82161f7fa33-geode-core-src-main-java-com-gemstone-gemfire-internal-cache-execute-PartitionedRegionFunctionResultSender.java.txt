GEODE-1760 Sending partial results to users ResultCollector

For non-HA functions on the client, results will now be passed to the
users result collector, even if some nodes fail due to a bucket movement
or cache close.

Signed-off-by: Dan Smith <upthewaterspout@apache.org>

+  private BucketMovedException bme;
+  
+  private void checkForBucketMovement(Object oneResult){
+    if (!(forwardExceptions && oneResult instanceof Throwable) 
+        && !pr.getDataStore().areAllBucketsHosted(bucketSet)) {
+      // making sure that we send all the local results first
+      // before sending this exception to client
+      bme =  new BucketMovedException(
+          LocalizedStrings.FunctionService_BUCKET_MIGRATED_TO_ANOTHER_NODE
+              .toLocalizedString());
+      if(function.isHA()){
+        throw bme;
+      }
+    }
+    
+    
+  }
+  
+  // this must be getting called directly from function
-    if (!(forwardExceptions && oneResult instanceof Throwable) 
-        && !pr.getDataStore().areAllBucketsHosted(bucketSet)) {
-      throw new BucketMovedException(
-          LocalizedStrings.FunctionService_BUCKET_MIGRATED_TO_ANOTHER_NODE
-              .toLocalizedString());
-    }
+    // this could be done before doing end result
+    // so that client receives all the results before
+
-        lastClientSend(dm.getDistributionManagerId(), oneResult);
+        checkForBucketMovement(oneResult);
+        if (bme != null) {
+          clientSend(oneResult, dm.getDistributionManagerId());
+          lastClientSend(dm.getDistributionManagerId(), bme);
+        }else{
+          lastClientSend(dm.getDistributionManagerId(), oneResult);
+        }
+        
+        checkForBucketMovement(oneResult);
-          this.msg.sendReplyForOneResult(dm, pr, time, oneResult, true, enableOrderedResultStreming);
+          if(this.bme !=null){
+            this.msg.sendReplyForOneResult(dm, pr, time, oneResult, false, enableOrderedResultStreming);
+            throw bme;
+          }else{
+            this.msg.sendReplyForOneResult(dm, pr, time, oneResult, true, enableOrderedResultStreming);  
+          }
+          
-          this.rc.addResult(dm.getDistributionManagerId(), oneResult);
+          checkForBucketMovement(oneResult);
+          if (bme != null) {
+            this.rc.addResult(dm.getDistributionManagerId(), oneResult);
+            this.rc.addResult(dm.getDistributionManagerId(), bme);
+          }else{
+            this.rc.addResult(dm.getDistributionManagerId(), oneResult);
+          }
+          // exception thrown will do end result
-        lastClientSend(memberID, oneResult);
+        if(lastLocalResult){
+          checkForBucketMovement(oneResult);
+          if (bme != null) {
+            clientSend(oneResult, dm.getDistributionManagerId());
+            lastClientSend(dm.getDistributionManagerId(), bme);
+          }else{
+            lastClientSend(memberID, oneResult);
+          }
+        }else{
+          lastClientSend(memberID, oneResult);
+        }
+            
-        clientSend(oneResult, memberID);
+        if(lastLocalResult){
+          checkForBucketMovement(oneResult);
+          if (bme != null) {
+            clientSend(oneResult, memberID);
+            clientSend(bme,memberID);
+          }else{
+            clientSend(oneResult, memberID);
+          }
+        }else{
+          clientSend(oneResult, memberID);  
+        }
+        
-        collector.addResult(memberID, oneResult);
+        if(lastLocalResult){
+          checkForBucketMovement(oneResult);
+          if(bme!=null){
+            collector.addResult(memberID, oneResult);
+            collector.addResult(memberID, bme);
+          }else{
+            collector.addResult(memberID, oneResult);
+          }
+        }else{
+          collector.addResult(memberID, oneResult);
+        }
-        collector.addResult(memberID, oneResult);
+        if(lastLocalResult){
+          checkForBucketMovement(oneResult);
+          if(bme!=null){
+            collector.addResult(memberID, oneResult);
+            collector.addResult(memberID, bme);
+          }else{
+            collector.addResult(memberID, oneResult);
+          }
+        }
+        else{
+          collector.addResult(memberID, oneResult);
+        }
-  public void lastResult(Object oneResult, boolean completelyDone,
+  public synchronized void lastResult(Object oneResult, boolean completelyDoneFromRemote,
-      if (completelyDone) {
+      if (completelyDoneFromRemote) {
-      if (completelyDone) {
+      if (completelyDoneFromRemote) {

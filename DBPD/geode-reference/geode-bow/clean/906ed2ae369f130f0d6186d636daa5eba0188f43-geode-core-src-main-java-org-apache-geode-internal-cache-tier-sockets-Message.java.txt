GEODE-3948 Improve CQ performance under flaky network conditions

This adds a new PoolFactory setting allowing subscription connections to
time out and initiate failover to a backup server. The new setting is
setSubscriptionTimeoutMultiplier:

A server has an inactivity monitor that ensures a message is sent to a client at least once a
minute (60,000 milliseconds). If a subscription timeout multipler is set in the client it
enables timing out of the subscription feed with failover to another server.

A value of zero (the default) disables timeouts

A value of one will time out the server connection after one of its ping intervals (not
recommended)

A value of two or more will time out the server connection after that many ping intervals have
elapsed

The client/server handshake is modified for clients having version 1.5 or
later. The server sends its ping-interval setting to the client. The client
then uses this and the multiplier to establish a read-timeout in the
CacheClientUpdater subscription processor.

Two tests are added to ensure that 1) the Message method that allows a
read to timeout functions correctly and 2) the CacheClientUpdater
correctly receives the multiplier setting.

This closes #1364

+  private static final int NO_HEADER_READ_TIMEOUT = 0;
+
-  private void read() throws IOException {
+  private void readHeaderAndBody(int headerReadTimeoutMillis) throws IOException {
-    readHeaderAndPayload();
-  }
-  /**
-   * Read the actual bytes of the header off the socket
-   */
-  void fetchHeader() throws IOException {
-    final ByteBuffer cb = getCommBuffer();
-    cb.clear();
-
-    // messageType is invalidated here and can be used as an indicator
-    // of problems reading the message
-    this.messageType = MessageType.INVALID;
-
-    final int headerLength = getHeaderLength();
-    if (this.socketChannel != null) {
-      cb.limit(headerLength);
-      do {
-        int bytesRead = this.socketChannel.read(cb);
-        if (bytesRead == -1) {
-          throw new EOFException(
-              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
-                  .toLocalizedString());
-        }
-        if (this.messageStats != null) {
-          this.messageStats.incReceivedBytes(bytesRead);
-        }
-      } while (cb.remaining() > 0);
-      cb.flip();
-
-    } else {
-      int hdr = 0;
-      do {
-        int bytesRead = this.inputStream.read(cb.array(), hdr, headerLength - hdr);
-        if (bytesRead == -1) {
-          throw new EOFException(
-              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
-                  .toLocalizedString());
-        }
-        hdr += bytesRead;
-        if (this.messageStats != null) {
-          this.messageStats.incReceivedBytes(bytesRead);
-        }
-      } while (hdr < headerLength);
-
-      // now setup the commBuffer for the caller to parse it
-      cb.rewind();
+    int timeout = socket.getSoTimeout();
+    try {
+      socket.setSoTimeout(headerReadTimeoutMillis);
+      fetchHeader();
+    } finally {
+      socket.setSoTimeout(timeout);
-  }
-  private void readHeaderAndPayload() throws IOException {
-    fetchHeader();
+   * Read the actual bytes of the header off the socket
+   */
+  void fetchHeader() throws IOException {
+    final ByteBuffer cb = getCommBuffer();
+    cb.clear();
+
+    // messageType is invalidated here and can be used as an indicator
+    // of problems reading the message
+    this.messageType = MessageType.INVALID;
+
+    final int headerLength = getHeaderLength();
+    if (this.socketChannel != null) {
+      cb.limit(headerLength);
+      do {
+        int bytesRead = this.socketChannel.read(cb);
+        if (bytesRead == -1) {
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
+                  .toLocalizedString());
+        }
+        if (this.messageStats != null) {
+          this.messageStats.incReceivedBytes(bytesRead);
+        }
+      } while (cb.remaining() > 0);
+      cb.flip();
+
+    } else {
+      int hdr = 0;
+      do {
+        int bytesRead = this.inputStream.read(cb.array(), hdr, headerLength - hdr);
+        if (bytesRead == -1) {
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
+                  .toLocalizedString());
+        }
+        hdr += bytesRead;
+        if (this.messageStats != null) {
+          this.messageStats.incReceivedBytes(bytesRead);
+        }
+      } while (hdr < headerLength);
+
+      // now setup the commBuffer for the caller to parse it
+      cb.rewind();
+    }
+  }
+
+  /**
+  // Set up a message on the server side.
+  // Set up a message on the client side.
+  // Set up a message on the client side.
-   * Populates the stats of this {@code Message} with information received via its socket
+   * Read a message, populating the state of this {@code Message} with information received via its
+   * socket
+   *
+   * @param timeoutMillis timeout setting for reading the header (0 = no timeout)
+   * @throws IOException
-  public void recv() throws IOException {
+  public void receiveWithHeaderReadTimeout(int timeoutMillis) throws IOException {
-        read();
+        readHeaderAndBody(timeoutMillis);
-  public void recv(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter,
+  /**
+   * Populates the state of this {@code Message} with information received via its socket
+   */
+  public void receive() throws IOException {
+    receiveWithHeaderReadTimeout(NO_HEADER_READ_TIMEOUT);
+  }
+
+  public void receive(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter,
-    recv();
+    receive();

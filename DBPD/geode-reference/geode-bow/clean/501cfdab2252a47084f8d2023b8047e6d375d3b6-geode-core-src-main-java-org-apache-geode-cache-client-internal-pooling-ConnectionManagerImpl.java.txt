GEODE-4147: Add variability to client rebalance logic.

-import java.util.*;
-import java.util.concurrent.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.SplittableRandom;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
-import org.apache.geode.cache.client.*;
-import org.apache.geode.cache.client.internal.*;
+import org.apache.geode.cache.client.AllConnectionsInUseException;
+import org.apache.geode.cache.client.NoAvailableServersException;
+import org.apache.geode.cache.client.ServerConnectivityException;
+import org.apache.geode.cache.client.ServerOperationException;
+import org.apache.geode.cache.client.ServerRefusedConnectionException;
+import org.apache.geode.cache.client.internal.Connection;
+import org.apache.geode.cache.client.internal.ConnectionFactory;
+import org.apache.geode.cache.client.internal.Endpoint;
+import org.apache.geode.cache.client.internal.EndpointManager;
+import org.apache.geode.cache.client.internal.PoolImpl;
+import org.apache.geode.cache.client.internal.QueueConnectionImpl;
+   * Adds an arbitrary variance to a positive temporal interval. Where possible, 10% of the interval
+   * is added or subtracted from the interval. Otherwise, 1 is added or subtracted from the
+   * interval. For all positive intervals, the returned value will <bold>not</bold> equal the
+   * supplied interval.
+   *
+   * @param interval Positive temporal interval.
+   * @return Adjusted interval including the variance for positive intervals; the unmodified
+   *         interval for non-positive intervals.
+   */
+  static int addVarianceToInterval(int interval) {
+    if (1 <= interval) {
+      final SplittableRandom random = new SplittableRandom();
+      final int variance = (interval < 10) ? 1 : (1 + random.nextInt((interval / 10) - 1));
+      final int sign = random.nextBoolean() ? 1 : -1;
+      return interval + (sign * variance);
+    }
+    return interval;
+  }
+
+  /**
-    this.lifetimeTimeout = lifetimeTimeout;
-    this.lifetimeTimeoutNanos = lifetimeTimeout * NANOS_PER_MS;
-    if (lifetimeTimeout != -1) {
-      if (idleTimeout > lifetimeTimeout || idleTimeout == -1) {
+    this.lifetimeTimeout = addVarianceToInterval(lifetimeTimeout);
+    this.lifetimeTimeoutNanos = this.lifetimeTimeout * NANOS_PER_MS;
+    if (this.lifetimeTimeout != -1) {
+      if (idleTimeout > this.lifetimeTimeout || idleTimeout == -1) {
-        idleTimeout = lifetimeTimeout;
+        idleTimeout = this.lifetimeTimeout;

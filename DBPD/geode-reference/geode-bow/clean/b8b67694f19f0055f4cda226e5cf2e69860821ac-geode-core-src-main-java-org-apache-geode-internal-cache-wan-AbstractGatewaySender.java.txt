Merge branch 'develop' into feature/GEODE-7049

+import static org.apache.geode.internal.statistics.StatisticsClockFactory.disabledClock;
+
+import org.apache.geode.internal.statistics.StatisticsClock;
+  protected boolean startEventProcessorInPausedState = false;
+
-  protected AbstractGatewaySender() {}
+  private final StatisticsClock statisticsClock;
-  public AbstractGatewaySender(InternalCache cache, GatewaySenderAttributes attrs) {
+  protected AbstractGatewaySender() {
+    statisticsClock = disabledClock();
+  }
+
+  public AbstractGatewaySender(InternalCache cache, StatisticsClock statisticsClock,
+      GatewaySenderAttributes attrs) {
+    this.statisticsClock = statisticsClock;
-        this.statistics = new GatewaySenderStats(cache.getDistributedSystem(), id);
+        this.statistics = new GatewaySenderStats(cache.getDistributedSystem(),
+            "gatewaySenderStats-", id, statisticsClock);
+  @Override
+  public StatisticsClock getStatisticsClock() {
+    return statisticsClock;
+  }
+
+  public boolean isStartEventProcessorInPausedState() {
+    return startEventProcessorInPausedState;
+  }
+
+  public void setStartEventProcessorInPausedState() {
+    startEventProcessorInPausedState = true;
+  }
+
+  /**
+   * This pause will set the pause flag even if the
+   * processor has not yet started.
+   */
+  public void pauseEvenIfProcessorStopped() {
+    if (this.eventProcessor != null) {
+      this.getLifeCycleLock().writeLock().lock();
+      try {
+        this.eventProcessor.pauseDispatching();
+        InternalDistributedSystem system =
+            (InternalDistributedSystem) this.cache.getDistributedSystem();
+        system.handleResourceEvent(ResourceEvent.GATEWAYSENDER_PAUSE, this);
+        logger.info("Paused {}", this);
+
+        enqueueTempEvents();
+      } finally {
+        this.getLifeCycleLock().writeLock().unlock();
+      }
+    }
+  }
+
-              "RegionStats-" + META_DATA_REGION_NAME);
+              "RegionStats-" + META_DATA_REGION_NAME, sender.statisticsClock);

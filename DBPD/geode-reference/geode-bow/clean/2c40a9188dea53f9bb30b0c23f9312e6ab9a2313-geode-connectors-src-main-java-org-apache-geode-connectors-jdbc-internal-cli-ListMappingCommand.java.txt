GEODE-6365: Add server group support for list and destroy jdbc-mapping (#3175)

Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>
Co-authored-by: Ben Ross <bross@pivotal.io>
Co-authored-by: Jianxia Chen <jchen@pivotal.io>




-import java.util.Collection;
-import java.util.Set;
+import java.util.ArrayList;
+import org.springframework.shell.core.annotation.CliOption;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.RegionConfig;
-import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.connectors.util.internal.MappingCommandUtils;
+import org.apache.geode.distributed.ConfigurationPersistenceService;
+import org.apache.geode.management.cli.ConverterHint;
-import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
+  private static final String LIST_MAPPING__GROUPS_NAME__HELP =
+      "Server Group(s) of the JDBC mappings to list.";
+
-  public ResultModel listMapping() {
-    Collection<RegionMapping> mappings = null;
+  public ResultModel listMapping(@CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
+      optionContext = ConverterHint.MEMBERGROUP,
+      help = LIST_MAPPING__GROUPS_NAME__HELP) String[] groups) {
+    ArrayList<RegionMapping> mappings = new ArrayList<>();
-    Set<DistributedMember> members = findMembers(null, null);
-    if (members.size() > 0) {
-      DistributedMember targetMember = members.iterator().next();
-      CliFunctionResult result =
-          executeFunctionAndGetFunctionResult(new ListMappingFunction(), null, targetMember);
-      if (result != null) {
-        mappings = (Collection<RegionMapping>) result.getResultObject();
+    try {
+      ConfigurationPersistenceService configService = checkForClusterConfiguration();
+      if (groups == null) {
+        groups = new String[] {ConfigurationPersistenceService.CLUSTER_CONFIG};
-    } else {
-      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+      for (String group : groups) {
+        CacheConfig cacheConfig = getCacheConfig(configService, group);
+        for (RegionConfig regionConfig : cacheConfig.getRegions()) {
+          mappings.addAll(
+              MappingCommandUtils.getMappingsFromRegionConfig(cacheConfig, regionConfig, group));
+        }
+      }
+    } catch (PreconditionException ex) {
+      return ResultModel.createError(ex.getMessage());
-  private boolean fillTabularResultData(Collection<RegionMapping> mappings,
+  private boolean fillTabularResultData(ArrayList<RegionMapping> mappings,
+  private CacheConfig getCacheConfig(ConfigurationPersistenceService configService, String group)
+      throws PreconditionException {
+    CacheConfig result = configService.getCacheConfig(group);
+    if (result == null) {
+      throw new PreconditionException(
+          "Cache Configuration not found"
+              + ((group.equals(ConfigurationPersistenceService.CLUSTER_CONFIG)) ? "."
+                  : " for group " + group + "."));
+    }
+    return result;
+  }
+
+  private ConfigurationPersistenceService checkForClusterConfiguration()
+      throws PreconditionException {
+    ConfigurationPersistenceService result = getConfigurationPersistenceService();
+    if (result == null) {
+      throw new PreconditionException("Cluster Configuration must be enabled.");
+    }
+    return result;
+  }
+

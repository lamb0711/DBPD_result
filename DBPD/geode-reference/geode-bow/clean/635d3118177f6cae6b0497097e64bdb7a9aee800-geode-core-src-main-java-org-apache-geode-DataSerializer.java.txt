Merge branch 'develop' of https://git-wip-us.apache.org/repos/asf/geode into develop

* 'develop' of https://git-wip-us.apache.org/repos/asf/geode: (57 commits)
  GEODE-2551 Fix code issues found by AppChecker
  Revert "GEODE-1887: Now Size api goes through ServerProxy when cache is of type client and DataPolicy is Empty."
  GEODE-2538: Don't deserialize values on the server when getting results
  GEODE-2461: remove json4s-ast_2.10 as explicit dependency
  GEODE-2547: Interest registration no longer causes a CacheLoader to be invoked
  GEODE-2526: Enhance log statement to include ResourceTypeName
  GEODE-880 Remove unused classes
  GEODE-2460: update dependency versions
  GEODE-1995: Removed ReliableMessageQueue, ReliableMessageQueueFactory, ReliableMessageQueueFactoryImpl and it's usage in the code from GemfireCacheImpl and DistributedRegion.
  GEODE-2550 Improve README and BUILDING
  GEODE-2538: Don't invoke a cache loader when fetching values for a lucene query
  GEODE-2404: Added support for destroying lucene indexes
  GEODE-2545: NPE during lucene query execution when cache is closing or region is destroyed
  GEODE-2515: Disabling BaseLineAndCompareQueryPerfJUnitTest
  GEODE-2142: Removing JSON licence stuff from NOTICE files
  GEODE-2142: removing tests so run precheckin
  GEODE-2142: final compiling build
  GEODE-2142: cyclical dependency in gradle build
  GEODE-2142: spotless
  GEODE-2142: Refactoring of tests to work with new JSONObject class. Changing file export to use Base64 encoding.
  ...

+import java.util.LinkedHashMap;
+
+  /**
+   * Writes a <code>LinkedHashMap</code> to a <code>DataOutput</code>. Note that even though
+   * <code>map</code> may be an instance of a subclass of <code>LinkedHashMap</code>,
+   * <code>readLinkedHashMap</code> will always return an instance of <code>LinkedHashMap</code>,
+   * <B>not</B> an instance of the subclass. To preserve the class type of <code>map</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization. This method
+   * will serialize a <code>null</code> map and not throw a <code>NullPointerException</code>.
+   *
+   * @throws IOException A problem occurs while writing to <code>out</code>
+   * @see #readLinkedHashMap
+   */
+  public static void writeLinkedHashMap(Map<?, ?> map, DataOutput out) throws IOException {
+
+    InternalDataSerializer.checkOut(out);
+
+    int size;
+    if (map == null) {
+      size = -1;
+    } else {
+      size = map.size();
+    }
+    InternalDataSerializer.writeArrayLength(size, out);
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+      logger.trace(LogMarker.SERIALIZER, "Writing LinkedHashMap with {} elements: {}", size, map);
+    }
+    if (size > 0) {
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        writeObject(entry.getKey(), out);
+        writeObject(entry.getValue(), out);
+      }
+    }
+  }
+
+  /**
+   * Reads a <code>LinkedHashMap</code> from a <code>DataInput</code>.
+   *
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>HashMap</code>'s elements cannot
+   *         be found.
+   * @see #writeLinkedHashMap
+   */
+  public static <K, V> LinkedHashMap<K, V> readLinkedHashMap(DataInput in)
+      throws IOException, ClassNotFoundException {
+
+    InternalDataSerializer.checkIn(in);
+
+    int size = InternalDataSerializer.readArrayLength(in);
+    if (size == -1) {
+      return null;
+    } else {
+      LinkedHashMap<K, V> map = new LinkedHashMap<>(size);
+      for (int i = 0; i < size; i++) {
+        K key = DataSerializer.<K>readObject(in);
+        V value = DataSerializer.<V>readObject(in);
+        map.put(key, value);
+      }
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read LinkedHashMap with {} elements: {}", size, map);
+      }
+
+      return map;
+    }
+  }
+
+
+

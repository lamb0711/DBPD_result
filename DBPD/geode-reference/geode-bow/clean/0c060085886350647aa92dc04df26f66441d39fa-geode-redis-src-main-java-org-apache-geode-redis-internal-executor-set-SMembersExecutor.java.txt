GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4781)

* Revert "Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)"

This reverts commit f0982cdedf1b122f734919d0647434cca33ec254.

* Fix sporadic test failures for concurrent HSetNX
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.redis.internal.CoderException;
+import org.apache.geode.redis.internal.RedisConstants;
-    if (commandElems.size() < 2) {
+    if (commandElems.size() != 2) {
-    @SuppressWarnings("unchecked")
-    Region<ByteArrayWrapper, Boolean> keyRegion =
-        (Region<ByteArrayWrapper, Boolean>) context.getRegionProvider().getRegion(key);
-    if (keyRegion == null) {
-      command.setResponse(Coder.getEmptyArrayResponse(context.getByteBufAllocator()));
+    Set<ByteArrayWrapper> members;
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      Region<ByteArrayWrapper, Set<ByteArrayWrapper>> region = getRegion(context);
+
+      // companies:ea64fe8c-e0a0-4439-a05d-d0738dd5ef80:idx
+      Set<ByteArrayWrapper> set = region.get(key);
+
+      if (set == null) {
+        command.setResponse(Coder.getEmptyArrayResponse(context.getByteBufAllocator()));
+        return;
+      }
+
+      members = new HashSet<>(set); // Emulate copy on read
+
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      command.setResponse(
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
-    Set<ByteArrayWrapper> members = new HashSet(keyRegion.keySet()); // Emulate copy on read
-    respondBulkStrings(command, context, members);
+    try {
+      command.setResponse(Coder.getArrayResponse(context.getByteBufAllocator(), members));
+    } catch (CoderException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          RedisConstants.SERVER_ERROR_MESSAGE));
+    }

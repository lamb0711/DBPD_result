Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Manages the client side of client to server connections
- * and client queues. 
+ * Manages the client side of client to server connections and client queues.
-  public static final String ON_DISCONNECT_CLEAR_PDXTYPEIDS = DistributionConfig.GEMFIRE_PREFIX + "ON_DISCONNECT_CLEAR_PDXTYPEIDS";
+  public static final String ON_DISCONNECT_CLEAR_PDXTYPEIDS =
+      DistributionConfig.GEMFIRE_PREFIX + "ON_DISCONNECT_CLEAR_PDXTYPEIDS";
-  public static final int HANDSHAKE_TIMEOUT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.HANDSHAKE_TIMEOUT", AcceptorImpl.DEFAULT_HANDSHAKE_TIMEOUT_MS).intValue();
-  public static final long SHUTDOWN_TIMEOUT = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.SHUTDOWN_TIMEOUT", 30000).longValue();
-  public static final int BACKGROUND_TASK_POOL_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_SIZE", 20)
+  public static final int HANDSHAKE_TIMEOUT =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.HANDSHAKE_TIMEOUT",
+          AcceptorImpl.DEFAULT_HANDSHAKE_TIMEOUT_MS).intValue();
+  public static final long SHUTDOWN_TIMEOUT = Long
+      .getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.SHUTDOWN_TIMEOUT", 30000).longValue();
+  public static final int BACKGROUND_TASK_POOL_SIZE = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_SIZE", 20)
-  public static final int BACKGROUND_TASK_POOL_KEEP_ALIVE = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_KEEP_ALIVE", 1000).intValue();
-  //For durable client tests only. Connection Sources read this flag
-  //and return an empty list of servers.
+  public static final int BACKGROUND_TASK_POOL_KEEP_ALIVE =
+      Integer
+          .getInteger(
+              DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_KEEP_ALIVE", 1000)
+          .intValue();
+  // For durable client tests only. Connection Sources read this flag
+  // and return an empty list of servers.
-  private ScheduledExecutorService backgroundProcessor; 
+  private ScheduledExecutorService backgroundProcessor;
-  private final InternalDistributedSystem dsys; 
+  private final InternalDistributedSystem dsys;
-  
+
-  
-  private boolean keepAlive=false;
-  private static Object simpleLock=new Object();
+
+  private boolean keepAlive = false;
+  private static Object simpleLock = new Object();
-  
+
-    } catch(RuntimeException e) {
+    } catch (RuntimeException e) {
-      } catch(RuntimeException e2) {
-        //do nothing
+      } catch (RuntimeException e2) {
+        // do nothing
-  	this.pm = pm;
+    this.pm = pm;
-    this.startDisabled = ((PoolFactoryImpl.PoolAttributes)attributes).startDisabled
-      || !pm.isNormal();
-    this.usedByGateway = ((PoolFactoryImpl.PoolAttributes)attributes).isGateway();
-    this.gatewaySender = ((PoolFactoryImpl.PoolAttributes)attributes).getGatewaySender();
-//    if (this.subscriptionEnabled && this.multiuserSecureModeEnabled) {
-//      throw new IllegalStateException(
-//          "subscription-enabled and multiuser-authentication both cannot be true.");
-//    }
+    this.startDisabled =
+        ((PoolFactoryImpl.PoolAttributes) attributes).startDisabled || !pm.isNormal();
+    this.usedByGateway = ((PoolFactoryImpl.PoolAttributes) attributes).isGateway();
+    this.gatewaySender = ((PoolFactoryImpl.PoolAttributes) attributes).getGatewaySender();
+    // if (this.subscriptionEnabled && this.multiuserSecureModeEnabled) {
+    // throw new IllegalStateException(
+    // "subscription-enabled and multiuser-authentication both cannot be true.");
+    // }
-    if(ds==null) {
-      throw new IllegalStateException(LocalizedStrings.PoolImpl_DISTRIBUTED_SYSTEM_MUST_BE_CREATED_BEFORE_CREATING_POOL.toLocalizedString());
+    if (ds == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.PoolImpl_DISTRIBUTED_SYSTEM_MUST_BE_CREATED_BEFORE_CREATING_POOL
+              .toLocalizedString());
-    if (!ds.getConfig().getStatisticSamplingEnabled()
-        && this.statisticInterval > 0) {
+    if (!ds.getConfig().getStatisticSamplingEnabled() && this.statisticInterval > 0) {
-              LocalizedStrings.PoolImpl_STATISTIC_SAMPLING_MUST_BE_ENABLED_FOR_SAMPLING_RATE_OF_0_TO_TAKE_AFFECT,
-              this.statisticInterval));
+          LocalizedStrings.PoolImpl_STATISTIC_SAMPLING_MUST_BE_ENABLED_FOR_SAMPLING_RATE_OF_0_TO_TAKE_AFFECT,
+          this.statisticInterval));
-	    ClientProxyMembershipID.setPoolName(null);
+      ClientProxyMembershipID.setPoolName(null);
-    	this.proxyId = ClientProxyMembershipID.getNewProxyMembership(ds);
+      this.proxyId = ClientProxyMembershipID.getNewProxyMembership(ds);
-    if(this.gatewaySender != null){
+    if (this.gatewaySender != null) {
-    }else{
+    } else {
-    this.stats = this.startDisabled
-      ? null
-      : new PoolStats(statFactory, getName()+"->"+(serverGroup==null || serverGroup.equals("") ? "[any servers]" : "["+getServerGroup()+"]"));
-    
-    source = getSourceImpl(((PoolFactoryImpl.PoolAttributes)attributes).locatorCallback);
-    endpointManager = new EndpointManagerImpl(name, ds,this.cancelCriterion, this.stats);
-    connectionFactory = new ConnectionFactoryImpl(source, endpointManager, ds,
-        socketBufferSize, HANDSHAKE_TIMEOUT, readTimeout, proxyId, this.cancelCriterion,
-        usedByGateway,gatewaySender, pingInterval, multiuserSecureModeEnabled, this);
-    if(subscriptionEnabled) {
-      queueManager = new QueueManagerImpl(this, endpointManager, source,
-          connectionFactory, subscriptionRedundancyLevel, pingInterval, securityLogWriter,
-          proxyId);
+    this.stats = this.startDisabled ? null
+        : new PoolStats(statFactory,
+            getName() + "->" + (serverGroup == null || serverGroup.equals("") ? "[any servers]"
+                : "[" + getServerGroup() + "]"));
+
+    source = getSourceImpl(((PoolFactoryImpl.PoolAttributes) attributes).locatorCallback);
+    endpointManager = new EndpointManagerImpl(name, ds, this.cancelCriterion, this.stats);
+    connectionFactory = new ConnectionFactoryImpl(source, endpointManager, ds, socketBufferSize,
+        HANDSHAKE_TIMEOUT, readTimeout, proxyId, this.cancelCriterion, usedByGateway, gatewaySender,
+        pingInterval, multiuserSecureModeEnabled, this);
+    if (subscriptionEnabled) {
+      queueManager = new QueueManagerImpl(this, endpointManager, source, connectionFactory,
+          subscriptionRedundancyLevel, pingInterval, securityLogWriter, proxyId);
-    
-    manager = new ConnectionManagerImpl(name, connectionFactory, endpointManager,
-                                        maxConnections, minConnections,
-                                        idleTimeout, loadConditioningInterval,
-                                        securityLogWriter, pingInterval,
-                                        cancelCriterion, getStats());
-    //Fix for 43468 - make sure we check the cache cancel criterion if we get 
-    //an exception, by passing in the poolOrCache stopper
-    executor = new OpExecutorImpl(manager, queueManager, endpointManager,
-        riTracker, retryAttempts, freeConnectionTimeout, threadLocalConnections,
-        new PoolOrCacheStopper(), this);
+
+    manager = new ConnectionManagerImpl(name, connectionFactory, endpointManager, maxConnections,
+        minConnections, idleTimeout, loadConditioningInterval, securityLogWriter, pingInterval,
+        cancelCriterion, getStats());
+    // Fix for 43468 - make sure we check the cache cancel criterion if we get
+    // an exception, by passing in the poolOrCache stopper
+    executor = new OpExecutorImpl(manager, queueManager, endpointManager, riTracker, retryAttempts,
+        freeConnectionTimeout, threadLocalConnections, new PoolOrCacheStopper(), this);
-   * Return true if the given Pool is compatible with these attributes.
-   * Currently this does what equals would but in the future we might
-   * decide to weaken the compatibility contract.
+   * Return true if the given Pool is compatible with these attributes. Currently this does what
+   * equals would but in the future we might decide to weaken the compatibility contract.
+   * 
-    if (p == null) return false;
-    return getFreeConnectionTimeout() ==            p.getFreeConnectionTimeout()
-      && getLoadConditioningInterval() ==           p.getLoadConditioningInterval()
-      && getSocketBufferSize() ==                   p.getSocketBufferSize()
-      && getMinConnections() ==                     p.getMinConnections()
-      && getMaxConnections() ==                     p.getMaxConnections()
-      && getIdleTimeout() ==                        p.getIdleTimeout()
-      && getPingInterval() ==                       p.getPingInterval()
-      && getStatisticInterval() ==                  p.getStatisticInterval()
-      && getRetryAttempts() ==                      p.getRetryAttempts()
-      && getThreadLocalConnections() ==             p.getThreadLocalConnections()
-      && getReadTimeout() ==                        p.getReadTimeout()
-      && getSubscriptionEnabled() ==                p.getSubscriptionEnabled()
-      && getPRSingleHopEnabled() ==                 p.getPRSingleHopEnabled()
-      && getSubscriptionRedundancy() ==             p.getSubscriptionRedundancy()
-      && getSubscriptionMessageTrackingTimeout() == p.getSubscriptionMessageTrackingTimeout()
-      && getSubscriptionAckInterval() ==            p.getSubscriptionAckInterval()
-      && getServerGroup().equals(                   p.getServerGroup())
-      && getMultiuserAuthentication() ==         p.getMultiuserAuthentication()
-      && getLocators().equals(                      p.getLocators())
-      && getServers().equals(                       p.getServers());
+    if (p == null)
+      return false;
+    return getFreeConnectionTimeout() == p.getFreeConnectionTimeout()
+        && getLoadConditioningInterval() == p.getLoadConditioningInterval()
+        && getSocketBufferSize() == p.getSocketBufferSize()
+        && getMinConnections() == p.getMinConnections()
+        && getMaxConnections() == p.getMaxConnections() && getIdleTimeout() == p.getIdleTimeout()
+        && getPingInterval() == p.getPingInterval()
+        && getStatisticInterval() == p.getStatisticInterval()
+        && getRetryAttempts() == p.getRetryAttempts()
+        && getThreadLocalConnections() == p.getThreadLocalConnections()
+        && getReadTimeout() == p.getReadTimeout()
+        && getSubscriptionEnabled() == p.getSubscriptionEnabled()
+        && getPRSingleHopEnabled() == p.getPRSingleHopEnabled()
+        && getSubscriptionRedundancy() == p.getSubscriptionRedundancy()
+        && getSubscriptionMessageTrackingTimeout() == p.getSubscriptionMessageTrackingTimeout()
+        && getSubscriptionAckInterval() == p.getSubscriptionAckInterval()
+        && getServerGroup().equals(p.getServerGroup())
+        && getMultiuserAuthentication() == p.getMultiuserAuthentication()
+        && getLocators().equals(p.getLocators()) && getServers().equals(p.getServers());
-  
+
-    if (this.startDisabled) return;
-    
+    if (this.startDisabled)
+      return;
+
-    if(isDebugEnabled) {
+    if (isDebugEnabled) {
-      if(!locators.isEmpty()) {
+      if (!locators.isEmpty()) {
-    
+
-    backgroundProcessor = new ScheduledThreadPoolExecutorWithKeepAlive(
-        BACKGROUND_TASK_POOL_SIZE, BACKGROUND_TASK_POOL_KEEP_ALIVE,
-        TimeUnit.MILLISECONDS, new ThreadFactory() {
-      AtomicInteger threadNum = new AtomicInteger();
-      public Thread newThread(final Runnable r) {
-        Thread result = new Thread(r, timerName + threadNum.incrementAndGet());
-        result.setDaemon(true);
-        return result;
-      }
-    });
+    backgroundProcessor = new ScheduledThreadPoolExecutorWithKeepAlive(BACKGROUND_TASK_POOL_SIZE,
+        BACKGROUND_TASK_POOL_KEEP_ALIVE, TimeUnit.MILLISECONDS, new ThreadFactory() {
+          AtomicInteger threadNum = new AtomicInteger();
+
+          public Thread newThread(final Runnable r) {
+            Thread result = new Thread(r, timerName + threadNum.incrementAndGet());
+            result.setDaemon(true);
+            return result;
+          }
+        });
-    .setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
-    
+        .setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+
-    
+
-    if(queueManager != null) {
+    if (queueManager != null) {
-    
+
-      backgroundProcessor.scheduleWithFixedDelay(new PublishClientStatsTask(), statisticInterval, statisticInterval, TimeUnit.MILLISECONDS);
+      backgroundProcessor.scheduleWithFixedDelay(new PublishClientStatsTask(), statisticInterval,
+          statisticInterval, TimeUnit.MILLISECONDS);
-            LocalizedStrings.PoolImpl_POOL_0_STARTED_WITH_MULTIUSER_SECURE_MODE_ENABLED_1,
-            new Object[] {this.name, this.multiuserSecureModeEnabled}));
+        LocalizedStrings.PoolImpl_POOL_0_STARTED_WITH_MULTIUSER_SECURE_MODE_ENABLED_1,
+        new Object[] {this.name, this.multiuserSecureModeEnabled}));
-  
+
+   * 
-  
+
-  
+
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
+
+
+
+
+
+
+
+
+
+
+
+
-  
+
-  
+
+
+
+
+
-  
+
-  
+
-    sb.append(this.getClass().getSimpleName()).append('@')
-        .append(System.identityHashCode(this)).append(" name=")
-        .append(getName());
+    sb.append(this.getClass().getSimpleName()).append('@').append(System.identityHashCode(this))
+        .append(" name=").append(getName());
-    boolean SPECIAL_DURABLE = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "SPECIAL_DURABLE");
-        if (cnt > 0) {
-        //special case to allow closing durable client pool under the keep alive flag
-            //closing regions prior to closing pool can cause them to unregister interest
-            if (SPECIAL_DURABLE) {
-                synchronized (simpleLock) {
-                    try {
-                        if (!CacheFactory.getAnyInstance().isClosed() && this.getPoolOrCacheCancelInProgress() == null) {
-                            Set<Region<?, ?>> regions = CacheFactory.getInstance(dsys).rootRegions();
-                            for (Region<?, ?> roots : regions) {
-                                Set<Region<?, ?>> subregions = roots.subregions(true);
-                                for (Region<?, ?> subroots : subregions) {
-                                    if (!subroots.isDestroyed() &&  subroots.getAttributes().getPoolName() != null
-                                            && subroots.getAttributes().getPoolName().equals(this.name) ) {
-                                        if (logger.isDebugEnabled()) {
-                                            logger.debug("PoolImpl.destroy[ Region connected count:{} Region subroot closing:{} Pool Name:{} ]", cnt, subroots.getName(), this.name);
-                                        }
-                                        subroots.close();
-                                    }
-                                }
-
-                                if (!roots.isDestroyed() && roots.getAttributes().getPoolName() != null
-                                        && roots.getAttributes().getPoolName().equals(this.name)) {
-                                    if (logger.isDebugEnabled()) {
-                                        logger.debug("PoolImpl.destroy[ Region connected count:{} Region root closing:{} Pool Name:{} ]", cnt, roots.getName(), this.name);
-                                    }
-                                    roots.close();
-                                }
-                            }
-                        }
-                    } catch (CacheClosedException ccex) {
-                      if (logger.isDebugEnabled()) {
-                        logger.debug(ccex.getMessage(), ccex);
-                      }
-                    } catch (Exception ex) {
-                      if (logger.isDebugEnabled()) {
-                        logger.debug(ex.getMessage(), ex);
-                      }
-                    }
-                }
-            } //end special case
-        
-            cnt = getAttachCount();
+    boolean SPECIAL_DURABLE =
+        Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "SPECIAL_DURABLE");
-      throw new IllegalStateException( LocalizedStrings.PoolImpl_POOL_COULD_NOT_BE_DESTROYED_BECAUSE_IT_IS_STILL_IN_USE_BY_0_REGIONS.toLocalizedString(Integer.valueOf(cnt)));
-    }
+      // special case to allow closing durable client pool under the keep alive flag
+      // closing regions prior to closing pool can cause them to unregister interest
+      if (SPECIAL_DURABLE) {
+        synchronized (simpleLock) {
+          try {
+            if (!CacheFactory.getAnyInstance().isClosed()
+                && this.getPoolOrCacheCancelInProgress() == null) {
+              Set<Region<?, ?>> regions = CacheFactory.getInstance(dsys).rootRegions();
+              for (Region<?, ?> roots : regions) {
+                Set<Region<?, ?>> subregions = roots.subregions(true);
+                for (Region<?, ?> subroots : subregions) {
+                  if (!subroots.isDestroyed() && subroots.getAttributes().getPoolName() != null
+                      && subroots.getAttributes().getPoolName().equals(this.name)) {
+                    if (logger.isDebugEnabled()) {
+                      logger.debug(
+                          "PoolImpl.destroy[ Region connected count:{} Region subroot closing:{} Pool Name:{} ]",
+                          cnt, subroots.getName(), this.name);
+                    }
+                    subroots.close();
+                  }
+                }
+
+                if (!roots.isDestroyed() && roots.getAttributes().getPoolName() != null
+                    && roots.getAttributes().getPoolName().equals(this.name)) {
+                  if (logger.isDebugEnabled()) {
+                    logger.debug(
+                        "PoolImpl.destroy[ Region connected count:{} Region root closing:{} Pool Name:{} ]",
+                        cnt, roots.getName(), this.name);
+                  }
+                  roots.close();
+                }
+              }
+            }
+          } catch (CacheClosedException ccex) {
+            if (logger.isDebugEnabled()) {
+              logger.debug(ccex.getMessage(), ccex);
+            }
+          } catch (Exception ex) {
+            if (logger.isDebugEnabled()) {
+              logger.debug(ex.getMessage(), ex);
+            }
+          }
+      } // end special case
+
+      cnt = getAttachCount();
+      if (cnt > 0) {
+        throw new IllegalStateException(
+            LocalizedStrings.PoolImpl_POOL_COULD_NOT_BE_DESTROYED_BECAUSE_IT_IS_STILL_IN_USE_BY_0_REGIONS
+                .toLocalizedString(Integer.valueOf(cnt)));
+      }
+    }
-   * Destroys this pool but does not unregister it.
-   * This is used by the PoolManagerImpl when it wants to close all its pools.
+   * Destroys this pool but does not unregister it. This is used by the PoolManagerImpl when it
+   * wants to close all its pools.
-      logger.info(LocalizedMessage.create(LocalizedStrings.PoolImpl_DESTROYING_CONNECTION_POOL_0, name));
+      logger.info(
+          LocalizedMessage.create(LocalizedStrings.PoolImpl_DESTROYING_CONNECTION_POOL_0, name));
-          if(!backgroundProcessor.awaitTermination(SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
+          if (!backgroundProcessor.awaitTermination(SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
-      } catch(RuntimeException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_BACKGROUNDPROCESSOR), e);
-      } catch(InterruptedException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_INTERRUPTED_WHILE_STOPPING_BACKGROUNDPROCESSOR), e);
+      } catch (RuntimeException e) {
+        logger.error(LocalizedMessage.create(
+            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_BACKGROUNDPROCESSOR), e);
+      } catch (InterruptedException e) {
+        logger.error(LocalizedMessage
+            .create(LocalizedStrings.PoolImpl_INTERRUPTED_WHILE_STOPPING_BACKGROUNDPROCESSOR), e);
-      } catch(RuntimeException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_SOURCE), e);
-      } 
+      } catch (RuntimeException e) {
+        logger.error(LocalizedMessage.create(
+            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_SOURCE), e);
+      }
-        if(this.queueManager != null) {
+        if (this.queueManager != null) {
-      } catch(RuntimeException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_SUBSCRIPTION_MANAGER), e);
-      }
-      
-      try {
-        if(this.manager != null) {
-          manager.close(keepAlive);
-        }
-      } catch(RuntimeException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_MANAGER), e);
-      }
-      
-      try {
-        endpointManager.close();
-      } catch(RuntimeException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_ENDPOINT_MANAGER), e);
+      } catch (RuntimeException e) {
+        logger.error(
+            LocalizedMessage.create(
+                LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_SUBSCRIPTION_MANAGER),
+            e);
-        if(this.stats!=null) {
+        if (this.manager != null) {
+          manager.close(keepAlive);
+        }
+      } catch (RuntimeException e) {
+        logger.error(LocalizedMessage.create(
+            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_MANAGER), e);
+      }
+
+      try {
+        endpointManager.close();
+      } catch (RuntimeException e) {
+        logger.error(LocalizedMessage.create(
+            LocalizedStrings.PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_ENDPOINT_MANAGER), e);
+      }
+
+      try {
+        if (this.stats != null) {
-      } catch(RuntimeException e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_WHILE_CLOSING_STATISTICS), e);
+      } catch (RuntimeException e) {
+        logger.error(
+            LocalizedMessage.create(LocalizedStrings.PoolImpl_ERROR_WHILE_CLOSING_STATISTICS), e);
-  
+
-  
-  
+
+
-    }
-    else {
-      AutoConnectionSourceImpl source = new AutoConnectionSourceImpl(locators,
-          getServerGroup(), HANDSHAKE_TIMEOUT);
-      if(locatorDiscoveryCallback != null) {
+    } else {
+      AutoConnectionSourceImpl source =
+          new AutoConnectionSourceImpl(locators, getServerGroup(), HANDSHAKE_TIMEOUT);
+      if (locatorDiscoveryCallback != null) {
+
-      throw new RuntimeException( 
+      throw new RuntimeException(
-          .toLocalizedString(new Object[] {this, obj}));
+              .toLocalizedString(new Object[] {this, obj}));
-    PoolImpl other = (PoolImpl)obj;
+    PoolImpl other = (PoolImpl) obj;
-      throw new RuntimeException(
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("subscriptionMessageTrackingTimeout"));
+      throw new RuntimeException(LocalizedStrings.PoolImpl_0_IS_DIFFERENT
+          .toLocalizedString("subscriptionMessageTrackingTimeout"));
-      throw new RuntimeException(
-          LocalizedStrings.PoolImpl_0_IS_DIFFERENT.toLocalizedString("subscriptionRedundancyLevel"));
+      throw new RuntimeException(LocalizedStrings.PoolImpl_0_IS_DIFFERENT
+          .toLocalizedString("subscriptionRedundancyLevel"));
-  
+
-   * Execute the given op on the servers that this pool connects to.
-   * This method is responsible for retrying the op if an attempt fails.
-   * It will only execute it once and on one server.
+   * Execute the given op on the servers that this pool connects to. This method is responsible for
+   * retrying the op if an attempt fails. It will only execute it once and on one server.
+   * 
-    //if(multiuser)
-    //get a server from threadlocal cache else throw cacheWriterException 
-    //executeOn(ServerLocation server, Op op, boolean accessed,boolean onlyUseExistingCnx)
+    // if(multiuser)
+    // get a server from threadlocal cache else throw cacheWriterException
+    // executeOn(ServerLocation server, Op op, boolean accessed,boolean onlyUseExistingCnx)
-   * Execute the given op on the servers that this pool connects to.
-   * This method is responsible for retrying the op if an attempt fails.
-   * It will only execute it once and on one server.
+   * Execute the given op on the servers that this pool connects to. This method is responsible for
+   * retrying the op if an attempt fails. It will only execute it once and on one server.
+   * 
+   * 
+
+   * 
-  public Object executeOn(ServerLocation server, Op op, boolean accessed,boolean onlyUseExistingCnx) {
+  public Object executeOn(ServerLocation server, Op op, boolean accessed,
+      boolean onlyUseExistingCnx) {
-    return executor.executeOn(server, op, accessed,onlyUseExistingCnx);
+    return executor.executeOn(server, op, accessed, onlyUseExistingCnx);
-  
+
+   * 
-   * Execute the given op on all the servers that have server-to-client
-   * queues for this pool
+   * Execute the given op on all the servers that have server-to-client queues for this pool
+   * 
-    throws NoSubscriptionServersAvailableException, SubscriptionNotEnabledException {
+      throws NoSubscriptionServersAvailableException, SubscriptionNotEnabledException {
+   * 
-  
+
-  
+
-  
+
+
-   * Test hook.
-   * Verify if this EventId is already present in the map or not. If it is
-   * already present then return true.
+   * Test hook. Verify if this EventId is already present in the map or not. If it is already
+   * present then return true.
-    return ((QueueStateImpl)this.queueManager.getState()).verifyIfDuplicate(eventId);
+    return ((QueueStateImpl) this.queueManager.getState()).verifyIfDuplicate(eventId);
-    return ((QueueStateImpl)this.queueManager.getState()).verifyIfDuplicate(eventId);
+    return ((QueueStateImpl) this.queueManager.getState()).verifyIfDuplicate(eventId);
-   * Borrows a connection from the pool.. Used by gateway and tests.
-   * Any connection that is acquired using this method must be returned using
-   * returnConnection, even if it is destroyed.
+   * Borrows a connection from the pool.. Used by gateway and tests. Any connection that is acquired
+   * using this method must be returned using returnConnection, even if it is destroyed.
-  
+
-   * Hook to return connections that were acquired using 
-   * acquireConnection.
+   * Hook to return connections that were acquired using acquireConnection.
+   * 
-  
+
-    return manager.borrowConnection(loc,15000L,false);
+    return manager.borrowConnection(loc, 15000L, false);
+
+
-    if (this.queueManager == null) return Collections.EMPTY_MAP;
-    if (this.queueManager.getState() == null) return Collections.EMPTY_MAP;
+    if (this.queueManager == null)
+      return Collections.EMPTY_MAP;
+    if (this.queueManager.getState() == null)
+      return Collections.EMPTY_MAP;
-  
+
-   * Test hook that returns true if we have a primary and its updater thread
-   * is alive.
+   * Test hook that returns true if we have a primary and its updater thread is alive.
-    return ((QueueManagerImpl)this.queueManager).isPrimaryUpdaterAlive();
+    return ((QueueManagerImpl) this.queueManager).isPrimaryUpdaterAlive();
+
-  public void killPrimaryEndpoint() //throws ServerException
+  public void killPrimaryEndpoint() // throws ServerException
+
-  
+
-    if(!isDurableClient() || queueManager == null) {
+    if (!isDurableClient() || queueManager == null) {
-    
+
-  
+
-  
+
+
-   * Test hook that returns an int which the port of the primary server.
-   * -1 is returned if we have no primary.
+   * Test hook that returns an int which the port of the primary server. -1 is returned if we have
+   * no primary.
+
-  
+
-  
+
-   * Test hook that returns a list of strings. Each string consists of the host name and port of a redundant server.
-   * An empty list is returned if we have no redundant servers.
+   * Test hook that returns a list of strings. Each string consists of the host name and port of a
+   * redundant server. An empty list is returned if we have no redundant servers.
+
-   * Test hook that returns a list of ServerLocation instances.
-   * Each ServerLocation describes a redundant server.
-   * An empty list is returned if we have no redundant servers.
+   * Test hook that returns a list of ServerLocation instances. Each ServerLocation describes a
+   * redundant server. An empty list is returned if we have no redundant servers.
+
-  
+
+   * 
-  public static volatile boolean IS_INSTANTIATOR_CALLBACK = false ;
+  public static volatile boolean IS_INSTANTIATOR_CALLBACK = false;
-   * <p>Made public so it can be used by tests
+   * <p>
+   * Made public so it can be used by tests
+   * 
+
-   * This needs to be called when a service (like a Region or CQService)
-   * starts using a pool.
+   * This needs to be called when a service (like a Region or CQService) starts using a pool.
+   * 
+
-   * This needs to be called when a service (like a Region or CQService)
-   * stops using a pool.
+   * This needs to be called when a service (like a Region or CQService) stops using a pool.
+   * 
-   * Get the connection held by this thread
-   * if we're using thread local connections
+   * Get the connection held by this thread if we're using thread local connections
-   * This is a a hook for hydra code to pass
-   * thread local connections between threads.
-   * @return the connection from the thread local,
-   * or null if there is no thread local connection.
+   * This is a a hook for hydra code to pass thread local connections between threads.
+   * 
+   * @return the connection from the thread local, or null if there is no thread local connection.
-   * Returns a list of ServerLocation instances;
-   * one for each server we are currently connected to.
+   * Returns a list of ServerLocation instances; one for each server we are currently connected to.
+
-   * Test hook that returns a list of server names (host+port);
-   * one for each server we are currently connected to.
+   * Test hook that returns a list of server names (host+port); one for each server we are currently
+   * connected to.
-      ServerLocation sl = (ServerLocation)it.next();
+      ServerLocation sl = (ServerLocation) it.next();
-  
+
+   * 
-  
+
-    }
-    catch (java.lang.InterruptedException ex) {
+    } catch (java.lang.InterruptedException ex) {
-    
+
-    for(Iterator itr = endpoints.values().iterator(); itr.hasNext();) {
+    for (Iterator itr = endpoints.values().iterator(); itr.hasNext();) {
+
-    }
-    catch (java.lang.InterruptedException ex) {
+    } catch (java.lang.InterruptedException ex) {
+
-    return ((QueueStateImpl)this.queueManager.getState()).getInvalidateCount();
+    return ((QueueStateImpl) this.queueManager.getState()).getInvalidateCount();
+
-   * Set the connection held by this thread
-   * if we're using thread local connections
+   * Set the connection held by this thread if we're using thread local connections
-   * This is a a hook for hydra code to pass
-   * thread local connections between threads.
+   * This is a a hook for hydra code to pass thread local connections between threads.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-   */  
+   */
-  
+
-   * Test hook flag to notify observer(s) that a primary is recovered
-   * either from a backup or from a new connection.
+   * Test hook flag to notify observer(s) that a primary is recovered either from a backup or from a
+   * new connection.
-  
+
-    
+
-      } catch(VirtualMachineError e) {
+      } catch (VirtualMachineError e) {
-      } 
-      catch (CancelException e) {
-//        throw e;
+      } catch (CancelException e) {
+        // throw e;
-      } catch(Throwable t) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.PoolImpl_UNEXPECTED_ERROR_IN_POOL_TASK_0, this), t);
+      } catch (Throwable t) {
+        logger.error(LocalizedMessage
+            .create(LocalizedStrings.PoolImpl_UNEXPECTED_ERROR_IN_POOL_TASK_0, this), t);
-      
+
-    
+
-  
+
-  
+
-   * A cancel criterion that checks both the pool and the cache
-   * for canceled status.
+   * A cancel criterion that checks both the pool and the cache for canceled status.
-    
+
-    
+
-   * A cancel criterion that checks only if this pool has been
-   * closed. This is necessary because there are some things that
-   * we want to allow even after the cache has started closing.
+   * A cancel criterion that checks only if this pool has been closed. This is necessary because
+   * there are some things that we want to allow even after the cache has started closing.
-      if(destroyed) {
+      if (destroyed) {
-  
+
-   * Returns the QueryService, that can be used to execute Query functions on 
-   * the servers associated with this pool.
-   * @return the QueryService 
+   * Returns the QueryService, that can be used to execute Query functions on the servers associated
+   * with this pool.
+   * 
+   * @return the QueryService
-    Cache cache = CacheFactory.getInstance(InternalDistributedSystem
-        .getAnyInstance());
+    Cache cache = CacheFactory.getInstance(InternalDistributedSystem.getAnyInstance());
-      props.setProperty((String)entry.getKey(), (String)entry.getValue());
+      props.setProperty((String) entry.getKey(), (String) entry.getValue());
-    ProxyCache proxy = new ProxyCache(props, (GemFireCacheImpl)cache, this);
+    ProxyCache proxy = new ProxyCache(props, (GemFireCacheImpl) cache, this);
-  
+
-    if(re != null) {
+    if (re != null) {
-         * If the cache instance has somehow changed, we need to get a reference
-         * to the new criterion. This is pretty unlikely because the cache
-         * closes all the pools when it shuts down, but I wanted to be safe.
+         * If the cache instance has somehow changed, we need to get a reference to the new
+         * criterion. This is pretty unlikely because the cache closes all the pools when it shuts
+         * down, but I wanted to be safe.
-      if(reason!=null) {
+      if (reason != null) {
-      if(cache==null) {
-         if(cacheCriterion!=null) {
-            return cacheCriterion.cancelInProgress();
-	 }
-         return null;
+      if (cache == null) {
+        if (cacheCriterion != null) {
+          return cacheCriterion.cancelInProgress();
+        }
+        return null;
-        if(cacheCriterion==null) {
-	  cacheCriterion = cache.getCancelCriterion();
-	} else if(cacheCriterion!=cache.getCancelCriterion()) {
-	  /* 
-	  If the cache instance has somehow changed, we need to 
-	  get a reference to the new criterion. This is pretty unlikely
-	  because the cache closes all the pools when it shuts down,
-	  but I wanted to be safe.
-	  */
-	  cacheCriterion = cache.getCancelCriterion();
-	}
-        return cacheCriterion.cancelInProgress();  
+        if (cacheCriterion == null) {
+          cacheCriterion = cache.getCancelCriterion();
+        } else if (cacheCriterion != cache.getCancelCriterion()) {
+          /*
+           * If the cache instance has somehow changed, we need to get a reference to the new
+           * criterion. This is pretty unlikely because the cache closes all the pools when it shuts
+           * down, but I wanted to be safe.
+           */
+          cacheCriterion = cache.getCancelCriterion();
+        }
+        return cacheCriterion.cancelInProgress();
-    } catch(CancelException cce) {
-      if(cce.getMessage()!=null) {
+    } catch (CancelException cce) {
+      if (cce.getMessage() != null) {
-    } 
+    }
-    if(cache == null) {
+    if (cache == null) {
-   * Assert thread-local var is not null, if it has
-   * multiuser-authentication set to true.
+   * Assert thread-local var is not null, if it has multiuser-authentication set to true.
-   * If serverLocation is non-null, check if the the user is authenticated on
-   * that server. If not, authenticate it and return.
+   * If serverLocation is non-null, check if the the user is authenticated on that server. If not,
+   * authenticate it and return.
-        && ((AbstractOp)op).needsUserId()) {
+        && ((AbstractOp) op).needsUserId()) {
-        throw new UnsupportedOperationException(LocalizedStrings.MultiUserSecurityEnabled_USE_POOL_API.toLocalizedString());
+        throw new UnsupportedOperationException(
+            LocalizedStrings.MultiUserSecurityEnabled_USE_POOL_API.toLocalizedString());
-          Long userId = (Long)AuthenticateUserOp.executeOn(serverLocation,
-              this, userAttributes.getCredentials());
+          Long userId = (Long) AuthenticateUserOp.executeOn(serverLocation, this,
+              userAttributes.getCredentials());
-    if (this.multiuserSecureModeEnabled && ((AbstractOp)op).needsUserId()) {
+    if (this.multiuserSecureModeEnabled && ((AbstractOp) op).needsUserId()) {
-        ConcurrentHashMap<ServerLocation, Long> map = userAttributes
-            .getServerToId();
+        ConcurrentHashMap<ServerLocation, Long> map = userAttributes.getServerToId();
-        Connection primary = this.queueManager.getAllConnectionsNoWait()
-            .getPrimary();
+        Connection primary = this.queueManager.getAllConnectionsNoWait().getPrimary();
-          Long userId = (Long)AuthenticateUserOp.executeOn(primary.getServer(),
-              this, userAttributes.getCredentials());
+          Long userId = (Long) AuthenticateUserOp.executeOn(primary.getServer(), this,
+              userAttributes.getCredentials());
-            Long userId = (Long)AuthenticateUserOp.executeOn(conn.getServer(),
-                this, userAttributes.getCredentials());
+            Long userId = (Long) AuthenticateUserOp.executeOn(conn.getServer(), this,
+                userAttributes.getCredentials());
-        throw new UnsupportedOperationException(LocalizedStrings.MultiUserSecurityEnabled_USE_POOL_API.toLocalizedString());
+        throw new UnsupportedOperationException(
+            LocalizedStrings.MultiUserSecurityEnabled_USE_POOL_API.toLocalizedString());
-    if(!isDurableClient() || this.queueManager == null) {
-      throw new IllegalStateException(LocalizedStrings.PoolManagerImpl_ONLY_DURABLE_CLIENTS_SHOULD_CALL_GETPENDINGEVENTCOUNT.toLocalizedString());
+    if (!isDurableClient() || this.queueManager == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.PoolManagerImpl_ONLY_DURABLE_CLIENTS_SHOULD_CALL_GETPENDINGEVENTCOUNT
+              .toLocalizedString());
-      throw new IllegalStateException(LocalizedStrings.PoolManagerImpl_GETPENDINGEVENTCOUNT_SHOULD_BE_CALLED_BEFORE_INVOKING_READYFOREVENTS.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.PoolManagerImpl_GETPENDINGEVENTCOUNT_SHOULD_BE_CALLED_BEFORE_INVOKING_READYFOREVENTS
+              .toLocalizedString());

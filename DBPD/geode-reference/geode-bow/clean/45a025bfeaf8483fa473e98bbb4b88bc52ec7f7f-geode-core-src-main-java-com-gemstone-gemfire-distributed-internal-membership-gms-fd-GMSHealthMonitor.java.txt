Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-import static com.sun.corba.se.impl.naming.cosnaming.NamingUtils.debug;
+import java.util.stream.*;
-import com.gemstone.gemfire.distributed.DistributedSystemDisconnectedException;
+@SuppressWarnings({ "SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems" })
-  private static Logger logger = Services.getLogger();
+  private static final Logger logger = Services.getLogger();
-  volatile long currentTimeStamp;
+  private volatile long currentTimeStamp;
-  volatile boolean playingDead = false;
+  private volatile boolean playingDead = false;
-  volatile boolean beingSick = false;
+  private volatile boolean beingSick = false;
-  protected DMStats stats;
+  private DMStats stats;
-    private Socket socket;
+    private final Socket socket;
-        @SuppressWarnings("unused")
+        @SuppressWarnings("UnusedAssignment")
+  @SuppressWarnings("EmptyMethod")
-    checkExecutor.execute(new Runnable() {
-
-      @Override
-      public void run() {
-        boolean pinged = false;
-        try {
-          pinged = GMSHealthMonitor.this.doCheckMember(mbr, true);
-        } catch (CancelException e) {
-          return;
-        }
-          
-        if (!pinged) {
-          suspectedMemberInView.put(mbr, currentView);
-          String reason = "Member isn't responding to heartbeat requests";
-          GMSHealthMonitor.this.initiateSuspicion(mbr, reason);
-        } else {
-          logger.trace("Setting next neighbor as member {} has responded.", mbr);
-          suspectedMemberInView.remove(mbr);
-          // back to previous one
-          setNextNeighbor(GMSHealthMonitor.this.currentView, null);
-        }
+    checkExecutor.execute(() -> {
+      boolean pinged = false;
+      try {
+        pinged = GMSHealthMonitor.this.doCheckMember(mbr, true);
+      } catch (CancelException e) {
+        return;
+      }
+        
+      if (!pinged) {
+        suspectedMemberInView.put(mbr, currentView);
+        String reason = "Member isn't responding to heartbeat requests";
+        GMSHealthMonitor.this.initiateSuspicion(mbr, reason);
+      } else {
+        logger.trace("Setting next neighbor as member {} has responded.", mbr);
+        suspectedMemberInView.remove(mbr);
+        // back to previous one
+        setNextNeighbor(GMSHealthMonitor.this.currentView, null);
-    List<SuspectRequest> sl = new ArrayList<SuspectRequest>();
+    List<SuspectRequest> sl = new ArrayList<>();
-   * @param member
-   * @return
-    scheduler = Executors.newScheduledThreadPool(1, new ThreadFactory() {
-      @Override
-      public Thread newThread(Runnable r) {
-        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Scheduler");
-        th.setDaemon(true);
-        return th;
-      }
+    scheduler = Executors.newScheduledThreadPool(1, r -> {
+      Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Scheduler");
+      th.setDaemon(true);
+      return th;
-      AtomicInteger threadIdx = new AtomicInteger();
+      final AtomicInteger threadIdx = new AtomicInteger();
-//    suspectRequestCollectorThread.start();
+//    suspectRequestCollectorThread.start()
-      AtomicInteger threadIdx = new AtomicInteger();
+      final AtomicInteger threadIdx = new AtomicInteger();
-    ServerSocket serverSocket = null;
+    ServerSocket serverSocket;
-    } catch (IOException e) {
-      throw new GemFireConfigException("Unable to allocate a failure detection port in the membership-port range", e);
-    } catch (SystemConnectException e) {
+    } catch (IOException | SystemConnectException e) {
-    serverSocketExecutor.execute(new Runnable() {
-      @Override
-      public void run() {
-        logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(), socketPort);
-        Socket socket = null;
-        try {
-          while (!services.getCancelCriterion().isCancelInProgress() 
-              && !GMSHealthMonitor.this.isStopping) {
-            try {
-              socket = ssocket.accept();
-              if (GMSHealthMonitor.this.playingDead) {
-                continue;
-              }
-              serverSocketExecutor.execute(new ClientSocketHandler(socket)); //start();  [bruce] I'm seeing a lot of failures due to this thread not being created fast enough, sometimes as long as 30 seconds
-            
-            } catch (RejectedExecutionException e) {
-              // this can happen during shutdown
+    serverSocketExecutor.execute(() -> {
+      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(), socketPort);
+      Socket socket = null;
+      try {
+        while (!services.getCancelCriterion().isCancelInProgress() 
+            && !GMSHealthMonitor.this.isStopping) {
+          try {
+            socket = ssocket.accept();
+            if (GMSHealthMonitor.this.playingDead) {
+              continue;
+            }
+            serverSocketExecutor.execute(new ClientSocketHandler(socket)); //start();  [bruce] I'm seeing a lot of failures due to this thread not being created fast enough, sometimes as long as 30 seconds
+          
+          } catch (RejectedExecutionException e) {
+            // this can happen during shutdown
-            } catch (IOException e) {
-              if (!isStopping) {
-                logger.trace("Unexpected exception", e);
+          } catch (IOException e) {
+            if (!isStopping) {
+              logger.trace("Unexpected exception", e);
+            }
+            try {
+              if (socket != null) {
+                socket.close();
-              try {
-                if (socket != null) {
-                  socket.close();
-                }
-              } catch (IOException ioe) {
-                logger.trace("Unexpected exception", ioe);
-              }
+            } catch (IOException ioe) {
+              logger.trace("Unexpected exception", ioe);
-          logger.info("GMSHealthMonitor server thread exiting");
-        } finally {
-          // close the server socket
-          if (ssocket != null && !ssocket.isClosed()) {
-            try {
-              ssocket.close();
-              serverSocket = null;
-              logger.info("GMSHealthMonitor server socket closed.");
-            } catch (IOException e) {
-              logger.debug("Unexpected exception", e);
-            }
+        }
+        logger.info("GMSHealthMonitor server thread exiting");
+      } finally {
+        // close the server socket
+        if (!ssocket.isClosed()) {
+          try {
+            ssocket.close();
+            serverSocket = null;
+            logger.info("GMSHealthMonitor server socket closed.");
+          } catch (IOException e) {
+            logger.debug("Unexpected exception", e);
-    Set<?> checkAllSuspected = new HashSet<>(allMembers);
+    Set<InternalDistributedMember> checkAllSuspected = new HashSet<>(allMembers);
-    for (Iterator<Response> it = val.iterator(); it.hasNext();) {
-      Response r = it.next();
+    for (Response r : val) {
-   * 
-   * @param incomingRequest
-      ArrayList<SuspectRequest> smbr = new ArrayList<SuspectRequest>();
+      ArrayList<SuspectRequest> smbr = new ArrayList<>();
-        Iterator<SuspectRequest> itr = viewVsMembers.iterator();
-        while (itr.hasNext()) {
-          SuspectRequest sr = itr.next();
+        for (final SuspectRequest sr : viewVsMembers) {
-   * @param sMembers
-   * @param cv
-    Set<SuspectRequest> viewVsMembers = null;
+    Set<SuspectRequest> viewVsMembers;
-        viewVsMembers = new HashSet<SuspectRequest>();
+        viewVsMembers = new HashSet<>();
-   *  
-   * @param initiator
-   * @param sMembers
-   * @param cv
-    for (int i = 0; i < sMembers.size(); i++) {
-      final SuspectRequest sr = sMembers.get(i);
+    for (final SuspectRequest sr : sMembers) {
-      checkExecutor.execute(new Runnable() {
-
-        @Override
-        public void run() {
-          try {
-            inlineCheckIfAvailable(initiator, cv, true, mbr,
-                reason);
-          } catch (DistributedSystemDisconnectedException e) {
-            return;
-          } catch (CancelException e) {
-            // shutting down
-          } catch (Exception e) {
-            logger.info("Unexpected exception while verifying member", e);
-          } finally {
-            GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
-          }
+      checkExecutor.execute(() -> {
+        try {
+          inlineCheckIfAvailable(initiator, cv, true, mbr, reason);
+        } catch (CancelException e) {
+          // shutting down
+        } catch (Exception e) {
+          logger.info("Unexpected exception while verifying member", e);
+        } finally {
+          GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
-
-
-      HashSet<InternalDistributedMember> filter = new HashSet<InternalDistributedMember>();
+      HashSet<InternalDistributedMember> filter = new HashSet<>();
-      for (int i = 0; i < requests.size(); i++) {
-        filter.add(requests.get(i).getSuspectMember());
-      }
+      filter.addAll(requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
-    Timer scheduler;
+    final Timer scheduler;
-    long timeout;
+    final long timeout;

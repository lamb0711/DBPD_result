GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+
-import org.apache.geode.cache.query.AmbiguousNameException;
-  private String name;
+  private final String name;
-  private CompiledIteratorDef cmpIteratorDefn;
-  private ObjectType elementType; // may be more specific than that in
-  // cmpIteratorDefn
-  // for canonicalization
+  private final CompiledIteratorDef cmpIteratorDefn;
+  /** may be more specific than that in cmpIteratorDefn */
+  private ObjectType elementType;
+  /** for canonicalization */
-    return this.elementType;
+    return elementType;
-  // public RuntimeIterator(String name, SelectResults collection) {
-  // if (collection == null)
-  // throw new IllegalArgumentException("base collection must not be null");
-  //
-  // this.name = name; // may be null
-  // this.collection = collection;
-  // this.cmpIteratorDefn = null;
-  // this.elementType = collection.getCollectionType().getElementType();
-  // }
-  // /** Return true if this is an iterator that is dependent on other
-  // iterator(s)
-  // * in this scope (a cached result from isDependentOn(context))
-  // */
-  // public boolean isDependent() {
-  // return this.isDependent;
-  // }
-    return this.cmpIteratorDefn;
+    return cmpIteratorDefn;
-    return this.name;
+    return name;
-    if (this.collection != UNINITIALIZED
-        && !this.cmpIteratorDefn.isDependentOnAnyIteratorOfScopeLessThanItsOwn(context)
-        && this.scopeID != IndexCreationHelper.INDEX_QUERY_SCOPE_ID) {
-      return this.collection;
+    if (collection != UNINITIALIZED
+        && !cmpIteratorDefn.isDependentOnAnyIteratorOfScopeLessThanItsOwn(context)
+        && scopeID != IndexCreationHelper.INDEX_QUERY_SCOPE_ID) {
+      return collection;
-    this.collection = this.cmpIteratorDefn.evaluateCollection(context, this);
-    if (this.collection == null) {
+    collection = cmpIteratorDefn.evaluateCollection(context, this);
+    if (collection == null) {
-    if (!this.elementType.equals(TypeUtils.OBJECT_TYPE)) {
-      this.collection.setElementType(elementType);
+    if (!elementType.equals(TypeUtils.OBJECT_TYPE)) {
+      collection.setElementType(elementType);
-      // Asif : The elementType in the Collection obtained is more
-      // specific . So use that type.
-      this.elementType = collection.getCollectionType().getElementType();
+      // The elementType in the Collection obtained is more specific . So use that type.
+      elementType = collection.getCollectionType().getElementType();
-    return this.collection;
+    return collection;
-    return this.cmpIteratorDefn.isDependentOnIterator(itr, context);
+    return cmpIteratorDefn.isDependentOnIterator(itr, context);
-    return this.cmpIteratorDefn.isDependentOnCurrentScope(context);
+    return cmpIteratorDefn.isDependentOnCurrentScope(context);
-    return this.current;
+    return current;
-  boolean containsProperty(ExecutionContext context, String name, int numArgs, boolean mustBeMethod)
-      throws AmbiguousNameException {
+  boolean containsProperty(ExecutionContext context, String name, int numArgs,
+      boolean mustBeMethod) {
-    if ((this.elementType instanceof StructType) && !mustBeMethod) {
+    if ((elementType instanceof StructType) && !mustBeMethod) {
-      String fieldName[] = ((StructType) this.elementType).getFieldNames();
-      for (int i = 0; i < fieldName.length; i++) {
-        if (name.equals(fieldName[i])) {
+      String[] fieldName = ((StructType) elementType).getFieldNames();
+      for (String s : fieldName) {
+        if (name.equals(s)) {
-    Class clazz = this.elementType.resolveClass();
+    Class<?> clazz = elementType.resolveClass();
-      for (int i = 0; i < methods.length; i++) {
-        Method m = methods[i];
-        if (m.getName().equals(name) && m.getParameterTypes().length == numArgs)
+      for (Method m : methods) {
+        if (m.getName().equals(name) && m.getParameterTypes().length == numArgs) {
+        }
-  // private SelectResults prepareIteratorDef(Object obj)
-  // throws TypeMismatchException {
-  // if (obj == null) {
-  // return null;
-  // }
-  //
-  // if (obj == QueryService.UNDEFINED) {
-  // return null;
-  // }
-  //
-  // if (obj instanceof SelectResults) {
-  // // probably came from nested query or is a QRegion already from region
-  // path
-  // return (SelectResults)obj;
-  // }
-  //
-  // if (obj instanceof Region) {
-  // return new QRegion((Region)obj); // this can happen if region passed in as
-  // parameter
-  // }
-  //
-  // // if this is a domain collection, it should be unmodifiable
-  // // if obj is a Collection but not a SelectResults, it must be from the
-  // // domain, otherwise it would be a SelectResults.
-  // if (obj instanceof Collection) {
-  // // do not lose ordering and duplicate information,
-  // ResultsCollectionWrapper res =
-  // new ResultsCollectionWrapper(this.elementType, (Collection)obj);
-  // res.setModifiable(false);
-  // return res;
-  // }
-  //
-  // // Object[] is wrapped and considered a domain object so unmodifiable
-  // if (obj instanceof Object[]) {
-  // // the element type is specified in the array itself, unless we have
-  // // something more specific
-  // if (this.elementType.equals(TypeUtils.OBJECT_TYPE)) { // if we don't have
-  // constraint info
-  // this.elementType =
-  // TypeUtils.getObjectType(obj.getClass().getComponentType());
-  // }
-  //
-  // // do not lose ordering and duplicate information,
-  // ResultsCollectionWrapper res =
-  // new ResultsCollectionWrapper(this.elementType,
-  // Arrays.asList((Object[])obj));
-  // res.setModifiable(false);
-  // return res;
-  // }
-  //
-  // if (obj instanceof Map) {
-  // if (this.elementType.equals(TypeUtils.OBJECT_TYPE)) { // if we don't have
-  // more specific type info, use Map.Entry
-  // elementType = TypeUtils.getObjectType(Map.Entry.class);
-  // }
-  // ResultsCollectionWrapper res =
-  // new ResultsCollectionWrapper(elementType, ((Map)obj).entrySet());
-  // res.setModifiable(false);
-  // return res;
-  // } else {
-  // throw new TypeMismatchException(
-  // "The expression in the FROM clause of a SELECT statement was type '"
-  // + obj.getClass().getName()
-  // + "', which cannot be interpreted as a collection");
-  // }
-  // }
-    StringBuffer sb = new StringBuffer();
-    sb.append(this.getClass().getName());
-    sb.append(" (name=" + this.name);
-    // if(isDependent)
-    sb.append(" collection expr=" + cmpIteratorDefn);
-    // else {
-    // sb.append("; collection=" +this.collection + ")");
-    // sb.append("; collectionType=" +this.collection.getCollectionType() +
-    // ")");
-    // sb.append("; elementType="
-    // +this.collection.getCollectionType().getElementType() + ")");
-    // }
-    return sb.toString();
+    return getClass().getName() + " (name=" + name + " collection expr=" + cmpIteratorDefn + ")";
-  public void setInternalId(String id) {
+  void setInternalId(String id) {
-    return this.index_internal_id;
+    return index_internal_id;
-  public void generateCanonicalizedExpression(StringBuilder clauseBuffer, ExecutionContext context)
-      throws AmbiguousNameException, TypeMismatchException {
-    // Asif: prepend the internal iterator variable name for this
-    // RunTimeIterator
-    //
+  public void generateCanonicalizedExpression(StringBuilder clauseBuffer,
+      ExecutionContext context) {
+    // prepend the internal iterator variable name for this RunTimeIterator
-    if (currScopeID == this.scopeID) {
-      // Support.Assert(this.index_internal_id != null, "Index_Internal_ID
-      // should have been set at this point");
-      clauseBuffer.insert(0,
-          this.index_internal_id == null ? this.internalId : this.index_internal_id);
+    if (currScopeID == scopeID) {
+      // should have been set at this point
+      clauseBuffer.insert(0, index_internal_id == null ? internalId : index_internal_id);
-      clauseBuffer.insert(0, internalId).insert(0, '_').insert(0, this.scopeID).insert(0, "scope");
+      clauseBuffer.insert(0, internalId).insert(0, '_').insert(0, scopeID).insert(0, "scope");
-    return this.scopeID;
+    return scopeID;

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Synchronization structure which allows multiple threads to lock the
- * structure. Implementation is fair: the next waiting thread will be
- * serviced.
+ * Synchronization structure which allows multiple threads to lock the structure. Implementation is
+ * fair: the next waiting thread will be serviced.
- * Collaborating threads may jointly synchronize on this structure if they all
- * agree on the same topic of collaboration.
+ * Collaborating threads may jointly synchronize on this structure if they all agree on the same
+ * topic of collaboration.
- * Threads that want to change the topic will wait until the current topic
- * has been released.
+ * Threads that want to change the topic will wait until the current topic has been released.
-  
+
-  
+
-  
-  /** The current topic of collaboration 
+
+  /**
+   * The current topic of collaboration
-  
+
-  
+
-  
+
-  
-  /** 
-   * Constructs new stoppable instance of Collaboration which will heed an 
-   * interrupt request if it is acceptable to the creator of the lock.
+
+  /**
+   * Constructs new stoppable instance of Collaboration which will heed an interrupt request if it
+   * is acceptable to the creator of the lock.
-  
-  /** 
-   * Acquire permission to participate in the collaboration. Returns 
-   * immediately if topic matches the current topic. Otherwise, this will 
-   * block until the Collaboration has been freed by the threads working
-   * on the current topic. This call is interruptible.
+
+  /**
+   * Acquire permission to participate in the collaboration. Returns immediately if topic matches
+   * the current topic. Otherwise, this will block until the Collaboration has been freed by the
+   * threads working on the current topic. This call is interruptible.
-    throw new UnsupportedOperationException(LocalizedStrings.Collaboration_NOT_IMPLEMENTED.toLocalizedString());
+    throw new UnsupportedOperationException(
+        LocalizedStrings.Collaboration_NOT_IMPLEMENTED.toLocalizedString());
-   * Must be synchronized on this.topicsQueue... Asserts that thread is not 
-   * reentering. 
+   * Must be synchronized on this.topicsQueue... Asserts that thread is not reentering.
-    Assert.assertTrue(false,
-      Thread.currentThread() + " attempting to lock topic " + topicObject +
-      " while locking topic " + this.currentTopic);
+    Assert.assertTrue(false, Thread.currentThread() + " attempting to lock topic " + topicObject
+        + " while locking topic " + this.currentTopic);
-  
-  /** 
-   * Acquire permission to participate in the collaboration. Returns 
-   * immediately if topic matches the current topic. Otherwise, this will 
-   * block until the Collaboration has been freed by the threads working
-   * on the current topic. This call is uninterruptible.
+
+  /**
+   * Acquire permission to participate in the collaboration. Returns immediately if topic matches
+   * the current topic. Otherwise, this will block until the Collaboration has been freed by the
+   * threads working on the current topic. This call is uninterruptible.
-    
+
-          logger.debug("Collaboration.acquireUninterruptibly: {}: no current topic, setting topic to {}", this.toString(), topicObject);
+          logger.debug(
+              "Collaboration.acquireUninterruptibly: {}: no current topic, setting topic to {}",
+              this.toString(), topicObject);
-      
+
-        //assertNotRecursingTopic(topicObject);
+        // assertNotRecursingTopic(topicObject);
-          logger.debug("Collaboration.acquireUninterruptibly: {}: already current topic: {}", this.toString(), topicObject);
+          logger.debug("Collaboration.acquireUninterruptibly: {}: already current topic: {}",
+              this.toString(), topicObject);
-      
+
-      
+
-          logger.debug("Collaboration.acquireUninterruptibly: {}: adding pendingTopic {}; current topic is {}", this.toString(), pendingTopic, this.currentTopic);
+          logger.debug(
+              "Collaboration.acquireUninterruptibly: {}: adding pendingTopic {}; current topic is {}",
+              this.toString(), pendingTopic, this.currentTopic);
-    }
-    catch (InterruptedException e) { // LOST INTERRUPT
+    } catch (InterruptedException e) { // LOST INTERRUPT
-    }
-    finally {
-      if (interrupted) Thread.currentThread().interrupt();
+    } finally {
+      if (interrupted)
+        Thread.currentThread().interrupt();
-  
+
-            logger.debug("Collaboration.setCurrentTopic: {}: new topic is {}", this.getIdentity(), topic);
+            logger.debug("Collaboration.setCurrentTopic: {}: new topic is {}", this.getIdentity(),
+                topic);
-      }
-      else {
+      } else {
-          logger.debug("Collaboration.setCurrentTopic: {} setting current topic to null", this.toString());
+          logger.debug("Collaboration.setCurrentTopic: {} setting current topic to null",
+              this.toString());
-  
-  private void awaitTopic(Topic topic, boolean interruptible)
-  throws InterruptedException {
+
+  private void awaitTopic(Topic topic, boolean interruptible) throws InterruptedException {
-          Assert.assertTrue(false, "[" + getIdentity() +
-            ".awaitTopic] attempting to wait on old topic");
+          Assert.assertTrue(false,
+              "[" + getIdentity() + ".awaitTopic] attempting to wait on old topic");
-          // No can do in this instance (wrong lock ordering) but we still want 
+          // No can do in this instance (wrong lock ordering) but we still want
-            logger.debug("Collaboration.awaitTopic: {} waiting for topic {}; current topic probably {}, which may have a thread count of {}", getIdentity(), topic, sniff.toString(), sniff.threadCount());
+            logger.debug(
+                "Collaboration.awaitTopic: {} waiting for topic {}; current topic probably {}, which may have a thread count of {}",
+                getIdentity(), topic, sniff.toString(), sniff.threadCount());
-        }
-        catch (InterruptedException e) {
-          if (interruptible) throw e;
+        } catch (InterruptedException e) {
+          if (interruptible)
+            throw e;
-        }
-        finally {
-          if (interrupted) Thread.currentThread().interrupt();
+        } finally {
+          if (interrupted)
+            Thread.currentThread().interrupt();
-    
+
-    /*Assert.assertTrue(isCurrentTopic(topic.getTopicObject()), 
-        "Failed to make " + topic + " the topic for " + this);*/ 
+    /*
+     * Assert.assertTrue(isCurrentTopic(topic.getTopicObject()), "Failed to make " + topic +
+     * " the topic for " + this);
+     */
-  
-  /** 
+
+  /**
-    throw new UnsupportedOperationException(LocalizedStrings.Collaboration_NOT_IMPLEMENTED.toLocalizedString());
+    throw new UnsupportedOperationException(
+        LocalizedStrings.Collaboration_NOT_IMPLEMENTED.toLocalizedString());
-      
-  /** 
-   * Acquire permission to participate in the collaboration; waits the
-   * specified timeout.
+
+  /**
+   * Acquire permission to participate in the collaboration; waits the specified timeout.
-  throws InterruptedException {
-    throw new UnsupportedOperationException(LocalizedStrings.Collaboration_NOT_IMPLEMENTED.toLocalizedString());
+      throws InterruptedException {
+    throw new UnsupportedOperationException(
+        LocalizedStrings.Collaboration_NOT_IMPLEMENTED.toLocalizedString());
-  
+
-   * Releases the current thread's participation in the collaboration. When
-   * the last thread involved in the current topic has released, a new topic
-   * can be started by any waiting threads.
+   * Releases the current thread's participation in the collaboration. When the last thread involved
+   * in the current topic has released, a new topic can be started by any waiting threads.
-   * Nothing happens if the calling thread is not participating in the current
-   * topic.
+   * Nothing happens if the calling thread is not participating in the current topic.
-        throw new IllegalStateException(LocalizedStrings.Collaboration_COLLABORATION_HAS_NO_CURRENT_TOPIC.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.Collaboration_COLLABORATION_HAS_NO_CURRENT_TOPIC.toLocalizedString());
-      }
-      else  {
+      } else {
-      if (this.currentTopic == null) return false;
+      if (this.currentTopic == null)
+        return false;
-  
+
-  
+
-      throw new IllegalArgumentException(LocalizedStrings.Collaboration_TOPIC_MUST_BE_SPECIFIED.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.Collaboration_TOPIC_MUST_BE_SPECIFIED.toLocalizedString());
-    
+
-  
+
-    return me.substring(me.lastIndexOf(".")+1);
+    return me.substring(me.lastIndexOf(".") + 1);
-  
+
-   * Blocking threads will wait on this wrapper object. As threads release,
-   * they will be removed from the Topic. The last one removed will notifyAll 
-   * on the next Topic in topicsQueue.
+   * Blocking threads will wait on this wrapper object. As threads release, they will be removed
+   * from the Topic. The last one removed will notifyAll on the next Topic in topicsQueue.
-    
+
-    
+
-    
+
-    
+
-     * guarded.By {@link Collaboration#topicsQueue}
-     * guarded.By this instance, <em>after</em> acquiring the topicsQueue
+     * guarded.By {@link Collaboration#topicsQueue} guarded.By this instance, <em>after</em>
+     * acquiring the topicsQueue
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-    /** 
-     * Atomically removes thread and returns true if there are no more 
-     * participating threads. 
+
+    /**
+     * Atomically removes thread and returns true if there are no more participating threads.
-          Assert.assertTrue(false, 
-              "thread " + thread + " was not participating in " + this);
+          Assert.assertTrue(false, "thread " + thread + " was not participating in " + this);
-        /*if (Collaboration.this.debugEnabled()) {
-          Collaboration.this.log.fine("[" + Collaboration.this.getIdentity() + 
-              ".Topic] removed " + thread + " from " + this +
-              "; remaining threads: " + this.participatingThreads);
-        }*/
+        /*
+         * if (Collaboration.this.debugEnabled()) { Collaboration.this.log.fine("[" +
+         * Collaboration.this.getIdentity() + ".Topic] removed " + thread + " from " + this +
+         * "; remaining threads: " + this.participatingThreads); }
+         */
-    
-    /** Adds thread to list of threads participating in this topic. */ 
+
+    /** Adds thread to list of threads participating in this topic. */
-    
+
-    
+
-    
+
-    
+
-    
+
-  
+

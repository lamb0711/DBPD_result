Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.internal.cache.CachedDeserializableFactory;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl.NewValueImporter;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl.OldValueImporter;
+import com.gemstone.gemfire.internal.cache.RemotePutMessage;
+import com.gemstone.gemfire.internal.cache.VMCachedDeserializable;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+
-public final class PutMessage extends PartitionMessageWithDirectReply
-  {
+public final class PutMessage extends PartitionMessageWithDirectReply implements NewValueImporter {
-  
+
+  @Unretained(ENTRY_EVENT_NEW_VALUE) 
+  /** whether this operation should fetch oldValue from HDFS*/
+  private transient boolean fetchFromHDFS;
+
+  private transient boolean isPutDML;
+  
+  //using the left most bit for IS_PUT_DML, the last available bit
+  protected static final short IS_PUT_DML = (short) (HAS_VERSION_TAG << 1);
+  // TODO this should really have been at the PartitionMessage level but all
+  // masks there are taken
+  // also switching the masks will impact backwards compatibility. Need to
+  // verify if it is ok to break backwards compatibility
+  protected static final int FETCH_FROM_HDFS = getNextByteMask(HAS_CALLBACKARG);  
-        {
+        if (original.valObj instanceof StoredObject && !((StoredObject)original.valObj).isSerialized()) {
+          this.valObj = ((StoredObject)original.valObj).getDeserializedForReading();
+        } else {
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedNewValue();
-      if (cd != null) {
-        {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-          Object v = cd.getValue();
-          if (v instanceof byte[]) {
-            setValBytes((byte[])v);
-          }
-          else {
-            // Defer serialization until toData is called.
-            setValObj(v);
-          }
-        }
+      if (CachedDeserializableFactory.preferObject() || event.hasDelta()) {
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER;
+      } else {
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-      else {
-        Object v = event.getRawNewValue();
-        if (v instanceof byte[]) {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
-          setValBytes((byte[]) v);
-        }
-        else if (event.hasDelta()) {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER;
-          if (event.getCachedSerializedNewValue() != null) {
-            setValBytes(event.getCachedSerializedNewValue());
-          } else {
-            setValObj(v);
-          }
-        }
-        else {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-          if (event.getCachedSerializedNewValue() != null) {
-            setValBytes(event.getCachedSerializedNewValue());
-          } else {
-            setValObj(v);
-          }
-        }
-      }
+      event.exportNewValue(this);
+    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
-  private void setValObj(Object o) {
+  private void setValObj(@Unretained(ENTRY_EVENT_NEW_VALUE) Object o) {
-
+    if ((extraFlags & FETCH_FROM_HDFS) != 0) {
+      this.fetchFromHDFS = true;
+    }
+    if ((flags & IS_PUT_DML) != 0) {
+      this.isPutDML = true;
+    }
+    
+    if (this.event.isFetchFromHDFS()) extraFlags |= FETCH_FROM_HDFS;
-      // for eager deserialization avoid extra byte array serialization
-      if (this.deserializationPolicy
-          == DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER) {
-        byte[] newValBytes = getValBytes();
-        if (getValBytes() == null) {
-          newValBytes = BlobHelper.serializeToBlob(this.valObj);
-          this.event.setCachedSerializedNewValue(newValBytes);
-        }
-        out.write(getValBytes());
-      }
-      else if (this.deserializationPolicy == DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY) {
-        byte[] newValBytes = getValBytes();
-        if (getValBytes() == null) {
-          newValBytes = BlobHelper.serializeToBlob(this.valObj);
-          this.event.setCachedSerializedNewValue(newValBytes);
-        }
-        DataSerializer.writeByteArray(newValBytes, out);
-      }
-      else { // POLICY_NONE
-        DataSerializer.writeByteArray(getValBytes(), out);
-      }
+      // TODO OFFHEAP MERGE: cache serialized blob in event
+      DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(), out);
+    if (this.event.isPutDML()) s |= IS_PUT_DML;
-    final EntryEventImpl ev = new EntryEventImpl(
+    final EntryEventImpl ev = EntryEventImpl.create(
+    try {
+	ev.setFetchFromHDFS(this.fetchFromHDFS);
+    ev.setPutDML(this.isPutDML);
+      try {
+      } finally {
+        // if e2 == ev then no need to free it here. The outer finally block will get it.
+        if (e2 != ev) {
+          e2.release();
+        }
+      }
-      Object oldValue = null;
-      if (!this.notificationOnly && this.requireOldValue) {
-        oldValue = ev.getSerializedOldValue();
-        if (oldValue == null) {
-          oldValue = ev.getRawOldValue();
-        }
-      }
-                oldValue, ev.getVersionTag());
+                ev);
+    } finally {
+      ev.release();
+    }
-                           Object oldValue,
-                           VersionTag version) {
+                           EntryEventImpl ev) {
-    PutReplyMessage.send(member, procId, getReplySender(dm), result, getOperation(), ex, oldValue, version);
+    PutReplyMessage.send(member, procId, getReplySender(dm), result, getOperation(), ex, this, ev);
+  
+  @Override
+  protected boolean mayAddToMultipleSerialGateways(DistributionManager dm) {
+    return _mayAddToMultipleSerialGateways(dm);
+  }
-  public static final class PutReplyMessage extends ReplyMessage {
+  public static final class PutReplyMessage extends ReplyMessage implements OldValueImporter {
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
+    /**
+     * Set to true by the import methods if the oldValue
+     * is already serialized. In that case toData
+     * should just copy the bytes to the stream.
+     * In either case fromData just calls readObject.
+     */
+    private transient boolean oldValueIsSerialized;
+
-    private PutReplyMessage(int processorId,
+    // package access for unit test
+    PutReplyMessage(int processorId,
-                            Object oldValue,
-                            VersionTag version)
+                            PutMessage sourceMessage,
+                            EntryEventImpl ev)
-      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, oldValue, version);
+      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, null, ev.getVersionTag());
+      if (!sourceMessage.notificationOnly && sourceMessage.requireOldValue) {
+        ev.exportOldValue(m);
+      }
+
-    @Override
+   @Override
-      DataSerializer.writeObject(this.oldValue, out);
+      Object ov = getOldValue();
+      RemotePutMessage.PutReplyMessage.oldValueToData(out, getOldValue(), this.oldValueIsSerialized);
+
+    @Override
+    public boolean prefersOldSerialized() {
+      return true;
+    }
+
+    @Override
+    public boolean isUnretainedOldReferenceOk() {
+      return true;
+    }
+    
+    @Override
+    public boolean isCachedDeserializableValueOk() {
+      return true;
+    }
+
+
+    @Override
+    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+      this.oldValue = ov;
+      this.oldValueIsSerialized = isSerialized;
+    }
+
+    @Override
+    public void importOldBytes(byte[] ov, boolean isSerialized) {
+      importOldObject(ov, isSerialized);
+    }
+
+  // NewValueImporter methods
+  
+  @Override
+  public boolean prefersNewSerialized() {
+    return true;
+  }
+
+  @Override
+  public boolean isUnretainedNewReferenceOk() {
+    return true;
+  }
+  
+  private void setDeserializationPolicy(boolean isSerialized) {
+    if (!isSerialized) {
+      this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
+    }
+  }
+
+  @Override
+  public void importNewObject(@Unretained(ENTRY_EVENT_NEW_VALUE) Object nv, boolean isSerialized) {
+    setDeserializationPolicy(isSerialized);
+    setValObj(nv);
+  }
+
+  @Override
+  public void importNewBytes(byte[] nv, boolean isSerialized) {
+    setDeserializationPolicy(isSerialized);
+    setValBytes(nv);
+  }

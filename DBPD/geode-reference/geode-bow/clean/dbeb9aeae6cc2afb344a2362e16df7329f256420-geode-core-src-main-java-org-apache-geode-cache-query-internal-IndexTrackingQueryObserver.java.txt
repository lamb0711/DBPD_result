Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-//  IndexTrackingQueryObserver.java
-//  gemfire
+// IndexTrackingQueryObserver.java
+// gemfire
-  
+
+  private static final ThreadLocal lastKeyUsed = new ThreadLocal();
-  
+
-    Map<String, IndexInfo> indexMap = (Map)this.indexInfo.get();
+    Map<String, IndexInfo> indexMap = (Map) this.indexInfo.get();
-    String indexName;
-    //Dont create new IndexInfo if one is already there in map for aggregation
-    //of results later for whole partition region on this node.
-    if((index instanceof MapRangeIndex || index instanceof CompactMapRangeIndex) && key instanceof Object[]){
-      indexName = index.getName()+ "-"+((Object[])key)[1];
-    } else {
-      indexName = index.getName();
-    }
-    if(indexMap.containsKey(indexName)){
+    String indexName = getIndexName(index, key);
+    if (indexMap.containsKey(indexName)) {
-    if(th != null){
+    this.lastKeyUsed.set(key);
+    if (th != null) {
-  
-  public void beforeIndexLookup(Index index, int lowerBoundOperator,
-                                Object lowerBoundKey, int upperBoundOperator, Object upperBoundKey,
-                                Set NotEqualKeys) {
-    Map<String, IndexInfo> indexMap = (Map)this.indexInfo.get();
+
+  public void beforeIndexLookup(Index index, int lowerBoundOperator, Object lowerBoundKey,
+      int upperBoundOperator, Object upperBoundKey, Set NotEqualKeys) {
+    Map<String, IndexInfo> indexMap = (Map) this.indexInfo.get();
-    //Dont create new IndexInfo if one is already there in map for aggregation
-    //of results later for whole partition region on this node.
-    if(indexMap.containsKey(index.getName())){
+    // Dont create new IndexInfo if one is already there in map for aggregation
+    // of results later for whole partition region on this node.
+    if (indexMap.containsKey(index.getName())) {
-    if(th != null){
+    if (th != null) {
-  
+
-    
+
-    Map indexMap = (Map)this.indexInfo.get();
-    if (lastIndexUsed.get() != null) {
-      IndexInfo indexInfo = (IndexInfo) indexMap
-          .get(((Index) this.lastIndexUsed.get()).getName());
+    Map indexMap = (Map) this.indexInfo.get();
+    Index index = (Index) lastIndexUsed.get();
+    if (index != null) {
+      IndexInfo indexInfo = (IndexInfo) indexMap.get(getIndexName(index, this.lastKeyUsed.get()));
-      indexInfo.getResults().put(
-          ((Index)this.lastIndexUsed.get()).getRegion().getFullPath(),
-          new Integer(results.size()));
+        indexInfo.getResults().put(index.getRegion().getFullPath(), new Integer(results.size()));
-    if(th != null){
+    this.lastKeyUsed.set(null);
+    if (th != null) {
-  }    
-  
+  }
+
+  private String getIndexName(Index index, Object key) {
+    String indexName;
+    if ((index instanceof MapRangeIndex || index instanceof CompactMapRangeIndex)
+        && key instanceof Object[]) {
+      indexName = index.getName() + "-" + ((Object[]) key)[1];
+    } else {
+      indexName = index.getName();
+    }
+    return indexName;
+  }
+
+
-   * This should be called only when one query execution on one gemfire node is done.
-   * NOT for each buckets.
+   * This should be called only when one query execution on one gemfire node is done. NOT for each
+   * buckets.
-    if(th != null){
+    if (th != null) {
-    Map map = (Map)this.indexInfo.get();
+    Map map = (Map) this.indexInfo.get();
+
-   * This class contains information related to buckets and results found in
-   * the index on those buckets.
+   * This class contains information related to buckets and results found in the index on those
+   * buckets.
-  public class IndexInfo{
+  public class IndexInfo {
-    
+
+
-     * Adds a results map (mostly a bucket index lookup results)
-     * to the "this" IndexInfo.
+     * Adds a results map (mostly a bucket index lookup results) to the "this" IndexInfo.
+     * 
-      for(Object obj : rslts.entrySet()){
-        Entry<String, Integer> ent = (Entry)obj;
+      for (Object obj : rslts.entrySet()) {
+        Entry<String, Integer> ent = (Entry) obj;
+
+
-    
+
-      int total =0;
-      for (Integer i: results.values()){
-        total+=i.intValue();
+      int total = 0;
+      for (Integer i : results.values()) {
+        total += i.intValue();
-      return "(Results: "+ total +")";
+      return "(Results: " + total + ")";
+
-    Map map = (Map)this.indexInfo.get();
+    Map map = (Map) this.indexInfo.get();
-    for(Object obj: (Set)map.entrySet()){
-      Map.Entry<String, IndexInfo> entry = (Map.Entry<String, IndexInfo>)obj;
-      if(entry != null && entry.getValue().getRegionIds().contains(fullPath)){
+    for (Object obj : (Set) map.entrySet()) {
+      Map.Entry<String, IndexInfo> entry = (Map.Entry<String, IndexInfo>) obj;
+      if (entry != null && entry.getValue().getRegionIds().contains(fullPath)) {

GEODE-7042: Set server status to "online" after all startup tasks complete (#3878)

ServerLauncher start will now wait until all asynchronous startup tasks
complete to update server status as "online".

Previously, the server status was set to "online" before all of the
startup tasks had completed. This provided users with incorrect facts
about the system and its availability. This commit changes the behavior
of ServerLauncher.start() so that it waits for all of the asynchronous
startup tasks to complete before returning the "online" status. The GFSH
"start server" command relies on this status, so this also has the
effect of making the command wait for all startup tasks to complete
before returning.

* ServerLauncher.start() waits for startup tasks to complete
* Improve testability of ServerLauncher
* Extract ControllableProcess interface
* Change InternalResourceManager support for asynchronous startup tasks
* Move the responsibility for chaining the completion and exception
actions of startup tasks to ServerLauncher

Co-authored-by: Aaron Lindsey <alindsey@pivotal.io>
Co-authored-by: Kirk Lund <klund@apache.org>
Co-authored-by: Dale Emery <demery@pivotal.io>

+
-import static org.apache.commons.lang3.Validate.notNull;
-
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import org.apache.logging.log4j.Logger;
+public interface ControllableProcess {
+  int getPid();
-import org.apache.geode.distributed.AbstractLauncher.ServiceState;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.process.ControlFileWatchdog.ControlRequestHandler;
+  File getPidFile();
-/**
- * Creates the {@link PidFile} and uses {@link ControlFileWatchdog} to monitor the directory for
- * creation of stop or status request files.
- *
- * @since GemFire 8.0
- */
-public class ControllableProcess {
-  private static final Logger logger = LogService.getLogger();
+  File getDirectory();
-  private final File directory;
-  private final LocalProcessLauncher launcher;
-  private final ControlFileWatchdog stopRequestFileWatchdog;
-  private final ControlFileWatchdog statusRequestFileWatchdog;
+  void stop();
-  public ControllableProcess(final ControlNotificationHandler handler, final File directory,
-      final ProcessType processType, final boolean force)
-      throws FileAlreadyExistsException, IOException, PidUnavailableException {
-    this(directory, processType, force, createPidFile(directory, processType),
-        createStopHandler(handler), createStatusHandler(handler, directory, processType));
-  }
-
-  private ControllableProcess(final File directory, final ProcessType processType,
-      final boolean force, final File pidFile, final ControlRequestHandler stopHandler,
-      final ControlRequestHandler statusHandler)
-      throws FileAlreadyExistsException, IOException, PidUnavailableException {
-    this(directory, processType, createLocalProcessLauncher(pidFile, force),
-        createStopRequestFileWatchdog(directory, processType, stopHandler),
-        createStatusRequestFileWatchdog(directory, processType, statusHandler));
-  }
-
-  ControllableProcess(final File directory, final ProcessType processType,
-      final LocalProcessLauncher launcher, final ControlFileWatchdog stopRequestFileWatchdog,
-      final ControlFileWatchdog statusRequestFileWatchdog) {
-    notNull(directory, "Invalid directory '" + directory + "' specified");
-    notNull(processType, "Invalid processType '" + processType + "' specified");
-    notNull(launcher, "Invalid launcher '" + launcher + "' specified");
-    notNull(stopRequestFileWatchdog,
-        "Invalid stopRequestFileWatchdog '" + stopRequestFileWatchdog + "' specified");
-    notNull(statusRequestFileWatchdog,
-        "Invalid statusRequestFileWatchdog '" + statusRequestFileWatchdog + "' specified");
-
-    this.directory = directory;
-    this.launcher = launcher;
-    this.stopRequestFileWatchdog = stopRequestFileWatchdog;
-    this.statusRequestFileWatchdog = statusRequestFileWatchdog;
-
-    deleteFiles(directory, processType);
-    stopRequestFileWatchdog.start();
-    statusRequestFileWatchdog.start();
-  }
-
-  /**
-   * Returns the process id (PID).
-   *
-   * @return the process id (PID)
-   */
-  public int getPid() {
-    return launcher.getPid();
-  }
-
-  /**
-   * Returns the PID file.
-   *
-   * @return the PID file
-   */
-  public File getPidFile() {
-    return launcher.getPidFile();
-  }
-
-  public File getDirectory() {
-    return directory;
-  }
-
-  public void stop() {
-    boolean interrupted = false;
-    try {
-      interrupted = stop(statusRequestFileWatchdog);
-      interrupted = stop(stopRequestFileWatchdog) || interrupted;
-      launcher.close();
-    } finally {
-      if (interrupted) {
-        Thread.currentThread().interrupt();
-      }
-    }
-  }
-
-  public void stop(final boolean deletePidFileOnStop) {
-    boolean interrupted = false;
-    try {
-      interrupted = stop(statusRequestFileWatchdog);
-      interrupted = stop(stopRequestFileWatchdog) || interrupted;
-      launcher.close(deletePidFileOnStop);
-    } finally {
-      if (interrupted) {
-        Thread.currentThread().interrupt();
-      }
-    }
-  }
-
-  private boolean stop(final ControlFileWatchdog fileWatchdog) {
-    boolean interrupted = false;
-    try {
-      fileWatchdog.stop();
-    } catch (InterruptedException e) {
-      interrupted = true;
-      logger.warn("Interrupted while stopping status handler for controllable process.", e);
-    }
-    return interrupted;
-  }
-
-  private void deleteFiles(final File directory, final ProcessType processType) {
-    try {
-      deleteFileWithValidation(new File(directory, processType.getStatusRequestFileName()),
-          "statusRequestFile");
-      deleteFileWithValidation(new File(directory, processType.getStatusFileName()), "statusFile");
-      deleteFileWithValidation(new File(directory, processType.getStopRequestFileName()),
-          "stopRequestFile");
-    } catch (IOException e) {
-      throw new UncheckedIOException(e);
-    }
-  }
-
-  private static File createPidFile(final File directory, final ProcessType processType) {
-    return new File(directory, processType.getPidFileName());
-  }
-
-  private static LocalProcessLauncher createLocalProcessLauncher(final File pidFile,
-      final boolean force) throws FileAlreadyExistsException, IOException, PidUnavailableException {
-    return new LocalProcessLauncher(pidFile, force);
-  }
-
-  private static ControlRequestHandler createStopHandler(final ControlNotificationHandler handler) {
-    return handler::handleStop;
-  }
-
-  private static ControlRequestHandler createStatusHandler(final ControlNotificationHandler handler,
-      final File directory, final ProcessType processType) {
-    return () -> {
-      writeStatusToFile(fetchStatusWithValidation(handler), directory, processType);
-    };
-  }
-
-  private static ControlFileWatchdog createStopRequestFileWatchdog(final File directory,
-      final ProcessType processType, final ControlRequestHandler stopHandler) {
-    return new ControlFileWatchdog(directory, processType.getStopRequestFileName(), stopHandler,
-        false);
-  }
-
-  private static ControlFileWatchdog createStatusRequestFileWatchdog(final File directory,
-      final ProcessType processType, final ControlRequestHandler statusHandler) {
-    return new ControlFileWatchdog(directory, processType.getStatusRequestFileName(), statusHandler,
-        false);
-  }
-
-  static String fetchStatusWithValidation(final ControlNotificationHandler handler) {
-    ServiceState<?> state = handler.handleStatus();
-    if (state == null) {
-      throw new IllegalStateException("Null ServiceState is invalid");
-    }
-
-    String jsonContent = state.toJson();
-    if (jsonContent == null) {
-      throw new IllegalStateException("Null JSON for status is invalid");
-    } else if (jsonContent.trim().isEmpty()) {
-      throw new IllegalStateException("Empty JSON for status is invalid");
-    }
-
-    return jsonContent;
-  }
-
-  private static void deleteFileWithValidation(final File file, final String fileNameForMessage)
-      throws IOException {
-    if (file.exists()) {
-      if (!file.delete()) {
-        throw new IOException(
-            "Unable to delete " + fileNameForMessage + "'" + file.getCanonicalPath() + "'");
-      }
-    }
-  }
-
-  private static void writeStatusToFile(final String jsonContent, final File directory,
-      final ProcessType processType) throws IOException {
-    File statusFile = new File(directory, processType.getStatusFileName());
-    File statusFileTmp = new File(directory, processType.getStatusFileName() + ".tmp");
-
-    deleteFileWithValidation(statusFile, "statusFile");
-    deleteFileWithValidation(statusFileTmp, "statusFileTmp");
-
-    if (!statusFileTmp.createNewFile()) {
-      throw new IOException(
-          "Unable to create statusFileTmp '" + statusFileTmp.getCanonicalPath() + "'");
-    }
-
-    FileWriter writer = new FileWriter(statusFileTmp);
-    writer.write(jsonContent);
-    writer.flush();
-    writer.close();
-
-    if (!statusFileTmp.renameTo(statusFile)) {
-      throw new IOException("Unable to rename statusFileTmp '" + statusFileTmp.getCanonicalPath()
-          + "' to '" + statusFile.getCanonicalPath() + "'");
-    }
-  }
+  void stop(boolean deletePidFileOnStop);

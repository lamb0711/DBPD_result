Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * DirectChannel is used to interact directly with other Direct servers to
- * distribute GemFire messages to other nodes.  It is held by a
- * org.apache.geode.internal.cache.distribution.DistributionChannel,
- * which is used by the DistributionManager to send and receive asynchronous
- * messages.
+ * DirectChannel is used to interact directly with other Direct servers to distribute GemFire
+ * messages to other nodes. It is held by a
+ * org.apache.geode.internal.cache.distribution.DistributionChannel, which is used by the
+ * DistributionManager to send and receive asynchronous messages.
-  
+
-    /** this is the conduit used for communications */
-    private final transient TCPConduit conduit;
+  /** this is the conduit used for communications */
+  private final transient TCPConduit conduit;
-    private volatile boolean disconnected = true;
-    
-    /** This is set to true when completely disconnected (all connections are closed) */
-    private volatile boolean disconnectCompleted = true;
+  private volatile boolean disconnected = true;
-    /** this is the DistributionManager, most of the time */
-    private final DirectChannelListener receiver;
+  /** This is set to true when completely disconnected (all connections are closed) */
+  private volatile boolean disconnectCompleted = true;
-    private final InetAddress address;
-    
-    InternalDistributedMember localAddr;
+  /** this is the DistributionManager, most of the time */
+  private final DirectChannelListener receiver;
-    /**
-     * Callback to set the local address, must be done before this channel is used.
-     * 
-     * @param localAddr
-     * @throws ConnectionException if the conduit has stopped
-     */
-    public void setLocalAddr(InternalDistributedMember localAddr) {
-      this.localAddr = localAddr;
-      conduit.setLocalAddr(localAddr);
-      if (disconnected) {
-        disconnected = false;
-        disconnectCompleted = false;
-        this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-        this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      }
-    }
-    
-    /**
-     * when the initial number of members is known, this method is invoked
-     * to ensure that connections to those members can be established in a
-     * reasonable amount of time.  See bug 39848 
-     * @param numberOfMembers
-     */
-    public void setMembershipSize(int numberOfMembers) {
-      conduit.setMaximumHandshakePoolSize(numberOfMembers);
-    }
-    
-    /**
-     * Returns the cancel criterion for the channel,
-     * which will note if the channel is abnormally
-     * closing
-     */
-    public CancelCriterion getCancelCriterion() {
-      return conduit.getCancelCriterion();
-    }
+  private final InetAddress address;
-    public DirectChannel(MembershipManager mgr, DirectChannelListener listener,
-        DistributionConfig dc)
-        throws ConnectionException {
-      this.receiver = listener;
+  InternalDistributedMember localAddr;
-      this.address = initAddress(dc);
-      boolean isBindAddress = dc.getBindAddress() != null;
-      try {
-        int port = Integer.getInteger("tcpServerPort", 0).intValue();
-        if (port == 0) {
-          port = dc.getTcpPort();
-        }
-        Properties props = System.getProperties();
-        if (props.getProperty("p2p.shareSockets") == null) {
-          props.setProperty("p2p.shareSockets", String.valueOf(dc.getConserveSockets()));
-        }
-        if (dc.getSocketBufferSize() != DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE) {
-          // Note that the system property "p2p.tcpBufferSize" will be
-          // overridden by the new "socket-buffer-size".
-          props.setProperty("p2p.tcpBufferSize", String.valueOf(dc.getSocketBufferSize()));
-        }
-        if (props.getProperty("p2p.idleConnectionTimeout") == null) {
-          props.setProperty("p2p.idleConnectionTimeout", String.valueOf(dc.getSocketLeaseTime()));
-        }
-        int[] range = dc.getMembershipPortRange();
-        props.setProperty("membership_port_range_start", ""+range[0]);
-        props.setProperty("membership_port_range_end", ""+range[1]);
-
-        this.conduit = new TCPConduit(mgr, port, address, isBindAddress, this, props);
-        disconnected = false;
-        disconnectCompleted = false;
-        this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-        this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.DirectChannel_GEMFIRE_P2P_LISTENER_STARTED_ON__0, conduit.getLocalAddr()));
-
-      }
-      catch (ConnectionException ce) {
-        logger.fatal(LocalizedMessage.create(
-            LocalizedStrings.DirectChannel_UNABLE_TO_INITIALIZE_DIRECT_CHANNEL_BECAUSE__0, new Object[]{ce.getMessage()}), ce);
-        throw ce; // fix for bug 31973
-      }
-    }
-
- 
-   * Return how many concurrent operations should be allowed by default.
-   * since 6.6, this has been raised to Integer.MAX value from the number
-   * of available processors. Setting this to a lower value raises the possibility
-   * of a deadlock when serializing a message with PDX objects, because the 
-   * PDX serialization can trigger further distribution.
+   * Callback to set the local address, must be done before this channel is used.
+   * 
+   * @param localAddr
+   * @throws ConnectionException if the conduit has stopped
-  static public final int DEFAULT_CONCURRENCY_LEVEL = Integer.getInteger("p2p.defaultConcurrencyLevel", Integer.MAX_VALUE / 2).intValue();
-  
+  public void setLocalAddr(InternalDistributedMember localAddr) {
+    this.localAddr = localAddr;
+    conduit.setLocalAddr(localAddr);
+    if (disconnected) {
+      disconnected = false;
+      disconnectCompleted = false;
+      this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
+      this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
+    }
+  }
+
+  /**
+   * when the initial number of members is known, this method is invoked to ensure that connections
+   * to those members can be established in a reasonable amount of time. See bug 39848
+   * 
+   * @param numberOfMembers
+   */
+  public void setMembershipSize(int numberOfMembers) {
+    conduit.setMaximumHandshakePoolSize(numberOfMembers);
+  }
+
+  /**
+   * Returns the cancel criterion for the channel, which will note if the channel is abnormally
+   * closing
+   */
+  public CancelCriterion getCancelCriterion() {
+    return conduit.getCancelCriterion();
+  }
+
+  public DirectChannel(MembershipManager mgr, DirectChannelListener listener, DistributionConfig dc)
+      throws ConnectionException {
+    this.receiver = listener;
+
+    this.address = initAddress(dc);
+    boolean isBindAddress = dc.getBindAddress() != null;
+    try {
+      int port = Integer.getInteger("tcpServerPort", 0).intValue();
+      if (port == 0) {
+        port = dc.getTcpPort();
+      }
+      Properties props = System.getProperties();
+      if (props.getProperty("p2p.shareSockets") == null) {
+        props.setProperty("p2p.shareSockets", String.valueOf(dc.getConserveSockets()));
+      }
+      if (dc.getSocketBufferSize() != DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE) {
+        // Note that the system property "p2p.tcpBufferSize" will be
+        // overridden by the new "socket-buffer-size".
+        props.setProperty("p2p.tcpBufferSize", String.valueOf(dc.getSocketBufferSize()));
+      }
+      if (props.getProperty("p2p.idleConnectionTimeout") == null) {
+        props.setProperty("p2p.idleConnectionTimeout", String.valueOf(dc.getSocketLeaseTime()));
+      }
+      int[] range = dc.getMembershipPortRange();
+      props.setProperty("membership_port_range_start", "" + range[0]);
+      props.setProperty("membership_port_range_end", "" + range[1]);
+
+      this.conduit = new TCPConduit(mgr, port, address, isBindAddress, this, props);
+      disconnected = false;
+      disconnectCompleted = false;
+      this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
+      this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.DirectChannel_GEMFIRE_P2P_LISTENER_STARTED_ON__0, conduit.getAddress()));
+
+    } catch (ConnectionException ce) {
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.DirectChannel_UNABLE_TO_INITIALIZE_DIRECT_CHANNEL_BECAUSE__0,
+          new Object[] {ce.getMessage()}), ce);
+      throw ce; // fix for bug 31973
+    }
+  }
+
+
+  /**
+   * Return how many concurrent operations should be allowed by default. since 6.6, this has been
+   * raised to Integer.MAX value from the number of available processors. Setting this to a lower
+   * value raises the possibility of a deadlock when serializing a message with PDX objects, because
+   * the PDX serialization can trigger further distribution.
+   */
+  static public final int DEFAULT_CONCURRENCY_LEVEL =
+      Integer.getInteger("p2p.defaultConcurrencyLevel", Integer.MAX_VALUE / 2).intValue();
+
-  static private final int MAX_GROUP_SENDERS = Integer.getInteger("p2p.maxGroupSenders", DEFAULT_CONCURRENCY_LEVEL).intValue();
+  static private final int MAX_GROUP_SENDERS =
+      Integer.getInteger("p2p.maxGroupSenders", DEFAULT_CONCURRENCY_LEVEL).intValue();
+
-      throw new org.apache.geode.distributed.DistributedSystemDisconnectedException(LocalizedStrings.DirectChannel_DIRECT_CHANNEL_HAS_BEEN_STOPPED.toLocalizedString());
+      throw new org.apache.geode.distributed.DistributedSystemDisconnectedException(
+          LocalizedStrings.DirectChannel_DIRECT_CHANNEL_HAS_BEEN_STOPPED.toLocalizedString());
-      } 
-      catch (InterruptedException ex) {
+      } catch (InterruptedException ex) {
-      }
-      finally {
+      } finally {
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.DirectChannel_COMMUNICATIONS_DISCONNECTED.toLocalizedString());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.DirectChannel_COMMUNICATIONS_DISCONNECTED.toLocalizedString());
+
-  
+
-    
+
-   * This is basically just sendToMany, giving us a way to see on the stack
-   * whether we are sending to a single member or multiple members, in which
-   * case the group-send lock will be held during distribution.
+   * This is basically just sendToMany, giving us a way to see on the stack whether we are sending
+   * to a single member or multiple members, in which case the group-send lock will be held during
+   * distribution.
-   * @throws ConnectExceptions if message could not be send to its
-   *         <code>destination</code>
-   * @throws NotSerializableException
-   *         If the msg cannot be serialized
+   * @throws ConnectExceptions if message could not be send to its <code>destination</code>
+   * @throws NotSerializableException If the msg cannot be serialized
-  private final int sendToOne(final MembershipManager mgr, 
-      InternalDistributedMember[] p_destinations,
-      final DistributionMessage msg, long ackWaitThreshold, long ackSAThreshold)
+  private final int sendToOne(final MembershipManager mgr,
+      InternalDistributedMember[] p_destinations, final DistributionMessage msg,
+      long ackWaitThreshold, long ackSAThreshold)
-  
-  
+
+
-   * Sends a msg to a list of destinations. This code does some special optimizations
-   * to stream large messages
+   * Sends a msg to a list of destinations. This code does some special optimizations to stream
+   * large messages
+   * 
-   * @throws ConnectExceptions if message could not be send to its
-   *         <code>destination</code>
-   * @throws NotSerializableException
-   *         If the msg cannot be serialized
+   * @throws ConnectExceptions if message could not be send to its <code>destination</code>
+   * @throws NotSerializableException If the msg cannot be serialized
-  private int sendToMany(final MembershipManager mgr, 
-      InternalDistributedMember[] p_destinations,
+  private int sendToMany(final MembershipManager mgr, InternalDistributedMember[] p_destinations,
-    //Connections we actually sent messages to.
+    // Connections we actually sent messages to.
-      directMsg = (DirectReplyMessage)msg;
-    }
-    else {
+      directMsg = (DirectReplyMessage) msg;
+    } else {
-      ackTimeout = (int)(ackWaitThreshold * 1000);
+      ackTimeout = (int) (ackWaitThreshold * 1000);
-        ackSDTimeout = (int)(ackSAThreshold * 1000);
+        ackSDTimeout = (int) (ackSAThreshold * 1000);
-          ackSDTimeout = (int)(ReplyProcessor21.PR_SEVERE_ALERT_RATIO * ackSDTimeout);
+          ackSDTimeout = (int) (ReplyProcessor21.PR_SEVERE_ALERT_RATIO * ackSDTimeout);
-    if (directMsg != null
-        && directMsg.supportsDirectAck()
-        && threadOwnsResources()) {
+    if (directMsg != null && directMsg.supportsDirectAck() && threadOwnsResources()) {
-    //If this is a direct reply message, but we are sending it
-    //over the shared socket, tell the message it needs to
-    //use a regular reply processor.
+    // If this is a direct reply message, but we are sending it
+    // over the shared socket, tell the message it needs to
+    // use a regular reply processor.
-    do {
-      interrupted = interrupted || Thread.interrupted();
-      /**
-       * Exceptions that happened during one attempt to send
-       */
-      if (retryInfo != null) {
-        // need to retry to each of the guys in the exception
-        List retryMembers = retryInfo.getMembers();
-        InternalDistributedMember[] retryDest = new InternalDistributedMember[retryMembers.size()];
-        retryDest = (InternalDistributedMember[])retryMembers.toArray(retryDest);
-        destinations = retryDest;
-        retryInfo = null;
-        retry = true;
-      }
-      final List cons = new ArrayList(destinations.length);
-      ConnectExceptions ce = getConnections(mgr, msg, destinations, orderedMsg,
-            retry, ackTimeout, ackSDTimeout, cons);
-      if (directReply && msg.getProcessorId() > 0) { // no longer a direct-reply message?
-        directReply = false;
-      }
-      if (ce != null) {
-        if (failedCe != null) {
-          failedCe.getMembers().addAll(ce.getMembers());
-          failedCe.getCauses().addAll(ce.getCauses());
-        } 
-        else {
-          failedCe = ce;
+      do {
+        interrupted = interrupted || Thread.interrupted();
+        /**
+         * Exceptions that happened during one attempt to send
+         */
+        if (retryInfo != null) {
+          // need to retry to each of the guys in the exception
+          List retryMembers = retryInfo.getMembers();
+          InternalDistributedMember[] retryDest =
+              new InternalDistributedMember[retryMembers.size()];
+          retryDest = (InternalDistributedMember[]) retryMembers.toArray(retryDest);
+          destinations = retryDest;
+          retryInfo = null;
+          retry = true;
-        ce = null;
-      }
-      if (cons.isEmpty()) {
-        if (failedCe != null) {
-          throw failedCe;
-        } 
-        return bytesWritten;
-      }
-
-      boolean sendingToGroup = cons.size() > 1;
-      Connection permissionCon = null;
-      if (sendingToGroup) {
-        acquireGroupSendPermission(orderedMsg);
-      }
-      else {
-        // sending to just one guy
-        permissionCon = (Connection)cons.get(0);
-        if (permissionCon != null) {
-          try {
-            permissionCon.acquireSendPermission();
-          }
-          catch (ConnectionException conEx) {
-            // Set retryInfo and then retry.
-            // We want to keep calling TCPConduit.getConnection until it doesn't
-            // return a connection.
-            retryInfo = new ConnectExceptions();
-            retryInfo.addFailure(permissionCon.getRemoteAddress(), conEx);
-            continue;
-          }
+        final List cons = new ArrayList(destinations.length);
+        ConnectExceptions ce = getConnections(mgr, msg, destinations, orderedMsg, retry, ackTimeout,
+            ackSDTimeout, cons);
+        if (directReply && msg.getProcessorId() > 0) { // no longer a direct-reply message?
+          directReply = false;
-      }
-
-      try {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{}{}) to {} peers ({}) via tcp/ip",
-              (retry ? "Retrying send (" : "Sending ("),  msg, cons.size(), cons);
-        }
-        DMStats stats = getDMStats();
-        List<?> sentCons; // used for cons we sent to this time
-
-        final BaseMsgStreamer ms = MsgStreamer.create(cons, msg, directReply,
-            stats);
-        try {
-          startTime = 0;
-          if (ackTimeout > 0) {
-            startTime = System.currentTimeMillis();
-          }
-          ms.reserveConnections(startTime, ackTimeout, ackSDTimeout);
-
-          int result = ms.writeMessage();
-          if (bytesWritten == 0) {
-            // bytesWritten only needs to be set once.
-            // if we have to do a retry we don't want to count
-            // each one's bytes.
-            bytesWritten = result;
-          }
-          ce = ms.getConnectExceptions();
-          sentCons = ms.getSentConnections();
-
-          totalSentCons.addAll(sentCons);
-        } 
-        catch (NotSerializableException e) {
-          throw e;
-        } 
-        catch (ToDataException e) {
-          throw e;
-        } 
-        catch (IOException ex) {
-          throw new InternalGemFireException(LocalizedStrings.DirectChannel_UNKNOWN_ERROR_SERIALIZING_MESSAGE.toLocalizedString(), ex);
-        }
-        finally {
-          try {
-            ms.close();
-          } catch (IOException e) {
-            throw new InternalGemFireException(
-                "Unknown error serializing message", e);
-          }
-        }
-
-          retryInfo = ce;
+          if (failedCe != null) {
+            failedCe.getMembers().addAll(ce.getMembers());
+            failedCe.getCauses().addAll(ce.getCauses());
+          } else {
+            failedCe = ce;
+          }
-        
-        if (directReply && !sentCons.isEmpty()) {
-          long readAckStart = 0;
-          if (stats != null) {
-            readAckStart = stats.startReplyWait();
+        if (cons.isEmpty()) {
+          if (failedCe != null) {
+            throw failedCe;
-          try {
-            ce = readAcks(sentCons, startTime, ackTimeout, ackSDTimeout, ce, directMsg.getDirectReplyProcessor());
-          } finally {
-            if (stats != null) {
-              stats.endReplyWait(readAckStart, startTime);
+          return bytesWritten;
+        }
+
+        boolean sendingToGroup = cons.size() > 1;
+        Connection permissionCon = null;
+        if (sendingToGroup) {
+          acquireGroupSendPermission(orderedMsg);
+        } else {
+          // sending to just one guy
+          permissionCon = (Connection) cons.get(0);
+          if (permissionCon != null) {
+            try {
+              permissionCon.acquireSendPermission();
+            } catch (ConnectionException conEx) {
+              // Set retryInfo and then retry.
+              // We want to keep calling TCPConduit.getConnection until it doesn't
+              // return a connection.
+              retryInfo = new ConnectExceptions();
+              retryInfo.addFailure(permissionCon.getRemoteAddress(), conEx);
+              continue;
-      } finally {
-        if (sendingToGroup) {
-          releaseGroupSendPermission(orderedMsg);
+
+        try {
+          if (logger.isDebugEnabled()) {
+            logger.debug("{}{}) to {} peers ({}) via tcp/ip",
+                (retry ? "Retrying send (" : "Sending ("), msg, cons.size(), cons);
+          }
+          DMStats stats = getDMStats();
+          List<?> sentCons; // used for cons we sent to this time
+
+          final BaseMsgStreamer ms = MsgStreamer.create(cons, msg, directReply, stats);
+          try {
+            startTime = 0;
+            if (ackTimeout > 0) {
+              startTime = System.currentTimeMillis();
+            }
+            ms.reserveConnections(startTime, ackTimeout, ackSDTimeout);
+
+            int result = ms.writeMessage();
+            if (bytesWritten == 0) {
+              // bytesWritten only needs to be set once.
+              // if we have to do a retry we don't want to count
+              // each one's bytes.
+              bytesWritten = result;
+            }
+            ce = ms.getConnectExceptions();
+            sentCons = ms.getSentConnections();
+
+            totalSentCons.addAll(sentCons);
+          } catch (NotSerializableException e) {
+            throw e;
+          } catch (ToDataException e) {
+            throw e;
+          } catch (IOException ex) {
+            throw new InternalGemFireException(
+                LocalizedStrings.DirectChannel_UNKNOWN_ERROR_SERIALIZING_MESSAGE
+                    .toLocalizedString(),
+                ex);
+          } finally {
+            try {
+              ms.close();
+            } catch (IOException e) {
+              throw new InternalGemFireException("Unknown error serializing message", e);
+            }
+          }
+
+          if (ce != null) {
+            retryInfo = ce;
+            ce = null;
+          }
+
+          if (directReply && !sentCons.isEmpty()) {
+            long readAckStart = 0;
+            if (stats != null) {
+              readAckStart = stats.startReplyWait();
+            }
+            try {
+              ce = readAcks(sentCons, startTime, ackTimeout, ackSDTimeout, ce,
+                  directMsg.getDirectReplyProcessor());
+            } finally {
+              if (stats != null) {
+                stats.endReplyWait(readAckStart, startTime);
+              }
+            }
+          }
+        } finally {
+          if (sendingToGroup) {
+            releaseGroupSendPermission(orderedMsg);
+          } else if (permissionCon != null) {
+            permissionCon.releaseSendPermission();
+          }
-        else if (permissionCon != null) {
-          permissionCon.releaseSendPermission();
+        if (ce != null) {
+          if (retryInfo != null) {
+            retryInfo.getMembers().addAll(ce.getMembers());
+            retryInfo.getCauses().addAll(ce.getCauses());
+          } else {
+            retryInfo = ce;
+          }
+          ce = null;
-      }
-      if (ce != null) {
-          retryInfo.getMembers().addAll(ce.getMembers());
-          retryInfo.getCauses().addAll(ce.getCauses());
-        } else {
-          retryInfo = ce;
+          this.conduit.getCancelCriterion().checkCancelInProgress(null);
-        ce = null;
-      }
-      if (retryInfo != null) {
-        this.conduit.getCancelCriterion().checkCancelInProgress(null);
-      }
-    } while (retryInfo != null);
-    }
-    finally {
+      } while (retryInfo != null);
+    } finally {
-      for (Iterator it=totalSentCons.iterator(); it.hasNext();) {
-        Connection con = (Connection)it.next();
+      for (Iterator it = totalSentCons.iterator(); it.hasNext();) {
+        Connection con = (Connection) it.next();
-  
+
-    for (Iterator it=sentCons.iterator(); it.hasNext();) {
-      Connection con = (Connection)it.next();
-      //We don't expect replies on shared connections.
-      if(con.isSharedResource()) {
+    for (Iterator it = sentCons.iterator(); it.hasNext();) {
+      Connection con = (Connection) it.next();
+      // We don't expect replies on shared connections.
+      if (con.isSharedResource()) {
-      int msToWait = (int)(ackTimeout - (System.currentTimeMillis() - startTime));
+      int msToWait = (int) (ackTimeout - (System.currentTimeMillis() - startTime));
-        } 
-        catch (SocketTimeoutException ex) {
+        } catch (SocketTimeoutException ex) {
-      } 
-      catch (ConnectionException conEx) {
+      } catch (ConnectionException conEx) {
-   * Obtain the connections needed to transmit a message.  The connections are
-   * put into the cons object (the last parameter)
+   * Obtain the connections needed to transmit a message. The connections are put into the cons
+   * object (the last parameter)
-   * @return null if everything went okay, or a ConnectExceptions object if some connections couldn't be obtained
+   * @return null if everything went okay, or a ConnectExceptions object if some connections
+   *         couldn't be obtained
-  private ConnectExceptions getConnections(
-      MembershipManager mgr, DistributionMessage msg,
-      InternalDistributedMember[] destinations,
-      boolean preserveOrder, boolean retry,
-      long ackTimeout, long ackSDTimeout,
-      List cons) {
+  private ConnectExceptions getConnections(MembershipManager mgr, DistributionMessage msg,
+      InternalDistributedMember[] destinations, boolean preserveOrder, boolean retry,
+      long ackTimeout, long ackSDTimeout, List cons) {
-    for (int i=0; i < destinations.length; i++) {
+    for (int i = 0; i < destinations.length; i++) {
-      if (!mgr.memberExists(destination) || mgr.shutdownInProgress() || mgr.isShunned(destination)) {
+      if (!mgr.memberExists(destination) || mgr.shutdownInProgress()
+          || mgr.isShunned(destination)) {
-        if (ce == null) ce = new ConnectExceptions();
-        ce.addFailure(destination, new ShunnedMemberException(LocalizedStrings.DirectChannel_SHUNNING_0.toLocalizedString(destination)));
-      }
-      else {
+        if (ce == null)
+          ce = new ConnectExceptions();
+        ce.addFailure(destination, new ShunnedMemberException(
+            LocalizedStrings.DirectChannel_SHUNNING_0.toLocalizedString(destination)));
+      } else {
-          Connection con = conduit.getConnection(destination, preserveOrder,
-              retry, startTime, ackTimeout, ackSDTimeout);
-          
+          Connection con = conduit.getConnection(destination, preserveOrder, retry, startTime,
+              ackTimeout, ackSDTimeout);
+
-          if(con.isSharedResource() && msg instanceof DirectReplyMessage) {
+          if (con.isSharedResource() && msg instanceof DirectReplyMessage) {
-          if (ce == null) ce = new ConnectExceptions();
+          if (ce == null)
+            ce = new ConnectExceptions();
-  
+
+   * 
-   * @throws ConnectExceptions if message could not be send to one or more
-   *         of the <code>destinations</code>
-   * @throws NotSerializableException
-   *         If the content cannot be serialized
-     * @throws ConnectionException if the conduit has stopped
+   * @throws ConnectExceptions if message could not be send to one or more of the
+   *         <code>destinations</code>
+   * @throws NotSerializableException If the content cannot be serialized
+   * @throws ConnectionException if the conduit has stopped
-  public int send(MembershipManager mgr, InternalDistributedMember[] destinations,  
-                  DistributionMessage msg, long ackWaitThreshold, long ackSAThreshold)
-    throws ConnectExceptions, NotSerializableException {
-    
+  public int send(MembershipManager mgr, InternalDistributedMember[] destinations,
+      DistributionMessage msg, long ackWaitThreshold, long ackSAThreshold)
+      throws ConnectExceptions, NotSerializableException {
+
-        logger.debug("Returning from DirectChannel send because empty destinations passed in {}", msg);
+        logger.debug("Returning from DirectChannel send because empty destinations passed in {}",
+            msg);
-    if (destinations.length==1) {
+    if (destinations.length == 1) {
-  
-  
+
+
-    }
-    else {
+    } else {
-  
+
+   * 
-    }
-    else {
+    } else {
-  
+
-  
+
-   * @param processor 
+   * @param processor
-  private void handleAckTimeout(long ackTimeout, long ackSATimeout, Connection c, DirectReplyProcessor processor) 
-      throws ConnectionException {
+  private void handleAckTimeout(long ackTimeout, long ackSATimeout, Connection c,
+      DirectReplyProcessor processor) throws ConnectionException {
-      final StringId msg = LocalizedStrings.DirectChannel_0_SECONDS_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLY_FROM_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3;  
-      final Object[] msgArgs = new Object[] {Long.valueOf(ackTimeout/1000), c.getRemoteAddress(), dm.getId(), activeMembers};
+      final StringId msg =
+          LocalizedStrings.DirectChannel_0_SECONDS_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLY_FROM_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3;
+      final Object[] msgArgs = new Object[] {Long.valueOf(ackTimeout / 1000), c.getRemoteAddress(),
+          dm.getId(), activeMembers};
-      
+
-        TimeoutException cause = new TimeoutException(LocalizedStrings.TIMED_OUT_WAITING_FOR_ACKS.toLocalizedString());
+        TimeoutException cause =
+            new TimeoutException(LocalizedStrings.TIMED_OUT_WAITING_FOR_ACKS.toLocalizedString());
-          c.readAck((int)ackSATimeout, ackSATimeout, processor);
+          c.readAck((int) ackSATimeout, ackSATimeout, processor);
-        }
-        catch (SocketTimeoutException e) {
-          Object[] args = new Object[] {Long.valueOf((ackSATimeout+ackTimeout)/1000), c.getRemoteAddress(), dm.getId(), activeMembers};
+        } catch (SocketTimeoutException e) {
+          Object[] args = new Object[] {Long.valueOf((ackSATimeout + ackTimeout) / 1000),
+              c.getRemoteAddress(), dm.getId(), activeMembers};
-              LocalizedStrings.DirectChannel_0_SECONDS_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLY_FROM_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3, args));
+              LocalizedStrings.DirectChannel_0_SECONDS_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLY_FROM_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3,
+              args));
-      }
-      catch (SocketTimeoutException ex) {
+      } catch (SocketTimeoutException ex) {
-            LocalizedStrings.DirectChannel_UNEXPECTED_TIMEOUT_WHILE_WAITING_FOR_ACK_FROM__0, c.getRemoteAddress()), ex);
+            LocalizedStrings.DirectChannel_UNEXPECTED_TIMEOUT_WHILE_WAITING_FOR_ACK_FROM__0,
+            c.getRemoteAddress()), ex);
-        LocalizedStrings.DirectChannel_VIEW_NO_LONGER_HAS_0_AS_AN_ACTIVE_MEMBER_SO_WE_WILL_NO_LONGER_WAIT_FOR_IT,
-        c.getRemoteAddress()));
+          LocalizedStrings.DirectChannel_VIEW_NO_LONGER_HAS_0_AS_AN_ACTIVE_MEMBER_SO_WE_WILL_NO_LONGER_WAIT_FOR_IT,
+          c.getRemoteAddress()));
-  
+
-    }
-    catch (MemberShunnedException e) {
+    } catch (MemberShunnedException e) {
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DirectChannel_WHILE_PULLING_A_MESSAGE), ex);
+        logger.fatal(
+            LocalizedMessage.create(LocalizedStrings.DirectChannel_WHILE_PULLING_A_MESSAGE), ex);
+
-  
+
-   * This closes down the Direct connection.  Theoretically you can disconnect
-   * and, if you need to use the channel again you can and it will automatically
-   * reconnect.  Reconnection will cause a new local address to be generated.
+   * This closes down the Direct connection. Theoretically you can disconnect and, if you need to
+   * use the channel again you can and it will automatically reconnect. Reconnection will cause a
+   * new local address to be generated.
-//    this.shutdownCause = cause;
+    // this.shutdownCause = cause;
-  
+
-      /* note: had to change the following to make sure the prop wasn't empty 
-         in addition to not null for admin.DistributedSystemFactory */
+      /*
+       * note: had to change the following to make sure the prop wasn't empty in addition to not
+       * null for admin.DistributedSystemFactory
+       */
+      } else {
+        return SocketCreator.getLocalHost();
-      else {
-       return SocketCreator.getLocalHost();
-      }
-    }
-    catch (java.net.UnknownHostException unhe) {
+    } catch (java.net.UnknownHostException unhe) {
-  
+
-  public void closeEndpoint(InternalDistributedMember member, String reason, boolean notifyDisconnect) {
+  public void closeEndpoint(InternalDistributedMember member, String reason,
+      boolean notifyDisconnect) {
-   * adds state for thread-owned serial connections to the given member to
-   * the parameter <i>result</i>.  This can be used to wait for the state to
-   * reach the given level in the member's vm.
-   * @param member
-   *    the member whose state is to be captured
-   * @param result
-   *    the map to add the state to
+   * adds state for thread-owned serial connections to the given member to the parameter
+   * <i>result</i>. This can be used to wait for the state to reach the given level in the member's
+   * vm.
+   * 
+   * @param member the member whose state is to be captured
+   * @param result the map to add the state to
-  public void getChannelStates(DistributedMember member, Map result)
-  {
+  public void getChannelStates(DistributedMember member, Map result) {
-  
+
-   * wait for the given connections to process the number of messages
-   * associated with the connection in the given map
+   * wait for the given connections to process the number of messages associated with the connection
+   * in the given map
-    throws InterruptedException
-  {
-    if (Thread.interrupted()) throw new InterruptedException();
+      throws InterruptedException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
-  
+
-  
+
-  
+
-  
+

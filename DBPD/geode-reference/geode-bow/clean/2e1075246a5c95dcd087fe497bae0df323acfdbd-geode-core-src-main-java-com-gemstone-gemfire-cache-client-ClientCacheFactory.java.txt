Merge branch 'release/1.0.0-incubating.M3'

-import java.util.Properties;
-
-import com.gemstone.gemfire.internal.jndi.JNDIInvoker;
-import com.gemstone.gemfire.pdx.PdxSerializer;
+import com.gemstone.gemfire.pdx.PdxSerializer;
+
+import java.util.Properties;
+
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.LOCATORS;
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.MCAST_PORT;
-Factory class used to create the singleton {@link ClientCache client cache} and connect to one or more GemFire Cache Servers. If the application wants to connect to GemFire as a peer it should use {@link com.gemstone.gemfire.cache.CacheFactory} instead.
-<p> Once the factory has been configured using its set* methods you produce a {@link ClientCache} by calling the {@link #create} method.
-The
-<a href="../distribution/DistributedSystem.html#cache-xml-file">"cache-xml-file"</a>
-property can be used to specify a cache.xml file to initialize the cache with.
-The contents of this file must comply with the
- <code>"doc-files/cache8_0.dtd"</code> file and the top level element must be a <code>client-cache</code> element.
-<p> Client connections are managed through connection {@link Pool pools}. ClientCacheFactory creates a single pool to use by default on the cache it creates. ClientCacheFactory can also be used to configure the default connection pool using its <code>setPool*</code> and <code>addPool*</code> methods. In most cases, the defaults used by this implementation will suffice. For the default pool attributes see {@link PoolFactory}.
-If no pool is configured and a pool was not declared in cache.xml or created using {@link PoolManager} then a default one will be created that connects to a server on the default cache server port and local host. If multiple pools are declared in cache.xml or created by the PoolFactory then no default pool will exist and <code>ClientRegionFactory.setPoolName</code> will need to be called on each region created.
-<p>
-To get the existing unclosed singleton client cache instance call {@link #getAnyInstance}.
-<p>
-The following examples illustrate bootstrapping the client cache using region shortcuts:
-<p>
-Example 1: Connect to a CacheServer on the default host and port and access a region "customers"
-<PRE>
-  ClientCache c = new ClientCacheFactory().create();
-  Region r = c.createClientRegionFactory(PROXY).create("customers");
-  // The PROXY shortcut tells GemFire to route all requests to the servers
-  //. i.e. there is no local caching
-</PRE>
-Example 2: Connect using the GemFire locator and create a local LRU cache
-<PRE>
-  ClientCache c = new ClientCacheFactory()
-      .addPoolLocator(host, port)
-      .create();
-  Region r = c.createClientRegionFactory(CACHING_PROXY_HEAP_LRU)
-      .create("customers");
-  // The local LRU "customers" data region will automatically start evicting, by default, at 80% heap utilization threshold
-</PRE>
-Example 3: Access the query service
-<PRE>
-  QueryService qs = new ClientCacheFactory().create().getQueryService();
-</PRE>
-Example 4: Construct the client cache region declaratively in cache.xml
-<PRE>
-  &lt;!DOCTYPE client-cache PUBLIC
-    "-//GemStone Systems, Inc.//GemFire Declarative Caching 6.5//EN"
-    "http://www.gemstone.com/dtd/cache8_0.dtd">
-  &lt;client-cache>	
-    &lt;pool name="myPool">
-      &lt;locator host="hostName" port="10334"/>
-    &lt;/pool>
-    &lt;region name="myRegion" refid="PROXY"/>
-      &lt;!-- you can override or add to the PROXY attributes by adding
-           a region-attributes sub element here -->
-  &lt;/client-cache>
-</PRE>
-Now, create the cache telling it to read your cache.xml file:
-<PRE>
-  ClientCache c = new ClientCacheFactory()
-    .set("cache-xml-file", "myCache.xml")
-    .create();
-  Region r = c.getRegion("myRegion");
-</PRE>
-
-<p> For a complete list of all client region shortcuts see {@link ClientRegionShortcut}. 
-Applications that need to explicitly control the individual region attributes can do this declaratively in XML or using API.
-<p>
-Example 5: Define custom region attributes for persistence in XML and create region using API.
-  Define new region attributes with ID "MYAPP_CACHING_PROXY_MEM_LRU" that overrides the 
-  "CACHING_PROXY" shortcut
-<PRE>
- &lt;!DOCTYPE client-cache PUBLIC
-    "-//GemStone Systems, Inc.//GemFire Declarative Caching 8.0//EN"
-    "http://www.gemstone.com/dtd/cache8_0.dtd">
- &lt;client-cache>
-  &lt;!-- now create a named region attributes that uses the CACHING_PROXY shortcut
-       and adds a memory LRU limited to 900 megabytes --> 
-  &lt;region-attributes id="MYAPP_CACHING_PROXY_MEM_LRU" refid="CACHING_PROXY" >
-    &lt;lru-memory-size maximum="900"/>
-  &lt;/region-attributes>
- &lt;/client-cache> 
-</PRE>
-Now, create the data region in the client cache using this new attributes ID.
-<PRE>
-  ClientCache c = new ClientCacheFactory()
-    .set("cache-xml-file", "myCache.xml")
-    .addPoolLocator(host, port)
-    .create();
-  Region r = c.createClientRegionFactory("MYAPP_CACHING_PROXY_MEM_LRU").create("customers");
-</PRE>
+ * Factory class used to create the singleton {@link ClientCache client cache} and connect to one or more GemFire Cache Servers. If the application wants to connect to GemFire as a peer it should use {@link com.gemstone.gemfire.cache.CacheFactory} instead.
+ * <p> Once the factory has been configured using its set* methods you produce a {@link ClientCache} by calling the {@link #create} method.
+ * The {@link com.gemstone.gemfire.distributed.ConfigurationProperties#CACHE_XML_FILE}
+ * property can be used to specify a cache.xml file to initialize the cache with.
+ * The contents of this file must comply with the
+ * <code>"doc-files/cache8_0.dtd"</code> file and the top level element must be a <code>client-cache</code> element.
+ * <p> Client connections are managed through connection {@link Pool pools}. ClientCacheFactory creates a single pool to use by default on the cache it creates. ClientCacheFactory can also be used to configure the default connection pool using its <code>setPool*</code> and <code>addPool*</code> methods. In most cases, the defaults used by this implementation will suffice. For the default pool attributes see {@link PoolFactory}.
+ * If no pool is configured and a pool was not declared in cache.xml or created using {@link PoolManager} then a default one will be created that connects to a server on the default cache server port and local host. If multiple pools are declared in cache.xml or created by the PoolFactory then no default pool will exist and <code>ClientRegionFactory.setPoolName</code> will need to be called on each region created.
+ * <p>
+ * To get the existing unclosed singleton client cache instance call {@link #getAnyInstance}.
+ * <p>
+ * The following examples illustrate bootstrapping the client cache using region shortcuts:
+ * <p>
+ * Example 1: Connect to a CacheServer on the default host and port and access a region "customers"
+ * <PRE>
+ * ClientCache c = new ClientCacheFactory().create();
+ * Region r = c.createClientRegionFactory(PROXY).create("customers");
+ * // The PROXY shortcut tells GemFire to route all requests to the servers
+ * //. i.e. there is no local caching
+ * </PRE>
+ * Example 2: Connect using the GemFire locator and create a local LRU cache
+ * <PRE>
+ * ClientCache c = new ClientCacheFactory()
+ * .addPoolLocator(host, port)
+ * .create();
+ * Region r = c.createClientRegionFactory(CACHING_PROXY_HEAP_LRU)
+ * .create("customers");
+ * // The local LRU "customers" data region will automatically start evicting, by default, at 80% heap utilization threshold
+ * </PRE>
+ * Example 3: Access the query service
+ * <PRE>
+ * QueryService qs = new ClientCacheFactory().create().getQueryService();
+ * </PRE>
+ * Example 4: Construct the client cache region declaratively in cache.xml
+ * <PRE>
+ * &lt;!DOCTYPE client-cache PUBLIC
+ * "-//GemStone Systems, Inc.//GemFire Declarative Caching 6.5//EN"
+ * "http://www.gemstone.com/dtd/cache8_0.dtd">
+ * &lt;client-cache>
+ * &lt;pool name="myPool">
+ * &lt;locator host="hostName" port="10334"/>
+ * &lt;/pool>
+ * &lt;region name="myRegion" refid="PROXY"/>
+ * &lt;!-- you can override or add to the PROXY attributes by adding
+ * a region-attributes sub element here -->
+ * &lt;/client-cache>
+ * </PRE>
+ * Now, create the cache telling it to read your cache.xml file:
+ * <PRE>
+ * ClientCache c = new ClientCacheFactory()
+ * .set("cache-xml-file", "myCache.xml")
+ * .create();
+ * Region r = c.getRegion("myRegion");
+ * </PRE>
+ * <p>
+ * <p> For a complete list of all client region shortcuts see {@link ClientRegionShortcut}.
+ * Applications that need to explicitly control the individual region attributes can do this declaratively in XML or using API.
+ * <p>
+ * Example 5: Define custom region attributes for persistence in XML and create region using API.
+ * Define new region attributes with ID "MYAPP_CACHING_PROXY_MEM_LRU" that overrides the
+ * "CACHING_PROXY" shortcut
+ * <PRE>
+ * &lt;!DOCTYPE client-cache PUBLIC
+ * "-//GemStone Systems, Inc.//GemFire Declarative Caching 8.0//EN"
+ * "http://www.gemstone.com/dtd/cache8_0.dtd">
+ * &lt;client-cache>
+ * &lt;!-- now create a named region attributes that uses the CACHING_PROXY shortcut
+ * and adds a memory LRU limited to 900 megabytes -->
+ * &lt;region-attributes id="MYAPP_CACHING_PROXY_MEM_LRU" refid="CACHING_PROXY" >
+ * &lt;lru-memory-size maximum="900"/>
+ * &lt;/region-attributes>
+ * &lt;/client-cache>
+ * </PRE>
+ * Now, create the data region in the client cache using this new attributes ID.
+ * <PRE>
+ * ClientCache c = new ClientCacheFactory()
+ * .set("cache-xml-file", "myCache.xml")
+ * .addPoolLocator(host, port)
+ * .create();
+ * Region r = c.createClientRegionFactory("MYAPP_CACHING_PROXY_MEM_LRU").create("customers");
+ * </PRE>
+ *
-  
+
-  
+
+
+   *
-   * These properties can be overridden using the {@link #set} method
-   * For a full list of valid gemfire properties see {@link com.gemstone.gemfire.distributed.DistributedSystem}.
+   *              These properties can be overridden using the {@link #set} method
+   *              For a full list of valid gemfire properties see {@link com.gemstone.gemfire.distributed.ConfigurationProperties}.
-   * For a full list of valid gemfire properties see {@link com.gemstone.gemfire.distributed.DistributedSystem}.
-   * @param name the name of the gemfire property
+   * For a full list of valid gemfire properties see {@link com.gemstone.gemfire.distributed.ConfigurationProperties}.
+   *
+   * @param name  the name of the gemfire property
-   * <p> While creating the cache instance any declarative cache configuration (cache.xml) 
+   * <p> While creating the cache instance any declarative cache configuration (cache.xml)
-   * 
+   *
-   * 
-   * @throws CacheXmlException
-   *         If a problem occurs while parsing the declarative caching
-   *         XML file.
-   * @throws TimeoutException
-   *         If a {@link Region#put(Object, Object)} times out while initializing the
-   *         cache.
-   * @throws CacheWriterException
-   *         If a <code>CacheWriterException</code> is thrown while
-   *         initializing the cache.
-   * @throws RegionExistsException
-   *         If the declarative caching XML file describes a region
-   *         that already exists (including the root region).
-   * @throws IllegalStateException if a client cache already exists and it
-   *         is not compatible with this factory's configuration.
-   * @throws IllegalStateException if mcast-port or locator is set on client cache.
-   * @throws AuthenticationFailedException if authentication fails.
+   * @throws CacheXmlException               If a problem occurs while parsing the declarative caching
+   *                                         XML file.
+   * @throws TimeoutException                If a {@link Region#put(Object, Object)} times out while initializing the
+   *                                         cache.
+   * @throws CacheWriterException            If a <code>CacheWriterException</code> is thrown while
+   *                                         initializing the cache.
+   * @throws RegionExistsException           If the declarative caching XML file describes a region
+   *                                         that already exists (including the root region).
+   * @throws IllegalStateException           if a client cache already exists and it
+   *                                         is not compatible with this factory's configuration.
+   * @throws IllegalStateException           if mcast-port or locator is set on client cache.
+   * @throws AuthenticationFailedException   if authentication fails.
-   *         is not configured with security credentials.
+   *                                         is not configured with security credentials.
-    GemFireCacheImpl instance = GemFireCacheImpl.getInstance();
+      GemFireCacheImpl instance = GemFireCacheImpl.getInstance();
-    {
-      String propValue = this.dsProps.getProperty("mcast-port");
-      if (propValue != null) {
-        int mcastPort = Integer.parseInt(propValue);
-        if (mcastPort != 0) {
-          throw new IllegalStateException("On a client cache the mcast-port must be set to 0 or not set. It was set to " + mcastPort);
+      {
+        String propValue = this.dsProps.getProperty(MCAST_PORT);
+        if (propValue != null) {
+          int mcastPort = Integer.parseInt(propValue);
+          if (mcastPort != 0) {
+            throw new IllegalStateException("On a client cache the mcast-port must be set to 0 or not set. It was set to " + mcastPort);
+          }
-    }
-    {
-      String propValue = this.dsProps.getProperty("locators");
-      if (propValue != null && !propValue.equals("")) {
-        throw new IllegalStateException("On a client cache the locators property must be set to an empty string or not set. It was set to \"" + propValue + "\".");
-      }
-    }
-    this.dsProps.setProperty("mcast-port", "0");
-    this.dsProps.setProperty("locators", "");
-    DistributedSystem system = DistributedSystem.connect(this.dsProps);
-
-    if (instance != null && !instance.isClosed()) {
-      // this is ok; just make sure it is a client cache
-      if (!instance.isClient()) {
-        throw new IllegalStateException("A client cache can not be created because a non-client cache already exists.");
-      }
-
-      // check if pool is compatible
-      Pool pool = instance.determineDefaultPool(this.pf);
-      if (pool == null) {
-        if (instance.getDefaultPool() != null) {
-          throw new IllegalStateException("Existing cache's default pool was not compatible");
+      {
+        String propValue = this.dsProps.getProperty(LOCATORS);
+        if (propValue != null && !propValue.equals("")) {
+          throw new IllegalStateException(
+              "On a client cache the locators property must be set to an empty string or not set. It was set to \"" + propValue + "\".");
-      
-      // Check if cache configuration matches.
-      cacheConfig.validateCacheConfig(instance);
-      
-      return instance;
-    } else {
-      GemFireCacheImpl gfc = GemFireCacheImpl.createClient(system, this.pf, cacheConfig);
-      return gfc;
-    }
+      this.dsProps.setProperty(MCAST_PORT, "0");
+      this.dsProps.setProperty(LOCATORS, "");
+      DistributedSystem system = DistributedSystem.connect(this.dsProps);
+
+      if (instance != null && !instance.isClosed()) {
+        // this is ok; just make sure it is a client cache
+        if (!instance.isClient()) {
+          throw new IllegalStateException("A client cache can not be created because a non-client cache already exists.");
+        }
+
+        // check if pool is compatible
+        Pool pool = instance.determineDefaultPool(this.pf);
+        if (pool == null) {
+          if (instance.getDefaultPool() != null) {
+            throw new IllegalStateException("Existing cache's default pool was not compatible");
+          }
+        }
+
+        // Check if cache configuration matches.
+        cacheConfig.validateCacheConfig(instance);
+
+        return instance;
+      } else {
+        GemFireCacheImpl gfc = GemFireCacheImpl.createClient(system, this.pf, cacheConfig);
+        return gfc;
+      }
-  
+
-   * an {@link AllConnectionsInUseException}. If max connections 
+   * an {@link AllConnectionsInUseException}. If max connections
-   * @see #setPoolMaxConnections(int)
+   *
-   * is less than or equal to <code>0</code>.
+   *                                  is less than or equal to <code>0</code>.
+   * @see #setPoolMaxConnections(int)
+
-   * This interval controls how frequently the pool will check to see if 
+   * This interval controls how frequently the pool will check to see if
-   * server to improve the load balance.  
+   * server to improve the load balance.
+   *
-   * is less than <code>-1</code>.
+   *                                  is less than <code>-1</code>.
+   *
-   * writing on each connection in this pool.
+   *                   writing on each connection in this pool.
-   * is less than or equal to <code>0</code>.
+   *                                  is less than or equal to <code>0</code>.
+   *
-   * connections.
+   *                               connections.
-  
+   *
-   * is less than <code>0</code>.
+   *                                  is less than <code>0</code>.
-  
-   * When the pool is created, it will create this many connections. 
+   * When the pool is created, it will create this many connections.
+   *
-   * this pool will create.
+   *                       this pool will create.
-   * is less than <code>0</code>.
+   *                                  is less than <code>0</code>.
-  
-   * Set the max number of client to server connections that the pool will create. If all of 
+   * Set the max number of client to server connections that the pool will create. If all of
-   * @see #setPoolFreeConnectionTimeout(int) 
+   *
-   * this pool will create. -1 indicates that there is no maximum number of connections
+   *                       this pool will create. -1 indicates that there is no maximum number of connections
-   * is less than <code>minConnections</code>.
+   *                                  is less than <code>minConnections</code>.
+   * @see #setPoolFreeConnectionTimeout(int)
-  
-   * If the pool size is greater than the minimum specified by 
+   * If the pool size is greater than the minimum specified by
-   * for longer than the idleTimeout will be closed. 
+   * for longer than the idleTimeout will be closed.
+   *
-   * should live before expiring. -1 indicates that connections should never expire.
+   *                    should live before expiring. -1 indicates that connections should never expire.
-   * is less than <code>-1</code>.
+   *                                  is less than <code>-1</code>.
-  
-   * @param retryAttempts The number of times to retry a request 
-   * after timeout/exception. -1 indicates that a request should be 
-   * tried against every available server before failing
+   *
+   * @param retryAttempts The number of times to retry a request
+   *                      after timeout/exception. -1 indicates that a request should be
+   *                      tried against every available server before failing
-   * is less than <code>-1</code>.
+   *                                  is less than <code>-1</code>.
-  
-   * 
+   * <p>
-   * the client. Make sure that the pingInterval is less than the 
+   * the client. Make sure that the pingInterval is less than the
+   *
-   * pings.
+   *                     pings.
-   * is less than or equal to <code>0</code>.
+   *                                  is less than or equal to <code>0</code>.
-
-   * 
+   *
-   * sends of client statistics to the server.
+   *                          sends of client statistics to the server.
-   * is less than <code>-1</code>.
+   *                                  is less than <code>-1</code>.
-
+   *
-   * If <code>null</code> or <code>""</code> then all servers will be connected to.
+   *              If <code>null</code> or <code>""</code> then all servers will be connected to.
-
+   *
-   * the valid range of [0..65535] inclusive.
-   * @throws IllegalStateException if a server has already been {@link #addPoolServer added} to this factory.
+   *                                  the valid range of [0..65535] inclusive.
+   * @throws IllegalStateException    if a server has already been {@link #addPoolServer added} to this factory.
-
+   *
-   * the valid range of [0..65535] inclusive.
-   * @throws IllegalStateException if a locator has already been {@link #addPoolLocator added} to this factory.
+   *                                  the valid range of [0..65535] inclusive.
+   * @throws IllegalStateException    if a locator has already been {@link #addPoolLocator added} to this factory.
-
+   *
-  
+   *
-   * is less than <code>-1</code>.
+   *                                  is less than <code>-1</code>.
+   *
-   * is less than or equal to <code>0</code>.
+   *                                  is less than or equal to <code>0</code>.
-  
-   * 
+   *
-   * acknowledgements.
+   *                    acknowledgements.
-   * is less than or equal to <code>0</code>.
+   *                                  is less than or equal to <code>0</code>.
-
-   * This mode works best 
+   * This mode works best
-   *  with
+   * with
-   * 
+   *
-
-   * 
+   *
-
-  /** Returns the version of the cache implementation.
+  /**
+   * Returns the version of the cache implementation.
+   *
+
-   * @throws CacheClosedException if a cache has not been created
-   * or the only created one is {@link ClientCache#isClosed closed}
+   *
+   * @throws CacheClosedException  if a cache has not been created
+   *                               or the only created one is {@link ClientCache#isClosed closed}
-   * of ClientCacheFactory
+   *                               of ClientCacheFactory
-  
-  /** Sets the object preference to PdxInstance type.
+
+  /**
+   * Sets the object preference to PdxInstance type.
-   * The PdxInstance is an interface that provides run time access to 
-   * the fields of a PDX without deserializing the entire PDX. 
-   * The PdxInstance implementation is a light weight wrapper 
-   * that simply refers to the raw bytes of the PDX that are kept 
-   * in the cache. Using this method applications can choose to 
+   * The PdxInstance is an interface that provides run time access to
+   * the fields of a PDX without deserializing the entire PDX.
+   * The PdxInstance implementation is a light weight wrapper
+   * that simply refers to the raw bytes of the PDX that are kept
+   * in the cache. Using this method applications can choose to
-   *  @since 6.6
+   *  @since GemFire 6.6
-  
+
-   * it will be consulted to see if it can serialize any domain classes which are 
-   * added to the cache in portable data exchange format. 
+   * it will be consulted to see if it can serialize any domain classes which are
+   * added to the cache in portable data exchange format.
+   *
-   * @since 6.6
+   * @since GemFire 6.6
-  
+
-   * 
+   * <p>
+   *
-   * for the PDX metadata.
+   *                      for the PDX metadata.
-   * @since 6.6
+   * @since GemFire 6.6
-   * The default for this setting is false. 
+   * The default for this setting is false.
-   * 
+   *
-   * @since 6.6
+   * @since GemFire 6.6
+
-   * of preserving the unread fields since you will never be reserializing pdx data. 
-   * 
+   * of preserving the unread fields since you will never be reserializing pdx data.
+   *
-   * <code>false</code>, the default, if they should be preserved.
+   *               <code>false</code>, the default, if they should be preserved.
-   * @since 6.6
+   * @since GemFire 6.6
-  
+

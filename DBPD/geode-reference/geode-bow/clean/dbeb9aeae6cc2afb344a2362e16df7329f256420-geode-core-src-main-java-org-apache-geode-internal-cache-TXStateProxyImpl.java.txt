Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-   * for client/server JTA transactions we need to have a single thread handle
-   * both beforeCompletion and afterCompletion so that beforeC can obtain
-   * locks for the afterC step.  This is that thread
+   * for client/server JTA transactions we need to have a single thread handle both beforeCompletion
+   * and afterCompletion so that beforeC can obtain locks for the afterC step. This is that thread
-  
+
-  
+
-  
+
-  
+
+   * 
-  
-  
+
+
-   * This returns either the TXState for the current transaction or
-   * a proxy for the state if it is held in another member.  If no
-   * state currently exists, one is created
+   * This returns either the TXState for the current transaction or a proxy for the state if it is
+   * held in another member. If no state currently exists, one is created
+   * 
-      if (r == null) {  // TODO: stop gap to get tests working
-        this.realDeal = new TXState(this,false);
+      if (r == null) { // TODO: stop gap to get tests working
+        this.realDeal = new TXState(this, false);
-        if(r.hasServerProxy()) {
+        if (r.hasServerProxy()) {
-              logger.warn(LocalizedMessage.create(LocalizedStrings.TXStateProxyImpl_Distributed_Region_In_Client_TX, r.getFullPath()));
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.TXStateProxyImpl_Distributed_Region_In_Client_TX,
+                  r.getFullPath()));
-          if (target==null || target.equals(this.txMgr.getDM().getId())) {
-            this.realDeal = new TXState(this,false);   
+          if (target == null || target.equals(this.txMgr.getDM().getId())) {
+            this.realDeal = new TXState(this, false);
-             this.realDeal = new PeerTXStateStub(this, target,onBehalfOfClientMember);
+            this.realDeal = new PeerTXStateStub(this, target, onBehalfOfClientMember);
-    return this.realDeal;   
+    return this.realDeal;
-  
+
-         * txtodo: // what to do!!
-         * We don't know if this is client or server!!!
+         * txtodo: // what to do!! We don't know if this is client or server!!!
-        this.realDeal = new PeerTXStateStub(this, target,onBehalfOfClientMember);
+        this.realDeal = new PeerTXStateStub(this, target, onBehalfOfClientMember);
-  public TXStateProxyImpl(TXManagerImpl managerImpl, TXId id,InternalDistributedMember clientMember) {
+  public TXStateProxyImpl(TXManagerImpl managerImpl, TXId id,
+      InternalDistributedMember clientMember) {
-  
+
-  
+
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  public void precommit() throws CommitConflictException,
-      UnsupportedOperationInTransactionException {
+  public void precommit()
+      throws CommitConflictException, UnsupportedOperationInTransactionException {
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-      TransactionException ex = new TransactionDataNotColocatedException(LocalizedStrings.
-          PartitionedRegion_KEY_0_NOT_COLOCATED_WITH_TRANSACTION.toLocalizedString(keyInfo.getKey()));
+      TransactionException ex = new TransactionDataNotColocatedException(
+          LocalizedStrings.PartitionedRegion_KEY_0_NOT_COLOCATED_WITH_TRANSACTION
+              .toLocalizedString(keyInfo.getKey()));
-        return new TransactionDataRebalancedException(LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
-            .toLocalizedString());
+        return new TransactionDataRebalancedException(
+            LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
+                .toLocalizedString());
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#containsValueForKey(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#containsValueForKey(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#destroyExistingEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, java.lang.Object)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#destroyExistingEntry(org.apache.geode.internal
+   * .cache.EntryEventImpl, boolean, java.lang.Object)
-      getRealDeal(event.getKeyInfo(), event.getLocalRegion()).destroyExistingEntry(event, cacheWrite, expectedOldValue);
+      getRealDeal(event.getKeyInfo(), event.getLocalRegion()).destroyExistingEntry(event,
+          cacheWrite, expectedOldValue);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#getDeserializedValue(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#getDeserializedValue(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public Object getDeserializedValue(KeyInfo keyInfo,
-                                     LocalRegion localRegion,
-                                     boolean updateStats,
-                                     boolean disableCopyOnRead,
-                                     boolean preferCD,
-                                     EntryEventImpl clientEvent,
-                                     boolean returnTombstones,
-                                     boolean retainResult) {
-    Object val = getRealDeal(keyInfo, localRegion).getDeserializedValue(keyInfo, localRegion, updateStats, disableCopyOnRead, preferCD, null, false,
-      retainResult);
+  public Object getDeserializedValue(KeyInfo keyInfo, LocalRegion localRegion, boolean updateStats,
+      boolean disableCopyOnRead, boolean preferCD, EntryEventImpl clientEvent,
+      boolean returnTombstones, boolean retainResult) {
+    Object val = getRealDeal(keyInfo, localRegion).getDeserializedValue(keyInfo, localRegion,
+        updateStats, disableCopyOnRead, preferCD, null, false, retainResult);
-      // fixes bug 51057: TXStateStub  on client always returns null, so do not increment
+      // fixes bug 51057: TXStateStub on client always returns null, so do not increment
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#getEntry(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#getEntry(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#invalidateExistingEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#invalidateExistingEntry(org.apache.geode.
+   * internal.cache.EntryEventImpl, boolean, boolean)
-  public void invalidateExistingEntry(EntryEventImpl event,
-      boolean invokeCallbacks, boolean forceNewEntry) {
+  public void invalidateExistingEntry(EntryEventImpl event, boolean invokeCallbacks,
+      boolean forceNewEntry) {
-      getRealDeal(event.getKeyInfo(), event.getLocalRegion()).invalidateExistingEntry(event, invokeCallbacks, forceNewEntry);
+      getRealDeal(event.getKeyInfo(), event.getLocalRegion()).invalidateExistingEntry(event,
+          invokeCallbacks, forceNewEntry);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#readRegion(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#readRegion(org.apache.geode.internal.cache.
+   * LocalRegion)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#rmRegion(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#rmRegion(org.apache.geode.internal.cache.
+   * LocalRegion)
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#txPutEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#txPutEntry(org.apache.geode.internal.cache.
+   * EntryEventImpl, boolean, boolean, boolean)
-  public boolean txPutEntry(EntryEventImpl event, boolean ifNew,
-      boolean requireOldValue, boolean checkResources, Object expectedOldValue) {
+  public boolean txPutEntry(EntryEventImpl event, boolean ifNew, boolean requireOldValue,
+      boolean checkResources, Object expectedOldValue) {
-      boolean retVal = getRealDeal(event.getKeyInfo(), (LocalRegion)event.getRegion()).txPutEntry(event, ifNew, requireOldValue, checkResources, expectedOldValue);
+      boolean retVal = getRealDeal(event.getKeyInfo(), (LocalRegion) event.getRegion())
+          .txPutEntry(event, ifNew, requireOldValue, checkResources, expectedOldValue);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#txReadEntry(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#txReadEntry(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion,
-      boolean rememberRead,boolean createTxEntryIfAbsent) {
+  public TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion, boolean rememberRead,
+      boolean createTxEntryIfAbsent) {
-      TXEntryState retVal = getRealDeal(keyInfo, localRegion).txReadEntry(keyInfo, localRegion, 
-          rememberRead,createTxEntryIfAbsent);
+      TXEntryState retVal = getRealDeal(keyInfo, localRegion).txReadEntry(keyInfo, localRegion,
+          rememberRead, createTxEntryIfAbsent);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#txReadRegion(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#txReadRegion(org.apache.geode.internal.cache.
+   * LocalRegion)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#txWriteRegion(org.apache.geode.internal.cache.LocalRegion, java.lang.Object)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#txWriteRegion(org.apache.geode.internal.cache.
+   * LocalRegion, java.lang.Object)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#writeRegion(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#writeRegion(org.apache.geode.internal.cache.
+   * LocalRegion)
-    assert realDeal!=null;
+    assert realDeal != null;
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    getRealDeal(null, null).beforeCompletion();    
+    getRealDeal(null, null).beforeCompletion();
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#containsKey(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#containsKey(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#entryCount(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#entryCount(org.apache.geode.internal.cache.
+   * LocalRegion)
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="UL_UNRELEASED_LOCK", justification="This method unlocks and then conditionally undoes the unlock in the finally-block. Review again at later time.") 
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "UL_UNRELEASED_LOCK",
+      justification = "This method unlocks and then conditionally undoes the unlock in the finally-block. Review again at later time.")
-    	txp = getTxMgr().internalSuspend();
+      txp = getTxMgr().internalSuspend();
-      if(resetTXState) {
-    	return localRegion.getSharedDataView().entryCount(localRegion);
+      if (resetTXState) {
+        return localRegion.getSharedDataView().entryCount(localRegion);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#findObject(org.apache.geode.internal.cache.LocalRegion, java.lang.Object, java.lang.Object, boolean, boolean, java.lang.Object)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#findObject(org.apache.geode.internal.cache.
+   * LocalRegion, java.lang.Object, java.lang.Object, boolean, boolean, java.lang.Object)
-  public Object findObject(KeyInfo key, LocalRegion r, boolean isCreate,
-                           boolean generateCallbacks, Object value, boolean disableCopyOnRead,
-                           boolean preferCD, ClientProxyMembershipID requestingClient,
-                           EntryEventImpl clientEvent, boolean returnTombstones) {
+  public Object findObject(KeyInfo key, LocalRegion r, boolean isCreate, boolean generateCallbacks,
+      Object value, boolean disableCopyOnRead, boolean preferCD,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) {
-      Object retVal = getRealDeal(key, r).findObject(key, r, isCreate, generateCallbacks,
-          value, disableCopyOnRead, preferCD, requestingClient, clientEvent, false);
+      Object retVal = getRealDeal(key, r).findObject(key, r, isCreate, generateCallbacks, value,
+          disableCopyOnRead, preferCD, requestingClient, clientEvent, false);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getAdditionalKeysForIterator(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getAdditionalKeysForIterator(org.apache.geode.
+   * internal.cache.LocalRegion)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getEntryForIterator(org.apache.geode.internal.cache.LocalRegion, java.lang.Object, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getEntryForIterator(org.apache.geode.internal.
+   * cache.LocalRegion, java.lang.Object, boolean)
-  public Object getEntryForIterator(KeyInfo key, LocalRegion currRgn,
-      boolean rememberReads, boolean allowTombstones) {
+  public Object getEntryForIterator(KeyInfo key, LocalRegion currRgn, boolean rememberReads,
+      boolean allowTombstones) {
-    if(resetTxState) {
-    	txp = getTxMgr().internalSuspend();
+    if (resetTxState) {
+      txp = getTxMgr().internalSuspend();
-      return getRealDeal(key, currRgn).getEntryForIterator(key, currRgn, rememberReads, allowTombstones);
+      return getRealDeal(key, currRgn).getEntryForIterator(key, currRgn, rememberReads,
+          allowTombstones);
-    
+
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getKeyForIterator(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#getKeyForIterator(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public Object getKeyForIterator(KeyInfo keyInfo, LocalRegion currRgn,
-      boolean rememberReads, boolean allowTombstones) {
+  public Object getKeyForIterator(KeyInfo keyInfo, LocalRegion currRgn, boolean rememberReads,
+      boolean allowTombstones) {
-    if(resetTxState) {
-        txp = getTxMgr().internalSuspend();
+    if (resetTxState) {
+      txp = getTxMgr().internalSuspend();
-        return currRgn.getSharedDataView().getKeyForIterator(keyInfo, currRgn, rememberReads, allowTombstones);
+        return currRgn.getSharedDataView().getKeyForIterator(keyInfo, currRgn, rememberReads,
+            allowTombstones);
-      return getRealDeal(keyInfo, currRgn).getKeyForIterator(keyInfo, currRgn, rememberReads, allowTombstones);
+      return getRealDeal(keyInfo, currRgn).getKeyForIterator(keyInfo, currRgn, rememberReads,
+          allowTombstones);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getValueInVM(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#getValueInVM(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public Object getValueInVM(KeyInfo keyInfo, LocalRegion localRegion,
-      boolean rememberRead) {
+  public Object getValueInVM(KeyInfo keyInfo, LocalRegion localRegion, boolean rememberRead) {
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#putEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#putEntry(org.apache.geode.internal.cache.
+   * EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
-      boolean retVal = getRealDeal(event.getKeyInfo(), event.getLocalRegion()).putEntry(event, ifNew,
-            ifOld, expectedOldValue, requireOldValue, lastModified, overwriteDestroyed);
+      boolean retVal = getRealDeal(event.getKeyInfo(), event.getLocalRegion()).putEntry(event,
+          ifNew, ifOld, expectedOldValue, requireOldValue, lastModified, overwriteDestroyed);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#isInProgressAndSameAs(org.apache.geode.internal.cache.TXStateInterface)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#isInProgressAndSameAs(org.apache.geode.
+   * internal.cache.TXStateInterface)
-    return isInProgress() && otherState == this; 
+    return isInProgress() && otherState == this;
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateProxy#setLocalTXState(org.apache.geode.internal.cache.TXState)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateProxy#setLocalTXState(org.apache.geode.internal.cache.
+   * TXState)
-   * @see org.apache.geode.internal.cache.InternalDataView#getSerializedValue(org.apache.geode.internal.cache.LocalRegion, java.lang.Object, java.lang.Object)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getSerializedValue(org.apache.geode.internal.
+   * cache.LocalRegion, java.lang.Object, java.lang.Object)
-  public Object getSerializedValue(LocalRegion localRegion,
-                                   KeyInfo key,
-                                   boolean doNotLockEntry,
-                                   ClientProxyMembershipID requestingClient,
-                                   EntryEventImpl clientEvent,
-                                   boolean returnTombstones) throws DataLocationException {
+  public Object getSerializedValue(LocalRegion localRegion, KeyInfo key, boolean doNotLockEntry,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) throws DataLocationException {
-    return getRealDeal(key, localRegion).getSerializedValue(localRegion, key, doNotLockEntry, requestingClient, clientEvent, returnTombstones);
+    return getRealDeal(key, localRegion).getSerializedValue(localRegion, key, doNotLockEntry,
+        requestingClient, clientEvent, returnTombstones);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#putEntryOnRemote(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#putEntryOnRemote(org.apache.geode.internal.
+   * cache.EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
-  public boolean putEntryOnRemote(EntryEventImpl event, boolean ifNew,
-      boolean ifOld, Object expectedOldValue, boolean requireOldValue,
-      long lastModified, boolean overwriteDestroyed)
-      throws DataLocationException {
+  public boolean putEntryOnRemote(EntryEventImpl event, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue, long lastModified,
+      boolean overwriteDestroyed) throws DataLocationException {
-    return tx.putEntryOnRemote(event, ifNew, ifOld, expectedOldValue, requireOldValue, lastModified, overwriteDestroyed);
-  }
-  
-  public boolean isFireCallbacks() {
-    return getRealDeal(null,null).isFireCallbacks();
+    return tx.putEntryOnRemote(event, ifNew, ifOld, expectedOldValue, requireOldValue, lastModified,
+        overwriteDestroyed);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#destroyOnRemote(java.lang.Integer, org.apache.geode.internal.cache.EntryEventImpl, java.lang.Object)
+  public boolean isFireCallbacks() {
+    return getRealDeal(null, null).isFireCallbacks();
+  }
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#destroyOnRemote(java.lang.Integer,
+   * org.apache.geode.internal.cache.EntryEventImpl, java.lang.Object)
-  public void destroyOnRemote(EntryEventImpl event, boolean cacheWrite,
-      Object expectedOldValue) throws DataLocationException {
+  public void destroyOnRemote(EntryEventImpl event, boolean cacheWrite, Object expectedOldValue)
+      throws DataLocationException {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#invalidateOnRemote(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#invalidateOnRemote(org.apache.geode.internal.
+   * cache.EntryEventImpl, boolean, boolean)
-  
-  public void checkSupportsRegionDestroy()
-    throws UnsupportedOperationInTransactionException {
-    throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_REGION_DESTROY_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
+
+  public void checkSupportsRegionDestroy() throws UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.TXState_REGION_DESTROY_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
-  
-  public void checkSupportsRegionInvalidate()
-    throws UnsupportedOperationInTransactionException {
-    throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_REGION_INVALIDATE_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
+
+  public void checkSupportsRegionInvalidate() throws UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.TXState_REGION_INVALIDATE_NOT_SUPPORTED_IN_A_TRANSACTION
+            .toLocalizedString());
-  public void checkSupportsRegionClear()
-      throws UnsupportedOperationInTransactionException {
-    throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_REGION_CLEAR_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
+  public void checkSupportsRegionClear() throws UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.TXState_REGION_CLEAR_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getBucketKeys(org.apache.geode.internal.cache.LocalRegion, int)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getBucketKeys(org.apache.geode.internal.cache.
+   * LocalRegion, int)
-    //if this the first operation in a transaction, reset txState
+    // if this the first operation in a transaction, reset txState
-    if(resetTxState) {
-    	txp = getTxMgr().internalSuspend();
+    if (resetTxState) {
+      txp = getTxMgr().internalSuspend();
-      if(resetTxState) {
-    	return localRegion.getSharedDataView().getBucketKeys(localRegion, bucketId, false);
+      if (resetTxState) {
+        return localRegion.getSharedDataView().getBucketKeys(localRegion, bucketId, false);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getEntryOnRemote(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#getEntryOnRemote(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-  
+
-    getRealDeal(null,null);
+    getRealDeal(null, null);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateProxy#setTarget(org.apache.geode.distributed.DistributedMember)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateProxy#setTarget(org.apache.geode.distributed.
+   * DistributedMember)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getRegionKeysForIteration(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getRegionKeysForIteration(org.apache.geode.
+   * internal.cache.LocalRegion)
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    }
-    else {
+    } else {
-  
+
-        return (TXState)this.realDeal;
+        return (TXState) this.realDeal;
-    builder.append("TXStateProxyImpl@").append(System.identityHashCode(this))
-    .append(" txId:").append(this.txId)
-    .append(" realDeal:"+this.realDeal)
-    .append(" isJTA:").append(isJTA);
+    builder.append("TXStateProxyImpl@").append(System.identityHashCode(this)).append(" txId:")
+        .append(this.txId).append(" realDeal:" + this.realDeal).append(" isJTA:").append(isJTA);
-    if(this.realDeal==null) {
+    if (this.realDeal == null) {
-    if(this.realDeal==null) {
+    if (this.realDeal == null) {
-    if(this.realDeal==null) {
+    if (this.realDeal == null) {
-  
-  
-  public void postPutAll(DistributedPutAllOperation putallOp, VersionedObjectList successfulPuts,LocalRegion region) {
-    if(putallOp.putAllData.length==0) {
+
+
+  public void postPutAll(DistributedPutAllOperation putallOp, VersionedObjectList successfulPuts,
+      LocalRegion region) {
+    if (putallOp.putAllData.length == 0) {
-    if(putallOp.putAllData[0]!=null) {
+    if (putallOp.putAllData[0] != null) {
-    KeyInfo ki = new KeyInfo(key,null,null);
-    TXStateInterface tsi = getRealDeal(ki,region);
+    KeyInfo ki = new KeyInfo(key, null, null);
+    TXStateInterface tsi = getRealDeal(ki, region);
+
-  public void postRemoveAll(DistributedRemoveAllOperation op, VersionedObjectList successfulOps, LocalRegion region) {
-    if(op.removeAllData.length==0) {
+  public void postRemoveAll(DistributedRemoveAllOperation op, VersionedObjectList successfulOps,
+      LocalRegion region) {
+    if (op.removeAllData.length == 0) {
-    if(op.removeAllData[0]!=null) {
+    if (op.removeAllData[0] != null) {
-    KeyInfo ki = new KeyInfo(key,null,null);
-    TXStateInterface tsi = getRealDeal(ki,region);
+    KeyInfo ki = new KeyInfo(key, null, null);
+    TXStateInterface tsi = getRealDeal(ki, region);
-  public boolean isJCATransaction()
-  {
+  public boolean isJCATransaction() {
-    
- 
-    public void setJCATransaction()
-    {
-      this.isJCATransaction = true;
-    }
-  
+
+
+  public void setJCATransaction() {
+    this.isJCATransaction = true;
+  }
+
-  
+
-  public void recordTXOperation(ServerRegionDataAccess region, ServerRegionOperation op, Object key, Object arguments[]) {
+  public void recordTXOperation(ServerRegionDataAccess region, ServerRegionOperation op, Object key,
+      Object arguments[]) {
-      getRealDeal(null, (LocalRegion)region.getRegion()).recordTXOperation(region, op, key, arguments);
+      getRealDeal(null, (LocalRegion) region.getRegion()).recordTXOperation(region, op, key,
+          arguments);
-  
+
-  public void updateEntryVersion(EntryEventImpl event)
-      throws EntryNotFoundException {
-    // Do nothing. Not applicable for transactions.    
+  public void updateEntryVersion(EntryEventImpl event) throws EntryNotFoundException {
+    // Do nothing. Not applicable for transactions.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    //only update in TXState if it has one
-    if (this.realDeal != null && this.realDeal.isRealDealLocal() 
-        && isOnBehalfOfClient()) {
-      ((TXState)this.realDeal).setProxyServer(proxy);
+    // only update in TXState if it has one
+    if (this.realDeal != null && this.realDeal.isRealDealLocal() && isOnBehalfOfClient()) {
+      ((TXState) this.realDeal).setProxyServer(proxy);

Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.cache.operations.internal.GetOperationContextImpl;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-          entry = getValueAndIsObject(region, key, callbackArg, servConn);
+          entry = getEntry(region, key, callbackArg, servConn);
-        Object data = entry.value;
+        @Retained final Object originalData = entry.value;
+        Object data = originalData;
+        try {
-            getContext = postAuthzRequest.getAuthorize(regionName, key, data,
-                isObject, getContext);
-            byte[] serializedValue = getContext.getSerializedValue();
-            if (serializedValue == null) {
-              data = getContext.getObject();
+            try {
+              getContext = postAuthzRequest.getAuthorize(regionName, key, data,
+                  isObject, getContext);
+              GetOperationContextImpl gci = (GetOperationContextImpl) getContext;
+              Object newData = gci.getRawValue();
+              if (newData != data) {
+                // user changed the value
+                isObject = getContext.isObject();
+                data = newData;
+              }
+            } finally {
+              if (getContext != null) {
+                ((GetOperationContextImpl)getContext).release();
+              }
-            else {
-              data = serializedValue;
-            }
-            isObject = getContext.isObject();
+        } finally {
+          OffHeapHelper.release(originalData);
+        }
+  /**
+   * This method was added so that Get70 could, by default,
+   * call getEntryRetained, but the subclass GetEntry70
+   * could override it and call getValueAndIsObject.
+   * If we ever get to the point that no code needs to
+   * call getValueAndIsObject then this method can go away.
+   */
+  @Retained
+  protected Entry getEntry(Region region, Object key,
+      Object callbackArg, ServerConnection servConn) {
+    return getEntryRetained(region, key, callbackArg, servConn);
+  }
+  
-    EntryEventImpl versionHolder = EntryEventImpl.createVersionTagHolder();
-      data  = ((LocalRegion) region).get(key, callbackArg, true, true, true, id, versionHolder, true);
+      EntryEventImpl versionHolder = EntryEventImpl.createVersionTagHolder();
+      try {
+        // TODO OFFHEAP: optimize
+      data  = ((LocalRegion) region).get(key, callbackArg, true, true, true, id, versionHolder, true, true /*allowReadFromHDFS*/);
+      }finally {
+        versionHolder.release();
+      }
-      {
+      if (data instanceof StoredObject && !((StoredObject) data).isSerialized()) {
+        // it is a byte[]
+        isObject = false;
+        data = ((StoredObject) data).getDeserializedForReading();
+      } else {
+  /**
+   * Same as getValueAndIsObject but the returned value can be a retained off-heap reference.
+   */
+  @Retained
+  public Entry getEntryRetained(Region region, Object key,
+      Object callbackArg, ServerConnection servConn) {
+
+//    Region.Entry entry;
+    String regionName = region.getFullPath();
+    if (servConn != null) {
+      servConn.setModificationInfo(true, regionName, key);
+    }
+    VersionTag versionTag = null;
+//    LocalRegion lregion = (LocalRegion)region;
+
+//    entry = lregion.getEntry(key, true);
+
+    boolean isObject = true;
+    @Retained Object data = null;
+
+    ClientProxyMembershipID id = servConn == null ? null : servConn.getProxyID();
+    EntryEventImpl versionHolder = EntryEventImpl.createVersionTagHolder();
+    try {
+      data = ((LocalRegion) region).getRetained(key, callbackArg, true, true, id, versionHolder, true);
+    }finally {
+      versionHolder.release();
+    }
+    versionTag = versionHolder.getVersionTag();
+    
+    // If it is Token.REMOVED, Token.DESTROYED,
+    // Token.INVALID, or Token.LOCAL_INVALID
+    // set it to null. If it is NOT_AVAILABLE, get the value from
+    // disk. If it is already a byte[], set isObject to false.
+    boolean wasInvalid = false;
+    if (data == Token.REMOVED_PHASE1 || data == Token.REMOVED_PHASE2 || data == Token.DESTROYED) {
+      data = null;
+    }
+    else if (data == Token.INVALID || data == Token.LOCAL_INVALID) {
+      data = null; // fix for bug 35884
+      wasInvalid = true;
+    }
+    else if (data instanceof byte[]) {
+      isObject = false;
+    } else if (data instanceof CachedDeserializable) {
+      if (data instanceof StoredObject) {
+        // it is off-heap so do not unwrap it.
+        if (!((StoredObject) data).isSerialized()) {
+          isObject = false;
+        }
+      } else {
+        data = ((CachedDeserializable)data).getValue();
+      }
+    }
+    Entry result = new Entry();
+    result.value = data;
+    result.isObject = isObject;
+    result.keyNotPresent = !wasInvalid && (data == null || data == Token.TOMBSTONE);
+    result.versionTag = versionTag;
+    return result;
+  }
+
-  private void writeResponse(Object data, Object callbackArg,
+  private void writeResponse(@Unretained Object data, Object callbackArg,
-    if (data instanceof byte[]) {
-      responseMsg.addRawPart((byte[])data, isObject);
-    }
-    else {
-      Assert.assertTrue(isObject,
-          "isObject should be true when value is not a byte[]");
-      responseMsg.addObjPart(data, zipValues);
-    }
+    responseMsg.addPartInAnyForm(data, isObject);
-    origMsg.flush();
+    origMsg.clearParts();
-  private void writeResponseWithRefreshMetadata(Object data,
+  private void writeResponseWithRefreshMetadata(@Unretained Object data,
-    if (data instanceof byte[]) {
-      responseMsg.addRawPart((byte[])data, isObject);
-    }
-    else {
-      Assert.assertTrue(isObject,
-          "isObject should be true when value is not a byte[]");
-      responseMsg.addObjPart(data, zipValues);
-    }
+    responseMsg.addPartInAnyForm(data, isObject);
-    origMsg.flush();
+    origMsg.clearParts();

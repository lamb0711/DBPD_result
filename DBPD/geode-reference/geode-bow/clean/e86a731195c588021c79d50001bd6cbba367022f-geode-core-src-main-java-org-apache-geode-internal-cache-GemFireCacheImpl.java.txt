Merge branch 'release/1.3.0'

+import org.apache.geode.cache.query.internal.InternalQueryService;
+import org.apache.geode.cache.query.internal.MethodInvocationAuthorizer;
+import org.apache.geode.cache.query.internal.RestrictedMethodInvocationAuthorizer;
+import org.apache.geode.internal.cache.event.EventTrackerExpiryTask;
+import org.apache.geode.internal.cache.wan.GatewaySenderQueueEntrySynchronizationListener;
+import org.apache.geode.internal.security.SecurityServiceFactory;
-import org.apache.geode.cache.client.internal.ConnectionImpl;
-import org.apache.geode.internal.cache.persistence.BackupManager;
+import org.apache.geode.internal.config.ClusterConfigurationNotAvailableException;
-import org.apache.geode.internal.process.ClusterConfigurationNotAvailableException;
+  private volatile ConfigurationResponse configurationResponse;
+
-  private final EventTracker.ExpiryTask recordedEventSweeper;
+  private final EventTrackerExpiryTask recordedEventSweeper;
-  private final SecurityService securityService = SecurityService.getSecurityService();
+  private final SecurityService securityService;
+
+  private final Set<RegionEntrySynchronizationListener> synchronizationListeners =
+      new ConcurrentHashSet<>();
-  public static GemFireCacheImpl createClient(DistributedSystem system, PoolFactory pf,
+  public static GemFireCacheImpl createClient(InternalDistributedSystem system, PoolFactory pf,
-  public static GemFireCacheImpl create(DistributedSystem system, CacheConfig cacheConfig) {
+  public static GemFireCacheImpl create(InternalDistributedSystem system, CacheConfig cacheConfig) {
-  static GemFireCacheImpl createWithAsyncEventListeners(DistributedSystem system,
+  static GemFireCacheImpl createWithAsyncEventListeners(InternalDistributedSystem system,
-  public static Cache create(DistributedSystem system, boolean existingOk,
+  public static Cache create(InternalDistributedSystem system, boolean existingOk,
-  private static GemFireCacheImpl basicCreate(DistributedSystem system, boolean existingOk,
+  private static GemFireCacheImpl basicCreate(InternalDistributedSystem system, boolean existingOk,
+          system.setCache(instance);
+        } else {
+          system.setCache(instance);
-  private GemFireCacheImpl(boolean isClient, PoolFactory pf, DistributedSystem system,
+  private GemFireCacheImpl(boolean isClient, PoolFactory pf, InternalDistributedSystem system,
-      this.system = (InternalDistributedSystem) system;
+      this.system = system;
+
+      this.configurationResponse = requestSharedConfiguration();
+
+      // apply the cluster's properties configuration and initialize security using that
+      // configuration
+      ClusterConfigurationLoader.applyClusterPropertiesConfiguration(this.configurationResponse,
+          this.system.getConfig());
+
+      this.securityService =
+          SecurityServiceFactory.create(this.system.getConfig().getSecurityProps(), cacheConfig);
+      this.system.setSecurityService(this.securityService);
+
-      this.recordedEventSweeper = EventTracker.startTrackerServices(this);
+      this.recordedEventSweeper = createEventTrackerExpiryTask();
+
+      addRegionEntrySynchronizationListener(new GatewaySenderQueueEntrySynchronizationListener());
+  /**
+   * Initialize the EventTracker's timer task. This is stored for tracking and shutdown purposes
+   */
+  private EventTrackerExpiryTask createEventTrackerExpiryTask() {
+    long lifetimeInMillis =
+        Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "messageTrackingTimeout",
+            PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT / 3);
+    EventTrackerExpiryTask task = new EventTrackerExpiryTask(lifetimeInMillis);
+    getCCPTimer().scheduleAtFixedRate(task, lifetimeInMillis, lifetimeInMillis);
+    return task;
+  }
+
+  @Override
+  public SecurityService getSecurityService() {
+    return this.securityService;
+  }
+
-  private void deployJarsReceivedFromClusterConfiguration(ConfigurationResponse response) {
-    try {
-      ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this, response);
-    } catch (IOException | ClassNotFoundException e) {
-      throw new GemFireConfigException(
-          LocalizedStrings.GemFireCache_EXCEPTION_OCCURRED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION
-              .toLocalizedString(),
-          e);
-    }
-  }
-
+    // set ClassPathLoader and then deploy cluster config jars
-    // request and check cluster configuration
-    ConfigurationResponse configurationResponse = requestSharedConfiguration();
-    deployJarsReceivedFromClusterConfiguration(configurationResponse);
-
-    // apply the cluster's properties configuration and initialize security using that configuration
-    ClusterConfigurationLoader.applyClusterPropertiesConfiguration(this, configurationResponse,
-        this.system.getConfig());
-
-    // first initialize the security service using the security properties
-    this.securityService.initSecurity(this.system.getConfig().getSecurityProps());
-    // secondly if cacheConfig has a securityManager, use that instead
-    if (this.cacheConfig.getSecurityManager() != null) {
-      this.securityService.setSecurityManager(this.cacheConfig.getSecurityManager());
-    }
-    // if cacheConfig has a postProcessor, use that instead
-    if (this.cacheConfig.getPostProcessor() != null) {
-      this.securityService.setPostProcessor(this.cacheConfig.getPostProcessor());
+    try {
+      ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this,
+          this.configurationResponse);
+    } catch (IOException | ClassNotFoundException e) {
+      throw new GemFireConfigException(
+          LocalizedStrings.GemFireCache_EXCEPTION_OCCURRED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION
+              .toLocalizedString(),
+          e);
-      if (configurationResponse == null) {
+      if (this.configurationResponse == null) {
-      ClusterConfigurationLoader.applyClusterXmlConfiguration(this, configurationResponse,
+      ClusterConfigurationLoader.applyClusterXmlConfiguration(this, this.configurationResponse,
+        this.configurationResponse = null;
+  @Override
-
-        EventTracker.stopTrackerServices(this);
+        getEventTrackerTask().cancel();
-        stopDiskStoreTaskPool();
-  /**
-   * Used to guard access to compactorPool and set to true when cache is shutdown.
-   */
-  private final AtomicBoolean diskStoreTaskSync = new AtomicBoolean(false);
-
-  /**
-   * Lazily initialized. TODO: this is always null
-   */
-  private ThreadPoolExecutor diskStoreTaskPool = null;
-
-  private void stopDiskStoreTaskPool() {
-    synchronized (this.diskStoreTaskSync) {
-      this.diskStoreTaskSync.set(true);
-      // All the regions have already been closed
-      // so this pool shouldn't be doing anything.
-      if (this.diskStoreTaskPool != null) {
-        List<Runnable> listOfRunnables = this.diskStoreTaskPool.shutdownNow();
-        for (Runnable runnable : listOfRunnables) {
-          // TODO: fix this for-loop and the one in DiskStoreImpl
-          if (listOfRunnables instanceof DiskStoreTask) {
-            ((DiskStoreTask) listOfRunnables).taskCancelled();
-          }
-        }
-      }
-    }
-  }
-
-  public EventTracker.ExpiryTask getEventTrackerTask() {
+  public EventTrackerExpiryTask getEventTrackerTask() {
+  @SuppressWarnings("unchecked")
+  @Override
+  public boolean hasPersistentRegion() {
+    synchronized (this.rootRegions) {
+      for (LocalRegion region : this.rootRegions.values()) {
+        if (region.getDataPolicy().withPersistence()) {
+          return true;
+        }
+        for (LocalRegion subRegion : (Set<LocalRegion>) region.basicSubregions(true)) {
+          if (subRegion.getDataPolicy().withPersistence()) {
+            return true;
+          }
+        }
+      }
+      return false;
+    }
+  }
+
-  public QueryService getQueryService() {
+  public InternalQueryService getQueryService() {
-    return defaultPool.getQueryService();
+    return (InternalQueryService) defaultPool.getQueryService();
-    manager.start();
+    manager.validateRequestingAdmin();
+
+  public void addRegionEntrySynchronizationListener(RegionEntrySynchronizationListener listener) {
+    this.synchronizationListeners.add(listener);
+  }
+
+  public void removeRegionEntrySynchronizationListener(
+      RegionEntrySynchronizationListener listener) {
+    this.synchronizationListeners.remove(listener);
+  }
+
+  public void invokeRegionEntrySynchronizationListenersAfterSynchronization(
+      InternalDistributedMember sender, LocalRegion region,
+      List<InitialImageOperation.Entry> entriesToSynchronize) {
+    for (RegionEntrySynchronizationListener listener : this.synchronizationListeners) {
+      try {
+        listener.afterSynchronization(sender, region, entriesToSynchronize);
+      } catch (Throwable t) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.GemFireCacheImpl_CAUGHT_EXCEPTION_SYNCHRONIZING_EVENTS,
+            new Object[] {sender, region.getFullPath(), entriesToSynchronize}), t);
+      }
+    }
+  }

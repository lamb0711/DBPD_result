Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Partitioned Region update message.  Meant to be sent only to
- * a bucket's primary owner.  In addition to updating an entry it is also used to
- * send Partitioned Region event information.
+ * A Partitioned Region update message. Meant to be sent only to a bucket's primary owner. In
+ * addition to updating an entry it is also used to send Partitioned Region event information.
-public final class PutAllPRMessage extends PartitionMessageWithDirectReply
-{
+public final class PutAllPRMessage extends PartitionMessageWithDirectReply {
-  
+
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-   * state from operateOnRegion that must be preserved for transmission
-   * from the waiting pool
+   * state from operateOnRegion that must be preserved for transmission from the waiting pool
-  
+
-  public PutAllPRMessage() {
-  }
+  public PutAllPRMessage() {}
-  public PutAllPRMessage(int bucketId, int size, boolean notificationOnly,
-      boolean posDup, boolean skipCallbacks, Object callbackArg) {
+  public PutAllPRMessage(int bucketId, int size, boolean notificationOnly, boolean posDup,
+      boolean skipCallbacks, Object callbackArg) {
-  public void initMessage(PartitionedRegion r, Set recipients, boolean notifyOnly, DirectReplyProcessor p) {
+  public void initMessage(PartitionedRegion r, Set recipients, boolean notifyOnly,
+      DirectReplyProcessor p) {
-    this.processorId = p==null? 0 : p.getProcessorId();
+    this.processorId = p == null ? 0 : p.getProcessorId();
-//  public void saveKeySet(PutAllPartialResult partialKeys) {
-//    partialKeys.addKeysAndVersions(this.versions);
-//  }
+  // public void saveKeySet(PutAllPartialResult partialKeys) {
+  // partialKeys.addKeysAndVersions(this.versions);
+  // }
-  
+
-    for (int i=0; i<putAllPRData.length; i++) {
+    for (int i = 0; i < putAllPRData.length; i++) {
+   * 
-   * @param r  the PartitionedRegion for which the put was performed
-   * @return the processor used to await acknowledgement that the update was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * @param r the PartitionedRegion for which the put was performed
+   * @return the processor used to await acknowledgement that the update was sent, or null to
+   *         indicate that no acknowledgement will be sent
-      throws ForceReattemptException
-  {
-    //Assert.assertTrue(recipient != null, "PutAllPRMessage NULL recipient");  recipient can be null for event notifications
+      throws ForceReattemptException {
+    // Assert.assertTrue(recipient != null, "PutAllPRMessage NULL recipient"); recipient can be null
+    // for event notifications
-    Set failures =r.getDistributionManager().putOutgoing(this);
+    Set failures = r.getDistributionManager().putOutgoing(this);
-  
+
-    this.bucketId = Integer.valueOf((int)InternalDataSerializer
-        .readSignedVL(in));
+    this.bucketId = Integer.valueOf((int) InternalDataSerializer.readSignedVL(in));
-    this.putAllPRDataSize = (int)InternalDataSerializer.readUnsignedVL(in);
+    this.putAllPRDataSize = (int) InternalDataSerializer.readUnsignedVL(in);
-      final Version version = InternalDataSerializer
-          .getVersionForDataStreamOrNull(in);
+      final Version version = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-        this.putAllPRData[i] = new PutAllEntryData(in, null, i, version,
-            bytesIn);
+        this.putAllPRData[i] = new PutAllEntryData(in, null, i, version, bytesIn);
- 
+
-    if (this.bridgeContext != null) s |= HAS_BRIDGE_CONTEXT;
-    if (this.skipCallbacks) s |= SKIP_CALLBACKS;
+    if (this.bridgeContext != null)
+      s |= HAS_BRIDGE_CONTEXT;
+    if (this.skipCallbacks)
+      s |= SKIP_CALLBACKS;
-  protected void setBooleans(short s, DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void setBooleans(short s, DataInput in) throws IOException, ClassNotFoundException {
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected final boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion r, long startTime)  throws EntryExistsException,
-      ForceReattemptException, DataLocationException
-  {
+  protected final boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws EntryExistsException, ForceReattemptException, DataLocationException {
-    }
-    catch (ForceReattemptException fre) {
-      sendReply(getSender(), getProcessorId(), dm, 
-          new ReplyException(fre), r, startTime);
+    } catch (ForceReattemptException fre) {
+      sendReply(getSender(), getProcessorId(), dm, new ReplyException(fre), r, startTime);
-    
-    @Retained EntryEventImpl ev = EntryEventImpl.create(r, 
-        putAllPRData[0].getOp(),
-        putAllPRData[0].getKey(), 
-        putAllPRData[0].getValue(), 
-        this.callbackArg,
-        false /* originRemote */,
-        getSender(),
-        true/* generate Callbacks */,
-        putAllPRData[0].getEventID());
+
+    @Retained
+    EntryEventImpl ev = EntryEventImpl.create(r, putAllPRData[0].getOp(), putAllPRData[0].getKey(),
+        putAllPRData[0].getValue(), this.callbackArg, false /* originRemote */, getSender(),
+        true/* generate Callbacks */, putAllPRData[0].getEventID());
-  
+
-   * This method is called by both operateOnPartitionedRegion() when processing a remote msg
-   * or by sendMsgByBucket() when processing a msg targeted to local Jvm. 
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgment
-   * @param r partitioned region
-   *        eventSender the endpoint server who received request from client
+   * This method is called by both operateOnPartitionedRegion() when processing a remote msg or by
+   * sendMsgByBucket() when processing a msg targeted to local Jvm. PartitionedRegion Note: It is
+   * very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgment
+   * 
+   * @param r partitioned region eventSender the endpoint server who received request from client
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="IMSE_DONT_CATCH_IMSE")
-  public final boolean doLocalPutAll(PartitionedRegion r, InternalDistributedMember eventSender, long lastModified)
-  throws EntryExistsException,
-  ForceReattemptException,DataLocationException
-  {
-    boolean didPut=false;
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "IMSE_DONT_CATCH_IMSE")
+  public final boolean doLocalPutAll(PartitionedRegion r, InternalDistributedMember eventSender,
+      long lastModified)
+      throws EntryExistsException, ForceReattemptException, DataLocationException {
+    boolean didPut = false;
-    
+
-    @Released EntryEventImpl baseEvent = null;
+    @Released
+    EntryEventImpl baseEvent = null;
-    
-    if (!notificationOnly) {
-      // bucketRegion is not null only when !notificationOnly
-      bucketRegion = ds.getInitializedBucketForId(null, bucketId);
-      
-      this.versions = new VersionedObjectList(this.putAllPRDataSize, true, bucketRegion.getAttributes().getConcurrencyChecksEnabled());
-      // create a base event and a DPAO for PutAllMessage distributed btw redundant buckets
-      baseEvent = EntryEventImpl.create(
-          bucketRegion, Operation.PUTALL_CREATE,
-          null, null, this.callbackArg, true, eventSender, !skipCallbacks, true);
-      // set baseEventId to the first entry's event id. We need the thread id for DACE
-      baseEvent.setEventId(putAllPRData[0].getEventID());
-      if (this.bridgeContext != null) {
-        baseEvent.setContext(this.bridgeContext);
+      if (!notificationOnly) {
+        // bucketRegion is not null only when !notificationOnly
+        bucketRegion = ds.getInitializedBucketForId(null, bucketId);
+
+        this.versions = new VersionedObjectList(this.putAllPRDataSize, true,
+            bucketRegion.getAttributes().getConcurrencyChecksEnabled());
+
+        // create a base event and a DPAO for PutAllMessage distributed btw redundant buckets
+        baseEvent = EntryEventImpl.create(bucketRegion, Operation.PUTALL_CREATE, null, null,
+            this.callbackArg, true, eventSender, !skipCallbacks, true);
+        // set baseEventId to the first entry's event id. We need the thread id for DACE
+        baseEvent.setEventId(putAllPRData[0].getEventID());
+        if (this.bridgeContext != null) {
+          baseEvent.setContext(this.bridgeContext);
+        }
+        baseEvent.setPossibleDuplicate(this.posDup);
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "PutAllPRMessage.doLocalPutAll: eventSender is {}, baseEvent is {}, msg is {}",
+              eventSender, baseEvent, this);
+        }
+        dpao = new DistributedPutAllOperation(baseEvent, putAllPRDataSize, false);
-      baseEvent.setPossibleDuplicate(this.posDup);
-      if (logger.isDebugEnabled()) {
-        logger.debug("PutAllPRMessage.doLocalPutAll: eventSender is {}, baseEvent is {}, msg is {}",
-            eventSender, baseEvent, this);
+
+      // Fix the updateMsg misorder issue
+      // Lock the keys when doing postPutAll
+      Object keys[] = new Object[putAllPRDataSize];
+      for (int i = 0; i < putAllPRDataSize; ++i) {
+        keys[i] = putAllPRData[i].getKey();
-      dpao = new DistributedPutAllOperation(baseEvent, putAllPRDataSize, false);
-    }
-    // Fix the updateMsg misorder issue
-    // Lock the keys when doing postPutAll
-    Object keys[] = new Object[putAllPRDataSize];
-    for (int i = 0; i < putAllPRDataSize; ++i) {
-      keys[i] = putAllPRData[i].getKey();
-    }
-
-    if (!notificationOnly) {
-      try {
-        if(putAllPRData.length > 0) {
-          if (this.posDup && bucketRegion.getConcurrencyChecksEnabled()) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("attempting to locate version tags for retried event");
-            }
-            // bug #48205 - versions may have already been generated for a posdup event
-            // so try to recover them before wiping out the eventTracker's record
-            // of the previous attempt
-            for (int i=0; i<putAllPRDataSize; i++) {
-              if (putAllPRData[i].versionTag == null) {
-                putAllPRData[i].versionTag = bucketRegion.findVersionTagForClientBulkOp(putAllPRData[i].getEventID());
-                if (putAllPRData[i].versionTag != null) {
-                  putAllPRData[i].versionTag.replaceNullIDs(bucketRegion.getVersionMember());
+      if (!notificationOnly) {
+        try {
+          if (putAllPRData.length > 0) {
+            if (this.posDup && bucketRegion.getConcurrencyChecksEnabled()) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("attempting to locate version tags for retried event");
+              }
+              // bug #48205 - versions may have already been generated for a posdup event
+              // so try to recover them before wiping out the eventTracker's record
+              // of the previous attempt
+              for (int i = 0; i < putAllPRDataSize; i++) {
+                if (putAllPRData[i].versionTag == null) {
+                  putAllPRData[i].versionTag =
+                      bucketRegion.findVersionTagForClientBulkOp(putAllPRData[i].getEventID());
+                  if (putAllPRData[i].versionTag != null) {
+                    putAllPRData[i].versionTag.replaceNullIDs(bucketRegion.getVersionMember());
+                  }
+            EventID eventID = putAllPRData[0].getEventID();
+            ThreadIdentifier membershipID =
+                new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
+            bucketRegion.recordBulkOpStart(membershipID);
-          EventID eventID = putAllPRData[0].getEventID();
-          ThreadIdentifier membershipID = new ThreadIdentifier(
-              eventID.getMembershipID(), eventID.getThreadID());
-          bucketRegion.recordBulkOpStart(membershipID);
-        }
-        bucketRegion.waitUntilLocked(keys);
-        boolean lockedForPrimary = false;
-        final HashMap succeeded = new HashMap();
-        PutAllPartialResult partialKeys = new PutAllPartialResult(putAllPRDataSize);
-        Object key = keys[0];
-        try {
-          bucketRegion.doLockForPrimary(false);
-          lockedForPrimary = true;
-      
-          /* The real work to be synchronized, it will take long time. We don't 
-           * worry about another thread to send any msg which has the same key
-           * in this request, because these request will be blocked by foundKey
-           */
-          for (int i=0; i<putAllPRDataSize; i++) {
-            @Released EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i,putAllPRData,notificationOnly,bridgeContext,posDup,skipCallbacks);
-            try {
-            key = ev.getKey();
-
-            ev.setPutAllOperation(dpao);
-
-            // make sure a local update inserts a cache de-serializable
-            ev.makeSerializedNewValue();
-            
-//            ev.setLocalFilterInfo(r.getFilterProfile().getLocalFilterRouting(ev));
-            
-            // ev will be added into dpao in putLocally()
-            // oldValue and real operation will be modified into ev in putLocally()
-            // then in basicPutPart3(), the ev is added into dpao
-            try {
-              didPut = r.getDataView().putEntryOnRemote(ev, false, false, null, false, lastModified, true);
-              if (didPut && logger.isDebugEnabled()) {
-                logger.debug("PutAllPRMessage.doLocalPutAll:putLocally success for {}", ev);
-              }
-            } catch (ConcurrentCacheModificationException e) {
-              didPut = true;
-              if (logger.isDebugEnabled()) {
-                logger.debug("PutAllPRMessage.doLocalPutAll:putLocally encountered concurrent cache modification for {}", ev, e);
-              }
-            }
-            putAllPRData[i].setTailKey(ev.getTailKey());
-            if (!didPut) { // make sure the region hasn't gone away
-              r.checkReadiness();
-              ForceReattemptException fre = new ForceReattemptException(
-              "unable to perform put in PutAllPR, but operation should not fail");
-              fre.setHash(ev.getKey().hashCode());
-              throw fre;
-            } else {
-              succeeded.put(putAllPRData[i].getKey(), putAllPRData[i].getValue());
-              this.versions.addKeyAndVersion(putAllPRData[i].getKey(), ev.getVersionTag());
-            }
-            } finally {
-              ev.release();
-            }
-          } // for
-
-        } catch (IllegalMonitorStateException ex) {
-          ForceReattemptException fre = new ForceReattemptException(
-          "unable to get lock for primary, retrying... ");
-          throw fre;
-        } catch (CacheWriterException cwe) {
-          // encounter cacheWriter exception
-          partialKeys.saveFailedKey(key, cwe);
-        } finally {
+          bucketRegion.waitUntilLocked(keys);
+          boolean lockedForPrimary = false;
+          final HashMap succeeded = new HashMap();
+          PutAllPartialResult partialKeys = new PutAllPartialResult(putAllPRDataSize);
+          Object key = keys[0];
-            // Only PutAllPRMessage knows if the thread id is fake. Event has no idea.
-            // So we have to manually set useFakeEventId for this DPAO
-            dpao.setUseFakeEventId(true);
-            r.checkReadiness();
-            bucketRegion.getDataView().postPutAll(dpao, this.versions, bucketRegion);
+            bucketRegion.doLockForPrimary(false);
+            lockedForPrimary = true;
+
+            /*
+             * The real work to be synchronized, it will take long time. We don't worry about
+             * another thread to send any msg which has the same key in this request, because these
+             * request will be blocked by foundKey
+             */
+            for (int i = 0; i < putAllPRDataSize; i++) {
+              @Released
+              EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i, putAllPRData,
+                  notificationOnly, bridgeContext, posDup, skipCallbacks);
+              try {
+                key = ev.getKey();
+
+                ev.setPutAllOperation(dpao);
+
+                // make sure a local update inserts a cache de-serializable
+                ev.makeSerializedNewValue();
+
+                // ev.setLocalFilterInfo(r.getFilterProfile().getLocalFilterRouting(ev));
+
+                // ev will be added into dpao in putLocally()
+                // oldValue and real operation will be modified into ev in putLocally()
+                // then in basicPutPart3(), the ev is added into dpao
+                try {
+                  didPut = r.getDataView().putEntryOnRemote(ev, false, false, null, false,
+                      lastModified, true);
+                  if (didPut && logger.isDebugEnabled()) {
+                    logger.debug("PutAllPRMessage.doLocalPutAll:putLocally success for {}", ev);
+                  }
+                } catch (ConcurrentCacheModificationException e) {
+                  didPut = true;
+                  if (logger.isDebugEnabled()) {
+                    logger.debug(
+                        "PutAllPRMessage.doLocalPutAll:putLocally encountered concurrent cache modification for {}",
+                        ev, e);
+                  }
+                }
+                putAllPRData[i].setTailKey(ev.getTailKey());
+                if (!didPut) { // make sure the region hasn't gone away
+                  r.checkReadiness();
+                  ForceReattemptException fre = new ForceReattemptException(
+                      "unable to perform put in PutAllPR, but operation should not fail");
+                  fre.setHash(ev.getKey().hashCode());
+                  throw fre;
+                } else {
+                  succeeded.put(putAllPRData[i].getKey(), putAllPRData[i].getValue());
+                  this.versions.addKeyAndVersion(putAllPRData[i].getKey(), ev.getVersionTag());
+                }
+              } finally {
+                ev.release();
+              }
+            } // for
+
+          } catch (IllegalMonitorStateException ex) {
+            ForceReattemptException fre =
+                new ForceReattemptException("unable to get lock for primary, retrying... ");
+            throw fre;
+          } catch (CacheWriterException cwe) {
+            // encounter cacheWriter exception
+            partialKeys.saveFailedKey(key, cwe);
-            if (lockedForPrimary) {
-              bucketRegion.doUnlockForPrimary();
+            try {
+              // Only PutAllPRMessage knows if the thread id is fake. Event has no idea.
+              // So we have to manually set useFakeEventId for this DPAO
+              dpao.setUseFakeEventId(true);
+              r.checkReadiness();
+              bucketRegion.getDataView().postPutAll(dpao, this.versions, bucketRegion);
+            } finally {
+              if (lockedForPrimary) {
+                bucketRegion.doUnlockForPrimary();
+              }
-        }
-        if (partialKeys.hasFailure()) {
-          partialKeys.addKeysAndVersions(this.versions);
-          if (logger.isDebugEnabled()) {
-            logger.debug("PutAllPRMessage: partial keys applied, map to bucket {}'s keys: {}. Applied {}",
-                bucketId, Arrays.toString(keys), succeeded);
+          if (partialKeys.hasFailure()) {
+            partialKeys.addKeysAndVersions(this.versions);
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  "PutAllPRMessage: partial keys applied, map to bucket {}'s keys: {}. Applied {}",
+                  bucketId, Arrays.toString(keys), succeeded);
+            }
+            throw new PutAllPartialResultException(partialKeys);
-          throw new PutAllPartialResultException(partialKeys);
-        }
-      } catch(RegionDestroyedException e) {
-          ds.checkRegionDestroyedOnBucket(bucketRegion ,true, e);
-      } finally {
-        bucketRegion.removeAndNotifyKeys(keys);
-      }
-    } else {
-      for (int i=0; i<putAllPRDataSize; i++) {
-        EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i,putAllPRData,notificationOnly,bridgeContext,posDup,skipCallbacks);
-        try {
-        ev.setOriginRemote(true);
-        if (this.callbackArg != null) {
-          ev.setCallbackArgument(this.callbackArg);
-        }
-        r.invokePutCallbacks(ev.getOperation().isCreate() ? EnumListenerEvent.AFTER_CREATE
-            : EnumListenerEvent.AFTER_UPDATE, ev, r.isInitialized(), true);
+        } catch (RegionDestroyedException e) {
+          ds.checkRegionDestroyedOnBucket(bucketRegion, true, e);
-          ev.release();
+          bucketRegion.removeAndNotifyKeys(keys);
+        }
+      } else {
+        for (int i = 0; i < putAllPRDataSize; i++) {
+          EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i, putAllPRData,
+              notificationOnly, bridgeContext, posDup, skipCallbacks);
+          try {
+            ev.setOriginRemote(true);
+            if (this.callbackArg != null) {
+              ev.setCallbackArgument(this.callbackArg);
+            }
+            r.invokePutCallbacks(ev.getOperation().isCreate() ? EnumListenerEvent.AFTER_CREATE
+                : EnumListenerEvent.AFTER_UPDATE, ev, r.isInitialized(), true);
+          } finally {
+            ev.release();
+          }
-    }
-      if (baseEvent != null) baseEvent.release();
-      if (dpao != null) dpao.freeOffHeapResources();
+      if (baseEvent != null)
+        baseEvent.release();
+      if (dpao != null)
+        dpao.freeOffHeapResources();
-  
+
-  
+
-	return true;
+    return true;
-  
+
-  public static EntryEventImpl getEventFromEntry(LocalRegion r,
-      InternalDistributedMember myId, InternalDistributedMember eventSender,
-      int idx, DistributedPutAllOperation.PutAllEntryData[] data,
-      boolean notificationOnly, ClientProxyMembershipID bridgeContext,
-      boolean posDup, boolean skipCallbacks) {
+  public static EntryEventImpl getEventFromEntry(LocalRegion r, InternalDistributedMember myId,
+      InternalDistributedMember eventSender, int idx,
+      DistributedPutAllOperation.PutAllEntryData[] data, boolean notificationOnly,
+      ClientProxyMembershipID bridgeContext, boolean posDup, boolean skipCallbacks) {
-    //EntryEventImpl ev = EntryEventImpl.create(r, 
-       // prd.getOp(),
-       // prd.getKey(), null/* value */, null /* callbackArg */,
-       // false /* originRemote */,
-      //  eventSender, 
-      //  true/* generate Callbacks */,
-      //  prd.getEventID());
-    
-    @Retained EntryEventImpl ev = EntryEventImpl.create(r, prd.getOp(), prd.getKey(), prd
-        .getValue(), null, false, eventSender, !skipCallbacks, prd.getEventID());
+    // EntryEventImpl ev = EntryEventImpl.create(r,
+    // prd.getOp(),
+    // prd.getKey(), null/* value */, null /* callbackArg */,
+    // false /* originRemote */,
+    // eventSender,
+    // true/* generate Callbacks */,
+    // prd.getEventID());
+
+    @Retained
+    EntryEventImpl ev = EntryEventImpl.create(r, prd.getOp(), prd.getKey(), prd.getValue(), null,
+        false, eventSender, !skipCallbacks, prd.getEventID());
-    if (prd.getValue() == null 
-        && ev.getRegion().getAttributes().getDataPolicy() == DataPolicy.NORMAL) {
-      ev.setLocalInvalid(true);
-    }
-    ev.setNewValue(prd.getValue());
-    ev.setOldValue(prd.getOldValue());
-    if (bridgeContext != null) {
-      ev.setContext(bridgeContext);
-    }
-    ev.setInvokePRCallbacks(!notificationOnly);
-    ev.setPossibleDuplicate(posDup);
-    if (prd.filterRouting != null) {
-      ev.setLocalFilterInfo(prd.filterRouting.getFilterInfo(myId));
-    }
-    if (prd.versionTag != null) {
-      prd.versionTag.replaceNullIDs(eventSender);
-      ev.setVersionTag(prd.versionTag);
-    }
-    //ev.setLocalFilterInfo(r.getFilterProfile().getLocalFilterRouting(ev));
-    if(notificationOnly){
-      ev.setTailKey(-1L);
-    } else {
-      ev.setTailKey(prd.getTailKey());
-    }
-    evReturned = true;
-    return ev;
+      if (prd.getValue() == null
+          && ev.getRegion().getAttributes().getDataPolicy() == DataPolicy.NORMAL) {
+        ev.setLocalInvalid(true);
+      }
+      ev.setNewValue(prd.getValue());
+      ev.setOldValue(prd.getOldValue());
+      if (bridgeContext != null) {
+        ev.setContext(bridgeContext);
+      }
+      ev.setInvokePRCallbacks(!notificationOnly);
+      ev.setPossibleDuplicate(posDup);
+      if (prd.filterRouting != null) {
+        ev.setLocalFilterInfo(prd.filterRouting.getFilterInfo(myId));
+      }
+      if (prd.versionTag != null) {
+        prd.versionTag.replaceNullIDs(eventSender);
+        ev.setVersionTag(prd.versionTag);
+      }
+      // ev.setLocalFilterInfo(r.getFilterProfile().getLocalFilterRouting(ev));
+      if (notificationOnly) {
+        ev.setTailKey(-1L);
+      } else {
+        ev.setTailKey(prd.getTailKey());
+      }
+      evReturned = true;
+      return ev;
-  
+
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
-//    if (!result && getOperation().isCreate()) {
-//      System.err.println("DEBUG: put returning false.  ifNew=" + ifNew
-//          +" ifOld="+ifOld + " message=" + this);
-//    }
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime) {
+    // if (!result && getOperation().isCreate()) {
+    // System.err.println("DEBUG: put returning false. ifNew=" + ifNew
+    // +" ifOld="+ifOld + " message=" + this);
+    // }
-      pr.getPrStats().endPartitionMessagesProcessing(startTime);
-    }
+        pr.getPrStats().endPartitionMessagesProcessing(startTime);
+      }
-  protected final void appendFields(StringBuffer buff)
-  {
+  protected final void appendFields(StringBuffer buff) {
-    buff.append("; putAllPRDataSize=").append(putAllPRDataSize)
-        .append("; bucketId=").append(bucketId);
+    buff.append("; putAllPRDataSize=").append(putAllPRDataSize).append("; bucketId=")
+        .append(bucketId);
-    buff.append("; directAck=")
-        .append(this.directAck);
-    
-    for (int i=0; i<putAllPRDataSize; i++) {
-//      buff.append("; entry"+i+":").append(putAllPRData[i]);
-      buff.append("; entry"+i+":").append(putAllPRData[i].getKey())
-        .append(",").append(putAllPRData[i].versionTag);
+    buff.append("; directAck=").append(this.directAck);
+
+    for (int i = 0; i < putAllPRDataSize; i++) {
+      // buff.append("; entry"+i+":").append(putAllPRData[i]);
+      buff.append("; entry" + i + ":").append(putAllPRData[i].getKey()).append(",")
+          .append(putAllPRData[i].versionTag);
-  public final InternalDistributedSystem getInternalDs()
-  {
+  public final InternalDistributedSystem getInternalDs() {
-  public final void setInternalDs(InternalDistributedSystem internalDs)
-  {
+  public final void setInternalDs(InternalDistributedSystem internalDs) {
-  public final void setDirectAck(boolean directAck)
-  {
+  public final void setDirectAck(boolean directAck) {
-  
+
-  
+
-  public String toString()
-  {
+  public String toString() {
-//    className.substring(className.lastIndexOf('.', className.lastIndexOf('.') - 1) + 1);  // partition.<foo> more generic version 
+    // className.substring(className.lastIndexOf('.', className.lastIndexOf('.') - 1) + 1); //
+    // partition.<foo> more generic version
-    
+
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-    public PutAllReplyMessage() {
-    }
+    public PutAllReplyMessage() {}
-    private PutAllReplyMessage(int processorId, boolean result, VersionedObjectList versions, ReplyException ex) {
+    private PutAllReplyMessage(int processorId, boolean result, VersionedObjectList versions,
+        ReplyException ex) {
-    public static void send(InternalDistributedMember recipient, int processorId,
-        ReplySender dm, boolean result, VersionedObjectList versions, ReplyException ex) {
+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,
+        boolean result, VersionedObjectList versions, ReplyException ex) {
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        PutAllResponse processor = (PutAllResponse)rp;
+        PutAllResponse processor = (PutAllResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.versions = (VersionedObjectList)DataSerializer.readObject(in);
+      this.versions = (VersionedObjectList) DataSerializer.readObject(in);
-      sb.append("PutAllReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" returning ").append(this.result)
-      .append(" exception=").append(getException())
-      .append(" versions= ").append(this.versions);
+      sb.append("PutAllReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" returning ").append(this.result).append(" exception=").append(getException())
+          .append(" versions= ").append(this.versions);
-  
+
+   * 
-    public PutAllResult waitForResult() throws CacheException,
-        ForceReattemptException {
+    public PutAllResult waitForResult() throws CacheException, ForceReattemptException {
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-//       try {
-//         waitForRepliesUninterruptibly();
-//       }
-//       catch (ReplyException e) {
-//         Throwable t = e.getCause();
-//         if (t instanceof CacheClosedException) {
-//           throw new PartitionedRegionCommunicationException("Put operation received an exception", t);
-//         }
-//         e.handleAsUnexpected();
-//       }
+      // try {
+      // waitForRepliesUninterruptibly();
+      // }
+      // catch (ReplyException e) {
+      // Throwable t = e.getCause();
+      // if (t instanceof CacheClosedException) {
+      // throw new PartitionedRegionCommunicationException("Put operation received an exception",
+      // t);
+      // }
+      // e.handleAsUnexpected();
+      // }
-    
+
+
-      return "PutAllResult("+this.returnValue+", "+this.versions+")";
-  }
+      return "PutAllResult(" + this.returnValue + ", " + this.versions + ")";
+    }

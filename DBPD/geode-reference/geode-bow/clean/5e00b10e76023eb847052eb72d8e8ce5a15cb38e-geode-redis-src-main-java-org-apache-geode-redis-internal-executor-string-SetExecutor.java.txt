GEODE-8134: convert String commands to use Function+Delta (#5160)

Co-authored-by: john Hutchison <hutchisonjo@vmware.com>
Co-authored-by: Ray Ingles <ringles@vmware.com>
-import org.apache.geode.redis.internal.RedisConstants.ArityDef;
+import org.apache.geode.redis.internal.RedisData;
-import org.apache.geode.redis.internal.RedisDataTypeMismatchException;
-  private final int VALUE_INDEX = 2;
-
-  private boolean NX = false; // Set only if not exists, incompatible with XX
-  private boolean XX = false; // Set only if exists, incompatible with NX
-  private boolean KEEPTTL = false; // Keep existing TTL on key
-  private long expiration = 0L;
-
+
+    ByteArrayWrapper keyToSet = command.getKey();
+    ByteArrayWrapper valueToSet = getValueToSet(commandElems);
-    if (commandElems.size() < 3) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ArityDef.SET));
-      return;
-    }
-
-    ByteArrayWrapper key = command.getKey();
-    ByteArrayWrapper value = getValue(commandElems);
-
-    String parseError = parseCommandElems(commandElems);
-    if (parseError != null) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), parseError));
-      return;
-    }
-
-    Region<ByteArrayWrapper, ByteArrayWrapper> region =
+    Region<ByteArrayWrapper, RedisData> region =
-    if (NX) {
-      setNX(region, command, key, value, context);
+    RedisStringCommands redisStringCommands = new RedisStringCommandsFunctionExecutor(region);
+    SetOptions setOptions;
+    try {
+      setOptions = parseCommandElems(commandElems);
+    } catch (IllegalArgumentException ex) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ex.getMessage()));
-    if (XX) {
-      setXX(region, command, key, value, context);
-      return;
-    }
-
-    set(command, context, region, key, value);
+    doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);
-  private ByteArrayWrapper getValue(List<byte[]> commandElems) {
-    byte[] value = commandElems.get(VALUE_INDEX);
+  private void doSet(Command command, ExecutionHandlerContext context, ByteArrayWrapper key,
+      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {
+
+    checkKeyRegistrarAndRemoveKeyIfNeeded(context, key);
+    RedisString result = redisStringCommands.set(key, value, setOptions);
+
+    if (result != null) {
+      context.getKeyRegistrar().register(key, RedisDataType.REDIS_STRING);
+      command.setResponse(Coder.getSimpleStringResponse(context.getByteBufAllocator(), SUCCESS));
+      handleExpiration(context, key, setOptions);
+    } else {
+      command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
+    }
+  }
+
+  private void checkKeyRegistrarAndRemoveKeyIfNeeded(ExecutionHandlerContext context,
+      ByteArrayWrapper key) {
+    RedisDataType existingKeyType = context.getKeyRegistrar().getType(key);
+    if (existingKeyType != null && existingKeyType != RedisDataType.REDIS_STRING) {
+      // It already exists. We need to kill it.
+      removeEntry(key, context);
+    }
+  }
+
+  private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {
+    byte[] value = commandElems.get(2);
-  private Region getRegion(ExecutionHandlerContext context, ByteArrayWrapper key) {
-    RedisDataType redisDataType = context.getKeyRegistrar().getType(key);
-    return context.getRegionProvider().getRegionForType(redisDataType);
-  }
-  private String parseCommandElems(List<byte[]> commandElems) {
-    // Set only if exists, incompatible with EX
-    boolean PX = false;
-    // Set only if not exists, incompatible with PX
-    boolean EX = false;
+  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {
+    boolean keepTTL = false;
+    SetOptions.Exists existsOption = SetOptions.Exists.NONE;
+    SetOptions.ExpireUnit expireUnitOption = SetOptions.ExpireUnit.NONE;
+    Long expiration = null;
-    NX = XX = EX = PX = KEEPTTL = false;
-
-    expiration = 0L;
-          KEEPTTL = true;
+          keepTTL = true;
-          EX = true;
+          if (expireUnitOption != SetOptions.ExpireUnit.NONE) {
+            throw new IllegalArgumentException(ERROR_SYNTAX);
+          }
+          expireUnitOption = SetOptions.ExpireUnit.EX;
-          PX = true;
+          if (expireUnitOption != SetOptions.ExpireUnit.NONE) {
+            throw new IllegalArgumentException(ERROR_SYNTAX);
+          }
+          expireUnitOption = SetOptions.ExpireUnit.PX;
-          NX = true;
+          if (existsOption != SetOptions.Exists.NONE) {
+            throw new IllegalArgumentException(ERROR_SYNTAX);
+          }
+          existsOption = SetOptions.Exists.NX;
-          XX = true;
+          if (existsOption != SetOptions.Exists.NONE) {
+            throw new IllegalArgumentException(ERROR_SYNTAX);
+          }
+          existsOption = SetOptions.Exists.XX;
-          return ERROR_SYNTAX;
+          throw new IllegalArgumentException(ERROR_SYNTAX);
-    if (EX && PX) {
-      return ERROR_SYNTAX;
-    }
-
-    if (NX && XX) {
-      return ERROR_SYNTAX;
-    }
-
-    if (EX || PX) {
-      if (expiration == -2L) {
-        return ERROR_SYNTAX;
-      }
-      if (expiration == -1L) {
-        return ERROR_NOT_INTEGER;
-      }
-      if (expiration == 0L) {
-        return ERROR_INVALID_EXPIRE_TIME;
-      }
-    }
-
-    return null;
+    return new SetOptions(existsOption, expiration, expireUnitOption, keepTTL);
-  private long parseExpirationTime(String arg, int index, List<byte[]> commandElems) {
+  private long parseExpirationTime(String arg, int index, List<byte[]> commandElems)
+      throws IllegalArgumentException {
-      return -2L;
+      throw new IllegalArgumentException(ERROR_SYNTAX);
-      return -1L;
+      throw new IllegalArgumentException(ERROR_NOT_INTEGER);
-      return 0L;
+      throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);
-      return -1L;
+      throw new IllegalArgumentException(ERROR_NOT_INTEGER);
-  private void setNX(Region<ByteArrayWrapper, ByteArrayWrapper> region, Command command,
-      ByteArrayWrapper key, ByteArrayWrapper valueWrapper,
-      ExecutionHandlerContext context) {
-    if (keyAlreadyExistsForDifferentDataType(context, key)) {
-      command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
-      return;
-    }
-
-    checkAndSetDataType(key, context);
-    Object oldValue = region.putIfAbsent(key, valueWrapper);
-
-    if (oldValue != null) {
-      command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
-      return;
-    }
-
-    command.setResponse(Coder.getSimpleStringResponse(context.getByteBufAllocator(), SUCCESS));
-    handleExpiration(context, key);
-  }
-
-  private void setXX(Region<ByteArrayWrapper, ByteArrayWrapper> region, Command command,
-      ByteArrayWrapper key, ByteArrayWrapper valueWrapper,
-      ExecutionHandlerContext context) {
-    if (region.containsKey(key) || keyAlreadyExistsForDifferentDataType(context, key)) {
-      set(command, context, region, key, valueWrapper);
+  private void handleExpiration(ExecutionHandlerContext context, ByteArrayWrapper key,
+      SetOptions setOptions) {
+    if (setOptions.getExpiration() != null) {
+      context.getRegionProvider().setExpiration(key, setOptions.getExpiration());
-      command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
-    }
-  }
-
-  private void set(Command command, ExecutionHandlerContext context,
-      Region<ByteArrayWrapper, ByteArrayWrapper> stringsRegion, ByteArrayWrapper key,
-      ByteArrayWrapper valueWrapper) {
-    if (keyAlreadyExistsForDifferentDataType(context, key)) {
-      removeOldValueAndDataTypeAssociation(context, key);
-    }
-    checkAndSetDataType(key, context);
-    stringsRegion.put(key, valueWrapper);
-    command.setResponse(Coder.getSimpleStringResponse(context.getByteBufAllocator(), SUCCESS));
-    handleExpiration(context, key);
-  }
-
-  private boolean keyAlreadyExistsForDifferentDataType(ExecutionHandlerContext context,
-      ByteArrayWrapper key) {
-    try {
-      checkDataType(key, RedisDataType.REDIS_STRING, context);
-    } catch (RedisDataTypeMismatchException e) {
-      return true;
-    }
-
-    return false;
-  }
-
-  private void removeOldValueAndDataTypeAssociation(ExecutionHandlerContext context,
-      ByteArrayWrapper key) {
-    Region oldRegion = getRegion(context, key);
-    oldRegion.remove(key);
-    context.getKeyRegistrar().unregister(key);
-  }
-
-  private void handleExpiration(ExecutionHandlerContext context, ByteArrayWrapper key) {
-    if (expiration > 0L) {
-      context.getRegionProvider().setExpiration(key, expiration);
-    } else {
-      if (!KEEPTTL) {
+      if (!setOptions.isKeepTTL()) {

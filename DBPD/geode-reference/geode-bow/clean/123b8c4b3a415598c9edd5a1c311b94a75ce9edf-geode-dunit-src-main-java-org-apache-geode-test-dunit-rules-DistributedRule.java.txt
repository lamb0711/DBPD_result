GEODE-5614: rename DistributedTestRule as DistributedRule

* Cleanup javadocs on rules that referred to DistributedTestRule.
* Add ClientCacheFactoryDistributedTest for ClientCacheRule.

- * JUnit Rule that launches DistributedTest VMs without {@code DistributedTestCase}. Test class may
- * need to implement {@code Serializable}.
+ * JUnit Rule that launches DistributedTest VMs and scans all log output for suspect strings without
+ * {@code DistributedTestCase}. The test class may need to implement {@code Serializable} if it
+ * uses lambdas to perform {@code RMI} invocations on {@code VM}s.
- * {@code DistributedTestRule} can be used in DistributedTests as a {@code ClassRule}. This ensures
- * that DUnit VMs will be available to non-Class {@code Rule}s. Unfortunately, you will need to
- * declare {@code DistributedTestRule.TearDown} as a non-Class {@code Rule}. Without
- * {@code DistributedTestRule.TearDown} grep for suspect strings will not be invoked after each
- * test.
+ * {@code DistributedRule} can be used in DistributedTests as a {@code Rule}. This will ensure
+ * that checking for suspect strings is performed after each test method.
- * {@literal @}ClassRule
- * public static DistributedTestRule distributedTestRule = new DistributedTestRule();
- *
- * public DistributedTestRule.TearDown tearDownRule = new DistributedTestRule.TearDown();
+ * public DistributedRule distributedRule = new DistributedRule();
- * public void shouldHaveFourDUnitVMsByDefault() {
+ * public void shouldHaveFourVMsByDefault() {
- * Or as a non-Class {@code Rule}. This usage does <bold>not</bold> require separate declaration of
- * {@code DistributedTestRule.TearDown}:
+ * You may specify a non-default number of {@code VM}s for the test when constructing
+ * {@code DistributedRule}.
+ *
+ * <p>
+ * Example of specifying fewer that the default number of {@code VM}s (which is 4):
- * public DistributedTestRule distributedTestRule = new DistributedTestRule();
+ * public DistributedRule distributedRule = new DistributedRule(1);
+ *
+ * {@literal @}Test
+ * public void hasOneVM() {
+ *   assertThat(getVMCount()).isEqualTo(1);
+ * }
+ * </pre>
+ *
+ * <p>
+ * Example of specifying greater that the default number of {@code VM}s (which is 4):
+ *
+ * <pre>
+ * {@literal @}Rule
+ * public DistributedRule distributedRule = new DistributedRule(8);
+ *
+ * {@literal @}Test
+ * public void hasEightVMs() {
+ *   assertThat(getVMCount()).isEqualTo(8);
+ * }
+ * </pre>
+ *
+ * <p>
+ * {@code DistributedRule} can also be used in DistributedTests as a {@code ClassRule}. This ensures
+ * that DUnit VMs will be available to non-Class {@code Rule}s. However, you may want to declare
+ * {@code DistributedRule.TearDown} as a non-Class {@code Rule} so that check for suspect strings is
+ * performed after each test method.
+ *
+ * <pre>
+ * {@literal @}ClassRule
+ * public static DistributedRule distributedRule = new DistributedRule();
- * public DistributedTestRule.TearDown tearDownRule = new DistributedTestRule.TearDown();
+ * public DistributedRule.TearDown distributedRuleTearDown = new DistributedRule.TearDown();
-public class DistributedTestRule extends AbstractDistributedTestRule {
+public class DistributedRule extends AbstractDistributedRule {
-   * Use {@code Builder} for more options in constructing {@code DistributedTestRule}.
+   * Use {@code Builder} for more options in constructing {@code DistributedRule}.
-  public DistributedTestRule() {
+  /**
+   * Constructs DistributedRule and launches the default number of {@code VM}s (which is 4).
+   */
+  public DistributedRule() {
-  public DistributedTestRule(final int vmCount) {
+  /**
+   * Constructs DistributedRule and launches the specified number of {@code VM}s.
+   *
+   * @param vmCount specified number of VMs
+   */
+  public DistributedRule(final int vmCount) {
-  DistributedTestRule(final Builder builder) {
+  DistributedRule(final Builder builder) {
-  protected void before() throws Exception {
+  protected void before() {
-   * Builds an instance of CacheRule.
+   * Builds an instance of DistributedRule.
-    public DistributedTestRule build() {
-      return new DistributedTestRule(this);
+    public DistributedRule build() {
+      return new DistributedRule(this);
-   * {@link DistributedTestRule#after()} invokes the same cleanup that this Rule does, but if you
-   * defined {@code DistributedTestRule} as a {@code ClassRule} then you should declare TearDown
+   * {@link DistributedRule#after()} invokes the same cleanup that this Rule does, but if you
+   * defined {@code DistributedRule} as a {@code ClassRule} then you should declare TearDown
-   * public static DistributedTestRule distributedTestRule = new DistributedTestRule();
+   * public static DistributedRule distributedRule = new DistributedRule();
-   * public DistributedTestRule.TearDown tearDownRule = new DistributedTestRule.TearDown();
+   * public DistributedRule.TearDown tearDownRule = new DistributedRule.TearDown();
-    protected void before() throws Exception {
+    protected void before() {

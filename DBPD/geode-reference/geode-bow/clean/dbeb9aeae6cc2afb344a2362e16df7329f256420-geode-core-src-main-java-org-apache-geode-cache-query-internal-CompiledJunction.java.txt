Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Conjunctions and Disjunctions (LITERAL_and LITERAL_or) As a part of feature
- * development to ensure index usage for multiple regions & index usage in equi
- * join conditions across the regions , a CompiledJunction's organized operands
- * method creates internal structures like GroupJunction, AllGroupJunction &
- * CompositeGroupJunction. The method createJunction is where the decision of
- * creating an AllGroupJunction ( wrapping multiple GroupJunctions and
- * CompositeGroupJunctions) or a single GroupJunction or a singe
- * CompositeGroupJunction is taken.
+ * Conjunctions and Disjunctions (LITERAL_and LITERAL_or) As a part of feature development to ensure
+ * index usage for multiple regions & index usage in equi join conditions across the regions , a
+ * CompiledJunction's organized operands method creates internal structures like GroupJunction,
+ * AllGroupJunction & CompositeGroupJunction. The method createJunction is where the decision of
+ * creating an AllGroupJunction ( wrapping multiple GroupJunctions and CompositeGroupJunctions) or a
+ * single GroupJunction or a singe CompositeGroupJunction is taken.
- *          CompiledJunction -----> on organization of Operands may result in any 
- *          of the following cases
- *          
- *          1)    CompiledJunction
- *                     |
- *                     |
- *          --------------------------------
- *          |                               |                     
- *       CompiledJunction                GroupJunction (Filter evaluable)
- *       (Filter evaluable)   
- *       
- *       2)    CompiledJunction
- *                     |
- *                     |
- *          --------------------------------
- *          |                               |                     
- *       CompiledJunction                RangeJunction (Filter evaluable same index operands. May contain iter operands belonging to the same Group)
- *       (Filter evaluable)
- *           
- *           
- *      3)      CompiledJunction
- *                     |
- *                     |
- *          --------------------------------
- *          |                               |                     
- *       CompiledJunction                GroupJunction (Filter evaluable)
- *       (Filter evaluable)                     |
- *                                                | 
- *                                      ----------------------------------------------
- *                                      |                                             |
- *                                   CompiledComparison                               RangeJunction 
- *                            (at least one filter evaluable compiled
- *                             Comparison using an index shared by no other
- *                             condition)           
- *                             
- *                             
- *     5)      CompiledJunction
- *                     |
- *                     |
- *          --------------------------------
- *          |                               |                     
- *       CompiledJunction                GroupJunction (Filter evaluable)
- *       (Filter evaluable)                     |
- *                                                | 
- *                                      ---------------------------------------
- *                                      |                     |                |
- *                                   RangeJunction          RangeJunction   CompiledComparison
- *                                                                            (zero or more Filter evaluable or iter
- *                                                                             evaluable )      
+ * CompiledJunction -----> on organization of Operands may result in any of the following cases
- *   6)    CompiledJunction
- *             |
- *     ----------------------------------
- *     |                                 |
- *   CompiledJunction                AllGroupJunction
- *   (filter evaluable)                  |
- *                             ------------------------------------------------
- *                             |                             |                 |
- *                          GroupJunction               GroupJunction       CompositeGroupJunction
- *                                                                                |
- *                                                                            ---------------------------------------
- *                                                                            |             |                        |
- *                                                                         GroupJunction  equi join conditions    GroupJunction       
+ * 1) CompiledJunction | | -------------------------------- | | CompiledJunction GroupJunction
+ * (Filter evaluable) (Filter evaluable)
+ * 
+ * 2) CompiledJunction | | -------------------------------- | | CompiledJunction RangeJunction
+ * (Filter evaluable same index operands. May contain iter operands belonging to the same Group)
+ * (Filter evaluable)
+ * 
+ * 
+ * 3) CompiledJunction | | -------------------------------- | | CompiledJunction GroupJunction
+ * (Filter evaluable) (Filter evaluable) | | ---------------------------------------------- | |
+ * CompiledComparison RangeJunction (at least one filter evaluable compiled Comparison using an
+ * index shared by no other condition)
+ * 
+ * 
+ * 5) CompiledJunction | | -------------------------------- | | CompiledJunction GroupJunction
+ * (Filter evaluable) (Filter evaluable) | | --------------------------------------- | | |
+ * RangeJunction RangeJunction CompiledComparison (zero or more Filter evaluable or iter evaluable )
+ * 
+ * 6) CompiledJunction | ---------------------------------- | | CompiledJunction AllGroupJunction
+ * (filter evaluable) | ------------------------------------------------ | | | GroupJunction
+ * GroupJunction CompositeGroupJunction | --------------------------------------- | | |
+ * GroupJunction equi join conditions GroupJunction
- * @version $Revision: 1.2 $                                  
+ * @version $Revision: 1.2 $
-public class CompiledJunction extends AbstractCompiledValue implements
-    Negatable {
+public class CompiledJunction extends AbstractCompiledValue implements Negatable {
-  private List unevaluatedFilterOperands = null; 
-  
-  //A token to place into the samesort map.  This is to let the engine know there is more than one index
-  //being used for this junction but allows actual operands to form range junctions if enough exist. 
-  //The mechanism checks to see if the mapped object is an integer, if so, it increments, if it's not it sets as 1
-  //Because we are a string place holder, the next actual operand would just start at one.  If the join is added
-  //after a valid operand has already set the counter to an integer, we instead just ignore and do not set the place holder
-  private final static String PLACEHOLDER_FOR_JOIN = "join";  
+  private List unevaluatedFilterOperands = null;
+
+  // A token to place into the samesort map. This is to let the engine know there is more than one
+  // index
+  // being used for this junction but allows actual operands to form range junctions if enough
+  // exist.
+  // The mechanism checks to see if the mapped object is an integer, if so, it increments, if it's
+  // not it sets as 1
+  // Because we are a string place holder, the next actual operand would just start at one. If the
+  // join is added
+  // after a valid operand has already set the counter to an integer, we instead just ignore and do
+  // not set the place holder
+  private final static String PLACEHOLDER_FOR_JOIN = "join";
+
-    if (!((operator == LITERAL_or || 
-        operator == LITERAL_and) && operands.length >= 2)) { 
+    if (!((operator == LITERAL_or || operator == LITERAL_and) && operands.length >= 2)) {
-        "operator=" + operator + "operands.length =" + operands.length); }
+          "operator=" + operator + "operands.length =" + operands.length);
+    }
-  
+
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-        if (((Boolean) r).booleanValue() && _operator == LITERAL_or)
-          return r;
-        else if (!((Boolean) r).booleanValue() && _operator == LITERAL_and)
-            return r;
+      if (((Boolean) r).booleanValue() && _operator == LITERAL_or)
+        return r;
+      else if (!((Boolean) r).booleanValue() && _operator == LITERAL_and)
+        return r;
-        throw new TypeMismatchException(LocalizedStrings.CompiledJunction_LITERAL_ANDLITERAL_OR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0.toLocalizedString(r.getClass().getName()));
+      throw new TypeMismatchException(
+          LocalizedStrings.CompiledJunction_LITERAL_ANDLITERAL_OR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0
+              .toLocalizedString(r.getClass().getName()));
-          if (((Boolean) ri).booleanValue() && _operator == LITERAL_or)
-            return ri;
-          else if (!((Boolean) ri).booleanValue() && _operator == LITERAL_and)
-              return ri;
-      if (ri == null || ri == QueryService.UNDEFINED
-          || r == QueryService.UNDEFINED) {
+        if (((Boolean) ri).booleanValue() && _operator == LITERAL_or)
+          return ri;
+        else if (!((Boolean) ri).booleanValue() && _operator == LITERAL_and)
+          return ri;
+      if (ri == null || ri == QueryService.UNDEFINED || r == QueryService.UNDEFINED) {
-      }
-      else if (!(ri instanceof Boolean))
-          throw new TypeMismatchException(LocalizedStrings.CompiledJunction_LITERAL_ANDLITERAL_OR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0.toLocalizedString(ri.getClass().getName()));
+      } else if (!(ri instanceof Boolean))
+        throw new TypeMismatchException(
+            LocalizedStrings.CompiledJunction_LITERAL_ANDLITERAL_OR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0
+                .toLocalizedString(ri.getClass().getName()));
-        r = Boolean.valueOf(((Boolean) r).booleanValue()
-            && ((Boolean) ri).booleanValue());
+        r = Boolean.valueOf(((Boolean) r).booleanValue() && ((Boolean) ri).booleanValue());
-        r = Boolean.valueOf(((Boolean) r).booleanValue()
-            || ((Boolean) ri).booleanValue());
+        r = Boolean.valueOf(((Boolean) r).booleanValue() || ((Boolean) ri).booleanValue());
-      context.addDependencies(this, this._operands[i]
-          .computeDependencies(context));
+      context.addDependencies(this, this._operands[i].computeDependencies(context));
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-    result = newOperands.isSingleFilter ? (newOperands.filterOperand)
-        .filterEvaluate(context, result) : (newOperands.filterOperand)
-        .auxFilterEvaluate(context, result);
+    result =
+        newOperands.isSingleFilter ? (newOperands.filterOperand).filterEvaluate(context, result)
+            : (newOperands.filterOperand).auxFilterEvaluate(context, result);
-      List unevaluatedOps = ((CompiledJunction)newOperands.filterOperand).unevaluatedFilterOperands;
+      List unevaluatedOps =
+          ((CompiledJunction) newOperands.filterOperand).unevaluatedFilterOperands;
-            newOperands.iterateOperand = (CompiledValue)unevaluatedOps.get(0);
-          }
-          else {
+            newOperands.iterateOperand = (CompiledValue) unevaluatedOps.get(0);
+          } else {
-              iterOps[i] = (CompiledValue)unevaluatedOps.get(i);
+              iterOps[i] = (CompiledValue) unevaluatedOps.get(i);
-            newOperands.iterateOperand = new CompiledJunction(iterOps,
-                getOperator());
+            newOperands.iterateOperand = new CompiledJunction(iterOps, getOperator());
-        }
-        else {
+        } else {
-            CompiledJunction temp = (CompiledJunction)newOperands.iterateOperand;
+            CompiledJunction temp = (CompiledJunction) newOperands.iterateOperand;
-          }
-          else {
+          } else {
-            combinedOps[j++] = (CompiledValue)itr.next();
+            combinedOps[j++] = (CompiledValue) itr.next();
-          newOperands.iterateOperand = new CompiledJunction(combinedOps,
-              getOperator());
+          newOperands.iterateOperand = new CompiledJunction(combinedOps, getOperator());
-  private List getCondtionsSortedOnIncreasingEstimatedIndexResultSize(
-      ExecutionContext context) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  private List getCondtionsSortedOnIncreasingEstimatedIndexResultSize(ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-   * invariant: all operands are known to be evaluated as a filter no operand
-   * organization is necessary
+   * invariant: all operands are known to be evaluated as a filter no operand organization is
+   * necessary
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+      SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-    List sortedConditionsList = this.getCondtionsSortedOnIncreasingEstimatedIndexResultSize(context);
+    List sortedConditionsList =
+        this.getCondtionsSortedOnIncreasingEstimatedIndexResultSize(context);
-      SelectResults filterResults = ((Filter) sortedConditionsItr.next()).filterEvaluate(context, null);
+      SelectResults filterResults =
+          ((Filter) sortedConditionsItr.next()).filterEvaluate(context, null);
-        }
-        else if (filterResults != null) {
+        } else if (filterResults != null) {
-      }
-      else {
-        //Asif : In case of OR clause, the filterEvaluate cannot return a
+      } else {
+        // Asif : In case of OR clause, the filterEvaluate cannot return a
-    if (_operator == LITERAL_and && !sortedConditionsList.isEmpty()) {          
+    if (_operator == LITERAL_and && !sortedConditionsList.isEmpty()) {
-    }    
+    }
-   SelectResults auxIterateEvaluate(CompiledValue operand,
-      ExecutionContext context, SelectResults intermediateResults)
-      throws FunctionDomainException, TypeMismatchException,
+  SelectResults auxIterateEvaluate(CompiledValue operand, ExecutionContext context,
+      SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
-     
+
-    
-     // This also implies that there will be at least one operand which will be
+
+    // This also implies that there will be at least one operand which will be
-        throw new RuntimeException(LocalizedStrings.CompiledJunction_INTERMEDIATERESULTS_CAN_NOT_BE_NULL.toLocalizedString());
+      throw new RuntimeException(
+          LocalizedStrings.CompiledJunction_INTERMEDIATERESULTS_CAN_NOT_BE_NULL
+              .toLocalizedString());
-        return intermediateResults;
+      return intermediateResults;
-    ObjectType elementType = intermediateResults.getCollectionType()
-        .getElementType();
-    SelectResults resultSet ;
-    if(elementType.isStructType()) {
-      resultSet = QueryUtils.createStructCollection(context, (StructTypeImpl) elementType) ;
-    }else {
+    ObjectType elementType = intermediateResults.getCollectionType().getElementType();
+    SelectResults resultSet;
+    if (elementType.isStructType()) {
+      resultSet = QueryUtils.createStructCollection(context, (StructTypeImpl) elementType);
+    } else {
-        
-     
+
+
-        }
-        else {
+        } else {
-        }
-        finally {
+        } finally {
-          if (((Boolean) result).booleanValue()) resultSet.add(tuple);
-        }
-        else if (result != null && result != QueryService.UNDEFINED)
-            throw new TypeMismatchException(LocalizedStrings.CompiledJunction_ANDOR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0.toLocalizedString(result.getClass().getName()));
+          if (((Boolean) result).booleanValue())
+            resultSet.add(tuple);
+        } else if (result != null && result != QueryService.UNDEFINED)
+          throw new TypeMismatchException(
+              LocalizedStrings.CompiledJunction_ANDOR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0
+                  .toLocalizedString(result.getClass().getName()));
-    }
-    finally {
+    } finally {
-   * invariant: all operands are known to be evaluated as a filter no operand
-   * organization is necessary
+   * invariant: all operands are known to be evaluated as a filter no operand organization is
+   * necessary
-  protected PlanInfo protGetPlanInfo(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  protected PlanInfo protGetPlanInfo(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    //     then change default evalAsFilter from false to true
+    // then change default evalAsFilter from false to true
-      }
-      else if (isOr && !opPlanInfo.evalAsFilter) {
+      } else if (isOr && !opPlanInfo.evalAsFilter) {
-   * TODO: Should composite operands be part of iterator operands of
-   * CompiledJunction or should it be part of AllGroupJunction Write a unit Test
-   * for this function.
+   * TODO: Should composite operands be part of iterator operands of CompiledJunction or should it
+   * be part of AllGroupJunction Write a unit Test for this function.
-   * Asif: The iterators which can be considered part of GroupJunction are
-   * those which are exclusively dependent only on the independent
-   * iterator of the group. Any iterator which is ultimately dependent
-   * on more than one independent iterators cannot be assumed to be part of
-   * the GroupJunction, even if one of independent iterator belongs to a
-   * different scope.
+   * Asif: The iterators which can be considered part of GroupJunction are those which are
+   * exclusively dependent only on the independent iterator of the group. Any iterator which is
+   * ultimately dependent on more than one independent iterators cannot be assumed to be part of the
+   * GroupJunction, even if one of independent iterator belongs to a different scope.
-  OrganizedOperands organizeOperands(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  OrganizedOperands organizeOperands(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      }
-      else if (operand instanceof CompiledJunction) {
+      } else if (operand instanceof CompiledJunction) {
-        }
-        else {
+        } else {
-      }
-      else {
+      } else {
-        // execution. We expand only if the current junction is AND because if its 
+        // execution. We expand only if the current junction is AND because if its
-        
-        if (operand.getType() == LIKE
-            && this._operator == OQLLexerTokenTypes.LITERAL_and
+
+        if (operand.getType() == LIKE && this._operator == OQLLexerTokenTypes.LITERAL_and
-          expandedOperands = ((CompiledLike) operand)
-              .getExpandedOperandsWithIndexInfoSetIfAny(context);
+          expandedOperands =
+              ((CompiledLike) operand).getExpandedOperandsWithIndexInfoSetIfAny(context);
-          expandedOperands = new CompiledValue[] { operand };
+          expandedOperands = new CompiledValue[] {operand};
-        
+
-          isJunctionNeeded = isJunctionNeeded
-              || operandEvalAsFilter;
-          Set set = QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(
-              expndOperand, context);
+          isJunctionNeeded = isJunctionNeeded || operandEvalAsFilter;
+          Set set = QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(expndOperand, context);
-            }
-            else {
+            } else {
-          }
-          else {
-            Support
-                .Assert(set.size() == 1,
-                    "The size has to be 1 & cannot be zero as that would mean it is independent");
-            RuntimeIterator rIter = (RuntimeIterator)set.iterator().next();
-            List operandsList = (List)iterToOperands.get(rIter);
+          } else {
+            Support.Assert(set.size() == 1,
+                "The size has to be 1 & cannot be zero as that would mean it is independent");
+            RuntimeIterator rIter = (RuntimeIterator) set.iterator().next();
+            List operandsList = (List) iterToOperands.get(rIter);
-     * Asif : If there exists a SingleGroupJunction & no other Filter operand ,
-     * then all remaining eval operands ( even if they are CompiledJunction which
-     * are not evaluable as Filter) & composite operands should become part of
-     * GroupJunction. If there exists only SingleGroupJunction & at least one
-     * Filter operand, then all conditions of GroupJunction which are not filter
-     * evaluable should become iter operand of CompiledJunction. If there
-     * exists an AllGroupJunction & no Filter operand, then all remaining iter
-     * operands of CompiledJunction along with Composite operands should be part
-     * of AllGroupJunction. If there exists at least one Filter operand , all
-     * remaining operands of AllGroupJunction ( including those GroupJunction not
-     * filter evaluable should become part of eval operand of
-     * CompiledJunction) The index count will give the idea of number of filter
-     * operands
+     * Asif : If there exists a SingleGroupJunction & no other Filter operand , then all remaining
+     * eval operands ( even if they are CompiledJunction which are not evaluable as Filter) &
+     * composite operands should become part of GroupJunction. If there exists only
+     * SingleGroupJunction & at least one Filter operand, then all conditions of GroupJunction which
+     * are not filter evaluable should become iter operand of CompiledJunction. If there exists an
+     * AllGroupJunction & no Filter operand, then all remaining iter operands of CompiledJunction
+     * along with Composite operands should be part of AllGroupJunction. If there exists at least
+     * one Filter operand , all remaining operands of AllGroupJunction ( including those
+     * GroupJunction not filter evaluable should become part of eval operand of CompiledJunction)
+     * The index count will give the idea of number of filter operands
-      Filter junction = createJunction(compositeIterOperands,
-          compositeFilterOpsMap, iterToOperands, context, indexCount,
-          evalOperands, indexExistsOnNonJoinOp);
+      Filter junction = createJunction(compositeIterOperands, compositeFilterOpsMap, iterToOperands,
+          context, indexCount, evalOperands, indexExistsOnNonJoinOp);
-    }
-    else {
+    } else {
-    }
-    else {
+    } else {
-    //int numIterating = _operands.length - indexCount;
+    // int numIterating = _operands.length - indexCount;
-  
+
-   * Creates a GroupJunction or a RangeJunction based on the operands passed.
-   * The operands are either Filter Operands belonging to single independent
-   * RuntimeIterator or are iter evaluable on the RuntimeIterator[] passed as
-   * parameter. If all the filter evaluable operands use a single Index , than
-   * a RangeJunction is created with iter operand as part of RangeJunction. If
-   * there exists operands using multiple indexes, then a GroupJunction is
-   * created. In that case , the operands using the same index are grouped in a
-   * RangeJunction & that Range Junction becomes part of the GroupJunction. A
-   * GroupJunction may contain one or more RangeJunction
+   * Creates a GroupJunction or a RangeJunction based on the operands passed. The operands are
+   * either Filter Operands belonging to single independent RuntimeIterator or are iter evaluable on
+   * the RuntimeIterator[] passed as parameter. If all the filter evaluable operands use a single
+   * Index , than a RangeJunction is created with iter operand as part of RangeJunction. If there
+   * exists operands using multiple indexes, then a GroupJunction is created. In that case , the
+   * operands using the same index are grouped in a RangeJunction & that Range Junction becomes part
+   * of the GroupJunction. A GroupJunction may contain one or more RangeJunction
-   * @param needsCompacting
-   *                boolean indicating if there is a possibility of
-   *                RangeJunction or not. If needsCompacting is false , then a
-   *                GroupJunction will be formed, without any RangeJunction
-   * @param grpIndpndntItr
-   *                Array of RuntimeIterator which represents the independent
-   *                iterator for the Group. for all cases , except a
-   *                CompositeGroupJunction containing a single GroupJunction ,
-   *                will have a single RuntimeIterator in this array.
-   * @param completeExpnsn
-   *                boolean indicating whether the Group or Range Junction needs
-   *                to be expanded to the query from clause level or the group
-   *                level
-   * @param cv
-   *                Array of CompiledValue containing operands belonging to a
-   *                group
-   * @param sameIndexOperands
-   *                Map object containing Index as the key & as a value an
-   *                Integer object or a List. If it contains an Integer as value
-   *                against Index, it implies that there is only one operand
-   *                which uses that type of index & hence cannot form a
-   *                RangeJunction. If it contains a List then the Lis contains
-   *                the operands which use same index & thus can form a
-   *                RangeJunction
+   * @param needsCompacting boolean indicating if there is a possibility of RangeJunction or not. If
+   *        needsCompacting is false , then a GroupJunction will be formed, without any
+   *        RangeJunction
+   * @param grpIndpndntItr Array of RuntimeIterator which represents the independent iterator for
+   *        the Group. for all cases , except a CompositeGroupJunction containing a single
+   *        GroupJunction , will have a single RuntimeIterator in this array.
+   * @param completeExpnsn boolean indicating whether the Group or Range Junction needs to be
+   *        expanded to the query from clause level or the group level
+   * @param cv Array of CompiledValue containing operands belonging to a group
+   * @param sameIndexOperands Map object containing Index as the key & as a value an Integer object
+   *        or a List. If it contains an Integer as value against Index, it implies that there is
+   *        only one operand which uses that type of index & hence cannot form a RangeJunction. If
+   *        it contains a List then the Lis contains the operands which use same index & thus can
+   *        form a RangeJunction
-  private AbstractGroupOrRangeJunction createGroupJunctionOrRangeJunction(
-      boolean needsCompacting, RuntimeIterator[] grpIndpndntItr,
-      boolean completeExpnsn, CompiledValue[] cv, Map sameIndexOperands) {
+  private AbstractGroupOrRangeJunction createGroupJunctionOrRangeJunction(boolean needsCompacting,
+      RuntimeIterator[] grpIndpndntItr, boolean completeExpnsn, CompiledValue[] cv,
+      Map sameIndexOperands) {
-        List sameIndexOps = (List)itr.next();
+        List sameIndexOps = (List) itr.next();
-            cv[i] = (CompiledValue)sameIndexOpsItr.next();
+            cv[i] = (CompiledValue) sameIndexOpsItr.next();
-        junction = new RangeJunction(this._operator, grpIndpndntItr,
-            completeExpnsn, cv);
-      }
-      else {
+        junction = new RangeJunction(this._operator, grpIndpndntItr, completeExpnsn, cv);
+      } else {
-        CompiledValue[] rangeJunctions = new CompiledValue[sameIndexOperands
-            .size()];
+        CompiledValue[] rangeJunctions = new CompiledValue[sameIndexOperands.size()];
-            List ops = (List)listOrPosition;
+            List ops = (List) listOrPosition;
-            CompiledValue operands[] = (CompiledValue[])ops
-                .toArray(new CompiledValue[ops.size()]);
-            rangeJunctions[numRangeJunctions++] = new RangeJunction(
-                this._operator, grpIndpndntItr, completeExpnsn, operands);
+            CompiledValue operands[] = (CompiledValue[]) ops.toArray(new CompiledValue[ops.size()]);
+            rangeJunctions[numRangeJunctions++] =
+                new RangeJunction(this._operator, grpIndpndntItr, completeExpnsn, operands);
-        junction = new GroupJunction(this._operator, grpIndpndntItr,
-            completeExpnsn, allOperands);
+        junction = new GroupJunction(this._operator, grpIndpndntItr, completeExpnsn, allOperands);
-    }
-    else {
-      junction = new GroupJunction(this._operator, grpIndpndntItr,
-          completeExpnsn, cv);
+    } else {
+      junction = new GroupJunction(this._operator, grpIndpndntItr, completeExpnsn, cv);
-  
-  private boolean sortSameIndexOperandsForGroupJunction(CompiledValue cv[],
-      List operandsList, Map sameIndexOperands, ExecutionContext context)
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException, FunctionDomainException,
-      QueryInvocationTargetException {
+
+  private boolean sortSameIndexOperandsForGroupJunction(CompiledValue cv[], List operandsList,
+      Map sameIndexOperands, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException,
+      FunctionDomainException, QueryInvocationTargetException {
-      tempOp = (CompiledValue)operandsList.get(i);
+      tempOp = (CompiledValue) operandsList.get(i);
-      //TODO:Do not club Like predicate in an existing range
-      if (evalAsFilter ) {
-        indx = ((Indexable)tempOp).getIndexInfo(context);
-        //We are now sorting these for joins, therefore we need to weed out the join indexes
+      // TODO:Do not club Like predicate in an existing range
+      if (evalAsFilter) {
+        indx = ((Indexable) tempOp).getIndexInfo(context);
+        // We are now sorting these for joins, therefore we need to weed out the join indexes
-    
-     if (listOrPosition != null) {
+
+      if (listOrPosition != null) {
-          int position = ((Integer)listOrPosition).intValue();
+          int position = ((Integer) listOrPosition).intValue();
-        }
-        else if (listOrPosition instanceof List){
-          List operands = (List)listOrPosition;
+        } else if (listOrPosition instanceof List) {
+          List operands = (List) listOrPosition;
-        }
-        else {
-          //a join was present here, let's now occupy that spot and remove the placeholder
+        } else {
+          // a join was present here, let's now occupy that spot and remove the placeholder
-     }
+      }
-  //This is called only if the CompiledJunction was either independent or filter evaluable.
-  public int getSizeEstimate(ExecutionContext context)throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
-    if( this.isDependentOnCurrentScope(context)) {    
-  return Integer.MAX_VALUE;
-    }else {
+
+  // This is called only if the CompiledJunction was either independent or filter evaluable.
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    if (this.isDependentOnCurrentScope(context)) {
+      return Integer.MAX_VALUE;
+    } else {
-  private Filter createJunction(List compositeIterOperands,
-      Map compositeFilterOpsMap, Map iterToOperands, ExecutionContext context,
-      int indexCount, List evalOperands, boolean indexExistsOnNonJoinOp) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    Support.Assert(!(iterToOperands.isEmpty() && compositeFilterOpsMap
-        .isEmpty()),
+  private Filter createJunction(List compositeIterOperands, Map compositeFilterOpsMap,
+      Map iterToOperands, ExecutionContext context, int indexCount, List evalOperands,
+      boolean indexExistsOnNonJoinOp) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+    Support.Assert(!(iterToOperands.isEmpty() && compositeFilterOpsMap.isEmpty()),
-        // without the optimization we only fall into here if it's empty anyways, but have not tested the removal of this if clause
+        // without the optimization we only fall into here if it's empty anyways, but have not
+        // tested the removal of this if clause
-      }
-      else {
+      } else {
-      size = operandsList.size();      
+      size = operandsList.size();
-      //Enable only for AND junction
-      boolean needsCompacting = sortSameIndexOperandsForGroupJunction(cv,operandsList, sameIndexOperands, context);      
-      junction = createGroupJunctionOrRangeJunction(needsCompacting, new RuntimeIterator[] { (RuntimeIterator)entry.getKey()},  true /* need a Complete expansion */, cv, sameIndexOperands);      
+      // Enable only for AND junction
+      boolean needsCompacting =
+          sortSameIndexOperandsForGroupJunction(cv, operandsList, sameIndexOperands, context);
+      junction = createGroupJunctionOrRangeJunction(needsCompacting,
+          new RuntimeIterator[] {(RuntimeIterator) entry.getKey()},
+          true /* need a Complete expansion */, cv, sameIndexOperands);
-     * Asif : An AllGroupJunction or a CompositeGroupJunction can get created.
-     * An AllGroupJunction will get created , if there exists a need to create
-     * more than one CompositeGroupJunction AND/OR more than one GroupJunctions (
-     * not part of CompositeGroupJunction) If suppose the where clause contained
-     * two sets of conditions each dependent exclusively on a separate
-     * independent group ( implying two independent groups) then we should
-     * create an AllGroupJunction iff the two Groups are both filter
-     * evaluable. If an AllGroupJunction contains only one filter evaluable
-     * Group & no CompositeGroupJunction then we should just create a
-     * singleGroupJunction with complete expansion as true
+     * Asif : An AllGroupJunction or a CompositeGroupJunction can get created. An AllGroupJunction
+     * will get created , if there exists a need to create more than one CompositeGroupJunction
+     * AND/OR more than one GroupJunctions ( not part of CompositeGroupJunction) If suppose the
+     * where clause contained two sets of conditions each dependent exclusively on a separate
+     * independent group ( implying two independent groups) then we should create an
+     * AllGroupJunction iff the two Groups are both filter evaluable. If an AllGroupJunction
+     * contains only one filter evaluable Group & no CompositeGroupJunction then we should just
+     * create a singleGroupJunction with complete expansion as true
-          CompositeGroupJunction temp = (CompositeGroupJunction) tempMap
-              .get(ritr);
+          CompositeGroupJunction temp = (CompositeGroupJunction) tempMap.get(ritr);
-          }
-          else if (cgj != null && temp != null && cgj != temp) {
+          } else if (cgj != null && temp != null && cgj != temp) {
-        entry = (Map.Entry)itr.next();
-        List operandsList = (List)entry.getValue();
+        entry = (Map.Entry) itr.next();
+        List operandsList = (List) entry.getValue();
-          tempOp = (CompiledValue)operandsList.get(j);
+          tempOp = (CompiledValue) operandsList.get(j);
-            indx = ((Indexable)tempOp).getIndexInfo(context);
+            indx = ((Indexable) tempOp).getIndexInfo(context);
-              int position = ((Integer)listOrPosition).intValue();
+              int position = ((Integer) listOrPosition).intValue();
-            }
-            else {
-              List operands = (List)listOrPosition;
+            } else {
+              List operands = (List) listOrPosition;
-          }
-          else {
+          } else {
-            if (isFilterevaluable
-                && this._operator == OQLLexerTokenTypes.LITERAL_and) {
+            if (isFilterevaluable && this._operator == OQLLexerTokenTypes.LITERAL_and) {
-          }
-          else {
+          } else {
-        }
-        else {
-          RuntimeIterator grpIndpndtItr = (RuntimeIterator)entry.getKey();
-          AbstractGroupOrRangeJunction gj = createGroupJunctionOrRangeJunction(
-              needsCompacting, new RuntimeIterator[] { (RuntimeIterator)entry
-                  .getKey() }, false/* Expand only to Group Level */, cv,
-              sameIndexOperands);
+        } else {
+          RuntimeIterator grpIndpndtItr = (RuntimeIterator) entry.getKey();
+          AbstractGroupOrRangeJunction gj = createGroupJunctionOrRangeJunction(needsCompacting,
+              new RuntimeIterator[] {(RuntimeIterator) entry.getKey()},
+              false/* Expand only to Group Level */, cv, sameIndexOperands);
-          if ((cgj = (CompositeGroupJunction)tempMap.get(grpIndpndtItr)) != null) {
+          if ((cgj = (CompositeGroupJunction) tempMap.get(grpIndpndtItr)) != null) {
-          }
-          else {
+          } else {
-      }
-      else {
+      } else {
-        CompositeGroupJunction compGrpJnc = (CompositeGroupJunction) cgjs
-            .iterator().next();
+        CompositeGroupJunction compGrpJnc = (CompositeGroupJunction) cgjs.iterator().next();
-      }
-      else if (gjs.size() == 1 && cgjSize == 0) {
+      } else if (gjs.size() == 1 && cgjSize == 0) {
-        junction = gjTemp.createNewOfSameType(this._operator,gjTemp.getIndependentIteratorForGroup(), true/* The expansion needs to be complete */, newOps);   
-         
-      }
-      else {
+        junction =
+            gjTemp.createNewOfSameType(this._operator, gjTemp.getIndependentIteratorForGroup(),
+                true/* The expansion needs to be complete */, newOps);
+
+      } else {
-  OrganizedOperands testOrganizedOperands(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  OrganizedOperands testOrganizedOperands(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-  public boolean isProjectionEvaluationAPossibility(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException
-  {
-    for (int i=0; i<this._operands.length; ++i) {
+  public boolean isProjectionEvaluationAPossibility(ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    for (int i = 0; i < this._operands.length; ++i) {
-      if ((this._operands[i].getType() == JUNCTION || this._operands[i]
-          .getType() == LIKE)
+      if ((this._operands[i].getType() == JUNCTION || this._operands[i].getType() == LIKE)
-  
-  /* 
-   * This method checks the limit applicability on index intermediate results for
-   * junctions and optimizes the limit on index intermediate results ONLY if ONE index
-   * is used for whole query and all conditions in where clause use that index. Look at
-   * the call hierarchy of this function. There are two cases:
+
+  /*
+   * This method checks the limit applicability on index intermediate results for junctions and
+   * optimizes the limit on index intermediate results ONLY if ONE index is used for whole query and
+   * all conditions in where clause use that index. Look at the call hierarchy of this function.
+   * There are two cases:
-   * CompiledJunction (or subjunction). we recursively check if all of those use the same index
-   * and if ANY one of those comparisons or subjunctions does not use the index, it retruns false.
+   * CompiledJunction (or subjunction). we recursively check if all of those use the same index and
+   * if ANY one of those comparisons or subjunctions does not use the index, it retruns false.
-   * Literal_AND: If we get combination of comparisons and subjunctions then limit is NOT
-   * applicable on index results. Like, "where ID != 10 AND (ID < 5 OR ID > 10) LIMIT 5". 
-   * If we get only comparisons ONLY then if all comparisons use the same index then limit
-   * is applicable and this returns true. Like, "where ID != 10 AND (ID < 5 AND ID > 10) LIMIT 5".
+   * Literal_AND: If we get combination of comparisons and subjunctions then limit is NOT applicable
+   * on index results. Like, "where ID != 10 AND (ID < 5 OR ID > 10) LIMIT 5". If we get only
+   * comparisons ONLY then if all comparisons use the same index then limit is applicable and this
+   * returns true. Like, "where ID != 10 AND (ID < 5 AND ID > 10) LIMIT 5".
-  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
-    if(this._operator == LITERAL_or) {
-      //There is a slight inefficiency in the sense that if the subjunction ( say AND) cannot apply limit,
-      // then limit would not be applied at remaining conditions of OR. But since we have single flag
-      //governing the behaviour of applying limit at index level, we cannot make it true for specific clauses
-      for (int i=0; i<this._operands.length; ++i) {
-        if( !this._operands[i].getPlanInfo(context).evalAsFilter || ((Filter)this._operands[i]).isLimitApplicableAtIndexLevel(context)) {
+  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    if (this._operator == LITERAL_or) {
+      // There is a slight inefficiency in the sense that if the subjunction ( say AND) cannot apply
+      // limit,
+      // then limit would not be applied at remaining conditions of OR. But since we have single
+      // flag
+      // governing the behaviour of applying limit at index level, we cannot make it true for
+      // specific clauses
+      for (int i = 0; i < this._operands.length; ++i) {
+        if (!this._operands[i].getPlanInfo(context).evalAsFilter
+            || ((Filter) this._operands[i]).isLimitApplicableAtIndexLevel(context)) {
-      return true;      
-    }else {
-      //For limit to be applicable on a AND junction, there should be only one type of index used and rest iter evaluable
-      //But since the selection of which index to use happens in GroupJunction created at runtimke, we do not have that
-      //information yet, and at this point there would be multiple indexes. Ideally we should invoke this function in GroupJunction,
-      //in case we want to support multi index usage again at some point. Till then since it is hard coded to use 1 index
+      return true;
+    } else {
+      // For limit to be applicable on a AND junction, there should be only one type of index used
+      // and rest iter evaluable
+      // But since the selection of which index to use happens in GroupJunction created at runtimke,
+      // we do not have that
+      // information yet, and at this point there would be multiple indexes. Ideally we should
+      // invoke this function in GroupJunction,
+      // in case we want to support multi index usage again at some point. Till then since it is
+      // hard coded to use 1 index
-        if( this._operands[i].getPlanInfo(context).evalAsFilter &&  this._operands[i].getType() == JUNCTION) {
+        if (this._operands[i].getPlanInfo(context).evalAsFilter
+            && this._operands[i].getType() == JUNCTION) {
-  
+
-  public boolean isOrderByApplicableAtIndexLevel(ExecutionContext context, String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    if(this._operator == LITERAL_and) {
-      //Set<IndexProtocol> usedIndex = new HashSet<IndexProtocol>();
+  public boolean isOrderByApplicableAtIndexLevel(ExecutionContext context,
+      String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+    if (this._operator == LITERAL_and) {
+      // Set<IndexProtocol> usedIndex = new HashSet<IndexProtocol>();
-      for (int i=0; i<this._operands.length; ++i) {
-        PlanInfo pi =this._operands[i].getPlanInfo(context); 
-        if( pi.evalAsFilter &&  this._operands[i].getType() == JUNCTION) {
+      for (int i = 0; i < this._operands.length; ++i) {
+        PlanInfo pi = this._operands[i].getPlanInfo(context);
+        if (pi.evalAsFilter && this._operands[i].getType() == JUNCTION) {
-        }else if(pi.evalAsFilter) {
-          if(!foundRightIndex) {
-            IndexProtocol ip = (IndexProtocol)this._operands[i].getPlanInfo(context).indexes.get(0);           
-            if(ip.getCanonicalizedIndexedExpression().equals(canonicalizedOrderByClause) && pi.isPreferred ) {
+        } else if (pi.evalAsFilter) {
+          if (!foundRightIndex) {
+            IndexProtocol ip =
+                (IndexProtocol) this._operands[i].getPlanInfo(context).indexes.get(0);
+            if (ip.getCanonicalizedIndexedExpression().equals(canonicalizedOrderByClause)
+                && pi.isPreferred) {
-          //usedIndex.addAll(this._operands[i].getPlanInfo(context).indexes);
+          // usedIndex.addAll(this._operands[i].getPlanInfo(context).indexes);
-//      if(usedIndex.size() == 1 && usedIndex.iterator().next().getCanonicalizedIndexedExpression().equals(canonicalizedOrderByClause)) {
-//        return true;
-//      }
+      // if(usedIndex.size() == 1 &&
+      // usedIndex.iterator().next().getCanonicalizedIndexedExpression().equals(canonicalizedOrderByClause))
+      // {
+      // return true;
+      // }
-  
+
-   * class CGJData { RuntimeIterator [] indpndItrs = null; List iterOperands =
-   * null; List groupJunctions = null; CompiledValue []
-   * compositeCompiledComparisons = null;
+   * class CGJData { RuntimeIterator [] indpndItrs = null; List iterOperands = null; List
+   * groupJunctions = null; CompiledValue [] compositeCompiledComparisons = null;
-   * CGJData(RuntimeIterator [] indpndItrs, List iterOperands,List
-   * groupJunctions, CompiledValue [] compositeCompiledComparisons) {
-   * this.indpndItrs = indpndItrs; this.iterOperands = iterOperands;
+   * CGJData(RuntimeIterator [] indpndItrs, List iterOperands,List groupJunctions, CompiledValue []
+   * compositeCompiledComparisons) { this.indpndItrs = indpndItrs; this.iterOperands = iterOperands;

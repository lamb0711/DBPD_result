Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.cache.query.internal.CompiledSelect;
+import com.gemstone.gemfire.cache.query.internal.NWayMergeResults;
+import com.gemstone.gemfire.cache.query.types.ObjectType;
-  private final List _bucketsToQuery;
+  private final List<Integer> _bucketsToQuery;
+  private volatile ObjectType resultType = null; 
-      DefaultQuery query, Object[] parameters, List buckets) {
+      DefaultQuery query, Object[] parameters, List<Integer> buckets) {
+   * @return boolean true if the result is a struct type
-  public void executeQuery(Collection<Collection> resultCollector)
+  public boolean executeQuery(Collection<Collection> resultCollector)
-    }    
+    }
+    return this.resultType.isStructType();
+        
+        CompiledSelect cs = this.query.getSimpleSelect();
+       
+        if(cs != null && (cs.isOrderBy() || cs.isGroupBy())) {      
+          ExecutionContext context = new QueryExecutionContext(this.parameters, pr.getCache());
+          int limit = this.query.getLimit(parameters);
+          Collection mergedResults =coalesceOrderedResults(resultCollector, context, cs, limit);
+          resultCollector.clear();
+          resultCollector.add(mergedResults);
+        }
+          this.resultType = results.getCollectionType().getElementType(); 
-    context.setBucketList(buckets);
-    context.setCqQueryContext(query.isCqQuery());
+    CompiledSelect cs = this.query.getSimpleSelect();
+    int limit = this.query.getLimit(parameters);
+    if(cs != null && cs.isOrderBy() ) {
+      for(Integer bucketID : this._bucketsToQuery) {
+        List<Integer> singleBucket = Collections.singletonList(bucketID);
+        context.setBucketList(singleBucket);
+        executeQueryOnBuckets(resultCollector, context);
+      }     
+      Collection mergedResults =coalesceOrderedResults(resultCollector, context, cs, limit);
+      resultCollector.clear();
+      resultCollector.add(mergedResults);
+      
+    }else {
+      context.setBucketList(buckets);        
+      executeQueryOnBuckets(resultCollector, context);
+    }
+  }
+  
+  private Collection coalesceOrderedResults(Collection<Collection> results, 
+      ExecutionContext context, CompiledSelect cs, int limit) {
+    List<Collection> sortedResults = new ArrayList<Collection>(results.size());
+    //TODO :Asif : Deal with UNDEFINED
+    for(Object o : results) {
+      if(o instanceof Collection) {
+        sortedResults.add((Collection)o);
+      }        
+    }
+   
+    NWayMergeResults mergedResults = new NWayMergeResults(sortedResults, cs.isDistinct(), limit, 
+        cs.getOrderByAttrs(), context,cs.getElementTypeForOrderByQueries());
+    return mergedResults;
+  
+  }
+
+  private void executeQueryOnBuckets(Collection<Collection> resultCollector,
+      ExecutionContext context) throws ForceReattemptException,
+      QueryInvocationTargetException, QueryException {
+    context.setCqQueryContext(query.isCqQuery());
-      synchronized (resultCollector) {
-        if (results == QueryService.UNDEFINED) {
+      
+      synchronized (resultCollector) {        
+        //TODO:Asif: In what situation would the results object itself be undefined?
+        // The elements of the results can be undefined , but not the resultset itself
+        /*if (results == QueryService.UNDEFINED) {
-        } else {
+        } else {*/
+          this.resultType = ((SelectResults)results).getCollectionType().getElementType(); 
-        }
+        //}
-        ArrayList bucketList = new ArrayList();
-        bucketList.add(this._bucketId);
-        executeSequentially(this.resultColl, bucketList);
+        List<Integer> bucketList = Collections.singletonList(bId);       
+        ExecutionContext context = new QueryExecutionContext(this.parameters, pr.getCache(), this.query);
+        context.setBucketList(bucketList);
+        executeQueryOnBuckets(this.resultColl, context);
+        //executeSequentially(this.resultColl, bucketList);

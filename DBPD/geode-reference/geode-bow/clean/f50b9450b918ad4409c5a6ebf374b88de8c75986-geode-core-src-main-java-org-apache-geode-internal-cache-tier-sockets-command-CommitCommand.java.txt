GEODE-5269 CommitConflictException after TransactionInDoubtException

Before sending a client a TransactionInDoubtException that is caused by
a server shutting down we now wait a bit for the server to finish shutting
down.  This allows any locks it held to be released and avoids a
CommitConflictException if the client should immediately try another
transaction with the same key(s).

+import java.util.concurrent.TimeoutException;
+import org.apache.geode.CancelException;
+import org.apache.geode.cache.TransactionInDoubtException;
+import org.apache.geode.distributed.DistributedMember;
+
+
+    commitTransaction(clientMessage, serverConnection, txMgr, wasInProgress,
+        txProxy);
+  }
+
+  protected void commitTransaction(Message clientMessage, ServerConnection serverConnection,
+      TXManagerImpl txMgr,
+      boolean wasInProgress, TXStateProxy txProxy) throws IOException {
+    Exception txException = null;
+    TXCommitMessage commitMsg = null;
+    TXId txId = txProxy.getTxId();
-
-      txId = txProxy.getTxId();
-
+      logger.debug("Sending commit response to client: {}", commitMsg);
+
-      sendException(clientMessage, serverConnection, e);
+      txException = e;
+    if (txException != null) {
+      DistributedMember target = txProxy.getTarget();
+      // a TransactionInDoubtException caused by the TX host shutting down means that
+      // the transaction may still be active and hold locks. We must wait for the transaction
+      // host to finish shutting down before responding to the client or it could encounter
+      // conflicts in retrying the transaction
+      if ((txException instanceof TransactionInDoubtException)
+          && (txException.getCause() instanceof CancelException)) {
+        logger.info(
+            "Waiting for departure of {} before throwing TransactionInDoubtException.",
+            target);
+        try {
+          serverConnection.getCache().getDistributionManager().getMembershipManager()
+              .waitForDeparture(target);
+        } catch (TimeoutException e) {
+          // status will be logged below
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+        }
+        logger.info("Done waiting.  Transaction host {} in the cluster.",
+            serverConnection.getCache().getDistributionManager().isCurrentMember(target)
+                ? "is still"
+                : "is no longer");
+      }
+      sendException(clientMessage, serverConnection, txException);
+    }
-

GEODE-8170: change all hash and set commands to use function (#5125)

All hash and set commands now use the new function+delta data model.
This allowed the synchronized keyword to be removed from RedisHash and RedisSet.

+import java.util.regex.Pattern;
+import org.apache.geode.redis.internal.Coder;
-  public synchronized void fromDelta(DataInput in) throws IOException, InvalidDeltaException {
+  public void fromDelta(DataInput in) throws IOException, InvalidDeltaException {
-  public synchronized int hset(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
+  public int hset(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
-  public synchronized int hdel(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
+  public int hdel(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
-  public synchronized Collection<ByteArrayWrapper> hgetall() {
+  public Collection<ByteArrayWrapper> hgetall() {
+  public int hexists(ByteArrayWrapper field) {
+    if (hash.containsKey(field)) {
+      return 1;
+    } else {
+      return 0;
+    }
+  }
+
+  public ByteArrayWrapper hget(ByteArrayWrapper field) {
+    return hash.get(field);
+  }
+
+  public int hlen() {
+    return hash.size();
+  }
+
+  public List<ByteArrayWrapper> hmget(List<ByteArrayWrapper> fields) {
+    ArrayList<ByteArrayWrapper> results = new ArrayList<>(fields.size());
+    for (ByteArrayWrapper field : fields) {
+      results.add(hash.get(field));
+    }
+    return results;
+  }
+
+  public Collection<ByteArrayWrapper> hvals() {
+    return new ArrayList<>(hash.values());
+  }
+
+  public Collection<ByteArrayWrapper> hkeys() {
+    return new ArrayList<>(hash.keySet());
+  }
+
+  public List<Object> hscan(Pattern matchPattern, int count, int cursor) {
+    List<Object> returnList = new ArrayList<Object>();
+    int size = hash.size();
+    int beforeCursor = 0;
+    int numElements = 0;
+    int i = -1;
+    for (Map.Entry<ByteArrayWrapper, ByteArrayWrapper> entry : hash.entrySet()) {
+      ByteArrayWrapper key = entry.getKey();
+      ByteArrayWrapper value = entry.getValue();
+      i++;
+      if (beforeCursor < cursor) {
+        beforeCursor++;
+        continue;
+      } else if (numElements < count) {
+        if (matchPattern != null) {
+          if (matchPattern.matcher(key.toString()).matches()) {
+            returnList.add(key);
+            returnList.add(value);
+            numElements++;
+          }
+        } else {
+          returnList.add(key);
+          returnList.add(value);
+          numElements++;
+        }
+      } else {
+        break;
+      }
+    }
+
+    if (i == size - 1) {
+      returnList.add(0, String.valueOf(0));
+    } else {
+      returnList.add(0, String.valueOf(i));
+    }
+    return returnList;
+  }
+
+  public long hincrby(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
+      ByteArrayWrapper field, long increment)
+      throws NumberFormatException, ArithmeticException {
+    ByteArrayWrapper oldValue = hash.get(field);
+    if (oldValue == null) {
+      ByteArrayWrapper newValue = new ByteArrayWrapper(Coder.longToBytes(increment));
+      hash.put(field, newValue);
+      deltas = new ArrayList<>(2);
+      deltas.add(field);
+      deltas.add(newValue);
+      storeChanges(region, key, true);
+      return increment;
+    }
+
+    long value = Long.parseLong(oldValue.toString());
+    if ((value >= 0 && increment > (Long.MAX_VALUE - value))
+        || (value <= 0 && increment < (Long.MIN_VALUE - value))) {
+      throw new ArithmeticException("overflow");
+    }
+
+    value += increment;
+
+    ByteArrayWrapper modifiedValue = new ByteArrayWrapper(Coder.longToBytes(value));
+    hash.put(field, modifiedValue);
+    deltas = new ArrayList<>(2);
+    deltas.add(field);
+    deltas.add(modifiedValue);
+    storeChanges(region, key, true);
+    return value;
+  }
+
+  public double hincrbyfloat(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
+      ByteArrayWrapper field, double increment) throws NumberFormatException {
+    ByteArrayWrapper oldValue = hash.get(field);
+    if (oldValue == null) {
+      ByteArrayWrapper newValue = new ByteArrayWrapper(Coder.doubleToBytes(increment));
+      hash.put(field, newValue);
+      deltas = new ArrayList<>(2);
+      deltas.add(field);
+      deltas.add(newValue);
+      storeChanges(region, key, true);
+      return increment;
+    }
+
+    String valueS = oldValue.toString();
+    if (valueS.contains(" ")) {
+      throw new NumberFormatException("could not convert " + valueS + " to a double");
+    }
+    double value = Coder.stringToDouble(valueS);
+
+    value += increment;
+
+    ByteArrayWrapper modifiedValue = new ByteArrayWrapper(Coder.doubleToBytes(value));
+    hash.put(field, modifiedValue);
+    deltas = new ArrayList<>(2);
+    deltas.add(field);
+    deltas.add(modifiedValue);
+    storeChanges(region, key, true);
+    return value;
+  }
+
-  // the following are needed because not all the hash commands have been converted to functions.
-
-  public synchronized boolean isEmpty() {
-    return hash.isEmpty();
-  }
-
-  public synchronized Collection<Map.Entry<ByteArrayWrapper, ByteArrayWrapper>> entries() {
-    return new ArrayList<>(hash.entrySet());
-  }
-
-  public synchronized ByteArrayWrapper get(ByteArrayWrapper field) {
-    return hash.get(field);
-  }
-
-  public synchronized void put(ByteArrayWrapper field, ByteArrayWrapper value) {
-    hash.put(field, value);
-  }
-
-  public synchronized List<ByteArrayWrapper> keys() {
-    return new ArrayList<>(hash.keySet());
-  }
-
-  public synchronized int size() {
-    return hash.size();
-  }
-
-  public synchronized Collection<ByteArrayWrapper> values() {
-    return new ArrayList<>(hash.values());
-  }
-
-  public synchronized boolean containsKey(ByteArrayWrapper field) {
-    return hash.containsKey(field);
-  }
-

GEODE-5393: StateFlushOperation hangs waiting for non-existant operation to complete

I've added additional debugging to DistributionAdvisor so that it knows
which threads are performing operations and can log them at debug level.
This let me determine that a putAll operation was the source of the hang
due to an exception being thrown during message distribution in
DistributedCacheOperation.startOperation().  The exception resulted in
DistributionAdvisor.endOperation() not being invoked correctly.

+import java.io.OutputStream;
+import java.io.PrintStream;
-   * This system property is not supported and disabling intelligent messaging is currently
-   * problematic
+   * The operationMonitor tracks in-progress cache operations and holds the profile set
+   * version number
-  protected static final boolean disabled = Boolean.getBoolean("disable-intelligent-msg");
-
+  private final OperationMonitor operationMonitor =
+      logger.isDebugEnabled() ? new ThreadTrackingOperationMonitor(this)
+          : new OperationMonitor(this);
-   * the version of the profile set
-   *
-   * @since GemFire 5.1
-   */
-  private long membershipVersion;
-
-  /**
-   * opCountLock guards access to previousVersionOpCount and currentVersionOpCount
-   */
-  private final Object opCountLock = new Object();
-
-  /**
-   * the number of operations in-progress for previous versions of the profile set. Guarded by
-   * opCountLock
-   */
-  private long previousVersionOpCount;
-
-  /**
-   * the number of operations in-progress for the current version of the profile set. Guarded by
-   * opCountLock
-   */
-  private long currentVersionOpCount;
-
-  /**
-        synchronized (this.opCountLock) {
-          this.previousVersionOpCount = 0;
-          this.currentVersionOpCount = 0;
-        }
+        operationMonitor.close();
+
-          membershipVersion++;
-          if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-            logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-                "StateFlush incremented membership version: {}", membershipVersion);
-          }
-          newProfile.initialMembershipVersion = membershipVersion;
-          synchronized (this.opCountLock) {
-            previousVersionOpCount += currentVersionOpCount;
-            currentVersionOpCount = 0;
-          }
+          operationMonitor.initNewProfile(newProfile);
-      forceNewMembershipVersion();
+      operationMonitor.forceNewMembershipVersion();
-  public synchronized void forceNewMembershipVersion() {
-    if (!membershipClosed) {
-      membershipVersion++;
-      if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-        logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-            "StateFlush forced new membership version: {}", membershipVersion);
-      }
-      synchronized (this.opCountLock) {
-        previousVersionOpCount += currentVersionOpCount;
-        currentVersionOpCount = 0;
-        if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE)) {
-          logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE,
-              "advisor for {} forced new membership version to {} previousOpCount={}", getAdvisee(),
-              membershipVersion, previousVersionOpCount);
-        }
-      }
-    }
+  public void forceNewMembershipVersion() {
+    operationMonitor.forceNewMembershipVersion();
-  public synchronized long startOperation() {
-    if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE)) {
-      logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE,
-          "startOperation() op count is now {} in view version {}", currentVersionOpCount + 1,
-          membershipVersion);
-    }
-    synchronized (this.opCountLock) {
-      currentVersionOpCount++;
-      if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-        logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE, "StateFlush current opcount incremented: {}",
-            currentVersionOpCount);
-      }
-    }
-    return membershipVersion;
+  public long startOperation() {
+    return operationMonitor.startOperation();
-  public synchronized long endOperation(long version) {
-    synchronized (this.opCountLock) {
-      if (version == membershipVersion) {
-        currentVersionOpCount--;
-        if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-          logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-              "StateFlush current opcount deccremented: {}", currentVersionOpCount);
-        }
-      } else {
-        previousVersionOpCount--;
-        if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-          logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-              "StateFlush previous opcount incremented: {}", previousVersionOpCount);
-        }
-      }
-    }
-    return membershipVersion;
+  public void endOperation(long version) {
+    operationMonitor.endOperation(version);
-    long timeout =
-        1000L * this.getDistributionManager().getSystem().getConfig().getAckWaitThreshold();
-    waitForCurrentOperations(logger, timeout, timeout * 2L);
+    operationMonitor.waitForCurrentOperations();
-    final long startTime = System.currentTimeMillis();
-    final long warnTime = startTime + warnMS;
-    final long severeAlertTime = startTime + severeAlertMS;
-    boolean warned = false;
-    boolean severeAlertIssued = false;
-    final boolean isDebugEnabled_STATE_FLUSH_OP =
-        DistributionAdvisor.logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE);
-    while (true) {
-      long opCount;
-      synchronized (this.opCountLock) {
-        opCount = this.previousVersionOpCount;
-      }
-      if (opCount <= 0) {
-        if (warned) {
-          alertLogger.info("Wait for current operations completed");
-        }
-        break;
-      }
-      // The advisor's close() method will set the pVOC to zero. This loop
-      // must not terminate due to cache closure until that happens.
-      // See bug 34361 comment 79
-      if (isDebugEnabled_STATE_FLUSH_OP) {
-        DistributionAdvisor.logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-            "Waiting for current operations to finish({})", opCount);
-      }
-      try {
-        Thread.sleep(50);
-      } catch (InterruptedException e) {
-        throw new GemFireIOException("State flush interrupted");
-      }
-      long now = System.currentTimeMillis();
-      if ((!warned) && System.currentTimeMillis() >= warnTime) {
-        warned = true;
-        alertLogger.warn("This operation has been stalled for {} milliseconds waiting for "
-            + "current operations to complete.", warnMS);
-      } else if (warned && !severeAlertIssued && (now >= severeAlertTime)) {
-        // OSProcess.printStacks(0);
-        alertLogger.fatal("This operation has been stalled for {} milliseconds "
-            + "waiting for current operations to complete.  Something may be blocking operations.",
-            severeAlertMS);
-        severeAlertIssued = true;
-      }
-    }
-    if (this.membershipClosed) {
-      if (isDebugEnabled_STATE_FLUSH_OP) {
-        DistributionAdvisor.logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-            "State Flush stopped waiting for operations to distribute because advisor has been closed");
-      }
-    }
+    operationMonitor.waitForCurrentOperations(alertLogger, warnMS, severeAlertMS);
-    if (disabled) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Intelligent Messaging Disabled");
-      }
-      return getDefaultDistributionMembers();
-    }
-    if (disabled) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Intelligent Messaging Disabled");
-      }
-      return !getDefaultDistributionMembers().isEmpty();
-    }
+
+
+
+  private static class OperationMonitor {
+    private final DistributionAdvisor distributionAdvisor;
+
+    /**
+     * the version of the profile set
+     */
+    private long membershipVersion;
+
+    /**
+     * the number of operations in-progress for previous versions of the profile set
+     */
+    private long previousVersionOpCount;
+    /**
+     * the number of operations in-progress for the current version of the profile set
+     */
+    private long currentVersionOpCount;
+
+    /**
+     * for debugging stalled state-flush operations we track threads performing operations
+     * and capture the state when startOperatiopn is invoked
+     */
+    private boolean closed;
+
+    private OperationMonitor(DistributionAdvisor distributionAdvisor) {
+      this.distributionAdvisor = distributionAdvisor;
+    }
+
+    private synchronized void incrementMembershipVersion() {
+      membershipVersion++;
+    }
+
+    /**
+     * Create a new version of the membership profile set. This is used in flushing state out of the
+     * VM for previous versions of the set.
+     *
+     * @since GemFire 5.1
+     */
+    synchronized void forceNewMembershipVersion() {
+      if (!closed) {
+        incrementMembershipVersion();
+        previousVersionOpCount += currentVersionOpCount;
+        currentVersionOpCount = 0;
+        membershipVersionChanged();
+      }
+    }
+
+    /**
+     * this method must be invoked at the start of every operation that can modify the state of
+     * resource. The return value must be recorded and sent to the advisor in an endOperation
+     * message when messages for the operation have been put in the DistributionManager's outgoing
+     * "queue".
+     *
+     * @return the current membership version for this advisor
+     * @since GemFire 5.1
+     */
+    synchronized long startOperation() {
+      logNewOperation();
+      currentVersionOpCount++;
+      return membershipVersion;
+    }
+
+    /**
+     * This method must be invoked when messages for an operation have been put in the
+     * DistributionManager's outgoing queue.
+     *
+     * @param version The membership version returned by startOperation
+     * @since GemFire 5.1
+     */
+    synchronized void endOperation(long version) {
+      if (version == membershipVersion) {
+        currentVersionOpCount--;
+        logEndOperation(true);
+      } else {
+        previousVersionOpCount--;
+        logEndOperation(false);
+      }
+    }
+
+    /**
+     * wait for the current operations being sent on views prior to the joining of the given member
+     * to be placed on communication channels before returning
+     *
+     * @since GemFire 5.1
+     */
+    void waitForCurrentOperations() {
+      long timeout =
+          1000L * distributionAdvisor.getDistributionManager().getSystem().getConfig()
+              .getAckWaitThreshold();
+      waitForCurrentOperations(logger, timeout, timeout * 2L);
+    }
+
+    void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
+      // this may wait longer than it should if the membership version changes, dumping
+      // more operations into the previousVersionOpCount
+      final long startTime = System.currentTimeMillis();
+      final long warnTime = startTime + warnMS;
+      final long severeAlertTime = startTime + severeAlertMS;
+      boolean warned = false;
+      boolean severeAlertIssued = false;
+      while (operationsAreInProgress()) {
+        // The advisor's close() method will set the pVOC to zero. This loop
+        // must not terminate due to cache closure until that happens.
+        try {
+          Thread.sleep(50);
+        } catch (InterruptedException e) {
+          throw new GemFireIOException("State flush interrupted");
+        }
+        long now = System.currentTimeMillis();
+        if ((!warned) && System.currentTimeMillis() >= warnTime) {
+          warned = true;
+          logWaitOnOperationsWarning(alertLogger, warnMS);
+        } else if (warned && !severeAlertIssued && (now >= severeAlertTime)) {
+          logWaitOnOperationsSevere(alertLogger, severeAlertMS);
+          severeAlertIssued = true;
+        }
+      }
+      if (warned) {
+        alertLogger.info("Wait for current operations completed");
+      }
+    }
+
+    synchronized boolean operationsAreInProgress() {
+      return previousVersionOpCount > 0;
+    }
+
+    synchronized void initNewProfile(Profile newProfile) {
+      membershipVersion++;
+      newProfile.initialMembershipVersion = membershipVersion;
+      previousVersionOpCount =
+          previousVersionOpCount + currentVersionOpCount;
+      currentVersionOpCount = 0;
+      membershipVersionChanged();
+    }
+
+    synchronized void close() {
+      previousVersionOpCount = 0;
+      currentVersionOpCount = 0;
+      closed = true;
+    }
+
+    void logNewOperation() {}
+
+    void logEndOperation(boolean newOperation) {}
+
+    void logWaitOnOperationsSevere(Logger alertLogger, long severeAlertMS) {
+      // OSProcess.printStacks(0);
+      alertLogger.fatal("This thread has been stalled for {} milliseconds "
+          + "waiting for current operations to complete.  Something may be blocking operations.",
+          severeAlertMS);
+    }
+
+    void logWaitOnOperationsWarning(Logger alertLogger, long warnMS) {
+      alertLogger.warn("This thread has been stalled for {} milliseconds waiting for "
+          + "current operations to complete.", warnMS);
+    }
+
+    void membershipVersionChanged() {}
+
+  }
+
+  private static class ThreadTrackingOperationMonitor extends OperationMonitor {
+
+    /**
+     * for debugging stalled state-flush operations we track threads performing operations
+     * and capture the state when startOperatiopn is invoked
+     */
+    private final Map<Thread, ExceptionWrapper> currentVersionOperationThreads;
+    private final Map<Thread, ExceptionWrapper> previousVersionOperationThreads;
+
+    private ThreadTrackingOperationMonitor(
+        DistributionAdvisor distributionAdvisor) {
+      super(distributionAdvisor);
+      this.currentVersionOperationThreads = new HashMap<>();
+      this.previousVersionOperationThreads = new HashMap<>();
+    }
+
+    @Override
+    void logNewOperation() {
+      currentVersionOperationThreads.put(Thread.currentThread(),
+          new ExceptionWrapper(new Exception("stack trace")));
+    }
+
+    @Override
+    void logEndOperation(boolean newOp) {
+      if (newOp) {
+        currentVersionOperationThreads.remove(Thread.currentThread());
+      } else {
+        previousVersionOperationThreads.remove(Thread.currentThread());
+      }
+    }
+
+    @Override
+    void logWaitOnOperationsWarning(Logger alertLogger, long warnMS) {
+      super.logWaitOnOperationsWarning(alertLogger, warnMS);
+      synchronized (this) {
+        logger
+            .debug("Waiting for these threads: {}", previousVersionOperationThreads);
+        logger
+            .debug("New version threads are {}", currentVersionOperationThreads);
+      }
+    }
+
+    @Override
+    void logWaitOnOperationsSevere(Logger alertLogger, long severeAlertMS) {
+      super.logWaitOnOperationsSevere(alertLogger, severeAlertMS);
+      synchronized (this) {
+        logger
+            .debug("Waiting for these threads: {}", previousVersionOperationThreads);
+        logger
+            .debug("New version threads are {}", currentVersionOperationThreads);
+      }
+    }
+
+    @Override
+    void membershipVersionChanged() {
+      super.membershipVersionChanged();
+      previousVersionOperationThreads
+          .putAll(currentVersionOperationThreads);
+      currentVersionOperationThreads.clear();
+    }
+
+
+    /**
+     * ExceptionWrapper is used in debugging hangs in waitForCurrentOperations(). It
+     * captures the call stack of a thread invoking startOperation().
+     */
+    private static class ExceptionWrapper {
+      private Exception exception;
+
+      ExceptionWrapper(Exception exception) {
+        this.exception = exception;
+      }
+
+      @Override
+      public String toString() {
+        StringBuilder builder = new StringBuilder(500);
+        OutputStream os = new OutputStream() {
+          @Override
+          public void write(int i) {
+            builder.append((char) i);
+          }
+        };
+        PrintStream stream = new PrintStream(os);
+        exception.printStackTrace(stream);
+        return builder.toString();
+      }
+    }
+
+  }
+

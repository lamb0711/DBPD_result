Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private static final Map<Class, FieldSet> FIELD_CACHE = new CopyOnWriteWeakHashMap<Class, FieldSet>();
+  private static final Map<Class, FieldSet> FIELD_CACHE =
+      new CopyOnWriteWeakHashMap<Class, FieldSet>();
-  
+
-   * method requires some heap space - probably between 8 - 30 bytes per reachable object. 
+   * method requires some heap space - probably between 8 - 30 bytes per reachable object.
+   * 
-   * @param includeStatics if true, the first time we see a new object type, we will visit all of the static fields.
+   * @param includeStatics if true, the first time we see a new object type, we will visit all of
+   *        the static fields.
-  public static void breadthFirstSearch(Object root, Visitor visitor, boolean includeStatics) throws IllegalArgumentException, IllegalAccessException {
+  public static void breadthFirstSearch(Object root, Visitor visitor, boolean includeStatics)
+      throws IllegalArgumentException, IllegalAccessException {
-    
+
-    while(!stack.isEmpty()) {
+    while (!stack.isEmpty()) {
-    
+
-  
-  private static void doSearch(Object root, VisitStack stack) throws IllegalArgumentException, IllegalAccessException {
+
+  private static void doSearch(Object root, VisitStack stack)
+      throws IllegalArgumentException, IllegalAccessException {
-    if(set == null) {
+    if (set == null) {
-    if(set == NON_PRIMATIVE_ARRAY) {
+    if (set == NON_PRIMATIVE_ARRAY) {
-      for(int i = 0; i < length; i++) {
+      for (int i = 0; i < length; i++) {
-    if(includeStatics) {
-      for(Field field : set.getStaticFields()) {
+    if (includeStatics) {
+      for (Field field : set.getStaticFields()) {
-    
-    for(Field field : set.getNonPrimativeFields()) {
+
+    for (Field field : set.getNonPrimativeFields()) {
-  
+
-  
+
-    
-    while(clazz != null) {
-      if(clazz.isArray()) {
+
+    while (clazz != null) {
+      if (clazz.isArray()) {
-        if(!componentType.isPrimitive()) {
+        if (!componentType.isPrimitive()) {
-      for(int i = 0; i < fields.length; i++) {
+      for (int i = 0; i < fields.length; i++) {
-        //skip static fields if we've already counted them once
-        if(!fieldType.isPrimitive()) {
+        // skip static fields if we've already counted them once
+        if (!fieldType.isPrimitive()) {
-          if(Modifier.isStatic(field.getModifiers())) {
+          if (Modifier.isStatic(field.getModifiers())) {
-          }
-          else {
+          } else {
-        } 
+        }
-      
+
-    
-    return new FieldSet(staticFields.toArray(new Field[staticFields.size()]), nonPrimativeFields.toArray(new Field[nonPrimativeFields.size()]));
+
+    return new FieldSet(staticFields.toArray(new Field[staticFields.size()]),
+        nonPrimativeFields.toArray(new Field[nonPrimativeFields.size()]));
-  
+
+     * 
-  
-  
-  
+
+
+
-    
+
-      this.visitor = visitor; 
+      this.visitor = visitor;
-    
+
-      if(object == null) {
+      if (object == null) {
-      boolean newObject = ! seen.contains(object);
-      if(newObject) {
-        seen.add(object);        
+      boolean newObject = !seen.contains(object);
+      if (newObject) {
+        seen.add(object);
-        if(visitChildren) {
+        if (visitChildren) {
-    
+
-    
+
-    
+
-      if(!includeStatics) {
+      if (!includeStatics) {
-      return ! keyExists;
+      return !keyExists;
-  
+
-    
+
-  
+
-    
+
-    
+
+
-    
-    
+
+

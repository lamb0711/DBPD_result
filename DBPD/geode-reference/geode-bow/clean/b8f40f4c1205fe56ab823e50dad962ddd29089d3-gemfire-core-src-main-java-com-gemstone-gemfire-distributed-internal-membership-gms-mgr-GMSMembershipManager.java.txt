GEODE-77 adding new unit tests for GMSJoinLeave

This adds a bunch of new unit tests to GMSJoinLeaveJUnitTest and
fixes a number of problems exposed by the new tests.

Members were in the view multiple times.
Members were in the shutdownMembers collection multiple times.
Members could be in the crashedMembers collection multiple times.
View preparation was actually installing the view in the coordinator.
A rogue process could request removal of a member.

+import java.util.LinkedHashMap;
-import com.gemstone.gemfire.cache.util.BoundedLinkedHashMap;
-import com.gemstone.gemfire.distributed.internal.membership.MemberAttributes;
-  /**
-   * Trick class to make the view lock more visible
-   * in stack traces
-   * 
-   */
-  static class ViewLock extends ReentrantReadWriteLock {
-    public ViewLock() {
-    }
-  }
-  
-  protected ViewLock latestViewLock = new ViewLock();
+  protected ReadWriteLock latestViewLock = new ReentrantReadWriteLock();
-    synchronized (latestViewLock) {
+    latestViewLock.writeLock().lock();
+    try {
-    } // synchronized
+    } finally {
+      latestViewLock.writeLock().unlock();
+    }
-   * use only).  Synchronizes on {@link #latestViewLock} and then deletes
+   * use only).  Write-locks {@link #latestViewLock} and then deletes
-   * Add a mapping from the given member to the given stub. Must be
-   * synchronized on {@link #latestViewLock} by caller.
+   * Add a mapping from the given member to the given stub. Must
+   * be called with {@link #latestViewLock} held.
+  /**
+   * Class <code>BoundedLinkedHashMap</code> is a bounded
+   * <code>LinkedHashMap</code>. The bound is the maximum
+   * number of entries the <code>BoundedLinkedHashMap</code>
+   * can contain.
+   */
+  static class BoundedLinkedHashMap extends LinkedHashMap
+  {
+    private static final long serialVersionUID = -3419897166186852692L;
+
+    /**
+     * The maximum number of entries allowed in this
+     * <code>BoundedLinkedHashMap</code>
+     */
+    protected int _maximumNumberOfEntries;
+
+    /**
+     * Constructor.
+     *
+     * @param initialCapacity The initial capacity.
+     * @param loadFactor The load factor
+     * @param maximumNumberOfEntries The maximum number of allowed entries
+     */
+    public BoundedLinkedHashMap(int initialCapacity, float loadFactor, int maximumNumberOfEntries) {
+      super(initialCapacity, loadFactor);
+      this._maximumNumberOfEntries = maximumNumberOfEntries;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param initialCapacity The initial capacity.
+     * @param maximumNumberOfEntries The maximum number of allowed entries
+     */
+    public BoundedLinkedHashMap(int initialCapacity, int maximumNumberOfEntries) {
+      super(initialCapacity);
+      this._maximumNumberOfEntries = maximumNumberOfEntries;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param maximumNumberOfEntries The maximum number of allowed entries
+     */
+    public BoundedLinkedHashMap(int maximumNumberOfEntries) {
+      super();
+      this._maximumNumberOfEntries = maximumNumberOfEntries;
+    }
+
+    /**
+     * Returns the maximum number of entries.
+     * @return the maximum number of entries
+     */
+    public int getMaximumNumberOfEntries(){
+      return this._maximumNumberOfEntries;
+    }
+
+    @Override
+    protected boolean removeEldestEntry(Map.Entry entry) {
+      return size() > this._maximumNumberOfEntries;
+    }
+  }
+

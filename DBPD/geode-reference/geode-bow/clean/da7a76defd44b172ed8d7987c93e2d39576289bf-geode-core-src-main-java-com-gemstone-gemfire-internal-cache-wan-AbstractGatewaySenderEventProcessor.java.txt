Merge branch 'develop' into feature/GEODE-17-2

-import com.gemstone.gemfire.cache.client.internal.Connection;
-import com.gemstone.gemfire.cache.client.internal.pooling.ConnectionDestroyedException;
-import com.gemstone.gemfire.internal.Version;
+
+  /**
+   * The batchSize is the batch size being used by this processor. By default, it is the
+   * configured batch size of the GatewaySender. It may be automatically reduced if a
+   * MessageTooLargeException occurs.
+   */
+  private int batchSize;
+    this.batchSize = sender.getBatchSize();
+  protected int getBatchSize() {
+    return this.batchSize;
+  }
+
+  protected void setBatchSize(int batchSize) {
+    int currentBatchSize = this.batchSize;
+    if (batchSize <= 0) {
+      this.batchSize = 1;
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.AbstractGatewaySenderEventProcessor_ATTEMPT_TO_SET_BATCH_SIZE_FAILED, new Object[] { currentBatchSize, batchSize }));
+    } else {
+      this.batchSize = batchSize;
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.AbstractGatewaySenderEventProcessor_SET_BATCH_SIZE, new Object[] { currentBatchSize, this.batchSize }));
+    }
+  }
+
-    final int batchSize = sender.getBatchSize();
-          logger.debug("Attempting to peek a batch of {} events", batchSize);
+          logger.debug("Attempting to peek a batch of {} events", this.batchSize);
-            events = this.queue.peek(batchSize, batchTimeInterval);
+            events = this.queue.peek(this.batchSize, batchTimeInterval);
+
+          // If the exception has been set and its cause is an IllegalStateExcetption,
+          // remove all events whose serialized value is no longer available
+          if (this.exception != null && this.exception.getCause() != null
+              && this.exception.getCause() instanceof IllegalStateException) {
+            for (Iterator<GatewaySenderEventImpl> i = filteredList.iterator(); i.hasNext();) {
+              GatewaySenderEventImpl event = i.next();
+              if (event.isSerializedValueNotAvailable()) {
+                i.remove();
+              }
+            }
+            this.exception = null;
+          }
+
+          // Filter the events

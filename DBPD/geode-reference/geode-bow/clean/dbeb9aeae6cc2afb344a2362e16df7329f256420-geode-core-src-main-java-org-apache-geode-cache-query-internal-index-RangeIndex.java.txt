Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.query.internal.QueryMonitor;
-public class RangeIndex extends AbstractIndex  {
+public class RangeIndex extends AbstractIndex {
-   * Map for valueOf(indexedExpression)=>RegionEntries.
-   *  SortedMap<Object, (RegionEntry | List<RegionEntry>)>.
-   * Package access for unit tests.
+   * Map for valueOf(indexedExpression)=>RegionEntries. SortedMap<Object, (RegionEntry |
+   * List<RegionEntry>)>. Package access for unit tests.
-  final ConcurrentNavigableMap valueToEntriesMap = new ConcurrentSkipListMap(TypeUtils.getExtendedNumericComparator());
+  final ConcurrentNavigableMap valueToEntriesMap =
+      new ConcurrentSkipListMap(TypeUtils.getExtendedNumericComparator());
-  //Map for RegionEntries=>values when indexedExpression evaluates to null
+  // Map for RegionEntries=>values when indexedExpression evaluates to null
-  //All following data-structures are used only at index update time.
-  //So minimum memory must be allocated for these collections.
+  // All following data-structures are used only at index update time.
+  // So minimum memory must be allocated for these collections.
-  
+
-   * @param indexedExpression the expression to index on, a function dependent
-   *          on region entries individually.
-   * @param fromClause expression that evaluates to the collection(s) that will
-   *          be queried over, must contain one and only one region path.
-   * @param projectionAttributes expression that transforms each element in the
-   *          result set of a query Return the newly created Index
+   * @param indexedExpression the expression to index on, a function dependent on region entries
+   *        individually.
+   * @param fromClause expression that evaluates to the collection(s) that will be queried over,
+   *        must contain one and only one region path.
+   * @param projectionAttributes expression that transforms each element in the result set of a
+   *        query Return the newly created Index
-      String projectionAttributes, String origFromClause,
-      String origIndexExpr, String[] definitions, IndexStatistics stats) {
-    super(indexName, region, fromClause, indexedExpression,
-        projectionAttributes, origFromClause, origIndexExpr, definitions, stats);
-    
+      String projectionAttributes, String origFromClause, String origIndexExpr,
+      String[] definitions, IndexStatistics stats) {
+    super(indexName, region, fromClause, indexedExpression, projectionAttributes, origFromClause,
+        origIndexExpr, definitions, stats);
+
-        new java.util.concurrent.ConcurrentHashMap(ra.getInitialCapacity(),ra.getLoadFactor(), ra.getConcurrencyLevel()), false /* use set*/);
-    nullMappedEntries = new RegionEntryToValuesMap(true /* use list*/);
-    undefinedMappedEntries = new RegionEntryToValuesMap(true /* use list*/);
+        new java.util.concurrent.ConcurrentHashMap(ra.getInitialCapacity(), ra.getLoadFactor(),
+            ra.getConcurrencyLevel()),
+        false /* use set */);
+    nullMappedEntries = new RegionEntryToValuesMap(true /* use list */);
+    undefinedMappedEntries = new RegionEntryToValuesMap(true /* use list */);
-  
+
-  
+
- 
+
-  
+
-    //Save oldKeys somewhere first
+    // Save oldKeys somewhere first
-    }
-    else if (key == QueryService.UNDEFINED) {
+    } else if (key == QueryService.UNDEFINED) {
-      
+
-        if (indxResultSet.getClass().getName()
-            .startsWith("org.apache.geode.internal.cache.Token$")
+        if (indxResultSet.getClass().getName().startsWith("org.apache.geode.internal.cache.Token$")
-        }
-        else {
+        } else {
-    }
-    else {
+    } else {
-    
+
-    //Add nullEntries
+    // Add nullEntries
-      this.internalIndexStats.incNumValues(-this.nullMappedEntries.getNumValues(entry) + nullSet.size());
-      this.nullMappedEntries.replace(entry, (nullSet.size() > 1) ? nullSet : nullSet.iterator().next());
+      this.internalIndexStats
+          .incNumValues(-this.nullMappedEntries.getNumValues(entry) + nullSet.size());
+      this.nullMappedEntries.replace(entry,
+          (nullSet.size() > 1) ? nullSet : nullSet.iterator().next());
-    //Add undefined entries
+    // Add undefined entries
-      this.internalIndexStats.incNumValues(-this.undefinedMappedEntries.getNumValues(entry) + undefinedSet.size());
-      this.undefinedMappedEntries.replace(entry, (undefinedSet.size() > 1) ? undefinedSet : undefinedSet.iterator().next());
+      this.internalIndexStats
+          .incNumValues(-this.undefinedMappedEntries.getNumValues(entry) + undefinedSet.size());
+      this.undefinedMappedEntries.replace(entry,
+          (undefinedSet.size() > 1) ? undefinedSet : undefinedSet.iterator().next());
-    //Get existing keys from reverse map and remove new keys
-    //from this list and remove index entries for these old keys.
+    // Get existing keys from reverse map and remove new keys
+    // from this list and remove index entries for these old keys.
-            for (Object key: keys) {
-              ((Collection)oldkeys).remove(TypeUtils.indexKeyFor(key));
+            for (Object key : keys) {
+              ((Collection) oldkeys).remove(TypeUtils.indexKeyFor(key));
-            for (Object key: keys) {
+            for (Object key : keys) {
-        throw new IMQException(
-            LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
-                .toLocalizedString(oldkeys.getClass().getName()), ex);
+        throw new IMQException(LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
+            .toLocalizedString(oldkeys.getClass().getName()), ex);
-  
-      //Perform replace of new index entries in index.
+
+      // Perform replace of new index entries in index.
-            RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap
-                .get(newKey);
+            RegionEntryToValuesMap rvMap =
+                (RegionEntryToValuesMap) this.valueToEntriesMap.get(newKey);
-                  
+
-            throw new IMQException(
-                LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
-                    .toLocalizedString(key.getClass().getName()), ex);
+          throw new IMQException(LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
+              .toLocalizedString(key.getClass().getName()), ex);
-        for (Object key: keys) {
+        for (Object key : keys) {
-             boolean retry = false;
-            // Going in a retry loop until  concurrent index update is successful.
+            boolean retry = false;
+            // Going in a retry loop until concurrent index update is successful.
-              RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap
-                  .get(newKey);
+              RegionEntryToValuesMap rvMap =
+                  (RegionEntryToValuesMap) this.valueToEntriesMap.get(newKey);
-                Object oldValue = this.valueToEntriesMap.putIfAbsent(newKey,
-                    rvMap);
+                Object oldValue = this.valueToEntriesMap.putIfAbsent(newKey, rvMap);
-              throw new IMQException(
-                  LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
-                      .toLocalizedString(key.getClass().getName()), ex);
+            throw new IMQException(LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
+                .toLocalizedString(key.getClass().getName()), ex);
-        }//for loop for keys
+        } // for loop for keys
-    //Remove the remaining old keys.
+    // Remove the remaining old keys.
-        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap
-            .get(key);
+        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap.get(key);
-    }
-    else {
-      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap
-          .get(oldkeys);
+    } else {
+      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap.get(oldkeys);
-  
+
-    throw new UnsupportedOperationException(LocalizedStrings.RangeIndex_NOT_YET_IMPLEMENTED.toLocalizedString());
+    throw new UnsupportedOperationException(
+        LocalizedStrings.RangeIndex_NOT_YET_IMPLEMENTED.toLocalizedString());
-  
+
-  public ObjectType getResultSetType()  {
-   return this.evaluator.getIndexResultSetType();
-  }  
+  public ObjectType getResultSetType() {
+    return this.evaluator.getIndexResultSetType();
+  }
-   * We are NOT using any synchronization in this method as this is supposed to
-   * be called only during initialization. Watch out for Initialization
-   * happening during region.clear() call because that happens concurrently with
-   * other index updates WITHOUT synchronization on RegionEntry.
+   * We are NOT using any synchronization in this method as this is supposed to be called only
+   * during initialization. Watch out for Initialization happening during region.clear() call
+   * because that happens concurrently with other index updates WITHOUT synchronization on
+   * RegionEntry.
-  void addMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException
-  {
+  void addMapping(Object key, Object value, RegionEntry entry) throws IMQException {
-    //Find old entries for the entry
+    // Find old entries for the entry
-    }
-    else if (key == QueryService.UNDEFINED) {
+    } else if (key == QueryService.UNDEFINED) {
-        if (value.getClass().getName()
-            .startsWith("org.apache.geode.internal.cache.Token$")
+        if (value.getClass().getName().startsWith("org.apache.geode.internal.cache.Token$")
-        }
-        else {
+        } else {
-    }
-    else {
+    } else {
-        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)this.valueToEntriesMap.get(newKey);
+        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap.get(newKey);
-          rvMap = new RegionEntryToValuesMap(true /* use target list*/);
+          rvMap = new RegionEntryToValuesMap(true /* use target list */);
-        rvMap.add(entry, value); 
+        rvMap.add(entry, value);
-      }
-      catch (TypeMismatchException ex) {
-        throw new IMQException(
-            LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
-                .toLocalizedString(key.getClass().getName()), ex);
+      } catch (TypeMismatchException ex) {
+        throw new IMQException(LocalizedStrings.RangeIndex_COULD_NOT_ADD_OBJECT_OF_TYPE_0
+            .toLocalizedString(key.getClass().getName()), ex);
-  
+
-    //Shobhit: Now we are not going to remove anything before update.
-    //In fact we will only Replace not remove and add now on.
+    // Shobhit: Now we are not going to remove anything before update.
+    // In fact we will only Replace not remove and add now on.
-    //System.out.println("RangeIndex.removeMapping "+entry.getKey());
+    // System.out.println("RangeIndex.removeMapping "+entry.getKey());
-      }
-      else {
+      } else {
-    }
-    else if (values instanceof Collection) {
+    } else if (values instanceof Collection) {
-         RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap
-            .get(key);
+        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap.get(key);
-      
+
-    }
-    else {
-      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap
-          .get(values);
+    } else {
+      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) this.valueToEntriesMap.get(values);
-  //Asif TODO: Provide explanation of the method. Test this method
+  // Asif TODO: Provide explanation of the method. Test this method
-      throws TypeMismatchException, FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-    ((AbstractIndex)indx).updateIndexUseStats();
+    ((AbstractIndex) indx).updateIndexUseStats();
-    Iterator  inner = null;
+    Iterator inner = null;
-      
-      if(indx instanceof CompactRangeIndex){
+
+      if (indx instanceof CompactRangeIndex) {
-      } else{
+      } else {
-        //}
+        // }
-            if(innerEntry instanceof IndexStoreEntry){
-              innerKey = ((IndexStoreEntry)innerEntry).getDeserializedKey();
-            } else{
-              innerKey = ((Map.Entry)innerEntry).getKey();
+            if (innerEntry instanceof IndexStoreEntry) {
+              innerKey = ((IndexStoreEntry) innerEntry).getDeserializedKey();
+            } else {
+              innerKey = ((Map.Entry) innerEntry).getKey();
-          
+
-            //Asif :Select the data
+            // Asif :Select the data
-            if(innerEntry instanceof IndexStoreEntry){
+            if (innerEntry instanceof IndexStoreEntry) {
-            } else{
-              innerValue = ((Map.Entry)innerEntry).getValue();
+            } else {
+              innerValue = ((Map.Entry) innerEntry).getValue();
-            populateListForEquiJoin(data, outerEntry.getValue(),
-                innerValue, context, null);
+            populateListForEquiJoin(data, outerEntry.getValue(), innerValue, context, null);
-          }
-          else if (compare < 0) {
-            //Asif :The outer key is smaller than the inner key. That means
+          } else if (compare < 0) {
+            // Asif :The outer key is smaller than the inner key. That means
-            //incrementOuter = true;
+            // incrementOuter = true;
-          }
-          else {
-            //Asif : The outer key is greater than inner key , so increment the
+          } else {
+            // Asif : The outer key is greater than inner key , so increment the
-    }
-    finally {
-      ((AbstractIndex)indx).updateIndexUseEndStats(start);
+    } finally {
+      ((AbstractIndex) indx).updateIndexUseEndStats(start);
-  throws TypeMismatchException
-  {
-     // Get approx size;
+      throws TypeMismatchException {
+    // Get approx size;
-          }
-          else if (key == QueryService.UNDEFINED) {
+          } else if (key == QueryService.UNDEFINED) {
-          }
-          else {
+          } else {
-            RegionEntryToValuesMap valMap = (RegionEntryToValuesMap)this.valueToEntriesMap
-            .get(key);
+            RegionEntryToValuesMap valMap =
+                (RegionEntryToValuesMap) this.valueToEntriesMap.get(key);
-            size = valMap == null?0: valMap.getNumValues();
+            size = valMap == null ? 0 : valMap.getNumValues();
-          }
-          else if (key == QueryService.UNDEFINED) {
+          } else if (key == QueryService.UNDEFINED) {
-          }
-          else {
-             key = TypeUtils.indexKeyFor(key);
-             key = getPdxStringForIndexedPdxKeys(key);
-            RegionEntryToValuesMap valMap = (RegionEntryToValuesMap)this.valueToEntriesMap
-            .get(key);
-            size -= valMap == null?0:valMap.getNumValues();
+          } else {
+            key = TypeUtils.indexKeyFor(key);
+            key = getPdxStringForIndexedPdxKeys(key);
+            RegionEntryToValuesMap valMap =
+                (RegionEntryToValuesMap) this.valueToEntriesMap.get(key);
+            size -= valMap == null ? 0 : valMap.getNumValues();
-  
+
-                  //truncate to the same long, so safest calculation is to convert to doubles
-                  x = (int) (((keyAsNum.doubleValue() - first.doubleValue()) * totalSize) / (last
-                      .doubleValue() - first.doubleValue()));
+                  // truncate to the same long, so safest calculation is to convert to doubles
+                  x = (int) (((keyAsNum.doubleValue() - first.doubleValue()) * totalSize)
+                      / (last.doubleValue() - first.doubleValue()));
-          }
-          else {
+          } else {
-          }
-          else {
+          } else {
-  private void evaluate(Object key, int operator, Collection results,
-      Set keysToRemove, int limit, ExecutionContext context)
-      throws TypeMismatchException {
+  private void evaluate(Object key, int operator, Collection results, Set keysToRemove, int limit,
+      ExecutionContext context) throws TypeMismatchException {
-    Boolean orderByClause = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    limit = multiColOrderBy ? -1:limit;
-        
+    limit = multiColOrderBy ? -1 : limit;
+
-      case OQLLexerTokenTypes.TOK_EQ: {
-        assert keysToRemove == null;
-        addValuesToResult(this.valueToEntriesMap.get(key), results, keysToRemove, limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_LT: {
-        NavigableMap sm = this.valueToEntriesMap.headMap(key, false);
-        sm = asc ? sm : sm.descendingMap();
-
-        addValuesToResult(sm, results, keysToRemove, limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_LE: {
-
-        NavigableMap sm = this.valueToEntriesMap.headMap(key, true);
-        sm = asc ? sm : sm.descendingMap();
-
-        addValuesToResult(sm, results, keysToRemove, limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_GT: {
-        // Asif:As tail Map returns the SortedMap vie which is greater than or
-        // equal to the key passed, the equal to key needs to be removed.
-        // However if the boundtary key is already part of the keysToRemove set
-        // then we do not have to remove it as it is already taken care of
-
-        NavigableMap sm = this.valueToEntriesMap.tailMap(key, false);
-        sm = asc ? sm : sm.descendingMap();
-        addValuesToResult(sm, results, keysToRemove, limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_GE: {
-        NavigableMap sm = this.valueToEntriesMap.tailMap(key, true);
-        sm = asc ? sm : sm.descendingMap();
-        addValuesToResult(sm, results, keysToRemove, limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_NE_ALT:
-      case OQLLexerTokenTypes.TOK_NE: {
-        NavigableMap sm = this.valueToEntriesMap;
-        if (!asc) {
-          sm = sm.descendingMap();
-
+        case OQLLexerTokenTypes.TOK_EQ: {
+          assert keysToRemove == null;
+          addValuesToResult(this.valueToEntriesMap.get(key), results, keysToRemove, limit, context);
+          break;
-        if (keysToRemove == null) {
-          addValuesToResultSingleKeyToRemove(sm, results, key, limit, context);
-        } else {
-          // TODO:Asif Somehow avoid this removal & then addition
-          keysToRemove.add(key);
+        case OQLLexerTokenTypes.TOK_LT: {
+          NavigableMap sm = this.valueToEntriesMap.headMap(key, false);
+          sm = asc ? sm : sm.descendingMap();
+
+          break;
-        nullMappedEntries.addValuesToCollection(results, limit, context);
-        undefinedMappedEntries.addValuesToCollection(results, limit, context);
-        // removeValuesFromResult(this.valueToEntriesMap.get(key), results);
+        case OQLLexerTokenTypes.TOK_LE: {
-        break;
-      }
-      default: {
-        throw new IllegalArgumentException(
-            LocalizedStrings.RangeIndex_OPERATOR_0.toLocalizedString(Integer
-                .valueOf(operator)));
-      }
+          NavigableMap sm = this.valueToEntriesMap.headMap(key, true);
+          sm = asc ? sm : sm.descendingMap();
+
+          addValuesToResult(sm, results, keysToRemove, limit, context);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_GT: {
+          // Asif:As tail Map returns the SortedMap vie which is greater than or
+          // equal to the key passed, the equal to key needs to be removed.
+          // However if the boundtary key is already part of the keysToRemove set
+          // then we do not have to remove it as it is already taken care of
+
+          NavigableMap sm = this.valueToEntriesMap.tailMap(key, false);
+          sm = asc ? sm : sm.descendingMap();
+          addValuesToResult(sm, results, keysToRemove, limit, context);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_GE: {
+          NavigableMap sm = this.valueToEntriesMap.tailMap(key, true);
+          sm = asc ? sm : sm.descendingMap();
+          addValuesToResult(sm, results, keysToRemove, limit, context);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE: {
+          NavigableMap sm = this.valueToEntriesMap;
+          if (!asc) {
+            sm = sm.descendingMap();
+
+          }
+          if (keysToRemove == null) {
+            addValuesToResultSingleKeyToRemove(sm, results, key, limit, context);
+          } else {
+            // TODO:Asif Somehow avoid this removal & then addition
+            keysToRemove.add(key);
+            addValuesToResult(sm, results, keysToRemove, limit, context);
+          }
+          nullMappedEntries.addValuesToCollection(results, limit, context);
+          undefinedMappedEntries.addValuesToCollection(results, limit, context);
+          // removeValuesFromResult(this.valueToEntriesMap.get(key), results);
+
+          break;
+        }
+        default: {
+          throw new IllegalArgumentException(
+              LocalizedStrings.RangeIndex_OPERATOR_0.toLocalizedString(Integer.valueOf(operator)));
+        }
-private void evaluate(Object key, int operator, Collection results,
-  CompiledValue iterOps, RuntimeIterator runtimeItr,
-  ExecutionContext context, List projAttrib, SelectResults intermediateResults, boolean isIntersection,
-  int limit, boolean applyOrderBy, List orderByAttribs) throws TypeMismatchException,
-  FunctionDomainException, NameResolutionException,
-  QueryInvocationTargetException
-{
-key = TypeUtils.indexKeyFor(key);
-boolean multiColOrderBy = false;
-boolean asc = true;
-if(applyOrderBy) {
-  CompiledSortCriterion csc = (CompiledSortCriterion)orderByAttribs.get(0);
-  asc = !csc.getCriterion();
-  multiColOrderBy = orderByAttribs.size()>1;
-}
-limit = multiColOrderBy?-1:limit;
-
-
-try {
-  switch (operator) {
-  case OQLLexerTokenTypes.TOK_EQ: {
-    addValuesToResult(this.valueToEntriesMap.get(key), results, null, iterOps,
-        runtimeItr, context, projAttrib, intermediateResults, isIntersection,limit);
-    break;
-  }  
-  case OQLLexerTokenTypes.TOK_LT: {
-    
-    NavigableMap sm = this.valueToEntriesMap.headMap(key,false);
-    sm = asc ? sm : sm.descendingMap();
-
-    addValuesToResult(sm, results, null,
-        iterOps, runtimeItr, context, projAttrib, intermediateResults,isIntersection,limit);
-
-    break;
-  }
-  case OQLLexerTokenTypes.TOK_LE: {
-    NavigableMap sm = this.valueToEntriesMap.headMap(key, true);
-    sm = asc ? sm : sm.descendingMap();
-
-    addValuesToResult(sm, results, null,
-        iterOps, runtimeItr, context, projAttrib, intermediateResults,isIntersection,limit);              
-    break;
-  }
-  case OQLLexerTokenTypes.TOK_GT: {
-    // Asif:As tail Map returns the SortedMap vie which is greater
-    // than or equal
-    // to the key passed, the equal to key needs to be removed.
-    // However if the boundary key is already part of the
-    // keysToRemove set
-    // then we do not have to remove it as it is already taken care
-    // of
- 
-    NavigableMap sm = this.valueToEntriesMap.tailMap(key, false);
-    sm = asc ? sm : sm.descendingMap();
-
-    addValuesToResult(sm, results, null,
-        iterOps, runtimeItr, context, projAttrib, intermediateResults,isIntersection, limit);
-
-
-    break;
-  }
-  case OQLLexerTokenTypes.TOK_GE: {
-    NavigableMap sm =  this.valueToEntriesMap.tailMap(key,true);
-    sm = asc ? sm : sm.descendingMap();
-
-    addValuesToResult(sm, results, null,
-        iterOps, runtimeItr, context, projAttrib,intermediateResults,isIntersection, limit);
-
-    break;
-  }
-  case OQLLexerTokenTypes.TOK_NE_ALT:
-  case OQLLexerTokenTypes.TOK_NE: {
-    NavigableMap sm = this.valueToEntriesMap;
-    if(!asc) {
-      sm = sm.descendingMap();  
+  private void evaluate(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit, boolean applyOrderBy,
+      List orderByAttribs) throws TypeMismatchException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
+    key = TypeUtils.indexKeyFor(key);
+    boolean multiColOrderBy = false;
+    boolean asc = true;
+    if (applyOrderBy) {
+      CompiledSortCriterion csc = (CompiledSortCriterion) orderByAttribs.get(0);
+      asc = !csc.getCriterion();
+      multiColOrderBy = orderByAttribs.size() > 1;
-    addValuesToResult(sm, results, key, iterOps,
-        runtimeItr, context, projAttrib,intermediateResults,isIntersection,limit);
-
-    nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr,
-        context, projAttrib,intermediateResults,isIntersection,limit);
-    undefinedMappedEntries.addValuesToCollection(results, iterOps,
-        runtimeItr, context, projAttrib,intermediateResults,isIntersection,limit);
-
-    break;
-  }
-  default: {
-    throw new IllegalArgumentException("Operator = " + operator);
-  }
-  } // end switch
-}
-catch (ClassCastException ex) {
-  if (operator == OQLLexerTokenTypes.TOK_EQ) { // result is empty
-    // set
-    return;
-  }
-  else if (operator == OQLLexerTokenTypes.TOK_NE
-      || operator == OQLLexerTokenTypes.TOK_NE_ALT) { // put
-    // all
-    // in
-    // result
-    NavigableMap sm = this.valueToEntriesMap;
-    if(!asc) {      
-        sm = sm.descendingMap();   
-    }
-    addValuesToResult(sm, results, key, iterOps,
-        runtimeItr, context, projAttrib,intermediateResults,isIntersection,limit);
-
-    nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr,
-        context, projAttrib,intermediateResults,isIntersection,limit);
-    undefinedMappedEntries.addValuesToCollection(results, iterOps,
-        runtimeItr, context, projAttrib, intermediateResults,isIntersection,limit);
-  }
-  else { // otherwise throw exception
-    throw new TypeMismatchException("", ex);
-  }
-}
-} 
-/**
- * 
- * @param entriesMap
- *                SortedMap object containing the indexed key as the key & the
- *                value being RegionEntryToValues Map object containing the
- *                indexed results
- * @param result
- *                Index Results holder Collection used for fetching the index
- *                results
- * @param keysToRemove
-       *            Set containing the index keys for which index results should
-       *            not be taken from the entriesMap
- */
-
-private void addValuesToResult(Object entriesMap, Collection result, Set keysToRemove, int limit, ExecutionContext context) {
-  if (entriesMap == null || result == null) return;
-  QueryObserver observer = QueryObserverHolder.getInstance();
-  if (verifyLimit(result, limit, context)) {
-    observer.limitAppliedAtIndexLevel(this, limit,result);
-    return;
-  }
-  if (entriesMap instanceof SortedMap) {
-    if (((SortedMap)entriesMap).isEmpty()){ // bug#40514
-      return;
-    }
-   
-    SortedMap sortedMap = (SortedMap)entriesMap;    
-    Iterator entriesIter = sortedMap.entrySet().iterator();
-    Map.Entry entry = null;
-    while (entriesIter.hasNext()) {
-      entry = (Map.Entry)entriesIter.next();
-      Object key = entry.getKey();
-      if (keysToRemove == null || !keysToRemove.remove(key)) {
-        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entry.getValue();
-          rvMap.addValuesToCollection(result, limit, context);
-        if (verifyLimit(result, limit, context)) {
-          observer.limitAppliedAtIndexLevel(this, limit,result);
-          return;
-        }
-      }
-    }
-  }
-  else if (entriesMap instanceof RegionEntryToValuesMap) {
-    //We have already been passed the collection to add, assuming keys to remove is null or already been applied
-    RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesMap;
-    rvMap.addValuesToCollection(result, limit, context);
-    if (limit != -1 &&  result.size() == limit) {
-      observer.limitAppliedAtIndexLevel(this, limit,result);
-      return;
-    }
-  }
-  else {
-    throw new RuntimeException(LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString());
-  }
-}
+    limit = multiColOrderBy ? -1 : limit;
-
-
-
-
-/**
- * 
- * @param entriesMap
- *                SortedMap object containing the indexed key as the key & the
- *                value being RegionEntryToValues Map object containing the
- *                indexed results
- * @param result
- *                Index Results holder Collection used for fetching the index
- *                results
- * @param keyToRemove
- *                The index key object for which index result should not be
- *                taken from the entriesMap
- * @param limit 
- *                The limit to be applied on the resultset. If no limit is to be applied the value 
- *                will be -1              
- */
-private void addValuesToResultSingleKeyToRemove(Object entriesMap, Collection result,
-    Object keyToRemove, int limit, ExecutionContext context) {
-  if (entriesMap == null || result == null)
-    return;
-  QueryObserver observer = QueryObserverHolder.getInstance();
-  if (verifyLimit(result, limit, context)) {
-    observer.limitAppliedAtIndexLevel(this, limit,result);
-    return;
-  }
-  assert entriesMap instanceof SortedMap;
-  Iterator entriesIter = ((SortedMap)entriesMap).entrySet().iterator();
-  Map.Entry entry = null;
-  boolean foundKeyToRemove = false;
-  while (entriesIter.hasNext()) {
-    entry = (Map.Entry)entriesIter.next();
-    // Object key = entry.getKey();
-    if (foundKeyToRemove || !keyToRemove.equals(entry.getKey())) {
-      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entry.getValue();
-      rvMap.addValuesToCollection(result, limit, context);
-      if (verifyLimit(result, limit, context)) {
-        observer.limitAppliedAtIndexLevel(this, limit,result);
-        return;
-      }
-    }
-    else {
-      foundKeyToRemove = true;
-    }
-  }
-}
-
-private void addValuesToResult(Object entriesMap, Collection result,
-    Object keyToRemove, CompiledValue iterOps, RuntimeIterator runtimeItr,
-    ExecutionContext context, List projAttrib, SelectResults intermediateResults, 
-    boolean isIntersection, int limit)
-    throws FunctionDomainException, TypeMismatchException,
-    NameResolutionException, QueryInvocationTargetException
-{
-  boolean limitApplied = false;
-  if (entriesMap == null || result == null || (limitApplied = verifyLimit(result, limit, context))) {
-    if(limitApplied) {
-      QueryObserver observer = QueryObserverHolder.getInstance();
-      if(observer != null) {
-        observer.limitAppliedAtIndexLevel(this, limit, result);
-      }
-    }
-    return;
-  }
-  QueryObserver observer = QueryObserverHolder.getInstance();
-  if (entriesMap instanceof SortedMap) {
-    Iterator entriesIter = ((SortedMap)entriesMap).entrySet().iterator();
-    Map.Entry entry = null;
-    boolean foundKeyToRemove = false;
-    
-    //That means we aren't removing any keys (remember if we are matching for nulls, we have the null maps
-    if (keyToRemove == null) {
-      foundKeyToRemove = true;
-    }
-    while (entriesIter.hasNext()) {
-      entry = (Map.Entry)entriesIter.next();
-      // Object key = entry.getKey();
-      if (foundKeyToRemove || !keyToRemove.equals(entry.getKey())) {
-        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entry.getValue();
-        rvMap.addValuesToCollection(result, iterOps, runtimeItr, context,
-            projAttrib,intermediateResults,isIntersection,limit);
-        if (verifyLimit(result, limit, context)){
-          observer.limitAppliedAtIndexLevel(this, limit,result);
+    try {
+      switch (operator) {
+        case OQLLexerTokenTypes.TOK_EQ: {
+          addValuesToResult(this.valueToEntriesMap.get(key), results, null, iterOps, runtimeItr,
+              context, projAttrib, intermediateResults, isIntersection, limit);
+        case OQLLexerTokenTypes.TOK_LT: {
+
+          NavigableMap sm = this.valueToEntriesMap.headMap(key, false);
+          sm = asc ? sm : sm.descendingMap();
+
+          addValuesToResult(sm, results, null, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_LE: {
+          NavigableMap sm = this.valueToEntriesMap.headMap(key, true);
+          sm = asc ? sm : sm.descendingMap();
+
+          addValuesToResult(sm, results, null, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_GT: {
+          // Asif:As tail Map returns the SortedMap vie which is greater
+          // than or equal
+          // to the key passed, the equal to key needs to be removed.
+          // However if the boundary key is already part of the
+          // keysToRemove set
+          // then we do not have to remove it as it is already taken care
+          // of
+
+          NavigableMap sm = this.valueToEntriesMap.tailMap(key, false);
+          sm = asc ? sm : sm.descendingMap();
+
+          addValuesToResult(sm, results, null, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+
+
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_GE: {
+          NavigableMap sm = this.valueToEntriesMap.tailMap(key, true);
+          sm = asc ? sm : sm.descendingMap();
+
+          addValuesToResult(sm, results, null, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE: {
+          NavigableMap sm = this.valueToEntriesMap;
+          if (!asc) {
+            sm = sm.descendingMap();
+          }
+          addValuesToResult(sm, results, key, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+
+          nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+          undefinedMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, limit);
+
+          break;
+        }
+        default: {
+          throw new IllegalArgumentException("Operator = " + operator);
+        }
+      } // end switch
+    } catch (ClassCastException ex) {
+      if (operator == OQLLexerTokenTypes.TOK_EQ) { // result is empty
+        // set
+        return;
+      } else if (operator == OQLLexerTokenTypes.TOK_NE
+          || operator == OQLLexerTokenTypes.TOK_NE_ALT) { // put
+        // all
+        // in
+        // result
+        NavigableMap sm = this.valueToEntriesMap;
+        if (!asc) {
+          sm = sm.descendingMap();
+        }
+        addValuesToResult(sm, results, key, iterOps, runtimeItr, context, projAttrib,
+            intermediateResults, isIntersection, limit);
+
+        nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context, projAttrib,
+            intermediateResults, isIntersection, limit);
+        undefinedMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context,
+            projAttrib, intermediateResults, isIntersection, limit);
+      } else { // otherwise throw exception
+        throw new TypeMismatchException("", ex);
-      else {
+    }
+  }
+
+  /**
+   * 
+   * @param entriesMap SortedMap object containing the indexed key as the key & the value being
+   *        RegionEntryToValues Map object containing the indexed results
+   * @param result Index Results holder Collection used for fetching the index results
+   * @param keysToRemove Set containing the index keys for which index results should not be taken
+   *        from the entriesMap
+   */
+
+  private void addValuesToResult(Object entriesMap, Collection result, Set keysToRemove, int limit,
+      ExecutionContext context) {
+    if (entriesMap == null || result == null)
+      return;
+    QueryObserver observer = QueryObserverHolder.getInstance();
+    if (verifyLimit(result, limit, context)) {
+      observer.limitAppliedAtIndexLevel(this, limit, result);
+      return;
+    }
+    if (entriesMap instanceof SortedMap) {
+      if (((SortedMap) entriesMap).isEmpty()) { // bug#40514
+        return;
+      }
+
+      SortedMap sortedMap = (SortedMap) entriesMap;
+      Iterator entriesIter = sortedMap.entrySet().iterator();
+      Map.Entry entry = null;
+      while (entriesIter.hasNext()) {
+        entry = (Map.Entry) entriesIter.next();
+        Object key = entry.getKey();
+        if (keysToRemove == null || !keysToRemove.remove(key)) {
+          RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entry.getValue();
+          rvMap.addValuesToCollection(result, limit, context);
+          if (verifyLimit(result, limit, context)) {
+            observer.limitAppliedAtIndexLevel(this, limit, result);
+            return;
+          }
+        }
+      }
+    } else if (entriesMap instanceof RegionEntryToValuesMap) {
+      // We have already been passed the collection to add, assuming keys to remove is null or
+      // already been applied
+      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesMap;
+      rvMap.addValuesToCollection(result, limit, context);
+      if (limit != -1 && result.size() == limit) {
+        observer.limitAppliedAtIndexLevel(this, limit, result);
+        return;
+      }
+    } else {
+      throw new RuntimeException(
+          LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString());
+    }
+  }
+
+
+
+  /**
+   * 
+   * @param entriesMap SortedMap object containing the indexed key as the key & the value being
+   *        RegionEntryToValues Map object containing the indexed results
+   * @param result Index Results holder Collection used for fetching the index results
+   * @param keyToRemove The index key object for which index result should not be taken from the
+   *        entriesMap
+   * @param limit The limit to be applied on the resultset. If no limit is to be applied the value
+   *        will be -1
+   */
+  private void addValuesToResultSingleKeyToRemove(Object entriesMap, Collection result,
+      Object keyToRemove, int limit, ExecutionContext context) {
+    if (entriesMap == null || result == null)
+      return;
+    QueryObserver observer = QueryObserverHolder.getInstance();
+    if (verifyLimit(result, limit, context)) {
+      observer.limitAppliedAtIndexLevel(this, limit, result);
+      return;
+    }
+    assert entriesMap instanceof SortedMap;
+    Iterator entriesIter = ((SortedMap) entriesMap).entrySet().iterator();
+    Map.Entry entry = null;
+    boolean foundKeyToRemove = false;
+    while (entriesIter.hasNext()) {
+      entry = (Map.Entry) entriesIter.next();
+      // Object key = entry.getKey();
+      if (foundKeyToRemove || !keyToRemove.equals(entry.getKey())) {
+        RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entry.getValue();
+        rvMap.addValuesToCollection(result, limit, context);
+        if (verifyLimit(result, limit, context)) {
+          observer.limitAppliedAtIndexLevel(this, limit, result);
+          return;
+        }
+      } else {
-  else if (entriesMap instanceof RegionEntryToValuesMap) {
-    RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entriesMap;
-    rvMap.addValuesToCollection(result, iterOps, runtimeItr, context,
-        projAttrib, intermediateResults,isIntersection, limit);
-  }
-  else {
-    throw new RuntimeException(LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString());
-  }
-}
-/*
-private void removeValuesFromResult(Object entriesMap, Collection result) {
-  if (entriesMap == null || result == null) return;
-  if (entriesMap instanceof SortedMap) {
-    Iterator entriesIter = ((SortedMap) entriesMap).values().iterator();
-    while (entriesIter.hasNext()) {
-      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesIter
-          .next();
-      rvMap.removeValuesFromCollection(result);
+  private void addValuesToResult(Object entriesMap, Collection result, Object keyToRemove,
+      CompiledValue iterOps, RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    boolean limitApplied = false;
+    if (entriesMap == null || result == null
+        || (limitApplied = verifyLimit(result, limit, context))) {
+      if (limitApplied) {
+        QueryObserver observer = QueryObserverHolder.getInstance();
+        if (observer != null) {
+          observer.limitAppliedAtIndexLevel(this, limit, result);
+        }
+      }
+      return;
+    }
+    QueryObserver observer = QueryObserverHolder.getInstance();
+    if (entriesMap instanceof SortedMap) {
+      Iterator entriesIter = ((SortedMap) entriesMap).entrySet().iterator();
+      Map.Entry entry = null;
+      boolean foundKeyToRemove = false;
+
+      // That means we aren't removing any keys (remember if we are matching for nulls, we have the
+      // null maps
+      if (keyToRemove == null) {
+        foundKeyToRemove = true;
+      }
+      while (entriesIter.hasNext()) {
+        entry = (Map.Entry) entriesIter.next();
+        // Object key = entry.getKey();
+        if (foundKeyToRemove || !keyToRemove.equals(entry.getKey())) {
+          RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entry.getValue();
+          rvMap.addValuesToCollection(result, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+          if (verifyLimit(result, limit, context)) {
+            observer.limitAppliedAtIndexLevel(this, limit, result);
+            break;
+          }
+        } else {
+          foundKeyToRemove = true;
+        }
+      }
+    } else if (entriesMap instanceof RegionEntryToValuesMap) {
+      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesMap;
+      rvMap.addValuesToCollection(result, iterOps, runtimeItr, context, projAttrib,
+          intermediateResults, isIntersection, limit);
+    } else {
+      throw new RuntimeException(
+          LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString());
-  else if (entriesMap instanceof RegionEntryToValuesMap) {
-    RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesMap;
-    rvMap.removeValuesFromCollection(result);
-  }
-  else {
-    throw new RuntimeException(LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString());
-  }
-}
-private void removeValuesFromResult(Object entriesMap, Collection result,CompiledValue iterOps,
-    RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib, 
-    SelectResults intermediateResults, boolean isIntersection)
-    throws FunctionDomainException, TypeMismatchException,
-    NameResolutionException, QueryInvocationTargetException
-{
-  if (entriesMap == null || result == null)
-    return;
-  if (entriesMap instanceof SortedMap) {
-    Iterator entriesIter = ((SortedMap)entriesMap).values().iterator();
-    while (entriesIter.hasNext()) {
-      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entriesIter
-          .next();
-      rvMap.removeValuesFromCollection(result, iterOps, runtimeItr, context,
-          projAttrib, intermediateResults, isIntersection);
-    }
-  }
-  else if (entriesMap instanceof RegionEntryToValuesMap) {
-    RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entriesMap;
-    rvMap.removeValuesFromCollection(result, iterOps, runtimeItr, context,
-        projAttrib, intermediateResults, isIntersection);
-  }
-  else {
-    throw new RuntimeException(LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString());
-  }
-}
-*/
-
-void recreateIndexData() throws IMQException {
-   * Asif : Mark the data maps to null & call the initialization code of index
+   * private void removeValuesFromResult(Object entriesMap, Collection result) { if (entriesMap ==
+   * null || result == null) return; if (entriesMap instanceof SortedMap) { Iterator entriesIter =
+   * ((SortedMap) entriesMap).values().iterator(); while (entriesIter.hasNext()) {
+   * RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesIter .next();
+   * rvMap.removeValuesFromCollection(result); } } else if (entriesMap instanceof
+   * RegionEntryToValuesMap) { RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) entriesMap;
+   * rvMap.removeValuesFromCollection(result); } else { throw new
+   * RuntimeException(LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString()); } }
+   * 
+   * private void removeValuesFromResult(Object entriesMap, Collection result,CompiledValue iterOps,
+   * RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib, SelectResults
+   * intermediateResults, boolean isIntersection) throws FunctionDomainException,
+   * TypeMismatchException, NameResolutionException, QueryInvocationTargetException { if (entriesMap
+   * == null || result == null) return; if (entriesMap instanceof SortedMap) { Iterator entriesIter
+   * = ((SortedMap)entriesMap).values().iterator(); while (entriesIter.hasNext()) {
+   * RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entriesIter .next();
+   * rvMap.removeValuesFromCollection(result, iterOps, runtimeItr, context, projAttrib,
+   * intermediateResults, isIntersection); } } else if (entriesMap instanceof
+   * RegionEntryToValuesMap) { RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap)entriesMap;
+   * rvMap.removeValuesFromCollection(result, iterOps, runtimeItr, context, projAttrib,
+   * intermediateResults, isIntersection); } else { throw new
+   * RuntimeException(LocalizedStrings.RangeIndex_PROBLEM_IN_INDEX_QUERY.toLocalizedString()); } }
-  //TODO:Asif : The statistics data needs to be modified appropriately
-  // for the clear operation
-  this.valueToEntriesMap.clear();
-  this.entryToValuesMap.clear();
-  this.nullMappedEntries.clear();
-  this.undefinedMappedEntries.clear();
-  int numKeys = (int) this.internalIndexStats.getNumberOfKeys();
-  if(numKeys > 0){
-    this.internalIndexStats.incNumKeys(-numKeys);
-  }
-  int numValues = (int) this.internalIndexStats.getNumberOfValues();
-  if(numValues > 0) {
-    this.internalIndexStats.incNumValues(-numValues);
-  }
-  int updates = (int) this.internalIndexStats.getNumUpdates();
-  if(updates > 0) {
-    this.internalIndexStats.incNumUpdates(updates);
-  }
-  this.initializeIndex(true);
-}
-void lockedQuery(Object key, int operator, Collection results,
-    CompiledValue iterOps, RuntimeIterator runtimeItr,
-    ExecutionContext context,  List projAttrib, SelectResults intermediateResults,
-    boolean isIntersection)
-    throws TypeMismatchException, FunctionDomainException,
-    NameResolutionException, QueryInvocationTargetException
-{    
-  int limit = -1;
-  
-  Boolean applyLimit = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX); 
-  if(applyLimit != null && applyLimit.booleanValue()) {
-    limit = ((Integer)context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
-  }
-  
-  Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-  boolean multiColOrderBy = false;
-  List orderByAttrs =null;
-  boolean asc = true;
-  boolean applyOrderBy = false;
-  if(orderByClause != null && orderByClause.booleanValue()) {
-    orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);  
-    CompiledSortCriterion csc = (CompiledSortCriterion)orderByAttrs.get(0);
-    asc = !csc.getCriterion();
-    multiColOrderBy = orderByAttrs.size()>1;
-    applyOrderBy= true;
-  }
-  
-  if (key == null) {
-    switch (operator) {
-    case OQLLexerTokenTypes.TOK_EQ: {
-      nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr,
-          context, projAttrib, intermediateResults, isIntersection,limit);
-      break;
-    }
-    case OQLLexerTokenTypes.TOK_NE_ALT:
-    case OQLLexerTokenTypes.TOK_NE: { // add all btree values
-      NavigableMap sm = this.valueToEntriesMap;      
-      if(!asc) {   
-          sm =  sm.descendingMap();   
-   
-      }
-      //keysToRemove should be null, meaning we aren't removing any keys
-      addValuesToResult(sm, results, null, iterOps, runtimeItr,
-          context,projAttrib,intermediateResults,isIntersection,multiColOrderBy?-1:limit);
-      undefinedMappedEntries.addValuesToCollection(results, iterOps,
-          runtimeItr, context,projAttrib, intermediateResults,isIntersection,limit);
-      break;
-    }
-    default: {
-      throw new IllegalArgumentException("Invalid Operator");
-    }
-    } // end switch
-  }
-  else if (key == QueryService.UNDEFINED) { // do nothing
-    switch (operator) {
-    case OQLLexerTokenTypes.TOK_EQ: {
-      undefinedMappedEntries.addValuesToCollection(results, iterOps,
-          runtimeItr, context,projAttrib,intermediateResults,isIntersection,limit);
-      break;
-    }
-    case OQLLexerTokenTypes.TOK_NE:
-    case OQLLexerTokenTypes.TOK_NE_ALT: { // add all btree values
-      NavigableMap sm = this.valueToEntriesMap;
-      
-      if(!asc) {        
-          sm =  sm.descendingMap();
-      }
-      //keysToRemove should be null
-      addValuesToResult(sm, results, null, iterOps, runtimeItr,
-          context,projAttrib,intermediateResults,isIntersection,multiColOrderBy?-1:limit);
-      nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr,
-          context,projAttrib,intermediateResults,isIntersection,limit);
-      break;
-    }
-    default: {
-      throw new IllegalArgumentException("Invalid Operator");
-    }
-    } // end switch
-  }
-  else {
-    // return if the index map is still empty at this stage
-    if(isEmpty()){
-      return;
-    }
-    key = getPdxStringForIndexedPdxKeys(key);
-    evaluate(key, operator, results, iterOps, runtimeItr, context,projAttrib,intermediateResults,isIntersection,limit,
-        applyOrderBy,orderByAttrs);
-  } // end else
-}
-/** Method called while appropriate lock held */
-@Override
-void lockedQuery(Object key, int operator, Collection results, Set keysToRemove, ExecutionContext context)
-    throws TypeMismatchException {
-  int limit = -1;
-  
-  //not applying limit at this level currently as range index does not properly apply other conditions
-  //we could end up returning incorrect results - missing results
-  //This querie's limits are restricted up in the RangeIndex/QueryUtils calls.
-  //The next step may be to move the query utils cutdown/etc code into the range index itself and pass down the runtimeItrs?
-  //but that code is fragile and hard to read.
-  //It looks like this path is only for AbstractGroupOrRangeJunction, CompositeGroupJunction, CompiledComparison with some caveats as well as CompiledLike
-  
-  Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-  
-  boolean asc = true;
-  List orderByAttrs =null;
-  
-  boolean multiColOrderBy = false;
-  if(orderByClause != null && orderByClause.booleanValue()) {
-    orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);    
-    CompiledSortCriterion csc = (CompiledSortCriterion)orderByAttrs.get(0);
-    asc = !csc.getCriterion();  
-    multiColOrderBy =  orderByAttrs.size()>1;
-  }
-  
-  limit = multiColOrderBy?-1:limit;
-  
-  if (key == null) {
-    switch (operator) {
-      case OQLLexerTokenTypes.TOK_EQ: {
-        nullMappedEntries.addValuesToCollection(results,limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_NE_ALT:
-      case OQLLexerTokenTypes.TOK_NE: { // add all btree values        
-        NavigableMap sm = this.valueToEntriesMap;
-        if (!asc) {
-          sm = sm.descendingMap();
-        }       
-        //keysToRemove should be null
-        addValuesToResult(sm, results, keysToRemove, limit, context);
-        undefinedMappedEntries.addValuesToCollection(results,limit, context);
-        break;
-      }
-      default: {
-        throw new IllegalArgumentException(LocalizedStrings.RangeIndex_INVALID_OPERATOR.toLocalizedString());
-      }
-    } // end switch
-  }
-  else if (key == QueryService.UNDEFINED) { // do nothing
-    switch (operator) {
-      case OQLLexerTokenTypes.TOK_EQ: {
-        undefinedMappedEntries.addValuesToCollection(results,limit, context);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_NE:
-      case OQLLexerTokenTypes.TOK_NE_ALT: { // add all btree values
-        NavigableMap sm = this.valueToEntriesMap.headMap(key,false);        
-        sm = asc ? sm : sm.descendingMap();
-        //keysToRemove should be null
-        addValuesToResult(sm, results, keysToRemove, limit, context);
-        nullMappedEntries.addValuesToCollection(results,limit, context);
-        break;
-      }
-      default: {
-        throw new IllegalArgumentException(LocalizedStrings.RangeIndex_INVALID_OPERATOR.toLocalizedString());
-      }
-    } // end switch
-  }
-  else {
-    // return if the index map is still empty at this stage
-    if(isEmpty()){
-      return;
-    }
-    key = getPdxStringForIndexedPdxKeys(key);
-    evaluate(key, operator, results, keysToRemove,limit, context);
-  } // end else
-}
-@Override
-@SuppressWarnings("fallthrough")
-void lockedQuery(Object lowerBoundKey, int lowerBoundOperator,
-    Object upperBoundKey, int upperBoundOperator,
-      Collection results, Set keysToRemove, ExecutionContext context) throws TypeMismatchException {
-    int limit = -1;
-    //not applying limit at this level currently as range index does not properly apply other conditions
-    //we could end up returning incorrect results - missing results
-    //This querie's limits are restricted up in the RangeIndex/QueryUtils calls.
-    //The next step may be to move the query utils cutdown/etc code into the range index itself and pass down the runtimeItrs?
-    //but that code is fragile and hard to read.
-    
-    Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    boolean multiColOrderBy = false;
-    List orderByAttrs =null;
-    boolean asc = true;
-    if(orderByClause != null && orderByClause.booleanValue()) {
-      orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);      
-      CompiledSortCriterion csc = (CompiledSortCriterion)orderByAttrs.get(0);
-      asc = !csc.getCriterion();
-      multiColOrderBy =  orderByAttrs.size() > 1;
+  void recreateIndexData() throws IMQException {
+    /*
+     * Asif : Mark the data maps to null & call the initialization code of index
+     */
+    // TODO:Asif : The statistics data needs to be modified appropriately
+    // for the clear operation
+    this.valueToEntriesMap.clear();
+    this.entryToValuesMap.clear();
+    this.nullMappedEntries.clear();
+    this.undefinedMappedEntries.clear();
+    int numKeys = (int) this.internalIndexStats.getNumberOfKeys();
+    if (numKeys > 0) {
+      this.internalIndexStats.incNumKeys(-numKeys);
-    limit = multiColOrderBy? -1: limit;
-    
+    int numValues = (int) this.internalIndexStats.getNumberOfValues();
+    if (numValues > 0) {
+      this.internalIndexStats.incNumValues(-numValues);
+    }
+    int updates = (int) this.internalIndexStats.getNumUpdates();
+    if (updates > 0) {
+      this.internalIndexStats.incNumUpdates(updates);
+    }
+    this.initializeIndex(true);
+  }
+
+  void lockedQuery(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+    int limit = -1;
+
+    Boolean applyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+    if (applyLimit != null && applyLimit.booleanValue()) {
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    }
+
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    boolean multiColOrderBy = false;
+    List orderByAttrs = null;
+    boolean asc = true;
+    boolean applyOrderBy = false;
+    if (orderByClause != null && orderByClause.booleanValue()) {
+      orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+      CompiledSortCriterion csc = (CompiledSortCriterion) orderByAttrs.get(0);
+      asc = !csc.getCriterion();
+      multiColOrderBy = orderByAttrs.size() > 1;
+      applyOrderBy = true;
+    }
+
+    if (key == null) {
+      switch (operator) {
+        case OQLLexerTokenTypes.TOK_EQ: {
+          nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE: { // add all btree values
+          NavigableMap sm = this.valueToEntriesMap;
+          if (!asc) {
+            sm = sm.descendingMap();
+
+          }
+          // keysToRemove should be null, meaning we aren't removing any keys
+          addValuesToResult(sm, results, null, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          undefinedMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, limit);
+          break;
+        }
+        default: {
+          throw new IllegalArgumentException("Invalid Operator");
+        }
+      } // end switch
+    } else if (key == QueryService.UNDEFINED) { // do nothing
+      switch (operator) {
+        case OQLLexerTokenTypes.TOK_EQ: {
+          undefinedMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, limit);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE:
+        case OQLLexerTokenTypes.TOK_NE_ALT: { // add all btree values
+          NavigableMap sm = this.valueToEntriesMap;
+
+          if (!asc) {
+            sm = sm.descendingMap();
+          }
+          // keysToRemove should be null
+          addValuesToResult(sm, results, null, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          nullMappedEntries.addValuesToCollection(results, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit);
+          break;
+        }
+        default: {
+          throw new IllegalArgumentException("Invalid Operator");
+        }
+      } // end switch
+    } else {
+      // return if the index map is still empty at this stage
+      if (isEmpty()) {
+        return;
+      }
+      key = getPdxStringForIndexedPdxKeys(key);
+      evaluate(key, operator, results, iterOps, runtimeItr, context, projAttrib,
+          intermediateResults, isIntersection, limit, applyOrderBy, orderByAttrs);
+    } // end else
+  }
+
+  /** Method called while appropriate lock held */
+  @Override
+  void lockedQuery(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException {
+    int limit = -1;
+
+    // not applying limit at this level currently as range index does not properly apply other
+    // conditions
+    // we could end up returning incorrect results - missing results
+    // This querie's limits are restricted up in the RangeIndex/QueryUtils calls.
+    // The next step may be to move the query utils cutdown/etc code into the range index itself and
+    // pass down the runtimeItrs?
+    // but that code is fragile and hard to read.
+    // It looks like this path is only for AbstractGroupOrRangeJunction, CompositeGroupJunction,
+    // CompiledComparison with some caveats as well as CompiledLike
+
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+
+    boolean asc = true;
+    List orderByAttrs = null;
+
+    boolean multiColOrderBy = false;
+    if (orderByClause != null && orderByClause.booleanValue()) {
+      orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+      CompiledSortCriterion csc = (CompiledSortCriterion) orderByAttrs.get(0);
+      asc = !csc.getCriterion();
+      multiColOrderBy = orderByAttrs.size() > 1;
+    }
+
+    limit = multiColOrderBy ? -1 : limit;
+
+    if (key == null) {
+      switch (operator) {
+        case OQLLexerTokenTypes.TOK_EQ: {
+          nullMappedEntries.addValuesToCollection(results, limit, context);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE: { // add all btree values
+          NavigableMap sm = this.valueToEntriesMap;
+          if (!asc) {
+            sm = sm.descendingMap();
+          }
+          // keysToRemove should be null
+          addValuesToResult(sm, results, keysToRemove, limit, context);
+          undefinedMappedEntries.addValuesToCollection(results, limit, context);
+          break;
+        }
+        default: {
+          throw new IllegalArgumentException(
+              LocalizedStrings.RangeIndex_INVALID_OPERATOR.toLocalizedString());
+        }
+      } // end switch
+    } else if (key == QueryService.UNDEFINED) { // do nothing
+      switch (operator) {
+        case OQLLexerTokenTypes.TOK_EQ: {
+          undefinedMappedEntries.addValuesToCollection(results, limit, context);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE:
+        case OQLLexerTokenTypes.TOK_NE_ALT: { // add all btree values
+          NavigableMap sm = this.valueToEntriesMap.headMap(key, false);
+          sm = asc ? sm : sm.descendingMap();
+          // keysToRemove should be null
+          addValuesToResult(sm, results, keysToRemove, limit, context);
+          nullMappedEntries.addValuesToCollection(results, limit, context);
+          break;
+        }
+        default: {
+          throw new IllegalArgumentException(
+              LocalizedStrings.RangeIndex_INVALID_OPERATOR.toLocalizedString());
+        }
+      } // end switch
+    } else {
+      // return if the index map is still empty at this stage
+      if (isEmpty()) {
+        return;
+      }
+      key = getPdxStringForIndexedPdxKeys(key);
+      evaluate(key, operator, results, keysToRemove, limit, context);
+    } // end else
+  }
+
+  @Override
+  @SuppressWarnings("fallthrough")
+  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException {
+    int limit = -1;
+    // not applying limit at this level currently as range index does not properly apply other
+    // conditions
+    // we could end up returning incorrect results - missing results
+    // This querie's limits are restricted up in the RangeIndex/QueryUtils calls.
+    // The next step may be to move the query utils cutdown/etc code into the range index itself and
+    // pass down the runtimeItrs?
+    // but that code is fragile and hard to read.
+
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    boolean multiColOrderBy = false;
+    List orderByAttrs = null;
+    boolean asc = true;
+    if (orderByClause != null && orderByClause.booleanValue()) {
+      orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+      CompiledSortCriterion csc = (CompiledSortCriterion) orderByAttrs.get(0);
+      asc = !csc.getCriterion();
+      multiColOrderBy = orderByAttrs.size() > 1;
+    }
+    limit = multiColOrderBy ? -1 : limit;
+
-    if(isEmpty()){
+    if (isEmpty()) {
-    boolean upperBoundInclusive = upperBoundOperator == OQLLexerTokenTypes.TOK_LE;   
-    
-    NavigableMap dataset = this.valueToEntriesMap.subMap(
-        lowerBoundKey, lowerBoundInclusive, upperBoundKey, upperBoundInclusive);
+    boolean upperBoundInclusive = upperBoundOperator == OQLLexerTokenTypes.TOK_LE;
+
+    NavigableMap dataset = this.valueToEntriesMap.subMap(lowerBoundKey, lowerBoundInclusive,
+        upperBoundKey, upperBoundInclusive);
-    
+
-@Override
-public boolean containsEntry(RegionEntry entry) {
-  return (this.entryToValuesMap.containsEntry(entry)
-      || this.nullMappedEntries.containsEntry(entry) || this.undefinedMappedEntries
-      .containsEntry(entry));
-}
+  @Override
+  public boolean containsEntry(RegionEntry entry) {
+    return (this.entryToValuesMap.containsEntry(entry)
+        || this.nullMappedEntries.containsEntry(entry)
+        || this.undefinedMappedEntries.containsEntry(entry));
+  }
-public String dump() {
-  StringBuffer sb = new StringBuffer(toString()).append(" {\n");
-  sb.append("Null Values\n");
-  Iterator nI = nullMappedEntries.entrySet().iterator();
-  while (nI.hasNext()) {
-    Map.Entry mapEntry = (Map.Entry) nI.next();
-    RegionEntry e = (RegionEntry) mapEntry.getKey();
-    Object value = mapEntry.getValue();
-    sb.append("  RegionEntry.key = ").append(e.getKey());
-    sb.append("  Value.type = ").append(value.getClass().getName());
-    if (value instanceof Collection) {
-      sb.append("  Value.size = ").append(((Collection) value).size());
-    }
-    sb.append("\n");
-  }
-  sb.append(" -----------------------------------------------\n");
-  sb.append("Undefined Values\n");
-  Iterator uI = undefinedMappedEntries.entrySet().iterator();
-  while (uI.hasNext()) {
-    Map.Entry mapEntry = (Map.Entry) uI.next();
-    RegionEntry e = (RegionEntry) mapEntry.getKey();
-    Object value = mapEntry.getValue();
-    sb.append("  RegionEntry.key = ").append(e.getKey());
-    sb.append("  Value.type = ").append(value.getClass().getName());
-    if (value instanceof Collection) {
-      sb.append("  Value.size = ").append(((Collection) value).size());
-    }
-    sb.append("\n");
-  }
-  sb.append(" -----------------------------------------------\n");
-  Iterator i1 = this.valueToEntriesMap.entrySet().iterator();
-  while (i1.hasNext()) {
-    Map.Entry indexEntry = (Map.Entry) i1.next();
-    sb.append(" Key = " + indexEntry.getKey()).append("\n");
-    sb.append(" Value Type = ").append(
-        " " + indexEntry.getValue().getClass().getName()).append("\n");
-    if (indexEntry.getValue() instanceof Map) {
-      sb.append(" Value Size = ").append(
-          " " + ((Map) indexEntry.getValue()).size()).append("\n");
-    }
-    Iterator i2 = ((RegionEntryToValuesMap) indexEntry.getValue()).entrySet()
-        .iterator();
-    while (i2.hasNext()) {
-      Map.Entry mapEntry = (Map.Entry) i2.next();
+  public String dump() {
+    StringBuffer sb = new StringBuffer(toString()).append(" {\n");
+    sb.append("Null Values\n");
+    Iterator nI = nullMappedEntries.entrySet().iterator();
+    while (nI.hasNext()) {
+      Map.Entry mapEntry = (Map.Entry) nI.next();
-      //sb.append(" Value.type = ").append(value).append("\n");
+    sb.append("Undefined Values\n");
+    Iterator uI = undefinedMappedEntries.entrySet().iterator();
+    while (uI.hasNext()) {
+      Map.Entry mapEntry = (Map.Entry) uI.next();
+      RegionEntry e = (RegionEntry) mapEntry.getKey();
+      Object value = mapEntry.getValue();
+      sb.append("  RegionEntry.key = ").append(e.getKey());
+      sb.append("  Value.type = ").append(value.getClass().getName());
+      if (value instanceof Collection) {
+        sb.append("  Value.size = ").append(((Collection) value).size());
+      }
+      sb.append("\n");
+    }
+    sb.append(" -----------------------------------------------\n");
+    Iterator i1 = this.valueToEntriesMap.entrySet().iterator();
+    while (i1.hasNext()) {
+      Map.Entry indexEntry = (Map.Entry) i1.next();
+      sb.append(" Key = " + indexEntry.getKey()).append("\n");
+      sb.append(" Value Type = ").append(" " + indexEntry.getValue().getClass().getName())
+          .append("\n");
+      if (indexEntry.getValue() instanceof Map) {
+        sb.append(" Value Size = ").append(" " + ((Map) indexEntry.getValue()).size()).append("\n");
+      }
+      Iterator i2 = ((RegionEntryToValuesMap) indexEntry.getValue()).entrySet().iterator();
+      while (i2.hasNext()) {
+        Map.Entry mapEntry = (Map.Entry) i2.next();
+        RegionEntry e = (RegionEntry) mapEntry.getKey();
+        Object value = mapEntry.getValue();
+        sb.append("  RegionEntry.key = ").append(e.getKey());
+        sb.append("  Value.type = ").append(value.getClass().getName());
+        if (value instanceof Collection) {
+          sb.append("  Value.size = ").append(((Collection) value).size());
+        }
+        sb.append("\n");
+        // sb.append(" Value.type = ").append(value).append("\n");
+      }
+      sb.append(" -----------------------------------------------\n");
+    }
+    sb.append("}// Index ").append(getName()).append(" end");
+    return sb.toString();
-  sb.append("}// Index ").append(getName()).append(" end");
-  return sb.toString();
-}
-    
+
-      this.vsdStats = new IndexStats(getRegion().getCache()
-          .getDistributedSystem(), indexName);
+      this.vsdStats = new IndexStats(getRegion().getCache().getDistributedSystem(), indexName);
-    
-    
+
+
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-     * Returns the total amount of time (in nanoseconds) spent updating this
-     * index.
+     * Returns the total amount of time (in nanoseconds) spent updating this index.
-     * Returns the total number of times this index has been accessed by a
-     * query.
+     * Returns the total number of times this index has been accessed by a query.
-      if (key == null) return nullMappedEntries.getNumValues();
+      if (key == null)
+        return nullMappedEntries.getNumValues();
-          return undefinedMappedEntries.getNumValues();
-      RegionEntryToValuesMap rvMap = (RegionEntryToValuesMap) RangeIndex.this.valueToEntriesMap
-          .get(key);
-      if (rvMap == null) return 0;
+        return undefinedMappedEntries.getNumValues();
+      RegionEntryToValuesMap rvMap =
+          (RegionEntryToValuesMap) RangeIndex.this.valueToEntriesMap.get(key);
+      if (rvMap == null)
+        return 0;
-      sb.append("Total Update time = ").append(getTotalUpdateTime()).append(
-          "\n");
+      sb.append("Total Update time = ").append(getTotalUpdateTime()).append("\n");
+

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * Empty constructor to satisfy {@link org.apache.geode.DataSerializer}
-   * requirements
+   * Empty constructor to satisfy {@link org.apache.geode.DataSerializer} requirements
-  public InvalidateMessage() {
-  }
+  public InvalidateMessage() {}
-  private InvalidateMessage(Set recipients,
-                            boolean notifyOnly,
-                            int regionId,
-                            DirectReplyProcessor processor,
-                            EntryEventImpl event) {
-    super(recipients,
-          notifyOnly,
-          regionId,
-          processor,
-          event,
-          null); // expectedOldValue
+  private InvalidateMessage(Set recipients, boolean notifyOnly, int regionId,
+      DirectReplyProcessor processor, EntryEventImpl event) {
+    super(recipients, notifyOnly, regionId, processor, event, null); // expectedOldValue
-  
+
+   * 
-    if (event.hasOldValue() && ( members != null && !members.isEmpty())){ 
+    if (event.hasOldValue() && (members != null && !members.isEmpty())) {
-  
+
-   * send a notification-only message to a set of listeners.  The processor
-   * id is passed with the message for reply message processing.  This method
-   * does not wait on the processor.
+   * send a notification-only message to a set of listeners. The processor id is passed with the
+   * message for reply message processing. This method does not wait on the processor.
-      FilterRoutingInfo filterRoutingInfo, 
-      PartitionedRegion r, EntryEventImpl event, 
+      FilterRoutingInfo filterRoutingInfo, PartitionedRegion r, EntryEventImpl event,
-    InvalidateMessage msg = new InvalidateMessage(Collections.EMPTY_SET, 
-        true, r.getPRId(), processor, event);
+    InvalidateMessage msg =
+        new InvalidateMessage(Collections.EMPTY_SET, true, r.getPRId(), processor, event);
-    return msg.relayToListeners(cacheOpReceivers, adjunctRecipients,
-        filterRoutingInfo, event, r, processor);
+    return msg.relayToListeners(cacheOpReceivers, adjunctRecipients, filterRoutingInfo, event, r,
+        processor);
-  
+
-   * Sends an InvalidateMessage
-   * {@link org.apache.geode.cache.Region#invalidate(Object)}message to the
-   * recipient
+   * Sends an InvalidateMessage {@link org.apache.geode.cache.Region#invalidate(Object)}message to
+   * the recipient
-   * @param r
-   *          the PartitionedRegion for which the invalidate was performed
+   * @param r the PartitionedRegion for which the invalidate was performed
-  public static InvalidateResponse send(DistributedMember recipient,
-      PartitionedRegion r, EntryEventImpl event)
-      throws ForceReattemptException
-  {
-    //Assert.assertTrue(recipient != null, "InvalidateMessage NULL recipient");  recipient may be null for remote notifications
+  public static InvalidateResponse send(DistributedMember recipient, PartitionedRegion r,
+      EntryEventImpl event) throws ForceReattemptException {
+    // Assert.assertTrue(recipient != null, "InvalidateMessage NULL recipient"); recipient may be
+    // null for remote notifications
-    InvalidateMessage m = new InvalidateMessage(recipients, false,
-        r.getPRId(), p, event);
-    Set failures =r.getDistributionManager().putOutgoing(m); 
-    if (failures != null && failures.size() > 0 ) {
-      throw new ForceReattemptException(LocalizedStrings.InvalidateMessage_FAILED_SENDING_0.toLocalizedString(m));
+    InvalidateMessage m = new InvalidateMessage(recipients, false, r.getPRId(), p, event);
+    Set failures = r.getDistributionManager().putOutgoing(m);
+    if (failures != null && failures.size() > 0) {
+      throw new ForceReattemptException(
+          LocalizedStrings.InvalidateMessage_FAILED_SENDING_0.toLocalizedString(m));
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-   * @throws DataLocationException 
+   * @throws DataLocationException
-  protected boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion r, long startTime)
-      throws EntryExistsException, DataLocationException
-  {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws EntryExistsException, DataLocationException {
-       eventSender = getSender();
+      eventSender = getSender();
-    @Released final EntryEventImpl event = EntryEventImpl.create(
-        r,
-        getOperation(),
-        key,
-        null, /*newValue*/
-        getCallbackArg(),
-        false/*originRemote - false to force distribution in buckets*/,
-        eventSender,
-        true/*generateCallbacks*/,
-        false/*initializeId*/);
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(r, getOperation(), key, null, /* newValue */
+        getCallbackArg(), false/* originRemote - false to force distribution in buckets */,
+        eventSender, true/* generateCallbacks */, false/* initializeId */);
-    if (this.versionTag != null) {
-      this.versionTag.replaceNullIDs(getSender());
-      event.setVersionTag(this.versionTag);
-    }
-    if (this.bridgeContext != null) {
-      event.setContext(this.bridgeContext);
-    }
-//    Assert.assertTrue(eventId != null);  bug #47235: region invalidation doesn't send event ids
-    event.setEventId(eventId);
-    event.setPossibleDuplicate(this.posDup);
-    
-    PartitionedRegionDataStore ds = r.getDataStore();
-    boolean sendReply = true;
-//    boolean failed = false;
-    event.setInvokePRCallbacks(!notificationOnly);
-    if (!notificationOnly) {
-      Assert.assertTrue(ds!=null, "This process should have storage for an item in " + this.toString());
-      try {
-        Integer bucket = Integer.valueOf(PartitionedRegionHelper.getHashKey(event));
-        event.setCausedByMessage(this);
-        r.getDataView().invalidateOnRemote(event, true/*invokeCallbacks*/, false/*forceNewEntry*/);
-        this.versionTag = event.getVersionTag();
-        if (logger.isTraceEnabled(LogMarker.DM)) {
-          logger.trace(LogMarker.DM, "{} invalidateLocally in bucket: {}, key: {}", getClass().getName(), bucket, key);
-        }
-      }
-      catch (DataLocationException e) {
-        ((ForceReattemptException)e).checkKey(event.getKey());
-        throw e;
-      }
-      catch (EntryNotFoundException eee) {
-        //        failed = true;
-        if (logger.isDebugEnabled()) {
-          logger.debug("{}: operateOnRegion caught EntryNotFoundException {}", getClass().getName(), eee.getMessage(), eee);
-        }
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(eee), r, startTime);
-        sendReply = false; // this prevents us from acking later
-      }
-      catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        return false;
-      }
-
-    }
-    else {
-      event.setRegion(r);
-      event.setOriginRemote(true);
-      if (this.filterInfo != null) {
-        event.setLocalFilterInfo(this.filterInfo.getFilterInfo(dm.getDistributionManagerId()));
+      if (this.bridgeContext != null) {
+        event.setContext(this.bridgeContext);
-      r.invokeInvalidateCallbacks(EnumListenerEvent.AFTER_INVALIDATE, event, r.isInitialized());
-    }
-    
-    return sendReply;
+      // Assert.assertTrue(eventId != null); bug #47235: region invalidation doesn't send event ids
+      event.setEventId(eventId);
+      event.setPossibleDuplicate(this.posDup);
+
+      PartitionedRegionDataStore ds = r.getDataStore();
+      boolean sendReply = true;
+      // boolean failed = false;
+      event.setInvokePRCallbacks(!notificationOnly);
+      if (!notificationOnly) {
+        Assert.assertTrue(ds != null,
+            "This process should have storage for an item in " + this.toString());
+        try {
+          Integer bucket = Integer.valueOf(PartitionedRegionHelper.getHashKey(event));
+          event.setCausedByMessage(this);
+          r.getDataView().invalidateOnRemote(event, true/* invokeCallbacks */,
+              false/* forceNewEntry */);
+          this.versionTag = event.getVersionTag();
+          if (logger.isTraceEnabled(LogMarker.DM)) {
+            logger.trace(LogMarker.DM, "{} invalidateLocally in bucket: {}, key: {}",
+                getClass().getName(), bucket, key);
+          }
+        } catch (DataLocationException e) {
+          ((ForceReattemptException) e).checkKey(event.getKey());
+          throw e;
+        } catch (EntryNotFoundException eee) {
+          // failed = true;
+          if (logger.isDebugEnabled()) {
+            logger.debug("{}: operateOnRegion caught EntryNotFoundException {}",
+                getClass().getName(), eee.getMessage(), eee);
+          }
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(eee), r, startTime);
+          sendReply = false; // this prevents us from acking later
+        } catch (PrimaryBucketException pbe) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
+          return false;
+        }
+
+      } else {
+        event.setRegion(r);
+        event.setOriginRemote(true);
+        if (this.versionTag != null) {
+          this.versionTag.replaceNullIDs(getSender());
+          event.setVersionTag(this.versionTag);
+        }
+        if (this.filterInfo != null) {
+          event.setLocalFilterInfo(this.filterInfo.getFilterInfo(dm.getDistributionManagerId()));
+        }
+        r.invokeInvalidateCallbacks(EnumListenerEvent.AFTER_INVALIDATE, event, r.isInitialized());
+      }
+
+      return sendReply;
-  
+
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime) {
-      pr.getPrStats().endPartitionMessagesProcessing(startTime); 
+      pr.getPrStats().endPartitionMessagesProcessing(startTime);
-  
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public InvalidateReplyMessage() {
-    }
-  
-    private InvalidateReplyMessage(int processorId, VersionTag version, ReplyException ex)
-    {
+    public InvalidateReplyMessage() {}
+
+    private InvalidateReplyMessage(int processorId, VersionTag version, ReplyException ex) {
-    
+
-        ReplySender replySender, ReplyException ex, VersionTag version) 
-    {
+        ReplySender replySender, ReplyException ex, VersionTag version) {
-      
+
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        logger.trace(LogMarker.DM, "InvalidateReplyMessage process invoking reply processor with processorId: {}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "InvalidateReplyMessage process invoking reply processor with processorId: {}",
+            this.processorId);
-  
+
-        InvalidateResponse processor = (InvalidateResponse)rp;
+        InvalidateResponse processor = (InvalidateResponse) rp;
-  
+
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    
+
-    
+
-  
+
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.versionTag = (VersionTag)DataSerializer.readObject(in);
+      this.versionTag = (VersionTag) DataSerializer.readObject(in);
-  
+
-      sb.append("InvalidateReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" exception=").append(getException())
-      .append(" versionTag=").append(this.versionTag);
+      sb.append("InvalidateReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" exception=").append(getException()).append(" versionTag=")
+          .append(this.versionTag);
+   * 
-  public static class InvalidateResponse extends PartitionResponse  {
+  public static class InvalidateResponse extends PartitionResponse {
-    
+
-    public void waitForResult() throws CacheException, ForceReattemptException
-    {
+    public void waitForResult() throws CacheException, ForceReattemptException {
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-        throw new ForceReattemptException(LocalizedStrings.InvalidateMessage_NO_RESPONSE_CODE_RECEIVED.toLocalizedString());
+        throw new ForceReattemptException(
+            LocalizedStrings.InvalidateMessage_NO_RESPONSE_CODE_RECEIVED.toLocalizedString());
-  
+

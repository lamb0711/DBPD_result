GEODE-8250: Create new custom log config acceptance tests (#5309)

* Adjust GfshRule use of TemporaryFolder and use it
* Move GfshRuleIntegrationTest from test to integrationTest
* Fixup GfshRuleIntegrationTest, VersionManager, and VersionManagerJUnitTest
* Add geode-old-versions to integrationTests
* Print JAVA_HOME directory tree if assertion about java binary fails
+import static java.util.Collections.unmodifiableList;
+
-import java.util.Collections;
+import org.apache.geode.annotations.VisibleForTesting;
+
+ *
- * see Host.getVM(String, int)
+ * <p>
+ * See VM.getVM(String version, int whichVM). Example:
+ *
+ * <pre>
+ * import static org.apache.geode.test.dunit.VM.getVM;
+ *
+ * VM oldServerVM = getVM("1.3.0", 0);
+ * </pre>
-  private static VersionManager instance;
+  private static final String DEFAULT_VERSIONS_FILE = "geodeOldVersionClasspaths.txt";
+  private static final String DEFAULT_INSTALLS_FILE = "geodeOldVersionInstalls.txt";
-  protected String loadFailure = "";
+  private static final VersionManager INSTANCE = newInstance();
-  /**
-   * returns the ordinal of the Version of Geode used in this JVM. Use this
-   * instead of Version.CURRENT or Version.CURRENT_ORDINAL in test code
-   */
-  public short getCurrentVersionOrdinal() {
-    return geodeCurrentVersionOrdinal;
-  }
-
-  private short geodeCurrentVersionOrdinal = -1;
-
-  protected static void init() {
-    instance = new VersionManager();
-    final String fileName = "geodeOldVersionClasspaths.txt";
-    final String installLocations = "geodeOldVersionInstalls.txt";
-    instance.findVersions(fileName);
-    instance.findInstalls(installLocations);
-    instance.establishGeodeVersionOrdinal();
-    // System.out
-    // .println("VersionManager has loaded the following classpaths:\n" + instance.classPaths);
+  private static VersionManager newInstance() {
+    VersionManager versionManager = new VersionManager();
+    versionManager.findVersions(DEFAULT_VERSIONS_FILE);
+    versionManager.findInstalls(DEFAULT_INSTALLS_FILE);
+    versionManager.establishGeodeVersionOrdinal();
+    // System.out.println(String.format("VersionManager has loaded the following classpaths:%s%s",
+    // lineSeparator(), versionManager.classPaths));
+    return versionManager;
-    if (instance == null) {
-      init();
-    }
-    return instance;
+    return INSTANCE;
-   * for unit testing, this creates a VersionManager with paths loaded from the given file, which
+   * For unit testing, this creates a VersionManager with paths loaded from the given file, which
-  protected static VersionManager getInstance(String classpathsFileName, String installFileName) {
+  @VisibleForTesting
+  static VersionManager getInstance(String classpathsFileName) {
-   * classPaths for old versions loaded from a file generated by Gradle
-   */
-  private Map<String, String> classPaths = new HashMap<>();
-
-  private List<String> testVersions = new ArrayList<String>(10);
-
-  private Map<String, String> installs = new HashMap();
-
-  /**
-   * Test to see if a version string is known to VersionManager. Versions are either CURRENT_VERSION
-   * or one of the versions returned by VersionManager#getVersions()
-   */
-  public boolean isValidVersion(String version) {
-    return version.equals(CURRENT_VERSION) || classPaths.containsKey(version);
-  }
-
-  /**
+  private volatile String loadFailure = "";
+  private volatile short geodeCurrentVersionOrdinal = -1;
+
-   * Returns the classPath for the given version, or null if the version is not valid. Use
-   * CURRENT_VERSION for the version in development.
+   * Classpaths for old versions loaded from a file generated by Gradle
+   */
+  private final Map<String, String> classPaths = new HashMap<>();
+  private final List<String> testVersions = new ArrayList<>(10);
+  private final Map<String, String> installs = new HashMap<>();
+
+  /**
+   * Returns the ordinal of the version of Geode used in this JVM. Use this instead of
+   * {@code Version.CURRENT} or {@code Version.CURRENT_ORDINAL} in test code.
+   */
+  public short getCurrentVersionOrdinal() {
+    return geodeCurrentVersionOrdinal;
+  }
+
+  /**
+   * Check to see if a version string is known to VersionManager. Versions are either
+   * {@link #CURRENT_VERSION} or one of the versions returned by
+   * {@link VersionManager#getVersions()}.
+   */
+  public boolean isValidVersion(String version) {
+    return version.equals(CURRENT_VERSION) || classPaths.containsKey(version);
+  }
+
+  /**
+   * Returns the classpath for the given version, or null if the version is not valid. Use
+   * {@link #CURRENT_VERSION} for the version in development.
-
-    if (!installs.containsKey(version) || (installs.get(version) == null)) {
+    if (!installs.containsKey(version) || installs.get(version) == null) {
-   * Returns a list of older versions available for testing, sorted
-   * from oldest to newest.<br>
-   * Note: if you need to compare version strings use TestVersion.compare() or TestVersion.equals()
+   * Returns a list of older versions available for testing, sorted from oldest to newest.
+   *
+   * <p>
+   * Note: if you need to compare version strings use {@link TestVersion#compare(String, String)} or
+   * {@link TestVersion#equals(TestVersion)}.
-    return Collections.unmodifiableList(testVersions);
+    return unmodifiableList(testVersions);
-   * returns a list of testable versions sorted from oldest to newest<br>
-   * Note: if you need to compare version strings use TestVersion.compare() or TestVersion.equals()
+   * Returns a list of testable versions sorted from oldest to newest
+   *
+   * <p>
+   * Note: if you need to compare version strings use {@link TestVersion#compare(String, String)} or
+   * {@link TestVersion#equals(TestVersion)}.
-    if (loadFailure.length() > 0) {
+    if (!loadFailure.isEmpty()) {
-    Collections.sort(testVersions, (v1, v2) -> TestVersion.compare(v1, v2));
+    testVersions.sort(TestVersion::compare);
-      if (parsedVersion.isPresent()) {
-        installs.put(parsedVersion.get(), install);
-      }
+      parsedVersion.ifPresent(s -> installs.put(s, install));
-    if (version.length() > 0 && Character.isDigit(version.charAt(0))
+    if (!version.isEmpty()
+        && Character.isDigit(version.charAt(0))
-    props.forEach((k, v) -> {
-      consumer.accept(k.toString(), v.toString());
-    });
+    props.forEach((k, v) -> consumer.accept(k.toString(), v.toString()));
-  public Properties readPropertiesFile(String fileName) {
+  private Properties readPropertiesFile(String fileName) {
-    try (InputStream in = VersionManager.class.getResource("/" + fileName).openStream()) {
+
+    try (InputStream in = url.openStream()) {
-      return props;
-  public void establishGeodeVersionOrdinal() {
-    Class versionClass;
-    Field currentOrdinalField;
+  private void establishGeodeVersionOrdinal() {
+    try {
+      geodeCurrentVersionOrdinal = findOrdinalField(findVersionClass()).getShort(null);
+    } catch (IllegalAccessException e) {
+      throw new IllegalStateException(
+          "Unable to retrieve Version.java's CURRENT_ORDINAL field in order to establish the product's serialization version",
+          e);
+    }
+  }
+
+  private Class<?> findVersionClass() {
-      versionClass = Class.forName("org.apache.geode.internal.Version");
+      return Class.forName("org.apache.geode.internal.Version");
-        versionClass = Class.forName("org.apache.geode.internal.serialization.Version");
+        return Class.forName("org.apache.geode.internal.serialization.Version");
+  }
+
+  private Field findOrdinalField(Class<?> versionClass) {
-      currentOrdinalField = versionClass.getDeclaredField("CURRENT_ORDINAL");
+      Field currentOrdinalField = versionClass.getDeclaredField("CURRENT_ORDINAL");
+      currentOrdinalField.setAccessible(true);
+      return currentOrdinalField;
-    currentOrdinalField.setAccessible(true);
-    try {
-      geodeCurrentVersionOrdinal = currentOrdinalField.getShort(null);
-    } catch (IllegalAccessException e) {
-      throw new IllegalStateException(
-          "Unable to retrieve Version.java's CURRENT_ORDINAL field in order to establlish the product's serialization version",
-          e);
-    }
+  }
+
+  @VisibleForTesting
+  String getLoadFailure() {
+    return loadFailure;

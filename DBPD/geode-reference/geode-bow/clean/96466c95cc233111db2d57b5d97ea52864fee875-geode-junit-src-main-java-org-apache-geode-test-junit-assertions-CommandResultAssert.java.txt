GEODE-5971: delete LegacyCommandResult and rename ModelResultModel toâ€¦ (#3497)



-import java.util.LinkedHashMap;
+import org.assertj.core.api.AbstractStringAssert;
-import org.junit.Assert;
-import org.apache.geode.management.internal.cli.result.ModelCommandResult;
-    extends AbstractAssert<CommandResultAssert, CommandResultExecution> {
+    extends AbstractAssert<CommandResultAssert, CommandResult> {
+
+  private String commandOutput;
-    super(new CommandResultExecution(commandResult.toJson(), commandResult),
-        CommandResultAssert.class);
-  }
-
-  public CommandResultAssert(String output, CommandResult commandResult) {
-    super(new CommandResultExecution(output, commandResult), CommandResultAssert.class);
+    super(commandResult, CommandResultAssert.class);
+    this.commandOutput = commandResult.asString();
-    return actual.getCommandResult();
+    return actual;
-    assertThat(actual.getOutput()).containsPattern("\\Q" + key + "\\E\\s+: \\Q" + value + "\\E");
+    assertThat(commandOutput).containsPattern("\\Q" + key + "\\E\\s+: \\Q" + value + "\\E");
+  public AbstractStringAssert<?> hasOutput() {
+    return assertThat(commandOutput);
+  }
+
-    for (String expectedOutput : expectedOutputs) {
-      assertThat(actual.getOutput()).contains(expectedOutput);
-    }
-
-    return this;
-  }
-
-  /**
-   * @deprecated use hasDataSection methods to verify the table contents
-   */
-  public CommandResultAssert containsOrderedOutput(String dataSectionName,
-      String... expectedOutputs) {
-
-    LinkedHashMap<String, String> outputMap;
-    try {
-      outputMap =
-          ((LinkedHashMap) actual.getCommandResult().getMapFromSection(dataSectionName));
-    } catch (NullPointerException ex) {
-      Assert.fail("No section found for \"" + dataSectionName + "\"");
-      return this;
-    }
-    String outputString = outputMap.toString();
-    int outputIndex = 0;
-
-    for (int i = 0; i < expectedOutputs.length; i++) {
-      outputIndex = outputString.indexOf(expectedOutputs[i]);
-      if (outputIndex == -1) {
-        Assert.fail("Expected output " + expectedOutputs[i]
-            + " was not found, or isn't in the specified order.");
-      }
-      outputString = outputString.substring(outputIndex);
-    }
-
+    assertThat(commandOutput).contains(expectedOutputs);
-    for (String expectedOutput : expectedOutputs) {
-      assertThat(actual.getOutput()).doesNotContain(expectedOutput);
-    }
-
+    assertThat(commandOutput).doesNotContain(expectedOutputs);
-    CommandResult result = actual.getCommandResult();
-    Assertions.assertThat(result.getStatus()).describedAs(actual.getOutput())
+    Assertions.assertThat(actual.getStatus()).describedAs(commandOutput)
-  public CommandResultAssert hasFailToPersistError() {
-    Assertions.assertThat(actual.getCommandResult().failedToPersist()).isTrue();
-    return this;
-  }
-
-  public CommandResultAssert hasNoFailToPersistError() {
-    Assertions.assertThat(actual.getCommandResult().failedToPersist()).isFalse();
-    return this;
-  }
-
-    CommandResult result = actual.getCommandResult();
-    Assertions.assertThat(result.getStatus()).describedAs(actual.getOutput())
+    Assertions.assertThat(actual.getStatus()).describedAs(commandOutput)
-   * the specified values in the specified order.
-   *
-   * For example, given the following gfsh output:
-   *
-   * <pre>
-   * Index Name | Region Path | Server Name |      Indexed Fields      |
-   * ---------- | ----------- | ----------- | ------------------------ |
-   * index1      | /region1     | server-0    | [field1, field3, field2] |
-   * index2      | /region2     | server-0    | [field1, field3, field2] |
-   * </pre>
-   *
-   * We might assert that:
-   *
-   * <pre>
-   * <code> tableHasColumnWithExactValuesInExactOrder("Region Path", "/region1", "/region2");
-   * </code>
-   * </pre>
-   *
-   * @deprecated use hasTableSection methods to verify the table contents
-   */
-  public CommandResultAssert tableHasColumnWithExactValuesInExactOrder(String header,
-      String... expectedValues) {
-    List<String> actualValues = actual.getCommandResult().getTableColumnValues(header);
-    assertThat(actualValues).containsExactly(expectedValues);
-
-    return this;
-  }
-
-  /**
-   * Verifies that the gfsh output contains a table that has a column with the specified header and
-    List<String> actualValues = actual.getCommandResult().getTableColumnValues(header);
-    assertThat(actualValues).containsExactlyInAnyOrder(expectedValues);
-
+    hasTableSection().hasColumn(header).containsExactlyInAnyOrder(expectedValues);
-      List<String> columnValues = actual.getCommandResult().getTableColumnValues(header);
+      List<String> columnValues =
+          actual.getResultData().getTableSections().get(0).getValuesInColumn(header);
-  public CommandResultAssert tableHasRowCount(String anyColumnHeader, int rowSize) {
-    assertThat(actual.getCommandResult().getTableColumnValues(anyColumnHeader).size())
-        .isEqualTo(rowSize);
+  public CommandResultAssert tableHasRowCount(int rowSize) {
+    hasTableSection().hasRowSize(rowSize);
-    List<String> actualValues = actual.getCommandResult().getTableColumnValues(header);
+    TabularResultModel actual = hasTableSection().getActual();
+    List<String> actualValues = actual.getValuesInColumn(header);
-    List<String> actualValues = actual.getCommandResult().getTableColumnValues(header);
-    assertThat(actualValues).containsOnly(expectedValues);
+    hasTableSection().hasColumn(header).containsOnly(expectedValues);
-   * methods that are only applicable to ModelCommandResult
+   * methods that are only applicable to CommandResult
-    ModelCommandResult modelCommandResult = (ModelCommandResult) actual.getCommandResult();
-    return modelCommandResult.getResultData();
+    return actual.getResultData();
+  public CommandResultAssert hasNoTableSection() {
+    assertThat(actual.getResultData().getTableSections().size()).isEqualTo(0);
+    return this;
+  }
+

GEODE-5971: have command pipeline send ResultModel json across the wire (#3495)

Co-authored-by: Owen Nichols <onichols@pivotal.io>
-import org.apache.commons.lang3.StringUtils;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CommandResponse;
-import org.apache.geode.management.internal.cli.CommandResponseBuilder;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
+   *         this returns a ModelCommandResult for all the online commands. For offline-commands,
+   *         this can return either a ModelCommandResult or ExitShellRequest
-    Result result;
-    result = executeOnRemote((GfshParseResult) parseResult);
-    return result;
+    ResultModel resultModel = executeOnRemote((GfshParseResult) parseResult);
+
+    if (resultModel == null) {
+      return null;
+    }
+    return new ModelCommandResult(resultModel);
-  private Result executeOnRemote(GfshParseResult parseResult) {
+  private ResultModel executeOnRemote(GfshParseResult parseResult) {
-    boolean useResultModel = false;
-        return ResultBuilder.createBadConfigurationErrorResult("Interceptor Configuration Error");
+        return ResultModel.createError("Interceptor Configuration Error");
-      Object preExecResult = interceptor.preExecution(parseResult);
-      if (preExecResult instanceof ResultModel) {
-        useResultModel = true;
-        if (((ResultModel) preExecResult).getStatus() != Status.OK) {
-          return new ModelCommandResult((ResultModel) preExecResult);
-        }
-      } else { // Must be Result
-        if (Status.ERROR.equals(((Result) preExecResult).getStatus())) {
-          return (Result) preExecResult;
-        }
+      ResultModel preExecResult = interceptor.preExecution(parseResult);
+      if (preExecResult.getStatus() != Status.OK) {
+        return preExecResult;
-
-      // when the preExecution yields a FileResult, we will get the fileData out of it
-      if (preExecResult instanceof ResultModel) {
-        ResultModel fileResult = (ResultModel) preExecResult;
-        fileData = fileResult.getFileList();
-      }
+      fileData = preExecResult.getFileList();
-        return ResultBuilder
-            .createBadResponseErrorResult("Response was null for: " + parseResult.getUserInput());
+        return ResultModel.createError("Response was null for: " + parseResult.getUserInput());
-      return ResultBuilder
-          .createGemFireUnAuthorizedErrorResult("Unauthorized. Reason : " + e.getMessage());
+      return ResultModel.createError("Unauthorized. Reason : " + e.getMessage());
-      e.printStackTrace();
-      return ResultBuilder.createBadResponseErrorResult(
+      return ResultModel.createError(
-    // CommandResult/ResultModel object
+    // ResultModel object
-    Object commandResult = null;
+    ResultModel commandResult = null;
-      try {
-        // if it's ResultModel
-        commandResult = ResultModel.fromJson((String) response);
-        useResultModel = true;
-      } catch (Exception ex) {
-        // if it's a CommandResult
-        CommandResponse commandResponse =
-            CommandResponseBuilder.prepareCommandResponseFromJson((String) response);
+      commandResult = ResultModel.fromJson((String) response);
-        if (commandResponse.isFailedToPersist()) {
-          shell.printAsSevere(CliStrings.SHARED_CONFIGURATION_FAILED_TO_PERSIST_COMMAND_CHANGES);
-          logWrapper.severe(CliStrings.SHARED_CONFIGURATION_FAILED_TO_PERSIST_COMMAND_CHANGES);
-        }
-
-        String debugInfo = commandResponse.getDebugInfo();
-        if (StringUtils.isNotBlank(debugInfo)) {
-          debugInfo = debugInfo.replaceAll("\n\n\n", "\n");
-          debugInfo = debugInfo.replaceAll("\n\n", "\n");
-          debugInfo =
-              debugInfo.replaceAll("\n", "\n[From Manager : " + commandResponse.getSender() + "]");
-          debugInfo = "[From Manager : " + commandResponse.getSender() + "]" + debugInfo;
-          this.logWrapper.info(debugInfo);
-        }
-        commandResult = ResultBuilder.fromJson((String) response);
-      }
-        if (useResultModel) {
-          commandResult =
-              interceptor.postExecution(parseResult, (ResultModel) commandResult, tempFile);
-        } else {
-          commandResult =
-              interceptor.postExecution(parseResult, (CommandResult) commandResult, tempFile);
-        }
+        commandResult =
+            interceptor.postExecution(parseResult, commandResult, tempFile);
+
-        commandResult = ResultBuilder.createGemFireErrorResult(e.getMessage());
+        commandResult = ResultModel.createError(e.getMessage());
-      commandResult = ResultBuilder
-          .createGemFireErrorResult("Unable to build commandResult using the remote response.");
+      commandResult =
+          ResultModel.createError("Unable to build ResultModel using the remote response.");
-    CommandResult gfshResult;
-    if (commandResult instanceof ResultModel) {
-      gfshResult = new ModelCommandResult((ResultModel) commandResult);
-    } else {
-      gfshResult = (CommandResult) commandResult;
-    }
-
-    return gfshResult;
+    return commandResult;

GEODE-4863: refactor jdbc commands to use this public cluster configuration api (#1776)

   * refactored jdbc connector commands to use public cc service
   * removed JdbcConnectorServiceXmlGenerator
   * removed RegionMappingBuilder & ConnectionConfigBuilder
   * if cc service is running then user can only alter whats available in CC
   * describe & List commands now list entries from cc service
   * converted some integration tests to junits
   * removed unwanted functions, tests

Signed-off-by: Jinmei Liao <jiliao@pivotal.io>

-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.connectors.jdbc.internal.RegionMapping;
-import org.apache.geode.connectors.jdbc.internal.RegionMappingBuilder;
+import org.apache.geode.connectors.jdbc.internal.configuration.ConnectorService;
+import org.apache.geode.distributed.ClusterConfigurationService;
-import org.apache.geode.distributed.internal.InternalClusterConfigurationService;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
+import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.TabularResultData;
-import org.apache.geode.management.internal.configuration.domain.XmlEntity;
-      @CliOption(key = ALTER_MAPPING__CONNECTION_NAME,
+      @CliOption(key = ALTER_MAPPING__CONNECTION_NAME, specifiedDefaultValue = "",
-    RegionMapping mapping =
-        getArguments(regionName, connectionName, table, pdxClassName, keyInValue, fieldMappings);
+    ConnectorService.RegionMapping newMapping = new ConnectorService.RegionMapping(regionName,
+        pdxClassName, table, connectionName, keyInValue);
+    newMapping.setFieldMapping(fieldMappings);
-    // action
-    ResultCollector<CliFunctionResult, List<CliFunctionResult>> resultCollector =
-        execute(new AlterMappingFunction(), mapping, targetMembers);
-
-    // output
-    TabularResultData tabularResultData = ResultBuilder.createTabularResultData();
-    XmlEntity xmlEntity = fillTabularResultData(resultCollector, tabularResultData);
-    tabularResultData.setHeader(EXPERIMENTAL);
-    Result result = ResultBuilder.buildResult(tabularResultData);
-    updateClusterConfiguration(result, xmlEntity);
-    return result;
-  }
-
-  ResultCollector<CliFunctionResult, List<CliFunctionResult>> execute(AlterMappingFunction function,
-      RegionMapping mapping, Set<DistributedMember> targetMembers) {
-    return (ResultCollector<CliFunctionResult, List<CliFunctionResult>>) executeFunction(function,
-        mapping, targetMembers);
-  }
-
-  private RegionMapping getArguments(String regionName, String connectionName, String table,
-      String pdxClassName, Boolean keyInValue, String[] fieldMappings) {
-    RegionMappingBuilder builder = new RegionMappingBuilder().withRegionName(regionName)
-        .withConnectionConfigName(connectionName).withTableName(table)
-        .withPdxClassName(pdxClassName).withPrimaryKeyInValue(keyInValue)
-        .withFieldToColumnMappings(fieldMappings);
-    return builder.build();
-  }
-
-  private XmlEntity fillTabularResultData(
-      ResultCollector<CliFunctionResult, List<CliFunctionResult>> resultCollector,
-      TabularResultData tabularResultData) {
-    XmlEntity xmlEntity = null;
-
-    for (CliFunctionResult oneResult : resultCollector.getResult()) {
-      if (oneResult.isSuccessful()) {
-        xmlEntity = addSuccessToResults(tabularResultData, oneResult);
-      } else {
-        addErrorToResults(tabularResultData, oneResult);
+    ClusterConfigurationService ccService = getConfigurationService();
+    // if cc is running, you can only alter connection available in cc service.
+    if (ccService != null) {
+      // search for the connection that has this id to see if it exists
+      ConnectorService service =
+          ccService.getCustomCacheElement("cluster", "connector-service", ConnectorService.class);
+      if (service == null) {
+        throw new EntityNotFoundException("mapping with name '" + regionName + "' does not exist.");
+      }
+      ConnectorService.RegionMapping mapping =
+          ccService.findIdentifiable(service.getRegionMapping(), regionName);
+      if (mapping == null) {
+        throw new EntityNotFoundException("mapping with name '" + regionName + "' does not exist.");
-    return xmlEntity;
-  }
+    // action
+    List<CliFunctionResult> results =
+        executeAndGetFunctionResult(new AlterMappingFunction(), newMapping, targetMembers);
-  private XmlEntity addSuccessToResults(TabularResultData tabularResultData,
-      CliFunctionResult oneResult) {
-    tabularResultData.accumulate("Member", oneResult.getMemberIdOrName());
-    tabularResultData.accumulate("Status", oneResult.getMessage());
-    return oneResult.getXmlEntity();
-  }
-
-  private void addErrorToResults(TabularResultData tabularResultData, CliFunctionResult oneResult) {
-    tabularResultData.accumulate("Member", oneResult.getMemberIdOrName());
-    tabularResultData.accumulate("Status", ERROR_PREFIX + oneResult.getMessage());
-    tabularResultData.setStatus(Result.Status.ERROR);
-  }
-
-  private void updateClusterConfiguration(final Result result, final XmlEntity xmlEntity) {
-    if (xmlEntity != null) {
-      persistClusterConfiguration(result,
-          () -> ((InternalClusterConfigurationService) getConfigurationService())
-              .addXmlEntity(xmlEntity, null));
+    boolean persisted = false;
+    // update the cc with the merged connection returned from the server
+    if (ccService != null && results.stream().filter(CliFunctionResult::isSuccessful).count() > 0) {
+      ConnectorService service =
+          ccService.getCustomCacheElement("cluster", "connector-service", ConnectorService.class);
+      if (service == null) {
+        service = new ConnectorService();
+      }
+      CliFunctionResult successResult =
+          results.stream().filter(CliFunctionResult::isSuccessful).findAny().get();
+      ConnectorService.RegionMapping mergedMapping =
+          (ConnectorService.RegionMapping) successResult.getResultObject();
+      ccService.removeFromList(service.getRegionMapping(), connectionName);
+      service.getRegionMapping().add(mergedMapping);
+      ccService.saveCustomCacheElement("cluster", service);
+      persisted = true;
+
+    CommandResult commandResult = ResultBuilder.buildResult(results, EXPERIMENTAL, null);
+    commandResult.setCommandPersisted(persisted);
+    return commandResult;

GEODE-4863: refactor jdbc commands to use this public cluster configuration api (#1776)

   * refactored jdbc connector commands to use public cc service
   * removed JdbcConnectorServiceXmlGenerator
   * removed RegionMappingBuilder & ConnectionConfigBuilder
   * if cc service is running then user can only alter whats available in CC
   * describe & List commands now list entries from cc service
   * converted some integration tests to junits
   * removed unwanted functions, tests

Signed-off-by: Jinmei Liao <jiliao@pivotal.io>

-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.connectors.jdbc.internal.ConnectionConfiguration;
-import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.connectors.jdbc.internal.configuration.ConnectorService;
+import org.apache.geode.distributed.ClusterConfigurationService;
-    // input
-    Set<DistributedMember> targetMembers = getMembers(null, null);
-    if (targetMembers.isEmpty()) {
-      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    ClusterConfigurationService ccService = getConfigurationService();
+    if (ccService == null) {
+      return ResultBuilder.createInfoResult("cluster configuration service is not running");
-    // action
-    ResultCollector<ConnectionConfiguration, List<ConnectionConfiguration[]>> resultCollector =
-        execute(new ListConnectionFunction(), targetMembers.iterator().next());
+    ConnectorService service =
+        ccService.getCustomCacheElement("cluster", "connector-service", ConnectorService.class);
+    if (service == null) {
+      return ResultBuilder.createInfoResult(EXPERIMENTAL + "\n" + NO_CONNECTIONS_FOUND);
+    }
-    boolean connectionsExist = fillTabularResultData(resultCollector, tabularResultData);
+    boolean connectionsExist = fillTabularResultData(service.getConnection(), tabularResultData);
-  ResultCollector<ConnectionConfiguration, List<ConnectionConfiguration[]>> execute(
-      ListConnectionFunction function, DistributedMember targetMember) {
-    return (ResultCollector<ConnectionConfiguration, List<ConnectionConfiguration[]>>) executeFunction(
-        function, null, targetMember);
-  }
-
-  private boolean fillTabularResultData(
-      ResultCollector<ConnectionConfiguration, List<ConnectionConfiguration[]>> resultCollector,
+  private boolean fillTabularResultData(List<ConnectorService.Connection> connections,
-    Set<ConnectionConfiguration> connectionConfigs = new HashSet<>();
-
-    for (Object resultObject : resultCollector.getResult()) {
-      if (resultObject instanceof ConnectionConfiguration[]) {
-        connectionConfigs.addAll(Arrays.asList((ConnectionConfiguration[]) resultObject));
-      } else if (resultObject instanceof Throwable) {
-        throw new IllegalStateException((Throwable) resultObject);
-      } else {
-        throw new IllegalStateException(resultObject.getClass().getName());
-      }
-    }
-
-    for (ConnectionConfiguration connectionConfig : connectionConfigs) {
+    for (ConnectorService.Connection connectionConfig : connections) {
-
-    return !connectionConfigs.isEmpty();
+    return !connections.isEmpty();

Merge branch 'release/1.8.0'

-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegionDataStore_CREATEBUCKETREGION_CREATING_BUCKETID_0_NAME_1,
-          new Object[] {this.partitionedRegion.bucketStringForLogs(bucketId), bucketRegionName}));
+      logger.info("createBucketRegion: Creating bucketId, {} name, {}.",
+          this.partitionedRegion.bucketStringForLogs(bucketId),
+          bucketRegionName);
-        logger.info(
-            LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegionDataStore_ASSERTION_ERROR_CREATING_BUCKET_IN_REGION),
+        logger.info("Assertion error creating bucket in region",
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionedRegionDataStore_EXCPETION__IN_BUCKET_INDEX_CREATION_,
-            ignor.getLocalizedMessage()), ignor);
+        logger.info(String.format("Excpetion  in bucket index creation : %s",
+            ignor.getLocalizedMessage()),
+            ignor);
-   * Querys the buckets in this data store for query specified by queryPredicate.
-   *
-   * @param parameters the parameters to be used to execute the query
-   * @param buckets to be queried
-   * @throws QueryException TODO-javadocs
-   */
-  /*
-   * public void queryLocalNode(DefaultQuery query, Object[] parameters, List buckets,
-   * PRQueryResultCollector resultCollector) throws QueryException, InterruptedException {
-   * Assert.assertTrue(!buckets.isEmpty(), "bucket list can not be empty. ");
-   * invokeBucketReadHook();
-   *
-   * // Check if QueryMonitor is enabled, if so add query to be monitored. QueryMonitor queryMonitor
-   * = null; if( GemFireCacheImpl.getInstance() != null) { queryMonitor =
-   * GemFireCacheImpl.getInstance().getQueryMonitor(); }
-   *
-   * try { if (queryMonitor != null) { // Add current thread to be monitored by QueryMonitor.
-   * queryMonitor.monitorQueryThread(Thread.currentThread(), query); } new PRQueryProcessor(this,
-   * query, parameters, buckets).executeQuery(resultCollector); } finally { if (queryMonitor !=
-   * null) { queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), query); } } }
-   */
-
-  /**
-
-
-    // Update stats
-
-    if (!this.partitionedRegion.isEntryEvictionPossible()) {
-      StringId logStr = null;
-      // only check for exceeding local max memory if we're not evicting entries.
-      // TODO, investigate precision issues with cast to long
-      if (!this.exceededLocalMaxMemoryLimit) { // previously OK
-        if (locBytes > this.maximumLocalBytes) { // not OK now
-          this.exceededLocalMaxMemoryLimit = true;
-          logStr =
-              LocalizedStrings.PartitionedRegionDataStore_PARTITIONED_REGION_0_HAS_EXCEEDED_LOCAL_MAXIMUM_MEMORY_CONFIGURATION_2_MB_CURRENT_SIZE_IS_3_MB;
-        }
-      } else {
-        if (locBytes <= this.maximumLocalBytes) {
-          this.exceededLocalMaxMemoryLimit = false;
-          logStr =
-              LocalizedStrings.PartitionedRegionDataStore_PARTITIONED_REGION_0_IS_AT_OR_BELOW_LOCAL_MAXIMUM_MEMORY_CONFIGURATION_2_MB_CURRENT_SIZE_IS_3_MB;
-        }
+    // only check for exceeding local max memory if we're not evicting entries.
+    if (this.partitionedRegion.isEntryEvictionPossible()) {
+      return;
+    }
+
+    if (this.exceededLocalMaxMemoryLimit) { // previously over limit
+      if (locBytes <= this.maximumLocalBytes) { // not over limit now
+        this.exceededLocalMaxMemoryLimit = false;
+        logger.info(
+            "Partitioned Region {} is at or below local maximum memory configuration {} Mb, current size is {} Mb",
+            this.partitionedRegion.getFullPath(),
+            this.partitionedRegion.getLocalMaxMemory(),
+            locBytes / PartitionedRegionHelper.BYTES_PER_MB);
-      if (logStr != null) {
-        Object[] logArgs = new Object[] {this.partitionedRegion.getFullPath(), logStr,
-            Long.valueOf(this.partitionedRegion.getLocalMaxMemory()),
-            Long.valueOf(locBytes / PartitionedRegionHelper.BYTES_PER_MB)};
-        if (this.exceededLocalMaxMemoryLimit) {
-          logger.warn(LocalizedMessage.create(logStr, logArgs));
-        } else {
-          logger.info(LocalizedMessage.create(logStr, logArgs));
-        }
+    } else { // previously not over limit
+      if (locBytes > this.maximumLocalBytes) { // over limit now
+        this.exceededLocalMaxMemoryLimit = true;
+        logger.warn(
+            "Partitioned Region {} has exceeded local maximum memory configuration {} Mb, current size is {} Mb",
+            this.partitionedRegion.getFullPath(),
+            this.partitionedRegion.getLocalMaxMemory(),
+            locBytes / PartitionedRegionHelper.BYTES_PER_MB);
-                LocalizedStrings.PartitionedRegionDataStore_REGION_HAS_BEEN_DESTROYED
-                    .toLocalizedString(),
+                "Region has been destroyed",
-      // stack trace when he had a perfectly good one already?
+      // stack trace when there was a perfectly good one already?
-                logger.warn(LocalizedMessage.create(
-                    LocalizedStrings.PartitionedRegion_PARTITIONEDREGION_0_CLEANUP_PROBLEM_DESTROYING_BUCKET_1,
-                    new Object[] {this.partitionedRegion.getFullPath(),
-                        Integer.valueOf(buk.getId())}),
+                logger.warn(
+                    String.format("PartitionedRegion %s: cleanUp problem destroying bucket %s",
+                        new Object[] {this.partitionedRegion.getFullPath(),
+                            Integer.valueOf(buk.getId())}),
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegionDataStore_PARTITIONEDREGION_0_CAUGHT_UNEXPECTED_EXCEPTION_DURING_CLEANUP,
-          this.partitionedRegion.getFullPath()), ex);
+      logger.warn(
+          String.format("PartitionedRegion %s: caught unexpected exception during data cleanup",
+              this.partitionedRegion.getFullPath()),
+          ex);
-   * itself to be the primary or if he doesn't host the bucket by sending a failure reply to REB. 2.
+   * itself to be the primary or if it doesn't host the bucket by sending a failure reply to REB. 2.
-      Lock writeLock = bucketAdvisor.getActiveWriteLock();
+      Lock primaryMoveReadLock = bucketAdvisor.getPrimaryMoveReadLock();
-      writeLock.lock();
+      primaryMoveReadLock.lock();
-        writeLock.unlock();
+        primaryMoveReadLock.unlock();
-          LocalizedStrings.PartitionedRegionDataStore_BUCKET_ID_0_NOT_FOUND_ON_VM_1
-              .toLocalizedString(
-                  new Object[] {this.partitionedRegion.bucketStringForLogs(bucketId.intValue()),
-                      this.partitionedRegion.getMyId()}));
+          String.format("Bucket id %s not found on VM %s",
+
+              new Object[] {this.partitionedRegion.bucketStringForLogs(bucketId.intValue()),
+                  this.partitionedRegion.getMyId()}));
-              LocalizedStrings.PartitionedRegionDataStore_UNABLE_TO_GET_VALUE_FOR_KEY
-                  .toLocalizedString(),
+              "Unable to get value for key.",
-          LocalizedStrings.PartitionedRegionDataStore_UNABLE_TO_SERIALIZE_VALUE.toLocalizedString(),
+          "Unable to serialize value",
-            LocalizedStrings.PartitionedRegionDataStore_ENTRY_NOT_FOUND.toLocalizedString());
+            "entry not found");
-              LocalizedStrings.PartitionedRegionDataStore_UNABLE_TO_GET_ENTRY.toLocalizedString(),
+              "Unable to get Entry.",
-              LocalizedStrings.PartitionedRegionDataStore_UNABLE_TO_FETCH_KEYS_ON_0
-                  .toLocalizedString(this.partitionedRegion.toString()),
+              String.format("Unable to fetch keys on %s",
+                  this.partitionedRegion.toString()),
-              LocalizedStrings.PartitionedRegionDataStore_UNABLE_TO_FETCH_KEYS_ON_0
-                  .toLocalizedString(this.partitionedRegion),
+              String.format("Unable to fetch keys on %s",
+                  this.partitionedRegion),
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionedRegionDataStore_VERIFIED_NODELIST_FOR_BUCKETID_0_IS_1,
-            new Object[] {partitionedRegion.bucketStringForLogs(buckId),
-                PartitionedRegionHelper.printCollection(owners)}));
+        logger.info("Verified nodelist for bucketId={} is {}",
+            partitionedRegion.bucketStringForLogs(buckId),
+            PartitionedRegionHelper.printCollection(owners));
-          LocalizedStrings.FunctionService_BUCKET_MIGRATED_TO_ANOTHER_NODE.toLocalizedString());
+          "Bucket migrated to another node. Please retry.");

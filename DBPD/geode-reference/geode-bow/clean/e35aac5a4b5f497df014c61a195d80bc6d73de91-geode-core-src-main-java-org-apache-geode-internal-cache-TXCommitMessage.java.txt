Merge branch 'release/1.5.0'

-import org.apache.geode.cache.CacheFactory;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
-  protected transient DM dm; // Used on the sending side of this message
+  protected transient DistributionManager dm; // Used on the sending side of this message
+  /**
+   * A token to be put in TXManagerImpl#failoverMap to represent a rolled back transaction
+   */
+  public static final TXCommitMessage ROLLBACK_MSG = new TXCommitMessage();
-  public TXCommitMessage(TXId txIdent, DM dm, TXState txState) {
+  public TXCommitMessage(TXId txIdent, DistributionManager dm, TXState txState) {
-  public static TXCommitMessage waitForMessage(Object id, DM dm) {
+  public static TXCommitMessage waitForMessage(Object id, DistributionManager dm) {
-  protected void process(DistributionManager dm) {
+  protected void process(ClusterDistributionManager dm) {
-      TXLockService.createDTLS(); // fix bug 38843; no-op if already created
+      TXLockService.createDTLS(this.dm.getSystem()); // fix bug 38843; no-op if already created
-        memberDeparted(getSender(), false /* don't care */);
+        memberDeparted(this.dm, getSender(), false /* don't care */);
-  public void setDM(DM dm) {
+  public void setDM(DistributionManager dm) {
-  public DM getDM() {
+  public DistributionManager getDM() {
-    final DM dm = this.dm;
+    final DistributionManager dm = this.dm;
-      if (!GemFireCacheImpl.getExisting("Applying TXCommitMessage").isClient()) {
+      if (!dm.getExistingCache().isClient()) {
-    boolean beginProcess(DM dm, TransactionId txIdent, TXRmtEvent txEvent)
+    boolean beginProcess(DistributionManager dm, TransactionId txIdent, TXRmtEvent txEvent)
-    private boolean hookupRegion(DM dm) {
-      this.r = LocalRegion.getRegionFromPath(dm.getSystem(), this.regionPath);
+    private boolean hookupRegion(DistributionManager dm) {
+      this.r = getRegionByPath(dm, regionPath);
-        this.r = LocalRegion.getRegionFromPath(dm.getSystem(), this.parentRegionPath);
+        this.r = getRegionByPath(dm, this.parentRegionPath);
+    LocalRegion getRegionByPath(DistributionManager dm, String regionPath) {
+      InternalCache cache = dm.getCache();
+      return cache == null ? null : (LocalRegion) cache.getRegionByPath(regionPath);
+    }
+
-    public boolean isForceFireEvent(DM dm) {
-      LocalRegion r = LocalRegion.getRegionFromPath(dm.getSystem(), this.regionPath);
+    public boolean isForceFireEvent(DistributionManager dm) {
+      LocalRegion r = getRegionByPath(dm, regionPath);
-          entryOp.fromData(in, largeModCount, !this.msg.getDM().isLoner());
+          entryOp.fromData(in, largeModCount, hasShadowKey(regionPath, parentRegionPath));
+    private boolean hasShadowKey(String regionPath, String parentRegionPath) {
+      // in bucket region, regionPath is bucket name, use parentRegionPath
+      String path = parentRegionPath != null ? parentRegionPath : regionPath;
+      LocalRegion region = getRegionByPath(msg.getDM(), path);
+
+      // default value is whether loner or not, region is null if destroyRegion executed
+      boolean readShadowKey = !msg.getDM().isLoner();
+      if (region != null) {
+        // shadowkey is not being sent to clients
+        readShadowKey = region.getPoolName() == null;
+      }
+      return readShadowKey;
+    }
+
-              this.value = CachedDeserializableFactory.create(DataSerializer.readByteArray(in));
+              this.value = CachedDeserializableFactory.create(DataSerializer.readByteArray(in),
+                  GemFireCacheImpl.getInstance());
-    protected void process(DistributionManager dm) {
+    protected void process(ClusterDistributionManager dm) {
-    protected void process(DistributionManager dm) {
+    protected void process(ClusterDistributionManager dm) {
-    protected void basicProcess(final TXCommitMessage mess, final DistributionManager dm) {
+    protected void basicProcess(final TXCommitMessage mess, final ClusterDistributionManager dm) {
-    protected void process(DistributionManager dm) {
+    protected void process(ClusterDistributionManager dm) {
-    CommitProcessQueryReplyProcessor(DM dm, Set members) {
+    CommitProcessQueryReplyProcessor(DistributionManager dm, Set members) {
-  public void memberJoined(InternalDistributedMember id) {
+  @Override
+  public void memberJoined(DistributionManager distributionManager, InternalDistributedMember id) {
-  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
-      String reason) {}
+  @Override
+  public void memberSuspect(DistributionManager distributionManager, InternalDistributedMember id,
+      InternalDistributedMember whoSuspected, String reason) {}
-  public void quorumLost(Set<InternalDistributedMember> failures,
-      List<InternalDistributedMember> remaining) {}
+  @Override
+  public void quorumLost(DistributionManager distributionManager,
+      Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
-  public void memberDeparted(final InternalDistributedMember id, boolean crashed) {
+  @Override
+  public void memberDeparted(DistributionManager distributionManager,
+      final InternalDistributedMember id, boolean crashed) {
-            e.handleAsUnexpected();
+            e.handleCause();
-      TXLockService.createDTLS().updateParticipants(this.lockId, this.msgMap.keySet());
+      TXLockService.createDTLS(this.dm.getSystem()).updateParticipants(this.lockId,
+          this.msgMap.keySet());
-    public CommitReplyProcessor(DM dm, Set initMembers, HashMap msgMap) {
+    public CommitReplyProcessor(DistributionManager dm, Set initMembers, HashMap msgMap) {
-  public void hookupRegions(DM dm) {
+  public void hookupRegions(DistributionManager dm) {

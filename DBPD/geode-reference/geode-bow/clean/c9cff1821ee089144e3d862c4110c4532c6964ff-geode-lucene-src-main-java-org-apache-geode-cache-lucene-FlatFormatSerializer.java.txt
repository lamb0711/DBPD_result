GEODE-3727: FlatFormatSerializer should support collection

This closes #933

- * contact.name, contact.homepage.title.
+ * contacts.name, contacts.homepage.title.
- * .addField("name").addField("contact.name").addField("contact.email", new KeywordAnalyzer())
- * .addField("contact.address").addField("contact.homepage.content") .create(INDEX_NAME,
+ * .addField("name").addField("contacts.name").addField("contacts.email", new KeywordAnalyzer())
+ * .addField("contacts.address").addField("contacts.homepage.content") .create(INDEX_NAME,
- * When querying, use the same dot-separated index field name, such as contact.homepage.content
+ * When querying, use the same dot-separated index field name, such as contacts.homepage.content
- * "contact.homepage.content:Hello*", "name"); results = query.findPages();
+ * "contacts.homepage.content:Hello*", "name");
+ * 
+ * results = query.findPages();
-   * name will be in the same format as its indexed, such as contact.homepage.content
+   * name will be in the same format as its indexed, such as contacts.homepage.content
+    if (fieldValue.getClass().isArray()) {
+      Object[] array = (Object[]) fieldValue;
+      for (Object item : array) {
+        addFieldValueForNonCollectionObject(doc, indexedFieldName, item, tokenizedFields);
+      }
+    } else if (fieldValue instanceof Collection) {
+      Collection collection = (Collection) fieldValue;
+      for (Object item : collection) {
+        addFieldValueForNonCollectionObject(doc, indexedFieldName, item, tokenizedFields);
+      }
+    } else {
+      addFieldValueForNonCollectionObject(doc, indexedFieldName, fieldValue, tokenizedFields);
+    }
+  }
+
+  private void addFieldValueForNonCollectionObject(Document doc, String indexedFieldName,
+      Object fieldValue, List<String> tokenizedFields) {

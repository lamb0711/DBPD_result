Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.internal.cache.EntryEventImpl.NewValueImporter;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl.OldValueImporter;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_BYTES;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_SERIALIZED_OBJECT;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_OBJECT;
-  {
+  implements NewValueImporter, OldValueImporter {
+  @Unretained(ENTRY_EVENT_NEW_VALUE) 
+  @Unretained(ENTRY_EVENT_OLD_VALUE) 
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedNewValue();
-      if (cd != null) {
-        {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-          Object v = cd.getValue();
-          if (v instanceof byte[]) {
-            setValBytes((byte[])v);
-          }
-          else {
-            // Defer serialization until toData is called.
-            setValObj(v);
-          }
-        }
+      if (CachedDeserializableFactory.preferObject() || event.hasDelta()) {
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER;
+      } else {
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-      else {
-        Object v = event.getRawNewValue();
-        if (v instanceof byte[]) {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
-          setValBytes((byte[]) v);
-        }
-        else if (event.hasDelta()) {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER;
-          if (event.getCachedSerializedNewValue() != null) {
-            setValBytes(event.getCachedSerializedNewValue());
-          } else {
-            setValObj(v);
-          }
-        }
-        else {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-          if (event.getCachedSerializedNewValue() != null) {
-            setValBytes(event.getCachedSerializedNewValue());
-          } else {
-            setValObj(v);
-          }
-        }
-      }
+      event.exportNewValue(this);
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedOldValue();
-      if (cd != null) {
-        {
-          this.oldValueIsSerialized = true;
-          Object o = cd.getValue();
-          if (o instanceof byte[]) {
-            setOldValBytes((byte[])o);
-          } else {
-            // Defer serialization until toData is called.
-            setOldValObj(o);
-          }
-        }
-      } else {
-        Object old = event.getRawOldValue();
-        if (old instanceof byte[]) {
-          this.oldValueIsSerialized = false;
-          setOldValBytes((byte[]) old);
-        } else {
-          this.oldValueIsSerialized = true;
-          setOldValObj(old);
-        }
-      }
+      event.exportOldValue(this);
-
+    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
+    
-  private void setValObj(Object o) {
+  private void setValObj(@Unretained(ENTRY_EVENT_NEW_VALUE) Object o) {
-  private void setOldValObj(Object o){
+  private void setOldValObj(@Unretained(ENTRY_EVENT_OLD_VALUE) Object o){
-      if (this.oldValueIsSerialized) {
-        DataSerializer.writeObjectAsByteArray(getOldValObj(), out);
-      }
-      else {
-        DataSerializer.writeByteArray(getOldValueBytes(), out);
-      }
+      byte policy = DistributedCacheOperation.valueIsToDeserializationPolicy(oldValueIsSerialized);
+      DistributedCacheOperation.writeValue(policy, getOldValObj(), getOldValueBytes(), out);
-    byte[] newValBytes = null;
-    if (this.valObj != null) {
-      newValBytes = BlobHelper.serializeToBlob(this.valObj);
-      this.event.setCachedSerializedNewValue(newValBytes);
-    }
-    else {
-      newValBytes = getValBytes();
-    }
-    if (this.deserializationPolicy == DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER) {
-      out.write(newValBytes);
-    } else {
-      DataSerializer.writeByteArray(newValBytes, out);
-    }
+    DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(), out);
-    this.event = new EntryEventImpl(
+    this.event = EntryEventImpl.create(
+    try {
-      Object oldValue = null;
-      if (this.requireOldValue) {
-        oldValue = event.getSerializedOldValue();
-        if (oldValue == null) {
-          oldValue = event.getRawOldValue();
-        }
-      }
-                oldValue,
+    } finally {
+      this.event.release(); // OFFHEAP this may be too soon to make this call
+    }
-                           Object oldValue,
-    PutReplyMessage.send(member, procId, getReplySender(dm), result, getOperation(), ex, oldValue, event);
+    PutReplyMessage.send(member, procId, getReplySender(dm), result,
+        getOperation(), ex, this, event);
+  // override reply message type from PartitionMessage
+  @Override
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm,
+      ReplyException ex, LocalRegion pr, long startTime) {
+    PutReplyMessage.send(member, procId, getReplySender(dm), result,
+        getOperation(), ex, this, null);
+  }
-  public static final class PutReplyMessage extends ReplyMessage {
+  public static final class PutReplyMessage extends ReplyMessage implements OldValueImporter {
+
+     * Set to true by the import methods if the oldValue
+     * is already serialized. In that case toData
+     * should just copy the bytes to the stream.
+     * In either case fromData just calls readObject.
+     */
+    private transient boolean oldValueIsSerialized;
+    
+    /**
-    Object oldValue;
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
+    private Object oldValue;
-    private PutReplyMessage(int processorId,
+    // unit tests may call this constructor
+    PutReplyMessage(int processorId,
-                            Object oldValue, EntryEventImpl event) {
+                            RemotePutMessage sourceMessage,
+                            EntryEventImpl event) {
-      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, oldValue, event.getVersionTag());
+      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, null, event != null ? event.getVersionTag() : null);
+      
+      if (sourceMessage.requireOldValue && event != null) {
+        event.exportOldValue(m);
+      }
+
-    /** Return oldValue in deserialized form */
+    /** Return oldValue as a byte[] or as a CachedDeserializable.
+     * This method used to deserialize a CachedDeserializable but that is too soon.
+     * This method is called during message processing. The deserialization needs
+     * to be deferred until we get back to the application thread which happens
+     * for this oldValue when they call EntryEventImpl.getOldValue.
+     */
-      if (this.oldValue instanceof CachedDeserializable) {
-        return ((CachedDeserializable)this.oldValue).getDeserializedValue(null, null);
-      }
-    @Override
+    public static void oldValueToData(DataOutput out, Object ov, boolean ovIsSerialized) throws IOException {
+      if (ovIsSerialized && ov != null) {
+        byte[] oldValueBytes;
+        if (ov instanceof byte[]) {
+          oldValueBytes = (byte[]) ov;
+          DataSerializer.writeObject(new VMCachedDeserializable(oldValueBytes), out);
+        } else if (ov instanceof CachedDeserializable) {
+          if (ov instanceof StoredObject) {
+            ((StoredObject) ov).sendAsCachedDeserializable(out);
+          } else {
+            DataSerializer.writeObject(ov, out);
+          }
+        } else {
+          oldValueBytes = EntryEventImpl.serialize(ov);
+          DataSerializer.writeObject(new VMCachedDeserializable(oldValueBytes), out);
+        }
+      } else {
+        DataSerializer.writeObject(ov, out);
+      }
+      
+    }
+    
+     @Override
-      DataSerializer.writeObject(this.oldValue, out);
+      oldValueToData(out, getOldValue(), this.oldValueIsSerialized);
+
+    @Override
+    public boolean prefersOldSerialized() {
+      return true;
+    }
+
+    @Override
+    public boolean isUnretainedOldReferenceOk() {
+      return true;
+    }
+    
+    @Override
+    public boolean isCachedDeserializableValueOk() {
+      return true;
+    }
+
+    @Override
+    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+      this.oldValueIsSerialized = isSerialized;
+      this.oldValue = ov;
+    }
+
+    @Override
+    public void importOldBytes(byte[] ov, boolean isSerialized) {
+      importOldObject(ov, isSerialized);
+    }
+
+  @Override
+  public boolean prefersNewSerialized() {
+    return true;
+  }
+
+  @Override
+  public boolean isUnretainedNewReferenceOk() {
+    return true;
+  }
+
+  private void setDeserializationPolicy(boolean isSerialized) {
+    if (!isSerialized) {
+      this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
+    }
+  }
+
+  @Override
+  public void importNewObject(@Unretained(ENTRY_EVENT_NEW_VALUE) Object nv, boolean isSerialized) {
+    setDeserializationPolicy(isSerialized);
+    setValObj(nv);
+  }
+
+  @Override
+  public void importNewBytes(byte[] nv, boolean isSerialized) {
+    setDeserializationPolicy(isSerialized);
+    setValBytes(nv);
+  }
+
+  @Override
+  public boolean prefersOldSerialized() {
+    return true;
+  }
+
+  @Override
+  public boolean isUnretainedOldReferenceOk() {
+    return true;
+  }
+
+  @Override
+  public boolean isCachedDeserializableValueOk() {
+    return false;
+  }
+  
+  private void setOldValueIsSerialized(boolean isSerialized) {
+    if (isSerialized) {
+      if (CachedDeserializableFactory.preferObject()) {
+        this.oldValueIsSerialized = true; //VALUE_IS_OBJECT;
+      } else {
+        // Defer serialization until toData is called.
+        this.oldValueIsSerialized = true; //VALUE_IS_SERIALIZED_OBJECT;
+      }
+    } else {
+      this.oldValueIsSerialized = false; //VALUE_IS_BYTES;
+    }
+  }
+  
+  public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+    setOldValueIsSerialized(isSerialized);
+    // Defer serialization until toData is called.
+    setOldValObj(ov);
+  }
+
+  @Override
+  public void importOldBytes(byte[] ov, boolean isSerialized) {
+    setOldValueIsSerialized(isSerialized);
+    setOldValBytes(ov);
+  }

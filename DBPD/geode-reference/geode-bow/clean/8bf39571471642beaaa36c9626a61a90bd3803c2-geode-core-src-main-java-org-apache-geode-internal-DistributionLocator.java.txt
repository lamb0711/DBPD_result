Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class is used to work with a managed VM that hosts a {@link
- * org.apache.geode.distributed.Locator}.
+ * This class is used to work with a managed VM that hosts a
+ * {@link org.apache.geode.distributed.Locator}.
-public class DistributionLocator  {
-  
+public class DistributionLocator {
+
-  public static final String TEST_OVERRIDE_DEFAULT_PORT_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "test.DistributionLocator.OVERRIDE_DEFAULT_PORT";
+  public static final String TEST_OVERRIDE_DEFAULT_PORT_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "test.DistributionLocator.OVERRIDE_DEFAULT_PORT";
-  
+
-        throw new IllegalArgumentException(LocalizedStrings.DistributionLocator_THE_PORT_ARGUMENT_MUST_BE_GREATER_THAN_0_AND_LESS_THAN_65536.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.DistributionLocator_THE_PORT_ARGUMENT_MUST_BE_GREATER_THAN_0_AND_LESS_THAN_65536
+                .toLocalizedString());
-    } catch ( ConnectException ignore ) {
+    } catch (ConnectException ignore) {
-  
+
-  
+
-      System.err.println(LocalizedStrings.DistributionLocator_USAGE.toLocalizedString() + ": port [bind-address] [peerLocator] [serverLocator] [hostname-for-clients]");
-      System.err.println(LocalizedStrings.DistributionLocator_A_ZEROLENGTH_ADDRESS_WILL_BIND_TO_LOCALHOST.toLocalizedString());
-      System.err.println(LocalizedStrings.DistributionLocator_A_ZEROLENGTH_GEMFIREPROPERTIESFILE_WILL_MEAN_USE_THE_DEFAULT_SEARCH_PATH.toLocalizedString());
-      System.err.println(LocalizedStrings.DistributionLocator_PEERLOCATOR_AND_SERVERLOCATOR_BOTH_DEFAULT_TO_TRUE.toLocalizedString());
-      System.err.println(LocalizedStrings.DistributionLocator_A_ZEROLENGTH_HOSTNAMEFORCLIENTS_WILL_DEFAULT_TO_BINDADDRESS.toLocalizedString());
+      System.err.println(LocalizedStrings.DistributionLocator_USAGE.toLocalizedString()
+          + ": port [bind-address] [peerLocator] [serverLocator] [hostname-for-clients]");
+      System.err
+          .println(LocalizedStrings.DistributionLocator_A_ZEROLENGTH_ADDRESS_WILL_BIND_TO_LOCALHOST
+              .toLocalizedString());
+      System.err.println(
+          LocalizedStrings.DistributionLocator_A_ZEROLENGTH_GEMFIREPROPERTIESFILE_WILL_MEAN_USE_THE_DEFAULT_SEARCH_PATH
+              .toLocalizedString());
+      System.err.println(
+          LocalizedStrings.DistributionLocator_PEERLOCATOR_AND_SERVERLOCATOR_BOTH_DEFAULT_TO_TRUE
+              .toLocalizedString());
+      System.err.println(
+          LocalizedStrings.DistributionLocator_A_ZEROLENGTH_HOSTNAMEFORCLIENTS_WILL_DEFAULT_TO_BINDADDRESS
+              .toLocalizedString());
-      SystemFailure.loadEmergencyClasses();
-      
-      //log.info(Banner.getString(args));
-      final int port = parsePort(args[0]);
-      InetAddress address = null;
-      boolean peerLocator  = true;
-      boolean serverLocator  = true;
-      String hostnameForClients = null;
-      try {
-        if (args.length > 1 && !args[1].equals("")) {
-          if (!SystemAdmin.validLocalAddress(args[1])) {
-            System.err.println(LocalizedStrings.DistributionLocator__0_IS_NOT_A_VALID_IP_ADDRESS_FOR_THIS_MACHINE.toLocalizedString(args[1]));
-            System.exit(1);
-          }
-          address = InetAddress.getByName(args[1]);
-        } else {
-//          address = null; // was InetAddress.getLocalHost(); (redundant assignment)
+    SystemFailure.loadEmergencyClasses();
+
+    // log.info(Banner.getString(args));
+    final int port = parsePort(args[0]);
+    InetAddress address = null;
+    boolean peerLocator = true;
+    boolean serverLocator = true;
+    String hostnameForClients = null;
+    try {
+      if (args.length > 1 && !args[1].equals("")) {
+        if (!SystemAdmin.validLocalAddress(args[1])) {
+          System.err.println(
+              LocalizedStrings.DistributionLocator__0_IS_NOT_A_VALID_IP_ADDRESS_FOR_THIS_MACHINE
+                  .toLocalizedString(args[1]));
+          System.exit(1);
-        if (args.length > 2) {
-          peerLocator = "true".equalsIgnoreCase(args[2]);
-        }
-        if (args.length > 3) {
-          serverLocator = "true".equalsIgnoreCase(args[3]);
-        }
-        if (args.length > 4) {
-          hostnameForClients = args[4];
-        }
-
-        if ( ! Boolean.getBoolean(InternalDistributedSystem.DISABLE_SHUTDOWN_HOOK_PROPERTY) ) {
-          final InetAddress faddress = address;
-          Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
-            public void run() {
-              try {
-                DistributionLocator.shutdown(port, faddress);
-              }
-              catch (IOException e) {
-                e.printStackTrace();
-              }
-            }
-          }));
-        }
-          
-        lockFile = ManagerInfo.setLocatorStarting(directory, port, address);
-        lockFile.deleteOnExit();
-
-        try {
-          
-          InternalLocator locator = InternalLocator
-            .startLocator(port,
-                          new File(DEFAULT_LOG_FILE),
-                          null,
-                          null,
-                          null,
-                          address,
-                          (Properties)null,
-                          peerLocator,
-                          serverLocator,
-                          hostnameForClients, LOAD_SHARED_CONFIGURATION);
-
-          ManagerInfo.setLocatorStarted(directory, port, address);
-          locator.waitToStop();
-
-        } finally {
-          shutdown(port, address);
-        }
-
-      } catch (InterruptedException ex) {
-        // We were interrupted while waiting for the locator to stop.
-        // No big deal.
-
-      } catch (java.net.BindException ex) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionLocator_COULD_NOT_BIND_LOCATOR_TO__0__1, new Object[] {address, Integer.valueOf(port)}));
-        System.exit(1);
-
-      } catch (Exception ex) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionLocator_COULD_NOT_START_LOCATOR), ex);
-        System.exit(1);
+        address = InetAddress.getByName(args[1]);
+      } else {
+        // address = null; // was InetAddress.getLocalHost(); (redundant assignment)
+      if (args.length > 2) {
+        peerLocator = "true".equalsIgnoreCase(args[2]);
+      }
+      if (args.length > 3) {
+        serverLocator = "true".equalsIgnoreCase(args[3]);
+      }
+      if (args.length > 4) {
+        hostnameForClients = args[4];
+      }
+
+      if (!Boolean.getBoolean(InternalDistributedSystem.DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
+        final InetAddress faddress = address;
+        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
+          public void run() {
+            try {
+              DistributionLocator.shutdown(port, faddress);
+            } catch (IOException e) {
+              e.printStackTrace();
+            }
+          }
+        }));
+      }
+
+      lockFile = ManagerInfo.setLocatorStarting(directory, port, address);
+      lockFile.deleteOnExit();
+
+      try {
+
+        InternalLocator locator = InternalLocator.startLocator(port, new File(DEFAULT_LOG_FILE),
+            null, null, null, address, (Properties) null, peerLocator, serverLocator,
+            hostnameForClients, LOAD_SHARED_CONFIGURATION);
+
+        ManagerInfo.setLocatorStarted(directory, port, address);
+        locator.waitToStop();
+
+      } finally {
+        shutdown(port, address);
+      }
+
+    } catch (InterruptedException ex) {
+      // We were interrupted while waiting for the locator to stop.
+      // No big deal.
+
+    } catch (java.net.BindException ex) {
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.DistributionLocator_COULD_NOT_BIND_LOCATOR_TO__0__1,
+          new Object[] {address, Integer.valueOf(port)}));
+      System.exit(1);
+
+    } catch (Exception ex) {
+      logger.fatal(
+          LocalizedMessage.create(LocalizedStrings.DistributionLocator_COULD_NOT_START_LOCATOR),
+          ex);
+      System.exit(1);
+    }
- 
+

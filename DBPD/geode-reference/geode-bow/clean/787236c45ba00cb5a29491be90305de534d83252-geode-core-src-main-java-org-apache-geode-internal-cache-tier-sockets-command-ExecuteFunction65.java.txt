GEODE-6143: Remove PowerMock from ExecuteFunction tests (#3045)

Remove PowerMock from:
* ExecuteFunctionTest
* ExecuteFunction65Test
* ExecuteFunction66Test

Add test for ExecuteFunction70Test by subclasses ExecuteFunction66Test.

Misc cleanup:
* Fixup logger statements and minor IDE warnings

+import org.apache.geode.annotations.TestingOnly;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.LowMemoryException;
-import org.apache.geode.cache.execute.FunctionService;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.internal.cache.execute.InternalFunctionExecutionService;
+import org.apache.geode.internal.cache.execute.InternalFunctionService;
-  ExecuteFunction65() {}
+  private final InternalFunctionExecutionService internalFunctionExecutionService;
+  private final ServerToClientFunctionResultSender65Factory serverToClientFunctionResultSender65Factory;
+  private final FunctionContextImplFactory functionContextImplFactory;
+
+  private ExecuteFunction65() {
+    this(InternalFunctionService.getInternalFunctionExecutionService(),
+        new DefaultServerToClientFunctionResultSender65Factory(),
+        new DefaultFunctionContextImplFactory());
+  }
+
+  @TestingOnly
+  ExecuteFunction65(InternalFunctionExecutionService internalFunctionExecutionService,
+      ServerToClientFunctionResultSender65Factory serverToClientFunctionResultSender65Factory,
+      FunctionContextImplFactory functionContextImplFactory) {
+    this.internalFunctionExecutionService = internalFunctionExecutionService;
+    this.serverToClientFunctionResultSender65Factory = serverToClientFunctionResultSender65Factory;
+    this.functionContextImplFactory = functionContextImplFactory;
+  }
+
-    } catch (ClassNotFoundException exception) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          exception);
+    } catch (ClassNotFoundException e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
-        writeChunkedException(clientMessage, exception, serverConnection);
+        writeChunkedException(clientMessage, e, serverConnection);
+
-      final String message =
-          "The input function for the execute function request is null";
+      String message = "The input function for the execute function request is null";
-      Function<?> functionObject = null;
+      Function<?> functionObject;
-        functionObject = FunctionService.getFunction((String) function);
+        functionObject = internalFunctionExecutionService.getFunction((String) function);
-          final String message =
-              String.format("Function named %s is not registered to FunctionService",
-                  function);
+          String message = String.format("Function named %s is not registered to FunctionService",
+              function);
-      ChunkedMessage m = serverConnection.getFunctionResponseMessage();
-      m.setTransactionId(clientMessage.getTransactionId());
-      ResultSender resultSender = new ServerToClientFunctionResultSender65(m,
+      ChunkedMessage chunkedMessage = serverConnection.getFunctionResponseMessage();
+      chunkedMessage.setTransactionId(clientMessage.getTransactionId());
+      ResultSender resultSender = serverToClientFunctionResultSender65Factory.create(chunkedMessage,
-      FunctionContext context = null;
+      FunctionContext context;
-        context = new FunctionContextImpl(cache, functionObject.getId(),
+        context = functionContextImplFactory.create(cache, functionObject.getId(),
-        context =
-            new FunctionContextImpl(cache, functionObject.getId(), args, resultSender, isReexecute);
+        context = functionContextImplFactory.create(cache, functionObject.getId(), args,
+            resultSender, isReexecute);
+
-        Exception e = cache.getInternalResourceManager().getHeapMonitor()
+        cache.getInternalResourceManager().getHeapMonitor().createLowMemoryIfNeeded(null,
+            (DistributedMember) null);
+
+        LowMemoryException lowMemoryException = cache.getInternalResourceManager().getHeapMonitor()
-        if (e != null) {
-          sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+        if (lowMemoryException != null) {
+          sendException(hasResult, clientMessage, lowMemoryException.getMessage(), serverConnection,
+              lowMemoryException);
-          throw new FunctionException(
-              String.format("The function, %s, did not send last result",
-                  functionObject.getId()));
+          throw new FunctionException(String.format("The function, %s, did not send last result",
+              functionObject.getId()));
-      } catch (FunctionException functionException) {
+      } catch (FunctionException e) {
-
-        throw functionException;
-      } catch (Exception exception) {
+        throw e;
+      } catch (Exception e) {
-        throw new FunctionException(exception);
+        throw new FunctionException(e);
-    } catch (IOException ioException) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          ioException);
-      String message =
-          "Server could not send the reply";
-      sendException(hasResult, clientMessage, message, serverConnection, ioException);
-    } catch (InternalFunctionInvocationTargetException internalfunctionException) {
-      // Fix for #44709: User should not be aware of
-      // InternalFunctionInvocationTargetException. No instance of
-      // InternalFunctionInvocationTargetException is giving useful
-      // information to user to take any corrective action hence logging
-      // this at fine level logging
-      // 1> In case of HA FucntionInvocationTargetException thrown. Since
-      // it is HA, function will be reexecuted on right node
-      // 2> in case of HA member departed
-      if (logger.isDebugEnabled()) {
-        logger.debug(String.format("Exception on server while executing function: %s",
-            new Object[] {function}),
-            internalfunctionException);
-      }
-      final String message = internalfunctionException.getMessage();
-      sendException(hasResult, clientMessage, message, serverConnection, internalfunctionException);
-    } catch (Exception e) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          e);
-      final String message = e.getMessage();
+
+    } catch (IOException e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
+      String message = "Server could not send the reply";
+
+    } catch (InternalFunctionInvocationTargetException e) {
+      /*
+       * TRAC #44709: InternalFunctionInvocationTargetException should not be logged
+       * Fix for #44709: User should not be aware of InternalFunctionInvocationTargetException. No
+       * instance is giving useful information to user to take any corrective action hence logging
+       * this at fine level logging. May occur when:
+       * 1> In case of HA FunctionInvocationTargetException thrown. Since it is HA, function will
+       * be re-executed on right node
+       * 2> in case of HA member departed
+       */
+      if (logger.isDebugEnabled()) {
+        logger.debug("Exception on server while executing function: {}", function, e);
+      }
+      sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+
+    } catch (Exception e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
+      sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+  interface ServerToClientFunctionResultSender65Factory {
+    ServerToClientFunctionResultSender65 create(ChunkedMessage msg, int messageType,
+        ServerConnection sc, Function function, ExecuteFunctionOperationContext authzContext);
+  }
+
+  interface FunctionContextImplFactory {
+    FunctionContextImpl create(Cache cache, String functionId, Object args,
+        ResultSender resultSender, boolean isPossibleDuplicate);
+  }
+
+  private static class DefaultServerToClientFunctionResultSender65Factory
+      implements ServerToClientFunctionResultSender65Factory {
+    @Override
+    public ServerToClientFunctionResultSender65 create(ChunkedMessage msg, int messageType,
+        ServerConnection sc, Function function, ExecuteFunctionOperationContext authzContext) {
+      return new ServerToClientFunctionResultSender65(msg, messageType, sc, function, authzContext);
+    }
+  }
+
+  private static class DefaultFunctionContextImplFactory implements FunctionContextImplFactory {
+    @Override
+    public FunctionContextImpl create(Cache cache, String functionId, Object args,
+        ResultSender resultSender, boolean isPossibleDuplicat) {
+      return new FunctionContextImpl(cache, functionId, args, resultSender, isPossibleDuplicat);
+    }
+  }

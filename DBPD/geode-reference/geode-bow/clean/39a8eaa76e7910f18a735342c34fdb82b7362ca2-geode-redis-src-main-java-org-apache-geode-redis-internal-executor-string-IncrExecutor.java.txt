GEODE-7886 Update strings tests to cover sad as well as happy paths (#4821)


Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.redis.internal.RedisConstants;
-
-  private final String ERROR_VALUE_NOT_USABLE =
-      "The value at this key cannot be incremented numerically";
-
-  private final String ERROR_OVERFLOW = "This incrementation cannot be performed due to overflow";
+  private final String ERROR_OVERFLOW = "value is not an integer or out of range";
+    long value;
-    Region<ByteArrayWrapper, ByteArrayWrapper> r = context.getRegionProvider().getStringsRegion();
-    if (commandElems.size() < 2) {
+    if (commandElems.size() != 2) {
+    Region<ByteArrayWrapper, ByteArrayWrapper> region =
+        context.getRegionProvider().getStringsRegion();
+
-    ByteArrayWrapper valueWrapper = r.get(key);
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      ByteArrayWrapper valueWrapper = region.get(key);
-    /*
-     * Value does not exist
-     */
+      /*
+       * Value does not exist
+       */
-    if (valueWrapper == null) {
-      byte[] newValue = {Coder.NUMBER_1_BYTE};
-      r.put(key, new ByteArrayWrapper(newValue));
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
-      return;
-    }
+      if (valueWrapper == null) {
+        byte[] newValue = {Coder.NUMBER_1_BYTE};
+        region.put(key, new ByteArrayWrapper(newValue));
+        command
+            .setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
+        return;
+      }
-    /*
-     * Value exists
-     */
+      /*
+       * Value exists
+       */
-    String stringValue = valueWrapper.toString();
+      String stringValue = valueWrapper.toString();
-    long value;
-    try {
-      value = Long.parseLong(stringValue);
-    } catch (NumberFormatException e) {
+      try {
+        value = Long.parseLong(stringValue);
+      } catch (NumberFormatException e) {
+        command.setResponse(
+            Coder.getErrorResponse(context.getByteBufAllocator(), RedisConstants.ERROR_WRONG_TYPE));
+        return;
+      }
+
+      if (value == Long.MAX_VALUE) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
+        return;
+      }
+
+      value++;
+
+      stringValue = "" + value;
+      region.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
-          Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
-
-    if (value == Long.MAX_VALUE) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
-      return;
-    }
-
-    value++;
-
-    stringValue = "" + value;
-    r.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
-
-
-

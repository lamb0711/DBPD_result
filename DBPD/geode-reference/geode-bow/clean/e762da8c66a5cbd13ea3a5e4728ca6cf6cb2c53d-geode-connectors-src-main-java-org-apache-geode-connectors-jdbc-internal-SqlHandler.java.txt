GEODE-6291: change create mapping to define column and pdx field information  (#3155)

Create mapping now requires that the pdx class exists on the server.
It generates a FieldMapping definition for each column/field. It will load the pdx class and
generate a pdx type for it, failing if it can not do so.
If the pdx type field count does not match the table column count then it will fail.
The pdx field names can differ in case from the column names as long as only one field matches the column.

Authored-by: Benjamin Ross <bross@pivotal.io>
Authored-by: Darrel Schneider <dschneider@pivotal.io>

-import java.sql.Types;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;
-  private final JdbcConnectorService configService;
+  private final InternalCache cache;
-  private final DataSourceFactory dataSourceFactory;
+  private final RegionMapping regionMapping;
+  private final DataSource dataSource;
+  private final Map<String, FieldMapping> pdxToFieldMappings = new HashMap<>();
+  private final Map<String, FieldMapping> jdbcToFieldMappings = new HashMap<>();
+  private volatile SqlToPdxInstance sqlToPdxInstance;
-  public SqlHandler(TableMetaDataManager tableMetaDataManager, JdbcConnectorService configService,
+  public SqlHandler(InternalCache cache, String regionName,
+      TableMetaDataManager tableMetaDataManager, JdbcConnectorService configService,
+    this.cache = cache;
-    this.configService = configService;
-    this.dataSourceFactory = dataSourceFactory;
+    this.regionMapping = getMappingForRegion(configService, regionName);
+    this.dataSource = getDataSource(dataSourceFactory, this.regionMapping.getDataSourceName());
+    initializeFieldMappingMaps();
-  public SqlHandler(TableMetaDataManager tableMetaDataManager, JdbcConnectorService configService) {
-    this(tableMetaDataManager, configService,
+  public SqlHandler(InternalCache cache, String regionName,
+      TableMetaDataManager tableMetaDataManager, JdbcConnectorService configService) {
+    this(cache, regionName, tableMetaDataManager, configService,
-  Connection getConnection(String dataSourceName) throws SQLException {
-    return getDataSource(dataSourceName).getConnection();
+  private static RegionMapping getMappingForRegion(JdbcConnectorService configService,
+      String regionName) {
+    RegionMapping regionMapping = configService.getMappingForRegion(regionName);
+    if (regionMapping == null) {
+      throw new JdbcConnectorException("JDBC mapping for region " + regionName
+          + " not found. Create the mapping with the gfsh command 'create jdbc-mapping'.");
+    }
+    return regionMapping;
-  DataSource getDataSource(String dataSourceName) {
-    DataSource dataSource = this.dataSourceFactory.getDataSource(dataSourceName);
+  private static DataSource getDataSource(DataSourceFactory dataSourceFactory,
+      String dataSourceName) {
+    DataSource dataSource = dataSourceFactory.getDataSource(dataSourceName);
+  private void initializeFieldMappingMaps() {
+    for (FieldMapping fieldMapping : regionMapping.getFieldMappings()) {
+      this.jdbcToFieldMappings.put(fieldMapping.getJdbcName(), fieldMapping);
+      if (!fieldMapping.getPdxName().isEmpty()) {
+        this.pdxToFieldMappings.put(fieldMapping.getPdxName(), fieldMapping);
+      }
+    }
+  }
+
+  private String getColumnNameForField(String fieldName) {
+    FieldMapping exactMatch = this.pdxToFieldMappings.get(fieldName);
+    if (exactMatch != null) {
+      return exactMatch.getJdbcName();
+    }
+    exactMatch = this.jdbcToFieldMappings.get(fieldName);
+    if (exactMatch != null) {
+      this.pdxToFieldMappings.put(fieldName, exactMatch);
+      return exactMatch.getJdbcName();
+    }
+    FieldMapping inexactMatch = null;
+    for (FieldMapping fieldMapping : regionMapping.getFieldMappings()) {
+      if (fieldMapping.getJdbcName().equalsIgnoreCase(fieldName)) {
+        if (inexactMatch != null) {
+          throw new JdbcConnectorException(
+              "Multiple columns matched the pdx field \"" + fieldName + "\".");
+        }
+        inexactMatch = fieldMapping;
+      }
+    }
+    if (inexactMatch == null) {
+      throw new JdbcConnectorException("No column matched the pdx field \"" + fieldName + "\".");
+    }
+    this.pdxToFieldMappings.put(fieldName, inexactMatch);
+    return inexactMatch.getJdbcName();
+  }
+
+  Connection getConnection() throws SQLException {
+    return this.dataSource.getConnection();
+  }
+
-    RegionMapping regionMapping = getMappingForRegion(region.getName());
-    try (Connection connection = getConnection(regionMapping.getDataSourceName())) {
+    try (Connection connection = getConnection()) {
-          getEntryColumnData(tableMetaData, regionMapping, key, null, Operation.GET);
+          getEntryColumnData(tableMetaData, key, null, Operation.GET);
-          InternalCache cache = (InternalCache) region.getRegionService();
-          SqlToPdxInstanceCreator sqlToPdxInstanceCreator =
-              new SqlToPdxInstanceCreator(cache, regionMapping, resultSet, tableMetaData);
-          result = sqlToPdxInstanceCreator.create();
+          result = getSqlToPdxInstance().create(resultSet);
+  private SqlToPdxInstance getSqlToPdxInstance() {
+    SqlToPdxInstance result = this.sqlToPdxInstance;
+    if (result == null) {
+      result = initializeSqlToPdxInstance();
+    }
+    return result;
+  }
+
+  private synchronized SqlToPdxInstance initializeSqlToPdxInstance() {
+    SqlToPdxInstanceCreator sqlToPdxInstanceCreator =
+        new SqlToPdxInstanceCreator(cache, regionMapping);
+    SqlToPdxInstance result = sqlToPdxInstanceCreator.create();
+    this.sqlToPdxInstance = result;
+    return result;
+  }
+
-  private RegionMapping getMappingForRegion(String regionName) {
-    RegionMapping regionMapping =
-        this.configService.getMappingForRegion(regionName);
-    if (regionMapping == null) {
-      throw new JdbcConnectorException("JDBC mapping for region " + regionName
-          + " not found. Create the mapping with the gfsh command 'create jdbc-mapping'.");
-    }
-    return regionMapping;
-  }
-
-        case Types.DATE:
+        case DATE:
-        case Types.TIME:
-        case Types.TIME_WITH_TIMEZONE:
+        case TIME:
+        case TIME_WITH_TIMEZONE:
-        case Types.TIMESTAMP:
-        case Types.TIMESTAMP_WITH_TIMEZONE:
+        case TIMESTAMP:
+        case TIMESTAMP_WITH_TIMEZONE:
-      statement.setNull(index, columnData.getDataType());
+      statement.setNull(index, columnData.getDataType().getVendorTypeNumber());
-    RegionMapping regionMapping = getMappingForRegion(region.getName());
-    try (Connection connection = getConnection(regionMapping.getDataSourceName())) {
+    try (Connection connection = getConnection()) {
-          getEntryColumnData(tableMetaData, regionMapping, key, value, operation);
+          getEntryColumnData(tableMetaData, key, value, operation);
-      RegionMapping regionMapping, K key, PdxInstance value, Operation operation) {
-    List<ColumnData> keyColumnData = createKeyColumnDataList(tableMetaData, regionMapping, key);
+      K key, PdxInstance value, Operation operation) {
+    List<ColumnData> keyColumnData = createKeyColumnDataList(tableMetaData, key);
-      valueColumnData = createValueColumnDataList(tableMetaData, regionMapping, value);
+      valueColumnData = createValueColumnDataList(tableMetaData, value);
-  private <K> List<ColumnData> createKeyColumnDataList(TableMetaDataView tableMetaData,
-      RegionMapping regionMapping, K key) {
+  private <K> List<ColumnData> createKeyColumnDataList(TableMetaDataView tableMetaData, K key) {
-        String columnName = regionMapping.getColumnNameForField(fieldName, tableMetaData);
+        String columnName = getColumnNameForField(fieldName);
-      RegionMapping regionMapping, PdxInstance value) {
+      PdxInstance value) {
-      String columnName = regionMapping.getColumnNameForField(fieldName, tableMetaData);
+      String columnName = getColumnNameForField(fieldName);

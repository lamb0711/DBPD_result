Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.Map.Entry;
-import com.gemstone.gemfire.cache.client.internal.BridgePoolImpl;
-import com.gemstone.gemfire.cache.util.BridgeServer;
-import com.gemstone.gemfire.internal.cache.BridgeServerImpl;
+import com.gemstone.gemfire.cache.hdfs.HDFSStoreFactory;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSIntegrationUtil;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSStoreCreation;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSStoreFactoryImpl;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSStoreImpl;
+import com.gemstone.gemfire.internal.cache.CacheServerImpl;
+import com.gemstone.gemfire.internal.cache.CacheService;
-public class CacheCreation implements InternalCache, Extensible<Cache> {
+public class CacheCreation implements InternalCache {
+  protected final Map hdfsStores = new LinkedHashMap();
+  
+  /** clear thread locals that may have been set by previous uses of CacheCreation */
+  public static void clearThreadLocals() {
+    createInProgress = new ThreadLocal<>();
+  }
-  private static final ThreadLocal createInProgress = new ThreadLocal();
+  private static ThreadLocal createInProgress = new ThreadLocal();
-    
+
+    for(Iterator iter = this.hdfsStores.entrySet().iterator(); iter.hasNext(); ) {
+      Entry entry = (Entry) iter.next();
+      HDFSStoreCreation hdfsStoreCreation = (HDFSStoreCreation) entry.getValue();
+      HDFSStoreFactory storefactory = cache.createHDFSStoreFactory(hdfsStoreCreation);
+      storefactory.create((String) entry.getKey());
+    }
+
+      // TODO: HDFS: HDFS store/queue will be mapped against region path and not
+      // the attribute id; don't really understand what this is trying to do
+      if (creation.getHDFSStoreName() != null)
+      {
+        HDFSStoreImpl store = cache.findHDFSStore(creation.getHDFSStoreName());
+        if(store == null) {
+          HDFSIntegrationUtil.createDefaultAsyncQueueForHDFS((Cache)cache, creation.getHDFSWriteOnly(), id);
+        }
+      }
+      if (creation.getHDFSStoreName() != null && creation.getPartitionAttributes().getColocatedWith() == null) {
+        creation.addAsyncEventQueueId(HDFSStoreFactoryImpl.getEventQueueName(id));
+      }
+      
-    Iterator it = this.roots.values().iterator();
-    while (it.hasNext()) {
-      RegionCreation r = (RegionCreation)it.next();
-      r.createRoot(cache);
-    }
+    initializeRegions(this.roots, cache);
+    startCacheServers(this.getCacheServers(), cache, serverPort, serverBindAdd, disableDefaultServer);
+    cache.setBackupFiles(this.backups);
+    cache.addDeclarableProperties(this.declarablePropertiesMap);
+    runInitializer();
+    cache.setInitializer(getInitializer(), getInitializerProps());
-    if (this.getCacheServers().size() > 1
+    // UnitTest CacheXml81Test.testCacheExtension
+    // Create all extensions
+    extensionPoint.fireCreate(cache);
+  }
+
+  protected void initializeRegions(Map declarativeRegions, Cache cache) {
+    Iterator it = declarativeRegions.values().iterator();
+    while (it.hasNext()) {
+      RegionCreation r = (RegionCreation)it.next();
+      r.createRoot(cache);
+    }
+  }
+
+  /**
+   * starts declarative cache servers if a server is not running on the port already.
+   * Also adds a default server to the param declarativeCacheServers if a serverPort is specified.
+   */
+  protected void startCacheServers(List declarativeCacheServers, Cache cache, Integer serverPort, String serverBindAdd, Boolean disableDefaultServer) {
+
+    if (declarativeCacheServers.size() > 1
-    
-    if (this.getCacheServers().isEmpty()
+
+    if (declarativeCacheServers.isEmpty()
-      
+
-          if (serverPort == cacheServer.getPort() && cacheServer.getBindAddress().equals(serverBindAdd)) {
+          if (serverPort == cacheServer.getPort()) {
-        this.getCacheServers().add(new BridgeServerCreation(cache, false));
+        declarativeCacheServers.add(new CacheServerCreation((GemFireCacheImpl)cache, false));
-    for (Iterator iter = this.getCacheServers().iterator(); iter.hasNext();) {
-      BridgeServerCreation bridge = (BridgeServerCreation)iter.next();
-      
-      BridgeServerImpl impl = (BridgeServerImpl)cache.addCacheServer();
-      impl.configureFrom(bridge);
+    for (Iterator iter = declarativeCacheServers.iterator(); iter.hasNext();) {
+      CacheServerCreation declaredCacheServer = (CacheServerCreation)iter.next();
+
+      boolean startServer = true;
+      List<CacheServer> cacheServers = cache.getCacheServers();
+      if (cacheServers != null) {
+        for (CacheServer cacheServer : cacheServers) {
+          if (declaredCacheServer.getPort() == cacheServer.getPort()) {
+            startServer = false;
+          }
+        }
+      }
+
+      if (!startServer) {
+        continue;
+      }
+
+      CacheServerImpl impl = (CacheServerImpl)cache.addCacheServer();
+      impl.configureFrom(declaredCacheServer);
-            LocalizedStrings.CacheCreation_WHILE_STARTING_BRIDGE_SERVER_0
+            LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0
-    cache.setBackupFiles(this.backups);
-    cache.addDeclarableProperties(this.declarablePropertiesMap);
-    runInitializer();
-    cache.setInitializer(getInitializer(), getInitializerProps());
-    
-    // UnitTest CacheXml81Test.testCacheExtension
-    // Create all extensions
-    extensionPoint.fireCreate(cache);
-        if (!RegionAttributesCreation.equal(drc1.getDiskDir(), drc2.getDiskDir())) {
-          return false;
-        }
-        if (!RegionAttributesCreation.equal(drc1.getBridgeWriter(), drc2.getBridgeWriter())) {
+        if (!drc1.equals(drc2)) {
-        throw new RuntimeException(LocalizedStrings.CacheCreation_BRIDGESERVERS_SIZE.toLocalizedString());
+        throw new RuntimeException(LocalizedStrings.CacheCreation_CACHESERVERS_SIZE.toLocalizedString());
-        BridgeServerCreation myBridge =
-          (BridgeServerCreation) myIter.next();
+        CacheServerCreation myBridge =
+          (CacheServerCreation) myIter.next();
-          throw new RuntimeException(LocalizedStrings.CacheCreation_BRIDGE_0_NOT_FOUND.toLocalizedString(myBridge));
+          throw new RuntimeException(LocalizedStrings.CacheCreation_CACHE_SERVER_0_NOT_FOUND.toLocalizedString(myBridge));
-          // ignore any BridgePool instances
+          // ignore any gateway instances
-            if (cp instanceof BridgePoolImpl || ((PoolImpl)cp).isUsedByGateway()) {
+            if (((PoolImpl)cp).isUsedByGateway()) {
-          // ignore any BridgePool instances
+          // ignore any gateway instances
-            if (cp instanceof BridgePoolImpl || ((PoolImpl)cp).isUsedByGateway()) {
+            if (((PoolImpl)cp).isUsedByGateway()) {
-            // ignore any BridgePool instances
-            if (!(cp instanceof BridgePoolImpl) && !(cp).isUsedByGateway()) {
+            // ignore any gateway instances
+            if (!(cp).isUsedByGateway()) {
-  @SuppressWarnings("deprecation")
-  public BridgeServer addBridgeServer() {
-    return (BridgeServer)addCacheServer();
-  }
-  
-    CacheServer bridge = new BridgeServerCreation(this, false);
+    CacheServer bridge = new CacheServerCreation(this, false);
-  public List getBridgeServers() {
-    return getCacheServers();
-  }
+  @Override
+  public Collection<HDFSStoreImpl> getHDFSStores() {
+    return this.hdfsStores.values();
+  }
+
+  public void addHDFSStore(String name, HDFSStoreCreation hs) {
+    this.hdfsStores.put(name, hs);
+  }
+
-
+    
+
+  @Override
+  public <T extends CacheService> T getService(Class<T> clazz) {
+    throw new UnsupportedOperationException();
+  }

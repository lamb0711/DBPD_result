Merge remote-tracking branch 'origin/develop' into feature/GEODE-917

+  /* lock for making size and data changes atomically. */
+  private Object lock = new Object();
+
-    if (o == null) {
-      for (int i = 0; i < size; i++)
-        if (elementData[i] == null)
-          return i;
-    } else {
-      for (int i = 0; i < size; i++)
-        if (o.equals(elementData[i]))
-          return i;
+    synchronized (lock) {
+      if (o == null) {
+        for (int i = 0; i < size; i++)
+          if (elementData[i] == null)
+            return i;
+      } else {
+        for (int i = 0; i < size; i++)
+          if (o.equals(elementData[i]))
+            return i;
+      }
-    RangeCheck(index);
-    return elementData[index];
+    synchronized (lock) {
+      RangeCheck(index);
+      return elementData[index];
+    }
-    RangeCheck(index);
+    synchronized (lock) {
+      RangeCheck(index);
-    Object oldValue = (Object) elementData[index];
-    elementData[index] = element;
-    return oldValue;
+      Object oldValue = (Object) elementData[index];
+      elementData[index] = element;
+      return oldValue;
+    }
-  public synchronized boolean add(Object e) {
-    ensureCapacity(size + 1);
-    elementData[size] = e;
-    ++size;
+  public boolean add(Object e) {
+    synchronized (lock) {
+      ensureCapacity(size + 1);
+      elementData[size] = e;
+      ++size;
+    }
-  public synchronized boolean remove(Object o) {
+  public boolean remove(Object o) {
-    elementData = newArray;
-    --size;
+
+    synchronized (lock) {
+      elementData = newArray;
+      --size;
+    }
-    for (int i = 0; i < size; i++) {
-      elementData[i] = null;
+    synchronized (lock) {
+      for (int i = 0; i < size; i++) {
+        elementData[i] = null;
+      }
+      size = 0;
-    size = 0;
-  public synchronized boolean addAll(Collection c) {
+  public boolean addAll(Collection c) {
-    ensureCapacity(size + numNew);
-    System.arraycopy(a, 0, elementData, size, numNew);
-    size += numNew;
+    synchronized (lock) {
+      ensureCapacity(size + numNew);
+      System.arraycopy(a, 0, elementData, size, numNew);
+      size += numNew;
+    }
+    private Object[] elements;
+    private int len;
+
+    IndexArrayListIterator() {
+      synchronized (lock) {
+        elements = elementData;
+        len = size;
+      }
+    }
-      return current < size;
+      return current < len;
-        currentEntry = elementData[current++];
+        currentEntry = elements[current++];
-        // Following exception must never be thrown.
-        //throw new NoSuchElementException();
-        return null;
+        // We should not be coming here as element-data and
+        // size are updated atomically.
+        throw new NoSuchElementException();
+        //return null;

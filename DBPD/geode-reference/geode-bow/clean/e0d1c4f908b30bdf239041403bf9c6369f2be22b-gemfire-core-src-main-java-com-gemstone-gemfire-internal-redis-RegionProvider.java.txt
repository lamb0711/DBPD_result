Merge remote-tracking branch 'origin/develop' into feature/GEODE-77

+import java.util.Map.Entry;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import com.gemstone.gemfire.cache.RegionShortcut;
+import com.gemstone.gemfire.cache.query.QueryInvalidException;
+import com.gemstone.gemfire.cache.query.RegionNotFoundException;
-
-public class RegionCache implements Closeable {
+/**
+ * This class stands between {@link Executor} and {@link Cache#getRegion(String)}.
+ * This is needed because some keys for Redis represented as a {@link Region} in
+ * {@link GemFireRedisServer} come with additional state. Therefore getting, creating,
+ * or destroying a {@link Region} needs to be synchronized, which is done away with
+ * and abstracted by this class.
+ * 
+ * @author Vitaly Gavrilov
+ *
+ */
+public class RegionProvider implements Closeable {
-   * This is the {@link RedisDataType#REDIS_LIST} meta data {@link Region}. Here each list
-   * stores the index of the head and tail of the list
-   */
-  private final Region<String, Integer> listsMetaRegion;
-
-  /**
+  private final RegionShortcut defaultRegionType;
+  private final ConcurrentHashMap<String, Lock> locks;
+  private final LogWriter logger;
-  public RegionCache(Region<ByteArrayWrapper, ByteArrayWrapper> stringsRegion, Region<ByteArrayWrapper, HyperLogLogPlus> hLLRegion, Region<String, RedisDataType> redisMetaRegion, Region<String, Integer> listsMetaRegion, ConcurrentMap<ByteArrayWrapper, ScheduledFuture<?>> expirationsMap, ScheduledExecutorService expirationExecutor) {
-    if (stringsRegion == null || hLLRegion == null || redisMetaRegion == null || listsMetaRegion == null)
+  public RegionProvider(Region<ByteArrayWrapper, ByteArrayWrapper> stringsRegion, Region<ByteArrayWrapper, HyperLogLogPlus> hLLRegion, Region<String, RedisDataType> redisMetaRegion, ConcurrentMap<ByteArrayWrapper, ScheduledFuture<?>> expirationsMap, ScheduledExecutorService expirationExecutor, RegionShortcut defaultShortcut) {
+    if (stringsRegion == null || hLLRegion == null || redisMetaRegion == null)
-    this.listsMetaRegion = listsMetaRegion;
+    this.defaultRegionType = defaultShortcut;
+    this.locks = new ConcurrentHashMap<String, Lock>();
+    this.logger = this.cache.getLogger();
-    cancelKeyExpiration(key);
-    this.regions.remove(key);
+    Lock lock = this.locks.get(key.toString());
+    boolean locked = false;
+    try {
+      locked = lock.tryLock();
+      // If we cannot get the lock we ignore this remote event, this key has local event
+      // that started independently, ignore this event to prevent deadlock
+      if (locked) {
+        cancelKeyExpiration(key);
+        removeRegionState(key, type);
+      }
+    } finally {
+      if (locked) {
+        lock.unlock();
+      }
+    }
-    metaRemoveEntry(key);
+    Lock lock = this.locks.get(key.toString());
-      if (type == RedisDataType.REDIS_STRING) {
-        return this.stringsRegion.remove(key) != null;
-      } else if (type == RedisDataType.REDIS_HLL) {
-        return this.hLLRegion.remove(key) != null;
-      } else {
-        return destroyRegion(key, type);
+      if (lock != null)  {// Strings/hlls will not have locks
+        lock.lock();
-    } catch (Exception exc) {
-      return false;
+      metaRemoveEntry(key);
+      try {
+        if (type == RedisDataType.REDIS_STRING) {
+          return this.stringsRegion.remove(key) != null;
+        } else if (type == RedisDataType.REDIS_HLL) {
+          return this.hLLRegion.remove(key) != null;
+        } else {
+          return destroyRegion(key, type);
+        }
+      } catch (Exception exc) {
+        return false;
+      } finally {
+        if (cancelExpiration)
+          cancelKeyExpiration(key);
+        else
+          removeKeyExpiration(key);
+        if (lock != null)
+          this.locks.remove(key.toString());
+      }
-      if (cancelExpiration)
-        cancelKeyExpiration(key);
-      else
-        removeKeyExpiration(key);
+      if (lock != null) {
+        lock.unlock();
+      }
-  public Region<?, ?> createRemoteRegionLocally(ByteArrayWrapper key, RedisDataType type) {
-    return getOrCreateRegion0(key, type, null, false);
+  public void createRemoteRegionLocally(ByteArrayWrapper key, RedisDataType type) {
+    if (type == null || type == RedisDataType.REDIS_STRING || type == RedisDataType.REDIS_HLL)
+      return;
+    Region<?, ?> r = this.regions.get(key);
+    if (r != null)
+      return;
+    if (!this.regions.contains(key)) {
+      String stringKey = key.toString();
+      Lock lock = this.locks.get(stringKey);
+      if (lock == null) {
+        this.locks.putIfAbsent(stringKey, new ReentrantLock());
+        lock = this.locks.get(stringKey);
+      }
+      boolean locked = false;
+      try {
+        locked = lock.tryLock();
+        // If we cannot get the lock then this remote even may have been initialized
+        // independently on this machine, so if we wait on the lock it is more than
+        // likely we will deadlock just to do the same task, this even can be ignored
+        if (locked) {
+          r = cache.getRegion(key.toString());
+          if (type == RedisDataType.REDIS_LIST)
+            doInitializeList(key, r);
+          else if (type == RedisDataType.REDIS_SORTEDSET)
+            doInitializeSortedSet(key, r);
+          this.regions.put(key, r);
+        }
+      } finally {
+        if (locked) {
+          lock.unlock();
+        }
+      }
+    }
+    if (r != null && r.isDestroyed()) {
+      removeKey(key, type);
+      r = null;
+    }
-      synchronized (stringKey) { // This object will be interned across the vm
+      Lock lock = this.locks.get(stringKey);
+      if (lock == null) {
+        this.locks.putIfAbsent(stringKey, new ReentrantLock());
+        lock = this.locks.get(stringKey);
+      }
+
+      try {
+        lock.lock();
-            r = createRegionGlobally(stringKey);
-            if (addToMeta)
-              metaPut(key, type);
-            if (type == RedisDataType.REDIS_LIST)
-              doInitializeList(key, r.getFullPath());
-            else if (type == RedisDataType.REDIS_SORTEDSET)
-              doInitializeSortedSet(key, r);
-            this.regions.put(key, r);
+            Exception concurrentCreateDestroyException = null;
+            do {
+              concurrentCreateDestroyException = null;
+              r = createRegionGlobally(stringKey);
+              try {
+                if (type == RedisDataType.REDIS_LIST)
+                  doInitializeList(key, r);
+                else if (type == RedisDataType.REDIS_SORTEDSET)
+                  doInitializeSortedSet(key, r);
+              } catch (QueryInvalidException e) {
+                if (e.getCause() instanceof RegionNotFoundException) {
+                  concurrentCreateDestroyException = e;
+                }
+              }
+            } while(concurrentCreateDestroyException != null);
+            this.regions.put(key, r);            
+            if (addToMeta) {
+              RedisDataType existingType = metaPutIfAbsent(key, type);
+              if (existingType != null && existingType != type)
+                throw new RedisDataTypeMismatchException("The key name \"" + key + "\" is already used by a " + existingType.toString());
+            }
+      } finally {
+        lock.unlock();
+  /**
+   * SYNCHRONIZE EXTERNALLY OF this.locks.get(key.toString())!!!!!
+   * 
+   * @param key Key of region to destroy
+   * @param type Type of region to destroyu
+   * @return Flag if destroyed
+   */
-    String stringKey = key.toString();
-      synchronized (stringKey) { // This object will be interned across the vm
-        try {
-          r.destroyRegion();
-        } catch (Exception e) {
-          return false;
-        } finally {
-          this.preparedQueries.remove(key);
-          metaRemoveEntry(key);
-          if (type == RedisDataType.REDIS_LIST) {
-            this.listsMetaRegion.remove(stringKey + "head");
-            this.listsMetaRegion.remove(stringKey + "tail");
-          }
-          this.regions.remove(key);
-        }
+      try {
+        r.destroyRegion();
+      } catch (Exception e) {
+        return false;
+      } finally {
+        removeRegionState(key, type);
+  /**
+   * Do not call this method if you are not synchronized on the lock associated with this key
+   * 
+   * @param key Key of region to remove
+   * @param type Type of key to remove all state
+   */
+  private void removeRegionState(ByteArrayWrapper key, RedisDataType type) {
+    this.preparedQueries.remove(key);
+    this.regions.remove(key);
+  }
+
-      queryService.createIndex("scoreIndex", "value.score", r.getFullPath() + ".entrySet entry");
+      queryService.createIndex("scoreIndex", "entry.value.score", r.getFullPath() + ".entrySet entry");
-        LogWriter logger = cache.getLogger();
-  private void doInitializeList(ByteArrayWrapper key, String fullpath) {
-    listsMetaRegion.put(key + "head", Integer.valueOf(0));
-    listsMetaRegion.put(key + "tail", Integer.valueOf(0));
+  private void doInitializeList(ByteArrayWrapper key, Region r) {
+    r.put("head", Integer.valueOf(0));
+    r.put("tail", Integer.valueOf(0));
+    String fullpath = r.getFullPath();
-    Result result = cliCmds.createRegion(key, GemFireRedisServer.DEFAULT_REGION_TYPE, null, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
-    if (result.getStatus() == Status.ERROR && r == null) {
-      String err = "";
-      while(result.hasNextLine())
-        err += result.nextLine();
-      throw new RegionCreationException(err);
-    }
-    if (r == null)
-      throw new RegionCreationException();
+    if (r != null) return r;
+    do {
+      Result result = cliCmds.createRegion(key, defaultRegionType, null, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
+      r = cache.getRegion(key);
+      if (result.getStatus() == Status.ERROR && r == null) {
+        String err = "";
+        while(result.hasNextLine())
+          err += result.nextLine();
+        if (this.logger.errorEnabled()) {
+          this.logger.error("Region creation failure- "+ err);
+        }
+        throw new RegionCreationException(err);
+      }
+    } while(r == null); // The region can be null in the case that it is concurrently destroyed by
+    // a remote even triggered internally by Geode
+    /*
+    if (query instanceof ListQuery) {
+      return this.queryService.newQuery(((ListQuery)query).getQueryString(this.regions.get(key).getFullPath()));
+    } else {
+      return this.queryService.newQuery(((SortedSetQuery)query).getQueryString(this.regions.get(key).getFullPath()));
+    }
+    */
-  public Region<String, Integer> getListsMetaRegion() {
-    return this.listsMetaRegion;
-  }
-
-
+  public String dumpRegionsCache() {
+    StringBuilder builder = new StringBuilder();
+    for (Entry<ByteArrayWrapper, Region<?, ?>> e : this.regions.entrySet()) {
+      builder.append(e.getKey() + " --> {" + e.getValue() + "}\n");
+    }
+    return builder.toString();
+  }
+

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
-import org.apache.geode.distributed.DistributedLockService;
-/**
- */
-  // ///////////// All the final variable //////////////////
-  /** Name of allPartitionedRegions Region * */
-  // static final String PARTITIONED_REGION_CONFIG_NAME = "__Config";
-
-  /** Prefix for the bucket2Node Region name defined in the global space. */
-  // static final String BUCKET_2_NODE_TABLE_PREFIX = "_B2N_";
-
-
-
-      GemFireCacheImpl cache) {
+      InternalCache cache) {
-      GemFireCacheImpl cache, final boolean lock) {
+      InternalCache cache, final boolean lock) {
-    // Region allPartitionedRegions = PartitionedRegionHelper.getPRConfigRegion(
-    // root, cache);
-        // if (!rl.lock()) {
-        // return;
-        // }
-  public static LocalRegion getPRRoot(final Cache cache) {
+  public static LocalRegion getPRRoot(final InternalCache cache) {
-  public static LocalRegion getPRRoot(final Cache cache, boolean createIfAbsent) {
-    GemFireCacheImpl gemCache = (GemFireCacheImpl) cache;
-    DistributedRegion root = (DistributedRegion) gemCache.getRegion(PR_ROOT_REGION_NAME, true);
+  public static LocalRegion getPRRoot(final InternalCache cache, boolean createIfAbsent) {
+    DistributedRegion root = (DistributedRegion) cache.getRegion(PR_ROOT_REGION_NAME, true);
-        root = (DistributedRegion) gemCache.createVMRegion(PR_ROOT_REGION_NAME, ra,
+        root = (DistributedRegion) cache.createVMRegion(PR_ROOT_REGION_NAME, ra,
-      } catch (RegionExistsException silly) {
+      } catch (RegionExistsException ignore) {
-        root = (DistributedRegion) gemCache.getRegion(PR_ROOT_REGION_NAME, true);
+        root = (DistributedRegion) cache.getRegion(PR_ROOT_REGION_NAME, true);
-      final GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+      final InternalCache cache = GemFireCacheImpl.getInstance();
-        Collections.shuffle(ks, PartitionedRegion.rand);
+        Collections.shuffle(ks, PartitionedRegion.RANDOM);
-        } catch (CancelException e) {
+        } catch (CancelException ignore) {
-    } catch (CancelException e) {
+    } catch (CancelException ignore) {
-  public static void cleanUpMetaDataForRegion(final GemFireCacheImpl cache, final String prName,
+  public static void cleanUpMetaDataForRegion(final InternalCache cache, final String prName,
-      } catch (EntryDestroyedException ede) {
+      } catch (EntryDestroyedException ignore) {
-  private static void cleanPartitionedRegionMetaDataForNode(GemFireCacheImpl cache, Node node,
+  private static void cleanPartitionedRegionMetaDataForNode(InternalCache cache, Node node,
-   * @param cache
-    escaped = escaped.replace(LocalRegion.SEPARATOR_CHAR, '_');
+    escaped = escaped.replace(Region.SEPARATOR_CHAR, '_');
-  public static String TWO_SEPARATORS = LocalRegion.SEPARATOR + LocalRegion.SEPARATOR;
+  public static String TWO_SEPARATORS = Region.SEPARATOR + Region.SEPARATOR;
-    String path = escapedPath.replace('_', LocalRegion.SEPARATOR_CHAR);
+    String path = escapedPath.replace('_', Region.SEPARATOR_CHAR);
-   * This method returns true if the member is found in the membership list of this member, else
-   * false.
-   * 
-   * @param mem
-   * @param cache
-   * @return true if mem is found in membership list of this member.
-   */
-  public static boolean isMemberAlive(DistributedMember mem, GemFireCacheImpl cache) {
-    return getMembershipSet(cache).contains(mem);
-  }
-
-  /**
-   * Returns the current membership Set for this member.
-   * 
-   * @param cache
-   * @return membership Set.
-   */
-  public static Set getMembershipSet(GemFireCacheImpl cache) {
-    return cache.getInternalDistributedSystem().getDistributionManager()
-        .getDistributionManagerIds();
-  }
-
-  /**
-   * @param partitionedRegion
-        new Object[] {callingMethod, Integer.valueOf(bucketId)}));
+        new Object[] {callingMethod, bucketId}));
-   * @param c
-      StringBuffer sb = new StringBuffer("[");
+      StringBuilder sb = new StringBuilder("[");
-  /**
-   * Destroys and removes the distributed lock service. This is called from cache closure operation.
-   * 
-   * @see PartitionedRegion#afterRegionsClosedByCacheClose(GemFireCacheImpl)
-   */
-  static void destroyLockService() {
-    DistributedLockService dls = null;
-    synchronized (dlockMonitor) {
-      dls = DistributedLockService.getServiceNamed(PARTITION_LOCK_SERVICE_NAME);
-    }
-    if (dls != null) {
-      try {
-        DistributedLockService.destroy(PARTITION_LOCK_SERVICE_NAME);
-      } catch (IllegalArgumentException ex) {
-        // Our dlockService is already destroyed,
-        // probably by another thread - ignore
-      }
-    }
-  }
-
-  public static boolean isBucketPrimary(Bucket buk) {
-    return buk.getBucketAdvisor().isPrimary();
-  }
-
-  public static boolean isRemotePrimaryAvailable(PartitionedRegion region,
-      FixedPartitionAttributesImpl fpa) {
-    List<FixedPartitionAttributesImpl> fpaList = region.getRegionAdvisor().adviseSameFPAs(fpa);
-
-    for (FixedPartitionAttributes remotefpa : fpaList) {
-      if (remotefpa.isPrimary()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-    Object[] prms = new Object[] {pr.getName(), Integer.valueOf(bucketId)};
+    Object[] prms = new Object[] {pr.getName(), bucketId};
-}
+  static class FixedPartitionAttributesListener extends CacheListenerAdapter {
+    private static final Logger logger = LogService.getLogger();
-class FixedPartitionAttributesListener extends CacheListenerAdapter {
-  private static final Logger logger = LogService.getLogger();
-
-  public void afterCreate(EntryEvent event) {
-    PartitionRegionConfig prConfig = (PartitionRegionConfig) event.getNewValue();
-    if (!prConfig.getElderFPAs().isEmpty()) {
-      updatePartitionMap(prConfig);
-    }
-  }
-
-  public void afterUpdate(EntryEvent event) {
-    PartitionRegionConfig prConfig = (PartitionRegionConfig) event.getNewValue();
-    if (!prConfig.getElderFPAs().isEmpty()) {
-      updatePartitionMap(prConfig);
-    }
-  }
-
-  private void updatePartitionMap(PartitionRegionConfig prConfig) {
-    int prId = prConfig.getPRId();
-    PartitionedRegion pr = null;
-
-    try {
-      pr = PartitionedRegion.getPRFromId(prId);
-      if (pr != null) {
-        Map<String, Integer[]> partitionMap = pr.getPartitionsMap();
-        for (FixedPartitionAttributesImpl fxPrAttr : prConfig.getElderFPAs()) {
-          partitionMap.put(fxPrAttr.getPartitionName(),
-              new Integer[] {fxPrAttr.getStartingBucketID(), fxPrAttr.getNumBuckets()});
-        }
+    public void afterCreate(EntryEvent event) {
+      PartitionRegionConfig prConfig = (PartitionRegionConfig) event.getNewValue();
+      if (!prConfig.getElderFPAs().isEmpty()) {
+        updatePartitionMap(prConfig);
-    } catch (PRLocallyDestroyedException e) {
-      logger.debug("PRLocallyDestroyedException : Region ={} is locally destroyed on this node",
-          prConfig.getPRId(), e);
+    }
+
+    public void afterUpdate(EntryEvent event) {
+      PartitionRegionConfig prConfig = (PartitionRegionConfig) event.getNewValue();
+      if (!prConfig.getElderFPAs().isEmpty()) {
+        updatePartitionMap(prConfig);
+      }
+    }
+
+    private void updatePartitionMap(PartitionRegionConfig prConfig) {
+      int prId = prConfig.getPRId();
+      PartitionedRegion pr = null;
+
+      try {
+        pr = PartitionedRegion.getPRFromId(prId);
+        if (pr != null) {
+          Map<String, Integer[]> partitionMap = pr.getPartitionsMap();
+          for (FixedPartitionAttributesImpl fxPrAttr : prConfig.getElderFPAs()) {
+            partitionMap.put(fxPrAttr.getPartitionName(),
+                new Integer[] {fxPrAttr.getStartingBucketID(), fxPrAttr.getNumBuckets()});
+          }
+        }
+      } catch (PRLocallyDestroyedException e) {
+        logger.debug("PRLocallyDestroyedException : Region ={} is locally destroyed on this node",
+            prConfig.getPRId(), e);
+      }

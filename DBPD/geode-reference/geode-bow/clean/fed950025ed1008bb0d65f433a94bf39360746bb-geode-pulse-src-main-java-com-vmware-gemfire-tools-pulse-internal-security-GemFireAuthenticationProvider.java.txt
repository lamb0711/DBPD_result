GEODE-17: WIP integrating Pulse with new security

- After refactoring some Pulse test code, various tests are broken as
  they seem to depend on prior test state.

- * Spring security AuthenticationProvider for GemFire. It connects to 
- * gemfire manager using given credentials. Successful connect is treated
- * as successful authentication and web user is authenticated
+ * Spring security AuthenticationProvider for GemFire. It connects to gemfire manager using given credentials.
+ * Successful connect is treated as successful authentication and web user is authenticated
-	
-  private final static PulseLogWriter LOGGER = PulseLogWriter.getLogger();	
-	public GemFireAuthenticationProvider(){
-		System.out.println("here");
-	}
-	
-	@Override
-	public Authentication authenticate(Authentication authentication)
-			throws AuthenticationException {
-			  
-		if (authentication instanceof GemFireAuthentication) {
-			GemFireAuthentication gemAuth = (GemFireAuthentication) authentication;
-			LOGGER.fine("GemAuthentication is connected? = "
-					+ gemAuth.getJmxc());
-			if(gemAuth.getJmxc()!=null && gemAuth.isAuthenticated())
-				return gemAuth;
-		}
-		
-		String name = authentication.getName();
-		String password = authentication.getCredentials().toString();
+  private final static PulseLogWriter LOGGER = PulseLogWriter.getLogger();
-		try {
-		  LOGGER.fine("Connecting to GemFire with user=" + name);
-		  JMXConnector jmxc = Repository.get().getCluster().connectToGemFire(name, password);
-		  if(jmxc!=null) {
-  			Collection<GrantedAuthority> list = GemFireAuthentication.populateAuthorities(jmxc);
-  			GemFireAuthentication auth = new GemFireAuthentication(
-  					authentication.getPrincipal(),
-  					authentication.getCredentials(), list, jmxc);
-  			LOGGER.fine("For user " + name + " authList="+ list);
-  			return auth;
-		  } else 
-		    throw new AuthenticationServiceException("JMX Connection unavailable");
-		} catch (Exception e) {
-		  throw new BadCredentialsException("Error connecting to GemFire JMX Server", e);			
-		}
-	}
+  public GemFireAuthenticationProvider() {
+    System.out.println("here");
+  }
-	@Override
-	public boolean supports(Class<?> authentication) {
-		return authentication.equals(UsernamePasswordAuthenticationToken.class);
-	}	
+  @Override
+  public Authentication authenticate(Authentication authentication) throws AuthenticationException {
+
+    if (authentication instanceof GemFireAuthentication) {
+      GemFireAuthentication gemAuth = (GemFireAuthentication) authentication;
+      LOGGER.fine("GemAuthentication is connected? = " + gemAuth.getJmxc());
+      if (gemAuth.getJmxc() != null && gemAuth.isAuthenticated()) return gemAuth;
+    }
+
+    String name = authentication.getName();
+    String password = authentication.getCredentials().toString();
+
+    try {
+      LOGGER.fine("Connecting to GemFire with user=" + name);
+      JMXConnector jmxc = Repository.get().getCluster().connectToGemFire(name, password);
+      if (jmxc != null) {
+        Collection<GrantedAuthority> list = GemFireAuthentication.populateAuthorities(jmxc);
+        GemFireAuthentication auth = new GemFireAuthentication(authentication.getPrincipal(),
+            authentication.getCredentials(), list, jmxc);
+        LOGGER.fine("For user " + name + " authList=" + list);
+        return auth;
+      } else {
+        throw new AuthenticationServiceException("JMX Connection unavailable");
+      }
+    } catch (Exception e) {
+      throw new BadCredentialsException("Error connecting to GemFire JMX Server", e);
+    }
+  }
+
+  @Override
+  public boolean supports(Class<?> authentication) {
+    return authentication.equals(UsernamePasswordAuthenticationToken.class);
+  }

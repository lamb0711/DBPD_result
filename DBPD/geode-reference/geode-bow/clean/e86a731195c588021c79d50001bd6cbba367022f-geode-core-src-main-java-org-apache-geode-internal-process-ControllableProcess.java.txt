Merge branch 'release/1.3.0'

+import static org.apache.commons.lang.Validate.notNull;
+
+import java.io.UncheckedIOException;
- * Exists inside a process launched by ServerLauncher or LocatorLauncher. Creates the PID file and
- * ControlFileWatchdogs to monitor working directory for creation of stop or status request files.
+ * Creates the {@link PidFile} and uses {@link ControlFileWatchdog} to monitor the directory for
+ * creation of stop or status request files.
-  private final File workingDir;
-  private final File pidFile;
+  private final File directory;
-  public ControllableProcess(final ControlNotificationHandler handler, final File workingDir,
-      final ProcessType processType, boolean force)
+  public ControllableProcess(final ControlNotificationHandler handler, final File directory,
+      final ProcessType processType, final boolean force)
-    this.workingDir = workingDir;
-    this.pidFile = new File(this.workingDir, processType.getPidFileName());
+    this(directory, processType, force, createPidFile(directory, processType),
+        createStopHandler(handler), createStatusHandler(handler, directory, processType));
+  }
-    deleteFiles(this.workingDir, processType);
+  private ControllableProcess(final File directory, final ProcessType processType,
+      final boolean force, final File pidFile, final ControlRequestHandler stopHandler,
+      final ControlRequestHandler statusHandler)
+      throws FileAlreadyExistsException, IOException, PidUnavailableException {
+    this(directory, processType, createLocalProcessLauncher(pidFile, force),
+        createStopRequestFileWatchdog(directory, processType, stopHandler),
+        createStatusRequestFileWatchdog(directory, processType, statusHandler));
+  }
-    this.launcher = new LocalProcessLauncher(this.pidFile, force);
+  ControllableProcess(final File directory, final ProcessType processType,
+      final LocalProcessLauncher launcher, final ControlFileWatchdog stopRequestFileWatchdog,
+      final ControlFileWatchdog statusRequestFileWatchdog) {
+    notNull(directory, "Invalid directory '" + directory + "' specified");
+    notNull(processType, "Invalid processType '" + processType + "' specified");
+    notNull(launcher, "Invalid launcher '" + launcher + "' specified");
+    notNull(stopRequestFileWatchdog,
+        "Invalid stopRequestFileWatchdog '" + stopRequestFileWatchdog + "' specified");
+    notNull(statusRequestFileWatchdog,
+        "Invalid statusRequestFileWatchdog '" + statusRequestFileWatchdog + "' specified");
-    final ControlRequestHandler stopHandler = new ControlRequestHandler() {
-      @Override
-      public void handleRequest() {
-        handler.handleStop();
-      }
-    };
-    final ControlRequestHandler statusHandler = new ControlRequestHandler() {
-      @Override
-      public void handleRequest() throws IOException {
-        final ServiceState<?> state = handler.handleStatus();
-        final File statusFile = new File(workingDir, processType.getStatusFileName());
-        if (statusFile.exists()) {
-          statusFile.delete();
-        }
-        final File statusFileTmp = new File(workingDir, processType.getStatusFileName() + ".tmp");
-        if (statusFileTmp.exists()) {
-          statusFileTmp.delete();
-        }
-        boolean created = statusFileTmp.createNewFile();
-        assert created;
-        final FileWriter writer = new FileWriter(statusFileTmp);
-        writer.write(state.toJson());
-        writer.flush();
-        writer.close();
-        boolean renamed = statusFileTmp.renameTo(statusFile);
-        assert renamed;
-      }
-    };
+    this.directory = directory;
+    this.launcher = launcher;
+    this.stopRequestFileWatchdog = stopRequestFileWatchdog;
+    this.statusRequestFileWatchdog = statusRequestFileWatchdog;
-    this.stopRequestFileWatchdog = new ControlFileWatchdog(workingDir,
-        processType.getStopRequestFileName(), stopHandler, false);
-    this.stopRequestFileWatchdog.start();
-    this.statusRequestFileWatchdog = new ControlFileWatchdog(workingDir,
-        processType.getStatusRequestFileName(), statusHandler, false);
-    this.statusRequestFileWatchdog.start();
+    deleteFiles(directory, processType);
+    stopRequestFileWatchdog.start();
+    statusRequestFileWatchdog.start();
-    return this.launcher.getPid();
+    return launcher.getPid();
-    return this.launcher.getPidFile();
+    return launcher.getPidFile();
+  }
+
+  public File getDirectory() {
+    return directory;
+    boolean interrupted = false;
-      this.statusRequestFileWatchdog.stop();
-    } catch (InterruptedException e) {
-      logger.warn("Interrupted while stopping status handler for controllable process.", e);
+      interrupted = stop(statusRequestFileWatchdog);
+      interrupted = stop(stopRequestFileWatchdog) || interrupted;
+      launcher.close();
-      try {
-        this.stopRequestFileWatchdog.stop();
-      } catch (InterruptedException e) {
-        logger.warn("Interrupted while stopping stop handler for controllable process.", e);
+      if (interrupted) {
+        Thread.currentThread().interrupt();
-      this.launcher.close();
-  protected File getWorkingDir() {
-    return this.workingDir;
+  public void stop(final boolean deletePidFileOnStop) {
+    boolean interrupted = false;
+    try {
+      interrupted = stop(statusRequestFileWatchdog);
+      interrupted = stop(stopRequestFileWatchdog) || interrupted;
+      launcher.close(deletePidFileOnStop);
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
-  private static void deleteFiles(final File workingDir, final ProcessType processType) {
-    deleteFile(workingDir, processType.getStatusRequestFileName());
-    deleteFile(workingDir, processType.getStatusFileName());
-    deleteFile(workingDir, processType.getStopRequestFileName());
+  private boolean stop(final ControlFileWatchdog fileWatchdog) {
+    boolean interrupted = false;
+    try {
+      fileWatchdog.stop();
+    } catch (InterruptedException e) {
+      interrupted = true;
+      logger.warn("Interrupted while stopping status handler for controllable process.", e);
+    }
+    return interrupted;
-  private static void deleteFile(final File workingDir, final String fileName) {
-    final File file = new File(workingDir, fileName);
+  private void deleteFiles(final File directory, final ProcessType processType) {
+    try {
+      deleteFileWithValidation(new File(directory, processType.getStatusRequestFileName()),
+          "statusRequestFile");
+      deleteFileWithValidation(new File(directory, processType.getStatusFileName()), "statusFile");
+      deleteFileWithValidation(new File(directory, processType.getStopRequestFileName()),
+          "stopRequestFile");
+    } catch (IOException e) {
+      throw new UncheckedIOException(e);
+    }
+  }
+
+  private static File createPidFile(final File directory, final ProcessType processType) {
+    return new File(directory, processType.getPidFileName());
+  }
+
+  private static LocalProcessLauncher createLocalProcessLauncher(final File pidFile,
+      final boolean force) throws FileAlreadyExistsException, IOException, PidUnavailableException {
+    return new LocalProcessLauncher(pidFile, force);
+  }
+
+  private static ControlRequestHandler createStopHandler(final ControlNotificationHandler handler) {
+    return handler::handleStop;
+  }
+
+  private static ControlRequestHandler createStatusHandler(final ControlNotificationHandler handler,
+      final File directory, final ProcessType processType) {
+    return () -> {
+      writeStatusToFile(fetchStatusWithValidation(handler), directory, processType);
+    };
+  }
+
+  private static ControlFileWatchdog createStopRequestFileWatchdog(final File directory,
+      final ProcessType processType, final ControlRequestHandler stopHandler) {
+    return new ControlFileWatchdog(directory, processType.getStopRequestFileName(), stopHandler,
+        false);
+  }
+
+  private static ControlFileWatchdog createStatusRequestFileWatchdog(final File directory,
+      final ProcessType processType, final ControlRequestHandler statusHandler) {
+    return new ControlFileWatchdog(directory, processType.getStatusRequestFileName(), statusHandler,
+        false);
+  }
+
+  private static String fetchStatusWithValidation(final ControlNotificationHandler handler) {
+    ServiceState<?> state = handler.handleStatus();
+    if (state == null) {
+      throw new IllegalStateException("Null ServiceState is invalid");
+    }
+
+    String jsonContent = state.toJson();
+    if (jsonContent == null) {
+      throw new IllegalStateException("Null JSON for status is invalid");
+    } else if (jsonContent.isEmpty()) {
+      throw new IllegalStateException("Empty JSON for status is invalid");
+    }
+
+    return jsonContent;
+  }
+
+  private static void deleteFileWithValidation(final File file, final String fileNameForMessage)
+      throws IOException {
-      file.delete();
+      if (!file.delete()) {
+        throw new IOException(
+            "Unable to delete " + fileNameForMessage + "'" + file.getCanonicalPath() + "'");
+      }
+    }
+  }
+
+  private static void writeStatusToFile(final String jsonContent, final File directory,
+      final ProcessType processType) throws IOException {
+    File statusFile = new File(directory, processType.getStatusFileName());
+    File statusFileTmp = new File(directory, processType.getStatusFileName() + ".tmp");
+
+    deleteFileWithValidation(statusFile, "statusFile");
+    deleteFileWithValidation(statusFileTmp, "statusFileTmp");
+
+    if (!statusFileTmp.createNewFile()) {
+      throw new IOException(
+          "Unable to create statusFileTmp '" + statusFileTmp.getCanonicalPath() + "'");
+    }
+
+    FileWriter writer = new FileWriter(statusFileTmp);
+    writer.write(jsonContent);
+    writer.flush();
+    writer.close();
+
+    if (!statusFileTmp.renameTo(statusFile)) {
+      throw new IOException("Unable to rename statusFileTmp '" + statusFileTmp.getCanonicalPath()
+          + "' to '" + statusFile.getCanonicalPath() + "'");

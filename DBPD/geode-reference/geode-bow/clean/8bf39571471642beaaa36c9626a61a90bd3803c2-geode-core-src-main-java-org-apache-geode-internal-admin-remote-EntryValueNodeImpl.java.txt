Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class holds the metadata for a single object field in a value
- * stored in the cache.  They are built during construction of {@link
- * ObjectDetailsResponse} instances and returned to the console. This
- * class does not implement {@link
- * org.apache.geode.DataSerializable} since that
- * mechanism gets confused by the often cyclical refrences between
- * instances of this class.
+ * This class holds the metadata for a single object field in a value stored in the cache. They are
+ * built during construction of {@link ObjectDetailsResponse} instances and returned to the console.
+ * This class does not implement {@link org.apache.geode.DataSerializable} since that mechanism gets
+ * confused by the often cyclical refrences between instances of this class.
-public class EntryValueNodeImpl implements EntryValueNode, Externalizable/*, DataSerializable */ {
+public class EntryValueNodeImpl implements EntryValueNode, Externalizable/* , DataSerializable */ {
-  public static EntryValueNodeImpl createFromValueRoot(Object value,
-                                                       boolean logicalInspection) {
+  public static EntryValueNodeImpl createFromValueRoot(Object value, boolean logicalInspection) {
-    Map map = (Map)recursionSet.get();
+    Map map = (Map) recursionSet.get();
-                                                       Object primitiveWrapper) {    
+      Object primitiveWrapper) {
-                                                    Class arrayClass) {
+      Class arrayClass) {
-    Map map = (Map)recursionSet.get();
+    Map map = (Map) recursionSet.get();
-//    if (arrayObj != null) (cannot be null) 
+    // if (arrayObj != null) (cannot be null)
-        Object[] array = (Object[])arrayObj;
+        Object[] array = (Object[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        int[] array = (int[])arrayObj;
+        int[] array = (int[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        boolean[] array = (boolean[])arrayObj;
+        boolean[] array = (boolean[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        char[] array = (char[])arrayObj;
+        char[] array = (char[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        double[] array = (double[])arrayObj;
+        double[] array = (double[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        long[] array = (long[])arrayObj;
+        long[] array = (long[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        float[] array = (float[])arrayObj;
+        float[] array = (float[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        byte[] array = (byte[])arrayObj;
+        byte[] array = (byte[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-        short[] array = (short[])arrayObj;
+        short[] array = (short[]) arrayObj;
-        for (int i = 0; i<array.length; i++) {
+        for (int i = 0; i < array.length; i++) {
-                                                    boolean logicalInspection) {
-    Map map = (Map)recursionSet.get();
-    EntryValueNodeImpl stored = (EntryValueNodeImpl)map.get(obj);
+      boolean logicalInspection) {
+    Map map = (Map) recursionSet.get();
+    EntryValueNodeImpl stored = (EntryValueNodeImpl) map.get(obj);
-        
-//         if (cancelled) { return; }
-        
+
+        // if (cancelled) { return; }
+
-            Map theMap = (Map)obj;
+            Map theMap = (Map) obj;
-//                 if (cancelled) { return; }
-                Map.Entry entry = (Map.Entry)it.next();
+                // if (cancelled) { return; }
+                Map.Entry entry = (Map.Entry) it.next();
-                  elements.add(createFromObject("key->" + constructKeyDisplay(key),
-                                                key, logicalInspection));
+                  elements.add(
+                      createFromObject("key->" + constructKeyDisplay(key), key, logicalInspection));
-                  elements.add(createFromNullField("key->" + constructKeyDisplay(key),
-                                                   Object.class));
+                  elements
+                      .add(createFromNullField("key->" + constructKeyDisplay(key), Object.class));
-                  elements.add(createFromObject("value->" + constructKeyDisplay(value),
-                                                value, logicalInspection));
+                  elements.add(createFromObject("value->" + constructKeyDisplay(value), value,
+                      logicalInspection));
-                  elements.add(createFromNullField("value->" + constructKeyDisplay(value),
-                                                   Object.class));
+                  elements.add(
+                      createFromNullField("value->" + constructKeyDisplay(value), Object.class));
-            java.util.List list = (List)obj;
+            java.util.List list = (List) obj;
-//               if (cancelled) { return; }
+              // if (cancelled) { return; }
-              elements.add(createFromObject(constructKeyDisplay(element),
-                                            element, logicalInspection));
+              elements
+                  .add(createFromObject(constructKeyDisplay(element), element, logicalInspection));
-            Collection coll = (Collection)obj;
+            Collection coll = (Collection) obj;
-//               if (cancelled) { return; }
+              // if (cancelled) { return; }
-              elements.add(createFromObject(constructKeyDisplay(element),
-                                            element, logicalInspection));
+              elements
+                  .add(createFromObject(constructKeyDisplay(element), element, logicalInspection));
-//       if (cancelled) { return; }
-      
-      node.fields = (EntryValueNodeImpl[])elements.toArray(new EntryValueNodeImpl[0]);
-      
-    } else { //physical inspection
+      // if (cancelled) { return; }
+
+      node.fields = (EntryValueNodeImpl[]) elements.toArray(new EntryValueNodeImpl[0]);
+
+    } else { // physical inspection
-        throw new InternalGemFireException(LocalizedStrings.EntryValueNodeImpl_UNABLE_TO_SET_ACCESSIBILITY_OF_FIELD_OBJECTS_DURING_CACHE_VALUE_DISPLAY_CONSTRUCTION.toLocalizedString(), se);
+        throw new InternalGemFireException(
+            LocalizedStrings.EntryValueNodeImpl_UNABLE_TO_SET_ACCESSIBILITY_OF_FIELD_OBJECTS_DURING_CACHE_VALUE_DISPLAY_CONSTRUCTION
+                .toLocalizedString(),
+            se);
-      for (int i=0; i<fields.length; i++) {
+      for (int i = 0; i < fields.length; i++) {
-          throw new InternalGemFireException(LocalizedStrings.EntryValueNodeImpl_UNABLE_TO_BUILD_CACHE_VALUE_DISPLAY.toLocalizedString(), e);
+          throw new InternalGemFireException(
+              LocalizedStrings.EntryValueNodeImpl_UNABLE_TO_BUILD_CACHE_VALUE_DISPLAY
+                  .toLocalizedString(),
+              e);
-          
+
-          fieldList.add(createFromPrimitive(name, fields[i].getType().getName(),
-                                            fieldVal));
+          fieldList.add(createFromPrimitive(name, fields[i].getType().getName(), fieldVal));
-      node.fields = (EntryValueNodeImpl[])fieldList.toArray(new EntryValueNodeImpl[0]);
+      node.fields = (EntryValueNodeImpl[]) fieldList.toArray(new EntryValueNodeImpl[0]);
-    return (test instanceof Number || test instanceof String ||
-            test instanceof Boolean || test instanceof Character);
-    
+    return (test instanceof Number || test instanceof String || test instanceof Boolean
+        || test instanceof Character);
+
-    return (obj instanceof Map || obj instanceof List ||
-            obj instanceof Collection);
+    return (obj instanceof Map || obj instanceof List || obj instanceof Collection);
-  public static String constructKeyDisplay( Object toDisplay ) {
-    if ( toDisplay == null )
+  public static String constructKeyDisplay(Object toDisplay) {
+    if (toDisplay == null)
-    else if ( toDisplay instanceof String )
-      return (String)toDisplay;
-    else if ( toDisplay instanceof Number )
+    else if (toDisplay instanceof String)
+      return (String) toDisplay;
+    else if (toDisplay instanceof Number)
-    else if ( toDisplay instanceof Character )
+    else if (toDisplay instanceof Character)
-    else if ( toDisplay instanceof Boolean )
+    else if (toDisplay instanceof Boolean)
-    else{
+    else {
-      className = className.substring(className.lastIndexOf(".")+1);
+      className = className.substring(className.lastIndexOf(".") + 1);
-    }      
+    }
-  public void readExternal(ObjectInput in) throws IOException,
-      ClassNotFoundException {
+  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-    this.type = (String)in.readObject();
-    this.name = (String)in.readObject();
-    this.fields = (EntryValueNodeImpl[])in.readObject();
+    this.type = (String) in.readObject();
+    this.name = (String) in.readObject();
+    this.fields = (EntryValueNodeImpl[]) in.readObject();
-//   public void toData(DataOutput out) throws IOException {
-//     Helper.writeObject(primitive, out);
-//     Helper.writeString(type, out);
-//     Helper.writeString(name, out);
-//     Helper.writeObject(fields, out);
-//   }
+  // public void toData(DataOutput out) throws IOException {
+  // Helper.writeObject(primitive, out);
+  // Helper.writeString(type, out);
+  // Helper.writeString(name, out);
+  // Helper.writeObject(fields, out);
+  // }
-//   public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-//     this.primitive = Helper.readObject(in);
-//     this.type = Helper.readString(in);
-//     this.name = Helper.readString(in);
-//     this.fields = (EntryValueNodeImpl[])Helper.readObject(in);                               
-//   }
+  // public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+  // this.primitive = Helper.readObject(in);
+  // this.type = Helper.readString(in);
+  // this.name = Helper.readString(in);
+  // this.fields = (EntryValueNodeImpl[])Helper.readObject(in);
+  // }
-
-

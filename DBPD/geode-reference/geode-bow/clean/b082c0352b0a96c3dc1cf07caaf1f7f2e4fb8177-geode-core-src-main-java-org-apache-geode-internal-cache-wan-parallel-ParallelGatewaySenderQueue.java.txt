GEODE-7803: provide undeprecated internal region create (#4722)

You can now use InternalRegionFactory to create a region configured with InternalRegionArguments. No need to use the deprecated AttributesFactory.
InternalRegionFactory used to be named RegionFactoryImpl.

-import java.io.IOException;
-import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.internal.cache.InternalRegionFactory;
-        // TODO:REF:Avoid deprecated apis
-        AttributesFactory fact = new AttributesFactory();
+        InternalRegionFactory fact = cache.createInternalRegionFactory();
-        final RegionAttributes ra = fact.create();
+        final RegionAttributes ra = fact.getCreateAttributes();
-        try {
-          prQ = (PartitionedRegion) cache.createVMRegion(prQName, ra,
-              new InternalRegionArguments().setInternalMetaRegion(meta).setDestroyLockFlag(true)
-                  .setSnapshotInputStream(null).setImageTarget(null));
+        fact.setInternalMetaRegion(meta).setDestroyLockFlag(true)
+            .setSnapshotInputStream(null).setImageTarget(null);
+        prQ = (PartitionedRegion) fact.create(prQName);
-          if (logger.isDebugEnabled()) {
-            logger.debug("Region created  : {} partition Attributes : {}", prQ,
-                prQ.getPartitionAttributes());
-          }
-
-          // TODO This should not be set on the PR but on the GatewaySender
-          prQ.enableConflation(sender.isBatchConflationEnabled());
-
-          // Before going ahead, make sure all the buckets of shadowPR are
-          // loaded
-          // and primary nodes have been decided.
-          // This is required in case of persistent PR and sender.
-          if (prQ.getLocalMaxMemory() != 0) {
-            Iterator<Integer> itr = prQ.getRegionAdvisor().getBucketSet().iterator();
-            while (itr.hasNext()) {
-              itr.next();
-            }
-          }
-          // In case of Replicated Region it may not be necessary.
-
-        } catch (IOException veryUnLikely) {
-          logger.fatal("Unexpected Exception during init of " +
-              this.getClass(),
-              veryUnLikely);
-        } catch (ClassNotFoundException alsoUnlikely) {
-          logger.fatal("Unexpected Exception during init of " +
-              this.getClass(),
-              alsoUnlikely);
+        if (logger.isDebugEnabled()) {
+          logger.debug("Region created  : {} partition Attributes : {}", prQ,
+              prQ.getPartitionAttributes());
+
+        // TODO This should not be set on the PR but on the GatewaySender
+        prQ.enableConflation(sender.isBatchConflationEnabled());
+
+        // Before going ahead, make sure all the buckets of shadowPR are
+        // loaded
+        // and primary nodes have been decided.
+        // This is required in case of persistent PR and sender.
+        if (prQ.getLocalMaxMemory() != 0) {
+          Iterator<Integer> itr = prQ.getRegionAdvisor().getBucketSet().iterator();
+          while (itr.hasNext()) {
+            itr.next();
+          }
+        }
+        // In case of Replicated Region it may not be necessary.
+
-        // TODO:REF:Avoid deprecated apis
+        RegionShortcut regionShortcut;
+        if (sender.isPersistenceEnabled() && !isAccessor) {
+          regionShortcut = RegionShortcut.PARTITION_PERSISTENT;
+        } else {
+          regionShortcut = RegionShortcut.PARTITION;
+        }
+        InternalRegionFactory fact = cache.createInternalRegionFactory(regionShortcut);
-        AttributesFactory fact = new AttributesFactory();
-        if (sender.isPersistenceEnabled() && !isAccessor) {
-          fact.setDataPolicy(DataPolicy.PERSISTENT_PARTITION);
-        }
-
-        final RegionAttributes ra = fact.create();
+        final RegionAttributes ra = fact.getCreateAttributes();
-        try {
-          prQ = (PartitionedRegion) cache.createVMRegion(prQName, ra,
-              new InternalRegionArguments().setInternalMetaRegion(meta).setDestroyLockFlag(true)
-                  .setInternalRegion(true).setSnapshotInputStream(null).setImageTarget(null));
-          // at this point we should be able to assert prQ == meta;
+        fact.setInternalMetaRegion(meta);
+        fact.setDestroyLockFlag(true);
+        fact.setInternalRegion(true);
+        fact.setSnapshotInputStream(null);
+        fact.setImageTarget(null);
+        prQ = (PartitionedRegion) fact.create(prQName);
+        // at this point we should be able to assert prQ == meta;
-          // TODO This should not be set on the PR but on the GatewaySender
-          prQ.enableConflation(sender.isBatchConflationEnabled());
-          if (isAccessor)
-            return; // return from here if accessor node
+        // TODO This should not be set on the PR but on the GatewaySender
+        prQ.enableConflation(sender.isBatchConflationEnabled());
+        if (isAccessor)
+          return; // return from here if accessor node
-          // Add the overflow statistics to the mbean
-          addOverflowStatisticsToMBean(cache, prQ);
+        // Add the overflow statistics to the mbean
+        addOverflowStatisticsToMBean(cache, prQ);
-          // Wait for buckets to be recovered.
-          prQ.shadowPRWaitForBucketRecovery();
+        // Wait for buckets to be recovered.
+        prQ.shadowPRWaitForBucketRecovery();
-        } catch (IOException | ClassNotFoundException veryUnLikely) {
-          logger.fatal("Unexpected Exception during init of " +
-              this.getClass(),
-              veryUnLikely);
-        }

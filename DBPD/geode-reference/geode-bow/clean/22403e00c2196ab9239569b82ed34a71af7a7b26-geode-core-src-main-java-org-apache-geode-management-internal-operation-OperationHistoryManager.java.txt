GEODE-7799: Distribute rebalance status to other locators (#4692)

Co-authored-by: Joris Melchior <joris.melchior@gmail.com>
Co-authored-by: Darrel Schneider <dschneider@pivotal.io>
Co-authored-by: Dale Emery <demery@pivotal.io>

+import java.time.Duration;
-import java.util.Map;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import org.apache.geode.lang.Identifiable;
+import org.apache.geode.annotations.VisibleForTesting;
- * The policy for expiring completed operations is subject to change, but may be based on age,
- * count, when it was last accessed, or some combination thereof.
+ * Completed operations can expire after 7 days.
+ * Expiration is only checked for when get, list, or recordStart are called.
-  private final ConcurrentMap<String, OperationInstance> history;
+  private final OperationStateStore operationStateStore;
-  public OperationHistoryManager() {
-    this(2, TimeUnit.HOURS);
+  public OperationHistoryManager(
+      OperationStateStore operationStateStore) {
+    this(Duration.ofDays(7), operationStateStore);
-  public OperationHistoryManager(long keepCompleted, TimeUnit timeUnit) {
-    history = new ConcurrentHashMap<>();
-    keepCompletedMillis = timeUnit.toMillis(keepCompleted);
+  public OperationHistoryManager(Duration keepCompleted,
+      OperationStateStore operationStateStore) {
+    keepCompletedMillis = keepCompleted.toMillis();
+    this.operationStateStore = operationStateStore;
-  <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationInstance<A, V> getOperationInstance(
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationState<A, V> get(
-    return (OperationInstance<A, V>) history.get(opId);
+
+    return (OperationState<A, V>) operationStateStore.get(opId);
-  private void expireHistory() {
-    final long expirationDate = now() - keepCompletedMillis;
-    Set<String> expiredKeys =
-        history.entrySet().stream().filter(e -> isExpired(expirationDate, e.getValue()))
-            .map(Map.Entry::getKey).collect(Collectors.toSet());
-    expiredKeys.forEach(history::remove);
+  @VisibleForTesting
+  void expireHistory() {
+    final long expirationTime = now() - keepCompletedMillis;
+    Set<String> expiredKeys = operationStateStore.list()
+        .stream()
+        .filter(operationInstance -> isExpired(expirationTime, operationInstance))
+        .map(OperationState::getId)
+        .collect(Collectors.toSet());
+
+    expiredKeys.forEach(operationStateStore::remove);
-  long now() {
+  private long now() {
-  private static boolean isExpired(long expirationDate, OperationInstance<?, ?> operationInstance) {
-    CompletableFuture<Date> futureOperationEnded = operationInstance.getFutureOperationEnded();
+  private static boolean isExpired(long expirationTime, OperationState<?, ?> operationInstance) {
+    Date operationEnd = operationInstance.getOperationEnd();
-    if (!futureOperationEnded.isDone())
+    if (operationEnd == null) {
-
-    final long endTime;
-    try {
-      endTime = futureOperationEnded.get().getTime();
-    } catch (ExecutionException ignore) {
-      // cannot ever happen because we've already checked isDone above
-      return false;
-    } catch (InterruptedException ignore) {
-      // cannot ever happen because we've already checked isDone above
-      Thread.currentThread().interrupt();
-      return false;
-    return endTime <= expirationDate;
+    return operationEnd.getTime() <= expirationTime;
-   * Stores a new operation in the history and installs a trigger to record the operation end time.
+   * Stores a new operation in the history and returns its unique identifier.
-  public <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationInstance<A, V> save(
-      OperationInstance<A, V> operationInstance) {
-    String opId = operationInstance.getId();
-    CompletableFuture<V> future = operationInstance.getFutureResult();
-
-    future.whenComplete((result, exception) -> operationInstance.setOperationEnded(new Date()));
-
-    history.put(opId, operationInstance);
+  public String recordStart(ClusterManagementOperation<?> op) {
-    return operationInstance;
+    return operationStateStore.recordStart(op);
-  @SuppressWarnings("unchecked")
-  <A extends ClusterManagementOperation<V>, V extends OperationResult> List<OperationInstance<A, V>> listOperationInstances(
+  /**
+   * Records that a previously started operation has ended with the given result or cause.
+   */
+  public void recordEnd(String opId, OperationResult result, Throwable cause) {
+    operationStateStore.recordEnd(opId, result, cause);
+  }
+
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> List<OperationState<A, V>> list(
-    return history.values().stream().filter(oi -> opType.getClass().isInstance(oi.getOperation()))
-        .map(oi -> (OperationInstance<A, V>) oi).collect(Collectors.toList());
+
+    return operationStateStore.list()
+        .stream()
+        .filter(instance -> opType.getClass().isAssignableFrom(instance.getOperation().getClass()))
+        .map(fi -> (OperationState<A, V>) fi)
+        .collect(Collectors.toList());
-  /**
-   * struct for holding information pertinent to a specific instance of an operation
-   *
-   * all fields are immutable, however note that {@link #setOperationEnded(Date)} completes
-   * {@link #getFutureOperationEnded()}
-   */
-  public static class OperationInstance<A extends ClusterManagementOperation<V>, V extends OperationResult>
-      implements Identifiable<String> {
-    private final CompletableFuture<V> future;
-    private final String opId;
-    private final A operation;
-    private final Date operationStart;
-    private final CompletableFuture<Date> futureOperationEnded;
-    private String operator;
-
-    public OperationInstance(CompletableFuture<V> future, String opId, A operation,
-        Date operationStart) {
-      this.future = future;
-      this.opId = opId;
-      this.operation = operation;
-      this.operationStart = operationStart;
-      this.futureOperationEnded = new CompletableFuture<>();
-    }
-
-    @Override
-    public String getId() {
-      return opId;
-    }
-
-    public CompletableFuture<V> getFutureResult() {
-      return future;
-    }
-
-    public A getOperation() {
-      return operation;
-    }
-
-    public Date getOperationStart() {
-      return operationStart;
-    }
-
-    public CompletableFuture<Date> getFutureOperationEnded() {
-      return futureOperationEnded;
-    }
-
-    public void setOperationEnded(Date operationEnded) {
-      this.futureOperationEnded.complete(operationEnded);
-    }
-
-    public String getOperator() {
-      return operator;
-    }
-
-    public void setOperator(String operator) {
-      this.operator = operator;
-    }
-  }

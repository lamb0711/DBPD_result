GEODE_6883: Creating membership api classes (#3985)

Creating a new membership API package. Starting that package out with
these classes:
* MembershipBuilder - created by moving NetMember and NetLocator factory stuff
  out of MembershipFactory and renaming MembershipFactory to MembershipBuilder
* Membership - Extracted an interface from MembershipManager
* Authenticator - Moved Authenticator to the API package
* MembershipStatistics - Extracted interface from DMStats
* MembershipListener and MessageListener - Creating these new membership
  specific interfaces by splitting up DistributedMembershipListener into two
  separate interfaces.
* MembershipConfig - Extracted interface from ServiceConfig

* Adding an archunit test for the membership API. Ensure that the API only
  depends on other API classes.

* Removing GMSMemberFactory and MemberServices
  These classes were adding another layer to creating a MembershipManager,
  but they didn't actually allow swapping in a different implementation.
  Inlining these methods into the respective NetLocatorFactory,
  NetMemberFactory, and MembershipManagerFactory.

* Removing getDM from DirectChannelListener - We want to get rid of this
  interface in favor of other membership
  specific interfaces that don't depend on core.

-import java.io.NotSerializableException;
-import java.util.Map;
-import org.apache.geode.distributed.internal.DMStats;
-import org.apache.geode.distributed.internal.DistributionMessage;
+import org.apache.geode.distributed.internal.membership.gms.api.Membership;
-public interface MembershipManager {
+public interface MembershipManager extends Membership {
-   * Fetch the current view of memberships in th distributed system, as an ordered list.
-   *
-   * @return list of members
-   */
-  MembershipView getView();
-
-  /**
-   * Return a {@link InternalDistributedMember} representing the current system
-   *
-   * @return an address corresponding to the current system
-   */
-  InternalDistributedMember getLocalMember();
-
-  /**
-   * @param destinations list of members to send the message to. A list of length 1 with
-   *        <em>null</em> as a single element broadcasts to all members of the system.
-   * @param content the message to send
-   * @param stats the statistics object to update
-   * @return list of members who did not receive the message. If
-   *         {@link DistributionMessage#ALL_RECIPIENTS} is given as thelist of recipients, this
-   *         return list is null (empty). Otherwise, this list is all of those recipients that did
-   *         not receive the message because they departed the distributed system.
-   * @throws NotSerializableException If content cannot be serialized
-   */
-  Set<InternalDistributedMember> send(InternalDistributedMember[] destinations,
-      DistributionMessage content, DMStats stats)
-      throws NotSerializableException;
-
-  /**
-   * Returns a serializable map of communications state for use in state stabilization.
-   *
-   * @param member the member whose message state is to be captured
-   * @param includeMulticast whether the state of the mcast messaging should be included
-   * @return the current state of the communication channels between this process and the given
-   *         distributed member
-   * @since GemFire 5.1
-   */
-  Map<String, Long> getMessageState(DistributedMember member, boolean includeMulticast);
-
-  /**
-   * Waits for the given communications to reach the associated state
-   *
-   * @param member The member whose messaging state we're waiting for
-   * @param state The message states to wait for. This should come from getMessageStates
-   * @throws InterruptedException Thrown if the thread is interrupted
-   * @since GemFire 5.1
-   */
-  void waitForMessageState(DistributedMember member, Map<String, Long> state)
-      throws InterruptedException;
-
-  /**
-  boolean waitForDeparture(DistributedMember mbr, int timeoutMS)
+  boolean waitForDeparture(DistributedMember mbr, long timeoutMS)
-  /**
-   * Request the current membership coordinator to remove the given member
-   */
-  boolean requestMemberRemoval(DistributedMember member, String reason);
-
-  /**
-   * like memberExists() this checks to see if the given ID is in the current membership view. If it
-   * is in the view though we try to connect to its failure-detection port to see if it's still
-   * around. If we can't then suspect processing is initiated on the member with the given reason
-   * string.
-   *
-   * @param mbr the member to verify
-   * @param reason why the check is being done (must not be blank/null)
-   * @return true if the member checks out
-   */
-  boolean verifyMember(DistributedMember mbr, String reason);
-
-   * Returns true if the member is being shunned
-   */
-  boolean isShunned(DistributedMember m);
-
-  /**

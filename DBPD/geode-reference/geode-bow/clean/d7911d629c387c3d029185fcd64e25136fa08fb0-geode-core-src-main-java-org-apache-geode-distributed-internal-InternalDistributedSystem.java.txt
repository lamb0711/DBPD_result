GEODE-6558: Add InternalDistributedSystem.Builder (#3354)

* Remove all but one constructor.
* Replace newInstance methods with InternalDistributedSystem.Builder.
* Replace newInstanceForTesting methods with
InternalDistributedSystem.BuilderForTesting.
* Replace public static boolean var ALLOW_MULTIPLE_SYSTEMS with usage
of Boolean.getBoolean(ALLOW_MULTIPLE_SYSTEMS_PROPERTY) in
connectInternal.

Most code paths are using DistributedSystem.connect or
InternalDistributedSystem.connectInternal to construct a system.
connectInternal now uses InternalDistributedSystem.Builder.

Several tests are using  InternalDistributedSystem.BuilderForTesting.

-
+import org.apache.geode.annotations.VisibleForTesting;
-   * Feature flag to enable multiple caches within a JVM.
-   */
-  @MutableForTesting
-  public static boolean ALLOW_MULTIPLE_SYSTEMS =
-      Boolean.getBoolean(ALLOW_MULTIPLE_SYSTEMS_PROPERTY);
-
-  /**
+   * <p>
-    if (ALLOW_MULTIPLE_SYSTEMS) {
-      return InternalDistributedSystem.newInstance(config);
+    if (Boolean.getBoolean(ALLOW_MULTIPLE_SYSTEMS_PROPERTY)) {
+      return new Builder(config)
+          .setSecurityConfig(securityConfig)
+          .build();
-      InternalDistributedSystem newSystem =
-          InternalDistributedSystem.newInstance(config, securityConfig);
+      InternalDistributedSystem newSystem = new Builder(config)
+          .setSecurityConfig(securityConfig)
+          .build();
-  ///////////////////// Static Methods /////////////////////
-
-  /**
-   * Creates a new instance of <code>InternalDistributedSystem</code> with the given configuration.
-   */
-  public static InternalDistributedSystem newInstance(Properties config) {
-    return newInstance(config, null);
-  }
-
-  public static InternalDistributedSystem newInstance(Properties config,
-      SecurityConfig securityConfig) {
-    if (securityConfig == null) {
-      return newInstance(config, null, null);
-    } else {
-      return newInstance(config, securityConfig.getSecurityManager(),
-          securityConfig.getPostProcessor());
-    }
-  }
-
-  public static InternalDistributedSystem newInstance(Properties config,
-      SecurityManager securityManager, PostProcessor postProcessor) {
-    boolean success = false;
-    InternalDataSerializer.checkSerializationVersion();
-    try {
-      SystemFailure.startThreads();
-      InternalDistributedSystem newSystem = new InternalDistributedSystem(config);
-      newSystem.initialize(securityManager, postProcessor);
-      reconnectAttemptCounter = 0; // reset reconnect count since we just got a new connection
-      notifyConnectListeners(newSystem);
-      success = true;
-      return newSystem;
-    } finally {
-      if (!success) {
-        SystemFailure.stopThreads();
-      }
-    }
-  }
-
-  /**
-   * Creates a non-functional instance for testing.
-   *
-   * @param distributionManager the distribution manager for the test instance
-   * @param properties properties to configure the test instance
-   */
-  public static InternalDistributedSystem newInstanceForTesting(
-      DistributionManager distributionManager, Properties properties) {
-    StatisticsManagerFactory statisticsManagerFactory = defaultStatisticsManagerFactory();
-
-    return newInstanceForTesting(
-        distributionManager, properties, statisticsManagerFactory);
-  }
-
-  /**
-   * Creates a non-functional instance for testing.
-   *
-   * @param distributionManager the distribution manager for the test instance
-   * @param properties properties to configure the test instance
-   * @param statisticsManagerFactory the statistics manager factory for the test instance
-   */
-  static InternalDistributedSystem newInstanceForTesting(DistributionManager distributionManager,
-      Properties properties, StatisticsManagerFactory statisticsManagerFactory) {
-    ConnectionConfigImpl connectionConfig = new ConnectionConfigImpl(properties);
-
-    InternalDistributedSystem internalDistributedSystem =
-        new InternalDistributedSystem(connectionConfig, statisticsManagerFactory);
-
-    internalDistributedSystem.config = new RuntimeDistributionConfigImpl(internalDistributedSystem);
-    internalDistributedSystem.dm = distributionManager;
-    internalDistributedSystem.isConnected = true;
-
-    return internalDistributedSystem;
-  }
-
-   * Creates a new {@code InternalDistributedSystem} with the given configuration properties.
-   * Does all of the magic of finding the "default" values of properties.
-   * <p>
-   * See {@link #connect} for a list of exceptions that may be thrown.
-   *
-   * @param configurationProperties properties to configure the connection
-   */
-  private InternalDistributedSystem(Properties configurationProperties) {
-    this(new ConnectionConfigImpl(configurationProperties));
-  }
-
-  /**
-   * <p>
-   * See {@link #connect} for a list of exceptions that may be thrown.
-   * @param config the configuration for the connection
-   */
-  private InternalDistributedSystem(ConnectionConfig config) {
-    this(config, defaultStatisticsManagerFactory());
-    isReconnectingDS = config.isReconnecting();
-    quorumChecker = config.quorumChecker();
-  }
-
-  /**
-   * Creates a new {@code InternalDistributedSystem} with the given configuration.
+    isReconnectingDS = config.isReconnecting();
+    quorumChecker = config.quorumChecker();
-
-  //////////////////// Instance Methods ////////////////////
+    reconnectAttemptCounter = 0; // reset reconnect count since we just got a new connection
+
+  public static class Builder {
+
+    private final Properties configProperties;
+
+    private SecurityConfig securityConfig;
+
+    public Builder(Properties configProperties) {
+      this.configProperties = configProperties;
+    }
+
+    public Builder setSecurityConfig(SecurityConfig securityConfig) {
+      this.securityConfig = securityConfig;
+      return this;
+    }
+
+    /**
+     * Builds and initializes new instance of InternalDistributedSystem.
+     */
+    public InternalDistributedSystem build() {
+      if (securityConfig == null) {
+        securityConfig = new SecurityConfig(null, null);
+      }
+
+      boolean stopThreads = true;
+      InternalDataSerializer.checkSerializationVersion();
+      try {
+        SystemFailure.startThreads();
+        InternalDistributedSystem newSystem =
+            new InternalDistributedSystem(new ConnectionConfigImpl(
+                configProperties), defaultStatisticsManagerFactory());
+        newSystem
+            .initialize(securityConfig.getSecurityManager(), securityConfig.getPostProcessor());
+        notifyConnectListeners(newSystem);
+        stopThreads = false;
+        return newSystem;
+      } finally {
+        if (stopThreads) {
+          SystemFailure.stopThreads();
+        }
+      }
+    }
+  }
+
+  @VisibleForTesting
+  public static class BuilderForTesting {
+
+    private final Properties configProperties;
+
+    private DistributionManager distributionManager;
+    private StatisticsManagerFactory statisticsManagerFactory = defaultStatisticsManagerFactory();
+
+    public BuilderForTesting(Properties configProperties) {
+      this.configProperties = configProperties;
+    }
+
+    public BuilderForTesting setDistributionManager(DistributionManager distributionManager) {
+      this.distributionManager = distributionManager;
+      return this;
+    }
+
+    public BuilderForTesting setStatisticsManagerFactory(
+        StatisticsManagerFactory statisticsManagerFactory) {
+      this.statisticsManagerFactory = statisticsManagerFactory;
+      return this;
+    }
+
+    /**
+     * Builds instance without initializing it for testing.
+     */
+    public InternalDistributedSystem build() {
+      ConnectionConfigImpl connectionConfig = new ConnectionConfigImpl(configProperties);
+
+      InternalDistributedSystem internalDistributedSystem =
+          new InternalDistributedSystem(connectionConfig, statisticsManagerFactory);
+
+      internalDistributedSystem.config =
+          new RuntimeDistributionConfigImpl(internalDistributedSystem);
+      internalDistributedSystem.dm = distributionManager;
+      internalDistributedSystem.isConnected = true;
+
+      return internalDistributedSystem;
+    }
+  }

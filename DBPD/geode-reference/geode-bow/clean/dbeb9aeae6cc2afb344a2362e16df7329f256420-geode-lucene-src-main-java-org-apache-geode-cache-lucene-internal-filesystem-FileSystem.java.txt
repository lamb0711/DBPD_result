Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *   http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This filesystem is safe for use with multiple threads if the threads are not
- * modifying the same files. A single file is not safe to modify by multiple
- * threads, even between different members of the distributed system.
+ * This filesystem is safe for use with multiple threads if the threads are not modifying the same
+ * files. A single file is not safe to modify by multiple threads, even between different members of
+ * the distributed system.
- * Changes to a file may not be visible to other members of the system until the
- * FileOutputStream is closed.
+ * Changes to a file may not be visible to other members of the system until the FileOutputStream is
+ * closed.
-  
-  static final int CHUNK_SIZE = 1024 * 1024; //1 MB
+
+  static final int CHUNK_SIZE = 1024 * 1024; // 1 MB
-   * metadata about the files, and the chunkRegion contains the actual data. If data from either region is missing
-   * or inconsistent, no guarantees are made about what this class will do, so it's best if these regions are colocated
-   * and in the same disk store to ensure the data remains together.
+   * metadata about the files, and the chunkRegion contains the actual data. If data from either
+   * region is missing or inconsistent, no guarantees are made about what this class will do, so
+   * it's best if these regions are colocated and in the same disk store to ensure the data remains
+   * together.
+   * 
-  public FileSystem(ConcurrentMap<String, File> fileRegion, ConcurrentMap<ChunkKey, byte[]> chunkRegion, FileSystemStats stats) {
+  public FileSystem(ConcurrentMap<String, File> fileRegion,
+      ConcurrentMap<ChunkKey, byte[]> chunkRegion, FileSystemStats stats) {
-  
+
-    
+
-    
+
-    // TODO - What is the state of the system if 
+    // TODO - What is the state of the system if
-    // Seems like a file will be left with some 
+    // Seems like a file will be left with some
-    if(file == null) {
+    if (file == null) {
-  
+
-    
+
-    
+
-    
-    // TODO - What is the state of the system if 
+
+    // TODO - What is the state of the system if
-  
+
-    
-    //The file's metadata indicates that this chunk shouldn't
-    //exist. Purge all of the chunks that are larger than the file metadata
-    if(id >= file.chunks) {
-      while(chunkRegion.containsKey(key)) {
+
+    // The file's metadata indicates that this chunk shouldn't
+    // exist. Purge all of the chunks that are larger than the file metadata
+    if (id >= file.chunks) {
+      while (chunkRegion.containsKey(key)) {
-      
+
-    
+
-    listFileNames().stream().forEach(fileName-> {
+    listFileNames().stream().forEach(fileName -> {
-      }
-      catch (FileNotFoundException e) {
-        //ignore this, it was concurrently removed
+      } catch (FileNotFoundException e) {
+        // ignore this, it was concurrently removed

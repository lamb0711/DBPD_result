Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class wraps a delegate bucket operator that is synchronous. That is, the
- * delegate bucket operator is expected to move the bucket and notify the
- * Completion within the scope of the call to create bucket.
+ * This class wraps a delegate bucket operator that is synchronous. That is, the delegate bucket
+ * operator is expected to move the bucket and notify the Completion within the scope of the call to
+ * create bucket.
- * What this class does in make that call asynchronous. A task to create the
- * bucket is handed to the thread pool and executed there. After it is done, the
- * completion is notified.
+ * What this class does in make that call asynchronous. A task to create the bucket is handed to the
+ * thread pool and executed there. After it is done, the completion is notified.
- * Calling waitForOperations waits for all previously submitted operations and 
- * ensures the completions are notified.
+ * Calling waitForOperations waits for all previously submitted operations and ensures the
+ * completions are notified.
- * Note that only createRedundantBucket is asynchronous, the rest of the 
- * operations are synchronous.
+ * Note that only createRedundantBucket is asynchronous, the rest of the operations are synchronous.
-  private final ConcurrentLinkedQueue<Completion> pendingSuccess = new ConcurrentLinkedQueue<BucketOperator.Completion>();
-  private final ConcurrentLinkedQueue<Completion> pendingFailure = new ConcurrentLinkedQueue<BucketOperator.Completion>();
-  
+  private final ConcurrentLinkedQueue<Completion> pendingSuccess =
+      new ConcurrentLinkedQueue<BucketOperator.Completion>();
+  private final ConcurrentLinkedQueue<Completion> pendingFailure =
+      new ConcurrentLinkedQueue<BucketOperator.Completion>();
+
-   * @param maxParallelOperations The number of operations that can execute concurrently. Futher calls to createRedundantBucket will block.
-   * @param executor the executor to submit tasks to. This executor should be able to create at least maxParallelOperations threads.
-   * @param operator A bucket operator that is synchronous that will do the actual work of creating a bucket.
+   * 
+   * @param maxParallelOperations The number of operations that can execute concurrently. Futher
+   *        calls to createRedundantBucket will block.
+   * @param executor the executor to submit tasks to. This executor should be able to create at
+   *        least maxParallelOperations threads.
+   * @param operator A bucket operator that is synchronous that will do the actual work of creating
+   *        a bucket.
-  public ParallelBucketOperator(int maxParallelOperations, ExecutorService executor, BucketOperator operator) {
+  public ParallelBucketOperator(int maxParallelOperations, ExecutorService executor,
+      BucketOperator operator) {
-   * Create a redundant bucket asynchronously. If maxParallelOperations is not reached, this call will submit 
-   * a task and return immediately. Otherwise, it will block until an executor thread is available to 
-   * take a task.
+   * Create a redundant bucket asynchronously. If maxParallelOperations is not reached, this call
+   * will submit a task and return immediately. Otherwise, it will block until an executor thread is
+   * available to take a task.
-   * The completion will not be notified until the caller makes another call to createRedundant bucket or
-   * waitForOperations.
+   * The completion will not be notified until the caller makes another call to createRedundant
+   * bucket or waitForOperations.
-          delegate.createRedundantBucket(targetMember, bucketId, colocatedRegionBytes, new Completion() {
-            @Override
-            public void onSuccess() {
-              pendingSuccess.add(completion);
-            }
-            
-            @Override
-            public void onFailure() {
-              pendingFailure.add(completion);
-            }
-          });
-        } catch(CancelException e) {
-          //ignore 
-        } catch(RegionDestroyedException e) {
-          //ignore
+          delegate.createRedundantBucket(targetMember, bucketId, colocatedRegionBytes,
+              new Completion() {
+                @Override
+                public void onSuccess() {
+                  pendingSuccess.add(completion);
+                }
+
+                @Override
+                public void onFailure() {
+                  pendingFailure.add(completion);
+                }
+              });
+        } catch (CancelException e) {
+          // ignore
+        } catch (RegionDestroyedException e) {
+          // ignore
-    
+
-      return delegate.moveBucket(sourceMember, targetMember, bucketId, colocatedRegionBytes);
+    return delegate.moveBucket(sourceMember, targetMember, bucketId, colocatedRegionBytes);
-  public boolean movePrimary(InternalDistributedMember source,
-      InternalDistributedMember target, int bucketId) {
+  public boolean movePrimary(InternalDistributedMember source, InternalDistributedMember target,
+      int bucketId) {
-  
+
-    while((next = pendingSuccess.poll()) != null) {
+    while ((next = pendingSuccess.poll()) != null) {
-    
-    while((next = pendingFailure.poll()) != null) {
+
+    while ((next = pendingFailure.poll()) != null) {
-    
+
-   * Wait for any pending operations, and notify the the completions
-   * that the operations and done.
+   * Wait for any pending operations, and notify the the completions that the operations and done.
-    while(!executor.isShutdown()) {
+    while (!executor.isShutdown()) {
-        if(operationSemaphore.tryAcquire(maxParallelOperations, 1, TimeUnit.SECONDS)) {
+        if (operationSemaphore.tryAcquire(maxParallelOperations, 1, TimeUnit.SECONDS)) {
-          
+
-          
-          if(interrupted) {
+
+          if (interrupted) {
-          
-          return; 
+
+          return;

GEODE-8182: change String commands to use one region (#5165)

* changed all String commands to use the function and to use a single region
* renabled tests ignored for GEODE-8182
* removed the RedisLockService since it is not used in the new data model
* removed the unused del methods on RedisSetCommands and RedisHashCommands
* removed the KeyRegistar since it was no longer needed with a single data region

Co-authored-by: Ray Ingles <ringles@pivotal.io>
-  /**
-   * This is the Redis meta data {@link Region} that holds the {@link RedisDataType} information for
-   * all Regions created. The mapping is a {@link String} key which is the name of the {@link
-   * Region} created to hold the data to the RedisDataType it contains.
-   */
-  private final KeyRegistrar keyRegistrar;
-
-  /**
-   * This is the {@link RedisDataType#REDIS_STRING} {@link Region}. This is the Region that stores
-   * all string contents
-   */
-  private final Region<ByteArrayWrapper, RedisData> stringsRegion;
-  public RegionProvider(Region<ByteArrayWrapper, RedisData> stringsRegion,
-      KeyRegistrar redisMetaRegion,
+  public RegionProvider(
-    if (stringsRegion == null || redisMetaRegion == null) {
-      throw new NullPointerException();
-    }
-    this.stringsRegion = stringsRegion;
-    keyRegistrar = redisMetaRegion;
-  public Region<ByteArrayWrapper, ?> getRegionForType(RedisDataType redisDataType) {
-    if (redisDataType == null) {
-      return null;
-    }
-
-    switch (redisDataType) {
-      case REDIS_STRING:
-        return stringsRegion;
-
-      case REDIS_HASH:
-      case REDIS_SET:
-        return dataRegion;
-
-      case REDIS_PUBSUB:
-      default:
-        return null;
-    }
-  }
-
-  public boolean removeKey(ByteArrayWrapper key) {
-    RedisDataType type = keyRegistrar.getType(key);
-    return removeKey(key, type);
-  }
-
-  public boolean removeKey(ByteArrayWrapper key, RedisDataType type) {
-    return removeKey(key, type, true);
-  }
-
-  private boolean typeStoresDataInKeyRegistrar(RedisDataType type) {
-    if (type == RedisDataType.REDIS_SET) {
-      return true;
-    }
-    if (type == RedisDataType.REDIS_HASH) {
-      return true;
-    }
-    return false;
-  }
-
-  public boolean removeKey(ByteArrayWrapper key, RedisDataType type, boolean cancelExpiration) {
-    if (!typeStoresDataInKeyRegistrar(type)) {
-      keyRegistrar.unregister(key);
-    }
+  public boolean expireKey(ByteArrayWrapper key, RedisDataType type, boolean cancelExpiration) {
-      if (type == RedisDataType.REDIS_STRING) {
-        return stringsRegion.remove(key) != null;
-      } else if (type == RedisDataType.REDIS_SET || type == RedisDataType.REDIS_HASH) {
-        return redisKeyCommands.del(key);
-      } else {
-        return false;
-      }
+      return redisKeyCommands.del(key);
-  public Region<ByteArrayWrapper, RedisData> getStringsRegion() {
-    return stringsRegion;
-  }
-
-    RedisDataType type = keyRegistrar.getType(key);
-    if (type == null) {
+
+    if (!getDataRegion().containsKey(key)) {
-        .schedule(new ExpirationExecutor(key, type, this), delay, TimeUnit.MILLISECONDS);
+        .schedule(new ExpirationExecutor(key, null, this), delay, TimeUnit.MILLISECONDS);
-    RedisDataType type = keyRegistrar.getType(key);
-    if (type == null) {
+    if (!getDataRegion().containsKey(key)) {
-        .schedule(new ExpirationExecutor(key, type, this), delay, TimeUnit.MILLISECONDS);
+        .schedule(new ExpirationExecutor(key, null, this), delay, TimeUnit.MILLISECONDS);

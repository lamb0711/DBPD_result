GEODE-5653: Synchronize and free GatewaySenderEvents in background thâ€¦ (#2407)

   * Synchronize and free GatewaySenderEvents in background thread
   * Await off-heap release in test

+import org.apache.geode.internal.cache.tier.sockets.command.KeySet;
+ * <p>
+ * Modifications made to the Java {@link java.util.Hashtable} implementation
+ * are indicated using comments to mark the beginning and end of Geode changes.
+ *
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-  transient Set<Map.Entry<K, V>> reusableEntrySet; // GemStone addition
+  transient Set<Map.Entry<K, V>> reusableEntrySet; // Geode addition
-  // GemStone addition
-  // GemStone changed HashEntry to be an interface with original HashEntry
+  // Geode addition
+  // Geode changed HashEntry to be an interface with original HashEntry
-  // End GemStone addition
+  // End Geode addition
-    // GemStone addition
+    // Geode addition
-    // End GemStone addition
+    // End Geode addition
-    // GemStone added the method below
+    // Geode added the method below
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-                // GemStone changes BEGIN
+                // Geode changes BEGIN
-                // GemStone changes END
+                // Geode changes END
-    // GemStone additions
+    // Geode additions
-    // End GemStone additions
+    // End Geode additions
-            // GemStone changes BEGIN
+            // Geode changes BEGIN
-            // GemStone changes END
+            // Geode changes END
-    // GemStone change
+    // Geode change
-      // End GemStone change
+      // End Geode change
-        // GemStone change
+        // Geode change
-          // GemStone change
+          // Geode change
-            // End GemStone change
+            // End Geode change
-            // GemStone changes BEGIN
+            // Geode changes BEGIN
-            // GemStone changes END
+            // Geode changes END
-     * GemStone added the clearedEntries param and the result
+     * Geode added the clearedEntries param and the result
-          // GemStone changes BEGIN
-          boolean collectEntries = clearedEntries != null;
-          if (!collectEntries) {
-            // see if we have a map with off-heap region entries
-            for (HashEntry<K, V> he : tab) {
-              if (he != null) {
-                collectEntries = he instanceof OffHeapRegionEntry;
-                if (collectEntries) {
-                  clearedEntries = new ArrayList<HashEntry<?, ?>>();
+          // Geode changes BEGIN
+          if (clearedEntries == null) {
+            final boolean checkForGatewaySenderEvent =
+                OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
+            if (checkForGatewaySenderEvent) {
+              clearedEntries = new ArrayList<HashEntry<?, ?>>();
+            } else {
+              // see if we have a map with off-heap region entries
+              for (HashEntry<K, V> he : tab) {
+                if (he != null) {
+                  if (he instanceof OffHeapRegionEntry) {
+                    clearedEntries = new ArrayList<HashEntry<?, ?>>();
+                  }
+                  // after the first non-null entry we are done
+                  break;
-                // after the first non-null entry we are done
-                break;
-          final boolean checkForGatewaySenderEvent =
-              OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
-          final boolean skipProcessOffHeap = !collectEntries && !checkForGatewaySenderEvent;
-          if (skipProcessOffHeap) {
+          if (clearedEntries == null) {
-              if (collectEntries) {
-                clearedEntries.add(he);
-              } else {
-                for (HashEntry<K, V> p = he; p != null; p = p.getNextEntry()) {
-                  if (p instanceof RegionEntry) {
-                    // It is ok to call GatewaySenderEventImpl release without being synced
-                    // on the region entry. It will not create an orphan.
-                    GatewaySenderEventImpl.release(((RegionEntry) p).getValue()); // OFFHEAP
-                                                                                  // _getValue ok
-                  }
-                }
-              }
+              clearedEntries.add(he);
-            // GemStone changes END
+            // Geode changes END
-      return clearedEntries; // GemStone change
+      return clearedEntries; // Geode change
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-  // GemStone addition
+  // Geode addition
-        final Runnable runnable = new Runnable() {
-          public void run() {
-            for (HashEntry<?, ?> he : clearedEntries) {
-              for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
-                synchronized (p) {
-                  ((OffHeapRegionEntry) p).release();
+        Runnable runnable;
+        if (OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap()) {
+          runnable = new Runnable() {
+            public void run() {
+              for (HashEntry<?, ?> he : clearedEntries) {
+                for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
+                  if (p instanceof RegionEntry) {
+                    synchronized (p) {
+                      GatewaySenderEventImpl.release(((RegionEntry) p).getValue()); // OFFHEAP
+                    }
+                  }
-          }
-        };
+          };
+        } else {
+          runnable = new Runnable() {
+            public void run() {
+              for (HashEntry<?, ?> he : clearedEntries) {
+                for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
+                  synchronized (p) {
+                    ((OffHeapRegionEntry) p).release();
+                  }
+                }
+              }
+            }
+          };
+        }
-  // End GemStone addition
+  // End Geode addition
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-    // GemStone changed HashEntry<K, V>[] currentTable to currentSegment
+    // Geode changed HashEntry<K, V>[] currentTable to currentSegment
-      // GemStone changes BEGIN
+      // Geode changes BEGIN
-      // GemStone changes END
+      // Geode changes END
-    // GemStone added the method below
+    // Geode added the method below
-    protected K key; // GemStone change; made non-final to enable reuse
+    protected K key; // Geode change; made non-final to enable reuse
-    // GemStone change
+    // Geode change
-    // End GemStone change
+    // End Geode change
-    // GemStone change
+    // Geode change
-    // End GemStone change
+    // End Geode change

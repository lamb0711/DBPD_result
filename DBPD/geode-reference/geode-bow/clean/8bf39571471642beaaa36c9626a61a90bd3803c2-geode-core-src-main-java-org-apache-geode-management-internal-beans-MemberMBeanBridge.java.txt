Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class acts as an Bridge between MemberMBean and GemFire Cache and
- * Distributed System
+ * This class acts as an Bridge between MemberMBean and GemFire Cache and Distributed System
-  
+
-  
+
-  public static MBeanServer mbeanServer = ManagementFactory
-      .getPlatformMBeanServer();
-  
+  public static MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  
+
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  private StatsAverageLatency  listenerCallsAvgLatency;
-  
+
+  private StatsAverageLatency listenerCallsAvgLatency;
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  private  String osName = System.getProperty("os.name", "unknown");
-  
+
+  private String osName = System.getProperty("os.name", "unknown");
+
-  
+
-  
+
-  
-  
-  
+
+
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    
-    if(dm  instanceof DistributionManager){
-      DistributionManager distManager = (DistributionManager)system.getDistributionManager();
-      this.redundancyZone = distManager.getRedundancyZone(cache.getDistributedSystem().getDistributedMember());
+
+    if (dm instanceof DistributionManager) {
+      DistributionManager distManager = (DistributionManager) system.getDistributionManager();
+      this.redundancyZone =
+          distManager.getRedundancyZone(cache.getDistributedSystem().getDistributedMember());
-    
-    
+
+
-        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
+        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}",
+            e.getMessage());
-        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
+        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}",
+            e.getMessage());
-    this.osBean       =  ManagementFactory.getOperatingSystemMXBean();
+    this.osBean = ManagementFactory.getOperatingSystemMXBean();
-    
-    //Initialize all the Stats Monitors
-    this.monitor = new MBeanStatsMonitor(ManagementStrings.MEMBER_CACHE_MONITOR
-        .toLocalizedString());
+
+    // Initialize all the Stats Monitors
+    this.monitor =
+        new MBeanStatsMonitor(ManagementStrings.MEMBER_CACHE_MONITOR.toLocalizedString());
-    this.gcMonitor = new GCStatsMonitor(ManagementStrings.GC_STATS_MONITOR
-        .toLocalizedString());
-    this.vmStatsMonitor = new VMStatsMonitor(ManagementStrings.VM_STATS_MONITOR
-        .toLocalizedString());
-    
-    this.systemStatsMonitor = new MBeanStatsMonitor(ManagementStrings.SYSTEM_STATS_MONITOR
-        .toLocalizedString());
-    
-    //Initialize Proecess related informations 
-    
+    this.gcMonitor = new GCStatsMonitor(ManagementStrings.GC_STATS_MONITOR.toLocalizedString());
+    this.vmStatsMonitor =
+        new VMStatsMonitor(ManagementStrings.VM_STATS_MONITOR.toLocalizedString());
+
+    this.systemStatsMonitor =
+        new MBeanStatsMonitor(ManagementStrings.SYSTEM_STATS_MONITOR.toLocalizedString());
+
+    // Initialize Proecess related informations
+
-    
+
-    
-    
+
+
-    
+
-  
-  public MemberMBeanBridge(){
-    this.monitor = new MBeanStatsMonitor(ManagementStrings.MEMBER_CACHE_MONITOR
-        .toLocalizedString());
+
+  public MemberMBeanBridge() {
+    this.monitor =
+        new MBeanStatsMonitor(ManagementStrings.MEMBER_CACHE_MONITOR.toLocalizedString());
-    this.gcMonitor = new GCStatsMonitor(ManagementStrings.GC_STATS_MONITOR
-        .toLocalizedString());
-    this.vmStatsMonitor = new VMStatsMonitor(ManagementStrings.VM_STATS_MONITOR
-        .toLocalizedString());
-    this.systemStatsMonitor = new MBeanStatsMonitor(ManagementStrings.SYSTEM_STATS_MONITOR
-        .toLocalizedString());
-    
+    this.gcMonitor = new GCStatsMonitor(ManagementStrings.GC_STATS_MONITOR.toLocalizedString());
+    this.vmStatsMonitor =
+        new VMStatsMonitor(ManagementStrings.VM_STATS_MONITOR.toLocalizedString());
+    this.systemStatsMonitor =
+        new MBeanStatsMonitor(ManagementStrings.SYSTEM_STATS_MONITOR.toLocalizedString());
+
-    
+
-    CachePerfStats cachePerfStats = ((GemFireCacheImpl) cache)
-        .getCachePerfStats();
+    CachePerfStats cachePerfStats = ((GemFireCacheImpl) cache).getCachePerfStats();
-      DistributionStats distributionStats = (DistributionStats) system
-          .getDistributionManager().getStats();
+      DistributionStats distributionStats =
+          (DistributionStats) system.getDistributionManager().getStats();
-        systemStats = null;//@TODO once OSX stats are implemented
+        systemStats = null;// @TODO once OSX stats are implemented
-    
+
-    if((null != allocator) ) {
+    if ((null != allocator)) {
-      
-      if(null != offHeapStats) {
+
+      if (null != offHeapStats) {
-    
+
-  
+
-  
+
-  
-  public void addDiskStoreStats(DiskStoreStats stats){
+
+  public void addDiskStoreStats(DiskStoreStats stats) {
-  
+
-  
-  public void removeDiskStoreStats(DiskStoreStats stats){
+
+  public void removeDiskStoreStats(DiskStoreStats stats) {
-  
-  public void addRegion(Region region ){
-    if(region.getAttributes().getPartitionAttributes() != null){
+
+  public void addRegion(Region region) {
+    if (region.getAttributes().getPartitionAttributes() != null) {
-    
+
-    if(l.getEvictionController() != null){
+    if (l.getEvictionController() != null) {
-    
+
-    if(dr != null){
-      for(DirectoryHolder dh:dr.getDirectories()){
-          addDirectoryStats(dh.getDiskDirectoryStats());
-        }
+    if (dr != null) {
+      for (DirectoryHolder dh : dr.getDirectories()) {
+        addDirectoryStats(dh.getDiskDirectoryStats());
+    }
-  
-  public void addPartionRegionStats(PartitionedRegionStats parStats){
+
+  public void addPartionRegionStats(PartitionedRegionStats parStats) {
-  
-  public void addLRUStats(LRUStatistics lruStats){
+
+  public void addLRUStats(LRUStatistics lruStats) {
-  
-  public void addDirectoryStats(DiskDirectoryStats diskDirStats){
+
+  public void addDirectoryStats(DiskDirectoryStats diskDirStats) {
-  
-  public void removeRegion(Region region ){
-    if(region.getAttributes().getPartitionAttributes() != null){
+
+  public void removeRegion(Region region) {
+    if (region.getAttributes().getPartitionAttributes() != null) {
-    
+
-    if(l.getEvictionController() != null){
+    if (l.getEvictionController() != null) {
-    
+
-    if(dr != null){
-      for(DirectoryHolder dh:dr.getDirectories()){
+    if (dr != null) {
+      for (DirectoryHolder dh : dr.getDirectories()) {
-  
+
-  
+
-  
-  
-  public void addLockServiceStats(DLockService lock){
-    if(!lockStatsAdded){
-      DLockStats stats = (DLockStats)lock.getStats();
+
+
+  public void addLockServiceStats(DLockService lock) {
+    if (!lockStatsAdded) {
+      DLockStats stats = (DLockStats) lock.getStats();
-  
-  public void addLockServiceStats(DLockStats stats){
+
+  public void addLockServiceStats(DLockStats stats) {
- 
+
-    
-    
+
+
-    
+
-    if(samplerStats != null){
+    if (samplerStats != null) {
-  
-  public void addVMStats(){
+
+  public void addVMStats() {
-    
-    if (vmStatsContract != null && vmStatsContract instanceof VMStats50){
+
+    if (vmStatsContract != null && vmStatsContract instanceof VMStats50) {
-      
+
-      
-      //vmStatsMonitor.addStatisticsToMonitor(vm50.getVMNonHeapStats());
-      
+
+      // vmStatsMonitor.addStatisticsToMonitor(vm50.getVMNonHeapStats());
+
-        if (gcStats != null && gcStats.length > 0){
+        if (gcStats != null && gcStats.length > 0) {
-  
+
-  
+
-  
+
-  
-  public void stopMonitor(){
+
+  public void stopMonitor() {
-  
-  private void initializeStats(){
-    
+
+  private void initializeStats() {
+
-    bytesReceivedRate = new StatsRate(StatsKey.RECEIVED_BYTES,
-        StatType.LONG_TYPE, monitor);
-    bytesSentRate = new StatsRate(StatsKey.SENT_BYTES, StatType.LONG_TYPE,
-        monitor);
+    bytesReceivedRate = new StatsRate(StatsKey.RECEIVED_BYTES, StatType.LONG_TYPE, monitor);
+    bytesSentRate = new StatsRate(StatsKey.SENT_BYTES, StatType.LONG_TYPE, monitor);
-    functionExecutionRate = new StatsRate(
-        StatsKey.FUNCTION_EXECUTIONS_COMPLETED, StatType.INT_TYPE, monitor);
-    
-    getsRate = new StatsRate(
-        StatsKey.GETS, StatType.INT_TYPE, monitor);
-    
-    putAllRate =  new StatsRate(
-        StatsKey.PUT_ALLS, StatType.INT_TYPE, monitor);
-    
-    putsRate =  new StatsRate(
-        StatsKey.PUTS, StatType.INT_TYPE, monitor);
-    
-    transactionCommitsRate =  new StatsRate(
-        StatsKey.TRANSACTION_COMMITS, StatType.INT_TYPE, monitor);
-    
-    diskReadsRate =  new StatsRate(
-        StatsKey.DISK_READ_BYTES, StatType.LONG_TYPE, diskMonitor);
-    
-    diskWritesRate =  new StatsRate(
-        StatsKey.DISK_WRITEN_BYTES, StatType.LONG_TYPE, diskMonitor);
+    functionExecutionRate =
+        new StatsRate(StatsKey.FUNCTION_EXECUTIONS_COMPLETED, StatType.INT_TYPE, monitor);
-    listenerCallsAvgLatency = new StatsAverageLatency(
-        StatsKey.CACHE_LISTENER_CALLS_COMPLETED, StatType.INT_TYPE,
-        StatsKey.CACHE_LISTENR_CALL_TIME, monitor);
+    getsRate = new StatsRate(StatsKey.GETS, StatType.INT_TYPE, monitor);
-    writerCallsAvgLatency = new StatsAverageLatency(
-        StatsKey.CACHE_WRITER_CALLS_COMPLETED, StatType.INT_TYPE,
-        StatsKey.CACHE_WRITER_CALL_TIME, monitor);
-    
-    getsAvgLatency = new StatsAverageLatency(
-        StatsKey.GETS, StatType.INT_TYPE,
-        StatsKey.GET_TIME, monitor);
-    
-    putAllAvgLatency = new StatsAverageLatency(
-        StatsKey.PUT_ALLS, StatType.INT_TYPE,
+    putAllRate = new StatsRate(StatsKey.PUT_ALLS, StatType.INT_TYPE, monitor);
+
+    putsRate = new StatsRate(StatsKey.PUTS, StatType.INT_TYPE, monitor);
+
+    transactionCommitsRate =
+        new StatsRate(StatsKey.TRANSACTION_COMMITS, StatType.INT_TYPE, monitor);
+
+    diskReadsRate = new StatsRate(StatsKey.DISK_READ_BYTES, StatType.LONG_TYPE, diskMonitor);
+
+    diskWritesRate = new StatsRate(StatsKey.DISK_WRITEN_BYTES, StatType.LONG_TYPE, diskMonitor);
+
+    listenerCallsAvgLatency = new StatsAverageLatency(StatsKey.CACHE_LISTENER_CALLS_COMPLETED,
+        StatType.INT_TYPE, StatsKey.CACHE_LISTENR_CALL_TIME, monitor);
+
+    writerCallsAvgLatency = new StatsAverageLatency(StatsKey.CACHE_WRITER_CALLS_COMPLETED,
+        StatType.INT_TYPE, StatsKey.CACHE_WRITER_CALL_TIME, monitor);
+
+    getsAvgLatency =
+        new StatsAverageLatency(StatsKey.GETS, StatType.INT_TYPE, StatsKey.GET_TIME, monitor);
+
+    putAllAvgLatency = new StatsAverageLatency(StatsKey.PUT_ALLS, StatType.INT_TYPE,
-    
-    putsAvgLatency = new StatsAverageLatency(
-        StatsKey.PUTS, StatType.INT_TYPE,
-        StatsKey.PUT_TIME, monitor);
-    
-    loadsAverageLatency = new StatsAverageLatency(
-        StatsKey.LOADS_COMPLETED, StatType.INT_TYPE,
-        StatsKey.LOADS_TIME, monitor);
-    
-    netLoadsAverageLatency = new StatsAverageLatency(
-        StatsKey.NET_LOADS_COMPLETED, StatType.INT_TYPE,
-        StatsKey.NET_LOADS_TIME, monitor);
-    
-    
-    netSearchAverageLatency = new StatsAverageLatency(
-        StatsKey.NET_SEARCH_COMPLETED, StatType.INT_TYPE,
-        StatsKey.NET_SEARCH_TIME, monitor);
-    
-    transactionCommitsAvgLatency = new StatsAverageLatency(
-        StatsKey.TRANSACTION_COMMITS, StatType.INT_TYPE,
-        StatsKey.TRANSACTION_COMMIT_TIME, monitor);
-    
-    diskFlushAvgLatency = new StatsAverageLatency(
-        StatsKey.NUM_FLUSHES, StatType.INT_TYPE,
-        StatsKey.TOTAL_FLUSH_TIME, diskMonitor);
-    
-    deserializationAvgLatency = new StatsAverageLatency(
-        StatsKey.DESERIALIZATIONS, StatType.INT_TYPE,
-        StatsKey.DESERIALIZATION_TIME, monitor);
-    deserializationLatency = new StatsLatency(StatsKey.DESERIALIZATIONS,
+    putsAvgLatency =
+        new StatsAverageLatency(StatsKey.PUTS, StatType.INT_TYPE, StatsKey.PUT_TIME, monitor);
+
+    loadsAverageLatency = new StatsAverageLatency(StatsKey.LOADS_COMPLETED, StatType.INT_TYPE,
+        StatsKey.LOADS_TIME, monitor);
+
+    netLoadsAverageLatency = new StatsAverageLatency(StatsKey.NET_LOADS_COMPLETED,
+        StatType.INT_TYPE, StatsKey.NET_LOADS_TIME, monitor);
+
+
+    netSearchAverageLatency = new StatsAverageLatency(StatsKey.NET_SEARCH_COMPLETED,
+        StatType.INT_TYPE, StatsKey.NET_SEARCH_TIME, monitor);
+
+    transactionCommitsAvgLatency = new StatsAverageLatency(StatsKey.TRANSACTION_COMMITS,
+        StatType.INT_TYPE, StatsKey.TRANSACTION_COMMIT_TIME, monitor);
+
+    diskFlushAvgLatency = new StatsAverageLatency(StatsKey.NUM_FLUSHES, StatType.INT_TYPE,
+        StatsKey.TOTAL_FLUSH_TIME, diskMonitor);
+
+    deserializationAvgLatency = new StatsAverageLatency(StatsKey.DESERIALIZATIONS,
-    deserializationRate = new StatsRate(StatsKey.DESERIALIZATIONS,
-        StatType.INT_TYPE, monitor);
+    deserializationLatency = new StatsLatency(StatsKey.DESERIALIZATIONS, StatType.INT_TYPE,
+        StatsKey.DESERIALIZATION_TIME, monitor);
-    serializationAvgLatency = new StatsAverageLatency(StatsKey.SERIALIZATIONS,
-        StatType.INT_TYPE, StatsKey.SERIALIZATION_TIME, monitor);
+    deserializationRate = new StatsRate(StatsKey.DESERIALIZATIONS, StatType.INT_TYPE, monitor);
-    serializationLatency = new StatsLatency(StatsKey.SERIALIZATIONS,
-        StatType.INT_TYPE, StatsKey.SERIALIZATION_TIME, monitor);
+    serializationAvgLatency = new StatsAverageLatency(StatsKey.SERIALIZATIONS, StatType.INT_TYPE,
+        StatsKey.SERIALIZATION_TIME, monitor);
-    serializationRate = new StatsRate(StatsKey.SERIALIZATIONS,
-        StatType.INT_TYPE, monitor);
+    serializationLatency = new StatsLatency(StatsKey.SERIALIZATIONS, StatType.INT_TYPE,
+        StatsKey.SERIALIZATION_TIME, monitor);
-    pdxDeserializationAvgLatency = new StatsAverageLatency(
-        StatsKey.PDX_INSTANCE_DESERIALIZATIONS, StatType.INT_TYPE,
-        StatsKey.PDX_INSTANCE_DESERIALIZATION_TIME, monitor);
+    serializationRate = new StatsRate(StatsKey.SERIALIZATIONS, StatType.INT_TYPE, monitor);
-    pdxDeserializationRate = new StatsRate(
-        StatsKey.PDX_INSTANCE_DESERIALIZATIONS, StatType.INT_TYPE, monitor);
-    
+    pdxDeserializationAvgLatency = new StatsAverageLatency(StatsKey.PDX_INSTANCE_DESERIALIZATIONS,
+        StatType.INT_TYPE, StatsKey.PDX_INSTANCE_DESERIALIZATION_TIME, monitor);
-    lruDestroyRate = new StatsRate(
-        StatsKey.LRU_DESTROYS, StatType.LONG_TYPE, regionMonitor);
-    
-    lruEvictionRate = new StatsRate(
-        StatsKey.LRU_EVICTIONS, StatType.LONG_TYPE, regionMonitor);
+    pdxDeserializationRate =
+        new StatsRate(StatsKey.PDX_INSTANCE_DESERIALIZATIONS, StatType.INT_TYPE, monitor);
+
+
+    lruDestroyRate = new StatsRate(StatsKey.LRU_DESTROYS, StatType.LONG_TYPE, regionMonitor);
+
+    lruEvictionRate = new StatsRate(StatsKey.LRU_EVICTIONS, StatType.LONG_TYPE, regionMonitor);
-  
- 
+
+
-    long gcCount = getGCStatistic(StatsKey.VM_GC_STATS_COLLECTIONS)
-        .longValue();
-    long gcTimeMillis = getGCStatistic(
-        StatsKey.VM_GC_STATS_COLLECTION_TIME).longValue();
-    
-    //Fixed values might not be updated back by Stats monitor. Hence getting it directly
+    long gcCount = getGCStatistic(StatsKey.VM_GC_STATS_COLLECTIONS).longValue();
+    long gcTimeMillis = getGCStatistic(StatsKey.VM_GC_STATS_COLLECTION_TIME).longValue();
+
+    // Fixed values might not be updated back by Stats monitor. Hence getting it directly
-    
-    int totalThreads = getVMStatistic(StatsKey.VM_STATS_NUM_THREADS)
-        .intValue();
-    return new JVMMetrics(gcCount, gcTimeMillis, initMemory, committedMemory,
-        usedMemory, maxMemory, totalThreads);
+    int totalThreads = getVMStatistic(StatsKey.VM_STATS_NUM_THREADS).intValue();
+
+    return new JVMMetrics(gcCount, gcTimeMillis, initMemory, committedMemory, usedMemory, maxMemory,
+        totalThreads);
-   * All OS metrics are not present in
-   * java.lang.management.OperatingSystemMXBean It has to be cast to
-   * com.sun.management.OperatingSystemMXBean. To avoid the cast using dynamic
-   * call so that Java platform will take care of the details in a native
-   * manner;
+   * All OS metrics are not present in java.lang.management.OperatingSystemMXBean It has to be cast
+   * to com.sun.management.OperatingSystemMXBean. To avoid the cast using dynamic call so that Java
+   * platform will take care of the details in a native manner;
-      String arch = osBean.getArch();      
+      String arch = osBean.getArch();
-     
-      openFileDescriptorCount = getVMStatistic(
-          StatsKey.VM_STATS_OPEN_FDS).longValue();
-      processCpuTime = getVMStatistic(StatsKey.VM_PROCESS_CPU_TIME)
-          .longValue();
+
+      openFileDescriptorCount = getVMStatistic(StatsKey.VM_STATS_OPEN_FDS).longValue();
+      processCpuTime = getVMStatistic(StatsKey.VM_PROCESS_CPU_TIME).longValue();
-        maxFileDescriptorCount = (Long) mbeanServer.getAttribute(osObjectName,
-            "MaxFileDescriptorCount");
+        maxFileDescriptorCount =
+            (Long) mbeanServer.getAttribute(osObjectName, "MaxFileDescriptorCount");
-        committedVirtualMemorySize = (Long) mbeanServer.getAttribute(
-            osObjectName, "CommittedVirtualMemorySize");
+        committedVirtualMemorySize =
+            (Long) mbeanServer.getAttribute(osObjectName, "CommittedVirtualMemorySize");
-      
-      //If Linux System type exists
+
+      // If Linux System type exists
-        
+
-          totalPhysicalMemorySize = systemStat.get(
-              StatsKey.LINUX_SYSTEM_PHYSICAL_MEMORY).longValue();
+          totalPhysicalMemorySize =
+              systemStat.get(StatsKey.LINUX_SYSTEM_PHYSICAL_MEMORY).longValue();
-          freePhysicalMemorySize = systemStat.get(
-              StatsKey.LINUX_SYSTEM_FREE_MEMORY).longValue();
+          freePhysicalMemorySize = systemStat.get(StatsKey.LINUX_SYSTEM_FREE_MEMORY).longValue();
-          totalSwapSpaceSize = systemStat.get(
-              StatsKey.LINUX_SYSTEM_TOTAL_SWAP_SIZE).longValue();
+          totalSwapSpaceSize = systemStat.get(StatsKey.LINUX_SYSTEM_TOTAL_SWAP_SIZE).longValue();
-          freeSwapSpaceSize = systemStat.get(
-              StatsKey.LINUX_SYSTEM_FREE_SWAP_SIZE).longValue();
+          freeSwapSpaceSize = systemStat.get(StatsKey.LINUX_SYSTEM_FREE_SWAP_SIZE).longValue();
-      metrics = new OSMetrics(maxFileDescriptorCount, openFileDescriptorCount,
-          processCpuTime, committedVirtualMemorySize, totalPhysicalMemorySize,
-          freePhysicalMemorySize, totalSwapSpaceSize, freeSwapSpaceSize, name,
-          version, arch, availableProcessors, systemLoadAverage);
+      metrics = new OSMetrics(maxFileDescriptorCount, openFileDescriptorCount, processCpuTime,
+          committedVirtualMemorySize, totalPhysicalMemorySize, freePhysicalMemorySize,
+          totalSwapSpaceSize, freeSwapSpaceSize, name, version, arch, availableProcessors,
+          systemLoadAverage);
-      if(logger.isTraceEnabled()){
+      if (logger.isTraceEnabled()) {
-      
+
+   * 
-  
+
-   * An instruction to members with cache that they should compact their disk
-   * stores.
+   * An instruction to members with cache that they should compact their disk stores.
-   * @param includeRegionOwned
-   *          indicates whether to show the disk belonging to any particular
-   *          region
+   * @param includeRegionOwned indicates whether to show the disk belonging to any particular region
-  
+
-  public String fetchLog(int numLines){
-    
-    if(numLines > ManagementConstants.MAX_SHOW_LOG_LINES){
+  public String fetchLog(int numLines) {
+
+    if (numLines > ManagementConstants.MAX_SHOW_LOG_LINES) {
-    if(numLines == 0 || numLines < 0){
+    if (numLines == 0 || numLines < 0) {
-        childTail = BeanUtilFuncs.tailSystemLog(lwa.getChildLogFile(),numLines);
+        childTail = BeanUtilFuncs.tailSystemLog(lwa.getChildLogFile(), numLines);
-          mainTail = LocalizedStrings.TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT
-              .toLocalizedString();
+          mainTail =
+              LocalizedStrings.TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT
+                  .toLocalizedString();
-        Assert
-            .assertTrue(false,
-                "TailLogRequest/Response processed in application vm with shared logging.");
+        Assert.assertTrue(false,
+            "TailLogRequest/Response processed in application vm with shared logging.");
-      logger.warn(LocalizedMessage.create(LocalizedStrings.TailLogResponse_ERROR_OCCURRED_WHILE_READING_SYSTEM_LOG__0, e));
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.TailLogResponse_ERROR_OCCURRED_WHILE_READING_SYSTEM_LOG__0, e));
-        result.append("\n"
-            + LocalizedStrings.SystemMemberImpl_TAIL_OF_CHILD_LOG
-                .toLocalizedString() + "\n");
+        result.append(
+            "\n" + LocalizedStrings.SystemMemberImpl_TAIL_OF_CHILD_LOG.toLocalizedString() + "\n");
-   * Using async thread. As remote operation will be executed by
-   * FunctionService. Might cause problems in cleaning up function related
-   * resources. Aggregate bean DistributedSystemMBean will have to depend on
-   * GemFire messages to decide whether all the members have been shutdown or
-   * not before deciding to shut itself down
+   * Using async thread. As remote operation will be executed by FunctionService. Might cause
+   * problems in cleaning up function related resources. Aggregate bean DistributedSystemMBean will
+   * have to depend on GemFire messages to decide whether all the members have been shutdown or not
+   * before deciding to shut itself down
-   * @param targetDirPath
-   *          path of the directory where back up is to be taken
-   * @return array of DiskBackup results which might get aggregated at Managing
-   *         node
-   *         
-   * Check the validity of this mbean call.   When does it make sense to backup a single member of a gemfire system
-   * in isolation of the other members?
+   * @param targetDirPath path of the directory where back up is to be taken
+   * @return array of DiskBackup results which might get aggregated at Managing node
+   * 
+   *         Check the validity of this mbean call. When does it make sense to backup a single
+   *         member of a gemfire system in isolation of the other members?
- 
+
-      Collection<DiskStoreImpl> diskStores = cache
-          .listDiskStoresIncludingRegionOwned();
+      Collection<DiskStoreImpl> diskStores = cache.listDiskStoresIncludingRegionOwned();
-        BackupManager manager = cache.startBackup(cache.getDistributedSystem()
-            .getDistributedMember());
+        BackupManager manager =
+            cache.startBackup(cache.getDistributedSystem().getDistributedMember());
-          successfulDataStores = manager
-              .finishBackup(targetDir, null/* TODO rishi */, abort);
+          successfulDataStores = manager.finishBackup(targetDir, null/* TODO rishi */, abort);
-  
+
-  
+
-   * Gets a String describing the GemFire member's status.  A GemFire member includes, but is not limited to: Locators,
-   * Managers, Cache Servers and so on.
+   * Gets a String describing the GemFire member's status. A GemFire member includes, but is not
+   * limited to: Locators, Managers, Cache Servers and so on.
+   * 
-    //if (isLocator()) {
+    // if (isLocator()) {
-    //else if (isServer()) {
+    // else if (isServer()) {
-  
+
-   * @return true if member contains one locator. From 7.0 only locator can be
-   *         hosted in a JVM
+   * @return true if member contains one locator. From 7.0 only locator can be hosted in a JVM
-    } 
-    try{
-      boolean isManager  = service.isManager();
+    }
+    try {
+      boolean isManager = service.isManager();
-    }catch(Exception e){
+    } catch (Exception e) {
-  
+
-   * Returns true if the manager has been created.
-   * Note it does not need to be running so this
+   * Returns true if the manager has been created. Note it does not need to be running so this
+   * 
-    } 
+    }
-    } catch(Exception e) {
+    } catch (Exception e) {
-  
+
-    return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGE_KEYS_RECEIVED)
-        .intValue();
+    return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGE_KEYS_RECEIVED).intValue();
-    return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGES_INPROGRESS)
-        .intValue();
+    return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGES_INPROGRESS).intValue();
-  
+
-    return getMemberLevelStatistic(StatsKey.TOTAL_INDEX_UPDATE_TIME)
-        .longValue();
+    return getMemberLevelStatistic(StatsKey.TOTAL_INDEX_UPDATE_TIME).longValue();
-    this.instCreatesRate = createsRate.getRate(); 
+    this.instCreatesRate = createsRate.getRate();
-    return getMemberLevelStatistic(StatsKey.FUNCTION_EXECUTIONS_RUNNING)
-        .intValue();
+    return getMemberLevelStatistic(StatsKey.FUNCTION_EXECUTIONS_RUNNING).intValue();
-    return getMemberLevelStatistic(
-        StatsKey.FUNCTION_EXECUTIONS_HASRESULT_RUNNING).intValue();
+    return getMemberLevelStatistic(StatsKey.FUNCTION_EXECUTIONS_HASRESULT_RUNNING).intValue();
-    this.instPutsRate = putsRate.getRate(); 
+    this.instPutsRate = putsRate.getRate();
-  
+
-  
+
-    return getMemberLevelStatistic(StatsKey.GETS).intValue()
-        - getTotalMissCount();
+    return getMemberLevelStatistic(StatsKey.GETS).intValue() - getTotalMissCount();
-  
+
-  
+
-   * Processes the given command string using the given environment information
-   * if it's non-empty. Result returned is in a JSON format.
+   * Processes the given command string using the given environment information if it's non-empty.
+   * Result returned is in a JSON format.
-   * @param commandString
-   *          command string to be processed
-   * @param env
-   *          environment information to be used for processing the command
+   * @param commandString command string to be processed
+   * @param env environment information to be used for processing the command
-          "Command can not be processed as Command Service did not get initialized. Reason: "+commandServiceInitError);
+          "Command can not be processed as Command Service did not get initialized. Reason: "
+              + commandServiceInitError);
-    
+
-    
-    Result result = ((MemberCommandService)commandService).processCommand(commandString, env);
+
+    Result result = ((MemberCommandService) commandService).processCommand(commandString, env);
-  
+
-    
+
-  
+
-      maxFileDescriptorCount = (Long) mbeanServer.getAttribute(osObjectName,
-          "MaxFileDescriptorCount");
+      maxFileDescriptorCount =
+          (Long) mbeanServer.getAttribute(osObjectName, "MaxFileDescriptorCount");
-    if(!osName.startsWith(ManagementConstants.LINUX_SYSTEM)){
+    if (!osName.startsWith(ManagementConstants.LINUX_SYSTEM)) {
-    
-    if(null != stats) {
+
+    if (null != stats) {
-    
+
-  
+
-  
+
-    
-    if(null != stats) {
+
+    if (null != stats) {
-    
+
-  
+
-    
-    if(null != stats) {
+
+    if (null != stats) {
-    
+
-  
+
-    
-    if(null != stats) {
+
+    if (null != stats) {
-    
+
-  
+
-    
-    if(null != stats) {
+
+    if (null != stats) {
-    
-    return fragmentation;        
+
+    return fragmentation;
-  
+
-    
-    if(null != stats) {
+
+    if (null != stats) {
-    
-    return compactionTime;            
+
+    return compactionTime;
-  
+
-    
+
-    
-    if(null != offHeap) {
+
+    if (null != offHeap) {
-    return stats;    
+    return stats;
-  }   
+  }
-  }  
-  
+  }
+
-  }   
-  
+  }
+
-  }    
+  }
-  
+
-  
+
-  
+

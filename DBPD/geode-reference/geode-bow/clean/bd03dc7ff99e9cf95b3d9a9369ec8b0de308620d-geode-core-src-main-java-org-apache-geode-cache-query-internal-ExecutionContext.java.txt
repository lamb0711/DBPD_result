GEODE-7283: Store MethodAuthorizer in Context (#4179)

The MethodInvocationAuthorizer should be unique per query and should
not be changed for a particular query while it's being executed so,
starting with this commit, it is directly stored as part of the
ExecutionContext. This also prevents the creation of multiple instances
of the DefaultQueryService and the configured authorizer itself while
the intermediate result objects are being traversed during the query
evaluation.

- Added tests.
- Fixed minor warnings and spelling.
- Replaced usages of 'junit.Assert' by 'assertj'.
- The AttributeDescriptor and MethodDispatch classes do not require
  MethodInvocationAuthorizer as a constructor parameter anymore, the
  authorizer is obtained from the context, and **only** when needed.
- The MethodDispatch class does not internally store and cache the
  MethodInvocationAuthorizer instance anymore, thus allowing Geode to
  change the authorizer in runtime without needing to re-load every
  already known method (expensive due to reflection).
- The ExecutionContext uses a no-op authorizer when created from a
  client cache: authorization and authentication logic happens only on
  server side, and the authorizer will be obtained from the cluster
  configuration service directly instead of the query service when OQL
  security is fully implemented.
+import org.apache.geode.cache.query.security.MethodInvocationAuthorizer;
-   * came prior or later to another scope. It is needed to distiguish between two scopes having same
-   * nesting level relative to the top scope
+   * came prior or later to another scope. It is needed to distinguish between two scopes having
+   * same nesting level relative to the top scope
+  // Authorizer to use during the query execution.
+  private final MethodInvocationAuthorizer methodInvocationAuthorizer;
+
+  /**
+   * Returns the {@link MethodInvocationAuthorizer} that will be used, if needed, during the
+   * execution
+   * of the query associated with this context.
+   *
+   * @return the {@link MethodInvocationAuthorizer} that will be used, if needed, during the
+   *         execution of the query associated with this context.
+   */
+  public MethodInvocationAuthorizer getMethodInvocationAuthorizer() {
+    return methodInvocationAuthorizer;
+  }
+
+
+    // Authorization & authentication logic happens on server side only.
+    if (cache.isClient()) {
+      this.methodInvocationAuthorizer = DefaultQueryService.NO_OP_AUTHORIZER;
+    } else {
+      this.methodInvocationAuthorizer = cache.getQueryService().getMethodInvocationAuthorizer();
+    }

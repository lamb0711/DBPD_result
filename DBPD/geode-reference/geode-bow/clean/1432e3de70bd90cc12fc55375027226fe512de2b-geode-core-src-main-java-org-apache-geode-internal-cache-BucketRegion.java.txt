Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
+import java.util.Iterator;
-  private static final RawValue NULLVALUE = new RawValue(null);
+  public static final RawValue NULLVALUE = new RawValue(null);
-      rawValue = rawVal;
+      this.rawValue = rawVal;
-      return rawValue instanceof byte[];
+      return this.rawValue instanceof byte[];
-      return rawValue;
+      return this.rawValue;
-        DataSerializer.writeByteArray((byte[]) rawValue, out);
-      } else if (rawValue instanceof CachedDeserializable) {
-        ((CachedDeserializable) rawValue).writeValueAsByteArray(out);
-      } else if (Token.isInvalid(rawValue)) {
+        DataSerializer.writeByteArray((byte[]) this.rawValue, out);
+      } else if (this.rawValue instanceof CachedDeserializable) {
+        ((CachedDeserializable) this.rawValue).writeValueAsByteArray(out);
+      } else if (Token.isInvalid(this.rawValue)) {
-      } else if (rawValue == Token.TOMBSTONE) {
+      } else if (this.rawValue == Token.TOMBSTONE) {
-        DataSerializer.writeObjectAsByteArray(rawValue, out);
+        DataSerializer.writeObjectAsByteArray(this.rawValue, out);
-      return "RawValue(" + rawValue + ")";
+      return "RawValue(" + this.rawValue + ")";
-          byte[] src = (byte[]) rawValue;
+          byte[] src = (byte[]) this.rawValue;
-          System.arraycopy(rawValue, 0, dest, 0, dest.length);
+          System.arraycopy(this.rawValue, 0, dest, 0, dest.length);
-          return rawValue;
+          return this.rawValue;
-      } else if (rawValue instanceof CachedDeserializable) {
+      } else if (this.rawValue instanceof CachedDeserializable) {
-          return ((CachedDeserializable) rawValue).getDeserializedWritableCopy(null, null);
+          return ((CachedDeserializable) this.rawValue).getDeserializedWritableCopy(null, null);
-          return ((CachedDeserializable) rawValue).getDeserializedForReading();
+          return ((CachedDeserializable) this.rawValue).getDeserializedForReading();
-      } else if (Token.isInvalid(rawValue)) {
+      } else if (Token.isInvalid(this.rawValue)) {
-          return CopyHelper.copy(rawValue);
+          return CopyHelper.copy(this.rawValue);
-          return rawValue;
+          return this.rawValue;
+  private static final long serialVersionUID = 1L;
+
-  private final Map<Object, ExpiryTask> pendingSecondaryExpires = new HashMap<>();
+  private final Map<Object, ExpiryTask> pendingSecondaryExpires = new HashMap<Object, ExpiryTask>();
-  private final HashMap<Object, LockObject> allKeysMap = new HashMap<>();
+  public HashMap allKeysMap = new HashMap();
-  AtomicLong5 getEventSeqNum() {
+  public AtomicLong5 getEventSeqNum() {
-    redundancy = internalRegionArgs.getPartitionedRegionBucketRedundancy();
-    partitionedRegion = internalRegionArgs.getPartitionedRegion();
+    this.redundancy = internalRegionArgs.getPartitionedRegionBucketRedundancy();
+    this.partitionedRegion = internalRegionArgs.getPartitionedRegion();
-    if (partitionedRegion.isShadowPR() && partitionedRegion.getColocatedWith() != null) {
-      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion);
+    if (this.partitionedRegion.isShadowPR() && this.partitionedRegion.getColocatedWith() != null) {
+      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(this.partitionedRegion);
-    if (partitionedRegion.getColocatedWith() == null) {
-      eventSeqNum = new AtomicLong5(getId());
+    if (this.partitionedRegion.getColocatedWith() == null) {
+      this.eventSeqNum = new AtomicLong5(getId());
-      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion);
+      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(this.partitionedRegion);
-            partitionedRegion.getFullPath(), getId());
+            this.partitionedRegion.getFullPath(), getId());
-      eventSeqNum = parentBucket.eventSeqNum;
+      this.eventSeqNum = parentBucket.eventSeqNum;
-    createRegionReplyProcessor = processor;
+    this.createRegionReplyProcessor = processor;
-    if (createRegionReplyProcessor != null) {
+    if (this.createRegionReplyProcessor != null) {
-          createRegionReplyProcessor.getEventState(provider);
+          this.createRegionReplyProcessor.getEventState(provider);
-      createRegionReplyProcessor = null;
+      this.createRegionReplyProcessor = null;
-    return getFilterProfile() != null;
+    if (getFilterProfile() != null) {
+      return true;
+    }
+    return false;
-  LockObject searchAndLock(Object[] keys) {
+  LockObject searchAndLock(Object keys[]) {
-      for (Object key : keys) {
-        if (allKeysMap.containsKey(key)) {
-          foundLock = allKeysMap.get(key);
+      for (int i = 0; i < keys.length; i++) {
+        if (allKeysMap.containsKey(keys[i])) {
+          foundLock = (LockObject) allKeysMap.get(keys[i]);
-            logger.debug("LockKeys: found key: {}:{}", key, foundLock.lockedTimeStamp);
+            logger.debug("LockKeys: found key: {}:{}", keys[i], foundLock.lockedTimeStamp);
-        for (Object key : keys) {
+        for (int i = 0; i < keys.length; i++) {
-              new LockObject(key, isDebugEnabled ? System.currentTimeMillis() : 0);
-          allKeysMap.put(key, lockValue);
+              new LockObject(keys[i], isDebugEnabled ? System.currentTimeMillis() : 0);
+          allKeysMap.put(keys[i], lockValue);
-            logger.debug("LockKeys: add key: {}:{}", key, lockValue.lockedTimeStamp);
+            logger.debug("LockKeys: add key: {}:{}", keys[i], lockValue.lockedTimeStamp);
-  public void removeAndNotifyKeys(Object[] keys) {
+  public void removeAndNotifyKeys(Object keys[]) {
-      for (Object key : keys) {
-        LockObject lockValue = allKeysMap.remove(key);
+      for (int i = 0; i < keys.length; i++) {
+        LockObject lockValue = (LockObject) allKeysMap.remove(keys[i]);
-              logger.trace("LockKeys: remove key {}, notifyAll for {}. It waited {}", key,
+              logger.trace("LockKeys: remove key {}, notifyAll for {}. It waited {}", keys[i],
-  public boolean waitUntilLocked(Object[] keys) {
+  public boolean waitUntilLocked(Object keys[]) {
-      if (partitionedRegion.isParallelWanEnabled()) {
+      if (this.partitionedRegion.isParallelWanEnabled()) {
-        RegionEntry oldEntry = entries.basicPut(event, lastModified, ifNew, ifOld,
+        RegionEntry oldEntry = this.entries.basicPut(event, lastModified, ifNew, ifOld,
-  long generateTailKey() {
-    long key = eventSeqNum.addAndGet(partitionedRegion.getTotalNumberOfBuckets());
+  public long generateTailKey() {
+    long key = this.eventSeqNum.addAndGet(this.partitionedRegion.getTotalNumberOfBuckets());
-          eventSeqNum.get());
+          this.eventSeqNum.get());
-    if (eventSeqNum == null) {
+    if (this.eventSeqNum == null) {
-        long key = eventSeqNum.addAndGet(partitionedRegion.getTotalNumberOfBuckets());
+        long key = this.eventSeqNum.addAndGet(this.partitionedRegion.getTotalNumberOfBuckets());
-              eventSeqNum.get());
+              this.eventSeqNum.get());
-        Atomics.setIfGreater(eventSeqNum, event.getTailKey());
+        Atomics.setIfGreater(this.eventSeqNum, event.getTailKey());
-  void updateEventSeqNum(long l) {
-    Atomics.setIfGreater(eventSeqNum, l);
+  public void updateEventSeqNum(long l) {
+    Atomics.setIfGreater(this.eventSeqNum, l);
-          event.getPutAllOperation().addEntry(event, getId());
+          event.getPutAllOperation().addEntry(event, this.getId());
-            logger.debug("sent update operation : for region  : {}: with event: {}", getName(),
+            logger.debug("sent update operation : for region  : {}: with event: {}", this.getName(),
-      if (partitionedRegion.getDataStore().hasClientInterest(event)) {
+      if (this.partitionedRegion.getDataStore().hasClientInterest(event)) {
-              logger.debug("generated version tag {} in region {}", v, getName());
+              logger.debug("generated version tag {} in region {}", v, this.getName());
-          long start = partitionedRegion.getPrStats().startSendReplication();
+          long start = this.partitionedRegion.getPrStats().startSendReplication();
-            partitionedRegion.getPrStats().endSendReplication(start);
+            this.partitionedRegion.getPrStats().endSendReplication(start);
-      return super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
+      long lastModifiedTime =
+          super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
+      return lastModifiedTime;
-      event.setRegion(partitionedRegion);
-      partitionedRegion.notifyGatewaySender(operation, event);
+      event.setRegion(this.partitionedRegion);
+      this.partitionedRegion.notifyGatewaySender(operation, event);
-      partitionedRegion.checkReadiness();
+      this.partitionedRegion.checkReadiness();
-    Object[] keys = new Object[1];
+    Object keys[] = new Object[1];
-            entries.invalidate(event, invokeCallbacks, forceNewEntry, forceCallbacks);
+            this.entries.invalidate(event, invokeCallbacks, forceNewEntry, forceCallbacks);
+        return;
+        return;
-            logger.debug("generated version tag {} in region {}", v, getName());
+            logger.debug("generated version tag {} in region {}", v, this.getName());
-    event.region = partitionedRegion;
+    event.region = this.partitionedRegion;
-    return getConcurrencyChecksEnabled()
+    return this.getConcurrencyChecksEnabled()
-    } catch (PrimaryBucketException ignored) {
+      return;
+    } catch (PrimaryBucketException e) {
+      return;
+    ExpiryTask task = expiryTask;
-        synchronized (pendingSecondaryExpires) {
-          if (expiryTask.isPending()) {
-            Object key = expiryTask.getKey();
+        synchronized (this.pendingSecondaryExpires) {
+          if (task.isPending()) {
+            Object key = task.getKey();
-              pendingSecondaryExpires.put(key, expiryTask);
+              this.pendingSecondaryExpires.put(key, task);
-        super.performExpiryTimeout(expiryTask);
+        super.performExpiryTimeout(task);
-  private boolean isEntryEvictDestroyEnabled() {
+  protected boolean isEntryEvictDestroyEnabled() {
-  void processPendingSecondaryExpires() {
+  protected void processPendingSecondaryExpires() {
-      synchronized (pendingSecondaryExpires) {
-        if (pendingSecondaryExpires.isEmpty()) {
+      synchronized (this.pendingSecondaryExpires) {
+        if (this.pendingSecondaryExpires.isEmpty()) {
-        tasks = new ExpiryTask[pendingSecondaryExpires.size()];
-        tasks = pendingSecondaryExpires.values().toArray(tasks);
-        pendingSecondaryExpires.clear();
+        tasks = new ExpiryTask[this.pendingSecondaryExpires.size()];
+        tasks = this.pendingSecondaryExpires.values().toArray(tasks);
+        this.pendingSecondaryExpires.clear();
-        if (isCacheClosing() || isClosed() || isDestroyed) {
+        if (isCacheClosing() || isClosed() || this.isDestroyed) {
-        for (ExpiryTask task : tasks) {
+        for (int i = 0; i < tasks.length; i++) {
-              logger.debug("{} fired at {}", task, System.currentTimeMillis());
+              logger.debug("{} fired at {}", tasks[i], System.currentTimeMillis());
-            task.basicPerformTimeout(true);
+            tasks[i].basicPerformTimeout(true);
-      } catch (RegionDestroyedException ignored) {
+      } catch (RegionDestroyedException re) {
-      } catch (CancelException ignored) {
+      } catch (CancelException ex) {
-      if (partitionedRegion.isParallelWanEnabled()) {
+      if (this.partitionedRegion.isParallelWanEnabled()) {
+        return;
+        return;
-          event.getRemoveAllOperation().addEntry(event, getId());
+          event.getRemoveAllOperation().addEntry(event, this.getId());
-            logger.debug("generated version tag {} in region {}", v, getName());
+            logger.debug("generated version tag {} in region {}", v, this.getName());
-          entries.updateEntryVersion(event);
+          this.entries.updateEntryVersion(event);
+        return;
-    return redundancy;
+    return this.redundancy;
-        String.format("This should never be called on %s", getClass()));
+        String.format("This should never be called on %s",
+            getClass()));
-    return isBucketDestroyed() || (partitionedRegion != null
-        && partitionedRegion.isLocallyDestroyed && !isInDestroyingThread());
+    return isBucketDestroyed() || (this.partitionedRegion != null
+        && this.partitionedRegion.isLocallyDestroyed && !isInDestroyingThread());
-    return partitionedRegion;
+    return this.partitionedRegion;
-    return partitionedRegion.locallyDestroyingThread == Thread.currentThread();
+    return this.partitionedRegion.locallyDestroyingThread == Thread.currentThread();
-    bp.isInitializing = getInitializationLatchAfterGetInitialImage().getCount() > 0;
+    bp.isInitializing = this.getInitializationLatchAfterGetInitialImage().getCount() > 0;
-  boolean isPartitionedRegionOpen() {
-    return !partitionedRegion.isLocallyDestroyed && !partitionedRegion.isClosed
-        && !partitionedRegion.isDestroyed();
+  public boolean isPartitionedRegionOpen() {
+    return !this.partitionedRegion.isLocallyDestroyed && !this.partitionedRegion.isClosed
+        && !this.partitionedRegion.isDestroyed();
+   * @throws IOException if there is a serialization problem see
+   *         LocalRegion#getDeserializedValue(RegionEntry, KeyInfo, boolean, boolean, boolean,
+   *         EntryEventImpl, boolean, boolean, boolean)
-      throws EntryNotFoundException {
-    RegionEntry re;
-    re = entries.getEntry(key);
+      throws EntryNotFoundException, IOException {
+    RegionEntry re = null;
+    re = this.entries.getEntry(key);
-    Object v;
+    Object v = null;
-      handleDiskAccessException(dae);
+      this.handleDiskAccessException(dae);
-      boolean isCreate;
+      RawValue valueBytes = NULLVALUE;
+      boolean isCreate = false;
-    return "BucketRegion" + "[path='" + getFullPath()
-        + ";serial=" + getSerialNumber() + ";primary="
-        + getBucketAdvisor().getProxyBucketRegion().isPrimary() + "]";
+    return new StringBuilder().append("BucketRegion").append("[path='").append(getFullPath())
+        .append(";serial=").append(getSerialNumber()).append(";primary=")
+        .append(getBucketAdvisor().getProxyBucketRegion().isPrimary()).append("]").toString();
-    distAdvisor.removeMembershipListener(advisorListener);
+    this.distAdvisor.removeMembershipListener(this.advisorListener);
-  void removeFromPeersAdvisors(boolean rebalance) {
+  public void removeFromPeersAdvisors(boolean rebalance) {
-  private EntryEventImpl createEventForPR(EntryEventImpl sourceEvent) {
+  EntryEventImpl createEventForPR(EntryEventImpl sourceEvent) {
-      e2.setRegion(partitionedRegion);
+      e2.setRegion(this.partitionedRegion);
-      DistributedMember dm = getDistributionManager().getDistributionManagerId();
+      DistributedMember dm = this.getDistributionManager().getDistributionManagerId();
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-      partitionedRegion.invokeTXCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent);
+      this.partitionedRegion.invokeTXCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false);
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      partitionedRegion.invokeDestroyCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent, false);
+      this.partitionedRegion.invokeDestroyCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false, false);
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      partitionedRegion.invokeInvalidateCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent);
+      this.partitionedRegion.invokeInvalidateCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false);
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      partitionedRegion.invokePutCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent, false);
+      this.partitionedRegion.invokePutCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false, false);
-   * perform adjunct messaging for the given operation
+   * perform adjunct messaging for the given operation and return a set of members that should be
+   * attached to the operation's reply processor (if any)
+   * @return the set of failed recipients
-  void performAdjunctMessaging(EntryEventImpl event, Set cacheOpRecipients,
-      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
-      DirectReplyProcessor processor,
+  protected Set performAdjunctMessaging(EntryEventImpl event, Set cacheOpRecipients,
+      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo, DirectReplyProcessor processor,
+    Set failures = Collections.emptySet();
-      msg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
+      msg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
-      msg.relayToListeners(cacheOpRecipients, adjunctRecipients, filterRoutingInfo,
-          event, partitionedRegion, processor);
+      failures = msg.relayToListeners(cacheOpRecipients, adjunctRecipients, filterRoutingInfo,
+          event, this.partitionedRegion, processor);
-        PutMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, partitionedRegion, event, op.isCreate(), !op.isCreate(),
+        failures = PutMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, this.partitionedRegion, event, op.isCreate(), !op.isCreate(),
-        DestroyMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, partitionedRegion, event, processor);
+        failures = DestroyMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, this.partitionedRegion, event, processor);
-        InvalidateMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, partitionedRegion, event, processor);
+        failures = InvalidateMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, this.partitionedRegion, event, processor);
+      } else {
+        failures = adjunctRecipients;
+    return failures;
-    if (partitionedRegion.getSystem().getConfig().getDeltaPropagation()
+    if (this.partitionedRegion.getSystem().getConfig().getDeltaPropagation()
-          partitionedRegion.getCachePerfStats().endDeltaPrepared(start);
+          this.partitionedRegion.getCachePerfStats().endDeltaPrepared(start);
+   * @return the set of failed recipients
-  void performPutAllAdjunctMessaging(DistributedPutAllOperation dpao, Set cacheOpRecipients,
-      Set<InternalDistributedMember> adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
-      DirectReplyProcessor processor) {
+  public Set performPutAllAdjunctMessaging(DistributedPutAllOperation dpao, Set cacheOpRecipients,
+      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo, DirectReplyProcessor processor) {
+    // create a PutAllPRMessage out of PutAllMessage to send to adjunct nodes
-    prMsg.initMessage(partitionedRegion, adjunctRecipients, true, processor);
-    prMsg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
-    partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+    prMsg.initMessage(this.partitionedRegion, adjunctRecipients, true, processor);
+    prMsg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
+
+    // find members who have clients subscribed to this event and add them
+    // to the recipients list. Also determine if there are any FilterInfo
+    // routing tables for any of the receivers
+    // boolean anyWithRouting = false;
+    Set recipients = null;
+    Set membersWithRouting = filterRoutingInfo.getMembers();
+    for (Iterator it = membersWithRouting.iterator(); it.hasNext();) {
+      Object mbr = it.next();
+      if (!cacheOpRecipients.contains(mbr)) {
+        // anyWithRouting = true;
+        if (!adjunctRecipients.contains(mbr)) {
+          if (recipients == null) {
+            recipients = new HashSet();
+            recipients.add(mbr);
+          }
+        }
+      }
+    }
+    if (recipients == null) {
+      recipients = adjunctRecipients;
+    } else {
+      recipients.addAll(adjunctRecipients);
+    }
+
+    // Set failures = Collections.EMPTY_SET;
+
+    // if (!anyWithRouting) {
+    Set failures = this.partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+
+    return failures;
-  void performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,
-      Set cacheOpRecipients, Set<InternalDistributedMember> adjunctRecipients,
-      FilterRoutingInfo filterRoutingInfo,
+  public Set performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,
+      Set cacheOpRecipients, Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
-    prMsg.initMessage(partitionedRegion, adjunctRecipients, true, processor);
-    prMsg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
-    partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+    prMsg.initMessage(this.partitionedRegion, adjunctRecipients, true, processor);
+    prMsg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
+
+    // find members who have clients subscribed to this event and add them
+    // to the recipients list. Also determine if there are any FilterInfo
+    // routing tables for any of the receivers
+    Set recipients = null;
+    Set membersWithRouting = filterRoutingInfo.getMembers();
+    for (Iterator it = membersWithRouting.iterator(); it.hasNext();) {
+      Object mbr = it.next();
+      if (!cacheOpRecipients.contains(mbr)) {
+        // anyWithRouting = true;
+        if (!adjunctRecipients.contains(mbr)) {
+          if (recipients == null) {
+            recipients = new HashSet();
+            recipients.add(mbr);
+          }
+        }
+      }
+    }
+    if (recipients == null) {
+      recipients = adjunctRecipients;
+    } else {
+      recipients.addAll(adjunctRecipients);
+    }
+
+    Set failures = this.partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+    return failures;
-  protected Set<InternalDistributedMember> getAdjunctReceivers(EntryEventImpl event,
-      Set<InternalDistributedMember> cacheOpReceivers, Set<InternalDistributedMember> twoMessages,
+  protected Set getAdjunctReceivers(EntryEventImpl event, Set cacheOpReceivers, Set twoMessages,
-      Set<InternalDistributedMember> r =
-          partitionedRegion.getRegionAdvisor().adviseRequiresNotification();
-      r.removeAll(cacheOpReceivers);
+      Set r = this.partitionedRegion.getRegionAdvisor().adviseRequiresNotification(event);
+
+      if (r.size() > 0) {
+        r.removeAll(cacheOpReceivers);
+      }
-              r = new HashSet<>();
+              r = new HashSet();
-      event.setRegion(partitionedRegion);
-      partitionedRegion.cacheWriteBeforePut(event, netWriteRecipients, localWriter,
+      event.setRegion(this.partitionedRegion);
+      this.partitionedRegion.cacheWriteBeforePut(event, netWriteRecipients, localWriter,
+    boolean ret = false;
-      event.setRegion(partitionedRegion);
-      return partitionedRegion.cacheWriteBeforeDestroy(event, expectedOldValue);
+      event.setRegion(this.partitionedRegion);
+      ret = this.partitionedRegion.cacheWriteBeforeDestroy(event, expectedOldValue);
+    return ret;
+    // return super.cacheWriteBeforeDestroy(event);
-    return partitionedRegion.basicGetWriter();
+    return this.partitionedRegion.basicGetWriter();
-  public Set<InternalDistributedMember> getBucketOwners() {
+  public Set getBucketOwners() {
-  void updateCounter(long delta) {
+  public void updateCounter(long delta) {
-      counter.getAndAdd(delta);
+      this.counter.getAndAdd(delta);
-    if (counter.get() != 0) {
-      counter.set(0);
+    if (this.counter.get() != 0) {
+      this.counter.set(0);
-    if (limit == null) {
+    if (this.limit == null) {
-  private static int calcMemSize(Object value) {
+  static int calcMemSize(Object value) {
-    final PartitionedRegionDataStore prDs = partitionedRegion.getDataStore();
+    final PartitionedRegionDataStore prDs = this.partitionedRegion.getDataStore();
-    if (isDestroyed || isDestroyingDiskRegion) {
+    if (this.isDestroyed || this.isDestroyingDiskRegion) {
-      oldMemValue = bytesInMemory.getAndSet(BUCKET_DESTROYED);
+      oldMemValue = this.bytesInMemory.getAndSet(BUCKET_DESTROYED);
-    } else if (!isInitialized()) {
+    } else if (!this.isInitialized()) {
-      oldMemValue = bytesInMemory.getAndSet(0);
+      oldMemValue = this.bytesInMemory.getAndSet(0);
-      partitionedRegion.getPrStats().incDataStoreEntryCount(-sizeBeforeClear);
+      this.partitionedRegion.getPrStats().incDataStoreEntryCount(-sizeBeforeClear);
-    partitionedRegion.getPrStats().incDataStoreEntryCount(1);
+    this.partitionedRegion.getPrStats().incDataStoreEntryCount(1);
-    partitionedRegion.getPrStats().incDataStoreEntryCount(-1);
+    this.partitionedRegion.getPrStats().incDataStoreEntryCount(-1);
-    updateBucket2Size(oldSize, oldSize, SizeOp.EVICT);
-    return oldSize;
+    int newDiskSize = oldSize;
+    updateBucket2Size(oldSize, newDiskSize, SizeOp.EVICT);
+    return newDiskSize;
-    long result = bytesInMemory.get();
+    long result = this.bytesInMemory.get();
-    long result = bytesInMemory.get();
+    long result = this.bytesInMemory.get();
-  void preDestroyBucket(int bucketId) {}
+  public void preDestroyBucket(int bucketId) {}
-    preDestroyBucket(getId());
+    this.preDestroyBucket(this.getId());
-  void invokePartitionListenerAfterBucketRemoved() {
+  protected void invokePartitionListenerAfterBucketRemoved() {
-    for (PartitionListener listener : partitionListeners) {
+    for (int i = 0; i < partitionListeners.length; i++) {
+      PartitionListener listener = partitionListeners[i];
-  void invokePartitionListenerAfterBucketCreated() {
+  protected void invokePartitionListenerAfterBucketCreated() {
-    for (PartitionListener listener : partitionListeners) {
+    for (int i = 0; i < partitionListeners.length; i++) {
+      PartitionListener listener = partitionListeners[i];
-  private void updateBucket2Size(int oldSize, int newSize, SizeOp op) {
+  void updateBucket2Size(int oldSize, int newSize, SizeOp op) {
-  private void updateBucketMemoryStats(final int memoryDelta) {
+  void updateBucketMemoryStats(final int memoryDelta) {
-    final PartitionedRegionDataStore prDS = partitionedRegion.getDataStore();
+    final PartitionedRegionDataStore prDS = this.partitionedRegion.getDataStore();
-    return numOverflowOnDisk.get();
+    return this.numOverflowOnDisk.get();
-    return numOverflowBytesOnDisk.get();
+    return this.numOverflowBytesOnDisk.get();
-    return numEntriesInVM.get();
+    return this.numEntriesInVM.get();
-    numOverflowOnDisk.addAndGet(delta);
+    this.numOverflowOnDisk.addAndGet(delta);
-    numOverflowBytesOnDisk.addAndGet(delta);
+    this.numOverflowBytesOnDisk.addAndGet(delta);
-    numEntriesInVM.addAndGet(delta);
+    this.numEntriesInVM.addAndGet(delta);
-    evictions.getAndAdd(1);
+    this.evictions.getAndAdd(1);
-    return evictions.get();
+    return this.evictions.get();
-    EvictionAttributes ea = getAttributes().getEvictionAttributes();
+    EvictionAttributes ea = this.getAttributes().getEvictionAttributes();
-    return action.isLocalDestroy() ? getRegionMap().sizeInVM() : (int) getNumEntriesInVM();
+    int size =
+        action.isLocalDestroy() ? this.getRegionMap().sizeInVM() : (int) this.getNumEntriesInVM();
+    return size;
-    return partitionedRegion.getFilterProfile();
+    return this.partitionedRegion.getFilterProfile();
-    partitionedRegion.setCloningEnabled(isCloningEnabled);
+    this.partitionedRegion.setCloningEnabled(isCloningEnabled);
-    return partitionedRegion.getCloningEnabled();
+    return this.partitionedRegion.getCloningEnabled();
-  void beforeReleasingPrimaryLockDuringDemotion() {}
+  public void beforeReleasingPrimaryLockDuringDemotion() {}
+  public boolean areSecondariesPingable() {
+
+    Set<InternalDistributedMember> hostingservers =
+        this.partitionedRegion.getRegionAdvisor().getBucketOwners(this.getId());
+    hostingservers.remove(cache.getDistributedSystem().getDistributedMember());
+
+    if (cache.getLogger().fineEnabled())
+      cache.getLogger()
+          .fine("Pinging secondaries of bucket " + this.getId() + " on servers " + hostingservers);
+
+    if (hostingservers.size() == 0)
+      return true;
+
+    return ServerPingMessage.send(cache, hostingservers);
+
+  }
+
-    DiskRegion dr = getDiskRegion();
+    DiskRegion dr = this.getDiskRegion();
-    return getPartitionedRegion().getFullPath();
+    return this.getPartitionedRegion().getFullPath();
-    entries.close(this);
+    this.entries.close(this);
-    return entries.clear(rvv, this);
+    return this.entries.clear(rvv, this);

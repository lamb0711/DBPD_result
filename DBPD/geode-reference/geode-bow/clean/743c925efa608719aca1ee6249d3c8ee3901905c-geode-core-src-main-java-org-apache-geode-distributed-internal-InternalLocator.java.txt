Revert GEODE-2644 because offline diskstore commands generate info level logs

GFSH forks the offline diskstore commands in a JVM using log4j2-cli.xml
which sets the log level to WARN. However, the forked JVM creates a
Cache which then starts generating info level statements to STDOUT.

Revert "GEODE-2644: Remove log level from MonitorQueryUnderContentionBenchmark"
This reverts commit 6691d310e1263966991e584f712156d919dabecf.

Revert "GEODE-2644: Update session state caching dependencies for logging"
This reverts commit 688f58a4a75cc1297faa1dda201b971346c3a9fe.

Revert "GEODE-5637: Fix flaky SingleHopClientExecutorWithLoggingIntegrationTest"
This reverts commit 0a8f3dffa1ebaa618fafecc15bbc92ba8ba83696.

Revert "GEODE-2644: Make LogWriterAppender optional and support log4j2.xml"
This reverts commit 591f3f7840ce38c6100bff2040f396ad2469175e.

Revert "GEODE-2644: Expand DistributedSystemMXBean tests"
This reverts commit cd2bba13e2fb7e79f7634053a6c612050b328e11.

Revert "GEODE-2644: Make AlertAppender optional and support log4j2.xml"
This reverts commit 02c3cae1d38098259ff6aa4635c6e74f795bdc50.

Revert "GEODE-2644: Add LogConfig and StatisticsConfig for logging"
This reverts commit a77c94b349b3ed7fc873fc29f6852f9936843790.

Revert "GEODE-2644: Add AlertingTest JUnit Category"
This reverts commit 731cd2a7d35b086d34f8bbcb94a83c40739ae8ee.

Revert "GEODE-2644: Add LogFileAssert and LogLevelAssert assertions"
This reverts commit 5e61da5301469cdbd71ac186573f56c38e9a6cf0.

Revert "GEODE-2644: Cleanup logging related files"
This reverts commit 763e4177f201eff9b140654e6858152a1a184b8c.

Revert "GEODE-2644: Define interfaces for new Log4j2 Appenders"
This reverts commit efd8a14027195b6dae1dd3e4d53a33696ed318bb.

-import java.util.Set;
-import org.apache.geode.internal.logging.LogConfig;
-import org.apache.geode.internal.logging.LogConfigListener;
-import org.apache.geode.internal.logging.LogConfigSupplier;
-import org.apache.geode.internal.logging.LoggingSession;
-import org.apache.geode.internal.logging.NullLoggingSession;
+import org.apache.geode.internal.logging.log4j.LogWriterAppenders;
-import org.apache.geode.internal.statistics.StatisticsConfig;
-public class InternalLocator extends Locator implements ConnectListener, LogConfigSupplier {
+public class InternalLocator extends Locator implements ConnectListener {
-  private final LoggingSession loggingSession;
-
-  private final Set<LogConfigListener> logConfigListeners = new HashSet<>();
-
-      locator.loggingSession.stopSession();
-      locator.loggingSession.shutdown();
+      LogWriterAppenders.stop(LogWriterAppenders.Identifier.MAIN);
+      LogWriterAppenders.stop(LogWriterAppenders.Identifier.SECURITY);
+      LogWriterAppenders.destroy(LogWriterAppenders.Identifier.MAIN);
+      LogWriterAppenders.destroy(LogWriterAppenders.Identifier.SECURITY);
-   * @param loggingSession the LoggingSession to use, may be a NullLoggingSession which does nothing
-  public static InternalLocator createLocator(int port, LoggingSession loggingSession, File logFile,
-      InternalLogWriter logger,
+  public static InternalLocator createLocator(int port, File logFile, InternalLogWriter logger,
-          new InternalLocator(port, loggingSession, logFile, logger, securityLogger, bindAddress,
+          new InternalLocator(port, logFile, logger, securityLogger, bindAddress,
-      // if startDistributedSystem is true then Locator uses a NullLoggingSession (does nothing)
-      LoggingSession loggingSession =
-          startDistributedSystem ? NullLoggingSession.create() : LoggingSession.create();
-
-      newLocator = createLocator(port, loggingSession, logFile, logger, securityLogger, bindAddress,
+      newLocator = createLocator(port, logFile, logger, securityLogger, bindAddress,
-      loggingSession.createSession(newLocator);
-      loggingSession.startSession();
-
-   * @param logFile the file that log messages should be written to
+   * @param logF the file that log messages should be written to
-  private InternalLocator(int port, LoggingSession loggingSession, File logFile,
-      InternalLogWriter logWriter, InternalLogWriter securityLogWriter,
+  private InternalLocator(int port, File logF, InternalLogWriter logWriter,
+      // LOG: 3 non-null sources: GemFireDistributionLocator, InternalDistributedSystem,
+      // LocatorLauncher
+      InternalLogWriter securityLogWriter,
+      // LOG: 1 non-null source: GemFireDistributionLocator(same instance as logWriter),
+      // InternalDistributedSystem
-    this.logFile = logFile;
+    this.logFile = logF;
-    if (loggingSession == null) {
-      throw new Error("LoggingSession must not be null");
-    } else {
-      this.loggingSession = loggingSession;
+    // LOG: create LogWriterAppenders (these are closed at shutdown)
+    final boolean hasLogFile =
+        this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
+    final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null
+        && !this.config.getSecurityLogFile().equals(new File(""));
+    LogService.configureLoggers(hasLogFile, hasSecurityLogFile);
+    if (hasLogFile || hasSecurityLogFile) {
+
+      if (hasLogFile) {
+        // if log-file then create logWriterAppender
+        LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, true, false,
+            this.config, !startDistributedSystem);
+      }
+
+      if (hasSecurityLogFile) {
+        // if security-log-file then create securityLogWriterAppender
+        LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.SECURITY, true, false,
+            this.config, false);
+      }
+      // do not create a LogWriterAppender for security -- let it go through to logWriterAppender
-      logWriter = LogWriterFactory.createLogWriterLogger(this.config, false);
+      logWriter = LogWriterFactory.createLogWriterLogger(false, false, this.config, false);
-      securityLogWriter = LogWriterFactory.createLogWriterLogger(this.config, true);
+      securityLogWriter = LogWriterFactory.createLogWriterLogger(false, true, this.config, false);
+      logWriter.setLogWriterLevel(this.config.getSecurityLogLevel());
-  @Override
-  public LogConfig getLogConfig() {
-    return config;
-  }
-
-  @Override
-  public StatisticsConfig getStatisticsConfig() {
-    return config;
-  }
-
-  @Override
-  public void addLogConfigListener(LogConfigListener logConfigListener) {
-    logConfigListeners.add(logConfigListener);
-  }
-
-  @Override
-  public void removeLogConfigListener(LogConfigListener logConfigListener) {
-    logConfigListeners.remove(logConfigListener);
-  }
-
-  /**
-   * Apparently nothing provides RuntimeDistributionConfigImpl behavior in a stand-alone locator
-   * (without DS), so there are currently no callers of {@code logConfigChanged()}. Keep it?
-   */
-  @SuppressWarnings("unused")
-  void logConfigChanged() {
-    for (LogConfigListener listener : logConfigListeners) {
-      listener.configChanged();
-    }
-  }
-

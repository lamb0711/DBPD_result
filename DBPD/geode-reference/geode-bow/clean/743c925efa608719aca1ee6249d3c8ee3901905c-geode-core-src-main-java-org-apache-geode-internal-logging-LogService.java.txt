Revert GEODE-2644 because offline diskstore commands generate info level logs

GFSH forks the offline diskstore commands in a JVM using log4j2-cli.xml
which sets the log level to WARN. However, the forked JVM creates a
Cache which then starts generating info level statements to STDOUT.

Revert "GEODE-2644: Remove log level from MonitorQueryUnderContentionBenchmark"
This reverts commit 6691d310e1263966991e584f712156d919dabecf.

Revert "GEODE-2644: Update session state caching dependencies for logging"
This reverts commit 688f58a4a75cc1297faa1dda201b971346c3a9fe.

Revert "GEODE-5637: Fix flaky SingleHopClientExecutorWithLoggingIntegrationTest"
This reverts commit 0a8f3dffa1ebaa618fafecc15bbc92ba8ba83696.

Revert "GEODE-2644: Make LogWriterAppender optional and support log4j2.xml"
This reverts commit 591f3f7840ce38c6100bff2040f396ad2469175e.

Revert "GEODE-2644: Expand DistributedSystemMXBean tests"
This reverts commit cd2bba13e2fb7e79f7634053a6c612050b328e11.

Revert "GEODE-2644: Make AlertAppender optional and support log4j2.xml"
This reverts commit 02c3cae1d38098259ff6aa4635c6e74f795bdc50.

Revert "GEODE-2644: Add LogConfig and StatisticsConfig for logging"
This reverts commit a77c94b349b3ed7fc873fc29f6852f9936843790.

Revert "GEODE-2644: Add AlertingTest JUnit Category"
This reverts commit 731cd2a7d35b086d34f8bbcb94a83c40739ae8ee.

Revert "GEODE-2644: Add LogFileAssert and LogLevelAssert assertions"
This reverts commit 5e61da5301469cdbd71ac186573f56c38e9a6cf0.

Revert "GEODE-2644: Cleanup logging related files"
This reverts commit 763e4177f201eff9b140654e6858152a1a184b8c.

Revert "GEODE-2644: Define interfaces for new Log4j2 Appenders"
This reverts commit efd8a14027195b6dae1dd3e4d53a33696ed318bb.

+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.io.File;
+
+import org.apache.logging.log4j.Level;
-import org.apache.logging.log4j.util.StackLocator;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.Configuration;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.apache.logging.log4j.core.lookup.StrLookup;
+import org.apache.logging.log4j.core.lookup.StrSubstitutor;
+import org.apache.logging.log4j.status.StatusLogger;
-import org.apache.geode.cache.Region;
-import org.apache.geode.internal.cache.EntriesSet;
+import org.apache.geode.internal.logging.log4j.AppenderContext;
+import org.apache.geode.internal.logging.log4j.ConfigLocator;
+import org.apache.geode.internal.logging.log4j.Configurator;
-import org.apache.geode.internal.logging.log4j.message.GemFireParameterizedMessage;
- * Provides Log4J2 Loggers with customized optimizations for Geode:
- *
- * <p>
- * Returned Logger is wrapped inside an instance of {@link FastLogger} which skips expensive
- * filtering, debug and trace handling with a volatile boolean. This optimization is turned on only
- * when using the default Geode {@code log4j2.xml} by checking for the existence of this property:
- *
- * <pre>
- * &lt;Property name="geode-default"&gt;true&lt;/Property&gt;
- * </pre>
- *
- * <p>
- * Returned Logger uses {@link GemFireParameterizedMessageFactory} to create
- * {@link GemFireParameterizedMessage} which excludes {@link Region}s from being handled as a
- * {@code Map} and {@link EntriesSet} from being handled as a {@code Collection}. Without this
- * change, using a {@code Region} or {@code EntriesSet} in a log statement can result in an
- * expensive operation or even a hang in the case of a {@code PartitionedRegion}.
- *
- * <p>
- * {@code LogService} only uses Log4J2 API so that any logging backend may be used.
+ * Centralizes log configuration and initialization.
+  private static final Logger LOGGER = StatusLogger.getLogger();
+
+  // This is highest point in the hierarchy for all Geode logging
+  public static final String ROOT_LOGGER_NAME = "";
+  public static final String BASE_LOGGER_NAME = "org.apache.geode";
+  public static final String MAIN_LOGGER_NAME = "org.apache.geode";
+  public static final String SECURITY_LOGGER_NAME = "org.apache.geode.security";
+
+  public static final String GEODE_VERBOSE_FILTER = "{GEODE_VERBOSE}";
+  public static final String GEMFIRE_VERBOSE_FILTER = "{GEMFIRE_VERBOSE}";
+  public static final String DEFAULT_CONFIG = "/log4j2.xml";
+  public static final String CLI_CONFIG = "/log4j2-cli.xml";
+
+  protected static final String STDOUT = "STDOUT";
+
+  private static final PropertyChangeListener propertyChangeListener =
+      new PropertyChangeListenerImpl();
+
+  /**
+   * Name of variable that is set to "true" in log4j2.xml to indicate that it is the default geode
+   * config xml.
+   */
+  private static final String GEMFIRE_DEFAULT_PROPERTY = "geode-default";
+
+  /**
+   * Protected by static synchronization. Used for removal and adding stdout back in.
+   */
+  private static Appender stdoutAppender;
+
+  static {
+    init();
+  }
+
+  private static void init() {
+    LoggerContext loggerContext = getLoggerContext(BASE_LOGGER_NAME);
+    loggerContext.removePropertyChangeListener(propertyChangeListener);
+    loggerContext.addPropertyChangeListener(propertyChangeListener);
+    loggerContext.reconfigure(); // propertyChangeListener invokes configureFastLoggerDelegating
+    configureLoggers(false, false);
+  }
+
+  public static void reconfigure() {
+    init();
+  }
+
+  public static void configureLoggers(final boolean hasLogFile, final boolean hasSecurityLogFile) {
+    Configurator.getOrCreateLoggerConfig(BASE_LOGGER_NAME, true, false);
+    Configurator.getOrCreateLoggerConfig(MAIN_LOGGER_NAME, true, hasLogFile);
+    boolean useMainLoggerForSecurity = !hasSecurityLogFile;
+    Configurator.getOrCreateLoggerConfig(SECURITY_LOGGER_NAME, useMainLoggerForSecurity,
+        hasSecurityLogFile);
+  }
+
+  public static AppenderContext getAppenderContext() {
+    return new AppenderContext();
+  }
+
+  public static AppenderContext getAppenderContext(final String name) {
+    return new AppenderContext(name);
+  }
+
+  public static boolean isUsingGemFireDefaultConfig() {
+    Configuration configuration = getConfiguration();
+
+    StrSubstitutor strSubstitutor = configuration.getStrSubstitutor();
+    StrLookup variableResolver = strSubstitutor.getVariableResolver();
+
+    String value = variableResolver.lookup(GEMFIRE_DEFAULT_PROPERTY);
+
+    return "true".equals(value);
+  }
+
+  public static String getConfigurationInfo() {
+    return getConfiguration().getConfigurationSource().toString();
+  }
+
+  /**
+   * Finds a Log4j configuration file in the current directory. The names of the files to look for
+   * are the same as those that Log4j would look for on the classpath.
+   *
+   * @return A File for the configuration file or null if one isn't found.
+   */
+  public static File findLog4jConfigInCurrentDir() {
+    return ConfigLocator.findConfigInWorkingDirectory();
+  }
+
-    String name = StackLocator.getInstance().getCallerClass(2).getName();
-        LogManager.getLogger(name, GemFireParameterizedMessageFactory.INSTANCE));
+        LogManager.getLogger(getClassName(2), GemFireParameterizedMessageFactory.INSTANCE));
-   *
+
+  /**
+   * Return the Log4j Level associated with the int level.
+   *
+   * @param intLevel The int value of the Level to return.
+   *
+   * @return The Level.
+   *
+   * @throws IllegalArgumentException if the Level int is not registered.
+   */
+  public static Level toLevel(final int intLevel) {
+    for (Level level : Level.values()) {
+      if (level.intLevel() == intLevel) {
+        return level;
+      }
+    }
+
+    throw new IllegalArgumentException("Unknown int level [" + intLevel + "].");
+  }
+
+  /**
+   * Gets the class name of the caller in the current stack at the given {@code depth}.
+   *
+   * @param depth a 0-based index in the current stack.
+   *
+   * @return a class name
+   */
+  public static String getClassName(final int depth) {
+    return new Throwable().getStackTrace()[depth].getClassName();
+  }
+
+  public static Configuration getConfiguration() {
+    return getRootLoggerContext().getConfiguration();
+  }
+
+  public static void configureFastLoggerDelegating() {
+    Configuration configuration = getConfiguration();
+    if (Configurator.hasContextWideFilter(configuration)
+        || Configurator.hasAppenderFilter(configuration)
+        || Configurator.hasDebugOrLower(configuration)
+        || Configurator.hasLoggerFilter(configuration)
+        || Configurator.hasAppenderRefFilter(configuration)) {
+      FastLogger.setDelegating(true);
+    } else {
+      FastLogger.setDelegating(false);
+    }
+  }
+
+  public static void setSecurityLogLevel(Level level) {
+    Configurator.setLevel(SECURITY_LOGGER_NAME, level);
+  }
+
+  public static Level getBaseLogLevel() {
+    return Configurator.getLevel(BASE_LOGGER_NAME);
+  }
+
+  public static void setBaseLogLevel(Level level) {
+    if (isUsingGemFireDefaultConfig()) {
+      Configurator.setLevel(ROOT_LOGGER_NAME, level);
+    }
+    Configurator.setLevel(BASE_LOGGER_NAME, level);
+    Configurator.setLevel(MAIN_LOGGER_NAME, level);
+  }
+
+  private static LoggerContext getLoggerContext(final String name) {
+    return ((org.apache.logging.log4j.core.Logger) LogManager
+        .getLogger(name, GemFireParameterizedMessageFactory.INSTANCE)).getContext();
+  }
+
+  static LoggerContext getRootLoggerContext() {
+    return ((org.apache.logging.log4j.core.Logger) LogManager.getRootLogger()).getContext();
+  }
+
+  /**
+   * Removes STDOUT ConsoleAppender from ROOT logger. Only called when using the log4j2-default.xml
+   * configuration. This is done when creating the LogWriterAppender for log-file. The Appender
+   * instance is stored in stdoutAppender so it can be restored later using restoreConsoleAppender.
+   */
+  public static synchronized void removeConsoleAppender() {
+    AppenderContext appenderContext = getAppenderContext(ROOT_LOGGER_NAME);
+    LoggerConfig loggerConfig = appenderContext.getLoggerConfig();
+    Appender stdoutAppender = loggerConfig.getAppenders().get(STDOUT);
+    if (stdoutAppender != null) {
+      loggerConfig.removeAppender(STDOUT);
+      LogService.stdoutAppender = stdoutAppender;
+      appenderContext.getLoggerContext().updateLoggers();
+    }
+  }
+
+  /**
+   * Restores STDOUT ConsoleAppender to ROOT logger. Only called when using the log4j2-default.xml
+   * configuration. This is done when the LogWriterAppender for log-file is destroyed. The Appender
+   * instance stored in stdoutAppender is used.
+   */
+  public static synchronized void restoreConsoleAppender() {
+    if (stdoutAppender == null) {
+      return;
+    }
+    AppenderContext appenderContext = getAppenderContext(ROOT_LOGGER_NAME);
+    LoggerConfig loggerConfig = appenderContext.getLoggerConfig();
+    Appender stdoutAppender = loggerConfig.getAppenders().get(STDOUT);
+    if (stdoutAppender == null) {
+      loggerConfig.addAppender(LogService.stdoutAppender, Level.ALL, null);
+      appenderContext.getLoggerContext().updateLoggers();
+    }
+  }
+
+  private static class PropertyChangeListenerImpl implements PropertyChangeListener {
+
+    @Override
+    public void propertyChange(final PropertyChangeEvent evt) {
+      LOGGER.debug("LogService responding to a property change event. Property name is {}.",
+          evt.getPropertyName());
+
+      if (evt.getPropertyName().equals(LoggerContext.PROPERTY_CONFIG)) {
+        configureFastLoggerDelegating();
+      }
+    }
+  }

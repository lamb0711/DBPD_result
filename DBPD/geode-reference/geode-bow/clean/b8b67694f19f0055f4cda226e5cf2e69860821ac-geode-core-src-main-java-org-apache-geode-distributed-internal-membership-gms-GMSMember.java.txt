Merge branch 'develop' into feature/GEODE-7049

-import java.net.UnknownHostException;
-import org.apache.geode.DataSerializer;
-import org.apache.geode.distributed.DurableClientAttributes;
-import org.apache.geode.distributed.internal.membership.MemberAttributes;
-import org.apache.geode.distributed.internal.membership.NetMember;
-import org.apache.geode.internal.DataSerializableFixedID;
-import org.apache.geode.internal.InternalDataSerializer;
-import org.apache.geode.internal.Version;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.serialization.DataSerializableFixedID;
+import org.apache.geode.internal.serialization.DeserializationContext;
+import org.apache.geode.internal.serialization.SerializationContext;
+import org.apache.geode.internal.serialization.StaticSerialization;
+import org.apache.geode.internal.serialization.Version;
- * This is the fundamental representation of a member of a GemFire distributed system.
- *
- * Unfortunately, this class serves two distinct functions. First, it is the fundamental element of
- * membership in the GemFire distributed system. As such, it is used in enumerations and properly
- * responds to hashing and equals() comparisons.
- *
- * Second, it is used as a cheap way of representing an address. This is unfortunate, because as a
- * NetMember, it holds two separate port numbers: the "membership" descriptor as well as a direct
- * communication channel.
- *
+ * GMSMember is the membership identifier class for Group Membership Services.
-public class GMSMember implements NetMember, DataSerializableFixedID {
+public class GMSMember implements DataSerializableFixedID {
+  /** The type for regular members */
+  public static final int NORMAL_DM_TYPE = 10;
+
+  /** The DM type for locator members */
+  public static final int LOCATOR_DM_TYPE = 11;
+
+  /** The DM type for deprecated admin-only members */
+  public static final int ADMIN_ONLY_DM_TYPE = 12;
+
+  /** The DM type for stand-alone members (usually clients) */
+  public static final int LONER_DM_TYPE = 13;
+
+  private String hostName;
+
-  private DurableClientAttributes durableClientAttributes;
-  private short versionOrdinal = Version.CURRENT_ORDINAL;
+  private short versionOrdinal = Version.getCurrentVersion().ordinal();
+  private String durableId;
+  private int durableTimeout;
+  private boolean isPartial; // transient state - created with readEssentialData
+  public boolean isPartial() {
+    return isPartial;
+  }
-  @Override
-  public MemberAttributes getAttributes() {
-    return new MemberAttributes(directPort, processId, vmKind, vmViewId, name, groups,
-        durableClientAttributes);
+  @VisibleForTesting
+  public GMSMember(String localhost, int udpPort, Version version) {
+    this.hostName = localhost;
+    this.inetAddr = SocketCreator.toInetAddress(localhost);
+    this.udpPort = udpPort;
+    this.versionOrdinal = version.ordinal();
+    this.vmKind = NORMAL_DM_TYPE;
+    this.preferredForCoordinator = true;
+    this.vmViewId = -1;
+    this.processId = -1;
+    this.directPort = -1;
+    setUUID(UUID.randomUUID());
-  @Override
-  public void setAttributes(MemberAttributes p_attr) {
-    MemberAttributes attr = p_attr;
-    if (attr == null) {
-      attr = MemberAttributes.INVALID;
-    }
-    processId = attr.getVmPid();
-    vmKind = (byte) attr.getVmKind();
-    directPort = attr.getPort();
-    vmViewId = attr.getVmViewId();
-    name = attr.getName();
-    groups = attr.getGroups();
-    durableClientAttributes = attr.getDurableClientAttributes();
-  }
+  @VisibleForTesting
-    udpPort = p;
-    try {
-      inetAddr = InetAddress.getByName(i);
-    } catch (UnknownHostException e) {
-      // oops
-    }
+    this(i, p, Version.getCurrentVersion());
-  public GMSMember(MemberAttributes attr, InetAddress i, int p,
+  public GMSMember(InetAddress i, String hostName, int p, int processId, byte vmKind,
+      int directPort, int vmViewId,
+      String name, String[] groups,
+      String durableId, int durableTimeout,
-    setAttributes(attr);
+    this.hostName = hostName;
+    this.processId = processId;
+    this.vmKind = vmKind;
+    this.directPort = directPort;
+    this.vmViewId = vmViewId;
+    this.name = name;
+    this.groups = groups;
+    this.durableId = durableId;
+    this.durableTimeout = durableTimeout;
+    this.hostName = i.getHostName();
+    this.hostName = other.hostName;
-    this.durableClientAttributes = other.durableClientAttributes;
+    this.durableId = other.durableId;
+    this.durableTimeout = other.durableTimeout;
-  @Override
+
-  @Override
-  public boolean isMulticastAddress() {
-    return false;
-  }
-  @Override
-  @Override
+
-  @Override
+
+  public String getDurableId() {
+    return durableId;
+  }
+
+  public int getDurableTimeout() {
+    return durableTimeout;
+  }
+
-  @Override
+
-  @Override
-  public int compareTo(NetMember o) {
+
+  public int compareTo(GMSMember o) {
+    return compareTo(o, true);
+  }
+
+  public int compareTo(GMSMember o, boolean compareUUIDs) {
-    if (o == null || !(o instanceof GMSMember)) {
+    if (o == null) {
-          "NetMember.compareTo(): comparison between different classes");
+          "GMSMember.compareTo(): comparison between different classes");
-    GMSMember his = (GMSMember) o;
+    GMSMember his = o;
-    if (result == 0 && this.uuidMSBs != 0 && his.uuidMSBs != 0) {
+    if (compareUUIDs && result == 0 && this.uuidMSBs != 0 && his.uuidMSBs != 0) {
-  @Override
-  public int compareAdditionalData(NetMember other) {
-    GMSMember his = (GMSMember) other;
+
+  public int compareAdditionalData(GMSMember his) {
-    sb.append("GMSMember[addr=").append(inetAddr).append(";port=").append(udpPort)
-        .append(";processId=").append(processId).append(";name=").append(name).append(uuid)
+    sb.append("GMSMember[name=").append(name)
+        .append(";addr=").append(inetAddr).append(";port=").append(udpPort)
+        .append(";kind=").append(vmKind).append(";processId=").append(processId)
+        .append(";viewId=").append(vmViewId)
+        .append(";version=").append(versionOrdinal).append(uuid)
-  @Override
-  public String getUniqueId() {
-    StringBuilder sb = new StringBuilder(100);
-    sb.append("GMSMember[addr=").append(inetAddr);
-    sb.append(";processId=").append(processId);
-    sb.append(";name=").append(name);
-    sb.append(formatUUID()).append("]");
-    return sb.toString();
-  }
-  public int getUdpPort() {
-    return udpPort;
-  }
-
-  @Override
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
-  public DurableClientAttributes getDurableClientAttributes() {
-    return durableClientAttributes;
-  }
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
-  public void setDurableClientAttributes(DurableClientAttributes durableClientAttributes) {
-    this.durableClientAttributes = durableClientAttributes;
-  }
-  @Override
-  @Override
+
-  @Override
+
+  static final int VERSION_BIT = 0x8;
+
+  static final int LONER_VM_TYPE = 13; // from ClusterDistributionManager
-  public void toData(DataOutput out) throws IOException {
-    writeEssentialData(out);
-    out.writeInt(directPort);
-    out.writeByte(memberWeight);
-    out.writeByte(vmKind);
-    out.writeInt(processId);
+  public void toData(DataOutput out,
+      SerializationContext context) throws IOException {
+    StaticSerialization.writeInetAddress(getInetAddress(), out);
+    out.writeInt(getPort());
-    DataSerializer.writeString(name, out);
-    DataSerializer.writeStringArray(groups, out);
+    StaticSerialization.writeString(hostName, out);
+
+    int flags = 0;
+    if (isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (preferredForCoordinator())
+      flags |= PREFERRED_FOR_COORD_BIT;
+    // always write product version but enable reading from older versions
+    // that do not have it
+    flags |= VERSION_BIT;
+
+    out.writeByte((byte) (flags & 0xff));
+
+    out.writeInt(getDirectPort());
+    out.writeInt(getProcessId());
+    int vmKind = getVmKind();
+    out.writeByte(vmKind);
+    StaticSerialization.writeStringArray(getGroups(), out);
+
+    StaticSerialization.writeString(getName(), out);
+    if (vmKind == LONER_VM_TYPE) {
+      StaticSerialization.writeString("", out);
+    } else { // added in 6.5 for unique identifiers in P2P
+      StaticSerialization.writeString(String.valueOf(getVmViewId()), out);
+    }
+    StaticSerialization
+        .writeString(durableId == null ? "" : durableId, out);
+    out.writeInt(durableId == null ? 300 : durableTimeout);
+
+    Version.writeOrdinal(out, versionOrdinal, true);
+
+    if (versionOrdinal >= Version.GFE_90.ordinal()) {
+      writeAdditionalData(out);
+    }
-  public void writeEssentialData(DataOutput out) throws IOException {
+  public void writeEssentialData(DataOutput out,
+      SerializationContext context) throws IOException {
-    DataSerializer.writeInetAddress(inetAddr, out);
+    StaticSerialization.writeInetAddress(inetAddr, out);
-    if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GEODE_1_2_0) >= 0) {
+    if (context.getSerializationVersion().ordinal() >= Version.GEODE_1_2_0.ordinal()) {
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    readEssentialData(in);
-    this.directPort = in.readInt();
-    this.memberWeight = in.readByte();
-    this.vmKind = in.readByte();
-    this.processId = in.readInt();
+  public void fromData(DataInput in,
+      DeserializationContext context) throws IOException, ClassNotFoundException {
+    inetAddr = StaticSerialization.readInetAddress(in);
+    udpPort = in.readInt();
-    this.name = DataSerializer.readString(in);
-    this.groups = DataSerializer.readStringArray(in);
+    this.hostName = StaticSerialization.readString(in);
+
+    int flags = in.readUnsignedByte();
+    preferredForCoordinator = (flags & PREFERRED_FOR_COORD_BIT) != 0;
+    this.networkPartitionDetectionEnabled = (flags & NPD_ENABLED_BIT) != 0;
+
+    directPort = in.readInt();
+    processId = in.readInt();
+    vmKind = (byte) in.readUnsignedByte();
+    groups = StaticSerialization.readStringArray(in);
+    vmViewId = -1;
+
+    name = StaticSerialization.readString(in);
+    if (vmKind == LONER_DM_TYPE) {
+      StaticSerialization.readString(in);
+    } else {
+      String str = StaticSerialization.readString(in);
+      if (str != null) { // backward compatibility from earlier than 6.5
+        vmViewId = Integer.parseInt(str);
+      }
+    }
+
+    durableId = StaticSerialization.readString(in);
+    durableTimeout = in.readInt();
+
+    versionOrdinal = readVersion(flags, in, context);
+
+    if (versionOrdinal >= Version.GFE_90.ordinal()) {
+      readAdditionalData(in);
+    }
-  public void readEssentialData(DataInput in) throws IOException, ClassNotFoundException {
+  private short readVersion(int flags, DataInput in,
+      DeserializationContext context) throws IOException {
+    if ((flags & VERSION_BIT) != 0) {
+      return Version.readOrdinal(in);
+    } else {
+      // prior to 7.1 member IDs did not serialize their version information
+      Version v = context.getSerializationVersion();
+      return v.ordinal();
+    }
+  }
+
+  public String getHostName() {
+    return hostName;
+  }
+
+  public void setHostName(String hostName) {
+    this.hostName = hostName;
+  }
+
+  public void readEssentialData(DataInput in,
+      DeserializationContext context) throws IOException, ClassNotFoundException {
-    this.inetAddr = DataSerializer.readInetAddress(in);
+    this.inetAddr = StaticSerialization.readInetAddress(in);
+    if (this.inetAddr != null) {
+      this.hostName =
+          SocketCreator.resolve_dns ? SocketCreator.getHostName(inetAddr)
+              : inetAddr.getHostAddress();
+    }
-    if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GEODE_1_2_0) >= 0) {
+    if (context.getSerializationVersion().ordinal() >= Version.GEODE_1_2_0.ordinal()) {
+    this.isPartial = true;
-  @Override
+
-  @Override
+
-  @Override
+
-    return ";uuid=" + getUUID().toStringLong();
+    UUID uuid = getUUID();
+    return ";uuid=" + (uuid == null ? "none" : getUUID().toStringLong());
+
+  public void setDurableTimeout(int newValue) {
+    durableTimeout = newValue;
+  }
+
+  public void setDurableId(String id) {
+    durableId = id;
+  }
+
+
+  public static class GMSMemberWrapper {
+    GMSMember mbr;
+
+    public GMSMemberWrapper(GMSMember m) {
+      this.mbr = m;
+    }
+
+    public GMSMember getMbr() {
+      return mbr;
+    }
+
+    @Override
+    public int hashCode() {
+      return mbr.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == null || !(obj instanceof GMSMemberWrapper)) {
+        return false;
+      }
+      GMSMember other = ((GMSMemberWrapper) obj).mbr;
+      return mbr.compareTo(other) == 0;
+    }
+
+    @Override
+    public String toString() {
+      return "GMSMemberWrapper [mbr=" + mbr + "]";
+    }
+  }
+
+

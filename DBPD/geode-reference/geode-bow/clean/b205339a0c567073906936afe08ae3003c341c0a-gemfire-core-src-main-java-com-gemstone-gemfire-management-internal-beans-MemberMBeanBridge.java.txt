Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.cache.hdfs.internal.HDFSStoreImpl;
+import com.gemstone.gemfire.internal.offheap.MemoryAllocator;
+import com.gemstone.gemfire.internal.offheap.OffHeapMemoryStats;
-        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage(), e);
+        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
-        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage(), e);
+        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
+    MemoryAllocator allocator = ((GemFireCacheImpl) cache).getOffHeapStore();
+    if((null != allocator) ) {
+      OffHeapMemoryStats offHeapStats = allocator.getStats();
+      
+      if(null != offHeapStats) {
+        addOffHeapStats(offHeapStats);
+      }
+    }
+
+    
-
+  public void addOffHeapStats(OffHeapMemoryStats offHeapStats) {
+    Statistics offHeapMemoryStatistics = offHeapStats.getStats();
+    monitor.addStatisticsToMonitor(offHeapMemoryStatistics);
+  }
+  
+
+  
+  /**
+   * @return list all the HDFSStore's name at cache level
+   */
+  
+  public String[] getHDFSStores() {
+    GemFireCacheImpl cacheImpl = (GemFireCacheImpl) cache;
+    String[] retStr = null;
+    Collection<HDFSStoreImpl> hdfsStoreCollection = null;
+    hdfsStoreCollection = cacheImpl.getHDFSStores();
+      
+    if (hdfsStoreCollection != null && hdfsStoreCollection.size() > 0) {
+      retStr = new String[hdfsStoreCollection.size()];
+      Iterator<HDFSStoreImpl> it = hdfsStoreCollection.iterator();
+      int i = 0;
+      while (it.hasNext()) {
+        retStr[i] = it.next().getName();
+        i++;
+
+      }
+    }
+    return retStr;
+  }
+      
-   * @return maximum heap size in MB
-   */
-  public long getMaximumHeapSize() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.maxMemory() / MBFactor;
-  }
-
-  /**
-   * 
-  /**
-   * 
-   * @return get free heap size
-   */
-  public long getFreeHeapSize() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.freeMemory() / MBFactor;
+  public int getOffHeapObjects() {
+    int objects = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      objects = stats.getObjects();
+    }
+    
+    return objects;
+  @Deprecated
+  public long getOffHeapFreeSize() {
+    return getOffHeapFreeMemory();
+  }
+  
+  @Deprecated
+  public long getOffHeapUsedSize() {
+    return getOffHeapUsedMemory();
+  }
+  
+  public long getOffHeapMaxMemory() {
+    long usedSize = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      usedSize = stats.getMaxMemory();
+    }
+    
+    return usedSize;
+  }
+  
+  public long getOffHeapFreeMemory() {
+    long freeSize = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      freeSize = stats.getFreeMemory();
+    }
+    
+    return freeSize;
+  }
+  
+  public long getOffHeapUsedMemory() {
+    long usedSize = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      usedSize = stats.getUsedMemory();
+    }
+    
+    return usedSize;
+  }
+  
+  public int getOffHeapFragmentation() {
+    int fragmentation = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      fragmentation = stats.getFragmentation();
+    }
+    
+    return fragmentation;        
+  }
+  
+  public long getOffHeapCompactionTime() {
+    long compactionTime = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      compactionTime = stats.getCompactionTime();
+    }
+    
+    return compactionTime;            
+  }
+  
-   * 
-   * @return current heap size
+   * Returns the OffHeapMemoryStats for this VM.
-  public long getCurrentHeapSize() {
-    return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue()
-    / MBFactor;
-  }
+  private OffHeapMemoryStats getOffHeapStats() {
+    OffHeapMemoryStats stats = null;
+    
+    MemoryAllocator offHeap = this.cache.getOffHeapStore();
+    
+    if(null != offHeap) {
+      stats = offHeap.getStats();
+    }
-  public long getMaxMemory() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.maxMemory() / MBFactor;
-  }
-  
-  public long getFreeMemory() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.freeMemory() / MBFactor;
-  }
-  
-  public long getUsedMemory() {
-    return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue() / MBFactor;
+    return stats;    
+  public long getMaxMemory() {
+    Runtime rt = Runtime.getRuntime();
+    return rt.maxMemory() / MBFactor;
+  }
+  
+  public long getFreeMemory() {
+    Runtime rt = Runtime.getRuntime();
+    return rt.freeMemory() / MBFactor;
+  }
+  
+  public long getUsedMemory() {
+    return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue() / MBFactor;
+  }

Merge branch 'release/1.0.0-incubating.M3'

+import java.util.concurrent.ConcurrentHashMap;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import com.gemstone.gemfire.cache.lucene.internal.directory.RegionDirectory;
+import com.gemstone.gemfire.cache.lucene.internal.filesystem.FileSystemStats;
-import com.gemstone.gemfire.cache.lucene.internal.repository.IndexRepositoryImpl;
-  /** map of the parent bucket region to the index repository 
+
+  public static IndexRepositoryFactory indexRepositoryFactory = new IndexRepositoryFactory();
+
+  /** map of the parent bucket region to the index repository
-  CopyOnWriteHashMap<Integer, IndexRepository> indexRepositories = new CopyOnWriteHashMap<Integer, IndexRepository>();
+  private final ConcurrentHashMap<Integer, IndexRepository> indexRepositories = new ConcurrentHashMap<Integer, IndexRepository>();
-  
+  private final LuceneIndexStats indexStats;
+  private final FileSystemStats fileSystemStats;
+
-  public PartitionedRepositoryManager(PartitionedRegion userRegion, PartitionedRegion fileRegion,
-      PartitionedRegion chunkRegion,
-      LuceneSerializer serializer,
-      Analyzer analyzer) {
+  public PartitionedRepositoryManager(PartitionedRegion userRegion,
+                                      PartitionedRegion fileRegion,
+                                      PartitionedRegion chunkRegion,
+                                      LuceneSerializer serializer,
+                                      Analyzer analyzer,
+                                      LuceneIndexStats indexStats,
+                                      FileSystemStats fileSystemStats) {
+    this.indexStats = indexStats;
+    this.fileSystemStats = fileSystemStats;
-    
-    //Remove the repository if it has been destroyed (due to rebalancing)
-    if(repo != null && repo.isClosed()) {
-      indexRepositories.remove(bucketId, repo);
-      repo = null;
+    if(repo != null && !repo.isClosed()) {
+      return repo;
-    
-    if(repo == null) {
+
+    repo = indexRepositories.compute(bucketId, (key, oldRepository) -> {
+      if(oldRepository != null && !oldRepository.isClosed()) {
+        return oldRepository;
+      }
+      if(oldRepository != null) {
+        oldRepository.cleanup();
+      }
+
-        BucketRegion fileBucket = getMatchingBucket(fileRegion, bucketId);
-        BucketRegion chunkBucket = getMatchingBucket(chunkRegion, bucketId);
-        RegionDirectory dir = new RegionDirectory(fileBucket, chunkBucket);
-        IndexWriterConfig config = new IndexWriterConfig(analyzer);
-        IndexWriter writer = new IndexWriter(dir, config);
-        repo = new IndexRepositoryImpl(fileBucket, writer, serializer);
-        IndexRepository oldRepo = indexRepositories.putIfAbsent(bucketId, repo);
-        if(oldRepo != null) {
-          repo = oldRepo;
-        }
+        return indexRepositoryFactory.createIndexRepository(bucketId, userRegion, fileRegion, chunkRegion, serializer,
+          analyzer, indexStats, fileSystemStats);
-    }
-    
-    return repo;
-  }
-  /**
-   * Find the bucket in region2 that matches the bucket id from region1.
-   */
-  private BucketRegion getMatchingBucket(PartitionedRegion region, Integer bucketId) throws BucketNotFoundException {
-    //Force the bucket to be created if it is not already
-    region.getOrCreateNodeForBucketWrite(bucketId, null);
-    
-    BucketRegion result = region.getDataStore().getLocalBucketById(bucketId);
-    if(result == null) {
-      throw new BucketNotFoundException("Bucket not found for region " + region + " bucekt id " + bucketId);
+    });
+
+    if(repo == null) {
+      throw new BucketNotFoundException("Colocated index buckets not found for regions " + chunkRegion + ", " + fileRegion + " bucket id " + bucketId);
-    
-    return result;
+
+    return repo;

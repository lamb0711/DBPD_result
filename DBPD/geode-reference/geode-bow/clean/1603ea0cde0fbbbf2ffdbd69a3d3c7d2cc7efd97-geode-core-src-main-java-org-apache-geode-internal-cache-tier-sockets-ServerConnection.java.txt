GEODE-6626: Separate CacheServer and GatewayReceiver

Introduce new interfaces and then have GatewayReceiverServer extend
CacheServerImpl to override behavior.

-
-  final AcceptorImpl acceptor;
+
+  final Acceptor acceptor;
-  public ServerConnection(Socket socket, InternalCache internalCache, CachedRegionHelper helper,
-      CacheServerStats stats, int hsTimeout, int socketBufferSize, String communicationModeStr,
-      byte communicationMode, Acceptor acceptor, SecurityService securityService) {
-
+  public ServerConnection(final Socket socket, final InternalCache internalCache,
+      final CachedRegionHelper cachedRegionHelper, final CacheServerStats stats,
+      final int hsTimeout, final int socketBufferSize, final String communicationModeStr,
+      final byte communicationMode, final Acceptor acceptor,
+      final SecurityService securityService) {
-    if (((AcceptorImpl) acceptor).isGatewayReceiver()) {
+    if (acceptor.isGatewayReceiver()) {
-    this.acceptor = (AcceptorImpl) acceptor;
-    crHelper = helper;
+    this.acceptor = acceptor;
+    crHelper = cachedRegionHelper;
-  public AcceptorImpl getAcceptor() {
+  public Acceptor getAcceptor() {
-
-              new Object[] {getName(), handshakeTimeout});
+              getName(), handshakeTimeout);
-        crHelper.checkCancelInProgress(null); // bug 37113?
+        crHelper.checkCancelInProgress(null);
-        // Bug #52023.
-                  String.format("Duplicate durable clientId (%s)",
-                      proxyId.getDurableId());
-              logger.warn("{} : {}",
-                  new Object[] {name, handshakeRefusalMessage});
+                  String.format("Duplicate durable clientId (%s)", proxyId.getDurableId());
+              logger.warn("{} : {}", name, handshakeRefusalMessage);
-        && !(acceptor.getCachedRegionHelper().getCache()).isClosed()
+        && !acceptor.getCachedRegionHelper().getCache().isClosed()
-      Assert.assertTrue((handshake.getVersion().ordinal() == testVersionAfterHandshake),
+      Assert.assertTrue(handshake.getVersion().ordinal() == testVersionAfterHandshake,
-        if (!processMessages || (crHelper.isShutdown())) {
+        if (!processMessages || crHelper.isShutdown()) {
-
-        // TODO (ashetkar)
-    // we allow older clients to not send credentials for a handful of messages
-    // if and only if a system property is set. This allows a rolling upgrade
-    // to be performed.
+    // we allow older clients to not send credentials for a handful of messages if and only if a
+    // system property is set. This allows a rolling upgrade to be performed.
-    setOwner();
-
-            registerWithSelector(); // finished message so reregister
+            // finished message so reregister
+            registerWithSelector();
-        logger.warn(ex + " : Unexpected Exception");
+        logger.warn("Unexpected Exception", ex);
-        logger.warn(ex.toString() + " : Unexpected Exception");
+        logger.warn("Unexpected Exception", ex);
-        // DistributedSystem.releaseThreadsSockets();
-        unsetOwner();
-    getAcceptor().registerSC(this);
+    getAcceptor().registerServerConnection(this);
-    if (timeout > 0) { // 0 means no timeout
+    // 0 means no timeout
+    if (timeout > 0) {
-      return String.format("Error in getSocketString: %s",
-          e.getLocalizedMessage());
+      return String.format("Error in getSocketString: %s", e.getLocalizedMessage());
-          new Object[] {justProcessed,
-              latestBatchIdReplied});
+          justProcessed, latestBatchIdReplied);
-  private final Object ownerLock = new Object();
-
-  private void setOwner() { // TODO:KIRK
-    synchronized (ownerLock) {
-      owner = Thread.currentThread();
-    }
-  }
-
-  private void unsetOwner() { // TODO:KIRK
-    synchronized (ownerLock) {
-      owner = null;
-      // clear the interrupted bit since our thread is in a thread pool
-      Thread.interrupted();
-    }
-  }
-
-    if (communicationMode.isWAN()
-        || communicationMode.isCountedAsClientServerConnection()) {
-      getAcceptor().decClientServerCnxCount();
+    if (communicationMode.isWAN() || communicationMode.isCountedAsClientServerConnection()) {
+      getAcceptor().decClientServerConnectionCount();
-    getAcceptor().unregisterSC(this);
+    getAcceptor().unregisterServerConnection(this);
-    return logWriter; // TODO:LOG:CONVERT: remove getLogWriter after callers are converted
+    return logWriter;
-      throw new AuthenticationRequiredException(
-          "No security credentials are provided");
+      throw new AuthenticationRequiredException("No security credentials are provided");
+  @VisibleForTesting
+

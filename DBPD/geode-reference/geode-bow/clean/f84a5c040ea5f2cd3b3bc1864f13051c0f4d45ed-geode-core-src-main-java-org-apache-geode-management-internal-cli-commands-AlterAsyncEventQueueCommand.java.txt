Merge branch 'develop' into GEODE-5407

+import java.util.List;
+import java.util.Set;
+import org.apache.commons.lang3.StringUtils;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NodeList;
-import org.apache.geode.cache.Region;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.CacheElement;
+import org.apache.geode.management.cli.SingleGfshCommand;
+import org.apache.geode.management.cli.UpdateAllConfigurationGroupsMarker;
-import org.apache.geode.management.internal.cli.result.model.TabularResultModel;
-import org.apache.geode.management.internal.configuration.domain.Configuration;
-import org.apache.geode.management.internal.configuration.utils.XmlUtils;
-public class AlterAsyncEventQueueCommand extends InternalGfshCommand {
+public class AlterAsyncEventQueueCommand extends SingleGfshCommand implements
+    UpdateAllConfigurationGroupsMarker {
-
-      throws IOException, SAXException, ParserConfigurationException, TransformerException {
+      throws IOException, SAXException, ParserConfigurationException, TransformerException,
+      EntityNotFoundException {
-    InternalConfigurationPersistenceService service =
-        (InternalConfigurationPersistenceService) getConfigurationPersistenceService();
-
-    if (service == null) {
+    if (getConfigurationPersistenceService() == null) {
-    boolean locked = service.lockSharedConfiguration();
-    if (!locked) {
-      return ResultModel.createCommandProcessingError("Unable to lock the cluster configuration.");
-    }
-
-    ResultModel result = new ResultModel();
-    TabularResultModel tableData = result.addTable(GROUP_STATUS_SECTION);
-    boolean xmlUpdated = false;
-    try {
-      Region<String, Configuration> configRegion = service.getConfigurationRegion();
-      for (String group : configRegion.keySet()) {
-        Configuration config = configRegion.get(group);
-        if (config.getCacheXmlContent() == null) {
-          // skip to the next group
-          continue;
-        }
-
-        Document document = XmlUtils.createDocumentFromXml(config.getCacheXmlContent());
-        NodeList nodeList = document.getElementsByTagName("async-event-queue");
-        for (int i = 0; i < nodeList.getLength(); i++) {
-          Element item = (Element) nodeList.item(i);
-          String queueId = item.getAttribute("id");
-          if (!id.equals(queueId)) {
-            // skip to the next async-event-queue found in this xml
-            continue;
-          }
-          // this node is the async-event-queue with the correct id
-          if (batchSize != null) {
-            item.setAttribute(BATCH_SIZE, batchSize + "");
-          }
-          if (batchTimeInterval != null) {
-            item.setAttribute(BATCH_TIME_INTERVAL, batchTimeInterval + "");
-          }
-          if (maxQueueMemory != null) {
-            item.setAttribute(MAXIMUM_QUEUE_MEMORY, maxQueueMemory + "");
-          }
-          // each group should have only one queue with this id defined
-          tableData.accumulate("Group", group);
-          tableData.accumulate("Status", "Cluster Configuration Updated");
-          xmlUpdated = true;
-          break;
-        }
-
-        if (xmlUpdated) {
-          String newXml = XmlUtils.prettyXml(document.getFirstChild());
-          config.setCacheXmlContent(newXml);
-          configRegion.put(group, config);
-        }
-      }
-    } finally {
-      service.unlockSharedConfiguration();
-    }
-
-    if (!xmlUpdated) {
+    if (findAEQ(id) == null) {
-    // some configurations are changed, print out the warning message as well.
-    tableData.setFooter(System.lineSeparator()
-        + "These changes won't take effect on the running servers. " + System.lineSeparator()
-        + "Please restart the servers in these groups for the changes to take effect.");
+    CacheConfig.AsyncEventQueue aeqConfiguration = new CacheConfig.AsyncEventQueue();
+    aeqConfiguration.setId(id);
+
+    if (batchSize != null) {
+      aeqConfiguration.setBatchSize(batchSize + "");
+    }
+    if (batchTimeInterval != null) {
+      aeqConfiguration.setBatchTimeInterval(batchTimeInterval + "");
+    }
+    if (maxQueueMemory != null) {
+      aeqConfiguration.setMaximumQueueMemory(maxQueueMemory + "");
+    }
+
+    ResultModel result = new ResultModel();
+    result.addInfo().addLine("Please restart the servers to apply any changed configuration");
+    result.setConfigObject(aeqConfiguration);
+  CacheConfig.AsyncEventQueue findAEQ(String aeqId) {
+    CacheConfig.AsyncEventQueue queue = null;
+    InternalConfigurationPersistenceService ccService =
+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();
+    if (ccService == null) {
+      return null;
+    }
+
+    Set<String> groups = ccService.getGroups();
+    for (String group : groups) {
+      queue =
+          CacheElement.findElement(ccService.getCacheConfig(group).getAsyncEventQueues(), aeqId);
+      if (queue != null) {
+        return queue;
+      }
+    }
+    return queue;
+  }
+
+  @Override
+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {
+
+    boolean aeqConfigsHaveBeenUpdated = false;
+
+    List<CacheConfig.AsyncEventQueue> queues = config.getAsyncEventQueues();
+    if (queues.isEmpty()) {
+      return false;
+    }
+
+    CacheConfig.AsyncEventQueue aeqConfiguration =
+        ((CacheConfig.AsyncEventQueue) configObject);
+
+    String aeqId = aeqConfiguration.getId();
+
+    for (CacheConfig.AsyncEventQueue queue : queues) {
+      if (aeqId.equals(queue.getId())) {
+        if (StringUtils.isNotBlank(aeqConfiguration.getBatchSize())) {
+          queue.setBatchSize(aeqConfiguration.getBatchSize());
+        }
+
+        if (StringUtils.isNotBlank(aeqConfiguration.getBatchTimeInterval())) {
+          queue.setBatchTimeInterval(aeqConfiguration.getBatchTimeInterval());
+        }
+
+        if (StringUtils.isNotBlank(aeqConfiguration.getMaximumQueueMemory())) {
+          queue.setMaximumQueueMemory(aeqConfiguration.getMaximumQueueMemory());
+        }
+        aeqConfigsHaveBeenUpdated = true;
+      }
+
+    }
+    return aeqConfigsHaveBeenUpdated;
+
+  }
+

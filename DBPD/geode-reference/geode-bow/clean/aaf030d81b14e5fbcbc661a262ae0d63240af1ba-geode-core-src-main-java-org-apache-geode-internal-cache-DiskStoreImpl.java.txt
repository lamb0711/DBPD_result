GEODE-5437: change async region gii to be synchronous (#2219)

When a region uses async disk persistence it used to write its data to disk async but some of the gii meta-data synchronously. This could cause data inconsistency during recovery because it looked like the disk had the entire gii, when it may not have been able to write all the data.

To fix this we now write all data to the disk store during gii synchronously for regions that are persistent even if they are configured async.

DUnit tests have been added for both backup/restore and killing during gii.
Unit tests have been added to cover the product changes.

Also added bounceForcibly to the test framework which enables bounce to do a mean vm kill unlike bounce which always does a nice vm kill. 

-  public void addDiskRegionToQueue(LocalRegion lr) {
-    try {
-      addAsyncItem(lr, true);
-    } catch (InterruptedException ignore) {
-      // If it fail, that means the RVVTrusted is not written. It will
-      // automatically do full-GII
-    }
-  }
-
-                  if (o != null && o instanceof LocalRegion) {
-                    LocalRegion lr = (LocalRegion) o;
-                    lr.getDiskRegion().writeRVV(null, true);
-                    lr.getDiskRegion().writeRVVGC(lr);
+                  AsyncDiskEntry ade = (AsyncDiskEntry) o;
+                  InternalRegion region = ade.region;
+                  VersionTag tag = ade.tag;
+                  if (ade.versionOnly) {
+                    DiskEntry.Helper.doAsyncFlush(tag, region);
-                    AsyncDiskEntry ade = (AsyncDiskEntry) o;
-                    InternalRegion region = ade.region;
-                    VersionTag tag = ade.tag;
-                    if (ade.versionOnly) {
-                      DiskEntry.Helper.doAsyncFlush(tag, region);
-                    } else {
-                      DiskEntry entry = ade.de;
-                      // We check isPendingAsync
-                      if (entry.getDiskId().isPendingAsync()) {
-                        if (LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER) {
-                          if (!doingFlush) {
-                            doingFlush = true;
-                            CacheObserverHolder.getInstance().goingToFlush();
-                          }
-                        }
-                        DiskEntry.Helper.doAsyncFlush(entry, region, tag);
-                      } else {
-                        // If it is no longer pending someone called
-                        // unscheduleAsyncWrite
-                        // so we don't need to write the entry, but
-                        // if we have a version tag we need to record the
-                        // operation
-                        // to update the RVV
-                        if (tag != null) {
-                          DiskEntry.Helper.doAsyncFlush(tag, region);
+                    DiskEntry entry = ade.de;
+                    // We check isPendingAsync
+                    if (entry.getDiskId().isPendingAsync()) {
+                      if (LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER) {
+                        if (!doingFlush) {
+                          doingFlush = true;
+                          CacheObserverHolder.getInstance().goingToFlush();
+                      DiskEntry.Helper.doAsyncFlush(entry, region, tag);
+                    } else {
+                      // If it is no longer pending someone called
+                      // unscheduleAsyncWrite
+                      // so we don't need to write the entry, but
+                      // if we have a version tag we need to record the
+                      // operation
+                      // to update the RVV
+                      if (tag != null) {
+                        DiskEntry.Helper.doAsyncFlush(tag, region);
+                      }
-                  } // else
+                  }

GEODE-2163: Optimized caching of names in CqService needs to be maintained correctly

+   * Access and modification to the contents of this map do not necessarily need to be lock
+   * protected. This is just used to optimize construction of a server side cq name. Missing values
+   * in this cache will mean a look up for a specific proxy id and cq name will miss and reconstruct
+   * the string before adding it back to the cache
+   */
+  private static final ConcurrentHashMap<String, ConcurrentHashMap<ClientProxyMembershipID, String>> serverCqNameCache =
+      new ConcurrentHashMap<>();
+
+  /**
+      removeFromCacheForServerToConstructedCQName(cqName, clientId);
+      removeFromCacheForServerToConstructedCQName(cqName, clientProxyId);
-  private static final ConcurrentHashMap<String, ConcurrentHashMap<ClientProxyMembershipID, String>> serverCqNameCache =
-      new ConcurrentHashMap<>();
-
-    ConcurrentHashMap<ClientProxyMembershipID, String> cache = serverCqNameCache.get(cqName);
-    if (null == cache) {
-      final ConcurrentHashMap<ClientProxyMembershipID, String> old = serverCqNameCache
-          .putIfAbsent(cqName, cache = new ConcurrentHashMap<ClientProxyMembershipID, String>());
-      if (null != old) {
-        cache = old;
-      }
-    }
+    ConcurrentHashMap<ClientProxyMembershipID, String> cache = serverCqNameCache
+        .computeIfAbsent(cqName, key -> new ConcurrentHashMap<ClientProxyMembershipID, String>());
+  private void removeFromCacheForServerToConstructedCQName(final String cqName,
+      ClientProxyMembershipID clientProxyMembershipID) {
+    ConcurrentHashMap<ClientProxyMembershipID, String> cache = serverCqNameCache.get(cqName);
+    if (cache != null) {
+      cache.remove(clientProxyMembershipID);
+      if (cache.size() == 0) {
+        serverCqNameCache.remove(cqName);
+      }
+    }
+  }
+

GEODE-5971: refactor StartJConsoleCommand to use ResultModel (#2962)

Co-authored-by: Peter Tran <ptran@pivotal.io>
+import org.apache.commons.lang3.StringUtils;
-import org.apache.geode.GemFireException;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.converters.ConnectionEndpointConverter;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
+import org.apache.geode.management.internal.cli.result.model.InfoResultModel;
+import org.apache.geode.management.internal.cli.result.model.ResultModel;
-import org.apache.geode.management.internal.cli.util.ConnectionEndpoint;
-  public Result startJConsole(
+  public ResultModel startJConsole(
-          help = CliStrings.START_JCONSOLE__J__HELP) final String[] jvmArgs) {
-    try {
-      String[] jconsoleCommandLine =
-          createJConsoleCommandLine(null, interval, notile, pluginpath, version, jvmArgs);
+          help = CliStrings.START_JCONSOLE__J__HELP) final String[] jvmArgs)
+      throws InterruptedException, IOException {
+    String[] jconsoleCommandLine =
+        createJConsoleCommandLine(interval, notile, pluginpath, version, jvmArgs);
-      if (isDebugging()) {
-        getGfsh().printAsInfo(
-            String.format("JConsole command-line ($1%s)", Arrays.toString(jconsoleCommandLine)));
-      }
-
-      Process jconsoleProcess = Runtime.getRuntime().exec(jconsoleCommandLine);
-
-      StringBuilder message = new StringBuilder();
-
-      if (version) {
-        jconsoleProcess.waitFor();
-
-        BufferedReader reader =
-            new BufferedReader(new InputStreamReader(jconsoleProcess.getErrorStream()));
-
-        for (String line = reader.readLine(); line != null; line = reader.readLine()) {
-          message.append(line);
-          message.append(StringUtils.LINE_SEPARATOR);
-        }
-
-        IOUtils.close(reader);
-      } else {
-        getGfsh().printAsInfo(CliStrings.START_JCONSOLE__RUN);
-
-        String jconsoleProcessOutput = waitAndCaptureProcessStandardErrorStream(jconsoleProcess);
-
-        if (StringUtils.isNotBlank(jconsoleProcessOutput)) {
-          message.append(StringUtils.LINE_SEPARATOR);
-          message.append(jconsoleProcessOutput);
-        }
-      }
-
-      return ResultBuilder.createInfoResult(message.toString());
-    } catch (GemFireException | IllegalStateException | IllegalArgumentException e) {
-      return ResultBuilder.createShellClientErrorResult(e.getMessage());
-    } catch (IOException e) {
-      return ResultBuilder
-          .createShellClientErrorResult(CliStrings.START_JCONSOLE__IO_EXCEPTION_MESSAGE);
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE, t.getMessage()));
+    ResultModel resultModel = new ResultModel();
+    InfoResultModel infoResult = resultModel.addInfo();
+    if (isDebugging()) {
+      infoResult.addLine(
+          String.format("JConsole command-line ($1%s)", Arrays.toString(jconsoleCommandLine)));
+
+    Process jconsoleProcess = getProcess(jconsoleCommandLine);
+
+    StringBuilder message;
+
+    if (version) {
+      jconsoleProcess.waitFor();
+      message = getErrorStringBuilder(jconsoleProcess);
+    } else {
+      message = new StringBuilder();
+      message.append(CliStrings.START_JCONSOLE__RUN);
+
+      String jconsoleProcessOutput = getProcessOutput(jconsoleProcess);
+
+      if (StringUtils.isNotBlank(jconsoleProcessOutput)) {
+        message.append(System.lineSeparator());
+        message.append(jconsoleProcessOutput);
+      }
+    }
+
+    infoResult.addLine(message.toString());
+
+    return resultModel;
-  protected String[] createJConsoleCommandLine(final String member, final int interval,
-      final boolean notile, final String pluginpath, final boolean version,
+  StringBuilder getErrorStringBuilder(Process jconsoleProcess) throws IOException {
+    StringBuilder message;
+    message = new StringBuilder();
+    BufferedReader reader =
+        new BufferedReader(new InputStreamReader(jconsoleProcess.getErrorStream()));
+
+    for (String line = reader.readLine(); line != null; line = reader.readLine()) {
+      message.append(line);
+      message.append(System.lineSeparator());
+    }
+
+    IOUtils.close(reader);
+    return message;
+  }
+
+  String getProcessOutput(Process jconsoleProcess) {
+    return waitAndCaptureProcessStandardErrorStream(jconsoleProcess);
+  }
+
+  Process getProcess(String[] jconsoleCommandLine) throws IOException {
+    return Runtime.getRuntime().exec(jconsoleCommandLine);
+  }
+
+  protected String[] createJConsoleCommandLine(final int interval,
+      final boolean notile, final String pluginpath,
+      final boolean version,
-      String jmxServiceUrl = getJmxServiceUrlAsString(member);
+      String jmxServiceUrl = getJmxServiceUrlAsString();
-  protected String getJmxServiceUrlAsString(final String member) {
-    if (StringUtils.isNotBlank(member)) {
-      ConnectionEndpointConverter converter = new ConnectionEndpointConverter();
+  String getJmxServiceUrlAsString() {
+    if (isConnectedAndReady()
+        && (getGfsh().getOperationInvoker() instanceof JmxOperationInvoker)) {
+      JmxOperationInvoker jmxOperationInvoker =
+          (JmxOperationInvoker) getGfsh().getOperationInvoker();
-      try {
-        ConnectionEndpoint connectionEndpoint =
-            converter.convertFromText(member, ConnectionEndpoint.class, null);
-        String hostAndPort = connectionEndpoint.getHost() + ":" + connectionEndpoint.getPort();
-        return String.format("service:jmx:rmi://%s/jndi/rmi://%s/jmxrmi", hostAndPort, hostAndPort);
-      } catch (Exception e) {
-        throw new IllegalArgumentException(
-            CliStrings.START_JCONSOLE__CONNECT_BY_MEMBER_NAME_ID_ERROR_MESSAGE);
-      }
-    } else {
-      if (isConnectedAndReady()
-          && (getGfsh().getOperationInvoker() instanceof JmxOperationInvoker)) {
-        JmxOperationInvoker jmxOperationInvoker =
-            (JmxOperationInvoker) getGfsh().getOperationInvoker();
-
-        return ObjectUtils.toString(jmxOperationInvoker.getJmxServiceUrl());
-      }
+      return ObjectUtils.toString(jmxOperationInvoker.getJmxServiceUrl());
-

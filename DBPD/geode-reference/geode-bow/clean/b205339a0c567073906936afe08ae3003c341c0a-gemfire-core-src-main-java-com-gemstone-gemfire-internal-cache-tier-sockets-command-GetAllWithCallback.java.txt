Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.cache.operations.internal.GetOperationContextImpl;
+import com.gemstone.gemfire.distributed.internal.DistributionStats;
+import com.gemstone.gemfire.internal.cache.PartitionedRegion;
+import com.gemstone.gemfire.internal.cache.tier.sockets.command.Get70.Entry;
+import com.gemstone.gemfire.internal.cache.versions.VersionTag;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+    try {
-      Get70.Entry entry = request.getValueAndIsObject(region, key, callback, servConn);
-      keyNotPresent = entry.keyNotPresent;
+      Get70.Entry entry = request.getEntry(region, key, callback, servConn);
+      @Retained final Object originalData = entry.value;
+      Object data = originalData;
+      boolean addedToValues = false;
+      try {
+        boolean isObject = entry.isObject;
+        VersionTag versionTag = entry.versionTag;
+        keyNotPresent = entry.keyNotPresent;
-      if (postAuthzRequest != null) {
-        try {
-          getContext = postAuthzRequest.getAuthorize(regionName, key, entry.value,
-                  entry.isObject, getContext);
-          byte[] serializedValue = getContext.getSerializedValue();
-          if (serializedValue == null) {
-            entry.value = getContext.getObject();
-          } else {
-            entry.value = serializedValue;
+        if (postAuthzRequest != null) {
+          try {
+            getContext = postAuthzRequest.getAuthorize(regionName, key, data,
+                isObject, getContext);
+            GetOperationContextImpl gci = (GetOperationContextImpl) getContext;
+            Object newData = gci.getRawValue();
+            if (newData != data) {
+              // user changed the value
+              isObject = getContext.isObject();
+              data = newData;
+            }
+          } catch (NotAuthorizedException ex) {
+            logger.warn(LocalizedMessage.create(LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
+                new Object[]{servConn.getName(), key}), ex);
+            values.addExceptionPart(key, ex);
+            continue;
+          } finally {
+            if (getContext != null) {
+              ((GetOperationContextImpl)getContext).release();
+            }
-          entry.isObject = getContext.isObject();
-          if (logger.isDebugEnabled()) {
-            logger.debug("{}: Passed GET post-authorization for key={}: {}", servConn.getName(), key, entry.value);
-          }
-        } catch (NotAuthorizedException ex) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
-                  new Object[]{servConn.getName(), key}), ex);
-          values.addExceptionPart(key, ex);
-          continue;
-      }
-
-
-      // Add the entry to the list that will be returned to the client
-
-      if (keyNotPresent) {
-        values.addObjectPartForAbsentKey(key, entry.value, entry.versionTag);
-      } else {
-        values.addObjectPart(key, entry.value, entry.isObject, entry.versionTag);
+        // Add the entry to the list that will be returned to the client
+        if (keyNotPresent) {
+          values.addObjectPartForAbsentKey(key, data, versionTag);
+          addedToValues = true;
+        } else {
+          values.addObjectPart(key, data, isObject, versionTag);
+          addedToValues = true;
+        }
+      } finally {
+        if (!addedToValues || data != originalData) {
+          OffHeapHelper.release(originalData);
+        }
+    } finally {
+      values.release();
+    }
-    chunkedResponseMsg.addObjPart(list, zipValues);
+    chunkedResponseMsg.addObjPartNoCopying(list);
-      String str = servConn.getName() + ": Sending" +
-              (lastChunk ? " last " : " ") + "getAll response chunk for region=" +
-              region.getFullPath() + (logger.isTraceEnabled()? " values=" + list + " chunk=<" +
-              chunkedResponseMsg + ">" : "");
-      logger.debug(str);
+      logger.debug("{}: Sending {} getAll response chunk for region={}{}", servConn.getName(), (lastChunk ? " last " : " "), region.getFullPath(), (logger.isTraceEnabled()? " values=" + list + " chunk=<" + chunkedResponseMsg + ">" : ""));

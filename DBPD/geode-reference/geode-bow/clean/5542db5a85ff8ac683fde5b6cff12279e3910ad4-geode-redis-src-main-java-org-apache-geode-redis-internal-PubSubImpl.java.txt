GEODE-7998: Do not block Netty threads when publishing (#5042)

- Now delegate PUBLISH responses to a background executor in order to
  free up the Netty worker thread. This prevents possible deadlocks.

Co-authored-by: Murtuza Boxwala <mboxwala@vmware.com>
Co-authored-by: Ray Ingles <ringles@vmware.com>
Co-authored-by: Jens Deppe <jdeppe@vmware.com>

-import java.util.Map;
-import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.Logger;
+import org.apache.geode.logging.internal.log4j.api.LogService;
+  private static final Logger logger = LogService.getLogger();
+
-    List<Long> subscriberCounts = subscriberCountCollector.getResult();
+    List<Long> subscriberCounts = null;
+    try {
+      subscriberCounts = subscriberCountCollector.getResult();
+    } catch (Exception e) {
+      logger.warn("Failed to execute publish function {}", e.getMessage());
+      return 0;
+    }
+
+      /**
+       * Since the publish process uses an onMembers function call, we don't want to re-publish
+       * to members if one fails.
+       * TODO: Revisit this in the event that we instead use an onMember call against individual
+       * members.
+       */
+      @Override
+      public boolean isHA() {
+        return false;
+      }
-    Map<Boolean, List<PublishResult>> results = subscriptions
-        .findSubscriptions(channel)
-        .stream()
-        .map(subscription -> subscription.publishMessage(channel, message))
-        .collect(Collectors.partitioningBy(PublishResult::isSuccessful));
+    List<Subscription> foundSubscriptions = subscriptions
+        .findSubscriptions(channel);
+    if (foundSubscriptions.isEmpty()) {
+      return 0;
+    }
-    prune(results.get(false));
+    PublishResultCollector publishResultCollector =
+        new PublishResultCollector(foundSubscriptions.size(), subscriptions);
-    return results.get(true).size();
+    foundSubscriptions.forEach(
+        subscription -> subscription.publishMessage(channel, message, publishResultCollector));
+
+    return publishResultCollector.getSuccessCount();
-  private void prune(List<PublishResult> failedSubscriptions) {
-    failedSubscriptions.forEach(publishResult -> {
-      Client client = publishResult.getClient();
-      if (client.isDead()) {
-        subscriptions.remove(client);
-      }
-    });
-  }

GEODE-7585: Create API for starting a locator in the membership package

Creating a new MembershipLocator and MembershipLocatorBuilder that are used to
create the membership locator. These classes encapsulate the TcpServer,
PrimaryHandler, and GMSLocator that were previously held by InternalLocator.

Getting rid of some intermdiate classes that wrapped the GMSLocator -
NetLocator and GMSLocatorAdapter.

Refactoring the restart logic out of PrimaryHandler. There is now a separate
RestartHandler, and a separate collection that tracks RestartHandlers. Removing
RestartableTcpHandler.

Removing TcpServerFactory.

-package org.apache.geode.distributed.internal;
+package org.apache.geode.distributed.internal.membership.gms.locator;
-import org.apache.geode.cache.GemFireCache;
-import org.apache.geode.cache.client.internal.locator.wan.LocatorMembershipListener;
-import org.apache.geode.distributed.DistributedSystem;
-import org.apache.geode.distributed.internal.membership.gms.locator.PeerLocatorRequest;
-public class PrimaryHandler implements RestartableTcpHandler {
+public class PrimaryHandler implements TcpHandler {
-  private final LocatorMembershipListener locatorListener;
-  private final InternalLocator internalLocator;
+  private final TcpHandler fallbackHandler;
-  private volatile Map<Class, RestartableTcpHandler> handlerMapping = new HashMap<>();
-  private volatile Set<RestartableTcpHandler> allHandlers = new HashSet<>();
+  private volatile Map<Class<?>, TcpHandler> handlerMapping = new HashMap<>();
+  private volatile Set<TcpHandler> allHandlers = new HashSet<>();
+  private int locatorWaitTime;
-  PrimaryHandler(InternalLocator locator, LocatorMembershipListener listener) {
-    locatorListener = listener;
-    internalLocator = locator;
+  PrimaryHandler(TcpHandler fallbackHandler, int locatorWaitTime) {
+    this.locatorWaitTime = locatorWaitTime;
+    this.fallbackHandler = fallbackHandler;
+    allHandlers.add(fallbackHandler);
-    if (locatorListener != null) {
-      // This is deferred until now as the initial requested port could have been 0
-      locatorListener.setPort(internalLocator.getPort());
-    }
-  public void restarting(DistributedSystem ds, GemFireCache cache,
-      InternalConfigurationPersistenceService sharedConfig) {
-    if (ds != null) {
-      for (RestartableTcpHandler handler : allHandlers) {
-        handler.restarting(ds, cache, sharedConfig);
-      }
-    }
-  }
-
-  @Override
-  public void restartCompleted(DistributedSystem ds) {
-    if (ds != null) {
-      for (RestartableTcpHandler handler : allHandlers) {
-        handler.restartCompleted(ds);
-      }
-    }
-  }
-
-  @Override
-      if (locatorListener != null) {
-        return locatorListener.handleRequest(request);
+      if (fallbackHandler != null) {
+        return fallbackHandler.processRequest(request);
-        int locatorWaitTime = internalLocator.getConfig().getLocatorWaitTime();
+        int locatorWaitTime = this.locatorWaitTime;
-    try {
-      for (TcpHandler handler : allHandlers) {
+    for (TcpHandler handler : allHandlers) {
+      try {
+      } catch (Throwable e) {
+        logger.error("Caught exception shutting down handler", e);
-    } finally {
-      internalLocator.handleShutdown();
-  synchronized boolean isHandled(Class clazz) {
+  synchronized boolean isHandled(Class<?> clazz) {
-  public synchronized void addHandler(Class clazz, RestartableTcpHandler handler) {
-    Map<Class, RestartableTcpHandler> tmpHandlerMapping = new HashMap<>(handlerMapping);
-    Set<RestartableTcpHandler> tmpAllHandlers = new HashSet<>(allHandlers);
+  public synchronized void addHandler(Class<?> clazz, TcpHandler handler) {
+    Map<Class<?>, TcpHandler> tmpHandlerMapping = new HashMap<>(handlerMapping);
+    Set<TcpHandler> tmpAllHandlers = new HashSet<>(allHandlers);

Merge branch 'release/1.3.0'

-import static org.apache.geode.management.internal.cli.multistep.CLIMultiStepHelper.execCLISteps;
+import java.lang.reflect.Method;
+import java.nio.file.Path;
+import java.util.Map;
+import org.springframework.shell.core.ExecutionStrategy;
+import org.springframework.shell.core.Shell;
+import org.springframework.shell.event.ParseResult;
+import org.springframework.util.Assert;
+
-import org.apache.geode.management.cli.CommandProcessingException;
-import org.apache.geode.management.internal.cli.multistep.MultiStepCommand;
+import org.apache.geode.management.internal.cli.remote.CommandExecutor;
-import org.springframework.shell.core.ExecutionStrategy;
-import org.springframework.shell.core.Shell;
-import org.springframework.shell.event.ParseResult;
-import org.springframework.util.Assert;
-import org.springframework.util.ReflectionUtils;
-
-import java.lang.reflect.Method;
-import java.nio.file.Path;
-import java.util.Map;
- * Defines the {@link ExecutionStrategy} for commands that are executed in GemFire SHell (gfsh).
- * 
+ * Defines the {@link ExecutionStrategy} for commands that are executed in GemFire Shell (gfsh).
-  //////////////// ExecutionStrategy interface Methods Start ///////////////////
-  ///////////////////////// Implemented Methods ////////////////////////////////
-    Result result = null;
+    Result result;
-    try {
-      // Check if it's a multi-step command
-      MultiStepCommand cmd = method.getAnnotation(MultiStepCommand.class);
-      if (cmd != null) {
-        return execCLISteps(logWrapper, shell, parseResult);
-      }
-      // check if it's a shell only command
-      if (isShellOnly(method)) {
-        Assert.notNull(parseResult, "Parse result required");
-        synchronized (mutex) {
-          Assert.isTrue(isReadyForCommands(),
-              "ProcessManagerHostedExecutionStrategy not yet ready for commands");
-          return ReflectionUtils.invokeMethod(parseResult.getMethod(), parseResult.getInstance(),
-              parseResult.getArguments());
-        }
-      }
+    // check if it's a shell only command
+    if (isShellOnly(method)) {
+      Assert.notNull(parseResult, "Parse result required");
+      synchronized (mutex) {
+        Assert.isTrue(isReadyForCommands(), "Not yet ready for commands");
-      // check if it's a GfshParseResult
-      if (!GfshParseResult.class.isInstance(parseResult)) {
-        throw new IllegalStateException("Configuration error!");
+        return new CommandExecutor().execute(parseResult);
-
-      result = executeOnRemote((GfshParseResult) parseResult);
-    } catch (NotAuthorizedException e) {
-      result = ResultBuilder
-          .createGemFireUnAuthorizedErrorResult("Unauthorized. Reason: " + e.getMessage());
-    } catch (JMXInvocationException | IllegalStateException e) {
-      Gfsh.getCurrentInstance().logWarning(e.getMessage(), e);
-    } catch (CommandProcessingException e) {
-      Gfsh.getCurrentInstance().logWarning(e.getMessage(), null);
-      Object errorData = e.getErrorData();
-      if (errorData != null && errorData instanceof Throwable) {
-        logWrapper.warning(e.getMessage(), (Throwable) errorData);
-      } else {
-        logWrapper.warning(e.getMessage());
-      }
-    } catch (Exception e) {
-      Gfsh.getCurrentInstance().logWarning("Unexpected exception occurred. " + e.getMessage(), e);
-      // Log other exceptions in gfsh log
-      logWrapper.warning("Unexpected error occurred while executing command : "
-          + ((GfshParseResult) parseResult).getUserInput(), e);
+
+    // check if it's a GfshParseResult
+    if (!GfshParseResult.class.isInstance(parseResult)) {
+      throw new IllegalStateException("Configuration error!");
+    }
+
+    result = executeOnRemote((GfshParseResult) parseResult);
-  // Not used currently
-  // private static String getCommandName(ParseResult result) {
-  // Method method = result.getMethod();
-  // CliCommand cliCommand = method.getAnnotation(CliCommand.class);
-  //
-  // return cliCommand != null ? cliCommand.value() [0] : null;
-  // }
-
-    // TODO: Is additional cleanup required?
-  //////////////// ExecutionStrategy interface Methods End /////////////////////
-   * @param parseResult
-   * 
-   * 
+    Path tempFile = null;
-      if (interceptor != null) {
-        Result preExecResult = interceptor.preExecution(parseResult);
-        if (Status.ERROR.equals(preExecResult.getStatus())) {
-          return preExecResult;
-        } else if (preExecResult instanceof FileResult) {
-          FileResult fileResult = (FileResult) preExecResult;
-          fileData = fileResult.toBytes();
-        }
-      } else {
+
+      if (interceptor == null) {
+
+      Result preExecResult = interceptor.preExecution(parseResult);
+      if (Status.ERROR.equals(preExecResult.getStatus())) {
+        return preExecResult;
+      }
+
+      // when the preExecution yields a FileResult, we will get the fileData out of it
+      if (preExecResult instanceof FileResult) {
+        FileResult fileResult = (FileResult) preExecResult;
+        fileData = fileResult.toBytes();
+      }
+      if (response == null) {
+        return ResultBuilder
+            .createBadResponseErrorResult("Response was null for: " + parseResult.getUserInput());
+      }
+      e.printStackTrace();
+      return ResultBuilder.createBadResponseErrorResult(
+          "Error occurred while executing \"" + parseResult.getUserInput() + "\" on manager.");
-    if (response == null) {
-      shell.logWarning("Response was null for: \"" + parseResult.getUserInput()
-          + "\". (gfsh.isConnected=" + shell.isConnectedAndReady() + ")", null);
-      return ResultBuilder.createBadResponseErrorResult(
-          " Error occurred while " + "executing \"" + parseResult.getUserInput() + "\" on manager. "
-              + "Please check manager logs for error.");
-    }
-
-        // TODO - Abhishek When debug is ON, log response in gfsh logs
-        // TODO - Abhishek handle \n better. Is it coming from GemFire formatter
-    }
-
-    Path tempFile = null;
-    if (response instanceof Path) {
+    } else if (response instanceof Path) {
+    if (commandResult == null) {
+      commandResult = ResultBuilder
+          .createGemFireErrorResult("Unable to build commandResult using the remote response.");
+    }
+

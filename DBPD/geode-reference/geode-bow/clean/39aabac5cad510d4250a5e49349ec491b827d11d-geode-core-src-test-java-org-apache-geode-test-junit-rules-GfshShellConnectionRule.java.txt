Merge remote-tracking branch 'origin/develop' into feature/GEODE-3239

-package org.apache.geode.test.dunit.rules;
+package org.apache.geode.test.junit.rules;
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.apache.geode.test.junit.rules.DescribedExternalResource;
+ * <p>
+ * <p>
- * you can use this as Rule
- * 
- * @Rule GfshShellConnectionRule rule = new GfshSheelConnectionRule(); then after you connect to a
- *       locator, you don't have to call disconnect() or close() at all, since the rule's after
- *       takes care of it for you.
+ * <p>
+ * you can use this as Rule:
- *       Or as a ClassRule
- * @ClassRule GfshShellConnectionRule rule = new GfshSheelConnectionRule(); When using as a
- *            ClassRule, if you call connect in a test, you will need to call disconnect after the
- *            test as well. See NetstatDUnitTest for example.
+ * <pre>
+ * {@literal @}Rule GfshShellConnectionRule rule = new GfshShellConnectionRule();
+ * </pre>
+ * then after you connect to a locator, you don't have to call disconnect() or close() at all, since
+ * the rule's after takes care of it for you.
+ *
+ * <p>
+ * Or as a ClassRule:
+ *
+ * <pre>
+ * {@literal @}ClassRule GfshShellConnectionRule rule = new GfshShellConnectionRule();
+ * </pre>
+ *
+ * When using as a ClassRule, if you call connect in a test, you will need to call disconnect after
+ * the test as well. See NetstatDUnitTest for example.
-  private PortType portType = PortType.jmxManger;
+  private PortType portType = PortType.jmxManager;
+  private File workingDir;
-    } catch (Exception e) {
-      throw new RuntimeException(e.getMessage(), e);
+    } catch (IOException e) {
+      throw new UncheckedIOException(e);
-    this.gfsh = new HeadlessGfsh(getClass().getName(), 30,
-        temporaryFolder.newFolder("gfsh_files").getAbsolutePath());
+    workingDir = temporaryFolder.newFolder("gfsh_files");
+    this.gfsh = new HeadlessGfsh(getClass().getName(), 30, workingDir.getAbsolutePath());
+  @Override
+  protected void after(Description description) throws Throwable {
+    close();
+
+    if (ignoredException != null) {
+      ignoredException.remove();
+    }
+  }
+
-      endpoint = "http://localhost:" + port + "/gemfire/v1";
+      endpoint = "http://localhost:" + port + "/geode-mgmt/v1";
-    // can not use Awaitility here because it starts another thead, but the Gfsh instance is in a
+    // can not use Awaitility here because it starts another thread, but the Gfsh instance is in a
-  @Override
-  protected void after(Description description) throws Throwable {
-    close();
-
-    if (ignoredException != null) {
-      ignoredException.remove();
-    }
-  }
-
-  public HeadlessGfsh getGfsh() {
+  public HeadlessGfsh getHeadlessGfsh() {
-  public CommandResult executeCommand(String command) throws Exception {
+  public Gfsh getGfsh() {
+    return gfsh.getGfsh();
+  }
+
+  public CommandResult executeCommand(String command) {
-    CommandResult result = (CommandResult) gfsh.getResult();
+    CommandResult result = null;
+    try {
+      result = (CommandResult) gfsh.getResult();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
-
-  public CommandResult executeAndVerifyCommand(String command) {
+  public CommandResult executeAndVerifyCommand(String command, String... expectedOutputs) {
-    assertThat(result.getStatus())
-        .describedAs("Failure in command: " + command + "\n Result " + result)
-        .isEqualTo(Result.Status.OK);
+    assertThat(result.getStatus()).describedAs(getGfshOutput()).isEqualTo(Result.Status.OK);
+    for (String expectedOutput : expectedOutputs) {
+      assertThat(getGfshOutput()).contains(expectedOutput);
+    }
+    return result;
+  }
+
+  public CommandResult executeAndVerifyCommandError(String command, String... expectedOutputs) {
+    CommandResult result = null;
+    try {
+      result = executeCommand(command);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    assertThat(result.getStatus()).describedAs(getGfshOutput()).isEqualTo(Result.Status.ERROR);
+    for (String expectedOutput : expectedOutputs) {
+      assertThat(getGfshOutput()).contains(expectedOutput);
+    }
+  public File getWorkingDir() {
+    return workingDir;
+  }
+
-    locator, jmxManger, http
+    locator, jmxManager, http

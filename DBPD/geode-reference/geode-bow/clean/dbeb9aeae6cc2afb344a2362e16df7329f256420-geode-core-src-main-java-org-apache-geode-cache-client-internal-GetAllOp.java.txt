Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-  
+
-  
+
-   * Does a region getAll on a server using connections from the given pool
-   * to communicate with the server.
+   * Does a region getAll on a server using connections from the given pool to communicate with the
+   * server.
+   * 
-  public static VersionedObjectList execute(ExecutablePool pool,
-                                               String region,
-                                               List keys,
-                                               Object callback)
-  {
+  public static VersionedObjectList execute(ExecutablePool pool, String region, List keys,
+      Object callback) {
-    return ((VersionedObjectList)pool.execute(op)).setKeys(keys);
+    return ((VersionedObjectList) pool.execute(op)).setKeys(keys);
-  
-  public static VersionedObjectList execute(ExecutablePool pool,
-      Region region, List keys, int retryAttempts, Object callback) {
-    AbstractOp op = new GetAllOpImpl(region.getFullPath(), keys, callback);
-    ClientMetadataService cms = ((LocalRegion)region).getCache()
-        .getClientMetadataService();
-    Map<ServerLocation, HashSet> serverToFilterMap = cms.getServerToFilterMap(
-        keys, region, true);
-    
+  public static VersionedObjectList execute(ExecutablePool pool, Region region, List keys,
+      int retryAttempts, Object callback) {
+    AbstractOp op = new GetAllOpImpl(region.getFullPath(), keys, callback);
+    ClientMetadataService cms = ((LocalRegion) region).getCache().getClientMetadataService();
+
+    Map<ServerLocation, HashSet> serverToFilterMap = cms.getServerToFilterMap(keys, region, true);
+
-      return ((VersionedObjectList)pool.execute(op)).setKeys(keys);
-    }
-    else {
+      return ((VersionedObjectList) pool.execute(op)).setKeys(keys);
+    } else {
-      List callableTasks = constructGetAllTasks(region.getFullPath(),
-          serverToFilterMap, (PoolImpl)pool, callback);
-      Map<ServerLocation, Object> results = SingleHopClientExecutor.submitGetAll(
-          serverToFilterMap, callableTasks, cms, (LocalRegion)region);
+      List callableTasks =
+          constructGetAllTasks(region.getFullPath(), serverToFilterMap, (PoolImpl) pool, callback);
+      Map<ServerLocation, Object> results = SingleHopClientExecutor.submitGetAll(serverToFilterMap,
+          callableTasks, cms, (LocalRegion) region);
-          se = (ServerConnectivityException)serverResult;
+          se = (ServerConnectivityException) serverResult;
-        }
-        else {
+        } else {
-            result = (VersionedObjectList)serverResult;
+            result = (VersionedObjectList) serverResult;
-            result.addAll((VersionedObjectList)serverResult);
+            result.addAll((VersionedObjectList) serverResult);
-      
+
-        }
-        else {
-          VersionedObjectList retryResult = GetAllOp.execute(pool,
-              region.getFullPath(), retryList, callback);
+        } else {
+          VersionedObjectList retryResult =
+              GetAllOp.execute(pool, region.getFullPath(), retryList, callback);
-  
+
-  
+
-      final Map<ServerLocation, HashSet> serverToFilterMap, final PoolImpl pool, final Object callback) {
+      final Map<ServerLocation, HashSet> serverToFilterMap, final PoolImpl pool,
+      final Object callback) {
-    ArrayList<ServerLocation> servers = new ArrayList<ServerLocation>(
-        serverToFilterMap.keySet());
+    ArrayList<ServerLocation> servers = new ArrayList<ServerLocation>(serverToFilterMap.keySet());
-      SingleHopOperationCallable task = new SingleHopOperationCallable(
-          new ServerLocation(server.getHostName(), server.getPort()), pool,
-          getAllOp,UserAttributes.userAttributes.get());
+      SingleHopOperationCallable task =
+          new SingleHopOperationCallable(new ServerLocation(server.getHostName(), server.getPort()),
+              pool, getAllOp, UserAttributes.userAttributes.get());
-  
+
-    
+
-    
+
-    public GetAllOpImpl(String region,
-                        List keys,
-                        Object callback)
-    {
+    public GetAllOpImpl(String region, List keys, Object callback) {
-        
+
-    
+
-    @Override  
+    @Override
-    
+
-    @Override  
+    @Override
-      processChunkedResponse((ChunkedMessage)msg,
-                             "getAll",
-                             new ChunkHandler() {
-                               public void handle(ChunkedMessage cm) throws Exception {
-                                 Part part = cm.getPart(0);
-                                 try {
-                                   Object o = part.getObject();
-                                   if (o instanceof Throwable) {
-                                     String s = "While performing a remote getAll";
-                                     exceptionRef[0] = new ServerOperationException(s, (Throwable)o);
-                                   } else {
-                                     VersionedObjectList chunk = (VersionedObjectList)o;
-                                     chunk.replaceNullIDs(con.getEndpoint().getMemberId());
-                                     result.addAll(chunk);
-                                   }
-                                 } catch(Exception e) {
-                                   exceptionRef[0] = new ServerOperationException("Unable to deserialize value" , e);
-                                 }
-                               }
-                             });
+      processChunkedResponse((ChunkedMessage) msg, "getAll", new ChunkHandler() {
+        public void handle(ChunkedMessage cm) throws Exception {
+          Part part = cm.getPart(0);
+          try {
+            Object o = part.getObject();
+            if (o instanceof Throwable) {
+              String s = "While performing a remote getAll";
+              exceptionRef[0] = new ServerOperationException(s, (Throwable) o);
+            } else {
+              VersionedObjectList chunk = (VersionedObjectList) o;
+              chunk.replaceNullIDs(con.getEndpoint().getMemberId());
+              result.addAll(chunk);
+            }
+          } catch (Exception e) {
+            exceptionRef[0] = new ServerOperationException("Unable to deserialize value", e);
+          }
+        }
+      });
-    @Override  
+    @Override
-    @Override  
+    @Override
-    @Override  
+
+    @Override
-    @Override  
+
+    @Override

GEODE-2404: Added gfsh support for destroying a lucene index

+import org.apache.geode.internal.logging.LogService;
+import java.util.ArrayList;
+import java.util.HashSet;
-              valueSeparator = ",") final String[] analyzers,
-
-      @CliOption(key = LuceneCliStrings.LUCENE_CREATE_INDEX__GROUP,
-          optionContext = ConverterHint.MEMBERGROUP,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          help = LuceneCliStrings.LUCENE_CREATE_INDEX__GROUP__HELP) @CliMetaData(
-              valueSeparator = ",") final String[] groups) {
+              valueSeparator = ",") final String[] analyzers) {
-          this.executeFunctionOnGroups(createIndexFunction, groups, indexInfo);
+          this.executeFunctionOnAllMembers(createIndexFunction, indexInfo);
-        this.executeFunctionOnGroups(describeIndexFunction, new String[] {}, indexInfo);
+        executeFunctionOnRegion(describeIndexFunction, indexInfo, true);
-  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.READ)
-    Result result = null;
+    Result result;
-      LuceneIndexInfo indexInfo = new LuceneIndexInfo(indexName, regionPath);
-      ResultCollector<?, ?> rc = executeFunction(destroyIndexFunction, indexInfo, false);
-      List<CliFunctionResult> functionResults = (List<CliFunctionResult>) rc.getResult();
-      CliFunctionResult cliFunctionResult = functionResults.get(0);
-
-      final TabularResultData tabularResult = ResultBuilder.createTabularResultData();
-      tabularResult.accumulate("Member", cliFunctionResult.getMemberIdOrName());
-      if (cliFunctionResult.isSuccessful()) {
-        tabularResult.accumulate("Status",
-            indexName == null
-                ? CliStrings.format(
-                    LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__SUCCESSFULLY_DESTROYED_INDEXES_FOR_REGION_0,
-                    new Object[] {regionPath})
-                : CliStrings.format(
-                    LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__SUCCESSFULLY_DESTROYED_INDEX_0_FOR_REGION_1,
-                    new Object[] {indexName, regionPath}));
-      } else {
-        tabularResult.accumulate("Status", "Failed: " + cliFunctionResult.getMessage());
-      }
-      result = ResultBuilder.buildResult(tabularResult);
-      if (cliFunctionResult.isSuccessful()) {
+      List<CliFunctionResult> accumulatedResults = new ArrayList<>();
+      final XmlEntity xmlEntity =
+          executeDestroyIndexFunction(accumulatedResults, indexName, regionPath);
+      result = getDestroyIndexResult(accumulatedResults, indexName, regionPath);
+      if (xmlEntity != null) {
-          // Update the xml entity (region entity) to remove the async event id(s) and index(es)
-          getSharedConfiguration().addXmlEntity((XmlEntity) cliFunctionResult.getXmlEntity(), null);
+          // Delete the xml entity to remove the index(es) in all groups
+          getSharedConfiguration().deleteXmlEntity(xmlEntity, null);
+      t.printStackTrace();
+  private XmlEntity executeDestroyIndexFunction(List<CliFunctionResult> accumulatedResults,
+      String indexName, String regionPath) {
+    // Destroy has three cases:
+    //
+    // - no members define the region
+    // In this case, send the request to all members to handle the case where the index has been
+    // created, but not the region
+    //
+    // - all members define the region
+    // In this case, send the request to one of the region members to destroy the index on all
+    // member
+    //
+    // - some members define the region; some don't
+    // In this case, send the request to one of the region members to destroy the index in all the
+    // region members. Then send the function to the remaining members to handle the case where
+    // the index has been created, but not the region
+    XmlEntity xmlEntity = null;
+    Cache cache = getCache();
+    Set<DistributedMember> regionMembers = getRegionMembers(cache, regionPath);
+    Set<DistributedMember> normalMembers = getNormalMembers(cache);
+    LuceneDestroyIndexInfo indexInfo = new LuceneDestroyIndexInfo(indexName, regionPath);
+    ResultCollector<?, ?> rc;
+    if (regionMembers.isEmpty()) {
+      // Attempt to destroy the proxy index on all members
+      indexInfo.setDefinedDestroyOnly(true);
+      rc = executeFunction(destroyIndexFunction, indexInfo, normalMembers);
+      accumulatedResults.addAll((List<CliFunctionResult>) rc.getResult());
+    } else {
+      // Attempt to destroy the index on a region member
+      indexInfo.setDefinedDestroyOnly(false);
+      Set<DistributedMember> singleMember = new HashSet<>();
+      singleMember.add(regionMembers.iterator().next());
+      rc = executeFunction(destroyIndexFunction, indexInfo, singleMember);
+      List<CliFunctionResult> cliFunctionResults = (List<CliFunctionResult>) rc.getResult();
+      CliFunctionResult cliFunctionResult = cliFunctionResults.get(0);
+      xmlEntity = cliFunctionResult.getXmlEntity();
+      for (DistributedMember regionMember : regionMembers) {
+        accumulatedResults.add(new CliFunctionResult(regionMember.getId(),
+            cliFunctionResult.isSuccessful(), cliFunctionResult.getMessage()));
+      }
+      // If that succeeds, destroy the proxy index(es) on all other members if necessary
+      if (cliFunctionResult.isSuccessful()) {
+        normalMembers.removeAll(regionMembers);
+        if (!normalMembers.isEmpty()) {
+          indexInfo.setDefinedDestroyOnly(true);
+          rc = executeFunction(destroyIndexFunction, indexInfo, normalMembers);
+          accumulatedResults.addAll((List<CliFunctionResult>) rc.getResult());
+        }
+      } else {
+        // @todo Should dummy results be added to the accumulatedResults for the non-region
+        // members in the failed case
+      }
+    }
+    return xmlEntity;
+  }
+
+  protected Set<DistributedMember> getRegionMembers(Cache cache, String regionPath) {
+    return CliUtil.getMembersForeRegionViaFunction(cache, regionPath, true);
+  }
+
+  protected Set<DistributedMember> getNormalMembers(Cache cache) {
+    return CliUtil.getAllNormalMembers(cache);
+  }
+
+  private Result getDestroyIndexResult(List<CliFunctionResult> cliFunctionResults, String indexName,
+      String regionPath) {
+    final TabularResultData tabularResult = ResultBuilder.createTabularResultData();
+    for (CliFunctionResult cliFunctionResult : cliFunctionResults) {
+      tabularResult.accumulate("Member", cliFunctionResult.getMemberIdOrName());
+      if (cliFunctionResult.isSuccessful()) {
+        tabularResult.accumulate("Status",
+            indexName == null
+                ? CliStrings.format(
+                    LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__SUCCESSFULLY_DESTROYED_INDEXES_FROM_REGION_0,
+                    new Object[] {regionPath})
+                : CliStrings.format(
+                    LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__SUCCESSFULLY_DESTROYED_INDEX_0_FROM_REGION_1,
+                    new Object[] {indexName, regionPath}));
+      } else {
+        tabularResult.accumulate("Status", cliFunctionResult.getMessage());
+      }
+    }
+    return ResultBuilder.buildResult(tabularResult);
+  }
+
-  protected ResultCollector<?, ?> executeFunctionOnGroups(FunctionAdapter function, String[] groups,
-      final LuceneIndexInfo indexInfo) throws IllegalArgumentException, CommandResultException {
-    ResultCollector<?, ?> results = null;
-    if (function != createIndexFunction) {
-      results = executeFunction(function, indexInfo, true);
-    } else {
-      Set<DistributedMember> targetMembers = CliUtil.findMembersOrThrow(groups, null);
-      results = CliUtil.executeFunction(function, indexInfo, targetMembers);
-    }
-    return results;
+  protected ResultCollector<?, ?> executeFunctionOnAllMembers(Function function,
+      final LuceneFunctionSerializable functionArguments)
+      throws IllegalArgumentException, CommandResultException {
+    Set<DistributedMember> targetMembers = CliUtil.getAllNormalMembers(getCache());
+    return executeFunction(function, functionArguments, targetMembers);
-    return executeFunction(searchIndexFunction, queryInfo, false);
+    return executeFunctionOnRegion(searchIndexFunction, queryInfo, false);
-  protected ResultCollector<?, ?> executeFunction(Function function,
+  protected ResultCollector<?, ?> executeFunctionOnRegion(Function function,
+    return executeFunction(function, functionArguments, targetMembers);
+  }
+
+  protected ResultCollector<?, ?> executeFunction(Function function,
+      LuceneFunctionSerializable functionArguments, Set<DistributedMember> targetMembers) {

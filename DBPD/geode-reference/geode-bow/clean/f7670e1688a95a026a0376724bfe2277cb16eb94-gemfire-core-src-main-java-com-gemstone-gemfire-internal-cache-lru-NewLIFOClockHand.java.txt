GEODE-654: Changes LIFO queue to remove touched entry

Removes any entry that has been touched while processing
the LIFO queue. Prevents issue when eviction gets stuck
during startup and GII and an entry can not be removed.

+import com.gemstone.gemfire.internal.cache.AbstractRegionEntry;
-
-  /*
-   *  return the Entry that is considered most recently used
-   */
-  @Override
-   public LRUClockNode getLRUEntry() { // new getLIFOEntry
-    LRUClockNode aNode = null;
-    synchronized (this.lock) {
-      aNode = this.tail.prevLRUNode();
-      if(aNode == this.head) {
-        return null;
-      }
-      //TODO - Dan 9/23/09 We should probably
-      //do something like this to change the tail pointer.
-      //But this code wasn't changing the tail before
-      //I made this a doubly linked list, and I don't
-      //want to change it on this branch.
-//      LRUClockNode prev = aNode.prevLRUNode();
-//      prev.setNextLRUNode(this.tail);
-//      aNode.setNextLRUNode(null);
-//      aNode.setPrevLRUNode(null);
+  
+    /* Fetch the tail member which should be the last added value and remove it
+     * from the list
+     */
+    protected LRUClockNode getTailEntry() {
+        LRUClockNode aNode = null;
+        synchronized (this.lock) {
+            aNode = this.tail.prevLRUNode();
+            if (aNode == this.head) {
+                return null; //end of lru list
+            }
+            //remove entry from list
+            LRUClockNode prev = aNode.prevLRUNode();
+            prev.setNextLRUNode(this.tail);
+            this.tail.setPrevLRUNode(prev);
+            aNode.setNextLRUNode(null);
+            aNode.setPrevLRUNode(null);
+            super.size--;
+        }
+        return aNode;
-    /* no need to update stats here as when this function finished executing 
-       next few calls update stats */
-    return aNode.testEvicted()? null:aNode;
-  }
+
+    /*
+     *  return the Entry that is considered most recently used and available 
+     * to be evicted to overflow
+     */
+    @Override
+    public LRUClockNode getLRUEntry() {
+        long numEvals = 0;
+        LRUClockNode aNode = null;
+        //search for entry to return from list
+        for (;;) {
+            aNode = getTailEntry();
+            //end of Lifo list stop searching
+            if (aNode == null) {
+                break;
+            }
+            numEvals++;
+            synchronized (aNode) {
+                //look for another entry if in transaction
+		boolean inUseByTransaction = false;
+                if (aNode instanceof AbstractRegionEntry) {
+                    if (((AbstractRegionEntry) aNode).isInUseByTransaction()) {
+                       inUseByTransaction=true; 
+                    }
+                }
+                //if entry NOT used by transaction and NOT evicted return entry
+                if (!inUseByTransaction && !aNode.testEvicted()) {
+                    break;
+                }
+            }
+        }
+        this.stats().incEvaluations(numEvals);
+        return aNode;
+    }

Merge branch 'release/1.3.0'

+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
+
+import org.apache.geode.cache.lucene.internal.security.LucenePermission;
-import org.apache.geode.internal.security.IntegratedSecurityService;
-import org.apache.geode.internal.security.SecurityService;
-import org.apache.geode.management.internal.security.ResourceOperation;
+import org.apache.geode.security.GemFireSecurityException;
-import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.stream.Collectors;
-  private SecurityService securityService = IntegratedSecurityService.getSecurityService();
-
-  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.READ)
+    getSecurityService().authorize(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
+
-        results.stream().flatMap(set -> set.stream()).sorted().collect(Collectors.toList());
+        results.stream().flatMap(Collection::stream).sorted().collect(Collectors.toList());
+  /**
+   * On the server, we also verify the resource operation permissions CLUSTER:WRITE:DISK
+   */
-    this.securityService.authorizeRegionManage(regionPath);
+    // Every lucene index potentially writes to disk.
+    getSecurityService().authorize(Resource.CLUSTER, Operation.MANAGE, LucenePermission.TARGET);
+
+
-      String[] trimmedFields =
-          Arrays.stream(fields).map(field -> field.trim()).toArray(size -> new String[size]);
+      String[] trimmedFields = Arrays.stream(fields).map(String::trim).toArray(String[]::new);
+
-  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.READ)
+
+    getSecurityService().authorize(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
+
-    return funcResults.stream().filter(indexDetails -> indexDetails != null)
-        .collect(Collectors.toList());
+    return funcResults.stream().filter(Objects::nonNull).collect(Collectors.toList());
+  /**
+   * Internally, we verify the resource operation permissions DATA:READ:[RegionName]
+   */
-  @ResourceOperation(resource = Resource.DATA, operation = Operation.WRITE)
-      @CliOption(key = LuceneCliStrings.LUCENE_SEARCH_INDEX__QUERY_STRING, mandatory = true,
+      @CliOption(
+          key = {LuceneCliStrings.LUCENE_SEARCH_INDEX__QUERY_STRING,
+              LuceneCliStrings.LUCENE_SEARCH_INDEX__QUERY_STRINGS},
+          mandatory = true,
+
+    getSecurityService().authorize(Resource.DATA, Operation.READ, regionPath);
+
+    } catch (GemFireSecurityException e) {
+      throw e;
+
-    this.securityService.authorizeRegionManage(regionPath);
+    getSecurityService().authorize(Resource.CLUSTER, Operation.MANAGE, LucenePermission.TARGET);
-    return functionResults.stream().flatMap(set -> set.stream()).sorted()
+    return functionResults.stream().flatMap(Collection::stream).sorted()
-      if (!searchResults.get(i).getExeptionFlag()) {
+      if (!searchResults.get(i).getExceptionFlag()) {
-    return (!CliUtil.isGfshVM() || (getGfsh() != null && getGfsh().isConnectedAndReady()));
+    Gfsh gfsh = Gfsh.getCurrentInstance();
+
+    // command should always be available on the server
+    if (gfsh == null) {
+      return true;
+    }
+
+    // if in gfshVM, only when gfsh is connected and ready
+    return gfsh.isConnectedAndReady();

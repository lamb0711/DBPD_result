GEODE-4299: refactor eviction (#1290)

GEODE-4299: refactor eviction

The EvictionController classes are no longer Serializable nor Cloneable. These internal classes used to be external and needed to be these things in the past because they were stored in the configuration. But they no longer are so these interfaces were removed for clarity.
The EvictionController classes are no longer responsible for creating InternalEvictionStatistics. Instead the other entities it depends on are passed in to its constructor.

The only class with an EvictionController instance is now VMLRURegionMap which makes the code easier to understand and reduces the number of inter-module dependencies.

renamed internalSetMaximum to setMaximum on EvictionAttributesImpl

AbstractBucketRegionQueue no longer uses EvictionStatistics to notify itself that it removed some objects from the queue. So it no longer needs to access all the EvictionStatistics.

AbstractLRURegionMap has been moved to VMLRURegionMap
Casts to AbstractLRURegionMap have been removed by added additional methods to RegionMap.

new EvictableRegion interface make clear the things a region implementation needs to do/provide for the eviction implementation

EvictionAttributesMutator is now implemented by the dedicated class EvictionAttributesMutatorImpl

close and clear on RegionMap now take a BucketRegion parameter so that the eviction classes do not need to keep track of the BucketRegion.

EvictionList no longer does some of the things it did before that should have been the responsibility of the EvictionController. Now the EvictionList is given the EvictionController it should defer to. The EvictionListBuilder has been simplified since EvictionList now only needs a controller.

The eviction classes that track statistics have been refactored to be clearer. Now the EvictionStats interface is implemented by classes that provide vsd type stats. The EvictionCounters interface is implemented by a class that wraps EvictionStats and provides atomics for some of them.* Removed old code that made the EvictionController classes
Serializable, Declarable, and Clonable.

-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-
-import org.apache.geode.InternalGemFireException;
-import org.apache.geode.cache.Region;
+import org.apache.geode.cache.EvictionAlgorithm;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.util.ObjectSizer;
-import org.apache.geode.internal.cache.PlaceHolderDiskRegion;
-import org.apache.geode.internal.i18n.LocalizedStrings;
- * <b>created</b> with {@link org.apache.geode.cache.EvictionAttributes}
+ * <b>created</b> with {@link EvictionAttributes}
- * LRU algorithms also specify what {@linkplain org.apache.geode.cache.EvictionAction action} should
- * be performed upon the least recently used entry when the capacity is reached. Currently, there
- * are two supported actions: {@linkplain org.apache.geode.cache.EvictionAction#LOCAL_DESTROY
- * locally destroying} the entry (which is the
- * {@linkplain org.apache.geode.cache.EvictionAction#DEFAULT_EVICTION_ACTION default}), thus freeing
- * up space in the VM, and {@linkplain org.apache.geode.cache.EvictionAction#OVERFLOW_TO_DISK
- * overflowing} the value of the entry to disk.
+ * LRU algorithms also specify what {@linkplain EvictionAction action} should be performed upon the
+ * least recently used entry when the capacity is reached. Currently, there are two supported
+ * actions: {@linkplain EvictionAction#LOCAL_DESTROY locally destroying} the entry (which is the
+ * {@linkplain EvictionAction#DEFAULT_EVICTION_ACTION default}), thus freeing up space in the VM,
+ * and {@linkplain EvictionAction#OVERFLOW_TO_DISK overflowing} the value of the entry to disk.
- * {@link org.apache.geode.cache.EvictionAttributes Eviction controllers} that use an LRU algorithm
- * maintain certain region-dependent state (such as the maximum number of entries allowed in the
- * region). As a result, an instance of {@code AbstractEvictionController} cannot be shared among
- * multiple regions. Attempts to create a region with a LRU-based capacity controller that has
- * already been used to create another region will result in an {@link IllegalStateException} being
- * thrown.
+ * {@link EvictionAttributes Eviction controllers} that use an LRU algorithm maintain certain
+ * region-dependent state (such as the maximum number of entries allowed in the region). As a
+ * result, an instance of {@code AbstractEvictionController} cannot be shared among multiple
+ * regions. Attempts to create a region with a LRU-based capacity controller that has already been
+ * used to create another region will result in an {@link IllegalStateException} being thrown.
-abstract class AbstractEvictionController implements EvictionController, Serializable, Cloneable {
+public abstract class AbstractEvictionController implements EvictionController {
-   * The key for setting the {@code eviction-action} property of an
-   * {@code AbstractEvictionController}
+   * Create and return the appropriate eviction controller using the attributes provided.
-  protected static final String EVICTION_ACTION = "eviction-action";
+  public static EvictionController create(EvictionAttributes evictionAttributes, boolean isOffHeap,
+      StatisticsFactory statsFactory, String statsName) {
+    EvictionAlgorithm algorithm = evictionAttributes.getAlgorithm();
+    EvictionAction action = evictionAttributes.getAction();
+    ObjectSizer sizer = evictionAttributes.getObjectSizer();
+    int maximum = evictionAttributes.getMaximum();
+    EvictionStats evictionStats;
+    EvictionCounters evictionCounters;
+    if (algorithm == EvictionAlgorithm.LRU_HEAP) {
+      evictionStats = new HeapLRUStatistics(statsFactory, statsName);
+      evictionCounters = new EvictionCountersImpl(evictionStats);
+      return new HeapLRUController(evictionCounters, action, sizer, algorithm);
+    }
+    if (algorithm == EvictionAlgorithm.LRU_MEMORY || algorithm == EvictionAlgorithm.LIFO_MEMORY) {
+      evictionStats = new MemoryLRUStatistics(statsFactory, statsName);
+      evictionCounters = new EvictionCountersImpl(evictionStats);
+      return new MemoryLRUController(evictionCounters, maximum, sizer, action, isOffHeap,
+          algorithm);
+    }
+    if (algorithm == EvictionAlgorithm.LRU_ENTRY || algorithm == EvictionAlgorithm.LIFO_ENTRY) {
+      evictionStats = new CountLRUStatistics(statsFactory, statsName);
+      evictionCounters = new EvictionCountersImpl(evictionStats);
+      return new CountLRUEviction(evictionCounters, maximum, action, algorithm);
+    }
-  private static final int DESTROYS_LIMIT = 1000;
+    throw new IllegalStateException("Unhandled algorithm " + algorithm);
+  }
-  protected EvictionAction evictionAction;
+  private final EvictionAction evictionAction;
-  protected transient InternalEvictionStatistics stats;
+  private final EvictionCounters counters;
-  protected BucketRegion bucketRegion;
-
-  /** The region whose capacity is controller by this eviction controller */
-  private transient volatile String regionName;
+  private final EvictionAlgorithm algorithm;
+   *
+   * @param evictionCounters
-  protected AbstractEvictionController(EvictionAction evictionAction, Region region) {
-    bucketRegion = (BucketRegion) (region instanceof BucketRegion ? region : null);
-    setEvictionAction(evictionAction);
+  protected AbstractEvictionController(EvictionCounters evictionCounters,
+      EvictionAction evictionAction, EvictionAlgorithm algorithm) {
+    this.counters = evictionCounters;
+    this.evictionAction = evictionAction;
+    this.algorithm = algorithm;
-   * Used to hook up a bucketRegion late during disk recovery.
-   */
-  @Override
-  public void setBucketRegion(Region region) {
-    if (region instanceof BucketRegion) {
-      this.bucketRegion = (BucketRegion) region;
-      this.bucketRegion.setLimit(getLimit());
-    }
-  }
-
-  /**
-  public synchronized EvictionStatistics getStatistics() {
-    // Synchronize with readObject/writeObject to avoid race
-    // conditions with copy sharing. See bug 31047.
-    return stats;
+  public EvictionCounters getCounters() {
+    return this.counters;
-  /**
-   * Releases resources obtained by this {@code AbstractEvictionController}
-   */
-  public void close() {
-    if (this.stats != null) {
-      if (bucketRegion != null) {
-        this.stats.incEvictions(bucketRegion.getEvictions() * -1);
-        this.stats.decrementCounter(bucketRegion.getCounter());
-        bucketRegion.close();
-      } else {
-        this.stats.close();
-      }
-    }
-  }
-
-  /**
-   * Returns a copy of this LRU-based eviction controller. This method is a artifact when capacity
-   * controllers were used on a {@code Region}
-   */
-  @Override
-  public Object clone() throws CloneNotSupportedException {
-    synchronized (this) {
-      AbstractEvictionController clone = (AbstractEvictionController) super.clone();
-      clone.stats = null;
-      return clone;
-    }
-  }
-
-  /**
-   * Return true if the specified capacity controller is compatible with this
-   */
-  @Override
-  public boolean equals(Object cc) {
-    if (cc == null) {
-      return false;
-    }
-    if (!getClass().isAssignableFrom(cc.getClass())) {
-      return false;
-    }
-    AbstractEvictionController other = (AbstractEvictionController) cc;
-    if (!other.evictionAction.equals(this.evictionAction)) {
-      return false;
-    }
-    return true;
-  }
-
-  /**
-   * Note that we just need to make sure that equal objects return equal hashcodes; nothing really
-   * elaborate is done here.
-   */
-  @Override
-  public int hashCode() {
-    return this.evictionAction.hashCode();
+  public EvictionAlgorithm getEvictionAlgorithm() {
+    return this.algorithm;
-    if (stats == null) {
-      throw new InternalGemFireException(
-          LocalizedStrings.LRUAlgorithm_LRU_STATS_IN_EVICTION_CONTROLLER_INSTANCE_SHOULD_NOT_BE_NULL
-              .toLocalizedString());
-    }
-    if (bucketRegion != null) {
-      return bucketRegion.getLimit();
-    }
-    return stats.getLimit();
+    return getCounters().getLimit();
-  public EvictionStatistics initStats(Object region, StatisticsFactory statsFactory) {
-    setRegionName(region);
-    InternalEvictionStatistics stats =
-        new EvictionStatisticsImpl(statsFactory, getRegionName(), this);
-    stats.setLimit(AbstractEvictionController.this.getLimit());
-    stats.setDestroysLimit(DESTROYS_LIMIT);
-    setStatistics(stats);
-    return stats;
+  public void close() {
+    getCounters().close();
-  /**
-   * Sets the action that is performed on the least recently used entry when it is evicted from the
-   * VM.
-   *
-   * @throws IllegalArgumentException If {@code evictionAction} specifies an unknown eviction
-   *         action.
-   * @see EvictionAction
-   */
-  protected void setEvictionAction(EvictionAction evictionAction) {
-    this.evictionAction = evictionAction;
+  @Override
+  public void closeBucket(BucketRegion bucketRegion) {
+    getCounters().decrementCounter(bucketRegion.getCounter());
-  protected String getRegionName() {
-    return this.regionName;
-  }
-
-  protected void setRegionName(Object region) {
-    String fullPathName;
-    if (region instanceof Region) {
-      fullPathName = ((Region) region).getFullPath();
-    } else if (region instanceof PlaceHolderDiskRegion) {
-      PlaceHolderDiskRegion placeHolderDiskRegion = (PlaceHolderDiskRegion) region;
-      if (placeHolderDiskRegion.isBucket()) {
-        fullPathName = placeHolderDiskRegion.getPrName();
-      } else {
-        fullPathName = placeHolderDiskRegion.getName();
-      }
-    } else {
-      throw new IllegalStateException("expected Region or PlaceHolderDiskRegion");
-    }
-
-    if (this.regionName != null && !this.regionName.equals(fullPathName)) {
-      throw new IllegalArgumentException(
-          LocalizedStrings.LRUAlgorithm_LRU_EVICTION_CONTROLLER_0_ALREADY_CONTROLS_THE_CAPACITY_OF_1_IT_CANNOT_ALSO_CONTROL_THE_CAPACITY_OF_REGION_2
-              .toLocalizedString(AbstractEvictionController.this, this.regionName, fullPathName));
-    }
-    this.regionName = fullPathName; // store the name not the region since
-    // region is not fully constructed yet
-  }
-
-  protected void setStatistics(InternalEvictionStatistics stats) {
-    this.stats = stats;
-  }
-
-  private void writeObject(ObjectOutputStream out) throws IOException {
-    synchronized (this) { // See bug 31047
-      out.writeObject(this.evictionAction);
-    }
-  }
-
-  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-    synchronized (this) { // See bug 31047
-      this.evictionAction = (EvictionAction) in.readObject();
-    }
+  @Override
+  public void setPerEntryOverhead(int entryOverhead) {
+    // nothing needed by default

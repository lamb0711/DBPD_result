Merge branch 'release/1.8.0'

-import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
-              LocalizedStrings.ParallelAsyncEventQueue_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1
-                  .toLocalizedString(new Object[] {
+              String.format(
+                  "Parallel Async Event Queue %s can not be used with replicated region %s",
+                  new Object[] {
-            LocalizedStrings.ParallelGatewaySender_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1
-                .toLocalizedString(new Object[] {this.sender.getId(), userRegion.getFullPath()}));
+            String.format("Parallel gateway sender %s can not be used with replicated region %s",
+                new Object[] {this.sender.getId(), userRegion.getFullPath()}));
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
-              this.getClass()), veryUnLikely);
+          logger.fatal("Unexpected Exception during init of " +
+              this.getClass(),
+              veryUnLikely);
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
-              this.getClass()), alsoUnlikely);
+          logger.fatal("Unexpected Exception during init of " +
+              this.getClass(),
+              alsoUnlikely);
-            LocalizedStrings.ParallelGatewaySenderQueue_NON_PERSISTENT_GATEWAY_SENDER_0_CAN_NOT_BE_ATTACHED_TO_PERSISTENT_REGION_1
-                .toLocalizedString(new Object[] {this.sender.getId(), userPR.getFullPath()}));
+            String.format(
+                "Non persistent gateway sender %s can not be attached to persistent region %s",
+                new Object[] {this.sender.getId(), userPR.getFullPath()}));
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
-              this.getClass()), veryUnLikely);
+          logger.fatal("Unexpected Exception during init of " +
+              this.getClass(),
+              veryUnLikely);
-    final LoggingThreadGroup loggingThreadGroup =
-        LoggingThreadGroup.createThreadGroup("WAN Queue Conflation Logger Group", logger);
-
-    final ThreadFactory threadFactory = new ThreadFactory() {
-      public Thread newThread(final Runnable task) {
-        final Thread thread = new Thread(loggingThreadGroup, task, "WAN Queue Conflation Thread");
-        thread.setDaemon(true);
-        return thread;
-      }
-    };
-
+    int poolSize = Runtime.getRuntime().availableProcessors();
-        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), threadFactory);
+        LoggingExecutors.newFixedThreadPool("WAN Queue Conflation Thread", true, poolSize);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.ParallelGatewaySenderQueue_COULD_NOT_TERMINATE_CONFLATION_THREADPOOL,
-              (sender == null ? "all" : sender)));
+          logger.warn("Conflation thread pool did not terminate for the GatewaySender : {}",
+              (sender == null ? "all" : sender));
-      logger.warn(LocalizedMessage
-          .create(LocalizedStrings.NOT_QUEUING_AS_USERPR_IS_NOT_YET_CONFIGURED, value));
+      logger.warn(
+          "GatewaySender: Not queuing the event {}, as the region for which this event originated is not yet configured in the GatewaySender",
+          value);
-        logger.info(
-            LocalizedMessage.create(LocalizedStrings.HARegionQueue_THE_QUEUEREMOVALTHREAD_IS_DONE));
+        logger.info("The QueueRemovalThread is done.");
-        logger.warn(LocalizedMessage
-            .create(LocalizedStrings.HARegionQueue_QUEUEREMOVALTHREAD_IGNORED_CANCELLATION));
+        logger.warn("QueueRemovalThread ignored cancellation");

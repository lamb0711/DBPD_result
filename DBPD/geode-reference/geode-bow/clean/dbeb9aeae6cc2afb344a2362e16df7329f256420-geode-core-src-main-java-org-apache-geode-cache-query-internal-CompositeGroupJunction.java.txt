Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.query.internal.SelectResultsComparator;
- * An object of this class gets created during the organization of operands in a
- * CompiledJunction. It gets created if there exists an equi join condition
- * across two regions with range indexes available on both LHS as well as RHS of
- * the condition. The CompositeGroupJunction may wrap GroupJunctions belonging
- * to the regions participating in the equi join condition. A single
- * CompositeGroupJunction may span multiple Regions and hence may contain
- * multiple filter evaluatable equi join conditions of different regions as well
- * as their GroupJunctions if any.
+ * An object of this class gets created during the organization of operands in a CompiledJunction.
+ * It gets created if there exists an equi join condition across two regions with range indexes
+ * available on both LHS as well as RHS of the condition. The CompositeGroupJunction may wrap
+ * GroupJunctions belonging to the regions participating in the equi join condition. A single
+ * CompositeGroupJunction may span multiple Regions and hence may contain multiple filter
+ * evaluatable equi join conditions of different regions as well as their GroupJunctions if any.
- *  
+ * 
-public class CompositeGroupJunction extends AbstractCompiledValue implements 
-    Filter, OQLLexerTokenTypes {
+public class CompositeGroupJunction extends AbstractCompiledValue
+    implements Filter, OQLLexerTokenTypes {
-  
+
-  }  
+  }
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    }
-    else {
+    } else {
-   * Add the Independent iterator of the Group which is constituent of this
-   * CompositeGroupJunction
+   * Add the Independent iterator of the Group which is constituent of this CompositeGroupJunction
-   * @param itr RuntimeIterator The independent iterator for the region forming
-   *          the CompositeGroupJunction
+   * @param itr RuntimeIterator The independent iterator for the region forming the
+   *        CompositeGroupJunction
-   * Add the GroupJunction for a Region as a part of CompositeGroupJunction ,
-   * implying that their exists atleast one equi join condition which involes
-   * the Region which the GroupJunction represents
+   * Add the GroupJunction for a Region as a part of CompositeGroupJunction , implying that their
+   * exists atleast one equi join condition which involes the Region which the GroupJunction
+   * represents
-   * @param iterOps List of CompiledValues representing conditions which are
-   *          iter evaluatable. This will be set only if there does not exist
-   *          any independent condition or filter evaluatabel subtree
-   *          CompiledJunction and the complete expansion flag is turned on
+   * @param iterOps List of CompiledValues representing conditions which are iter evaluatable. This
+   *        will be set only if there does not exist any independent condition or filter evaluatabel
+   *        subtree CompiledJunction and the complete expansion flag is turned on
-   * This flag gets toggled if only a Single CompositeGroupJunction gets
-   * created. It means that an AllGroupJunction will not exist and the result
-   * obtained from the evaluation of CompositeGroupJunction will be expanded to
-   * the level of query from clause ( i.e top level iterators).
-   *  
+   * This flag gets toggled if only a Single CompositeGroupJunction gets created. It means that an
+   * AllGroupJunction will not exist and the result obtained from the evaluation of
+   * CompositeGroupJunction will be expanded to the level of query from clause ( i.e top level
+   * iterators).
+   * 
-    this.indpndnts = (RuntimeIterator[]) this.indpndntItrs
-        .toArray(this.indpndnts);
-    //TODO:Asif identifying a cleaner way of making the
+    this.indpndnts = (RuntimeIterator[]) this.indpndntItrs.toArray(this.indpndnts);
+    // TODO:Asif identifying a cleaner way of making the
-   * @param temp CompositeGroupJunction which gets merged in this
-   *          CompositeGroupJunction. This fusion occurs during creation of
-   *          junction if the order in which the conditions of where clause
-   *          arrival are such that condition1 tying region1 & region2 ,
-   *          condition 2 tying region 3 & region 4 and condition 3 tying region
-   *          3 and region 4. In such case , finally it should result in a
-   *          single CompositeGroupJunction containing region1, region2 , region
-   *          3 and region4 conditions and theire correspodning GroupJunctions
-   *          if any.
+   * @param temp CompositeGroupJunction which gets merged in this CompositeGroupJunction. This
+   *        fusion occurs during creation of junction if the order in which the conditions of where
+   *        clause arrival are such that condition1 tying region1 & region2 , condition 2 tying
+   *        region 3 & region 4 and condition 3 tying region 3 and region 4. In such case , finally
+   *        it should result in a single CompositeGroupJunction containing region1, region2 , region
+   *        3 and region4 conditions and theire correspodning GroupJunctions if any.
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      }
-      else {
+      } else {
-    boolean delayIterOpEval = (this.groupJunctions != null && this.groupJunctions
-        .size() != 0);
+    boolean delayIterOpEval = (this.groupJunctions != null && this.groupJunctions.size() != 0);
-        intermediateResults = ((Filter) cc)
-            .filterEvaluate(context, intermediateResults, false,
-                null/* iterOpn = null */, null/* send independent itrs null */, false,true, false);
+        intermediateResults = ((Filter) cc).filterEvaluate(context, intermediateResults, false,
+            null/* iterOpn = null */, null/* send independent itrs null */, false, true, false);
-          StructType structType = QueryUtils .createStructTypeForRuntimeIterators(
-              this.completeExpansion ? context.getCurrentIterators() : QueryUtils.
-                  getDependentItrChainForIndpndntItrs( this.indpndnts, context));
-          return QueryUtils.createStructCollection(context, structType) ;
+          StructType structType = QueryUtils.createStructTypeForRuntimeIterators(
+              this.completeExpansion ? context.getCurrentIterators()
+                  : QueryUtils.getDependentItrChainForIndpndntItrs(this.indpndnts, context));
+          return QueryUtils.createStructCollection(context, structType);
-    intermediateResults = ((Filter) cc).filterEvaluate(context,
-        intermediateResults, this.completeExpansion, delayIterOpEval ? null
-            : iterOp, this.indpndnts /*
-                                      * Since this is the last condition pass
-                                      * the indpndt. grp of itrs so that result
-                                      * structset with correct placement of itrs
-                                      * can be formed
-                                      */, false,true,false);
+    intermediateResults = ((Filter) cc).filterEvaluate(context, intermediateResults,
+        this.completeExpansion, delayIterOpEval ? null : iterOp,
+        this.indpndnts /*
+                        * Since this is the last condition pass the indpndt. grp of itrs so that
+                        * result structset with correct placement of itrs can be formed
+                        */, false, true, false);
-    Support
-        .Assert(
-            iterOp == null || (this.groupJunctions != null),
-            "The Iter operand can be not null only if there exists atleast one group junction");
+    Support.Assert(iterOp == null || (this.groupJunctions != null),
+        "The Iter operand can be not null only if there exists atleast one group junction");
-        }
-        else {
-          finalList = QueryUtils.getDependentItrChainForIndpndntItrs(
-              this.indpndnts, context);
+        } else {
+          finalList = QueryUtils.getDependentItrChainForIndpndntItrs(this.indpndnts, context);
-          SelectResults filterResults = ((Filter) gj).filterEvaluate(context,
-              null);
-          Support.Assert(filterResults != null,
-              "FilterResults cannot be null here");
+          SelectResults filterResults = ((Filter) gj).filterEvaluate(context, null);
+          Support.Assert(filterResults != null, "FilterResults cannot be null here");
-              ObjectType type = ((RuntimeIterator) finalList.iterator().next())
-                  .getElementType();
+              ObjectType type = ((RuntimeIterator) finalList.iterator().next()).getElementType();
-                empty = QueryUtils.createStructCollection(context, (StructTypeImpl) type) ;
-              }
-              else {
+                empty = QueryUtils.createStructCollection(context, (StructTypeImpl) type);
+              } else {
-            }
-            else {
-              StructType strucType =QueryUtils.createStructTypeForRuntimeIterators(finalList);
-              empty = QueryUtils.createStructCollection(context, strucType) ;
+            } else {
+              StructType strucType = QueryUtils.createStructTypeForRuntimeIterators(finalList);
+              empty = QueryUtils.createStructCollection(context, strucType);
-          }
-          else {
+          } else {
-            grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(gj
-                .getIndependentIteratorForGroup()[0]);
+            grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(
+                gj.getIndependentIteratorForGroup()[0]);
-        //TODO:Asif Remove the time
+        // TODO:Asif Remove the time
-        observer
-            .beforeCartesianOfGroupJunctionsInCompositeGroupJunctionOfType_AND(results);
-        SelectResults grpCartRs = QueryUtils.cartesian(results,
-            itrsForResultFields, expansionList, finalList, context, iterOp);
-        observer
-            .afterCartesianOfGroupJunctionsInCompositeGroupJunctionOfType_AND();
-        Support.Assert(grpCartRs != null,
-            "ResultsSet obtained was NULL in CompositeGroupJunction");
+        observer.beforeCartesianOfGroupJunctionsInCompositeGroupJunctionOfType_AND(results);
+        SelectResults grpCartRs = QueryUtils.cartesian(results, itrsForResultFields, expansionList,
+            finalList, context, iterOp);
+        observer.afterCartesianOfGroupJunctionsInCompositeGroupJunctionOfType_AND();
+        Support.Assert(grpCartRs != null, "ResultsSet obtained was NULL in CompositeGroupJunction");
-      }
-      else {
+      } else {
-        AbstractGroupOrRangeJunction newGJ = (AbstractGroupOrRangeJunction) this.groupJunctions.get(0);
+        AbstractGroupOrRangeJunction newGJ =
+            (AbstractGroupOrRangeJunction) this.groupJunctions.get(0);
-          newGJ = newGJ.recreateFromOld( this.completeExpansion,this.indpndnts, iterOp);
-        }
-        else if (iterOp != null) {
+          newGJ = newGJ.recreateFromOld(this.completeExpansion, this.indpndnts, iterOp);
+        } else if (iterOp != null) {
-          newGJ = newGJ.recreateFromOld(this.completeExpansion, newGJ.getIndependentIteratorForGroup(), iterOp);
+          newGJ = newGJ.recreateFromOld(this.completeExpansion,
+              newGJ.getIndependentIteratorForGroup(), iterOp);
-        }
-        else {
+        } else {
-      intermediateResults = (intermediateResults == null) ? sr : QueryUtils
-          .intersection(intermediateResults, sr, context);
+      intermediateResults = (intermediateResults == null) ? sr
+          : QueryUtils.intersection(intermediateResults, sr, context);
-  private SelectResults evaluateOrJunction(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  private SelectResults evaluateOrJunction(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      SelectResults sr = ((Filter) cc).filterEvaluate(context, null,
-          this.completeExpansion, null, this.indpndnts,false,true,false);
-      intermediateResults = (intermediateResults == null) ? sr : QueryUtils
-          .union(intermediateResults, sr, context);
+      SelectResults sr = ((Filter) cc).filterEvaluate(context, null, this.completeExpansion, null,
+          this.indpndnts, false, true, false);
+      intermediateResults =
+          (intermediateResults == null) ? sr : QueryUtils.union(intermediateResults, sr, context);
-    //TODO:Asif Identify a cleaner approach
+    // TODO:Asif Identify a cleaner approach
-        }
-        else {
-          finalList = QueryUtils.getDependentItrChainForIndpndntItrs(
-              this.indpndnts, context);
+        } else {
+          finalList = QueryUtils.getDependentItrChainForIndpndntItrs(this.indpndnts, context);
-       
+
-          grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(gj
-              .getIndependentIteratorForGroup()[0]);
+          grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(
+              gj.getIndependentIteratorForGroup()[0]);
-          SelectResults expandedResult = QueryUtils.cartesian(grpResults,
-              itrsForResultFields, expansionList, finalList, context, null/*
-                                                                           * Iter
-                                                                           * oprenad
-                                                                           * for
-                                                                           * OR
-                                                                           * Junction
-                                                                           * evaluation
-                                                                           * should
-                                                                           * be
-                                                                           * null
-                                                                           */);
+          SelectResults expandedResult =
+              QueryUtils.cartesian(grpResults, itrsForResultFields, expansionList, finalList,
+                  context, null/*
+                                * Iter oprenad for OR Junction evaluation should be null
+                                */);
-      }
-      else {
+      } else {
-        AbstractGroupOrRangeJunction newGJ = (AbstractGroupOrRangeJunction) this.groupJunctions.get(0);
+        AbstractGroupOrRangeJunction newGJ =
+            (AbstractGroupOrRangeJunction) this.groupJunctions.get(0);
-          //TODO:Asif: Check it out ..................
-          newGJ = newGJ.recreateFromOld( this.completeExpansion, this.indpndnts, null);
+          // TODO:Asif: Check it out ..................
+          newGJ = newGJ.recreateFromOld(this.completeExpansion, this.indpndnts, null);
-        intermediateResults = (intermediateResults == null) ? rs : QueryUtils
-            .union(rs, intermediateResults, context);
+        intermediateResults =
+            (intermediateResults == null) ? rs : QueryUtils.union(rs, intermediateResults, context);
-   * @return Array of RuntimeIterator which represent the independent iterators
-   *         of each Group which form the CompositeGroupJunction
+   * @return Array of RuntimeIterator which represent the independent iterators of each Group which
+   *         form the CompositeGroupJunction
-  //TODO:Asif : Identify a way to make it unmodifiable
+  // TODO:Asif : Identify a way to make it unmodifiable
-   * @return List containing the filter evaluatable Composite Comparison
-   *         conditions ( equi join conditions across the regions)
+   * @return List containing the filter evaluatable Composite Comparison conditions ( equi join
+   *         conditions across the regions)
-   * @return List containg GroupJunctions which are part of this
-   *         CompositeGroupJunction. It can be null if there does not exist any
-   *         filter evaluatable condition belonging solely to an independent
-   *         region or its group of iterators, constituting the
-   *         CompositeGroupJunction, so that no GroupJunctions get assosciated
-   *         with the CompositeGroupJunction
-   *  
+   * @return List containg GroupJunctions which are part of this CompositeGroupJunction. It can be
+   *         null if there does not exist any filter evaluatable condition belonging solely to an
+   *         independent region or its group of iterators, constituting the CompositeGroupJunction,
+   *         so that no GroupJunctions get assosciated with the CompositeGroupJunction
+   * 
-    //  return unmodifiable copy
-    return this.groupJunctions != null ? Collections
-        .unmodifiableList(this.groupJunctions) : null;
+    // return unmodifiable copy
+    return this.groupJunctions != null ? Collections.unmodifiableList(this.groupJunctions) : null;
-   * @return List containing the iter evaluatable conditions.This Can be null in
-   *         case there exists more than one filter operand in CompiledJunction
-   *         in which case all the iter ops will become part of iter operand of
-   *         CompiledJunction. This can be not null iff the complete expansion
-   *         flag is true
+   * @return List containing the iter evaluatable conditions.This Can be null in case there exists
+   *         more than one filter operand in CompiledJunction in which case all the iter ops will
+   *         become part of iter operand of CompiledJunction. This can be not null iff the complete
+   *         expansion flag is true
-    return this.iterOperands != null ? Collections
-        .unmodifiableList(this.iterOperands) : null;
+    return this.iterOperands != null ? Collections.unmodifiableList(this.iterOperands) : null;
-  
-  public int getSizeEstimate(ExecutionContext context)throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
-	 return 1;
+
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    return 1;

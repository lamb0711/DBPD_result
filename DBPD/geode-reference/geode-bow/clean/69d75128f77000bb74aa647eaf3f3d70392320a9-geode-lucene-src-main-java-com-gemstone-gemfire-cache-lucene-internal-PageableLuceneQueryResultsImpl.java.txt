Merge branch 'develop' into feature/GEODE-1571

+import java.util.Collections;
-  
+
+  /**
+   * * Current page of results
+   */
+  private List<LuceneResultStruct<K,V>> currentPage;
+
+  public List<LuceneResultStruct<K,V>> getHitEntries(int fromIndex, int toIndex) {
+    List<EntryScore<K>> scores = hits.subList(fromIndex, toIndex);
+    ArrayList<K> keys = new ArrayList<K>(scores.size());
+    for(EntryScore<K> score : scores) {
+      keys.add(score.getKey());
+    }
+
+    Map<K,V> values = userRegion.getAll(keys);
+
+    ArrayList<LuceneResultStruct<K,V>> results = new ArrayList<LuceneResultStruct<K,V>>(scores.size());
+    for(EntryScore<K> score : scores) {
+      V value = values.get(score.getKey());
+      if (value!=null)
+        results.add(new LuceneResultStructImpl(score.getKey(), value, score.getScore()));
+    }
+    return results;
+  }
+
-    
-    int end = currentHit + pageSize;
-    end = end > hits.size() ? hits.size() : end;
-    List<EntryScore<K>> scores = hits.subList(currentHit, end);
-    
-    ArrayList<K> keys = new ArrayList<K>(hits.size());
-    for(EntryScore<K> score : scores) {
-      keys.add(score.getKey());
-    }
-    
-    Map<K,V> values = userRegion.getAll(keys);
+    List<LuceneResultStruct<K,V>> result = advancePage();
+    currentPage = null;
+    return result;
+  }
-    ArrayList<LuceneResultStruct<K,V>> results = new ArrayList<LuceneResultStruct<K,V>>(hits.size());
-    for(EntryScore<K> score : scores) {
-      V value = values.get(score.getKey());
-      results.add(new LuceneResultStructImpl(score.getKey(), value, score.getScore()));
+  private List<LuceneResultStruct<K, V>> advancePage() {
+    if(currentPage != null) {
+      return currentPage;
-    
-    currentHit = end;
-    
-    return results;
+    int resultSize = (pageSize != Integer.MAX_VALUE) ? pageSize : hits.size();
+    currentPage = new ArrayList<LuceneResultStruct<K,V>>(resultSize);
+    while (currentPage.size()<pageSize && currentHit < hits.size()) {
+      int end = currentHit + pageSize - currentPage.size();
+      end = end > hits.size() ? hits.size() : end;
+      currentPage.addAll(getHitEntries(currentHit, end));
+      currentHit = end;
+    }
+    return currentPage;
-    return hits.size() > currentHit;
+
+    advancePage();
+    if ( currentPage.isEmpty() ) {
+      return false;
+    }
+    return true;

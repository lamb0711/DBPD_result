Merge branch 'develop' into feature/GEODE-3109

+import org.apache.geode.internal.VersionedDataInputStream;
+    return getDistributedMember(Version.CURRENT);
+  }
+
+  /**
+   * deserialize the memberID bytes using the given version. The correct thing to do would be to
+   * have EventID carry the version ordinal of the serialized memberID, or to have it be part of the
+   * memberID bytes and use that version to deserialize the bytes. Clients prior to 1.1.0 need to
+   * have UUID bytes in the memberID. Newer clients don't require this.
+   */
+  public InternalDistributedMember getDistributedMember(Version targetVersion) {
+    if (targetVersion.compareTo(Version.GEODE_110) < 0) {
+      // GEODE-3153: clients expect to receive UUID bytes, which are only
+      // read if the stream's version is 1.0.0-incubating
+      dis = new VersionedDataInputStream(dis, Version.GFE_90);
+    }
-    if (version.compareTo(Version.GFE_90) <= 0) {
-      InternalDistributedMember member = getDistributedMember();
-      HeapDataOutputStream hdos = new HeapDataOutputStream(version);
+    // if we are sending to old clients we need to reserialize the ID
+    // using the client's version to ensure it gets the proper on-wire form
+    // of the identifier
+    // See GEODE-3072
+    if (version.compareTo(Version.GEODE_110) < 0) {
+      InternalDistributedMember member = getDistributedMember(Version.GFE_90);
+      // reserialize with the client's version so that we write the UUID
+      // bytes
+      HeapDataOutputStream hdos = new HeapDataOutputStream(Version.GFE_90);
-    if (!Arrays.equals(membershipID, other.membershipID))
+    return equalMembershipIds(membershipID, other.membershipID);
+  }
+
+  /** GEODE_3072 - 1.0.0 client IDs contain a UUID and member-weight byte that are all zero */
+  static final int NULL_90_MEMBER_DATA_LENGTH = 17;
+
+  /** minimum length of an ID array */
+  static final int MINIMIM_ID_LENGTH = 19;
+
+  /**
+   * check to see if membership ID byte arrays are equal
+   */
+  static public boolean equalMembershipIds(byte[] m1, byte[] m2) {
+    int sizeDifference = Math.abs(m1.length - m2.length);
+    if (sizeDifference != 0 && sizeDifference != NULL_90_MEMBER_DATA_LENGTH) {
+    }
+    for (int i = 0; i < m1.length; i++) {
+      if (i >= m2.length) {
+        return nullUUIDCheck(m1, i);
+      }
+      if (m1[i] != m2[i]) {
+        return false;
+      }
+    }
+    if (m1.length != m2.length) {
+      return nullUUIDCheck(m2, m1.length);
+    }
+  /**
+   * GEODE-3072 - v1.0.0 memberIDs in EventIDs may have trailing bytes that should be ignored
+   */
+  static private boolean nullUUIDCheck(byte[] memberID, int position) {
+    if (position < 0) {
+      return false;
+    }
+    if (memberID.length - position != NULL_90_MEMBER_DATA_LENGTH) {
+      return false;
+    }
+    for (int i = position; i < memberID.length; i++) {
+      if (memberID[i] != 0) {
+        return false;
+      }
+    }
+    return true;
+  }
-  @Override
+  /**
+   * form the hashcode for the memberID byte array
+   */
+  static public int hashCodeMemberId(byte[] memberID) {
+    if (memberID.length < (NULL_90_MEMBER_DATA_LENGTH + MINIMIM_ID_LENGTH)
+        || !nullUUIDCheck(memberID, memberID.length - NULL_90_MEMBER_DATA_LENGTH)) {
+      return Arrays.hashCode(memberID);
+    }
+    byte[] newID = new byte[memberID.length - NULL_90_MEMBER_DATA_LENGTH];
+    System.arraycopy(memberID, 0, newID, 0, newID.length);
+    return Arrays.hashCode(newID);
+  }
+
-      result = prime * result + Arrays.hashCode(membershipID);
+      result = prime * result + hashCodeMemberId(membershipID);
-      buf.append("[");
+      buf.append("id=").append(membershipID.length).append("bytes;");

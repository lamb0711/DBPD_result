Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.lang.reflect.Method;
-
-import org.springframework.shell.event.ParseResult;
-import org.springframework.util.Assert;
-import org.springframework.util.ReflectionUtils;
-
-import org.apache.geode.distributed.DistributedLockService;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.SharedConfiguration;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.springframework.shell.event.ParseResult;
+import org.springframework.util.Assert;
+import org.springframework.util.ReflectionUtils;
+
+import java.lang.reflect.Method;
+
-      
+
-        //Remote command means implemented for Gfsh and ParseResult should be GfshParseResult.
-        //TODO: should this message be more specific?
+        // Remote command means implemented for Gfsh and ParseResult should be GfshParseResult.
+        // TODO: should this message be more specific?
-      
+
-      
+
-      
+
-            interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest().forName(interceptorClass).newInstance();
+            interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest()
+                .forName(interceptorClass).newInstance();
-            } else if (preExecResult instanceof FileResult) {            
+            } else if (preExecResult instanceof FileResult) {
-              byte[][]fileData = fileResult.toBytes();
+              byte[][] fileData = fileResult.toBytes();
-            return ResultBuilder.createBadConfigurationErrorResult("Interceptor Configuration Error");
+            return ResultBuilder
+                .createBadConfigurationErrorResult("Interceptor Configuration Error");
-        
-        GemFireCacheImpl gfc = GemFireCacheImpl.getInstance();
-        
-        //Do the locking and annotation check only if the shared configuration service is enabled 
-        //Else go the usual route of command execution
-        if (gfc.getDistributionManager().isSharedConfigurationServiceEnabledForDS() && 
-            (writesToSharedConfiguration(method) || readsFromSharedConfiguration(method))) {
-          DistributedLockService dls = SharedConfiguration.getSharedConfigLockService(InternalDistributedSystem.getAnyInstance());
-          if (dls.lock(SharedConfiguration.SHARED_CONFIG_LOCK_NAME, 10000, -1)) {
-            try {
-              result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(), gfshParseResult.getInstance(), gfshParseResult.getArguments());
-            } finally {
-              dls.unlock(SharedConfiguration.SHARED_CONFIG_LOCK_NAME);
-            }
-          } else {
-            return ResultBuilder.createGemFireErrorResult("Unable to execute the command due to ongoing configuration change/member startup.");
-          }
-        } else {
-          result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(), gfshParseResult.getInstance(), gfshParseResult.getArguments());
-        }
-        
-        
+
+        result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(),
+            gfshParseResult.getInstance(), gfshParseResult.getArguments());
+
-          logWrapper.info("Error occurred while executing \""+gfshParseResult.getUserInput()+"\".");
+          logWrapper
+              .info("Error occurred while executing \"" + gfshParseResult.getUserInput() + "\".");
-        
+
-            "Only Remote command can be executed through "
-                + ManagementService.class.getSimpleName()
-                + ".processCommand() or ManagementMBean's processCommand " 
-                + "operation. Please refer documentation for the list of " 
-                + "commands.");
+            "Only Remote command can be executed through " + ManagementService.class.getSimpleName()
+                + ".processCommand() or ManagementMBean's processCommand "
+                + "operation. Please refer documentation for the list of " + "commands.");
-    } catch(RuntimeException e) {
+    } catch (RuntimeException e) {
-  
-  private boolean writesToSharedConfiguration (Method method) {
-    CliMetaData cliMetadata = method.getAnnotation(CliMetaData.class);
-    return cliMetadata != null && cliMetadata.writesToSharedConfiguration();
-  }
-  
-  private boolean readsFromSharedConfiguration (Method method) {
-    CliMetaData cliMetadata = method.getAnnotation(CliMetaData.class);
-    return cliMetadata != null && cliMetadata.readsSharedConfiguration();
-  }
-  
+
-  public void terminate() {
-  }
+  public void terminate() {}

Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-  private final HashMap<String, LuceneIndex> indexMap = new HashMap<String, LuceneIndex>();;
+  private final HashMap<String, LuceneIndex> indexMap = new HashMap<String, LuceneIndex>();
+  private final HashMap<String, LuceneIndexCreationProfile> definedIndexMap = new HashMap<>();
+
+    registerDefinedIndex(LuceneServiceImpl.getUniqueIndexName(indexName, regionPath),
+                                new LuceneIndexCreationProfile(indexName, regionPath, fields, analyzer, fieldAnalyzers));
+
+      definedIndexMap.remove(LuceneServiceImpl.getUniqueIndexName(indexName, regionPath));
+
+
+          if (!attrs.getDataPolicy().withPartitioning()) {
+            // replicated region
+            throw new UnsupportedOperationException("Lucene indexes on replicated regions are not supported");
+          }
+
+          //For now we cannot support eviction with local destroy.
+          //Eviction with overflow to disk still needs to be supported
+          EvictionAttributes evictionAttributes = attrs.getEvictionAttributes();
+          EvictionAlgorithm evictionAlgorithm = evictionAttributes.getAlgorithm();
+          if (evictionAlgorithm != EvictionAlgorithm.NONE && evictionAttributes.getAction().isLocalDestroy()) {
+            throw new UnsupportedOperationException("Lucene indexes on regions with eviction and action local destroy are not supported");
+          }
+
-    
-  
+
+
-    
-    LuceneIndexImpl index = null;
+    return new LuceneIndexForPartitionedRegion(indexName, regionPath, cache);
+  }
-    //For now we cannot support eviction with local destroy.
-    //Eviction with overflow to disk still needs to be supported
-    EvictionAttributes evictionAttributes = dataregion.getAttributes().getEvictionAttributes();
-    EvictionAlgorithm evictionAlgorithm = evictionAttributes.getAlgorithm();
-    if (evictionAlgorithm != EvictionAlgorithm.NONE && evictionAttributes.getAction().isLocalDestroy()) {
-      throw new UnsupportedOperationException("Lucene indexes on regions with eviction and action local destroy are not supported");
-    }
-
-    if (dataregion instanceof PartitionedRegion) {
-      // partitioned region
-      index = new LuceneIndexForPartitionedRegion(indexName, regionPath, cache);
-    } else {
-      // replicated region
-      throw new UnsupportedOperationException("Lucene indexes on replicated regions are not supported");
-    }
-    return index;
+  private void registerDefinedIndex(final String regionAndIndex, final LuceneIndexCreationProfile luceneIndexCreationProfile) {
+    if (definedIndexMap.containsKey(regionAndIndex) || indexMap.containsKey(regionAndIndex))
+      throw new IllegalArgumentException("Lucene index already exists in region");
+    definedIndexMap.put(regionAndIndex, luceneIndexCreationProfile);
+    definedIndexMap.remove(regionAndIndex);
+
+  public Collection<LuceneIndexCreationProfile> getAllDefinedIndexes() {
+    return definedIndexMap.values();
+  }
+
+  public LuceneIndexCreationProfile getDefinedIndex(String indexName, String regionPath) {
+    return definedIndexMap.get(getUniqueIndexName(indexName , regionPath));
+  }

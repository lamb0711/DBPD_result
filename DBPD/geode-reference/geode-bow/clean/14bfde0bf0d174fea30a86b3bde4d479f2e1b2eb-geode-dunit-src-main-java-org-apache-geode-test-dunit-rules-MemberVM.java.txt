Merge branch 'release/1.8.0'

-import static java.util.concurrent.TimeUnit.SECONDS;
-import java.util.concurrent.TimeUnit;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+
+import java.util.concurrent.CountDownLatch;
-import org.awaitility.Awaitility;
+  /**
+   * This disconnects the distributed system of the member. The reconnect thread will wait for at
+   * least the given delay before completing the attempt.
+   *
+   * @param delayReconnecting minimum delay in milliseconds before reconnect can complete.
+   */
+  public void forceDisconnect(final long delayReconnecting) {
+    vm.invoke(() -> {
+      // The reconnect thread can yield the CPU before allowing the listeners to be invoked. The
+      // latch ensures that the listener is guaranteed to be called before this method returns thus
+      // ensuring that reconnection has started but not yet completed.
+      CountDownLatch latch = new CountDownLatch(1);
+      InternalDistributedSystem.addReconnectListener(
+          new InternalDistributedSystem.ReconnectListener() {
+            @Override
+            public void reconnecting(InternalDistributedSystem oldSystem) {
+              try {
+                Thread.sleep(delayReconnecting);
+                latch.countDown();
+              } catch (InterruptedException e) {
+                e.printStackTrace();
+              }
+            }
+
+            @Override
+            public void onReconnect(InternalDistributedSystem oldSystem,
+                InternalDistributedSystem newSystem) {}
+          });
+      ClusterStartupRule.memberStarter.forceDisconnectMember();
+      latch.await();
+    });
+  }
+
-        Awaitility.waitAtMost(60, TimeUnit.SECONDS).until(() -> {
+        await().until(() -> {
-        Awaitility.waitAtMost(60, SECONDS).until(() -> {
+        await().until(() -> {

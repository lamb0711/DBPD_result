Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class CompiledIndexOperation extends AbstractCompiledValue implements 
-   MapIndexable 
-{
+public class CompiledIndexOperation extends AbstractCompiledValue implements MapIndexable {
-  
+
-  public CompiledIndexOperation(CompiledValue receiver,
-      CompiledValue indexExpr, boolean evalRegionAsEntry) {
+  public CompiledIndexOperation(CompiledValue receiver, CompiledValue indexExpr,
+      boolean evalRegionAsEntry) {
-  
+
-    return context.addDependencies(this, this.indexExpr
-        .computeDependencies(context));
+    return context.addDependencies(this, this.indexExpr.computeDependencies(context));
-  public Object evaluate(ExecutionContext context)
-      throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
+  public Object evaluate(ExecutionContext context) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
-    if (rcvr == null || rcvr == QueryService.UNDEFINED){ 
+    if (rcvr == null || rcvr == QueryService.UNDEFINED) {
-    if (context.isCqQueryContext()
-        && (rcvr instanceof Region.Entry || rcvr instanceof CqEntry)) {
+    if (context.isCqQueryContext() && (rcvr instanceof Region.Entry || rcvr instanceof CqEntry)) {
-    
-    if (rcvr instanceof Map) { return ((Map) rcvr).get(index); }
-    if ((rcvr instanceof List) || rcvr.getClass().isArray()
-        || (rcvr instanceof String)) {
-      if (!(index instanceof Integer)) { throw new TypeMismatchException(LocalizedStrings.CompiledIndexOperation_INDEX_EXPRESSION_MUST_BE_AN_INTEGER_FOR_LISTS_OR_ARRAYS.toLocalizedString()); }
+
+    if (rcvr instanceof Map) {
+      return ((Map) rcvr).get(index);
-    if (rcvr instanceof List) { return ((List) rcvr).get(((Integer) index)
-        .intValue()); }
-    if (rcvr instanceof String) { return new Character(((String) rcvr)
-        .charAt(((Integer) index).intValue())); }
+    if ((rcvr instanceof List) || rcvr.getClass().isArray() || (rcvr instanceof String)) {
+      if (!(index instanceof Integer)) {
+        throw new TypeMismatchException(
+            LocalizedStrings.CompiledIndexOperation_INDEX_EXPRESSION_MUST_BE_AN_INTEGER_FOR_LISTS_OR_ARRAYS
+                .toLocalizedString());
+      }
+    }
+    if (rcvr instanceof List) {
+      return ((List) rcvr).get(((Integer) index).intValue());
+    }
+    if (rcvr instanceof String) {
+      return new Character(((String) rcvr).charAt(((Integer) index).intValue()));
+    }
-       * in the appropriate wrapper type (i.e. java.lang.Integer, etc.) if (rcvr
-       * instanceof Object[]) { return
-       * ((Object[])rcvr)[((Integer)index).intValue()]; } throw new
-       * UnsupportedOperationException("indexing primitive arrays not yet
-       * implemented");
+       * in the appropriate wrapper type (i.e. java.lang.Integer, etc.) if (rcvr instanceof
+       * Object[]) { return ((Object[])rcvr)[((Integer)index).intValue()]; } throw new
+       * UnsupportedOperationException("indexing primitive arrays not yet implemented");
-    //Asif : In case of 4.1.0 branch where the Map implementation is not
+    // Asif : In case of 4.1.0 branch where the Map implementation is not
-      if (entry == null) { return null; }
+      if (entry == null) {
+        return null;
+      }
-     * if (rcvr instanceof Region) { Region.Entry entry =
-     * ((Region)rcvr).getEntry(index); if (entry == null) { return null; }
-     * return this.evalRegionAsEntry? entry:entry.getValue(); }
+     * if (rcvr instanceof Region) { Region.Entry entry = ((Region)rcvr).getEntry(index); if (entry
+     * == null) { return null; } return this.evalRegionAsEntry? entry:entry.getValue(); }
-    throw new TypeMismatchException(LocalizedStrings.CompiledIndexOperation_INDEX_EXPRESSION_NOT_SUPPORTED_ON_OBJECTS_OF_TYPE_0.toLocalizedString(rcvr.getClass().getName()));
+    throw new TypeMismatchException(
+        LocalizedStrings.CompiledIndexOperation_INDEX_EXPRESSION_NOT_SUPPORTED_ON_OBJECTS_OF_TYPE_0
+            .toLocalizedString(rcvr.getClass().getName()));
-  //Asif :Function for generating canonicalized expression
+  // Asif :Function for generating canonicalized expression
-  public void generateCanonicalizedExpression(StringBuffer clauseBuffer,
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
-    //  Asif: The canonicalization of Index operator will be of
+  public void generateCanonicalizedExpression(StringBuffer clauseBuffer, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    // Asif: The canonicalization of Index operator will be of
-  public CompiledValue getMapLookupKey()
-  {
+  public CompiledValue getMapLookupKey() {
-  
-  public CompiledValue getRecieverSansIndexArgs()
-  {
+
+  public CompiledValue getRecieverSansIndexArgs() {
-  
-  public List<CompiledValue> getIndexingKeys()
-  {
+
+  public List<CompiledValue> getIndexingKeys() {

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class DataCommandFunction extends FunctionAdapter implements  InternalEntity {
+public class DataCommandFunction extends FunctionAdapter implements InternalEntity {
-  
+
-  
+
-  @Override 
+  @Override
-  }  
-  
+  }
+
-      DataCommandRequest request =(DataCommandRequest) functionContext.getArguments();
-      if(logger.isDebugEnabled()){
-        logger.debug("Executing function : \n{}\n on member {}", request, System.getProperty("memberName"));
+      DataCommandRequest request = (DataCommandRequest) functionContext.getArguments();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Executing function : \n{}\n on member {}", request,
+            System.getProperty("memberName"));
-      if(request.isGet())
+      if (request.isGet())
-      else if(request.isLocateEntry())
+      else if (request.isLocateEntry())
-      else if(request.isPut())
+      else if (request.isPut())
-      else if(request.isRemove())
+      else if (request.isRemove())
-      else if(request.isSelect())
+      else if (request.isSelect())
-  
-  
+
+
-    String key = request.getKey();   
+    String key = request.getKey();
-    return remove(key,keyClass,regionName,removeAllKeys);
+    return remove(key, keyClass, regionName, removeAllKeys);
-    String key = request.getKey();              
+    String key = request.getKey();
-  
+
-    String key = request.getKey();              
+    String key = request.getKey();
-    return locateEntry(key,keyClass,valueClass,regionName,recursive);
+    return locateEntry(key, keyClass, valueClass, regionName, recursive);
-    return put(key,value,putIfAbsent,keyClass,valueClass,regionName);
+    return put(key, value, putIfAbsent, keyClass, valueClass, regionName);
-  
+
-    String query = request.getQuery();    
+    String query = request.getQuery();
-  
+
-  public static class WrappedIndexTrackingQueryObserver extends IndexTrackingQueryObserver{
-    
+  public static class WrappedIndexTrackingQueryObserver extends IndexTrackingQueryObserver {
+
-      //NOOP
+      // NOOP
-    
+
-  
+
-      // TODO : Find out if is this optimised use. Can you have something equivalent of parsed queries with names
+      // TODO : Find out if is this optimised use. Can you have something equivalent of parsed
+      // queries with names
-      DefaultQuery tracedQuery = (DefaultQuery)query;
-      WrappedIndexTrackingQueryObserver queryObserver=null;
+      DefaultQuery tracedQuery = (DefaultQuery) query;
+      WrappedIndexTrackingQueryObserver queryObserver = null;
-      long startTime=-1;
-      if(tracedQuery.isTraced()){
+      long startTime = -1;
+      if (tracedQuery.isTraced()) {
-        if(tracedQuery.isTraced()){
-          queryVerboseMsg = getLogMessage(queryObserver, startTime,queryString);
+        if (tracedQuery.isTraced()) {
+          queryVerboseMsg = getLogMessage(queryObserver, startTime, queryString);
-              if(logger.isDebugEnabled())
+              if (logger.isDebugEnabled())
-              list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_STRUCT_RESULT, jsonStruct.toString()));
+              list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_STRUCT_RESULT,
+                  jsonStruct.toString()));
-                if(logger.isDebugEnabled())
+                if (logger.isDebugEnabled())
-                if(logger.isDebugEnabled())
+                if (logger.isDebugEnabled())
-                if(logger.isDebugEnabled())
+                if (logger.isDebugEnabled())
-          if(logger.isDebugEnabled())
+          if (logger.isDebugEnabled())
-          if(logger.isDebugEnabled())
+          if (logger.isDebugEnabled())
-        }        
-        return DataCommandResult.createSelectResult(queryString, list, queryVerboseMsg, null, null, true);
+        }
+        return DataCommandResult.createSelectResult(queryString, list, queryVerboseMsg, null, null,
+            true);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e, e.getMessage(), false);
+        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
+            e.getMessage(), false);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e, e.getMessage(), false);
+        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
+            e.getMessage(), false);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e, e.getMessage(), false);
+        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
+            e.getMessage(), false);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e, e.getMessage(), false);
+        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
+            e.getMessage(), false);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e, e.getMessage(), false);
-      }finally{
-        if(queryObserver!=null){          
+        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
+            e.getMessage(), false);
+      } finally {
+        if (queryObserver != null) {
-      return DataCommandResult
-          .createSelectInfoResult(null, null, -1, null, CliStrings.QUERY__MSG__QUERY_EMPTY, false);
+      return DataCommandResult.createSelectInfoResult(null, null, -1, null,
+          CliStrings.QUERY__MSG__QUERY_EMPTY, false);
-  
-  private String toJson(Object object){
-    if(object instanceof Undefined){
+
+  private String toJson(Object object) {
+    if (object instanceof Undefined) {
-    }else if (object instanceof PdxInstance)
-      return pdxToJson((PdxInstance)object);
+    } else if (object instanceof PdxInstance)
+      return pdxToJson((PdxInstance) object);
-    Object[] values = impl.getFieldValues();    
+    Object[] values = impl.getFieldValues();
-    for(int i=0;i<fields.length;i++){
+    for (int i = 0; i < fields.length; i++) {
-      if(value!=null){
+      if (value != null) {
-          //jsonObject.put(fields[i], value.getClass().getCanonicalName());
-          jsonObject.put(fields[i],toJson(value));
+          // jsonObject.put(fields[i], value.getClass().getCanonicalName());
+          jsonObject.put(fields[i], toJson(value));
-      }else{
+      } else {
-  @SuppressWarnings({ "rawtypes" })
-  public DataCommandResult remove(String key, String keyClass, String regionName, String removeAllKeys) {
-    
+  @SuppressWarnings({"rawtypes"})
+  public DataCommandResult remove(String key, String keyClass, String regionName,
+      String removeAllKeys) {
+
-    
-    if(regionName==null || regionName.isEmpty()){
-      return DataCommandResult.createRemoveResult(key, null, null, CliStrings.REMOVE__MSG__REGIONNAME_EMPTY, false);
+
+    if (regionName == null || regionName.isEmpty()) {
+      return DataCommandResult.createRemoveResult(key, null, null,
+          CliStrings.REMOVE__MSG__REGIONNAME_EMPTY, false);
-    
-    boolean allKeysFlag = (removeAllKeys==null || removeAllKeys.isEmpty());    
-    if(allKeysFlag && (key==null || key.isEmpty())){
-      return DataCommandResult.createRemoveResult(key, null, null, CliStrings.REMOVE__MSG__KEY_EMPTY,false);
-    }     
-     
-    Region region = cache.getRegion(regionName); 
-    if(region==null){
-      return DataCommandResult.createRemoveInfoResult(key, null, null, CliStrings.format(CliStrings.REMOVE__MSG__REGION_NOT_FOUND,regionName), false);
-    }else{      
-      if(removeAllKeys==null){
+
+    boolean allKeysFlag = (removeAllKeys == null || removeAllKeys.isEmpty());
+    if (allKeysFlag && (key == null || key.isEmpty())) {
+      return DataCommandResult.createRemoveResult(key, null, null,
+          CliStrings.REMOVE__MSG__KEY_EMPTY, false);
+    }
+
+    Region region = cache.getRegion(regionName);
+    if (region == null) {
+      return DataCommandResult.createRemoveInfoResult(key, null, null,
+          CliStrings.format(CliStrings.REMOVE__MSG__REGION_NOT_FOUND, regionName), false);
+    } else {
+      if (removeAllKeys == null) {
-        try{
-          keyObject = getClassObject(key,keyClass);
-        }catch(ClassNotFoundException e){
-          return DataCommandResult.createRemoveResult(key, null, null, "ClassNotFoundException " + keyClass, false); 
-        }catch(IllegalArgumentException e){
-          return DataCommandResult.createRemoveResult(key, null, null, "Error in converting JSON " + e.getMessage(), false); 
+        try {
+          keyObject = getClassObject(key, keyClass);
+        } catch (ClassNotFoundException e) {
+          return DataCommandResult.createRemoveResult(key, null, null,
+              "ClassNotFoundException " + keyClass, false);
+        } catch (IllegalArgumentException e) {
+          return DataCommandResult.createRemoveResult(key, null, null,
+              "Error in converting JSON " + e.getMessage(), false);
-        
-        if(region.containsKey(keyObject)){
-          Object value= region.remove(keyObject);
-          if (logger.isDebugEnabled()) 
+
+        if (region.containsKey(keyObject)) {
+          Object value = region.remove(keyObject);
+          if (logger.isDebugEnabled())
-          //return DataCommandResult.createRemoveResult(key, value, null, null);
+          // return DataCommandResult.createRemoveResult(key, value, null, null);
-          DataCommandResult result = DataCommandResult.createRemoveResult(key,array[1] , null, null,true);
-          if(array[0]!=null)
-            result.setValueClass((String)array[0]);
+          DataCommandResult result =
+              DataCommandResult.createRemoveResult(key, array[1], null, null, true);
+          if (array[0] != null)
+            result.setValueClass((String) array[0]);
-        }else{
-          return DataCommandResult.createRemoveInfoResult(key, null, null, CliStrings.REMOVE__MSG__KEY_NOT_FOUND_REGION,false); 
+        } else {
+          return DataCommandResult.createRemoveInfoResult(key, null, null,
+              CliStrings.REMOVE__MSG__KEY_NOT_FOUND_REGION, false);
-          if (logger.isDebugEnabled()) 
+          if (logger.isDebugEnabled())
-      }        
-    }    
+      }
+    }
-  
-  @SuppressWarnings({ "rawtypes" })
-  public DataCommandResult get(Object principal, String key, String keyClass, String valueClass, String regionName, Boolean loadOnCacheMiss) {
-    
+
+  @SuppressWarnings({"rawtypes"})
+  public DataCommandResult get(Object principal, String key, String keyClass, String valueClass,
+      String regionName, Boolean loadOnCacheMiss) {
+
-    
-    if(regionName==null || regionName.isEmpty()){
-     return DataCommandResult.createGetResult(key, null, null, CliStrings.GET__MSG__REGIONNAME_EMPTY, false);
+
+    if (regionName == null || regionName.isEmpty()) {
+      return DataCommandResult.createGetResult(key, null, null,
+          CliStrings.GET__MSG__REGIONNAME_EMPTY, false);
-    
-    if(key==null || key.isEmpty()){
-      return DataCommandResult.createGetResult(key, null, null, CliStrings.GET__MSG__KEY_EMPTY, false);
+
+    if (key == null || key.isEmpty()) {
+      return DataCommandResult.createGetResult(key, null, null, CliStrings.GET__MSG__KEY_EMPTY,
+          false);
-    
+
-    if(region==null){
-      if (logger.isDebugEnabled()) 
+    if (region == null) {
+      if (logger.isDebugEnabled())
-      return DataCommandResult.createGetResult(key, null, null, CliStrings.format(CliStrings.GET__MSG__REGION_NOT_FOUND,regionName), false);
-    }else{
+      return DataCommandResult.createGetResult(key, null, null,
+          CliStrings.format(CliStrings.GET__MSG__REGION_NOT_FOUND, regionName), false);
+    } else {
-      try{
-        keyObject = getClassObject(key,keyClass);
-      }catch(ClassNotFoundException e){
-        return DataCommandResult.createGetResult(key, null, null, "ClassNotFoundException " + keyClass, false); 
-      }catch(IllegalArgumentException e){
-        return DataCommandResult.createGetResult(key, null, null, "Error in converting JSON " + e.getMessage(), false); 
+      try {
+        keyObject = getClassObject(key, keyClass);
+      } catch (ClassNotFoundException e) {
+        return DataCommandResult.createGetResult(key, null, null,
+            "ClassNotFoundException " + keyClass, false);
+      } catch (IllegalArgumentException e) {
+        return DataCommandResult.createGetResult(key, null, null,
+            "Error in converting JSON " + e.getMessage(), false);
-      // TODO determine whether the following conditional logic (assigned to 'doGet') is safer or necessary
-      //boolean doGet = (Boolean.TRUE.equals(loadOnCacheMiss) && region.getAttributes().getCacheLoader() != null);
+      // TODO determine whether the following conditional logic (assigned to 'doGet') is safer or
+      // necessary
+      // boolean doGet = (Boolean.TRUE.equals(loadOnCacheMiss) &&
+      // region.getAttributes().getCacheLoader() != null);
-        Object value= region.get(keyObject);
+        Object value = region.get(keyObject);
-        // run it through post processor. region.get will return the deserialized object already, so we don't need to
+        // run it through post processor. region.get will return the deserialized object already, so
+        // we don't need to
-        if (logger.isDebugEnabled()) 
+        if (logger.isDebugEnabled())
-        //return DataCommandResult.createGetResult(key, value, null, null);
+        // return DataCommandResult.createGetResult(key, value, null, null);
-        if(value!=null){         
-          DataCommandResult result = DataCommandResult.createGetResult(key, array[1], null, null, true);
-          if(array[0]!=null)
-            result.setValueClass((String)array[0]);
+        if (value != null) {
+          DataCommandResult result =
+              DataCommandResult.createGetResult(key, array[1], null, null, true);
+          if (array[0] != null)
+            result.setValueClass((String) array[0]);
-        }
-        else{
+        } else {
-      }else{
-        if (logger.isDebugEnabled()) 
+      } else {
+        if (logger.isDebugEnabled())
-        return DataCommandResult.createGetInfoResult(key, null, null, CliStrings.GET__MSG__KEY_NOT_FOUND_REGION, false); 
-      }  
-    }  
+        return DataCommandResult.createGetInfoResult(key, null, null,
+            CliStrings.GET__MSG__KEY_NOT_FOUND_REGION, false);
+      }
+    }
-  
-  @SuppressWarnings({ "unchecked", "rawtypes" })
-  public DataCommandResult locateEntry(String key, String keyClass, String valueClass, String regionPath, boolean recursive) {
-    
+
+  @SuppressWarnings({"unchecked", "rawtypes"})
+  public DataCommandResult locateEntry(String key, String keyClass, String valueClass,
+      String regionPath, boolean recursive) {
+
-    
-    if(regionPath==null || regionPath.isEmpty()){
-     return DataCommandResult.createLocateEntryResult(key, null,null, CliStrings.LOCATE_ENTRY__MSG__REGIONNAME_EMPTY, false);
+
+    if (regionPath == null || regionPath.isEmpty()) {
+      return DataCommandResult.createLocateEntryResult(key, null, null,
+          CliStrings.LOCATE_ENTRY__MSG__REGIONNAME_EMPTY, false);
-    
-    if(key==null || key.isEmpty()){
-      return DataCommandResult.createLocateEntryResult(key, null, null, CliStrings.LOCATE_ENTRY__MSG__KEY_EMPTY, false);
+
+    if (key == null || key.isEmpty()) {
+      return DataCommandResult.createLocateEntryResult(key, null, null,
+          CliStrings.LOCATE_ENTRY__MSG__KEY_EMPTY, false);
-    
+
-    
-    if(recursive){
+
+    if (recursive) {
-      }      
-      if(listofRegionStartingwithRegionPath.size()==0){
-        if (logger.isDebugEnabled()) 
-          logger.debug("Region Not Found - {}", regionPath);
-        return DataCommandResult.createLocateEntryResult(key, null, null, CliStrings.format(CliStrings.REMOVE__MSG__REGION_NOT_FOUND, regionPath) , false);
-    }else{
+      if (listofRegionStartingwithRegionPath.size() == 0) {
+        if (logger.isDebugEnabled())
+          logger.debug("Region Not Found - {}", regionPath);
+        return DataCommandResult.createLocateEntryResult(key, null, null,
+            CliStrings.format(CliStrings.REMOVE__MSG__REGION_NOT_FOUND, regionPath), false);
+      }
+    } else {
-      if(region==null){
-        if (logger.isDebugEnabled()) 
+      if (region == null) {
+        if (logger.isDebugEnabled())
-        return DataCommandResult.createLocateEntryResult(key, null, null, CliStrings.format(CliStrings.REMOVE__MSG__REGION_NOT_FOUND, regionPath) , false);
-      }
-      else        
+        return DataCommandResult.createLocateEntryResult(key, null, null,
+            CliStrings.format(CliStrings.REMOVE__MSG__REGION_NOT_FOUND, regionPath), false);
+      } else
-    
+
-    try{
-      keyObject = getClassObject(key,keyClass);
-    }catch(ClassNotFoundException e){
+    try {
+      keyObject = getClassObject(key, keyClass);
+    } catch (ClassNotFoundException e) {
-      return DataCommandResult.createLocateEntryResult(key, null,null, "ClassNotFoundException " + keyClass, false); 
-    }catch(IllegalArgumentException e){
+      return DataCommandResult.createLocateEntryResult(key, null, null,
+          "ClassNotFoundException " + keyClass, false);
+    } catch (IllegalArgumentException e) {
-      return DataCommandResult.createLocateEntryResult(key, null, null, "Error in converting JSON " + e.getMessage(), false); 
+      return DataCommandResult.createLocateEntryResult(key, null, null,
+          "Error in converting JSON " + e.getMessage(), false);
-    
+
-    DataCommandResult.KeyInfo keyInfo= null;
+    DataCommandResult.KeyInfo keyInfo = null;
-    
-    for(Region region : listofRegionStartingwithRegionPath){      
+
+    for (Region region : listofRegionStartingwithRegionPath) {
-        //Following code is adaptation of which.java of old Gfsh
-        PartitionedRegion pr = (PartitionedRegion)region;
-        Region localRegion = PartitionRegionHelper.getLocalData((PartitionedRegion)region);
+        // Following code is adaptation of which.java of old Gfsh
+        PartitionedRegion pr = (PartitionedRegion) region;
+        Region localRegion = PartitionRegionHelper.getLocalData((PartitionedRegion) region);
-        if(value!=null){
-          DistributedMember primaryMember = PartitionRegionHelper.getPrimaryMemberForKey(region, keyObject);
+        if (value != null) {
+          DistributedMember primaryMember =
+              PartitionRegionHelper.getPrimaryMemberForKey(region, keyObject);
-          keyInfo.addLocation(new Object[]{region.getFullPath(),true,getJSONForNonPrimitiveObject(value)[1],isPrimary,""+bucketId});          
-        }else{
-          if (logger.isDebugEnabled()) 
+          keyInfo.addLocation(new Object[] {region.getFullPath(), true,
+              getJSONForNonPrimitiveObject(value)[1], isPrimary, "" + bucketId});
+        } else {
+          if (logger.isDebugEnabled())
-          return DataCommandResult.createLocateEntryInfoResult(key, null,null, CliStrings.LOCATE_ENTRY__MSG__KEY_NOT_FOUND_REGION, false);
+          return DataCommandResult.createLocateEntryInfoResult(key, null, null,
+              CliStrings.LOCATE_ENTRY__MSG__KEY_NOT_FOUND_REGION, false);
-      }else{
-        if(region.containsKey(keyObject)){
-          value= region.get(keyObject);         
-          if (logger.isDebugEnabled()) 
+      } else {
+        if (region.containsKey(keyObject)) {
+          value = region.get(keyObject);
+          if (logger.isDebugEnabled())
-          if(value!=null)
-            keyInfo.addLocation(new Object[]{region.getFullPath(),true,getJSONForNonPrimitiveObject(value)[1], false,null});
+          if (value != null)
+            keyInfo.addLocation(new Object[] {region.getFullPath(), true,
+                getJSONForNonPrimitiveObject(value)[1], false, null});
-            keyInfo.addLocation(new Object[]{region.getFullPath(),false,null, false,null});
-        }else{
-          if (logger.isDebugEnabled()) 
+            keyInfo.addLocation(new Object[] {region.getFullPath(), false, null, false, null});
+        } else {
+          if (logger.isDebugEnabled())
-          keyInfo.addLocation(new Object[]{region.getFullPath(), false,null, false,null}); 
-        }  
+          keyInfo.addLocation(new Object[] {region.getFullPath(), false, null, false, null});
+        }
-    
-    if(keyInfo.hasLocation()){
-      return DataCommandResult.createLocateEntryResult(key,keyInfo, null, null, true);
-    }else{
-      return DataCommandResult.createLocateEntryInfoResult(key, null,null, CliStrings.LOCATE_ENTRY__MSG__KEY_NOT_FOUND_REGION, false);
+
+    if (keyInfo.hasLocation()) {
+      return DataCommandResult.createLocateEntryResult(key, keyInfo, null, null, true);
+    } else {
+      return DataCommandResult.createLocateEntryInfoResult(key, null, null,
+          CliStrings.LOCATE_ENTRY__MSG__KEY_NOT_FOUND_REGION, false);
-    
+
-  
-  @SuppressWarnings({ "rawtypes" })
-  public DataCommandResult put(String key, String value, boolean putIfAbsent, String keyClass, String valueClass,
-      String regionName) { 
-    
-    if(regionName==null || regionName.isEmpty()){
-      return DataCommandResult.createPutResult(key, null, null, CliStrings.PUT__MSG__REGIONNAME_EMPTY, false);
+
+  @SuppressWarnings({"rawtypes"})
+  public DataCommandResult put(String key, String value, boolean putIfAbsent, String keyClass,
+      String valueClass, String regionName) {
+
+    if (regionName == null || regionName.isEmpty()) {
+      return DataCommandResult.createPutResult(key, null, null,
+          CliStrings.PUT__MSG__REGIONNAME_EMPTY, false);
-     
-    if(key==null || key.isEmpty()){
-       return DataCommandResult.createPutResult(key, null, null, CliStrings.PUT__MSG__KEY_EMPTY, false);
+
+    if (key == null || key.isEmpty()) {
+      return DataCommandResult.createPutResult(key, null, null, CliStrings.PUT__MSG__KEY_EMPTY,
+          false);
-     
-    if(value==null || value.isEmpty()){
-       return DataCommandResult.createPutResult(key, null, null, CliStrings.PUT__MSG__VALUE_EMPTY, false);
+
+    if (value == null || value.isEmpty()) {
+      return DataCommandResult.createPutResult(key, null, null, CliStrings.PUT__MSG__VALUE_EMPTY,
+          false);
-    
+
-    Region region = cache.getRegion(regionName); 
-    if(region==null){
-      return DataCommandResult.createPutResult(key, null, null, CliStrings.format(CliStrings.PUT__MSG__REGION_NOT_FOUND, regionName) , false);
-    }
-    else{
+    Region region = cache.getRegion(regionName);
+    if (region == null) {
+      return DataCommandResult.createPutResult(key, null, null,
+          CliStrings.format(CliStrings.PUT__MSG__REGION_NOT_FOUND, regionName), false);
+    } else {
-      try{
-        keyObject = getClassObject(key,keyClass);
-      }catch(ClassNotFoundException e){
-        return DataCommandResult.createPutResult(key, null, null, "ClassNotFoundException " + keyClass, false); 
-      }catch(IllegalArgumentException e){
-        return DataCommandResult.createPutResult(key, null, null, "Error in converting JSON " + e.getMessage(), false); 
+      try {
+        keyObject = getClassObject(key, keyClass);
+      } catch (ClassNotFoundException e) {
+        return DataCommandResult.createPutResult(key, null, null,
+            "ClassNotFoundException " + keyClass, false);
+      } catch (IllegalArgumentException e) {
+        return DataCommandResult.createPutResult(key, null, null,
+            "Error in converting JSON " + e.getMessage(), false);
-      
-      try{
-        valueObject = getClassObject(value,valueClass);
-      }catch(ClassNotFoundException e){
-        return DataCommandResult.createPutResult(key, null, null, "ClassNotFoundException " + valueClass, false); 
+
+      try {
+        valueObject = getClassObject(value, valueClass);
+      } catch (ClassNotFoundException e) {
+        return DataCommandResult.createPutResult(key, null, null,
+            "ClassNotFoundException " + valueClass, false);
-        returnValue = region.put(keyObject,valueObject);
-      Object array[] = getJSONForNonPrimitiveObject(returnValue);             
+        returnValue = region.put(keyObject, valueObject);
+      Object array[] = getJSONForNonPrimitiveObject(returnValue);
-      if(array[0]!=null)
-        result.setValueClass((String)array[0]);
-       return result;
+      if (array[0] != null)
+        result.setValueClass((String) array[0]);
+      return result;
-  @SuppressWarnings({ "rawtypes", "unchecked" })
-  private Object getClassObject(String string, String klassString) throws ClassNotFoundException, IllegalArgumentException{
-    if(klassString==null || klassString.isEmpty())
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  private Object getClassObject(String string, String klassString)
+      throws ClassNotFoundException, IllegalArgumentException {
+    if (klassString == null || klassString.isEmpty())
-        Object o = null;
-        Class klass =  ClassPathLoader.getLatest().forName(klassString);
-        
-        if(klass.equals(String.class))
-          return string;
-        
-        if(JsonUtil.isPrimitiveOrWrapper(klass)){
-          try{
-            if(klass.equals(Byte.class)){
-              o = Byte.parseByte(string);return o;
-            }else if(klass.equals(Short.class)){
-             o = Short.parseShort(string);return o; 
-            }else if(klass.equals(Integer.class)){
-              o = Integer.parseInt(string);return o; 
-            }else if(klass.equals(Long.class)){
-              o = Long.parseLong(string);return o;
-            }else if(klass.equals(Double.class)){
-              o = Double.parseDouble(string);return o;
-            }else if(klass.equals(Boolean.class)){
-              o = Boolean.parseBoolean(string);return o;
-            }else if(klass.equals(Float.class)){
-              o = Float.parseFloat(string);return o;
-            }
+      Object o = null;
+      Class klass = ClassPathLoader.getLatest().forName(klassString);
+
+      if (klass.equals(String.class))
+        return string;
+
+      if (JsonUtil.isPrimitiveOrWrapper(klass)) {
+        try {
+          if (klass.equals(Byte.class)) {
+            o = Byte.parseByte(string);
-          }catch(NumberFormatException e){
-            throw new IllegalArgumentException("Failed to convert input key to " + klassString + " Msg : " + e.getMessage());
-          }                
-        }
-        
-        try{
-          o = getObjectFromJson(string, klass);
+          } else if (klass.equals(Short.class)) {
+            o = Short.parseShort(string);
+            return o;
+          } else if (klass.equals(Integer.class)) {
+            o = Integer.parseInt(string);
+            return o;
+          } else if (klass.equals(Long.class)) {
+            o = Long.parseLong(string);
+            return o;
+          } else if (klass.equals(Double.class)) {
+            o = Double.parseDouble(string);
+            return o;
+          } else if (klass.equals(Boolean.class)) {
+            o = Boolean.parseBoolean(string);
+            return o;
+          } else if (klass.equals(Float.class)) {
+            o = Float.parseFloat(string);
+            return o;
+          }
-        }catch(IllegalArgumentException e){         
-          throw e;
+        } catch (NumberFormatException e) {
+          throw new IllegalArgumentException(
+              "Failed to convert input key to " + klassString + " Msg : " + e.getMessage());
+      }
+
+      try {
+        o = getObjectFromJson(string, klass);
+        return o;
+      } catch (IllegalArgumentException e) {
+        throw e;
+      }
-  
-  @SuppressWarnings({ "rawtypes"})
-  public static Object[] getJSONForNonPrimitiveObject(Object obj){
+
+  @SuppressWarnings({"rawtypes"})
+  public static Object[] getJSONForNonPrimitiveObject(Object obj) {
-    if(obj==null){
-      array[0] = null;array[1] ="<NULL>"; 
+    if (obj == null) {
+      array[0] = null;
+      array[1] = "<NULL>";
-    }
-    else{     
+    } else {
-      if(JsonUtil.isPrimitiveOrWrapper(klass)) {
+      if (JsonUtil.isPrimitiveOrWrapper(klass)) {
-      }
-      else if (obj instanceof PdxInstance){
-        String str = pdxToJson((PdxInstance)obj);
-        array[1] =  str;
-      }else{
-        GfJsonObject object = new GfJsonObject(obj,true);
+      } else if (obj instanceof PdxInstance) {
+        String str = pdxToJson((PdxInstance) obj);
+        array[1] = str;
+      } else {
+        GfJsonObject object = new GfJsonObject(obj, true);
-        while(keysIterator.hasNext()){
+        while (keysIterator.hasNext()) {
-          if(GfJsonObject.isJSONKind(value)) {
+          if (GfJsonObject.isJSONKind(value)) {
-            //System.out.println("Re-wrote inner object");
+            // System.out.println("Re-wrote inner object");
-            }            
-          } else if(value instanceof JSONArray) {
-            //Its a collection either a set or list
+            }
+          } else if (value instanceof JSONArray) {
+            // Its a collection either a set or list
-            }            
+            }
-        String str =object.toString();        
+        String str = object.toString();
-  
+
-    if(obj!=null){
-      try{
+    if (obj != null) {
+      try {
-        for(String field : obj.getFieldNames()){
+        for (String field : obj.getFieldNames()) {
-          if(fieldValue!=null){
-            if(JsonUtil.isPrimitiveOrWrapper(fieldValue.getClass())){
+          if (fieldValue != null) {
+            if (JsonUtil.isPrimitiveOrWrapper(fieldValue.getClass())) {
-            }else{
+            } else {
-      }catch(GfJsonException e){        
+      } catch (GfJsonException e) {
-  public static <V> V getObjectFromJson(String json, Class<V> klass){    
+  public static <V> V getObjectFromJson(String json, Class<V> klass) {
-    if(newString.charAt(0)=='('){
+    if (newString.charAt(0) == '(') {
-      sb.append("{").append(newString.substring(1, len-1)).append("}");
-      newString=  sb.toString();
+      sb.append("{").append(newString.substring(1, len - 1)).append("}");
+      newString = sb.toString();
-    V v = JsonUtil.jsonToObject(newString,klass);
+    V v = JsonUtil.jsonToObject(newString, klass);
-  
-  
-  //Copied from RegionUtil of old Gfsh
+
+
+  // Copied from RegionUtil of old Gfsh
-   * Returns a sorted list of all region full paths found in the specified
-   * cache.
+   * Returns a sorted list of all region full paths found in the specified cache.
+   * 
-   * @return Returns a sorted list of all region paths defined in the 
-   *         distributed system.  
+   * @return Returns a sorted list of all region paths defined in the distributed system.
-  @SuppressWarnings({ "rawtypes", "unchecked" })
-  public static List getAllRegionPaths(Cache cache, boolean recursive)
-  {
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  public static List getAllRegionPaths(Cache cache, boolean recursive) {
-    
+
-  Set regions = cache.rootRegions();
-  Iterator itor = regions.iterator();
+    Set regions = cache.rootRegions();
+    Iterator itor = regions.iterator();
-  while (itor.hasNext()) {
-    String regionPath = ((Region)itor.next()).getFullPath();
+    while (itor.hasNext()) {
+      String regionPath = ((Region) itor.next()).getFullPath();
-    Region region = cache.getRegion(regionPath);
-    list.add(regionPath);
-    Set subregionSet = region.subregions(true);
-    if (recursive) {
-      for (Iterator subIter = subregionSet.iterator(); subIter.hasNext(); ){
-        list.add(((Region)subIter.next()).getFullPath());
+      Region region = cache.getRegion(regionPath);
+      list.add(regionPath);
+      Set subregionSet = region.subregions(true);
+      if (recursive) {
+        for (Iterator subIter = subregionSet.iterator(); subIter.hasNext();) {
+          list.add(((Region) subIter.next()).getFullPath());
+        }
+    Collections.sort(list);
+    return list;
-  Collections.sort(list);
-  return list;
-  }
-  
+
-  
-  public static class SelectDisplayStep extends CLIMultiStepHelper.LocalStep{
-    
+
+  public static class SelectDisplayStep extends CLIMultiStepHelper.LocalStep {
+
-      boolean interactive = (Boolean)commandArguments[2]; 
-      GfJsonObject args = CLIMultiStepHelper.getStepArgs();      
-      int startCount = args.getInt( DataCommandResult.QUERY_PAGE_START);
-      int endCount = args.getInt( DataCommandResult.QUERY_PAGE_END);
-      int rows = args.getInt(DataCommandResult.NUM_ROWS); //returns Zero if no rows added so it works.
+      boolean interactive = (Boolean) commandArguments[2];
+      GfJsonObject args = CLIMultiStepHelper.getStepArgs();
+      int startCount = args.getInt(DataCommandResult.QUERY_PAGE_START);
+      int endCount = args.getInt(DataCommandResult.QUERY_PAGE_END);
+      int rows = args.getInt(DataCommandResult.NUM_ROWS); // returns Zero if no rows added so it
+                                                          // works.
-                return CLIMultiStepHelper.createBannerResult(new String[] { DataCommandResult.QUERY_PAGE_START,
-                    DataCommandResult.QUERY_PAGE_END,  }, new Object[] {
-                    nextStart, (nextStart + getPageSize()) }, SELECT_STEP_MOVE);
+                return CLIMultiStepHelper.createBannerResult(
+                    new String[] {DataCommandResult.QUERY_PAGE_START,
+                        DataCommandResult.QUERY_PAGE_END,},
+                    new Object[] {nextStart, (nextStart + getPageSize())}, SELECT_STEP_MOVE);
-                return CLIMultiStepHelper.createBannerResult(new String[] { DataCommandResult.QUERY_PAGE_START,
-                    DataCommandResult.QUERY_PAGE_END}, new Object[] {
-                    nextStart, (nextStart + getPageSize())}, SELECT_STEP_MOVE);
+                return CLIMultiStepHelper.createBannerResult(
+                    new String[] {DataCommandResult.QUERY_PAGE_START,
+                        DataCommandResult.QUERY_PAGE_END},
+                    new Object[] {nextStart, (nextStart + getPageSize())}, SELECT_STEP_MOVE);
-                return CLIMultiStepHelper.createBannerResult(new String[] {  },
-                    new Object[] {  }, SELECT_STEP_END);
+                return CLIMultiStepHelper.createBannerResult(new String[] {}, new Object[] {},
+                    SELECT_STEP_END);
-      }        
-      return CLIMultiStepHelper.createBannerResult(new String[] {},
-          new Object[] {}, SELECT_STEP_END);      
+      }
+      return CLIMultiStepHelper.createBannerResult(new String[] {}, new Object[] {},
+          SELECT_STEP_END);
- 
+
-    
+
-    
+
-      GfJsonObject args = CLIMultiStepHelper.getStepArgs();      
+      GfJsonObject args = CLIMultiStepHelper.getStepArgs();
-      int endCount = args.getInt(DataCommandResult.QUERY_PAGE_END);      
+      int endCount = args.getInt(DataCommandResult.QUERY_PAGE_END);
-  };   
+  };
-  public static class SelectExecStep extends CLIMultiStepHelper.RemoteStep {    
-    
+  public static class SelectExecStep extends CLIMultiStepHelper.RemoteStep {
+
-      String remainingQuery = (String)commandArguments[0];
-      boolean interactive = (Boolean)commandArguments[2]; 
+      String remainingQuery = (String) commandArguments[0];
+      boolean interactive = (Boolean) commandArguments[2];
-      if(interactive){          
+      if (interactive) {
-      }else{
-        if(result.getSelectResult()!=null)
+      } else {
+        if (result.getSelectResult() != null)
-        return CLIMultiStepHelper.createBannerResult(new String[] {},
-            new Object[] {}, SELECT_STEP_END);
+        return CLIMultiStepHelper.createBannerResult(new String[] {}, new Object[] {},
+            SELECT_STEP_END);
-    
-    /*private int getLimit(CompiledValue compiledQuery) {
-      return compiledQuery instanceof CompiledSelect ?  ((CompiledSelect)compiledQuery).getLimitValue(): -1;
-    }*/
-    
+
+    /*
+     * private int getLimit(CompiledValue compiledQuery) { return compiledQuery instanceof
+     * CompiledSelect ? ((CompiledSelect)compiledQuery).getLimitValue(): -1; }
+     */
+
-      
-      //String query = querySB.toString().trim();      
+
+      // String query = querySB.toString().trim();
-      
+
-        for(String region:regions){
+        for (String region : regions) {
-          Set<DistributedMember> members = DataCommands.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);
+          Set<DistributedMember> members =
+              DataCommands.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);
-            if(subject!=null){
-              request.setPrincipal((Serializable)subject.getPrincipal());
+            if (subject != null) {
+              request.setPrincipal((Serializable) subject.getPrincipal());
-            return (dataResult = DataCommandResult.createSelectInfoResult(null, null, -1, null,
-                CliStrings.format(CliStrings.QUERY__MSG__REGIONS_NOT_FOUND, regionsInQuery.toString()), false));
+            return (dataResult =
+                DataCommandResult.createSelectInfoResult(null, null, -1, null, CliStrings.format(
+                    CliStrings.QUERY__MSG__REGIONS_NOT_FOUND, regionsInQuery.toString()), false));
-              CliStrings.format(CliStrings.QUERY__MSG__INVALID_QUERY, "Region mentioned in query probably missing /"),
+              CliStrings.format(CliStrings.QUERY__MSG__INVALID_QUERY,
+                  "Region mentioned in query probably missing /"),
-      } catch (QueryInvalidException qe) {        
+      } catch (QueryInvalidException qe) {
-      if (StringUtils.containsIgnoreCase(query, " limit") || StringUtils.containsIgnoreCase(query, " count("))
+      if (StringUtils.containsIgnoreCase(query, " limit")
+          || StringUtils.containsIgnoreCase(query, " count("))
-  public static class SelectQuitStep extends CLIMultiStepHelper.RemoteStep{
-    
+  public static class SelectQuitStep extends CLIMultiStepHelper.RemoteStep {
+
-      boolean interactive = (Boolean)commandArguments[2];
-      GfJsonObject args = CLIMultiStepHelper.getStepArgs();      
+      boolean interactive = (Boolean) commandArguments[2];
+      GfJsonObject args = CLIMultiStepHelper.getStepArgs();
-      if(interactive)
+      if (interactive)
-      else{
+      else {
-  
+
-    if(session!=null){
+    if (session != null) {
-  
+
-  
-  
-  public static String getLogMessage(QueryObserver observer,
-      long startTime, String query) {
+
+
+  public static String getLogMessage(QueryObserver observer, long startTime, String query) {
-      IndexTrackingQueryObserver indexObserver = (IndexTrackingQueryObserver)observer;
+      IndexTrackingQueryObserver indexObserver = (IndexTrackingQueryObserver) observer;
-    /*if (resultSize != -1){
-      rowCountString = " rowCount = " + resultSize + ";";
-    }*/
-    return "Query Executed" +
-    (startTime > 0L ? " in " + time + " ms;": ";") +
-    (rowCountString != null ? rowCountString : "") +
-    (usedIndexesString != null ? usedIndexesString : "") 
-    /*+ " \"" + query + "\""*/;
-  } 
- 
+    /*
+     * if (resultSize != -1){ rowCountString = " rowCount = " + resultSize + ";"; }
+     */
+    return "Query Executed" + (startTime > 0L ? " in " + time + " ms;" : ";")
+        + (rowCountString != null ? rowCountString : "")
+        + (usedIndexesString != null ? usedIndexesString : "")
+    /* + " \"" + query + "\"" */;
+  }
+

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The <code>DistributionManager</code> uses a {@link
- * MembershipManager} to distribute {@link DistributionMessage messages}
- * queued in {@link MQueue}s.
+ * The <code>DistributionManager</code> uses a {@link MembershipManager} to distribute
+ * {@link DistributionMessage messages} queued in {@link MQueue}s.
- * Code that wishes to send a {@link DistributionMessage} must get
- * the <code>DistributionManager</code> and invoke {@link
- * #putOutgoing}.
+ * Code that wishes to send a {@link DistributionMessage} must get the
+ * <code>DistributionManager</code> and invoke {@link #putOutgoing}.
- * Prior to GemFire 4.0, <code>DistributionManager</code> was an
- * abstract class with two concrete subclasses,
- * <code>LocalDistributionManager</code> and
- * <code>ConsoleDistributionManager</code>.  We decided that
- * <code>ConsoleDistributionManager</code> (which was used for the GUI
- * console and admin APIs) did not offer enough interesting
- * functionality to warrant a separate class.  More importantly, it
- * prevented the Cache and admin APIs from being used in the same VM.
- * So, we refactored the code of those two subclasses into
- * <code>DistributionManager</code>.
+ * Prior to GemFire 4.0, <code>DistributionManager</code> was an abstract class with two concrete
+ * subclasses, <code>LocalDistributionManager</code> and <code>ConsoleDistributionManager</code>. We
+ * decided that <code>ConsoleDistributionManager</code> (which was used for the GUI console and
+ * admin APIs) did not offer enough interesting functionality to warrant a separate class. More
+ * importantly, it prevented the Cache and admin APIs from being used in the same VM. So, we
+ * refactored the code of those two subclasses into <code>DistributionManager</code>.
-public class DistributionManager
-  implements DM {
+public class DistributionManager implements DM {
-  
-  private static final boolean SYNC_EVENTS =
-    Boolean.getBoolean("DistributionManager.syncEvents");
+
+  private static final boolean SYNC_EVENTS = Boolean.getBoolean("DistributionManager.syncEvents");
-   * <p>see org.apache.geode.cache30.ClearMultiVmCallBkDUnitTest
+   * <p>
+   * see org.apache.geode.cache30.ClearMultiVmCallBkDUnitTest
-  public static final boolean INLINE_PROCESS = 
-    !Boolean.getBoolean("DistributionManager.enqueueOrderedMessages");
+  public static final boolean INLINE_PROCESS =
+      !Boolean.getBoolean("DistributionManager.enqueueOrderedMessages");
-  /** Flag indicating whether to use single Serial-Executor thread or 
-   * Multiple Serial-executor thread, 
+  /**
+   * Flag indicating whether to use single Serial-Executor thread or Multiple Serial-executor
+   * thread,
-  public static final boolean MULTI_SERIAL_EXECUTORS = 
-    !Boolean.getBoolean("DistributionManager.singleSerialExecutor");
+  public static final boolean MULTI_SERIAL_EXECUTORS =
+      !Boolean.getBoolean("DistributionManager.singleSerialExecutor");
-  
-  /** The number of milliseconds to wait for distribution-related
-   * things to happen */
-  public static final long TIMEOUT =
-    Long.getLong("DistributionManager.TIMEOUT", -1).longValue();
+
+  /**
+   * The number of milliseconds to wait for distribution-related things to happen
+   */
+  public static final long TIMEOUT = Long.getLong("DistributionManager.TIMEOUT", -1).longValue();
-    Integer.getInteger("DistributionManager.PUSHER_THREADS", 50).intValue();
+      Integer.getInteger("DistributionManager.PUSHER_THREADS", 50).intValue();
-    Integer.getInteger("DistributionManager.PUSHER_QUEUE_SIZE", 4096).intValue();
+      Integer.getInteger("DistributionManager.PUSHER_QUEUE_SIZE", 4096).intValue();
-  
-  public static final int MAX_WAITING_THREADS = 
-    Integer.getInteger("DistributionManager.MAX_WAITING_THREADS", Integer.MAX_VALUE).intValue();
-  
-  public static final int MAX_PR_META_DATA_CLEANUP_THREADS = 
+
+  public static final int MAX_WAITING_THREADS =
+      Integer.getInteger("DistributionManager.MAX_WAITING_THREADS", Integer.MAX_VALUE).intValue();
+
+  public static final int MAX_PR_META_DATA_CLEANUP_THREADS =
-  public static final int MAX_THREADS = Integer.getInteger("DistributionManager.MAX_THREADS", 100).intValue();
-  public static final int MAX_PR_THREADS = Integer.getInteger("DistributionManager.MAX_PR_THREADS", Math.max(Runtime.getRuntime().availableProcessors()*4, 16)).intValue();
-  public static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS", Math.max(Runtime.getRuntime().availableProcessors()*4, 16)).intValue();
-  //    Integer.getInteger("DistributionManager.MAX_THREADS", max(Runtime.getRuntime().availableProcessors()*2, 2)).intValue();
+  public static final int MAX_THREADS =
+      Integer.getInteger("DistributionManager.MAX_THREADS", 100).intValue();
+  public static final int MAX_PR_THREADS = Integer.getInteger("DistributionManager.MAX_PR_THREADS",
+      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
+  public static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",
+      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
+  // Integer.getInteger("DistributionManager.MAX_THREADS",
+  // max(Runtime.getRuntime().availableProcessors()*2, 2)).intValue();
-    Integer.getInteger("DistributionManager.INCOMING_QUEUE_LIMIT", 80000).intValue();
+      Integer.getInteger("DistributionManager.INCOMING_QUEUE_LIMIT", 80000).intValue();
-    Integer.getInteger("DistributionManager.INCOMING_QUEUE_THROTTLE", (int)(INCOMING_QUEUE_LIMIT * 0.75)).intValue();
+      Integer.getInteger("DistributionManager.INCOMING_QUEUE_THROTTLE",
+          (int) (INCOMING_QUEUE_LIMIT * 0.75)).intValue();
-  public static final double THROTTLE_PERCENT =
-    (double) (Integer.getInteger("DistributionManager.SERIAL_QUEUE_THROTTLE_PERCENT", 75).intValue())/100;
-  public static final int SERIAL_QUEUE_BYTE_LIMIT =
-    Integer.getInteger("DistributionManager.SERIAL_QUEUE_BYTE_LIMIT", (40 * (1024 * 1024))).intValue();
+  public static final double THROTTLE_PERCENT = (double) (Integer
+      .getInteger("DistributionManager.SERIAL_QUEUE_THROTTLE_PERCENT", 75).intValue()) / 100;
+  public static final int SERIAL_QUEUE_BYTE_LIMIT = Integer
+      .getInteger("DistributionManager.SERIAL_QUEUE_BYTE_LIMIT", (40 * (1024 * 1024))).intValue();
-    Integer.getInteger("DistributionManager.SERIAL_QUEUE_THROTTLE", (int)(SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT)).intValue();
+      Integer.getInteger("DistributionManager.SERIAL_QUEUE_THROTTLE",
+          (int) (SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT)).intValue();
-    Integer.getInteger("DistributionManager.TOTAL_SERIAL_QUEUE_BYTE_LIMIT", (80 * (1024 * 1024))).intValue();
+      Integer.getInteger("DistributionManager.TOTAL_SERIAL_QUEUE_BYTE_LIMIT", (80 * (1024 * 1024)))
+          .intValue();
-    Integer.getInteger("DistributionManager.TOTAL_SERIAL_QUEUE_THROTTLE", (int)(SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT)).intValue();
-  
+      Integer.getInteger("DistributionManager.TOTAL_SERIAL_QUEUE_THROTTLE",
+          (int) (SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT)).intValue();
+
-    Integer.getInteger("DistributionManager.SERIAL_QUEUE_SIZE_LIMIT", 20000).intValue();
+      Integer.getInteger("DistributionManager.SERIAL_QUEUE_SIZE_LIMIT", 20000).intValue();
-    Integer.getInteger("DistributionManager.SERIAL_QUEUE_SIZE_THROTTLE", (int)(SERIAL_QUEUE_SIZE_LIMIT * THROTTLE_PERCENT)).intValue();
+      Integer.getInteger("DistributionManager.SERIAL_QUEUE_SIZE_THROTTLE",
+          (int) (SERIAL_QUEUE_SIZE_LIMIT * THROTTLE_PERCENT)).intValue();
-    Integer.getInteger("DistributionManager.MAX_SERIAL_QUEUE_THREAD", 20).intValue();
+      Integer.getInteger("DistributionManager.MAX_SERIAL_QUEUE_THREAD", 20).intValue();
-   * Whether or not to include link local addresses in the list of addresses we use
-   * to determine if two members are no the same host.
+   * Whether or not to include link local addresses in the list of addresses we use to determine if
+   * two members are no the same host.
-  
+
-  /** The DM type for locator distribution managers 
+  /**
+   * The DM type for locator distribution managers
+   * 
+   * 
-
+   * 
-  
+
-  
+
-  /** The number of open  distribution managers in this VM */
+  /** The number of open distribution managers in this VM */
-//  /** The stack trace of the last time a console DM was opened */
-//  private static Exception openStackTrace;
+  // /** The stack trace of the last time a console DM was opened */
+  // private static Exception openStackTrace;
-  /** Is this VM dedicated to administration (like a GUI console or a
-   * JMX agent)?  If so, then it creates {@link #ADMIN_ONLY_DM_TYPE}
-   * type distribution managers.
+  /**
+   * Is this VM dedicated to administration (like a GUI console or a JMX agent)? If so, then it
+   * creates {@link #ADMIN_ONLY_DM_TYPE} type distribution managers.
-  
+
-   * Is this admin agent used for a command line console.
-   * This flag controls whether connect will throw 
-   * an exception or just wait for a DS if one is not
-   * available. If true, we will throw an exception.
+   * Is this admin agent used for a command line console. This flag controls whether connect will
+   * throw an exception or just wait for a DS if one is not available. If true, we will throw an
+   * exception.
-  
-  
-  
-  /////////////////////  Instance Fields  //////////////////////
+
+
+
+  ///////////////////// Instance Fields //////////////////////
-  /** The <code>MembershipListener</code>s that are registered on this
-   * manager. */
+  /**
+   * The <code>MembershipListener</code>s that are registered on this manager.
+   */
-  protected final Object membershipListenersLock =
-    new MembershipListenersLock();
-  /** The <code>MembershipListener</code>s that are registered on this
-   * manager for ALL members.
+  protected final Object membershipListenersLock = new MembershipListenersLock();
+  /**
+   * The <code>MembershipListener</code>s that are registered on this manager for ALL members.
+   * 
+   * 
-  protected final Object allMembershipListenersLock =
-    new MembershipListenersLock();
+  protected final Object allMembershipListenersLock = new MembershipListenersLock();
-  protected final BlockingQueue membershipEventQueue =
-    new LinkedBlockingQueue();
+  protected final BlockingQueue membershipEventQueue = new LinkedBlockingQueue();
-  protected /*final*/ DistributionStats stats;
+  protected /* final */ DistributionStats stats;
-    
+
-  
+
-  
+
-  
+
-   * The (non-admin-only) members of the distributed system.  This is a
-   * map of memberid->memberid for fast access to canonical ID references.
-   * All accesses to this 
-   * field must be synchronized on {@link #membersLock}.
+   * The (non-admin-only) members of the distributed system. This is a map of memberid->memberid for
+   * fast access to canonical ID references. All accesses to this field must be synchronized on
+   * {@link #membersLock}.
-  private Map<InternalDistributedMember,InternalDistributedMember> members = Collections.emptyMap();
-  /** 
-   * All (admin and non-admin) members of the distributed system. All accesses 
-   * to this field must be synchronized on {@link #membersLock}.
+  private Map<InternalDistributedMember, InternalDistributedMember> members =
+      Collections.emptyMap();
+  /**
+   * All (admin and non-admin) members of the distributed system. All accesses to this field must be
+   * synchronized on {@link #membersLock}.
-  /** 
-   * Map of all locator members of the distributed system. The value is a
-   * collection of locator strings that are hosted in that member. All accesses 
-   * to this field must be synchronized on {@link #membersLock}.
+  /**
+   * Map of all locator members of the distributed system. The value is a collection of locator
+   * strings that are hosted in that member. All accesses to this field must be synchronized on
+   * {@link #membersLock}.
-  private Map<InternalDistributedMember, Collection<String>> hostedLocatorsAll = Collections.emptyMap();
-  
-  /** 
-   * Map of all locator members of the distributed system which have the shared configuration. The value is a
-   * collection of locator strings that are hosted in that member. All accesses 
-   * to this field must be synchronized on {@link #membersLock}.
+  private Map<InternalDistributedMember, Collection<String>> hostedLocatorsAll =
+      Collections.emptyMap();
+
+  /**
+   * Map of all locator members of the distributed system which have the shared configuration. The
+   * value is a collection of locator strings that are hosted in that member. All accesses to this
+   * field must be synchronized on {@link #membersLock}.
-  private Map<InternalDistributedMember, Collection<String>> hostedLocatorsWithSharedConfiguration = Collections.emptyMap();
+  private Map<InternalDistributedMember, Collection<String>> hostedLocatorsWithSharedConfiguration =
+      Collections.emptyMap();
-   * StartupResponseMessage does not contain version. We will assign a default
-   * version for them.
+   * StartupResponseMessage does not contain version. We will assign a default version for them.
-  /** 
+  /**
-  /** 
-   * The ids of all known admin consoles
-   * Uses Copy on Write. Writers must sync on adminConsolesLock.
+  /**
+   * The ids of all known admin consoles Uses Copy on Write. Writers must sync on adminConsolesLock.
-  //private Thread pusher;
+  // private Thread pusher;
-  
+
-  /** High Priority processing thread pool, used for initializing messages
-   *  such as UpdateAttributes and CreateRegion messages
+  /**
+   * High Priority processing thread pool, used for initializing messages such as UpdateAttributes
+   * and CreateRegion messages
-  
-  /** Waiting Pool, used for messages that may have to wait on something.
-   *  Use this separate pool with an unbounded queue so that waiting
-   *  runnables don't get in the way of other processing threads.
-   *  Used for threads that will most likely have to wait for a region to be
-   *  finished initializing before it can proceed
+
+  /**
+   * Waiting Pool, used for messages that may have to wait on something. Use this separate pool with
+   * an unbounded queue so that waiting runnables don't get in the way of other processing threads.
+   * Used for threads that will most likely have to wait for a region to be finished initializing
+   * before it can proceed
-  
+
-  
+
-   * Thread used to decouple {@link org.apache.geode.internal.cache.partitioned.PartitionMessage}s from 
-   * {@link org.apache.geode.internal.cache.DistributedCacheOperation}s </b>
+   * Thread used to decouple {@link org.apache.geode.internal.cache.partitioned.PartitionMessage}s
+   * from {@link org.apache.geode.internal.cache.DistributedCacheOperation}s </b>
+   * 
-  
-  /** Message processing executor for view messages
-   * @see org.apache.geode.distributed.internal.membership.gms.messages.ViewAckMessage 
+
+  /**
+   * Message processing executor for view messages
+   * 
+   * @see org.apache.geode.distributed.internal.membership.gms.messages.ViewAckMessage
-  
-  /** If using a throttling queue for the serialThread, we cache the queue here
-      so we can see if delivery would block */
+
+  /**
+   * If using a throttling queue for the serialThread, we cache the queue here so we can see if
+   * delivery would block
+   */
-  //protected final Map channelMap = CFactory.createCM();
+  // protected final Map channelMap = CFactory.createCM();
-   * Set to true once this DM is ready to send messages.
-   * Note that it is always ready to send the startup message.
+   * Set to true once this DM is ready to send messages. Note that it is always ready to send the
+   * startup message.
-  /** The distributed system to which this distribution manager is
-   * connected. */
+  /**
+   * The distributed system to which this distribution manager is connected.
+   */
-  /** The administration agent associated with this distribution
-   * manager. */
+  /**
+   * The administration agent associated with this distribution manager.
+   */
-  
+
-   * Map of InetAddress to HashSets of InetAddress, to define equivalences
-   * between network interface cards and hosts.
+   * Map of InetAddress to HashSets of InetAddress, to define equivalences between network interface
+   * cards and hosts.
-  private final HashMap<InetAddress, Set<InetAddress>> equivalentHosts = new HashMap<InetAddress, Set<InetAddress>>();
+  private final HashMap<InetAddress, Set<InetAddress>> equivalentHosts =
+      new HashMap<InetAddress, Set<InetAddress>>();
-  
-  
-  private final Map<InternalDistributedMember, String> redundancyZones = Collections.synchronizedMap(new HashMap<InternalDistributedMember, String>());
-  
+
+
+  private final Map<InternalDistributedMember, String> redundancyZones =
+      Collections.synchronizedMap(new HashMap<InternalDistributedMember, String>());
+
-  public static final InheritableThreadLocal<Boolean> isFunctionExecutionThread = new InheritableThreadLocal<Boolean>() {
-    @Override
-    protected Boolean initialValue() {
-      return Boolean.FALSE;
-    }
-  };
-  //////////////////////  Static Methods  //////////////////////
+  public static final InheritableThreadLocal<Boolean> isFunctionExecutionThread =
+      new InheritableThreadLocal<Boolean>() {
+        @Override
+        protected Boolean initialValue() {
+          return Boolean.FALSE;
+        }
+      };
+  ////////////////////// Static Methods //////////////////////
-   * Given two DistributionManager ids, check to see if they are
-   * from the same host address.
+   * Given two DistributionManager ids, check to see if they are from the same host address.
+   * 
-   * Creates a new distribution manager and discovers the other members of the
-   * distributed system. Note that it does not check to see whether or not this
-   * VM already has a distribution manager.
+   * Creates a new distribution manager and discovers the other members of the distributed system.
+   * Note that it does not check to see whether or not this VM already has a distribution manager.
-   * @param system
-   *                The distributed system to which this distribution manager
-   *                will send messages.
+   * @param system The distributed system to which this distribution manager will send messages.
-  public static DistributionManager create(InternalDistributedSystem system)
-  {
+  public static DistributionManager create(InternalDistributedSystem system) {
-    
+
-      
+
-    
+
-      
+
-          for (InternalDistributedMember m: (List<InternalDistributedMember>)distributionManager.getViewMembers()) {
+          for (InternalDistributedMember m : (List<InternalDistributedMember>) distributionManager
+              .getViewMembers()) {
-              if (distributionManager.getMembershipManager().verifyMember(m, "member is using the name of " + id)) {
-                throw new IncompatibleSystemException("Member " + id + " could not join this distributed system because the existing member " + m + " used the same name. Set the \"name\" gemfire property to a unique value.");
+              if (distributionManager.getMembershipManager().verifyMember(m,
+                  "member is using the name of " + id)) {
+                throw new IncompatibleSystemException("Member " + id
+                    + " could not join this distributed system because the existing member " + m
+                    + " used the same name. Set the \"name\" gemfire property to a unique value.");
-          // We'll we didn't hear back from anyone else.  We assume that
+          // We'll we didn't hear back from anyone else. We assume that
-            logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_DIDNT_HEAR_BACK_FROM_ANY_OTHER_SYSTEM_I_AM_THE_FIRST_ONE));
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.DistributionManager_DIDNT_HEAR_BACK_FROM_ANY_OTHER_SYSTEM_I_AM_THE_FIRST_ONE));
-        throw new InternalGemFireException(LocalizedStrings.DistributionManager_INTERRUPTED_WHILE_WAITING_FOR_FIRST_STARTUPRESPONSEMESSAGE.toLocalizedString(), ex);
+        throw new InternalGemFireException(
+            LocalizedStrings.DistributionManager_INTERRUPTED_WHILE_WAITING_FOR_FIRST_STARTUPRESPONSEMESSAGE
+                .toLocalizedString(),
+            ex);
-        Object[] logArgs = new Object[] {
-            distributionManager.getDistributionManagerId(),
-            transport,
+        Object[] logArgs = new Object[] {distributionManager.getDistributionManagerId(), transport,
-            ((distributionManager.getDMType() == ADMIN_ONLY_DM_TYPE) ? " (admin only)" : (distributionManager.getDMType() == LOCATOR_DM_TYPE) ? " (locator)" : "")
-        };
-        logger.info(LogMarker.DM, LocalizedMessage.create(
-            LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_0_STARTED_ON_1_THERE_WERE_2_OTHER_DMS_3_4_5, logArgs));
+            ((distributionManager.getDMType() == ADMIN_ONLY_DM_TYPE) ? " (admin only)"
+                : (distributionManager.getDMType() == LOCATOR_DM_TYPE) ? " (locator)" : "")};
+        logger.info(LogMarker.DM,
+            LocalizedMessage.create(
+                LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_0_STARTED_ON_1_THERE_WERE_2_OTHER_DMS_3_4_5,
+                logArgs));
-    }
-    catch (RuntimeException r) {
+    } catch (RuntimeException r) {
-          logger.debug("cleaning up incompletely started DistributionManager due to exception", r); 
+          logger.debug("cleaning up incompletely started DistributionManager due to exception", r);
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-        logger.trace("Caught shutdown exception", e); 
+        logger.trace("Caught shutdown exception", e);
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
+      } else {
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.DistributionManager_TASK_FAILED_WITH_EXCEPTION), t);
-      else {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_TASK_FAILED_WITH_EXCEPTION), t);
-      }
-    }  }
-  
+    }
+  }
+
-  
+
-    
-    // validateDM is commented out because expiry threads hit it with 
+
+    // validateDM is commented out because expiry threads hit it with
-//    private String validateDM() {
-//      GemFireCache cache = GemFireCache.getInstance();
-//      if (cache == null) {
-//        return null; // Distributed system with no cache
-//      }
-//      Object obj = cache.getDistributedSystem();
-//      if (obj == null) {
-//        return null; // Cache is very dead
-//      }
-//      InternalDistributedSystem ids = (InternalDistributedSystem)obj;
-//      DM current = ids.getDistributionManager();
-//      if (current != dm) {
-//        String response = LocalizedStrings.DistributionManager_CURRENT_CACHE_DISTRIBUTIONMANAGER_0_IS_NOT_THE_SAME_AS_1
-//        .toLocalizedString(new Object[] { current, dm});
-//        return response; 
-//      }
-//      return null;
-//    }
-    
+    // private String validateDM() {
+    // GemFireCache cache = GemFireCache.getInstance();
+    // if (cache == null) {
+    // return null; // Distributed system with no cache
+    // }
+    // Object obj = cache.getDistributedSystem();
+    // if (obj == null) {
+    // return null; // Cache is very dead
+    // }
+    // InternalDistributedSystem ids = (InternalDistributedSystem)obj;
+    // DM current = ids.getDistributionManager();
+    // if (current != dm) {
+    // String response =
+    // LocalizedStrings.DistributionManager_CURRENT_CACHE_DISTRIBUTIONMANAGER_0_IS_NOT_THE_SAME_AS_1
+    // .toLocalizedString(new Object[] { current, dm});
+    // return response;
+    // }
+    // return null;
+    // }
+
-      this.dm = dm;  
+      this.dm = dm;
+
-      
+
-        return LocalizedStrings.DistributionManager__0_MESSAGE_DISTRIBUTION_HAS_TERMINATED.toLocalizedString(dm.toString());
+        return LocalizedStrings.DistributionManager__0_MESSAGE_DISTRIBUTION_HAS_TERMINATED
+            .toLocalizedString(dm.toString());
-      
+
-      
+
-        // Caller did not specify  any root cause, so just use our own.
+        // Caller did not specify any root cause, so just use our own.
-      
+
-      }
-      catch (IllegalStateException e2) {
-        // Bug 39496 (Jrockit related)  Give up.  The following
+      } catch (IllegalStateException e2) {
+        // Bug 39496 (Jrockit related) Give up. The following
+
-  
+
-  
-  ///////////////////////  Constructors  ///////////////////////
-  
+
+  /////////////////////// Constructors ///////////////////////
+
-   * Creates a new <code>DistributionManager</code> by initializing
-   * itself, creating the membership manager and executors
+   * Creates a new <code>DistributionManager</code> by initializing itself, creating the membership
+   * manager and executors
-   * @param transport
-   *        The configuration for the communications transport
+   * @param transport The configuration for the communications transport
-  private DistributionManager(RemoteTransportConfig transport,
-                              InternalDistributedSystem system) {
+  private DistributionManager(RemoteTransportConfig transport, InternalDistributedSystem system) {
-      /* deadcoded since we don't know the channel id yet.
-        if (statId == 0 || statId == -1) {
-        statId = getChannelId();
-        }
-      */
+      /*
+       * deadcoded since we don't know the channel id yet. if (statId == 0 || statId == -1) { statId
+       * = getChannelId(); }
+       */
-    
+
-      LoggingThreadGroup.createThreadGroup("DistributionManager Threads", logger);
+        LoggingThreadGroup.createThreadGroup("DistributionManager Threads", logger);
-    
+
-    if (MULTI_SERIAL_EXECUTORS) {
-      if (logger.isInfoEnabled(LogMarker.DM)) {
-        logger.info(LogMarker.DM,
-            "Serial Queue info :" + 
-            " THROTTLE_PERCENT: " + THROTTLE_PERCENT +
-            " SERIAL_QUEUE_BYTE_LIMIT :" + SERIAL_QUEUE_BYTE_LIMIT +   
-            " SERIAL_QUEUE_THROTTLE :" + SERIAL_QUEUE_THROTTLE + 
-            " TOTAL_SERIAL_QUEUE_BYTE_LIMIT :" + TOTAL_SERIAL_QUEUE_BYTE_LIMIT +  
-            " TOTAL_SERIAL_QUEUE_THROTTLE :" + TOTAL_SERIAL_QUEUE_THROTTLE + 
-            " SERIAL_QUEUE_SIZE_LIMIT :" + SERIAL_QUEUE_SIZE_LIMIT +
-            " SERIAL_QUEUE_SIZE_THROTTLE :" + SERIAL_QUEUE_SIZE_THROTTLE
-        ); 
-      }
-      //  when TCP/IP is disabled we can't throttle the serial queue or we run the risk of 
-      // distributed deadlock when we block the UDP reader thread
-      boolean throttlingDisabled = system.getConfig().getDisableTcp();
-      this.serialQueuedExecutorPool = new SerialQueuedExecutorPool(this.threadGroup, this.stats, throttlingDisabled);
-    }
-      
-    {
-      BlockingQueue poolQueue;
-      if (SERIAL_QUEUE_BYTE_LIMIT == 0) {
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getSerialQueueHelper());
-      } else {
-        this.serialQueue = new ThrottlingMemLinkedQueueWithDMStats(TOTAL_SERIAL_QUEUE_BYTE_LIMIT, 
-            TOTAL_SERIAL_QUEUE_THROTTLE, SERIAL_QUEUE_SIZE_LIMIT, SERIAL_QUEUE_SIZE_THROTTLE, 
-            this.stats.getSerialQueueHelper());
-        poolQueue = this.serialQueue;
-     } 
-      ThreadFactory tf = new ThreadFactory() {
-        public Thread newThread(final Runnable command) {
-          DistributionManager.this.stats.incSerialThreadStarts();
-          final Runnable r = new Runnable() {
-            public void run() {
-              DistributionManager.this.stats.incNumSerialThreads(1);
-              try {
-              ConnectionTable.threadWantsSharedResources();
-              Connection.makeReaderThread();
-              runUntilShutdown(command);
-              // command.run();
-              } finally {
-                ConnectionTable.releaseThreadsSockets();
-                DistributionManager.this.stats.incNumSerialThreads(-1);
-              }
-            }
-          };
-          Thread thread = new Thread(group, r, LocalizedStrings.DistributionManager_SERIAL_MESSAGE_PROCESSOR.toLocalizedString());
-          thread.setDaemon(true);
-          return thread;
+      if (MULTI_SERIAL_EXECUTORS) {
+        if (logger.isInfoEnabled(LogMarker.DM)) {
+          logger.info(LogMarker.DM, "Serial Queue info :" + " THROTTLE_PERCENT: " + THROTTLE_PERCENT
+              + " SERIAL_QUEUE_BYTE_LIMIT :" + SERIAL_QUEUE_BYTE_LIMIT + " SERIAL_QUEUE_THROTTLE :"
+              + SERIAL_QUEUE_THROTTLE + " TOTAL_SERIAL_QUEUE_BYTE_LIMIT :"
+              + TOTAL_SERIAL_QUEUE_BYTE_LIMIT + " TOTAL_SERIAL_QUEUE_THROTTLE :"
+              + TOTAL_SERIAL_QUEUE_THROTTLE + " SERIAL_QUEUE_SIZE_LIMIT :" + SERIAL_QUEUE_SIZE_LIMIT
+              + " SERIAL_QUEUE_SIZE_THROTTLE :" + SERIAL_QUEUE_SIZE_THROTTLE);
-      };
-      SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue, 
-          this.stats.getSerialProcessorHelper(), tf);
-      this.serialThread = executor;
-    }
-    {
-      BlockingQueue q = new LinkedBlockingQueue();
-      ThreadFactory tf = new ThreadFactory() {
+        // when TCP/IP is disabled we can't throttle the serial queue or we run the risk of
+        // distributed deadlock when we block the UDP reader thread
+        boolean throttlingDisabled = system.getConfig().getDisableTcp();
+        this.serialQueuedExecutorPool =
+            new SerialQueuedExecutorPool(this.threadGroup, this.stats, throttlingDisabled);
+      }
+
+      {
+        BlockingQueue poolQueue;
+        if (SERIAL_QUEUE_BYTE_LIMIT == 0) {
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getSerialQueueHelper());
+        } else {
+          this.serialQueue = new ThrottlingMemLinkedQueueWithDMStats(TOTAL_SERIAL_QUEUE_BYTE_LIMIT,
+              TOTAL_SERIAL_QUEUE_THROTTLE, SERIAL_QUEUE_SIZE_LIMIT, SERIAL_QUEUE_SIZE_THROTTLE,
+              this.stats.getSerialQueueHelper());
+          poolQueue = this.serialQueue;
+        }
+        ThreadFactory tf = new ThreadFactory() {
-            DistributionManager.this.stats.incViewThreadStarts();
+            DistributionManager.this.stats.incSerialThreadStarts();
-                public void run() {
-                  DistributionManager.this.stats.incNumViewThreads(1);
-                  try {
-                    ConnectionTable.threadWantsSharedResources();
-                    Connection.makeReaderThread();
-                    runUntilShutdown(command);
-                  } finally {
-                    ConnectionTable.releaseThreadsSockets();
-                    DistributionManager.this.stats.incNumViewThreads(-1);
-                  }
+              public void run() {
+                DistributionManager.this.stats.incNumSerialThreads(1);
+                try {
+                  ConnectionTable.threadWantsSharedResources();
+                  Connection.makeReaderThread();
+                  runUntilShutdown(command);
+                  // command.run();
+                } finally {
+                  ConnectionTable.releaseThreadsSockets();
+                  DistributionManager.this.stats.incNumSerialThreads(-1);
-              };
-            Thread thread = new Thread(group, r, LocalizedStrings.DistributionManager_VIEW_MESSAGE_PROCESSOR.toLocalizedString());
+              }
+            };
+            Thread thread = new Thread(group, r,
+                LocalizedStrings.DistributionManager_SERIAL_MESSAGE_PROCESSOR.toLocalizedString());
-      this.viewThread = new SerialQueuedExecutorWithDMStats(q, 
-          this.stats.getViewProcessorHelper(), tf);
-    }
-
-    {
-      BlockingQueue poolQueue;
-      if (INCOMING_QUEUE_LIMIT == 0) {
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getOverflowQueueHelper());
-      } else {
-        poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT, this.stats.getOverflowQueueHelper());
+        SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue,
+            this.stats.getSerialProcessorHelper(), tf);
+        this.serialThread = executor;
-      ThreadFactory tf = new ThreadFactory() {
+      {
+        BlockingQueue q = new LinkedBlockingQueue();
+        ThreadFactory tf = new ThreadFactory() {
+          public Thread newThread(final Runnable command) {
+            DistributionManager.this.stats.incViewThreadStarts();
+            final Runnable r = new Runnable() {
+              public void run() {
+                DistributionManager.this.stats.incNumViewThreads(1);
+                try {
+                  ConnectionTable.threadWantsSharedResources();
+                  Connection.makeReaderThread();
+                  runUntilShutdown(command);
+                } finally {
+                  ConnectionTable.releaseThreadsSockets();
+                  DistributionManager.this.stats.incNumViewThreads(-1);
+                }
+              }
+            };
+            Thread thread = new Thread(group, r,
+                LocalizedStrings.DistributionManager_VIEW_MESSAGE_PROCESSOR.toLocalizedString());
+            thread.setDaemon(true);
+            return thread;
+          }
+        };
+        this.viewThread =
+            new SerialQueuedExecutorWithDMStats(q, this.stats.getViewProcessorHelper(), tf);
+      }
+
+      {
+        BlockingQueue poolQueue;
+        if (INCOMING_QUEUE_LIMIT == 0) {
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getOverflowQueueHelper());
+        } else {
+          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+              this.stats.getOverflowQueueHelper());
+        }
+        ThreadFactory tf = new ThreadFactory() {
-                public void run() {
-                  DistributionManager.this.stats.incNumProcessingThreads(1);
-                  try {
+              public void run() {
+                DistributionManager.this.stats.incNumProcessingThreads(1);
+                try {
-                  } finally {
-                    ConnectionTable.releaseThreadsSockets();
-                    DistributionManager.this.stats.incNumProcessingThreads(-1);
-                  }
+                } finally {
+                  ConnectionTable.releaseThreadsSockets();
+                  DistributionManager.this.stats.incNumProcessingThreads(-1);
-              };
-            Thread thread = new Thread(group, r, 
-               LocalizedStrings.DistributionManager_POOLED_MESSAGE_PROCESSOR.toLocalizedString() + (next++));
+              }
+            };
+            Thread thread = new Thread(group, r,
+                LocalizedStrings.DistributionManager_POOLED_MESSAGE_PROCESSOR.toLocalizedString()
+                    + (next++));
-      ThreadPoolExecutor pool =
-        new PooledExecutorWithDMStats(poolQueue, MAX_THREADS, this.stats.getNormalPoolHelper(), tf);
-      this.threadPool = pool;
-    }
-
-
-    {
-      BlockingQueue poolQueue;
-      if (INCOMING_QUEUE_LIMIT == 0) {
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getHighPriorityQueueHelper());
-      } else {
-        poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT, this.stats.getHighPriorityQueueHelper());
+        ThreadPoolExecutor pool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS,
+            this.stats.getNormalPoolHelper(), tf);
+        this.threadPool = pool;
-      ThreadFactory tf = new ThreadFactory() {
+
+
+      {
+        BlockingQueue poolQueue;
+        if (INCOMING_QUEUE_LIMIT == 0) {
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getHighPriorityQueueHelper());
+        } else {
+          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+              this.stats.getHighPriorityQueueHelper());
+        }
+        ThreadFactory tf = new ThreadFactory() {
-                public void run() {
-                  DistributionManager.this.stats.incHighPriorityThreads(1);
-                  try {
-                    ConnectionTable.threadWantsSharedResources();
-                    Connection.makeReaderThread();
-                    runUntilShutdown(command);
-                  } finally {
-                    ConnectionTable.releaseThreadsSockets();
-                    DistributionManager.this.stats.incHighPriorityThreads(-1);
-                  }
+              public void run() {
+                DistributionManager.this.stats.incHighPriorityThreads(1);
+                try {
+                  ConnectionTable.threadWantsSharedResources();
+                  Connection.makeReaderThread();
+                  runUntilShutdown(command);
+                } finally {
+                  ConnectionTable.releaseThreadsSockets();
+                  DistributionManager.this.stats.incHighPriorityThreads(-1);
-              };
-            Thread thread = new Thread(group, r, 
-                LocalizedStrings.DistributionManager_POOLED_HIGH_PRIORITY_MESSAGE_PROCESSOR.toLocalizedString() + (next++));
+              }
+            };
+            Thread thread = new Thread(group, r,
+                LocalizedStrings.DistributionManager_POOLED_HIGH_PRIORITY_MESSAGE_PROCESSOR
+                    .toLocalizedString() + (next++));
-      this.highPriorityPool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS, this.stats.getHighPriorityPoolHelper(), tf);
-    }
+        this.highPriorityPool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS,
+            this.stats.getHighPriorityPoolHelper(), tf);
+      }
-    {
-      ThreadFactory tf = new ThreadFactory() {
+      {
+        ThreadFactory tf = new ThreadFactory() {
-                public void run() {
-                  DistributionManager.this.stats.incWaitingThreads(1);
-                  try {
+              public void run() {
+                DistributionManager.this.stats.incWaitingThreads(1);
+                try {
-                  } finally {
-                   ConnectionTable.releaseThreadsSockets();
-                   DistributionManager.this.stats.incWaitingThreads(-1);
-                  }
+                } finally {
+                  ConnectionTable.releaseThreadsSockets();
+                  DistributionManager.this.stats.incWaitingThreads(-1);
-              };
-            Thread thread = new Thread(group, r, 
-                                       LocalizedStrings.DistributionManager_POOLED_WAITING_MESSAGE_PROCESSOR.toLocalizedString() + (next++));
+              }
+            };
+            Thread thread = new Thread(group, r,
+                LocalizedStrings.DistributionManager_POOLED_WAITING_MESSAGE_PROCESSOR
+                    .toLocalizedString() + (next++));
-      BlockingQueue poolQueue;
-      if (MAX_WAITING_THREADS == Integer.MAX_VALUE) {
-        // no need for a queue since we have infinite threads
-        poolQueue = new SynchronousQueue();
-      } else {
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getWaitingQueueHelper());
+        BlockingQueue poolQueue;
+        if (MAX_WAITING_THREADS == Integer.MAX_VALUE) {
+          // no need for a queue since we have infinite threads
+          poolQueue = new SynchronousQueue();
+        } else {
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getWaitingQueueHelper());
+        }
+        this.waitingPool = new PooledExecutorWithDMStats(poolQueue, MAX_WAITING_THREADS,
+            this.stats.getWaitingPoolHelper(), tf);
-      this.waitingPool = new PooledExecutorWithDMStats(poolQueue,
-                                                       MAX_WAITING_THREADS,
-                                                       this.stats.getWaitingPoolHelper(),
-                                                       tf);
-    }
-    
-    {
-      ThreadFactory tf = new ThreadFactory() {
+
+      {
+        ThreadFactory tf = new ThreadFactory() {
-            DistributionManager.this.stats.incWaitingThreadStarts();//will it be ok?
+            DistributionManager.this.stats.incWaitingThreadStarts();// will it be ok?
-                public void run() {
-                  DistributionManager.this.stats.incWaitingThreads(1);//will it be ok
-                  try {
+              public void run() {
+                DistributionManager.this.stats.incWaitingThreads(1);// will it be ok
+                try {
-                  } finally {
-                   ConnectionTable.releaseThreadsSockets();
-                   DistributionManager.this.stats.incWaitingThreads(-1);
-                  }
+                } finally {
+                  ConnectionTable.releaseThreadsSockets();
+                  DistributionManager.this.stats.incWaitingThreads(-1);
-              };
-            Thread thread = new Thread(group, r, 
-                                       LocalizedStrings.DistributionManager_PR_META_DATA_CLEANUP_MESSAGE_PROCESSOR.toLocalizedString() + (next++));
+              }
+            };
+            Thread thread = new Thread(group, r,
+                LocalizedStrings.DistributionManager_PR_META_DATA_CLEANUP_MESSAGE_PROCESSOR
+                    .toLocalizedString() + (next++));
-      BlockingQueue poolQueue;
-      poolQueue = new OverflowQueueWithDMStats(this.stats.getWaitingQueueHelper());
-      this.prMetaDataCleanupThreadPool = new PooledExecutorWithDMStats(poolQueue,
-                                                        MAX_PR_META_DATA_CLEANUP_THREADS,
-                                                       this.stats.getWaitingPoolHelper(),
-                                                       tf);
-    }
-
-    {
-      BlockingQueue poolQueue;
-      if (INCOMING_QUEUE_LIMIT == 0) {
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getPartitionedRegionQueueHelper());
-      } else {
-        poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT, this.stats.getPartitionedRegionQueueHelper());
+        BlockingQueue poolQueue;
+        poolQueue = new OverflowQueueWithDMStats(this.stats.getWaitingQueueHelper());
+        this.prMetaDataCleanupThreadPool = new PooledExecutorWithDMStats(poolQueue,
+            MAX_PR_META_DATA_CLEANUP_THREADS, this.stats.getWaitingPoolHelper(), tf);
-      ThreadFactory tf = new ThreadFactory() {
-        private int next = 0;
-        public Thread newThread(final Runnable command) {
-          DistributionManager.this.stats.incPartitionedRegionThreadStarts();
-          final Runnable r = new Runnable() {
+      {
+        BlockingQueue poolQueue;
+        if (INCOMING_QUEUE_LIMIT == 0) {
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getPartitionedRegionQueueHelper());
+        } else {
+          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+              this.stats.getPartitionedRegionQueueHelper());
+        }
+        ThreadFactory tf = new ThreadFactory() {
+          private int next = 0;
+
+          public Thread newThread(final Runnable command) {
+            DistributionManager.this.stats.incPartitionedRegionThreadStarts();
+            final Runnable r = new Runnable() {
-          Thread thread = new Thread(group, r, 
-                                     "PartitionedRegion Message Processor" + (next++));
-          thread.setDaemon(true);
-          return thread;
+            Thread thread = new Thread(group, r, "PartitionedRegion Message Processor" + (next++));
+            thread.setDaemon(true);
+            return thread;
+          }
+        };
+        if (MAX_PR_THREADS > 1) {
+          this.partitionedRegionPool = new PooledExecutorWithDMStats(poolQueue, MAX_PR_THREADS,
+              this.stats.getPartitionedRegionPoolHelper(), tf);
+        } else {
+          SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue,
+              this.stats.getPartitionedRegionPoolHelper(), tf);
+          this.partitionedRegionThread = executor;
-      };
-      if (MAX_PR_THREADS > 1) {
-        this.partitionedRegionPool = new PooledExecutorWithDMStats(poolQueue, 
-            MAX_PR_THREADS, this.stats.getPartitionedRegionPoolHelper(), tf);
-      } else {
-        SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue, 
-            this.stats.getPartitionedRegionPoolHelper(), tf);
-        this.partitionedRegionThread = executor;
-      }
-      
-    }
-    {
-      BlockingQueue poolQueue;
-      if (INCOMING_QUEUE_LIMIT == 0) {
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getFunctionExecutionQueueHelper());
-      } else {
-        poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT, this.stats.getFunctionExecutionQueueHelper());
-      ThreadFactory tf = new ThreadFactory() {
-        private int next = 0;
-        public Thread newThread(final Runnable command) {
-          DistributionManager.this.stats.incFunctionExecutionThreadStarts();
-          final Runnable r = new Runnable() {
+      {
+        BlockingQueue poolQueue;
+        if (INCOMING_QUEUE_LIMIT == 0) {
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getFunctionExecutionQueueHelper());
+        } else {
+          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+              this.stats.getFunctionExecutionQueueHelper());
+        }
+        ThreadFactory tf = new ThreadFactory() {
+          private int next = 0;
+
+          public Thread newThread(final Runnable command) {
+            DistributionManager.this.stats.incFunctionExecutionThreadStarts();
+            final Runnable r = new Runnable() {
-          Thread thread = new Thread(group, r, 
-                                     "Function Execution Processor" + (next++));
-          thread.setDaemon(true);
-          return thread;
+            Thread thread = new Thread(group, r, "Function Execution Processor" + (next++));
+            thread.setDaemon(true);
+            return thread;
+          }
+        };
+
+        if (MAX_FE_THREADS > 1) {
+          this.functionExecutionPool =
+              new FunctionExecutionPooledExecutor(poolQueue, MAX_FE_THREADS,
+                  this.stats.getFunctionExecutionPoolHelper(), tf, true /* for fn exec */);
+        } else {
+          SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue,
+              this.stats.getFunctionExecutionPoolHelper(), tf);
+          this.functionExecutionThread = executor;
-      };
-      
-      if(MAX_FE_THREADS > 1){
-        this.functionExecutionPool = new FunctionExecutionPooledExecutor(poolQueue, 
-            MAX_FE_THREADS, this.stats.getFunctionExecutionPoolHelper(), tf,true /*for fn exec*/);
-      } else {
-        SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue, 
-            this.stats.getFunctionExecutionPoolHelper(), tf);
-        this.functionExecutionThread = executor;
+
-    
-    }
-    
-    if (!SYNC_EVENTS) {
-      this.memberEventThread = new Thread(group, new MemberEventInvoker(), 
-          "DM-MemberEventInvoker");
-      this.memberEventThread.setDaemon(true);
-    }
-    StringBuffer sb = new StringBuffer(" (took ");
+      if (!SYNC_EVENTS) {
+        this.memberEventThread =
+            new Thread(group, new MemberEventInvoker(), "DM-MemberEventInvoker");
+        this.memberEventThread.setDaemon(true);
+      }
-   long start = System.currentTimeMillis();
-    
-    // Create direct channel first
-//    DirectChannel dc = new DirectChannel(new MyListener(this), system.getConfig(), logger, null);
-//    setDirectChannelPort(dc.getPort()); // store in a thread local
+      StringBuffer sb = new StringBuffer(" (took ");
-    // connect to JGroups
-    start = System.currentTimeMillis();
-    
-    MyListener l = new MyListener(this);
-    membershipManager = MemberFactory.newMembershipManager(l, system.getConfig(), transport, stats);
+      long start = System.currentTimeMillis();
-    sb.append(System.currentTimeMillis() - start);
+      // Create direct channel first
+      // DirectChannel dc = new DirectChannel(new MyListener(this), system.getConfig(), logger,
+      // null);
+      // setDirectChannelPort(dc.getPort()); // store in a thread local
-    this.myid = membershipManager.getLocalMember();
+      // connect to JGroups
+      start = System.currentTimeMillis();
-//    dc.patchUpAddress(this.myid);
-//    id.setDirectChannelPort(dc.getPort());
+      MyListener l = new MyListener(this);
+      membershipManager =
+          MemberFactory.newMembershipManager(l, system.getConfig(), transport, stats);
-    // create the distribution channel
-    this.channel = new DistributionChannel(membershipManager);
+      sb.append(System.currentTimeMillis() - start);
-    membershipManager.postConnect();
-    
-    //Assert.assertTrue(this.getChannelMap().size() >= 1);
-    //       System.out.println("Channel Map:");
-    //       for (Iterator iter = this.getChannelMap().entrySet().iterator();
-    //            iter.hasNext(); ) {
-    //         Map.Entry entry = (Map.Entry) iter.next();
-    //         Object key = entry.getKey();
-    //         System.out.println("  " + key + " a " +
-    //                            key.getClass().getName() + " -> " +
-    //                            entry.getValue());
-    //       }
+      this.myid = membershipManager.getLocalMember();
-    sb.append(" ms)");
+      // dc.patchUpAddress(this.myid);
+      // id.setDirectChannelPort(dc.getPort());
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_STARTING_DISTRIBUTIONMANAGER_0_1,
-        new Object[] { this.myid, (logger.isInfoEnabled(LogMarker.DM) ? sb.toString() : "")}));
+      // create the distribution channel
+      this.channel = new DistributionChannel(membershipManager);
-    this.description = NAME + " on " + this.myid + " started at "
-      + (new Date(System.currentTimeMillis())).toString();
+      membershipManager.postConnect();
-    finishedConstructor = true;
+      // Assert.assertTrue(this.getChannelMap().size() >= 1);
+      // System.out.println("Channel Map:");
+      // for (Iterator iter = this.getChannelMap().entrySet().iterator();
+      // iter.hasNext(); ) {
+      // Map.Entry entry = (Map.Entry) iter.next();
+      // Object key = entry.getKey();
+      // System.out.println(" " + key + " a " +
+      // key.getClass().getName() + " -> " +
+      // entry.getValue());
+      // }
+
+      sb.append(" ms)");
+
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.DistributionManager_STARTING_DISTRIBUTIONMANAGER_0_1,
+          new Object[] {this.myid, (logger.isInfoEnabled(LogMarker.DM) ? sb.toString() : "")}));
+
+      this.description = NAME + " on " + this.myid + " started at "
+          + (new Date(System.currentTimeMillis())).toString();
+
+      finishedConstructor = true;
-   * @param system
-   *        The distributed system to which this distribution manager
-   *        will send messages.
+   * @param system The distributed system to which this distribution manager will send messages.
-  private DistributionManager(
-    InternalDistributedSystem system,
-    RemoteTransportConfig transport)
-  {
+  private DistributionManager(InternalDistributedSystem system, RemoteTransportConfig transport) {
-    isStartupThread.set(Boolean.TRUE);
-    
-    startThreads();
-    
-    // Since we need a StartupResponseMessage to make sure licenses
-    // are compatible the following has been deadcoded.
-//     // For the time being, invoke processStartupResponse()
-//     String rejectionMessage = null;
-//     if (GemFireVersion.getGemFireVersion().
-//         equals(state.getGemFireVersion())) {
-//       rejectionMessage = "Rejected new system node " +
-//         this.getDistributionManagerId() + " with version \"" +
-//         GemFireVersion.getGemFireVersion() +
-//         "\" because the distributed system's version is \"" +
-//         state.getGemFireVersion() + "\".";
-//     }
-//     this.processStartupResponse(state.getCacheTime(),
-//                         rejectionMessage);
+      isStartupThread.set(Boolean.TRUE);
-    // Allow events to start being processed.
-    membershipManager.startEventProcessing();
-    for (;;) {
-      this.getCancelCriterion().checkCancelInProgress(null);
-      boolean interrupted = Thread.interrupted();
-      try {
-        membershipManager.waitForEventProcessing();
-        break;
-      }
-      catch (InterruptedException e) {
-        interrupted = true;
-      }
-      finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
+      startThreads();
+
+      // Since we need a StartupResponseMessage to make sure licenses
+      // are compatible the following has been deadcoded.
+      // // For the time being, invoke processStartupResponse()
+      // String rejectionMessage = null;
+      // if (GemFireVersion.getGemFireVersion().
+      // equals(state.getGemFireVersion())) {
+      // rejectionMessage = "Rejected new system node " +
+      // this.getDistributionManagerId() + " with version \"" +
+      // GemFireVersion.getGemFireVersion() +
+      // "\" because the distributed system's version is \"" +
+      // state.getGemFireVersion() + "\".";
+      // }
+      // this.processStartupResponse(state.getCacheTime(),
+      // rejectionMessage);
+
+      // Allow events to start being processed.
+      membershipManager.startEventProcessing();
+      for (;;) {
+        this.getCancelCriterion().checkCancelInProgress(null);
+        boolean interrupted = Thread.interrupted();
+        try {
+          membershipManager.waitForEventProcessing();
+          break;
+        } catch (InterruptedException e) {
+          interrupted = true;
+        } finally {
+          if (interrupted) {
+            Thread.currentThread().interrupt();
+          }
-    }
-    
-    synchronized (DistributionManager.class) {
-      openDMs++;
-    }
-    finishedConstructor = true;
+
+      synchronized (DistributionManager.class) {
+        openDMs++;
+      }
+      finishedConstructor = true;
-  ////////////////////  Instance Methods  /////////////////////
+  //////////////////// Instance Methods /////////////////////
-   * Returns true if the two members are on the same equivalent host based 
-   * on overlapping IP addresses collected for all NICs during exchange of
-   * startup messages.
+   * Returns true if the two members are on the same equivalent host based on overlapping IP
+   * addresses collected for all NICs during exchange of startup messages.
-                                     InternalDistributedMember member2) {
+      InternalDistributedMember member2) {
-  
+
-   * Set the host equivalencies for a given host.  This overrides any
-   * previous information in the tables.
+   * Set the host equivalencies for a given host. This overrides any previous information in the
+   * tables.
+   * 
-     while (it.hasNext()) {
-       equivalentHosts.put(it.next(), Collections.unmodifiableSet(equivs));
-     }
+      while (it.hasNext()) {
+        equivalentHosts.put(it.next(), Collections.unmodifiableSet(equivs));
+      }
-  
+
-  
+
-   * Return all of the InetAddress's that are equivalent to the given one (same
-   * host)
+   * Return all of the InetAddress's that are equivalent to the given one (same host)
+   * 
-    //DS 11/25/08 - It appears that when using VPN, the distributed member
-    //id is the vpn address, but that doesn't show up in the equivalents.
-    if(result == null) {
+    // DS 11/25/08 - It appears that when using VPN, the distributed member
+    // id is the vpn address, but that doesn't show up in the equivalents.
+    if (result == null) {
-  
+
-    if(redundancyZone != null && !redundancyZone.equals("")) {
+    if (redundancyZone != null && !redundancyZone.equals("")) {
-      String relationship = areInSameZone(getDistributionManagerId(), member) ? ""
-          : "not ";
-      Object[] logArgs = new Object[] { member, relationship };
-      logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_MEMBER_0_IS_1_EQUIVALENT, logArgs));
+      String relationship = areInSameZone(getDistributionManagerId(), member) ? "" : "not ";
+      Object[] logArgs = new Object[] {member, relationship};
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_MEMBER_0_IS_1_EQUIVALENT,
+          logArgs));
-   * Set the flag indicating that we should enforce unique zones.
-   * If we are already enforcing unique zones, keep it that way.
+   * Set the flag indicating that we should enforce unique zones. If we are already enforcing unique
+   * zones, keep it that way.
-  
+
-  
+
-  
+
-   * Asserts that distributionManagerType is LOCAL, GEMFIRE, or
-   * ADMIN_ONLY.  Also asserts that the distributionManagerId
-   * (jgroups DistributedMember) has a VmKind that matches.
+   * Asserts that distributionManagerType is LOCAL, GEMFIRE, or ADMIN_ONLY. Also asserts that the
+   * distributionManagerId (jgroups DistributedMember) has a VmKind that matches.
-    case NORMAL_DM_TYPE:
-    case LONER_DM_TYPE:
-    case ADMIN_ONLY_DM_TYPE:
-    case LOCATOR_DM_TYPE:
-      break;
-    default:
-      Assert.assertTrue(false, "unknown distribution manager type");
+      case NORMAL_DM_TYPE:
+      case LONER_DM_TYPE:
+      case ADMIN_ONLY_DM_TYPE:
+      case LOCATOR_DM_TYPE:
+        break;
+      default:
+        Assert.assertTrue(false, "unknown distribution manager type");
-    
+
-      Assert.assertTrue(false, 
-          "InternalDistributedMember has a vmKind of " + vmKind + 
-          " instead of " + theDmType);
+      Assert.assertTrue(false,
+          "InternalDistributedMember has a vmKind of " + vmKind + " instead of " + theDmType);
-  
+
-        }
+      }
+
-    for (int i=0; i<view.size(); i++) {
+    for (int i = 0; i < view.size(); i++) {
-          return (DistributedMember)nextMbr;
+          return (DistributedMember) nextMbr;
-    throw new NoSuchElementException(LocalizedStrings.DistributionManager_NONE_OF_THE_GIVEN_MANAGERS_IS_IN_THE_CURRENT_MEMBERSHIP_VIEW.toLocalizedString());
+    throw new NoSuchElementException(
+        LocalizedStrings.DistributionManager_NONE_OF_THE_GIVEN_MANAGERS_IS_IN_THE_CURRENT_MEMBERSHIP_VIEW
+            .toLocalizedString());
-  
+
-    
+
-   * Need to do this outside the constructor so that the child
-   * constructor can finish.
+   * Need to do this outside the constructor so that the child constructor can finish.
-      
+
-      logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_INITIAL_MEMBERSHIPMANAGER_VIEW___0, printView(v)));
-      
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.DistributionManager_INITIAL_MEMBERSHIPMANAGER_VIEW___0, printView(v)));
+
-      
+
-      throw new InternalGemFireException(LocalizedStrings.DistributionManager_COULD_NOT_PROCESS_INITIAL_VIEW.toLocalizedString(), ex);
+      throw new InternalGemFireException(
+          LocalizedStrings.DistributionManager_COULD_NOT_PROCESS_INITIAL_VIEW.toLocalizedString(),
+          ex);
-          public void run() {
-            // call in background since it might need to send a reply
-            // and we are not ready to send messages until startup is finished
-            isStartupThread.set(Boolean.TRUE);
-            readyForMessages();
-          }
-        });
-    }
-    catch (VirtualMachineError err) {
+        public void run() {
+          // call in background since it might need to send a reply
+          // and we are not ready to send messages until startup is finished
+          isStartupThread.set(Boolean.TRUE);
+          readyForMessages();
+        }
+      });
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionManager_UNCAUGHT_EXCEPTION_CALLING_READYFORMESSAGES), t);
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.DistributionManager_UNCAUGHT_EXCEPTION_CALLING_READYFORMESSAGES), t);
-  
+
-//    membershipManager.waitForEventProcessing();
+    // membershipManager.waitForEventProcessing();
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
+
+   * 
-//    membershipManager.waitForEventProcessing();
+    // membershipManager.waitForEventProcessing();
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
-  
+
-  
+
-   * Did an exception occur in one of the threads launched by this
-   * distribution manager?
+   * Did an exception occur in one of the threads launched by this distribution manager?
-   * Clears the boolean that determines whether or not an exception
-   * occurred in one of the worker threads.  This method should be
-   * used for testing purposes only!
+   * Clears the boolean that determines whether or not an exception occurred in one of the worker
+   * threads. This method should be used for testing purposes only!
-   * Returns the current "cache time" in milliseconds since the epoch.
-   * The "cache time" takes into account skew among the local clocks
-   * on the various machines involved in the cache.
+   * Returns the current "cache time" in milliseconds since the epoch. The "cache time" takes into
+   * account skew among the local clocks on the various machines involved in the cache.
-   * Returns an unmodifiable set containing the identities of all of
-   * the known (non-admin-only) distribution managers.
+   * Returns an unmodifiable set containing the identities of all of the known (non-admin-only)
+   * distribution managers.
-    // access to members synchronized under membersLock in order to 
+    // access to members synchronized under membersLock in order to
-  
+
-   * Adds the entry in {@link #hostedLocatorsAll} for a member with one or more
-   * hosted locators. The value is a collection of host[port] strings. If a 
-   * bind-address was used for a locator then the form is bind-addr[port].
+   * Adds the entry in {@link #hostedLocatorsAll} for a member with one or more hosted locators. The
+   * value is a collection of host[port] strings. If a bind-address was used for a locator then the
+   * form is bind-addr[port].
-  public void addHostedLocators(InternalDistributedMember member, Collection<String> locators, boolean isSharedConfigurationEnabled) {
+  public void addHostedLocators(InternalDistributedMember member, Collection<String> locators,
+      boolean isSharedConfigurationEnabled) {
-      
+
-      
-      Map<InternalDistributedMember, Collection<String>> tmp = 
+
+      Map<InternalDistributedMember, Collection<String>> tmp =
-      
+
-          this.hostedLocatorsWithSharedConfiguration = new HashMap<InternalDistributedMember, Collection<String>>();
+          this.hostedLocatorsWithSharedConfiguration =
+              new HashMap<InternalDistributedMember, Collection<String>>();
-        tmp = new HashMap<InternalDistributedMember, Collection<String>>(this.hostedLocatorsWithSharedConfiguration);
+        tmp = new HashMap<InternalDistributedMember, Collection<String>>(
+            this.hostedLocatorsWithSharedConfiguration);
-  
-  
+
+
-        Map<InternalDistributedMember, Collection<String>> tmp = 
+        Map<InternalDistributedMember, Collection<String>> tmp =
-        Map<InternalDistributedMember, Collection<String>> tmp = 
-            new HashMap<InternalDistributedMember, Collection<String>>(this.hostedLocatorsWithSharedConfiguration);
+        Map<InternalDistributedMember, Collection<String>> tmp =
+            new HashMap<InternalDistributedMember, Collection<String>>(
+                this.hostedLocatorsWithSharedConfiguration);
-  
-  
-  
+
+
+
-   * Gets the value in {@link #hostedLocatorsAll} for a member with one or more
-   * hosted locators. The value is a collection of host[port] strings. If a 
-   * bind-address was used for a locator then the form is bind-addr[port].
+   * Gets the value in {@link #hostedLocatorsAll} for a member with one or more hosted locators. The
+   * value is a collection of host[port] strings. If a bind-address was used for a locator then the
+   * form is bind-addr[port].
-  
+
-   * Returns a copy of the map of all members hosting locators. The key is the 
-   * member, and the value is a collection of host[port] strings. If a 
-   * bind-address was used for a locator then the form is bind-addr[port].
+   * Returns a copy of the map of all members hosting locators. The key is the member, and the value
+   * is a collection of host[port] strings. If a bind-address was used for a locator then the form
+   * is bind-addr[port].
+   *
+   * The member is the vm that hosts one or more locator, if another locator starts up linking to
+   * this locator, it will put that member in this map as well, and this member will in the map on
+   * the other locato vm as well.
+   *
+   * The keyset of the map are the locator vms in this cluster.
+   *
+   * the value is a collection of strings in case one vm can have multiple locators ????
+
-   * Returns a copy of the map of all members hosting locators with shared configuration. The key is the 
-   * member, and the value is a collection of host[port] strings. If a 
-   * bind-address was used for a locator then the form is bind-addr[port].
+   * Returns a copy of the map of all members hosting locators with shared configuration. The key is
+   * the member, and the value is a collection of host[port] strings. If a bind-address was used for
+   * a locator then the form is bind-addr[port].
+
-   * Returns an unmodifiable set containing the identities of all of
-   * the known (including admin) distribution managers.
+   * Returns an unmodifiable set containing the identities of all of the known (including admin)
+   * distribution managers.
-    // access to members synchronized under membersLock in order to 
+    // access to members synchronized under membersLock in order to
-  
+
-   * Returns the low-level distribution channel for this distribution
-   * manager. (brought over from ConsoleDistributionManager)
+   * Returns the low-level distribution channel for this distribution manager. (brought over from
+   * ConsoleDistributionManager)
-   * Returns a private-memory list containing the identities of all
-   * the other known distribution managers not including me.
+   * Returns a private-memory list containing the identities of all the other known distribution
+   * managers not including me.
+
-      return (InternalDistributedMember)id;
+      return (InternalDistributedMember) id;
-   * Add a membership listener and return other DistribtionManagerIds
-   * as an atomic operation
+   * Add a membership listener and return other DistribtionManagerIds as an atomic operation
-      // listener.  This ensures that the listener (probably a
+      // listener. This ensures that the listener (probably a
-        break;        
+        break;
-        throw new InternalGemFireError(LocalizedStrings.DistributionManager_UNKNOWN_MEMBER_TYPE_0.toLocalizedString(Integer.valueOf(vmType)));
+        throw new InternalGemFireError(LocalizedStrings.DistributionManager_UNKNOWN_MEMBER_TYPE_0
+            .toLocalizedString(Integer.valueOf(vmType)));
-   /**
+  /**
-   * Returns the id of the underlying distribution channel used for
-   * communication.
+   * Returns the id of the underlying distribution channel used for communication.
-   * Adds a message to the outgoing queue.  Note that
-   * <code>message</code> should not be modified after it has been
-   * added to the queue.  After <code>message</code> is distributed,
-   * it will be recycled.
+   * Adds a message to the outgoing queue. Note that <code>message</code> should not be modified
+   * after it has been added to the queue. After <code>message</code> is distributed, it will be
+   * recycled.
-  public Set putOutgoingUserData(final DistributionMessage message) 
+  public Set putOutgoingUserData(final DistributionMessage message)
-    return sendMessage(message); 
+    return sendMessage(message);
+   * 
-      if(observer != null) {
+      if (observer != null) {
-    }
-    catch (NotSerializableException e) {
+    } catch (NotSerializableException e) {
-    }
-    catch (ToDataException e) {
+    } catch (ToDataException e) {
-  
+
-   * Informs other members that this dm is shutting down.
-   * Stops the pusher, puller, and processor threads and closes the
-   * connection to the transport layer.
+   * Informs other members that this dm is shutting down. Stops the pusher, puller, and processor
+   * threads and closes the connection to the transport layer.
-    // "Starting" message.  recycleConn.conf is hard to debug w/o this
-    final String exceptionStatus = (this.exceptionInThreads() ? LocalizedStrings.DistributionManager_AT_LEAST_ONE_EXCEPTION_OCCURRED.toLocalizedString() : "");
+    // "Starting" message. recycleConn.conf is hard to debug w/o this
+    final String exceptionStatus = (this.exceptionInThreads()
+        ? LocalizedStrings.DistributionManager_AT_LEAST_ONE_EXCEPTION_OCCURRED.toLocalizedString()
+        : "");
-          logger.debug("inhibiting sending of shutdown message to other members due to forced-disconnect");
+          logger.debug(
+              "inhibiting sending of shutdown message to other members due to forced-disconnect");
-            }
-            catch (final CancelException e) {
+            } catch (final CancelException e) {
-        final Thread t = new Thread(threadGroup,
-            r, LocalizedStrings.DistributionManager_SHUTDOWN_MESSAGE_THREAD_FOR_0.toLocalizedString(this.myid));
+        final Thread t = new Thread(threadGroup, r,
+            LocalizedStrings.DistributionManager_SHUTDOWN_MESSAGE_THREAD_FOR_0
+                .toLocalizedString(this.myid));
-        }
-        catch (final InterruptedException e) {
+        } catch (final InterruptedException e) {
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_INTERRUPTED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS), e);
-        }
-        finally {
+          logger.warn(
+              LocalizedMessage.create(
+                  LocalizedStrings.DistributionManager_INTERRUPTED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS),
+              e);
+        } finally {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_FAILED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS_TIMEOUT));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.DistributionManager_FAILED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS_TIMEOUT));
-      
-    }
-    finally {
+
+    } finally {
-      }
-      finally {
+      } finally {
-          LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_STOPPED_IN_0_MS, delta));
+            LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_STOPPED_IN_0_MS, delta));
-  
+
-      // processed.  Not sure it's very important whether they get
+      // processed. Not sure it's very important whether they get
-    
+
-  
+
-    
-    ExecutorService[] allExecutors = new ExecutorService[] {
-        this.serialThread, 
-        this.viewThread, 
-        this.functionExecutionThread, 
-        this.functionExecutionPool,
-        this.partitionedRegionThread, 
-        this.partitionedRegionPool,
-        this.highPriorityPool,
-        this.waitingPool,
-        this.prMetaDataCleanupThreadPool,
-        this.threadPool};
-    for(ExecutorService es : allExecutors) { 
+
+    ExecutorService[] allExecutors = new ExecutorService[] {this.serialThread, this.viewThread,
+        this.functionExecutionThread, this.functionExecutionPool, this.partitionedRegionThread,
+        this.partitionedRegionPool, this.highPriorityPool, this.waitingPool,
+        this.prMetaDataCleanupThreadPool, this.threadPool};
+    for (ExecutorService es : allExecutors) {
-      if(remaining <= 0) {
+      if (remaining <= 0) {
-    
-    
+
+
-    if(remaining <= 0) {
+    if (remaining <= 0) {
-      th.interrupt(); // bug #43452 - this thread sometimes eats interrupts, so we interrupt it again here
+      th.interrupt(); // bug #43452 - this thread sometimes eats interrupts, so we interrupt it
+                      // again here
-    
+
-  
+
-  
+
-   * Time to sleep, in milliseconds, while polling to see if threads have 
-   * finished
+   * Time to sleep, in milliseconds, while polling to see if threads have finished
-  
+
-  
+
-      logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_FORCING_THREAD_STOP_ON__0_, t));
-      
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.DistributionManager_FORCING_THREAD_STOP_ON__0_, t));
+
-      
-// we could be more violent here...
-//      t.stop();
+
+      // we could be more violent here...
+      // t.stop();
-      }
-      catch (InterruptedException ex) {
+      } catch (InterruptedException ex) {
-      
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_CLOBBERTHREAD_THREAD_REFUSED_TO_DIE__0, t));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.DistributionManager_CLOBBERTHREAD_THREAD_REFUSED_TO_DIE__0, t));
-  
+
+   * 
-  private boolean executorAlive(ThreadPoolExecutor tpe, String name)
-  {
+  private boolean executorAlive(ThreadPoolExecutor tpe, String name) {
-//      boolean result = tpe.getActiveCount() > 0;
+      // boolean result = tpe.getActiveCount() > 0;
-  
+
-   * Wait for the ancillary queues to exit.  Kills them if they are
-   * still around.
+   * Wait for the ancillary queues to exit. Kills them if they are still around.
-      
+
-      
+
-      
+
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-        // Desperation, the shutdown thread is being killed.  Don't
+        // Desperation, the shutdown thread is being killed. Don't
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.DistributionManager_INTERRUPTED_DURING_SHUTDOWN), e); 
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.DistributionManager_INTERRUPTED_DURING_SHUTDOWN), e);
-    
+
-        LocalizedStrings.DistributionManager_DAEMON_THREADS_ARE_SLOW_TO_STOP_CULPRITS_INCLUDE_0, culprits));
-    
+        LocalizedStrings.DistributionManager_DAEMON_THREADS_ARE_SLOW_TO_STOP_CULPRITS_INCLUDE_0,
+        culprits));
+
-    }    
+    }
-    
+
-  
+
-  
+
-  
+
-  
+
-   * Stops the pusher, puller and processor threads and closes the
-   * connection to the transport layer.  This should only be used from
-   * shutdown() or from the dm initialization code
+   * Stops the pusher, puller and processor threads and closes the connection to the transport
+   * layer. This should only be used from shutdown() or from the dm initialization code
-  private void uncleanShutdown(boolean duringStartup)
-  {
+  private void uncleanShutdown(boolean duringStartup) {
-      
+
-      try { waitForThreadsToStop(1000); } 
-      catch (InterruptedException ie) {
+      try {
+        waitForThreadsToStop(1000);
+      } catch (InterruptedException ie) {
-      
-//      // bug36329: desperation measure, send a second interrupt?
-//      try { Thread.sleep(1000); } 
-//      catch (InterruptedException ie) {
-//        // No need to reset interrupt bit, we're really trying to quit...
-//      }
-//      forceThreadsToStop();
+
+      // // bug36329: desperation measure, send a second interrupt?
+      // try { Thread.sleep(1000); }
+      // catch (InterruptedException ie) {
+      // // No need to reset interrupt bit, we're really trying to quit...
+      // }
+      // forceThreadsToStop();
-          try { Thread.sleep(100); } 
-          catch (InterruptedException ie) {
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException ie) {
-      }
-      finally {
+      } finally {
-          logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_NOW_CLOSING_DISTRIBUTION_FOR__0, this.myid));
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.DistributionManager_NOW_CLOSING_DISTRIBUTION_FOR__0, this.myid));
-//          this.channel = null;  DO NOT NULL OUT INSTANCE VARIABLES AT SHUTDOWN - bug #42087
+          // this.channel = null; DO NOT NULL OUT INSTANCE VARIABLES AT SHUTDOWN - bug #42087
-   * Returns the distributed system to which this distribution manager
-   * is connected.
+   * Returns the distributed system to which this distribution manager is connected.
-  
+
+   * 
-   * Adds a <code>MembershipListener</code> to this distribution
-   * manager.
+   * Adds a <code>MembershipListener</code> to this distribution manager.
-   * Removes a <code>MembershipListener</code> from this distribution
-   * manager.
+   * Removes a <code>MembershipListener</code> from this distribution manager.
-   * @throws IllegalArgumentException
-   *         <code>l</code> was not registered on this distribution
-   *         manager
+   * @throws IllegalArgumentException <code>l</code> was not registered on this distribution manager
-   * Adds a <code>MembershipListener</code> to this distribution
-   * manager.
+   * Adds a <code>MembershipListener</code> to this distribution manager.
+   * 
-      Set newAllMembershipListeners =
-        new HashSet(this.allMembershipListeners);
+      Set newAllMembershipListeners = new HashSet(this.allMembershipListeners);
-   * Removes a <code>MembershipListener</code> listening for all members
-   * from this distribution manager.
+   * Removes a <code>MembershipListener</code> listening for all members from this distribution
+   * manager.
-   * @throws IllegalArgumentException
-   *         <code>l</code> was not registered on this distribution
-   *         manager
+   * @throws IllegalArgumentException <code>l</code> was not registered on this distribution manager
-      Set newAllMembershipListeners =
-        new HashSet(this.allMembershipListeners);
+      Set newAllMembershipListeners = new HashSet(this.allMembershipListeners);
-        // on the same peer.  We regard this as benign.
+        // on the same peer. We regard this as benign.
-//        String s = "MembershipListener was never registered";
-//        throw new IllegalArgumentException(s);
+        // String s = "MembershipListener was never registered";
+        // throw new IllegalArgumentException(s);
-   * Returns true if this DM or the DistributedSystem owned by
-   * it is closing or is closed.
+   * Returns true if this DM or the DistributedSystem owned by it is closing or is closed.
-  
+
-    synchronized(this.membershipViewIdGuard) {
+    synchronized (this.membershipViewIdGuard) {
-  
+
-   * This stalls waiting for the current membership view (as seen by the
-   * membership manager) to be acknowledged by all membership listeners
+   * This stalls waiting for the current membership view (as seen by the membership manager) to be
+   * acknowledged by all membership listeners
-    synchronized(this.membershipViewIdGuard) { 
+    synchronized (this.membershipViewIdGuard) {
-          logger.debug("waiting for view {}.  Current DM view processed by all listeners is {}", id, this.membershipViewIdAcknowledged);
+          logger.debug("waiting for view {}.  Current DM view processed by all listeners is {}", id,
+              this.membershipViewIdAcknowledged);
-        SystemFailure.checkFailure(); 
+        SystemFailure.checkFailure();
-        //             or reply processors may hang waiting for replies from
-        //             departed members
-//        if (getCancelCriterion().isCancelInProgress()) {
-//          break; // no message, just quit
-//        }
-        if (!DistributionManager.this.system.isConnected &&
-            DistributionManager.this.isClosed()) {
+        // or reply processors may hang waiting for replies from
+        // departed members
+        // if (getCancelCriterion().isCancelInProgress()) {
+        // break; // no message, just quit
+        // }
+        if (!DistributionManager.this.system.isConnected && DistributionManager.this.isClosed()) {
-          MemberEvent ev = (MemberEvent)DistributionManager.this
-              .membershipEventQueue.take();
+          MemberEvent ev = (MemberEvent) DistributionManager.this.membershipEventQueue.take();
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-          }
-          else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_UNEXPECTED_INTERRUPTEDEXCEPTION), e);
+          } else {
+            logger.warn(LocalizedMessage
+                .create(LocalizedStrings.DistributionManager_UNEXPECTED_INTERRUPTEDEXCEPTION), e);
-        }
-        catch (DistributedSystemDisconnectedException e) {
+        } catch (DistributedSystemDisconnectedException e) {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-          }
-          else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_UNEXPECTED_CANCELLATION), e);
+          } else {
+            logger.warn(LocalizedMessage
+                .create(LocalizedStrings.DistributionManager_UNEXPECTED_CANCELLATION), e);
-        }
-        catch (Exception e) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionManager_UNCAUGHT_EXCEPTION_PROCESSING_MEMBER_EVENT), e);
+        } catch (Exception e) {
+          logger.fatal(
+              LocalizedMessage.create(
+                  LocalizedStrings.DistributionManager_UNCAUGHT_EXCEPTION_PROCESSING_MEMBER_EVENT),
+              e);
-      }
-      finally {
+      } finally {
-  
+
-   * Stops the threads associated with this distribution manager and
-   * closes the connection to the transport layer.
+   * Stops the threads associated with this distribution manager and closes the connection to the
+   * transport layer.
-        LocalizedStrings.DistributionManager_MARKING_DISTRIBUTIONMANAGER_0_AS_CLOSED, this.myid));
+          LocalizedStrings.DistributionManager_MARKING_DISTRIBUTIONMANAGER_0_AS_CLOSED, this.myid));
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.DistributionManager_MESSAGE_DISTRIBUTION_HAS_TERMINATED.toLocalizedString(), this.getRootCause());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.DistributionManager_MESSAGE_DISTRIBUTION_HAS_TERMINATED
+              .toLocalizedString(),
+          this.getRootCause());
-  
+
-    synchronized(this.adminConsolesLock) {
+    synchronized (this.adminConsolesLock) {
-  
+
-//   /**
-//    * Initializes and returns a <code>DistributedSystem</code> to be
-//    * sent to new members of the distributed system.
-//    *
-//    * @since GemFire 3.0
-//    */
-//   protected DistributedState getNewDistributedState() {
-//     DistributedState state = new DistributedState();
-//     state.setGemFireVersion(GemFireVersion.getGemFireVersion());
-//     state.setCacheTime(this.cacheTimeMillis());
-//     return state;
-//}
-  
-  private static final int STARTUP_TIMEOUT =
-  Integer.getInteger("DistributionManager.STARTUP_TIMEOUT", 15000).intValue();
+  // /**
+  // * Initializes and returns a <code>DistributedSystem</code> to be
+  // * sent to new members of the distributed system.
+  // *
+  // * @since GemFire 3.0
+  // */
+  // protected DistributedState getNewDistributedState() {
+  // DistributedState state = new DistributedState();
+  // state.setGemFireVersion(GemFireVersion.getGemFireVersion());
+  // state.setCacheTime(this.cacheTimeMillis());
+  // return state;
+  // }
-  public static final boolean DEBUG_NO_ACKNOWLEDGEMENTS = Boolean.getBoolean("DistributionManager.DEBUG_NO_ACKNOWLEDGEMENTS");
+  private static final int STARTUP_TIMEOUT =
+      Integer.getInteger("DistributionManager.STARTUP_TIMEOUT", 15000).intValue();
+
+  public static final boolean DEBUG_NO_ACKNOWLEDGEMENTS =
+      Boolean.getBoolean("DistributionManager.DEBUG_NO_ACKNOWLEDGEMENTS");
-  
+
-  public void retainMembersWithSameOrNewerVersion(Collection<InternalDistributedMember> members, Version version) {
-    for (Iterator<InternalDistributedMember> it = members.iterator(); it.hasNext(); ) {
+  public void retainMembersWithSameOrNewerVersion(Collection<InternalDistributedMember> members,
+      Version version) {
+    for (Iterator<InternalDistributedMember> it = members.iterator(); it.hasNext();) {
-  
+
-  public void removeMembersWithSameOrNewerVersion(Collection<InternalDistributedMember> members, Version version) {
-    for (Iterator<InternalDistributedMember> it = members.iterator(); it.hasNext(); ) {
+  public void removeMembersWithSameOrNewerVersion(Collection<InternalDistributedMember> members,
+      Version version) {
+    for (Iterator<InternalDistributedMember> it = members.iterator(); it.hasNext();) {
-  
+
-   * Add a membership listener for all members
-   * and return other DistribtionManagerIds as an atomic operation
+   * Add a membership listener for all members and return other DistribtionManagerIds as an atomic
+   * operation
+   * 
-    //  waiting to lock monitor 0x080f691c (object 0xe3ba7680, a org.apache.geode.distributed.internal.DistributionManager$MembersLock),
-    //  which is held by "RMI TCP Connection(259)-10.80.10.55"
+    // waiting to lock monitor 0x080f691c (object 0xe3ba7680, a
+    // org.apache.geode.distributed.internal.DistributionManager$MembersLock),
+    // which is held by "RMI TCP Connection(259)-10.80.10.55"
-    //  waiting to lock monitor 0x080f6598 (object 0xe3bacd90, a org.apache.geode.distributed.internal.membership.jgroup.JGroupMembershipManager$ViewLock),
-    //  which is held by "View Message Processor"
+    // waiting to lock monitor 0x080f6598 (object 0xe3bacd90, a
+    // org.apache.geode.distributed.internal.membership.jgroup.JGroupMembershipManager$ViewLock),
+    // which is held by "View Message Processor"
-            // listener.  This ensures that the listener (probably a
+            // listener. This ensures that the listener (probably a
-      // listener.  This ensures that the listener (probably a
+      // listener. This ensures that the listener (probably a
-  
+
-   * Sends a startup message and waits for a response.
-   * Returns true if response received; false if it timed out or there are no peers.
+   * Sends a startup message and waits for a response. Returns true if response received; false if
+   * it timed out or there are no peers.
-    throws InterruptedException
-  {
-    if (Thread.interrupted()) throw new InterruptedException();
+      throws InterruptedException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
-          throw new SystemConnectException("Unable to examine network cards and other members exist");
+          throw new SystemConnectException(
+              "Unable to examine network cards and other members exist");
-    if(redundancyZone != null && !redundancyZone.equals("")) {
+    if (redundancyZone != null && !redundancyZone.equals("")) {
-        InetAddress in = (InetAddress)it.next();
+        InetAddress in = (InetAddress) it.next();
-    
+
-      ok = startupOperation.sendStartupMessage(allOthers, STARTUP_TIMEOUT, equivs,
-          redundancyZone, enforceUniqueZone());
-    }
-    catch (Exception re) {
-      throw new SystemConnectException(LocalizedStrings.DistributionManager_ONE_OR_MORE_PEERS_GENERATED_EXCEPTIONS_DURING_CONNECTION_ATTEMPT.toLocalizedString(), re);
+      ok = startupOperation.sendStartupMessage(allOthers, STARTUP_TIMEOUT, equivs, redundancyZone,
+          enforceUniqueZone());
+    } catch (Exception re) {
+      throw new SystemConnectException(
+          LocalizedStrings.DistributionManager_ONE_OR_MORE_PEERS_GENERATED_EXCEPTIONS_DURING_CONNECTION_ATTEMPT
+              .toLocalizedString(),
+          re);
-    boolean isAdminDM = 
-      getId().getVmKind() == DistributionManager.ADMIN_ONLY_DM_TYPE
-      || getId().getVmKind() == DistributionManager.LOCATOR_DM_TYPE
-      || DistributionManager.isDedicatedAdminVM
-      || Boolean.getBoolean(InternalLocator.FORCE_LOCATOR_DM_TYPE);
-    
+    boolean isAdminDM = getId().getVmKind() == DistributionManager.ADMIN_ONLY_DM_TYPE
+        || getId().getVmKind() == DistributionManager.LOCATOR_DM_TYPE
+        || DistributionManager.isDedicatedAdminVM
+        || Boolean.getBoolean(InternalLocator.FORCE_LOCATOR_DM_TYPE);
+
-      
+
-          unresponsiveCount = unfinishedStartups.size();        
+          unresponsiveCount = unfinishedStartups.size();
-            throw new SystemConnectException(LocalizedStrings.DistributionManager_NO_STARTUP_REPLIES_FROM_0.toLocalizedString(unfinishedStartups));
+            throw new SystemConnectException(
+                LocalizedStrings.DistributionManager_NO_STARTUP_REPLIES_FROM_0
+                    .toLocalizedString(unfinishedStartups));
-          Iterator itt = allOthers.iterator();          
+          Iterator itt = allOthers.iterator();
-          throw new SystemConnectException(LocalizedStrings.DistributionManager_RECEIVED_NO_CONNECTION_ACKNOWLEDGMENTS_FROM_ANY_OF_THE_0_SENIOR_CACHE_MEMBERS_1.toLocalizedString(new Object[] {Integer.toString(allOthers.size()), sb.toString()}));
+          throw new SystemConnectException(
+              LocalizedStrings.DistributionManager_RECEIVED_NO_CONNECTION_ACKNOWLEDGMENTS_FROM_ANY_OF_THE_0_SENIOR_CACHE_MEMBERS_1
+                  .toLocalizedString(
+                      new Object[] {Integer.toString(allOthers.size()), sb.toString()}));
-      
+
-              LocalizedStrings.DistributionManager_FORCING_AN_ELDER_JOIN_EVENT_SINCE_A_STARTUP_RESPONSE_WAS_NOT_RECEIVED_FROM_ELDER__0_, e));
+              LocalizedStrings.DistributionManager_FORCING_AN_ELDER_JOIN_EVENT_SINCE_A_STARTUP_RESPONSE_WAS_NOT_RECEIVED_FROM_ELDER__0_,
+              e));
-   * List of InternalDistributedMember's that we have
-   * not received startup replies from.  If null, we have
-   * not finished sending the startup message.
+   * List of InternalDistributedMember's that we have not received startup replies from. If null, we
+   * have not finished sending the startup message.
-  
+
-      Assert.assertTrue(unfinishedStartups == null, 
-          "Set unfinished startups twice");
+      Assert.assertTrue(unfinishedStartups == null, "Set unfinished startups twice");
-      
+
-          InternalDistributedMember m = (InternalDistributedMember)it.next();
+          InternalDistributedMember m = (InternalDistributedMember) it.next();
-  
-  public void removeUnfinishedStartup(InternalDistributedMember m,
-      boolean departed) {
+
+  public void removeUnfinishedStartup(InternalDistributedMember m, boolean departed) {
-      StringId msg = null;      
+      StringId msg = null;
-        msg = LocalizedStrings.DistributionManager_STOPPED_WAITING_FOR_STARTUP_REPLY_FROM_0_BECAUSE_THE_PEER_DEPARTED_THE_VIEW;
-      }
-      else {
-        msg = LocalizedStrings.DistributionManager_STOPPED_WAITING_FOR_STARTUP_REPLY_FROM_0_BECAUSE_THE_REPLY_WAS_FINALLY_RECEIVED;
+        msg =
+            LocalizedStrings.DistributionManager_STOPPED_WAITING_FOR_STARTUP_REPLY_FROM_0_BECAUSE_THE_PEER_DEPARTED_THE_VIEW;
+      } else {
+        msg =
+            LocalizedStrings.DistributionManager_STOPPED_WAITING_FOR_STARTUP_REPLY_FROM_0_BECAUSE_THE_REPLY_WAS_FINALLY_RECEIVED;
-        LocalizedStrings.DistributionManager_STILL_AWAITING_0_RESPONSES_FROM_1, 
-        new Object[] {Integer.valueOf(numLeft), unfinishedStartups}));
+            LocalizedStrings.DistributionManager_STILL_AWAITING_0_RESPONSES_FROM_1,
+            new Object[] {Integer.valueOf(numLeft), unfinishedStartups}));
-  
+
-  void processStartupResponse(InternalDistributedMember sender,
-      long otherCacheTime, String theRejectionMessage) {
+  void processStartupResponse(InternalDistributedMember sender, long otherCacheTime,
+      String theRejectionMessage) {
-  void processStartupResponse(InternalDistributedMember sender,
-      String theRejectionMessage) {
+  void processStartupResponse(InternalDistributedMember sender, String theRejectionMessage) {
-  
+
-   * Based on a recent JGroups view, return a member that might be the
-   * next elder.
+   * Based on a recent JGroups view, return a member that might be the next elder.
+   * 
-    
-//    Assert.assertTrue(!closeInProgress 
-//        && theMembers.contains(this.myid)); // bug36202?
-    
+
+    // Assert.assertTrue(!closeInProgress
+    // && theMembers.contains(this.myid)); // bug36202?
+
-    
+
-        
+
-        
-        // Fix for #45566.  Using a surprise member as the elder can cause a
+
+        // Fix for #45566. Using a surprise member as the elder can cause a
-        
+
-    
+
-      InternalDistributedMember member = it.next(); 
+      InternalDistributedMember member = it.next();
-      
-      // Fix for #45566.  Using a surprise member as the elder can cause a
+
+      // Fix for #45566. Using a surprise member as the elder can cause a
-      if (member.equals(this.myid)) { // c'est moi
+      if (member.equals(this.myid)) {
-          logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_0_IS_THE_ELDER_AND_THE_ONLY_MEMBER, this.myid));
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.DistributionManager_0_IS_THE_ELDER_AND_THE_ONLY_MEMBER, this.myid));
-          logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_I_0_AM_THE_ELDER, this.myid));
+          logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_I_0_AM_THE_ELDER,
+              this.myid));
-      } // c'est moi
+      }
-  
+
-    getSystem().getCancelCriterion().checkCancelInProgress(null); // bug 37884, if DS is disconnecting, throw exception
-    
+    getSystem().getCancelCriterion().checkCancelInProgress(null); // bug 37884, if DS is
+                                                                  // disconnecting, throw exception
+
-  
+
-   * Returns true if id was removed.
-   * Returns false if it was not in the list of managers.
+   * Returns true if id was removed. Returns false if it was not in the list of managers.
-  private boolean removeManager(InternalDistributedMember theId, 
-      boolean crashed, String p_reason) {
+  private boolean removeManager(InternalDistributedMember theId, boolean crashed, String p_reason) {
-          logger.debug("DistributionManager: removing member <{}>; crashed {}; reason = {}", theId, crashed, reason);
+          logger.debug("DistributionManager: removing member <{}>; crashed {}; reason = {}", theId,
+              crashed, reason);
-        Map<InternalDistributedMember,InternalDistributedMember> tmp = new HashMap(this.members);
+        Map<InternalDistributedMember, InternalDistributedMember> tmp = new HashMap(this.members);
-        if(tmp2.remove(theId)) {
+        if (tmp2.remove(theId)) {
-    
+
-      }
-      catch (DistributedSystemDisconnectedException e) {
+      } catch (DistributedSystemDisconnectedException e) {
-    
+
-    
+
- /**
-   * Makes note of a new distribution manager that has started up in
-   * the distributed cache.  Invokes the appropriately listeners.
+  /**
+   * Makes note of a new distribution manager that has started up in the distributed cache. Invokes
+   * the appropriately listeners.
-   * @param theId
-   *        The id of the distribution manager starting up
+   * @param theId The id of the distribution manager starting up
-    HashMap<InternalDistributedMember,InternalDistributedMember> tmp = null;
+    HashMap<InternalDistributedMember, InternalDistributedMember> tmp = null;
-      tmp.put(theId,theId);
+      tmp.put(theId, theId);
-      
+
-        new Object[] { theId, Integer.valueOf(tmp.size())}));
+        new Object[] {theId, Integer.valueOf(tmp.size())}));
-   *   Return true if id is a current member of our system.
+   * Return true if id is a current member of our system.
-      // access to members synchronized under membersLock in order to 
+      // access to members synchronized under membersLock in order to
-  
+
-   * Makes note of a new console that has started up in
-   * the distributed cache.
+   * Makes note of a new console that has started up in the distributed cache.
-    
-    for (Iterator iter = allMembershipListeners.iterator();
-         iter.hasNext(); ) {
+
+    for (Iterator iter = allMembershipListeners.iterator(); iter.hasNext();) {
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_DMMEMBERSHIP_ADMITTING_NEW_ADMINISTRATION_MEMBER__0_, theId));
+    logger.info(LocalizedMessage.create(
+        LocalizedStrings.DistributionManager_DMMEMBERSHIP_ADMITTING_NEW_ADMINISTRATION_MEMBER__0_,
+        theId));
-   * Process an incoming distribution message.
-   * This includes scheduling it correctly based on the message's
-   * nioPriority (executor type)
+   * Process an incoming distribution message. This includes scheduling it correctly based on the
+   * message's nioPriority (executor type)
-    /* disabled - not being used
-       if (message instanceof OutgoingMessageWrapper) {
-       putOutgoing(((OutgoingMessageWrapper)message).getMessage());
-       return;
-       }
-    */
+    /*
+     * disabled - not being used if (message instanceof OutgoingMessageWrapper) {
+     * putOutgoing(((OutgoingMessageWrapper)message).getMessage()); return; }
+     */
-//     long latency = message.getLatency();
-//     this.stats.incMessageTransitTime(latency * 1000000L);
-//     message.resetTimestamp();
+    // long latency = message.getLatency();
+    // this.stats.incMessageTransitTime(latency * 1000000L);
+    // message.resetTimestamp();
- //   message.setRecipient(DistributionManager.this.getId());
+    // message.setRecipient(DistributionManager.this.getId());
-   * @param theId
-   *        The id of the console shutting down
-   * @param crashed only true if we detect this id to be gone from
-   *         a javagroup view
+   * 
+   * @param theId The id of the console shutting down
+   * @param crashed only true if we detect this id to be gone from a javagroup view
-          logger.debug("DistributionManager: removing admin member <{}>; crashed = {}; reason = {}", theId, crashed, reason);
+          logger.debug("DistributionManager: removing admin member <{}>; crashed = {}; reason = {}",
+              theId, crashed, reason);
-    synchronized(this.adminConsolesLock) {
+    synchronized (this.adminConsolesLock) {
-      for (Iterator iter = allMembershipListeners.iterator();
-           iter.hasNext(); ) {
+      for (Iterator iter = allMembershipListeners.iterator(); iter.hasNext();) {
-    
+
-  
+
-    handleManagerDeparture(theId, false, LocalizedStrings.ShutdownMessage_SHUTDOWN_MESSAGE_RECEIVED.toLocalizedString());
+    handleManagerDeparture(theId, false,
+        LocalizedStrings.ShutdownMessage_SHUTDOWN_MESSAGE_RECEIVED.toLocalizedString());
-  /** used by the DistributedMembershipListener and startup and shutdown operations, this
-      method decrements the number of nodes and handles lower-level clean up of
-      the resources used by the departed manager */
-  public void handleManagerDeparture(InternalDistributedMember theId, 
-      boolean p_crashed, String p_reason) {
+  /**
+   * used by the DistributedMembershipListener and startup and shutdown operations, this method
+   * decrements the number of nodes and handles lower-level clean up of the resources used by the
+   * departed manager
+   */
+  public void handleManagerDeparture(InternalDistributedMember theId, boolean p_crashed,
+      String p_reason) {
-    }
-    catch (DistributedSystemDisconnectedException e) {
+    } catch (DistributedSystemDisconnectedException e) {
-    
-    
-    
+
+
+
-    
+
-      if (crashed && ! isCloseInProgress()) {
-        msg = LocalizedStrings.DistributionManager_MEMBER_AT_0_UNEXPECTEDLY_LEFT_THE_DISTRIBUTED_CACHE_1;
+      if (crashed && !isCloseInProgress()) {
+        msg =
+            LocalizedStrings.DistributionManager_MEMBER_AT_0_UNEXPECTEDLY_LEFT_THE_DISTRIBUTED_CACHE_1;
-        msg = LocalizedStrings.DistributionManager_MEMBER_AT_0_GRACEFULLY_LEFT_THE_DISTRIBUTED_CACHE_1;
+        msg =
+            LocalizedStrings.DistributionManager_MEMBER_AT_0_GRACEFULLY_LEFT_THE_DISTRIBUTED_CACHE_1;
-      
+
-      if (this.serialQueuedExecutorPool != null)
-      {
+      if (this.serialQueuedExecutorPool != null) {
-  public void handleManagerSuspect(InternalDistributedMember suspect, 
+  public void handleManagerSuspect(InternalDistributedMember suspect,
-    
+
-  
+
-  public void handleQuorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
+  public void handleQuorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {
-   * Sends the shutdown message.  Not all DistributionManagers need to
-   * do this.
+   * Sends the shutdown message. Not all DistributionManagers need to do this.
-//     [bruce] changed above "if" to have ShutdownMessage sent by locators.
-//     Otherwise the system can hang because an admin member does not trigger
-//     member-left notification unless a new view is received showing the departure.
-//     If two locators are simultaneously shut down this may not occur.
+      // [bruce] changed above "if" to have ShutdownMessage sent by locators.
+      // Otherwise the system can hang because an admin member does not trigger
+      // member-left notification unless a new view is received showing the departure.
+      // If two locators are simultaneously shut down this may not occur.
-    InternalDistributedMember theId =
-      this.getDistributionManagerId();
+    InternalDistributedMember theId = this.getDistributionManagerId();
-//    ReplyProcessor21 rp = new ReplyProcessor21(this, allOthers);
-//    m.setProcessorId(rp.getProcessorId());
-//    m.setMulticast(system.getConfig().getMcastPort() != 0);
+    // ReplyProcessor21 rp = new ReplyProcessor21(this, allOthers);
+    // m.setProcessorId(rp.getProcessorId());
+    // m.setMulticast(system.getConfig().getMcastPort() != 0);
-    //Address recipient = (Address) m.getRecipient();
+    // Address recipient = (Address) m.getRecipient();
-      logger.trace("{} Sending {} to {}", this.getDistributionManagerId(), m, m.getRecipientsDescription());
+      logger.trace("{} Sending {} to {}", this.getDistributionManagerId(), m,
+          m.getRecipientsDescription());
-      //m.resetTimestamp(); // nanotimers across systems don't match
+      // m.resetTimestamp(); // nanotimers across systems don't match
-        stats.incSentMessagesTime(DistributionStats.getStatTime()-startTime);
+        stats.incSentMessagesTime(DistributionStats.getStatTime() - startTime);
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionManager_WHILE_SENDING_SHUTDOWN_MESSAGE), ex2);
-    }
-    finally {
+      logger.fatal(LocalizedMessage
+          .create(LocalizedStrings.DistributionManager_WHILE_SENDING_SHUTDOWN_MESSAGE), ex2);
+    } finally {
-    switch(processorType) {
+    switch (processorType) {
-        throw new InternalGemFireError(
-            LocalizedStrings.DistributionManager_UNKNOWN_PROCESSOR_TYPE
-                .toLocalizedString(processorType));
+        throw new InternalGemFireError(LocalizedStrings.DistributionManager_UNKNOWN_PROCESSOR_TYPE
+            .toLocalizedString(processorType));
-  
-//  /**
-//   * Return a shortened name of a class that excludes the package
-//   */
-//  private static String shortenClassName(String className) {
-//    int index = className.lastIndexOf('.');
-//    if (index != -1) {
-//      return className.substring(index + 1);
-//
-//    } else {
-//      return className;
-//    }
-//  }
+
+  // /**
+  // * Return a shortened name of a class that excludes the package
+  // */
+  // private static String shortenClassName(String className) {
+  // int index = className.lastIndexOf('.');
+  // if (index != -1) {
+  // return className.substring(index + 1);
+  //
+  // } else {
+  // return className;
+  // }
+  // }
+   * 
-    }
-    catch (NotSerializableException e) {
+    } catch (NotSerializableException e) {
-    }
-    catch (ToDataException e) {
+    } catch (ToDataException e) {
-  
+
-   * Actually does the work of sending a message out over the
-   * distribution channel.
+   * Actually does the work of sending a message out over the distribution channel.
-   * @return list of recipients that did not receive the message because
-   * they left the view (null if all received it or it was sent to
-   * {@link DistributionMessage#ALL_RECIPIENTS}.
-   * @throws NotSerializableException
-   *         If <code>message</code> cannot be serialized
+   * @return list of recipients that did not receive the message because they left the view (null if
+   *         all received it or it was sent to {@link DistributionMessage#ALL_RECIPIENTS}.
+   * @throws NotSerializableException If <code>message</code> cannot be serialized
-  protected Set sendOutgoing(DistributionMessage message)
-    throws  NotSerializableException {
+  protected Set sendOutgoing(DistributionMessage message) throws NotSerializableException {
-    
-    Set result = channel.send(message.getRecipients(), message,
-                             DistributionManager.this, 
-                             this.stats);
+
+    Set result =
+        channel.send(message.getRecipients(), message, DistributionManager.this, this.stats);
-        stats.incBroadcastMessagesTime(endTime-startTime);
+        stats.incBroadcastMessagesTime(endTime - startTime);
-    stats.incSentMessages(1L);    
+    stats.incSentMessages(1L);
-      stats.incSentMessagesTime(endTime-startTime);
+      stats.incSentMessagesTime(endTime - startTime);
-    
+
-   * @throws NotSerializableException
-   *         If <codE>message</code> cannot be serialized
+   * @throws NotSerializableException If <codE>message</code> cannot be serialized
-  Set sendMessage(DistributionMessage message) 
-      throws NotSerializableException {
+  Set sendMessage(DistributionMessage message) throws NotSerializableException {
-      
+
-      
+
-    }
-    catch (ReenteredConnectException ex) {
+    } catch (ReenteredConnectException ex) {
-    } 
-    catch (CancelException ex) {
+    } catch (CancelException ex) {
-    }
-    catch (InvalidDeltaException ide) {
-      logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_CAUGHT_EXCEPTION_WHILE_SENDING_DELTA), ide.getCause());
-      throw (RuntimeException)ide.getCause();
-    }
-    catch (Exception ex) {
+    } catch (InvalidDeltaException ide) {
+      logger.info(
+          LocalizedMessage
+              .create(LocalizedStrings.DistributionManager_CAUGHT_EXCEPTION_WHILE_SENDING_DELTA),
+          ide.getCause());
+      throw (RuntimeException) ide.getCause();
+    } catch (Exception ex) {
-      
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionManager_WHILE_PUSHING_MESSAGE_0_TO_1, new Object[] {message, receiver}), ex);
+
+      logger.fatal(
+          LocalizedMessage.create(LocalizedStrings.DistributionManager_WHILE_PUSHING_MESSAGE_0_TO_1,
+              new Object[] {message, receiver}),
+          ex);
-      for (int i = 0; i < message.getRecipients().length; i ++)
+      for (int i = 0; i < message.getRecipients().length; i++)
-   /*   if (ex instanceof org.apache.geode.GemFireIpcResourceException) {
-        return;
-      }*/
+      /*
+       * if (ex instanceof org.apache.geode.GemFireIpcResourceException) { return; }
+       */
-   * Schedule a given message appropriately, depending upon its
-   * executor kind.
+   * Schedule a given message appropriately, depending upon its executor kind.
-  protected void scheduleIncomingMessage(DistributionMessage message)
-  {
-    /* Potential race condition between starting up and getting other
-     * distribution manager ids -- DM will only be initialized upto
-     * the point at which it called startThreads
+  protected void scheduleIncomingMessage(DistributionMessage message) {
+    /*
+     * Potential race condition between starting up and getting other distribution manager ids -- DM
+     * will only be initialized upto the point at which it called startThreads
-   * Mutex to control access to {@link #waitingForElderChange}
-   * or {@link #elder}.
+   * Mutex to control access to {@link #waitingForElderChange} or {@link #elder}.
-  
+
-   * This is the "elder" member of the distributed system, responsible
-   * for certain types of arbitration.
+   * This is the "elder" member of the distributed system, responsible for certain types of
+   * arbitration.
-  
+
-  
-  public InternalDistributedMember getElderId() 
-    throws DistributedSystemDisconnectedException {
-//    membershipManager.waitForEventProcessing();
+
+  public InternalDistributedMember getElderId() throws DistributedSystemDisconnectedException {
+    // membershipManager.waitForEventProcessing();
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.DistributionManager_NO_VALID_ELDER_WHEN_SYSTEM_IS_SHUTTING_DOWN.toLocalizedString(), this.getRootCause());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.DistributionManager_NO_VALID_ELDER_WHEN_SYSTEM_IS_SHUTTING_DOWN
+              .toLocalizedString(),
+          this.getRootCause());
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_ELDER__0__IS_NOT_CURRENTLY_AN_ACTIVE_MEMBER_SELECTING_NEW_ELDER, elder));
+    logger.info(LocalizedMessage.create(
+        LocalizedStrings.DistributionManager_ELDER__0__IS_NOT_CURRENTLY_AN_ACTIVE_MEMBER_SELECTING_NEW_ELDER,
+        elder));
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_NEWLY_SELECTED_ELDER_IS_NOW__0_, elder));
+    logger.info(LocalizedMessage
+        .create(LocalizedStrings.DistributionManager_NEWLY_SELECTED_ELDER_IS_NOW__0_, elder));
+
-  
+
-  /**  
-   * Usage: GrantorRequestProcessor calls getElderState with useTryLock set
-   * to true if the becomeGrantor Collaboration is already acquired.
+  /**
+   * Usage: GrantorRequestProcessor calls getElderState with useTryLock set to true if the
+   * becomeGrantor Collaboration is already acquired.
-   * This tryLock is attempted and if it fails, an exception is thrown to
-   * cause a Doug Lea style back-off (p. 149). It throws an exception because
-   * it needs to back down a couple of packages and I didn't want to couple
-   * this pkg too tightly with the dlock pkg.
+   * This tryLock is attempted and if it fails, an exception is thrown to cause a Doug Lea style
+   * back-off (p. 149). It throws an exception because it needs to back down a couple of packages
+   * and I didn't want to couple this pkg too tightly with the dlock pkg.
-   * GrantorRequestProcessor catches the exception, releases and reacquires
-   * the Collaboration, and then comes back here to attempt the tryLock
-   * again. Currently nothing will stop it from re-attempting forever. It
-   * has to get the ElderState and cannot give up, but it can free up the
-   * Collaboration and then re-enter it. The other thread holding the
-   * elder lock will hold it only briefly. I've added a volatile called
-   * elderStateInitialized which should cause this back-off to occur only
-   * once in the life of a vm... once the elder, always the elder.
+   * GrantorRequestProcessor catches the exception, releases and reacquires the Collaboration, and
+   * then comes back here to attempt the tryLock again. Currently nothing will stop it from
+   * re-attempting forever. It has to get the ElderState and cannot give up, but it can free up the
+   * Collaboration and then re-enter it. The other thread holding the elder lock will hold it only
+   * briefly. I've added a volatile called elderStateInitialized which should cause this back-off to
+   * occur only once in the life of a vm... once the elder, always the elder.
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-      throw new IllegalStateException(LocalizedStrings.DistributionManager_POSSIBLE_DEADLOCK_DETECTED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.DistributionManager_POSSIBLE_DEADLOCK_DETECTED.toLocalizedString());
-    }
-    finally {
+    } finally {
-//    if (Thread.currentThread().isInterrupted())
-//      throw new RuntimeException("Interrupted");
+    // if (Thread.currentThread().isInterrupted())
+    // throw new RuntimeException("Interrupted");
-   * @return true if newElder is the elder; false if he is no longer a member
-   * or we are the elder.
+   * 
+   * @return true if newElder is the elder; false if he is no longer a member or we are the elder.
-//      Assert.assertTrue(
-//          desiredElder.getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE);
+      // Assert.assertTrue(
+      // desiredElder.getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE);
-//          Assert.assertTrue( 
-//              currentElder.getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE);
+          // Assert.assertTrue(
+          // currentElder.getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE);
-                public void memberJoined(InternalDistributedMember theId) {
-                  // nothing needed
+              public void memberJoined(InternalDistributedMember theId) {
+                // nothing needed
+              }
+
+              public void memberDeparted(InternalDistributedMember theId, boolean crashed) {
+                if (desiredElder.equals(theId)) {
+                  notifyElderChangeWaiters();
-                public void memberDeparted(InternalDistributedMember theId, boolean crashed) {
-                  if (desiredElder.equals(theId)) {
-                    notifyElderChangeWaiters();
-                  }
-                }
-                public void memberSuspect(InternalDistributedMember id,
-                    InternalDistributedMember whoSuspected, String reason) {
-                }
-                public void viewInstalled(NetView view) {
-                }
-                public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-                }
+              }
+
+              public void memberSuspect(InternalDistributedMember id,
+                  InternalDistributedMember whoSuspected, String reason) {}
+
+              public void viewInstalled(NetView view) {}
+
+              public void quorumLost(Set<InternalDistributedMember> failures,
+                  List<InternalDistributedMember> remaining) {}
-          logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_CHANGING_ELDER_FROM_0_TO_1,
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.DistributionManager_CHANGING_ELDER_FROM_0_TO_1,
+
-      if (newElder != null &&
-          this.myid != null && !this.myid.equals(newElder)) {
+      if (newElder != null && this.myid != null && !this.myid.equals(newElder)) {
+
-    
+
-      } 
-      catch (InterruptedException ignore) {
+      } catch (InterruptedException ignore) {
-      }
-      finally {
+      } finally {
-   }
+  }
-   * getThreadPool gets this distribution manager's message-processing thread
-   * pool
+   * getThreadPool gets this distribution manager's message-processing thread pool
-   * Return the high-priority message-processing executor */
+   * Return the high-priority message-processing executor
+   */
-  
+
-   * Return the waiting message-processing executor 
+   * Return the waiting message-processing executor
-  
+
-   * Return the waiting message-processing executor 
+   * Return the waiting message-processing executor
-   * Return the waiting message-processing executor 
+   * Return the waiting message-processing executor
-   * Return the waiting message-processing executor 
+   * Return the waiting message-processing executor
-  
+
-     if (MULTI_SERIAL_EXECUTORS) {
-       return this.serialQueuedExecutorPool.getThrottledSerialExecutor(sender);
-     } else {
-       return this.serialThread;
-     }
+    if (MULTI_SERIAL_EXECUTORS) {
+      return this.serialQueuedExecutorPool.getThrottledSerialExecutor(sender);
+    } else {
+      return this.serialThread;
+    }
-    
+
-    if (MULTI_SERIAL_EXECUTORS) {  
+    if (MULTI_SERIAL_EXECUTORS) {
-  
+
-   * Sets the administration agent associated with this distribution
-   * manager.
+   * Sets the administration agent associated with this distribution manager.
-    // Don't let the agent be set twice.  There should be a one-to-one
+    // Don't let the agent be set twice. There should be a one-to-one
-        throw new IllegalStateException(LocalizedStrings.DistributionManager_THERE_IS_ALREADY_AN_ADMIN_AGENT_ASSOCIATED_WITH_THIS_DISTRIBUTION_MANAGER.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.DistributionManager_THERE_IS_ALREADY_AN_ADMIN_AGENT_ASSOCIATED_WITH_THIS_DISTRIBUTION_MANAGER
+                .toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.DistributionManager_THERE_WAS_NEVER_AN_ADMIN_AGENT_ASSOCIATED_WITH_THIS_DISTRIBUTION_MANAGER.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.DistributionManager_THERE_WAS_NEVER_AN_ADMIN_AGENT_ASSOCIATED_WITH_THIS_DISTRIBUTION_MANAGER
+                .toLocalizedString());
-   * Returns the agent that owns this distribution manager.
-   * (in ConsoleDistributionManager)
+   * Returns the agent that owns this distribution manager. (in ConsoleDistributionManager)
+   * 
-  public RemoteGfManagerAgent getAgent(){
+  public RemoteGfManagerAgent getAgent() {
-   * Returns a description of the distribution configuration used for
-   * this distribution manager. (in ConsoleDistributionManager)
+   * Returns a description of the distribution configuration used for this distribution manager. (in
+   * ConsoleDistributionManager)
-   * @return <code>null</code> if no admin {@linkplain #getAgent
-   *         agent} is associated with this distribution manager
+   * @return <code>null</code> if no admin {@linkplain #getAgent agent} is associated with this
+   *         distribution manager
-  } 
+  }
+   * 
-   * @return the health monitor created by the owner; <code>null</code>
-   *    if the owner has now created a monitor.
+   * @return the health monitor created by the owner; <code>null</code> if the owner has now created
+   *         a monitor.
-    return (HealthMonitor)this.hmMap.get(owner);
+    return (HealthMonitor) this.hmMap.get(owner);
+
-  public void createHealthMonitor(InternalDistributedMember owner,
-                                  GemFireHealthConfig cfg) {
+  public void createHealthMonitor(InternalDistributedMember owner, GemFireHealthConfig cfg) {
+
+   * 
+
-      HealthMonitor hm = (HealthMonitor)it.next();
+      HealthMonitor hm = (HealthMonitor) it.next();
-  
+
-  
+
-  
+
-  
-  /** Returns the membership manager for this distributed system.
-      The membership manager owns the membership set and handles
-      all communications.   The manager should NOT be used to
-      bypass DistributionManager to send or receive messages.<p>
-      This method was added to allow hydra to obtain thread-local
-      data for transport from one thread to another. */
+
+  /**
+   * Returns the membership manager for this distributed system. The membership manager owns the
+   * membership set and handles all communications. The manager should NOT be used to bypass
+   * DistributionManager to send or receive messages.
+   * <p>
+   * This method was added to allow hydra to obtain thread-local data for transport from one thread
+   * to another.
+   */
-    // NOTE: do not add cancellation checks here.  This method is
+    // NOTE: do not add cancellation checks here. This method is
-  //////////////////////  Inner Classes  //////////////////////
+  ////////////////////// Inner Classes //////////////////////
-   * This class is used for DM's multi serial executor.
-   * The serial messages are managed/executed by multiple serial thread.
-   * This class takes care of executing messages related to a sender 
-   * using the same thread.
+   * This class is used for DM's multi serial executor. The serial messages are managed/executed by
+   * multiple serial thread. This class takes care of executing messages related to a sender using
+   * the same thread.
-  static private class SerialQueuedExecutorPool  {
+  static private class SerialQueuedExecutorPool {
-    
+
-    
+
-    
-    /** Holds info about unused thread, a thread is marked unused when the 
-     *  member associated with it has left distribution system. 
+
+    /**
+     * Holds info about unused thread, a thread is marked unused when the member associated with it
+     * has left distribution system.
-    
+
-    
+
-    
+
+     * 
-     * @param stats 
+     * @param stats
-    SerialQueuedExecutorPool(ThreadGroup group, DistributionStats stats, boolean throttlingDisabled) {
+    SerialQueuedExecutorPool(ThreadGroup group, DistributionStats stats,
+        boolean throttlingDisabled) {
-     * Returns an id of the thread in serialQueuedExecutorMap, thats mapped to the 
-     * given seder.
+     * Returns an id of the thread in serialQueuedExecutorMap, thats mapped to the given seder.
-     * @param sender 
-     * @param createNew boolean flag to indicate whether to create a new id, if id
-     *                  doesnot exists. 
+     * @param sender
+     * 
+     * @param createNew boolean flag to indicate whether to create a new id, if id doesnot exists.
-      
-      synchronized (senderToSerialQueueIdMap)
-      { 
+
+      synchronized (senderToSerialQueueIdMap) {
-        queueId = (Integer)senderToSerialQueueIdMap.get(sender);
-        
-        if (!createNew || queueId != null){
+        queueId = (Integer) senderToSerialQueueIdMap.get(sender);
+
+        if (!createNew || queueId != null) {
-        
+
-        if (!threadMarkedForUse.isEmpty()){
-          queueId = (Integer)threadMarkedForUse.remove(0);
+        if (!threadMarkedForUse.isEmpty()) {
+          queueId = (Integer) threadMarkedForUse.remove(0);
-        if (queueId == null){
-          queueId =  Integer.valueOf((serialQueuedExecutorMap.size() + 1) % MAX_SERIAL_QUEUE_THREAD);
+        if (queueId == null) {
+          queueId = Integer.valueOf((serialQueuedExecutorMap.size() + 1) % MAX_SERIAL_QUEUE_THREAD);
-      }    
-      return queueId;      
-    }
-    
-    /*
-     * Returns the queue associated with this sender.
-     * Used in FlowControl for throttling (based on queue size).
-     */
-    public OverflowQueueWithDMStats getSerialQueue(InternalDistributedMember sender) {
-      Integer queueId = getQueueId(sender, false);
-      if (queueId == null){
-        return null;
-      return (OverflowQueueWithDMStats)serialQueuedMap.get(queueId);
+      return queueId;
-     * Returns the serial queue executor, before returning the thread this 
-     * applies throttling, based on the total serial queue size (total - sum 
-     * of all the serial queue size). 
-     * The throttling is applied during put event, this doesnt block the extract 
-     * operation on the queue. 
+     * Returns the queue associated with this sender. Used in FlowControl for throttling (based on
+     * queue size).
+     */
+    public OverflowQueueWithDMStats getSerialQueue(InternalDistributedMember sender) {
+      Integer queueId = getQueueId(sender, false);
+      if (queueId == null) {
+        return null;
+      }
+      return (OverflowQueueWithDMStats) serialQueuedMap.get(queueId);
+    }
+
+    /*
+     * Returns the serial queue executor, before returning the thread this applies throttling, based
+     * on the total serial queue size (total - sum of all the serial queue size). The throttling is
+     * applied during put event, this doesnt block the extract operation on the queue.
-    public SerialQueuedExecutorWithDMStats getThrottledSerialExecutor(InternalDistributedMember sender) {
+    public SerialQueuedExecutorWithDMStats getThrottledSerialExecutor(
+        InternalDistributedMember sender) {
-      if (stats.getSerialQueueBytes() > TOTAL_SERIAL_QUEUE_THROTTLE  &&
-          !DistributionMessage.isPreciousThread())
-      {
-        do { 
+      if (stats.getSerialQueueBytes() > TOTAL_SERIAL_QUEUE_THROTTLE
+          && !DistributionMessage.isPreciousThread()) {
+        do {
-            float throttlePercent = (float)(totalSerialQueueMemSize - TOTAL_SERIAL_QUEUE_THROTTLE) / (float)(TOTAL_SERIAL_QUEUE_BYTE_LIMIT - TOTAL_SERIAL_QUEUE_THROTTLE);
-            int sleep = (int)(100.0 * throttlePercent);
+            float throttlePercent = (float) (totalSerialQueueMemSize - TOTAL_SERIAL_QUEUE_THROTTLE)
+                / (float) (TOTAL_SERIAL_QUEUE_BYTE_LIMIT - TOTAL_SERIAL_QUEUE_THROTTLE);
+            int sleep = (int) (100.0 * throttlePercent);
-          }
-          finally {
+          } finally {
-      }      
-      return executor;    
+      }
+      return executor;
-      SerialQueuedExecutorWithDMStats executor = null;      
+      SerialQueuedExecutorWithDMStats executor = null;
-      if ((executor = (SerialQueuedExecutorWithDMStats)serialQueuedExecutorMap.get(queueId)) != null){
+      if ((executor =
+          (SerialQueuedExecutorWithDMStats) serialQueuedExecutorMap.get(queueId)) != null) {
-      
-      serialQueuedExecutorMap.put(queueId, executor);  
-         
-      if (logger.isDebugEnabled()){
-        logger.debug("Created Serial Queued Executor With queueId {}. Total number of live Serial Threads :{}", 
-            queueId, serialQueuedExecutorMap.size());          
+
+      serialQueuedExecutorMap.put(queueId, executor);
+
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Created Serial Queued Executor With queueId {}. Total number of live Serial Threads :{}",
+            queueId, serialQueuedExecutorMap.size());
-      
+
-      
+
-        poolQueue = new ThrottlingMemLinkedQueueWithDMStats(SERIAL_QUEUE_BYTE_LIMIT, SERIAL_QUEUE_THROTTLE, SERIAL_QUEUE_SIZE_LIMIT, SERIAL_QUEUE_SIZE_THROTTLE, this.stats.getSerialQueueHelper());
+        poolQueue = new ThrottlingMemLinkedQueueWithDMStats(SERIAL_QUEUE_BYTE_LIMIT,
+            SERIAL_QUEUE_THROTTLE, SERIAL_QUEUE_SIZE_LIMIT, SERIAL_QUEUE_SIZE_THROTTLE,
+            this.stats.getSerialQueueHelper());
-      
+
-      
+
-          
+
-      return new SerialQueuedExecutorWithDMStats(poolQueue, this.stats.getSerialPooledProcessorHelper(), tf);
+      return new SerialQueuedExecutorWithDMStats(poolQueue,
+          this.stats.getSerialPooledProcessorHelper(), tf);
-    
+
-     * Does cleanup relating to this member. And marks the serial executor associated
-     * with this member for re-use.
+     * Does cleanup relating to this member. And marks the serial executor associated with this
+     * member for re-use.
-    public void handleMemberDeparture(InternalDistributedMember member)
-    {
+    public void handleMemberDeparture(InternalDistributedMember member) {
-      if (queueId == null){
+      if (queueId == null) {
-      
+
-      
-      synchronized (senderToSerialQueueIdMap)
-      { 
+
+      synchronized (senderToSerialQueueIdMap) {
-        
+
-          Integer value = (Integer)iter.next();
-          if (value.equals(queueId))
-          {
+          Integer value = (Integer) iter.next();
+          if (value.equals(queueId)) {
-        } 
-        
+        }
+
-        if (!isUsed)
-        {
+        if (!isUsed) {
-            logger.info(LogMarker.DM, LocalizedMessage.create(
-                LocalizedStrings.DistributionManager_MARKING_THE_SERIALQUEUEDEXECUTOR_WITH_ID__0__USED_BY_THE_MEMBER__1__TO_BE_UNUSED,
-                new Object[] {queueId, member}));      
-          
+            logger.info(LogMarker.DM,
+                LocalizedMessage.create(
+                    LocalizedStrings.DistributionManager_MARKING_THE_SERIALQUEUEDEXECUTOR_WITH_ID__0__USED_BY_THE_MEMBER__1__TO_BE_UNUSED,
+                    new Object[] {queueId, member}));
+
-        }        
+        }
-    
+
-        ExecutorService executor = (ExecutorService)iter.next();
+        ExecutorService executor = (ExecutorService) iter.next();
-        if(remainingNanos <= 0) {
+        if (remainingNanos <= 0) {
-    
-    protected void shutdown(){
+
+    protected void shutdown() {
-        ExecutorService executor = (ExecutorService)iter.next();
+        ExecutorService executor = (ExecutorService) iter.next();
-   * A simple class used for locking the list of members of the
-   * distributed system.  We give this lock its own class so that it
-   * shows up nicely in stack traces.
+   * A simple class used for locking the list of members of the distributed system. We give this
+   * lock its own class so that it shows up nicely in stack traces.
-  private static final class MembersLock  {
+  private static final class MembersLock {
-   * A simple class used for locking the list of membership listeners.
-   * We give this lock its own class so that it shows up nicely in
-   * stack traces.
+   * A simple class used for locking the list of membership listeners. We give this lock its own
+   * class so that it shows up nicely in stack traces.
-  private static final class MembershipListenersLock  {
-    protected MembershipListenersLock() {
-    }
+  private static final class MembershipListenersLock {
+    protected MembershipListenersLock() {}
-   * This is the listener implementation for responding from events from
-   * the Membership Manager.
+   * This is the listener implementation for responding from events from the Membership Manager.
-    
+
-    
+
-     public void messageReceived(DistributionMessage message) {
+    public void messageReceived(DistributionMessage message) {
-      // without holding the view lock.  That can cause a race condition and
-      // subsequent deadlock (#45566).  Elder selection is now done when a view
+      // without holding the view lock. That can cause a race condition and
+      // subsequent deadlock (#45566). Elder selection is now done when a view
-        message.setIgnoreAlertListenerRemovalFailure(true); // we don't know if it was a listener so don't issue a warning
+        message.setIgnoreAlertListenerRemovalFailure(true); // we don't know if it was a listener so
+                                                            // don't issue a warning
-        message.setReason(reason); //added for #37950
+        message.setReason(reason); // added for #37950
-    
-    public void memberSuspect(InternalDistributedMember suspect, InternalDistributedMember whoSuspected, String reason) {
+
+    public void memberSuspect(InternalDistributedMember suspect,
+        InternalDistributedMember whoSuspected, String reason) {
-    
+
-    
+
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
+    public void quorumLost(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {
-    public DistributionManager getDM()
-    {
+    public DistributionManager getDM() {
-    
+
-      }
-      catch (DistributedSystemDisconnectedException e) {
+      } catch (DistributedSystemDisconnectedException e) {
-  
- 
-  private static abstract class MemberEvent  {
-    
+
+
+  private static abstract class MemberEvent {
+
+
+
-    protected void handleEvent(DistributionManager manager, Set<MembershipListener> membershipListeners) {
+    protected void handleEvent(DistributionManager manager,
+        Set<MembershipListener> membershipListeners) {
-          }
-          else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_UNEXPECTED_CANCELLATION), e);
+          } else {
+            logger.warn(LocalizedMessage
+                .create(LocalizedStrings.DistributionManager_UNEXPECTED_CANCELLATION), e);
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-          logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionManager_EXCEPTION_WHILE_CALLING_MEMBERSHIP_LISTENER_FOR_EVENT__0, this), t);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.DistributionManager_EXCEPTION_WHILE_CALLING_MEMBERSHIP_LISTENER_FOR_EVENT__0,
+              this), t);
-}
-  
-  /**
-   * This is an event reflecting that a InternalDistributedMember has joined
-   * the system.
-   * 
-   *
-   */
-  private static final class MemberJoinedEvent extends MemberEvent  {
-    MemberJoinedEvent(InternalDistributedMember id) {
-      super(id);
-    }
-    @Override
-    public String toString() {
-      return "member " + getId() + " joined";
-    }
-    @Override
-    protected void handleEvent(MembershipListener listener) {
-      listener.memberJoined(getId());	
-    }
-  }
-  
-  /**
-   * This is an event reflecting that a InternalDistributedMember has left the system.
-   *
-   */
-  private static final class MemberDepartedEvent extends MemberEvent  {
-    String reason;
-    
-    MemberDepartedEvent(InternalDistributedMember id, String r) {
-      super(id);
-      reason = r;
-    }
-    @Override
-    public String toString() {
-      return "member " + getId() + " departed (" + reason + ")";
-    }
-    @Override
-    protected void handleEvent(MembershipListener listener) {
-     listener.memberDeparted(getId(), false);	
-    }
-  }
-  
-  /**
-   * This is an event reflecting that a InternalDistributedMember has left the
-   * system in an unexpected way.
-   * 
-   *
-   */
-  private static final class MemberCrashedEvent extends MemberEvent  {
-    String reason;
-    
-    MemberCrashedEvent(InternalDistributedMember id, String r) {
-      super(id);
-      reason = r;
-    }
-    @Override
-    public String toString() {
-      return "member " + getId() + " crashed: " + reason;
-    }
-    @Override
-    protected void handleEvent(MembershipListener listener) {
-      listener.memberDeparted(getId(), true/*crashed*/);	
-    }
-   * This is an event reflecting that a InternalDistributedMember may be missing
-   * but has not yet left the system.
+   * This is an event reflecting that a InternalDistributedMember has joined the system.
+   * 
+   *
+   */
+  private static final class MemberJoinedEvent extends MemberEvent {
+    MemberJoinedEvent(InternalDistributedMember id) {
+      super(id);
+    }
+
+    @Override
+    public String toString() {
+      return "member " + getId() + " joined";
+    }
+
+    @Override
+    protected void handleEvent(MembershipListener listener) {
+      listener.memberJoined(getId());
+    }
+  }
+
+  /**
+   * This is an event reflecting that a InternalDistributedMember has left the system.
+   *
+   */
+  private static final class MemberDepartedEvent extends MemberEvent {
+    String reason;
+
+    MemberDepartedEvent(InternalDistributedMember id, String r) {
+      super(id);
+      reason = r;
+    }
+
+    @Override
+    public String toString() {
+      return "member " + getId() + " departed (" + reason + ")";
+    }
+
+    @Override
+    protected void handleEvent(MembershipListener listener) {
+      listener.memberDeparted(getId(), false);
+    }
+  }
+
+  /**
+   * This is an event reflecting that a InternalDistributedMember has left the system in an
+   * unexpected way.
+   * 
+   *
+   */
+  private static final class MemberCrashedEvent extends MemberEvent {
+    String reason;
+
+    MemberCrashedEvent(InternalDistributedMember id, String r) {
+      super(id);
+      reason = r;
+    }
+
+    @Override
+    public String toString() {
+      return "member " + getId() + " crashed: " + reason;
+    }
+
+    @Override
+    protected void handleEvent(MembershipListener listener) {
+      listener.memberDeparted(getId(), true/* crashed */);
+    }
+  }
+
+  /**
+   * This is an event reflecting that a InternalDistributedMember may be missing but has not yet
+   * left the system.
-    MemberSuspectEvent(InternalDistributedMember suspect, InternalDistributedMember whoSuspected, String reason) {
+
+    MemberSuspectEvent(InternalDistributedMember suspect, InternalDistributedMember whoSuspected,
+        String reason) {
+
-    
+
-    
+
+
-      listener.memberSuspect(getId(), whoSuspected(), reason);	
+      listener.memberSuspect(getId(), whoSuspected(), reason);
-  
+
+
+
+
+
+
-    
-    QuorumLostEvent(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
+
+    QuorumLostEvent(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {
+
+
+
+
-      listener.quorumLost(getFailures(), getRemaining());	
+      listener.quorumLost(getFailures(), getRemaining());
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
+   * 
-  
-  public Set<InternalDistributedMember> getMembersInSameZone(InternalDistributedMember targetMember) {
+
+  public Set<InternalDistributedMember> getMembersInSameZone(
+      InternalDistributedMember targetMember) {
-    if(!redundancyZones.isEmpty()) {
-      synchronized(redundancyZones) {
+    if (!redundancyZones.isEmpty()) {
+      synchronized (redundancyZones) {
-        for(Map.Entry<InternalDistributedMember, String> entry : redundancyZones.entrySet()) {
-          if(entry.getValue().equals(targetZone)) {
+        for (Map.Entry<InternalDistributedMember, String> entry : redundancyZones.entrySet()) {
+          if (entry.getValue().equals(targetZone)) {
-        InternalDistributedMember o = (InternalDistributedMember)i.next();
+        InternalDistributedMember o = (InternalDistributedMember) i.next();
-  
+
-    
-    if(!redundancyZones.isEmpty()) {
+
+    if (!redundancyZones.isEmpty()) {
-  
+
-  
+
-  
+
-   * this causes all members in the system to log thread dumps
-   * If useNative is true we attempt to use OSProcess native code
-   * for the dumps.  This goes to stdout instead of the system.log files.
+   * this causes all members in the system to log thread dumps If useNative is true we attempt to
+   * use OSProcess native code for the dumps. This goes to stdout instead of the system.log files.
-  
+
-   * this causes the given InternalDistributedMembers to log thread dumps.
-   * If useNative is true we attempt to use OSProcess native code
-   * for the dumps.  This goes to stdout instead of the system.log files.
+   * this causes the given InternalDistributedMembers to log thread dumps. If useNative is true we
+   * attempt to use OSProcess native code for the dumps. This goes to stdout instead of the
+   * system.log files.
-      for (Iterator it=ids.iterator(); it.hasNext(); ) {
-        InternalDistributedMember mbr = (InternalDistributedMember)it.next();
+      for (Iterator it = ids.iterator(); it.hasNext();) {
+        InternalDistributedMember mbr = (InternalDistributedMember) it.next();
-    for (DistributedMember m: (Set<DistributedMember>)getDistributionManagerIdsIncludingAdmin()) {
+    for (DistributedMember m : (Set<DistributedMember>) getDistributionManagerIdsIncludingAdmin()) {
-    // access to members synchronized under membersLock in order to 
+    // access to members synchronized under membersLock in order to
-      for (InternalDistributedMember m: this.members.keySet()) {
+      for (InternalDistributedMember m : this.members.keySet()) {
-  
+
-    // access to members synchronized under membersLock in order to 
+    // access to members synchronized under membersLock in order to
-      for (InternalDistributedMember m: this.members.keySet()) {
+      for (InternalDistributedMember m : this.members.keySet()) {

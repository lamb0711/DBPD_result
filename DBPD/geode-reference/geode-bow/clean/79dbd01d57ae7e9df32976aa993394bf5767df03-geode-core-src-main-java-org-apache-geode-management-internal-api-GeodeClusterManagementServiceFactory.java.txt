GEODE-6450: ClientClusterManagementService supports ssl connection (#3276)

Co-authored-by: Jens Deppe <jdeppe@pivotal.io>

* provide capability for the client to configure ssl connection when getting the cluster management service.
* from the server side, create the SSLContext from the ssl configuration specified on the server
* refactor ssl code

+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+
+import org.apache.http.conn.ssl.NoopHostnameVerifier;
+import org.apache.geode.internal.admin.SSLConfig;
+import org.apache.geode.internal.net.SSLConfigurationFactory;
+import org.apache.geode.internal.security.SecurableCommunicationChannel;
-import org.apache.geode.management.internal.ClientClusterManagementService;
+import org.apache.geode.management.internal.SSLUtil;
-public class GeodeClusterManagementServiceFactory extends
-    JavaClientClusterManagementServiceFactory {
+public class GeodeClusterManagementServiceFactory
+    extends JavaClientClusterManagementServiceFactory {
+  public ClusterManagementService create() {
+    return create(null, null);
+  }
+
-  public ClusterManagementService create() throws IllegalStateException {
+  public ClusterManagementService create(String username, String password) {
-      String serviceAddress = getHttpServiceAddress(locatorsWithClusterConfig);
-      return new ClientClusterManagementService(serviceAddress);
+      MemberInformation memberInformation = getHttpServiceAddress(locatorsWithClusterConfig);
+
+      SSLContext sslContext = null;
+      HostnameVerifier hostnameVerifier = null;
+      if (memberInformation.isSsl()) {
+        SSLConfig sslConfig = SSLConfigurationFactory.getSSLConfigForComponent(
+            ((GemFireCacheImpl) cache).getSystem().getConfig(), SecurableCommunicationChannel.WEB);
+        if (sslConfig.getTruststore() == null) {
+          throw new IllegalStateException(
+              "The server needs to have truststore specified in order to use cluster management service.");
+        }
+
+        sslContext = SSLUtil.createAndConfigureSSLContext(sslConfig, false);
+        hostnameVerifier = new NoopHostnameVerifier();
+      }
+
+      return create(getHostName(memberInformation), memberInformation.getHttpServicePort(),
+          sslContext, hostnameVerifier, username, password);
-          "Under construction. To retrieve an instance of ClusterManagementService from a Geode client, please use either create(clusterUrl) or create(requestFactory) methods");
+          "Under construction. To retrieve an instance of ClusterManagementService from a Geode client, please use other methods");
-  private String getHttpServiceAddress(Set<InternalDistributedMember> locators) {
-    for (InternalDistributedMember locator : locators) {
+  private MemberInformation getHttpServiceAddress(Set<InternalDistributedMember> locators) {
+    for (InternalDistributedMember locator : locators) {
-        List<MemberInformation> memberInformation =
+        List<MemberInformation> memberInformations =
-        if (memberInformation.isEmpty()) {
+        if (memberInformations.isEmpty()) {
-        // What address to use
-        String host;
-        if (StringUtils.isNotBlank(memberInformation.get(0).getHttpServiceBindAddress())) {
-          host = memberInformation.get(0).getHttpServiceBindAddress();
-        } else if (StringUtils.isNotBlank(memberInformation.get(0).getServerBindAddress())) {
-          host = memberInformation.get(0).getServerBindAddress();
-        } else {
-          host = memberInformation.get(0).getHost();
-        }
-
-        return String.format("http://%s:%d", host, memberInformation.get(0).getHttpServicePort());
+        // return the first available one. Later for HA, we can return the entire list
+        return memberInformations.get(0);
+
+  private String getHostName(MemberInformation memberInformation) {
+    String host;
+    if (StringUtils.isNotBlank(memberInformation.getHttpServiceBindAddress())) {
+      host = memberInformation.getHttpServiceBindAddress();
+    } else if (StringUtils.isNotBlank(memberInformation.getServerBindAddress())) {
+      host = memberInformation.getServerBindAddress();
+    } else {
+      host = memberInformation.getHost();
+    }
+    return host;
+  }

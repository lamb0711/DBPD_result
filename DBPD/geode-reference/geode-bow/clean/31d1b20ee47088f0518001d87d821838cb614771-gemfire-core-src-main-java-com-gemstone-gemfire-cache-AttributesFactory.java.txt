Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.GemFireIOException;
+import com.gemstone.gemfire.cache.hdfs.HDFSStore;
+import com.gemstone.gemfire.internal.cache.CustomEvictionAttributesImpl;
+    this.regionAttributes.customEvictionAttributes = regionAttributes
+        .getCustomEvictionAttributes();
+    this.regionAttributes.hdfsStoreName = regionAttributes.getHDFSStoreName();
+    this.regionAttributes.hdfsWriteOnly = regionAttributes.getHDFSWriteOnly();
+    if (regionAttributes instanceof UserSpecifiedRegionAttributes) {
+      this.regionAttributes.setHasHDFSWriteOnly(((UserSpecifiedRegionAttributes<K,V>) regionAttributes).hasHDFSWriteOnly());
+    }
+    this.regionAttributes.offHeap = regionAttributes.getOffHeap();
-  /** Sets the mirror type for the next <code>RegionAttributes</code> created.
+  /**
+   * Set custom {@link EvictionCriteria} for the region with start time and
+   * frequency of evictor task to be run in milliseconds, or evict incoming rows
+   * in case both start and frequency are specified as zero.
+   * 
+   * @param criteria
+   *          an {@link EvictionCriteria} to be used for eviction for HDFS
+   *          persistent regions
+   * @param start
+   *          the start time at which periodic evictor task should be first
+   *          fired to apply the provided {@link EvictionCriteria}; if this is
+   *          zero then current time is used for the first invocation of evictor
+   * @param interval
+   *          the periodic frequency at which to run the evictor task after the
+   *          initial start; if this is if both start and frequency are zero
+   *          then {@link EvictionCriteria} is applied on incoming insert/update
+   *          to determine whether it is to be retained
+   */
+  public void setCustomEvictionAttributes(EvictionCriteria<K, V> criteria,
+      long start, long interval) {
+    this.regionAttributes.customEvictionAttributes =
+        new CustomEvictionAttributesImpl(criteria, start, interval,
+            start == 0 && interval == 0);
+    this.regionAttributes.setHasCustomEviction(true);
+  }
+
+   /** Sets the mirror type for the next <code>RegionAttributes</code> created.
-   * @throws IllegalArgumentException if a directory does not exist
+   * @throws GemFireIOException if a directory does not exist
+      
+      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).setOffHeap(this.regionAttributes.offHeap);
+   * Sets the HDFSStore name attribute.
+   * This causes the region to use the {@link HDFSStore}.
+   * @param name the name of the HDFSstore
+   */
+  public void setHDFSStoreName(String name) {
+    //TODO:HDFS throw an exception if the region is already configured for a disk store and 
+    // vice versa
+    this.regionAttributes.hdfsStoreName = name;
+    this.regionAttributes.setHasHDFSStoreName(true);
+  }
+  
+  /**
+   * Sets the HDFS write only attribute. if the region
+   * is configured to be write only to HDFS, events that have 
+   * been evicted from memory cannot be read back from HDFS.
+   * Events are written to HDFS in the order in which they occurred.
+   */
+  public void setHDFSWriteOnly(boolean writeOnly) {
+    //TODO:HDFS throw an exception if the region is already configured for a disk store and 
+    // vice versa
+    this.regionAttributes.hdfsWriteOnly = writeOnly;
+    this.regionAttributes.setHasHDFSWriteOnly(true);
+  }
+  
+  /**
+  /**
+   * Enables this region's usage of off-heap memory if true.
+   * @since 9.0
+   * @param offHeap boolean flag to enable off-heap memory
+   */
+  public void setOffHeap(boolean offHeap) {
+    this.regionAttributes.offHeap = offHeap;
+    this.regionAttributes.setHasOffHeap(true);
+    
+    if (this.regionAttributes.partitionAttributes != null) {
+      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).setOffHeap(offHeap);
+    }
+  }
+  
+      // fix bug #52033 by invoking setOffHeap now (localMaxMemory may now be the temporary placeholder for off-heap until DistributedSystem is created
+      ((PartitionAttributesImpl)this.regionAttributes.partitionAttributes).setOffHeap(this.regionAttributes.getOffHeap());
+    
+    if (attrs.getHDFSStoreName() != null) {
+      if (!attrs.getDataPolicy().withHDFS() && (attrs.getPartitionAttributes() == null || attrs.getPartitionAttributes().getLocalMaxMemory() != 0)) {
+        throw new IllegalStateException(LocalizedStrings.HDFSSTORE_IS_USED_IN_NONHDFS_REGION.toLocalizedString());        
+      }
+    }
-      if (pa.getLocalMaxMemory() < 0) {
+      
+      // fix bug #52033 by invoking getLocalMaxMemoryForValidation here
+      if (((PartitionAttributesImpl)pa).getLocalMaxMemoryForValidation() < 0) {
+      
-      if (pa.getLocalMaxMemory() == 0 && attrs.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
+      
+      // fix bug #52033 by invoking getLocalMaxMemoryForValidation here
+      if (((PartitionAttributesImpl)pa).getLocalMaxMemoryForValidation() == 0 && attrs.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
+    transient CustomEvictionAttributes customEvictionAttributes;
+    String hdfsStoreName = null;
+    private boolean hdfsWriteOnly = false;
+    boolean offHeap = false;
+
+      buf.append("; hdfsStoreName=").append(hdfsStoreName);
+      buf.append("; hdfsWriteOnly=").append(hdfsWriteOnly);
+      buf.append("; offHeap=").append(offHeap);
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public CustomEvictionAttributes getCustomEvictionAttributes() {
+      return this.customEvictionAttributes;
+    }
+
+    @Override
+    public String getHDFSStoreName() {
+      return hdfsStoreName;
+    }
+    
+    @Override
+    public boolean getHDFSWriteOnly() {
+      return hdfsWriteOnly;
+    }
+
+    @Override
+    
+    @Override
+    public boolean getOffHeap() {
+      return this.offHeap;
+    }

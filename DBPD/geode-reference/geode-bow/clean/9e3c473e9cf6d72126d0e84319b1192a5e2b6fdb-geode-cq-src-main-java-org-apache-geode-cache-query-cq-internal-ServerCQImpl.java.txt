GEODE-7863: Reduce ServerCQImpl Contention (#4798)

We don't need to lock the entire internal cache for Partitioned
regions so the implementation is now split by region type, this will
us to improve/change them independently in the future.

- Removed redundant checks.
- Keep current behavior for Replicate Regions.
- Use ConcurrentMap instead of locking the entire internal cache on
every operation for Partition Regions.
- Keep the lock on ServerCQImpl instance only while executing the
query and leave stats operations outside of the synchronized block.
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
+import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.cache.query.QueryException;
-import org.apache.geode.internal.cache.Token;
+  private static final ServerCQResultsCache NO_OP_CACHE = new ServerCQResultsCacheNoOpImpl();
-   * This holds the keys that are part of the CQ query results. Using this CQ engine can determine
-   * whether to execute query on old value from EntryEvent, which is an expensive operation.
-   *
-   * NOTE: In case of RR this map is populated and used as intended. In case of PR this map will not
-   * be populated. If executeCQ happens after update operations this map will remain empty.
+   * NOTE: In case of Replicated Regions this cache is populated and used as intended. In case of
+   * Partition Regions this cache will not be populated. If executeCQ happens after update
+   * operations this cache will remain empty.
-  private volatile HashMap<Object, Object> cqResultKeys;
-
-  /**
-   * This maintains the keys that are destroyed while the Results Cache is getting constructed. This
-   * avoids any keys that are destroyed (after query execution) but is still part of the CQs result.
-   */
-  private HashSet<Object> destroysWhileCqResultsInProgress;
-
-  /**
-   * To indicate if the CQ results key cache is initialized.
-   */
-  public volatile boolean cqResultKeysInitialized = false;
+  private volatile ServerCQResultsCache serverCQResultsCache = NO_OP_CACHE;
+
-          String.format("Region : %s specified with cq not found. CqName: %s",
-              new Object[] {regionName, this.cqName}));
+          String.format("Region : %s specified with cq not found. CqName: %s", regionName,
+              this.cqName));
-      this.cqResultKeys = new HashMap<>();
-        this.setCqResultsCacheInitialized();
+        serverCQResultsCache = new ServerCQResultsCachePartitionRegionImpl();
+        setCqResultsCacheInitialized();
-        this.destroysWhileCqResultsInProgress = new HashSet<>();
+        serverCQResultsCache = new ServerCQResultsCacheReplicateRegionImpl();
-        throw new CqException(String.format("Unable to create cq %s Error : %s",
-            new Object[] {cqName, cqe.getMessage()}));
+        throw new CqException(
+            String.format("Unable to create cq %s Error : %s", cqName, cqe.getMessage()));
+
+  @VisibleForTesting
-    if (this.cqResultKeys != null) {
-      synchronized (this.cqResultKeys) {
-        return Collections.synchronizedSet(new HashSet<>(this.cqResultKeys.keySet()));
-      }
-    } else {
-      return null;
-    }
+    return serverCQResultsCache.getKeys();
-  Query constructServerSideQuery() throws QueryException {
+  Query constructServerSideQuery() {
+
-    // Handle events that may have been deleted,
-    // but added by result caching.
-    if (this.cqResultKeys == null) {
-      logger.warn(
-          "The CQ Result key cache is Null. This should not happen as the call to isPartOfCqResult() is based on the condition cqResultsCacheInitialized.");
-      return false;
-    }
-
-    synchronized (this.cqResultKeys) {
-      if (this.destroysWhileCqResultsInProgress != null) {
-        // this.logger.fine("Removing keys from Destroy Cache For CQ :" +
-        // this.cqName + " Keys :" + this.destroysWhileCqResultsInProgress);
-        for (Object k : this.destroysWhileCqResultsInProgress) {
-          this.cqResultKeys.remove(k);
-        }
-        this.destroysWhileCqResultsInProgress = null;
-      }
-      return this.cqResultKeys.containsKey(key);
-    }
+    return serverCQResultsCache.contains(key);
-    if (!CqServiceProvider.MAINTAIN_KEYS) {
-      return;
-    }
-
-    if (this.cqResultKeys != null) {
-      synchronized (this.cqResultKeys) {
-        this.cqResultKeys.put(key, TOKEN);
-        if (!this.cqResultKeysInitialized) {
-          // This key could be coming after add, destroy.
-          // Remove this from destroy queue.
-          if (this.destroysWhileCqResultsInProgress != null) {
-            this.destroysWhileCqResultsInProgress.remove(key);
-          }
-        }
-      }
-    }
+    serverCQResultsCache.add(key);
-    if (!CqServiceProvider.MAINTAIN_KEYS) {
-      return;
-    }
-    if (this.cqResultKeys != null) {
-      synchronized (this.cqResultKeys) {
-        if (isTokenMode && this.cqResultKeys.get(key) != Token.DESTROYED) {
-          return;
-        }
-        this.cqResultKeys.remove(key);
-        if (!this.cqResultKeysInitialized) {
-          if (this.destroysWhileCqResultsInProgress != null) {
-            this.destroysWhileCqResultsInProgress.add(key);
-          }
-        }
-      }
-    }
+    serverCQResultsCache.remove(key, isTokenMode);
-    if (!CqServiceProvider.MAINTAIN_KEYS) {
-      return;
-    }
-
-    if (this.cqResultKeys != null) {
-      synchronized (this.cqResultKeys) {
-        this.cqResultKeys.clear();
-        this.cqResultKeysInitialized = false;
-      }
-    }
+    serverCQResultsCache.invalidate();
-    if (!CqServiceProvider.MAINTAIN_KEYS) {
-      return;
-    }
-
-    if (this.cqResultKeys != null) {
-      synchronized (this.cqResultKeys) {
-        this.cqResultKeys.put(key, Token.DESTROYED);
-        if (!this.cqResultKeysInitialized) {
-          // this.logger.fine("Adding key to Destroy Cache For CQ :" +
-          // this.cqName + " key :" + key);
-          if (this.destroysWhileCqResultsInProgress != null) {
-            this.destroysWhileCqResultsInProgress.add(key);
-          }
-        }
-      }
-    }
+    serverCQResultsCache.markAsDestroyed(key);
-    if (CqServiceProvider.MAINTAIN_KEYS) {
-      this.cqResultKeysInitialized = true;
-    }
+    serverCQResultsCache.setInitialized();
+  }
+
+  @Override
+  public boolean isCqResultsCacheInitialized() {
+    return serverCQResultsCache.isInitialized();
-    if (this.cqResultKeys == null) {
-      return 0;
-    }
-    synchronized (this.cqResultKeys) {
-      return this.cqResultKeys.size();
-    }
+    return serverCQResultsCache.size();
-    return !this.cqResultKeysInitialized || !this.isPartOfCqResult(key);
+    return serverCQResultsCache.isOldValueRequiredForQueryProcessing(key);
-      boolean isClosed = false;
-      if (this.cqResultKeys != null) {
-        synchronized (this.cqResultKeys) {
-          this.cqResultKeys.clear();
-        }
-      }
+      serverCQResultsCache.clear();
-  protected void cleanup() throws CqException {
+  protected void cleanup() {
-  public void stop() throws CqClosedException, CqException {
-    boolean isStopped = false;
+  public void stop() throws CqClosedException {
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+  public void fromData(DataInput in) throws IOException {
-  public <E> CqResults<E> executeWithInitialResults()
-      throws CqClosedException, RegionNotFoundException, CqException {
+  public <E> CqResults<E> executeWithInitialResults() throws CqClosedException {
-  public void execute() throws CqClosedException, RegionNotFoundException, CqException {
+  public void execute() throws CqClosedException {
-

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * @version     $Revision: 1.1 $
+ * @version $Revision: 1.1 $
-  private CompiledValue _receiver;  // the value represented by the expression before the dot
-  private String _tailID;           // the identifier after the dot.
-  
+  private CompiledValue _receiver; // the value represented by the expression before the dot
+  private String _tailID; // the identifier after the dot.
+
-  
+
-  
+
-  
+
-  throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-  
-  
-  
+
+
+
-  throws TypeMismatchException, AmbiguousNameException {
+      throws TypeMismatchException, AmbiguousNameException {
-    
+
-      CompiledPath p = (CompiledPath)v;
+      CompiledPath p = (CompiledPath) v;
-    };
-    
+    } ;
+
-    
+
-  
-  
-  public Object evaluate(ExecutionContext context)
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-          QueryInvocationTargetException {
+
+
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      } catch (EntryDestroyedException ede){
-        // Even though isDestory() check is made, the entry could 
+      } catch (EntryDestroyedException ede) {
+        // Even though isDestory() check is made, the entry could
-    
-    //         RuntimeIterator cmpItr = null;
-    
-    //         if (rcvr.getType() == ID)
-    //         {
-    //             CompiledValue resolvedRcvr = context.resolve(((CompiledID)rcvr).getId());
-    
-    //             if (resolvedRcvr != null && resolvedRcvr.getType() == ITERATOR)
-    //                 cmpItr = ((RuntimeIterator)resolvedRcvr);
-    //         }
-    
-    //         if (rcvr.getType() == ITERATOR)
-    //             cmpItr = (RuntimeIterator)rcvr;
-    
-    //         if (cmpItr != null)
-    //         {
-    //             Class constraint = cmpItr.getBaseCollection().getConstraint();
-    //             return PathUtils.evaluateAttribute(evalRcvr,
-    //                                                constraint,
-    //                                                getTailID());
-    //         }
-    
-    Object obj =  PathUtils.evaluateAttribute(evalRcvr, getTailID());
+
+    // RuntimeIterator cmpItr = null;
+
+    // if (rcvr.getType() == ID)
+    // {
+    // CompiledValue resolvedRcvr = context.resolve(((CompiledID)rcvr).getId());
+
+    // if (resolvedRcvr != null && resolvedRcvr.getType() == ITERATOR)
+    // cmpItr = ((RuntimeIterator)resolvedRcvr);
+    // }
+
+    // if (rcvr.getType() == ITERATOR)
+    // cmpItr = (RuntimeIterator)rcvr;
+
+    // if (cmpItr != null)
+    // {
+    // Class constraint = cmpItr.getBaseCollection().getConstraint();
+    // return PathUtils.evaluateAttribute(evalRcvr,
+    // constraint,
+    // getTailID());
+    // }
+
+    Object obj = PathUtils.evaluateAttribute(evalRcvr, getTailID());
-      if (pr.getFullPath().equals(((Region)obj).getFullPath())) {
+      if (pr.getFullPath().equals(((Region) obj).getFullPath())) {
-  
+
-  
+
-  
+
-  throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    //Asif: Canonicalize the tail ID. If the tail ID contains
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    // Asif: Canonicalize the tail ID. If the tail ID contains
-    if (_tailID.startsWith("get") && (len =_tailID.length()) > 3) {
-      clauseBuffer.insert(0, len > 4 ? _tailID.substring(4) : "" );
+    if (_tailID.startsWith("get") && (len = _tailID.length()) > 3) {
+      clauseBuffer.insert(0, len > 4 ? _tailID.substring(4) : "");
-    _receiver. generateCanonicalizedExpression(clauseBuffer, context);
+    _receiver.generateCanonicalizedExpression(clauseBuffer, context);

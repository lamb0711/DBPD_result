GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-/*
- * Utils.java
- *
- * Created on March 8, 2005, 4:16 PM
- */
-import org.apache.geode.LogWriter;
-import org.apache.geode.cache.*;
-import org.apache.geode.cache.query.types.CollectionType;
-import org.apache.geode.cache.query.types.ObjectType;
-import org.apache.geode.distributed.DistributedSystem;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import static org.apache.geode.distributed.ConfigurationProperties.*;
+import static org.junit.Assert.*;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+import org.apache.logging.log4j.Logger;
-/**
- * 
- */
+import org.apache.geode.LogWriter;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.CacheTransactionManager;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.cache.query.types.CollectionType;
+import org.apache.geode.cache.query.types.ObjectType;
+import org.apache.geode.distributed.DistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.logging.LogService;
+
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.GatewayException;
+import org.apache.geode.cache.RegionExistsException;
+
+  private static final Logger logger = LogService.getLogger();
-  static Properties props = new Properties();
-  static DistributedSystem ds;
-  static volatile Cache cache;
+  private static Properties props = new Properties();
+  private static DistributedSystem ds;
+  static volatile InternalCache cache;
-    try {
-      init();
-    } catch (Exception e) {
-      e.printStackTrace();
-    }
+    init();
-  static void init() throws Exception {
+  private static void init()
+      throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
-      cache = new CacheFactory(props).create();
+      cache = (InternalCache) new CacheFactory(props).create();
-  public static Cache getCache() {
+  public static InternalCache getCache() {
-        cache = new CacheFactory(props).create();
+        cache = (InternalCache) new CacheFactory(props).create();
-      e.printStackTrace();
+      throw new AssertionError(e);
-      e.printStackTrace();
+      throw new AssertionError(e);
-      cache = new CacheFactory(props).create();
+      cache = (InternalCache) new CacheFactory(props).create();
-      e.printStackTrace();
+      throw new AssertionError(e);
-      Region region = cache.createRegion(regionName, regionAttributes);
-      return region;
+      return cache.createRegion(regionName, regionAttributes);
-      e.printStackTrace();
+      throw new AssertionError(e);
-    return null;
+  // TODO: paramter flag is unused
-      Region region = cache.createRegion(regionName, regionAttributes);
-      return region;
+      return cache.createRegion(regionName, regionAttributes);
-      e.printStackTrace();
+      throw new AssertionError(e);
-    return null;
-      Region region = cache.createRegion(regionName, regionAttributes);
-      return region;
+      return cache.createRegion(regionName, regionAttributes);
-      e.printStackTrace();
+      throw new AssertionError(e);
-    return null;
-      Region region = parentRegion.createSubregion(regionName, regionAttributes);
-      return region;
+      return parentRegion.createSubregion(regionName, regionAttributes);
-      e.printStackTrace();
+      throw new AssertionError(e);
-    return null;
-    Cache cache = GemFireCacheImpl.getInstance();
-    if (cache != null) {
-      cache.getLogger().fine(message.toString());
-    }
+    logger.debug(message);
-    Set set1 = null;
-    Set set2 = null;
-    Iterator itert1 = null;
-    Iterator itert2 = null;
-    ObjectType type1, type2;
-    for (int j = 0; j < r.length; j++) {
-      CollectionType collType1 = r[j][0].getCollectionType();
-      CollectionType collType2 = r[j][1].getCollectionType();
+    Set set1;
+    Set set2;
+    Iterator itert1;
+    Iterator itert2;
+    ObjectType type1;
+    ObjectType type2;
+
+    for (final SelectResults[] selectResults : r) {
+      CollectionType collType1 = selectResults[0].getCollectionType();
+      CollectionType collType2 = selectResults[1].getCollectionType();
+
+
-      if (r[j][0].size() == r[j][1].size()) {
-        log("Both SelectResults are of Same Size i.e.  Size= " + r[j][1].size());
+
+      if (selectResults[0].size() == selectResults[1].size()) {
+        log("Both SelectResults are of Same Size i.e.  Size= " + selectResults[1].size());
-        fail("FAILED:SelectResults size is different in both the cases. Size1=" + r[j][0].size()
-            + " Size2 = " + r[j][1].size());
+        fail("FAILED:SelectResults size is different in both the cases. Size1="
+            + selectResults[0].size() + " Size2 = " + selectResults[1].size());
-      set2 = ((r[j][1]).asSet());
-      set1 = ((r[j][0]).asSet());
-      // boolean pass = true;
+
+      set2 = selectResults[1].asSet();
+      set1 = selectResults[0].asSet();
+
+
-                  elementEqual && ((values1[i] == values2[i]) || values1[i].equals(values2[i]));
+                  elementEqual && (values1[i] == values2[i] || values1[i].equals(values2[i]));
-            exactMatch = (p2 == p1) || p2.equals(p1);
+            exactMatch = p2 == p1 || p2.equals(p1);
-              "Atleast one element in the pair of SelectResults supposedly identical, is not equal ");
+              "At least one element in the pair of SelectResults supposedly identical, is not equal");
-    Set set1 = null;
-    Set set2 = null;
-    Iterator itert1 = null;
-    Iterator itert2 = null;
-    ObjectType type1, type2;
-    outer: for (int j = 0; j < r.length; j++) {
-      CollectionType collType1 = r[j][0].getCollectionType();
-      CollectionType collType2 = r[j][1].getCollectionType();
+    Set set1;
+    Set set2;
+    Iterator itert1;
+    Iterator itert2;
+    ObjectType type1;
+    ObjectType type2;
+
+    // TODO: eliminate loop labels
+    outer: for (final SelectResults[] aR : r) {
+      CollectionType collType1 = aR[0].getCollectionType();
+      CollectionType collType2 = aR[1].getCollectionType();
+
-      if (r[j][0].size() == r[j][1].size()) {
-        log("Both SelectResults are of Same Size i.e.  Size= " + r[j][1].size());
+
+      if (aR[0].size() == aR[1].size()) {
+        log("Both SelectResults are of Same Size i.e.  Size= " + aR[1].size());
-      set2 = (((SelectResults) r[j][1]).asSet());
-      set1 = (((SelectResults) r[j][0]).asSet());
-      boolean pass = true;
+
+      set2 = aR[1].asSet();
+      set1 = aR[0].asSet();
+
-            // test.assertIndexDetailsEquals(values1.length, values2.length);
-                    elementEqual && ((values1[i] == values2[i]) || values1[i].equals(values2[i]));
+                    elementEqual && (values1[i] == values2[i] || values1[i].equals(values2[i]));
-                elementEqual = elementEqual && ((values1[i] == values2[i]));
+                elementEqual = elementEqual && values1[i] == values2[i];
-            exactMatch = (p2 == p1) || p2.equals(p1);
+            exactMatch = p2 == p1 || p2.equals(p1);
-          // test.fail("Atleast one element in the pair of SelectResults supposedly identical, is
-          // not equal ");

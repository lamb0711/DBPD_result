Merge branch 'develop' into feature/GEODE-3109

+  private static final boolean ALLOW_OLD_VERSION_FOR_TESTING = Boolean
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "allow_old_members_to_join_for_testing");
-  private boolean isCoordinator;
+  private volatile boolean isCoordinator;
-  private List<InetSocketAddress> locators;
+  private List<HostAddress> locators;
-    int viewId = -1;
+    int viewId = -100;
+
+    public String toString() {
+      StringBuffer sb = new StringBuffer(200);
+      sb.append("SearchState(locatorsContacted=").append(locatorsContacted)
+          .append("; alreadyTried=").append(alreadyTried).append("; registrants=")
+          .append(registrants).append("; possibleCoordinator=").append(possibleCoordinator)
+          .append("; viewId=").append(viewId).append("; hasContactedAJoinedLocator=")
+          .append(hasContactedAJoinedLocator).append("; view=").append(view).append("; responses=")
+          .append(responses).append(")");
+      return sb.toString();
+    }
+        logger.debug("state after looking for membership coordinator is {}", state);
-            // reset the tries count and timer since we haven't actually tried to join yet
-          logger.debug("sleeping for {} before making another attempt to find the coordinator",
-              retrySleep);
-          Thread.sleep(retrySleep);
+          if (found && !state.hasContactedAJoinedLocator) {
+            // if locators are restarting they may be handing out IDs from a stale view that
+            // we should go through quickly. Otherwise we should sleep a bit to let failure
+            // detection select a new coordinator
+            if (state.possibleCoordinator.getVmViewId() < 0) {
+              logger.debug("sleeping for {} before making another attempt to find the coordinator",
+                  retrySleep);
+              Thread.sleep(retrySleep);
+            }
+            // since we were given a coordinator that couldn't be used we should keep trying
+            tries = 0;
+            giveupTime = System.currentTimeMillis() + timeout;
+          }
-    if (incomingRequest.getMemberID().getVersionObject().compareTo(Version.CURRENT) < 0) {
+    if (!ALLOW_OLD_VERSION_FOR_TESTING
+        && incomingRequest.getMemberID().getVersionObject().compareTo(Version.CURRENT) < 0) {
+
-    logger.debug("Recording the request to be processed in the next membership view");
-    synchronized (viewRequests) {
-      viewRequests.add(request);
-      if (viewCreator != null && services.getMessenger().getClusterSecretKey() != null) {
+    try {
+      synchronized (viewRequests) {
-          JoinRequestMessage jreq = (JoinRequestMessage) request;
-          // this will inform about cluster-secret key, as we have authenticated at this point
-          JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(),
-              services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
-          services.getMessenger().send(response);
+          if (isCoordinator
+              && !services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo().isEmpty()) {
+            services.getMessenger().initClusterKey();
+            JoinRequestMessage jreq = (JoinRequestMessage) request;
+            // this will inform about cluster-secret key, as we have authenticated at this point
+            JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(),
+                services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
+            services.getMessenger().send(response);
+          }
+        logger.debug("Recording the request to be processed in the next membership view");
+        viewRequests.add(request);
+        viewRequests.notifyAll();
-      viewRequests.notifyAll();
+    } catch (RuntimeException | Error t) {
+      logger.warn("unable to record a membership view request due to this exception", t);
+      throw t;
+    org.apache.geode.distributed.internal.membership.gms.interfaces.Locator locator =
+        services.getLocator();
+    if (locator != null) {
+      locator.setIsCoordinator(true);
+    }
+      services.getMessenger().initClusterKey();
-      services.getMessenger().initClusterKey();
-    if (!state.hasContactedAJoinedLocator && state.view != null) {
+    if (!state.hasContactedAJoinedLocator && state.registrants.size() >= locators.size()
+        && state.view != null) {
-      for (InetSocketAddress addr : locators) {
+      for (HostAddress laddr : locators) {
+          InetSocketAddress addr = laddr.getSocketInetAddress();
+            if (response.getRegistrants() != null) {
+              state.registrants.addAll(response.getRegistrants());
+            }
-                if (response.getRegistrants() != null) {
-                  state.registrants.addAll(response.getRegistrants());
-                }
+          logger.debug("EOFException IOException ", problem);
-      return client.requestToServer(addr.getAddress(), addr.getPort(), request, connectTimeout,
-          true);
+      return client.requestToServer(addr, request, connectTimeout, true);
+    logger.debug("searching for coordinator in findCoordinatorFromView");
+
-    // FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried,
-    // state.viewId, services.getMessenger().getPublickey(
-    // localAddress), services.getMessenger().getRequestId());
-    // req.setRecipients(v.getMembers());
-
-        for (InternalDistributedMember mbr : v.getMembers()) {
+        for (InternalDistributedMember mbr : recipients) {
-        req.setRecipients(v.getMembers());
+        req.setRecipients(recipients);
+      org.apache.geode.distributed.internal.membership.gms.interfaces.Locator locator =
+          services.getLocator();
+      if (locator != null) {
+        locator.setIsCoordinator(false);
+      }

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  //   Constructor and instance variables
+  // Constructor and instance variables
-  
+
-  /** List of active txLockIds */  
+  /** List of active txLockIds */
-  
-  /** 
-   * True if grantor recovery is in progress; used to keep <code>release</code> 
-   * from waiting for grantor.
-   * TODO: this boolean can probably be removed... it was insufficient and 
-   * new fixes for bug 38763 have the side effect of making this boolean 
-   * obsolete (verify before removal!)
-   */  
+
+  /**
+   * True if grantor recovery is in progress; used to keep <code>release</code> from waiting for
+   * grantor. TODO: this boolean can probably be removed... it was insufficient and new fixes for
+   * bug 38763 have the side effect of making this boolean obsolete (verify before removal!)
+   */
-  
-  /** 
-   * Read locks are held while any <code>txLock</code> is held; write lock is
-   * held during grantor recovery.
+
+  /**
+   * Read locks are held while any <code>txLock</code> is held; write lock is held during grantor
+   * recovery.
-  
+
-    InternalDistributedSystem sys = 
-        InternalDistributedSystem.getAnyInstance();
+    InternalDistributedSystem sys = InternalDistributedSystem.getAnyInstance();
-      throw new IllegalStateException(LocalizedStrings.TXLockServiceImpl_TXLOCKSERVICE_CANNOT_BE_CREATED_UNTIL_CONNECTED_TO_DISTRIBUTED_SYSTEM.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.TXLockServiceImpl_TXLOCKSERVICE_CANNOT_BE_CREATED_UNTIL_CONNECTED_TO_DISTRIBUTED_SYSTEM
+              .toLocalizedString());
-    
-    this.recoveryLock = 
-        new StoppableReentrantReadWriteLock(sys.getCancelCriterion());
-    
-    this.dlock = (DLockService) DLockService.create(
-        name, 
-        sys, 
-        true /*distributed*/, 
-        true /*destroyOnDisconnect*/,
-        true /*automateFreeResources*/);
-        
-    this.dlock.setDLockRecoverGrantorMessageProcessor(
-        new TXRecoverGrantorMessageProcessor());
-    
-    this.dlock.setDLockLessorDepartureHandler(
-        new TXLessorDepartureHandler());
+
+    this.recoveryLock = new StoppableReentrantReadWriteLock(sys.getCancelCriterion());
+
+    this.dlock = (DLockService) DLockService.create(name, sys, true /* distributed */,
+        true /* destroyOnDisconnect */, true /* automateFreeResources */);
+
+    this.dlock.setDLockRecoverGrantorMessageProcessor(new TXRecoverGrantorMessageProcessor());
+
+    this.dlock.setDLockLessorDepartureHandler(new TXLessorDepartureHandler());
-  
+
-  //   Instance methods
+  // Instance methods
-  
+
-  
+
-  
+
-  public TXLockId txLock(List regionLockReqs, Set txParticipants)
-  throws CommitConflictException {
+  public TXLockId txLock(List regionLockReqs, Set txParticipants) throws CommitConflictException {
-      throw new IllegalArgumentException(LocalizedStrings.TXLockServiceImpl_REGIONLOCKREQS_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.TXLockServiceImpl_REGIONLOCKREQS_MUST_NOT_BE_NULL.toLocalizedString());
-    
+
-      
+
-      
+
-      }
-      else if (keyIfFail[0] != null) {
+      } else if (keyIfFail[0] != null) {
-          LocalizedStrings.TXLockServiceImpl_CONCURRENT_TRANSACTION_COMMIT_DETECTED_0.toLocalizedString(keyIfFail[0]));
-      }
-      else {
-        throw new CommitConflictException(LocalizedStrings.TXLockServiceImpl_FAILED_TO_REQUEST_TRY_LOCKS_FROM_GRANTOR_0.toLocalizedString(this.dlock.getLockGrantorId()));
+            LocalizedStrings.TXLockServiceImpl_CONCURRENT_TRANSACTION_COMMIT_DETECTED_0
+                .toLocalizedString(keyIfFail[0]));
+      } else {
+        throw new CommitConflictException(
+            LocalizedStrings.TXLockServiceImpl_FAILED_TO_REQUEST_TRY_LOCKS_FROM_GRANTOR_0
+                .toLocalizedString(this.dlock.getLockGrantorId()));
-      logger.debug("[TXLockServiceImpl.txLock] gotLocks is {}, returning txLockId:{}", gotLocks, txLockId);
+      logger.debug("[TXLockServiceImpl.txLock] gotLocks is {}, returning txLockId:{}", gotLocks,
+          txLockId);
-    }
-    catch (InterruptedException e) {
+    } catch (InterruptedException e) {
-      throw new CommitConflictException(LocalizedStrings.TXLockServiceImpl_CONCURRENT_TRANSACTION_COMMIT_DETECTED_BECAUSE_REQUEST_WAS_INTERRUPTED.toLocalizedString(), e);
+      throw new CommitConflictException(
+          LocalizedStrings.TXLockServiceImpl_CONCURRENT_TRANSACTION_COMMIT_DETECTED_BECAUSE_REQUEST_WAS_INTERRUPTED
+              .toLocalizedString(),
+          e);
-        throw new IllegalArgumentException(LocalizedStrings.TXLockServiceImpl_INVALID_TXLOCKID_NOT_FOUND_0.toLocalizedString(txLockId));
+        throw new IllegalArgumentException(
+            LocalizedStrings.TXLockServiceImpl_INVALID_TXLOCKID_NOT_FOUND_0
+                .toLocalizedString(txLockId));
-      throw new IllegalArgumentException(LocalizedStrings.TXLockServiceImpl_INVALID_UPDATEDPARTICIPANTS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.TXLockServiceImpl_INVALID_UPDATEDPARTICIPANTS_NULL.toLocalizedString());
-        TXLockUpdateParticipantsMessage.updateParticipants(this.dlock,
-                                                           txLockId, 
-                                                           updatedParticipants);
-      } 
-      else { // not lock grantor
+        TXLockUpdateParticipantsMessage.updateParticipants(this.dlock, txLockId,
+            updatedParticipants);
+      } else { // not lock grantor
-        if (lockGrantorId == null ||
-            !this.dlock.isLockGrantorId(lockGrantorId)) {
+        if (lockGrantorId == null || !this.dlock.isLockGrantorId(lockGrantorId)) {
-        InternalDistributedMember grantorId = 
-            lockGrantorId.getLockGrantorMember();
-          
-        // logger.info("DEBUG: [TXLockServiceImpl.updateParticipants] sending update message to Grantor " + grantorId);
-        ReplyProcessor21 processor = 
-          new ReplyProcessor21(this.dlock.getDistributionManager(), grantorId);
-        TXLockUpdateParticipantsMessage dlup = 
-          new TXLockUpdateParticipantsMessage(txLockId, this.dlock.getName(), 
-                                              updatedParticipants, processor.getProcessorId());
+        InternalDistributedMember grantorId = lockGrantorId.getLockGrantorMember();
+
+        // logger.info("DEBUG: [TXLockServiceImpl.updateParticipants] sending update message to
+        // Grantor " + grantorId);
+        ReplyProcessor21 processor =
+            new ReplyProcessor21(this.dlock.getDistributionManager(), grantorId);
+        TXLockUpdateParticipantsMessage dlup = new TXLockUpdateParticipantsMessage(txLockId,
+            this.dlock.getName(), updatedParticipants, processor.getProcessorId());
-          this.dlock.getDistributionManager().getCancelCriterion().checkCancelInProgress(null);
-          try {
-            processor.waitForRepliesUninterruptibly();
-          }
-          catch (ReplyException e) {
-            e.handleAsUnexpected();
-          }
+        this.dlock.getDistributionManager().getCancelCriterion().checkCancelInProgress(null);
+        try {
+          processor.waitForRepliesUninterruptibly();
+        } catch (ReplyException e) {
+          e.handleAsUnexpected();
+        }
-  
+
-        //TXLockService.destroyServices can be invoked in cache.close().
-        //Other P2P threads could process message such as TXCommitMessage afterwards,
-        //and invoke TXLockService.createDTLS(). It could create a new TXLockService
-        //which will have a new empty list (txLockIdList) and it will not
-        //contain the originally added txLockId
-        throw new IllegalArgumentException(LocalizedStrings.TXLockServiceImpl_INVALID_TXLOCKID_NOT_FOUND_0.toLocalizedString(txLockId));
+        // TXLockService.destroyServices can be invoked in cache.close().
+        // Other P2P threads could process message such as TXCommitMessage afterwards,
+        // and invoke TXLockService.createDTLS(). It could create a new TXLockService
+        // which will have a new empty list (txLockIdList) and it will not
+        // contain the originally added txLockId
+        throw new IllegalArgumentException(
+            LocalizedStrings.TXLockServiceImpl_INVALID_TXLOCKID_NOT_FOUND_0
+                .toLocalizedString(txLockId));
-  
+
-  //   Internal implementation methods
+  // Internal implementation methods
-  
+
-  
+
-  
+
-  
+
-  
+
- 
+

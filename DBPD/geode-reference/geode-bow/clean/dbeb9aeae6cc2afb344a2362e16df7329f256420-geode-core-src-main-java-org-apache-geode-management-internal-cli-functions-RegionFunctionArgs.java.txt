Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Used to carry arguments between gfsh region command implementations and the functions
- * that do the work for those commands.
+ * Used to carry arguments between gfsh region command implementations and the functions that do the
+ * work for those commands.
-  
+
-  private final RegionShortcut regionShortcut; 
+  private final RegionShortcut regionShortcut;
-  private final Boolean skipIfExists; 
+  private final Boolean skipIfExists;
-  private final RegionFunctionArgs.ExpirationAttrs regionExpirationTTL;      
+  private final RegionFunctionArgs.ExpirationAttrs regionExpirationTTL;
+  private final boolean isPartitionResolver;
+  private String partitionResolver;
-  public RegionFunctionArgs(String regionPath,
-      RegionShortcut regionShortcut, String useAttributesFrom,
-      boolean skipIfExists, String keyConstraint, String valueConstraint,
-      Boolean statisticsEnabled, 
-      RegionFunctionArgs.ExpirationAttrs entryExpirationIdleTime, 
-      RegionFunctionArgs.ExpirationAttrs entryExpirationTTL, 
-      RegionFunctionArgs.ExpirationAttrs regionExpirationIdleTime, 
+  public RegionFunctionArgs(String regionPath, RegionShortcut regionShortcut,
+      String useAttributesFrom, boolean skipIfExists, String keyConstraint, String valueConstraint,
+      Boolean statisticsEnabled, RegionFunctionArgs.ExpirationAttrs entryExpirationIdleTime,
+      RegionFunctionArgs.ExpirationAttrs entryExpirationTTL,
+      RegionFunctionArgs.ExpirationAttrs regionExpirationIdleTime,
-      Boolean diskSynchronous, Boolean enableAsyncConflation,
-      Boolean enableSubscriptionConflation, String[] cacheListeners,
-      String cacheLoader, String cacheWriter, String[] asyncEventQueueIds,
-      String[] gatewaySenderIds, Boolean concurrencyChecksEnabled,
-      Boolean cloningEnabled, Integer concurrencyLevel, String prColocatedWith,
-      Integer prLocalMaxMemory, Long prRecoveryDelay,
-      Integer prRedundantCopies, Long prStartupRecoveryDelay,
-      Long prTotalMaxMemory, Integer prTotalNumBuckets, Integer evictionMax,
-      String compressor, Boolean offHeap, Boolean mcastEnabled) {
+      Boolean diskSynchronous, Boolean enableAsyncConflation, Boolean enableSubscriptionConflation,
+      String[] cacheListeners, String cacheLoader, String cacheWriter, String[] asyncEventQueueIds,
+      String[] gatewaySenderIds, Boolean concurrencyChecksEnabled, Boolean cloningEnabled,
+      Integer concurrencyLevel, String prColocatedWith, Integer prLocalMaxMemory,
+      Long prRecoveryDelay, Integer prRedundantCopies, Long prStartupRecoveryDelay,
+      Long prTotalMaxMemory, Integer prTotalNumBuckets, Integer evictionMax, String compressor,
+      Boolean offHeap, Boolean mcastEnabled, final String partitionResolver) {
-    this.partitionArgs = new PartitionArgs(prColocatedWith,
-        prLocalMaxMemory, prRecoveryDelay, prRedundantCopies,
-        prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets);
-    
+    this.partitionArgs =
+        new PartitionArgs(prColocatedWith, prLocalMaxMemory, prRecoveryDelay, prRedundantCopies,
+            prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets, partitionResolver);
+
-    if(this.isSetCompressor) {
+    if (this.isSetCompressor) {
+    this.isPartitionResolver = (partitionResolver != null);
+    if (this.isPartitionResolver) {
+      this.partitionResolver = partitionResolver;
+    }
-  public RegionFunctionArgs(String regionPath,
-      String useAttributesFrom,
-      boolean skipIfExists, String keyConstraint, String valueConstraint,
-      Boolean statisticsEnabled, 
-      RegionFunctionArgs.ExpirationAttrs entryExpirationIdleTime, 
-      RegionFunctionArgs.ExpirationAttrs entryExpirationTTL, 
-      RegionFunctionArgs.ExpirationAttrs regionExpirationIdleTime, 
+  public RegionFunctionArgs(String regionPath, String useAttributesFrom, boolean skipIfExists,
+      String keyConstraint, String valueConstraint, Boolean statisticsEnabled,
+      RegionFunctionArgs.ExpirationAttrs entryExpirationIdleTime,
+      RegionFunctionArgs.ExpirationAttrs entryExpirationTTL,
+      RegionFunctionArgs.ExpirationAttrs regionExpirationIdleTime,
-      Boolean diskSynchronous, Boolean enableAsyncConflation,
-      Boolean enableSubscriptionConflation, String[] cacheListeners,
-      String cacheLoader, String cacheWriter, String[] asyncEventQueueIds,
-      String[] gatewaySenderIds, Boolean concurrencyChecksEnabled,
-      Boolean cloningEnabled, Integer concurrencyLevel, String prColocatedWith,
-      Integer prLocalMaxMemory, Long prRecoveryDelay,
-      Integer prRedundantCopies, Long prStartupRecoveryDelay,
-      Long prTotalMaxMemory, Integer prTotalNumBuckets, 
-      Boolean offHeap,
-      Boolean mcastEnabled, RegionAttributes<?, ?> regionAttributes) {   
-    this(regionPath, null, useAttributesFrom, skipIfExists, keyConstraint,
-        valueConstraint, statisticsEnabled, entryExpirationIdleTime,
-        entryExpirationTTL, regionExpirationIdleTime, regionExpirationTTL,
-        diskStore, diskSynchronous, enableAsyncConflation,
-        enableSubscriptionConflation, cacheListeners, cacheLoader,
-        cacheWriter, asyncEventQueueIds, gatewaySenderIds,
-        concurrencyChecksEnabled, cloningEnabled, concurrencyLevel, 
-        prColocatedWith, prLocalMaxMemory, prRecoveryDelay,
-        prRedundantCopies, prStartupRecoveryDelay,
-        prTotalMaxMemory, prTotalNumBuckets, null, null, offHeap , mcastEnabled);
+      Boolean diskSynchronous, Boolean enableAsyncConflation, Boolean enableSubscriptionConflation,
+      String[] cacheListeners, String cacheLoader, String cacheWriter, String[] asyncEventQueueIds,
+      String[] gatewaySenderIds, Boolean concurrencyChecksEnabled, Boolean cloningEnabled,
+      Integer concurrencyLevel, String prColocatedWith, Integer prLocalMaxMemory,
+      Long prRecoveryDelay, Integer prRedundantCopies, Long prStartupRecoveryDelay,
+      Long prTotalMaxMemory, Integer prTotalNumBuckets, Boolean offHeap, Boolean mcastEnabled,
+      RegionAttributes<?, ?> regionAttributes, final String partitionResolver) {
+    this(regionPath, null, useAttributesFrom, skipIfExists, keyConstraint, valueConstraint,
+        statisticsEnabled, entryExpirationIdleTime, entryExpirationTTL, regionExpirationIdleTime,
+        regionExpirationTTL, diskStore, diskSynchronous, enableAsyncConflation,
+        enableSubscriptionConflation, cacheListeners, cacheLoader, cacheWriter, asyncEventQueueIds,
+        gatewaySenderIds, concurrencyChecksEnabled, cloningEnabled, concurrencyLevel,
+        prColocatedWith, prLocalMaxMemory, prRecoveryDelay, prRedundantCopies,
+        prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets, null, null, offHeap,
+        mcastEnabled, partitionResolver);
-    return this.regionShortcut == null && this.useAttributesFrom != null && this.regionAttributes != null;
+    return this.regionShortcut == null && this.useAttributesFrom != null
+        && this.regionAttributes != null;
-  }  
+  }
-  
+
+   * @return the PartitionResolver
+   */
+  public String getPartitionResolver() {
+    return this.partitionResolver;
+  }
+
+  /**
+   * @return True if Partition Resolver is set otherwise False
+   */
+  public Boolean isPartitionResolverSet() {
+    return this.isPartitionResolver;
+  }
+
+  /**
-    return hasPartitionAttributes() || (this.regionShortcut != null && this.regionShortcut.name().startsWith("PARTITION"));
+    return hasPartitionAttributes()
+        || (this.regionShortcut != null && this.regionShortcut.name().startsWith("PARTITION"));
-  
+
-  
+
-  
+
-  
+
-    private Integer   time;
+    private Integer time;
-  
+
-      this.type   = type;
-      this.time   = time;
+      this.type = type;
+      this.time = time;
-  
+
-  
+
-  
+
-  
+
-  
+
-    
+
-      } else if (action.equalsIgnoreCase(ExpirationAction.INVALIDATE
-          .toString())) {
+      } else if (action.equalsIgnoreCase(ExpirationAction.INVALIDATE.toString())) {
-      } else if (action.equalsIgnoreCase(ExpirationAction.LOCAL_DESTROY
-          .toString())) {
+      } else if (action.equalsIgnoreCase(ExpirationAction.LOCAL_DESTROY.toString())) {
-      } else if (action.equalsIgnoreCase(ExpirationAction.LOCAL_INVALIDATE
-          .toString())) {
+      } else if (action.equalsIgnoreCase(ExpirationAction.LOCAL_INVALIDATE.toString())) {
-        throw new IllegalArgumentException(CliStrings.format(CliStrings.CREATE_REGION__MSG__EXPIRATION_ACTION_0_IS_NOT_VALID, new Object[] {action}));
+        throw new IllegalArgumentException(
+            CliStrings.format(CliStrings.CREATE_REGION__MSG__EXPIRATION_ACTION_0_IS_NOT_VALID,
+                new Object[] {action}));
-  
+
-  
+
+    private final boolean isPartitionResolver;
+    private String partitionResolver;
-    public PartitionArgs(String prColocatedWith,
-        Integer prLocalMaxMemory, Long prRecoveryDelay,
-        Integer prRedundantCopies, Long prStartupRecoveryDelay,
-        Long prTotalMaxMemory, Integer prTotalNumBuckets) {
+    public PartitionArgs(String prColocatedWith, Integer prLocalMaxMemory, Long prRecoveryDelay,
+        Integer prRedundantCopies, Long prStartupRecoveryDelay, Long prTotalMaxMemory,
+        Integer prTotalNumBuckets, String partitionResolver) {
+      this.isPartitionResolver = partitionResolver != null;
+      if (this.isPartitionResolver) {
+        this.partitionResolver = partitionResolver;
+        this.hasPartitionAttributes = true;
+        userSpecifiedPartitionAttributes.add(CliStrings.CREATE_REGION__PARTITION_RESOLVER);
+      }
+

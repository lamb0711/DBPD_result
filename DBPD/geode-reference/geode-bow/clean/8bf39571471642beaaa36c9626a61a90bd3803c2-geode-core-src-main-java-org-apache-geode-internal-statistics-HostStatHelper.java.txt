Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  static final int OSX_CODE = 4;  // Mac OS X
+  static final int OSX_CODE = 4; // Mac OS X
-  
+
-    if (! PureJavaMode.osStatsAreAvailable()) {
-      throw new RuntimeException(LocalizedStrings.HostStatHelper_HOSTSTATHELPER_NOT_ALLOWED_IN_PURE_JAVA_MODE.toLocalizedString());
+    if (!PureJavaMode.osStatsAreAvailable()) {
+      throw new RuntimeException(
+          LocalizedStrings.HostStatHelper_HOSTSTATHELPER_NOT_ALLOWED_IN_PURE_JAVA_MODE
+              .toLocalizedString());
-    } else if (osName.equals("Mac OS X")) { 
+    } else if (osName.equals("Mac OS X")) {
-      throw new InternalGemFireException(LocalizedStrings.HostStatHelper_UNSUPPORTED_OS_0_SUPPORTED_OSS_ARE_SUNOSSPARC_SOLARIS_LINUXX86_AND_WINDOWS.toLocalizedString(osName));
+      throw new InternalGemFireException(
+          LocalizedStrings.HostStatHelper_UNSUPPORTED_OS_0_SUPPORTED_OSS_ARE_SUNOSSPARC_SOLARIS_LINUXX86_AND_WINDOWS
+              .toLocalizedString(osName));
+
+
+
+
+
-      return osCode == OSX_CODE;
+    return osCode == OSX_CODE;
-  
+
-    if(isLinux()) {
+    if (isLinux()) {
-  
+
-    if(isLinux()) {
+    if (isLinux()) {
-  
+
-    if(isLinux()) {
+    if (isLinux()) {
-  
+
-   * Allocates and initializes any resources required to sample
-   * operating system statistics.
-   * returns 0 if initialization succeeded
+   * Allocates and initializes any resources required to sample operating system statistics. returns
+   * 0 if initialization succeeded
+
-   * Frees up resources used by this class. Once close is called this
-   * class can no longer be used.
+   * Frees up resources used by this class. Once close is called this class can no longer be used.
+
-   * Should be called before any calls to the refresh methods.
-   * On some platforms if this is not called then the refesh methods
-   * will just keep returning the same old data.
+   * Should be called before any calls to the refresh methods. On some platforms if this is not
+   * called then the refesh methods will just keep returning the same old data.
+
-   * Refreshes the specified process stats instance by fetching
-   * the current OS values for the given stats and storing them in the instance.
+   * Refreshes the specified process stats instance by fetching the current OS values for the given
+   * stats and storing them in the instance.
-    int pid = (int)s.getNumericId();
-    if(isLinux()) {
-      LinuxProcFsStatistics.refreshProcess(pid, s._getIntStorage(), s._getLongStorage(), s._getDoubleStorage());
+    int pid = (int) s.getNumericId();
+    if (isLinux()) {
+      LinuxProcFsStatistics.refreshProcess(pid, s._getIntStorage(), s._getLongStorage(),
+          s._getDoubleStorage());
-    }  
+    }
+
+
-   * Refreshes the specified system stats instance by fetching
-   * the current OS values for the local machine and storing them in
-   * the instance.
+   * Refreshes the specified system stats instance by fetching the current OS values for the local
+   * machine and storing them in the instance.
-    if(isLinux()) {
-      LinuxProcFsStatistics.refreshSystem(s._getIntStorage(), s._getLongStorage(), s._getDoubleStorage());
+    if (isLinux()) {
+      LinuxProcFsStatistics.refreshSystem(s._getIntStorage(), s._getLongStorage(),
+          s._getDoubleStorage());
+
-   * The call should have already checked to make sure
-   * usesSystemCalls returns true.
+   * The call should have already checked to make sure usesSystemCalls returns true.
-      throw new RuntimeException(LocalizedStrings.HostStatHelper_UNEXPECTED_OS_STATS_FLAGS_0.toLocalizedString(Integer.valueOf(flags)));
+      throw new RuntimeException(LocalizedStrings.HostStatHelper_UNEXPECTED_OS_STATS_FLAGS_0
+          .toLocalizedString(Integer.valueOf(flags)));
-  
+
-   * Creates and returns a {@link Statistics} with
-   * the given pid and name. The resource's stats will contain a snapshot
-   * of the current statistic values for the specified process.
+   * Creates and returns a {@link Statistics} with the given pid and name. The resource's stats will
+   * contain a snapshot of the current statistic values for the specified process.
-    case SOLARIS_CODE:
-      stats = f.createOsStatistics(SolarisProcessStats.getType(),
-                                   name, pid, PROCESS_STAT_FLAG);
-      break;
-    case LINUX_CODE:
-      stats = f.createOsStatistics(LinuxProcessStats.getType(),
-                                   name, pid, PROCESS_STAT_FLAG);
-      break;
-    case OSX_CODE:
-        stats = f.createOsStatistics(OSXProcessStats.getType(),
-                                     name, pid, PROCESS_STAT_FLAG);
+      case SOLARIS_CODE:
+        stats = f.createOsStatistics(SolarisProcessStats.getType(), name, pid, PROCESS_STAT_FLAG);
-    case WINDOWS_CODE:
-      stats = f.createOsStatistics(WindowsProcessStats.getType(),
-                                   name, pid, PROCESS_STAT_FLAG);
-      break;
-    default:
-      throw new InternalGemFireException(LocalizedStrings.HostStatHelper_UNHANDLED_OSCODE_0_HOSTSTATHELPERNEWPROCESS.toLocalizedString(Integer.valueOf(osCode)));
+      case LINUX_CODE:
+        stats = f.createOsStatistics(LinuxProcessStats.getType(), name, pid, PROCESS_STAT_FLAG);
+        break;
+      case OSX_CODE:
+        stats = f.createOsStatistics(OSXProcessStats.getType(), name, pid, PROCESS_STAT_FLAG);
+        break;
+      case WINDOWS_CODE:
+        stats = f.createOsStatistics(WindowsProcessStats.getType(), name, pid, PROCESS_STAT_FLAG);
+        break;
+      default:
+        throw new InternalGemFireException(
+            LocalizedStrings.HostStatHelper_UNHANDLED_OSCODE_0_HOSTSTATHELPERNEWPROCESS
+                .toLocalizedString(Integer.valueOf(osCode)));
-   * Creates a new <code>ProcessStats</code> instance that wraps the
-   * given <code>Statistics</code>.
+   * Creates a new <code>ProcessStats</code> instance that wraps the given <code>Statistics</code>.
-    case SOLARIS_CODE:
-      return SolarisProcessStats.createProcessStats(stats);
+      case SOLARIS_CODE:
+        return SolarisProcessStats.createProcessStats(stats);
-    case LINUX_CODE:
-      return LinuxProcessStats.createProcessStats(stats);
+      case LINUX_CODE:
+        return LinuxProcessStats.createProcessStats(stats);
-    case WINDOWS_CODE:
-      return WindowsProcessStats.createProcessStats(stats);
+      case WINDOWS_CODE:
+        return WindowsProcessStats.createProcessStats(stats);
-    case OSX_CODE:
+      case OSX_CODE:
-        
-    default:
-      throw new InternalGemFireException(LocalizedStrings.HostStatHelper_UNHANDLED_OSCODE_0_HOSTSTATHELPERNEWPROCESSSTATS.toLocalizedString(Integer.valueOf(osCode)));
+
+      default:
+        throw new InternalGemFireException(
+            LocalizedStrings.HostStatHelper_UNHANDLED_OSCODE_0_HOSTSTATHELPERNEWPROCESSSTATS
+                .toLocalizedString(Integer.valueOf(osCode)));
-   * Creates and returns a {@link Statistics} with the current
-   * machine's stats. The resource's stats will contain a snapshot
-   * of the current statistic values for the local machine.
+   * Creates and returns a {@link Statistics} with the current machine's stats. The resource's stats
+   * will contain a snapshot of the current statistic values for the local machine.
-    case SOLARIS_CODE:
-      stats = f.createOsStatistics(SolarisSystemStats.getType(),
-                                   getHostSystemName(),
-                                   getHostSystemId(),
-                                   SYSTEM_STAT_FLAG);
-      break;
-    case LINUX_CODE:
-      stats = f.createOsStatistics(LinuxSystemStats.getType(),
-                                   getHostSystemName(),
-                                   getHostSystemId(),
-                                   SYSTEM_STAT_FLAG);
-      break;
-    case WINDOWS_CODE:
-      stats = f.createOsStatistics(WindowsSystemStats.getType(),
-                                   getHostSystemName(),
-                                   getHostSystemId(),
-                                   SYSTEM_STAT_FLAG);
-      break;
-    case OSX_CODE:
-      stats = f.createOsStatistics(OSXSystemStats.getType(),
-                                     getHostSystemName(),
-                                     getHostSystemId(),
-                                     SYSTEM_STAT_FLAG);
-      break;
-    default:
-      throw new InternalGemFireException(LocalizedStrings.HostStatHelper_UNHANDLED_OSCODE_0_HOSTSTATHELPERNEWSYSTEM.toLocalizedString(Integer.valueOf(osCode)));
+      case SOLARIS_CODE:
+        stats = f.createOsStatistics(SolarisSystemStats.getType(), getHostSystemName(),
+            getHostSystemId(), SYSTEM_STAT_FLAG);
+        break;
+      case LINUX_CODE:
+        stats = f.createOsStatistics(LinuxSystemStats.getType(), getHostSystemName(),
+            getHostSystemId(), SYSTEM_STAT_FLAG);
+        break;
+      case WINDOWS_CODE:
+        stats = f.createOsStatistics(WindowsSystemStats.getType(), getHostSystemName(),
+            getHostSystemId(), SYSTEM_STAT_FLAG);
+        break;
+      case OSX_CODE:
+        stats = f.createOsStatistics(OSXSystemStats.getType(), getHostSystemName(),
+            getHostSystemId(), SYSTEM_STAT_FLAG);
+        break;
+      default:
+        throw new InternalGemFireException(
+            LocalizedStrings.HostStatHelper_UNHANDLED_OSCODE_0_HOSTSTATHELPERNEWSYSTEM
+                .toLocalizedString(Integer.valueOf(osCode)));
-      refreshSystem((LocalStatisticsImpl)stats);
+      refreshSystem((LocalStatisticsImpl) stats);
-   * @return this machine's fully qualified hostname 
-   *         or "unknownHostName" if one cannot be found.
+   * @return this machine's fully qualified hostname or "unknownHostName" if one cannot be found.
-  
-  /** 
-   * Generate a systemid based off of the ip address of the host.
-   * This duplicates the common implementation of 
-   * <code>long gethostid(void) </code>.
-   * Punt on the ipv6 case and just use the same algorithm.
+
+  /**
+   * Generate a systemid based off of the ip address of the host. This duplicates the common
+   * implementation of <code>long gethostid(void) </code>. Punt on the ipv6 case and just use the
+   * same algorithm.
+   * 
-      id = (addr[1] & 0xFFL) << 24 |  
-           (addr[0] & 0xFFL) << 16 |  
-           (addr[3] & 0xFFL) << 8  |  
-           (addr[2] & 0xFFL) << 0;
+      id = (addr[1] & 0xFFL) << 24 | (addr[0] & 0xFFL) << 16 | (addr[3] & 0xFFL) << 8
+          | (addr[2] & 0xFFL) << 0;

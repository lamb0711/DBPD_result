GEODE-2113 Implement SSL over NIO

This removes old-I/O use in TCPConduit peer-to-peer communications.
This was used for SSL/TLS secure commuications but Java has had an
SSLEngine implementation that allows you to implement secure communications
on new-I/O SocketChannels or any other transport mechanism.

A new NioSSLEngine class wraps the JDK's SSLEngine and provides the
SSL handshake as well as encryption/decryption of messages. SocketCreator
performs the SSL handshake and returns a NioSslEngine that TCPConduit
then uses for messaging.

The SSL handshake needs to be done in Connection.java now because the
ByteBuffer used to do the handshake is also used for reading messages
in Receivers. Because of this the Handshake pool in TCPConduit became
obsolete and I deleted it.

I've also done a lot of cleanup of compilation warnings in Connection.java
and removed references to "NIO". The primary SSL/TLS changes in that class
are in writeFully (renamed from nioWriteFully) and processBuffer (renamed
from processNIOBuffer).

While testing I noticed some places where we're creating non-daemon
threads that were keeping DUnit ChildVM processes from exiting.  I've
changed these places to use daemon threads.  Very few threads in Geode
should be non-daemon.

Porting client/server to use NioSSLEngine will be done under a separate
ticket and a different version of NioEngine may be created to secure
UDP messaging.

-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.OutputStream;
-import java.net.Inet6Address;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+
-import org.apache.geode.internal.ByteArrayDataInput;
+import org.apache.geode.internal.net.Buffers;
+import org.apache.geode.internal.net.NioEngine;
+import org.apache.geode.internal.net.NioFilter;
-  private static final int INITIAL_CAPACITY =
-      Integer.getInteger("p2p.readerBufferSize", 32768).intValue();
-  public static final int NORMAL_MSG_TYPE = 0x4c;
-  public static final int CHUNKED_MSG_TYPE = 0x4d; // a chunk of one logical msg
-  public static final int END_CHUNKED_MSG_TYPE = 0x4e; // last in a series of chunks
-  public static final int DIRECT_ACK_BIT = 0x20;
+  static final int NORMAL_MSG_TYPE = 0x4c;
+  static final int CHUNKED_MSG_TYPE = 0x4d; // a chunk of one logical msg
+  static final int END_CHUNKED_MSG_TYPE = 0x4e; // last in a series of chunks
+  static final int DIRECT_ACK_BIT = 0x20;
-  public static final int MSG_HEADER_SIZE_OFFSET = 0;
-  public static final int MSG_HEADER_TYPE_OFFSET = 4;
-  public static final int MSG_HEADER_ID_OFFSET = 5;
-  public static final int MSG_HEADER_BYTES = 7;
+  static final int MSG_HEADER_SIZE_OFFSET = 0;
+  static final int MSG_HEADER_TYPE_OFFSET = 4;
+  static final int MSG_HEADER_ID_OFFSET = 5;
+  static final int MSG_HEADER_BYTES = 7;
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "SMALL_BUFFER_SIZE", 4096).intValue();
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "SMALL_BUFFER_SIZE", 4096);
+  private NioFilter ioFilter;
-  private static final ThreadLocal isReaderThread = new ThreadLocal();
+  private static final ThreadLocal<Boolean> isReaderThread = new ThreadLocal<Boolean>() {
+    @Override
+    public Boolean initialValue() {
+      return Boolean.FALSE;
+    }
+  };
-  public static boolean isReaderThread() {
-    Object o = isReaderThread.get();
-    if (o == null) {
-      return false;
-    } else {
-      return ((Boolean) o).booleanValue();
-    }
+  private static boolean isReaderThread() {
+    return isReaderThread.get();
-  private static final ThreadLocal isDominoThread = new ThreadLocal();
+  private static final ThreadLocal<Boolean> isDominoThread = new ThreadLocal<Boolean>() {
+    @Override
+    public Boolean initialValue() {
+      return Boolean.FALSE;
+    }
+  };
-  public static boolean tipDomino() {
+  private static boolean tipDomino() {
-    Object o = isDominoThread.get();
-    if (o == null) {
-      return false;
-    } else {
-      return ((Boolean) o).booleanValue();
-    }
+    return isDominoThread.get();
-  /** the non-NIO output stream */
-  OutputStream output;
-
-  String conduitIdStr;
+  private String conduitIdStr;
-  Version remoteVersion;
+  private Version remoteVersion;
-  private long queuedBytes = 0;
+  private long queuedBytes;
-  Thread pusherThread;
+  private Thread pusherThread;
-      .getInteger("p2p.maxConnectionSenders", DirectChannel.DEFAULT_CONCURRENCY_LEVEL).intValue();
+      .getInteger("p2p.maxConnectionSenders", DirectChannel.DEFAULT_CONCURRENCY_LEVEL);
-  volatile boolean handshakeRead = false;
-  volatile boolean handshakeCancelled = false;
+  private volatile boolean handshakeRead;
+  private volatile boolean handshakeCancelled;
-  private volatile int replyCode = 0;
+  private volatile int replyCode;
-  volatile boolean readerShuttingDown = false;
+  private volatile boolean readerShuttingDown = false;
-  volatile boolean finishedConnecting = false;
+  private volatile boolean finishedConnecting = false;
-  volatile boolean accessed = true;
-  volatile boolean socketInUse = false;
+  private volatile boolean accessed = true;
+  private volatile boolean socketInUse = false;
-  long transmissionStartTime;
+  private long transmissionStartTime;
-  List ackConnectionGroup;
+  private List ackConnectionGroup;
-  String ackThreadName;
+  private String ackThreadName;
-  /** the buffer used for NIO message receipt */
-  ByteBuffer nioInputBuffer;
+  /** the buffer used for message receipt */
+  private ByteBuffer inputBuffer;
-  int nioMessageLength;
+  private int messageLength;
-  byte nioMessageType;
+  private byte messageType;
+
+  /**
+   * when messages are chunked by a MsgStreamer we track the destreamers on
+   * the receiving side using a message identifier
+   */
+  private short messageId;
+
+  /** whether the length of the next message has been established */
+  private boolean lengthSet = false;
-  MsgDestreamer idleMsgDestreamer;
+  private MsgDestreamer idleMsgDestreamer;
-   * used to map a msgId to a MsgDestreamer which are used for destreaming chunked messages using
-   * nio
+   * used to map a msgId to a MsgDestreamer which are used for destreaming chunked messages
-  HashMap destreamerMap;
+  private HashMap destreamerMap;
-  boolean directAck;
+  private boolean directAck;
-  short nioMsgId;
-
-  /** whether the length of the next message has been established */
-  boolean nioLengthSet = false;
-  public int getReceiveBufferSize() {
+  int getReceiveBufferSize() {
-        } else {
-              Integer.valueOf(actualSize), Integer.valueOf(requestedSize));
+              actualSize, requestedSize);
-  public int getSendBufferSize() {
+  int getSendBufferSize() {
-   * creates a connection that we accepted (it was initiated by an explicit connect being done on
-   * the other side). We will only receive data on this socket; never send.
-   */
-  protected static Connection createReceiver(ConnectionTable table, Socket socket)
-      throws IOException, ConnectionException {
-    Connection connection = new Connection(table, socket);
-    boolean readerStarted = false;
-    try {
-      connection.startReader(table);
-      readerStarted = true;
-    } finally {
-      if (!readerStarted) {
-        connection.closeForReconnect(
-            "could not start reader thread");
-      }
-    }
-    connection.waitForHandshake();
-    connection.finishedConnecting = true;
-    return connection;
-  }
-
-  /**
-   * creates a connection that we accepted (it was initiated by an explicit connect being done on
+   * creates a "reader" connection that we accepted (it was initiated by an explicit connect being
+   * done on
-  protected Connection(ConnectionTable t, Socket socket) throws IOException, ConnectionException {
+  protected Connection(ConnectionTable t, Socket socket)
+      throws ConnectionException {
-    if (!useNIO()) {
-      try {
-        // this.output = new BufferedOutputStream(socket.getOutputStream(), SMALL_BUFFER_SIZE);
-        this.output = socket.getOutputStream();
-      } catch (IOException io) {
-        logger.fatal("Unable to get P2P connection streams", io);
-        t.getSocketCloser().asyncClose(socket, this.remoteAddr.toString(), null);
-        throw io;
-      }
-    }
-  protected void initReceiver() {
+  void initReceiver() {
-    this.waitForHandshake();
-    this.finishedConnecting = true;
-  public boolean checkForIdleTimeout() {
+  boolean checkForIdleTimeout() {
-  private static byte[] okHandshakeBytes;
-    if (TCPConduit.useDirectBuffers) {
+    if (Buffers.useDirectBuffers) {
-    okHandshakeBytes = bytes;
-  public static int calcHdrSize(int byteSize) {
+  static int calcHdrSize(int byteSize) {
-          Integer.valueOf(MAX_MSG_SIZE)));
+          MAX_MSG_SIZE));
-  public static int calcMsgByteSize(int hdrSize) {
+  static int calcMsgByteSize(int hdrSize) {
-  public static byte calcHdrVersion(int hdrSize) throws IOException {
+  static byte calcHdrVersion(int hdrSize) throws IOException {
-              new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(ver)}));
+              HANDSHAKE_VERSION, ver));
-    byte[] my_okHandshakeBytes = null;
-    ByteBuffer my_okHandshakeBuf = null;
+    ByteBuffer my_okHandshakeBuf;
-      if (useNIO() && TCPConduit.useDirectBuffers) {
+      if (Buffers.useDirectBuffers) {
-      if (useNIO()) {
-        my_okHandshakeBuf = bb;
-        bb.flip();
-      } else {
-        my_okHandshakeBytes = new byte[bb.position()];
-        bb.flip();
-        bb.get(my_okHandshakeBytes);
-      }
+      my_okHandshakeBuf = bb;
+      bb.flip();
-      my_okHandshakeBytes = okHandshakeBytes;
-    if (useNIO()) {
-      assert my_okHandshakeBuf != null;
-      synchronized (my_okHandshakeBuf) {
-        my_okHandshakeBuf.position(0);
-        nioWriteFully(getSocket().getChannel(), my_okHandshakeBuf, false, null);
-      }
-    } else {
-      synchronized (outLock) {
-        assert my_okHandshakeBytes != null;
-        this.output.write(my_okHandshakeBytes, 0, my_okHandshakeBytes.length);
-        this.output.flush();
-      }
-    }
+    my_okHandshakeBuf.position(0);
+    writeFully(getSocket().getChannel(), my_okHandshakeBuf, false, null);
-      Integer.getInteger("p2p.handshakeTimeoutMs", 59000).intValue();
+      Integer.getInteger("p2p.handshakeTimeoutMs", 59000);
-  public static final byte HANDSHAKE_VERSION = 7; // product version exchange during handshake
+  private static final byte HANDSHAKE_VERSION = 7; // product version exchange during handshake
-                        peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)));
+                        peerName, HANDSHAKE_TIMEOUT_MS));
-                      peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)));
+                      peerName, HANDSHAKE_TIMEOUT_MS));
-   * @param beingSick test hook to simulate sickness in communications & membership
+   * @param beingSickForTests test hook to simulate sickness in communications & membership
-  private void asyncClose(boolean beingSick) {
+  private void asyncClose(boolean beingSickForTests) {
+    releaseInputBuffer();
+
-    if (beingSick) {
+    if (beingSickForTests) {
-          this.owner.getSocketCloser().asyncClose(s, String.valueOf(this.remoteAddr), null);
+          this.owner.getSocketCloser().asyncClose(s, String.valueOf(this.remoteAddr),
+              () -> ioFilter.close(s.getChannel()));
-  private void handshakeNio() throws IOException {
+  private void handshakeFromNewSender() throws IOException {
-    nioWriteFully(getSocket().getChannel(), connectHandshake.getContentBuffer(), false, null);
-  }
-
-  private void handshakeStream() throws IOException {
-    waitForAddressCompletion();
-
-    this.output = getSocket().getOutputStream();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream(CONNECT_HANDSHAKE_SIZE);
-    DataOutputStream os = new DataOutputStream(baos);
-    InternalDistributedMember myAddr = owner.getConduit().getMemberId();
-    os.writeByte(0);
-    os.writeByte(HANDSHAKE_VERSION);
-    // NOTE: if you add or remove code in this section bump HANDSHAKE_VERSION
-    InternalDataSerializer.invokeToData(myAddr, os);
-    os.writeBoolean(this.sharedResource);
-    os.writeBoolean(this.preserveOrder);
-    os.writeLong(this.uniqueId);
-    Version.CURRENT.writeOrdinal(os, true);
-    os.writeInt(dominoCount.get() + 1);
-    os.flush();
-
-    byte[] msg = baos.toByteArray();
-    int len = calcHdrSize(msg.length);
-    byte[] lenbytes = new byte[MSG_HEADER_BYTES];
-    lenbytes[MSG_HEADER_SIZE_OFFSET] = (byte) ((len / 0x1000000) & 0xff);
-    lenbytes[MSG_HEADER_SIZE_OFFSET + 1] = (byte) ((len / 0x10000) & 0xff);
-    lenbytes[MSG_HEADER_SIZE_OFFSET + 2] = (byte) ((len / 0x100) & 0xff);
-    lenbytes[MSG_HEADER_SIZE_OFFSET + 3] = (byte) (len & 0xff);
-    lenbytes[MSG_HEADER_TYPE_OFFSET] = (byte) NORMAL_MSG_TYPE;
-    lenbytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID >> 8) & 0xff);
-    lenbytes[MSG_HEADER_ID_OFFSET + 1] = (byte) (MsgIdGenerator.NO_MSG_ID & 0xff);
-    synchronized (outLock) {
-      this.output.write(lenbytes, 0, lenbytes.length);
-      this.output.write(msg, 0, msg.length);
-      this.output.flush();
-    }
+    writeFully(getSocket().getChannel(), connectHandshake.getContentBuffer(), false, null);
-    // send this server's port. It's expected on the other side
-    if (useNIO()) {
-      handshakeNio();
-    } else {
-      handshakeStream();
+    // send this member's information. It's expected on the other side
+    if (logger.isDebugEnabled()) {
+      logger.debug("starting peer-to-peer handshake on socket {}", socket);
-
+    handshakeFromNewSender();
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "RECONNECT_WAIT_TIME", 2000).intValue();
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "RECONNECT_WAIT_TIME", 2000);
-                sharedResource, preserveOrder, remoteAddr, ioe);
+                sharedResource, preserveOrder, remoteAddr,
+                ioe.getCause() != null ? ioe.getCause() : ioe);
-              IOException ioe =
-                  new IOException("Handshake failed");
-              ioe.initCause(e);
-              throw ioe;
+              throw new IOException("Handshake failed", e);
-    if (useNIO()) {
-      SocketChannel channel = SocketChannel.open();
-      this.owner.addConnectingSocket(channel.socket(), addr.getAddress());
-      try {
-        channel.socket().setTcpNoDelay(true);
+    SocketChannel channel = SocketChannel.open();
+    this.owner.addConnectingSocket(channel.socket(), addr.getAddress());
-        channel.socket().setKeepAlive(SocketCreator.ENABLE_TCP_KEEP_ALIVE);
+    try {
+      channel.socket().setTcpNoDelay(true);
+      channel.socket().setKeepAlive(SocketCreator.ENABLE_TCP_KEEP_ALIVE);
-        /*
-         * If conserve-sockets is false, the socket can be used for receiving responses, so set the
-         * receive buffer accordingly.
-         */
-        if (!sharedResource) {
-          setReceiveBufferSize(channel.socket(), this.owner.getConduit().tcpBufferSize);
-        } else {
-          setReceiveBufferSize(channel.socket(), SMALL_BUFFER_SIZE); // make small since only
-                                                                     // receive ack messages
-        }
-        setSendBufferSize(channel.socket());
-        channel.configureBlocking(true);
-
-        int connectTime = getP2PConnectTimeout();
-
-        try {
-          channel.socket().connect(addr, connectTime);
-        } catch (NullPointerException e) {
-          // bug #45044 - jdk 1.7 sometimes throws an NPE here
-          ConnectException c = new ConnectException("Encountered bug #45044 - retrying");
-          c.initCause(e);
-          // prevent a hot loop by sleeping a little bit
-          try {
-            Thread.sleep(1000);
-          } catch (InterruptedException ie) {
-            Thread.currentThread().interrupt();
-          }
-          throw c;
-        } catch (CancelledKeyException | ClosedSelectorException e) {
-          // bug #44469: for some reason NIO throws this runtime exception
-          // instead of an IOException on timeouts
-          ConnectException c = new ConnectException(
-              String.format("Attempt timed out after %s milliseconds",
-                  new Object[] {connectTime}));
-          c.initCause(e);
-          throw c;
-        }
-      } finally {
-        this.owner.removeConnectingSocket(channel.socket());
-      }
-      this.socket = channel.socket();
-    } else {
-      if (TCPConduit.useSSL) {
-        int socketBufferSize =
-            sharedResource ? SMALL_BUFFER_SIZE : this.owner.getConduit().tcpBufferSize;
-        this.socket = owner.getConduit().getSocketCreator().connectForServer(
-            remoteAddr.getInetAddress(), remoteAddr.getDirectChannelPort(), socketBufferSize);
-        // Set the receive buffer size local fields. It has already been set in the socket.
-        setSocketBufferSize(this.socket, false, socketBufferSize, true);
-        setSendBufferSize(this.socket);
+      /*
+       * If conserve-sockets is false, the socket can be used for receiving responses, so set the
+       * receive buffer accordingly.
+       */
+      if (!sharedResource) {
+        setReceiveBufferSize(channel.socket(), this.owner.getConduit().tcpBufferSize);
-        Socket s = new Socket();
-        this.socket = s;
-        s.setTcpNoDelay(true);
-        s.setKeepAlive(SocketCreator.ENABLE_TCP_KEEP_ALIVE);
-        setReceiveBufferSize(s, SMALL_BUFFER_SIZE);
-        setSendBufferSize(s);
-        s.connect(addr, 0);
+        setReceiveBufferSize(channel.socket(), SMALL_BUFFER_SIZE); // make small since only
+        // receive ack messages
+      setSendBufferSize(channel.socket());
+      channel.configureBlocking(true);
+
+      int connectTime = getP2PConnectTimeout();
+
+      try {
+
+        channel.socket().connect(addr, connectTime);
+
+        createIoFilter(channel, true);
+
+      } catch (NullPointerException e) {
+        // bug #45044 - jdk 1.7 sometimes throws an NPE here
+        ConnectException c = new ConnectException("Encountered bug #45044 - retrying");
+        c.initCause(e);
+        // prevent a hot loop by sleeping a little bit
+        try {
+          Thread.sleep(1000);
+        } catch (InterruptedException ie) {
+          Thread.currentThread().interrupt();
+        }
+        throw c;
+      } catch (SSLException e) {
+        ConnectException c = new ConnectException("Problem connecting to peer " + addr);
+        c.initCause(e);
+        throw c;
+      } catch (CancelledKeyException | ClosedSelectorException e) {
+        // bug #44469: for some reason NIO throws this runtime exception
+        // instead of an IOException on timeouts
+        ConnectException c = new ConnectException(
+            String.format("Attempt timed out after %s milliseconds",
+                connectTime));
+        c.initCause(e);
+        throw c;
+      }
+    } finally {
+      this.owner.removeConnectingSocket(channel.socket());
+    this.socket = channel.socket();
+
-    } catch (SocketException e) {
+    } catch (SocketException ignored) {
-      Integer.getInteger("p2p.batchBufferSize", 1024 * 1024).intValue();
-  private static final int BATCH_FLUSH_MS = Integer.getInteger("p2p.batchFlushTime", 50).intValue();
-  private Object batchLock;
+      Integer.getInteger("p2p.batchBufferSize", 1024 * 1024);
+  private static final int BATCH_FLUSH_MS = Integer.getInteger("p2p.batchFlushTime", 50);
+  private final Object batchLock = new Object();
-    // batch send buffer isn't needed if old-io is being used
-    if (!this.useNIO) {
-      return;
-    }
-    this.batchLock = new Object();
-    if (TCPConduit.useDirectBuffers) {
+    if (Buffers.useDirectBuffers) {
-  public void cleanUpOnIdleTaskCancel() {
+  void cleanUpOnIdleTaskCancel() {
+  public void setInputBuffer(ByteBuffer buffer) {
+    this.inputBuffer = buffer;
+  }
+
-    public BatchBufferFlusher() {
+    BatchBufferFlusher() {
-    public void flushBuffer(ByteBuffer bb) {
+    void flushBuffer(ByteBuffer bb) {
-                  nioWriteFully(channel, sendBatchBuffer, false, null);
+                  writeFully(channel, sendBatchBuffer, false, null);
-          if (logger.isDebugEnabled()) {
-            logger.debug("Closing socket for {}", this);
-          }
-        nioLengthSet = false;
+        lengthSet = false;
+    if (logger.isDebugEnabled()) {
+      logger.debug("Starting thread for " + p2pReaderName());
+    }
-      if (useNIO()) {
-        runNioReader();
-      } else {
-        runOioReader();
-      }
+      readMessages();
-      initiateSuspicionIfSharedUnordered();
+        initiateSuspicionIfSharedUnordered();
-      }
-      ByteBuffer tmp = this.nioInputBuffer;
-      if (tmp != null) {
-        this.nioInputBuffer = null;
-        final DMStats stats = this.owner.getConduit().getStats();
-        Buffers.releaseReceiveBuffer(tmp, stats);
+
+        if (this.isSharedResource()) {
+          releaseInputBuffer();
+        }
+  private void releaseInputBuffer() {
+    ByteBuffer tmp = this.inputBuffer;
+    if (tmp != null) {
+      this.inputBuffer = null;
+      final DMStats stats = this.owner.getConduit().getStats();
+      Buffers.releaseReceiveBuffer(tmp, stats);
+    }
+  }
+
-  private void runNioReader() {
+  private void readMessages() {
-    SocketChannel channel = null;
+    SocketChannel channel;
+      socket.setSoTimeout(0);
+      socket.setTcpNoDelay(true);
+      if (ioFilter == null) {
+        createIoFilter(channel, false);
+      }
-            "runNioReader caught closed channel");
+            "readMessages caught closed channel");
-              "runNioReader caught shutdown");
+              "readMessages caught shutdown");
-      logger.fatal("Failed setting channel to blocking mode {}", ex);
+      logger.info("Failed initializing socket for message {}: {}",
+          (this.isReceiver ? "receiver" : "sender"), ex.getMessage());
-        requestClose(String.format("Failed setting channel to blocking mode %s",
+        requestClose(String.format("Failed initializing socket %s",
-        logger.debug("Starting {}", p2pReaderName());
+        logger.debug("Starting {} on {}", p2pReaderName(), socket);
+    // if we're using SSL/TLS the input buffer may already have data to process
+    boolean skipInitialRead = getInputBuffer().position() > 0;
+    boolean isInitialRead = true;
+              ioFilter.close(s.getChannel());
-          ByteBuffer buff = getNIOBuffer();
+          ByteBuffer buff = getInputBuffer();
-          int amt = channel.read(buff);
+          int amountRead;
+          if (!isInitialRead) {
+            amountRead = channel.read(buff);
+          } else {
+            isInitialRead = false;
+            if (!skipInitialRead) {
+              amountRead = channel.read(buff);
+            } else {
+              amountRead = buff.position();
+            }
+          }
-          if (amt == 0) {
+          if (amountRead == 0) {
-          if (amt < 0) {
+          if (amountRead < 0) {
-          processNIOBuffer();
+          processInputBuffer();
+
-                logger.debug("{} handshake has been read {}", p2pReaderName(), this);
+                logger.debug("handshake has been read {}", this);
-                logger.debug("{} handshake has been cancelled {}", p2pReaderName(), this);
+                logger.debug("handshake has been cancelled {}", this);
-          } catch (Exception ex) {
+          } catch (Exception ignored) {
-          } catch (Exception ex) {
+          } catch (Exception ignored) {
-          } catch (Exception ex) {
+          } catch (Exception ignored) {
-          } catch (Exception ex) {
+          } catch (Exception ignored) {
-        logger.debug("{} runNioReader terminated id={} from {}", p2pReaderName(), conduitIdStr,
-            remoteAddr);
+        logger.debug("readMessages terminated id={} from {} isHandshakeReader={}", conduitIdStr,
+            remoteAddr, isHandShakeReader);
+  private void createIoFilter(SocketChannel channel, boolean clientSocket) throws IOException {
+    if (TCPConduit.useSSL && channel != null) {
+      InetSocketAddress address = (InetSocketAddress) channel.getRemoteAddress();
+      SSLEngine engine =
+          getConduit().getSocketCreator().createSSLEngine(address.getHostName(), address.getPort());
+
+      if (!clientSocket) {
+        engine.setWantClientAuth(true);
+        engine.setNeedClientAuth(true);
+      }
+
+      if (inputBuffer == null
+          || (inputBuffer.capacity() < engine.getSession().getPacketBufferSize())) {
+        // TLS has a minimum input buffer size constraint
+        if (inputBuffer != null) {
+          Buffers.releaseReceiveBuffer(inputBuffer, getConduit().getStats());
+        }
+        inputBuffer = Buffers.acquireReceiveBuffer(engine.getSession().getPacketBufferSize(),
+            getConduit().getStats());
+      }
+      ioFilter = getConduit().getSocketCreator().handshakeSSLSocketChannel(channel, engine,
+          getConduit().idleConnectionTimeout, clientSocket, inputBuffer, getConduit().getStats());
+    } else {
+      ioFilter = new NioEngine();
+    }
+  }
+
-  public static boolean isIgnorableIOException(Exception e) {
+  private static boolean isIgnorableIOException(Exception e) {
-  private void runOioReader() {
-    InputStream input = null;
-    try {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Socket is of type: {}", getSocket().getClass());
-      }
-      input = new BufferedInputStream(getSocket().getInputStream(), INITIAL_CAPACITY);
-    } catch (IOException io) {
-      if (stopped || owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-        return; // bug 37520: exit run loop (and thread)
-      }
-      logger.fatal("Unable to get input stream", io);
-      stopped = true;
-    }
-
-    if (!stopped) {
-      Assert.assertTrue(owner != null,
-          "owner should not be null");
-      if (logger.isDebugEnabled()) {
-        logger.debug("Starting {}", p2pReaderName());
-      }
-    }
-
-    byte[] headerBytes = new byte[MSG_HEADER_BYTES];
-
-    final ByteArrayDataInput dis = new ByteArrayDataInput();
-    while (!stopped) {
-      try {
-        if (SystemFailure.getFailure() != null) {
-          // Allocate no objects here!
-          Socket s = this.socket;
-          if (s != null) {
-            try {
-              s.close();
-            } catch (IOException e) {
-              // don't care
-            }
-          }
-          SystemFailure.checkFailure(); // throws
-        }
-        if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-          break;
-        }
-        int len = 0;
-        if (readFully(input, headerBytes, headerBytes.length) < 0) {
-          stopped = true;
-          continue;
-        }
-        // long recvNanos = DistributionStats.getStatTime();
-        len = ((headerBytes[MSG_HEADER_SIZE_OFFSET] & 0xff) * 0x1000000)
-            + ((headerBytes[MSG_HEADER_SIZE_OFFSET + 1] & 0xff) * 0x10000)
-            + ((headerBytes[MSG_HEADER_SIZE_OFFSET + 2] & 0xff) * 0x100)
-            + (headerBytes[MSG_HEADER_SIZE_OFFSET + 3] & 0xff);
-        /* byte msgHdrVersion = */ calcHdrVersion(len);
-        len = calcMsgByteSize(len);
-        int msgType = headerBytes[MSG_HEADER_TYPE_OFFSET];
-        short msgId = (short) (((headerBytes[MSG_HEADER_ID_OFFSET] & 0xff) << 8)
-            + (headerBytes[MSG_HEADER_ID_OFFSET + 1] & 0xff));
-        boolean myDirectAck = (msgType & DIRECT_ACK_BIT) != 0;
-        if (myDirectAck) {
-          msgType &= ~DIRECT_ACK_BIT; // clear the bit
-        }
-        // Following validation fixes bug 31145
-        if (!validMsgType(msgType)) {
-          logger.fatal("Unknown P2P message type: {}", Integer.valueOf(msgType));
-          this.readerShuttingDown = true;
-          requestClose(String.format("Unknown P2P message type: %s",
-              Integer.valueOf(msgType)));
-          break;
-        }
-        if (logger.isTraceEnabled())
-          logger.trace("{} reading {} bytes", conduitIdStr, len);
-        byte[] bytes = new byte[len];
-        if (readFully(input, bytes, len) < 0) {
-          stopped = true;
-          continue;
-        }
-        boolean interrupted = Thread.interrupted();
-        try {
-          if (this.handshakeRead) {
-            if (msgType == NORMAL_MSG_TYPE) {
-              // DMStats stats = this.owner.getConduit().stats;
-              // long start = DistributionStats.getStatTime();
-              this.owner.getConduit().getStats().incMessagesBeingReceived(true, len);
-              dis.initialize(bytes, this.remoteVersion);
-              DistributionMessage msg = null;
-              try {
-                ReplyProcessor21.initMessageRPId();
-                long startSer = this.owner.getConduit().getStats().startMsgDeserialization();
-                msg = (DistributionMessage) InternalDataSerializer.readDSFID(dis);
-                this.owner.getConduit().getStats().endMsgDeserialization(startSer);
-                if (dis.available() != 0) {
-                  logger.warn("Message deserialization of {} did not read {} bytes.",
-                      msg, Integer.valueOf(dis.available()));
-                }
-                // stats.incBatchCopyTime(start);
-                try {
-                  // start = DistributionStats.getStatTime();
-                  if (!dispatchMessage(msg, len, myDirectAck)) {
-                    continue;
-                  }
-                  // stats.incBatchSendTime(start);
-                } catch (MemberShunnedException e) {
-                  continue;
-                } catch (Exception de) {
-                  this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de); // bug
-                                                                                          // 37101
-                  logger.fatal("Error dispatching message", de);
-                }
-              } catch (VirtualMachineError err) {
-                SystemFailure.initiateFailure(err);
-                // If this ever returns, rethrow the error. We're poisoned
-                // now, so don't let this thread continue.
-                throw err;
-              } catch (Throwable e) {
-                // Whenever you catch Error or Throwable, you must also
-                // catch VirtualMachineError (see above). However, there is
-                // _still_ a possibility that you are dealing with a cascading
-                // error condition, so you also need to check to see if the JVM
-                // is still usable:
-                SystemFailure.checkFailure();
-                // In particular I want OutOfMem to be caught here
-                if (!myDirectAck) {
-                  String reason =
-                      "Error deserializing message";
-                  sendFailureReply(ReplyProcessor21.getMessageRPId(), reason, e, myDirectAck);
-                }
-                if (e instanceof CancelException) {
-                  if (!(e instanceof CacheClosedException)) {
-                    // Just log a message if we had trouble deserializing due to
-                    // CacheClosedException; see bug 43543
-                    throw (CancelException) e;
-                  }
-                }
-                logger.fatal("Error deserializing message", e);
-                // requestClose();
-                // return;
-              } finally {
-                ReplyProcessor21.clearMessageRPId();
-              }
-            } else if (msgType == CHUNKED_MSG_TYPE) {
-              MsgDestreamer md = obtainMsgDestreamer(msgId, remoteVersion);
-              this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0, len);
-              try {
-                md.addChunk(bytes);
-              } catch (IOException ex) {
-                logger.fatal("Failed handling chunk message", ex);
-              }
-            } else /* (messageType == END_CHUNKED_MSG_TYPE) */ {
-              MsgDestreamer md = obtainMsgDestreamer(msgId, remoteVersion);
-              this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0, len);
-              try {
-                md.addChunk(bytes);
-              } catch (IOException ex) {
-                logger.fatal("Failed handling end chunk message", ex);
-              }
-              DistributionMessage msg = null;
-              int msgLength = 0;
-              String failureMsg = null;
-              Throwable failureEx = null;
-              int rpId = 0;
-              try {
-                msg = md.getMessage();
-              } catch (ClassNotFoundException ex) {
-                this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-                failureEx = ex;
-                rpId = md.getRPid();
-                logger.warn("ClassNotFound deserializing message: {}", ex.toString());
-              } catch (IOException ex) {
-                this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-                failureMsg = "IOException deserializing message";
-                failureEx = ex;
-                rpId = md.getRPid();
-                logger.fatal("IOException deserializing message", failureEx);
-              } catch (InterruptedException ex) {
-                Thread.currentThread().interrupt();
-                throw ex; // caught by outer try
-              } catch (VirtualMachineError err) {
-                SystemFailure.initiateFailure(err);
-                // If this ever returns, rethrow the error. We're poisoned
-                // now, so don't let this thread continue.
-                throw err;
-              } catch (Throwable ex) {
-                // Whenever you catch Error or Throwable, you must also
-                // catch VirtualMachineError (see above). However, there is
-                // _still_ a possibility that you are dealing with a cascading
-                // error condition, so you also need to check to see if the JVM
-                // is still usable:
-                SystemFailure.checkFailure();
-                this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-                failureMsg = "Unexpected failure deserializing message";
-                failureEx = ex;
-                rpId = md.getRPid();
-                logger.fatal("Unexpected failure deserializing message",
-                    failureEx);
-              } finally {
-                msgLength = md.size();
-                releaseMsgDestreamer(msgId, md);
-              }
-              if (msg != null) {
-                try {
-                  if (!dispatchMessage(msg, msgLength, myDirectAck)) {
-                    continue;
-                  }
-                } catch (MemberShunnedException e) {
-                  continue;
-                } catch (Exception de) {
-                  this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
-                  logger.fatal("Error dispatching message", de);
-                } catch (ThreadDeath td) {
-                  throw td;
-                } catch (VirtualMachineError err) {
-                  SystemFailure.initiateFailure(err);
-                  // If this ever returns, rethrow the error. We're poisoned
-                  // now, so don't let this thread continue.
-                  throw err;
-                } catch (Throwable t) {
-                  // Whenever you catch Error or Throwable, you must also
-                  // catch VirtualMachineError (see above). However, there is
-                  // _still_ a possibility that you are dealing with a cascading
-                  // error condition, so you also need to check to see if the JVM
-                  // is still usable:
-                  SystemFailure.checkFailure();
-                  logger.fatal("Throwable dispatching message", t);
-                }
-              } else if (failureEx != null) {
-                sendFailureReply(rpId, failureMsg, failureEx, myDirectAck);
-              }
-            }
-          } else {
-            dis.initialize(bytes, null);
-            if (!this.isReceiver) {
-              this.replyCode = dis.readUnsignedByte();
-              if (this.replyCode != REPLY_CODE_OK
-                  && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
-                Integer replyCodeInteger = Integer.valueOf(this.replyCode);
-                String err = String.format("Unknown handshake reply code: %s",
-                    replyCodeInteger);
-
-                if (this.replyCode == 0) { // bug 37113
-                  if (logger.isDebugEnabled()) {
-                    logger.debug("{} (peer probably departed ungracefully)", err);
-                  }
-                } else {
-                  logger.fatal("Unknown handshake reply code: {}",
-                      replyCodeInteger);
-                }
-                this.readerShuttingDown = true;
-                requestClose(err);
-                break;
-              }
-              if (this.replyCode == REPLY_CODE_OK_WITH_ASYNC_INFO) {
-                this.asyncDistributionTimeout = dis.readInt();
-                this.asyncQueueTimeout = dis.readInt();
-                this.asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
-                if (this.asyncDistributionTimeout != 0) {
-                  logger.info("{} async configuration received {}.",
-                      p2pReaderName(),
-                      " asyncDistributionTimeout=" + this.asyncDistributionTimeout
-                          + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                          + " asyncMaxQueueSize="
-                          + (this.asyncMaxQueueSize / (1024 * 1024)));
-                }
-                // read the product version ordinal for on-the-fly serialization
-                // transformations (for rolling upgrades)
-                this.remoteVersion = Version.readVersion(dis, true);
-              }
-              notifyHandshakeWaiter(true);
-            } else {
-              byte b = dis.readByte();
-              if (b != 0) {
-                throw new IllegalStateException(
-                    String.format(
-                        "Detected old version (pre 5.0.1) of GemFire or non-GemFire during handshake due to initial byte being %s",
-                        new Byte(b)));
-              }
-              byte handshakeByte = dis.readByte();
-              if (handshakeByte != HANDSHAKE_VERSION) {
-                throw new IllegalStateException(
-                    String.format(
-                        "Detected wrong version of GemFire product during handshake. Expected %s but found %s",
-
-                        new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handshakeByte)}));
-              }
-              InternalDistributedMember remote = DSFIDFactory.readInternalDistributedMember(dis);
-              setRemoteAddr(remote);
-              Thread.currentThread().setName(String.format("P2P message reader for %s on port %s",
-                  this.remoteAddr, this.socket.getPort()));
-              this.sharedResource = dis.readBoolean();
-              this.preserveOrder = dis.readBoolean();
-              this.uniqueId = dis.readLong();
-              // read the product version ordinal for on-the-fly serialization
-              // transformations (for rolling upgrades)
-              this.remoteVersion = Version.readVersion(dis, true);
-              int dominoNumber = 0;
-              if (this.remoteVersion == null
-                  || (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
-                dominoNumber = dis.readInt();
-                if (this.sharedResource) {
-                  dominoNumber = 0;
-                }
-                dominoCount.set(dominoNumber);
-                // this.senderName = dis.readUTF();
-                setThreadName(dominoNumber);
-              }
-
-              if (!this.sharedResource) {
-                if (tipDomino()) {
-                  logger
-                      .info("thread owned receiver forcing itself to send on thread owned sockets");
-                  // bug #49565 - if domino count is >= 2 use shared resources.
-                  // Also see DistributedCacheOperation#supportsDirectAck
-                } else { // if (dominoNumber < 2){
-                  ConnectionTable.threadWantsOwnResources();
-                  if (logger.isDebugEnabled()) {
-                    logger.debug(
-                        "thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets",
-                        dominoNumber);
-                  }
-                  // } else {
-                  // ConnectionTable.threadWantsSharedResources();
-                  // logger.fine("thread-owned receiver with domino count of " + dominoNumber + "
-                  // will prefer shared sockets");
-                }
-                this.conduit.getStats().incThreadOwnedReceivers(1L, dominoNumber);
-              }
-
-              if (logger.isDebugEnabled()) {
-                logger.debug("{} remoteAddr is {} {}", p2pReaderName(), this.remoteAddr,
-                    (this.remoteVersion != null ? " (" + this.remoteVersion + ')' : ""));
-              }
-
-              String authInit = System.getProperty(
-                  DistributionConfigImpl.SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
-              boolean isSecure = authInit != null && authInit.length() != 0;
-
-              if (isSecure) {
-                // ARB: wait till member authentication has been confirmed?
-                if (owner.getConduit().waitForMembershipCheck(this.remoteAddr)) {
-                  sendOKHandshakeReply(); // fix for bug 33224
-                  notifyHandshakeWaiter(true);
-                } else {
-                  // ARB: throw exception??
-                  notifyHandshakeWaiter(false);
-                  logger.warn("{} timed out during a membership check.",
-                      p2pReaderName());
-                }
-              } else {
-                sendOKHandshakeReply(); // fix for bug 33224
-                notifyHandshakeWaiter(true);
-              }
-            }
-            if (!this.isReceiver && (this.handshakeRead || this.handshakeCancelled)) {
-              if (logger.isDebugEnabled()) {
-                if (this.handshakeRead) {
-                  logger.debug("{} handshake has been read {}", p2pReaderName(), this);
-                } else {
-                  logger.debug("{} handshake has been cancelled {}", p2pReaderName(), this);
-                }
-              }
-              // Once we have read the handshake the reader can go away
-              break;
-            }
-            continue;
-          }
-        } catch (InterruptedException e) {
-          interrupted = true;
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
-          logger.fatal(String.format("%s Stray interrupt reading message", p2pReaderName()), e);
-          continue;
-        } catch (Exception ioe) {
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ioe); // bug 37101
-          if (!stopped) {
-            logger.fatal(String.format("%s Error reading message", p2pReaderName()), ioe);
-          }
-          continue;
-        } finally {
-          if (interrupted) {
-            Thread.currentThread().interrupt();
-          }
-        }
-      } catch (CancelException e) {
-        if (logger.isDebugEnabled()) {
-          String ccMsg = p2pReaderName() + " Cancelled: " + this;
-          if (e.getMessage() != null) {
-            ccMsg += ": " + e.getMessage();
-          }
-          logger.debug(ccMsg);
-        }
-        this.readerShuttingDown = true;
-        try {
-          requestClose(
-              String.format("CacheClosed in channel read: %s", e));
-        } catch (Exception ex) {
-        }
-        this.stopped = true;
-      } catch (IOException io) {
-        boolean closed = isSocketClosed() || "Socket closed".equalsIgnoreCase(io.getMessage()); // needed
-                                                                                                // for
-                                                                                                // Solaris
-                                                                                                // jdk
-                                                                                                // 1.4.2_08
-        if (!closed) {
-          if (logger.isDebugEnabled() && !isIgnorableIOException(io)) {
-            logger.debug("{} io exception for {}", p2pReaderName(), this, io);
-          }
-        }
-        this.readerShuttingDown = true;
-        try {
-          requestClose(String.format("IOException received: %s", io));
-        } catch (Exception ex) {
-        }
-
-        if (closed) {
-          stopped = true;
-        } else {
-          // sleep a bit to avoid a hot error loop
-          try {
-            Thread.sleep(1000);
-          } catch (InterruptedException ie) {
-            Thread.currentThread().interrupt();
-            if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-              return;
-            }
-            break;
-          }
-        }
-      } // IOException
-      catch (Exception e) {
-        if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-          return; // bug 37101
-        }
-        if (!stopped && !(e instanceof InterruptedException)) {
-          logger.fatal(String.format("%s exception received",
-              p2pReaderName()), e);
-        }
-        if (isSocketClosed()) {
-          stopped = true;
-        } else {
-          this.readerShuttingDown = true;
-          try {
-            requestClose(String.format("%s exception received", e));
-          } catch (Exception ex) {
-          }
-
-          // sleep a bit to avoid a hot error loop
-          try {
-            Thread.sleep(1000);
-          } catch (InterruptedException ie) {
-            Thread.currentThread().interrupt();
-            break;
-          }
-        }
-      }
-    }
-  }
-  int readFully(InputStream input, byte[] buffer, int len) throws IOException {
+  void readFully(InputStream input, byte[] buffer, int len) throws IOException {
-          } catch (Exception ex) {
+          } catch (Exception ignored) {
-          return -1;
+          return;
-        } catch (Exception ex) {
+        } catch (Exception ignored) {
-    return len;
-  public void sendPreserialized(ByteBuffer buffer, boolean cacheContentChanges,
+  void sendPreserialized(ByteBuffer buffer, boolean cacheContentChanges,
-      if (useNIO()) {
-        SocketChannel channel = getSocket().getChannel();
-        nioWriteFully(channel, buffer, false, msg);
-      } else {
-        if (buffer.hasArray()) {
-          this.output.write(buffer.array(), buffer.arrayOffset(),
-              buffer.limit() - buffer.position());
-        } else {
-          byte[] bytesToWrite = getBytesToWrite(buffer);
-          synchronized (outLock) {
-            this.output.write(bytesToWrite);
-            this.output.flush();
-          }
-        }
-      }
+      SocketChannel channel = getSocket().getChannel();
+      writeFully(channel, buffer, false, msg);
-  protected void setSharedUnorderedForTest() {
+  void setSharedUnorderedForTest() {
-  public synchronized void scheduleAckTimeouts() {
+  synchronized void scheduleAckTimeouts() {
-  protected boolean doSevereAlertProcessing() {
+  private boolean doSevereAlertProcessing() {
-          Long.valueOf((ackWaitTimeout + ackSATimeout) / 1000),
+          (ackWaitTimeout + ackSATimeout) / 1000L,
-          Long.valueOf(ackWaitTimeout / 1000), getRemoteAddress(), ackThreadName);
+          ackWaitTimeout / 1000L, getRemoteAddress(), ackThreadName);
-  private static byte[] getBytesToWrite(ByteBuffer buffer) {
-    byte[] bytesToWrite = new byte[buffer.limit()];
-    buffer.get(bytesToWrite);
-    return bytesToWrite;
-  }
-
-      startNioPusher();
+      startMessagePusher();
-  private final Object nioPusherSync = new Object();
+  private final Object pusherSync = new Object();
-  private void startNioPusher() {
-    synchronized (this.nioPusherSync) {
+  private void startMessagePusher() {
+    synchronized (this.pusherSync) {
-          this.nioPusherSync.wait(); // spurious wakeup ok
+          this.pusherSync.wait(); // spurious wakeup ok
-          new LoggingThread("P2P async pusher to " + this.remoteAddr, this::runNioPusher);
+          new LoggingThread("P2P async pusher to " + this.remoteAddr, this::runMessagePusher);
-  protected void runNioPusher() {
+  private void runMessagePusher() {
+                  logger.debug("closing socket", new Exception("closing socket"));
+                  ioFilter.close(s.getChannel());
-              nioWriteFully(channel, bb, true, null);
+              writeFully(channel, bb, true, null);
-            new Object[] {this, ex});
+            this, ex);
-          logger.debug("runNioPusher terminated id={} from {}/{}", conduitIdStr, remoteAddr,
+          logger.debug("runMessagePusher terminated id={} from {}/{}", conduitIdStr, remoteAddr,
-      synchronized (this.nioPusherSync) {
+      synchronized (this.pusherSync) {
-        this.nioPusherSync.notify();
+        this.pusherSync.notify();
+          ByteBuffer wrappedBuffer = ioFilter.wrap(buffer);
-              amtWritten = channel.write(buffer);
+              amtWritten = channel.write(wrappedBuffer);
-                  if (handleBlockedWrite(buffer, msg)) {
+                  if (handleBlockedWrite(wrappedBuffer, msg)) {
-                      Long.valueOf(curQueuedBytes),
-                      Long.valueOf(this.asyncMaxQueueSize), this.remoteAddr);
+                      curQueuedBytes,
+                      this.asyncMaxQueueSize, this.remoteAddr);
-                      Long.valueOf(blockedMs),
-                      Integer.valueOf(this.asyncQueueTimeout), this.remoteAddr);
+                      blockedMs,
+                      this.asyncQueueTimeout, this.remoteAddr);
-          } while (buffer.remaining() > 0);
+          } while (wrappedBuffer.remaining() > 0);
-   * nioWriteFully implements a blocking write on a channel that is in non-blocking mode.
+   * writeFully implements a blocking write on a channel that is in non-blocking mode.
-  protected void nioWriteFully(SocketChannel channel, ByteBuffer buffer, boolean forceAsync,
+  void writeFully(SocketChannel channel, ByteBuffer buffer, boolean forceAsync,
+        ByteBuffer wrappedBuffer = ioFilter.wrap(buffer);
+
-            amtWritten = channel.write(buffer);
+            amtWritten = channel.write(wrappedBuffer);
-        } while (buffer.remaining() > 0);
+        } while (wrappedBuffer.remaining() > 0);
+
-  protected ByteBuffer getNIOBuffer() {
-    final DMStats stats = this.owner.getConduit().getStats();
-    if (nioInputBuffer == null) {
+  private ByteBuffer getInputBuffer() {
+    if (inputBuffer == null) {
-      nioInputBuffer = Buffers.acquireReceiveBuffer(allocSize, stats);
+      inputBuffer = Buffers.acquireReceiveBuffer(allocSize, this.owner.getConduit().getStats());
-    return nioInputBuffer;
+    return inputBuffer;
-  protected static final byte STATE_IDLE = 0;
+  private static final byte STATE_IDLE = 0;
-  protected static final byte STATE_SENDING = 1;
+  private static final byte STATE_SENDING = 1;
-  protected static final byte STATE_POST_SENDING = 2;
+  private static final byte STATE_POST_SENDING = 2;
-  protected static final byte STATE_READING_ACK = 3;
+  private static final byte STATE_READING_ACK = 3;
-  protected static final byte STATE_RECEIVED_ACK = 4;
+  private static final byte STATE_RECEIVED_ACK = 4;
-  protected static final byte STATE_READING = 5;
+  private static final byte STATE_READING = 5;
-  protected volatile boolean ackTimedOut;
+  private volatile boolean ackTimedOut;
-   * @param msToWait number of milliseconds to wait for an ack. If 0 then wait forever.
-   * @param msInterval interval between checks
-   * @throws SocketTimeoutException if msToWait expires.
-   * @throws ConnectionException if ack is not received (fixes bug 34312)
+   * @throws SocketTimeoutException if wait expires.
+   * @throws ConnectionException if ack is not received
-  public void readAck(final int msToWait, final long msInterval,
-      final DirectReplyProcessor processor) throws SocketTimeoutException, ConnectionException {
+  public void readAck(final DirectReplyProcessor processor)
+      throws SocketTimeoutException, ConnectionException {
-      if (useNIO()) {
-        msgReader = new NIOMsgReader(this, version);
-      } else {
-        msgReader = new OioMsgReader(this, version);
-      }
+      msgReader = new MsgReader(this, ioFilter, getInputBuffer(), version);
-      if (header.getNioMessageType() == NORMAL_MSG_TYPE) {
+      if (header.getMessageType() == NORMAL_MSG_TYPE) {
-        len = header.getNioMessageLength();
+        len = header.getMessageLength();
-        MsgDestreamer destreamer = obtainMsgDestreamer(header.getNioMessageId(), version);
-        while (header.getNioMessageType() == CHUNKED_MSG_TYPE) {
+        MsgDestreamer destreamer = obtainMsgDestreamer(header.getMessageId(), version);
+        while (header.getMessageType() == CHUNKED_MSG_TYPE) {
-        releaseMsgDestreamer(header.getNioMessageId(), destreamer);
+        releaseMsgDestreamer(header.getMessageId(), destreamer);
-  private void processNIOBuffer() throws ConnectionException, IOException {
-    if (nioInputBuffer != null) {
-      nioInputBuffer.flip();
-    }
+  private void processInputBuffer() throws ConnectionException, IOException {
+    inputBuffer.flip();
+
+    ByteBuffer peerDataBuffer = ioFilter.unwrap(inputBuffer);
+    peerDataBuffer.flip();
+
-      int remaining = nioInputBuffer.remaining();
-      if (nioLengthSet || remaining >= MSG_HEADER_BYTES) {
-        if (!nioLengthSet) {
-          int headerStartPos = nioInputBuffer.position();
-          nioMessageLength = nioInputBuffer.getInt();
-          /* nioMessageVersion = */ calcHdrVersion(nioMessageLength);
-          nioMessageLength = calcMsgByteSize(nioMessageLength);
-          nioMessageType = nioInputBuffer.get();
-          nioMsgId = nioInputBuffer.getShort();
-          directAck = (nioMessageType & DIRECT_ACK_BIT) != 0;
-          if (directAck) {
-            nioMessageType &= ~DIRECT_ACK_BIT; // clear the ack bit
-          }
-          // Following validation fixes bug 31145
-          if (!validMsgType(nioMessageType)) {
-            Integer nioMessageTypeInteger = Integer.valueOf(nioMessageType);
-            logger.fatal("Unknown P2P message type: {}", nioMessageTypeInteger);
-            this.readerShuttingDown = true;
-            requestClose(String.format("Unknown P2P message type: %s",
-                nioMessageTypeInteger));
+      int remaining = peerDataBuffer.remaining();
+      if (lengthSet || remaining >= MSG_HEADER_BYTES) {
+        if (!lengthSet) {
+          if (readMessageHeader(peerDataBuffer)) {
-          nioLengthSet = true;
-          // keep the header "in" the buffer until we have read the entire msg.
-          // Trust me: this will reduce copying on large messages.
-          nioInputBuffer.position(headerStartPos);
-        if (remaining >= nioMessageLength + MSG_HEADER_BYTES) {
-          nioLengthSet = false;
-          nioInputBuffer.position(nioInputBuffer.position() + MSG_HEADER_BYTES);
+        if (remaining >= messageLength + MSG_HEADER_BYTES) {
+          lengthSet = false;
+          peerDataBuffer.position(peerDataBuffer.position() + MSG_HEADER_BYTES);
-          int startPos = nioInputBuffer.position();
-          int oldLimit = nioInputBuffer.limit();
-          nioInputBuffer.limit(startPos + nioMessageLength);
+          int startPos = peerDataBuffer.position();
+          int oldLimit = peerDataBuffer.limit();
+          peerDataBuffer.limit(startPos + messageLength);
+
-            if (nioMessageType == NORMAL_MSG_TYPE) {
-              this.owner.getConduit().getStats().incMessagesBeingReceived(true, nioMessageLength);
-              ByteBufferInputStream bbis =
-                  remoteVersion == null ? new ByteBufferInputStream(nioInputBuffer)
-                      : new VersionedByteBufferInputStream(nioInputBuffer, remoteVersion);
-              DistributionMessage msg = null;
-              try {
-                ReplyProcessor21.initMessageRPId();
-                // add serialization stats
-                long startSer = this.owner.getConduit().getStats().startMsgDeserialization();
-                msg = (DistributionMessage) InternalDataSerializer.readDSFID(bbis);
-                this.owner.getConduit().getStats().endMsgDeserialization(startSer);
-                if (bbis.available() != 0) {
-                  logger.warn("Message deserialization of {} did not read {} bytes.",
-                      msg, Integer.valueOf(bbis.available()));
-                }
-                try {
-                  if (!dispatchMessage(msg, nioMessageLength, directAck)) {
-                    directAck = false;
-                  }
-                } catch (MemberShunnedException e) {
-                  directAck = false; // don't respond (bug39117)
-                } catch (Exception de) {
-                  this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
-                  logger.fatal("Error dispatching message", de);
-                } catch (ThreadDeath td) {
-                  throw td;
-                } catch (VirtualMachineError err) {
-                  SystemFailure.initiateFailure(err);
-                  // If this ever returns, rethrow the error. We're poisoned
-                  // now, so don't let this thread continue.
-                  throw err;
-                } catch (Throwable t) {
-                  // Whenever you catch Error or Throwable, you must also
-                  // catch VirtualMachineError (see above). However, there is
-                  // _still_ a possibility that you are dealing with a cascading
-                  // error condition, so you also need to check to see if the JVM
-                  // is still usable:
-                  SystemFailure.checkFailure();
-                  logger.fatal("Throwable dispatching message", t);
-                }
-              } catch (VirtualMachineError err) {
-                SystemFailure.initiateFailure(err);
-                // If this ever returns, rethrow the error. We're poisoned
-                // now, so don't let this thread continue.
-                throw err;
-              } catch (Throwable t) {
-                // Whenever you catch Error or Throwable, you must also
-                // catch VirtualMachineError (see above). However, there is
-                // _still_ a possibility that you are dealing with a cascading
-                // error condition, so you also need to check to see if the JVM
-                // is still usable:
-                SystemFailure.checkFailure();
-                sendFailureReply(ReplyProcessor21.getMessageRPId(),
-                    "Error deserializing message", t,
-                    directAck);
-                if (t instanceof ThreadDeath) {
-                  throw (ThreadDeath) t;
-                }
-                if (t instanceof CancelException) {
-                  if (!(t instanceof CacheClosedException)) {
-                    // Just log a message if we had trouble deserializing due to
-                    // CacheClosedException; see bug 43543
-                    throw (CancelException) t;
-                  }
-                }
-                logger.fatal("Error deserializing message", t);
-              } finally {
-                ReplyProcessor21.clearMessageRPId();
-              }
-            } else if (nioMessageType == CHUNKED_MSG_TYPE) {
-              MsgDestreamer md = obtainMsgDestreamer(nioMsgId, remoteVersion);
-              this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
-                  nioMessageLength);
-              try {
-                md.addChunk(nioInputBuffer, nioMessageLength);
-              } catch (IOException ex) {
-                logger.fatal("Failed handling chunk message", ex);
-              }
-            } else /* (nioMessageType == END_CHUNKED_MSG_TYPE) */ {
-              // logger.info("END_CHUNK msgId="+nioMsgId);
-              MsgDestreamer md = obtainMsgDestreamer(nioMsgId, remoteVersion);
-              this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
-                  nioMessageLength);
-              try {
-                md.addChunk(nioInputBuffer, nioMessageLength);
-              } catch (IOException ex) {
-                logger.fatal("Failed handling end chunk message", ex);
-              }
-              DistributionMessage msg = null;
-              int msgLength = 0;
-              String failureMsg = null;
-              Throwable failureEx = null;
-              int rpId = 0;
-              boolean interrupted = false;
-              try {
-                msg = md.getMessage();
-              } catch (ClassNotFoundException ex) {
-                this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-                failureMsg = "ClassNotFound deserializing message";
-                failureEx = ex;
-                rpId = md.getRPid();
-                logger.fatal("ClassNotFound deserializing message: {}", ex.toString());
-              } catch (IOException ex) {
-                this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-                failureMsg = "IOException deserializing message";
-                failureEx = ex;
-                rpId = md.getRPid();
-                logger.fatal("IOException deserializing message", failureEx);
-              } catch (InterruptedException ex) {
-                interrupted = true;
-                this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-              } catch (VirtualMachineError err) {
-                SystemFailure.initiateFailure(err);
-                // If this ever returns, rethrow the error. We're poisoned
-                // now, so don't let this thread continue.
-                throw err;
-              } catch (Throwable ex) {
-                // Whenever you catch Error or Throwable, you must also
-                // catch VirtualMachineError (see above). However, there is
-                // _still_ a possibility that you are dealing with a cascading
-                // error condition, so you also need to check to see if the JVM
-                // is still usable:
-                SystemFailure.checkFailure();
-                this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-                this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-                failureMsg = "Unexpected failure deserializing message";
-                failureEx = ex;
-                rpId = md.getRPid();
-                logger.fatal("Unexpected failure deserializing message",
-                    failureEx);
-              } finally {
-                msgLength = md.size();
-                releaseMsgDestreamer(nioMsgId, md);
-                if (interrupted) {
-                  Thread.currentThread().interrupt();
-                }
-              }
-              if (msg != null) {
-                try {
-                  if (!dispatchMessage(msg, msgLength, directAck)) {
-                    directAck = false;
-                  }
-                } catch (MemberShunnedException e) {
-                  // not a member anymore - don't reply
-                  directAck = false;
-                } catch (Exception de) {
-                  this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
-                  logger.fatal("Error dispatching message", de);
-                } catch (ThreadDeath td) {
-                  throw td;
-                } catch (VirtualMachineError err) {
-                  SystemFailure.initiateFailure(err);
-                  // If this ever returns, rethrow the error. We're poisoned
-                  // now, so don't let this thread continue.
-                  throw err;
-                } catch (Throwable t) {
-                  // Whenever you catch Error or Throwable, you must also
-                  // catch VirtualMachineError (see above). However, there is
-                  // _still_ a possibility that you are dealing with a cascading
-                  // error condition, so you also need to check to see if the JVM
-                  // is still usable:
-                  SystemFailure.checkFailure();
-                  logger.fatal("Throwable dispatching message", t);
-                }
-              } else if (failureEx != null) {
-                sendFailureReply(rpId, failureMsg, failureEx, directAck);
-              }
-            }
+            readMessage(peerDataBuffer);
+
-            // read HANDSHAKE
-            ByteBufferInputStream bbis = new ByteBufferInputStream(nioInputBuffer);
+            ByteBufferInputStream bbis = new ByteBufferInputStream(peerDataBuffer);
-              try {
-                this.replyCode = dis.readUnsignedByte();
-                if (this.replyCode == REPLY_CODE_OK_WITH_ASYNC_INFO) {
-                  this.asyncDistributionTimeout = dis.readInt();
-                  this.asyncQueueTimeout = dis.readInt();
-                  this.asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
-                  if (this.asyncDistributionTimeout != 0) {
-                    logger.info("{} async configuration received {}.",
-                        p2pReaderName(),
-                        " asyncDistributionTimeout=" + this.asyncDistributionTimeout
-                            + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                            + " asyncMaxQueueSize="
-                            + (this.asyncMaxQueueSize / (1024 * 1024)));
-                  }
-                  // read the product version ordinal for on-the-fly serialization
-                  // transformations (for rolling upgrades)
-                  this.remoteVersion = Version.readVersion(dis, true);
-                }
-              } catch (Exception e) {
-                this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
-                logger.fatal("Error deserializing P2P handshake reply", e);
-                this.readerShuttingDown = true;
-                requestClose("Error deserializing P2P handshake reply");
-                return;
-              } catch (ThreadDeath td) {
-                throw td;
-              } catch (VirtualMachineError err) {
-                SystemFailure.initiateFailure(err);
-                // If this ever returns, rethrow the error. We're poisoned
-                // now, so don't let this thread continue.
-                throw err;
-              } catch (Throwable t) {
-                // Whenever you catch Error or Throwable, you must also
-                // catch VirtualMachineError (see above). However, there is
-                // _still_ a possibility that you are dealing with a cascading
-                // error condition, so you also need to check to see if the JVM
-                // is still usable:
-                SystemFailure.checkFailure();
-                logger.fatal("Throwable deserializing P2P handshake reply",
-                    t);
-                this.readerShuttingDown = true;
-                requestClose("Throwable deserializing P2P handshake reply");
+              if (readHandshakeForSender(dis)) {
+                ioFilter.doneReading(peerDataBuffer);
-              if (this.replyCode != REPLY_CODE_OK
-                  && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
-                String err =
-                    "Unknown handshake reply code: %s nioMessageLength: %s";
-                Object[] errArgs = new Object[] {Integer.valueOf(this.replyCode),
-                    Integer.valueOf(nioMessageLength)};
-                if (replyCode == 0 && logger.isDebugEnabled()) { // bug 37113
-                  logger.debug(
-                      String.format(err, errArgs) + " (peer probably departed ungracefully)");
-                } else {
-                  logger.fatal(err, errArgs);
-                }
-                this.readerShuttingDown = true;
-                requestClose(String.format(err, errArgs));
-                return;
-              }
-              notifyHandshakeWaiter(true);
-              try {
-                byte b = dis.readByte();
-                if (b != 0) {
-                  throw new IllegalStateException(
-                      String.format(
-                          "Detected old version (pre 5.0.1) of GemFire or non-GemFire during handshake due to initial byte being %s",
-                          new Byte(b)));
-                }
-                byte handshakeByte = dis.readByte();
-                if (handshakeByte != HANDSHAKE_VERSION) {
-                  throw new IllegalStateException(
-                      String.format(
-                          "Detected wrong version of GemFire product during handshake. Expected %s but found %s",
-
-                          new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handshakeByte)}));
-                }
-                InternalDistributedMember remote = DSFIDFactory.readInternalDistributedMember(dis);
-                setRemoteAddr(remote);
-                this.sharedResource = dis.readBoolean();
-                this.preserveOrder = dis.readBoolean();
-                this.uniqueId = dis.readLong();
-                // read the product version ordinal for on-the-fly serialization
-                // transformations (for rolling upgrades)
-                this.remoteVersion = Version.readVersion(dis, true);
-                int dominoNumber = 0;
-                if (this.remoteVersion == null
-                    || (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
-                  dominoNumber = dis.readInt();
-                  if (this.sharedResource) {
-                    dominoNumber = 0;
-                  }
-                  dominoCount.set(dominoNumber);
-                  // this.senderName = dis.readUTF();
-                }
-                if (!this.sharedResource) {
-                  if (tipDomino()) {
-                    logger.info(
-                        "thread owned receiver forcing itself to send on thread owned sockets");
-                    // bug #49565 - if domino count is >= 2 use shared resources.
-                    // Also see DistributedCacheOperation#supportsDirectAck
-                  } else { // if (dominoNumber < 2) {
-                    ConnectionTable.threadWantsOwnResources();
-                    if (logger.isDebugEnabled()) {
-                      logger.debug(
-                          "thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets",
-                          dominoNumber);
-                    }
-                    // } else {
-                    // ConnectionTable.threadWantsSharedResources();
-                  }
-                  this.conduit.getStats().incThreadOwnedReceivers(1L, dominoNumber);
-                  // Because this thread is not shared resource, it will be used for direct
-                  // ack. Direct ack messages can be large. This call will resize the send
-                  // buffer.
-                  setSendBufferSize(this.socket);
-                }
-                // String name = owner.getDM().getConfig().getName();
-                // if (name == null) {
-                // name = "pid="+OSProcess.getId();
-                // }
-                setThreadName(dominoNumber);
-              } catch (Exception e) {
-                this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e); // bug 37101
-                logger.fatal("Error deserializing P2P handshake message", e);
-                this.readerShuttingDown = true;
-                requestClose("Error deserializing P2P handshake message");
-                return;
-              }
-              if (logger.isDebugEnabled()) {
-                logger.debug("P2P handshake remoteAddr is {}{}", this.remoteAddr,
-                    (this.remoteVersion != null ? " (" + this.remoteVersion + ')' : ""));
-              }
-              try {
-                String authInit = System.getProperty(
-                    DistributionConfigImpl.SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
-                boolean isSecure = authInit != null && authInit.length() != 0;
-
-                if (isSecure) {
-                  if (owner.getConduit().waitForMembershipCheck(this.remoteAddr)) {
-                    sendOKHandshakeReply(); // fix for bug 33224
-                    notifyHandshakeWaiter(true);
-                  } else {
-                    // ARB: check if we need notifyHandshakeWaiter() call.
-                    notifyHandshakeWaiter(false);
-                    logger.warn("{} timed out during a membership check.",
-                        p2pReaderName());
-                    return;
-                  }
-                } else {
-                  sendOKHandshakeReply(); // fix for bug 33224
-                  try {
-                    notifyHandshakeWaiter(true);
-                  } catch (Exception e) {
-                    logger.fatal("Uncaught exception from listener", e);
-                  }
-                }
-              } catch (IOException ex) {
-                final String err = "Failed sending handshake reply";
-                if (logger.isDebugEnabled()) {
-                  logger.debug(err, ex);
-                }
-                this.readerShuttingDown = true;
-                requestClose(err + ": " + ex);
+              if (readHandshakeForReceiver(dis)) {
+                ioFilter.doneReading(peerDataBuffer);
-          nioInputBuffer.limit(oldLimit);
-          nioInputBuffer.position(startPos + nioMessageLength);
+          peerDataBuffer.limit(oldLimit);
+          peerDataBuffer.position(startPos + messageLength);
-          compactOrResizeBuffer(nioMessageLength);
+          if (TCPConduit.useSSL) {
+            ioFilter.doneReading(peerDataBuffer);
+          } else {
+            compactOrResizeBuffer(messageLength);
+          }
+        ioFilter.doneReading(peerDataBuffer);
-        if (nioInputBuffer.position() != 0) {
-          nioInputBuffer.compact();
-        } else {
-          nioInputBuffer.position(nioInputBuffer.limit());
-          nioInputBuffer.limit(nioInputBuffer.capacity());
-        }
+  private boolean readHandshakeForReceiver(DataInputStream dis) {
+    try {
+      byte b = dis.readByte();
+      if (b != 0) {
+        throw new IllegalStateException(
+            String.format(
+                "Detected old version (pre 5.0.1) of GemFire or non-GemFire during handshake due to initial byte being %s",
+                b));
+      }
+      byte handshakeByte = dis.readByte();
+      if (handshakeByte != HANDSHAKE_VERSION) {
+        throw new IllegalStateException(
+            String.format(
+                "Detected wrong version of GemFire product during handshake. Expected %s but found %s",
+                HANDSHAKE_VERSION, handshakeByte));
+      }
+      InternalDistributedMember remote = DSFIDFactory.readInternalDistributedMember(dis);
+      setRemoteAddr(remote);
+      this.sharedResource = dis.readBoolean();
+      this.preserveOrder = dis.readBoolean();
+      this.uniqueId = dis.readLong();
+      // read the product version ordinal for on-the-fly serialization
+      // transformations (for rolling upgrades)
+      this.remoteVersion = Version.readVersion(dis, true);
+      int dominoNumber = 0;
+      if (this.remoteVersion == null
+          || (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
+        dominoNumber = dis.readInt();
+        if (this.sharedResource) {
+          dominoNumber = 0;
+        }
+        dominoCount.set(dominoNumber);
+        // this.senderName = dis.readUTF();
+      }
+      if (!this.sharedResource) {
+        if (tipDomino()) {
+          logger.info(
+              "thread owned receiver forcing itself to send on thread owned sockets");
+          // bug #49565 - if domino count is >= 2 use shared resources.
+          // Also see DistributedCacheOperation#supportsDirectAck
+        } else { // if (dominoNumber < 2) {
+          ConnectionTable.threadWantsOwnResources();
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets",
+                dominoNumber);
+          }
+          // } else {
+          // ConnectionTable.threadWantsSharedResources();
+        }
+        this.conduit.getStats().incThreadOwnedReceivers(1L, dominoNumber);
+        // Because this thread is not shared resource, it will be used for direct
+        // ack. Direct ack messages can be large. This call will resize the send
+        // buffer.
+        setSendBufferSize(this.socket);
+      }
+      // String name = owner.getDM().getConfig().getName();
+      // if (name == null) {
+      // name = "pid="+OSProcess.getId();
+      // }
+      setThreadName(dominoNumber);
+    } catch (Exception e) {
+      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e); // bug 37101
+      logger.fatal("Error deserializing P2P handshake message", e);
+      this.readerShuttingDown = true;
+      requestClose("Error deserializing P2P handshake message");
+      return true;
+    }
+    if (logger.isDebugEnabled()) {
+      logger.debug("P2P handshake remoteAddr is {}{}", this.remoteAddr,
+          (this.remoteVersion != null ? " (" + this.remoteVersion + ')' : ""));
+    }
+    try {
+      String authInit = System.getProperty(
+          DistributionConfigImpl.SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
+      boolean isSecure = authInit != null && authInit.length() != 0;
+
+      if (isSecure) {
+        if (owner.getConduit().waitForMembershipCheck(this.remoteAddr)) {
+          sendOKHandshakeReply(); // fix for bug 33224
+          notifyHandshakeWaiter(true);
+        } else {
+          // ARB: check if we need notifyHandshakeWaiter() call.
+          notifyHandshakeWaiter(false);
+          logger.warn("{} timed out during a membership check.",
+              p2pReaderName());
+          return true;
+        }
+      } else {
+        sendOKHandshakeReply(); // fix for bug 33224
+        try {
+          notifyHandshakeWaiter(true);
+        } catch (Exception e) {
+          logger.fatal("Uncaught exception from listener", e);
+        }
+      }
+      this.finishedConnecting = true;
+    } catch (IOException ex) {
+      final String err = "Failed sending handshake reply";
+      if (logger.isDebugEnabled()) {
+        logger.debug(err, ex);
+      }
+      this.readerShuttingDown = true;
+      requestClose(err + ": " + ex);
+      return true;
+    }
+    return false;
+  }
+
+  private boolean readMessageHeader(ByteBuffer peerDataBuffer) throws IOException {
+    int headerStartPos = peerDataBuffer.position();
+    messageLength = peerDataBuffer.getInt();
+    /* nioMessageVersion = */
+    calcHdrVersion(messageLength);
+    messageLength = calcMsgByteSize(messageLength);
+    messageType = peerDataBuffer.get();
+    messageId = peerDataBuffer.getShort();
+    directAck = (messageType & DIRECT_ACK_BIT) != 0;
+    if (directAck) {
+      messageType &= ~DIRECT_ACK_BIT; // clear the ack bit
+    }
+    // Following validation fixes bug 31145
+    if (!validMsgType(messageType)) {
+      Integer nioMessageTypeInteger = (int) messageType;
+      logger.fatal("Unknown P2P message type: {}", nioMessageTypeInteger);
+      this.readerShuttingDown = true;
+      requestClose(String.format("Unknown P2P message type: %s",
+          nioMessageTypeInteger));
+      return true;
+    }
+    lengthSet = true;
+    // keep the header "in" the buffer until we have read the entire msg.
+    // Trust me: this will reduce copying on large messages.
+    peerDataBuffer.position(headerStartPos);
+    return false;
+  }
+
+  private void readMessage(ByteBuffer peerDataBuffer) {
+    if (messageType == NORMAL_MSG_TYPE) {
+      this.owner.getConduit().getStats().incMessagesBeingReceived(true, messageLength);
+      ByteBufferInputStream bbis =
+          remoteVersion == null ? new ByteBufferInputStream(peerDataBuffer)
+              : new VersionedByteBufferInputStream(peerDataBuffer, remoteVersion);
+      DistributionMessage msg;
+      try {
+        ReplyProcessor21.initMessageRPId();
+        // add serialization stats
+        long startSer = this.owner.getConduit().getStats().startMsgDeserialization();
+        msg = (DistributionMessage) InternalDataSerializer.readDSFID(bbis);
+        this.owner.getConduit().getStats().endMsgDeserialization(startSer);
+        if (bbis.available() != 0) {
+          logger.warn("Message deserialization of {} did not read {} bytes.",
+              msg, bbis.available());
+        }
+        try {
+          if (!dispatchMessage(msg, messageLength, directAck)) {
+            directAck = false;
+          }
+        } catch (MemberShunnedException e) {
+          directAck = false; // don't respond (bug39117)
+        } catch (Exception de) {
+          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
+          logger.fatal("Error dispatching message", de);
+        } catch (ThreadDeath td) {
+          throw td;
+        } catch (VirtualMachineError err) {
+          SystemFailure.initiateFailure(err);
+          // If this ever returns, rethrow the error. We're poisoned
+          // now, so don't let this thread continue.
+          throw err;
+        } catch (Throwable t) {
+          // Whenever you catch Error or Throwable, you must also
+          // catch VirtualMachineError (see above). However, there is
+          // _still_ a possibility that you are dealing with a cascading
+          // error condition, so you also need to check to see if the JVM
+          // is still usable:
+          SystemFailure.checkFailure();
+          logger.fatal("Throwable dispatching message", t);
+        }
+      } catch (VirtualMachineError err) {
+        SystemFailure.initiateFailure(err);
+        // If this ever returns, rethrow the error. We're poisoned
+        // now, so don't let this thread continue.
+        throw err;
+      } catch (Throwable t) {
+        // Whenever you catch Error or Throwable, you must also
+        // catch VirtualMachineError (see above). However, there is
+        // _still_ a possibility that you are dealing with a cascading
+        // error condition, so you also need to check to see if the JVM
+        // is still usable:
+        SystemFailure.checkFailure();
+        sendFailureReply(ReplyProcessor21.getMessageRPId(),
+            "Error deserializing message", t,
+            directAck);
+        if (t instanceof ThreadDeath) {
+          throw (ThreadDeath) t;
+        }
+        if (t instanceof CancelException) {
+          if (!(t instanceof CacheClosedException)) {
+            // Just log a message if we had trouble deserializing due to
+            // CacheClosedException; see bug 43543
+            throw (CancelException) t;
+          }
+        }
+        logger.fatal("Error deserializing message", t);
+      } finally {
+        ReplyProcessor21.clearMessageRPId();
+      }
+    } else if (messageType == CHUNKED_MSG_TYPE) {
+      MsgDestreamer md = obtainMsgDestreamer(messageId, remoteVersion);
+      this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
+          messageLength);
+      try {
+        md.addChunk(peerDataBuffer, messageLength);
+      } catch (IOException ex) {
+      }
+    } else /* (nioMessageType == END_CHUNKED_MSG_TYPE) */ {
+      // logger.info("END_CHUNK msgId="+nioMsgId);
+      MsgDestreamer md = obtainMsgDestreamer(messageId, remoteVersion);
+      this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
+          messageLength);
+      try {
+        md.addChunk(peerDataBuffer, messageLength);
+      } catch (IOException ex) {
+        logger.fatal("Failed handling end chunk message", ex);
+      }
+      DistributionMessage msg = null;
+      int msgLength;
+      String failureMsg = null;
+      Throwable failureEx = null;
+      int rpId = 0;
+      boolean interrupted = false;
+      try {
+        msg = md.getMessage();
+      } catch (ClassNotFoundException ex) {
+        this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
+        failureMsg = "ClassNotFound deserializing message";
+        failureEx = ex;
+        rpId = md.getRPid();
+        logger.fatal("ClassNotFound deserializing message: {}", ex.toString());
+      } catch (IOException ex) {
+        this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
+        failureMsg = "IOException deserializing message";
+        failureEx = ex;
+        rpId = md.getRPid();
+        logger.fatal("IOException deserializing message", failureEx);
+      } catch (InterruptedException ex) {
+        interrupted = true;
+        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+      } catch (VirtualMachineError err) {
+        SystemFailure.initiateFailure(err);
+        // If this ever returns, rethrow the error. We're poisoned
+        // now, so don't let this thread continue.
+        throw err;
+      } catch (Throwable ex) {
+        // Whenever you catch Error or Throwable, you must also
+        // catch VirtualMachineError (see above). However, there is
+        // _still_ a possibility that you are dealing with a cascading
+        // error condition, so you also need to check to see if the JVM
+        // is still usable:
+        SystemFailure.checkFailure();
+        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+        this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
+        failureMsg = "Unexpected failure deserializing message";
+        failureEx = ex;
+        rpId = md.getRPid();
+        logger.fatal("Unexpected failure deserializing message",
+            failureEx);
+      } finally {
+        msgLength = md.size();
+        releaseMsgDestreamer(messageId, md);
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      if (msg != null) {
+        try {
+          if (!dispatchMessage(msg, msgLength, directAck)) {
+            directAck = false;
+          }
+        } catch (MemberShunnedException e) {
+          // not a member anymore - don't reply
+          directAck = false;
+        } catch (Exception de) {
+          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
+          logger.fatal("Error dispatching message", de);
+        } catch (ThreadDeath td) {
+          throw td;
+        } catch (VirtualMachineError err) {
+          SystemFailure.initiateFailure(err);
+          // If this ever returns, rethrow the error. We're poisoned
+          // now, so don't let this thread continue.
+          throw err;
+        } catch (Throwable t) {
+          // Whenever you catch Error or Throwable, you must also
+          // catch VirtualMachineError (see above). However, there is
+          // _still_ a possibility that you are dealing with a cascading
+          // error condition, so you also need to check to see if the JVM
+          // is still usable:
+          SystemFailure.checkFailure();
+          logger.fatal("Throwable dispatching message", t);
+        }
+      } else if (failureEx != null) {
+        sendFailureReply(rpId, failureMsg, failureEx, directAck);
+      }
+    }
+  }
+
+  private boolean readHandshakeForSender(DataInputStream dis) {
+    try {
+      this.replyCode = dis.readUnsignedByte();
+      if (this.replyCode == REPLY_CODE_OK_WITH_ASYNC_INFO) {
+        this.asyncDistributionTimeout = dis.readInt();
+        this.asyncQueueTimeout = dis.readInt();
+        this.asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
+        if (this.asyncDistributionTimeout != 0) {
+          logger.info("{} async configuration received {}.",
+              p2pReaderName(),
+              " asyncDistributionTimeout=" + this.asyncDistributionTimeout
+                  + " asyncQueueTimeout=" + this.asyncQueueTimeout
+                  + " asyncMaxQueueSize="
+                  + (this.asyncMaxQueueSize / (1024 * 1024)));
+        }
+        // read the product version ordinal for on-the-fly serialization
+        // transformations (for rolling upgrades)
+        this.remoteVersion = Version.readVersion(dis, true);
+      }
+    } catch (Exception e) {
+      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
+      logger.fatal("Error deserializing P2P handshake reply", e);
+      this.readerShuttingDown = true;
+      requestClose("Error deserializing P2P handshake reply");
+      return true;
+    } catch (ThreadDeath td) {
+      throw td;
+    } catch (VirtualMachineError err) {
+      SystemFailure.initiateFailure(err);
+      // If this ever returns, rethrow the error. We're poisoned
+      // now, so don't let this thread continue.
+      throw err;
+    } catch (Throwable t) {
+      // Whenever you catch Error or Throwable, you must also
+      // catch VirtualMachineError (see above). However, there is
+      // _still_ a possibility that you are dealing with a cascading
+      // error condition, so you also need to check to see if the JVM
+      // is still usable:
+      SystemFailure.checkFailure();
+      logger.fatal("Throwable deserializing P2P handshake reply",
+          t);
+      this.readerShuttingDown = true;
+      requestClose("Throwable deserializing P2P handshake reply");
+      return true;
+    }
+    if (this.replyCode != REPLY_CODE_OK
+        && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
+      String err =
+          "Unknown handshake reply code: %s nioMessageLength: %s";
+      Object[] errArgs = new Object[] {this.replyCode,
+          messageLength};
+      if (replyCode == 0 && logger.isDebugEnabled()) { // bug 37113
+        logger.debug(
+            String.format(err, errArgs) + " (peer probably departed ungracefully)");
+      } else {
+        logger.fatal(err, errArgs);
+      }
+      this.readerShuttingDown = true;
+      requestClose(String.format(err, errArgs));
+      return true;
+    }
+    notifyHandshakeWaiter(true);
+    return false;
+  }
+
-    final int oldBufferSize = nioInputBuffer.capacity();
+    final int oldBufferSize = inputBuffer.capacity();
-          Integer.valueOf(allocSize), Integer.valueOf(oldBufferSize));
-      ByteBuffer oldBuffer = nioInputBuffer;
-      nioInputBuffer = Buffers.acquireReceiveBuffer(allocSize, stats);
+          allocSize, oldBufferSize);
+      ByteBuffer oldBuffer = inputBuffer;
+      inputBuffer = Buffers.acquireReceiveBuffer(allocSize, stats);
-        nioInputBuffer.put(oldBuffer);
-        nioInputBuffer.position(oldByteCount);
+        inputBuffer.put(oldBuffer);
+        inputBuffer.position(oldByteCount);
-      if (nioInputBuffer.position() != 0) {
-        nioInputBuffer.compact();
+      if (inputBuffer.position() != 0) {
+        inputBuffer.compact();
-        nioInputBuffer.position(nioInputBuffer.limit());
-        nioInputBuffer.limit(nioInputBuffer.capacity());
+        inputBuffer.position(inputBuffer.limit());
+        inputBuffer.limit(inputBuffer.capacity());
-  public boolean isSocketClosed() {
+  boolean isSocketClosed() {
-  public boolean isReceiverStopped() {
+  boolean isReceiverStopped() {
-  public Version getRemoteVersion() {
+  Version getRemoteVersion() {
-  protected boolean getOriginatedHere() {
+  boolean getOriginatedHere() {
-  protected boolean getPreserveOrder() {
+  boolean getPreserveOrder() {
-  protected long getMessagesReceived() {
+  long getMessagesReceived() {
-  protected long getMessagesSent() {
+  long getMessagesSent() {
-  boolean nioChecked;
-  boolean useNIO;
-
-  private boolean useNIO() {
-    if (TCPConduit.useSSL) {
-      return false;
-    }
-    if (this.nioChecked) {
-      return this.useNIO;
-    }
-    this.nioChecked = true;
-    this.useNIO = this.owner.getConduit().useNIO();
-    if (!this.useNIO) {
-      return false;
-    }
-    // JDK bug 6230761 - NIO can't be used with IPv6 on Windows
-    if (this.socket != null && (this.socket.getInetAddress() instanceof Inet6Address)) {
-      String os = System.getProperty("os.name");
-      if (os != null) {
-        if (os.contains("Windows")) {
-          this.useNIO = false;
-        }
-      }
-    }
-    return this.useNIO;
-  }

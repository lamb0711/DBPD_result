GEODE-8182: change String commands to use one region (#5165)

* changed all String commands to use the function and to use a single region
* renabled tests ignored for GEODE-8182
* removed the RedisLockService since it is not used in the new data model
* removed the unused del methods on RedisSetCommands and RedisHashCommands
* removed the KeyRegistar since it was no longer needed with a single data region

Co-authored-by: Ray Ingles <ringles@pivotal.io>
-import org.apache.geode.cache.Region;
-import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.redis.internal.RedisData;
+import org.apache.geode.redis.internal.executor.string.RedisStringCommands;
+import org.apache.geode.redis.internal.executor.string.RedisStringCommandsFunctionExecutor;
-    try (@SuppressWarnings("unused")
-    AutoCloseableLock lockForOldKey = context.getLockService().lock(key)) {
-      try (@SuppressWarnings("unused")
-      AutoCloseableLock lockForNewKey = context.getLockService().lock(newKey)) {
-        RedisDataType redisDataType = context.getKeyRegistrar().getType(key);
-        if (redisDataType == null) {
-          command.setResponse(
-              Coder.getErrorResponse(context.getByteBufAllocator(),
-                  RedisConstants.ERROR_NO_SUCH_KEY));
-          return;
-        }
-        switch (redisDataType) {
-          case REDIS_STRING:
-            @SuppressWarnings("unchecked")
-            Region<ByteArrayWrapper, Object> region =
-                (Region<ByteArrayWrapper, Object>) context.getRegionProvider()
-                    .getRegionForType(redisDataType);
-            Object value = region.get(key);
-            context.getKeyRegistrar().register(newKey, redisDataType);
-            region.put(newKey, value);
-            removeEntry(key, context);
-            break;
-          case REDIS_HASH:
-            // TODO this all needs to be done atomically. Add RENAME support to RedisHashCommands
-            RedisHashCommands redisHashCommands =
-                new RedisHashCommandsFunctionExecutor(context.getRegionProvider().getDataRegion());
-            Collection<ByteArrayWrapper> fieldsAndValues = redisHashCommands.hgetall(key);
-            redisHashCommands.del(key);
-            redisHashCommands.del(newKey);
-            redisHashCommands.hset(newKey, new ArrayList<>(fieldsAndValues), false);
-            break;
-          case REDIS_SET:
-            // TODO this all needs to be done atomically. Add RENAME support to RedisSetCommands
-            RedisSetCommands redisSetCommands =
-                new RedisSetCommandsFunctionExecutor(context.getRegionProvider().getDataRegion());
-            Set<ByteArrayWrapper> members = redisSetCommands.smembers(key);
-            redisSetCommands.del(key);
-            redisSetCommands.del(newKey);
-            redisSetCommands.sadd(newKey, new ArrayList<>(members));
-            break;
-          default:
-            break;
-        }
-      } catch (InterruptedException e) {
-        Thread.currentThread().interrupt();
-        command.setResponse(
-            Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
-        return;
-      }
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
+    RedisData redisData = getDataRegion(context).get(key);
+    if (redisData == null) {
-          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+          Coder.getErrorResponse(context.getByteBufAllocator(),
+              RedisConstants.ERROR_NO_SUCH_KEY));
+    RedisDataType redisDataType = redisData.getType();
+    RedisKeyCommands redisKeyCommands = getRedisKeyCommands(context);
+    switch (redisDataType) {
+      case REDIS_STRING:
+        // TODO this all needs to be done atomically. Add RENAME support to RedisStringCommands
+        RedisStringCommands redisStringCommands =
+            new RedisStringCommandsFunctionExecutor(
+                context.getRegionProvider().getDataRegion());
+        ByteArrayWrapper value = redisStringCommands.get(key);
+        redisKeyCommands.del(key);
+        redisStringCommands.set(newKey, value, null);
+        break;
+      case REDIS_HASH:
+        // TODO this all needs to be done atomically. Add RENAME support to RedisHashCommands
+        RedisHashCommands redisHashCommands =
+            new RedisHashCommandsFunctionExecutor(context.getRegionProvider().getDataRegion());
+        Collection<ByteArrayWrapper> fieldsAndValues = redisHashCommands.hgetall(key);
+        redisKeyCommands.del(key);
+        redisKeyCommands.del(newKey);
+        redisHashCommands.hset(newKey, new ArrayList<>(fieldsAndValues), false);
+        break;
+      case REDIS_SET:
+        // TODO this all needs to be done atomically. Add RENAME support to RedisSetCommands
+        RedisSetCommands redisSetCommands =
+            new RedisSetCommandsFunctionExecutor(context.getRegionProvider().getDataRegion());
+        Set<ByteArrayWrapper> members = redisSetCommands.smembers(key);
+        redisKeyCommands.del(key);
+        redisKeyCommands.del(newKey);
+        redisSetCommands.sadd(newKey, new ArrayList<>(members));
+        break;
+      default:
+        break;
+    }

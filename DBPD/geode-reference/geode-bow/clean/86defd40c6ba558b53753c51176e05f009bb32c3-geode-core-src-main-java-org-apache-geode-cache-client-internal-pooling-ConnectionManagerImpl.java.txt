Feature/geode 6536 1: modify borrowConnection singleHop solution (#4753)

* GEODE-6536: Added retry in borrowConnection/single hop

* GEODE-6536: bug fix

* GEODE-6536: update after comments

* GEODE-6536: modify borrowConnection singleHop solution

* GEODE-6536: test update

* GEODE-6536: updated tests, and added parameter to desable timeout

* GEODE-6536: update of cachexml impacts

* GEODE-6536: remove cachexml restriction

* GEODE-6536: update default value and documentation
-    return timeout < System.nanoTime();
+    return timeout <= System.nanoTime();
-  /**
-   * Borrow a connection to a specific server. This task currently allows us to break the connection
-   * limit, because it is used by tasks from the background thread that shouldn't be constrained by
-   * the limit. They will only violate the limit by 1 connection, and that connection will be
-   * destroyed when returned to the pool.
-   */
-  public PooledConnection borrowConnection(ServerLocation server,
-      boolean onlyUseExistingCnx) throws AllConnectionsInUseException, NoAvailableServersException {
-    PooledConnection connection =
-        availableConnectionManager.useFirst((c) -> c.getServer().equals(server));
-    if (null != connection) {
-      return connection;
+  public PooledConnection borrowConnection(ServerLocation server, long acquireTimeout,
+      boolean onlyUseExistingCnx)
+      throws AllConnectionsInUseException, NoAvailableServersException,
+      ServerConnectivityException {
+
+    PooledConnection connection;
+    logger.trace("Connection borrowConnection single hop connection");
+
+    long waitStart = NOT_WAITING;
+    try {
+      long timeout = System.nanoTime() + MILLISECONDS.toNanos(acquireTimeout);
+      while (true) {
+
+        connection =
+            availableConnectionManager.useFirst((c) -> c.getServer().equals(server));
+
+        if (null != connection) {
+          return connection;
+        }
+
+        if (connectionAccounting.tryCreate()) {
+          try {
+            connection = createPooledConnection(server);
+
+            if (null != connection) {
+              return connection;
+            }
+            throw new NoAvailableServersException();
+          } finally {
+            if (connection == null) {
+              connectionAccounting.cancelTryCreate();
+              if (connectionAccounting.isUnderMinimum()) {
+                startBackgroundPrefill();
+              }
+            }
+          }
+        }
+
+        if (!onlyUseExistingCnx) {
+          connection = forceCreateConnection(server);
+          if (null != connection) {
+            return connection;
+          }
+          throw new ServerConnectivityException(BORROW_CONN_ERROR_MSG + server);
+        }
+
+        if (checkShutdownInterruptedOrTimeout(timeout)) {
+          break;
+        }
+
+        waitStart = beginConnectionWaitStatIfNotStarted(waitStart);
+
+        Thread.yield();
+      }
+    } finally {
+      endConnectionWaitStatIfStarted(waitStart);
-    if (onlyUseExistingCnx) {
-      throw new AllConnectionsInUseException();
-    }
+    cancelCriterion.checkCancelInProgress(null);
-    connection = forceCreateConnection(server);
-    if (null != connection) {
-      return connection;
-    }
-
-    throw new ServerConnectivityException(BORROW_CONN_ERROR_MSG + server);
+    throw new AllConnectionsInUseException();

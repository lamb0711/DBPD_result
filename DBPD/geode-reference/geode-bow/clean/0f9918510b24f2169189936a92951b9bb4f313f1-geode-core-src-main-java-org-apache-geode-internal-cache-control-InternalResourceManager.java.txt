GEODE-7953: Restore Redundancy Internal API (#4909)

* GEODE-7953: Restore Redundancy Internal API

- Add RestoreRedundancyOperation interface and Impl class
- Add RestoreRedundancyResults interface and Impl class
- Add RegionRedundancyStatus interface and Impl class
- Add accessor methods for RestoreRedundancyOperation to ResourceManager interface
- Replace manually-synchronized sets in InternalResourceManager with
ConcurrentHashMap
- Add stats for restore redundancy operations
- Add unit and DUnit tests for all the above

Authored-by: Donal Evans <doevans@pivotal.io>
-import java.util.HashSet;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.geode.cache.control.RestoreRedundancyOperation;
+import org.apache.geode.cache.control.RestoreRedundancyResults;
-  private Map<ResourceType, Set<ResourceListener>> listeners =
-      new HashMap<ResourceType, Set<ResourceListener>>();
+  private Map<ResourceType, Set<ResourceListener>> listeners = new HashMap<>();
-  // The set of in progress rebalance operations.
-  private final Set<RebalanceOperation> inProgressOperations = new HashSet<RebalanceOperation>();
-  private final Object inProgressOperationsLock = new Object();
+  // A map of in progress rebalance operations. The value is Boolean because ConcurrentHashMap does
+  // not support null values.
+  private final Map<RebalanceOperation, Boolean> inProgressRebalanceOperations =
+      new ConcurrentHashMap<>();
+
+  // A map of in progress restore redundancy completable futures. The value is Boolean because
+  // ConcurrentHashMap does not support null values.
+  private final Map<CompletableFuture<RestoreRedundancyResults>, Boolean> inProgressRedundancyOperations =
+      new ConcurrentHashMap<>();
-    synchronized (this.inProgressOperationsLock) {
-      return new HashSet<RebalanceOperation>(this.inProgressOperations);
-    }
+    return Collections.unmodifiableSet(inProgressRebalanceOperations.keySet());
-    synchronized (this.inProgressOperationsLock) {
-      this.inProgressOperations.add(op);
-    }
+    inProgressRebalanceOperations.put(op, Boolean.TRUE);
-    synchronized (this.inProgressOperationsLock) {
-      this.inProgressOperations.remove(op);
-    }
+    inProgressRebalanceOperations.remove(op);
+  }
+  @Override
+  public RestoreRedundancyOperation createRestoreRedundancyOperation() {
+    return new RestoreRedundancyOperationImpl(cache);
+  }
+
+  @Override
+  public Set<CompletableFuture<RestoreRedundancyResults>> getRestoreRedundancyFutures() {
+    return Collections.unmodifiableSet(inProgressRedundancyOperations.keySet());
+  }
+
+  void addInProgressRestoreRedundancy(
+      CompletableFuture<RestoreRedundancyResults> completableFuture) {
+    inProgressRedundancyOperations.put(completableFuture, Boolean.TRUE);
+  }
+
+  void removeInProgressRestoreRedundancy(
+      CompletableFuture<RestoreRedundancyResults> completableFuture) {
+    inProgressRedundancyOperations.remove(completableFuture);
-   *
-     *
-     *
-     *
-     *
-     *

GEODE-6883 Move the membership code into a separate gradle sub-project

This commit is focused on removing references to
InternalDistributedMember and DistributionMessage from "gms"
packages.

    GMS classes only refer to GMSMember
    GMS classes use GMSMembershipView.  NetView is now an interface
    GMS classes do not refer to DistributionMessage.  JGroupsMessenger
      expects GMSMessage instances.  Geode messages to be sent over UDP
      are wrapped in a GMSMessageAdapter.
    "gms" messages extend AbstractGMSMessage which implements GMSMessage
    GMSMembershipManager has an inner class that implements the GMS Manager
      interface and is now in the "adapter" package
    GMSMembershipManager translates GMSMembershipView into a MembershipView
      for the rest of Geode to use (this is the old NetView class)
    GMS instantiation allows us to inject the Manager into the new Services
      instance.
    Other adapter classes have been added to translate between Geode
      and GMS.

    GMSUtil has new methods for marshalling/unmarshalling
    InternalDistributedMember instances for backward-compatibility.
    GMSMember now has the same on-wire form as
    InternalDistributedMember.  This allows the GMS classes to
    deserialize a message from a pre-1.10 member whose code writes
    InternalDistributedMembers when serializing something like a
    JoinRequest.

-package org.apache.geode.distributed.internal.membership.gms.mgr;
+package org.apache.geode.distributed.internal.membership.adapter;
-import org.apache.geode.distributed.internal.membership.NetView;
+import org.apache.geode.distributed.internal.membership.MembershipView;
+import org.apache.geode.distributed.internal.membership.gms.GMSMembershipView;
+import org.apache.geode.distributed.internal.membership.gms.interfaces.GMSMessage;
+import org.apache.geode.distributed.internal.membership.gms.messenger.GMSQuorumChecker;
+import org.apache.geode.internal.DataSerializableFixedID;
-public class GMSMembershipManager implements MembershipManager, Manager {
+public class GMSMembershipManager implements MembershipManager {
+
+  private final ManagerImpl gmsManager;
+
+  private long ackSevereAlertThreshold;
+  private long ackWaitThreshold;
+
-    NetView gmsView;
+    MembershipView gmsView;
-    StartupEvent(NetView v) {
+    StartupEvent(MembershipView v) {
-  private NetView latestView = new NetView();
+  private MembershipView latestView = new MembershipView();
-      services.getHealthMonitor().contactedBy(msg.getSender());
+      services.getHealthMonitor()
+          .contactedBy(((GMSMemberAdapter) msg.getSender().getNetMember()).getGmsMember());
-  protected void processView(long newViewId, NetView newView) {
+  protected void processView(long newViewId, MembershipView newView) {
-      NetView priorView = latestView;
+      MembershipView priorView = latestView;
-      latestView = new NetView(newView, newView.getViewId());
+      latestView = new MembershipView(newView, newView.getViewId());
-  @Override
-  public boolean isMulticastAllowed() {
-    return !disableMulticastForRollingUpgrade;
-  }
-
-        NetView initialView = services.getJoinLeave().getView();
-        latestView = new NetView(initialView, initialView.getViewId());
+        MembershipView initialView = createGeodeView(services.getJoinLeave().getView());
+        latestView = new MembershipView(initialView, initialView.getViewId());
+  private MembershipView createGeodeView(GMSMembershipView view) {
+    return createGeodeView(view.getCreator(), view.getViewId(), view.getMembers(),
+        view.getShutdownMembers(),
+        view.getCrashedMembers());
+  }
+
+  private MembershipView createGeodeView(GMSMember gmsCreator, int viewId,
+      List<GMSMember> gmsMembers,
+      Set<GMSMember> gmsShutdowns, Set<GMSMember> gmsCrashes) {
+    InternalDistributedMember geodeCreator =
+        new InternalDistributedMember(new GMSMemberAdapter(gmsCreator));
+    List<InternalDistributedMember> geodeMembers = new ArrayList<>(gmsMembers.size());
+    for (GMSMember member : gmsMembers) {
+      geodeMembers.add(new InternalDistributedMember(new GMSMemberAdapter(member)));
+    }
+    Set<InternalDistributedMember> geodeShutdownMembers =
+        gmsMemberCollectionToInternalDistributedMemberSet(gmsShutdowns);
+    Set<InternalDistributedMember> geodeCrashedMembers =
+        gmsMemberCollectionToInternalDistributedMemberSet(gmsCrashes);
+    return new MembershipView(geodeCreator, viewId, geodeMembers, geodeShutdownMembers,
+        geodeCrashedMembers);
+  }
+
+  private Set<InternalDistributedMember> gmsMemberCollectionToInternalDistributedMemberSet(
+      Collection<GMSMember> gmsMembers) {
+    if (gmsMembers.size() == 0) {
+      return Collections.emptySet();
+    } else if (gmsMembers.size() == 1) {
+      return Collections.singleton(
+          new InternalDistributedMember(new GMSMemberAdapter(gmsMembers.iterator().next())));
+    } else {
+      Set<InternalDistributedMember> idmMembers = new HashSet<>(gmsMembers.size());
+      for (GMSMember member : gmsMembers) {
+        idmMembers.add(new InternalDistributedMember(new GMSMemberAdapter((member))));
+      }
+      return idmMembers;
+    }
+  }
+
+
+  private List<InternalDistributedMember> gmsMemberListToInternalDistributedMemberList(
+      List<GMSMember> gmsMembers) {
+    if (gmsMembers.size() == 0) {
+      return Collections.emptyList();
+    } else if (gmsMembers.size() == 1) {
+      return Collections
+          .singletonList(new InternalDistributedMember(new GMSMemberAdapter(gmsMembers.get(0))));
+    } else {
+      List<InternalDistributedMember> idmMembers = new ArrayList<>(gmsMembers.size());
+      for (GMSMember member : gmsMembers) {
+        idmMembers.add(new InternalDistributedMember(new GMSMemberAdapter((member))));
+      }
+      return idmMembers;
+    }
+  }
+
+
+    this.gmsManager = new ManagerImpl();
-  @Override
-  public void init(Services services) {
-    this.services = services;
-
-    Assert.assertTrue(services != null);
-
-    DistributionConfig config = services.getConfig().getDistributionConfig();
-    RemoteTransportConfig transport = services.getConfig().getTransport();
-
-    this.membershipCheckTimeout = config.getSecurityPeerMembershipTimeout();
-    this.wasReconnectingSystem = transport.getIsReconnectingDS();
-
-    // cache these settings for use in send()
-    this.mcastEnabled = transport.isMcastEnabled();
-    this.tcpDisabled = transport.isTcpDisabled();
-
-    if (!this.tcpDisabled) {
-      dcReceiver = new MyDCReceiver(listener);
-    }
-
-    surpriseMemberTimeout =
-        Math.max(20 * DistributionConfig.DEFAULT_MEMBER_TIMEOUT, 20 * config.getMemberTimeout());
-    surpriseMemberTimeout =
-        Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "surprise-member-timeout",
-            surpriseMemberTimeout).intValue();
-
+  public Manager getGMSManager() {
+    return this.gmsManager;
-  public void start() {
-    DistributionConfig config = services.getConfig().getDistributionConfig();
-
-    int dcPort = 0;
-    if (!tcpDisabled) {
-      directChannel = new DirectChannel(this, dcReceiver, config);
-      dcPort = directChannel.getPort();
-    }
-
-
-    services.getMessenger().getMemberID().setDirectChannelPort(dcPort);
-
-  }
-
-
-  @Override
-  public void joinDistributedSystem() {
-    long startTime = System.currentTimeMillis();
-
-    try {
-      join();
-    } catch (RuntimeException e) {
-      if (directChannel != null) {
-        directChannel.disconnect(e);
-      }
-      throw e;
-    }
-
-    this.address = services.getMessenger().getMemberID();
-
-    if (directChannel != null) {
-      directChannel.setLocalAddr(address);
-    }
-
-    this.hasJoined = true;
-
-    // in order to debug startup issues we need to announce the membership
-    // ID as soon as we know it
-    logger.info("Finished joining (took {}ms).",
-        "" + (System.currentTimeMillis() - startTime));
-
-  }
-
-  @Override
-  public void started() {
-    startCleanupTimer();
-  }
-
-
-  /** this is invoked by JoinLeave when there is a loss of quorum in the membership system */
-  @Override
-  public void quorumLost(Collection<InternalDistributedMember> failures, NetView view) {
-    // notify of quorum loss if split-brain detection is enabled (meaning we'll shut down) or
-    // if the loss is more than one member
-
-    boolean notify = failures.size() > 1;
-    if (!notify) {
-      notify = services.getConfig().isNetworkPartitionDetectionEnabled();
-    }
-
-    if (notify) {
-      List<InternalDistributedMember> remaining = new ArrayList<>(view.getMembers());
-      remaining.removeAll(failures);
-
-      if (inhibitForceDisconnectLogging) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("<ExpectedException action=add>Possible loss of quorum</ExpectedException>");
-        }
-      }
-      logger.fatal("Possible loss of quorum due to the loss of {} cache processes: {}",
-          failures.size(), failures);
-      if (inhibitForceDisconnectLogging) {
-        if (logger.isDebugEnabled()) {
-          logger.debug(
-              "<ExpectedException action=remove>Possible loss of quorum</ExpectedException>");
-        }
-      }
-
-
-      try {
-        this.listener.quorumLost(new HashSet<>(failures), remaining);
-      } catch (CancelException e) {
-        // safe to ignore - a forced disconnect probably occurred
-      }
-    }
-  }
-
-
-  @Override
-        NetView newMembers = new NetView(latestView, latestView.getViewId());
+        MembershipView newMembers = new MembershipView(latestView, latestView.getViewId());
-  @Override
-  public void processMessage(DistributionMessage msg) {
-    handleOrDeferMessage(msg);
-  }
-
-    // UDP messages received from surprise members will have partial IDs.
-    // Attempt to replace these with full IDs from the MembershipManager's view.
-    if (msg.getSender().isPartial()) {
-      replacePartialIdentifierInMessage(msg);
-    }
-
-    sender = this.services.getJoinLeave().getMemberID(sender.getNetMember());
-    if (sender.isPartial()) {
+    GMSMember oldID = ((GMSMemberAdapter) sender.getNetMember()).getGmsMember();
+    GMSMember newID = this.services.getJoinLeave().getMemberID(oldID);
+    if (newID != null && newID != oldID) {
+      sender.setNetMember(new GMSMemberAdapter(newID));
+      sender.setIsPartial(false);
+    } else {
-  protected void handleOrDeferViewEvent(NetView viewArg) {
+  protected void handleOrDeferViewEvent(MembershipView viewArg) {
-  @Override
-  public void memberSuspected(InternalDistributedMember initiator,
-      InternalDistributedMember suspect, String reason) {
-    SuspectMember s = new SuspectMember(initiator, suspect, reason);
-    handleOrDeferSuspect(s);
+  private InternalDistributedMember gmsMemberToDMember(GMSMember gmsMember) {
+    return new InternalDistributedMember(new GMSMemberAdapter(gmsMember));
-      InternalDistributedMember suspect = suspectInfo.suspectedMember;
-      InternalDistributedMember who = suspectInfo.whoSuspected;
+      InternalDistributedMember suspect = gmsMemberToDMember(suspectInfo.suspectedMember);
+      InternalDistributedMember who = gmsMemberToDMember(suspectInfo.whoSuspected);
-  public NetView getView() {
+  public MembershipView getView() {
-    NetView v;
+    MembershipView v;
-    NetView result = new NetView(v, v.getViewId());
+    MembershipView result = new MembershipView(v, v.getViewId());
-  /**
-   * test hook
-   * <p>
-   * The lead member is the eldest member with partition detection enabled.
-   * <p>
-   * If no members have partition detection enabled, there will be no lead member and this method
-   * will return null.
-   *
-   * @return the lead member associated with the latest view
-   */
-  @Override
-  public DistributedMember getLeadMember() {
-    latestViewReadLock.lock();
-    try {
-      return latestView == null ? null : latestView.getLeadMember();
-    } finally {
-      latestViewReadLock.unlock();
-    }
-  }
-
-    NetView v = latestView;
+    MembershipView v = latestView;
-  public void shutdownMessageReceived(InternalDistributedMember id, String reason) {
+  public void shutdownMessageReceived(DistributedMember id, String reason) {
-      services.getHealthMonitor().memberShutdown(id, reason);
-      services.getJoinLeave().memberShutdown(id, reason);
+      services.getHealthMonitor()
+          .memberShutdown(
+              ((GMSMemberAdapter) ((InternalDistributedMember) id).getNetMember()).getGmsMember(),
+              reason);
+      services.getJoinLeave().memberShutdown(getGMSMember((InternalDistributedMember) id), reason);
-  public void stop() {
-
-    // [bruce] Do not null out the channel w/o adding appropriate synchronization
-
-    logger.debug("MembershipManager closing");
-
-    if (directChannel != null) {
-      directChannel.disconnect(null);
-
-      if (address != null) {
-        // Make sure that channel information is consistent
-        // Probably not important in this particular case, but just
-        // to be consistent...
-        latestViewWriteLock.lock();
-        try {
-          destroyMember(address, "orderly shutdown");
-        } finally {
-          latestViewWriteLock.unlock();
-        }
-      }
-    }
-
-    if (cleanupTimer != null) {
-      cleanupTimer.cancel();
-    }
-
-    if (logger.isDebugEnabled()) {
-      logger.debug("Membership: channel closed");
-    }
-  }
-
-  @Override
-      services.getJoinLeave().remove((InternalDistributedMember) mbr, reason);
+      services.getJoinLeave().remove(getGMSMember((InternalDistributedMember) mbr), reason);
-  public void suspectMembers(Set<InternalDistributedMember> members, String reason) {
-    for (final InternalDistributedMember member : members) {
+  public void suspectMembers(Set<DistributedMember> members, String reason) {
+    for (final DistributedMember member : members) {
-  public void suspectMember(InternalDistributedMember mbr, String reason) {
+  public void suspectMember(DistributedMember mbr, String reason) {
-  public boolean verifyMember(InternalDistributedMember mbr, String reason) {
+  public boolean verifyMember(DistributedMember mbr, String reason) {
-        && this.services.getHealthMonitor().checkIfAvailable(mbr, reason, false);
+        && this.services.getHealthMonitor()
+            .checkIfAvailable(getGMSMember((InternalDistributedMember) mbr), reason, false);
-      sentBytes = directChannel.send(this, keys, content,
-          this.services.getConfig().getDistributionConfig().getAckWaitThreshold(),
-          this.services.getConfig().getDistributionConfig().getAckSevereAlertThreshold());
+      sentBytes =
+          directChannel.send(this, keys, content, ackWaitThreshold, ackSevereAlertThreshold);
-      NetView view = services.getJoinLeave().getView();
+      GMSMembershipView view = services.getJoinLeave().getView();
-        if (!view.contains(member) || (th instanceof ShunnedMemberException)) {
+        if (!view.contains(getGMSMember(member)) || (th instanceof ShunnedMemberException)) {
+  /**
+   * retrieve the GMS member ID held in a Geode InternalDistributedMember
+   */
+  private GMSMember getGMSMember(InternalDistributedMember member) {
+    return ((GMSMemberAdapter) member.getNetMember()).getGmsMember();
+  }
+
-  /**
-   * Returns true if the distributed system is in the process of auto-reconnecting. Otherwise
-   * returns false.
-   */
-  @Override
-  public boolean isReconnectingDS() {
-    return this.wasReconnectingSystem && !this.reconnectCompleted;
-  }
-
-    if (this.quorumChecker != null) {
-      return this.quorumChecker;
+    if (quorumChecker != null) {
+      return quorumChecker;
-    QuorumChecker impl = services.getMessenger().getQuorumChecker();
-    this.quorumChecker = impl;
-    return impl;
+    GMSQuorumChecker impl = services.getMessenger().getQuorumChecker();
+    quorumChecker = new GMSQuorumCheckerAdapter(impl);
+    return quorumChecker;
-      result = services.getMessenger().send(msg);
+      Set<GMSMember> failures = services.getMessenger().send(new GMSMessageAdapter(msg));
+      if (failures == null || failures.size() == 0) {
+        return Collections.emptySet();
+      }
+      return gmsMemberCollectionToInternalDistributedMemberSet(failures);
+    GMSMembershipView view = services.getJoinLeave().getView();
-        GMSMember id = (GMSMember) m.getNetMember();
+        GMSMemberAdapter adapter = (GMSMemberAdapter) m.getNetMember();
+        GMSMember id = adapter.getGmsMember();
-          latestViewReadLock.lock();
-          try {
-            addresses[i] = latestView.getCanonicalID(addresses[i]);
-          } finally {
-            latestViewReadLock.unlock();
-          }
+          adapter.setGmsMember(view.getCanonicalID(id));
-  @Override
-  public boolean shutdownInProgress() {
-    // Impossible condition (bug36329): make sure that we check DM's
-    // view of shutdown here
-    ClusterDistributionManager dm = listener.getDM();
-    return shutdownInProgress || (dm != null && dm.shutdownInProgress());
-  }
-
-
-        NetView newView = new NetView(latestView, latestView.getViewId());
+        MembershipView newView = new MembershipView(latestView, latestView.getViewId());
-  @Override
-  public boolean isReconnectCompleted() {
-    return reconnectCompleted;
-  }
-
-    services.getMessenger().getMessageState((InternalDistributedMember) member, result,
+    services.getMessenger().getMessageState(getGMSMember((InternalDistributedMember) member),
+        result,
-    services.getMessenger().waitForMessageState((InternalDistributedMember) otherMember, state);
+    services.getMessenger().waitForMessageState(
+        getGMSMember((InternalDistributedMember) otherMember), state);
+  @Override
+  public boolean shutdownInProgress() {
+    // Impossible condition (bug36329): make sure that we check DM's
+    // view of shutdown here
+    ClusterDistributionManager dm = listener.getDM();
+    return shutdownInProgress || (dm != null && dm.shutdownInProgress());
+  }
+
-  public boolean waitForNewMember(InternalDistributedMember remoteId) {
+  public boolean waitForNewMember(DistributedMember remoteId) {
-  @Override
-  public void stopped() {}
-
-  @Override
-  public void installView(NetView v) {
-    if (latestViewId < 0 && !isConnected()) {
-      latestViewId = v.getViewId();
-      latestView = v;
-      logger.debug("MembershipManager: initial view is {}", latestView);
-    } else {
-      handleOrDeferViewEvent(v);
-    }
-  }
-
-  @Override
-  public Set<InternalDistributedMember> send(DistributionMessage m)
-      throws NotSerializableException {
-    return send(m.getRecipients(), m, this.services.getStatistics());
-  }
-
-  @Override
-  public void forceDisconnect(final String reason) {
-    if (GMSMembershipManager.this.shutdownInProgress || isJoining()) {
-      return; // probably a race condition
-    }
-
-    setShutdown();
-
-    final Exception shutdownCause = new ForcedDisconnectException(reason);
-
-    // cache the exception so it can be appended to ShutdownExceptions
-    services.setShutdownCause(shutdownCause);
-    services.getCancelCriterion().cancel(reason);
-
-    AlertAppender.getInstance().stopSession();
-
-    if (!inhibitForceDisconnectLogging) {
-      logger.fatal(
-          String.format("Membership service failure: %s", reason),
-          shutdownCause);
-    }
-
-    if (this.isReconnectingDS()) {
-      logger.info("Reconnecting system failed to connect");
-      uncleanShutdown(reason,
-          new ForcedDisconnectException("reconnecting system failed to connect"));
-      return;
-    }
-
-    listener.saveConfig();
-
-    Thread reconnectThread = new LoggingThread("DisconnectThread", false, () -> {
-      // stop server locators immediately since they may not have correct
-      // information. This has caused client failures in bridge/wan
-      // network-down testing
-      InternalLocator loc = (InternalLocator) Locator.getLocator();
-      if (loc != null) {
-        loc.stop(true, !services.getConfig().getDistributionConfig().getDisableAutoReconnect(),
-            false);
-      }
-      uncleanShutdown(reason, shutdownCause);
-    });
-    reconnectThread.start();
-  }
-
-
-  public boolean isShutdownStarted() {
-    ClusterDistributionManager dm = listener.getDM();
-    return shutdownInProgress || (dm != null && dm.isCloseInProgress());
-  }
-
-  @Override
+
+
+  class ManagerImpl implements Manager {
+
+    @Override
+    public Services getServices() {
+      return services;
+    }
+
+    @Override
+    /* Service interface */
+    public void init(Services services) {
+      GMSMembershipManager.this.services = services;
+
+      Assert.assertTrue(services != null);
+
+      DistributionConfig config = services.getConfig().getDistributionConfig();
+      RemoteTransportConfig transport = services.getConfig().getTransport();
+
+      membershipCheckTimeout = config.getSecurityPeerMembershipTimeout();
+      wasReconnectingSystem = transport.getIsReconnectingDS();
+
+      // cache these settings for use in send()
+      mcastEnabled = transport.isMcastEnabled();
+      tcpDisabled = transport.isTcpDisabled();
+      ackSevereAlertThreshold = config.getAckSevereAlertThreshold();
+      ackWaitThreshold = config.getAckWaitThreshold();
+
+      if (!tcpDisabled) {
+        dcReceiver = new MyDCReceiver(listener);
+      }
+
+      surpriseMemberTimeout =
+          Math.max(20 * DistributionConfig.DEFAULT_MEMBER_TIMEOUT, 20 * config.getMemberTimeout());
+      surpriseMemberTimeout =
+          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "surprise-member-timeout",
+              surpriseMemberTimeout).intValue();
+
+    }
+
+    /* Service interface */
+    @Override
+    public void start() {
+      DistributionConfig config = services.getConfig().getDistributionConfig();
+
+      int dcPort = 0;
+      if (!tcpDisabled) {
+        directChannel = new DirectChannel(GMSMembershipManager.this, dcReceiver, config);
+        dcPort = directChannel.getPort();
+      }
+      services.getMessenger().getMemberID().setDirectPort(dcPort);
+    }
+
+    /* Service interface */
+    @Override
+    public void started() {
+      startCleanupTimer();
+      // see if a locator was started and put it in GMS Services
+      InternalLocator l = (InternalLocator) org.apache.geode.distributed.Locator.getLocator();
+      if (l != null && l.getLocatorHandler() != null) {
+        if (l.getLocatorHandler().setServices(services)) {
+          services.setLocator(((GMSLocatorAdapter) l.getLocatorHandler()).getGMSLocator());
+        }
+      }
+    }
+
+    /* Service interface */
+    @Override
+    public void stop() {
+      // [bruce] Do not null out the channel w/o adding appropriate synchronization
+
+      logger.debug("MembershipManager closing");
+
+      if (directChannel != null) {
+        directChannel.disconnect(null);
+
+        if (address != null) {
+          // Make sure that channel information is consistent
+          // Probably not important in this particular case, but just
+          // to be consistent...
+          latestViewWriteLock.lock();
+          try {
+            destroyMember(address, "orderly shutdown");
+          } finally {
+            latestViewWriteLock.unlock();
+          }
+        }
+      }
+
+      if (cleanupTimer != null) {
+        cleanupTimer.cancel();
+      }
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("Membership: channel closed");
+      }
+    }
+
+    /* Service interface */
+    @Override
+    public void stopped() {}
+
+    /* Service interface */
+    @Override
+    public void installView(GMSMembershipView v) {
+      if (latestViewId < 0 && !isConnected()) {
+        latestViewId = v.getViewId();
+        latestView = createGeodeView(v);
+        logger.debug("MembershipManager: initial view is {}", latestView);
+      } else {
+        handleOrDeferViewEvent(createGeodeView(v));
+      }
+    }
+
+    @Override
+    public void beSick() {
+      // no-op
+    }
+
+    @Override
+    public void playDead() {
+      // no-op
+    }
+
+    @Override
+    public void beHealthy() {
+      // no-op
+    }
+
+    @Override
+    public void emergencyClose() {
+      // no-op
+    }
+
+
+    @Override
+    public void joinDistributedSystem() {
+      long startTime = System.currentTimeMillis();
+
+      try {
+        join();
+      } catch (RuntimeException e) {
+        if (directChannel != null) {
+          directChannel.disconnect(e);
+        }
+        throw e;
+      }
+
+      GMSMembershipManager.this.address =
+          new InternalDistributedMember(
+              new GMSMemberAdapter(services.getMessenger().getMemberID()));
+
+      if (directChannel != null) {
+        directChannel.setLocalAddr(address);
+      }
+
+      GMSMembershipManager.this.hasJoined = true;
+
+      // in order to debug startup issues we need to announce the membership
+      // ID as soon as we know it
+      logger.info("Finished joining (took {}ms).",
+          "" + (System.currentTimeMillis() - startTime));
+
+    }
+
+    @Override
+    public void memberSuspected(GMSMember initiator,
+        GMSMember suspect, String reason) {
+      SuspectMember s = new SuspectMember(initiator, suspect, reason);
+      handleOrDeferSuspect(s);
+    }
+
+
+    @Override
+    public void forceDisconnect(final String reason) {
+      if (GMSMembershipManager.this.shutdownInProgress || isJoining()) {
+        return; // probably a race condition
+      }
+
+      setShutdown();
+
+      final Exception shutdownCause = new ForcedDisconnectException(reason);
+
+      // cache the exception so it can be appended to ShutdownExceptions
+      services.setShutdownCause(shutdownCause);
+      services.getCancelCriterion().cancel(reason);
+
+      AlertAppender.getInstance().stopSession();
+
+      if (!inhibitForceDisconnectLogging) {
+        logger.fatal(
+            String.format("Membership service failure: %s", reason),
+            shutdownCause);
+      }
+
+      if (this.isReconnectingDS()) {
+        logger.info("Reconnecting system failed to connect");
+        uncleanShutdown(reason,
+            new ForcedDisconnectException("reconnecting system failed to connect"));
+        return;
+      }
+
+      listener.saveConfig();
+
+      Thread reconnectThread = new LoggingThread("DisconnectThread", false, () -> {
+        // stop server locators immediately since they may not have correct
+        // information. This has caused client failures in bridge/wan
+        // network-down testing
+        InternalLocator loc = (InternalLocator) Locator.getLocator();
+        if (loc != null) {
+          loc.stop(true, !services.getConfig().getDistributionConfig().getDisableAutoReconnect(),
+              false);
+        }
+        uncleanShutdown(reason, shutdownCause);
+      });
+      reconnectThread.start();
+    }
+
+
+    /** this is invoked by JoinLeave when there is a loss of quorum in the membership system */
+    @Override
+    public void quorumLost(Collection<GMSMember> failures, GMSMembershipView view) {
+      // notify of quorum loss if split-brain detection is enabled (meaning we'll shut down) or
+      // if the loss is more than one member
+
+      boolean notify = failures.size() > 1;
+      if (!notify) {
+        notify = services.getConfig().isNetworkPartitionDetectionEnabled();
+      }
+
+      if (notify) {
+        List<InternalDistributedMember> remaining =
+            gmsMemberListToInternalDistributedMemberList(view.getMembers());
+        remaining.removeAll(failures);
+
+        if (inhibitForceDisconnectLogging) {
+          if (logger.isDebugEnabled()) {
+            logger
+                .debug("<ExpectedException action=add>Possible loss of quorum</ExpectedException>");
+          }
+        }
+        logger.fatal("Possible loss of quorum due to the loss of {} cache processes: {}",
+            failures.size(), failures);
+        if (inhibitForceDisconnectLogging) {
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "<ExpectedException action=remove>Possible loss of quorum</ExpectedException>");
+          }
+        }
+
+
+        try {
+          listener.quorumLost(
+              gmsMemberCollectionToInternalDistributedMemberSet(failures),
+              remaining);
+        } catch (CancelException e) {
+          // safe to ignore - a forced disconnect probably occurred
+        }
+      }
+    }
+
+    @Override
+    public void processMessage(GMSMessage msg) {
+      DistributionMessage distributionMessage =
+          (DistributionMessage) ((GMSMessageAdapter) msg).getGeodeMessage();
+      // UDP messages received from surprise members will have partial IDs.
+      // Attempt to replace these with full IDs from the MembershipManager's view.
+      if (distributionMessage.getSender().isPartial()) {
+        replacePartialIdentifierInMessage(distributionMessage);
+      }
+
+      handleOrDeferMessage(distributionMessage);
+    }
+
+    @Override
+    public boolean isMulticastAllowed() {
+      return !disableMulticastForRollingUpgrade;
+    }
+
+    @Override
+    public boolean shutdownInProgress() {
+      // Impossible condition (bug36329): make sure that we check DM's
+      // view of shutdown here
+      ClusterDistributionManager dm = listener.getDM();
+      return shutdownInProgress || (dm != null && dm.shutdownInProgress());
+    }
+
+    @Override
+    public boolean isReconnectingDS() {
+      return wasReconnectingSystem && !reconnectCompleted;
+    }
+
+    @Override
+    public boolean isShutdownStarted() {
+      ClusterDistributionManager dm = listener.getDM();
+      return shutdownInProgress || (dm != null && dm.isCloseInProgress());
+    }
+
+    @Override
+    public GMSMessage wrapMessage(Object receivedMessage) {
+      if (receivedMessage instanceof GMSMessage) {
+        return (GMSMessage) receivedMessage;
+      }
+      // Geode's DistributionMessage class isn't known by GMS classes
+      return new GMSMessageAdapter((DistributionMessage) receivedMessage);
+    }
+
+    @Override
+    public DataSerializableFixedID unwrapMessage(GMSMessage messageToSend) {
+      if (messageToSend instanceof GMSMessageAdapter) {
+        return ((GMSMessageAdapter) messageToSend).getGeodeMessage();
+      }
+      return (DataSerializableFixedID) messageToSend;
+    }
+
+  }

Merge branch 'release/1.0.0-incubating.M3'

+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import com.gemstone.gemfire.InternalGemFireError;
+import com.gemstone.gemfire.cache.Cache;
+import com.gemstone.gemfire.cache.RegionAttributes;
+import com.gemstone.gemfire.cache.asyncqueue.AsyncEventQueue;
+import com.gemstone.gemfire.cache.lucene.internal.filesystem.FileSystemStats;
+import com.gemstone.gemfire.internal.cache.GemFireCacheImpl;
+import com.gemstone.gemfire.internal.cache.InternalRegionArguments;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-//  protected HashSet<String> searchableFieldNames = new HashSet<String>();
-  String[] searchableFieldNames;
+  protected final String indexName;
+  protected final String regionPath;
+  protected final Cache cache;
+  protected final LuceneIndexStats indexStats;
+  protected final FileSystemStats fileSystemStats;
+
+  protected boolean hasInitialized = false;
+  protected Map<String, Analyzer> fieldAnalyzers;
+  protected String[] searchableFieldNames;
-  
-  Region<String, File> fileRegion;
-  Region<ChunkKey, byte[]> chunkRegion;
-  
-  protected String indexName;
-  protected String regionPath;
-  protected boolean hasInitialized = false;
+  protected Region<String, File> fileRegion;
+  protected Region<ChunkKey, byte[]> chunkRegion;
+
+
+  protected LuceneIndexImpl(String indexName, String regionPath, Cache cache) {
+    this.indexName = indexName;
+    this.regionPath = regionPath;
+    this.cache = cache;
+    final String statsName = indexName + "-" + regionPath;
+    this.indexStats = new LuceneIndexStats(cache.getDistributedSystem(), statsName);
+    this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);
+  }
-  
+
+  @Override
+  public boolean waitUntilFlushed(int maxWaitInMillisecond) {
+    String aeqId = LuceneServiceImpl.getUniqueIndexName(indexName, regionPath);
+    AsyncEventQueue queue = (AsyncEventQueue)cache.getAsyncEventQueue(aeqId);
+    boolean flushed = false;
+    if (queue != null) {
+      long start = System.nanoTime();
+      while (System.nanoTime() - start < TimeUnit.MILLISECONDS.toNanos(maxWaitInMillisecond)) {
+        if (0 == queue.size()) {
+          flushed = true;
+          break;
+        } else {
+          try {
+            Thread.sleep(200);
+          } catch (InterruptedException e) {
+          }
+        }
+      }
+    } else { 
+      throw new IllegalArgumentException("The AEQ does not exist for the index "+indexName+" region "+regionPath);
+    }
+
+    return flushed;
+  }
+
-  public Map<String, Analyzer> getFieldAnalyzerMap() {
-    // TODO Auto-generated method stub
-    // Will do that later: Gester
-    return null;
+  public Map<String, Analyzer> getFieldAnalyzers() {
+    return this.fieldAnalyzers;
+  public void setFieldAnalyzers(Map<String, Analyzer> fieldAnalyzers) {
+    this.fieldAnalyzers = fieldAnalyzers == null ? null : Collections.unmodifiableMap(fieldAnalyzers);
+  }
+
+  public LuceneIndexStats getIndexStats() {
+    return indexStats;
+  }
+
+  public FileSystemStats getFileSystemStats() {
+    return fileSystemStats;
+  }
+
-    creation.setFieldFieldAnalyzerMap(this.getFieldAnalyzerMap());
+    creation.setFieldAnalyzers(this.getFieldAnalyzers());
+
+  protected <K, V> Region<K, V> createRegion(final String regionName, final RegionAttributes<K, V> attributes) {
+    // Create InternalRegionArguments to set isUsedForMetaRegion true to suppress xml generation (among other things)
+    InternalRegionArguments ira = new InternalRegionArguments().setDestroyLockFlag(true).setRecreateFlag(false)
+        .setSnapshotInputStream(null).setImageTarget(null).setIsUsedForMetaRegion(true);
+
+    // Create the region
+    try {
+      return ((GemFireCacheImpl)this.cache).createVMRegion(regionName, attributes, ira);
+    } catch (Exception e) {
+      InternalGemFireError ige = new InternalGemFireError(LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString());
+      ige.initCause(e);
+      throw ige;
+    }
+  }

Fixing failure from RegionDirectoryJUnitTest.testCopyBytesWithThreads

The underlying issue was that the FileIndexInputClass extended
BufferedIndexInput, which looks like has an issue in the clone method.
In FileIndexInput.clone. We were cloning the input stream to start
at the position that it left off (which I think is correct), but the
BufferedIndexInput.clone dropped the buffer, so the next read would miss
some of the bytes that where in that buffer.

After some thought, I don't think we want the BufferedIndexInput because
the data is already stored in memory in a byte array in FileInputStream.
So I removed the dependency on BufferedIndexInput. As part of that work,
I added seek() to the FileInputStream to make seek operations more
efficient.

+import java.io.EOFException;
-final class FileInputStream extends InputStream {
+final class FileInputStream extends SeekableInputStream {
+  public FileInputStream(FileInputStream other) {
+    this.file = other.file;
+    this.chunk = other.chunk;
+    this.chunkId = other.chunkId;
+    this.chunkPosition = other.chunkPosition;
+    this.open = other.open;
+  }
+
+  
+  @Override
+  public void seek(long position) throws IOException {
+    if(position > file.length) {
+      throw new EOFException();
+    }
+    int targetChunk = (int) (position / file.getChunkSize());
+    int targetPosition = (int) (position % file.getChunkSize());
+    
+    if(targetChunk != (this.chunkId - 1)) {
+      chunk = file.getFileSystem().getChunk(this.file, targetChunk);
+      chunkId = targetChunk + 1;
+      chunkPosition = targetPosition;
+    } else {
+      chunkPosition = targetPosition;
+    }
+  }
+  
+  
+
+  @Override
+  public long skip(long n) throws IOException {
+    int currentPosition = (chunkId - 1) * file.getChunkSize() + chunkPosition;
+    seek(currentPosition + n);
+    return n;
+  }
+  
+  @Override
+  public void reset() throws IOException {
+    seek(0);
+  }
+  
+  @Override
+  public FileInputStream clone() {
+    return new FileInputStream(this);
+  }

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Represents one unit of information (essentially a <code>byte</code>
- * array) in the wire protocol.  Each server connection runs in its
- * own thread to maximize concurrency and improve response times to
- * edge requests
+ * Represents one unit of information (essentially a <code>byte</code> array) in the wire protocol.
+ * Each server connection runs in its own thread to maximize concurrency and improve response times
+ * to edge requests
-  
+
+   * 
-  /** The payload of this part.
-   * Could be null, a byte[] or a HeapDataOutputStream on the send side.
+  /**
+   * The payload of this part. Could be null, a byte[] or a HeapDataOutputStream on the send side.
-    }
-    else {
+    } else {
-        ((HeapDataOutputStream)this.part).close();
+        ((HeapDataOutputStream) this.part).close();
-      byte[] b = (byte[])this.part;
+      byte[] b = (byte[]) this.part;
+
+
-  
+
+
+
+
-   * Return the length of the part. The length is the number of bytes needed
-   * for its serialized form.
+   * Return the length of the part. The length is the number of bytes needed for its serialized
+   * form.
-      return ((byte[])this.part).length;
+      return ((byte[]) this.part).length;
-      return ((HeapDataOutputStream)this.part).size();
+      return ((HeapDataOutputStream) this.part).size();
+
-      Assert.assertTrue(false, "expected String part to be of type BYTE, part ="
-          + this.toString());
+      Assert.assertTrue(false, "expected String part to be of type BYTE, part =" + this.toString());
-    return CacheServerHelper.fromUTF((byte[])this.part);
+    return CacheServerHelper.fromUTF((byte[]) this.part);
-  
+
-      Assert.assertTrue(false, "expected int part to be of type BYTE, part = "
-          + this.toString()); 
+      Assert.assertTrue(false, "expected int part to be of type BYTE, part = " + this.toString());
-      Assert.assertTrue(false, 
-          "expected int length to be 4 but it was " + getLength()
-          + "; part = " + this.toString());
+      Assert.assertTrue(false,
+          "expected int length to be 4 but it was " + getLength() + "; part = " + this.toString());
-    return (((bytes[offset + 0]) << 24) & 0xFF000000)
-        | (((bytes[offset + 1]) << 16) & 0x00FF0000)
-        | (((bytes[offset + 2]) << 8) & 0x0000FF00)
-        | ((bytes[offset + 3]) & 0x000000FF);
+    return (((bytes[offset + 0]) << 24) & 0xFF000000) | (((bytes[offset + 1]) << 16) & 0x00FF0000)
+        | (((bytes[offset + 2]) << 8) & 0x0000FF00) | ((bytes[offset + 3]) & 0x000000FF);
-  private static final Map<Integer,byte[]> CACHED_INTS = new ConcurrentHashMap<Integer,byte[]>();
-  
+  private static final Map<Integer, byte[]> CACHED_INTS = new ConcurrentHashMap<Integer, byte[]>();
+
-    bytes[offset + 2] = (byte) ((v & 0x0000FF00) >> 8 );
+    bytes[offset + 2] = (byte) ((v & 0x0000FF00) >> 8);
-  
+
-    bytes[6] = (byte) ((v & 0x000000000000FF00l) >>  8);
+    bytes[6] = (byte) ((v & 0x000000000000FF00l) >> 8);
-      Assert.assertTrue(false, "expected long part to be of type BYTE, part = "
-          + this.toString()); 
+      Assert.assertTrue(false, "expected long part to be of type BYTE, part = " + this.toString());
-      Assert.assertTrue(false, 
-          "expected long length to be 8 but it was " + getLength()
-          + "; part = " + this.toString());
+      Assert.assertTrue(false,
+          "expected long length to be 8 but it was " + getLength() + "; part = " + this.toString());
-    return ((((long)bytes[0]) << 56) & 0xFF00000000000000l) |
-           ((((long)bytes[1]) << 48) & 0x00FF000000000000l) |
-           ((((long)bytes[2]) << 40) & 0x0000FF0000000000l) |
-           ((((long)bytes[3]) << 32) & 0x000000FF00000000l) |
-           ((((long)bytes[4]) << 24) & 0x00000000FF000000l) |
-           ((((long)bytes[5]) << 16) & 0x0000000000FF0000l) |
-           ((((long)bytes[6]) <<  8) & 0x000000000000FF00l) |
-           (        bytes[7]         & 0x00000000000000FFl);
+    return ((((long) bytes[0]) << 56) & 0xFF00000000000000l)
+        | ((((long) bytes[1]) << 48) & 0x00FF000000000000l)
+        | ((((long) bytes[2]) << 40) & 0x0000FF0000000000l)
+        | ((((long) bytes[3]) << 32) & 0x000000FF00000000l)
+        | ((((long) bytes[4]) << 24) & 0x00000000FF000000l)
+        | ((((long) bytes[5]) << 16) & 0x0000000000FF0000l)
+        | ((((long) bytes[6]) << 8) & 0x000000000000FF00l) | (bytes[7] & 0x00000000000000FFl);
-      return (byte[])this.part;
+      return (byte[]) this.part;
+
-    }
-    else {
+    } else {
-        return CacheServerHelper.deserialize((byte[])this.part, this.version,
-            unzip);
-      }
-      else {
-        return CacheServerHelper.deserialize((byte[])this.part, unzip);
+        return CacheServerHelper.deserialize((byte[]) this.part, this.version, unzip);
+      } else {
+        return CacheServerHelper.deserialize((byte[]) this.part, unzip);
+
-  
+
-   * Write the contents of this part to the specified output stream.
-   * This is only called for parts that will not fit into the commBuffer
-   * so they need to be written directly to the stream.
-   * A stream is used because the client is configured for old IO (instead of nio).
+   * Write the contents of this part to the specified output stream. This is only called for parts
+   * that will not fit into the commBuffer so they need to be written directly to the stream. A
+   * stream is used because the client is configured for old IO (instead of nio).
+   * 
-        byte[] bytes = (byte[])this.part;
+        byte[] bytes = (byte[]) this.part;
-          HeapDataOutputStream.writeByteBufferToStream(out,  buf, sobb);
+          HeapDataOutputStream.writeByteBufferToStream(out, buf, sobb);
-              HeapDataOutputStream.flushStream(out,  buf);
+              HeapDataOutputStream.flushStream(out, buf);
-        HeapDataOutputStream hdos = (HeapDataOutputStream)this.part;
+        HeapDataOutputStream hdos = (HeapDataOutputStream) this.part;
+
-   * Write the contents of this part to the specified byte buffer.
-   * Precondition: caller has already checked the length of this part
-   * and it will fit into "buf".
+   * Write the contents of this part to the specified byte buffer. Precondition: caller has already
+   * checked the length of this part and it will fit into "buf".
-        buf.put((byte[])this.part);
+        buf.put((byte[]) this.part);
-        HeapDataOutputStream hdos = (HeapDataOutputStream)this.part;
+        HeapDataOutputStream hdos = (HeapDataOutputStream) this.part;
+
-   * Write the contents of this part to the specified socket channel
-   * using the specified byte buffer.
-   * This is only called for parts that will not fit into the commBuffer
-   * so they need to be written directly to the socket.
-   * Precondition: buf contains nothing that needs to be sent
+   * Write the contents of this part to the specified socket channel using the specified byte
+   * buffer. This is only called for parts that will not fit into the commBuffer so they need to be
+   * written directly to the socket. Precondition: buf contains nothing that needs to be sent
-        final byte[] bytes = (byte[])this.part;
+        final byte[] bytes = (byte[]) this.part;
-        HeapDataOutputStream hdos = (HeapDataOutputStream)this.part;
+        HeapDataOutputStream hdos = (HeapDataOutputStream) this.part;
-  
+
-    case BYTE_CODE:
-      return "BYTE_CODE";
-    case OBJECT_CODE:
-      return "OBJECT_CODE";
-    case EMPTY_BYTEARRAY_CODE:
-      return "EMPTY_BYTEARRAY_CODE";
-    default:
-      return "unknown code " + c;
+      case BYTE_CODE:
+        return "BYTE_CODE";
+      case OBJECT_CODE:
+        return "OBJECT_CODE";
+      case EMPTY_BYTEARRAY_CODE:
+        return "EMPTY_BYTEARRAY_CODE";
+      default:
+        return "unknown code " + c;
-//    sb.append(" partBytes=");
-//    byte[] b = getSerializedForm();
-//    if (b == null) {
-//      sb.append("null");
-//    }
-//    else {
-//      sb.append("(");
-//      for (int i = 0; i < b.length; i ++) {
-//        sb.append(Integer.toString(b[i]));
-//        sb.append(" ");
-//      }
-//      sb.append(")");
-//    }
+    // sb.append(" partBytes=");
+    // byte[] b = getSerializedForm();
+    // if (b == null) {
+    // sb.append("null");
+    // }
+    // else {
+    // sb.append("(");
+    // for (int i = 0; i < b.length; i ++) {
+    // sb.append(Integer.toString(b[i]));
+    // sb.append(" ");
+    // }
+    // sb.append(")");
+    // }

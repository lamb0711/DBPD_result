GEODE-5420: Protect events in HAContainer from premature modification

- Updated putInProgress boolean in HAWrapper to a counter to prevent prematurely setting ClientUpdateMessage to null when events are temporarily queued during a GII or message dispatcher initialization
- decAndRemoveFromHAContainer only removes when putInProgress counter and ref count are 0
- Refactored putEventInHARegion/putConditionallyInHAContainer to prevent overwriting an existing entry in the HAContainer.  Also reduces simplifies the code and reduces duplicated logic.
- Wrote missing basic HARegionQueue unit/integration tests, and an integration test to capture setting the ClientUpdateMessage property on HAEventWrapper to null prematurely
- Added new event tracing messages at debug logging level to help track similar issues in the future

Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
Co-authored-by: Lynn Hughes-Godfrey <lhughesgodfrey@pivotal.io>

+
+
+            if (conflatable instanceof HAEventWrapper) {
+              HAEventWrapper haEventWrapper = (HAEventWrapper) conflatable;
+              haEventWrapper.incrementPutInProgressCounter();
+              if (logger.isDebugEnabled()) {
+                logger.debug(
+                    "Incremented PutInProgressCounter on HAEventWrapper with Event ID hash code: "
+                        + haEventWrapper.hashCode()
+                        + "; System ID hash code: "
+                        + System.identityHashCode(haEventWrapper) + "; Wrapper details: "
+                        + haEventWrapper);
+              }
+            }
+
+
+
-              "Message is not added to the queue. Message dispatcher for proxy: {} doesn't exist.",
-              this);
+              "Message was not added to the queue. Message dispatcher was null for proxy: " + this
+                  + ". Event ID hash code: " + conflatable.hashCode() + "; System ID hash code: "
+                  + System.identityHashCode(conflatable) + "; Conflatable details: " + conflatable
+                      .toString());
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Message was not added to the queue. Event ID hash code: " + conflatable.hashCode()
+                + "; System ID hash code: "
+                + System.identityHashCode(conflatable) + "; Conflatable details: " + conflatable
+                    .toString());
+      }
+
-      Conflatable nextEvent;
-      while ((nextEvent = queuedEvents.poll()) != null) {
-        this._messageDispatcher.enqueueMessage(nextEvent);
-      }
+
+      drainQueuedEvents(false);
-        while ((nextEvent = queuedEvents.poll()) != null) {
-          this._messageDispatcher.enqueueMessage(nextEvent);
-        }
+        drainQueuedEvents(true);
+  private void drainQueuedEvents(boolean withSynchronization) {
+    Conflatable nextEvent;
+    while ((nextEvent = queuedEvents.poll()) != null) {
+      if (logger.isDebugEnabled()) {
+        if (nextEvent instanceof HAEventWrapper) {
+          logger.debug(
+              "Draining events queued during message dispatcher initialization "
+                  + (withSynchronization ? "with" : "without")
+                  + " synchronization. Event ID hash code: "
+                  + nextEvent.hashCode()
+                  + "; System ID hash code: " + System.identityHashCode(nextEvent)
+                  + "; Wrapper details: " + nextEvent);
+        }
+      }
+
+      this._messageDispatcher.enqueueMessage(nextEvent);
+
+      if (nextEvent instanceof HAEventWrapper) {
+        ((HAEventWrapper) nextEvent).decrementPutInProgressCounter();
+      }
+    }
+  }
+

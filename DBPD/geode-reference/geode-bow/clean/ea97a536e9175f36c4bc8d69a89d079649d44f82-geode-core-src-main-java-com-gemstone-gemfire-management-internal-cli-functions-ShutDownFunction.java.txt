GEODE-1236 GEODE-1248: Fix gfsh sutdown call

- This fixes two issues when using gfsh 'shutdown' command
- One is that the JVM can exit prematurely because all remaining threads
  are daemon threads. When coupled with network partition detection this
  can result in member departed events causing split brain scenarios -
  [GEODE-1236].
- The other issue is that when a member is starting up it may have
  synchronized on the CacheFactory class waiting on disk store recovery.
  This prevented gfsh shutdown to run as it would also try and
  synchronize on the CacheFactory and be blocked.

-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.cache.Cache;
-import com.gemstone.gemfire.cache.CacheFactory;
+import org.apache.logging.log4j.Logger;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
-      Cache cache = CacheFactory.getAnyInstance();
-      String memberName = cache.getDistributedSystem().getDistributedMember().getId();
-      cache.getLogger().info("Received GFSH shutdown. Shutting down member " + memberName);
-      final InternalDistributedSystem system = ((InternalDistributedSystem) cache.getDistributedSystem());
-
-      if (system.isConnected()) {
-        ConnectionTable.threadWantsSharedResources();
-        if (system.isConnected()) {
-          system.disconnect();
-        }
+      final InternalDistributedSystem system = InternalDistributedSystem.getConnectedInstance();
+      if (system == null) {
+        return;
-      
+      String memberName = system.getDistributedMember().getId();
+      logger.info("Received GFSH shutdown. Shutting down member " + memberName);
+
+      disconnectInNonDaemonThread(system);
+
-      context.getResultSender().lastResult("FAILURE: failed in shutting down " +ex.getMessage());
+      logger.warn("Error during shutdown", ex);
+      context.getResultSender().lastResult("FAILURE: failed in shutting down " + ex.getMessage());
+    }
+  }
+
+  /*
+   * The shutdown is performed in a separate, non-daemon thread so that the JVM does not shut down
+   * prematurely before the full process has completed.
+   */
+  private void disconnectInNonDaemonThread(final InternalDistributedSystem ids)
+      throws InterruptedException, ExecutionException {
+    ExecutorService exec = Executors.newSingleThreadExecutor();
+    Future future = exec.submit(() -> {
+      ConnectionTable.threadWantsSharedResources();
+      if (ids.isConnected()) {
+        ids.disconnect();
+      }
+    });
+    try {
+      future.get();
+    } finally {
+      exec.shutdown();

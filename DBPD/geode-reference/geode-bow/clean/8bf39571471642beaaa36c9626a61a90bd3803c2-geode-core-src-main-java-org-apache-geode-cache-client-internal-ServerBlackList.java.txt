Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class is designed to prevent the client from spinning
- * and reconnected to the same failed server over and over.
- * We've removed the old dead server monitor code because
- * the locator is supposed to keep track of what servers are
- * alive or dead. However, there is still the possibility that the locator
- * may tell us a server is alive but we are unable to reach it. 
+ * This class is designed to prevent the client from spinning and reconnected to the same failed
+ * server over and over. We've removed the old dead server monitor code because the locator is
+ * supposed to keep track of what servers are alive or dead. However, there is still the possibility
+ * that the locator may tell us a server is alive but we are unable to reach it.
- * This class keeps track of the number of consecutive failures
- * that happen to on each server. If the number of failures exceeds the limit,
- * the server is added to a blacklist for a certain period of time. After
- * the time is expired, the server comes off the blacklist, but the next
- * failure will put the server back on the list for a longer period of time.
+ * This class keeps track of the number of consecutive failures that happen to on each server. If
+ * the number of failures exceeds the limit, the server is added to a blacklist for a certain period
+ * of time. After the time is expired, the server comes off the blacklist, but the next failure will
+ * put the server back on the list for a longer period of time.
-  
+
-  
-  private final Map/*<ServerLocation, AI>*/ failureTrackerMap = new HashMap();
+
+  private final Map/* <ServerLocation, AI> */ failureTrackerMap = new HashMap();
-  
-  //not final for tests.
-  static int THRESHOLD = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "ServerBlackList.THRESHOLD", 3).intValue();
+
+  // not final for tests.
+  static int THRESHOLD = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "ServerBlackList.THRESHOLD", 3).intValue();
-  
+
-  
+
-  
+
-    synchronized(failureTrackerMap) {
+    synchronized (failureTrackerMap) {
-      if(failureTracker == null) {
+      if (failureTracker == null) {
-    
+
-  
+
-  
+
-    
+
-    
+
-    
+
-      if(blacklist.contains(location)) {
-        //A second failure must have happened before we added
-        //this server to the blacklist. Don't count that failure.
+      if (blacklist.contains(location)) {
+        // A second failure must have happened before we added
+        // this server to the blacklist. Don't count that failure.
-      if(failures >= THRESHOLD) {
-        if(logger.isDebugEnabled()) {
-          logger.debug("Blacklisting server {} for {}ms because it had {} consecutive failures", location, pingInterval, failures);
+      if (failures >= THRESHOLD) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("Blacklisting server {} for {}ms because it had {} consecutive failures",
+              location, pingInterval, failures);
-          background.schedule(new ExpireBlackListTask(location), pingInterval, TimeUnit.MILLISECONDS);
-        } catch(RejectedExecutionException e) {
-          //ignore, the timer has been cancelled, which means we're shutting down.
+          background.schedule(new ExpireBlackListTask(location), pingInterval,
+              TimeUnit.MILLISECONDS);
+        } catch (RejectedExecutionException e) {
+          // ignore, the timer has been cancelled, which means we're shutting down.
-        
+
-  
+
-  
+
-  
-  
+
+
-    
+
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-  
-  public static interface BlackListListener { 
+
+  public static interface BlackListListener {
-    
+
-  
+
-      //do nothing
+      // do nothing
-      //do nothing      
+      // do nothing
-  
+
-    
+
-      for(Iterator itr = listeners.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = listeners.iterator(); itr.hasNext();) {
-      for(Iterator itr = listeners.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = listeners.iterator(); itr.hasNext();) {

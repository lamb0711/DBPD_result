Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A listener which will try to resend the instantiators to all servers if the
- * entire server distributed system was lost and came back one line. This
- * listener also takes care of sending the initial list of instantiators to the servers <br>
- * <br> 
- * TODO - There is a window in which all of the servers could crash and come
- * back up and we would connect to a new server before realizing that all the
- * servers crashed. To fix this, we would need to get some kind of birthdate of
- * the server ds we connect and use that to decide if we need to recover
- * instantiators. As it is, the window is not very large.
+ * A listener which will try to resend the instantiators to all servers if the entire server
+ * distributed system was lost and came back one line. This listener also takes care of sending the
+ * initial list of instantiators to the servers <br>
+ * <br>
+ * TODO - There is a window in which all of the servers could crash and come back up and we would
+ * connect to a new server before realizing that all the servers crashed. To fix this, we would need
+ * to get some kind of birthdate of the server ds we connect and use that to decide if we need to
+ * recover instantiators. As it is, the window is not very large.
-  
+
-  
+
-  
+
-      logger.debug("InstantiatorRecoveryTask - EndpointNoLongerInUse. Now have {} endpoints", count);
+      logger.debug("InstantiatorRecoveryTask - EndpointNoLongerInUse. Now have {} endpoints",
+          count);
-    int count  = endpointCount.incrementAndGet();
+    int count = endpointCount.incrementAndGet();
-    if(count == 1) {
-      synchronized(recoveryScheduledLock) {
-        if(!recoveryScheduled) {
+    if (count == 1) {
+      synchronized (recoveryScheduledLock) {
+        if (!recoveryScheduled) {
-          } catch(RejectedExecutionException e) {
-            //ignore, the timer has been cancelled, which means we're shutting down.
+          } catch (RejectedExecutionException e) {
+            // ignore, the timer has been cancelled, which means we're shutting down.
-  
+
-      synchronized(recoveryScheduledLock) {
+      synchronized (recoveryScheduledLock) {
-      Object[] objects = InternalInstantiator
-          .getInstantiatorsForSerialization();
+      Object[] objects = InternalInstantiator.getInstantiatorsForSerialization();
-      //Fix for bug:40930
+      // Fix for bug:40930
-        background.schedule(new RecoveryTask(), pingInterval,
-            TimeUnit.MILLISECONDS);
+        background.schedule(new RecoveryTask(), pingInterval, TimeUnit.MILLISECONDS);
-      }
-      else {
+      } else {
-        } 
-        catch (CancelException e) {
+        } catch (CancelException e) {
-        }
-        catch (RejectedExecutionException e) {
+        } catch (RejectedExecutionException e) {
-        }
-        catch(Exception e) {
+        } catch (Exception e) {
-          
+
-            logger.warn(LocalizedMessage.create(
-              LocalizedStrings.InstantiatorRecoveryListener_INSTANTIATORRECOVERYTASK_ERROR_RECOVERING_INSTANTIATORS),
-              e);
+            logger.warn(
+                LocalizedMessage.create(
+                    LocalizedStrings.InstantiatorRecoveryListener_INSTANTIATORRECOVERYTASK_ERROR_RECOVERING_INSTANTIATORS),
+                e);

Merge branch 'develop' into feature/GEODE-53

-    if( this.buckToDispatchLock == null) {
-      this.buckToDispatchLock = new StoppableReentrantLock(sender.getCancelCriterion());
+    if( buckToDispatchLock == null) {
+      buckToDispatchLock = new StoppableReentrantLock(sender.getCancelCriterion());
-    if(this.regionToDispatchedKeysMapEmpty == null) {
-      this.regionToDispatchedKeysMapEmpty = this.buckToDispatchLock.newCondition();
+    if(regionToDispatchedKeysMapEmpty == null) {
+      regionToDispatchedKeysMapEmpty = buckToDispatchLock.newCondition();
-      if (this.removalThread == null) {
-        this.removalThread = new BatchRemovalThread(
+      if (removalThread == null) {
+        removalThread = new BatchRemovalThread(
-        this.removalThread.start();
+        removalThread.start();
-       * Here, enqueTempEvents need to be invoked when a sender is already
+         * Here, enqueueTempEvents need to be invoked when a sender is already
-       * started later, the enqueTempEvents is done in the start() method of
+       * started later, the enqueueTempEvents is done in the start() method of
-        ((AbstractGatewaySender)sender).enqueTempEvents();
+        ((AbstractGatewaySender)sender).enqueueTempEvents();
-       * Here, enqueTempEvents need to be invoked when a sender is already
+       * Here, enqueueTempEvents need to be invoked when a sender is already
-       * started later, the enqueTempEvents is done in the start() method of
+       * started later, the enqueueTempEvents is done in the start() method of
-        ((AbstractGatewaySender)sender).enqueTempEvents();
+        ((AbstractGatewaySender)sender).enqueueTempEvents();
-    buckToDispatchLock.lock();
-    boolean wasEmpty = regionToDispatchedKeysMap.isEmpty();
-    try {
-      Map bucketIdToDispatchedKeys = (Map)regionToDispatchedKeysMap.get(prQ.getFullPath());
-      if (bucketIdToDispatchedKeys == null) {
-        bucketIdToDispatchedKeys = new ConcurrentHashMap();
-        regionToDispatchedKeysMap.put(prQ.getFullPath(), bucketIdToDispatchedKeys);
+    StoppableReentrantLock lock = buckToDispatchLock;
+    if (lock != null) {
+      lock.lock();
+      boolean wasEmpty = regionToDispatchedKeysMap.isEmpty();
+      try {
+        Map bucketIdToDispatchedKeys = (Map)regionToDispatchedKeysMap.get(prQ.getFullPath());
+        if (bucketIdToDispatchedKeys == null) {
+          bucketIdToDispatchedKeys = new ConcurrentHashMap();
+          regionToDispatchedKeysMap.put(prQ.getFullPath(), bucketIdToDispatchedKeys);
+        }
+        addRemovedEventToMap(bucketIdToDispatchedKeys, bucketId, key);
+        if (wasEmpty) {
+          regionToDispatchedKeysMapEmpty.signal();        
+        }
-      addRemovedEventToMap(bucketIdToDispatchedKeys, bucketId, key);
-      if (wasEmpty) {
-        regionToDispatchedKeysMapEmpty.signal();        
+      finally {
+        lock.unlock();  
-    finally {
-      buckToDispatchLock.unlock();  
-    }
-    if (buckToDispatchLock != null) {
-      buckToDispatchLock = null;
-    }
-    if (regionToDispatchedKeysMapEmpty != null) {
-      regionToDispatchedKeysMapEmpty = null;
-    }
+    buckToDispatchLock = null;
+    regionToDispatchedKeysMapEmpty = null;

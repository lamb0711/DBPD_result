GEODE-7728: Fix Assertion Failures in OQL (#4639)

- Added unit and integration tests.
- Back off from the single index optimisation during join queries if
  we can't find the (single) best filter, allowing the regular
  execution to continue and use multiple indexes.
- If there are multiple indexes, add the filter evaluable operand at
  the beginning of the internal list to evaluate it first in the chain.
+import java.util.Arrays;
-      RuntimeIterator indpnds[], CompiledValue iterOp) {
+      RuntimeIterator[] indpnds, CompiledValue iterOp) {
-  AbstractGroupOrRangeJunction recreateFromOld(boolean completeExpansion, RuntimeIterator indpnds[],
+  AbstractGroupOrRangeJunction recreateFromOld(boolean completeExpansion, RuntimeIterator[] indpnds,
-    List evalOperands = new ArrayList(_operands.length);
+    List<Object> evalOperands = new ArrayList<>(_operands.length);
-        for (int i = 0; i < _operands.length; i++) {
-          if (_operands[i].getPlanInfo(context).evalAsFilter) {
+        for (CompiledValue operand : _operands) {
+          if (operand.getPlanInfo(context).evalAsFilter) {
-            evalOperands.add(0, _operands[i]);
+            evalOperands.add(0, operand);
-            evalOperands.add(_operands[i]);
+            evalOperands.add(operand);
-        for (int i = 0; i < _operands.length; i++) {
+        for (CompiledValue operand : _operands) {
-          PlanInfo pi = _operands[i].getPlanInfo(context);
+          PlanInfo pi = operand.getPlanInfo(context);
-              currentBestFilter = (Filter) _operands[i];
-              currentBestFilterSize = ((Filter) _operands[i]).getSizeEstimate(context);
+              currentBestFilter = (Filter) operand;
+              currentBestFilterSize = ((Filter) operand).getSizeEstimate(context);
-              currentBestFilter = (Filter) _operands[i];
-              currentBestFilterSize = ((Filter) _operands[i]).getSizeEstimate(context);
-            } else if (foundPreferredCondition || currentBestFilter
-                .isBetterFilter((Filter) _operands[i], context, currentBestFilterSize)) {
-              evalOperands.add(_operands[i]);
+              currentBestFilter = (Filter) operand;
+              currentBestFilterSize = ((Filter) operand).getSizeEstimate(context);
+            } else if (foundPreferredCondition || currentBestFilter.isBetterFilter((Filter) operand,
+                context, currentBestFilterSize)) {
+              evalOperands.add(operand);
-              currentBestFilter = (Filter) _operands[i];
+              currentBestFilter = (Filter) operand;
-              currentBestFilterSize = ((Filter) _operands[i]).getSizeEstimate(context);
+              currentBestFilterSize = ((Filter) operand).getSizeEstimate(context);
-          } else if (!_operands[i].isDependentOnCurrentScope(context)) {
+          } else if (!operand.isDependentOnCurrentScope(context)) {
-            evalOperands.add(_operands[i]);
+            // Back off from the 1-index solution.
+            if (pi.indexes.size() > 1) {
+              // Add the filter evaluable operand at the beginning of the list.
+              evalOperands.add(0, operand);
+            } else {
+              // No indexes, just add the operand.
+              evalOperands.add(operand);
+            }
-        evalOperands.add(0, currentBestFilter);
+
+        // Don't add null to the list of operands.
+        if (currentBestFilter != null) {
+          evalOperands.add(0, currentBestFilter);
+        }
-      for (int i = 0; i < indexCount; i++) {
-        evalOperands.add(_operands[i]);
-      }
+      evalOperands.addAll(Arrays.asList(_operands).subList(0, indexCount));
+
-  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+  public int getSizeEstimate(ExecutionContext context) {

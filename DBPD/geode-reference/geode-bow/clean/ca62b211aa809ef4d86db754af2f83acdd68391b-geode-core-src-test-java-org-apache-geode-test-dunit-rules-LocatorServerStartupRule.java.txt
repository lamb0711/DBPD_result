GEODE-4110: extend LocatorServerStartupRule to start a client VM. (#1175)

* created a new ClientCacheRule to create a client cache in current VM.
* have lcoatorserverStartupRule to use that rule to start up a client VM.
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_AUTH_INIT;
-import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Consumer;
-import java.util.stream.IntStream;
+import org.apache.geode.cache.client.ClientCache;
+import org.apache.geode.cache.client.ClientCacheFactory;
+import org.apache.geode.security.templates.UserPasswordAuthInit;
+import org.apache.geode.test.junit.rules.ClientCacheRule;
+import org.apache.geode.test.junit.rules.VMProvider;
+  public static ClientCacheRule clientCacheRule;
-  private ArrayList<MemberVM> members;
+  private Map<Integer, VMProvider> occupiedVMs;
+  public static ClientCache getClientCache() {
+    return clientCacheRule.getCache();
+  }
+
-    members = new ArrayList<>();
+    occupiedVMs = new HashMap<>();
-      IntStream.range(0, members.size()).forEach(this::stopVM);
+
+      // stop all the clientsVM before stop all the memberVM
+      occupiedVMs.values().stream().forEach(x -> x.stopVM(true));
-
-    return setMember(index, new MemberVM(locator, locatorVM, useTempWorkingDir()));
-  }
-
-  private MemberVM setMember(int index, MemberVM element) {
-    while (members.size() <= index) {
-      members.add(null);
-    }
-    members.set(index, element);
-    return members.get(index);
+    MemberVM memberVM = new MemberVM(locator, locatorVM, useTempWorkingDir());
+    occupiedVMs.put(index, memberVM);
+    return memberVM;
-    return setMember(index, new MemberVM(server, serverVM, useTempWorkingDir()));
-  }
-  public void startServerVMAsync(int index) {
-    startServerVMAsync(index, new Properties(), -1);
-  }
-
-  public void startServerVMAsync(int index, int locatorPort) {
-    startServerVMAsync(index, new Properties(), locatorPort);
-  }
-
-  public void startServerVMAsync(int index, Properties specifiedProperties, int locatorPort) {
-    assert members.get(index) != null;
-
-    Properties properties = new Properties();
-    properties.putAll(specifiedProperties);
-
-    String defaultName = "server-" + index;
-    properties.putIfAbsent(NAME, defaultName);
-    String name = properties.getProperty(NAME);
-
-    VM serverVM = getVM(index);
-    serverVM.invokeAsync(() -> {
-      memberStarter = new ServerStarterRule();
-      ServerStarterRule serverStarter = (ServerStarterRule) memberStarter;
-      if (useTempWorkingDir()) {
-        File workingDirFile = createWorkingDirForMember(name);
-        serverStarter.withWorkingDir(workingDirFile);
-      }
-      if (logFile) {
-        serverStarter.withLogFile();
-      }
-      serverStarter.withProperties(properties).withConnectionToLocator(locatorPort).withAutoStart();
-      serverStarter.before();
-    });
+    MemberVM memberVM = new MemberVM(server, serverVM, useTempWorkingDir());
+    occupiedVMs.put(index, memberVM);
+    return memberVM;
-  public MemberVM startServerAsJmxManager(int index, Properties properties, int locatorPort)
-      throws IOException {
-    properties.setProperty(JMX_MANAGER_PORT, AvailablePortHelper.getRandomAvailableTCPPort() + "");
-    return startServerVM(index, properties, locatorPort);
-  }
-
-    return setMember(index, new MemberVM(server, serverVM, useTempWorkingDir()));
+
+    MemberVM memberVM = new MemberVM(server, serverVM, useTempWorkingDir());
+    occupiedVMs.put(index, memberVM);
+    return memberVM;
-    MemberVM member = members.get(index);
-    // user has started a server/locator in this VM
-    if (member != null) {
-      member.stopMember(cleanWorkingDir);
+    VMProvider member = occupiedVMs.get(index);
+
+    if (member == null)
+      return;
+
+    member.stopVM(cleanWorkingDir);
+  }
+
+  public ClientVM startClientVM(int index, String username, String password,
+      boolean subscriptionEnabled, int... serverPorts) throws Exception {
+    Properties props = new Properties();
+    props.setProperty(UserPasswordAuthInit.USER_NAME, username);
+    props.setProperty(UserPasswordAuthInit.PASSWORD, password);
+    props.setProperty(SECURITY_CLIENT_AUTH_INIT, UserPasswordAuthInit.class.getName());
+
+    Consumer<ClientCacheFactory> consumer =
+        (Serializable & Consumer<ClientCacheFactory>) ((cacheFactory) -> {
+          cacheFactory.setPoolSubscriptionEnabled(subscriptionEnabled);
+          for (int serverPort : serverPorts) {
+            cacheFactory.addPoolServer("localhost", serverPort);
+          }
+        });
+    return startClientVM(index, props, consumer);
+  }
+
+  public ClientVM startClientVM(int index, Properties properties,
+      Consumer<ClientCacheFactory> cacheFactorySetup) throws Exception {
+    VM client = getVM(index);
+    Exception error = client.invoke(() -> {
+      clientCacheRule =
+          new ClientCacheRule().withProperties(properties).withCacheSetup(cacheFactorySetup);
+      try {
+        clientCacheRule.before();
+        return null;
+      } catch (Exception e) {
+        return e;
+      }
+    });
+    if (error != null) {
+      throw error;
-    // user may have used this VM as a client VM
-    else {
-      getVM(index).invoke(() -> MemberStarterRule.disconnectDSIfAny());
-    }
+    ClientVM clientVM = new ClientVM(client);
+    occupiedVMs.put(index, clientVM);
+    return clientVM;
-    return members.get(index);
+    return (MemberVM) occupiedVMs.get(index);
-  public static void stopMemberInThisVM() {
+  public static void stopElementInsideVM() {
+    if (clientCacheRule != null) {
+      clientCacheRule.after();
+      clientCacheRule = null;
+    }

Merge branch 'release/1.5.0'

-import java.io.InputStream;
-import java.io.OutputStream;
+import java.util.HashSet;
+import java.util.Set;
-import org.apache.geode.internal.protocol.protobuf.v1.ClientProtocol;
+import org.apache.geode.internal.protocol.protobuf.v1.ClientProtocol.Message;
+import org.apache.geode.internal.protocol.protobuf.v1.ClientProtocol.Message.MessageTypeCase;
+import org.apache.geode.internal.protocol.protobuf.v1.RegionAPI.GetRegionRequest;
+import org.apache.geode.internal.protocol.protobuf.v1.RegionAPI.GetRequest;
+import org.apache.geode.internal.protocol.protobuf.v1.RegionAPI.PutRequest;
+import org.apache.geode.internal.protocol.protobuf.v1.RegionAPI.RemoveRequest;
-  /**
-   * Socket to a GemFire server that has Protobuf enabled.
-   */
-  final Socket socket;
+  final ProtobufChannel protobufChannel;
-   * @param socket Socket to a GemFire server that has Protobuf enabled.
-  ProtobufRegion(String name, Socket socket) {
+  ProtobufRegion(String name, ProtobufChannel channel) {
-    this.socket = socket;
+    this.protobufChannel = channel;
-  @Override
-  public V get(K key) throws IOException {
-    final OutputStream outputStream = socket.getOutputStream();
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder().setGetRequest(RegionAPI.GetRequest
-            .newBuilder().setRegionName(name).setKey(ValueEncoder.encodeValue(key))))
-        .build().writeDelimitedTo(outputStream);
-
-    final InputStream inputStream = socket.getInputStream();
-    return (V) ValueEncoder.decodeValue(ClientProtocol.Message.parseDelimitedFrom(inputStream)
-        .getResponse().getGetResponse().getResult());
-  }
-    final OutputStream outputStream = socket.getOutputStream();
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder()
-            .setGetRegionRequest(RegionAPI.GetRegionRequest.newBuilder().setRegionName(name)))
-        .build().writeDelimitedTo(outputStream);
+    final Message request = Message.newBuilder()
+        .setGetRegionRequest(GetRegionRequest.newBuilder().setRegionName(name)).build();
-    final InputStream inputStream = socket.getInputStream();
-    return new RegionAttributes(ClientProtocol.Message.parseDelimitedFrom(inputStream).getResponse()
-        .getGetRegionResponse().getRegion());
+    return new RegionAttributes(
+        protobufChannel.sendRequest(request, MessageTypeCase.GETREGIONRESPONSE)
+            .getGetRegionResponse().getRegion());
+  public V get(K key) throws IOException {
+    Message request = Message.newBuilder()
+        .setGetRequest(
+            GetRequest.newBuilder().setRegionName(name).setKey(ValueEncoder.encodeValue(key)))
+        .build();
+    final Message response = protobufChannel.sendRequest(request, MessageTypeCase.GETRESPONSE);
+
+    return (V) ValueEncoder.decodeValue(response.getGetResponse().getResult());
+  }
+
+  @Override
-    final OutputStream outputStream = socket.getOutputStream();
-      getAllRequest.addKey(ValueEncoder.encodeValue(key.toString()));
+      getAllRequest.addKey(ValueEncoder.encodeValue(key));
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder().setGetAllRequest(getAllRequest)).build()
-        .writeDelimitedTo(outputStream);
+    Message request = Message.newBuilder().setGetAllRequest(getAllRequest).build();
-    final InputStream inputStream = socket.getInputStream();
-    final RegionAPI.GetAllResponse getAllResponse =
-        ClientProtocol.Message.parseDelimitedFrom(inputStream).getResponse().getGetAllResponse();
+    Message message = protobufChannel.sendRequest(request, MessageTypeCase.GETALLRESPONSE);
+
+    final RegionAPI.GetAllResponse getAllResponse = message.getGetAllResponse();
+    Map<Object, String> failures = new HashMap<>();
+    if (getAllResponse.getFailuresCount() > 0) {
+      for (BasicTypes.KeyedError keyedError : getAllResponse.getFailuresList()) {
+        failures.put(ValueEncoder.decodeValue(keyedError.getKey()),
+            keyedError.getError().getMessage());
+      }
+      throw new IOException("Unable to process the following keys: " + failures);
+    }
-    final OutputStream outputStream = socket.getOutputStream();
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder()
-            .setPutRequest(RegionAPI.PutRequest.newBuilder().setRegionName(name)
-                .setEntry(ValueEncoder.encodeEntry(key, value))))
-        .build().writeDelimitedTo(outputStream);
+    final Message request = Message.newBuilder().setPutRequest(
+        PutRequest.newBuilder().setRegionName(name).setEntry(ValueEncoder.encodeEntry(key, value)))
+        .build();
-    final InputStream inputStream = socket.getInputStream();
-    ClientProtocol.Message.parseDelimitedFrom(inputStream).getResponse().getPutResponse();
+    protobufChannel.sendRequest(request, MessageTypeCase.PUTRESPONSE);
-    final OutputStream outputStream = socket.getOutputStream();
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder().setPutAllRequest(putAllRequest)).build()
-        .writeDelimitedTo(outputStream);
+    final Message request = Message.newBuilder().setPutAllRequest(putAllRequest).build();
-    final InputStream inputStream = socket.getInputStream();
-        ClientProtocol.Message.parseDelimitedFrom(inputStream).getResponse().getPutAllResponse();
+        protobufChannel.sendRequest(request, MessageTypeCase.PUTALLRESPONSE).getPutAllResponse();
-      StringBuilder builder = new StringBuilder();
+      Map<Object, String> failures = new HashMap<>();
-        if (0 < builder.length()) {
-          builder.append(", ");
-        }
-        builder.append(ValueEncoder.decodeValue(keyedError.getKey()).toString());
+        failures.put(ValueEncoder.decodeValue(keyedError.getKey()),
+            keyedError.getError().getMessage());
-      throw new IOException("Unable to put the following keys: " + builder.toString());
+      throw new IOException("Unable to put the following keys: " + failures);
-    final OutputStream outputStream = socket.getOutputStream();
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder().setRemoveRequest(RegionAPI.RemoveRequest
-            .newBuilder().setRegionName(name).setKey(ValueEncoder.encodeValue(key))))
-        .build().writeDelimitedTo(outputStream);
+    final Message request = Message.newBuilder()
+        .setRemoveRequest(
+            RemoveRequest.newBuilder().setRegionName(name).setKey(ValueEncoder.encodeValue(key)))
+        .build();
-    final InputStream inputStream = socket.getInputStream();
-    ClientProtocol.Message.parseDelimitedFrom(inputStream).getResponse().getRemoveResponse();
+    protobufChannel.sendRequest(request, MessageTypeCase.REMOVERESPONSE);
+  }
+
+  @Override
+  public Set<K> keySet() throws IOException {
+    final Message request = Message.newBuilder()
+        .setKeySetRequest(RegionAPI.KeySetRequest.newBuilder().setRegionName(name)).build();
+    final Message message = protobufChannel.sendRequest(request, MessageTypeCase.KEYSETRESPONSE);
+    final RegionAPI.KeySetResponse keySetResponse = message.getKeySetResponse();
+
+    Set<K> keys = new HashSet<>(keySetResponse.getKeysCount());
+    for (BasicTypes.EncodedValue value : keySetResponse.getKeysList()) {
+      keys.add((K) ValueEncoder.decodeValue(value));
+    }
+    return keys;

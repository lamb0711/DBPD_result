Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * If this is a primary member,
-   * for each entry in TXState, generate next region version
-   * and store in the entry.
+   * If this is a primary member, for each entry in TXState, generate next region version and store
+   * in the entry.
-    Iterator<Map.Entry<LocalRegion, TXRegionState>> it = this.regions
-        .entrySet().iterator();
+    Iterator<Map.Entry<LocalRegion, TXRegionState>> it = this.regions.entrySet().iterator();
-      
+
-                //txes.setNextRegionVersion(v);
+                // txes.setNextRegionVersion(v);
-                  logger.debug("Set next region version to "+ v + " for region="+r.getName() + "in TXEntryState for key"+key );  
+                  logger.debug("Set next region version to " + v + " for region=" + r.getName()
+                      + "in TXEntryState for key" + key);
-  }  
-  
+  }
+
-   * Iterate through all changes and for those changes for which
-   * this member hosts a primary bucket, generate a tail key and store in
-   * the TXEntryState.  From there it is expected to be carried over
-   * to the secondaries in phase-2 commit.
-   * In phase-2 commit, the both the primary and secondaries should
-   * use this tail key to enqueue into parallel queues.
+   * Iterate through all changes and for those changes for which this member hosts a primary bucket,
+   * generate a tail key and store in the TXEntryState. From there it is expected to be carried over
+   * to the secondaries in phase-2 commit. In phase-2 commit, the both the primary and secondaries
+   * should use this tail key to enqueue into parallel queues.
-    Iterator<Map.Entry<LocalRegion, TXRegionState>> it = this.regions
-        .entrySet().iterator();
+    Iterator<Map.Entry<LocalRegion, TXRegionState>> it = this.regions.entrySet().iterator();
-  
+
-        BucketRegion bRegion = (BucketRegion)region;
+        BucketRegion bRegion = (BucketRegion) region;
-            
-            // Generate a tail key for each entry 
+
+            // Generate a tail key for each entry
-                
-                long tailKey = ((BucketRegion)region).generateTailKey();    
+
+                long tailKey = ((BucketRegion) region).generateTailKey();
-              } 
-            } 
+              }
+            }
-  
+
-   * Take Locks Does conflict check on primary ([DISTTX] TODO on primary only)
-   * Invoke TxWriter
+   * Take Locks Does conflict check on primary ([DISTTX] TODO on primary only) Invoke TxWriter
-  public void precommit() throws CommitConflictException,
-      UnsupportedOperationInTransactionException {
+  public void precommit()
+      throws CommitConflictException, UnsupportedOperationInTransactionException {
-      logger.debug("DistTXState.precommit transaction {} is closed {} ",
-          getTransactionId(), this.closed, new Throwable());
+      logger.debug("DistTXState.precommit transaction {} is closed {} ", getTransactionId(),
+          this.closed, new Throwable());
-    
+
-          LocalizedStrings.TXState_CANNOT_COMMIT_REMOTED_TRANSACTION
-              .toLocalizedString());
+          LocalizedStrings.TXState_CANNOT_COMMIT_REMOTED_TRANSACTION.toLocalizedString());
-     * Lock buckets so they can't be rebalanced then perform the conflict check
-     * to fix #43489
+     * Lock buckets so they can't be rebalanced then perform the conflict check to fix #43489
-    
+
-    
+
-    
+
-     * If there is a TransactionWriter plugged in, we need to to give it an
-     * opportunity to abort the transaction.
+     * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort the
+     * transaction.
-      logger.debug(
-          "DistTXState.commit transaction {} is closed {} ",
-          getTransactionId(), this.closed, new Throwable());
+      logger.debug("DistTXState.commit transaction {} is closed {} ", getTransactionId(),
+          this.closed, new Throwable());
-      List/* <TXEntryStateWithRegionAndKey> */entries = generateEventOffsets();
+      List/* <TXEntryStateWithRegionAndKey> */ entries = generateEventOffsets();
-        
+
-        
+
-        // This is applicable only for partitioned regions and 
+        // This is applicable only for partitioned regions and
-        // If an another method of notifying adjunct receivers is implemented, 
+        // If an another method of notifying adjunct receivers is implemented,
-        
+
-  
+
+   * 
-    TXCommitMessage msg = new DistTXAdjunctCommitMessage(this.proxy.getTxId(), this.proxy.getTxMgr().getDM(), this);
+    TXCommitMessage msg =
+        new DistTXAdjunctCommitMessage(this.proxy.getTxId(), this.proxy.getTxMgr().getDM(), this);
-      
+
-        txrs.buildMessageForAdjunctReceivers(r, msg);  
+        txrs.buildMessageForAdjunctReceivers(r, msg);
-      
+
-      setUpdatingTxStateDuringPreCommit(true); 
-      
+      setUpdatingTxStateDuringPreCommit(true);
+
-            + "secondaryTransactionalOperations = {}",
-            secondaryTransactionalOperations.size());
+            + "secondaryTransactionalOperations = {}", secondaryTransactionalOperations.size());
-       * operateOnPartitionedRegion(DistributionManager, PartitionedRegion,
-       * long)
+       * operateOnPartitionedRegion(DistributionManager, PartitionedRegion, long)
-          logger.debug("DistTXState.applyOpOnRedundantCopy: processing dist "
-              + "tx operation {}", dtop);
+          logger.debug("DistTXState.applyOpOnRedundantCopy: processing dist " + "tx operation {}",
+              dtop);
-         * [DISTTX} TODO handle call back argument version tag and other
-         * settings in PutMessage
+         * [DISTTX} TODO handle call back argument version tag and other settings in PutMessage
-            dtop.getKeyInfo().setCheckPrimary(false); 
-          }
-          else {
+            dtop.getKeyInfo().setCheckPrimary(false);
+          } else {
-            dtop.getKeyInfo().setCheckPrimary(false); 
+            dtop.getKeyInfo().setCheckPrimary(false);
-          //apply the op
+          // apply the op
-          
+
-          logger.debug("DistTXState.applyOpOnRedundantCopy {} ##op {},  "
-              + "##region {}, ##key {}", 
-              (result ? " sucessfully applied op " : " failed to apply op due to "+ failureReason), 
+          logger.debug("DistTXState.applyOpOnRedundantCopy {} ##op {},  " + "##region {}, ##key {}",
+              (result ? " sucessfully applied op " : " failed to apply op due to " + failureReason),
-   * Calls local function such as putEntry instead of putEntryOnRemote as for
-   * this {@link DistTXStateOnCoordinator} as events will always be local. In
-   * parent {@link DistTXState} class will call remote version of functions
+   * Calls local function such as putEntry instead of putEntryOnRemote as for this
+   * {@link DistTXStateOnCoordinator} as events will always be local. In parent {@link DistTXState}
+   * class will call remote version of functions
-  protected boolean applyIndividualOp(DistTxEntryEvent dtop)
-      throws DataLocationException {
+  protected boolean applyIndividualOp(DistTxEntryEvent dtop) throws DataLocationException {
-    if (dtop.op.isUpdate() || dtop.op.isCreate()) { 
+    if (dtop.op.isUpdate() || dtop.op.isCreate()) {
-        assert(dtop.getPutAllOperation() != null);
-        //[DISTTX] TODO what do with versions next?
+        assert (dtop.getPutAllOperation() != null);
+        // [DISTTX] TODO what do with versions next?
-            dtop.getPutAllOperation().putAllDataSize, true,
-            dtop.region.concurrencyChecksEnabled);
+            dtop.getPutAllOperation().putAllDataSize, true, dtop.region.concurrencyChecksEnabled);
-        result = putEntryOnRemote(dtop, false/* ifNew */,
-          false/* ifOld */, null/* expectedOldValue */,
-          false/* requireOldValue */, 0L/* lastModified */, true/*
-                                                                 * overwriteDestroyed
-                                                                 * *not*
-                                                                 * used
-                                                                 */);
+        result = putEntryOnRemote(dtop, false/* ifNew */, false/* ifOld */,
+            null/* expectedOldValue */, false/* requireOldValue */, 0L/* lastModified */,
+            true/*
+                 * overwriteDestroyed *not* used
+                 */);
-        final VersionedObjectList versions = new VersionedObjectList(
-            dtop.getRemoveAllOperation().removeAllDataSize, true,
-            dtop.region.concurrencyChecksEnabled);
+        final VersionedObjectList versions =
+            new VersionedObjectList(dtop.getRemoveAllOperation().removeAllDataSize, true,
+                dtop.region.concurrencyChecksEnabled);
-                                                             * TODO
-                                                             * [DISTTX]
+                                                             * TODO [DISTTX]
-                                                              * TODO
-                                                              * [DISTTX]
+                                                              * TODO [DISTTX]
-      logger.debug("DistTXCommitPhaseOneMessage: unsupported TX operation {}",
-          dtop);
+      logger.debug("DistTXCommitPhaseOneMessage: unsupported TX operation {}", dtop);
-  
+
-   * @param updatingTxState
-   *          if updating TxState during Commit Phase
+   * @param updatingTxState if updating TxState during Commit Phase
-      logger
-          .debug(
-              "DistTXState setUpdatingTxStateDuringPreCommit incoming {} final {} ",
-              updatingTxState, this.updatingTxStateDuringPreCommit,
-              new Throwable()); // [DISTTX] TODO: Remove throwable
+      logger.debug("DistTXState setUpdatingTxStateDuringPreCommit incoming {} final {} ",
+          updatingTxState, this.updatingTxStateDuringPreCommit, new Throwable()); // [DISTTX] TODO:
+                                                                                  // Remove
+                                                                                  // throwable
-  
-  
+
+
-   * [DISTTX] Note: This has been overridden here to associate DistKeyInfo
-   * with event to disable primary check(see DistKeyInfo.setCheckPrimary(false)) 
-   * when this gets called on secondary of a PR 
+   * [DISTTX] Note: This has been overridden here to associate DistKeyInfo with event to disable
+   * primary check(see DistKeyInfo.setCheckPrimary(false)) when this gets called on secondary of a
+   * PR
-   * @see
-   * org.apache.geode.internal.cache.InternalDataView#postPutAll(org.apache
+   * @see org.apache.geode.internal.cache.InternalDataView#postPutAll(org.apache
-     * We are on the data store, we don't need to do anything here. Commit will
-     * push them out.
+     * We are on the data store, we don't need to do anything here. Commit will push them out.
-        InternalDistributedMember myId = theRegion.getDistributionManager()
-            .getDistributionManagerId();
+        InternalDistributedMember myId =
+            theRegion.getDistributionManager().getDistributionManagerId();
-          @Released EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(theRegion,
-              myId, myId, i, putallOp.putAllData, false, putallOp
-                  .getBaseEvent().getContext(), false, !putallOp.getBaseEvent()
-                  .isGenerateCallbacks());
+          @Released
+          EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(theRegion, myId, myId, i,
+              putallOp.putAllData, false, putallOp.getBaseEvent().getContext(), false,
+              !putallOp.getBaseEvent().isGenerateCallbacks());
-//            ev.setPutAllOperation(putallOp);
-            
+            // ev.setPutAllOperation(putallOp);
+
-             * Whenever commit is called, especially when its a
-             * DistTxStateOnCoordinator the txState is set to null in @see
-             * TXManagerImpl.commit() and thus when @see LocalRegion.basicPut
-             * will be called as in this function, they will not found a TxState
-             * with call for getDataView()
+             * Whenever commit is called, especially when its a DistTxStateOnCoordinator the txState
+             * is set to null in @see TXManagerImpl.commit() and thus when @see LocalRegion.basicPut
+             * will be called as in this function, they will not found a TxState with call for
+             * getDataView()
-                successfulPuts.addKeyAndVersion(putallOp.putAllData[i].key,
-                    null);
+                successfulPuts.addKeyAndVersion(putallOp.putAllData[i].key, null);
-  
+
-     * Don't fire events here. We are on the data store, we don't need to do
-     * anything here. Commit will push them out. We need to put this into the tx
-     * state.
+     * Don't fire events here. We are on the data store, we don't need to do anything here. Commit
+     * will push them out. We need to put this into the tx state.
-        InternalDistributedMember myId = theRegion.getDistributionManager()
-            .getDistributionManagerId();
+        InternalDistributedMember myId =
+            theRegion.getDistributionManager().getDistributionManagerId();
-          @Released EntryEventImpl ev = RemoveAllPRMessage.getEventFromEntry(theRegion,
-              myId, myId, i, op.removeAllData, false, op.getBaseEvent()
-                  .getContext(), false, !op.getBaseEvent()
-                  .isGenerateCallbacks());
+          @Released
+          EntryEventImpl ev = RemoveAllPRMessage.getEventFromEntry(theRegion, myId, myId, i,
+              op.removeAllData, false, op.getBaseEvent().getContext(), false,
+              !op.getBaseEvent().isGenerateCallbacks());
-          ev.setRemoveAllOperation(op);
-          // below if condition returns true on secondary when TXState is
-          // updated in preCommit only on secondary
-          // In this case disable the primary check by calling
-          // distKeyInfo.setCheckPrimary(false);
-          if (isUpdatingTxStateDuringPreCommit()) {
-            KeyInfo keyInfo = ev.getKeyInfo();
-            DistTxKeyInfo distKeyInfo = new DistTxKeyInfo(keyInfo);
-            distKeyInfo.setCheckPrimary(false);
-            ev.setKeyInfo(distKeyInfo);
-          }
-          /*
-           * Whenever commit is called, especially when its a
-           * DistTxStateOnCoordinator the txState is set to null in @see
-           * TXManagerImpl.commit() and thus when basicDestroy will be called
-           * will be called as in i.e. @see LocalRegion.basicDestroy, they will
-           * not found a TxState with call for getDataView()
-           * 
-           * [DISTTX] TODO verify if this is correct to call
-           * destroyExistingEntry directly?
-           */
-          try {
-            if (!(theRegion.getDataView() instanceof TXStateInterface)) {
-              destroyExistingEntry(ev, true/* should we invoke cacheWriter? */,
-                  null);
-            } else {
-              theRegion.basicDestroy(ev,
-                  true/* should we invoke cacheWriter? */, null);
+            ev.setRemoveAllOperation(op);
+            // below if condition returns true on secondary when TXState is
+            // updated in preCommit only on secondary
+            // In this case disable the primary check by calling
+            // distKeyInfo.setCheckPrimary(false);
+            if (isUpdatingTxStateDuringPreCommit()) {
+              KeyInfo keyInfo = ev.getKeyInfo();
+              DistTxKeyInfo distKeyInfo = new DistTxKeyInfo(keyInfo);
+              distKeyInfo.setCheckPrimary(false);
+              ev.setKeyInfo(distKeyInfo);
-          } catch (EntryNotFoundException ignore) {
-          }
-          successfulOps.addKeyAndVersion(op.removeAllData[i].key, null);
+            /*
+             * Whenever commit is called, especially when its a DistTxStateOnCoordinator the txState
+             * is set to null in @see TXManagerImpl.commit() and thus when basicDestroy will be
+             * called will be called as in i.e. @see LocalRegion.basicDestroy, they will not found a
+             * TxState with call for getDataView()
+             * 
+             * [DISTTX] TODO verify if this is correct to call destroyExistingEntry directly?
+             */
+            try {
+              if (!(theRegion.getDataView() instanceof TXStateInterface)) {
+                destroyExistingEntry(ev, true/* should we invoke cacheWriter? */, null);
+              } else {
+                theRegion.basicDestroy(ev, true/* should we invoke cacheWriter? */, null);
+              }
+            } catch (EntryNotFoundException ignore) {
+            }
+            successfulOps.addKeyAndVersion(op.removeAllData[i].key, null);
-  
+
-  
+
-            logger
-                .debug("DistTxState.populateDistTxEntryStateList Adding entries "
-                    + " with count="
-                    + entryStateList.size()
-                    + " for region "
-                    + regionFullPath + " . Added list=" + entryStateList);
+            logger.debug("DistTxState.populateDistTxEntryStateList Adding entries " + " with count="
+                + entryStateList.size() + " for region " + regionFullPath + " . Added list="
+                + entryStateList);
-            logger
-                .debug("DistTxState.populateDistTxEntryStateList Got exception for region "
-                    + regionFullPath);
+            logger.debug("DistTxState.populateDistTxEntryStateList Got exception for region "
+                + regionFullPath);
-          logger
-              .debug("DistTxState.populateDistTxEntryStateList Not adding entries for region "
-                  + regionFullPath);
+          logger.debug("DistTxState.populateDistTxEntryStateList Not adding entries for region "
+              + regionFullPath);
-  
+
-  public void setDistTxEntryStates(
-      ArrayList<ArrayList<DistTxThinEntryState>> entryEventList) {
+  public void setDistTxEntryStates(ArrayList<ArrayList<DistTxThinEntryState>> entryEventList) {
-        logger.debug("DistTxState.setDistTxEntryStates For region="
-            + regionFullPath + " ,index=" + index + " ,entryEvents=("
-            + entryEvents.size() + ")=" + entryEvents + " ,regionSortedMap="
-            + regionSortedMap.keySet());
+        logger.debug("DistTxState.setDistTxEntryStates For region=" + regionFullPath + " ,index="
+            + index + " ,entryEvents=(" + entryEvents.size() + ")=" + entryEvents
+            + " ,regionSortedMap=" + regionSortedMap.keySet());

GEODE-3413: overhaul launcher and process classes and tests

This is primarily an overall of all ServerLauncher and LocatorLauncher
tests and org.apache.geode.internal.process tests. The main classes in
org.apachage.geode.internal.process package are also cleaned up.

In addition, several bugs involving these classes and tests are fixed.

Here is the complete list of tickets that are resolved in this overhaul:

* GEODE-1229: LocatorLauncherRemoteJUnitTest.testStartOverwritesStalePidFile
* GEODE-2791: LocatorLauncherAssemblyIntegrationTest.testLocatorStopsWhenJmxPortIsNonZero fails intermittently with AssertionError
* GEODE-1308: CI failure: LocatorLauncherTest.testSetBindAddressToNonLocalHost
* GEODE-1309: CI failure: ServerLauncherTest.testSetServerBindAddressToNonLocalHost
* GEODE-3193: locator pid file is removed even if there was a problem while shutting down
* GEODE-3413: Overhaul launcher tests and process tests
* GEODE-3414: Cleanup org.apache.geode.internal.process package

Note I moved all useful tests from LocatorLauncherAssemblyIntegrationTest
into the other launcher tests in geode-core.

-
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+import static org.apache.commons.lang.StringUtils.join;
+import static org.apache.commons.lang.StringUtils.lowerCase;
-
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.unsafe.RegisterSignalHandlerSupport;
-import org.apache.geode.internal.AvailablePort;
-import org.apache.geode.internal.GemFireVersion;
-import org.apache.geode.internal.OSProcess;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.lang.ClassUtils;
-import org.apache.geode.internal.lang.ObjectUtils;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.lang.SystemUtils;
-import org.apache.geode.internal.process.PidUnavailableException;
-import org.apache.geode.internal.process.ProcessUtils;
-import org.apache.geode.internal.util.ArgumentRedactor;
-import org.apache.geode.internal.util.SunAPINotFoundException;
-import org.apache.geode.management.internal.cli.json.GfJsonObject;
+import static org.apache.geode.internal.lang.ClassUtils.forName;
+import static org.apache.geode.internal.lang.ObjectUtils.defaultIfNull;
+import static org.apache.geode.internal.lang.StringUtils.defaultString;
+import static org.apache.geode.internal.lang.SystemUtils.CURRENT_DIRECTORY;
+import java.io.UncheckedIOException;
+import java.net.URISyntaxException;
-import java.util.logging.FileHandler;
-import java.util.logging.Level;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.unsafe.RegisterSignalHandlerSupport;
+import org.apache.geode.internal.AvailablePort;
+import org.apache.geode.internal.GemFireVersion;
+import org.apache.geode.internal.OSProcess;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.process.PidUnavailableException;
+import org.apache.geode.internal.process.ProcessUtils;
+import org.apache.geode.internal.util.ArgumentRedactor;
+import org.apache.geode.internal.util.SunAPINotFoundException;
+import org.apache.geode.management.internal.cli.json.GfJsonObject;
+
+  /**
+   * @deprecated This timeout is no longer needed.
+   */
+  @Deprecated
-  public static final String DEFAULT_WORKING_DIRECTORY = SystemUtils.CURRENT_DIRECTORY;
+  public static final String DEFAULT_WORKING_DIRECTORY = CURRENT_DIRECTORY;
-        ClassUtils.forName(SUN_SIGNAL_API_CLASS_NAME, new SunAPINotFoundException(
+        forName(SUN_SIGNAL_API_CLASS_NAME, new SunAPINotFoundException(
-    } catch (SunAPINotFoundException e) {
-      info(e.getMessage());
+    } catch (SunAPINotFoundException handled) {
+      info(handled.getMessage());
-   * @see #assertPortAvailable
-              (bindAddress != null ? bindAddress.getCanonicalHostName() : "localhost")));
+              bindAddress != null ? bindAddress.getCanonicalHostName() : "localhost"));
-    return StringUtils.isNotBlank(properties.getProperty(propertyName));
+    return isNotBlank(properties.getProperty(propertyName));
-    final Properties properties = new Properties();
+    if (url == null) {
+      return new Properties();
+    }
+    Properties properties = new Properties();
-    if (url != null) {
-      try {
-        properties.load(new FileReader(new File(url.toURI())));
-      } catch (Exception e) {
-        try {
-          // not in the file system, try the classpath
-          properties.load(
-              AbstractLauncher.class.getResourceAsStream(DistributedSystem.getPropertiesFile()));
-        } catch (Exception ignore) {
-          // not in the file system or the classpath; gemfire.properties does not exist
-        }
-      }
+    try {
+      properties.load(new FileReader(new File(url.toURI())));
+    } catch (IOException | URISyntaxException handled) {
+      // not in the file system, try the classpath
+      loadGemFirePropertiesFromClassPath(properties);
-  void initLogger() {
+  private static void loadGemFirePropertiesFromClassPath(Properties properties) {
-      this.logger.addHandler(new FileHandler(SystemUtils.CURRENT_DIRECTORY.concat("debug.log")));
-      this.logger.setLevel(Level.ALL);
-      this.logger.setUseParentHandlers(true);
-    } catch (IOException e) {
-      e.printStackTrace(System.err);
-      System.err.flush();
-      throw new RuntimeException(e);
+      properties
+          .load(AbstractLauncher.class.getResourceAsStream(DistributedSystem.getPropertiesFile()));
+    } catch (IOException | NullPointerException handled) {
+      // leave the properties empty
-    if (StringUtils.isNotBlank(getMemberName())) {
+    if (isNotBlank(getMemberName())) {
-    } catch (IOException e) {
-      return getLogFileName(); // TODO: or return null?
+    } catch (IOException handled) {
+      return getLogFileName();
-    if (StringUtils.isNotBlank(getMemberName())) {
+    if (isNotBlank(getMemberName())) {
-    if (StringUtils.isNotBlank(getMemberId())) {
+    if (isNotBlank(getMemberId())) {
-    return (distributedSystem != null ? distributedSystem.getMemberId() : null);
+    return distributedSystem != null ? distributedSystem.getMemberId() : null;
-    return (distributedSystem != null ? distributedSystem.getConfig().getName() : null);
+    return distributedSystem != null ? distributedSystem.getConfig().getName() : null;
-    } catch (PidUnavailableException e) {
+    } catch (PidUnavailableException handled) {
-    // TODO refactor the logic in this method into a DateTimeFormatUtils class
-      return (timestamp == null ? ""
-          : new SimpleDateFormat(DATE_TIME_FORMAT_PATTERN).format(timestamp));
+      return timestamp == null ? ""
+          : new SimpleDateFormat(DATE_TIME_FORMAT_PATTERN).format(timestamp);
-      } catch (PidUnavailableException ignore) {
+      } catch (PidUnavailableException handled) {
-    // TODO refactor the logic in this method into a DateTimeFormatUtils class
-      this.jvmArguments = ObjectUtils.defaultIfNull(Collections.unmodifiableList(jvmArguments),
+      this.jvmArguments = defaultIfNull(Collections.unmodifiableList(jvmArguments),
-      return (serviceState == null || serviceState.isStartingOrNotResponding());
+      return serviceState == null || serviceState.isStartingOrNotResponding();
-      return (Status.NOT_RESPONDING.equals(this.getStatus())
-          || Status.STARTING.equals(this.getStatus()));
+      return Status.NOT_RESPONDING == getStatus() || Status.STARTING == getStatus();
-      return ObjectUtils.defaultIfNull(workingDirectory, DEFAULT_WORKING_DIRECTORY);
+      return defaultIfNull(workingDirectory, DEFAULT_WORKING_DIRECTORY);
-      return StringUtils.defaultString(value);
+      return defaultString(value);
-      return values == null ? "" : StringUtils.join(values, " ");
+      return values == null ? "" : join(values, " ");
-      return ObjectUtils.defaultIfNull(value, "");
+      return defaultIfNull(value, "");
-  public static enum Status {
+  public enum Status {
-      assert StringUtils.isNotBlank(description) : "The Status description must be specified!";
-      this.description = StringUtils.lowerCase(description);
+      assert isNotBlank(description) : "The Status description must be specified!";
+      this.description = lowerCase(description);

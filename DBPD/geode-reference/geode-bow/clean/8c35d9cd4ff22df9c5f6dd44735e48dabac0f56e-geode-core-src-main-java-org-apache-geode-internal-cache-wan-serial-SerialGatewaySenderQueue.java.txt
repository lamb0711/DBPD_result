GEODE-8302: Fixed 'events not queued conflated' stats when group-tranâ€¦ (#5313)

* GEODE-8302: Fixed 'events not queued conflated' stats when group-transaction-events is true

Batch conflation is not compatible with group-transaction-events.
It must be prevented that both are enabled at the same time for
a given gateway sender.

* GEODE-8302: Add extra checks in propagation with HA tests and add fix in conflation stats

* GEODE-8302: Update GatewaySenderFactory javadoc

Added information about incompatibility between
group-transaction-events and enable-batch-conflation.

* GEODE-8302: Doc changes after review

* GEODE-8302: Fix for failing testReplicatedSerialPropagationHAWithGroupTransactionEvents

* GEODE-8302: doc and error messages changes after review

* GEODE-8302: Fix failing test case and possibly fix GEODE-8320
+   * Contains the set of peekedIds that were peeked to complete a transaction
+   * inside a batch when groupTransactionEvents is set and that have
+   * been sent in a batch but have not yet been removed.
+   */
+  private final Set<Long> extraPeekedIdsSentNotRemoved = ConcurrentHashMap.newKeySet();
+
+  /**
-      extraPeekedIds.remove(key);
+      boolean isExtraPeeked = extraPeekedIds.remove(key);
-        updateHeadKey(key.longValue());
+        if (!isExtraPeeked) {
+          updateHeadKey(key.longValue());
+        }
-      this.lastDispatchedKey = key;
+      if (!isExtraPeeked) {
+        this.lastDispatchedKey = key;
+        // Remove also the extraPeekedIds right after this one so that
+        // they do not stay in the secondary's queue forever
+        long tmpKey = key;
+        while (extraPeekedIdsSentNotRemoved.contains(tmpKey = inc(tmpKey))) {
+          extraPeekedIdsSentNotRemoved.remove(tmpKey);
+          this.lastDispatchedKey = tmpKey;
+          updateHeadKey(tmpKey);
+        }
+      } else {
+        extraPeekedIdsSentNotRemoved.add(key);
+        // Remove if previous key was already dispatched so that it does
+        // not stay in the secondary's queue forever
+        long tmpKey = dec(key);
+        if (this.lastDispatchedKey == tmpKey) {
+          this.lastDispatchedKey = key;
+          updateHeadKey(key);
+        }
+      }
+  private long dec(long value) {
+    long val = value - 1;
+    val = val == -1 ? MAXIMUM_KEY - 1 : val;
+    return val;
+  }
+
+
-    this.peekedIds.clear();
+    peekedIds.clear();
-    if (lastPeekedId.equals(-1)) {
+    if (lastPeekedId.get() == -1) {
-      if (this.stats != null) {
+      // When mustGroupTransactionEvents is true, conflation cannot be enabled.
+      // Therefore, if we reach here, it would not be due to a conflated event
+      // but rather to an extra peeked event already sent.
+      if (!mustGroupTransactionEvents() && this.stats != null) {
-      this.peekedIds.add(currentKey);
+      peekedIds.add(currentKey);

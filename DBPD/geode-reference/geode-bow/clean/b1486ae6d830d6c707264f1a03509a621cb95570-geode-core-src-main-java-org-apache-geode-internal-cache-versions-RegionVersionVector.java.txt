GEODE-4083: fix infinite loop caused by thread race changing version (#1161)

* GEODE-4083: fix infinite loop caused by thread race changing version


-import java.util.*;
+import java.util.Collections;
+import java.util.ConcurrentModificationException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import org.apache.geode.annotations.TestingOnly;
-  /** create a live version vector for a region */
-  public RegionVersionVector(T ownerId) {
-    this(ownerId, null);
+  /**
+   * constructor used to create a cloned vector
+   */
+  protected RegionVersionVector(T ownerId, ConcurrentHashMap<T, RegionVersionHolder<T>> vector,
+      long version, ConcurrentHashMap<T, Long> gcVersions, long gcVersion, boolean singleMember,
+      RegionVersionHolder<T> localExceptions) {
+    this.myId = ownerId;
+    this.memberToVersion = vector;
+    this.memberToGCVersion = gcVersions;
+    this.localGCVersion.set(gcVersion);
+    this.localVersion.set(version);
+    this.singleMember = singleMember;
+    this.localExceptions = localExceptions;
-  /** create a live version vector for a region */
-  public RegionVersionVector(T ownerId, LocalRegion owner) {
-    this.myId = ownerId;
-    this.isLiveVector = true;
-    this.region = owner;
-
-    this.localExceptions = new RegionVersionHolder<T>(0);
+  /**
+   * deserialize a cloned vector
+   */
+  public RegionVersionVector() {
+   * create a live version vector for a region
+   */
+  public RegionVersionVector(T ownerId) {
+    this(ownerId, null);
+  }
+
+  /**
+   * create a live version vector for a region
+   */
+  public RegionVersionVector(T ownerId, LocalRegion owner) {
+    this(ownerId, owner, 0);
+  }
+
+  @TestingOnly
+  RegionVersionVector(T ownerId, LocalRegion owner, long version) {
+    this.myId = ownerId;
+    this.isLiveVector = true;
+    this.region = owner;
+    this.localExceptions = new RegionVersionHolder<T>(0);
+    this.memberToVersion =
+        new ConcurrentHashMap<>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
+    this.memberToGCVersion =
+        new ConcurrentHashMap<>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
+    this.localVersion.set(version);
+  }
+
+  /**
-  private void updateLocalVersion(long version) {
-    boolean repeat = false;
+  void updateLocalVersion(long newVersion) {
+    boolean needToTrySetAgain;
-      long myVersion = this.localVersion.get();
-      if (myVersion < version) {
-        repeat = !this.localVersion.compareAndSet(myVersion, version);
+      needToTrySetAgain = false;
+      long currentVersion = this.localVersion.get();
+      if (currentVersion < newVersion) {
+        needToTrySetAgain = !compareAndSetVersion(currentVersion, newVersion);
-    } while (repeat);
+    } while (needToTrySetAgain);
-
+  boolean compareAndSetVersion(long currentVersion, long newVersion) {
+    return this.localVersion.compareAndSet(currentVersion, newVersion);
+  }
-   * constructor used to create a cloned vector
-   *
-   * @param localExceptions
-   */
-  protected RegionVersionVector(T ownerId, ConcurrentHashMap<T, RegionVersionHolder<T>> vector,
-      long version, ConcurrentHashMap<T, Long> gcVersions, long gcVersion, boolean singleMember,
-      RegionVersionHolder<T> localExceptions) {
-    this.myId = ownerId;
-    this.memberToVersion = vector;
-    this.memberToGCVersion = gcVersions;
-    this.localGCVersion.set(gcVersion);
-    this.localVersion.set(version);
-    this.singleMember = singleMember;
-    this.localExceptions = localExceptions;
-  }
-
-
-  /** deserialize a cloned vector */
-  public RegionVersionVector() {
-    this.memberToVersion = new ConcurrentHashMap<T, RegionVersionHolder<T>>(INITIAL_CAPACITY,
-        LOAD_FACTOR, CONCURRENCY_LEVEL);
-    this.memberToGCVersion =
-        new ConcurrentHashMap<T, Long>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
-  }
-
-  /**

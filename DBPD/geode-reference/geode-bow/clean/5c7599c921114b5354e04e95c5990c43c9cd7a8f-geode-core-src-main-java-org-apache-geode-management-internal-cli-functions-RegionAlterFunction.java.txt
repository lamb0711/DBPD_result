GEODE-6551: Fix Constraints Check in Alter Region (#3349)

* GEODE-6551: Fix Constraints Check in Alter Region

Some persistence constraints were not correctly validated for a
partitioned region before associating an async-event-queue and/or
gateway-sender, leaving the region and the cluster configuration
service inconsistent.

- Fixed minor warnings.
- Fixed the internal validation implemented by PartitionedRegion.
- Some method's signatures were changed from "parallelGatewaySender" to
"parallelAsynchronousEventDispatcher" as they are used alike for
both a gateway-sender and async-event-queue.
+import java.util.function.Predicate;
-
-  private static final String NULLSTR = "null";
+  public String getId() {
+    return RegionAlterFunction.class.getName();
+  }
+
+  @Override
+
+  private static <T> Predicate<T> not(Predicate<T> t) {
+    return t.negate();
+  }
+
-      throw new IllegalArgumentException(String.format(
-          "Region does not exist: %s", regionPathString));
+      throw new IllegalArgumentException(
+          String.format("Region does not exist: %s", regionPathString));
+    AttributesMutator<?, ?> mutator = region.getAttributesMutator();
-    AttributesMutator mutator = region.getAttributesMutator();
-        region.getEntryIdleTimeout(), p -> mutator.setEntryIdleTimeout(p),
-        p -> mutator.setCustomEntryIdleTimeout(p));
+        region.getEntryIdleTimeout(), mutator::setEntryIdleTimeout,
+        mutator::setCustomEntryIdleTimeout);
-        region.getEntryTimeToLive(), p -> mutator.setEntryTimeToLive(p),
-        p -> mutator.setCustomEntryTimeToLive(p));
+        region.getEntryTimeToLive(), mutator::setEntryTimeToLive,
+        mutator::setCustomEntryTimeToLive);
-        region.getRegionIdleTimeout(), p -> mutator.setRegionIdleTimeout(p), null);
+        region.getRegionIdleTimeout(), mutator::setRegionIdleTimeout, null);
-        region.getRegionTimeToLive(), p -> mutator.setRegionTimeToLive(p), null);
-
+        region.getRegionTimeToLive(), mutator::setRegionTimeToLive, null);
+
+
-        validateParallelGatewaySenderIDs((PartitionedRegion) region, newAsyncEventQueueIds);
+        validateParallelAsynchronousEventQueueIDs((PartitionedRegion) region,
+            newAsyncEventQueueIds);
-      ((PartitionedRegion) region).updatePRConfigWithNewSetOfGatewaySenders(senderIds);
+
+      ((PartitionedRegion) region)
+          .updatePRConfigWithNewSetOfAsynchronousEventDispatchers(senderIds);
-      // Remove old gateway sender ids that aren't in the new list
-      if (!oldGatewaySenderIds.isEmpty()) {
-        for (String gatewaySenderId : oldGatewaySenderIds) {
-          if (!newGatewaySenderIds.contains(gatewaySenderId)) {
-            mutator.removeGatewaySenderId(gatewaySenderId);
-          }
-        }
-      }
+      // Remove old gateway sender ids that aren't in the new list
+      oldGatewaySenderIds.stream().filter(not(newGatewaySenderIds::contains))
+          .forEach(mutator::removeGatewaySenderId);
-      for (String gatewaySenderId : newGatewaySenderIds) {
-        if (!oldGatewaySenderIds.contains(gatewaySenderId)) {
-          mutator.addGatewaySenderId(gatewaySenderId);
-        }
-      }
+      newGatewaySenderIds.stream().filter(not(oldGatewaySenderIds::contains))
+          .forEach(mutator::addGatewaySenderId);
+      Set<String> oldAsyncEventQueueIds = region.getAsyncEventQueueIds();
-      Set<String> oldAsyncEventQueueIds = region.getAsyncEventQueueIds();
-      if (!oldAsyncEventQueueIds.isEmpty()) {
-        for (String asyncEventQueueId : oldAsyncEventQueueIds) {
-          if (!newAsyncEventQueueIds.contains(asyncEventQueueId)) {
-            mutator.removeAsyncEventQueueId(asyncEventQueueId);
-          }
-        }
-      }
+      oldAsyncEventQueueIds.stream().filter(not(newAsyncEventQueueIds::contains))
+          .forEach(mutator::removeAsyncEventQueueId);
-      for (String asyncEventQueueId : newAsyncEventQueueIds) {
-        if (!oldAsyncEventQueueIds.contains(asyncEventQueueId)) {
-          mutator.addAsyncEventQueueId(asyncEventQueueId);
-        }
-      }
+      newAsyncEventQueueIds.stream().filter(not(oldAsyncEventQueueIds::contains))
+          .forEach(mutator::addAsyncEventQueueId);
-      ExpirationAttributes existingAttributes,
-      Consumer<ExpirationAttributes> mutator1,
+      ExpirationAttributes existingAttributes, Consumer<ExpirationAttributes> mutator1,
+
+
+
-
-      region.validateParallelGatewaySenderIds(parallelSenders);
+      region.validateParallelAsynchronousEventDispatcherIds(parallelSenders);
-  @Override
-  public String getId() {
-    return RegionAlterFunction.class.getName();
+  private void validateParallelAsynchronousEventQueueIDs(PartitionedRegion region,
+      Set<String> newAsyncEventQueueIds) {
+    try {
+      Set<String> parallelSenders =
+          region.filterOutNonParallelAsyncEventQueues(newAsyncEventQueueIds);
+      region.validateParallelAsynchronousEventDispatcherIds(parallelSenders);
+    } catch (PRLocallyDestroyedException e) {
+      throw new IllegalStateException("Partitioned Region not found registered", e);
+    }

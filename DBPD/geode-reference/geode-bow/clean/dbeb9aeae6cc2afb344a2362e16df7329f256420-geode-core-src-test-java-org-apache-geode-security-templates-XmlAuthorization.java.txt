Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An implementation of the {@link AccessControl} interface that allows
- * authorization using the permissions as specified in the given XML
- * file.
+ * An implementation of the {@link AccessControl} interface that allows authorization using the
+ * permissions as specified in the given XML file.
- * The format of the XML file is specified in <a href="authz5_5.dtd"/>. It
- * implements a role-based authorization at the operation level for each region.
- * Each principal name may be associated with a set of roles. The name of the
- * principal is obtained using the {@link Principal#getName()} method and no other
- * information of the principal is utilized. Each role can be provided
+ * The format of the XML file is specified in <a href="authz5_5.dtd"/>. It implements a role-based
+ * authorization at the operation level for each region. Each principal name may be associated with
+ * a set of roles. The name of the principal is obtained using the {@link Principal#getName()}
+ * method and no other information of the principal is utilized. Each role can be provided
- * The top-level element in the XML is "acl" tag that contains the "role" and
- * "permission" tags. The "role" tag contains the list of users that have been
- * given that role. The name of the role is specified in the "role" attribute
- * and the users are contained in the "user" tags insided the "role" tag.
+ * The top-level element in the XML is "acl" tag that contains the "role" and "permission" tags. The
+ * "role" tag contains the list of users that have been given that role. The name of the role is
+ * specified in the "role" attribute and the users are contained in the "user" tags insided the
+ * "role" tag.
- * The "permissions" tag contains the list of operations allowed for a
- * particular region. The role name is specified as the "role" attribute, the
- * list of comma separated region names as the optional "regions" attribute and
- * the operation names are contained in the "operation" tags inside the
- * "permissions" tag. The allowed operation names are: GET, PUT, PUTALL,
- * DESTROY, REGISTER_INTEREST, UNREGISTER_INTEREST, CONTAINS_KEY, KEY_SET,
- * QUERY, EXECUTE_CQ, STOP_CQ, CLOSE_CQ, REGION_CLEAR, REGION_CREATE,
- * REGION_DESTROY. These correspond to the operations in the
+ * The "permissions" tag contains the list of operations allowed for a particular region. The role
+ * name is specified as the "role" attribute, the list of comma separated region names as the
+ * optional "regions" attribute and the operation names are contained in the "operation" tags inside
+ * the "permissions" tag. The allowed operation names are: GET, PUT, PUTALL, DESTROY,
+ * REGISTER_INTEREST, UNREGISTER_INTEREST, CONTAINS_KEY, KEY_SET, QUERY, EXECUTE_CQ, STOP_CQ,
+ * CLOSE_CQ, REGION_CLEAR, REGION_CREATE, REGION_DESTROY. These correspond to the operations in the
- * When no region name is specified then the operation is allowed for all
- * regions in the cache. Any permissions specified for regions using the
- * "regions" attribute override these permissions. This allows users to provide
- * generic permissions without any region name, and override for specific
- * regions specified using the "regions" attribute. A cache-level operation
- * (e.g. {@link OperationCode#REGION_DESTROY}) specified for a particular region
- * is ignored i.e. the cache-level operations are only applicable when no region
- * name is specified. A {@link OperationCode#QUERY} operation is permitted when
- * either the {@code QUERY} permission is provided at the cache-level for
- * the user or when {@code QUERY} permission is provided for all the
+ * When no region name is specified then the operation is allowed for all regions in the cache. Any
+ * permissions specified for regions using the "regions" attribute override these permissions. This
+ * allows users to provide generic permissions without any region name, and override for specific
+ * regions specified using the "regions" attribute. A cache-level operation (e.g.
+ * {@link OperationCode#REGION_DESTROY}) specified for a particular region is ignored i.e. the
+ * cache-level operations are only applicable when no region name is specified. A
+ * {@link OperationCode#QUERY} operation is permitted when either the {@code QUERY} permission is
+ * provided at the cache-level for the user or when {@code QUERY} permission is provided for all the
- * Any roles specified in the "user" tag that do not have a specified permission
- * set using the "permission" tags are ignored. When no {@link Principal} is
- * associated with the current connection, then empty user name is used to
- * search for the roles so an empty user name can be used to specify roles of
- * unauthenticated clients (i.e. {@code Everyone}).
+ * Any roles specified in the "user" tag that do not have a specified permission set using the
+ * "permission" tags are ignored. When no {@link Principal} is associated with the current
+ * connection, then empty user name is used to search for the roles so an empty user name can be
+ * used to specify roles of unauthenticated clients (i.e. {@code Everyone}).
- * This sample implementation is useful only for pre-operation checks and should
- * not be used for post-operation authorization since it does nothing useful for
- * post-operation case.
+ * This sample implementation is useful only for pre-operation checks and should not be used for
+ * post-operation authorization since it does nothing useful for post-operation case.
-  private static Map<String, Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>> rolePermissions = null;
+  private static Map<String, Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>> rolePermissions =
+      null;
-   * Public static factory method to create an instance of
-   * {@code XmlAuthorization}. The fully qualified name of the class
-   * ({@code org.apache.geode.security.templates.XmlAuthorization.create})
-   * should be mentioned as the {@code security-client-accessor} system
-   * property to enable pre-operation authorization checks as implemented in
-   * this class.
+   * Public static factory method to create an instance of {@code XmlAuthorization}. The fully
+   * qualified name of the class
+   * ({@code org.apache.geode.security.templates.XmlAuthorization.create}) should be mentioned as
+   * the {@code security-client-accessor} system property to enable pre-operation authorization
+   * checks as implemented in this class.
-   * Change the region name to a standard format having single '/' as separator
-   * and starting with a '/' as in standard POSIX paths
+   * Change the region name to a standard format having single '/' as separator and starting with a
+   * '/' as in standard POSIX paths
-   * Initialize the {@code XmlAuthorization} callback for a client having
-   * the given principal.
+   * Initialize the {@code XmlAuthorization} callback for a client having the given principal.
-   * This method caches the full XML authorization file the first time it is
-   * invoked and caches all the permissions for the provided
-   * {@code principal} to speed up lookup the
-   * {@code authorizeOperation} calls. The permissions for the principal
-   * are maintained as a {@link Map} of region name to the {@link HashSet} of
-   * operations allowed for that region. A global entry with region name as
-   * empty string is also made for permissions provided for all the regions.
+   * This method caches the full XML authorization file the first time it is invoked and caches all
+   * the permissions for the provided {@code principal} to speed up lookup the
+   * {@code authorizeOperation} calls. The permissions for the principal are maintained as a
+   * {@link Map} of region name to the {@link HashSet} of operations allowed for that region. A
+   * global entry with region name as empty string is also made for permissions provided for all the
+   * regions.
-   * @param  principal
-   *         the principal associated with the authenticated client
-   * @param  cache
-   *         reference to the cache object
-   * @param  remoteMember
-   *         the {@link DistributedMember} object for the remote authenticated
-   *         client
+   * @param principal the principal associated with the authenticated client
+   * @param cache reference to the cache object
+   * @param remoteMember the {@link DistributedMember} object for the remote authenticated client
-   * @throws NotAuthorizedException
-   *         if some exception condition happens during the initialization
-   *         while reading the XML; in such a case all subsequent client
-   *         operations will throw {@code NotAuthorizedException}
+   * @throws NotAuthorizedException if some exception condition happens during the initialization
+   *         while reading the XML; in such a case all subsequent client operations will throw
+   *         {@code NotAuthorizedException}
-  public void init(final Principal principal, final DistributedMember remoteMember, final Cache cache) throws NotAuthorizedException {
+  public void init(final Principal principal, final DistributedMember remoteMember,
+      final Cache cache) throws NotAuthorizedException {
-        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionOperationMap = XmlAuthorization.rolePermissions.get(roleName);
+        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionOperationMap =
+            XmlAuthorization.rolePermissions.get(roleName);
-          for (Map.Entry<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionEntry : regionOperationMap.entrySet()) {
+          for (Map.Entry<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionEntry : regionOperationMap
+              .entrySet()) {
-            Map<OperationCode, FunctionSecurityPrmsHolder> regionOperations = this.allowedOps.get(regionName);
+            Map<OperationCode, FunctionSecurityPrmsHolder> regionOperations =
+                this.allowedOps.get(regionName);
-   * This looks up the cached permissions of the principal in the map for the
-   * provided region name. If none are found then the global permissions with
-   * empty region name are looked up. The operation is allowed if it is found
-   * this permission list.
+   * This looks up the cached permissions of the principal in the map for the provided region name.
+   * If none are found then the global permissions with empty region name are looked up. The
+   * operation is allowed if it is found this permission list.
-   * @param  regionName
-   *         When null then it indicates a cache-level operation, else the
-   *         name of the region for the operation.
-   * @param  context
-   *         the data required by the operation
+   * @param regionName When null then it indicates a cache-level operation, else the name of the
+   *        region for the operation.
+   * @param context the data required by the operation
-      boolean globalPermission = (operationMap != null && operationMap .containsKey(opCode));
-      Set<String> regionNames = ((QueryOperationContext)context) .getRegionNames();
+      boolean globalPermission = (operationMap != null && operationMap.containsKey(opCode));
+      Set<String> regionNames = ((QueryOperationContext) context).getRegionNames();
-            FunctionSecurityPrmsHolder functionParameter = operationMap.get(context.getOperationCode());
-            ExecuteFunctionOperationContext functionContext = (ExecuteFunctionOperationContext) context;
+            FunctionSecurityPrmsHolder functionParameter =
+                operationMap.get(context.getOperationCode());
+            ExecuteFunctionOperationContext functionContext =
+                (ExecuteFunctionOperationContext) context;
-              if (functionParameter.isOptimizeForWrite() != null && functionParameter.isOptimizeForWrite().booleanValue() != functionContext.isOptimizeForWrite()) {
+              if (functionParameter.isOptimizeForWrite() != null && functionParameter
+                  .isOptimizeForWrite().booleanValue() != functionContext.isOptimizeForWrite()) {
-              if (functionParameter.getFunctionIds() != null && !functionParameter.getFunctionIds().contains( functionContext.getFunctionId())) {
+              if (functionParameter.getFunctionIds() != null && !functionParameter.getFunctionIds()
+                  .contains(functionContext.getFunctionId())) {
-                if (functionContext.getKeySet().containsAll( functionParameter.getKeySet())) {
+                if (functionContext.getKeySet().containsAll(functionParameter.getKeySet())) {
-              if (functionParameter.getFunctionIds() != null && !functionParameter.getFunctionIds().contains(functionContext.getFunctionId())) {
+              if (functionParameter.getFunctionIds() != null && !functionParameter.getFunctionIds()
+                  .contains(functionContext.getFunctionId())) {
-            ExecuteFunctionOperationContext functionContext = (ExecuteFunctionOperationContext)context;
-            FunctionSecurityPrmsHolder functionParameter = operationMap.get(context.getOperationCode());
+            ExecuteFunctionOperationContext functionContext =
+                (ExecuteFunctionOperationContext) context;
+            FunctionSecurityPrmsHolder functionParameter =
+                operationMap.get(context.getOperationCode());
-              if (functionContext.getResult() instanceof ArrayList && functionParameter.getKeySet() != null) {
-                ArrayList<String> resultList = (ArrayList)functionContext.getResult();
+              if (functionContext.getResult() instanceof ArrayList
+                  && functionParameter.getKeySet() != null) {
+                ArrayList<String> resultList = (ArrayList) functionContext.getResult();
-              ArrayList<String> resultList = (ArrayList)functionContext.getResult();
+              ArrayList<String> resultList = (ArrayList) functionContext.getResult();
-      return ((Attr)attrNode).getValue();
+      return ((Attr) attrNode).getValue();
-   * Cache authorization information for all users statically. This method is
-   * not thread-safe and is should either be invoked only once, or the caller
-   * should take the appropriate locks.
+   * Cache authorization information for all users statically. This method is not thread-safe and is
+   * should either be invoked only once, or the caller should take the appropriate locks.
-    final String xmlDocumentUri = (String)cache.getDistributedSystem().getSecurityProperties().get(DOC_URI_PROP_NAME);
+    final String xmlDocumentUri =
+        (String) cache.getDistributedSystem().getSecurityProperties().get(DOC_URI_PROP_NAME);
-        throw new NotAuthorizedException("No ACL file defined using tag [" + DOC_URI_PROP_NAME + "] in system properties");
+        throw new NotAuthorizedException(
+            "No ACL file defined using tag [" + DOC_URI_PROP_NAME + "] in system properties");
-      XmlAuthorization.rolePermissions = new HashMap<String, Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>>();
+      XmlAuthorization.rolePermissions =
+          new HashMap<String, Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>>();
-            throw new SAXParseException("Unknown tag [" + userNode.getNodeName() + "] as child of tag [" + TAG_ROLE + ']', null);
+            throw new SAXParseException(
+                "Unknown tag [" + userNode.getNodeName() + "] as child of tag [" + TAG_ROLE + ']',
+                null);
-        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionOperationMap = XmlAuthorization.rolePermissions.get(roleName);
+        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionOperationMap =
+            XmlAuthorization.rolePermissions.get(roleName);
-          regionOperationMap = new HashMap<String, Map<OperationCode, FunctionSecurityPrmsHolder>>();
+          regionOperationMap =
+              new HashMap<String, Map<OperationCode, FunctionSecurityPrmsHolder>>();
-        final HashMap<OperationCode, FunctionSecurityPrmsHolder> operationMap = new HashMap<OperationCode, FunctionSecurityPrmsHolder>();
+        final HashMap<OperationCode, FunctionSecurityPrmsHolder> operationMap =
+            new HashMap<OperationCode, FunctionSecurityPrmsHolder>();
-              final String optimizeForWrite = getAttributeValue(operationNode, ATTR_FUNCTION_OPTIMIZE_FOR_WRITE);
+              final String optimizeForWrite =
+                  getAttributeValue(operationNode, ATTR_FUNCTION_OPTIMIZE_FOR_WRITE);
-              final FunctionSecurityPrmsHolder functionContext = new FunctionSecurityPrmsHolder(isOptimizeForWrite, functionIds, keySet);
+              final FunctionSecurityPrmsHolder functionContext =
+                  new FunctionSecurityPrmsHolder(isOptimizeForWrite, functionIds, keySet);
-            throw new SAXParseException("Unknown tag [" + operationNode.getNodeName() + "] as child of tag [" + TAG_PERMS + ']', null);
+            throw new SAXParseException("Unknown tag [" + operationNode.getNodeName()
+                + "] as child of tag [" + TAG_PERMS + ']', null);
-      }
-      else {
+      } else {
-    public InputSource resolveEntity(final String publicId, final String systemId) throws SAXException, IOException {
+    public InputSource resolveEntity(final String publicId, final String systemId)
+        throws SAXException, IOException {
-      } catch(Exception e) {
-        //do nothing, use the default resolver
+      } catch (Exception e) {
+        // do nothing, use the default resolver
-      
+

GEODE-2705: Jars undeployed from cluster configuration will not be loaded from disk on member restart

-import org.apache.commons.lang.ArrayUtils;
-import org.apache.geode.GemFireException;
-import org.apache.geode.GemFireIOException;
-import org.apache.geode.SystemFailure;
-import java.net.URLClassLoader;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.HashMap;
+  /**
+   * Writes the jarBytes for the given jarName to the next version of that jar file (if the bytes do
+   * not match the latest deployed version)
+   * 
+   * @return the DeployedJar that was written from jarBytes, or null if those bytes matched the
+   *         latest deployed version
+   */
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, jarBytes);
+      if (!shouldDeployNewVersion) {
+        return null;
+      }
+
+
-  protected Set<String> findDistinctDeployedJars() {
+  protected Set<String> findDistinctDeployedJarsOnDisk() {
-    final File[] oldFiles = this.deployDirectory.listFiles(new FilenameFilter() {
-      @Override
-      public boolean accept(final File file, final String name) {
-        return versionedPattern.matcher(name).matches();
-      }
-    });
+    final File[] oldFiles =
+        this.deployDirectory.listFiles((file, name) -> versionedPattern.matcher(name).matches());
-    final Set<String> jarNames = new HashSet<String>();
+    final Set<String> jarNames = new HashSet<>();
-      jarNames.add(matcher.group(1));
+      jarNames.add(matcher.group(1) + ".jar");
-    logger.debug("Renaming deployed jar from " + oldJar.getCanonicalPath() + " to "
-        + newJar.getCanonicalPath());
+    logger.debug("Renaming deployed jar from {} to {}", oldJar.getCanonicalPath(),
+        newJar.getCanonicalPath());
-    FileUtils.deleteQuietly(oldJar);
-   * Re-deploy all previously deployed JAR files.
+   * Re-deploy all previously deployed JAR files on disk.
-  public void loadPreviouslyDeployedJars() {
+  public void loadPreviouslyDeployedJarsFromDisk() {
+    logger.info("Loading previously deployed jars");
-      final Set<String> jarNames = findDistinctDeployedJars();
+      final Set<String> jarNames = findDistinctDeployedJarsOnDisk();
-      Map<String, DeployedJar> latestVersionOfEachJar = new LinkedHashMap<>();
+      List<DeployedJar> latestVersionOfEachJar = new ArrayList<>();
-        final File[] jarFiles = findSortedOldVersionsOfJar(jarName);
+        DeployedJar deployedJar = findLatestValidDeployedJarFromDisk(jarName);
-        Optional<File> latestValidDeployedJarOptional =
-            Arrays.stream(jarFiles).filter(Objects::nonNull).filter(jarFile -> {
-              try {
-                return DeployedJar.isValidJarContent(FileUtils.readFileToByteArray(jarFile));
-              } catch (IOException e) {
-                return false;
-              }
-            }).findFirst();
-
-        if (!latestValidDeployedJarOptional.isPresent()) {
-          // No valid version of this jar
-          continue;
-        }
-
-        File latestValidDeployedJar = latestValidDeployedJarOptional.get();
-        latestVersionOfEachJar.put(jarName, new DeployedJar(latestValidDeployedJar, jarName));
-
-        // Remove any old left-behind versions of this JAR file
-        for (File jarFile : jarFiles) {
-          if (!latestValidDeployedJar.equals(jarFile)) {
-            FileUtils.deleteQuietly(jarFile);
-          }
+        if (deployedJar != null) {
+          latestVersionOfEachJar.add(deployedJar);
+          deleteOtherVersionsOfJar(deployedJar);
-      registerNewVersions(latestVersionOfEachJar.values().stream().collect(toList()));
-      // ClassPathLoader.getLatest().deploy(latestVersionOfEachJar.keySet().toArray(),
-      // latestVersionOfEachJar.values().toArray())
+      registerNewVersions(latestVersionOfEachJar);
+  /**
+   * Deletes all versions of this jar on disk other than the given version
+   */
+  public void deleteOtherVersionsOfJar(DeployedJar deployedJar) {
+    logger.info("Deleting all versions of " + deployedJar.getJarName() + " other than "
+        + deployedJar.getFileName());
+    final File[] jarFiles = findSortedOldVersionsOfJar(deployedJar.getJarName());
+
+    Stream.of(jarFiles).filter(jarFile -> !jarFile.equals(deployedJar.getFile()))
+        .forEach(jarFile -> {
+          logger.info("Deleting old version of jar: " + jarFile.getAbsolutePath());
+          FileUtils.deleteQuietly(jarFile);
+        });
+  }
+
+  public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
+      throws IOException {
+    final File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+
+    Optional<File> latestValidDeployedJarOptional =
+        Arrays.stream(jarFiles).filter(Objects::nonNull).filter(jarFile -> {
+          try {
+            return DeployedJar.isValidJarContent(FileUtils.readFileToByteArray(jarFile));
+          } catch (IOException e) {
+            return false;
+          }
+        }).findFirst();
+
+    if (!latestValidDeployedJarOptional.isPresent()) {
+      // No valid version of this jar
+      return null;
+    }
+
+    File latestValidDeployedJar = latestValidDeployedJarOptional.get();
+
+    return new DeployedJar(latestValidDeployedJar, unversionedJarName);
+  }
+          logger.info("Registering new version of jar: {}", deployedJar.toString());
-        boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, newJarBytes);
-
-        if (shouldDeployNewVersion) {
-          deployedJars[i] = deployWithoutRegistering(jarName, newJarBytes);
-        } else {
-          deployedJars[i] = null;
-        }
+        deployedJars[i] = deployWithoutRegistering(jarName, newJarBytes);
-      logger.warn("Jar is identical to the latest deployed version: ",
+      logger.warn("Jar is identical to the latest deployed version: {}",
+  /**
+   * Returns the latest registered {@link DeployedJar} for the given JarName
+   * 
+   * @param jarName - the unversioned jar name, e.g. myJar.jar
+   */
+      deleteAllVersionsOfJar(jarName);
+
+  public void deleteAllVersionsOfJar(String unversionedJarName) {
+    lock.lock();
+    try {
+      File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+      for (File jarFile : jarFiles) {
+        logger.info("Deleting: {}", jarFile.getAbsolutePath());
+        FileUtils.deleteQuietly(jarFile);
+      }
+    } finally {
+      lock.unlock();
+    }
+
+  }

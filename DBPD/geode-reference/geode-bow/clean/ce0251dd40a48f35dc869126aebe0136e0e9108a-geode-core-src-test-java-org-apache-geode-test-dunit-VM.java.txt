GEODE-4734: cleanup tests for use as examples in Geode wiki (#1518)



-import java.util.concurrent.atomic.AtomicInteger;
-  private Host host;
+  private final Host host;
-    if (!this.available) {
-      this.available = true;
+    if (!available) {
+      available = true;
-  public static String getVMName(String version, int pid) {
+  public static String getVMName(final String version, final int pid) {
-  public VM(final Host host, int id, final RemoteDUnitVMIF client) {
+  public VM(final Host host, final int id, final RemoteDUnitVMIF client) {
-    this.available = true;
+    available = true;
-    return this.host;
+    return host;
-    return this.version;
+    return version;
-    return this.id;
+    return id;
-  public Object invoke(final Class targetClass, final String methodName) {
+  @Deprecated
+  public <V> V invoke(final Class<?> targetClass, final String methodName) {
-  public AsyncInvocation invokeAsync(final Class targetClass, final String methodName) {
+  @Deprecated
+  public <V> AsyncInvocation<V> invokeAsync(final Class<?> targetClass, final String methodName) {
-  public Object invoke(final Class targetClass, final String methodName, final Object[] args) {
-    if (!this.available) {
+  @Deprecated
+  public <V> V invoke(final Class<?> targetClass, final String methodName, final Object[] args) {
+    if (!available) {
-      return result.getResult();
+      return (V) result.getResult();
-  public AsyncInvocation invokeAsync(final Object targetObject, final String methodName,
+  @Deprecated
+  public <V> AsyncInvocation<V> invokeAsync(final Object targetObject, final String methodName,
-    return new AsyncInvocation(targetObject, methodName,
+    return new AsyncInvocation<V>(targetObject, methodName,
-  public AsyncInvocation invokeAsync(final Class<?> targetClass, final String methodName,
+  @Deprecated
+  public <V> AsyncInvocation<V> invokeAsync(final Class<?> targetClass, final String methodName,
-    return new AsyncInvocation(targetClass, methodName, () -> invoke(targetClass, methodName, args))
-        .start();
+    return new AsyncInvocation<V>(targetClass, methodName,
+        () -> invoke(targetClass, methodName, args)).start();
-  public AsyncInvocation invokeAsync(final SerializableRunnableIF runnable) {
+  public <V> AsyncInvocation<V> invokeAsync(final SerializableRunnableIF runnable) {
-  public AsyncInvocation invokeAsync(final String name, final SerializableRunnableIF runnable) {
+  public <V> AsyncInvocation<V> invokeAsync(final String name,
+      final SerializableRunnableIF runnable) {
-  public <T> AsyncInvocation<T> invokeAsync(final String name,
-      final SerializableCallableIF<T> callable) {
-    return invokeAsync(new NamedCallable(name, callable), "call", new Object[0]);
+  public <V> AsyncInvocation<V> invokeAsync(final String name,
+      final SerializableCallableIF<V> callable) {
+    return invokeAsync(new NamedCallable<>(name, callable), "call", new Object[0]);
-  public <T> AsyncInvocation<T> invokeAsync(final SerializableCallableIF<T> callable) {
+  public <V> AsyncInvocation<V> invokeAsync(final SerializableCallableIF<V> callable) {
-  public <T> T invoke(final String name, final SerializableCallableIF<T> callable) {
-    return (T) invoke(new NamedCallable(name, callable), "call");
+  public <V> V invoke(final String name, final SerializableCallableIF<V> callable) {
+    return invoke(new NamedCallable<>(name, callable), "call");
-  public <T> T invoke(final SerializableCallableIF<T> callable) {
-    return (T) invoke(callable, "call");
+  public <V> V invoke(final SerializableCallableIF<V> callable) {
+    return invoke(callable, "call");
+  @Deprecated
-  public Object invoke(final Object targetObject, final String methodName) {
+  @Deprecated
+  public <V> V invoke(final Object targetObject, final String methodName) {
-  public Object invoke(final Object targetObject, final String methodName, final Object[] args) {
-    if (!this.available) {
+  @Deprecated
+  public <V> V invoke(final Object targetObject, final String methodName, final Object[] args) {
+    if (!available) {
-      return result.getResult();
+      return (V) result.getResult();
-   * @throws RMIException if an exception occurs while bouncing this {@code VM}, for example a
-   *         {@code HydraTimeoutException} if the {@code VM} fails to stop within
-   *         {@code hydra.Prms#maxClientShutdownWaitSec} or restart within
-   *         {@code hydra.Prms#maxClientStartupWaitSec}.
+   * @throws RMIException if an exception occurs while bouncing this {@code VM}
-    bounce(this.version);
+    bounce(version);
-  public synchronized void bounce(String targetVersion) {
-    if (!this.available) {
+  public synchronized void bounce(final String targetVersion) {
+    if (!available) {
-    this.available = false;
+    available = false;
-      BounceResult result = DUnitEnv.get().bounce(targetVersion, this.id);
-      this.id = result.getNewId();
-      this.client = result.getNewClient();
-      this.version = targetVersion;
-      this.available = true;
+      BounceResult result = DUnitEnv.get().bounce(targetVersion, id);
+      id = result.getNewId();
+      client = result.getNewClient();
+      version = targetVersion;
+      available = true;
-      this.available = true;
+      available = true;
-      RMIException rmie =
-          new RMIException(this, getClass().getName(), "bounceVM", e, sw.toString());
-      throw rmie;
+      throw new RMIException(this, getClass().getName(), "bounceVM", e, sw.toString());
+  @Override
-  private MethExecutorResult execute(final Class targetClass, final String methodName,
+  private MethExecutorResult execute(final Class<?> targetClass, final String methodName,
-      return this.client.executeMethodOnClass(targetClass.getName(), methodName, args);
+      return client.executeMethodOnClass(targetClass.getName(), methodName, args);
-        return this.client.executeMethodOnObject(targetObject, methodName);
+        return client.executeMethodOnObject(targetObject, methodName);
-        return this.client.executeMethodOnObject(targetObject, methodName, args);
+        return client.executeMethodOnObject(targetObject, methodName, args);

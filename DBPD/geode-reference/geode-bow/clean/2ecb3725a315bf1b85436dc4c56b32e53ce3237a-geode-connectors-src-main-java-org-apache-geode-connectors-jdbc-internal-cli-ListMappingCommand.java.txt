GEODE-4863: refactor jdbc commands to use this public cluster configuration api (#1776)

   * refactored jdbc connector commands to use public cc service
   * removed JdbcConnectorServiceXmlGenerator
   * removed RegionMappingBuilder & ConnectionConfigBuilder
   * if cc service is running then user can only alter whats available in CC
   * describe & List commands now list entries from cc service
   * converted some integration tests to junits
   * removed unwanted functions, tests

Signed-off-by: Jinmei Liao <jiliao@pivotal.io>

-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.connectors.jdbc.internal.RegionMapping;
-import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.connectors.jdbc.internal.configuration.ConnectorService;
+import org.apache.geode.distributed.ClusterConfigurationService;
-    // input
-    Set<DistributedMember> targetMembers = getMembers(null, null);
-    if (targetMembers.isEmpty()) {
-      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    ClusterConfigurationService ccService = getConfigurationService();
+    if (ccService == null) {
+      return ResultBuilder.createInfoResult("cluster configuration service is not running");
-    // action
-    ResultCollector<RegionMapping, List<RegionMapping[]>> resultCollector =
-        execute(new ListMappingFunction(), targetMembers.iterator().next());
+    ConnectorService service =
+        ccService.getCustomCacheElement("cluster", "connector-service", ConnectorService.class);
+    if (service == null) {
+      return ResultBuilder.createInfoResult(EXPERIMENTAL + "\n" + NO_MAPPINGS_FOUND);
+    }
-    boolean mappingsExist = fillTabularResultData(resultCollector, tabularResultData);
+    boolean mappingsExist = fillTabularResultData(service.getRegionMapping(), tabularResultData);
-  ResultCollector<RegionMapping, List<RegionMapping[]>> execute(ListMappingFunction function,
-      DistributedMember targetMember) {
-    return (ResultCollector<RegionMapping, List<RegionMapping[]>>) executeFunction(function, null,
-        targetMember);
-  }
-
-  private boolean fillTabularResultData(
-      ResultCollector<RegionMapping, List<RegionMapping[]>> resultCollector,
+  private boolean fillTabularResultData(List<ConnectorService.RegionMapping> mappings,
-    Set<RegionMapping> regionMappings = new HashSet<>();
-
-    for (Object resultObject : resultCollector.getResult()) {
-      if (resultObject instanceof RegionMapping[]) {
-        regionMappings.addAll(Arrays.asList((RegionMapping[]) resultObject));
-      } else if (resultObject instanceof Throwable) {
-        throw new IllegalStateException((Throwable) resultObject);
-      } else {
-        throw new IllegalStateException(resultObject.getClass().getName());
-      }
-    }
-
-    for (RegionMapping mapping : regionMappings) {
+    for (ConnectorService.RegionMapping mapping : mappings) {
-
-    return !regionMappings.isEmpty();
+    return !mappings.isEmpty();

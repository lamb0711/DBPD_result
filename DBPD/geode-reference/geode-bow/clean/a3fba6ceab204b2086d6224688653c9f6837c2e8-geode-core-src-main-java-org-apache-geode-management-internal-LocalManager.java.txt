GEODE-7221: Cleanup and unit test LocalManager

* Move inner class to bottom of outer class
* Remove unnecessary code
* Extract doManagementTask from ManagementTask
* Create LocalManagerTest

-import java.util.Iterator;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.cache.CacheListener;
- * DistributionHelper solves the following problems
- *
- * a) Handles proxy creation when Management node comes up b) Handles proxy creation when a member
- * joins c) Remove proxies when a member leaves or node stops being management node. d) Takes care
- * to create resources like hidden regions for MBean and notification federation.
+ * <pre>
+ * a) Handles proxy creation when Management node comes up
+ * b) Handles proxy creation when a member joins
+ * c) Remove proxies when a member leaves or node stops being management node.
+ * d) Takes care to create resources like hidden regions for MBean and notification federation.
+ * </pre>
-  protected ScheduledExecutorService singleThreadFederationScheduler;
+  private ScheduledExecutorService singleThreadFederationScheduler;
-  public LocalManager(ManagementResourceRepo repo, InternalDistributedSystem system,
+  LocalManager(ManagementResourceRepo repo, InternalDistributedSystem system,
-    this.federatedComponentMap = new ConcurrentHashMap<ObjectName, FederationComponent>();
+    federatedComponentMap = new ConcurrentHashMap<>();
+   * <p>
-  private void startLocalManagement(Map<ObjectName, FederationComponent> federatedComponentMap) {
-
+  private void startLocalManagement() {
-      } else {
-        singleThreadFederationScheduler =
-            LoggingExecutors.newSingleThreadScheduledExecutor("Management Task");
+      }
+      singleThreadFederationScheduler =
+          LoggingExecutors.newSingleThreadScheduledExecutor("Management Task");
-        if (logger.isDebugEnabled()) {
-          logger.debug("Creating  Management Region :");
+      if (logger.isDebugEnabled()) {
+        logger.debug("Creating  Management Region :");
+      }
+
+      /*
+       * Sharing the same Internal Argument for both notification region and monitoring region
+       */
+      InternalRegionArguments internalArgs = new InternalRegionArguments();
+      internalArgs.setIsUsedForMetaRegion(true);
+
+      // Create anonymous stats holder for Management Regions
+      final HasCachePerfStats monitoringRegionStats =
+          () -> new CachePerfStats(cache.getDistributedSystem(),
+              "RegionStats-managementRegionStats", statisticsClock);
+
+      internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
+
+      AttributesFactory<String, Object> monitorRegionAttributeFactory =
+          new AttributesFactory<>();
+      monitorRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+      monitorRegionAttributeFactory.setDataPolicy(DataPolicy.REPLICATE);
+      monitorRegionAttributeFactory.setConcurrencyChecksEnabled(false);
+      CacheListener<String, Object> localListener = new MonitoringRegionCacheListener(service);
+      monitorRegionAttributeFactory.addCacheListener(localListener);
+
+      RegionAttributes<String, Object> monitoringRegionAttrs =
+          monitorRegionAttributeFactory.create();
+
+      AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
+          new AttributesFactory<>();
+      notificationRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+      notificationRegionAttributeFactory.setDataPolicy(DataPolicy.EMPTY);
+      notificationRegionAttributeFactory.setConcurrencyChecksEnabled(false);
+
+      RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
+          notificationRegionAttributeFactory.create();
+
+      String appender = MBeanJMXAdapter.getUniqueIDForMember(system.getDistributedMember());
+
+      try {
+        repo.setLocalMonitoringRegion(
+            cache.createInternalRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
+                monitoringRegionAttrs, internalArgs));
+
+      } catch (TimeoutException | RegionExistsException | ClassNotFoundException | IOException e) {
+        throw new ManagementException(e);
+      }
+
+      boolean notifRegionCreated = false;
+      try {
+        repo.setLocalNotificationRegion(
+            cache.createInternalRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
+                notifRegionAttrs, internalArgs));
+        notifRegionCreated = true;
+      } catch (TimeoutException | ClassNotFoundException | IOException | RegionExistsException e) {
+        throw new ManagementException(e);
+      } finally {
+        if (!notifRegionCreated) {
+          repo.getLocalMonitoringRegion().localDestroyRegion();
+
+      }
-        /*
-         * Sharing the same Internal Argument for both notification region and monitoring region
-         */
-        InternalRegionArguments internalArgs = new InternalRegionArguments();
-        internalArgs.setIsUsedForMetaRegion(true);
+      managementTask = new ManagementTask();
+      // call run to get us initialized immediately with a sync call
+      managementTask.run();
+      // All local resources are created for the ManagementTask
+      // Now Management tasks can proceed.
+      int updateRate = system.getConfig().getJmxManagerUpdateRate();
+      singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
+          TimeUnit.MILLISECONDS);
-        // Create anonymous stats holder for Management Regions
-        final HasCachePerfStats monitoringRegionStats =
-            () -> new CachePerfStats(cache.getDistributedSystem(),
-                "RegionStats-managementRegionStats", statisticsClock);
-
-        internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
-
-        AttributesFactory<String, Object> monitorRegionAttributeFactory =
-            new AttributesFactory<String, Object>();
-        monitorRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-        monitorRegionAttributeFactory.setDataPolicy(DataPolicy.REPLICATE);
-        monitorRegionAttributeFactory.setConcurrencyChecksEnabled(false);
-        MonitoringRegionCacheListener localListener = new MonitoringRegionCacheListener(service);
-        monitorRegionAttributeFactory.addCacheListener(localListener);
-
-        RegionAttributes<String, Object> monitoringRegionAttrs =
-            monitorRegionAttributeFactory.create();
-
-        AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
-            new AttributesFactory<NotificationKey, Notification>();
-        notificationRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-        notificationRegionAttributeFactory.setDataPolicy(DataPolicy.EMPTY);
-        notificationRegionAttributeFactory.setConcurrencyChecksEnabled(false);
-
-        RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
-            notificationRegionAttributeFactory.create();
-
-        String appender = MBeanJMXAdapter.getUniqueIDForMember(system.getDistributedMember());
-
-        boolean monitoringRegionCreated = false;
-        boolean notifRegionCreated = false;
-
-        try {
-          repo.setLocalMonitoringRegion(
-              cache.createInternalRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
-                  monitoringRegionAttrs, internalArgs));
-          monitoringRegionCreated = true;
-
-        } catch (TimeoutException e) {
-          throw new ManagementException(e);
-        } catch (RegionExistsException e) {
-          throw new ManagementException(e);
-        } catch (IOException e) {
-          throw new ManagementException(e);
-        } catch (ClassNotFoundException e) {
-          throw new ManagementException(e);
-        }
-
-        try {
-          repo.setLocalNotificationRegion(
-              cache.createInternalRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
-                  notifRegionAttrs, internalArgs));
-          notifRegionCreated = true;
-        } catch (TimeoutException e) {
-          throw new ManagementException(e);
-        } catch (RegionExistsException e) {
-          throw new ManagementException(e);
-        } catch (IOException e) {
-          throw new ManagementException(e);
-        } catch (ClassNotFoundException e) {
-          throw new ManagementException(e);
-        } finally {
-          if (!notifRegionCreated && monitoringRegionCreated) {
-            repo.getLocalMonitoringRegion().localDestroyRegion();
-
-          }
-        }
-
-        managementTask = new ManagementTask(federatedComponentMap);
-        // call run to get us initialized immediately with a sync call
-        managementTask.run();
-        // All local resources are created for the ManagementTask
-        // Now Management tasks can proceed.
-        int updateRate = system.getConfig().getJmxManagerUpdateRate();
-        singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
-            TimeUnit.MILLISECONDS);
-
-        if (logger.isDebugEnabled()) {
-          logger.debug("Management Region created with Name : {}",
-              repo.getLocalMonitoringRegion().getName());
-          logger.debug("Notification Region created with Name : {}",
-              repo.getLocalNotificationRegion().getName());
-        }
+      if (logger.isDebugEnabled()) {
+        logger.debug("Management Region created with Name : {}",
+            repo.getLocalMonitoringRegion().getName());
+        logger.debug("Notification Region created with Name : {}",
+            repo.getLocalNotificationRegion().getName());
-  public void markForFederation(ObjectName objName, FederationComponent fedComp) {
+  void markForFederation(ObjectName objName, FederationComponent fedComp) {
-  public void unMarkForFederation(ObjectName objName) {
+  void unMarkForFederation(ObjectName objName) {
-    if (this.singleThreadFederationScheduler != null) {
-      this.singleThreadFederationScheduler.shutdownNow();
+    if (singleThreadFederationScheduler != null) {
+      singleThreadFederationScheduler.shutdownNow();
-          } catch (MalformedObjectNameException e) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Unable to clean MBean: {} due to {}", objName, e.getMessage(), e);
-            }
-          } catch (NullPointerException e) {
+          } catch (MalformedObjectNameException | NullPointerException e) {
-  public ScheduledExecutorService getFederationSheduler() {
+  @VisibleForTesting
+  public ScheduledExecutorService getFederationScheduler() {
+  @VisibleForTesting
+  @Override
+  public boolean isRunning() {
+    return running;
+  }
+
+  @Override
+  public void startManager() {
+    startLocalManagement();
+    running = true;
+  }
+
+  @Override
+  public void stopManager() {
+    // Shutting down the GII executor as this node wont require it anymore
+    shutdownTasks();
+    // Clean up management Resources
+    cleanUpResources();
+    running = false;
+  }
+
+  public Map<ObjectName, FederationComponent> getFedComponents() {
+    return federatedComponentMap;
+  }
+
+  private void doManagementTask(Map<String, FederationComponent> replicaMap) {
+    if (logger.isTraceEnabled()) {
+      logger.trace("Federation started at managed node : ");
+    }
+
+    try {
+      synchronized (lock) {
+        replicaMap.clear();
+        Set<ObjectName> keySet = federatedComponentMap.keySet();
+        if (keySet.isEmpty()) {
+          return;
+        }
+
+        for (ObjectName objectName : keySet) {
+          FederationComponent fedCompInstance = federatedComponentMap.get(objectName);
+
+          if (Thread.interrupted()) {
+            replicaMap.clear();
+            return;
+          }
+
+          if (fedCompInstance != null) {
+            boolean stateChanged = fedCompInstance.refreshObjectState(service.isManager());
+            if (!stopCacheOps) {
+              String key = objectName.toString();
+              if (stateChanged || !repo.keyExistsInLocalMonitoringRegion(key)) {
+                replicaMap.put(key, fedCompInstance);
+              }
+            }
+          }
+        }
+
+        if (stopCacheOps) {
+          return;
+        }
+        if (Thread.interrupted()) {
+          replicaMap.clear();
+          return;
+        }
+        repo.putAllInLocalMonitoringRegion(replicaMap);
+      }
+    } catch (CancelException ex) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Management Task Cancelled");
+      }
+      return;
+    } catch (GemFireException ex) {
+      if (!cache.isClosed() && logger.isDebugEnabled()) {
+        logger.debug(ex.getMessage(), ex);
+      }
+      // Ignore Exception if cache is closing
+      return;
+    } catch (VirtualMachineError e) {
+      SystemFailure.initiateFailure(e);
+      throw e;
+    } catch (Throwable th) {
+      SystemFailure.checkFailure();
+      throw th;
+    }
+    if (logger.isTraceEnabled()) {
+      logger.trace("Federation completed at managed node : ");
+    }
+  }
+
-    public ManagementTask(Map<ObjectName, FederationComponent> federatedComponentMap)
-        throws ManagementException {
-      this.replicaMap = new HashMap<String, FederationComponent>();
+    private ManagementTask() {
+      replicaMap = new HashMap<>();
-      if (logger.isTraceEnabled()) {
-        logger.trace("Federation started at managed node : ");
-      }
-
-      try {
-        synchronized (lock) {
-          replicaMap.clear();
-          Set<ObjectName> keySet = federatedComponentMap.keySet();
-          if (keySet.size() == 0) {
-            return;
-          }
-
-          Iterator<ObjectName> it = keySet.iterator();
-
-          while (it.hasNext()) {
-
-            ObjectName objectName = it.next();
-            FederationComponent fedCompInstance = federatedComponentMap.get(objectName);
-
-            if (Thread.interrupted()) {
-              replicaMap.clear();
-              return;
-            }
-
-            if (fedCompInstance != null) {
-              boolean stateChanged = fedCompInstance.refreshObjectState(service.isManager());
-              if (!stopCacheOps) {
-                String key = objectName.toString();
-                if (stateChanged || !repo.keyExistsInLocalMonitoringRegion(key)) {
-                  replicaMap.put(key, fedCompInstance);
-                }
-              }
-            }
-          }
-
-          if (stopCacheOps) {
-            return;
-          }
-          if (Thread.interrupted()) {
-            replicaMap.clear();
-            return;
-          }
-          repo.putAllInLocalMonitoringRegion(replicaMap);
-        }
-      } catch (CancelException ex) {
-        if (logger.isDebugEnabled())
-          logger.debug("Management Task Cancelled");
-        return;
-      } catch (GemFireException ex) {
-        if (!cache.isClosed() && logger.isDebugEnabled()) {
-          logger.debug(ex.getMessage(), ex);
-        }
-        return; // Ignore Exception if cache is closing
-      } catch (VirtualMachineError e) {
-        SystemFailure.initiateFailure(e);
-        throw e;
-      } catch (Throwable th) {
-        SystemFailure.checkFailure();
-        throw th;
-      }
-      if (logger.isTraceEnabled()) {
-        logger.trace("Federation completed at managed node : ");
-      }
+      doManagementTask(replicaMap);
-
-  @Override
-  public boolean isRunning() {
-    return running;
-  }
-
-  @Override
-  public void startManager() {
-    startLocalManagement(federatedComponentMap);
-    running = true;
-  }
-
-  @Override
-  public void stopManager() {
-    // Shutting down the GII executor as this node wont require it anymore
-    shutdownTasks();
-    // Clean up management Resources
-    cleanUpResources();
-    running = false;
-  }
-
-  public void stopCacheOps() {
-    stopCacheOps = true;
-  }
-
-  public void startCacheOps() {
-    stopCacheOps = false;
-  }
-
-  public Map<ObjectName, FederationComponent> getFedComponents() {
-    return federatedComponentMap;
-  }
-

Merge branch 'develop' of https://git-wip-us.apache.org/repos/asf/geode into develop

* 'develop' of https://git-wip-us.apache.org/repos/asf/geode: (57 commits)
  GEODE-2551 Fix code issues found by AppChecker
  Revert "GEODE-1887: Now Size api goes through ServerProxy when cache is of type client and DataPolicy is Empty."
  GEODE-2538: Don't deserialize values on the server when getting results
  GEODE-2461: remove json4s-ast_2.10 as explicit dependency
  GEODE-2547: Interest registration no longer causes a CacheLoader to be invoked
  GEODE-2526: Enhance log statement to include ResourceTypeName
  GEODE-880 Remove unused classes
  GEODE-2460: update dependency versions
  GEODE-1995: Removed ReliableMessageQueue, ReliableMessageQueueFactory, ReliableMessageQueueFactoryImpl and it's usage in the code from GemfireCacheImpl and DistributedRegion.
  GEODE-2550 Improve README and BUILDING
  GEODE-2538: Don't invoke a cache loader when fetching values for a lucene query
  GEODE-2404: Added support for destroying lucene indexes
  GEODE-2545: NPE during lucene query execution when cache is closing or region is destroyed
  GEODE-2515: Disabling BaseLineAndCompareQueryPerfJUnitTest
  GEODE-2142: Removing JSON licence stuff from NOTICE files
  GEODE-2142: removing tests so run precheckin
  GEODE-2142: final compiling build
  GEODE-2142: cyclical dependency in gradle build
  GEODE-2142: spotless
  GEODE-2142: Refactoring of tests to work with new JSONObject class. Changing file export to use Base64 encoding.
  ...

-   * Provides a queue for reliable message delivery
-   * 
-   * @since GemFire 5.0
-   */
-  protected final ReliableMessageQueue rmq;
-
-  /**
-    {
-      ReliableMessageQueue tmp = null;
-      if (this.requiresReliabilityCheck) {
-        // if
-        // (attrs.getMembershipAttributes().getLossAction().isAllAccessWithQueuing())
-        // {
-        // tmp = cache.getReliableMessageQueueFactory().create(this);
-        // }
-      }
-      this.rmq = tmp;
-    }
-
-  protected void handleReliableDistribution(ReliableDistributionData data,
-      Set successfulRecipients) {
-    handleReliableDistribution(data, successfulRecipients, Collections.EMPTY_SET,
-        Collections.EMPTY_SET);
+  protected void handleReliableDistribution(Set successfulRecipients) {
+    handleReliableDistribution(successfulRecipients, Collections.EMPTY_SET, Collections.EMPTY_SET);
-  protected void handleReliableDistribution(ReliableDistributionData data, Set successfulRecipients,
-      Set otherRecipients1, Set otherRecipients2) {
+  protected void handleReliableDistribution(Set successfulRecipients, Set otherRecipients1,
+      Set otherRecipients2) {
-  /**
-   * Sends a list of queued messages to members playing a specified role
-   * 
-   * @param list List of QueuedOperation instances to send. Any messages sent will be removed from
-   *        this list
-   * @param role the role that a recipient must be playing
-   * @return true if at least one message made it to at least one guy playing the role
-   */
-  boolean sendQueue(List list, Role role) {
-    SendQueueOperation op = new SendQueueOperation(getDistributionManager(), this, list, role);
-    return op.distribute();
-  }
-
-        SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();
-        try {
-          processor.initialize(this, key, aCallbackArgument);
-          // processor fills in event
-          processor.doSearchAndLoad(event, txState, localValue);
-          if (clientEvent != null && clientEvent.getVersionTag() == null) {
-            clientEvent.setVersionTag(event.getVersionTag());
+        // If this event is because of a register interest call, don't invoke the CacheLoader
+        boolean getForRegisterInterest = clientEvent != null && clientEvent.getOperation() != null
+            && clientEvent.getOperation().isGetForRegisterInterest();
+        if (!getForRegisterInterest) {
+          SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();
+          try {
+            processor.initialize(this, key, aCallbackArgument);
+            // processor fills in event
+            processor.doSearchAndLoad(event, txState, localValue);
+            if (clientEvent != null && clientEvent.getVersionTag() == null) {
+              clientEvent.setVersionTag(event.getVersionTag());
+            }
+            lastModified = processor.getLastModified();
+          } finally {
+            processor.release();
-          lastModified = processor.getLastModified();
-        } finally {
-          processor.release();
+        } else {
+          if (logger.isDebugEnabled()) {
+            logger.debug("DistributedRegion.findObjectInSystem skipping loader for region="
+                + getFullPath() + "; key=" + key);
+          }
-    if (this.rmq != null) {
-      this.rmq.close();
-    }
-
-    if (this.rmq != null && destroyDiskRegion) {
-      this.rmq.destroy();
-    }
-              if (DistributedRegion.this.rmq != null) {
-                Iterator it = newlyAcquiredRoles.iterator();
-                final DM dm = getDistributionManager();
-                while (it.hasNext()) {
-                  getCache().getCancelCriterion().checkCancelInProgress(null);
-                  final Role role = (Role) it.next();
-                  try {
-                    // do this in the waiting pool to make it async
-                    // @todo darrel/klund: add a single serial executor for
-                    // queue flush
-                    dm.getWaitingThreadPool().execute(new Runnable() {
-                      public void run() {
-                        DistributedRegion.this.rmq.roleReady(role);
-                      }
-                    });
-                    break;
-                  } catch (RejectedExecutionException ex) {
-                    throw ex;
-                  }
-                } // while
-              }

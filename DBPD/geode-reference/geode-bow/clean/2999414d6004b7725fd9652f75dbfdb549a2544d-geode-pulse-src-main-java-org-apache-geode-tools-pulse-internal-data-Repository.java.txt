GEODE-7851: Pulse refreshes expired access tokens (#4977)

If a user's access token expires, Pulse attempts to refresh it. If the
refresh fails, Pulse logs the user out and redirects the browser to
/pulse/clusterLogout.

Changes in Repository:
- When OAuth is configured, before returning the user's cluster,
  getCluster() checks whether the user's access token has expired.
- If the access token has expired, the repository attempts to refresh
  it.  If the refresh succeeds, the repository reconnects the user's
  cluster to JMX and returns it.
- If the refresh fails, the repository disconnects the user's cluster
  from JMX, removes the cluster from the repository, and throws an
  authentication or authorization exception.

Changes in PulseController:
- If the service call throws an authentication or authorization
  exception, PulseController.  getPulseUpdate() returns a 401 status.

Changes in pulsescript/common.js:
- If a Pulse ajax call returns a 401 status, ajaxPost() redirects the
  browser to /pulse/clusterLogout to log the user out and request
  re-authorization.

Co-authored-by: Joris Melchior <joris.melchior@gmail.com>
Co-authored-by: Dale Emery <demery@pivotal.io>
Co-authored-by: Jinmei Liao <jiliao@pivotal.io>

Co-authored-by: Kirk Lund <klund@apache.org>
Co-authored-by: Joris Melchior <joris.melchior@gmail.com>
Co-authored-by: Jinmei Liao <jiliao@pivotal.io>
+import static java.time.Instant.now;
+
+import java.time.Instant;
-import java.util.Iterator;
-import java.util.Map;
+import java.util.Set;
-import org.springframework.security.oauth2.core.OAuth2AccessToken;
-import org.springframework.security.oauth2.core.user.OAuth2User;
+import org.springframework.security.oauth2.client.endpoint.DefaultRefreshTokenTokenResponseClient;
+import org.springframework.security.oauth2.client.endpoint.OAuth2RefreshTokenGrantRequest;
+import org.springframework.security.oauth2.core.AbstractOAuth2Token;
+import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
+import org.springframework.security.oauth2.core.OAuth2AuthorizationException;
+import org.springframework.security.oauth2.core.OAuth2Error;
+import org.springframework.security.oauth2.core.OAuth2RefreshToken;
+import org.springframework.security.oauth2.core.endpoint.OAuth2AccessTokenResponse;
+import org.springframework.security.oauth2.core.oidc.user.OidcUser;
+  private static final Locale LOCALE =
+      new Locale(PulseConstants.APPLICATION_LANGUAGE, PulseConstants.APPLICATION_COUNTRY);
-  Locale locale =
-      new Locale(PulseConstants.APPLICATION_LANGUAGE, PulseConstants.APPLICATION_COUNTRY);
-      ResourceBundle.getBundle(PulseConstants.LOG_MESSAGES_FILE, locale);
+      ResourceBundle.getBundle(PulseConstants.LOG_MESSAGES_FILE, LOCALE);
+  /**
+   * this will return a cluster already connected to the geode jmx manager for the user in the
+   * request
+   * <p>
+   * But for multi-user connections to gemfireJMX, i.e pulse that uses gemfire integrated security,
+   * we will need to get the username from the context
+   */
+  public Cluster getCluster() {
+    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
+    if (authentication == null) {
+      return null;
+    }
+
+    if (authentication instanceof OAuth2AuthenticationToken) {
+      return getClusterWithAuthenticationToken((OAuth2AuthenticationToken) authentication);
+    }
+
+    return getClusterWithUserNameAndPassword(authentication.getName(), null);
+  }
+
+  public Cluster getClusterWithUserNameAndPassword(String userName, String password) {
+    String[] credentials = {userName, password};
+    return getClusterWithCredentials(userName, credentials);
+  }
+
+  public Cluster getClusterWithCredentials(String userName, Object credentials) {
+    synchronized (clusterMap) {
+      Cluster cluster = clusterMap.get(userName);
+      if (cluster == null) {
+        logger.info(resourceBundle.getString("LOG_MSG_CREATE_NEW_THREAD") + " : " + userName);
+        cluster = clusterFactory.create(host, port, userName, resourceBundle, this);
+        // Assign name to thread created
+        cluster.setName(PulseConstants.APP_NAME + "-" + host + ":" + port + ":" + userName);
+        cluster.connectToGemFire(credentials);
+        if (cluster.isConnectedFlag()) {
+          clusterMap.put(userName, cluster);
+        }
+      }
+      return cluster;
+    }
+  }
+
+  /**
+   * Returns the cluster for the user associated with the given authentication. If the user's
+   * access token is expired, it is refreshed and the cluster is reconnected to JMX using the fresh
+   * token. If the refresh fails, the user's cluster is disconnected from JMX and removed from the
+   * repository.
+   */
+  private Cluster getClusterWithAuthenticationToken(OAuth2AuthenticationToken authentication) {
+    OAuth2AuthorizedClient authorizedClient = getAuthorizedClient(authentication);
+    if (isExpired(authorizedClient.getAccessToken())) {
+      return reconnectedClusterForExpiredClient(authentication, authorizedClient);
+    }
+
+    // When the cluster connects to JMX, it will include this access token as the
+    // jmx.remote.credentials attribute in the connection environment. The JMX server will then pass
+    // the access token to the security manager for authentication.
+    String credentials = authorizedClient.getAccessToken().getTokenValue();
+    String subject = getSubject(authentication);
+    return getClusterWithCredentials(subject, credentials);
+  }
+
+  private static String getSubject(Authentication authentication) {
+    OAuth2AuthenticationToken oauth2Authentication = (OAuth2AuthenticationToken) authentication;
+    OidcUser oidcUser = (OidcUser) oauth2Authentication.getPrincipal();
+    return oidcUser.getIdToken().getSubject();
+  }
+
+  public void logoutUser(String userName) {
+    Cluster cluster = clusterMap.remove(userName);
+    if (cluster != null) {
+      try {
+        cluster.setStopUpdates(true);
+        cluster.getJMXConnector().close();
+      } catch (Exception e) {
+        // We're logging out so this can be ignored
+      }
+    }
+  }
+
+  public void removeAllClusters() {
+    Set<String> keySet = clusterMap.keySet();
+
+    for (String key : keySet) {
+      Cluster c = clusterMap.get(key);
+      c.stopThread();
+      clusterMap.remove(key);
+      logger.info("{} : {}", resourceBundle.getString("LOG_MSG_REMOVE_THREAD"), key);
+    }
+  }
+
-    return this.jmxUseLocator;
+    return jmxUseLocator;
-    return this.host;
+    return host;
-    this.host = jmxHost;
+    host = jmxHost;
-    return this.port;
+    return port;
-    this.port = jmxPort;
+    port = jmxPort;
-    return this.pulseConfig;
+    return pulseConfig;
-  /**
-   * this will return a cluster already connected to the geode jmx manager for the user in the
-   * request
-   *
-   * But for multi-user connections to gemfireJMX, i.e pulse that uses gemfire integrated security,
-   * we will need to get the username from the context
-   */
-  public Cluster getCluster() {
-    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
-    if (authentication == null) {
-      return null;
-    }
-
-    if (authentication instanceof OAuth2AuthenticationToken) {
-      OAuth2AuthenticationToken authenticationToken = (OAuth2AuthenticationToken) authentication;
-      OAuth2AuthorizedClient authorizedClient = authorizedClientService.loadAuthorizedClient(
-          authenticationToken.getAuthorizedClientRegistrationId(),
-          authenticationToken.getName());
-
-      OAuth2User authenticatedPrincipal = authenticationToken.getPrincipal();
-      String authenticatedPrincipalName = authenticatedPrincipal.getName();
-      OAuth2AccessToken accessToken = authorizedClient.getAccessToken();
-      String accessTokenValue = accessToken.getTokenValue();
-      return getClusterWithCredentials(authenticatedPrincipalName, accessTokenValue);
-    }
-
-    return getClusterWithUserNameAndPassword(authentication.getName(), null);
-  }
-
-  public Cluster getClusterWithUserNameAndPassword(String userName, String password) {
-    return getClusterWithCredentials(userName, new String[] {userName, password});
-  }
-
-  public Cluster getClusterWithCredentials(String username, Object credentials) {
-    synchronized (this.clusterMap) {
-      Cluster data = clusterMap.get(username);
-      if (data == null) {
-        logger.info(resourceBundle.getString("LOG_MSG_CREATE_NEW_THREAD") + " : " + username);
-        data = clusterFactory.create(host, port, username, resourceBundle, this);
-        // Assign name to thread created
-        data.setName(PulseConstants.APP_NAME + "-" + host + ":" + port + ":" + username);
-        data.connectToGemFire(credentials);
-        if (data.isConnectedFlag()) {
-          this.clusterMap.put(username, data);
-        }
-      }
-      return data;
-    }
-  }
-
-  public void logoutUser(String username) {
-    Cluster data = clusterMap.remove(username);
-    if (data != null) {
-      try {
-        data.setStopUpdates(true);
-        data.getJMXConnector().close();
-      } catch (Exception e) {
-        // We're logging out so this can be ignored
-      }
-    }
-  }
-
-  // This method is used to remove all cluster threads
-  public void removeAllClusters() {
-
-    Iterator<Map.Entry<String, Cluster>> iter = clusterMap.entrySet().iterator();
-
-    while (iter.hasNext()) {
-      Map.Entry<String, Cluster> entry = iter.next();
-      Cluster c = entry.getValue();
-      String clusterKey = entry.getKey();
-      c.stopThread();
-      iter.remove();
-      logger.info("{} : {}", resourceBundle.getString("LOG_MSG_REMOVE_THREAD"), clusterKey);
-    }
-  }
-
-    return this.resourceBundle;
+    return resourceBundle;
+  private OAuth2AuthorizedClient getAuthorizedClient(
+      OAuth2AuthenticationToken authenticationToken) {
+    return authorizedClientService.loadAuthorizedClient(
+        authenticationToken.getAuthorizedClientRegistrationId(), authenticationToken.getName());
+  }
+  private static boolean isExpired(AbstractOAuth2Token token) {
+    Instant tokenExpiration = token.getExpiresAt();
+    return tokenExpiration != null && tokenExpiration.isBefore(now());
+  }
+
+  private OAuth2AuthorizedClient refreshExpiredClient(Authentication authentication,
+      OAuth2AuthorizedClient expiredClient) {
+    OAuth2RefreshToken refreshToken = expiredClient.getRefreshToken();
+    String subject = getSubject(authentication);
+    if (refreshToken == null) {
+      throw new OAuth2AuthenticationException(new OAuth2Error("401"),
+          "User " + subject + " has no refresh token.");
+    }
+    if (isExpired(refreshToken)) {
+      throw new OAuth2AuthenticationException(new OAuth2Error("401"),
+          "The refresh token for " + subject + " has expired.");
+    }
+
+    OAuth2AccessTokenResponse freshToken = getFreshToken(expiredClient);
+
+    OAuth2AuthorizedClient freshClient = new OAuth2AuthorizedClient(
+        expiredClient.getClientRegistration(), expiredClient.getPrincipalName(),
+        freshToken.getAccessToken(), freshToken.getRefreshToken());
+
+    authorizedClientService.saveAuthorizedClient(freshClient, authentication);
+
+    return freshClient;
+  }
+
+  /**
+   * Refreshes the expired client's access token, reconnects the associated user's cluster using
+   * the new token, and returns the reconnected cluster. If the access token cannot be refreshed,
+   * the user's cluster is disconnected from JMX and removed from the repository.
+   */
+  private Cluster reconnectedClusterForExpiredClient(OAuth2AuthenticationToken authentication,
+      OAuth2AuthorizedClient expiredClient) {
+    String subject = getSubject(authentication);
+
+    logger.info("Attempting to refresh the expired access token for {}.", subject);
+
+    OAuth2AuthorizedClient freshClient;
+    try {
+      freshClient = refreshExpiredClient(authentication, expiredClient);
+    } catch (OAuth2AuthenticationException | OAuth2AuthorizationException authException) {
+      String message = "Failed to refresh the access token for " + subject +
+          ". Disconnecting and removing the user's cluster.";
+      logger.info(message);
+      logoutUser(subject);
+      throw authException;
+    }
+
+    logger.info("Refreshed the access token for {}. Reconnecting the user's cluster.", subject);
+    synchronized (clusterMap) {
+      Cluster cluster = clusterMap.get(subject);
+      if (cluster != null) {
+        // When the cluster reconnects to JMX, it will include this access token as the
+        // jmx.remote.credentials attribute in the connection environment. The JMX server will then
+        // pass the access token to the security manager for authentication.
+        String credentials = freshClient.getAccessToken().getTokenValue();
+        cluster.reconnectToGemFire(credentials);
+      }
+      return cluster;
+    }
+  }
+
+  private static OAuth2AccessTokenResponse getFreshToken(OAuth2AuthorizedClient expiredClient) {
+    OAuth2RefreshTokenGrantRequest refreshRequest = new OAuth2RefreshTokenGrantRequest(
+        expiredClient.getClientRegistration(),
+        expiredClient.getAccessToken(),
+        expiredClient.getRefreshToken());
+
+    return new DefaultRefreshTokenTokenResponseClient()
+        .getTokenResponse(refreshRequest);
+  }

Merge branch 'release/1.0.0-incubating.M3'

-import java.io.File;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import com.gemstone.gemfire.InternalGemFireException;
-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.cache.client.internal.locator.ClientConnectionRequest;
-import com.gemstone.gemfire.cache.client.internal.locator.ClientReplacementRequest;
-import com.gemstone.gemfire.cache.client.internal.locator.GetAllServersRequest;
-import com.gemstone.gemfire.cache.client.internal.locator.LocatorListRequest;
-import com.gemstone.gemfire.cache.client.internal.locator.LocatorStatusRequest;
-import com.gemstone.gemfire.cache.client.internal.locator.LocatorStatusResponse;
-import com.gemstone.gemfire.cache.client.internal.locator.QueueConnectionRequest;
-import com.gemstone.gemfire.cache.client.internal.locator.ServerLocationRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.*;
+import org.apache.logging.log4j.Logger;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.*;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
- * @since 4.0
+ * @since GemFire 4.0
-  public static final String LOCATORS_PREFERRED_AS_COORDINATORS = "gemfire.disable-floating-coordinator";
+  public static final String LOCATORS_PREFERRED_AS_COORDINATORS = DistributionConfig.GEMFIRE_PREFIX + "disable-floating-coordinator";
-   * @since 5.7
+   * @since GemFire 5.7
+
+  private WanLocatorDiscoverer locatorDiscoverer;
-  
-  
+
-   * @since 7.0
+   * @since GemFire 7.0
-    
+    // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero port in a variable to use here
+
-        slocator.startDistributedSystem();
+        slocator.startDistributedSystem(); // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
-    this.port = port;
-      env.setProperty(DistributionConfig.BIND_ADDRESS_NAME,
+      env.setProperty(BIND_ADDRESS,
-    
-
-    env.setProperty(DistributionConfig.CACHE_XML_FILE_NAME, "");
+    env.setProperty(CACHE_XML_FILE, "");
-      this.locatorListener.setPort(this.port);
+      // We defer setting the port until the handler is init'd - that way we'll have an actual port in the
+      // case where we're starting with port = 0.
-    this.handler = new PrimaryHandler(this.port, this, locatorListener);
+    this.handler = new PrimaryHandler(this, locatorListener);
-    server = new TcpServer(this.port, this.bindAddress, null, this.config,
+    server = new TcpServer(port, this.bindAddress, null, this.config,
+  //Reset the file names with the correct port number if startLocatorAndDS was called with port number 0
+  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port){
+    this.stateFile = new File("locator" + port + "view.dat");
+    File productUseFile = new File("locator"+port+"views.log");
+    this.productUseLog = new ProductUseLog(productUseFile);
+  }
+
+
-   * @since 5.7
+   * @since GemFire 5.7
-    if (locatorsAreCoordinators) {
-      // LOG: changed from config to info
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_FORCING_GROUP_COORDINATION_INTO_LOCATORS));
-    }
-    
+
-   * @since 5.7
+   * @since GemFire 5.7
-        sb.append('[').append(port).append(']');
+        sb.append('[').append(getPort()).append(']');
-            updateEnv.setProperty(DistributionConfig.LOCATORS_NAME, locatorsProp);
+            updateEnv.setProperty(LOCATORS, locatorsProp);
-                                 DistributionConfig.LOCATORS_NAME;
+                LOCATORS;
-   * @since 5.7
+   * @since GemFire 5.7
-    WanLocatorDiscoverer s = WANServiceProvider.createLocatorDiscoverer();
-    if(s != null) {
-      s.discover(this.port, config, locatorListener);
+    this.locatorDiscoverer = WANServiceProvider.createLocatorDiscoverer();
+    if(this.locatorDiscoverer != null) {
+      this.locatorDiscoverer.discover(getPort(), config, locatorListener);
-   * @since 5.7
+   * @since GemFire 5.7
-    ServerLocator sl = new ServerLocator(this.port, 
+    ServerLocator sl = new ServerLocator(getPort(),
+    if (this.locatorDiscoverer != null) {
+      this.locatorDiscoverer.stop();
+      this.locatorDiscoverer = null;
+    }
+
-        stopLocator(this.port, this.bindAddress);
+        stopLocator(getPort(), this.bindAddress);
-  
+
+  /**
+   * Return the port on which the locator is actually listening. If called before the locator has actually
+   * started, this method will return null.
+   *
+   * @return the port the locator is listening on or null if it has not yet been started
+   */
+  public Integer getPort() {
+    if (server != null) {
+      return server.getPort();
+    }
+    return null;
+  }
-    InternalLocator interalLocator;
+    private InternalLocator internalLocator;
-    public PrimaryHandler(int port, InternalLocator locator,
+    public PrimaryHandler(InternalLocator locator,
-      interalLocator = locator;
+      internalLocator = locator;
+      if (this.locatorListener != null) {
+        // This is deferred until now as the initial requested port could have been 0
+        this.locatorListener.setPort(internalLocator.getPort());
+      }
+
-        this.interalLocator.handleShutdown();
+        this.internalLocator.handleShutdown();

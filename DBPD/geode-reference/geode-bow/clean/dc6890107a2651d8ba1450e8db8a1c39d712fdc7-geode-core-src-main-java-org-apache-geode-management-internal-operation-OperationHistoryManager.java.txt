GEODE-6897: implement CMS rebalance operation (#3820)


-import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Set;
-
-import org.apache.commons.collections.map.LRUMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
-import org.apache.geode.management.api.JsonSerializable;
+import org.apache.geode.management.runtime.OperationResult;
+/**
+ * Retains references to all running and some recently-completed operations.
+ *
+ * The policy for expiring completed operations is subject to change, but may be based on age,
+ * count, when it was last accessed, or some combination thereof.
+ */
-  private final ConcurrentMap<String, CompletableFuture> inProgressHistory;
-  private final Map<String, CompletableFuture> completedHistory;
+  private final ConcurrentMap<String, OperationInstance> history;
+  private final long keepCompletedMillis;
+  /**
+   * set a default retention policy to keep results for 2 hours after completion
+   */
-    this(100);
-  }
-
-  @SuppressWarnings("unchecked")
-  public OperationHistoryManager(int historySize) {
-    inProgressHistory = new ConcurrentHashMap<>();
-    completedHistory = Collections.synchronizedMap(new LRUMap(historySize));
+    this(2, TimeUnit.HOURS);
-   * looks up the future for an async operation by id
+   * set a custom retention policy to keep results for X amount of time after completion
+   */
+  public OperationHistoryManager(long keepCompleted, TimeUnit timeUnit) {
+    history = new ConcurrentHashMap<>();
+    keepCompletedMillis = timeUnit.toMillis(keepCompleted);
+  }
+
+  /**
+   * look up the specified key
-  public <V extends JsonSerializable> CompletableFuture<V> getStatus(String opId) {
-    CompletableFuture<V> ret = inProgressHistory.get(opId);
-    if (ret == null) {
-      ret = completedHistory.get(opId);
-    }
-    return ret;
+  <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationInstance<A, V> getOperationInstance(
+      String opId) {
+    expireHistory();
+    return (OperationInstance<A, V>) history.get(opId);
-  public <A extends ClusterManagementOperation<V>, V extends JsonSerializable> OperationInstance<A, V> save(
+  private void expireHistory() {
+    final long expirationDate = now() - keepCompletedMillis;
+    Set<String> expiredKeys =
+        history.entrySet().stream().filter(e -> isExpired(expirationDate, e.getValue()))
+            .map(Map.Entry::getKey).collect(Collectors.toSet());
+    expiredKeys.forEach(history::remove);
+  }
+
+  long now() {
+    return System.currentTimeMillis();
+  }
+
+  private static boolean isExpired(long expirationDate, OperationInstance<?, ?> operationInstance) {
+    CompletableFuture<Date> futureOperationEnded = operationInstance.getFutureOperationEnded();
+
+    if (!futureOperationEnded.isDone())
+      return false; // always keep while still in-progress
+
+    final long endTime;
+    try {
+      endTime = futureOperationEnded.get().getTime();
+    } catch (ExecutionException ignore) {
+      // cannot ever happen because we've already checked isDone above
+      return false;
+    } catch (InterruptedException ignore) {
+      // cannot ever happen because we've already checked isDone above
+      Thread.currentThread().interrupt();
+      return false;
+    }
+
+    return endTime <= expirationDate;
+  }
+
+  /**
+   * Stores a new operation in the history and installs a trigger to record the operation end time.
+   */
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationInstance<A, V> save(
-    CompletableFuture<V> future = operationInstance.getFuture();
+    CompletableFuture<V> future = operationInstance.getFutureResult();
-    inProgressHistory.put(opId, future);
+    future.whenComplete((result, exception) -> operationInstance.setOperationEnded(new Date()));
-    CompletableFuture<V> newFuture = future.whenComplete((result, exception) -> {
-      completedHistory.put(opId, future);
-      inProgressHistory.remove(opId);
-    });
+    history.put(opId, operationInstance);
+    expireHistory();
-    // we want to replace only if still in in-progress.
-    inProgressHistory.replace(opId, future, newFuture);
-
-    return new OperationInstance<>(newFuture, opId, operationInstance.getOperation());
+    return operationInstance;
-  public static final class OperationInstance<A extends ClusterManagementOperation<V>, V extends JsonSerializable>
+  @SuppressWarnings("unchecked")
+  <A extends ClusterManagementOperation<V>, V extends OperationResult> List<OperationInstance<A, V>> listOperationInstances(
+      A opType) {
+    expireHistory();
+    return history.values().stream().filter(oi -> opType.getClass().isInstance(oi.getOperation()))
+        .map(oi -> (OperationInstance<A, V>) oi).collect(Collectors.toList());
+  }
+
+  /**
+   * struct for holding information pertinent to a specific instance of an operation
+   *
+   * all fields are immutable, however note that {@link #setOperationEnded(Date)} completes
+   * {@link #getFutureOperationEnded()}
+   */
+  public static class OperationInstance<A extends ClusterManagementOperation<V>, V extends OperationResult>
+    private final Date operationStart;
+    private final CompletableFuture<Date> futureOperationEnded;
+    private String operator;
-    public OperationInstance(CompletableFuture<V> future, String opId, A operation) {
+    public OperationInstance(CompletableFuture<V> future, String opId, A operation,
+        Date operationStart) {
+      this.operationStart = operationStart;
+      this.futureOperationEnded = new CompletableFuture<>();
-    public CompletableFuture<V> getFuture() {
+    public CompletableFuture<V> getFutureResult() {
+
+    public Date getOperationStart() {
+      return operationStart;
+    }
+
+    public CompletableFuture<Date> getFutureOperationEnded() {
+      return futureOperationEnded;
+    }
+
+    public void setOperationEnded(Date operationEnded) {
+      this.futureOperationEnded.complete(operationEnded);
+    }
+
+    public String getOperator() {
+      return operator;
+    }
+
+    public void setOperator(String operator) {
+      this.operator = operator;
+    }

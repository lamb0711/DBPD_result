Merge branch 'release/1.5.0'

+import java.io.InputStream;
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import org.apache.geode.Statistics;
+import org.apache.geode.cache.Operation;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.internal.cache.tier.sockets.CacheClientNotifier;
+import org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID;
-public interface InternalRegion<K, V>
-    extends Region<K, V>, HasCachePerfStats, RegionEntryContext, RegionAttributes, HasDiskRegion {
+@SuppressWarnings("rawtypes")
+public interface InternalRegion extends Region, HasCachePerfStats, RegionEntryContext,
+    RegionAttributes, HasDiskRegion, RegionMapOwner {
-  RegionEntry getRegionEntry(K key);
+  RegionEntry getRegionEntry(Object key);
-  DM getDistributionManager();
+  /**
+   * Used by unit tests to get access to the EntryExpiryTask of the given key. Returns null if the
+   * entry exists but does not have an expiry task.
+   *
+   * @throws EntryNotFoundException if no entry exists key.
+   */
+  EntryExpiryTask getEntryExpiryTask(Object key);
+
+  DistributionManager getDistributionManager();
-  IndexManager getIndexManager();
+  Lock getClientMetaDataLock();
-  boolean isConcurrencyChecksEnabled();
+  IndexManager getIndexManager();
-  long getEvictions();
+  long getTotalEvictions();
+  void setEvictionMaximum(int maximum);
+
+  /**
+   * Returns null if the region is not configured for eviction otherwise returns the Statistics used
+   * to measure eviction activity.
+   */
+  Statistics getEvictionStatistics();
+
+  long getEvictionCounter();
+
+  RegionMap getRegionMap();
+
+  InternalDistributedSystem getSystem();
+
+  int getRegionSize();
+
+  void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event);
+
+  void basicDestroyPart2(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+      boolean conflictWithClear, boolean duringRI, boolean invokeCallbacks);
+
+  void notifyTimestampsToGateways(EntryEventImpl event);
+
+  boolean bridgeWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
+      throws CacheWriterException, EntryNotFoundException, TimeoutException;
+
+  void checkEntryNotFound(Object entryKey);
+
+  void rescheduleTombstone(RegionEntry entry, VersionTag version);
+
+  /** Throws CacheClosedException or RegionDestroyedException */
+  void checkReadiness();
+
+  void basicDestroyPart3(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+      boolean duringRI, boolean invokeCallbacks, Object expectedOldValue);
+
+  void cancelExpiryTask(RegionEntry regionEntry);
+
+  boolean hasServerProxy();
+
+  int calculateRegionEntryValueSize(RegionEntry re);
+
+  void updateSizeOnRemove(Object key, int oldSize);
+
+  boolean isEntryEvictionPossible();
+
+  KeyInfo getKeyInfo(Object key);
+
+  void waitOnInitialization();
+
+  Set basicSubregions(boolean recursive);
+
+  boolean isSecret();
+
+  boolean isUsedForMetaRegion();
+
+  boolean isInternalRegion();
+
+  void handleCacheClose(Operation op);
+
+  void initialize(InputStream snapshotInputStream, InternalDistributedMember imageTarget,
+      InternalRegionArguments internalRegionArgs)
+      throws TimeoutException, IOException, ClassNotFoundException;
+
+  void cleanupFailedInitialization();
+
+  void postCreateRegion();
+
+  Region getSubregion(String string, boolean b);
+
+  boolean checkForInitialization();
+
+  boolean isUsedForPartitionedRegionBucket();
+
+  Set<String> getAllGatewaySenderIds();
+
+  void senderCreated();
+
+  boolean isInitialized();
+
+  void cleanupForClient(CacheClientNotifier ccn, ClientProxyMembershipID client);

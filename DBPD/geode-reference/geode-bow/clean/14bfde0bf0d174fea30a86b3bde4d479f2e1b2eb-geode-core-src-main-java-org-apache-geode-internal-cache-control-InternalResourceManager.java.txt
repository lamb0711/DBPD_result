Merge branch 'release/1.8.0'

-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.apache.geode.distributed.internal.OverflowQueueWithDMStats;
-import org.apache.geode.distributed.internal.SerialQueuedExecutorWithDMStats;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
-    final ThreadGroup threadGroup =
-        LoggingThreadGroup.createThreadGroup("ResourceManagerThreadGroup", logger);
-
-    ThreadFactory tf = new ThreadFactory() {
-      AtomicInteger ai = new AtomicInteger();
-
-      @Override
-      public Thread newThread(Runnable r) {
-        int tId = ai.getAndIncrement();
-        Thread thread = new Thread(threadGroup, r, "ResourceManagerRecoveryThread " + tId);
-        thread.setDaemon(true);
-        return thread;
-      }
-    };
-
-    this.scheduledExecutor = new ScheduledThreadPoolExecutor(MAX_RESOURCE_MANAGER_EXE_THREADS, tf);
+    this.scheduledExecutor = LoggingExecutors
+        .newScheduledThreadPool("ResourceManagerRecoveryThread ", MAX_RESOURCE_MANAGER_EXE_THREADS);
-    final ThreadGroup listenerInvokerthrdGrp =
-        LoggingThreadGroup.createThreadGroup("ResourceListenerInvokerThreadGroup", logger);
-
-    ThreadFactory eventProcessorFactory = new ThreadFactory() {
-      @Override
-      public Thread newThread(Runnable r) {
-        Thread thread = new Thread(listenerInvokerthrdGrp, r, "Notification Handler");
-        thread.setDaemon(true);
-        thread.setPriority(Thread.MAX_PRIORITY);
-        return thread;
-      }
-    };
-    BlockingQueue<Runnable> threadQ =
-        new OverflowQueueWithDMStats(this.stats.getResourceEventQueueStatHelper());
-    this.notifyExecutor = new SerialQueuedExecutorWithDMStats(threadQ,
-        this.stats.getResourceEventPoolStatHelper(), eventProcessorFactory, getThreadMonitorObj());
+    this.notifyExecutor =
+        LoggingExecutors.newSerialThreadPoolWithFeedStatistics("Notification Handler",
+            thread -> thread.setPriority(Thread.MAX_PRIORITY), null,
+            this.stats.getResourceEventPoolStatHelper(), getThreadMonitorObj(),
+            0, this.stats.getResourceEventQueueStatHelper());
-    if (this.cache.getLoggerI18n().fineEnabled()) {
-      this.cache.getLoggerI18n()
+    if (this.cache.getLogger().fineEnabled()) {
+      this.cache.getLogger()
-    if (this.cache.getLoggerI18n().fineEnabled()) {
-      this.cache.getLoggerI18n()
+    if (this.cache.getLogger().fineEnabled()) {
+      this.cache.getLogger()
-        this.cache.getLoggerI18n()
-            .warning(LocalizedStrings.ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS);
+        this.cache.getLogger()
+            .warning("No memory events will be delivered because of RejectedExecutionException");
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.ResourceManager_FAILED_TO_STOP_RESOURCE_MANAGER_THREADS,
-          new Object[] {secToWait}));
+      logger.warn("Failed to stop resource manager threads in {} seconds",
+          secToWait);

GEODE-8333: Fix PUBSUB hang (#5349)

PUBSUB hangs with concurrent publishers and subscribers on multiple
servers. Changed Publish executor to execute publish on background
thread. Removed separate separate subscriber group.  Added DUnit test to
recreate failure.
A commandQueue is now used to preserve the order
in which commands are executed even if a command
if executed async. Currently the only async command
is PUBLISH.

Co-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>
Co-authored-by: Sarah Abbey <sabbey@vmware.com>
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.EventLoopGroup;
-  private final EventLoopGroup subscriberGroup;
+  private final ExecutorService backgroundExecutor;
+  private final LinkedBlockingQueue<Command> commandQueue = new LinkedBlockingQueue<>();
-      EventLoopGroup subscriberGroup,
+      ExecutorService backgroundExecutor,
-    this.subscriberGroup = subscriberGroup;
+    this.backgroundExecutor = backgroundExecutor;
-  public ChannelFuture writeToChannel(ByteBuf message) {
-    return channel.writeAndFlush(message, channel.newPromise());
-  }
-
-    try {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Redis command: {}", command);
+    command.setChannelHandlerContext(ctx);
+    synchronized (commandQueue) {
+      if (!commandQueue.isEmpty()) {
+        commandQueue.offer(command);
+        return;
-
-      executeCommand(ctx, command);
-    } catch (Exception e) {
-      logger.warn("Execution of Redis command {} failed: {}", command, e);
-      throw e;
+      if (command.getCommandType().isAsync()) {
+        commandQueue.offer(command);
+        startAsyncCommandExecution(command);
+        return;
+      }
+      executeCommand(command);
-
-  private void executeCommand(ChannelHandlerContext ctx, Command command) {
-    RedisResponse response;
-
-    if (!isAuthenticated()) {
-      response = handleUnAuthenticatedCommand(command);
-      writeToChannel(response);
-      return;
+  private void startAsyncCommandExecution(Command command) {
+    if (logger.isDebugEnabled()) {
+      logger.debug("Starting execution of async Redis command: {}", command);
-
-    if (command.isUnsupported() && !allowUnsupportedCommands()) {
-      writeToChannel(
-          RedisResponse.error(command.getCommandType() + RedisConstants.ERROR_UNSUPPORTED_COMMAND));
-      return;
-    }
-
-    if (command.isUnimplemented()) {
-      logger.info("Failed " + command.getCommandType() + " because it is not implemented.");
-      writeToChannel(RedisResponse.error(command.getCommandType() + " is not implemented."));
-      return;
-    }
-
-    try {
-      response = command.execute(this);
-      logResponse(response);
-      writeToChannel(response);
-    } finally {
-      redisStats.endCommand(command.getCommandType(), start);
-    }
+    command.setAsyncStartTime(start);
+    command.execute(this);
+  }
-    if (command.isOfType(RedisCommandType.QUIT)) {
-      channelInactive(ctx);
+  public void endAsyncCommandExecution(Command command, RedisResponse response) {
+    synchronized (commandQueue) {
+      Command head = takeFromCommandQueue();
+      if (head != command) {
+        throw new IllegalStateException(
+            "expected " + command + " but found " + head + " in the queue");
+      }
+      try {
+        writeToChannel(response);
+      } finally {
+        redisStats.endCommand(command.getCommandType(), command.getAsyncStartTime());
+      }
+      drainCommandQueue();
+    }
+  }
+
+  public void endAsyncCommandExecution(Command command, Throwable exception) {
+    synchronized (commandQueue) {
+      Command head = takeFromCommandQueue();
+      if (head != command) {
+        throw new IllegalStateException(
+            "expected " + command + " but found " + head + " in the queue");
+      }
+      try {
+        exceptionCaught(command.getChannelHandlerContext(), exception);
+      } finally {
+        redisStats.endCommand(command.getCommandType(), command.getAsyncStartTime());
+      }
+      drainCommandQueue();
+    }
+  }
+
+  private Command takeFromCommandQueue() {
+    try {
+      return commandQueue.take();
+    } catch (InterruptedException e) {
+      Thread.interrupted();
+      throw new IllegalStateException("unexpected interrupt");
+    }
+  }
+
+  /**
+   * execute all commands in the queue until an async one is found.
+   * If an async one is found start it.
+   */
+  private void drainCommandQueue() {
+    Command command;
+    while ((command = commandQueue.peek()) != null) {
+      if (command.getCommandType().isAsync()) {
+        startAsyncCommandExecution(command);
+        return;
+      } else {
+        takeFromCommandQueue();
+        try {
+          executeCommand(command);
+        } catch (Throwable ex) {
+          exceptionCaught(command.getChannelHandlerContext(), ex);
+        }
+      }
+    }
+  }
+
+  private void executeCommand(Command command) {
+    RedisResponse response;
+    try {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Executing Redis command: {}", command);
+      }
+
+      if (!isAuthenticated()) {
+        response = handleUnAuthenticatedCommand(command);
+        writeToChannel(response);
+        return;
+      }
+
+      if (command.isUnsupported() && !allowUnsupportedCommands()) {
+        writeToChannel(
+            RedisResponse
+                .error(command.getCommandType() + RedisConstants.ERROR_UNSUPPORTED_COMMAND));
+        return;
+      }
+
+      if (command.isUnimplemented()) {
+        logger.info("Failed " + command.getCommandType() + " because it is not implemented.");
+        writeToChannel(RedisResponse.error(command.getCommandType() + " is not implemented."));
+        return;
+      }
+
+      final long start = redisStats.startCommand(command.getCommandType());
+      try {
+        response = command.execute(this);
+        if (response == null) {
+          return;
+        }
+        logResponse(response);
+        writeToChannel(response);
+      } finally {
+        redisStats.endCommand(command.getCommandType(), start);
+      }
+
+      if (command.isOfType(RedisCommandType.QUIT)) {
+        channelInactive(command.getChannelHandlerContext());
+      }
+    } catch (Exception e) {
+      logger.warn("Execution of Redis command {} failed: {}", command, e);
+      throw e;
-  public EventLoopGroup getSubscriberGroup() {
-    return subscriberGroup;
-  }
-
-  public void changeChannelEventLoopGroup(EventLoopGroup newGroup) {
-    if (newGroup.equals(channel.eventLoop())) {
-      // already registered with newGroup
-      return;
-    }
-    channel.deregister().addListener((ChannelFutureListener) future -> {
-      newGroup.register(channel).sync();
-    });
-  }
-
-
+  public ExecutorService getBackgroundExecutor() {
+    return backgroundExecutor;
+  }

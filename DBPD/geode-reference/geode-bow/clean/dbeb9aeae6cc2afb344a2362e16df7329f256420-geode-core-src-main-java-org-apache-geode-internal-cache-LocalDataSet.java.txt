Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-    return this.proxy.new PREntriesSet(getBucketSet());    
+    return this.proxy.new PREntriesSet(getBucketSet());
-  
+
-  
+
-  public SelectResults query(String queryPredicate)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public SelectResults query(String queryPredicate) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    DefaultQuery query = (DefaultQuery)qs.newQuery("select * from "
-        + getFullPath() + " this where " + queryPredicate);
+    DefaultQuery query = (DefaultQuery) qs
+        .newQuery("select * from " + getFullPath() + " this where " + queryPredicate);
-    return (SelectResults)this.executeQuery(query, params, getBucketSet());
+    return (SelectResults) this.executeQuery(query, params, getBucketSet());
-  public Object selectValue(String queryPredicate)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public Object selectValue(String queryPredicate) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      throw new FunctionDomainException(LocalizedStrings
-          .AbstractRegion_SELECTVALUE_EXPECTS_RESULTS_OF_SIZE_1_BUT_FOUND_RESULTS_OF_SIZE_0
+      throw new FunctionDomainException(
+          LocalizedStrings.AbstractRegion_SELECTVALUE_EXPECTS_RESULTS_OF_SIZE_1_BUT_FOUND_RESULTS_OF_SIZE_0
-   * Asif: This method should not be used for multiple partitioned regions based join queries
-   * We do not support equijoin queries on PartitionedRegions unless they are colocated
-   * and the the colocated columns ACTUALLY EXIST IN WHERE CLAUSE  , AND  IN CASE OF
-   * MULTI COLUMN PARTITIONING , SHOULD HAVE AND CLAUSE.
+   * Asif: This method should not be used for multiple partitioned regions based join queries We do
+   * not support equijoin queries on PartitionedRegions unless they are colocated and the the
+   * colocated columns ACTUALLY EXIST IN WHERE CLAUSE , AND IN CASE OF MULTI COLUMN PARTITIONING ,
+   * SHOULD HAVE AND CLAUSE.
-   *  If not , this method will return wrong results.   We DO NOT DETECT COLOCATION
-   *  CRITERIA IN THE MULTI REGION PR BASED QUERIES. 
+   * If not , this method will return wrong results. We DO NOT DETECT COLOCATION CRITERIA IN THE
+   * MULTI REGION PR BASED QUERIES.
-  public Object executeQuery(DefaultQuery query, Object[] parameters,
-      Set buckets) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public Object executeQuery(DefaultQuery query, Object[] parameters, Set buckets)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    try{
+    try {
-    }
-    finally {
+    } finally {
-    
+
-  
+
-  public void create(Object key, Object value) throws TimeoutException,
-      EntryExistsException, CacheWriterException {
+  public void create(Object key, Object value)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-  public Region createSubregion(String subregionName,
-      RegionAttributes regionAttributes) throws RegionExistsException,
-      TimeoutException {
+  public Region createSubregion(String subregionName, RegionAttributes regionAttributes)
+      throws RegionExistsException, TimeoutException {
-  public Object destroy(Object key) throws TimeoutException,
-      EntryNotFoundException, CacheWriterException {
+  public Object destroy(Object key)
+      throws TimeoutException, EntryNotFoundException, CacheWriterException {
-  public void destroyRegion(Object callbackArgument)
-      throws CacheWriterException, TimeoutException {
+  public void destroyRegion(Object callbackArgument) throws CacheWriterException, TimeoutException {
-  public boolean existsValue(String queryPredicate)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public boolean existsValue(String queryPredicate) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-  public void invalidate(Object key) throws TimeoutException,
-      EntryNotFoundException {
+  public void invalidate(Object key) throws TimeoutException, EntryNotFoundException {
-  public void registerInterest(Object key, boolean isDurable)
-      throws CacheWriterException {
+  public void registerInterest(Object key, boolean isDurable) throws CacheWriterException {
-  public void registerInterest(Object key, InterestResultPolicy policy,
-      boolean isDurable) throws CacheWriterException {
+  public void registerInterest(Object key, InterestResultPolicy policy, boolean isDurable)
+      throws CacheWriterException {
-  public void registerInterestRegex(String regex, boolean isDurable)
-      throws CacheWriterException {
+  public void registerInterestRegex(String regex, boolean isDurable) throws CacheWriterException {
-  public void registerInterestRegex(String regex, InterestResultPolicy policy,
-      boolean isDurable) throws CacheWriterException {
+  public void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable)
+      throws CacheWriterException {
-  public void loadSnapshot(InputStream inputStream) throws IOException,
-      ClassNotFoundException, CacheWriterException, TimeoutException {
+  public void loadSnapshot(InputStream inputStream)
+      throws IOException, ClassNotFoundException, CacheWriterException, TimeoutException {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_THE_FOLLOWING_EXCEPTION_OCCURRED_ATTEMPTING_TO_GET_KEY_0, key), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.LocalRegion_THE_FOLLOWING_EXCEPTION_OCCURRED_ATTEMPTING_TO_GET_KEY_0,
+            key), e);
-  public void localDestroy(Object key, Object callbackArgument)
-      throws EntryNotFoundException {
+  public void localDestroy(Object key, Object callbackArgument) throws EntryNotFoundException {
-  public void localInvalidate(Object key, Object callbackArgument)
-      throws EntryNotFoundException {
+  public void localInvalidate(Object key, Object callbackArgument) throws EntryNotFoundException {
-  public Object put(Object key, Object value) throws TimeoutException,
-      CacheWriterException {
+  public Object put(Object key, Object value) throws TimeoutException, CacheWriterException {
-  
+
-    if(isInDataSet(key, null)) {
+    if (isInDataSet(key, null)) {
-    if(isInDataSet(key, null)) {
+    if (isInDataSet(key, null)) {
-    if(isInDataSet(key, null)) {
+    if (isInDataSet(key, null)) {
-    }
-    else {
+    } else {
-  public void saveSnapshot(OutputStream outputStream) throws IOException {
+  public void saveSnapshot(OutputStream outputStream) throws IOException {}
+
+  public void registerInterest(Object key, boolean isDurable, boolean receiveValues)
+      throws CacheWriterException {
+    throw new UnsupportedOperationException();
+
-  public void registerInterest(Object key, boolean isDurable,
+  public void registerInterest(Object key, InterestResultPolicy policy, boolean isDurable,
-  public void registerInterest(Object key, InterestResultPolicy policy,
-      boolean isDurable, boolean receiveValues) throws CacheWriterException {
+  public void registerInterestRegex(String regex, boolean isDurable, boolean receiveValues)
+      throws CacheWriterException {
-  public void registerInterestRegex(String regex, boolean isDurable,
+  public void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable,
-  public void registerInterestRegex(String regex, InterestResultPolicy policy,
-      boolean isDurable, boolean receiveValues) throws CacheWriterException {
-    throw new UnsupportedOperationException();
-
-  }
-
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see java.util.concurrent.ConcurrentMap#replace(java.lang.Object, java.lang.Object, java.lang.Object)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see java.util.concurrent.ConcurrentMap#replace(java.lang.Object, java.lang.Object,
+   * java.lang.Object)
-  } 
+  }
-  
+
-            while (curBucketIter == null || !(hasNext = curBucketIter.hasNext())) { // Loop all the buckets.
+            while (curBucketIter == null || !(hasNext = curBucketIter.hasNext())) { // Loop all the
+                                                                                    // buckets.
-              BucketRegion br = proxy.getDataStore().getLocalBucketById(
-                curBucketId);
+              BucketRegion br = proxy.getDataStore().getLocalBucketById(curBucketId);
-                throw new BucketMovedException("The Bucket region with id " +
-                  curBucketId + " is moved/destroyed.");
+                throw new BucketMovedException(
+                    "The Bucket region with id " + curBucketId + " is moved/destroyed.");
-            
+
-            if (hasNext){
-              Map.Entry e = (Map.Entry)curBucketIter.next();
+            if (hasNext) {
+              Map.Entry e = (Map.Entry) curBucketIter.next();
-                  if(((NonTXEntry)e).isDestroyed()){
+                  if (((NonTXEntry) e).isDestroyed()) {
-            } 
+            }
-          throw new BucketMovedException("The Bucket region with id " + 
-            curBucketId + " is moved/destroyed.");
+          throw new BucketMovedException(
+              "The Bucket region with id " + curBucketId + " is moved/destroyed.");
-        throw new UnsupportedOperationException(LocalizedStrings
-            .LocalRegion_THIS_ITERATOR_DOES_NOT_SUPPORT_MODIFICATION
-            .toLocalizedString());
+        throw new UnsupportedOperationException(
+            LocalizedStrings.LocalRegion_THIS_ITERATOR_DOES_NOT_SUPPORT_MODIFICATION
+                .toLocalizedString());
-        size+=br.size();
+        size += br.size();
-  
+

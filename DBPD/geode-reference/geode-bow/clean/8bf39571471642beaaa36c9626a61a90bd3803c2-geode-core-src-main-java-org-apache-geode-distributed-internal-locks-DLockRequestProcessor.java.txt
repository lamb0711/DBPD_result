Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Provides handling of remote and local lock requests.
- * <br>
- * A lock client sends a <code>DLockRequestMessage</code> to the lock grantor
- * and then blocks, waiting for the reply.
- * <br>
- * When the lock grantor grants or times out the request, a
- * <code>DLockResponseMessage</code> is finally sent back to the waiting client.
+ * Provides handling of remote and local lock requests. <br>
+ * A lock client sends a <code>DLockRequestMessage</code> to the lock grantor and then blocks,
+ * waiting for the reply. <br>
+ * When the lock grantor grants or times out the request, a <code>DLockResponseMessage</code> is
+ * finally sent back to the waiting client.
-  
+
-  
+
-  
+
-  protected boolean processTimeout(){
-    //if this returns false then no need to log warning/severe msg as Dlock request will have timeout
+  protected boolean processTimeout() {
+    // if this returns false then no need to log warning/severe msg as Dlock request will have
+    // timeout
-  
-//  private volatile boolean doneProcessing = false;
-  
-//  private final long grantorVersion;
-  
+
+  // private volatile boolean doneProcessing = false;
+
+  // private final long grantorVersion;
+
-  
+
-  //   Constructors
+  // Constructors
-  protected DLockRequestProcessor(LockGrantorId lockGrantorId,
-      DLockService svc, 
-      Object objectName,
-      int threadId,
-      long startTime,
-      long leaseMillis,
-      long waitMillis,
-      boolean reentrant,
-      boolean tryLock,
-      DM dm) {
-   this(lockGrantorId, svc, objectName, threadId, startTime, 
-       leaseMillis, waitMillis, reentrant, tryLock, false, dm, false);
-}
-  
-  protected DLockRequestProcessor(LockGrantorId lockGrantorId,
-                                  DLockService svc, 
-                                  Object objectName,
-                                  int threadId,
-                                  long startTime,
-                                  long leaseMillis,
-                                  long waitMillis,
-                                  boolean reentrant,
-                                  boolean tryLock,
-                                  boolean disableAlerts,
-                                  DM dm) {
-    this(lockGrantorId, svc, objectName, threadId, startTime, 
-        leaseMillis, waitMillis, reentrant, tryLock, disableAlerts, dm, false);
+  protected DLockRequestProcessor(LockGrantorId lockGrantorId, DLockService svc, Object objectName,
+      int threadId, long startTime, long leaseMillis, long waitMillis, boolean reentrant,
+      boolean tryLock, DM dm) {
+    this(lockGrantorId, svc, objectName, threadId, startTime, leaseMillis, waitMillis, reentrant,
+        tryLock, false, dm, false);
-  
-  protected DLockRequestProcessor(LockGrantorId lockGrantorId,
-      DLockService svc,
-      Object objectName,
-      int threadId,
-      long startTime,
-      long leaseMillis,
-      long waitMillis,
-      boolean reentrant,
-      boolean tryLock,
-      DM dm,
-      boolean async) {
-    this(lockGrantorId, svc, objectName, threadId, startTime, 
-        leaseMillis, waitMillis, reentrant, tryLock, false, dm, false);
+
+  protected DLockRequestProcessor(LockGrantorId lockGrantorId, DLockService svc, Object objectName,
+      int threadId, long startTime, long leaseMillis, long waitMillis, boolean reentrant,
+      boolean tryLock, boolean disableAlerts, DM dm) {
+    this(lockGrantorId, svc, objectName, threadId, startTime, leaseMillis, waitMillis, reentrant,
+        tryLock, disableAlerts, dm, false);
-  protected DLockRequestProcessor(LockGrantorId lockGrantorId,
-                                  DLockService svc,
-                                  Object objectName,
-                                  int threadId,
-                                  long startTime,
-                                  long leaseMillis,
-                                  long waitMillis,
-                                  boolean reentrant,
-                                  boolean tryLock,
-                                  boolean disableAlerts,
-                                  DM dm,
-                                  boolean async) {
+
+  protected DLockRequestProcessor(LockGrantorId lockGrantorId, DLockService svc, Object objectName,
+      int threadId, long startTime, long leaseMillis, long waitMillis, boolean reentrant,
+      boolean tryLock, DM dm, boolean async) {
+    this(lockGrantorId, svc, objectName, threadId, startTime, leaseMillis, waitMillis, reentrant,
+        tryLock, false, dm, false);
+  }
+
+  protected DLockRequestProcessor(LockGrantorId lockGrantorId, DLockService svc, Object objectName,
+      int threadId, long startTime, long leaseMillis, long waitMillis, boolean reentrant,
+      boolean tryLock, boolean disableAlerts, DM dm, boolean async) {
-    
+
-//    this.grantorVersion = grantorVersion;
+    // this.grantorVersion = grantorVersion;
-    
+
-  
+
-    boolean result = 
-        this.response.responseCode == DLockResponseMessage.DESTROYED;
+    boolean result = this.response.responseCode == DLockResponseMessage.DESTROYED;
-  
+
-    boolean result = 
-        this.response.responseCode == DLockResponseMessage.NOT_HOLDER;
+    boolean result = this.response.responseCode == DLockResponseMessage.NOT_HOLDER;
-  
+
-    boolean result = 
-        this.response.responseCode == DLockResponseMessage.NOT_GRANTOR;
+    boolean result = this.response.responseCode == DLockResponseMessage.NOT_GRANTOR;
-  
+
-  
+
-    boolean result = 
-        this.response.responseCode == DLockResponseMessage.TRY_LOCK_FAILED;
+    boolean result = this.response.responseCode == DLockResponseMessage.TRY_LOCK_FAILED;
-  
+
-    if (this.response == null) return null;
+    if (this.response == null)
+      return null;
-  
-  protected boolean requestLock(boolean interruptible, int lockId)
-  throws InterruptedException {
+
+  protected boolean requestLock(boolean interruptible, int lockId) throws InterruptedException {
-    
+
-    
-//    setDoneProcessing(false);
-    
+
+    // setDoneProcessing(false);
+
-      /*if (svc.isDestroyed()) {
-        return false;
-      }*/
-      //svc.checkDestroyed();
-        
+      /*
+       * if (svc.isDestroyed()) { return false; }
+       */
+      // svc.checkDestroyed();
+
-    
+
-    
+
-      } 
-      catch (ReplyException ex) {
+      } catch (ReplyException ex) {
-          logger.trace(LogMarker.DLS, "DLockRequestProcessor caught ReplyException",ex);
+          logger.trace(LogMarker.DLS, "DLockRequestProcessor caught ReplyException", ex);
-    }
-    else { // not interruptible
+    } else { // not interruptible
-      }
-      catch (ReplyException ex) {
+      } catch (ReplyException ex) {
-          logger.trace(LogMarker.DLS, "DLockRequestProcessor caught ReplyException",ex);
+          logger.trace(LogMarker.DLS, "DLockRequestProcessor caught ReplyException", ex);
-    
+
-      logger.trace(LogMarker.DLS, "DLockRequestProcessor {} for {}", (this.gotLock ? "got lock" : "failed to get lock"), this.request);
+      logger.trace(LogMarker.DLS, "DLockRequestProcessor {} for {}",
+          (this.gotLock ? "got lock" : "failed to get lock"), this.request);
-  
+
-  
-  
-  
-//  private synchronized void setDoneProcessing(boolean value) {
-//    this.doneProcessing = value;
-//  }
-  
+
+
+
+  // private synchronized void setDoneProcessing(boolean value) {
+  // this.doneProcessing = value;
+  // }
+
-  
+
-    if (this.gotLock || this.response == null) return null;
+    if (this.gotLock || this.response == null)
+      return null;
-      Assert.assertTrue(msg instanceof DLockResponseMessage, 
-          "DLockRequestProcessor is unable to process message of type " +
-          msg.getClass());
-      
+      Assert.assertTrue(msg instanceof DLockResponseMessage,
+          "DLockRequestProcessor is unable to process message of type " + msg.getClass());
+
-          logger.trace(LogMarker.DLS, "Failed to find processor for lockId {} processor ids must have wrapped.",
+          logger.trace(LogMarker.DLS,
+              "Failed to find processor for lockId {} processor ids must have wrapped.",
-      
+
-      case DLockResponseMessage.GRANT:
-        /*// If a different version of the lock service requested the lock, we need
-        // to turn around and release it
-        InternalDistributedLockService dls = (InternalDistributedLockService)
-            DistributedLockService.getServiceNamed(reply.serviceName);
-        boolean different = dls == null;
-        different = different || dls.getSerialNumber() != reply.dlsSerialNumber;
-        if (different) {
-          // Back at ya, dude, we don't want this lock!
-          reply.releaseOrphanedGrant(this.dm);
-          this.gotLock = false; // KIRK never set true except in else
-        }
-        else {*/
+        case DLockResponseMessage.GRANT:
+          /*
+           * // If a different version of the lock service requested the lock, we need // to turn
+           * around and release it InternalDistributedLockService dls =
+           * (InternalDistributedLockService)
+           * DistributedLockService.getServiceNamed(reply.serviceName); boolean different = dls ==
+           * null; different = different || dls.getSerialNumber() != reply.dlsSerialNumber; if
+           * (different) { // Back at ya, dude, we don't want this lock!
+           * reply.releaseOrphanedGrant(this.dm); this.gotLock = false; // KIRK never set true
+           * except in else } else {
+           */
-            logger.trace(LogMarker.DLS, "{} has granted lock for {} in {}", reply.getSender(), reply.objectName, reply.serviceName);
+            logger.trace(LogMarker.DLS, "{} has granted lock for {} in {}", reply.getSender(),
+                reply.objectName, reply.serviceName);
-        //}
-        break;
-      case DLockResponseMessage.NOT_GRANTOR:
-        // target was not the grantor!  who is the grantor?!
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.NOT_GRANTOR for {}", reply.getSender(), reply.serviceName);
-        }
-        break;
-      case DLockResponseMessage.DESTROYED:
-        // grantor claims we sent him a NonGrantorDestroyedMessage
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.DESTROYED for {}", reply.getSender(), reply.serviceName);
-        }
-        break;
-      case DLockResponseMessage.TIMEOUT:
-        // grantor told us the lock request has timed out...
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.TIMEOUT for {} in {}", reply.getSender(), reply.objectName, reply.serviceName);
-        }
-        break;
-      case DLockResponseMessage.SUSPENDED:
-        // grantor told us that locking has been suspended for the service...
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.SUSPENDED for {} in {}", reply.getSender(), reply.objectName, reply.serviceName);
-        }
-        break;
-      case DLockResponseMessage.NOT_HOLDER:
-        // tried to reenter lock but grantor says we're not the lock holder...
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.NOT_HOLDER for {} in {}", reply.getSender(), reply.objectName, reply.serviceName);
-        }
-        break;
-      case DLockResponseMessage.TRY_LOCK_FAILED:
-        // tried to acquire try-lock but grantor says it's held and we failed...
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.TRY_LOCK_FAILED for {} in {}", reply.getSender(), reply.objectName, reply.serviceName);
-        }
-        break;
-      default:
-          throw new InternalGemFireError(LocalizedStrings.DLockRequestProcessor_UNKNOWN_RESPONSE_CODE_0.toLocalizedString(Integer.valueOf(reply.responseCode)));
+          // }
+          break;
+        case DLockResponseMessage.NOT_GRANTOR:
+          // target was not the grantor! who is the grantor?!
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.NOT_GRANTOR for {}",
+                reply.getSender(), reply.serviceName);
+          }
+          break;
+        case DLockResponseMessage.DESTROYED:
+          // grantor claims we sent him a NonGrantorDestroyedMessage
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS, "{} has responded DLockResponseMessage.DESTROYED for {}",
+                reply.getSender(), reply.serviceName);
+          }
+          break;
+        case DLockResponseMessage.TIMEOUT:
+          // grantor told us the lock request has timed out...
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS,
+                "{} has responded DLockResponseMessage.TIMEOUT for {} in {}", reply.getSender(),
+                reply.objectName, reply.serviceName);
+          }
+          break;
+        case DLockResponseMessage.SUSPENDED:
+          // grantor told us that locking has been suspended for the service...
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS,
+                "{} has responded DLockResponseMessage.SUSPENDED for {} in {}", reply.getSender(),
+                reply.objectName, reply.serviceName);
+          }
+          break;
+        case DLockResponseMessage.NOT_HOLDER:
+          // tried to reenter lock but grantor says we're not the lock holder...
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS,
+                "{} has responded DLockResponseMessage.NOT_HOLDER for {} in {}", reply.getSender(),
+                reply.objectName, reply.serviceName);
+          }
+          break;
+        case DLockResponseMessage.TRY_LOCK_FAILED:
+          // tried to acquire try-lock but grantor says it's held and we failed...
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS,
+                "{} has responded DLockResponseMessage.TRY_LOCK_FAILED for {} in {}",
+                reply.getSender(), reply.objectName, reply.serviceName);
+          }
+          break;
+        default:
+          throw new InternalGemFireError(
+              LocalizedStrings.DLockRequestProcessor_UNKNOWN_RESPONSE_CODE_0
+                  .toLocalizedString(Integer.valueOf(reply.responseCode)));
-        
-    }
-    finally {
+
+    } finally {
-      ((DLockResponseMessage)msg).processed = true;
-//      setDoneProcessing(true);
+      ((DLockResponseMessage) msg).processed = true;
+      // setDoneProcessing(true);
-  
+
-   * LockGrantorDestroyedException or LockServiceDestroyedException is an 
-   * anticipated reply exception.  Receiving multiple replies with this 
-   * exception is normal.
+   * LockGrantorDestroyedException or LockServiceDestroyedException is an anticipated reply
+   * exception. Receiving multiple replies with this exception is normal.
-  //   DLockRequestMessage
+  // DLockRequestMessage
-  public static class DLockRequestMessage
-  extends HighPriorityDistributionMessage
-  implements MessageWithReply {
+  public static class DLockRequestMessage extends HighPriorityDistributionMessage
+      implements MessageWithReply {
-     * The id of the DLockRequestProcessor on the
-     * initiator node.  This will be communicated back in the response
-     * to enable collation of the results.
+     * The id of the DLockRequestProcessor on the initiator node. This will be communicated back in
+     * the response to enable collation of the results.
-    protected long leaseMillis;    
+    protected long leaseMillis;
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-  
+
-    
+
-    
+
-    
+
-    
+
+
+
+
+
+
+
+
+
+
+
-    
+
-//    void setReceivingDM(DM dm) {
-//      this.receivingDM = dm;
-//      
-//      this.response = createResponse();
-//      this.response.setProcessorId(getProcessorId());
-//      this.response.setRecipient(getSender());
-//      this.response.serviceName = this.serviceName;
-//      this.response.objectName = this.objectName;
-//    }
+    // void setReceivingDM(DM dm) {
+    // this.receivingDM = dm;
+    //
+    // this.response = createResponse();
+    // this.response.setProcessorId(getProcessorId());
+    // this.response.setRecipient(getSender());
+    // this.response.serviceName = this.serviceName;
+    // this.response.objectName = this.objectName;
+    // }
-        if (this.svc == null) { 
+        if (this.svc == null) {
-        }
-        else {
+        } else {
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-      }
-      catch (VirtualMachineError e) {
+      } catch (VirtualMachineError e) {
-      }
-      catch (Error e) {
+      } catch (Error e) {
-      }
-      finally {
+      } finally {
-    
+
-    
-    /** 
-     * Execute basicProcess inside Pooled Executor because grantor may not 
-     * be initializing which will require us to wait.
+
+    /**
+     * Execute basicProcess inside Pooled Executor because grantor may not be initializing which
+     * will require us to wait.
-    
+
-      
+
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-        
+
-            logger.trace(LogMarker.DLS, "respondWithNotGrantor this.svc={} this.grantor={}", this.svc, this.grantor);
+            logger.trace(LogMarker.DLS, "respondWithNotGrantor this.svc={} this.grantor={}",
+                this.svc, this.grantor);
-      
+
-            logger.trace(LogMarker.DLS, "respondWithNotGrantor grantor was destroyed {}", this.grantor);
+            logger.trace(LogMarker.DLS, "respondWithNotGrantor grantor was destroyed {}",
+                this.grantor);
-        }
-        else if (this.grantor.getVersionId() != this.grantorVersion) {
+        } else if (this.grantor.getVersionId() != this.grantorVersion) {
-            logger.trace(LogMarker.DLS, "respondWithNotGrantor current version is {}; request was for {}", this.grantor.getVersionId(), this.grantorVersion);
+            logger.trace(LogMarker.DLS,
+                "respondWithNotGrantor current version is {}; request was for {}",
+                this.grantor.getVersionId(), this.grantorVersion);
-        }
-        else if (this.svc.getSerialNumber() != this.grantorSerialNumber) {
+        } else if (this.svc.getSerialNumber() != this.grantorSerialNumber) {
-            logger.trace(LogMarker.DLS, "respondWithNotGrantor current serial number is {}; request was for {}", this.svc.getSerialNumber(), this.grantorSerialNumber);
+            logger.trace(LogMarker.DLS,
+                "respondWithNotGrantor current serial number is {}; request was for {}",
+                this.svc.getSerialNumber(), this.grantorSerialNumber);
-      
+
-              logger.trace(LogMarker.DLS, "respondWithNotGrantor service !isLockGrantor svc={}", this.svc);
+              logger.trace(LogMarker.DLS, "respondWithNotGrantor service !isLockGrantor svc={}",
+                  this.svc);
-          
+
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
-                
+
-                logger.trace(LogMarker.DLS, "respondWithNotGrantor grantor was destroyed grantor={}", this.grantor);
+                logger.trace(LogMarker.DLS,
+                    "respondWithNotGrantor grantor was destroyed grantor={}", this.grantor);
-            }
-            else {
+            } else {
-              }
-              catch (InterruptedException e) {
+              } catch (InterruptedException e) {
-              }
-              catch (LockGrantorDestroyedException e) {
+              } catch (LockGrantorDestroyedException e) {
-      }
-      catch (LockGrantorDestroyedException e) {
+      } catch (LockGrantorDestroyedException e) {
-          logger.trace(LogMarker.DLS, "LockGrantorDestroyedException respondWithNotGrantor svc={}", this.svc);
+          logger.trace(LogMarker.DLS, "LockGrantorDestroyedException respondWithNotGrantor svc={}",
+              this.svc);
-      }
-      catch (LockServiceDestroyedException e) {
+      } catch (LockServiceDestroyedException e) {
-          logger.trace(LogMarker.DLS, "LockServiceDestroyedException respondWithNotGrantor svc={}", this.svc);
+          logger.trace(LogMarker.DLS, "LockServiceDestroyedException respondWithNotGrantor svc={}",
+              this.svc);
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-          logger.trace(LogMarker.DLS, "CacheClosedException respondWithNotGrantor svc={} exception = {}", this.svc, e);
+          logger.trace(LogMarker.DLS,
+              "CacheClosedException respondWithNotGrantor svc={} exception = {}", this.svc, e);
-        }
-        else {
+        } else {
-      }
-      catch (RuntimeException e) {
-        logger.warn(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_DLOCKREQUESTMESSAGEPROCESS_CAUGHT_THROWABLE), e);
+      } catch (RuntimeException e) {
+        logger.warn(LogMarker.DLS,
+            LocalizedMessage.create(
+                LocalizedStrings.DLockRequestProcessor_DLOCKREQUESTMESSAGEPROCESS_CAUGHT_THROWABLE),
+            e);
-//      catch (VirtualMachineError err) {
-//        SystemFailure.initiateFailure(err);
-//        // If this ever returns, rethrow the error.  We're poisoned
-//        // now, so don't let this thread continue.
-//        throw err;
-//      }
-//      catch (Throwable t) {
-//        // Whenever you catch Error or Throwable, you must also
-//        // catch VirtualMachineError (see above).  However, there is
-//        // _still_ a possibility that you are dealing with a cascading
-//        // error condition, so you also need to check to see if the JVM
-//        // is still usable:
-//        SystemFailure.checkFailure();
-//        respondWithException(t);
-//      }
+      // catch (VirtualMachineError err) {
+      // SystemFailure.initiateFailure(err);
+      // // If this ever returns, rethrow the error. We're poisoned
+      // // now, so don't let this thread continue.
+      // throw err;
+      // }
+      // catch (Throwable t) {
+      // // Whenever you catch Error or Throwable, you must also
+      // // catch VirtualMachineError (see above). However, there is
+      // // _still_ a possibility that you are dealing with a cascading
+      // // error condition, so you also need to check to see if the JVM
+      // // is still usable:
+      // SystemFailure.checkFailure();
+      // respondWithException(t);
+      // }
-        
+
-    
+
-    
+
-        logger.trace(LogMarker.DLS, "Request {} timed out; grantor status = {}", this, this.grantor.displayStatus(rThread, objectName));
+        logger.trace(LogMarker.DLS, "Request {} timed out; grantor status = {}", this,
+            this.grantor.displayStatus(rThread, objectName));
-    
+
-    
+
-    
+
-            logger.trace(LogMarker.DLS, "While processing <{}>, got exception, returning to sender", this, this.response.getException());
+            logger.trace(LogMarker.DLS, "While processing <{}>, got exception, returning to sender",
+                this, this.response.getException());
+        } else {
+          logger.warn(LogMarker.DLS,
+              LocalizedMessage.create(
+                  LocalizedStrings.DLockRequestProcessor_MORE_THAN_ONE_EXCEPTION_THROWN_IN__0,
+                  this),
+              t);
-        else {
-          logger.warn(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_MORE_THAN_ONE_EXCEPTION_THROWN_IN__0, this), t);
-        }
-      }
-      finally {
+      } finally {
-     * Return the timestamp at which this request should timeout.
-     * If it should never timeout then returns Long.MAX_VALUE.
+     * Return the timestamp at which this request should timeout. If it should never timeout then
+     * returns Long.MAX_VALUE.
-    
+
-      if (this.waitMillis == -1 || this.waitMillis == Long.MAX_VALUE) return false;
-      if (this.tryLock) return false;
+      if (this.waitMillis == -1 || this.waitMillis == Long.MAX_VALUE)
+        return false;
+      if (this.tryLock)
+        return false;
-      if (now < this.startTime) now = this.startTime;
+      if (now < this.startTime)
+        now = this.startTime;
-          logger.trace(LogMarker.DLS, "DLockRequestProcessor request timed out: waitMillis={} now={} startTime={}", this.waitMillis, now, this.startTime);
+          logger.trace(LogMarker.DLS,
+              "DLockRequestProcessor request timed out: waitMillis={} now={} startTime={}",
+              this.waitMillis, now, this.startTime);
-    
+
-      if (this.statStart == -1) return; // failed to start the stat
+      if (this.statStart == -1)
+        return; // failed to start the stat
-        case DLockResponseMessage.GRANT: 
-          stats.endGrantWait(this.statStart); break;
-        case DLockResponseMessage.NOT_GRANTOR: 
-          stats.endGrantWaitNotGrantor(this.statStart); break;
-        case DLockResponseMessage.TIMEOUT: 
-          stats.endGrantWaitTimeout(this.statStart); break;
-        case DLockResponseMessage.SUSPENDED: 
-          stats.endGrantWaitSuspended(this.statStart); break;
-        case DLockResponseMessage.NOT_HOLDER: 
-          stats.endGrantWaitNotHolder(this.statStart); break;
-        case DLockResponseMessage.TRY_LOCK_FAILED: 
-          stats.endGrantWaitFailed(this.statStart); break;
-        case DLockResponseMessage.DESTROYED: 
-          stats.endGrantWaitDestroyed(this.statStart); break;
-        default: 
-          Assert.assertTrue(false,
-              "Unknown responseCode: " + this.response.responseCode); break;
+        case DLockResponseMessage.GRANT:
+          stats.endGrantWait(this.statStart);
+          break;
+        case DLockResponseMessage.NOT_GRANTOR:
+          stats.endGrantWaitNotGrantor(this.statStart);
+          break;
+        case DLockResponseMessage.TIMEOUT:
+          stats.endGrantWaitTimeout(this.statStart);
+          break;
+        case DLockResponseMessage.SUSPENDED:
+          stats.endGrantWaitSuspended(this.statStart);
+          break;
+        case DLockResponseMessage.NOT_HOLDER:
+          stats.endGrantWaitNotHolder(this.statStart);
+          break;
+        case DLockResponseMessage.TRY_LOCK_FAILED:
+          stats.endGrantWaitFailed(this.statStart);
+          break;
+        case DLockResponseMessage.DESTROYED:
+          stats.endGrantWaitDestroyed(this.statStart);
+          break;
+        default:
+          Assert.assertTrue(false, "Unknown responseCode: " + this.response.responseCode);
+          break;
-    
+
-        if (this.responded) return;
+        if (this.responded)
+          return;
-        
+
-            logger.warn(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_FAILED_TO_FIND_PROCESSOR_FOR__0, this.response));
+            logger.warn(LogMarker.DLS,
+                LocalizedMessage.create(
+                    LocalizedStrings.DLockRequestProcessor_FAILED_TO_FIND_PROCESSOR_FOR__0,
+                    this.response));
-              logger.info(LogMarker.DLS, LocalizedMessage.create(
-                  LocalizedStrings.DLockRequestProcessor_RELEASING_LOCAL_ORPHANED_GRANT_FOR_0, this));
+              logger.info(LogMarker.DLS,
+                  LocalizedMessage.create(
+                      LocalizedStrings.DLockRequestProcessor_RELEASING_LOCAL_ORPHANED_GRANT_FOR_0,
+                      this));
-              }
-              catch (InterruptedException e) {
+              } catch (InterruptedException e) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.DLockRequestProcess_INTERRUPTED_WHILE_RELEASING_GRANT), e);
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.DLockRequestProcess_INTERRUPTED_WHILE_RELEASING_GRANT), e);
-              logger.info(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_HANDLED_LOCAL_ORPHANED_GRANT));
+              logger.info(LocalizedMessage
+                  .create(LocalizedStrings.DLockRequestProcessor_HANDLED_LOCAL_ORPHANED_GRANT));
-        
+
-      }
-      finally {
+      } finally {
-    
+
-      }
-      finally {
+      } finally {
-    
+
-    
+
-    
+
-    
+
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      
+
-      sb.append(" for " +  this.serviceName + ":" + this.dlsSerialNumber);
+      sb.append(" for " + this.serviceName + ":" + this.dlsSerialNumber);
-  //   DLockResponseMessage
+  // DLockResponseMessage
-   * This is a response to an DLockRequestMessage.  A response communicates
-   * one of two things:
-   *  - GRANT - you can have the lock
-   *  - NOT_GRANTOR - I am not the lock grantor for this service
-   *  - TIMEOUT - the lock request has timed out
+   * This is a response to an DLockRequestMessage. A response communicates one of two things: -
+   * GRANT - you can have the lock - NOT_GRANTOR - I am not the lock grantor for this service -
+   * TIMEOUT - the lock request has timed out
-  
+
-    
-    /** Specifies the results of this response  */
+
+    /** Specifies the results of this response */
-    
+
-    
+
-    
+
-    
+
-    
+
-     * Need to handle race condition in which this side times out waiting for
-     * the lock before receiving a GRANT response which may already be in
-     * transit to this node.
+     * Need to handle race condition in which this side times out waiting for the lock before
+     * receiving a GRANT response which may already be in transit to this node.
-      if(processor==null) {
+      if (processor == null) {
-      
-      
-      //TODO - This a partial fix for bug 37158. It doesn't completely
-      //eliminate the race condition when interrupting a lock request, but
-      //it does make DistributedLockServiceTest continue to pass.
-      if(keeper.retrieve(processor.getProcessorId()) != null) {
+
+
+      // TODO - This a partial fix for bug 37158. It doesn't completely
+      // eliminate the race condition when interrupting a lock request, but
+      // it does make DistributedLockServiceTest continue to pass.
+      if (keeper.retrieve(processor.getProcessorId()) != null) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_NO_PROCESSOR_FOUND_FOR_DLOCKRESPONSEMESSAGE__0, this));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.DLockRequestProcessor_NO_PROCESSOR_FOUND_FOR_DLOCKRESPONSEMESSAGE__0,
+              this));
-        }
-        else {
-          logger.info(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_NO_PROCESSOR_FOUND_FOR_DLOCKRESPONSEMESSAGE__0, this));
+        } else {
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.DLockRequestProcessor_NO_PROCESSOR_FOUND_FOR_DLOCKRESPONSEMESSAGE__0,
+              this));
-    protected boolean callReleaseProcessor(DM dm,
-        InternalDistributedMember grantor) {
-      return DLockService.callReleaseProcessor(dm, this.serviceName, grantor,
-          this.objectName, false, this.lockId);
+    protected boolean callReleaseProcessor(DM dm, InternalDistributedMember grantor) {
+      return DLockService.callReleaseProcessor(dm, this.serviceName, grantor, this.objectName,
+          false, this.lockId);
-    /** 
-     * Releases a granted lock that was orphaned by interruption of the lock 
-     * request. This also releases any lock grant for which we cannot find an
-     * active reply processor.
+    /**
+     * Releases a granted lock that was orphaned by interruption of the lock request. This also
+     * releases any lock grant for which we cannot find an active reply processor.
-      logger.info(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_RELEASING_ORPHANED_GRANT_FOR__0, this));
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.DLockRequestProcessor_RELEASING_ORPHANED_GRANT_FOR__0, this));
-              GrantorInfo gi = DLockService.checkLockGrantorInfo(
-                  this.serviceName, dm.getSystem());
+              GrantorInfo gi = DLockService.checkLockGrantorInfo(this.serviceName, dm.getSystem());
-            }
-            else {
+            } else {
-          }
-          catch (LockGrantorDestroyedException e) {
+          } catch (LockGrantorDestroyedException e) {
-          }
-          catch (IllegalStateException e) {
+          } catch (IllegalStateException e) {
-                logger.debug("[releaseOrphanedGrant] Local grantor threw IllegalStateException handling {}", this); 
+                logger.debug(
+                    "[releaseOrphanedGrant] Local grantor threw IllegalStateException handling {}",
+                    this);
-            }
-            catch (InterruptedException ie) {
+            } catch (InterruptedException ie) {
-          }
-          finally {
+          } finally {
-      }
-      finally {
+      } finally {
-          logger.info(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_HANDLED_ORPHANED_GRANT_WITH_RELEASE));
+          logger.info(LocalizedMessage
+              .create(LocalizedStrings.DLockRequestProcessor_HANDLED_ORPHANED_GRANT_WITH_RELEASE));
-          logger.info(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_HANDLED_ORPHANED_GRANT_WITHOUT_RELEASE));
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.DLockRequestProcessor_HANDLED_ORPHANED_GRANT_WITHOUT_RELEASE));
-  
+
-        case GRANT:       response = "GRANT"; break;
-        case NOT_GRANTOR: response = "NOT_GRANTOR"; break;
-        case TIMEOUT:     response = "TIMEOUT"; break;
-        case SUSPENDED:   response = "SUSPENDED"; break;
-        case NOT_HOLDER:  response = "NOT_HOLDER"; break;
-        case TRY_LOCK_FAILED:  response = "TRY_LOCK_FAILED"; break;
-        case DESTROYED:  response = "DESTROYED"; break;
-        default: response = "UNKNOWN:" + String.valueOf(responseCode); break;
+        case GRANT:
+          response = "GRANT";
+          break;
+        case NOT_GRANTOR:
+          response = "NOT_GRANTOR";
+          break;
+        case TIMEOUT:
+          response = "TIMEOUT";
+          break;
+        case SUSPENDED:
+          response = "SUSPENDED";
+          break;
+        case NOT_HOLDER:
+          response = "NOT_HOLDER";
+          break;
+        case TRY_LOCK_FAILED:
+          response = "TRY_LOCK_FAILED";
+          break;
+        case DESTROYED:
+          response = "DESTROYED";
+          break;
+        default:
+          response = "UNKNOWN:" + String.valueOf(responseCode);
+          break;
-    
+
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      return "DLockRequestProcessor.DLockResponseMessage " +
-             "responding " + response + 
-             "; serviceName=" + serviceName + "(version " + dlsSerialNumber + ")" +
-             "; objectName=" + objectName + 
-             "; responseCode=" + responseCode + 
-             "; keyIfFailed=" + keyIfFailed +
-             "; leaseExpireTime=" + leaseExpireTime + 
-             "; processorId=" + this.processorId +
-             "; lockId=" + this.lockId;
+      return "DLockRequestProcessor.DLockResponseMessage " + "responding " + response
+          + "; serviceName=" + serviceName + "(version " + dlsSerialNumber + ")" + "; objectName="
+          + objectName + "; responseCode=" + responseCode + "; keyIfFailed=" + keyIfFailed
+          + "; leaseExpireTime=" + leaseExpireTime + "; processorId=" + this.processorId
+          + "; lockId=" + this.lockId;
-  
+
-  
+
+
+
-    synchronized(waitToProcessDLockResponseLock) {
+    synchronized (waitToProcessDLockResponseLock) {
+
-    synchronized(waitToProcessDLockResponseLock) {
+    synchronized (waitToProcessDLockResponseLock) {
-            logger.info(LocalizedMessage.create(LocalizedStrings.DLockRequestProcessor_WAITING_TO_PROCESS_DLOCKRESPONSEMESSAGE)); 
-            waitToProcessDLockResponseLock.wait();
-        }
-        catch (InterruptedException e) {
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.DLockRequestProcessor_WAITING_TO_PROCESS_DLOCKRESPONSEMESSAGE));
+          waitToProcessDLockResponseLock.wait();
+        } catch (InterruptedException e) {
-        }
-        finally {
-          if (interrupted) Thread.currentThread().interrupt();
+        } finally {
+          if (interrupted)
+            Thread.currentThread().interrupt();
-    
+

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+
-      
+
-        //Remote command means implemented for Gfsh and ParseResult should be GfshParseResult.
-        //TODO: should this message be more specific?
+        // Remote command means implemented for Gfsh and ParseResult should be GfshParseResult.
+        // TODO: should this message be more specific?
-      
+
-      
+
-      
+
-            interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest().forName(interceptorClass).newInstance();
+            interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest()
+                .forName(interceptorClass).newInstance();
-            } else if (preExecResult instanceof FileResult) {            
+            } else if (preExecResult instanceof FileResult) {
-              byte[][]fileData = fileResult.toBytes();
+              byte[][] fileData = fileResult.toBytes();
-            return ResultBuilder.createBadConfigurationErrorResult("Interceptor Configuration Error");
+            return ResultBuilder
+                .createBadConfigurationErrorResult("Interceptor Configuration Error");
-        
+
-        
-        //Do the locking and annotation check only if the shared configuration service is enabled 
-        //Else go the usual route of command execution
-        if (gfc.getDistributionManager().isSharedConfigurationServiceEnabledForDS() && 
-            (writesToSharedConfiguration(method) || readsFromSharedConfiguration(method))) {
-          DistributedLockService dls = SharedConfiguration.getSharedConfigLockService(InternalDistributedSystem.getAnyInstance());
+
+        // Do the locking and annotation check only if the shared configuration service is enabled
+        // Else go the usual route of command execution
+        if (gfc.getDistributionManager().isSharedConfigurationServiceEnabledForDS()
+            && (writesToSharedConfiguration(method) || readsFromSharedConfiguration(method))) {
+          DistributedLockService dls = SharedConfiguration
+              .getSharedConfigLockService(InternalDistributedSystem.getAnyInstance());
-              result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(), gfshParseResult.getInstance(), gfshParseResult.getArguments());
+              result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(),
+                  gfshParseResult.getInstance(), gfshParseResult.getArguments());
-            return ResultBuilder.createGemFireErrorResult("Unable to execute the command due to ongoing configuration change/member startup.");
+            return ResultBuilder.createGemFireErrorResult(
+                "Unable to execute the command due to ongoing configuration change/member startup.");
-          result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(), gfshParseResult.getInstance(), gfshParseResult.getArguments());
+          result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(),
+              gfshParseResult.getInstance(), gfshParseResult.getArguments());
-        
-        
+
+
-          logWrapper.info("Error occurred while executing \""+gfshParseResult.getUserInput()+"\".");
+          logWrapper
+              .info("Error occurred while executing \"" + gfshParseResult.getUserInput() + "\".");
-        
+
-            "Only Remote command can be executed through "
-                + ManagementService.class.getSimpleName()
-                + ".processCommand() or ManagementMBean's processCommand " 
-                + "operation. Please refer documentation for the list of " 
-                + "commands.");
+            "Only Remote command can be executed through " + ManagementService.class.getSimpleName()
+                + ".processCommand() or ManagementMBean's processCommand "
+                + "operation. Please refer documentation for the list of " + "commands.");
-    } catch(RuntimeException e) {
+    } catch (RuntimeException e) {
-  
-  private boolean writesToSharedConfiguration (Method method) {
+
+  private boolean writesToSharedConfiguration(Method method) {
-  
-  private boolean readsFromSharedConfiguration (Method method) {
+
+  private boolean readsFromSharedConfiguration(Method method) {
-  
+
-  public void terminate() {
-  }
+  public void terminate() {}

Merge branch 'release/1.4.0'

-import org.apache.geode.internal.cache.lru.LRUEntry;
-import org.apache.geode.internal.cache.lru.NewLRUClockHand;
+import org.apache.geode.internal.cache.entries.DiskEntry;
+import org.apache.geode.internal.cache.eviction.EvictableEntry;
+import org.apache.geode.internal.cache.eviction.EvictionList;
- * 
+ *
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-      boolean wasRecovered, boolean deferLRUCallback, VersionTag version,
+      boolean wasRecovered, boolean deferLRUCallback, VersionTag entryVersion,
+  @Override
+  @Override
-      boolean forceCallback) throws EntryNotFoundException {
+      boolean forceCallbacks) throws EntryNotFoundException {
+  @Override
+  @Override
+  @Override
+  @Override
-  public void txApplyDestroy(Object key, TransactionId txId, TXRmtEvent txEvent,
+  @Override
+  public void txApplyDestroy(Object key, TransactionId rmtOrigin, TXRmtEvent event,
-      ClientProxyMembershipID bridgeContext, boolean isOriginRemote, TXEntryState txEntryState,
+      ClientProxyMembershipID bridgeContext, boolean isOperationRemote, TXEntryState txEntryState,
-      if (txEvent != null) {
-        txEvent.addDestroy(this.owner, markerEntry, key, aCallbackArgument);
+      if (event != null) {
+        event.addDestroy(this.owner, markerEntry, key, aCallbackArgument);
-        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner, op, key, null, txId, txEvent,
-            eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag,
-            tailKey);
+        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner, op, key, null, rmtOrigin,
+            event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
+            versionTag, tailKey);
-  public void txApplyInvalidate(Object key, Object newValue, boolean didDestroy, TransactionId txId,
-      TXRmtEvent txEvent, boolean localOp, EventID eventId, Object aCallbackArgument,
-      List<EntryEventImpl> pendingCallbacks, FilterRoutingInfo filterRoutingInfo,
-      ClientProxyMembershipID bridgeContext, TXEntryState txEntryState, VersionTag versionTag,
-      long tailKey) {
+  @Override
+  public void txApplyInvalidate(Object key, Object newValue, boolean didDestroy,
+      TransactionId rmtOrigin, TXRmtEvent event, boolean localOp, EventID eventId,
+      Object aCallbackArgument, List<EntryEventImpl> pendingCallbacks,
+      FilterRoutingInfo filterRoutingInfo, ClientProxyMembershipID bridgeContext,
+      TXEntryState txEntryState, VersionTag versionTag, long tailKey) {
-      if (txEvent != null) {
-        txEvent.addInvalidate(this.owner, markerEntry, key, newValue, aCallbackArgument);
+      if (event != null) {
+        event.addInvalidate(this.owner, markerEntry, key, newValue, aCallbackArgument);
-            localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE, key, newValue, txId,
-            txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
+            localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE, key, newValue, rmtOrigin,
+            event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
-  public void txApplyPut(Operation p_putOp, Object key, Object newValue, boolean didDestroy,
-      TransactionId txId, TXRmtEvent txEvent, EventID eventId, Object aCallbackArgument,
+  @Override
+  public void txApplyPut(Operation putOp, Object key, Object newValue, boolean didDestroy,
+      TransactionId rmtOrigin, TXRmtEvent event, EventID eventId, Object aCallbackArgument,
-    Operation putOp = p_putOp.getCorrespondingCreateOp();
+    Operation putOperation = putOp.getCorrespondingCreateOp();
-    this.owner.txApplyPutPart2(markerEntry, key, lastMod, true, didDestroy,
-        false /* Clear conflict occurred */);
+    this.owner.txApplyPutPart2(markerEntry, key, lastMod, true, didDestroy, false);
-      if (txEvent != null) {
-        txEvent.addPut(putOp, this.owner, markerEntry, key, newValue, aCallbackArgument);
+      if (event != null) {
+        event.addPut(putOperation, this.owner, markerEntry, key, newValue, aCallbackArgument);
-        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner, putOp, key, newValue, txId,
-            txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
-            versionTag, tailKey);
+        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner, putOperation, key, newValue,
+            rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+            txEntryState, versionTag, tailKey);
+  @Override
+  @Override
+  @Override
-  public boolean lruLimitExceeded(DiskRegionView drv) {
+  public boolean lruLimitExceeded(DiskRegionView diskRegionView) {
+  @Override
+  @Override
-  public void removeEntry(Object key, RegionEntry entry, boolean updateStats) {
+  @Override
+  public void removeEntry(Object key, RegionEntry value, boolean updateStats) {
+  @Override
-      LocalRegion owner) {
+      InternalRegion owner) {
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
-        LocalRegion region, EntryEventImpl event) {
+        InternalRegion region, EntryEventImpl event) {
-    public void makeTombstone(LocalRegion r, VersionTag isOperationRemote) {
+    @Override
+    public void makeTombstone(InternalRegion region, VersionTag version) {
+    @Override
-    public void setRecentlyUsed() {
+    @Override
+    public void setRecentlyUsed(RegionEntryContext context) {
+    @Override
-    public void txDidDestroy(long currTime) {
+    @Override
+    public void txDidDestroy(long currentTime) {
+    @Override
-    public void removePhase1(LocalRegion r, boolean isClear) {
+    @Override
+    public void removePhase1(InternalRegion region, boolean clear) {
+    @Override
+    @Override
+    @Override
-    public boolean fillInValue(LocalRegion r, Entry entry, ByteArrayDataInput in, DM mgr,
-        final Version version) {
+    @Override
+    public boolean fillInValue(InternalRegion region, Entry entry, ByteArrayDataInput in,
+        DM distributionManager, final Version version) {
-    public boolean isOverflowedToDisk(LocalRegion r, DistributedRegion.DiskPosition dp) {
+    @Override
+    public boolean isOverflowedToDisk(InternalRegion region,
+        DistributedRegion.DiskPosition diskPosition) {
+    @Override
+    @Override
+    @Override
-    public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate) {
+    public Object prepareValueForCache(RegionEntryContext context, Object value,
+        boolean isEntryUpdate) {
-    // @Override
-    // public void _setValue(Object value) {
-    // throw new
-    // UnsupportedOperationException(LocalizedStrings.ProxyRegionMap_NO_ENTRY_SUPPORT_ON_REGIONS_WITH_DATAPOLICY_0.toLocalizedString(DataPolicy.EMPTY));
-    // }
-
-    public Object _getValue() {
+    public Object getValue() {
-    public Object _getValueRetain(RegionEntryContext context, boolean decompress) {
+    public Object getValueRetain(RegionEntryContext context, boolean decompress) {
-    public Object getValueOnDisk(LocalRegion r) throws EntryNotFoundException {
+    @Override
+    public Object getValueOnDisk(InternalRegion region) throws EntryNotFoundException {
-    public Object getValueOnDiskOrBuffer(LocalRegion r) throws EntryNotFoundException {
+    @Override
+    public Object getValueOnDiskOrBuffer(InternalRegion region) throws EntryNotFoundException {
-    public Object getSerializedValueOnDisk(LocalRegion localRegion) {
+    @Override
+    public Object getSerializedValueOnDisk(InternalRegion region) {
-    public boolean initialImagePut(LocalRegion region, long lastModified, Object newValue,
-        boolean wasRecovered, boolean versionTagAccepted) {
+    @Override
+    public boolean initialImagePut(InternalRegion region, long lastModified, Object newValue,
+        boolean wasRecovered, boolean acceptedVersionTag) {
-    public boolean initialImageInit(LocalRegion region, long lastModified, Object newValue,
-        boolean create, boolean wasRecovered, boolean versionTagAccepted) {
+    @Override
+    public boolean initialImageInit(InternalRegion region, long lastModified, Object newValue,
+        boolean create, boolean wasRecovered, boolean acceptedVersionTag) {
-    public boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
+    @Override
+    public boolean destroy(InternalRegion region, EntryEventImpl event, boolean inTokenMode,
+    @Override
-    public void setValueResultOfSearch(boolean v) {
-      throw new UnsupportedOperationException(
-          LocalizedStrings.ProxyRegionMap_NO_ENTRY_SUPPORT_ON_REGIONS_WITH_DATAPOLICY_0
-              .toLocalizedString(DataPolicy.EMPTY));
-    }
-
-    public boolean dispatchListenerEvents(EntryEventImpl event) throws InterruptedException {
-      // note that we don't synchronize on the RE before dispatching
-      // events
-      event.invokeCallbacks(event.getRegion(), event.inhibitCacheListenerNotification(), false);
-      return true;
-    }
-
-    public boolean hasStats() {
-      return false;
-    }
-
-    public Object getValueInVMOrDiskWithoutFaultIn(LocalRegion owner) {
+    @Override
+    public void setValueResultOfSearch(boolean value) {
-    public Object getValueOffHeapOrDiskWithoutFaultIn(LocalRegion owner) {
+    public boolean dispatchListenerEvents(EntryEventImpl event) throws InterruptedException {
+      // note that we don't synchronize on the RE before dispatching events
+      event.invokeCallbacks(event.getRegion(), event.inhibitCacheListenerNotification(), false);
+      return true;
+    }
+
+    @Override
+    public boolean hasStats() {
+      return false;
+    }
+
+    @Override
+    public Object getValueInVMOrDiskWithoutFaultIn(InternalRegion region) {
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.geode.internal.cache.RegionEntry#concurrencyCheck(org.apache.geode.internal.cache.
-     * LocalRegion, org.apache.geode.internal.cache.versions.VersionTag,
-     * org.apache.geode.distributed.internal.membership.InternalDistributedMember,
-     * org.apache.geode.distributed.internal.membership.InternalDistributedMember)
-     */
-    public void processVersionTag(LocalRegion r, VersionTag tag, InternalDistributedMember thisVM,
-        InternalDistributedMember sender) {
-      return;
+    @Override
+    public Object getValueOffHeapOrDiskWithoutFaultIn(InternalRegion region) {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.ProxyRegionMap_NO_ENTRY_SUPPORT_ON_REGIONS_WITH_DATAPOLICY_0
+              .toLocalizedString(DataPolicy.EMPTY));
-      // TODO Auto-generated method stub
-
+      // nothing
-      // TODO Auto-generated method stub
-      // TODO Auto-generated method stub
-
+      // nothing
-    public void setInUseByTransaction(boolean v) {}
+    public void incRefCount() {
+      // nothing
+    }
-    public void incRefCount() {}
+    public void decRefCount(EvictionList lruList, InternalRegion region) {
+      // nothing
+    }
-    public void decRefCount(NewLRUClockHand lruList, LocalRegion lr) {}
+    public void resetRefCount(EvictionList lruList) {
+      // nothing
+    }
-    public void resetRefCount(NewLRUClockHand lruList) {}
-
-    @Override
-    public Object prepareValueForCache(RegionEntryContext r, Object val, EntryEventImpl event,
-        boolean isEntryUpdate) {
+    public Object prepareValueForCache(RegionEntryContext context, Object value,
+        EntryEventImpl event, boolean isEntryUpdate) {
-  public void lruUpdateCallback(int n) {
-    // do nothing
-  }
-
-  public void lruEntryFaultIn(LRUEntry entry) {
+  @Override
+  public void lruEntryFaultIn(EvictableEntry entry) {
+  @Override
+  @Override
+  @Override
+  @Override
-  public void close() {}
+  public void close() {
+    // nothing
+  }
+
+  @Override
+  public long getEvictions() {
+    return 0;
+  }
+
+  @Override
+  public void incRecentlyUsed() {
+    // nothing
+  }

GEODE-74: Making the satisfy redundancy phase of rebalance parallel

Tasks submitted to background threads to trigger redundancy
satisfaction. After the satisfy redundancy phase is done we wait for the
tasks to finish.

The number of buckets that can be recovering in parallel is controlled
by the system property gemfire.MAX_PARALLEL_BUCKET_RECOVERIES, currently
set to 8.

If a redundancy recovery/rebalance is restarted due to a membership
change, wait for any in progress operations to complete before fetching
new information from all of the members.

-  public void createRedundantBucket(BucketRollup bucket,
-      Member targetMember) {
+  /**
+   * Trigger the creation of a redundant bucket, potentially asynchronously.
+   * 
+   * This method will find the best node to create a redundant bucket and 
+   * invoke the bucket operator to create a bucket on that node. Because the bucket
+   * operator is asynchronous, the bucket may not be created immediately, but
+   * the model will be updated regardless. Invoke {@link #waitForOperations()}
+   * to wait for those operations to actually complete
+   */
+  public void createRedundantBucket(final BucketRollup bucket,
+      final Member targetMember) {
-    Move move = new Move(null, targetMember, bucket);
+    final Move move = new Move(null, targetMember, bucket);
-    if(!this.operator.createRedundantBucket(targetMember.getMemberId(), bucket.getId(), colocatedRegionSizes)) {
-      this.attemptedBucketCreations.add(move);
-    } else {
+    
+    this.operator.createRedundantBucket(targetMember.getMemberId(), bucket.getId(), colocatedRegionSizes, new BucketOperator.Completion() {
+      @Override
+      public void onSuccess() {
+
+      @Override
+      public void onFailure() {
+        //If the bucket creation failed, we need to undo the changes
+        //we made to the model
+        attemptedBucketCreations.add(move);
+        bucket.removeMember(targetMember);
+        if(bucket.getRedundancy() < requiredRedundancy) {
+          lowRedundancyBuckets.add(bucket);
+        }
+        resetAverages();
+      }
+    });
+  /**
+   * Wait for the bucket operator to complete
+   * any pending asynchronous operations.
+   */
+  public void waitForOperations() {
+    operator.waitForOperations();
+  }
+  

Merge branch 'release/1.8.0'

+import static org.apache.geode.internal.cache.tier.sockets.Handshake.REPLY_REFUSED;
+import java.util.concurrent.ExecutorService;
-import java.util.concurrent.RejectedExecutionHandler;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
+import org.apache.geode.internal.logging.LoggingThread;
+import org.apache.geode.internal.logging.LoggingThreadFactory.CommandWrapper;
+import org.apache.geode.internal.logging.LoggingThreadFactory.ThreadInitializer;
- * Implements the acceptor thread on the bridge server. Accepts connections from the edge and starts
+ * Implements the acceptor thread on the cache server. Accepts connections from the edge and starts
-  private final ThreadPoolExecutor pool;
+  private final ExecutorService pool;
-  private final ThreadPoolExecutor hsPool;
+  private final ExecutorService hsPool;
-  private final ThreadPoolExecutor clientQueueInitPool;
+  private final ExecutorService clientQueueInitPool;
-   * THE selector for the bridge server; null if no selector.
+   * THE selector for the cache server; null if no selector.
-      int socketBufferSize, int maximumTimeBetweenPings, InternalCache internalCache,
-      int maxConnections, int maxThreads, int maximumMessageCount, int messageTimeToLive,
-      ConnectionListener listener, List overflowAttributesList, boolean isGatewayReceiver,
+      int socketBufferSize, int maximumTimeBetweenPings,
+      InternalCache internalCache,
+      int maxConnections, int maxThreads, int maximumMessageCount,
+      int messageTimeToLive,
+      ConnectionListener listener, List overflowAttributesList,
+      boolean isGatewayReceiver,
-      ServerConnectionFactory serverConnectionFactory) throws IOException {
+      ServerConnectionFactory serverConnectionFactory, long timeLimitMillis) throws IOException {
-          logger.warn(LocalizedMessage
-              .create(LocalizedStrings.AcceptorImpl_IGNORING_MAX_THREADS_DUE_TO_JROCKIT_NIO_BUG));
+          logger.warn(
+              "Ignoring max-threads setting and using zero instead due to JRockit NIO bugs.  See GemFire bug #40198");
-          logger.warn(LocalizedMessage
-              .create(LocalizedStrings.AcceptorImpl_IGNORING_MAX_THREADS_DUE_TO_WINDOWS_IPV6_BUG));
+          logger.warn(
+              "Ignoring max-threads setting and using zero instead due to Java bug 6230761: NIO does not work with IPv6 on Windows.  See GemFire bug #40472");
-      final long tilt = System.currentTimeMillis() + 120 * 1000;
+      final long tilt = System.currentTimeMillis() + timeLimitMillis;
-              LocalizedStrings.AcceptorImpl_SELECTOR_THREAD_POOLING_CAN_NOT_BE_USED_WITH_CLIENTSERVER_SSL_THE_SELECTOR_CAN_BE_DISABLED_BY_SETTING_MAXTHREADS0
-                  .toLocalizedString());
+              "Selector thread pooling can not be used with client/server SSL. The selector can be disabled by setting max-threads=0.");
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.AcceptorImpl_CACHE_SERVER_CONNECTION_LISTENER_BOUND_TO_ADDRESS_0_WITH_BACKLOG_1,
-          new Object[] {sockName, Integer.valueOf(backLog)}));
+      logger.info("Cache server connection listener bound to address {} with backlog {}.",
+          new Object[] {sockName, Integer.valueOf(backLog)});
-  private ThreadPoolExecutor initializeHandshakerThreadPool() throws IOException {
-    String gName = "Handshaker " + serverSock.getInetAddress() + ":" + this.localPort;
-    final ThreadGroup socketThreadGroup = LoggingThreadGroup.createThreadGroup(gName, logger);
-
-    ThreadFactory socketThreadFactory = new ThreadFactory() {
-      AtomicInteger connNum = new AtomicInteger(-1);
-
-      @Override
-      public Thread newThread(Runnable command) {
-        String threadName = socketThreadGroup.getName() + " Thread " + connNum.incrementAndGet();
-        getStats().incAcceptThreadsCreated();
-        return new Thread(socketThreadGroup, command, threadName);
-      }
-    };
+  private ExecutorService initializeHandshakerThreadPool() throws IOException {
+    String threadName =
+        "Handshaker " + serverSock.getInetAddress() + ":" + this.localPort + " Thread ";
-      final BlockingQueue blockingQueue = new SynchronousQueue();
-      final RejectedExecutionHandler rejectedExecutionHandler = new RejectedExecutionHandler() {
-        public void rejectedExecution(Runnable r, ThreadPoolExecutor pool) {
-          try {
-            blockingQueue.put(r);
-          } catch (InterruptedException ex) {
-            Thread.currentThread().interrupt(); // preserve the state
-            throw new RejectedExecutionException(
-                LocalizedStrings.AcceptorImpl_INTERRUPTED.toLocalizedString(), ex);
-          }
-        }
-      };
-      return new ThreadPoolExecutor(1, HANDSHAKE_POOL_SIZE, 60, TimeUnit.SECONDS, blockingQueue,
-          socketThreadFactory, rejectedExecutionHandler);
+      return LoggingExecutors.newThreadPoolWithSynchronousFeedThatHandlesRejection(threadName,
+          thread -> getStats().incAcceptThreadsCreated(), null, 1, HANDSHAKE_POOL_SIZE, 60);
-  private ThreadPoolExecutor initializeClientQueueInitializerThreadPool() throws IOException {
-    final ThreadGroup clientQueueThreadGroup =
-        LoggingThreadGroup.createThreadGroup("Client Queue Initialization ", logger);
-
-    ThreadFactory clientQueueThreadFactory = new ThreadFactory() {
-      AtomicInteger connNum = new AtomicInteger(-1);
-
-      @Override
-      public Thread newThread(final Runnable command) {
-        String threadName =
-            clientQueueThreadGroup.getName() + " Thread " + connNum.incrementAndGet();
-        Runnable runnable = new Runnable() {
-          public void run() {
-            try {
-              command.run();
-            } catch (CancelException e) {
-              logger.debug("Client Queue Initialization was canceled.", e);
-            }
+  private ExecutorService initializeClientQueueInitializerThreadPool() throws IOException {
+    return LoggingExecutors.newThreadPoolWithSynchronousFeed("Client Queue Initialization Thread ",
+        command -> {
+          try {
+            command.run();
+          } catch (CancelException e) {
+            logger.debug("Client Queue Initialization was canceled.", e);
-        };
-        return new Thread(clientQueueThreadGroup, runnable, threadName);
-      }
-    };
-    return new PooledExecutorWithDMStats(new SynchronousQueue(),
-        CLIENT_QUEUE_INITIALIZATION_POOL_SIZE, getStats().getCnxPoolHelper(),
-        clientQueueThreadFactory, 60000, getThreadMonitorObj());
+        }, CLIENT_QUEUE_INITIALIZATION_POOL_SIZE, getStats().getCnxPoolHelper(), 60000,
+        getThreadMonitorObj());
-  private ThreadPoolExecutor initializeServerConnectionThreadPool() throws IOException {
-    String gName = "ServerConnection "
-        // + serverSock.getInetAddress()
-        + "on port " + this.localPort;
-    final ThreadGroup socketThreadGroup = LoggingThreadGroup.createThreadGroup(gName, logger);
-
-    ThreadFactory socketThreadFactory = new ThreadFactory() {
-      AtomicInteger connNum = new AtomicInteger(-1);
-
-      @Override
-      public Thread newThread(final Runnable command) {
-        String tName = socketThreadGroup.getName() + " Thread " + connNum.incrementAndGet();
-        getStats().incConnectionThreadsCreated();
-        Runnable r = new Runnable() {
-          public void run() {
-            try {
-              command.run();
-            } catch (CancelException e) { // bug 39463
-              // ignore
-            } finally {
-              ConnectionTable.releaseThreadsSockets();
-            }
-          }
-        };
-        return new Thread(socketThreadGroup, r, tName);
+  private ExecutorService initializeServerConnectionThreadPool() throws IOException {
+    String threadName = "ServerConnection on port " + this.localPort + " Thread ";
+    ThreadInitializer threadInitializer = thread -> getStats().incConnectionThreadsCreated();
+    CommandWrapper commandWrapper = command -> {
+      try {
+        command.run();
+      } catch (CancelException e) { // bug 39463
+        // ignore
+      } finally {
+        ConnectionTable.releaseThreadsSockets();
-        return new PooledExecutorWithDMStats(new LinkedBlockingQueue(), this.maxThreads,
-            getStats().getCnxPoolHelper(), socketThreadFactory, Integer.MAX_VALUE,
-            getThreadMonitorObj());
+        return LoggingExecutors.newThreadPoolWithUnlimitedFeed(threadName, threadInitializer,
+            commandWrapper, this.maxThreads,
+            getStats().getCnxPoolHelper(), Integer.MAX_VALUE, getThreadMonitorObj());
-        return new ThreadPoolExecutor(MINIMUM_MAX_CONNECTIONS, this.maxConnections, 0L,
-            TimeUnit.MILLISECONDS, new SynchronousQueue(), socketThreadFactory);
+        return LoggingExecutors.newThreadPoolWithSynchronousFeed(threadName, threadInitializer,
+            commandWrapper,
+            MINIMUM_MAX_CONNECTIONS, this.maxConnections, 0L);
-    ThreadGroup tg = LoggingThreadGroup.createThreadGroup(
-        "Acceptor " + this.serverSock.getInetAddress() + ":" + this.localPort, logger);
-    thread = new Thread(tg, this, "Cache Server Acceptor " + this.serverSock.getInetAddress() + ":"
-        + this.localPort + " local port: " + this.serverSock.getLocalPort());
-
-    this.acceptorId = thread.getId();
-
+    thread =
+        new LoggingThread("Cache Server Acceptor " + this.serverSock.getInetAddress() + ":"
+            + this.localPort + " local port: " + this.serverSock.getLocalPort(), false, this);
+    this.acceptorId = thread.getId();
-      Runnable r = new Runnable() {
-        public void run() {
-          AcceptorImpl.this.runSelectorLoop();
-        }
-      };
-          new Thread(tg, r, "Cache Server Selector " + this.serverSock.getInetAddress() + ":"
-              + this.localPort + " local port: " + this.serverSock.getLocalPort());
+          new LoggingThread("Cache Server Selector " + this.serverSock.getInetAddress() + ":"
+              + this.localPort + " local port: " + this.serverSock.getLocalPort(),
+              false,
+              this::runSelectorLoop);
-          pr.getDistributionManager(), pr.getPRId(), profiles, true);
+          pr.getDistributionManager(), pr.getPRId(), profiles);
-        logger.warn(LocalizedMessage
-            .create(LocalizedStrings.AcceptorImpl_COULD_NOT_CHECK_FOR_STUCK_KEYS, ignore));
+        logger.warn("Could not check for stuck keys.", ignore);
-            logger.info(LocalizedMessage
-                .create(LocalizedStrings.AcceptorImpl_STUCK_SELECTION_KEY_DETECTED_ON_0, sc));
+            logger.info("stuck selection key detected on {}", sc);
-                  logger.warn(LocalizedMessage
-                      .create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
+                  logger.warn("Unexpected Exception:", ex);
-                logger.warn(LocalizedMessage
-                    .create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, rejected));
+                logger.warn("Unexpected Exception:", rejected);
-            logger.warn(
-                LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
+            logger.warn("Unexpected Exception:", ex);
-                logger.warn(LocalizedMessage
-                    .create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex2));
+                logger.warn("Unexpected Exception:", ex2);
-          logger.warn(
-              LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
+          logger.warn("Unexpected Exception:", ex);
-          logger.warn(
-              LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, npe));
+          logger.warn("Unexpected Exception:", npe);
-      logger.info(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_SELECTOR_ENABLED));
+      logger.info("SELECTOR enabled");
-            // do blocking wait on queue until we get some guys registered
+            // do blocking wait on queue until we get some keys registered
-            // we already have some guys registered so just do a poll on queue
+            // we already have some keys registered so just do a poll on queue
-              logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_IGNORING, ex));
+              logger.warn("ignoring", ex);
-              logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_IGNORING, ex));
+              logger.warn("ignoring", ex);
-                    logger.warn(
-                        LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, ex));
+                    logger.warn("unexpected", ex);
-                  logger.warn(
-                      LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, rejected));
+                  logger.warn("unexpected", rejected);
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.AcceptorImpl_IGNORING_EVENT_ON_SELECTOR_KEY__0, key));
+                  logger.warn("ignoring event on selector key {}", key);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, ex));
+      logger.warn("unexpected", ex);
-            logger.error(LocalizedMessage.create(
-                LocalizedStrings.AcceptorImpl_CACHE_SERVER_UNEXPECTED_IOEXCEPTION_FROM_ACCEPT, e));
+            logger.error("Cache server: Unexpected IOException from accept", e);
-          logger.fatal(LocalizedMessage
-              .create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_UNEXPECTED_EXCEPTION, e));
+          logger.fatal("Cache server: Unexpected Exception", e);
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION_DUE_TO_SOCKET_TIMEOUT));
+                  logger.warn(
+                      "Cache server: failed accepting client connection due to socket timeout.");
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION__0,
-                      ex), ex);
+                  logger.warn("Cache server: failed accepting client connection " +
+                      ex,
+                      ex);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, rejected));
+        logger.warn("unexpected", rejected);
-    logger.debug("Bridge server: Initializing {} communication socket: {}", communicationMode,
+    logger.debug("cache server: Initializing {} communication socket: {}", communicationMode,
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_CURRENT_CONNECTION_COUNT_OF_1_IS_GREATER_THAN_OR_EQUAL_TO_THE_CONFIGURED_MAX_OF_2,
+        logger.warn(
+            "Rejected connection from {} because current connection count of {} is greater than or equal to the configured max of {}",
-                Integer.valueOf(this.maxConnections)}));
+                Integer.valueOf(this.maxConnections)});
-                LocalizedStrings.AcceptorImpl_EXCEEDED_MAX_CONNECTIONS_0
-                    .toLocalizedString(Integer.valueOf(this.maxConnections)),
+                String.format("exceeded max-connections %s",
+                    Integer.valueOf(this.maxConnections)),
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_REQUEST_REJECTED_BY_POOL,
-            new Object[] {serverConn}));
+        logger.warn(
+            "Rejected connection from {} because incoming request was rejected by pool possibly due to thread exhaustion",
+            serverConn);
-              LocalizedStrings.AcceptorImpl_EXCEEDED_MAX_CONNECTIONS_0
-                  .toLocalizedString(Integer.valueOf(this.maxConnections)),
+              String.format("exceeded max-connections %s",
+                  Integer.valueOf(this.maxConnections)),
-  static final byte REPLY_REFUSED = (byte) 60;
-  static final byte REPLY_INVALID = (byte) 61;
-
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0,
-              socket.getRemoteSocketAddress()));
+          logger.warn("Cache server: timed out waiting for handshake from {}",
+              socket.getRemoteSocketAddress());
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.AcceptorImpl_CACHE_SERVER_ON_PORT_0_IS_SHUTTING_DOWN, this.localPort));
+        logger.info("Cache server on port {} is shutting down.", this.localPort);
-        notifyCacheMembersOfClose();
+        if (!cache.isClosed()) {
+          // the cache isn't closing so we need to inform peers that this CacheServer no longer
+          // exists
+          notifyCacheMembersOfClose();
+        }
-      logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED), e);
+      logger.warn("unexpected", e);
-  private void notifyCacheMembersOfClose() {
-    if (!this.cache.forcedDisconnect()) {
-      for (PartitionedRegion pr : this.cache.getPartitionedRegions()) {
-        Map<Integer, BucketAdvisor.BucketProfile> profiles = new HashMap<>();
-        // get all local real bucket advisors
-        Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
-        for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
-          BucketAdvisor advisor = entry.getValue();
-          BucketProfile bp = (BucketProfile) advisor.createProfile();
-          advisor.updateServerBucketProfile(bp);
-          profiles.put(entry.getKey(), bp);
-        }
+  void notifyCacheMembersOfClose() {
+    if (logger.isDebugEnabled()) {
+      logger.debug("sending messages to all peers for removing this server..");
+    }
+    for (PartitionedRegion pr : this.cache.getPartitionedRegions()) {
+      Map<Integer, BucketAdvisor.BucketProfile> profiles = new HashMap<>();
+      // get all local real bucket advisors
+      Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
+      for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
+        BucketAdvisor advisor = entry.getValue();
+        BucketProfile bp = (BucketProfile) advisor.createProfile();
+        advisor.updateServerBucketProfile(bp);
+        profiles.put(entry.getKey(), bp);
+      }
-        Set recipients = pr.getRegionAdvisor().adviseAllPRNodes();
-        // send it to all in one message
-        ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(recipients,
-            pr.getDistributionManager(), pr.getPRId(), profiles, true);
-        if (reply != null) {
-          reply.waitForRepliesUninterruptibly();
-        }
-
-        if (logger.isDebugEnabled()) {
-          logger.debug("sending messages to all peers for removing this server..");
-        }
+      Set recipients = pr.getRegionAdvisor().adviseAllPRNodes();
+      // send it to all in one message
+      ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(recipients,
+          pr.getDistributionManager(), pr.getPRId(), profiles);
+      if (reply != null) {
+        reply.waitForRepliesUninterruptibly();
-        logger.warn(LocalizedMessage
-            .create(LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
+        logger.warn("Timeout waiting for background tasks to complete.");
-   * Gets the address that this bridge server can be contacted on from external processes.
+   * Gets the address that this cache server can be contacted on from external processes.
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION_DUE_TO_SOCKET_TIMEOUT));
+              logger
+                  .warn("Cache server: failed accepting client connection due to socket timeout.");
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION__0,
-                  ex), ex);
+              logger.warn("Cache server: failed accepting client connection " +
+                  ex,
+                  ex);

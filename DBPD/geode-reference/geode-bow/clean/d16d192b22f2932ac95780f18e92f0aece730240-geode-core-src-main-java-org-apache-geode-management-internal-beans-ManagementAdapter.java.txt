GEODE-1994: Overhaul of internal.lang.StringUtils to extend and heavily use commons.lang.StringUtils

*   geode.internal.lang.StringUtils has been deprecated.  In the interim, it has been heavily refactored and extends commons.lang.StringUtils.
*
*   Renamed:
*   --  EMPTY_STRING -> EMPTY (inherited)
*   --  toUpperCase  -> upperCase (inherited)
*   --  toLowerCase  -> lowerCase (inherited)
*   --  padEnding    -> rightPad (inherited)
*
*   Removed:
*   --  EMPTY_STRING_ARRAY; usage replaced with commons.lang.ArrayUtils.EMPTY_STRING_ARRAY
*   --  SPACES
*   --  UTF_8; rare usage replaced with raw string
*   --  concat; usage replaced with commons.lang.join, refactoring as necessary.
*   --  getLettersOnly
*   --  getSpaces
*   --  truncate
*   --  valueOf; usage refactored to use defaultString
*
*   Refactored
*   --  defaultIfBlank: previously relied on varargs and could return null.  Usage refactored to allow inheritance from commons.
*   --  defaultString(s, EMPTY) refactored to use standard signature defaultString(s) for consistency throughout codebase.
*   --  isBlank: usage refactored to resolve discrepancies with commons.lang.isBlank, which is now inherited.
*   --  isEmpty: usage refactored to resolve discrepancies with commons.lang.isEmpty, which is now inherited.
*
*   Code Cleanup:
*   --  Many uses of !isBlank -> isNotBlank
*   --  Changes suggested by Inspections on most touched files.
*   --     Explicit <T> -> <> when type is inferable
*   --     while loops operating on iterators converted to for each loops
*   --     for loops operating on array indices converted to for each loops
*   --  Various string typos corrected.
*   --  isEmpty(s.trim()) -> isBlank(s)
*   --  s.trim().isEmpty() -> isEmpty(s)
*   --  Removed some instances of 'dead' code
*   --  Optimized imports in every touched file
*
*   Qualitative Changes:
*   --  The following functions now throw an error when called with a null string input:
*   --  *  LocatorLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setHostnameForClients
*   --  (Unit tests added to capture these changes)
*
*   Notes:
*   --  StringUtils.wraps may be inherited from Apache Commons when the dependency is updated.
*   --  AbstractLauncher.getMember has the documented behavior of returning null when both MemberName and ID are blank.  Is this the best behavior for this method?

* this closes #521

-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.management.InstanceNotFoundException;
-import javax.management.MBeanServer;
-import javax.management.MalformedObjectNameException;
-import javax.management.Notification;
-import javax.management.NotificationBroadcasterSupport;
-import javax.management.ObjectInstance;
-import javax.management.ObjectName;
-
-import org.apache.geode.distributed.internal.DistributionManager;
-import org.apache.geode.internal.cache.CacheService;
-import org.apache.logging.log4j.Logger;
-
+import org.apache.commons.lang.StringUtils;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.internal.cache.CacheService;
+import org.apache.logging.log4j.Logger;
+
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.Notification;
+import javax.management.NotificationBroadcasterSupport;
+import javax.management.ObjectInstance;
+import javax.management.ObjectName;
-  public static final List<Class> refreshOnInit = new ArrayList<Class>();
+  public static final List<Class> refreshOnInit = new ArrayList<>();
-  public static final List<String> internalLocks = new ArrayList<String>();
+  public static final List<String> internalLocks = new ArrayList<>();
-    Iterator<ObjectName> it = registeredMBeans.keySet().iterator();
-    while (it.hasNext()) {
-      ObjectName objectName = it.next();
+    for (ObjectName objectName : registeredMBeans.keySet()) {
-        for (int i = 0; i < intfTyps.length; i++) {
-          Class intfTyp = (Class) intfTyps[i];
+        for (Type intfTyp1 : intfTyps) {
+          Class intfTyp = (Class) intfTyp1;
-    ObjectName aggregatemMBeanPattern = null;
+    ObjectName aggregatemMBeanPattern;
-    } catch (MalformedObjectNameException e1) {
-      throw new ManagementException(e1);
-    } catch (NullPointerException e1) {
+    } catch (MalformedObjectNameException | NullPointerException e1) {
-    Iterator<ObjectName> it = registeredMBeans.keySet().iterator();
-
-    while (it.hasNext()) {
-      ObjectName objectName = it.next();
+    for (ObjectName objectName : registeredMBeans.keySet()) {
-        for (int i = 0; i < intfTyps.length; i++) {
-          Class intfTyp = (Class) intfTyps[i];
+        for (Type intfTyp1 : intfTyps) {
+          Class intfTyp = (Class) intfTyp1;
-      } catch (InstanceNotFoundException e) {
-        logger.warn("Failed to invoke aggregator for {} with exception {}", objectName,
-            e.getMessage(), e);
-      } catch (ClassNotFoundException e) {
+      } catch (InstanceNotFoundException | ClassNotFoundException e) {
-      RegionMXBean regionMBean = new RegionMBean<K, V>(bridge);
+      RegionMXBean regionMBean = new RegionMBean<>(bridge);
-    AsyncEventQueueMBean bean = null;
+    AsyncEventQueueMBean bean;
-    Map<String, String> userData = new HashMap<String, String>();
+    Map<String, String> userData = new HashMap<>();
-      nameOrId = nameOrId != null && !nameOrId.trim().isEmpty() ? nameOrId : sender.getId();
+      nameOrId = StringUtils.isNotBlank(nameOrId) ? nameOrId : sender.getId();
-      RegionMBean bean = null;
+      RegionMBean bean;
-    DiskStoreMBean bean = null;
+    DiskStoreMBean bean;

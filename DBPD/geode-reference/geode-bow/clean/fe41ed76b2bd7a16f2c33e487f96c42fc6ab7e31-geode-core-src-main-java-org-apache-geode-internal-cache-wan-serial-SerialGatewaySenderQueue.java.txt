GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
- * 
-    this.removalThread = new BatchRemovalThread((GemFireCacheImpl) abstractSender.getCache());
+    this.removalThread = new BatchRemovalThread(abstractSender.getCache());
-
-
-      // TODO: Kishor : after merging this change. AsyncEventQueue test failed
-      // with data inconsistency. As of now going ahead with sync putandGetKey.
-      // Need to work on this during cedar
-      // if (this.keyPutNoSync) {
-      // putAndGetKeyNoSync(event);
-      // }
-      // else {
-      // synchronized (this) {
-      // }
-      // }
-    // resetLastPeeked();
-    // AsyncEvent object = peekAhead();
-    // // If it is not null, destroy it and increment the head key
-    // if (object != null) {
-    // Long key = this.peekedIds.remove();
-    // if (logger.isTraceEnabled()) {
-    // logger.trace("{}: Retrieved {} -> {}",this, key, object);
-    // }
-    // // Remove the entry at that key with a callback arg signifying it is
-    // // a WAN queue so that AbstractRegionEntry.destroy can get the value
-    // // even if it has been evicted to disk. In the normal case, the
-    // // AbstractRegionEntry.destroy only gets the value in the VM.
-    // this.region.destroy(key, RegionQueue.WAN_QUEUE_TOKEN);
-    // updateHeadKey(key.longValue());
-
-    // if (logger.isTraceEnabled()) {
-    // logger.trace("{}: Destroyed {} -> {}", this, key, object);
-    // }
-    // }
-    // return object;
-    // List<AsyncEvent> batch = new ArrayList<AsyncEvent>(
-    // batchSize * 2);
-    // for (int i = 0; i < batchSize; i++) {
-    // AsyncEvent obj = take();
-    // if (obj != null) {
-    // batch.add(obj);
-    // } else {
-    // break;
-    // }
-    // }
-    // if (logger.isTraceEnabled()) {
-    // logger.trace("{}: Took a batch of {} entries", this, batch.size());
-    // }
-    // return batch;
-      this.notify();
+      notifyAll();
-    // resetLastPeeked();
-    // resetLastPeeked();
-   * 
-
-
-    // @todo don't do a get which updates the lru, instead just get the value
+    // TODO: don't do a get which updates the lru, instead just get the value
-    final GemFireCacheImpl gemCache = (GemFireCacheImpl) sender.getCache();
+    final InternalCache gemCache = sender.getCache();
-
-      // TODO: Suranjan, can we do the following
-      // In case of persistence write to disk sync and in case of eviction
-      // write in async
+
+      // In case of persistence write to disk sync and in case of eviction write in async
-    private final GemFireCacheImpl cache;
+    private final InternalCache cache;
+     * 
+     * @param c
-    public BatchRemovalThread(GemFireCacheImpl c) {
+    public BatchRemovalThread(InternalCache c) {
-        LocalRegion parentRegion, GemFireCacheImpl cache, AbstractGatewaySender sender) {
+        LocalRegion parentRegion, InternalCache cache, AbstractGatewaySender sender) {

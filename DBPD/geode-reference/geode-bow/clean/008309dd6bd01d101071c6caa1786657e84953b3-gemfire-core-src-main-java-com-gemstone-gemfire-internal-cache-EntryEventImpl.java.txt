Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.GemFireIOException;
-import com.gemstone.gemfire.internal.InternalDataSerializer.Sendable;
+import com.gemstone.gemfire.internal.Sendable;
+import com.gemstone.gemfire.internal.cache.tier.sockets.CacheServerHelper;
+import com.gemstone.gemfire.internal.cache.tx.DistTxKeyInfo;
+import com.gemstone.gemfire.internal.offheap.Chunk;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
+import com.gemstone.gemfire.internal.offheap.ReferenceCountHelper;
+import com.gemstone.gemfire.internal.offheap.Releasable;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
+
+import com.gemstone.gemfire.internal.util.ArrayUtils;
+             , Releasable
-  protected Object oldValue = null;
+  @Retained(ENTRY_EVENT_OLD_VALUE)
+  private Object oldValue = null;
-  private transient DistributedPutAllOperation putAllOp;
+  protected transient DistributedPutAllOperation putAllOp;
-  private transient DistributedRemoveAllOperation removeAllOp;
+  protected transient DistributedRemoveAllOperation removeAllOp;
+  /** boolean to indicate that this operation should be optimized by not fetching from HDFS*/
+  private transient boolean fetchFromHDFS = true;
+  
+  private transient boolean isPutDML = false;
+
+  /** boolean to indicate that the RegionEntry for this event was loaded from HDFS*/
+  private transient boolean loadedFromHDFS= false;
+  
+  private transient boolean isCustomEviction = false;
+  
+  /** boolean to indicate that the RegionEntry for this event has been evicted*/
+  private transient boolean isEvicted = false;
+  @Retained
-    return new EntryEventImpl();
+    return createVersionTagHolder(null);
+  @Retained
+    result.disallowOffHeapValues();
-  public EntryEventImpl(LocalRegion region,
-      Operation op,
-      Object key, Object newValue, Object callbackArgument,
-      boolean originRemote, DistributedMember distributedMember) {
-    // Added initializeId=true as the default case. This doesn't
-    // mean that the id will be initialized for sure. It only
-    // means that it will not be set after the entry is instantiated.
-    // UpdateOperation and DestroyOperation both set the id after the
-    // entry is instantiated. Other callers do not.
-    this(region, op, key, newValue, callbackArgument,
-        originRemote, distributedMember, true/* generateCallbacks */,
-        true /*initializeId*/);
-  }
-
-  public EntryEventImpl(LocalRegion region,
-      Operation op,
-      Object key,
-      Object newValue,
-      Object callbackArgument,
-      boolean originRemote,
-      DistributedMember distributedMember,
-      boolean generateCallbacks) {
-    // Added initializeId=true as the default case. This doesn't
-    // mean that the id will be initialized for sure. It only
-    // means that it will not be set after the entry is instantiated.
-    // UpdateOperation and DestroyOperation both set the id after the
-    // entry is instantiated. Other callers do not.
-    this(region, op, key, newValue, callbackArgument, originRemote,
-        distributedMember, generateCallbacks, true/*initializeId*/);
-  }
-  
-  public EntryEventImpl(LocalRegion region, Operation op, Object key,
+  @Retained
+  protected EntryEventImpl(LocalRegion region, Operation op, Object key,
-  public EntryEventImpl(
+  @Retained
+  protected EntryEventImpl(
-      Operation op, Object key, Object newVal,
+      Operation op, Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal,
-  public EntryEventImpl(LocalRegion region, Operation op, Object key,
-      Object newValue, Object callbackArgument, boolean originRemote,
+  @Retained
+  protected EntryEventImpl(LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument, boolean originRemote,
-  public EntryEventImpl(EntryEventImpl other) {
+  @Retained
+  public EntryEventImpl(@Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other) {
+    this(other, true);
+  }
+  
+  @Retained
+  public EntryEventImpl(@Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other, boolean setOldValue) {
-    
+
-    basicSetOldValue(other.basicGetOldValue(), true);
-    this.oldValueBytes = other.oldValueBytes;
-    eventFlags = other.eventFlags;
+    if (setOldValue) {
+      retainAndSetOldValue(other.basicGetOldValue());
+      this.oldValueBytes = other.oldValueBytes;
+    }
+    this.eventFlags = other.eventFlags;
+    this.keyInfo = other.keyInfo.isDistKeyInfo() ? new DistTxKeyInfo(
+        (DistTxKeyInfo) other.keyInfo) : new KeyInfo(other.keyInfo);
-      this.keyInfo = new KeyInfo(other.keyInfo);
-      this.keyInfo.setCallbackArg((new GatewaySenderEventCallbackArgument(
-          (GatewaySenderEventCallbackArgument)other.getRawCallbackArgument())));
-    } else {
-      this.keyInfo = new KeyInfo(other.keyInfo);
+      this.keyInfo
+          .setCallbackArg((new GatewaySenderEventCallbackArgument(
+              (GatewaySenderEventCallbackArgument) other
+                  .getRawCallbackArgument())));
+  @Retained
+  @Retained
+    this.offHeapOk = false;
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   */  
+  @Retained
+  public static EntryEventImpl create(LocalRegion region,
+      Operation op,
+      Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember) {
+    return create(region,op,key,newValue,callbackArgument,originRemote,distributedMember,true,true);
+  }
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   */
+  @Retained
+  public static EntryEventImpl create(LocalRegion region,
+      Operation op,
+      Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue,
+      Object callbackArgument,
+      boolean originRemote,
+      DistributedMember distributedMember,
+      boolean generateCallbacks) {
+    return create(region, op, key, newValue, callbackArgument, originRemote,
+        distributedMember, generateCallbacks,true);
+  }
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   *  
+   * Called by BridgeEntryEventImpl to use existing EventID
+   * 
+   * {@link EntryEventImpl#EntryEventImpl(LocalRegion, Operation, Object, Object, Object, boolean, DistributedMember, boolean, EventID)}
+   */ 
+  @Retained
+  public static EntryEventImpl create(LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument, boolean originRemote,
+      DistributedMember distributedMember, boolean generateCallbacks,
+      EventID eventID) {
+    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,newValue,callbackArgument,originRemote,distributedMember,generateCallbacks,eventID);
+    return entryEvent;
+  }
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * 
+   * {@link EntryEventImpl#EntryEventImpl(LocalRegion, Operation, Object, boolean, DistributedMember, boolean, boolean)}
+   */
+  @Retained
+  public static EntryEventImpl create(LocalRegion region, Operation op, Object key,
+      boolean originRemote, DistributedMember distributedMember,
+      boolean generateCallbacks, boolean fromRILocalDestroy) {
+    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,originRemote,distributedMember,generateCallbacks,fromRILocalDestroy);
+    return entryEvent;
+  }  
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * 
+   * This creator does not specify the oldValue as this will be filled in later as part of an
+   * operation on the region, or lets it default to null.
+   * 
+   * {@link EntryEventImpl#EntryEventImpl(LocalRegion, Operation, Object, Object, Object, boolean, DistributedMember, boolean, boolean)}
+   */
+  @Retained
+  public static EntryEventImpl create(final LocalRegion region,
+      Operation op, Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal,
+      Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember,
+      boolean generateCallbacks, boolean initializeId)  {
+    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,newVal,callbackArgument,
+        originRemote,distributedMember,generateCallbacks,initializeId);
+    return entryEvent;
+  }
+  
+  /**
+  @Retained
-      Operation entryOp, Object entryKey, Object entryNewValue)
+      Operation entryOp, Object entryKey, @Retained(ENTRY_EVENT_NEW_VALUE) Object entryNewValue)
-        e = new EntryEventImpl(region, entryOp, entryKey, entryNewValue,
+        e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue,
-        e = new EntryEventImpl(region, entryOp, entryKey, entryNewValue, event.getCallbackArgument(),
+        e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, event.getCallbackArgument(),
-      e = new EntryEventImpl(region, entryOp, entryKey, entryNewValue, null,
+      e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, null,
-  static EntryEventImpl createRemoveAllEvent(
+  protected static EntryEventImpl createRemoveAllEvent(
-        e = new EntryEventImpl(region, entryOp, entryKey, null,
+        e = EntryEventImpl.create(region, entryOp, entryKey, null,
-        e = new EntryEventImpl(region, entryOp, entryKey, null, event.getCallbackArgument(),
+        e = EntryEventImpl.create(region, entryOp, entryKey, null, event.getCallbackArgument(),
-      e = new EntryEventImpl(region, entryOp, entryKey, null, null,
+      e = EntryEventImpl.create(region, entryOp, entryKey, null, null,
+  public final boolean isCustomEviction() {
+    return this.isCustomEviction;
+  }
+  
+  public final void setCustomEviction(boolean customEvict) {
+    this.isCustomEviction = customEvict;
+  }
+  
+  public final void setEvicted() {
+    this.isEvicted = true;
+  }
+  
+  public final boolean isEvicted() {
+    return this.isEvicted;
+  }
+  
-  public Object getOldValue()
-  {
+  public final Object getOldValue() {
-      Object ov = basicGetOldValue();
+      @Unretained Object ov = basicGetOldValue();
+        if (ov instanceof StoredObject) {
+          // TODO OFFHEAP: returns off-heap PdxInstance
+          return ((StoredObject) ov).getValueAsDeserializedHeapObject();
+        } else
-   * Returns the new value as is; no deserialization or copying.
+   * Like getRawNewValue except that if the result is an off-heap reference then copy it to the heap.
+   * TODO OFFHEAP: to prevent the heap copy use getRawNewValue instead
-  public Object getRawNewValue() {
+  public final Object getRawNewValueAsHeapObject() {
+    return OffHeapHelper.getHeapForm(OffHeapHelper.copyIfNeeded(basicGetNewValue()));
+  }
+  
+  /**
+   * If new value is a Delta return it.
+   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
+   * Else return the raw form.
+   */
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public final Object getRawNewValue() {
+    if (this.delta != null) return this.delta;
+    return basicGetNewValue();
+  }
+
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public Object getValue() {
-  private void basicSetNewValue(Object v) {
-    if (v == this.newValue) return;
-    this.newValue = v;
-    this.cachedSerializedNewValue = null;
-  }
-  protected Object basicGetNewValue() {
-    Object result = this.newValue;
-    return result;
-  }
-  private void basicSetOldValue(Object v, boolean incRefCount) {
-    if (v == this.oldValue) return;
-    this.oldValue = v;
-  }
-  private Object basicGetOldValue() {
-    Object result = this.oldValue;
-    return result;
-  }
-
-  public Object getRawOldValue() {
-    return basicGetOldValue();
+  /**
+   * Returns the delta that represents the new value; null if no delta.
+   * @return the delta that represents the new value; null if no delta.
+   */
+  public final Delta getDeltaNewValue() {
+    return this.delta;
-   * Get the new value preferring the real value over delta if newValue has
-   * already been calculated. This is to correct size calculations when using
-   * delta (used by SQLFabric). See bug #40866.
+   *  Applies the delta 
-  public Object getNewValueForSize() {
-    applyDelta(false);
-    return basicGetNewValue();
+  private Object applyDeltaWithCopyOnRead(boolean doCopyOnRead) {
+    //try {
+      if (applyDelta(true)) {
+        Object applied = basicGetNewValue();
+        // if applyDelta returns true then newValue should not be off-heap
+        assert !(applied instanceof StoredObject);
+        if (applied == this.oldValue && doCopyOnRead) {
+          applied = CopyHelper.copy(applied);
+        }
+        return applied;
+      }
+    //} catch (EntryNotFoundException ex) {
+      // only (broken) product code has the opportunity to call this before
+      // this.oldValue is set. If oldValue is not set yet, then
+      // we most likely haven't synchronized on the region entry yet.
+      // (If we have, then make sure oldValue is set before
+      // calling this method).
+      //throw new AssertionError("too early to call getNewValue");
+    //}
+    return null;
+  }
+
+  @Released(ENTRY_EVENT_NEW_VALUE)
+  protected void basicSetNewValue(@Retained(ENTRY_EVENT_NEW_VALUE) Object v) {
+    if (v == this.newValue) return;
+    if (this.offHeapOk) {
+      OffHeapHelper.releaseAndTrackOwner(this.newValue, this);
+    }
+    if (v instanceof Chunk) {
+      ReferenceCountHelper.setReferenceCountOwner(this);
+      if (!((Chunk) v).retain()) {
+        ReferenceCountHelper.setReferenceCountOwner(null);
+        this.newValue = null;
+        return;
+      }
+      ReferenceCountHelper.setReferenceCountOwner(null);
+    }
+    this.newValue = v;
+    this.cachedSerializedNewValue = null;
+  }
+  /**
+   * Returns true if this event has a reference to an off-heap new or old value.
+   */
+  public boolean hasOffHeapValue() {
+    return (this.newValue instanceof Chunk) || (this.oldValue instanceof Chunk);
+  @Unretained
+  protected final Object basicGetNewValue() {
+    Object result = this.newValue;
+    if (!this.offHeapOk && result instanceof Chunk) {
+      //this.region.getCache().getLogger().info("DEBUG new value already freed " + System.identityHashCode(result));
+      throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+    }
+    return result;
+  }
+  
+  private class OldValueOwner {
+    private EntryEventImpl getEvent() {
+      return EntryEventImpl.this;
+    }
+    @Override
+    public int hashCode() {
+      return getEvent().hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof OldValueOwner) {
+        return getEvent().equals(((OldValueOwner) obj).getEvent());
+      } else {
+        return false;
+      }
+    }
+    @Override
+    public String toString() {
+      return "OldValueOwner " + getEvent().toString();
+    }
+  }
+
+  /**
+   * Note if v might be an off-heap reference that you did not retain for this EntryEventImpl
+   * then call retainsAndSetOldValue instead of this method.
+   * @param v the caller should have already retained this off-heap reference.
+   */
+  @Released(ENTRY_EVENT_OLD_VALUE)
+  private void basicSetOldValue(@Unretained(ENTRY_EVENT_OLD_VALUE) Object v) {
+    @Released final Object curOldValue = this.oldValue;
+    if (v == curOldValue) return;
+    if (this.offHeapOk) {
+      if (curOldValue instanceof Chunk) {
+        if (ReferenceCountHelper.trackReferenceCounts()) {
+          OffHeapHelper.releaseAndTrackOwner(curOldValue, new OldValueOwner());
+        } else {
+          OffHeapHelper.release(curOldValue);
+        }
+      }
+    }
+    
+    this.oldValue = v;
+  }
+
+  @Released(ENTRY_EVENT_OLD_VALUE)
+  private void retainAndSetOldValue(@Retained(ENTRY_EVENT_OLD_VALUE) Object v) {
+    if (v == this.oldValue) return;
+    
+    if (v instanceof Chunk) {
+      if (ReferenceCountHelper.trackReferenceCounts()) {
+        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+        boolean couldNotRetain = (!((Chunk) v).retain());
+        ReferenceCountHelper.setReferenceCountOwner(null);
+        if (couldNotRetain) {
+          this.oldValue = null;
+          return;
+        }
+      } else {
+        if (!((Chunk) v).retain()) {
+          this.oldValue = null;
+          return;
+        }
+      }
+    }
+    basicSetOldValue(v);
+  }
+
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
+  private Object basicGetOldValue() {
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
+    Object result = this.oldValue;
+    if (!this.offHeapOk && result instanceof Chunk) {
+      //this.region.getCache().getLogger().info("DEBUG old value already freed " + System.identityHashCode(result));
+      throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+    }
+    return result;
+  }
+
+  /**
+   * Like getRawOldValue except that if the result is an off-heap reference then copy it to the heap.
+   * To avoid the heap copy use getRawOldValue instead.
+   */
+  public final Object getRawOldValueAsHeapObject() {
+    return OffHeapHelper.getHeapForm(OffHeapHelper.copyIfNeeded(basicGetOldValue()));
+  }
+  /*
+   * If the old value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
+   * Else return the raw form.
+   */
+  @Unretained
+  public final Object getRawOldValue() {
+    return basicGetOldValue();
+  }
+  /**
+   * Just like getRawOldValue except if the raw old value is off-heap deserialize it.
+   * Note that in some cases sqlf ignores the request to deserialize.
+   */
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
+  public final Object getOldValueAsOffHeapDeserializedOrRaw() {
+    Object result = basicGetOldValue();
+    if (result instanceof StoredObject) {
+      result = ((StoredObject) result).getDeserializedForReading();
+    }
+    return AbstractRegion.handleNotAvailable(result); // fixes 49499
+  }
+
-  public Object getNewValue() {
+  public final Object getNewValue() {
+    
+        @Unretained(ENTRY_EVENT_NEW_VALUE)
+      if (nv instanceof StoredObject) {
+        // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
+        // TODO OFFHEAP: returns off-heap PdxInstance
+        return ((StoredObject) nv).getValueAsDeserializedHeapObject();
+      } else
-        // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
+  public final String getNewValueStringForm() {
+    return StringUtils.forceToString(basicGetNewValue());
+  }
+  public final String getOldValueStringForm() {
+    return StringUtils.forceToString(basicGetOldValue());
+  }
+  
-  public void setNewValue(Object obj) {
+  public final void setNewValue(@Retained(ENTRY_EVENT_NEW_VALUE) Object obj) {
-
-   * Return the new value iff it is already in serialized form,
-   * otherwise return null
+   * @return null if new value is not serialized; otherwise returns a SerializedCacheValueImpl containing the new value.
+    @Unretained(ENTRY_EVENT_NEW_VALUE)
+      if (tmp instanceof StoredObject) {
+        if (!((StoredObject) tmp).isSerialized()) {
+          // TODO OFFHEAP can we handle offheap byte[] better?
+          return null;
+        }
+      }
-      return new SerializedCacheValueImpl(getRegion(), this.re,
+      return new SerializedCacheValueImpl(this, getRegion(), this.re,
+   * Implement this interface if you want to call {@link #exportNewValue}.
+   * 
+   * @author darrel
+   *
+   */
+  public interface NewValueImporter {
+    /**
+     * @return true if the importer prefers the value to be in serialized form.
+     */
+    boolean prefersNewSerialized();
+
+    /**
+     * Only return true if the importer can use the value before the event that exported it is released.
+     * If false is returned then off-heap values will be copied to the heap for the importer.
+     * @return true if the importer can deal with the value being an unretained OFF_HEAP_REFERENCE.
+     */
+    boolean isUnretainedNewReferenceOk();
+
+    /**
+     * Import a new value that is currently in object form.
+     * @param nv the new value to import; unretained if isUnretainedNewReferenceOk returns true
+     * @param isSerialized true if the imported new value represents data that needs to be serialized; false if the imported new value is a simple sequence of bytes.
+     */
+    void importNewObject(@Unretained(ENTRY_EVENT_NEW_VALUE) Object nv, boolean isSerialized);
+
+    /**
+     * Import a new value that is currently in byte array form.
+     * @param nv the new value to import
+     * @param isSerialized true if the imported new value represents data that needs to be serialized; false if the imported new value is a simple sequence of bytes.
+     */
+    void importNewBytes(byte[] nv, boolean isSerialized);
+  }
+  
+  /**
+   * Export the event's new value to the given importer.
+   */
+  public final void exportNewValue(NewValueImporter importer) {
+    final boolean prefersSerialized = importer.prefersNewSerialized();
+    if (prefersSerialized) {
+      if (getCachedSerializedNewValue() != null) {
+        importer.importNewBytes(getCachedSerializedNewValue(), true);
+        return;
+      } else {
+      if (this.newValueBytes != null && this.newValue instanceof CachedDeserializable) {
+        importer.importNewBytes(this.newValueBytes, true);
+        return;
+      }
+      }
+    }
+    @Unretained(ENTRY_EVENT_NEW_VALUE) 
+    final Object nv = getRawNewValue();
+    if (nv instanceof StoredObject) {
+      @Unretained(ENTRY_EVENT_NEW_VALUE)
+      final StoredObject so = (StoredObject) nv;
+      final boolean isSerialized = so.isSerialized();
+      if (nv instanceof Chunk) {
+        if (importer.isUnretainedNewReferenceOk()) {
+          importer.importNewObject(nv, isSerialized);
+        } else {
+          if (!isSerialized || prefersSerialized) {
+            byte[] bytes = so.getValueAsHeapByteArray();
+            importer.importNewBytes(bytes, isSerialized);
+            if (isSerialized) {
+              setCachedSerializedNewValue(bytes);
+            }
+          } else {
+            // TODO OFFHEAP: returns off-heap PdxInstance which is not ok since isUnretainedNewReferenceOk returned false
+            importer.importNewObject(so.getValueAsDeserializedHeapObject(), true);
+          }
+        }
+      } else {
+        importer.importNewObject(nv, isSerialized);
+      }
+    } else if (nv instanceof byte[]) {
+      importer.importNewBytes((byte[])nv, false);
+    } else if (nv instanceof CachedDeserializable) {
+      CachedDeserializable cd = (CachedDeserializable) nv;
+      Object cdV = cd.getValue();
+      if (cdV instanceof byte[]) {
+        importer.importNewBytes((byte[]) cdV, true);
+        setCachedSerializedNewValue((byte[]) cdV);
+      } else {
+        importer.importNewObject(cdV, true);
+      }
+    } else {
+      importer.importNewObject(nv, true);
+    }
+  }
+  /**
+   * Implement this interface if you want to call {@link #exportOldValue}.
+   * 
+   * @author darrel
+   *
+   */
+  public interface OldValueImporter {
+    /**
+     * @return true if the importer prefers the value to be in serialized form.
+     */
+    boolean prefersOldSerialized();
+
+    /**
+     * Only return true if the importer can use the value before the event that exported it is released.
+     * @return true if the importer can deal with the value being an unretained OFF_HEAP_REFERENCE.
+     */
+    boolean isUnretainedOldReferenceOk();
+    
+    /**
+     * @return return true if you want the old value to possibly be an instanceof CachedDeserializable; false if you want the value contained in a CachedDeserializable.
+     */
+    boolean isCachedDeserializableValueOk();
+
+    /**
+     * Import an old value that is currently in object form.
+     * @param ov the old value to import; unretained if isUnretainedOldReferenceOk returns true
+     * @param isSerialized true if the imported old value represents data that needs to be serialized; false if the imported old value is a simple sequence of bytes.
+     */
+    void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized);
+
+    /**
+     * Import an old value that is currently in byte array form.
+     * @param ov the old value to import
+     * @param isSerialized true if the imported old value represents data that needs to be serialized; false if the imported old value is a simple sequence of bytes.
+     */
+    void importOldBytes(byte[] ov, boolean isSerialized);
+  }
+  
+  /**
+   * Export the event's old value to the given importer.
+   */
+  public final void exportOldValue(OldValueImporter importer) {
+    final boolean prefersSerialized = importer.prefersOldSerialized();
+    if (prefersSerialized) {
+      if (this.oldValueBytes != null && this.oldValue instanceof CachedDeserializable) {
+        importer.importOldBytes(this.oldValueBytes, true);
+        return;
+      }
+    }
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
+    final Object ov = getRawOldValue();
+    if (ov instanceof StoredObject) {
+      final StoredObject so = (StoredObject) ov;
+      final boolean isSerialized = so.isSerialized();
+      if (ov instanceof Chunk) {
+        if (importer.isUnretainedOldReferenceOk()) {
+          importer.importOldObject(ov, isSerialized);
+        } else {
+          if (!isSerialized || prefersSerialized) {
+            importer.importOldBytes(so.getValueAsHeapByteArray(), isSerialized);
+          } else {
+            // TODO OFFHEAP: returns off-heap PdxInstance which is not ok since isUnretainedNewReferenceOk returned false
+           importer.importOldObject(so.getValueAsDeserializedHeapObject(), true);
+          }
+        }
+      } else {
+        importer.importOldObject(ov, isSerialized);
+      }
+    } else if (ov instanceof byte[]) {
+      importer.importOldBytes((byte[])ov, false);
+    } else if (!importer.isCachedDeserializableValueOk() && ov instanceof CachedDeserializable) {
+      CachedDeserializable cd = (CachedDeserializable) ov;
+      Object cdV = cd.getValue();
+      if (cdV instanceof byte[]) {
+        importer.importOldBytes((byte[]) cdV, true);
+      } else {
+        importer.importOldObject(cdV, true);
+      }
+    } else {
+      importer.importOldObject(ov, true);
+    }
+  }
+
+  /**
+   * If applyDelta is true then first attempt to apply a delta (if we have one) and return the value.
+   * Else if new value is a Delta return it.
+   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
+   * Else return the raw form.
+   */
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public final Object getRawNewValue(boolean applyDelta) {
+    if (applyDelta) {
+      boolean doCopyOnRead = getRegion().isCopyOnRead();
+      Object newValueWithDelta = applyDeltaWithCopyOnRead(doCopyOnRead);
+      if (newValueWithDelta != null) {
+        return newValueWithDelta;
+      }
+      // if applyDelta is true and we have already applied the delta then
+      // just return the applied value instead of the delta object.
+      @Unretained(ENTRY_EVENT_NEW_VALUE)
+      Object newValue = basicGetNewValue();
+      if (newValue != null) return newValue;
+    }
+    return getRawNewValue();
+  }
+  /**
+   * Just like getRawNewValue(true) except if the raw new value is off-heap deserialize it.
+   * Note that in some cases sqlf ignores the request to deserialize.
+   */
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public final Object getNewValueAsOffHeapDeserializedOrRaw() {
+    Object result = getRawNewValue(true);
+    if (result instanceof StoredObject) {
+      result = ((StoredObject) result).getDeserializedForReading();
+    }
+    return AbstractRegion.handleNotAvailable(result); // fixes 49499
+  }
+
+  /**
+   * If the new value is stored off-heap return a retained OFF_HEAP_REFERENCE (caller must release).
+   * @return a retained OFF_HEAP_REFERENCE if the new value is off-heap; otherwise returns null
+   */
+  @Retained(ENTRY_EVENT_NEW_VALUE)
+  public StoredObject getOffHeapNewValue() {
+    final Object tmp = basicGetNewValue();
+    if (tmp instanceof StoredObject) {
+      StoredObject result = (StoredObject) tmp;
+      if (!result.retain()) {
+        return null;
+      }
+      return result;
+    } else {
+      return null;
+    }
+  }
+  
+  /**
+   * If the old value is stored off-heap return a retained OFF_HEAP_REFERENCE (caller must release).
+   * @return a retained OFF_HEAP_REFERENCE if the old value is off-heap; otherwise returns null
+   */
+  @Retained(ENTRY_EVENT_OLD_VALUE)
+  public StoredObject getOffHeapOldValue() {
+    final Object tmp = basicGetOldValue();
+    if (tmp instanceof StoredObject) {
+      StoredObject result = (StoredObject) tmp;
+      if (!result.retain()) {
+        return null;
+      }
+      return result;
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * Result may be unretained because sqlf getDeserializedForReading returns unretained.
+   */
+  public final Object getDeserializedValue() {
+    if (this.delta == null) {
+      final Object val = basicGetNewValue();
+      if (val instanceof StoredObject) {
+        // TODO OFFHEAP: returns off-heap PdxInstance
+        return ((StoredObject) val).getValueAsDeserializedHeapObject();
+      } else 
+      if (val instanceof CachedDeserializable) {
+        return ((CachedDeserializable)val).getDeserializedForReading();
+      }
+      else {
+        return val;
+      }
+    }
+    else {
+      return this.delta;
+    }
+  }
+
+  public final byte[] getSerializedValue() {
+    if (this.newValueBytes == null) {
+      final Object val;
+      if (this.delta == null) {
+        val = basicGetNewValue();
+        if (val instanceof byte[]) {
+          return (byte[])val;
+        }
+        else if (val instanceof CachedDeserializable) {
+          return ((CachedDeserializable)val).getSerializedValue();
+        }
+      }
+      else {
+        val = this.delta;
+      }
+      try {
+        return CacheServerHelper.serialize(val);
+      } catch (IOException ioe) {
+        throw new GemFireIOException("unexpected exception", ioe);
+      }
+    }
+    else {
+      return this.newValueBytes;
+    }
+  }
+
+  /**
-  private void makeSerializedNewValue(boolean isSynced) {
-    Object obj = this.newValue;
+  private final void makeSerializedNewValue(boolean isSynced) {
+    Object obj = basicGetNewValue();
-  public void setSerializedNewValue(byte[] serializedValue) {
+  public final void setSerializedNewValue(byte[] serializedValue) {
+    Object newVal = null;
+    if (serializedValue != null) {
+      if (CachedDeserializableFactory.preferObject()) {
+        newVal = deserialize(serializedValue);
+      } else {
+        newVal = CachedDeserializableFactory.create(serializedValue);
+      }
+      if (newVal instanceof Delta) {
+        this.delta = (Delta)newVal;
+        newVal = null;
+        // We need the newValueBytes field and the newValue field to be in sync.
+        // In the case of non-null delta set both fields to null.
+        serializedValue = null;
+      }
+    }
-    basicSetNewValue(CachedDeserializableFactory.create(serializedValue));
+    basicSetNewValue(newVal);
-    basicSetOldValue(CachedDeserializableFactory.create(serializedOldValue), true);
+    final Object ov;
+    if (CachedDeserializableFactory.preferObject()) {
+      ov = deserialize(serializedOldValue);
+    }
+    else if (serializedOldValue != null) {
+      ov = CachedDeserializableFactory.create(serializedOldValue);
+    }
+    else {
+      ov = null;
+    }
+    retainAndSetOldValue(ov);
+            || GemFireCacheImpl.sqlfSystem()
-          Object ov = reentry._getValueUse(owner, true); // TODO:KIRK:OK 
+          @Retained Object ov;
+          if (ReferenceCountHelper.trackReferenceCounts()) {
+            ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+            if (GemFireCacheImpl.sqlfSystem()) {
+              ov = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+            } else {
+              ov = reentry._getValueRetain(owner, true);
+            }
+            ReferenceCountHelper.setReferenceCountOwner(null);
+          } else {
+            if (GemFireCacheImpl.sqlfSystem()) {
+              ov = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+            } else {
+              ov = reentry._getValueRetain(owner, true);
+            }
+          }
-          basicSetOldValue(ov, false);
+          // ov has already been retained so call basicSetOldValue instead of retainAndSetOldValue
+          basicSetOldValue(ov);
-          basicSetOldValue(Token.NOT_AVAILABLE, true);
+          basicSetOldValue(Token.NOT_AVAILABLE);
-      basicSetOldValue(null, true);
+      basicSetOldValue(null);
+  @Retained(ENTRY_EVENT_NEW_VALUE)
-    } 
- 
-    v = AbstractRegionMap.prepareValueForCache(this.region, v, this);
+    }
+    Object preparedV = reentry.prepareValueForCache(this.region, v, this, this.hasDelta());
+    if (preparedV != v) {
+      v = preparedV;
+      if (v instanceof Chunk) {
+        if (!((Chunk) v).isCompressed()) { // fix bug 52109
+          // If we put it off heap and it is not compressed then remember that value.
+          // Otherwise we want to remember the decompressed value in the event.
+          basicSetNewValue(v);
+        }
+      }
+    }
+    boolean isTombstone = (v == Token.TOMBSTONE);
+    boolean success = false;
+    boolean calledSetValue = false;
+    try {
-    boolean isTombstone = (v == Token.TOMBSTONE);
-    
-      boolean success = false;
+        calledSetValue = true;
+      calledSetValue = true;
+      success = true;
+    }
+    } finally {
+      if (!success && reentry instanceof OffHeapRegionEntry && v instanceof Chunk) {
+        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (Chunk)v);
+      }      
-  void setTXEntryOldValue(Object oldVal, boolean mustBeAvailable)
-  {
-    if (Token.isInvalidOrRemoved(oldVal) || oldVal == null) {
-      basicSetOldValue(null, true);
+  void setTXEntryOldValue(Object oldVal, boolean mustBeAvailable) {
+    if (Token.isInvalidOrRemoved(oldVal)) {
+      oldVal = null;
-      if (mustBeAvailable) {
-        basicSetOldValue(oldVal, true);
-      } else if (EVENT_OLD_VALUE) {
-        basicSetOldValue(oldVal, true);
-      } else {
-        basicSetOldValue(Token.NOT_AVAILABLE, true);
+      if (mustBeAvailable || oldVal == null || EVENT_OLD_VALUE) {
+        // set oldValue to oldVal
+      }
+      else {
+        oldVal = Token.NOT_AVAILABLE;
+    retainAndSetOldValue(oldVal);
-      tx.setPendingValue(v);
+      tx.setPendingValue(OffHeapHelper.copyIfNeeded(v)); // TODO OFFHEAP optimize
-      Object v = re._getValueUse(this.region, true);
+      ReferenceCountHelper.skipRefCountTracking();
+      Object v = re._getValueRetain(this.region, true);
+      ReferenceCountHelper.unskipRefCountTracking();
+      try {
+      } finally {
+        OffHeapHelper.releaseWithNoTracking(v);
+      }
-    basicSetOldValue(Token.DESTROYED, true);
+    basicSetOldValue(Token.DESTROYED);
-        basicSetOldValue(null, true);
+        v = null;
-          basicSetOldValue(v, true);
+          // set oldValue to "v".
-          basicSetOldValue(v, true);
+          // set oldValue to "v".
-          basicSetOldValue(Token.NOT_AVAILABLE, true);
+          v = Token.NOT_AVAILABLE;
+      retainAndSetOldValue(v);
-    } else if (Token.isInvalid(v)) {
-      basicSetOldValue(null, true);
-      basicSetOldValue(v, true);
+      if (Token.isInvalid(v)) {
+        v = null;
+      }   
+      retainAndSetOldValue(v);
-    if (tmp == null && this.delta != null) {
+    if (tmp == null && hasDelta()) {
-  final public boolean hasOldValue() {
-    return this.oldValue != null  && basicGetOldValue() != Token.NOT_AVAILABLE;
+  public final boolean hasOldValue() {
+    return this.oldValue != null && this.oldValue != Token.NOT_AVAILABLE;
+  }
+  public final boolean isOldValueAToken() {
+    return this.oldValue instanceof Token;
-    basicSetOldValue(Token.NOT_AVAILABLE, true);
+    basicSetOldValue(Token.NOT_AVAILABLE);
+   * If a PdxInstance is returned then it will have an unretained reference
+   * to Chunk's off-heap address.
+   */
+  public static @Unretained Object deserializeChunk(Chunk bytes) {
+    if (bytes == null)
+      return null;
+    try {
+      return BlobHelper.deserializeOffHeapBlob(bytes);
+    }
+    catch (IOException e) {
+      throw new SerializationException(LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_DESERIALIZING.toLocalizedString(), e);
+    }
+    catch (ClassNotFoundException e) {
+      // fix for bug 43602
+      throw new SerializationException(LocalizedStrings.EntryEventImpl_A_CLASSNOTFOUNDEXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE_CACHED_VALUE.toLocalizedString(), e);
+    }
+  }
+
+  /**
-  String getShortClassName() {
+  protected String getShortClassName() {
-    buf.append(basicGetOldValue());
+    try {
+      ArrayUtils.objectStringNonRecursive(basicGetOldValue(), buf);
+    } catch (IllegalStateException ex) {
+      buf.append("OFFHEAP_VALUE_FREED");
+    }
-    buf.append(basicGetNewValue());
+    try {
+      ArrayUtils.objectStringNonRecursive(basicGetNewValue(), buf);
+    } catch (IllegalStateException ex) {
+      buf.append("OFFHEAP_VALUE_FREED");
+    }
+        if (newValueSerialized) {
+          if (nv instanceof StoredObject) {
+            newValueSerialized = ((StoredObject) nv).isSerialized();
+          }
+        }
+      if (oldValueSerialized) {
+        if (ov instanceof StoredObject) {
+          oldValueSerialized = ((StoredObject) ov).isSerialized();
+        }
+      }
-  public SerializedCacheValue<?> getSerializedOldValue() {
+  /**
+   * @return null if old value is not serialized; otherwise returns a SerializedCacheValueImpl containing the old value.
+   */
+  public final SerializedCacheValue<?> getSerializedOldValue() {
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
-      return new SerializedCacheValueImpl(this.region, this.re,
+      if (tmp instanceof StoredObject) {
+        if (!((StoredObject) tmp).isSerialized()) {
+          // TODO OFFHEAP can we handle offheap byte[] better?
+          return null;
+        }
+      }
+      return new SerializedCacheValueImpl(this, this.region, this.re,
-
+  
+   * Used to store next region version generated for a change on this entry
+   * by phase-1 commit on the primary.  
+   * 
+   * Not to be used in fromData and toData
+   */
+  protected transient long nextRegionVersion = -1L;
+  
+  public void setNextRegionVersion(long regionVersion) {
+    this.nextRegionVersion = regionVersion;
+  }
+  
+  public long getNextRegionVersion() {
+    return this.nextRegionVersion;
+  }
+  
+  /**
-      Object v = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+      @Retained Object v = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
-        basicSetOldValue(v, false);
+        // v has already been retained.
+        basicSetOldValue(v);
+        // this event now owns the retention of v.
-
-  // TODO this class is trouble for OffHeap storage.
-  // If the cd is a OffHeapCachedDeserializable we don't want to have a reference
-  // to it in this class since customers can hold onto SerializedCacheValue
-  // as long as they want and we would need to use finalization to know when
-  // they are done with it.
-  // TODO this class is also used in a number of places internally and those
-  // we want to be optimized. I think those places can be changed not to use
-  // this class.
-  public static class SerializedCacheValueImpl
+  public static final class SerializedCacheValueImpl
-    private final CachedDeserializable cd;
+    private final EntryEventImpl event;
+    @Unretained private final CachedDeserializable cd;
-    SerializedCacheValueImpl(Region r, RegionEntry re, CachedDeserializable cd, byte[] serializedBytes) {
+    SerializedCacheValueImpl(EntryEventImpl event, Region r, RegionEntry re, @Unretained CachedDeserializable cd, byte[] serializedBytes) {
+      if (cd instanceof Chunk) {
+        this.event = event;
+      } else {
+        this.event = null;
+      }
-      return this.cd.getSerializedValue();
+      return getCd().getSerializedValue();
+    }
+    
+    private CachedDeserializable getCd() {
+      if (this.event != null && !this.event.offHeapOk) {
+        throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+      }
+      return this.cd;
-      return this.cd.getDeserializedForReading();
+      // TODO OFFHEAP: returns off-heap PdxInstance
+      return OffHeapHelper.getHeapForm(getCd().getDeserializedForReading());
-      return this.cd.getDeserializedWritableCopy(rgn, entry);
+      // TODO OFFHEAP: returns off-heap PdxInstance
+      return OffHeapHelper.getHeapForm(getCd().getDeserializedWritableCopy(rgn, entry));
-      return this.cd.getDeserializedValue(rgn, reentry);
+      // TODO OFFHEAP: returns off-heap PdxInstance
+      return OffHeapHelper.getHeapForm(getCd().getDeserializedValue(rgn, reentry));
-      return this.cd.getValue();
+      return getCd().getValue();
-        this.cd.writeValueAsByteArray(out);
+        getCd().writeValueAsByteArray(out);
-        this.cd.fillSerializedValue(wrapper, userBits);
+        getCd().fillSerializedValue(wrapper, userBits);
-      return this.cd.getValueSizeInBytes();
+      return getCd().getValueSizeInBytes();
-      return this.cd.getSizeInBytes();
+      return getCd().getSizeInBytes();
-      return this.cd.getStringForm();
+      return getCd().getStringForm();
-      DataSerializer.writeObject(this.cd, out);
+      DataSerializer.writeObject(getCd(), out);
+
+  /**
+   * True if it is ok to use old/new values that are stored off heap.
+   * False if an exception should be thrown if an attempt is made to access old/new offheap values.
+   */
+  private transient boolean offHeapOk = true;
+ 
+  @Override
+  @Released({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE})
+  public void release() {
+    // noop if already freed or values can not be off-heap
+    if (!this.offHeapOk) return;
+    // Note that this method does not set the old/new values to null but
+    // leaves them set to the off-heap value so that future calls to getOld/NewValue
+    // will fail with an exception.
+//    LocalRegion lr = getLocalRegion();
+//    if (lr != null) {
+//      if (lr.isCacheClosing()) {
+//        // to fix races during closing and recreating cache (see bug 47883) don't bother
+//        // trying to decrement reference counts if we are closing the cache.
+//        // TODO OFFHEAP: this will cause problems once offheap lives longer than a cache.
+//        this.offHeapOk = false;
+//        return;
+//      }
+//    }
+    Object ov = basicGetOldValue();
+    Object nv = basicGetNewValue();
+    this.offHeapOk = false;
+    
+    if (ov instanceof Chunk) {
+      //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
+      if (ReferenceCountHelper.trackReferenceCounts()) {
+        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+        ((Chunk) ov).release();
+        ReferenceCountHelper.setReferenceCountOwner(null);
+      } else {
+        ((Chunk) ov).release();
+      }
+    }
+    OffHeapHelper.releaseAndTrackOwner(nv, this);
+  }
+
+  /**
+   * Make sure that this event will never own an off-heap value.
+   * Once this is called on an event it does not need to have release called.
+   */
+  public void disallowOffHeapValues() {
+    if (this.newValue instanceof Chunk || this.oldValue instanceof Chunk) {
+      throw new IllegalStateException("This event does not support off-heap values");
+    }
+    this.offHeapOk = false;
+  }
+  
+  /**
+   * This copies the off-heap new and/or old value to the heap.
+   * As a result the current off-heap new/old will be released.
+   * @throws IllegalStateException if called with an event for sqlf data.
+   */
+  @Released({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE})
+  public void copyOffHeapToHeap() {
+    Object ov = basicGetOldValue();
+    if (ov instanceof Chunk) {
+      if (ReferenceCountHelper.trackReferenceCounts()) {
+        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+        ReferenceCountHelper.setReferenceCountOwner(null);
+      } else {
+        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+      }
+    }
+    Object nv = basicGetNewValue();
+    if (nv instanceof Chunk) {
+      ReferenceCountHelper.setReferenceCountOwner(this);
+      this.newValue = OffHeapHelper.copyAndReleaseIfNeeded(nv);
+      ReferenceCountHelper.setReferenceCountOwner(null);
+    }
+    if (this.newValue instanceof Chunk || this.oldValue instanceof Chunk) {
+      throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
+    }
+    this.offHeapOk = false;
+  }
+
+  public boolean isOldValueOffHeap() {
+    return this.oldValue instanceof Chunk;
+  }
+  public final boolean isFetchFromHDFS() {
+    return fetchFromHDFS;
+  }
+
+  public final void setFetchFromHDFS(boolean fetchFromHDFS) {
+    this.fetchFromHDFS = fetchFromHDFS;
+  }
+
+  public final boolean isPutDML() {
+    return this.isPutDML;
+  }
+
+  public final void setPutDML(boolean val) {
+    this.isPutDML = val;
+  }
+
+  public final boolean isLoadedFromHDFS() {
+    return loadedFromHDFS;
+  }
+
+  public final void setLoadedFromHDFS(boolean loadedFromHDFS) {
+    this.loadedFromHDFS = loadedFromHDFS;
+  }

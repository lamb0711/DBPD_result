Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
+
+
+
-  protected void initialize(Object owner,
-                            Attributes attr,
-                            InternalRegionArguments internalRegionArgs) {
+  protected void initialize(Object owner, Attributes attr,
+      InternalRegionArguments internalRegionArgs) {
-    super.initialize(owner, attr, internalRegionArgs, true/*isLRU*/);
+    super.initialize(owner, attr, internalRegionArgs, true/* isLRU */);
-      ea = ((LocalRegion)owner).getEvictionAttributes().getAlgorithm();
-      ec = ((LocalRegion)owner).getEvictionController();
+      ea = ((LocalRegion) owner).getEvictionAttributes().getAlgorithm();
+      ec = ((LocalRegion) owner).getEvictionController();
-      PlaceHolderDiskRegion phdr = (PlaceHolderDiskRegion)owner;
+      PlaceHolderDiskRegion phdr = (PlaceHolderDiskRegion) owner;
-    
-    if (ea.isLRUMemory())  {
-      ((MemLRUCapacityController) ec).setEntryOverHead(getEntryOverHead()); 
+
+    if (ea.isLRUMemory()) {
+      ((MemLRUCapacityController) ec).setEntryOverHead(getEntryOverHead());
-    if (ea.isLRUHeap())  {
-      ((HeapLRUCapacityController) ec).setEntryOverHead(getEntryOverHead()); 
-    }    
+    if (ea.isLRUHeap()) {
+      ((HeapLRUCapacityController) ec).setEntryOverHead(getEntryOverHead());
+    }
-    
+
-    if (ea == EvictionAlgorithm.LIFO_ENTRY || ea == EvictionAlgorithm.LIFO_MEMORY ) {
+    if (ea == EvictionAlgorithm.LIFO_ENTRY || ea == EvictionAlgorithm.LIFO_MEMORY) {
-    }
-    else {
+    } else {
-  /** The delta produced during a put for activating LRU cannot be used while some
-   * outside party (LocalRegion) has a segment locked... so we'll keep it in a thread
-   * local for a callback after the segment is released.
+  /**
+   * The delta produced during a put for activating LRU cannot be used while some outside party
+   * (LocalRegion) has a segment locked... so we'll keep it in a thread local for a callback after
+   * the segment is released.
-  private int getDelta( ) {
+  private int getDelta() {
-    lruDelta.set(null);         // We only want the delta consumed once
-    if ( d == null ) return 0;
-    return ((Integer)d).intValue();
+    lruDelta.set(null); // We only want the delta consumed once
+    if (d == null)
+      return 0;
+    return ((Integer) d).intValue();
-  private void setDelta( int delta ) {
+  private void setDelta(int delta) {
-        // operation that needs to update LRU stats.  In order to do this
+        // operation that needs to update LRU stats. In order to do this
-      setMustRemove( true );
+      setMustRemove(true);
-    lruDelta.set( Integer.valueOf( delta ) );
+    lruDelta.set(Integer.valueOf(delta));
-   * Marker class to indicate that the wrapped value
-   * is owned by a CachedDeserializable and its form is
-   * changing from serialized to deserialized.
+   * Marker class to indicate that the wrapped value is owned by a CachedDeserializable and its form
+   * is changing from serialized to deserialized.
+
+
-  
+
-   * Used when a CachedDeserializable's value changes form.
-   * PRECONDITION: caller has le synced
+   * Used when a CachedDeserializable's value changes form. PRECONDITION: caller has le synced
+   * 
-    if (_getCCHelper().getEvictionAlgorithm().isLRUHeap()
-        &&_isOwnerALocalRegion() && _getOwner() instanceof BucketRegion
+    if (_getCCHelper().getEvictionAlgorithm().isLRUHeap() && _isOwnerALocalRegion()
+        && _getOwner() instanceof BucketRegion
-  
-  private boolean getMustRemove( ) {
+
+  private boolean getMustRemove() {
-    if ( d == null ) return false;
-    return ((Boolean)d).booleanValue();
+    if (d == null)
+      return false;
+    return ((Boolean) d).booleanValue();
-  private void setMustRemove( boolean b ) {
-    mustRemove.set( b ? Boolean.TRUE : null );
+  private void setMustRemove(boolean b) {
+    mustRemove.set(b ? Boolean.TRUE : null);
-  private boolean getCallbackDisabled( ) {
+
+  private boolean getCallbackDisabled() {
-    if ( d == null ) return false;
-    return ((Boolean)d).booleanValue();
+    if (d == null)
+      return false;
+    return ((Boolean) d).booleanValue();
-  private void setCallbackDisabled( boolean b ) {
-    callbackDisabled.set( b ? Boolean.TRUE : Boolean.FALSE );
+  private void setCallbackDisabled(boolean b) {
+    callbackDisabled.set(b ? Boolean.TRUE : Boolean.FALSE);
+
-  public final void audit( ) {
+  public final void audit() {
-      logger.trace(LogMarker.LRU, "Size of LRUMap = {}", sizeInVM() );
+      logger.trace(LogMarker.LRU, "Size of LRUMap = {}", sizeInVM());
-   * Evicts the given entry from the cache. Returns the total number of bytes
-   * evicted. 
-   * 1. For action local destroy, returns size(key + value)
-   * 2. For action evict to disk, returns size(value)
+   * Evicts the given entry from the cache. Returns the total number of bytes evicted. 1. For action
+   * local destroy, returns size(key + value) 2. For action evict to disk, returns size(value)
+   * 
-  protected int evictEntry(LRUEntry entry, LRUStatistics stats) throws RegionClearedException  {
+  protected int evictEntry(LRUEntry entry, LRUStatistics stats) throws RegionClearedException {
-            logger.trace(LogMarker.LRU, "No eviction of transactional entry for key={}", entry.getKey());
+            logger.trace(LogMarker.LRU, "No eviction of transactional entry for key={}",
+                entry.getKey());
-            logger.trace(LogMarker.LRU, "no need to evict {} token for key={}", entryVal, entry.getKey());
+            logger.trace(LogMarker.LRU, "no need to evict {} token for key={}", entryVal,
+                entry.getKey());
-        change = DiskEntry.Helper.overflowToDisk((DiskEntry)entry, region, _getCCHelper());
+        change = DiskEntry.Helper.overflowToDisk((DiskEntry) entry, region, _getCCHelper());
-        
+
-          BucketRegion bucketRegion = (BucketRegion)_getOwner();
+          BucketRegion bucketRegion = (BucketRegion) _getOwner();
-          //if(bucketRegion.getBucketAdvisor().isPrimary()){
-            stats.updateCounter(change);
-         // }
-        }
-        else {
+          // if(bucketRegion.getBucketAdvisor().isPrimary()){
+          stats.updateCounter(change);
+          // }
+        } else {
-          logger.trace(LogMarker.LRU, "no need to evict token for key={} because moving its value to disk resulted in a net change of {} bytes.",
-            entry.getKey(), change);
+          logger.trace(LogMarker.LRU,
+              "no need to evict token for key={} because moving its value to disk resulted in a net change of {} bytes.",
+              entry.getKey(), change);
-      throw new InternalGemFireException(LocalizedStrings.AbstractLRURegionMap_UNKNOWN_EVICTION_ACTION_0.toLocalizedString(action));
+      throw new InternalGemFireException(
+          LocalizedStrings.AbstractLRURegionMap_UNKNOWN_EVICTION_ACTION_0
+              .toLocalizedString(action));
-  
+
-   *  update the running counter of all the entries
+   * update the running counter of all the entries
-   * @param  delta  Description of the Parameter
+   * @param delta Description of the Parameter
-        BucketRegion bucketRegion = (BucketRegion)_getOwner();
+        BucketRegion bucketRegion = (BucketRegion) _getOwner();
-    if (delta > 0 ) {
+    if (delta > 0) {
-        logger.trace(LogMarker.LRU, "total lru size is now: {}", getTotalEntrySize() );
+        logger.trace(LogMarker.LRU, "total lru size is now: {}", getTotalEntrySize());
-   *  access the getHelper method on the eviction controller to initialize
-   *  the ccHelper field.
+   * access the getHelper method on the eviction controller to initialize the ccHelper field.
-   * @param  ec  The governing eviction controller.
-   * @return     the helper instance from the eviction controller.
+   * @param ec The governing eviction controller.
+   * @return the helper instance from the eviction controller.
-  private static EnableLRU getHelper( LRUAlgorithm ec ) {
+  private static EnableLRU getHelper(LRUAlgorithm ec) {
+
-    throw new IllegalStateException("The evictValue is not supported on regions with eviction attributes.");
+    throw new IllegalStateException(
+        "The evictValue is not supported on regions with eviction attributes.");
-   *  Gets the total entry size limit for the map from the capacity
-   *  controller helper.
+   * Gets the total entry size limit for the map from the capacity controller helper.
-   * @return    The total allowable size of this maps entries.
+   * @return The total allowable size of this maps entries.
-      BucketRegion bucketRegion = (BucketRegion)_getOwner();
+      BucketRegion bucketRegion = (BucketRegion) _getOwner();
-  
+
-      BucketRegion bucketRegion = (BucketRegion)_getOwner();
+      BucketRegion bucketRegion = (BucketRegion) _getOwner();
-    
+
-          getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(), delta, getLimit(), _getOwner().getTombstoneCount());
+          getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(), delta,
+          getLimit(), _getOwner().getTombstoneCount());
-    } else
-    if (_getCCHelper().getEvictionAlgorithm().isLRUHeap()) {
+    } else if (_getCCHelper().getEvictionAlgorithm().isLRUHeap()) {
-          while (bytesToEvict > 0 && _getCCHelper().mustEvict(stats, _getOwner(), bytesToEvict)) {
-            boolean evictFromThisRegion = true;
-          if (HeapEvictor.EVICT_HIGH_ENTRY_COUNT_BUCKETS_FIRST && _getOwner() instanceof BucketRegion) {
+        while (bytesToEvict > 0 && _getCCHelper().mustEvict(stats, _getOwner(), bytesToEvict)) {
+          boolean evictFromThisRegion = true;
+          if (HeapEvictor.EVICT_HIGH_ENTRY_COUNT_BUCKETS_FIRST
+              && _getOwner() instanceof BucketRegion) {
-            List<BucketRegion> regions = ((BucketRegion)_getOwner())
-                .getPartitionedRegion().getSortedBuckets();
+            List<BucketRegion> regions =
+                ((BucketRegion) _getOwner()).getPartitionedRegion().getSortedBuckets();
-              //only primaries can trigger inline eviction fix for 41814
-          	  if(!region.getBucketAdvisor().isPrimary()){       	
-              try {
-                bytesEvicted = ((AbstractLRURegionMap)region.entries)
-                    .centralizedLruUpdateCallback();
-                if (bytesEvicted == 0) {
-                  iter.remove();
-                } else {
-                  evictFromThisRegion = false;
-                }
-                totalBytesEvicted += bytesEvicted;
-                bytesToEvict -= bytesEvicted;
-                if(bytesEvicted > bytesToEvict){
-                  bytesToEvict = 0;
-                  break;
-                }                  
-                if(totalBytesEvicted > bytesToEvict) {
-                  break;
+              // only primaries can trigger inline eviction fix for 41814
+              if (!region.getBucketAdvisor().isPrimary()) {
+                try {
+                  bytesEvicted =
+                      ((AbstractLRURegionMap) region.entries).centralizedLruUpdateCallback();
+                  if (bytesEvicted == 0) {
+                    iter.remove();
+                  } else {
+                    evictFromThisRegion = false;
+                  }
+                  totalBytesEvicted += bytesEvicted;
+                  bytesToEvict -= bytesEvicted;
+                  if (bytesEvicted > bytesToEvict) {
+                    bytesToEvict = 0;
+                    break;
+                  }
+                  if (totalBytesEvicted > bytesToEvict) {
+                    break;
+                  }
+                } catch (RegionDestroyedException rd) {
+                  region.cache.getCancelCriterion().checkCancelInProgress(rd);
+                } catch (Exception e) {
+                  region.cache.getCancelCriterion().checkCancelInProgress(e);
+                  logger.warn(
+                      LocalizedMessage.create(LocalizedStrings.Eviction_EVICTOR_TASK_EXCEPTION,
+                          new Object[] {e.getMessage()}),
+                      e);
-              catch (RegionDestroyedException rd) {
-                region.cache.getCancelCriterion().checkCancelInProgress(rd);
-              }
-              catch (Exception e) {
-                region.cache.getCancelCriterion().checkCancelInProgress(e);
-                logger.warn(LocalizedMessage.create(LocalizedStrings.Eviction_EVICTOR_TASK_EXCEPTION,
-                    new Object[] { e.getMessage() }), e);
-              }
-            }
-          if(evictFromThisRegion) {
-            LRUEntry removalEntry = (LRUEntry)_getLruList().getLRUEntry();
+          if (evictFromThisRegion) {
+            LRUEntry removalEntry = (LRUEntry) _getLruList().getLRUEntry();
-                  logger.trace(LogMarker.LRU, "evicted entry key={} total entry size is now: {} bytesToEvict :{}",
+                  logger.trace(LogMarker.LRU,
+                      "evicted entry key={} total entry size is now: {} bytesToEvict :{}",
-                    ((BucketRegion)_getOwner()).incEvictions(1);
+                    ((BucketRegion) _getOwner()).incEvictions(1);
-            }
-            else {
+            } else {
-      }
-      catch (RegionClearedException e) {
+      } catch (RegionClearedException e) {
-    }
-    else {
+    } else {
-          LRUEntry removalEntry = (LRUEntry)_getLruList().getLRUEntry();
+          LRUEntry removalEntry = (LRUEntry) _getLruList().getLRUEntry();
-                logger.trace(LogMarker.LRU, "evicted entry key(2)={} total entry size is now: {} bytesToEvict :",
-                  removalEntry.getKey(), getTotalEntrySize(), bytesToEvict);
+                logger.trace(LogMarker.LRU,
+                    "evicted entry key(2)={} total entry size is now: {} bytesToEvict :",
+                    removalEntry.getKey(), getTotalEntrySize(), bytesToEvict);
-                  ((BucketRegion)_getOwner()).incEvictions(1);
+                  ((BucketRegion) _getOwner()).incEvictions(1);
-          }
-          else {
+          } else {
-      }
-      catch (RegionClearedException e) {
+      } catch (RegionClearedException e) {
-      logger.trace(LogMarker.LRU, "callback complete.  LRU size is now {}", _getLruList().stats().getCounter());
+      logger.trace(LogMarker.LRU, "callback complete.  LRU size is now {}",
+          _getLruList().stats().getCounter());
- } 
-  
+  }
+
-    
+
-    
+
-  
+
-    
+
-      logger.trace(LogMarker.LRU, "centralLruUpdateCallback: lru size is now {}, limit is: {}", getTotalEntrySize(), getLimit());
+      logger.trace(LogMarker.LRU, "centralLruUpdateCallback: lru size is now {}, limit is: {}",
+          getTotalEntrySize(), getLimit());
-        LRUEntry removalEntry = (LRUEntry)_getLruList().getLRUEntry();
+        LRUEntry removalEntry = (LRUEntry) _getLruList().getLRUEntry();
-              ((BucketRegion)_getOwner()).incEvictions(1);
+              ((BucketRegion) _getOwner()).incEvictions(1);
-        }
-        else {
+        } else {
-    }
-    catch (RegionClearedException rce) {
+    } catch (RegionClearedException rce) {
-  
- 
-  
+
+
+
-      logger.trace(LogMarker.LRU, "updateStats - delta is: {} total is: {} limit is: {}", delta, getTotalEntrySize(), getLimit());
+      logger.trace(LogMarker.LRU, "updateStats - delta is: {} total is: {} limit is: {}", delta,
+          getTotalEntrySize(), getLimit());
-  
+
+
-  //TODO rebalancing these methods are new on the
-  //rebalancing branch but never used???
+
+  // TODO rebalancing these methods are new on the
+  // rebalancing branch but never used???
+
-  
+
-  public final Set<VersionSource> clear(RegionVersionVector rvv)
-  {
+  public final Set<VersionSource> clear(RegionVersionVector rvv) {
-  
-  /*Asif :
-   * Motivation: An entry which is no longer existing in the system due to clear
-   * operation, should not be present the LRUList being used by the region.
+
+  /*
+   * Asif : Motivation: An entry which is no longer existing in the system due to clear operation,
+   * should not be present the LRUList being used by the region.
-   * Case1 : An entry has been written to disk & on its return code path, it 
-   * invokes lruCreate or lruUpdate. Before starting the operation of writing to disk,
-   * the HTree reference is set in the threadlocal. A clear operation changes
-   * the Htree reference in a write lock.
-   * Thus if the htree reference has not changed till this point, it would mean either
-   * the entry is still valid or a clear operation is in progress but has not changed the 
-   * Htree Reference . Since we store the LRUList in a local variable, it implies that if 
-   * clear occurs , it will go in the stale list & if not it goes in the right list.
-   * Both ways we are safe.
+   * Case1 : An entry has been written to disk & on its return code path, it invokes lruCreate or
+   * lruUpdate. Before starting the operation of writing to disk, the HTree reference is set in the
+   * threadlocal. A clear operation changes the Htree reference in a write lock. Thus if the htree
+   * reference has not changed till this point, it would mean either the entry is still valid or a
+   * clear operation is in progress but has not changed the Htree Reference . Since we store the
+   * LRUList in a local variable, it implies that if clear occurs , it will go in the stale list &
+   * if not it goes in the right list. Both ways we are safe.
-   * Case 2: The Htree reference has changed ( implying a clear conflic with put)
-   *  but the entry is valid. This is possible as we first set the Htree Ref in thread local.
-   *  Now before the update operation has acquired the entry , clear happens. As a result
-   *  the update operation has become create. Since the clear changes the Htree Ref & the LRUList
-   *  in a write lock & hence by the time the original update operation acquires the read lock,
-   *  the LRUList  has already been changed by clear. Now in the update operation's return path
-   *  the List which it stores in local variable is bound to be the new List. 
-   *  Since our code checks if the entry reference exists in the region in case of conflict
-   *  & if yes, we append the entry to the List. It is guaranteed to be added to the 
-   *  new List.
-   *  
-   *    Also it is necessary that when we clear the region, first the concurrent map of the region
-   *    containing entries needs to be cleared. The Htree Reference should be reset after 
-   *    that. And then we should be resetting the LRUList. 
-   *    Previously the Htree  reference was being set before clearing the Map. This caused
-   *    Bug 37606. 
-   *    If the order of clear operation on disk region is ( incorrect ) 
-   *    1) map.clear 2) Resetting the LRUList 3) Changing the Htree ref 
-   *    Then following bug  can occur.,
-   *    During entry operation on its return path, invokes lruUpdate/lruCreate. 
-   *    By that time the clear proceeds & it has reset the LRUList & cleared the entries.
-   *    But as the Htree ref has not changed, we would take the locally available LRUList
-   *    ( which may be the new List) & append the entry to the List.
-   *    
+   * Case 2: The Htree reference has changed ( implying a clear conflic with put) but the entry is
+   * valid. This is possible as we first set the Htree Ref in thread local. Now before the update
+   * operation has acquired the entry , clear happens. As a result the update operation has become
+   * create. Since the clear changes the Htree Ref & the LRUList in a write lock & hence by the time
+   * the original update operation acquires the read lock, the LRUList has already been changed by
+   * clear. Now in the update operation's return path the List which it stores in local variable is
+   * bound to be the new List. Since our code checks if the entry reference exists in the region in
+   * case of conflict & if yes, we append the entry to the List. It is guaranteed to be added to the
+   * new List.
+   * 
+   * Also it is necessary that when we clear the region, first the concurrent map of the region
+   * containing entries needs to be cleared. The Htree Reference should be reset after that. And
+   * then we should be resetting the LRUList. Previously the Htree reference was being set before
+   * clearing the Map. This caused Bug 37606. If the order of clear operation on disk region is (
+   * incorrect ) 1) map.clear 2) Resetting the LRUList 3) Changing the Htree ref Then following bug
+   * can occur., During entry operation on its return path, invokes lruUpdate/lruCreate. By that
+   * time the clear proceeds & it has reset the LRUList & cleared the entries. But as the Htree ref
+   * has not changed, we would take the locally available LRUList ( which may be the new List) &
+   * append the entry to the List.
-  */
+   * 
+   */
-    LRUEntry e = (LRUEntry)re;
+    LRUEntry e = (LRUEntry) re;
-          re.getKey(), getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(), e.getEntrySize(), !e.testEvicted());
+          re.getKey(), getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(),
+          e.getEntrySize(), !e.testEvicted());
-//    this.lruCreatedKey = re.getKey(); // [ bruce ] for DEBUGGING only
+    // this.lruCreatedKey = re.getKey(); // [ bruce ] for DEBUGGING only
-    NewLRUClockHand lruList = _getLruList();   
-    DiskRegion disk =  _getOwner().getDiskRegion();
+    NewLRUClockHand lruList = _getLruList();
+    DiskRegion disk = _getOwner().getDiskRegion();
-    if(!possibleClear || this._getOwner().basicGetEntry(re.getKey()) == re ) {
+    if (!possibleClear || this._getOwner().basicGetEntry(re.getKey()) == re) {
-    }    
+    }
-  
+
-  protected final void lruEntryUpdate(RegionEntry re ) {
-    final LRUEntry e = (LRUEntry)re;
+  protected final void lruEntryUpdate(RegionEntry re) {
+    final LRUEntry e = (LRUEntry) re;
-        // Also lruEntryUpdate only happens on an lru. Do we need to call reset for the non-lru (expiration) case?
+        // Also lruEntryUpdate only happens on an lru. Do we need to call reset for the non-lru
+        // (expiration) case?
+
-    final LRUEntry e = (LRUEntry)re;
+    final LRUEntry e = (LRUEntry) re;
-          re.getKey(), getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(), e.getEntrySize(), !e.testEvicted());
+          re.getKey(), getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(),
+          e.getEntrySize(), !e.testEvicted());
-//    if (this.lruCreatedKey == re.getKey()) {
-//      String method = Thread.currentThread().getStackTrace()[5].getMethodName(); 
-//    }
-//    boolean wasEvicted = e.testEvicted();
-    /*boolean removed = */_getLruList().unlinkEntry(e);
-//    if (removed || wasEvicted) { // evicted entries have already been removed from the list
+    // if (this.lruCreatedKey == re.getKey()) {
+    // String method = Thread.currentThread().getStackTrace()[5].getMethodName();
+    // }
+    // boolean wasEvicted = e.testEvicted();
+    /* boolean removed = */_getLruList().unlinkEntry(e);
+    // if (removed || wasEvicted) { // evicted entries have already been removed from the list
-    if (vTok == Token.DESTROYED || vTok == Token.TOMBSTONE) { // OFFHEAP noop TODO: use re.isDestroyedOrTombstone
+    if (vTok == Token.DESTROYED || vTok == Token.TOMBSTONE) { // OFFHEAP noop TODO: use
+                                                              // re.isDestroyedOrTombstone
-//    } else if (debug) {
-//      debugLogging("entry not removed from LRU list");
-//    }
+    // } else if (debug) {
+    // debugLogging("entry not removed from LRU list");
+    // }
-  /** Called by DiskEntry.Helper.faultInValue
+
+  /**
+   * Called by DiskEntry.Helper.faultInValue
-  
+
-  
+

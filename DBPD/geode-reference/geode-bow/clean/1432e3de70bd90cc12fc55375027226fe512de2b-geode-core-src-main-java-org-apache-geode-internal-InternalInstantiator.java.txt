Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
+import java.util.Collection;
+import java.util.Iterator;
-import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.cache.Cache;
+  /** Maps Classes to their ids */
-  private static final ConcurrentMap<String, Instantiator> dsMap = new ConcurrentHashMap<>();
+  private static final ConcurrentMap/* <String,Instantiator> */ dsMap = new ConcurrentHashMap();
-  private static final ConcurrentMap<Integer, Object> idsToInstantiators =
-      new ConcurrentHashMap<>();
+  private static final ConcurrentMap/* <Integer,Instantiator|Marker> */ idsToInstantiators =
+      new ConcurrentHashMap();
-      new ConcurrentHashMap<>();
+      new ConcurrentHashMap<String, InstantiatorAttributesHolder>();
-  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders;
-
-  static {
-    idsToHolders = new ConcurrentHashMap<>();
-  }
+  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders =
+      new ConcurrentHashMap<Integer, InstantiatorAttributesHolder>();
-    // Skip the checkForThread() check if the instantiation is not
+    // [sumedh] Skip the checkForThread() check if the instantiation has not
-      throw new NullPointerException("Cannot register a null Instantiator.");
+      throw new NullPointerException(
+          "Cannot register a null Instantiator.");
-      throw new IllegalArgumentException("Instantiator id cannot be zero");
+      throw new IllegalArgumentException(
+          "Instantiator id cannot be zero");
-        throw new IllegalStateException(String.format(
-            "Class %s is already registered with id %s so it can not be registered with id %s",
-            c.getName(), oldId, classId));
+        throw new IllegalStateException(
+            String.format(
+                "Class %s is already registered with id %s so it can not be registered with id %s",
+
+                new Object[] {c.getName(), Integer.valueOf(oldId), Integer.valueOf(classId)}));
-    final Integer idx = classId;
+    final Integer idx = Integer.valueOf(classId);
-              throw new IllegalStateException(String.format(
-                  "Class id %s is already registered for class %s so it could not be registered for class %s",
-                  classId, oldClass.getName(), cName));
+              throw new IllegalStateException(
+                  String.format(
+                      "Class id %s is already registered for class %s so it could not be registered for class %s",
+
+                      new Object[] {Integer.valueOf(classId), oldClass.getName(), cName}));
-              // it was already registered
-              return;
+              return; // it was already registered
-      setEventIdIfNew(instantiator);
+      // if instantiator is getting registered for first time
+      // its EventID will be null, so generate a new event id
+      // the the distributed system is connected
+      InternalCache cache = GemFireCacheImpl.getInstance();
+      if (cache != null && instantiator.getEventId() == null) {
+        instantiator.setEventId(new EventID(cache.getDistributedSystem()));
+      }
-      logger.info("Instantiator registered with id {} class {}", classId, c.getName());
+      logger
+          .info("Instantiator registered with id {} class {}",
+              Integer.valueOf(classId), c.getName());
-    if (distribute) {
-      // originated in this VM
+    if (distribute) { // originated in this VM
+      // send a message to other peers telling them about a newly-registered
+      // instantiator, it also send event id of the originator along with the
+      // instantiator
+      // send it to cache servers if it is a client
+    // send it to all cache clients irrelevant of distribute
+    // cache servers send it all the clients irrelevant of
+    // originator VM
-   * if instantiator is getting registered for first time its EventID will be null, so generate a
-   * new event id the the distributed system is connected
-   */
-  private static void setEventIdIfNew(final Instantiator instantiator) {
-    final InternalCache cache = getInternalCache();
-    if (cache != null && instantiator.getEventId() == null) {
-      instantiator.setEventId(new EventID(cache.getDistributedSystem()));
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  private static InternalCache getInternalCache() {
-    return GemFireCacheImpl.getInstance();
-  }
-
-  /**
-    if (isCacheCreated()) {
-      return new EventID(InternalDistributedSystem.getAnyInstance());
+    InternalCache cache = GemFireCacheImpl.getInstance();
+    if (cache == null) {
+      // A cache has not yet created
+      return null;
-    return null;
+    return new EventID(InternalDistributedSystem.getAnyInstance());
-    if (!isCacheCreated()) {
+    Cache cache = GemFireCacheImpl.getInstance();
+    if (cache == null) {
+      // A cache has not yet been created.
+      // we can't propagate it to clients
-  private static boolean isCacheCreated() {
-    return getInternalCache() != null;
-  }
-
-    Object inst;
+    Object inst = null;
-          throw new IllegalArgumentException("Instantiator id cannot be zero");
+          throw new IllegalArgumentException(
+              "Instantiator id cannot be zero");
-          throw new IllegalStateException(String.format(
-              "Class %s is already registered with id %s so it can not be registered with id %s",
-              instantiatorClassName, iah.getId(), holder.getId()));
+          throw new IllegalStateException(
+              String.format(
+                  "Class %s is already registered with id %s so it can not be registered with id %s",
+
+                  new Object[] {instantiatorClassName, iah.getId(), holder.getId()}));
-        logger.info("Instantiator registered with holder id {} class {}", holder.getId(),
+        logger.info("Instantiator registered with holder id {} class {}",
+            Integer.valueOf(holder.getId()),
+        // fix bug 46355, need to move getCachedClass() outside of sync
-      } catch (ClassNotFoundException e) {
-        logClassNotFoundException(e);
+      } catch (ClassNotFoundException cnfe) {
+        InternalCache cache = GemFireCacheImpl.getInstance();
+        if (cache != null && cache.getLogger() != null && cache.getLogger().infoEnabled()) {
+          cache.getLogger().info(
+              String.format("Could not load instantiator class: %s",
+                  new Object[] {cnfe.getMessage()}));
+        }
+            // recurse
+          } else {
+            // already registered
+            return;
-  private static void logClassNotFoundException(final ClassNotFoundException e) {
-    final InternalCache cache = getInternalCache();
-    if (cache != null && cache.getLogger() != null && cache.getLogger().infoEnabled()) {
-      cache.getLogger()
-          .info(String.format("Could not load instantiator class: %s", e.getMessage()));
-    }
-  }
-
-    InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
+    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
-      instantiatorName = instantiatorClass;
-      instantiatedName = instantiatedClass;
+      this.instantiatorName = instantiatorClass;
+      this.instantiatedName = instantiatedClass;
-    InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
+    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
-      instantiatorName = instantiatorClass;
-      instantiatedName = instantiatedClass;
+      this.instantiatorName = instantiatorClass;
+      this.instantiatedName = instantiatedClass;
-      return "InstantiatorAttributesHolder[irName=" + instantiatorName + ",idName="
-          + instantiatedName + ",id=" + id
-          + (eventId != null ? ",this.eventId=" + eventId : "")
-          + (context != null ? ",this.context=" + context : "") + "]";
+      return "InstantiatorAttributesHolder[irName=" + this.instantiatorName + ",idName="
+          + this.instantiatedName + ",id=" + this.id
+          + (this.eventId != null ? ",this.eventId=" + this.eventId : "")
+          + (this.context != null ? ",this.context=" + this.context : "") + "]";
-    final Integer idx = classId;
+    final Integer idx = Integer.valueOf(classId);
-          String.format("Class %s was not registered with id %s", c.getName(), classId));
+          String.format("Class %s was not registered with id %s",
+              new Object[] {c.getName(), Integer.valueOf(classId)}));
-  /**
-   * testhook that removes all registed instantiators
-   */
-  @VisibleForTesting
+  // testhook that removes all registed instantiators
-    final Instantiator i = dsMap.get(c.getName());
+    final Instantiator i = (Instantiator) dsMap.get(c.getName());
-    final Integer idx = classId;
+    final Integer idx = Integer.valueOf(classId);
-        } catch (ClassNotFoundException e) {
-          logClassNotFoundException(e);
+        } catch (ClassNotFoundException cnfe) {
+          InternalCache cache = GemFireCacheImpl.getInstance();
+          if (cache != null && cache.getLogger() != null
+              && cache.getLogger().infoEnabled()) {
+            cache.getLogger().info(
+                String.format("Could not load instantiator class: %s", cnfe.getMessage()));
+          }
-      RegistrationMessage m;
+      RegistrationMessage m = null;
-  protected static Instantiator newInstance(Class<?> instantiatorClass, Class<?> instantiatedClass,
-      int id) throws IllegalArgumentException {
+  protected static Instantiator newInstance(Class instantiatorClass, Class instantiatedClass,
+      int id) {
+    Class[] types;
-      init = instantiatorClass.getDeclaredConstructor(Class.class, int.class);
+      types = new Class[] {Class.class, int.class};
+      init = instantiatorClass.getDeclaredConstructor(types);
-        init = instantiatorClass.getDeclaredConstructor(Class.class, byte.class);
+        types = new Class[] {Class.class, byte.class};
+        init = instantiatorClass.getDeclaredConstructor(types);
-          throw new IllegalArgumentException(String.format(
+          String msg = String.format(
-              instantiatorClass.getName(), instantiatorClass.getDeclaringClass()));
+              instantiatorClass.getName(), instantiatorClass.getDeclaringClass());
+          throw new IllegalArgumentException(msg);
-        throw new IllegalArgumentException(
-            String.format("Class %s does not have a two-argument (Class, int) constructor.",
-                instantiatorClass.getName()));
+        String msg = String.format(
+            "Class %s does not have a two-argument (Class, int) constructor.",
+            instantiatorClass.getName());
+        throw new IllegalArgumentException(msg);
-      s = (Instantiator) init.newInstance(instantiatedClass, convertId(id, intConstructor));
+      Object[] args = new Object[] {instantiatedClass,
+          intConstructor ? (Object) Integer.valueOf(id) : (Object) Byte.valueOf((byte) id)};
+      s = (Instantiator) init.newInstance(args);
+
-      throw new IllegalArgumentException(String
-          .format("Could not access zero-argument constructor of %s", instantiatorClass.getName()));
+      throw new IllegalArgumentException(
+          String.format("Could not access zero-argument constructor of %s",
+              instantiatorClass.getName()));
-      throw new IllegalArgumentException(
-          String.format("Could not instantiate an instance of %s", instantiatorClass.getName()),
-          ex);
+      RuntimeException ex2 = new IllegalArgumentException(
+          String.format("Could not instantiate an instance of %s",
+              instantiatorClass.getName()));
+      ex2.initCause(ex);
+      throw ex2;
-      throw new IllegalArgumentException(
-          String.format("While instantiating an instance of %s", instantiatorClass.getName()), ex);
+      RuntimeException ex2 = new IllegalArgumentException(
+          String.format("While instantiating an instance of %s",
+              instantiatorClass.getName()));
+      ex2.initCause(ex);
+      throw ex2;
-  private static Object convertId(int id, boolean asInteger) {
-    if (asInteger) {
-      return id;
-    }
-    return (byte) id;
-  }
-
+    Collection coll = new ArrayList();
-      for (InstantiatorAttributesHolder holder : classNamesToHolders.values()) {
+      Iterator it = classNamesToHolders.values().iterator();
+      while (it.hasNext()) {
+          InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) it.next();
-        } catch (ClassNotFoundException e) {
-          logClassNotFoundException(e);
+        } catch (ClassNotFoundException cnfe) {
+          InternalCache cache = GemFireCacheImpl.getInstance();
+          if (cache != null && cache.getLogger() != null
+              && cache.getLogger().infoEnabled()) {
+            cache.getLogger().info(
+                String.format("Could not load instantiator class: %s",
+                    cnfe.getMessage()));
+          }
-    return dsMap.values().toArray(new Instantiator[0]);
+    coll.addAll(dsMap.values()); // Don't move it before the if block above.
+    return (Instantiator[]) coll.toArray(new Instantiator[coll.size()]);
-    ArrayList<Object> instantiators = new ArrayList<>(dsMap.size() + idsToHolders.size());
-    instantiators.addAll(dsMap.values());
-    instantiators.addAll(classNamesToHolders.values());
-    return instantiators.toArray();
+    Collection coll = new ArrayList(dsMap.size() + idsToHolders.size());
+    coll.addAll(dsMap.values());
+    coll.addAll(classNamesToHolders.values()); // TODO (ashetkar) will it add duplicates?
+    return coll.toArray(new Object[coll.size()]);
+  public static int getIdsToHoldersSize() {
+    return idsToHolders.size();
+  }
+
+  public static int getNamesToHoldersSize() {
+    return classNamesToHolders.size();
+  }
+  /////////////////////// Inner Classes ///////////////////////
+
-        if (instantiator == null) {
+        if (this.instantiator == null) {
-            wait(InternalDataSerializer.GetMarker.WAIT_MS);
+            this.wait(InternalDataSerializer.GetMarker.WAIT_MS);
-        return instantiator;
+        return this.instantiator;
-        notifyAll();
+        this.notifyAll();
+   * Persist this class's map to out
+   */
+  public static void saveRegistrations(DataOutput out) throws IOException {
+    for (Instantiator inst : InternalInstantiator.getInstantiators()) {
+      out.writeInt(inst.getId());
+      DataSerializer.writeClass(inst.getClass(), out);
+      DataSerializer.writeClass(inst.getInstantiatedClass(), out);
+    }
+    // We know that Instantiator id's must not be 0 so write a zero
+    // to mark then end of the instantiators.
+    out.writeInt(0);
+  }
+
+  /**
+   * Read the data from in and register it with this class.
+   *
+   * @throws IllegalArgumentException if a registration fails
+   */
+  public static void loadRegistrations(DataInput in) throws IOException {
+    int instId;
+    while ((instId = in.readInt()) != 0) {
+      Class instClass = null;
+      Class instantiatedClass = null;
+      boolean skip = false;
+      try {
+        instClass = DataSerializer.readClass(in);
+      } catch (ClassNotFoundException ex) {
+        skip = true;
+      }
+      try {
+        instantiatedClass = DataSerializer.readClass(in);
+      } catch (ClassNotFoundException ex) {
+        skip = true;
+      }
+      if (skip) {
+        continue;
+      }
+      register(newInstance(instClass, instantiatedClass, instId), true);
+    }
+  }
+
+  /**
-    Class instantiatorClass;
+    protected Class instantiatorClass;
-    Class instantiatedClass;
+    protected Class instantiatedClass;
-    transient StringBuffer fromDataProblems;
+    protected transient StringBuffer fromDataProblems;
-    String instantiatorClassName;
+    protected String instantiatorClassName;
-    String instantiatedClassName;
+    protected String instantiatedClassName;
-      instantiatorClass = s.getClass();
-      instantiatedClass = s.getInstantiatedClass();
-      id = s.getId();
-      eventId = (EventID) s.getEventId();
+      this.instantiatorClass = s.getClass();
+      this.instantiatedClass = s.getInstantiatedClass();
+      this.id = s.getId();
+      this.eventId = (EventID) s.getEventId();
-      if (fromDataProblems != null) {
+      if (this.fromDataProblems != null) {
-          logger.debug(fromDataProblems);
+          logger.debug(this.fromDataProblems);
-      if (instantiatorClass != null && instantiatedClass != null) {
-        Instantiator s = newInstance(instantiatorClass, instantiatedClass, id);
+      if (this.instantiatorClass != null && this.instantiatedClass != null) {
+        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
-      } else if (instantiatorClassName != null && instantiatedClassName != null) {
-        InternalInstantiator.register(instantiatorClassName, instantiatedClassName,
-            id, false, eventId, null);
+      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
+        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
+            this.id, false, this.eventId, null);
-      DataSerializer.writeNonPrimitiveClassName(instantiatorClass.getName(), out);
-      DataSerializer.writeNonPrimitiveClassName(instantiatedClass.getName(), out);
-      out.writeInt(id);
-      DataSerializer.writeObject(eventId, out);
+      DataSerializer.writeNonPrimitiveClassName(this.instantiatorClass.getName(), out);
+      DataSerializer.writeNonPrimitiveClassName(this.instantiatedClass.getName(), out);
+      out.writeInt(this.id);
+      DataSerializer.writeObject(this.eventId, out);
-      if (fromDataProblems == null) {
-        fromDataProblems = new StringBuffer();
+      if (this.fromDataProblems == null) {
+        this.fromDataProblems = new StringBuffer();
-      fromDataProblems.append(s);
-      fromDataProblems.append("\n\n");
+      this.fromDataProblems.append(s);
+      this.fromDataProblems.append("\n\n");
-      instantiatorClassName = DataSerializer.readNonPrimitiveClassName(in);
-      instantiatedClassName = DataSerializer.readNonPrimitiveClassName(in);
+      this.instantiatorClassName = DataSerializer.readNonPrimitiveClassName(in);
+      this.instantiatedClassName = DataSerializer.readNonPrimitiveClassName(in);
-          instantiatorClass = InternalDataSerializer.getCachedClass(instantiatorClassName);
+          this.instantiatorClass =
+              InternalDataSerializer.getCachedClass(this.instantiatorClassName); // fix for bug
+                                                                                 // 41206
-          recordFromDataProblem(String.format("Could not load instantiator class: %s", ex));
-          instantiatorClass = null;
+          recordFromDataProblem(
+              String.format("Could not load instantiator class: %s",
+                  ex));
+          this.instantiatorClass = null;
-          instantiatedClass = InternalDataSerializer.getCachedClass(instantiatedClassName);
+          this.instantiatedClass =
+              InternalDataSerializer.getCachedClass(this.instantiatedClassName); // fix for bug
+                                                                                 // 41206
-          recordFromDataProblem(String.format("Could not load instantiated class: %s", ex));
-          instantiatedClass = null;
+          recordFromDataProblem(
+              String.format("Could not load instantiated class: %s",
+                  ex));
+          this.instantiatedClass = null;
-      id = in.readInt();
-      eventId = DataSerializer.readObject(in);
+      this.id = in.readInt();
+      this.eventId = (EventID) DataSerializer.readObject(in);
-      String instatiatorName = (instantiatorClass == null) ? instantiatorClassName
-          : instantiatorClass.getName();
-      String instatiatedName = (instantiatedClass == null) ? instantiatedClassName
-          : instantiatedClass.getName();
-      return String.format("Register Instantiator %s of class %s that instantiates a %s", id,
-          instatiatorName, instatiatedName);
+      String instatiatorName = (this.instantiatorClass == null) ? this.instantiatorClassName
+          : this.instantiatorClass.getName();
+      String instatiatedName = (this.instantiatedClass == null) ? this.instantiatedClassName
+          : this.instantiatedClass.getName();
+      return String.format("Register Instantiator %s of class %s that instantiates a %s",
+
+          new Object[] {Integer.valueOf(this.id), instatiatorName, instatiatedName});
-      instantiatorClass = s.getClass();
-      instantiatedClass = s.getInstantiatedClass();
-      id = s.getId();
-      eventId = (EventID) s.getEventId();
-      context = (ClientProxyMembershipID) s.getContext();
+      this.instantiatorClass = s.getClass();
+      this.instantiatedClass = s.getInstantiatedClass();
+      this.id = s.getId();
+      this.eventId = (EventID) s.getEventId();
+      this.context = (ClientProxyMembershipID) s.getContext();
-      if (instantiatorClass != null && instantiatedClass != null) {
-        Instantiator s = newInstance(instantiatorClass, instantiatedClass, id);
-        s.setEventId(eventId);
-        s.setContext(context);
+      if (this.instantiatorClass != null && this.instantiatedClass != null) {
+        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
+        s.setEventId(this.eventId);
+        s.setContext(this.context);
-      } else if (instantiatorClassName != null && instantiatedClassName != null) {
-        InternalInstantiator.register(instantiatorClassName, instantiatedClassName,
-            id, false, eventId, context);
+      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
+        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
+            this.id, false, this.eventId, this.context);
-      context = ClientProxyMembershipID.readCanonicalized(in);
+      this.context = ClientProxyMembershipID.readCanonicalized(in);
-      DataSerializer.writeObject(context, out);
+      DataSerializer.writeObject(this.context, out);
-    for (Instantiator instantiator : dsMap.values()) {
-      logger.info("Instantiator registered with id {} class {}", instantiator.getId(),
-          instantiator.getInstantiatedClass().getName());
+    for (Iterator itr = dsMap.values().iterator(); itr.hasNext();) {
+      Instantiator instantiator = (Instantiator) itr.next();
+
+      logger
+          .info("Instantiator registered with id {} class {}",
+              Integer.valueOf(instantiator.getId()),
+              instantiator.getInstantiatedClass().getName());
-    for (InstantiatorAttributesHolder holder : idsToHolders.values()) {
-      logger.info("Instantiator registered with holder id {} class {}", holder.getId(),
-          holder.getInstantiatedClassName());
+    for (Iterator itr = idsToHolders.values().iterator(); itr.hasNext();) {
+      InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) itr.next();
+
+      logger.info("Instantiator registered with holder id {} class {}",
+          Integer.valueOf(holder.getId()), holder.getInstantiatedClassName());

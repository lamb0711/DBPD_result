Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The GeodeRedisServer is a server that understands the Redis protocol. As
- * commands are sent to the server, each command is picked up by a thread,
- * interpreted and then executed and a response is sent back to the client. The
- * default connection port is 6379 but that can be altered when run through GFSH
- * or started through the provided static main class.
+ * The GeodeRedisServer is a server that understands the Redis protocol. As commands are sent to the
+ * server, each command is picked up by a thread, interpreted and then executed and a response is
+ * sent back to the client. The default connection port is 6379 but that can be altered when run
+ * through GFSH or started through the provided static main class.
- * Each Redis data type instance is stored in a separate {@link Region} except
- * for the Strings and HyperLogLogs which are collectively stored in one Region
- * respectively. That Region along with a meta data region used internally are 
- * protected so the client may not store keys with the name {@link GeodeRedisServer#REDIS_META_DATA_REGION}
- * or {@link GeodeRedisServer#STRING_REGION}. The default Region type is
- * {@link RegionShortcut#PARTITION} although this can be changed by specifying the
- * SystemProperty {@value #DEFAULT_REGION_SYS_PROP_NAME} to a type defined by {@link RegionShortcut}.
- * If the {@link GeodeRedisServer#NUM_THREADS_SYS_PROP_NAME} system property is set to 0,
- * one thread per client will be created. Otherwise a worker thread pool of specified size is
- * used or a default size of 4 * {@link Runtime#availableProcessors()} if the property is not set.
+ * Each Redis data type instance is stored in a separate {@link Region} except for the Strings and
+ * HyperLogLogs which are collectively stored in one Region respectively. That Region along with a
+ * meta data region used internally are protected so the client may not store keys with the name
+ * {@link GeodeRedisServer#REDIS_META_DATA_REGION} or {@link GeodeRedisServer#STRING_REGION}. The
+ * default Region type is {@link RegionShortcut#PARTITION} although this can be changed by
+ * specifying the SystemProperty {@value #DEFAULT_REGION_SYS_PROP_NAME} to a type defined by
+ * {@link RegionShortcut}. If the {@link GeodeRedisServer#NUM_THREADS_SYS_PROP_NAME} system property
+ * is set to 0, one thread per client will be created. Otherwise a worker thread pool of specified
+ * size is used or a default size of 4 * {@link Runtime#availableProcessors()} if the property is
+ * not set.
- * Supported String commands - APPEND, BITCOUNT, BITOP, BITPOS, DECR, DECRBY, 
- * GET, GETBIT, GETRANGE, GETSET, INCR, INCRBY, INCRBYFLOAT, MGET, MSET, MSETNX,
- * PSETEX, SET, SETBIT, SETEX, SETNX, STRLEN
+ * Supported String commands - APPEND, BITCOUNT, BITOP, BITPOS, DECR, DECRBY, GET, GETBIT, GETRANGE,
+ * GETSET, INCR, INCRBY, INCRBYFLOAT, MGET, MSET, MSETNX, PSETEX, SET, SETBIT, SETEX, SETNX, STRLEN
- * Supported List commands - LINDEX, LLEN, LPOP, LPUSH, LPUSHX, LRANGE,
- * LREM, LSET, LTRIM, RPOP, RPUSH, RPUSHX
+ * Supported List commands - LINDEX, LLEN, LPOP, LPUSH, LPUSHX, LRANGE, LREM, LSET, LTRIM, RPOP,
+ * RPUSH, RPUSHX
- * Supported Hash commands - HDEL, HEXISTS, HGET, HGETALL, HINCRBY, HINCRBYFLOAT,
- * HKEYS, HMGET, HMSET, HSETNX, HLEN, HSCAN, HSET, HVALS
+ * Supported Hash commands - HDEL, HEXISTS, HGET, HGETALL, HINCRBY, HINCRBYFLOAT, HKEYS, HMGET,
+ * HMSET, HSETNX, HLEN, HSCAN, HSET, HVALS
- * Supported Set commands - SADD, SCARD, SDIFF, SDIFFSTORE, SINTER,
- * SINTERSTORE, SISMEMBER, SMEMBERS, SMOVE, SREM, SPOP, SRANDMEMBER, 
- * SCAN, SUNION, SUNIONSTORE
+ * Supported Set commands - SADD, SCARD, SDIFF, SDIFFSTORE, SINTER, SINTERSTORE, SISMEMBER,
+ * SMEMBERS, SMOVE, SREM, SPOP, SRANDMEMBER, SCAN, SUNION, SUNIONSTORE
- * Supported SortedSet commands - ZADD, ZCARD, ZCOUNT, ZINCRBY, ZLEXCOUNT,
- * ZRANGE, ZRANGEBYLEX, ZRANGEBYSCORE, ZRANK, ZREM, ZREMRANGEBYLEX,
- * ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYSCORE, ZREVRANK,
- * ZSCAN, ZSCORE
+ * Supported SortedSet commands - ZADD, ZCARD, ZCOUNT, ZINCRBY, ZLEXCOUNT, ZRANGE, ZRANGEBYLEX,
+ * ZRANGEBYSCORE, ZRANK, ZREM, ZREMRANGEBYLEX, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREVRANGE,
+ * ZREVRANGEBYSCORE, ZREVRANK, ZSCAN, ZSCORE
- * Supported Keys commands - DEL, DBSIZE, EXISTS, EXPIRE, EXPIREAT, FLUSHDB, FLUSHALL, 
- * KEYS, PERSIST, PEXPIRE, PEXPIREAT, PTTL, SCAN, TTL
+ * Supported Keys commands - DEL, DBSIZE, EXISTS, EXPIRE, EXPIREAT, FLUSHDB, FLUSHALL, KEYS,
+ * PERSIST, PEXPIRE, PEXPIREAT, PTTL, SCAN, TTL
- * The command executors are not explicitly documented but the functionality
- * can be found at <a href="http://redis.io/commands">Redis Commands</a>
+ * The command executors are not explicitly documented but the functionality can be found at
+ * <a href="http://redis.io/commands">Redis Commands</a>
- * Exceptions to the Redis Commands Documents:<p>
+ * Exceptions to the Redis Commands Documents:
+ * <p>
- * <li>Any command that removes keys and returns a count of removed
- * entries will not return a total remove count but rather a count of how
- * many entries have been removed that existed on the local vm, though 
- * all entries will be removed</li>
- * <li>Any command that returns a count of newly set members has an
- * unspecified return value. The command will work just as the Redis protocol
- * states but the count will not necessary reflect the number set compared
- * to overridden.</li>
- * <li>Transactions work just as they would on a Redis instance, they are local
- * transaction. Transactions cannot be executed on data that is not local to the 
- * executing server, that is on a partitioned region in a different server 
- * instance or on a persistent region that does not have transactions enabled.
- * Also, you cannot watch or unwatch keys as all keys within a GemFire 
+ * <li>Any command that removes keys and returns a count of removed entries will not return a total
+ * remove count but rather a count of how many entries have been removed that existed on the local
+ * vm, though all entries will be removed</li>
+ * <li>Any command that returns a count of newly set members has an unspecified return value. The
+ * command will work just as the Redis protocol states but the count will not necessary reflect the
+ * number set compared to overridden.</li>
+ * <li>Transactions work just as they would on a Redis instance, they are local transaction.
+ * Transactions cannot be executed on data that is not local to the executing server, that is on a
+ * partitioned region in a different server instance or on a persistent region that does not have
+ * transactions enabled. Also, you cannot watch or unwatch keys as all keys within a GemFire
-   * Temporary constant whether to use old single thread per connection
-   * model for worker group
+   * Temporary constant whether to use old single thread per connection model for worker group
-   * The field that defines the name of the {@link Region} which holds all of
-   * the strings. The current value of this field is {@value #STRING_REGION}.
+   * The field that defines the name of the {@link Region} which holds all of the strings. The
+   * current value of this field is {@value #STRING_REGION}.
-   * The field that defines the name of the {@link Region} which holds all of
-   * the HyperLogLogs. The current value of this field is {@value #HLL_REGION}.
+   * The field that defines the name of the {@link Region} which holds all of the HyperLogLogs. The
+   * current value of this field is {@value #HLL_REGION}.
-   * The field that defines the name of the {@link Region} which holds all of
-   * the Redis meta data. The current value of this field is {@value #REDIS_META_DATA_REGION}.
+   * The field that defines the name of the {@link Region} which holds all of the Redis meta data.
+   * The current value of this field is {@value #REDIS_META_DATA_REGION}.
-   * The system property name used to set the default {@link Region} creation
-   * type. The property name is {@value #DEFAULT_REGION_SYS_PROP_NAME} and the
-   * acceptable values are types defined by {@link RegionShortcut}, 
-   * i.e. "PARTITION" would be used for {@link RegionShortcut#PARTITION}.
+   * The system property name used to set the default {@link Region} creation type. The property
+   * name is {@value #DEFAULT_REGION_SYS_PROP_NAME} and the acceptable values are types defined by
+   * {@link RegionShortcut}, i.e. "PARTITION" would be used for {@link RegionShortcut#PARTITION}.
-   * System property name that can be used to set the number of threads to be
-   * used by the GeodeRedisServer
+   * System property name that can be used to set the number of threads to be used by the
+   * GeodeRedisServer
-   * Determine the {@link RegionShortcut} type from a String value.
-   * If the String value doesn't map to a RegionShortcut type then 
-   * {@link RegionShortcut#PARTITION} will be used by default.
+   * Determine the {@link RegionShortcut} type from a String value. If the String value doesn't map
+   * to a RegionShortcut type then {@link RegionShortcut#PARTITION} will be used by default.
-   * @return If the System property {@value #NUM_THREADS_SYS_PROP_NAME} is set then that number
-   * is used, otherwise 4 * # of cores
+   * @return If the System property {@value #NUM_THREADS_SYS_PROP_NAME} is set then that number is
+   *         used, otherwise 4 * # of cores
-   * Constructor for {@link GeodeRedisServer} that will start the
-   * server on the given port and bind to the first non-loopback address
+   * Constructor for {@link GeodeRedisServer} that will start the server on the given port and bind
+   * to the first non-loopback address
-   * @param port The port the server will bind to, will use {@value #DEFAULT_REDIS_SERVER_PORT} by default
+   * @param port The port the server will bind to, will use {@value #DEFAULT_REDIS_SERVER_PORT} by
+   *        default
-   * Constructor for {@link GeodeRedisServer} that will start the
-   * server and bind to the given address and port
+   * Constructor for {@link GeodeRedisServer} that will start the server and bind to the given
+   * address and port
-   * @param port The port the server will bind to, will use {@value #DEFAULT_REDIS_SERVER_PORT} by default if argument is less than or equal to 0
+   * @param port The port the server will bind to, will use {@value #DEFAULT_REDIS_SERVER_PORT} by
+   *        default if argument is less than or equal to 0
-   * Constructor for {@link GeodeRedisServer} that will start the
-   * server and bind to the given address and port. Keep in mind that the
-   * log level configuration will only be set if a {@link Cache} does not already
-   * exist, if one already exists then setting that property will have no effect.
+   * Constructor for {@link GeodeRedisServer} that will start the server and bind to the given
+   * address and port. Keep in mind that the log level configuration will only be set if a
+   * {@link Cache} does not already exist, if one already exists then setting that property will
+   * have no effect.
-   * @param port The port the server will bind to, will use {@value #DEFAULT_REDIS_SERVER_PORT} by default if argument is less than or equal to 0
+   * @param port The port the server will bind to, will use {@value #DEFAULT_REDIS_SERVER_PORT} by
+   *        default if argument is less than or equal to 0
-    this.expirationExecutor = Executors.newScheduledThreadPool(numExpirationThreads, new ThreadFactory() {
-      private final AtomicInteger counter = new AtomicInteger();
-      @Override
-      public Thread newThread(Runnable r) {
-        Thread t = new Thread(r);
-        t.setName("GemFireRedis-ScheduledExecutor-" + counter.incrementAndGet());
-        t.setDaemon(true);
-        return t;
-      }
+    this.expirationExecutor =
+        Executors.newScheduledThreadPool(numExpirationThreads, new ThreadFactory() {
+          private final AtomicInteger counter = new AtomicInteger();
-    });
+          @Override
+          public Thread newThread(Runnable r) {
+            Thread t = new Thread(r);
+            t.setName("GemFireRedis-ScheduledExecutor-" + counter.incrementAndGet());
+            t.setDaemon(true);
+            return t;
+          }
+
+        });
-    return this.bindAddress == null || this.bindAddress.isEmpty()
-        ? SocketCreator.getLocalHost()
-            : InetAddress.getByName(this.bindAddress);
+    return this.bindAddress == null || this.bindAddress.isEmpty() ? SocketCreator.getLocalHost()
+        : InetAddress.getByName(this.bindAddress);
-   * This is function to call on a {@link GeodeRedisServer} instance
-   * to start it running
+   * This is function to call on a {@link GeodeRedisServer} instance to start it running
-   * Initializes the {@link Cache}, and creates Redis necessities
-   * Region and protects declares that {@link Region} to be protected. 
-   * Also, every {@link GeodeRedisServer} will check for entries already in the
-   * meta data Region.
+   * Initializes the {@link Cache}, and creates Redis necessities Region and protects declares that
+   * {@link Region} to be protected. Also, every {@link GeodeRedisServer} will check for entries
+   * already in the meta data Region.
-          RegionFactory<ByteArrayWrapper, ByteArrayWrapper> regionFactory = gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
+          RegionFactory<ByteArrayWrapper, ByteArrayWrapper> regionFactory =
+              gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
-          RegionFactory<ByteArrayWrapper, HyperLogLogPlus> regionFactory = gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
+          RegionFactory<ByteArrayWrapper, HyperLogLogPlus> regionFactory =
+              gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
-          InternalRegionArguments ira = new InternalRegionArguments().setInternalRegion(true).setIsUsedForMetaRegion(true);
+          InternalRegionArguments ira =
+              new InternalRegionArguments().setInternalRegion(true).setIsUsedForMetaRegion(true);
-        InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString());
+        InternalGemFireError assErr = new InternalGemFireError(
+            LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString());
-      this.regionCache = new RegionProvider(stringsRegion, hLLRegion, redisMetaData, expirationFutures, expirationExecutor, this.DEFAULT_REGION_TYPE);
+      this.regionCache = new RegionProvider(stringsRegion, hLLRegion, redisMetaData,
+          expirationFutures, expirationExecutor, this.DEFAULT_REGION_TYPE);
-    for (Entry<String, RedisDataType> entry: entrySet) {
+    for (Entry<String, RedisDataType> entry : entrySet) {
-      if (newRegion == null && type != RedisDataType.REDIS_STRING && type != RedisDataType.REDIS_HLL && type != RedisDataType.REDIS_PROTECTED) {
+      if (newRegion == null && type != RedisDataType.REDIS_STRING && type != RedisDataType.REDIS_HLL
+          && type != RedisDataType.REDIS_PROTECTED) {
-          this.regionCache.createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(regionName), type);
+          this.regionCache
+              .createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(regionName), type);
-   * Helper method to start the server listening for connections. The
-   * server is bound to the port specified by {@link GeodeRedisServer#serverPort}
+   * Helper method to start the server listening for connections. The server is bound to the port
+   * specified by {@link GeodeRedisServer#serverPort}
+
+
-    b.group(bossGroup, workerGroup)
-    .channel(socketClass)
-    .childHandler(new ChannelInitializer<SocketChannel>() {
-      @Override
-      public void initChannel(SocketChannel ch) throws Exception {
-        if (logger.fineEnabled())
-          logger.fine("GeodeRedisServer-Connection established with " + ch.remoteAddress());
-        ChannelPipeline p = ch.pipeline();
-        p.addLast(ByteToCommandDecoder.class.getSimpleName(), new ByteToCommandDecoder());
-        p.addLast(ExecutionHandlerContext.class.getSimpleName(), new ExecutionHandlerContext(ch, cache, regionCache, GeodeRedisServer.this, pwdB));
-      }
-    })
-    .option(ChannelOption.SO_REUSEADDR, true)
-    .option(ChannelOption.SO_RCVBUF, getBufferSize())
-    .childOption(ChannelOption.SO_KEEPALIVE, true)
-    .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, GeodeRedisServer.connectTimeoutMillis)
-    .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
+    b.group(bossGroup, workerGroup).channel(socketClass)
+        .childHandler(new ChannelInitializer<SocketChannel>() {
+          @Override
+          public void initChannel(SocketChannel ch) throws Exception {
+            if (logger.fineEnabled())
+              logger.fine("GeodeRedisServer-Connection established with " + ch.remoteAddress());
+            ChannelPipeline p = ch.pipeline();
+            p.addLast(ByteToCommandDecoder.class.getSimpleName(), new ByteToCommandDecoder());
+            p.addLast(ExecutionHandlerContext.class.getSimpleName(),
+                new ExecutionHandlerContext(ch, cache, regionCache, GeodeRedisServer.this, pwdB));
+          }
+        }).option(ChannelOption.SO_REUSEADDR, true).option(ChannelOption.SO_RCVBUF, getBufferSize())
+        .childOption(ChannelOption.SO_KEEPALIVE, true)
+        .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, GeodeRedisServer.connectTimeoutMillis)
+        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
-      String logMessage = "GeodeRedisServer started {" + getBindAddress() + ":" + serverPort + "}, Selector threads: " + this.numSelectorThreads;
+      String logMessage = "GeodeRedisServer started {" + getBindAddress() + ":" + serverPort
+          + "}, Selector threads: " + this.numSelectorThreads;
-   * {@link RedisDataType#REDIS_LIST} or {@link RedisDataType#REDIS_SORTEDSET}
-   * was created then this function will call the necessary calls to create the 
-   * parameterized queries for those keys.
+   * {@link RedisDataType#REDIS_LIST} or {@link RedisDataType#REDIS_SORTEDSET} was created then this
+   * function will call the necessary calls to create the parameterized queries for those keys.
-      if (value != RedisDataType.REDIS_STRING && value != RedisDataType.REDIS_HLL && value != RedisDataType.REDIS_PROTECTED) {
+      if (value != RedisDataType.REDIS_STRING && value != RedisDataType.REDIS_HLL
+          && value != RedisDataType.REDIS_PROTECTED) {
-          this.regionCache.createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(key), value);
+          this.regionCache.createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(key),
+              value);
-   * When a key is removed then this function will make sure the associated
-   * queries with the key are also removed from each vm to avoid unnecessary
-   * data retention
+   * When a key is removed then this function will make sure the associated queries with the key are
+   * also removed from each vm to avoid unnecessary data retention
-      if (value != null && value != RedisDataType.REDIS_STRING && value != RedisDataType.REDIS_HLL && value != RedisDataType.REDIS_PROTECTED) {
+      if (value != null && value != RedisDataType.REDIS_STRING && value != RedisDataType.REDIS_HLL
+          && value != RedisDataType.REDIS_PROTECTED) {
-        if (r != null) { 
+        if (r != null) {
-   * Helper method to get GemFire set socket buffer size,
-   * possibly a default of 32k
+   * Helper method to get GemFire set socket buffer size, possibly a default of 32k
-   * Shutdown method for {@link GeodeRedisServer}. This closes the {@link Cache},
-   * interrupts all execution and forcefully closes all connections.
+   * Shutdown method for {@link GeodeRedisServer}. This closes the {@link Cache}, interrupts all
+   * execution and forcefully closes all connections.
-   * Static main method that allows the {@link GeodeRedisServer} to be
-   * started from the command line. The supported command line arguments are
-   * <p>-port=
-   * <br>-bind-address=
-   * <br>-log-level=
+   * Static main method that allows the {@link GeodeRedisServer} to be started from the command
+   * line. The supported command line arguments are
+   * <p>
+   * -port= <br>
+   * -bind-address= <br>
+   * -log-level=
-    for (String arg: args) {
+    for (String arg : args) {
-    while(true) {
+    while (true) {
-      } catch (InterruptedException e1) { 
+      } catch (InterruptedException e1) {
-   * @return The port number when the correct syntax was used, 
-   * otherwise will return {@link #DEFAULT_REDIS_SERVER_PORT}
+   * @return The port number when the correct syntax was used, otherwise will return
+   *         {@link #DEFAULT_REDIS_SERVER_PORT}

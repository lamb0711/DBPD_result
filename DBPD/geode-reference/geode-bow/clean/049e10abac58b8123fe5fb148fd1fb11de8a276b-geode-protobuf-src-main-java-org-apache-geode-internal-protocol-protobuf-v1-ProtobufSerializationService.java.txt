GEODE-4961: Allowing custom serialization formats with the protobuf protocol

Adding a new ValueSerializer interface that users can implement to
control the serialization format of data sent using the protobuf
protocol.

ValueSerializers are registered on the server side using the java
ServiceLoader mechanism. They are selected by the client using a new
valueFormat field in the handshake.

Renamed AuthenticationRequest to HandshakeRequest. Credentials
and valueFormat are all sent as part of a single HandshakeRequest.

Renamed the connection states to make them a little easier to
understand, and removed some duplicate states.

The new states are RequireVersion, RequireAuthentication,
AcceptMessages, InvalidSecurity, and TerminateConnection



+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.geode.internal.protocol.serialization.NoOpCustomValueSerializer;
+import org.apache.geode.protocol.serialization.ValueSerializer;
+  private final ValueSerializer serializer;
-  public ProtobufSerializationService() {}
+  public ProtobufSerializationService() {
+    this(new NoOpCustomValueSerializer());
+  }
+
+  public ProtobufSerializationService(ValueSerializer valueSerializer) {
+    this.serializer = valueSerializer;
+  }
-    if (value == null) {
-      return BasicTypes.EncodedValue.newBuilder().setNullResult(NullValue.NULL_VALUE).build();
-    }
-
+      if (serializer.supportsPrimitives()) {
+        ByteString encoded = serializer.serialize(value);
+        return builder.setCustomObjectResult(encoded).build();
+      }
+
+      if (value == null) {
+        return builder.setNullResult(NullValue.NULL_VALUE).build();
+      }
+
-        case PDX_OBJECT: {
-          builder.setJsonObjectResult(jsonPdxConverter.encode((PdxInstance) value));
+        default: {
+          ByteString customResult = customSerialize(value);
+          if (customResult != null) {
+            builder.setCustomObjectResult(customResult);
+          } else if (value instanceof PdxInstance) {
+            builder.setJsonObjectResult(jsonPdxConverter.encode((PdxInstance) value));
+          } else {
+            throw new EncodingException("No handler for object type " + value.getClass());
+          }
-        default:
-          throw new EncodingException("No handler for protobuf type "
-              + ProtobufEncodingTypes.valueOf(value.getClass()).toString());
-    } catch (UnknownProtobufEncodingType unknownProtobufEncodingType) {
-      throw new EncodingException("No protobuf encoding for type " + value.getClass().getName());
+    } catch (UnknownProtobufEncodingType e) {
+      throw new EncodingException("No protobuf encoding for type " + value.getClass().getName(), e);
+    } catch (IOException e) {
+      throw new EncodingException("Error encoding type " + value.getClass().getName(), e);
+  private ByteString customSerialize(Object value) throws IOException {
+    return serializer instanceof NoOpCustomValueSerializer ? null : serializer.serialize(value);
+  }
+
-    switch (encodedValue.getValueCase()) {
-      case BINARYRESULT:
-        return encodedValue.getBinaryResult().toByteArray();
-      case BOOLEANRESULT:
-        return encodedValue.getBooleanResult();
-      case BYTERESULT:
-        return (byte) encodedValue.getByteResult();
-      case DOUBLERESULT:
-        return encodedValue.getDoubleResult();
-      case FLOATRESULT:
-        return encodedValue.getFloatResult();
-      case INTRESULT:
-        return encodedValue.getIntResult();
-      case LONGRESULT:
-        return encodedValue.getLongResult();
-      case SHORTRESULT:
-        return (short) encodedValue.getShortResult();
-      case STRINGRESULT:
-        return encodedValue.getStringResult();
-      case JSONOBJECTRESULT:
-        return jsonPdxConverter.decode(encodedValue.getJsonObjectResult());
-      case NULLRESULT:
-        return null;
-      default:
-        throw new DecodingException(
-            "Unknown Protobuf encoding type: " + encodedValue.getValueCase());
+
+    try {
+      switch (encodedValue.getValueCase()) {
+        case BINARYRESULT:
+          return encodedValue.getBinaryResult().toByteArray();
+        case BOOLEANRESULT:
+          return encodedValue.getBooleanResult();
+        case BYTERESULT:
+          return (byte) encodedValue.getByteResult();
+        case DOUBLERESULT:
+          return encodedValue.getDoubleResult();
+        case FLOATRESULT:
+          return encodedValue.getFloatResult();
+        case INTRESULT:
+          return encodedValue.getIntResult();
+        case LONGRESULT:
+          return encodedValue.getLongResult();
+        case SHORTRESULT:
+          return (short) encodedValue.getShortResult();
+        case STRINGRESULT:
+          return encodedValue.getStringResult();
+        case JSONOBJECTRESULT:
+          return jsonPdxConverter.decode(encodedValue.getJsonObjectResult());
+        case NULLRESULT:
+          return null;
+        case CUSTOMOBJECTRESULT:
+          return serializer.deserialize(encodedValue.getCustomObjectResult());
+        default:
+          throw new DecodingException(
+              "Unknown Protobuf encoding type: " + encodedValue.getValueCase());
+      }
+    } catch (IOException | ClassNotFoundException e) {
+      throw new DecodingException("Error decoding value", e);
+    // If any classes are added to this list that are not final, the logic
+    // in valueOf must change. It currently works only if the user's class
+    // is exactly the same as the class listed here.
-
-    // This will probably have to change once the protocol supports multiple object encodings.
-    PDX_OBJECT(PdxInstance.class);
+    OTHER(Object.class);
+    private static Map<Class, ProtobufEncodingTypes> classToType = new HashMap<>();
+
+    static {
+      for (ProtobufEncodingTypes type : values()) {
+        classToType.put(type.clazz, type);
+      }
+    }
+
-      for (ProtobufEncodingTypes protobufEncodingTypes : values()) {
-        if (protobufEncodingTypes.clazz.isAssignableFrom(unencodedValueClass)) {
-          return protobufEncodingTypes;
-        }
+      ProtobufEncodingTypes type = classToType.get(unencodedValueClass);
+      if (type != null) {
+        return type;
+      } else {
+        return OTHER;
-      throw new UnknownProtobufEncodingType(
-          "There is no primitive protobuf type mapping for class:" + unencodedValueClass);

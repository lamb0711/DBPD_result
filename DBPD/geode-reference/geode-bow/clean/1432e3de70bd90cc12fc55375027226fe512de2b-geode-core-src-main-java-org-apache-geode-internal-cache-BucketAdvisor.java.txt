Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
-import org.apache.geode.cache.server.CacheServer;
-  private static final boolean ENFORCE_SAFE_CLOSE = false;
+  public static final boolean ENFORCE_SAFE_CLOSE = false;
-  private final AtomicReference<InternalDistributedMember> primaryMember = new AtomicReference<>();
+  private final AtomicReference primaryMember = new AtomicReference();
-  private final RegionAdvisor regionAdvisor;
+  protected final RegionAdvisor regionAdvisor;
-    pRegion = this.regionAdvisor.getPartitionedRegion();
-    redundancyTracker =
+    this.pRegion = this.regionAdvisor.getPartitionedRegion();
+    this.redundancyTracker =
-  private void resetParentAdvisor(int bucketId) {
-    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(pRegion);
+  public void resetParentAdvisor(int bucketId) {
+    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(this.pRegion);
-              parentAdvisor =
+              this.parentAdvisor =
-        parentAdvisor = colocatedRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
+        this.parentAdvisor = colocatedRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
-      parentAdvisor = null;
+      this.parentAdvisor = null;
-    if (pRegion.isFixedPartitionedRegion()) {
-      List<FixedPartitionAttributesImpl> fpas = pRegion.getFixedPartitionAttributesImpl();
+    if (this.pRegion.isFixedPartitionedRegion()) {
+      List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
-            startingBucketAdvisor = regionAdvisor.getBucketAdvisor(fpa.getStartingBucketID());
+            startingBucketAdvisor = this.regionAdvisor.getBucketAdvisor(fpa.getStartingBucketID());
-  void tryLockIfPrimary() {
+  public void tryLockIfPrimary() {
-        primaryMoveWriteLock.lock();
+        this.primaryMoveWriteLock.lock();
-        primaryMoveWriteLock.unlock();
+        this.primaryMoveWriteLock.unlock();
-      primaryMoveWriteLock.lock();
+      this.primaryMoveWriteLock.lock();
-        primaryMoveWriteLock.unlock();
+        this.primaryMoveWriteLock.unlock();
+   * @return true if children were all deposed as primaries
+   * @guarded.By this
-  private void deposePrimaryForColocatedChildren() {
+  private boolean deposePrimaryForColocatedChildren() {
-    List<PartitionedRegion> colocatedChildPRs = ColocationHelper.getColocatedChildRegions(pRegion);
+
+    // getColocatedChildRegions returns only the child PRs directly colocated
+    // with thisPR...
+    List<PartitionedRegion> colocatedChildPRs =
+        ColocationHelper.getColocatedChildRegions(this.pRegion);
+    return deposedChildPrimaries;
-  private void deposeOtherPrimaryBucketForFixedPartition() {
+  private boolean deposeOtherPrimaryBucketForFixedPartition() {
-    List<FixedPartitionAttributesImpl> fpas = pRegion.getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
+        } else {
+          continue;
+    return deposedOtherPrimaries;
-    Profile[] locProfiles = profiles; // volatile read
+    Profile locProfiles[] = this.profiles; // volatile read
-  private Queue<Runnable> getVolunteeringQueue() {
-    return regionAdvisor.getVolunteeringQueue();
+  Queue getVolunteeringQueue() {
+    return this.regionAdvisor.getVolunteeringQueue();
-  private Semaphore getVolunteeringSemaphore() {
-    return regionAdvisor.getVolunteeringSemaphore();
+  Semaphore getVolunteeringSemaphore() {
+    return this.regionAdvisor.getVolunteeringSemaphore();
-  private PartitionedRegionStats getPartitionedRegionStats() {
-    return regionAdvisor.getPartitionedRegionStats();
+  PartitionedRegionStats getPartitionedRegionStats() {
+    return this.regionAdvisor.getPartitionedRegionStats();
-    regionAdvisor.incrementBucketCount(profile);
+    this.regionAdvisor.incrementBucketCount(profile);
-      notifyAll();
+      this.notifyAll();
-    regionAdvisor.updateBucketStatus(getBucket().getId(), profile.peerMemberId, false);
+    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), profile.peerMemberId, false);
-      notifyAll();
+      this.notifyAll();
-    regionAdvisor.updateBucketStatus(getBucket().getId(), profile.peerMemberId, false);
+    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), profile.peerMemberId, false);
-      regionAdvisor.updateBucketStatus(getBucket().getId(),
+      this.regionAdvisor.updateBucketStatus(this.getBucket().getId(),
-      regionAdvisor.decrementsBucketCount(profile);
+      this.regionAdvisor.decrementsBucketCount(profile);
-          profile != null ? profile.getDistributedMember() : null, profile);
+          profile.getDistributedMember(), profile);
-    ProfileId elector = primaryElector;
+    ProfileId elector = this.primaryElector;
-      primaryElector = getBucket().getDistributionManager().getId();
-      getBucket().getDistributionManager().getWaitingThreadPool().execute(
-          () -> getBucket().getPartitionedRegion().getRedundancyProvider()
-              .finishIncompleteBucketCreation(getBucket().getId()));
+      this.primaryElector = getBucket().getDistributionManager().getId();
+      this.getBucket().getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
+        @Override
+        public void run() {
+          getBucket().getPartitionedRegion().getRedundancyProvider()
+              .finishIncompleteBucketCreation(getBucket().getId());
+        }
+      });
-      return new SetFromMap<>(map);
+      return new SetFromMap<E>(map);
-  @SuppressWarnings("NullableProblems")
+    @SuppressWarnings("unchecked")
-      backingSet = m == null ? Collections.emptySet() : m.keySet();
+      backingSet = m == null ? Collections.<E>emptySet() : m.keySet();
-    int bucketId = getBucket().getId();
+    int bucketId = this.getBucket().getId();
-        newSetFromMap(new HashMap<>());
-    for (Profile p : profiles) {
+        newSetFromMap(new HashMap<ServerBucketProfile, Boolean>());
+    for (Profile p : this.profiles) {
-    regionAdvisor.setClientBucketProfiles(bucketId, serverProfiles);
+    this.regionAdvisor.setClientBucketProfiles(bucketId, serverProfiles);
-    localProfile = p;
+    this.localProfile = p;
-    return localProfile;
+    return this.localProfile;
-  public Set<InternalDistributedMember> adviseProfileExchange() {
+  public Set adviseProfileExchange() {
-    Assert.assertTrue(regionAdvisor.isInitialized());
-    return regionAdvisor.adviseBucketProfileExchange();
+    Assert.assertTrue(this.regionAdvisor.isInitialized());
+    return this.regionAdvisor.adviseBucketProfileExchange();
-  public Set<InternalDistributedMember> adviseProfileUpdate() {
+  public Set adviseProfileUpdate() {
-    return regionAdvisor.adviseGeneric();
+    return this.regionAdvisor.adviseGeneric();
+   * If the current member is primary for this bucket return true, otherwise, give some time for the
+   * current member to become primary and then return whether it is a primary (true/false).
+   */
+  public boolean isPrimaryWithWait() {
+    if (this.isPrimary()) {
+      return true;
+    }
+    // wait for the current member to become primary holder
+    InternalDistributedMember primary = waitForNewPrimary();
+    if (primary != null) {
+      return true;
+    }
+    return false;
+  }
+
+  /**
-    DistributionManager dm = regionAdvisor.getDistributionManager();
+    DistributionManager dm = this.regionAdvisor.getDistributionManager();
-    return waitForPrimaryMember(timeout);
+    InternalDistributedMember newPrimary = waitForPrimaryMember(timeout);
+    return newPrimary;
-  private void removePrimary(InternalDistributedMember member) {
+  public void removePrimary(InternalDistributedMember member) {
-        boolean wasPrimary = isPrimary() && getDistributionManager().getId().equals(member);
-        final InternalDistributedMember currentPrimary = primaryMember.get();
+        boolean wasPrimary = isPrimary() && this.getDistributionManager().getId().equals(member);
+        final InternalDistributedMember currentPrimary =
+            (InternalDistributedMember) this.primaryMember.get();
-          primaryMember.set(null);
+          this.primaryMember.set(null);
-          if (pRegion.isFixedPartitionedRegion()) {
+          if (this.pRegion.isFixedPartitionedRegion()) {
-                regionAdvisor.adviseFixedPrimaryPartitionDataStore(getBucket().getId());
-            needToVolunteerForPrimary = primaryMember == null || primaryMember.equals(member);
+                this.regionAdvisor.adviseFixedPrimaryPartitionDataStore(this.getBucket().getId());
+            if (primaryMember == null || primaryMember.equals(member)) {
+              needToVolunteerForPrimary = true;
+            } else {
+              needToVolunteerForPrimary = false;
+            }
-        Bucket br = regionAdvisor.getBucket(getBucket().getId());
-        if (br instanceof BucketRegion) {
+        Bucket br = this.regionAdvisor.getBucket(getBucket().getId());
+        if (br != null && br instanceof BucketRegion) {
-        if (pRegion.isFixedPartitionedRegion()) {
+        if (this.pRegion.isFixedPartitionedRegion()) {
-  void closeAdvisor() {
+  protected void closeAdvisor() {
-      requestPrimaryState(CLOSED);
-      redundancyTracker.closeBucket();
-      localProfile = null;
+      this.requestPrimaryState(CLOSED);
+      this.redundancyTracker.closeBucket();
+      this.localProfile = null;
-      return primaryState == CLOSED;
+      return this.primaryState == CLOSED;
-      return primaryState == IS_PRIMARY_HOSTING;
+      return this.primaryState == IS_PRIMARY_HOSTING;
-  private boolean isVolunteering() {
+  protected boolean isVolunteering() {
-      return primaryState == VOLUNTEERING_HOSTING;
+      return this.primaryState == VOLUNTEERING_HOSTING;
-  private boolean isBecomingPrimary() {
+  protected boolean isBecomingPrimary() {
-      return primaryState == BECOMING_HOSTING && volunteeringDelegate != null
-          && volunteeringDelegate.isAggressive();
+      return this.primaryState == BECOMING_HOSTING && this.volunteeringDelegate != null
+          && this.volunteeringDelegate.isAggressive();
-      return primaryState == NO_PRIMARY_HOSTING || primaryState == OTHER_PRIMARY_HOSTING
-          || primaryState == VOLUNTEERING_HOSTING || primaryState == BECOMING_HOSTING
-          || primaryState == IS_PRIMARY_HOSTING;
+      return this.primaryState == NO_PRIMARY_HOSTING || this.primaryState == OTHER_PRIMARY_HOSTING
+          || this.primaryState == VOLUNTEERING_HOSTING || this.primaryState == BECOMING_HOSTING
+          || this.primaryState == IS_PRIMARY_HOSTING;
-      if (volunteeringDelegate == null) {
+      if (this.volunteeringDelegate == null) {
-      volunteeringDelegate.volunteerForPrimary();
+      this.volunteeringDelegate.volunteerForPrimary();
-    volunteeringDelegate = delegate;
+    this.volunteeringDelegate = delegate;
-        getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+        this.getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-            wait(waitTime); // spurious wakeup ok
+            this.wait(waitTime); // spurious wakeup ok
-            vDelegate = volunteeringDelegate;
+            vDelegate = this.volunteeringDelegate;
-              volunteeringDelegate = vDelegate;
+              this.volunteeringDelegate = vDelegate;
-            if (volunteeringDelegate == null) {
-              volunteeringDelegate = new VolunteeringDelegate();
+            if (this.volunteeringDelegate == null) {
+              this.volunteeringDelegate = new VolunteeringDelegate();
-            volunteeringDelegate.volunteerForPrimary();
+            this.volunteeringDelegate.volunteerForPrimary();
-                DeposePrimaryBucketMessage.send(otherPrimary, pRegion, getBucket().getId());
+                DeposePrimaryBucketMessage.send(otherPrimary, this.pRegion, getBucket().getId());
-    return primaryMember.get();
+    return (InternalDistributedMember) this.primaryMember.get();
-  private boolean acquiredPrimaryLock() {
+  protected boolean acquiredPrimaryLock() {
-          Bucket br = regionAdvisor.getBucket(getBucket().getId());
-          if (br instanceof BucketRegion) {
+          Bucket br = this.regionAdvisor.getBucket(getBucket().getId());
+          if (br != null && br instanceof BucketRegion) {
-          Bucket br = regionAdvisor.getBucket(getBucket().getId());
-          if (br instanceof BucketRegion) {
+          Bucket br = this.regionAdvisor.getBucket(getBucket().getId());
+          if (br != null && br instanceof BucketRegion) {
-          if (br instanceof BucketRegion) {
+          if (br != null && br instanceof BucketRegion) {
-    PartitionListener[] listeners = pRegion.getPartitionListeners();
+    PartitionListener[] listeners = this.pRegion.getPartitionListeners();
-    for (PartitionListener listener : listeners) {
+    for (int i = 0; i < listeners.length; i++) {
+      PartitionListener listener = listeners[i];
-    PartitionListener[] listeners = pRegion.getPartitionListeners();
+    PartitionListener[] listeners = this.pRegion.getPartitionListeners();
-    for (PartitionListener listener : listeners) {
+    for (int i = 0; i < listeners.length; i++) {
+      PartitionListener listener = listeners[i];
-  private DistributedMemberLock getPrimaryLock(boolean createDLS) {
+  DistributedMemberLock getPrimaryLock(boolean createDLS) {
-      if (primaryLock == null) {
+      if (this.primaryLock == null) {
-          catch (IllegalStateException | DistributedSystemDisconnectedException e) {
+          catch (IllegalStateException e) {
-          } // this would certainly prevent us from creating a DLS... messy
-
+          } catch (DistributedSystemDisconnectedException e) {
+            // this would certainly prevent us from creating a DLS... messy
+            return null;
+          }
-        primaryLock = new DistributedMemberLock(dls, getAdvisee().getName(),
+        this.primaryLock = new DistributedMemberLock(dls, getAdvisee().getName(),
-      return primaryLock;
+      return this.primaryLock;
-  private void acquirePrimaryRecursivelyForColocated() {
+  protected void acquirePrimaryRecursivelyForColocated() {
-                if (acquired && pRegion.isFixedPartitionedRegion()) {
+                if (acquired && this.pRegion.isFixedPartitionedRegion()) {
-  private void acquirePrimaryForRestOfTheBucket() {
-    List<FixedPartitionAttributesImpl> fpas = pRegion.getFixedPartitionAttributesImpl();
+  protected void acquirePrimaryForRestOfTheBucket() {
+    List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
+        } else {
+          continue;
-  private boolean setVolunteering() {
+  protected boolean setVolunteering() {
-  private boolean setBecoming() {
+  protected boolean setBecoming() {
-  private InternalDistributedMember waitForPrimaryMember(long timeout) {
+  protected InternalDistributedMember waitForPrimaryMember(long timeout) {
-          getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+          this.getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-                      new Object[] {warnTime / 1000L, this, adviseInitialized()});
+                      new Object[] {warnTime / 1000L, this, this.adviseInitialized()});
-          wait(timeLeft); // spurious wakeup ok
+          this.wait(timeLeft); // spurious wakeup ok
-          wait(timeLeft); // spurious wakeup ok
+          this.wait(timeLeft); // spurious wakeup ok
-  synchronized void clearPrimaryElector() {
+  private static final long BUCKET_STORAGE_WAIT =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "BUCKET_STORAGE_WAIT", 15000).longValue(); // 15
+                                                                                                  // seconds
+
+  public boolean waitForStorage() {
+    synchronized (this) {
+      // let's park this thread and wait for storage!
+      StopWatch timer = new StopWatch(true);
+      try {
+        for (;;) {
+          if (this.regionAdvisor.isBucketLocal(getBucket().getId())) {
+            return true;
+          }
+          getProxyBucketRegion().getPartitionedRegion().checkReadiness();
+          if (isClosed()) {
+            return false;
+          }
+          long timeLeft = BUCKET_STORAGE_WAIT - timer.elapsedTimeMillis();
+          if (timeLeft <= 0) {
+            return false;
+          }
+          if (logger.isDebugEnabled()) {
+            logger.debug("Waiting for bucket storage" + this);
+          }
+          this.wait(timeLeft); // spurious wakeup ok
+        }
+      } catch (InterruptedException e) {
+        // abort and return null
+        Thread.currentThread().interrupt();
+      }
+      return false;
+    }
+  }
+
+  public synchronized void clearPrimaryElector() {
-  synchronized void setPrimaryElector(InternalDistributedMember newPrimaryElector) {
+  public synchronized void setPrimaryElector(InternalDistributedMember newPrimaryElector) {
-    if (primaryElector != null) {
+    if (this.primaryElector != null) {
-        primaryElector = null;
+        this.primaryElector = null;
-        primaryElector = newPrimaryElector;
+        this.primaryElector = newPrimaryElector;
-        primaryElector = null;
+        this.primaryElector = null;
-        primaryElector = newPrimaryElector;
+        this.primaryElector = newPrimaryElector;
-    boolean wasPrimary;
+    boolean wasPrimary = false;
-            primaryMember.set(null);
+            this.primaryMember.set(null);
-      volunteeringDelegate = null;
+      this.volunteeringDelegate = null;
-        notifyAll();
+        this.notifyAll();
-    if (getDistributionManager().getSystem().isLoner()) {
+    if (this.getDistributionManager().getSystem().isLoner()) {
-    final int partitionedRegionId = pRegion.getPRId();
+    final int partitionedRegionId = this.pRegion.getPRId();
-    HashSet<InternalDistributedMember> hostsAndProxyMembers = new HashSet<>();
+    HashSet hostsAndProxyMembers = new HashSet();
-      return primaryState == OTHER_PRIMARY_NOT_HOSTING
-          || primaryState == OTHER_PRIMARY_HOSTING || primaryState == IS_PRIMARY_HOSTING;
+      return this.primaryState == OTHER_PRIMARY_NOT_HOSTING
+          || this.primaryState == OTHER_PRIMARY_HOSTING || this.primaryState == IS_PRIMARY_HOSTING;
-    if (!pRegion.isShadowPR()) {
+    if (!this.pRegion.isShadowPR()) {
-      List<CacheServer> servers = cache.getCacheServers();
+      List servers = null;
+      servers = cache.getCacheServers();
-      HashSet<BucketServerLocation66> serverLocations = new HashSet<>();
-      for (CacheServer cacheServer : servers) {
-        CacheServerImpl server = (CacheServerImpl) cacheServer;
+      HashSet<BucketServerLocation66> serverLocations = new HashSet<BucketServerLocation66>();
+      for (Object object : servers) {
+        CacheServerImpl server = (CacheServerImpl) object;
-              server.getPort(), server.getExternalAddress(), getBucket().isPrimary(),
-              Integer.valueOf(version).byteValue(), server.getCombinedGroups());
+              server.getPort(), server.getExternalAddress()
+              /* .getExternalAddress(false/ checkServerRunning ) */, getBucket().isPrimary(), Integer.valueOf(version).byteValue(), server.getCombinedGroups());
-  private void setPrimaryMember(InternalDistributedMember id) {
+  void setPrimaryMember(InternalDistributedMember id) {
-    primaryMember.set(id);
-    everHadPrimary = true;
+    this.primaryMember.set(id);
+    this.everHadPrimary = true;
-    notifyAll(); // wake up any threads in waitForPrimaryMember
+    this.notifyAll(); // wake up any threads in waitForPrimaryMember
-  void setHadPrimary() {
-    everHadPrimary = true;
+  public void setHadPrimary() {
+    this.everHadPrimary = true;
-  boolean getHadPrimary() {
-    return everHadPrimary;
+  public boolean getHadPrimary() {
+    return this.everHadPrimary;
-    Set<InternalDistributedMember> primaryMembers = adviseFilter(profile -> {
-      assert profile instanceof BucketProfile;
-      BucketProfile srp = (BucketProfile) profile;
-      return srp.isPrimary;
+    Set primaryMembers = adviseFilter(new Filter() {
+      @Override
+      public boolean include(Profile profile) {
+        assert profile instanceof BucketProfile;
+        BucketProfile srp = (BucketProfile) profile;
+        return srp.isPrimary;
+      }
-    return primaryMembers.toArray(new InternalDistributedMember[0]);
+    return (InternalDistributedMember[]) primaryMembers
+        .toArray(new InternalDistributedMember[primaryMembers.size()]);
-  private boolean findAndSetPrimaryMember() {
+  boolean findAndSetPrimaryMember() {
-      setPrimaryMember(getDistributionManager().getDistributionManagerId());
+      setPrimaryMember(this.getDistributionManager().getDistributionManagerId());
-  Set<InternalDistributedMember> adviseInitialized() {
-    return adviseFilter(profile -> {
-      assert profile instanceof BucketProfile;
-      BucketProfile bucketProfile = (BucketProfile) profile;
-      return bucketProfile.isHosting;
+  public Set<InternalDistributedMember> adviseInitialized() {
+    return adviseFilter(new Filter() {
+      @Override
+      public boolean include(Profile profile) {
+        assert profile instanceof BucketProfile;
+        BucketProfile bucketProfile = (BucketProfile) profile;
+        return bucketProfile.isHosting;
+      }
-  Set<InternalDistributedMember> adviseRecoveredFromDisk() {
+  public Set<InternalDistributedMember> adviseRecoveredFromDisk() {
-    Profile[] locProfiles = profiles; // grab current profiles
+    Profile[] locProfiles = this.profiles; // grab current profiles
-  private void releasePrimaryLock() {
+  protected void releasePrimaryLock() {
-    return primaryStateToString(primaryState);
+    return primaryStateToString(this.primaryState);
-    final byte fromState = primaryState;
+    final byte fromState = this.primaryState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-                primaryStateToString(), primaryStateToString(requestedState)));
+                new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-                primaryStateToString(),
-                primaryStateToString(requestedState)));
+                new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-                primaryStateToString(),
-                primaryStateToString(requestedState)));
+                new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState;
+            this.primaryState = requestedState;
-                primaryStateToString(),
-                primaryStateToString(requestedState)));
+                new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-                primaryStateToString(),
-                primaryStateToString(requestedState)));
+                new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-            primaryState = requestedState; {
+            this.primaryState = requestedState; {
-                primaryStateToString(),
-                primaryStateToString(requestedState)));
+                new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            throw new IllegalStateException("Cannot change from " + primaryStateToString()
-                + " to " + primaryStateToString(requestedState));
+            throw new IllegalStateException("Cannot change from " + this.primaryStateToString()
+                + " to " + this.primaryStateToString(requestedState));
-                    primaryStateToString(),
-                    primaryStateToString(requestedState), getAdvisee().getName()));
+                    new Object[] {this.primaryStateToString(),
+                        this.primaryStateToString(requestedState), getAdvisee().getName()}));
-    return primaryState == requestedState;
+    return this.primaryState == requestedState;
-      primaryState = requestedState;
+      this.primaryState = requestedState;
-    return regionAdvisor.adviseAllPRNodes();
+    return this.regionAdvisor.adviseAllPRNodes();
-  public Set<InternalDistributedMember> adviseRequiresTwoMessages() {
+  public Set adviseRequiresTwoMessages() {
-  private Set<InternalDistributedMember> adviseNotInitialized() {
-    return adviseFilter(profile -> {
-      assert profile instanceof CacheProfile;
-      CacheProfile cp = (CacheProfile) profile;
-      return !cp.regionInitialized;
+  public Set adviseNotInitialized() {
+    return adviseFilter(new Filter() {
+      @Override
+      public boolean include(Profile profile) {
+        assert profile instanceof CacheProfile;
+        CacheProfile cp = (CacheProfile) profile;
+        return !cp.regionInitialized;
+      }
-    return regionAdvisor.adviseNetWrite();
+    return this.regionAdvisor.adviseNetWrite();
+    // String identity = super.toString();
+    // String identity = "BucketAdvisor " + getAdvisee().getFullPath() +
+    // ":" + getAdvisee().getSerialNumber();
+    // identity = identity.substring(identity.lastIndexOf(".")+1);
+    // final StringBuffer sb = new StringBuffer("[" + identity + ": ");
-  void endBucketCreation() {
+  public void endBucketCreation() {
-      isPrimary = bucket.isPrimary();
-      isHosting = bucket.isHosting();
+      this.isPrimary = bucket.isPrimary();
+      this.isHosting = bucket.isHosting();
-      sb.append("; isPrimary=").append(isPrimary);
-      sb.append("; isHosting=").append(isHosting);
-      sb.append("; isInitializing=").append(isInitializing);
+      sb.append("; isPrimary=" + this.isPrimary);
+      sb.append("; isHosting=" + this.isHosting);
+      sb.append("; isInitializing=" + this.isInitializing);
-      isPrimary = in.readBoolean();
-      isHosting = in.readBoolean();
-      isInitializing = in.readBoolean();
+      this.isPrimary = in.readBoolean();
+      this.isHosting = in.readBoolean();
+      this.isInitializing = in.readBoolean();
-      out.writeBoolean(isPrimary);
-      out.writeBoolean(isHosting);
-      out.writeBoolean(isInitializing);
+      out.writeBoolean(this.isPrimary);
+      out.writeBoolean(this.isHosting);
+      out.writeBoolean(this.isInitializing);
-      bucketId = bucket.getId();
-      bucketServerLocations = serverLocations;
+      this.bucketId = bucket.getId();
+      this.bucketServerLocations = serverLocations;
-        sb.append("; hostName=").append(location.getHostName());
-        sb.append("; port=").append(location.getPort());
+        sb.append("; hostName=" + location.getHostName());
+        sb.append("; port=" + location.getPort());
-      bucketServerLocations = SerializationHelper.readBucketServerLocationSet(in);
-      bucketId = DataSerializer.readPrimitiveInt(in);
+      this.bucketServerLocations = SerializationHelper.readBucketServerLocationSet(in);
+      this.bucketId = DataSerializer.readPrimitiveInt(in);
-      DataSerializer.writePrimitiveInt(bucketId, out);
+      DataSerializer.writePrimitiveInt(this.bucketId, out);
-      return bucketServerLocations;
+      return this.bucketServerLocations;
+      final int prime = 31;
+      int result = 1;
-      return 31 * bucketId + sl.getPort();
+      result = prime * bucketId + sl.getPort();
+      return result;
-      if (other.bucketId != bucketId) {
+      if (other.bucketId != this.bucketId) {
-      if (other.bucketServerLocations.size() != bucketServerLocations.size()) {
+      if (other.bucketServerLocations.size() != this.bucketServerLocations.size()) {
-      return other.bucketServerLocations.containsAll(bucketServerLocations);
+      if (!other.bucketServerLocations.containsAll(this.bucketServerLocations)) {
+        return false;
+      }
+      return true;
-        return aggressive;
+        return this.aggressive;
-          execute(this::doVolunteerForPrimary);
+          execute(new Runnable() {
+            @Override
+            public void run() {
+              doVolunteerForPrimary();
+            }
+          });
-        if (volunteeringThread != null) {
+        if (this.volunteeringThread != null) {
-        aggressive = true;
+        this.aggressive = true;
-          primaryMoveWriteLock.lock();
+          BucketAdvisor.this.primaryMoveWriteLock.lock();
-            boolean acquiredLock;
+            boolean acquiredLock = false;
-            primaryMoveWriteLock.unlock();
+            BucketAdvisor.this.primaryMoveWriteLock.unlock();
-      } catch (RegionDestroyedException | CancelException e) {
+      } catch (RegionDestroyedException e) {
+        handleException(e, false);
+      } catch (CancelException e) {
-        if (Thread.currentThread().equals(volunteeringThread)) {
+        if (Thread.currentThread().equals(this.volunteeringThread)) {
-        if (volunteeringThread != null) {
+        if (this.volunteeringThread != null) {
-        volunteeringThread = Thread.currentThread();
+        this.volunteeringThread = Thread.currentThread();
-            aggressive = false;
-            volunteeringThread = null;
+            this.aggressive = false;
+            this.volunteeringThread = null;
-        if (!Thread.currentThread().equals(volunteeringThread)) {
+        if (!Thread.currentThread().equals(this.volunteeringThread)) {
-        return isHosting();
+        if (!isHosting()) {
+          return false;
+        }
+        return true;
-      if (Thread.currentThread().equals(volunteeringThread)) {
-        volunteeringThread = null;
-        aggressive = false;
+      if (Thread.currentThread().equals(this.volunteeringThread)) {
+        this.volunteeringThread = null;
+        this.aggressive = false;
-      Queue<Runnable> volunteeringQueue = getVolunteeringQueue();
+      Queue volunteeringQueue = getVolunteeringQueue();
-      return () -> {
-        getPartitionedRegionStats().incVolunteeringThreads(1);
-        boolean releaseSemaphore = true;
-        try {
-          Queue<Runnable> volunteeringQueue = getVolunteeringQueue();
-          Runnable queuedWork;
-          while (true) {
-            // SystemFailure.checkFailure();
-            getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-            synchronized (volunteeringQueue) {
-              // synchronized volunteeringQueue for coordination between threads adding
-              // work to the queue and checking for a consuming thread and the existing
-              // consuming thread to determine if it can exit since the queue is empty.
-              queuedWork = volunteeringQueue.poll();
-              if (queuedWork == null) {
-                // the queue is empty... no more work... so return
-                // @todo why release the semaphore here are sync'ed?
-                // we could just let the finally block do it.
-                getVolunteeringSemaphore().release();
-                releaseSemaphore = false;
-                return;
+      return new Runnable() {
+        @Override
+        public void run() {
+          getPartitionedRegionStats().incVolunteeringThreads(1);
+          boolean releaseSemaphore = true;
+          try {
+            Queue volunteeringQueue = getVolunteeringQueue();
+            Runnable queuedWork = null;
+            while (true) {
+              // SystemFailure.checkFailure();
+              getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+              synchronized (volunteeringQueue) {
+                // synchronized volunteeringQueue for coordination between threads adding
+                // work to the queue and checking for a consuming thread and the existing
+                // consuming thread to determine if it can exit since the queue is empty.
+                queuedWork = (Runnable) volunteeringQueue.poll();
+                if (queuedWork == null) {
+                  // the queue is empty... no more work... so return
+                  // @todo why release the semaphore here are sync'ed?
+                  // we could just let the finally block do it.
+                  getVolunteeringSemaphore().release();
+                  releaseSemaphore = false;
+                  return;
+                }
+                // still more work in the queue so let's run it
-              // still more work in the queue so let's run it
+              try {
+                queuedWork.run();
+              } catch (CancelException e) {
+                return;
+              } catch (RuntimeException e) {
+                // log and continue consuming queue
+                logger.error(e.getMessage(), e);
+              }
-            try {
-              queuedWork.run();
-            } catch (CancelException e) {
-              return;
-            } catch (RuntimeException e) {
-              // log and continue consuming queue
-              logger.error(e.getMessage(), e);
+          } finally {
+            getPartitionedRegionStats().incVolunteeringThreads(-1);
+            if (releaseSemaphore) {
+              // Clean up, just in case
+              getVolunteeringSemaphore().release();
+              releaseSemaphore = false;
-        } finally {
-          getPartitionedRegionStats().incVolunteeringThreads(-1);
-          if (releaseSemaphore) {
-            // Clean up, just in case
-            getVolunteeringSemaphore().release();
-          }
-  void setShadowBucketDestroyed(boolean destroyed) {
-    shadowBucketDestroyed = destroyed;
+  public boolean setShadowBucketDestroyed(boolean destroyed) {
+    return this.shadowBucketDestroyed = destroyed;
-    return shadowBucketDestroyed;
+    return this.shadowBucketDestroyed;

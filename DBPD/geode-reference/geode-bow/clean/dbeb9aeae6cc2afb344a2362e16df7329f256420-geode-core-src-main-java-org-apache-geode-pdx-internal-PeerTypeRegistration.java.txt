Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.internal.logging.LogService;
+import org.apache.logging.log4j.Logger;
+  private static final Logger logger = LogService.getLogger();
+
-  
-  private int nextTypeId;
+  public static final int PLACE_HOLDER_FOR_TYPE_ID = 0xFFFFFF;
+  public static final int PLACE_HOLDER_FOR_DS_ID = 0xFF000000;
+
+  private int dsId;
-  private int nextEnumId;
-  private final int maxEnumId;
-  
+
-   * The region where the PDX metadata is stored.
-   * Because this region is transactional for our internal updates
-   * but we don't want to participate in the users transactions,
-   * all operations on this region must suspend any existing
-   * transactions with suspendTX/resumeTX. 
+   * The region where the PDX metadata is stored. Because this region is transactional for our
+   * internal updates but we don't want to participate in the users transactions, all operations on
+   * this region must suspend any existing transactions with suspendTX/resumeTX.
-  private Region<Object/*Integer or EnumCode*/, Object/*PdxType or enum info*/> idToType;
-  
-  /** This map serves two purposes. It lets us look
-   * up an id based on a type, if we previously found that type
-   * in the region. And, if a type is present in this map, that means
-   * we read the type while holding the dlock, which means the type
-   * was distributed to all members.
+  private Region<Object/* Integer or EnumCode */, Object/* PdxType or enum info */> idToType;
+
+  /**
+   * This map serves two purposes. It lets us look up an id based on a type, if we previously found
+   * that type in the region. And, if a type is present in this map, that means we read the type
+   * while holding the dlock, which means the type was distributed to all members.
-  private Map<PdxType, Integer> typeToId = Collections.synchronizedMap(new HashMap<PdxType, Integer>());
-  private Map<EnumInfo, EnumId> enumToId = Collections.synchronizedMap(new HashMap<EnumInfo, EnumId>());
-  private final Map<String, Set<PdxType>> classToType = new CopyOnWriteHashMap<String, Set<PdxType>>();
+  private Map<PdxType, Integer> typeToId =
+      Collections.synchronizedMap(new HashMap<PdxType, Integer>());
+  private Map<EnumInfo, EnumId> enumToId =
+      Collections.synchronizedMap(new HashMap<EnumInfo, EnumId>());
+  private final Map<String, Set<PdxType>> classToType =
+      new CopyOnWriteHashMap<String, Set<PdxType>>();
-  
+
-    
-        
-    int distributedSystemId = cache.getDistributedSystem().getDistributionManager().getDistributedSystemId();
-    if(distributedSystemId == -1) {
+
+
+    int distributedSystemId =
+        cache.getDistributedSystem().getDistributionManager().getDistributedSystemId();
+    if (distributedSystemId == -1) {
-    this.nextTypeId = distributedSystemId << 24;
-    this.maxTypeId = distributedSystemId << 24 | 0xFFFFFF;
-    this.nextEnumId = distributedSystemId << 24;
-    this.maxEnumId = distributedSystemId << 24 | 0xFFFFFF;
+    this.dsId = distributedSystemId << 24;
+    this.maxTypeId = 0xFFFFFF;
-  
-  private Region<Object/*Integer or EnumCode*/, Object/*PdxType or enum info*/> getIdToType() {
+
+  private Region<Object/* Integer or EnumCode */, Object/* PdxType or enum info */> getIdToType() {
-      if (this.cache.getPdxPersistent() 
-          && this.cache.getCacheConfig().pdxDiskStoreUserSet) {
-          throw new PdxInitializationException("PDX registry could not be initialized because the disk store " + this.cache.getPdxDiskStore() + " was not created.");
+      if (this.cache.getPdxPersistent() && this.cache.getCacheConfig().pdxDiskStoreUserSet) {
+        throw new PdxInitializationException(
+            "PDX registry could not be initialized because the disk store "
+                + this.cache.getPdxDiskStore() + " was not created.");
+
-    if(cache.getPdxPersistent()) {
-      if(cache.getCacheConfig().pdxDiskStoreUserSet) {
+    if (cache.getPdxPersistent()) {
+      if (cache.getCacheConfig().pdxDiskStoreUserSet) {
-    
-    //Add a listener that makes sure that if anyone in the DS is using PDX
-    //Our PDX configuration is valid for this member. This is important if
-    //we are the gateway, we need to validate that we have a distributed system 
-    //id.
+
+    // Add a listener that makes sure that if anyone in the DS is using PDX
+    // Our PDX configuration is valid for this member. This is important if
+    // we are the gateway, we need to validate that we have a distributed system
+    // id.
-        //update a local map with the pdxtypes registered 
+        // update a local map with the pdxtypes registered
-         if(value instanceof PdxType){
+        if (value instanceof PdxType) {
-         }
+        }
-    
+
-      public void beforeUpdate(EntryEvent<Object, Object> event)
-          throws CacheWriterException {
-        if(!event.getOldValue().equals(event.getNewValue())) {
-          PdxRegistryMismatchException ex = new PdxRegistryMismatchException("Trying to add a PDXType with the same id as an existing PDX type. id=" + event.getKey() + ", existing pdx type " + event.getOldValue() + ", new type " + event.getNewValue());
+      public void beforeCreate(EntryEvent<Object, Object> event) throws CacheWriterException {
+        Object newValue = event.getNewValue();
+        if (newValue instanceof PdxType) {
+          logger.info("Adding new type: {}", ((PdxType) event.getNewValue()).toFormattedString());
+        } else {
+          logger.info("Adding new type: {} {}", event.getKey(),
+              ((EnumInfo) newValue).toFormattedString());
+        }
+      }
+
+      @Override
+      public void beforeUpdate(EntryEvent<Object, Object> event) throws CacheWriterException {
+        if (!event.getRegion().get(event.getKey()).equals(event.getNewValue())) {
+          PdxRegistryMismatchException ex = new PdxRegistryMismatchException(
+              "Trying to add a PDXType with the same id as an existing PDX type. id="
+                  + event.getKey() + ", existing pdx type " + event.getOldValue() + ", new type "
+                  + event.getNewValue());
-      
+
-    
+
-      this.idToType = cache.createVMRegion(REGION_NAME, regionAttrs,
-          internalArgs);
+      this.idToType = cache.createVMRegion(REGION_NAME, regionAttrs, internalArgs);
-    //If there is anything in the id to type registry,
-    //we should validate our configuration now.
-    //And send those types to any existing gateways.
-    if(!getIdToType().isEmpty()) {
+    // If there is anything in the id to type registry,
+    // we should validate our configuration now.
+    // And send those types to any existing gateways.
+    if (!getIdToType().isEmpty()) {
-          this.dls = DLockService.create(LOCK_SERVICE_NAME,
-              this.cache.getDistributedSystem(), true /* distributed */,
-              true /* destroyOnDisconnect */, true /* automateFreeResources */);
+          this.dls = DLockService.create(LOCK_SERVICE_NAME, this.cache.getDistributedSystem(),
+              true /* distributed */, true /* destroyOnDisconnect */,
+              true /* automateFreeResources */);
-          this.dls = DistributedLockService
-              .getServiceNamed(LOCK_SERVICE_NAME);
+          this.dls = DistributedLockService.getServiceNamed(LOCK_SERVICE_NAME);
-  
+
-  private int allocateTypeId() {
+  private int allocateTypeId(PdxType newType) {
-    try {
-      //Find the next available type id.
-      do {
-        this.nextTypeId++;
-        if(this.nextTypeId == maxTypeId) {
-          throw new InternalGemFireError("Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is " + maxTypeId);
-        }
-      } while(r.get(nextTypeId) != null);
-      this.lastAllocatedTypeId = this.nextTypeId;
-      return this.nextTypeId;
+    int id = newType.hashCode() & PLACE_HOLDER_FOR_TYPE_ID;
+    int newTypeId = id | this.dsId;
+
+    try {
+      int maxTry = maxTypeId;
+      while (r.get(newTypeId) != null) {
+        maxTry--;
+        if (maxTry == 0) {
+          throw new InternalGemFireError(
+              "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
+                  + maxTypeId);
+        }
+
+        // Find the next available type id.
+        id++;
+        if (id > this.maxTypeId) {
+          id = 1;
+        }
+        newTypeId = id | this.dsId;
+      }
+
+      return newTypeId;
-  private EnumId allocateEnumId() {
+
+  private EnumId allocateEnumId(EnumInfo ei) {
-    try {
-      //Find the next available type id.
-      do {
-        this.nextEnumId++;
-        if(this.nextEnumId == maxEnumId) {
-          throw new InternalGemFireError("Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is " + maxEnumId);
-        }
-      } while(r.get(new EnumId(nextEnumId)) != null);
-      this.lastAllocatedEnumId = this.nextEnumId;
-      return new EnumId(this.nextEnumId);
+    int id = ei.hashCode() & PLACE_HOLDER_FOR_TYPE_ID;
+    int newEnumId = id | this.dsId;
+    try {
+      int maxTry = this.maxTypeId;
+      // Find the next available type id.
+      while (r.get(new EnumId(newEnumId)) != null) {
+        maxTry--;
+        if (maxTry == 0) {
+          throw new InternalGemFireError(
+              "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
+                  + this.maxTypeId);
+        }
+
+        // Find the next available type id.
+        id++;
+        if (id > this.maxTypeId) {
+          id = 1;
+        }
+        newEnumId = id | this.dsId;
+      }
+
+      return new EnumId(newEnumId);
-    } catch(LockServiceDestroyedException e) {
-   // fix for bug 43574
+    } catch (LockServiceDestroyedException e) {
+      // fix for bug 43574
-    if (!dls.lock(LOCK_NAME, -1, -1)) {
-      // this should be impossible
-      throw new InternalGemFireException("Could not obtain pdx lock");
-    }
+      if (!dls.lock(LOCK_NAME, -1, -1)) {
+        // this should be impossible
+        throw new InternalGemFireException("Could not obtain pdx lock");
+      }
-  
+
-    if (sys != null  &&  !sys.threadOwnsResources()) {
+    if (sys != null && !sys.threadOwnsResources()) {
-  
+
+
-    if(existingId != null) {
+    if (existingId != null) {
-      if(id != -1) {
+      if (id != -1) {
-      
-      id = allocateTypeId();
+
+      id = allocateTypeId(newType);
-      
+
-      
+
-      //this.cache.getLogger().info("Defining: " + newType, new RuntimeException("STACK"));
-      
+      // this.cache.getLogger().info("Defining: " + newType, new RuntimeException("STACK"));
+
+
+
-    Cache c = (Cache)r.getRegionService();
-    
+    Cache c = (Cache) r.getRegionService();
+
-    
+
-      
-      //The loop might not be necessary because we're
-      //updating a replicated region inside a dlock,
-      //but just in case we'll make sure to retry the transaction.
+
+      // The loop might not be necessary because we're
+      // updating a replicated region inside a dlock,
+      // but just in case we'll make sure to retry the transaction.
-      while(true) {
+      while (true) {
-        } catch(TransactionException e) {
+        } catch (TransactionException e) {
-          //Let's just make sure things don't get out of hand.
-          if(++failureCount > MAX_TRANSACTION_FAILURES) {
+          // Let's just make sure things don't get out of hand.
+          if (++failureCount > MAX_TRANSACTION_FAILURES) {
-  
+
-      return (PdxType)getIdToType().get(typeId);
+      return (PdxType) getIdToType().get(typeId);
-    
+
-  
+
-      if(!r.containsKey(typeId)) {
-        //This type could actually be for this distributed system,
-        //so we need to make sure the type is published while holding
-        //the distributed lock.
+      if (!r.containsKey(typeId)) {
+        // This type could actually be for this distributed system,
+        // so we need to make sure the type is published while holding
+        // the distributed lock.
-    if(!typeRegistryInUse || this.idToType == null) {
+    if (!typeRegistryInUse || this.idToType == null) {
-    //Anything is allowed until the registry is in use.
-    if(!typeRegistryInUse) {
+    // Anything is allowed until the registry is in use.
+    if (!typeRegistryInUse) {
-  
-  public boolean hasGatewaySender(){
+
+  public boolean hasGatewaySender() {
-    while(itr.hasNext()){
+    while (itr.hasNext()) {
-      if(AsyncEventQueueImpl.isAsyncEventQueue(sender.getId())){
+      if (AsyncEventQueueImpl.isAsyncEventQueue(sender.getId())) {
+
-    if(typeRegistryInUse) {
-      throw new PdxInitializationException("The PDX metadata has already been created as a peer metadata region. Please create your pools first");
+    if (typeRegistryInUse) {
+      throw new PdxInitializationException(
+          "The PDX metadata has already been created as a peer metadata region. Please create your pools first");
-  
+
-    if(typeRegistryInUse) {
+    if (typeRegistryInUse) {
-      
-      for(Pool pool : PoolManager.getAll().values()) {
-        if(!((PoolImpl) pool).isUsedByGateway()) {
-        throw new PdxInitializationException("The PDX metadata has already been " +
-        		"created as a peer metadata region. " +
-        		"Please use ClientCacheFactory to create clients.");
+
+      for (Pool pool : PoolManager.getAll().values()) {
+        if (!((PoolImpl) pool).isUsedByGateway()) {
+          throw new PdxInitializationException(
+              "The PDX metadata has already been " + "created as a peer metadata region. "
+                  + "Please use ClientCacheFactory to create clients.");
-      
+
-    for(DiskStoreImpl store : diskStores) {
+    for (DiskStoreImpl store : diskStores) {
-    if(hasDiskStore && !cache.getPdxPersistent()) {
-      throw new PdxInitializationException("The PDX metadata must be persistent in a member that has persistent data. See CacheFactory.setPdxPersistent.");
+    if (hasDiskStore && !cache.getPdxPersistent()) {
+      throw new PdxInitializationException(
+          "The PDX metadata must be persistent in a member that has persistent data. See CacheFactory.setPdxPersistent.");
-    int distributedSystemId = cache.getDistributedSystem().getDistributionManager().getDistributedSystemId();
-    if(hasGatewaySender && distributedSystemId == -1) {
-      throw new PdxInitializationException("When using PDX with a WAN gateway sender, you must set the distributed-system-id gemfire property for your distributed system. See the javadocs for DistributedSystem.");
+    int distributedSystemId =
+        cache.getDistributedSystem().getDistributionManager().getDistributedSystemId();
+    if (hasGatewaySender && distributedSystemId == -1) {
+      throw new PdxInitializationException(
+          "When using PDX with a WAN gateway sender, you must set the distributed-system-id gemfire property for your distributed system. See the javadocs for DistributedSystem.");
+    int totalPdxTypeIdInDS = 0;
-    try { 
+    try {
-          EnumId id = (EnumId)k;
-          EnumInfo info = (EnumInfo)v;
+          EnumId id = (EnumId) k;
+          EnumInfo info = (EnumInfo) v;
-          PdxType foundType = (PdxType)v;
-          Integer id = (Integer)k;
+          PdxType foundType = (PdxType) v;
+          Integer id = (Integer) k;
+          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
+          if (tmpDsId == this.dsId) {
+            totalPdxTypeIdInDS++;
+          }
+
+      if (totalPdxTypeIdInDS == this.maxTypeId) {
+        throw new InternalGemFireError(
+            "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
+                + this.maxTypeId);
+      }
-    try { 
+    int totalEnumIdInDS = 0;
+    try {
-          EnumId id = (EnumId)k;
-          EnumInfo info = (EnumInfo)v;
+          EnumId id = (EnumId) k;
+          EnumInfo info = (EnumInfo) v;
+          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
+          if (tmpDsId == this.dsId) {
+            totalEnumIdInDS++;
+          }
-          typeToId.put((PdxType)v, (Integer)k);
+          typeToId.put((PdxType) v, (Integer) k);
+
+      if (totalEnumIdInDS == this.maxTypeId) {
+        throw new InternalGemFireError(
+            "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
+                + this.maxTypeId);
+      }
-  
+
-    Cache c = (Cache)getIdToType().getRegionService();
+    Cache c = (Cache) getIdToType().getRegionService();
-  
+
-    if(state != null) {
+    if (state != null) {
-    if(existingId != null) {
+    if (existingId != null) {
-      if(id != null) {
+      if (id != null) {
-      id = allocateEnumId();
+      id = allocateEnumId(ei);
-      if(!r.containsKey(enumId)) {
-        //This enum could actually be for this distributed system,
-        //so we need to make sure the enum is published while holding
-        //the distributed lock.
+      if (!r.containsKey(enumId)) {
+        // This enum could actually be for this distributed system,
+        // so we need to make sure the enum is published while holding
+        // the distributed lock.
-    if(existingId != null) {
+    if (existingId != null) {
-      if(id != null) {
+      if (id != null) {
-      
-      id = allocateEnumId();
-      
+
+      id = allocateEnumId(newInfo);
+
-      
+
-      
+
-      return (EnumInfo)getIdToType().get(enumId);
+      return (EnumInfo) getIdToType().get(enumId);
-  
-  
+
+
-    if(type != null){
-      synchronized (this.classToType){
-        if(type.getClassName().equals(JSONFormatter.JSON_CLASSNAME) )
-          return;//no need to include here
+    if (type != null) {
+      synchronized (this.classToType) {
+        if (type.getClassName().equals(JSONFormatter.JSON_CLASSNAME))
+          return;// no need to include here
-  
+
-  public void testClearRegistry(){
+  public void testClearRegistry() {
-   }
-  
+  }
+
-  
+
-    if(cache == null) {
+    if (cache == null) {
-    
+
-    if(registry == null) {
+    if (registry == null) {
-    
+

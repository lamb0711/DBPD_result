GEODE-1292: change defragment to not create fragments > 2G

+  
+  /**
+   * Return true if the two chunks have been combined into one.
+   * If low and high are adjacent to each other
+   * and the combined size is small enough (see isSmallEnough)
+   * then low's size will be increased by the size of high
+   * and true will be returned.
+   */
+  boolean combineIfAdjacentAndSmallEnough(long lowAddr, long highAddr) {
+    assert lowAddr <= highAddr;
+    int lowSize = OffHeapStoredObject.getSize(lowAddr);
+    if (isAdjacent(lowAddr, lowSize, highAddr)) {
+      int highSize = OffHeapStoredObject.getSize(highAddr);
+      int combinedSize = lowSize + highSize;
+      if (isSmallEnough(combinedSize)) {
+        // append the highAddr chunk to lowAddr
+        OffHeapStoredObject.setSize(lowAddr, (int)combinedSize);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns true if the area if memory (starting at lowAddr and extending to
+   * lowAddr+lowSize) is right before (i.e. adjacent) to highAddr.
+   */
+  boolean isAdjacent(long lowAddr, int lowSize, long highAddr) {
+    return (lowAddr + lowSize) == highAddr;
+  }
+  /**
+   * Return true if size is small enough to be set as the size
+   * of a OffHeapStoredObject.
+   */
+  boolean isSmallEnough(long size) {
+    return size <= Integer.MAX_VALUE;
+  }
+  
-        ArrayList<OffHeapStoredObjectAddressStack> freeChunks = new ArrayList<OffHeapStoredObjectAddressStack>();
-        collectFreeChunks(freeChunks);
-        final int SORT_ARRAY_BLOCK_SIZE = 128;
-        long[] sorted = new long[SORT_ARRAY_BLOCK_SIZE];
-        int sortedSize = 0;
-        boolean result = false;
-        int largestFragment = 0;
-        for (OffHeapStoredObjectAddressStack l: freeChunks) {
-          long addr = l.poll();
-          while (addr != 0) {
-            int idx = Arrays.binarySearch(sorted, 0, sortedSize, addr);
-            idx = -idx;
-            idx--;
-            if (idx == sortedSize) {
-              // addr is > everything in the array
-              if (sortedSize == 0) {
-                // nothing was in the array
-                sorted[0] = addr;
-                sortedSize++;
-              } else {
-                // see if we can conflate into sorted[idx]
-                long lowAddr = sorted[idx-1];
-                int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                if (lowAddr + lowSize == addr) {
-                  // append the addr chunk to lowAddr
-                  OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-                } else {
-                  if (sortedSize >= sorted.length) {
-                    long[] newSorted = new long[sorted.length+SORT_ARRAY_BLOCK_SIZE];
-                    System.arraycopy(sorted, 0, newSorted, 0, sorted.length);
-                    sorted = newSorted;
-                  }
-                  sortedSize++;
-                  sorted[idx] = addr;
-                }
-              }
-            } else {
-              int addrSize = OffHeapStoredObject.getSize(addr);
-              long highAddr = sorted[idx];
-              if (addr + addrSize == highAddr) {
-                // append highAddr chunk to addr
-                OffHeapStoredObject.setSize(addr, addrSize + OffHeapStoredObject.getSize(highAddr));
-                sorted[idx] = addr;
-              } else {
-                boolean insert = idx==0;
-                if (!insert) {
-                  long lowAddr = sorted[idx-1];
-                  //                  if (lowAddr == 0L) {
-                  //                    long[] tmp = Arrays.copyOf(sorted, sortedSize);
-                  //                    throw new IllegalStateException("addr was zero at idx=" + (idx-1) + " sorted="+ Arrays.toString(tmp));
-                  //                  }
-                  int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                  if (lowAddr + lowSize == addr) {
-                    // append the addr chunk to lowAddr
-                    OffHeapStoredObject.setSize(lowAddr, lowSize + addrSize);
-                  } else {
-                    insert = true;
-                  }
-                }
-                if (insert) {
-                  if (sortedSize >= sorted.length) {
-                    long[] newSorted = new long[sorted.length+SORT_ARRAY_BLOCK_SIZE];
-                    System.arraycopy(sorted, 0, newSorted, 0, idx);
-                    newSorted[idx] = addr;
-                    System.arraycopy(sorted, idx, newSorted, idx+1, sortedSize-idx);
-                    sorted = newSorted;
-                  } else {
-                    System.arraycopy(sorted, idx, sorted, idx+1, sortedSize-idx);
-                    sorted[idx] = addr;
-                  }
-                  sortedSize++;
-                }
-              }
-            }
-            addr = l.poll();
-          }
-        }
-        for (int i=sortedSize-1; i > 0; i--) {
-          long addr = sorted[i];
-          long lowAddr = sorted[i-1];
-          int lowSize = OffHeapStoredObject.getSize(lowAddr);
-          if (lowAddr + lowSize == addr) {
-            // append addr chunk to lowAddr
-            OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-            sorted[i] = 0L;
-          }
-        }
-        this.lastFragmentAllocation.set(0);
-        ArrayList<Fragment> tmp = new ArrayList<Fragment>();
-        for (int i=sortedSize-1; i >= 0; i--) {
-          long addr = sorted[i];
-          if (addr == 0L) continue;
-          int addrSize = OffHeapStoredObject.getSize(addr);
-          Fragment f = createFragment(addr, addrSize);
-          if (addrSize >= chunkSize) {
-            result = true;
-          }
-          if (addrSize > largestFragment) {
-            largestFragment = addrSize;
-            // TODO it might be better to sort them biggest first
-            tmp.add(0, f);
-          } else {
-            tmp.add(f);
-          }
-        }
-        this.fragmentList.addAll(tmp);
-
-        fillFragments();
+        boolean result = doDefragment(chunkSize);
-        this.ma.getStats().setLargestFragment(largestFragment);
-        this.ma.getStats().setFragments(tmp.size());        
-        this.ma.getStats().setFragmentation(getFragmentation());
-
+  
+  /**
+   * Simple interface the represents a "stack" of primitive longs.
+   * Currently this interface only allows supports poll but more
+   * could be added if needed in the future.
+   * This interface was introduced to aid unit testing.
+   * The only implementation of it is OffHeapStoredObjectAddressStack.
+   */
+  public interface LongStack {
+    /**
+     * Retrieves and removes the top of this stack,
+     * or returns {@code 0L} if this stack is empty.
+     */
+    public long poll();
+  }
+  /**
+   * Manages an array of primitive longs. The array can grow.
+   */
+  public static class ResizableLongArray {
+    private static final int SORT_ARRAY_BLOCK_SIZE = 128;
+    long[] data = new long[SORT_ARRAY_BLOCK_SIZE];
+    int size = 0;
+    
+    public int binarySearch(long l) {
+      return Arrays.binarySearch(data, 0, size, l);
+    }
+    public int size() {
+      return size;
+    }
+    public long get(int idx) {
+      return data[idx];
+    }
+    public void set(int idx, long l) {
+      data[idx] = l;
+    }
+    public void add(long l) {
+      if (size >= data.length) {
+        long[] newData = new long[data.length+SORT_ARRAY_BLOCK_SIZE];
+        System.arraycopy(data, 0, newData, 0, data.length);
+        data = newData;
+      }
+      data[size] = l;
+      size++;
+    }
+    public void insert(int idx, long l) {
+      if (size >= data.length) {
+        long[] newData = new long[data.length+SORT_ARRAY_BLOCK_SIZE];
+        System.arraycopy(data, 0, newData, 0, idx);
+        newData[idx] = l;
+        System.arraycopy(data, idx, newData, idx+1, size-idx);
+        data = newData;
+      } else {
+        System.arraycopy(data, idx, data, idx+1, size-idx);
+        data[idx] = l;
+      }
+      size++;
+    }
+  }
+  /**
+   * Defragments memory and returns true if enough memory to allocate chunkSize
+   * is freed. Otherwise returns false;
+   * Unlike the defragment method this method is not thread safe and does not check
+   * for a concurrent defragment. It should only be called by defragment and unit tests.
+   */
+  boolean doDefragment(int chunkSize) {
+    boolean result = false;
+    ArrayList<LongStack> freeChunks = new ArrayList<LongStack>();
+    collectFreeChunks(freeChunks);
+    ResizableLongArray sorted = new ResizableLongArray();
+    for (LongStack l: freeChunks) {
+      long addr = l.poll();
+      while (addr != 0) {
+        int idx = sorted.binarySearch(addr);
+        idx = -idx;
+        idx--;
+        int sortedSize = sorted.size();
+        if (idx == sortedSize) {
+          // addr is > everything in the array
+          if (sortedSize == 0) {
+            // nothing was in the array
+            sorted.add(addr);
+          } else {
+            if (!combineIfAdjacentAndSmallEnough(sorted.get(idx-1), addr)) {
+              sorted.add(addr);
+            }
+          }
+        } else {
+          if (combineIfAdjacentAndSmallEnough(addr, sorted.get(idx))) {
+            sorted.set(idx, addr);
+          } else {
+            if (idx == 0 || !combineIfAdjacentAndSmallEnough(sorted.get(idx-1), addr)) {
+              sorted.insert(idx, addr);
+            }
+          }
+        }
+        addr = l.poll();
+      }
+    }
+    for (int i=sorted.size()-1; i > 0; i--) {
+      if (combineIfAdjacentAndSmallEnough(sorted.get(i-1), sorted.get(i))) {
+        sorted.set(i, 0L);
+      }
+    }
+    
+    int largestFragment = 0;
+    this.lastFragmentAllocation.set(0);
+    ArrayList<Fragment> tmp = new ArrayList<Fragment>();
+    for (int i=sorted.size()-1; i >= 0; i--) {
+      long addr = sorted.get(i);
+      if (addr == 0L) continue;
+      int addrSize = OffHeapStoredObject.getSize(addr);
+      Fragment f = createFragment(addr, addrSize);
+      if (addrSize >= chunkSize) {
+        result = true;
+      }
+      if (addrSize > largestFragment) {
+        largestFragment = addrSize;
+        // TODO it might be better to sort them biggest first
+        tmp.add(0, f);
+      } else {
+        tmp.add(f);
+      }
+    }
+    this.fragmentList.addAll(tmp);
+
+    fillFragments();
+
+    this.ma.getStats().setLargestFragment(largestFragment);
+    this.ma.getStats().setFragments(tmp.size());        
+    this.ma.getStats().setFragmentation(getFragmentation());
+
+    return result;
+  }
-  private void collectFreeChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeChunks(List<LongStack> l) {
-  private void collectFreeFragmentChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeFragmentChunks(List<LongStack> l) {
-  private void collectFreeTinyChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeTinyChunks(List<LongStack> l) {
-  private void collectFreeHugeChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeHugeChunks(List<LongStack> l) {

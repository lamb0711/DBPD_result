Merge branch 'release/1.0.0-incubating.M1'

- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import com.gemstone.gemfire.distributed.internal.membership.jgroup.JGroupMembershipManager;
-import com.gemstone.gemfire.distributed.internal.membership.jgroup.LocatorImpl;
+import com.gemstone.gemfire.distributed.internal.membership.gms.Services;
+import com.gemstone.gemfire.distributed.internal.membership.gms.mgr.GMSMembershipManager;
+import com.gemstone.gemfire.internal.LinuxProcFsStatistics;
-import com.gemstone.gemfire.internal.OSProcess;
+import com.gemstone.gemfire.internal.cache.CacheServerImpl;
+import com.gemstone.gemfire.internal.cache.xmlcache.CacheServerCreation;
+import com.gemstone.gemfire.internal.offheap.MemoryAllocator;
+import com.gemstone.gemfire.internal.offheap.OffHeapStorage;
-import com.gemstone.org.jgroups.util.GemFireTracer;
+  public static final CreationStackGenerator DEFAULT_CREATION_STACK_GENERATOR = new CreationStackGenerator() {
+    @Override
+    public Throwable generateCreationStack(final DistributionConfig config) {
+      return null;
+    }
+  };
+
-  public static final AtomicReference<CreationStackGenerator> TEST_CREATION_STACK_GENERATOR = new AtomicReference<CreationStackGenerator>(
-      new CreationStackGenerator() {
-        @Override
-        public Throwable generateCreationStack(final DistributionConfig config) {
-          return null;
-        }
-      });
-  
+  public static final AtomicReference<CreationStackGenerator> TEST_CREATION_STACK_GENERATOR = new AtomicReference<CreationStackGenerator>(DEFAULT_CREATION_STACK_GENERATOR);
+  
+  
+  /**
+   * creates a non-functional instance for testing
+   * @param nonDefault - non-default distributed system properties
+   */
+  public static InternalDistributedSystem newInstanceForTesting(DM dm, Properties nonDefault) {
+    InternalDistributedSystem sys = new InternalDistributedSystem(nonDefault);
+    sys.config = new RuntimeDistributionConfigImpl(sys);
+    sys.dm = dm;
+    sys.isConnected = true;
+    return sys;
+  }
+  private MemoryAllocator offHeapStore = null;
+  
+  public MemoryAllocator getOffHeapStore() {
+    return this.offHeapStore;
+  }
+  
-    if (this.originalConfig.getMcastPort() == 0 && this.originalConfig.getLocators().equals("")) {
-      // no distribution
-      this.isLoner = true;
-//       throw new IllegalArgumentException("The "
-//                                          + DistributionConfig.LOCATORS_NAME
-//                                          + " attribute can not be empty when the "
-//                                          + DistributionConfig.MCAST_PORT_NAME
-//                                          + " attribute is zero.");
+    if (this.originalConfig.getLocators().equals("")) {
+      if (this.originalConfig.getMcastPort() != 0) {
+        throw new GemFireConfigException("The "
+                                          + DistributionConfig.LOCATORS_NAME
+                                          + " attribute can not be empty when the "
+                                          + DistributionConfig.MCAST_PORT_NAME
+                                          + " attribute is non-zero.");
+      } else {
+        // no distribution
+        this.isLoner = true;
+      }
-    if (this.isLoner) {
-      this.config = new RuntimeDistributionConfigImpl(this);
-    } else {
-      this.config = new RuntimeDistributionConfigImpl(this);
+    this.config = new RuntimeDistributionConfigImpl(this);
+    if (!this.isLoner) {
-
-    GemFireTracer tracer = GemFireTracer.getLog(InternalDistributedSystem.class);
-    tracer.setLogWriter(this.logWriter);
-    tracer.setSecurityLogWriter(this.securityLogWriter);
-    tracer.setLogger(LogService.getLogger(GemFireTracer.class));
+    
+    Services.setLogWriter(this.logWriter);
+    Services.setSecurityLogWriter(this.securityLogWriter);
+    final long offHeapMemorySize = OffHeapStorage.parseOffHeapMemorySize(getConfig().getOffHeapMemorySize());
+
+    this.offHeapStore = OffHeapStorage.createOffHeapStorage(getLogWriter(), this, offHeapMemorySize, this);
+    
+    // Note: this can only happen on a linux system
+    if (getConfig().getLockMemory()) {
+      // This calculation is not exact, but seems fairly close.  So far we have
+      // not loaded much into the heap and the current RSS usage is already 
+      // included the available memory calculation.
+      long avail = LinuxProcFsStatistics.getAvailableMemory(logger);
+      long size = offHeapMemorySize + Runtime.getRuntime().totalMemory();
+      if (avail < size) {
+        if (GemFireCacheImpl.ALLOW_MEMORY_LOCK_WHEN_OVERCOMMITTED) {
+          logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+        } else {
+          throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT.toLocalizedString(avail, size));
+        }
+      }
+      
+      logger.info("Locking memory. This may take a while...");
+      GemFireCacheImpl.lockMemory();
+      logger.info("Finished locking memory.");
+    }
+
-    if (!this.isLoner) {
-      this.dm.restartCommunications();
-    }
-            if (this.isConnected) {
-              InternalDistributedMember id = this.dm.getDistributionManagerId();
-              LocatorImpl gs = this.startedLocator.getLocatorHandler();
-              gs.setLocalAddress(id);
-            }
-              this.startedLocator = null;
-          this.startedLocator = null;
-      reconnected = tryReconnect(true, reason, GemFireCacheImpl.getInstance());
+    
+     reconnected = tryReconnect(true, reason, GemFireCacheImpl.getInstance());
-   * Ensure that the JGroupMembershipManager class gets loaded.
+   * Ensure that the MembershipManager class gets loaded.
-    JGroupMembershipManager.loadEmergencyClasses();
+    GMSMembershipManager.loadEmergencyClasses();
-            this.startedLocator.stop(preparingForReconnect, false);
+            this.startedLocator.stop(forcedDisconnect, preparingForReconnect, false);
+        if (getOffHeapStore() != null) {
+          getOffHeapStore().close();
+        }
+      } finally {
+      try {
+      }
-    if (me.getMcastPort() != 0) {
-      // mcast
-      return me.getMcastPort() == other.getMcastPort() &&
-        me.getMcastAddress().equals(other.getMcastAddress());
+    // locators
+    String myLocators = me.getLocators();
+    String otherLocators = other.getLocators();
+
+    // quick check
+    if (myLocators.equals(otherLocators)) {
+      return true;
-      // locators
-      String myLocators = me.getLocators();
-      String otherLocators = other.getLocators();
+      myLocators = canonicalizeLocators(myLocators);
+      otherLocators = canonicalizeLocators(otherLocators);
-      // quick check
-      if (myLocators.equals(otherLocators)) {
-        return true;
-
-      } else {
-        myLocators = canonicalizeLocators(myLocators);
-        otherLocators = canonicalizeLocators(otherLocators);
-
-        return myLocators.equals(otherLocators);
-      }
+      return myLocators.equals(otherLocators);
-      if (!locId.isMcastId()) {
-        String addr = locId.getBindAddress();
-        if (addr != null && addr.trim().length() > 0) {
-          canonical.append(addr);
-        }
-        else {
-          canonical.append(locId.getHost().getHostAddress());
-        }
-        canonical.append("[");
-        canonical.append(String.valueOf(locId.getPort()));
-        canonical.append("]");
-        sorted.add(canonical.toString());
+      String addr = locId.getBindAddress();
+      if (addr != null && addr.trim().length() > 0) {
+        canonical.append(addr);
+      else {
+        canonical.append(locId.getHost().getHostAddress());
+      }
+      canonical.append("[");
+      canonical.append(String.valueOf(locId.getPort()));
+      canonical.append("]");
+      sorted.add(canonical.toString());
-      Set<InetAddress> equivalentAddresses = dm.getEquivalents(member.getIpAddress());
+      Set<InetAddress> equivalentAddresses = dm.getEquivalents(member.getInetAddress());
-      if(address.equals(member.getIpAddress()) || equivalentAddresses.contains(address)) {
+      if(address.equals(member.getInetAddress()) || equivalentAddresses.contains(address)) {
-    
-          if (!forcedDisconnect &&
-              !oldCache.isClosed() &&
-              oldCache.getCachePerfStats().getReliableRegionsMissing() == 0) {
+          if (!forcedDisconnect && !oldCache.isClosed() && oldCache.getCachePerfStats().getReliableRegionsMissing() == 0) {
-        
+
-            if (this.config.getDisableAutoReconnect()) {
+            if (config.getDisableAutoReconnect()) {
-          return this.reconnectDS != null && this.reconnectDS.isConnected();
+          return (this.reconnectDS != null && this.reconnectDS.isConnected());
+    List<CacheServerCreation> cacheServerCreation = null;
+    
+        cacheServerCreation = cache.getCacheConfig().getCacheServerCreation();
-    boolean mcastDiscovery = oldConfig.getLocators().isEmpty()
-        && oldConfig.getStartLocator().isEmpty()
-        && oldConfig.getMcastPort() != 0;
-    boolean mcastQuorumContacted = false;
-    
-
-    if (Thread.currentThread().getName().equals("CloserThread")) {
+    if (Thread.currentThread().getName().equals("DisconnectThread")) {
-        logger.debug("changing thread name to ReconnectThread"); // wha?! really?
+        logger.debug("changing thread name to ReconnectThread");
-        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING, new Object[]{reconnectAttemptCounter}));
+        logger.info("Disconnecting old DistributedSystem to prepare for a reconnect attempt");
-          if (mcastDiscovery  &&  (quorumChecker != null) && !mcastQuorumContacted) {
-            mcastQuorumContacted = quorumChecker.checkForQuorum(3*this.config.getMemberTimeout());
-            if (!mcastQuorumContacted) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("quorum check failed - skipping reconnect attempt");
-              }
-              continue;
-            }
-            if (logger.isDebugEnabled()) {
-              logger.debug(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_QUORUM_OF_MEMBERS_CONTACTED));
-            }
-            mcastQuorumContacted = true;
-            // bug #51527: become more aggressive about reconnecting since there are other 
-            // members around now
-            if (timeOut > 5000) {
-              timeOut = 5000;
-            }
-          }
+            if (cacheServerCreation != null) {
+              for (CacheServerCreation bridge: cacheServerCreation) {
+                CacheServerImpl impl = (CacheServerImpl)cache.addCacheServer();
+                impl.configureFrom(bridge);
+                try {
+                  if (!impl.isRunning()) {
+                    impl.start();
+                  }
+                } catch (IOException ex) {
+                  throw new GemFireIOException(
+                      LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0
+                          .toLocalizedString(impl), ex);
+                }
+              }
+            }
-              if (isDebugEnabled) {
-                logger.debug("Reconnected properly");
-              }  
+              logger.info("Reconnected properly");

GEODE-2860: Refactor use of EventTracker

  * change EventTracker to an interface with two implementations
  * move as much logic out of LocalRegion down into subclasses that
    make use EventTracker
  * move and refactor static inner classes in EventTracker into own
    class files
  * migrate some of event-focused classes into a new sub package
  * add tests for existing logic from EventTracker

This closes #638

-import org.apache.geode.internal.cache.EventTracker.EventSeqnoHolder;
+import org.apache.geode.internal.cache.event.EventSequenceNumberHolder;
-  public void createEventTracker() {
-    this.eventTracker = new EventTracker(this);
-    this.eventTracker.start();
-  }
-
-  @Override
-      Map<ThreadIdentifier, EventSeqnoHolder> providerEventStates =
+      Map<ThreadIdentifier, EventSequenceNumberHolder> providerEventStates =
-          && this.eventTracker.isInitialImageProvider(event.getDistributedMember())) {
+          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-          && this.eventTracker.isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-          && this.eventTracker.isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-          && this.eventTracker.isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+  @Override
+  public boolean hasSeenEvent(EntryEventImpl event) {
+    ensureEventTrackerInitialization();
+    return super.hasSeenEvent(event);
+  }
+
+  // bug 41289 - wait for event tracker to be initialized before checkin
+  // so that an operation intended for a previous version of a bucket
+  // is not prematurely applied to a new version of the bucket
+  private void ensureEventTrackerInitialization() {
+    try {
+      getEventTracker().waitOnInitialization();
+    } catch (InterruptedException ie) {
+      stopper.checkCancelInProgress(ie);
+      Thread.currentThread().interrupt();
+    }
+  }
+

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-  
+
-  
+
-  
-  protected RemoveAll() {
-  }
-  
+
+  protected RemoveAll() {}
+
-  throws IOException, InterruptedException {
-    long start = startp;  // copy this since we need to modify it
+      throws IOException, InterruptedException {
+    long start = startp; // copy this since we need to modify it
-    
+
-    
+
-    
+
-      
+
-        String txt = LocalizedStrings.RemoveAll_THE_INPUT_REGION_NAME_FOR_THE_REMOVEALL_REQUEST_IS_NULL.toLocalizedString();
-        logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON, new Object[] {servConn.getName(), txt}));
+        String txt =
+            LocalizedStrings.RemoveAll_THE_INPUT_REGION_NAME_FOR_THE_REMOVEALL_REQUEST_IS_NULL
+                .toLocalizedString();
+        logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON,
+            new Object[] {servConn.getName(), txt}));
-        writeChunkedErrorResponse(msg, MessageType.PUT_DATA_ERROR,
-            errMessage.toString(), servConn);
+        writeChunkedErrorResponse(msg, MessageType.PUT_DATA_ERROR, errMessage.toString(), servConn);
-      LocalRegion region = (LocalRegion)servConn.getCache().getRegion(regionName);
+      LocalRegion region = (LocalRegion) servConn.getCache().getRegion(regionName);
-      ByteBuffer eventIdPartsBuffer = ByteBuffer.wrap(eventPart
-          .getSerializedForm());
-      long threadId = EventID
-      .readEventIdPartsFromOptmizedByteArray(eventIdPartsBuffer);
-      long sequenceId = EventID
-      .readEventIdPartsFromOptmizedByteArray(eventIdPartsBuffer);
-      EventID eventId = new EventID(servConn.getEventMemberIDByteArray(),
-          threadId, sequenceId);
-      
+      ByteBuffer eventIdPartsBuffer = ByteBuffer.wrap(eventPart.getSerializedForm());
+      long threadId = EventID.readEventIdPartsFromOptmizedByteArray(eventIdPartsBuffer);
+      long sequenceId = EventID.readEventIdPartsFromOptmizedByteArray(eventIdPartsBuffer);
+      EventID eventId = new EventID(servConn.getEventMemberIDByteArray(), threadId, sequenceId);
+
-      
+
-      
+
-      Object callbackArg =  msg.getPart(3).getObject();
-      
+      Object callbackArg = msg.getPart(3).getObject();
+
-      
+
-        buffer
-                .append(servConn.getName())
-                .append(": Received removeAll request from ")
-                .append(servConn.getSocketString())
-                .append(" for region ")
-                .append(regionName)
-                .append(callbackArg != null ? (" callbackArg " + callbackArg) : "")
-                .append(" with ")
-                .append(numberOfKeys)
-                .append(" keys.");
+        buffer.append(servConn.getName()).append(": Received removeAll request from ")
+            .append(servConn.getSocketString()).append(" for region ").append(regionName)
+            .append(callbackArg != null ? (" callbackArg " + callbackArg) : "").append(" with ")
+            .append(numberOfKeys).append(" keys.");
-      for (int i=0; i<numberOfKeys; i++) {
-        keyPart = msg.getPart(5+i);
+      for (int i = 0; i < numberOfKeys; i++) {
+        keyPart = msg.getPart(5 + i);
-          String txt = LocalizedStrings.RemoveAll_ONE_OF_THE_INPUT_KEYS_FOR_THE_REMOVEALL_REQUEST_IS_NULL.toLocalizedString();
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON, new Object[] {servConn.getName(), txt}));
+          String txt =
+              LocalizedStrings.RemoveAll_ONE_OF_THE_INPUT_KEYS_FOR_THE_REMOVEALL_REQUEST_IS_NULL
+                  .toLocalizedString();
+          logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON,
+              new Object[] {servConn.getName(), txt}));
-          writeChunkedErrorResponse(msg, MessageType.PUT_DATA_ERROR,
-              errMessage.toString(), servConn);
+          writeChunkedErrorResponse(msg, MessageType.PUT_DATA_ERROR, errMessage.toString(),
+              servConn);
-          //Constuct the thread id/sequence id information for this element of the bulk op
-          
-          //The sequence id is constructed from the base sequence id and the offset
-          EventID entryEventId= new EventID(eventId, i);
-          
-          //For PRs, the thread id assigned as a fake thread id.
-          if(region instanceof PartitionedRegion) {
+          // Constuct the thread id/sequence id information for this element of the bulk op
+
+          // The sequence id is constructed from the base sequence id and the offset
+          EventID entryEventId = new EventID(eventId, i);
+
+          // For PRs, the thread id assigned as a fake thread id.
+          if (region instanceof PartitionedRegion) {
-            long entryThreadId = ThreadIdentifier.createFakeThreadIDForBulkOp(bucketId, entryEventId.getThreadID());
-            entryEventId = new EventID(entryEventId.getMembershipID(), entryThreadId, entryEventId.getSequenceID());
+            long entryThreadId =
+                ThreadIdentifier.createFakeThreadIDForBulkOp(bucketId, entryEventId.getThreadID());
+            entryEventId = new EventID(entryEventId.getMembershipID(), entryThreadId,
+                entryEventId.getSequenceID());
-            
+
-          //FIND THE VERSION TAG FOR THIS KEY - but how?  all we have is the
-          //    removeAll eventId, not individual eventIds for entries, right?
+          // FIND THE VERSION TAG FOR THIS KEY - but how? all we have is the
+          // removeAll eventId, not individual eventIds for entries, right?
-      
-      if ( msg.getNumberOfParts() == ( 5 + numberOfKeys + 1) ) {//it means optional timeout has been added
+
+      if (msg.getNumberOfParts() == (5 + numberOfKeys + 1)) {// it means optional timeout has been
+                                                             // added
-        }
-        else {
-          RemoveAllOperationContext removeAllContext = authzRequest.removeAllAuthorize(regionName, keys, callbackArg);
+        } else {
+          RemoveAllOperationContext removeAllContext =
+              authzRequest.removeAllAuthorize(regionName, keys, callbackArg);
-      
-      response = region.basicBridgeRemoveAll(keys, retryVersions, servConn.getProxyID(), eventId, callbackArg);
+
+      response = region.basicBridgeRemoveAll(keys, retryVersions, servConn.getProxyID(), eventId,
+          callbackArg);
-          logger.trace("setting removeAll response to null. region-cc-enabled={}; clientIsEmpty={}; client-cc-enabled={}",
+          logger.trace(
+              "setting removeAll response to null. region-cc-enabled={}; clientIsEmpty={}; client-cc-enabled={}",
-      
+
-        PartitionedRegion pr = (PartitionedRegion)region;
+        PartitionedRegion pr = (PartitionedRegion) region;
-    } 
-    catch (RegionDestroyedException rde) {
+    } catch (RegionDestroyedException rde) {
-    }
-    catch (ResourceException re) {
+    } catch (ResourceException re) {
-    }
-    catch (PutAllPartialResultException pre) {
+    } catch (PutAllPartialResultException pre) {
-    }
-    catch (Exception ce) {
+    } catch (Exception ce) {
-      
+
-      logger.warn(LocalizedMessage.create(LocalizedStrings.Generic_0_UNEXPECTED_EXCEPTION, servConn.getName()), ce);
+      logger.warn(LocalizedMessage.create(LocalizedStrings.Generic_0_UNEXPECTED_EXCEPTION,
+          servConn.getName()), ce);
-    }
-    finally {
+    } finally {
-          servConn.getSocketString(), regionName, (logger.isTraceEnabled()? ": " + response : ""));
+          servConn.getSocketString(), regionName, (logger.isTraceEnabled() ? ": " + response : ""));
-    
+
-  
+
-  protected void writeReply(Message origMsg, ServerConnection servConn)
-  throws IOException {
+  protected void writeReply(Message origMsg, ServerConnection servConn) throws IOException {
-  
-  
+
+
-          (logger.isTraceEnabled()? " list=" + response : ""));
+          (logger.isTraceEnabled() ? " list=" + response : ""));
-      int chunkSize = 2*maximumChunkSize;
+      int chunkSize = 2 * maximumChunkSize;
-      VersionedObjectList.Chunker chunk = new VersionedObjectList.Chunker(response, chunkSize, false, false);
-      for (int i=0; i<listSize; i+=chunkSize) {
-        boolean lastChunk = (i+chunkSize >= listSize);
+      VersionedObjectList.Chunker chunk =
+          new VersionedObjectList.Chunker(response, chunkSize, false, false);
+      for (int i = 0; i < listSize; i += chunkSize) {
+        boolean lastChunk = (i + chunkSize >= listSize);
-          logger.debug("sending chunk at index {} last chunk={} numParts={}",i , lastChunk, replyMsg.getNumberOfParts());
+          logger.debug("sending chunk at index {} last chunk={} numParts={}", i, lastChunk,
+              replyMsg.getNumberOfParts());
-  protected void writeReplyWithRefreshMetadata(Message origMsg,
-      ServerConnection servConn, PartitionedRegion pr, byte nwHop) throws IOException {
+  protected void writeReplyWithRefreshMetadata(Message origMsg, ServerConnection servConn,
+      PartitionedRegion pr, byte nwHop) throws IOException {
-  
-  private void writeReplyWithRefreshMetadata(Message origMsg,
-      VersionedObjectList response, ServerConnection servConn,
-      PartitionedRegion pr, byte nwHop) throws IOException {
+
+  private void writeReplyWithRefreshMetadata(Message origMsg, VersionedObjectList response,
+      ServerConnection servConn, PartitionedRegion pr, byte nwHop) throws IOException {
-      logger.debug("sending chunked response header with metadata refresh status. Version list size = {}{}",
-          listSize, (logger.isTraceEnabled()? "; list=" + response : ""));
+      logger.debug(
+          "sending chunked response header with metadata refresh status. Version list size = {}{}",
+          listSize, (logger.isTraceEnabled() ? "; list=" + response : ""));
-    replyMsg.addBytesPart(new byte[]{pr.getMetadataVersion(), nwHop});
+    replyMsg.addBytesPart(new byte[] {pr.getMetadataVersion(), nwHop});
-      
-      int chunkSize = 2*maximumChunkSize; // maximumChunkSize
+
+      int chunkSize = 2 * maximumChunkSize; // maximumChunkSize
-      VersionedObjectList.Chunker chunk = new VersionedObjectList.Chunker(response, chunkSize, false, false);
-      for (int i=0; i<listSize; i+=chunkSize) {
-        boolean lastChunk = (i+chunkSize >= listSize);
+      VersionedObjectList.Chunker chunk =
+          new VersionedObjectList.Chunker(response, chunkSize, false, false);
+      for (int i = 0; i < listSize; i += chunkSize) {
+        boolean lastChunk = (i + chunkSize >= listSize);
-          logger.debug("sending chunk at index {} last chunk={} numParts={}", i, lastChunk, replyMsg.getNumberOfParts());
+          logger.debug("sending chunk at index {} last chunk={} numParts={}", i, lastChunk,
+              replyMsg.getNumberOfParts());
-      logger.trace("{}: rpl with REFRESH_METADAT tx: {}", servConn.getName(), origMsg.getTransactionId());
+      logger.trace("{}: rpl with REFRESH_METADAT tx: {}", servConn.getName(),
+          origMsg.getTransactionId());

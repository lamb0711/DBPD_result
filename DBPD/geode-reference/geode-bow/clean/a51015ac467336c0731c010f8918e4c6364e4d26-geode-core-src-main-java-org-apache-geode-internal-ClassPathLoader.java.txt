GEODE-6822: Deploying jars only creates new classloader for the newly deployed jar (#3537)

  * Deserialized objects of classes unrelated to the latest deployed jar should now compare correctly after an unrelated new jar is deployed
  * This solution causes each deployed jar to create it's own class loader and chains them together.
  * The class loaders are now child first class loaders and If a class cannot be found, it will search all 'sibling'/other deployed jars
  * When a jar is redeployed (new version), we keep some meta data in a map so we no longer crawl the 'old' jar when possible and only search through the latest version of a specific jar.
  * Java does some caching of classes and in the undeploy scenario, we may still be able to load classes that have been "removed" from the new jar (only if it was already cached by some other class loader). This can happen when we have inter jar dependencies.
  * Geode also caches classes, so whenever a redeploy occurs, the geode class cache gets wiped, and first lookups take a minor performance hit, but subsequent lookups go through geodes caching of the classes (so the for name and class lookups through chaining should have a minimal impact)

-import java.net.URLClassLoader;
+import java.util.Collection;
+import java.util.HashMap;
-  private volatile URLClassLoader classLoaderForDeployedJars;
+  public final HashMap<String, DeployJarChildFirstClassLoader> latestJarNamesToClassLoader =
+      new HashMap<>();
+
+  private volatile DeployJarChildFirstClassLoader leafLoader;
-  void rebuildClassLoaderForDeployedJars() {
-    ClassLoader parent = ClassPathLoader.class.getClassLoader();
-
-    this.classLoaderForDeployedJars = new URLClassLoader(jarDeployer.getDeployedJarURLs(), parent);
-  }
-
+  synchronized void rebuildClassLoaderForDeployedJars() {
+    leafLoader = null;
+    Collection<DeployedJar> deployedJars = jarDeployer.getDeployedJars().values();
+    for (DeployedJar deployedJar : deployedJars) {
+      chainClassloader(deployedJar);
+    }
+  }
+
+  ClassLoader getLeafLoader() {
+    if (leafLoader == null) {
+      return ClassPathLoader.class.getClassLoader();
+    }
+    return leafLoader;
+  }
+
+  synchronized void chainClassloader(DeployedJar jar) {
+    this.leafLoader = new DeployJarChildFirstClassLoader(latestJarNamesToClassLoader,
+        new URL[] {jar.getFileURL()}, jar.getJarName(), getLeafLoader());
+  }
+
+  synchronized void unloadClassloaderForJar(String jarName) {
+    latestJarNamesToClassLoader.put(jarName, null);
+  }
+
+    Class<?> clazz = forName(name, isDebugEnabled);
+    if (clazz != null)
+      return clazz;
+
+    throw new ClassNotFoundException(name);
+  }
+
+  private Class<?> forName(String name, boolean isDebugEnabled) {
+        // Do not look up class definitions in jars that have been unloaded or are old
+        if (classLoader instanceof DeployJarChildFirstClassLoader) {
+          if (((DeployJarChildFirstClassLoader) classLoader).thisIsOld()) {
+            return null;
+          }
+        }
-
-
-    throw new ClassNotFoundException(name);
+    return null;
-    if (classLoaderForDeployedJars != null) {
-      classLoaders.add(classLoaderForDeployedJars);
-    }
-
+    classLoaders.add(getLeafLoader());

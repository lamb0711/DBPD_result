Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public final class DiskWriteAttributesImpl implements DiskWriteAttributes
-{
+public final class DiskWriteAttributesImpl implements DiskWriteAttributes {
-   * The the number of milliseconds that can elapse before unwritten data is
-   * written to disk.
+   * The the number of milliseconds that can elapse before unwritten data is written to disk.
-   * The number of bytes of region entry data to queue up before writing to
-   * disk.
+   * The number of bytes of region entry data to queue up before writing to disk.
-  /** stored in bytes as a long but specified in megabytes by client applications**/
+  /** stored in bytes as a long but specified in megabytes by client applications **/
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "DEFAULT_MAX_OPLOG_SIZE", 1024L).longValue() * (1024 * 1024); // 1 GB
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "DEFAULT_MAX_OPLOG_SIZE", 1024L).longValue()
+          * (1024 * 1024); // 1 GB
-  private static final long DEFAULT_MAX_OPLOG_SIZE_LIMIT = (long)Integer.MAX_VALUE * (1024*1024);
+  private static final long DEFAULT_MAX_OPLOG_SIZE_LIMIT = (long) Integer.MAX_VALUE * (1024 * 1024);
-//  private static final long DEFAULT_BYTES_THRESHOLD = 0;
+  // private static final long DEFAULT_BYTES_THRESHOLD = 0;
-   * Creates a new <code>DiskWriteAttributes</code> object using the
-   * properties specified. The properties that can be specified are:
+   * Creates a new <code>DiskWriteAttributes</code> object using the properties specified. The
+   * properties that can be specified are:
-   * <li>synchronous : boolean to specify whether DiskWrites will be
-   * synchronous (true)/asynchronous (false)
-   * <li>auto-compact : boolean to specify whether to automatically compact
-   * disk files so they use less disk space (true)
-   * <li>allow-force-compaction : boolean to specify whether to manual compaction
-   * of disk files is allowed (false)
-   * <li>compaction-threshold: The threshold at which an oplog becomes compactable.
-   *   Must be in the range 0..100 inclusive. (50)
+   * <li>synchronous : boolean to specify whether DiskWrites will be synchronous (true)/asynchronous
+   * (false)
+   * <li>auto-compact : boolean to specify whether to automatically compact disk files so they use
+   * less disk space (true)
+   * <li>allow-force-compaction : boolean to specify whether to manual compaction of disk files is
+   * allowed (false)
+   * <li>compaction-threshold: The threshold at which an oplog becomes compactable. Must be in the
+   * range 0..100 inclusive. (50)
-   * <li>time-interval: The number of milliseconds that can elapse before
-   * unwritten data is written to disk.
-   * <li>bytes-threshold: The number of unwritten bytes of data that can be
-   * enqueued before being written to disk
+   * <li>time-interval: The number of milliseconds that can elapse before unwritten data is written
+   * to disk.
+   * <li>bytes-threshold: The number of unwritten bytes of data that can be enqueued before being
+   * written to disk
-   * The above properties are case sensitive and if a propery which is not in
-   * the list above is passed no action is taken. If a property which is present
-   * above is not specified then the following default values will be uses
+   * The above properties are case sensitive and if a propery which is not in the list above is
+   * passed no action is taken. If a property which is present above is not specified then the
+   * following default values will be uses
-   * @throws IllegalArgumentException
-   *           If any of the properties specified are not in the expected
-   *           format.
-   * @throws IllegalStateException
-   *           if max-oplog-size is set to infinity(0) and compaction is set to
-   *           true
+   * @throws IllegalArgumentException If any of the properties specified are not in the expected
+   *         format.
+   * @throws IllegalStateException if max-oplog-size is set to infinity(0) and compaction is set to
+   *         true
-    }
-    else {
+    } else {
-    String bytesThresholdString = properties
-        .getProperty(CacheXml.BYTES_THRESHOLD);
+    String bytesThresholdString = properties.getProperty(CacheXml.BYTES_THRESHOLD);
-      this.bytesThreshold = verifyLongInString(bytesThresholdString,
-          CacheXml.BYTES_THRESHOLD);
-    }
-    else {
+      this.bytesThreshold = verifyLongInString(bytesThresholdString, CacheXml.BYTES_THRESHOLD);
+    } else {
-    
+
-      this.timeInterval = verifyLongInString(timeIntervalString,
-          CacheXml.TIME_INTERVAL);
-    }
-    else {
-      if (!this.isSynchronous && this.bytesThreshold == 0 ) {
-        this.timeInterval =DiskWriteAttributesImpl.DEFAULT_TIME_INTERVAL;
-      }else {
+      this.timeInterval = verifyLongInString(timeIntervalString, CacheXml.TIME_INTERVAL);
+    } else {
+      if (!this.isSynchronous && this.bytesThreshold == 0) {
+        this.timeInterval = DiskWriteAttributesImpl.DEFAULT_TIME_INTERVAL;
+      } else {
-    
-    
+
+
-      long opSize = verifyLongInString(maxOplogSizeString,
-          CacheXml.MAX_OPLOG_SIZE);
+      long opSize = verifyLongInString(maxOplogSizeString, CacheXml.MAX_OPLOG_SIZE);
-        throw new IllegalStateException(LocalizedStrings.DiskWriteAttributesImpl_COMPACTION_CANNOT_BE_SET_TO_TRUE_IF_MAXOPLOGSIZE_IS_SET_TO_INFINITE_INFINITE_IS_REPRESENTED_BY_SIZE_ZERO_0.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.DiskWriteAttributesImpl_COMPACTION_CANNOT_BE_SET_TO_TRUE_IF_MAXOPLOGSIZE_IS_SET_TO_INFINITE_INFINITE_IS_REPRESENTED_BY_SIZE_ZERO_0
+                .toLocalizedString());
-          throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_CANNOT_SET_MAXOPLOGS_SIZE_TO_INFINITY_0_IF_COMPACTION_IS_SET_TO_TRUE.toLocalizedString());
-        }
-        else {
+          throw new IllegalArgumentException(
+              LocalizedStrings.DiskWriteAttributesImpl_CANNOT_SET_MAXOPLOGS_SIZE_TO_INFINITY_0_IF_COMPACTION_IS_SET_TO_TRUE
+                  .toLocalizedString());
+        } else {
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-   * Verifys if the propertyString passed is a valid boolean value or null else
-   * throws an IllegalArgument exception
+   * Verifys if the propertyString passed is a valid boolean value or null else throws an
+   * IllegalArgument exception
-   * @throws IllegalArgumentException
-   *           if the property string passed does not represent a boolean or
-   *           null
-   *  
+   * @throws IllegalArgumentException if the property string passed does not represent a boolean or
+   *         null
+   * 
-  private void verifyBooleanString(String propertyString, String property)
-  {
-    if (!(propertyString.equalsIgnoreCase("true")
-        || propertyString.equalsIgnoreCase("false"))) {
-      throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_0_PROPERTY_HAS_TO_BE_TRUE_OR_FALSE_OR_NULL_AND_CANNOT_BE_1.toLocalizedString(new Object[] {property, propertyString}));
+  private void verifyBooleanString(String propertyString, String property) {
+    if (!(propertyString.equalsIgnoreCase("true") || propertyString.equalsIgnoreCase("false"))) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.DiskWriteAttributesImpl_0_PROPERTY_HAS_TO_BE_TRUE_OR_FALSE_OR_NULL_AND_CANNOT_BE_1
+              .toLocalizedString(new Object[] {property, propertyString}));
-   * Verifys if the string passed, is in a number format which is acceptable and
-   * returns the long value of the string.
+   * Verifys if the string passed, is in a number format which is acceptable and returns the long
+   * value of the string.
-  private long verifyLongInString(String propertyString, String property)
-  {
+  private long verifyLongInString(String propertyString, String property) {
-    }
-    catch (NumberFormatException e) {
-      throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_A_VALID_NUMBER_AND_NOT_1.toLocalizedString(new Object[] {property, propertyString}));
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_A_VALID_NUMBER_AND_NOT_1
+              .toLocalizedString(new Object[] {property, propertyString}));
-      throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_POSITIVE_NUMBER_AND_THE_VALUE_GIVEN_1_IS_NOT_ACCEPTABLE.toLocalizedString(
-            new Object[] {property, Long.valueOf(returnValue)}));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_POSITIVE_NUMBER_AND_THE_VALUE_GIVEN_1_IS_NOT_ACCEPTABLE
+              .toLocalizedString(new Object[] {property, Long.valueOf(returnValue)}));
-   * Verifys if the string passed, is in a number format which is acceptable and
-   * returns the int value of the string.
+   * Verifys if the string passed, is in a number format which is acceptable and returns the int
+   * value of the string.
-  private int verifyPercentInString(String propertyString, String property)
-  {
+  private int verifyPercentInString(String propertyString, String property) {
-    }
-    catch (NumberFormatException e) {
-      throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_A_VALID_NUMBER_AND_NOT_1.toLocalizedString(new Object[] {property, propertyString}));
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_A_VALID_NUMBER_AND_NOT_1
+              .toLocalizedString(new Object[] {property, propertyString}));
-      throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_POSITIVE_NUMBER_AND_THE_VALUE_GIVEN_1_IS_NOT_ACCEPTABLE.toLocalizedString(
-            new Object[] {property, Integer.valueOf(returnValue)}));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_POSITIVE_NUMBER_AND_THE_VALUE_GIVEN_1_IS_NOT_ACCEPTABLE
+              .toLocalizedString(new Object[] {property, Integer.valueOf(returnValue)}));
-      throw new IllegalArgumentException(LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_LESS_THAN_2_BUT_WAS_1.toLocalizedString(new Object[] {property, Integer.valueOf(returnValue), Integer.valueOf(100)}));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DiskWriteAttributesImpl_0_HAS_TO_BE_LESS_THAN_2_BUT_WAS_1
+              .toLocalizedString(
+                  new Object[] {property, Integer.valueOf(returnValue), Integer.valueOf(100)}));
-   * Returns whether or not this <code>DiskWriteAttributes</code> configures
-   * synchronous writes.
+   * Returns whether or not this <code>DiskWriteAttributes</code> configures synchronous writes.
-  public boolean isSynchronous()
-  {
+  public boolean isSynchronous() {
-  public boolean isRollOplogs()
-  {
+  public boolean isRollOplogs() {
-  public int getMaxOplogSize()
-  {
-    return (int)(maxOplogSize/(1024 * 1024));
+  public int getMaxOplogSize() {
+    return (int) (maxOplogSize / (1024 * 1024));
-  long getMaxOplogSizeInBytes()
-  {
+  long getMaxOplogSizeInBytes() {
-  
+
-   * Returns the number of milliseconds that can elapse before unwritten data is
-   * written to disk. If this <code>DiskWriteAttributes</code> configures
-   * synchronous writing, then <code>timeInterval</code> has no meaning.
+   * Returns the number of milliseconds that can elapse before unwritten data is written to disk. If
+   * this <code>DiskWriteAttributes</code> configures synchronous writing, then
+   * <code>timeInterval</code> has no meaning.
-  public long getTimeInterval()
-  {
+  public long getTimeInterval() {
-   * Returns the number of unwritten bytes of data that can be enqueued before
-   * being written to disk. If this <code>DiskWriteAttributes</code>
-   * configures synchronous writing, then <code>bytesThreshold</code> has no
-   * meaning.
+   * Returns the number of unwritten bytes of data that can be enqueued before being written to
+   * disk. If this <code>DiskWriteAttributes</code> configures synchronous writing, then
+   * <code>bytesThreshold</code> has no meaning.
-  public long getBytesThreshold()
-  {
+  public long getBytesThreshold() {
-   * Two <code>DiskWriteAttributes</code> are equal if the both specify the
-   * synchronous writes, or they both specify asynchronous writes with the same
-   * time interval and bytes threshold.
+   * Two <code>DiskWriteAttributes</code> are equal if the both specify the synchronous writes, or
+   * they both specify asynchronous writes with the same time interval and bytes threshold.
-  public boolean equals(Object o)
-  {
+  public boolean equals(Object o) {
-    DiskWriteAttributesImpl other = (DiskWriteAttributesImpl)o;
+    DiskWriteAttributesImpl other = (DiskWriteAttributesImpl) o;
-    boolean result = other.isRollOplogs() == isRollOplogs()
-      && other.getMaxOplogSize() == getMaxOplogSize();
+    boolean result =
+        other.isRollOplogs() == isRollOplogs() && other.getMaxOplogSize() == getMaxOplogSize();
-      result = result
-        && other.getTimeInterval() == getTimeInterval()
-        && other.getBytesThreshold() == getBytesThreshold();
+      result = result && other.getTimeInterval() == getTimeInterval()
+          && other.getBytesThreshold() == getBytesThreshold();
+   * 
-   * Note that we just need to make sure that equal objects return equal
-   * hashcodes; nothing really elaborate is done here.
+   * Note that we just need to make sure that equal objects return equal hashcodes; nothing really
+   * elaborate is done here.
-    
+
-    }
-    else {
+    } else {
-  
+
-  public String toString()
-  {
+  public String toString() {
-    }
-    else {
+    } else {
-     return sb.toString();
+    return sb.toString();
+   * 
-  public static int getDefaultMaxOplogSizeLimit()
-  {
-    return (int)(DEFAULT_MAX_OPLOG_SIZE_LIMIT/(1024*1024));
+  public static int getDefaultMaxOplogSizeLimit() {
+    return (int) (DEFAULT_MAX_OPLOG_SIZE_LIMIT / (1024 * 1024));
-  public static boolean getDefaultRollOplogsValue()
-  {
+  public static boolean getDefaultRollOplogsValue() {
-  public static int getDefaultMaxOplogSize()
-  {
-    return (int)(DEFAULT_MAX_OPLOG_SIZE/(1024*1024));
+  public static int getDefaultMaxOplogSize() {
+    return (int) (DEFAULT_MAX_OPLOG_SIZE / (1024 * 1024));
-   * Returns a default instance of  DiskWriteAttributes
+   * Returns a default instance of DiskWriteAttributes
+   * 
-  public static DiskWriteAttributes getDefaultAsyncInstance()
-  {
+  public static DiskWriteAttributes getDefaultAsyncInstance() {
-  public static DiskWriteAttributes getDefaultSyncInstance()
-  {
+
+  public static DiskWriteAttributes getDefaultSyncInstance() {

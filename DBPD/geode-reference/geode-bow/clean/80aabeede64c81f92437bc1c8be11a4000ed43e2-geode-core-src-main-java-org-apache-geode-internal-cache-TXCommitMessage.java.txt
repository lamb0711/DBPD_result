 GEODE-5305: Add flag to TXCommitMessage to indicate the use of shadow key (#2043)

* Add new unit test for TxCommentMessage serialization.

Co-authored-by: Darrel Schneider <dschneider@pivotal.io>

-  /** (Nearside) true of any regions in this TX have required roles */
+  /**
+   * (Nearside) true of any regions in this TX have required roles
+   */
-  /** Set of all caching exceptions produced hile processing this tx */
+  /**
+   * Set of all caching exceptions produced hile processing this tx
+   */
-   * TransactionDataNodeHasDepartedException while committing a transaction
+   * TransactionDataNodeHasDepartedException
+   * while committing a transaction
-      this.currentRegion.persistentIds = getPersistentIds(this.currentRegion.r);
+      this.currentRegion.persistentIds = getPersistentIds(this.currentRegion.internalRegion);
-  /** record CacheDistributionAdvisor.startOperation versions for later cleanup */
+  /**
+   * record CacheDistributionAdvisor.startOperation versions for later cleanup
+   */
-                                                     // receivers
+    // receivers
-        if (!rc.r.requiresReliabilityCheck()) {
+        if (!rc.internalRegion.requiresReliabilityCheck()) {
-          : processor.getRegionDestroyedMembers(rc.r.getFullPath());
+          : processor.getRegionDestroyedMembers(rc.internalRegion.getFullPath());
-        rc.r.handleReliableDistribution(successfulRecipients);
+        rc.internalRegion.handleReliableDistribution(successfulRecipients);
-        failedRegionNames.add(rc.r.getFullPath());
+        failedRegionNames.add(rc.internalRegion.getFullPath());
-  public DistributionManager getDM() {
-    if (this.dm == null) {
-      InternalCache cache = GemFireCacheImpl.getExisting("Applying TXCommit");
-      this.dm = cache.getDistributionManager();
-    }
-    return this.dm;
-  }
-
-                rc.r = null; // Cause related FarSideEntryOps to skip processing
+                rc.internalRegion = null; // Cause related FarSideEntryOps to skip processing
-
+    final boolean hasShadowKeys = hasFlagsField(in) ? in.readBoolean() : useShadowKey();
+
-        rc.fromData(in);
+        rc.fromData(in, hasShadowKeys);
+    final boolean useShadowKey = useShadowKey();
+    if (hasFlagsField(out)) {
+      out.writeBoolean(useShadowKey);
+    }
-          rc.toData(out);
+          rc.toData(out, useShadowKey);
+  private boolean hasFlagsField(final DataOutput out) {
+    return hasFlagsField(InternalDataSerializer.getVersionForDataStream(out));
+  }
+
+  private boolean hasFlagsField(final DataInput in) {
+    return hasFlagsField(InternalDataSerializer.getVersionForDataStream(in));
+  }
+
+  private boolean hasFlagsField(final Version version) {
+    return version.compareTo(Version.GEODE_180) >= 0;
+  }
+
+  private boolean useShadowKey() {
+    return null == clientVersion;
+  }
-   * be a subset of the transaction, this method will combine those subsets into a complete message.
+   * be a subset of the transaction, this method will combine those subsets into a complete
+   * message.
-    protected transient InternalRegion r;
+    protected transient InternalRegion internalRegion;
-      this.r = r;
+      this.internalRegion = r;
-        if (msg.isAckRequired() && (this.r == null || !this.r.getScope().isDistributed())) {
+        if (msg.isAckRequired()
+            && (this.internalRegion == null || !this.internalRegion.getScope().isDistributed())) {
-          this.r = null;
+          this.internalRegion = null;
-        this.needsUnlock = this.r.lockGII();
-        this.r.txLRUStart();
+        this.needsUnlock = this.internalRegion.lockGII();
+        this.internalRegion.txLRUStart();
-        if (this.r.isInitialized()) {
+        if (this.internalRegion.isInitialized()) {
-        this.r = null;
+        this.internalRegion = null;
-      return this.r != null;
+      return this.internalRegion != null;
-      this.r = getRegionByPath(dm, regionPath);
-      if (this.r == null && this.parentRegionPath != null) {
-        this.r = getRegionByPath(dm, this.parentRegionPath);
+      this.internalRegion = getRegionByPath(dm, regionPath);
+      if (this.internalRegion == null && this.parentRegionPath != null) {
+        this.internalRegion = getRegionByPath(dm, this.parentRegionPath);
-      if (this.r == null && dm.getSystem().isLoner()) {
+      if (this.internalRegion == null && dm.getSystem().isLoner()) {
-      if (this.r != null) {
+      if (this.internalRegion != null) {
-            this.r.txLRUEnd();
+            this.internalRegion.txLRUEnd();
-            this.r.unlockGII();
+            this.internalRegion.unlockGII();
-      if (this.r == null) {
+      if (this.internalRegion == null) {
-      boolean isDuplicate = this.r.hasSeenEvent(eventID);
-      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION) || isDuplicate;
-      if (this.r instanceof PartitionedRegion) {
+      boolean isDuplicate = this.internalRegion.hasSeenEvent(eventID);
+      boolean callbacksOnly =
+          (this.internalRegion.getDataPolicy() == DataPolicy.PARTITION) || isDuplicate;
+      if (this.internalRegion instanceof PartitionedRegion) {
-        EntryEventImpl eei = AbstractRegionMap.createCallbackEvent(this.r, entryOp.op, entryOp.key,
-            entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,
-            entryOp.filterRoutingInfo, this.msg.bridgeContext, null, entryOp.versionTag,
-            entryOp.tailKey);
+        EntryEventImpl eei =
+            AbstractRegionMap.createCallbackEvent(this.internalRegion, entryOp.op, entryOp.key,
+                entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,
+                entryOp.filterRoutingInfo, this.msg.bridgeContext, null, entryOp.versionTag,
+                entryOp.tailKey);
-              entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+              entryOp.filterRoutingInfo.getFilterInfo(this.internalRegion.getCache().getMyId()));
-        this.r.txApplyDestroy(entryOp.key, this.msg.txIdent, this.txEvent, this.needsUnlock,
+        this.internalRegion.txApplyDestroy(entryOp.key, this.msg.txIdent, this.txEvent,
+            this.needsUnlock,
-        this.r.txApplyInvalidate(entryOp.key, Token.INVALID, entryOp.didDestroy, this.msg.txIdent,
+        this.internalRegion.txApplyInvalidate(entryOp.key, Token.INVALID, entryOp.didDestroy,
+            this.msg.txIdent,
-        this.r.txApplyPut(entryOp.op, entryOp.key, entryOp.value, entryOp.didDestroy,
+        this.internalRegion.txApplyPut(entryOp.op, entryOp.key, entryOp.value, entryOp.didDestroy,
-      if (this.r == null) {
+      if (this.internalRegion == null) {
-      boolean isDuplicate = this.r.hasSeenEvent(eventID);
-      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION) || isDuplicate;
-      if (this.r instanceof PartitionedRegion) {
+      boolean isDuplicate = this.internalRegion.hasSeenEvent(eventID);
+      boolean callbacksOnly =
+          (this.internalRegion.getDataPolicy() == DataPolicy.PARTITION) || isDuplicate;
+      if (this.internalRegion instanceof PartitionedRegion) {
-        PartitionedRegion pr = (PartitionedRegion) r;
+        PartitionedRegion pr = (PartitionedRegion) internalRegion;
-        InternalDistributedMember thisMember = this.r.getDistributionManager().getId();
+        InternalDistributedMember thisMember = this.internalRegion.getDistributionManager().getId();
-        EntryEventImpl eei = AbstractRegionMap.createCallbackEvent(this.r, entryOp.op, entryOp.key,
-            entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,
-            entryOp.filterRoutingInfo, this.msg.bridgeContext, null, entryOp.versionTag,
-            entryOp.tailKey);
+        EntryEventImpl eei =
+            AbstractRegionMap.createCallbackEvent(this.internalRegion, entryOp.op, entryOp.key,
+                entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,
+                entryOp.filterRoutingInfo, this.msg.bridgeContext, null, entryOp.versionTag,
+                entryOp.tailKey);
-                entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+                entryOp.filterRoutingInfo.getFilterInfo(this.internalRegion.getCache().getMyId()));
-          eei.invokeCallbacks(this.r, skipListeners, true);
+          eei.invokeCallbacks(this.internalRegion, skipListeners, true);
-      return this.r.getScope().isDistributedAck();
+      return this.internalRegion.getScope().isDistributedAck();
-    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in, boolean hasShadowKey)
+        throws IOException, ClassNotFoundException {
-          entryOp.fromData(in, largeModCount, hasShadowKey(regionPath, parentRegionPath));
+          entryOp.fromData(in, largeModCount, hasShadowKey);
-    private boolean hasShadowKey(String regionPath, String parentRegionPath) {
-      // in bucket region, regionPath is bucket name, use parentRegionPath
-      String path = parentRegionPath != null ? parentRegionPath : regionPath;
-      LocalRegion region = getRegionByPath(msg.getDM(), path);
-
-      // default value is whether loner or not, region is null if destroyRegion executed
-      boolean readShadowKey = !msg.getDM().isLoner();
-      if (region != null) {
-        // shadowkey is not being sent to clients
-        readShadowKey = region.getPoolName() == null;
-      }
-      return readShadowKey;
-    }
-
-        result.append(this.r.getFullPath());
+        result.append(this.internalRegion.getFullPath());
-    private void basicToData(DataOutput out) throws IOException {
-      if (this.r != null) {
-        DataSerializer.writeString(this.r.getFullPath(), out);
-        if (this.r instanceof BucketRegion) {
-          DataSerializer.writeString(((Bucket) this.r).getPartitionedRegion().getFullPath(), out);
+    private void basicToData(DataOutput out, boolean useShadowKey) throws IOException {
+      if (this.internalRegion != null) {
+        DataSerializer.writeString(this.internalRegion.getFullPath(), out);
+        if (this.internalRegion instanceof BucketRegion) {
+          DataSerializer.writeString(
+              ((Bucket) this.internalRegion).getPartitionedRegion().getFullPath(), out);
-            if (this.r == null) {
+            if (this.internalRegion == null) {
-              member = this.r.getVersionMember();
+              member = this.internalRegion.getVersionMember();
-                sendVersionTags, this.msg.clientVersion == null);
+                sendVersionTags, useShadowKey);
-                this.msg.clientVersion == null);
+                useShadowKey);
-    public void toData(DataOutput out) throws IOException {
+    public void toData(DataOutput out, boolean useShadowKey) throws IOException {
-        basicToData(hdos);
+        basicToData(hdos, useShadowKey);
-        basicToData(out);
+        basicToData(out, useShadowKey);
-        if (o == null || !(o instanceof FarSideEntryOp))
+        if (o == null || !(o instanceof FarSideEntryOp)) {
+        }
-      Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
+      Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-  /** return true if the member initiating this transaction has left the cluster */
+  /**
+   * return true if the member initiating this transaction has left the cluster
+   */
-    /** Set of members that threw CacheClosedExceptions */
+    /**
+     * Set of members that threw CacheClosedExceptions
+     */
-    /** key=region path, value=Set of members */
+    /**
+     * key=region path, value=Set of members
+     */
-    /** List of exceptions that were unexpected and caused the tx to fail */
+    /**
+     * List of exceptions that were unexpected and caused the tx to fail
+     */
-              regionExceptions.get(region.r.getFullPath());
+              regionExceptions.get(region.internalRegion.getFullPath());
-        region.r.getCancelCriterion().checkCancelInProgress(null);
+        region.internalRegion.getCancelCriterion().checkCancelInProgress(null);
-        ((DistributedRegion) region.r).getPersistenceAdvisor().markMemberOffline(member,
+        ((DistributedRegion) region.internalRegion).getPersistenceAdvisor().markMemberOffline(
+            member,

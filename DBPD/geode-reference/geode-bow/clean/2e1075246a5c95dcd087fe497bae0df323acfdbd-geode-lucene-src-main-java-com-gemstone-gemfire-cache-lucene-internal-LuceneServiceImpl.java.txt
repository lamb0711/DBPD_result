Merge branch 'release/1.0.0-incubating.M3'

-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
+import com.gemstone.gemfire.cache.lucene.internal.management.LuceneServiceMBean;
+import com.gemstone.gemfire.management.internal.beans.CacheServiceMBeanBase;
+import com.gemstone.gemfire.cache.EvictionAlgorithm;
+import com.gemstone.gemfire.cache.EvictionAttributes;
+import com.gemstone.gemfire.cache.lucene.internal.directory.DumpDirectoryFiles;
+import com.gemstone.gemfire.internal.cache.extension.Extensible;
-import com.gemstone.gemfire.internal.cache.extension.Extensible;
- * @since 8.5
+ * @since GemFire 8.5
-  
+
-  
+
+    FunctionService.registerFunction(new DumpDirectoryFiles());
-  
+
+  @Override
+  public CacheServiceMBeanBase getMBean() {
+    return new LuceneServiceMBean(this);
+  }
+
+    if(fields == null || fields.length == 0) {
+      throw new IllegalArgumentException("At least one field must be indexed");
+    }
-    createIndex(indexName, regionPath, analyzer, fields);
+    createIndex(indexName, regionPath, analyzer, null, fields);
-  public void createIndex(String indexName, String regionPath, Map<String, Analyzer> analyzerPerField) {
-    Analyzer analyzer = new PerFieldAnalyzerWrapper(new StandardAnalyzer(), analyzerPerField);
-    String[] fields = (String[])analyzerPerField.keySet().toArray(new String[analyzerPerField.keySet().size()]);
+  public void createIndex(String indexName, String regionPath, Map<String, Analyzer> fieldAnalyzers) {
+    if(fieldAnalyzers == null || fieldAnalyzers.isEmpty()) {
+      throw new IllegalArgumentException("At least one field must be indexed");
+    }
+    Analyzer analyzer = new PerFieldAnalyzerWrapper(new StandardAnalyzer(), fieldAnalyzers);
+    Set<String> fieldsSet = fieldAnalyzers.keySet();
+    String[] fields = (String[])fieldsSet.toArray(new String[fieldsSet.size()]);
-    createIndex(indexName, regionPath, analyzer, fields);
+    createIndex(indexName, regionPath, analyzer, fieldAnalyzers, fields);
-  private void createIndex(final String indexName, String regionPath,
-      final Analyzer analyzer, final String... fields) {
+  public void createIndex(final String indexName, String regionPath,
+      final Analyzer analyzer, final Map<String, Analyzer> fieldAnalyzers,
+      final String... fields) {
-    
+
+        RegionAttributes updatedRA = attrs;
-          AttributesFactory af = new AttributesFactory(attrs);
-          af.addAsyncEventQueueId(aeqId);
-          return af.create();
-        } else {
-          return attrs;
+          if (!attrs.getAsyncEventQueueIds().contains(aeqId)) {
+            AttributesFactory af = new AttributesFactory(attrs);
+            af.addAsyncEventQueueId(aeqId);
+            updatedRA = af.create();
+          }
+
+          // Add index creation profile
+          internalRegionArgs.addCacheServiceProfile(new LuceneIndexCreationProfile(indexName, fields, analyzer, fieldAnalyzers));
+        return updatedRA;
-          afterDataRegionCreated(indexName, analyzer, dataRegionPath, fields);
+          afterDataRegionCreated(indexName, analyzer, dataRegionPath, fieldAnalyzers, fields);
-      final String... fields) {
+      final Map<String, Analyzer> fieldAnalyzers, final String... fields) {
-    // for this API, set index to use the default StandardAnalyzer for each field
+    index.setFieldAnalyzers(fieldAnalyzers);
+
+    //For now we cannot support eviction with local destroy.
+    //Eviction with overflow to disk still needs to be supported
+    EvictionAttributes evictionAttributes = dataregion.getAttributes().getEvictionAttributes();
+    EvictionAlgorithm evictionAlgorithm = evictionAttributes.getAlgorithm();
+    if (evictionAlgorithm != EvictionAlgorithm.NONE && evictionAttributes.getAction().isLocalDestroy()) {
+      throw new UnsupportedOperationException("Lucene indexes on regions with eviction and action local destroy are not supported");
+    }
+
-      index = new LuceneIndexForReplicatedRegion(indexName, regionPath, cache);
+      throw new UnsupportedOperationException("Lucene indexes on replicated regions are not supported");
+  public void beforeCreate(Extensible<Cache> source, Cache cache) {
+    // Nothing to do here.
+  }
+
+  @Override
-  
+
-    
+

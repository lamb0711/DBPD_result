Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implements the acceptor thread on the bridge server. Accepts connections from
- * the edge and starts up threads to process requests from these.
+ * Implements the acceptor thread on the bridge server. Accepts connections from the edge and starts
+ * up threads to process requests from these.
-public class AcceptorImpl extends Acceptor implements Runnable
-{
+public class AcceptorImpl extends Acceptor implements Runnable {
-  
+
-  
+
-  //private final Selector tmpSel;
+  // private final Selector tmpSel;
-   * The name of a system property that sets the hand shake timeout (in
-   * milliseconds). This is how long a client will wait to hear back from
-   * a server.
+   * The name of a system property that sets the hand shake timeout (in milliseconds). This is how
+   * long a client will wait to hear back from a server.
-   * The default value of the {@link #HANDSHAKE_TIMEOUT_PROPERTY_NAME} system
-   * property.
+   * The default value of the {@link #HANDSHAKE_TIMEOUT_PROPERTY_NAME} system property.
-  protected static final int handShakeTimeout = Integer.getInteger(HANDSHAKE_TIMEOUT_PROPERTY_NAME, DEFAULT_HANDSHAKE_TIMEOUT_MS).intValue();
+  protected static final int handShakeTimeout =
+      Integer.getInteger(HANDSHAKE_TIMEOUT_PROPERTY_NAME, DEFAULT_HANDSHAKE_TIMEOUT_MS).intValue();
-   * The name of a system property that sets the accept timeout (in
-   * milliseconds). This is how long a server will wait to get its first
-   * byte from a client it has just accepted.
+   * The name of a system property that sets the accept timeout (in milliseconds). This is how long
+   * a server will wait to get its first byte from a client it has just accepted.
-   * The default value of the {@link #ACCEPT_TIMEOUT_PROPERTY_NAME} system
-   * property.
+   * The default value of the {@link #ACCEPT_TIMEOUT_PROPERTY_NAME} system property.
-  private final int acceptTimeout = Integer.getInteger(ACCEPT_TIMEOUT_PROPERTY_NAME, DEFAULT_ACCEPT_TIMEOUT_MS).intValue();
+  private final int acceptTimeout =
+      Integer.getInteger(ACCEPT_TIMEOUT_PROPERTY_NAME, DEFAULT_ACCEPT_TIMEOUT_MS).intValue();
-   * The default value of the {@link ServerSocket}
-   * {@link #BACKLOG_PROPERTY_NAME}system property
+   * The default value of the {@link ServerSocket} {@link #BACKLOG_PROPERTY_NAME}system property
-  
+
-  /** List of ServerConnections, for {@link #emergencyClose()}
+  /**
+   * List of ServerConnections, for {@link #emergencyClose()}
-   *  guarded.By {@link #allSCsLock}
+   * guarded.By {@link #allSCsLock}
-   * The ip address or host name this acceptor is to bind to;
-   * <code>null</code> or "" indicates
-   * it will listen on all local addresses.
+   * The ip address or host name this acceptor is to bind to; <code>null</code> or "" indicates it
+   * will listen on all local addresses.
+   * 
-  
+
-  
+
-  
+
-  
-  /** 
-   * The AcceptorImpl identifier, used to identify the clients connected to 
-   * this Acceptor.
+
+  /**
+   * The AcceptorImpl identifier, used to identify the clients connected to this Acceptor.
-  private final SocketCreator socketCreator; 
+  private final SocketCreator socketCreator;
-   * Initializes this acceptor thread to listen for connections on the given
-   * port.
+   * Initializes this acceptor thread to listen for connections on the given port.
-   * @param port
-   *          The port on which this acceptor listens for connections. If
-   *          <code>0</code>, a random port will be chosen.
-   * @param bindHostName The ip address or host name this acceptor listens on for
-   *        connections.
-   *        If <code>null</code> or "" then all local addresses are used
-   * @param socketBufferSize
-   *          The buffer size for server-side sockets
-   * @param maximumTimeBetweenPings
-   *          The maximum time between client pings. This value is used by the
-   *          <code>ClientHealthMonitor</code> to monitor the health of this
-   *          server's clients.
-   * @param internalCache
-   *          The GemFire cache whose contents is served to clients
-   * @param maxConnections
-   *          the maximum number of connections allowed in the server pool
-   * @param maxThreads
-   *          the maximum number of threads allowed in the server pool
+   * @param port The port on which this acceptor listens for connections. If <code>0</code>, a
+   *        random port will be chosen.
+   * @param bindHostName The ip address or host name this acceptor listens on for connections. If
+   *        <code>null</code> or "" then all local addresses are used
+   * @param socketBufferSize The buffer size for server-side sockets
+   * @param maximumTimeBetweenPings The maximum time between client pings. This value is used by the
+   *        <code>ClientHealthMonitor</code> to monitor the health of this server's clients.
+   * @param internalCache The GemFire cache whose contents is served to clients
+   * @param maxConnections the maximum number of connections allowed in the server pool
+   * @param maxThreads the maximum number of threads allowed in the server pool
-  public AcceptorImpl(int port,
-                      String bindHostName, boolean notifyBySubscription,
-                      int socketBufferSize, int maximumTimeBetweenPings,
-                      InternalCache internalCache, int maxConnections, int maxThreads,
-                      int maximumMessageCount, int messageTimeToLive,
-                      ConnectionListener listener,List overflowAttributesList, 
-                      boolean isGatewayReceiver, List<GatewayTransportFilter> transportFilter,
-                      boolean tcpNoDelay)
-      throws IOException
-  {
+  public AcceptorImpl(int port, String bindHostName, boolean notifyBySubscription,
+      int socketBufferSize, int maximumTimeBetweenPings, InternalCache internalCache,
+      int maxConnections, int maxThreads, int maximumMessageCount, int messageTimeToLive,
+      ConnectionListener listener, List overflowAttributesList, boolean isGatewayReceiver,
+      List<GatewayTransportFilter> transportFilter, boolean tcpNoDelay) throws IOException {
-      }
-      else if (tmp_maxThreads > this.maxConnections) {
+      } else if (tmp_maxThreads > this.maxConnections) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_IGNORING_MAX_THREADS_DUE_TO_JROCKIT_NIO_BUG));
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.AcceptorImpl_IGNORING_MAX_THREADS_DUE_TO_JROCKIT_NIO_BUG));
-          logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_IGNORING_MAX_THREADS_DUE_TO_WINDOWS_IPV6_BUG));
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.AcceptorImpl_IGNORING_MAX_THREADS_DUE_TO_WINDOWS_IPV6_BUG));
-      //Selector tmp2_s = null;
+      // Selector tmp2_s = null;
-        //tmp2_s = Selector.open(); // workaround for bug 39624
+        // tmp2_s = Selector.open(); // workaround for bug 39624
-        tmp_timer = new SystemTimer(
-            internalCache.getDistributedSystem(), true);
+        tmp_timer = new SystemTimer(internalCache.getDistributedSystem(), true);
-      //this.tmpSel = tmp2_s;
+      // this.tmpSel = tmp2_s;
-      if(!isGatewayReceiver) {
-        //If configured use SSL properties for cache-server
-        this.socketCreator = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.SERVER);
+      if (!isGatewayReceiver) {
+        // If configured use SSL properties for cache-server
+        this.socketCreator =
+            SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.SERVER);
-        this.socketCreator = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.GATEWAY);
+        this.socketCreator = SocketCreatorFactory
+            .getSocketCreatorForComponent(SecurableCommunicationChannel.GATEWAY);
-      
+
-        gc = (GemFireCacheImpl)getCachedRegionHelper().getCache();
-      }
-      else {
+        gc = (GemFireCacheImpl) getCachedRegionHelper().getCache();
+      } else {
-          throw new IllegalArgumentException(LocalizedStrings.AcceptorImpl_SELECTOR_THREAD_POOLING_CAN_NOT_BE_USED_WITH_CLIENTSERVER_SSL_THE_SELECTOR_CAN_BE_DISABLED_BY_SETTING_MAXTHREADS0.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.AcceptorImpl_SELECTOR_THREAD_POOLING_CAN_NOT_BE_USED_WITH_CLIENTSERVER_SSL_THE_SELECTOR_CAN_BE_DISABLED_BY_SETTING_MAXTHREADS0
+                  .toLocalizedString());
-        
+
-        
-        // fix for bug 36617.  If BindException is thrown, retry after
-        // sleeping.  The server may have been stopped and then
+
+        // fix for bug 36617. If BindException is thrown, retry after
+        // sleeping. The server may have been stopped and then
-          }
-          catch (SocketException b) {
-            if (! treatAsBindException(b) || 
-                System.currentTimeMillis() > tilt) { 
+          } catch (SocketException b) {
+            if (!treatAsBindException(b) || System.currentTimeMillis() > tilt) {
-          
+
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-          }
-          finally {
+          } finally {
-      } // isSelector 
+      } // isSelector
-        // fix for bug 36617.  If BindException is thrown, retry after
-        // sleeping.  The server may have been stopped and then
+        // fix for bug 36617. If BindException is thrown, retry after
+        // sleeping. The server may have been stopped and then
-            this.serverSock = this.socketCreator.createServerSocket(port, backLog,
-                getBindAddress(), this.gatewayTransportFilters,
-                socketBufferSize);
+            this.serverSock = this.socketCreator.createServerSocket(port, backLog, getBindAddress(),
+                this.gatewayTransportFilters, socketBufferSize);
-          }
-          catch (SocketException e) {
-            if (! treatAsBindException(e) ||
-                System.currentTimeMillis() > tilt) {
+          } catch (SocketException e) {
+            if (!treatAsBindException(e) || System.currentTimeMillis() > tilt) {
-          
+
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-          }
-          finally {
+          } finally {
-      
+
-          if (dm != null && dm.getDistributionManagerId().getPort() == 0 && (dm instanceof LonerDistributionManager)) {
+          if (dm != null && dm.getDistributionManagerId().getPort() == 0
+              && (dm instanceof LonerDistributionManager)) {
-            ((LonerDistributionManager)dm).updateLonerPort(port);
+            ((LonerDistributionManager) dm).updateLonerPort(port);
-      if(isGatewayReceiver){
+      if (isGatewayReceiver) {
-      }else{
+      } else {
-      
+
-    this.clientNotifier = CacheClientNotifier.getInstance(cache, this.stats,
-        maximumMessageCount,messageTimeToLive,
-        connectionListener,overflowAttributesList, isGatewayReceiver);
+    this.clientNotifier = CacheClientNotifier.getInstance(cache, this.stats, maximumMessageCount,
+        messageTimeToLive, connectionListener, overflowAttributesList, isGatewayReceiver);
-        //+ serverSock.getInetAddress()
-        + "on port " + this.localPort;
-      final ThreadGroup socketThreadGroup
-        = LoggingThreadGroup.createThreadGroup(gName, logger);
-                                          
-      ThreadFactory socketThreadFactory = new ThreadFactory() {
-          int connNum = -1;
+          // + serverSock.getInetAddress()
+          + "on port " + this.localPort;
+      final ThreadGroup socketThreadGroup = LoggingThreadGroup.createThreadGroup(gName, logger);
-          public Thread newThread(final Runnable command) {
-            int tnum;
-            synchronized (this) {
-              tnum = ++connNum;
-            }
-            String tName = socketThreadGroup.getName() + " Thread " + tnum;
-            getStats().incConnectionThreadsCreated();
-            Runnable r = new Runnable() {
-              public void run() {
-                try {
-                  command.run();
-                }
-                catch (CancelException e) { // bug 39463
-                  // ignore
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                }
-              }
-            };
-            return new Thread(socketThreadGroup, r, tName);
+      ThreadFactory socketThreadFactory = new ThreadFactory() {
+        int connNum = -1;
+
+        public Thread newThread(final Runnable command) {
+          int tnum;
+          synchronized (this) {
+            tnum = ++connNum;
-        };
+          String tName = socketThreadGroup.getName() + " Thread " + tnum;
+          getStats().incConnectionThreadsCreated();
+          Runnable r = new Runnable() {
+            public void run() {
+              try {
+                command.run();
+              } catch (CancelException e) { // bug 39463
+                // ignore
+              } finally {
+                ConnectionTable.releaseThreadsSockets();
+              }
+            }
+          };
+          return new Thread(socketThreadGroup, r, tName);
+        }
+      };
-          tmp_pool = new PooledExecutorWithDMStats(new LinkedBlockingQueue(),
-                                                   this.maxThreads,
-                                                   getStats().getCnxPoolHelper(),
-                                                   socketThreadFactory,
-                                                   Integer.MAX_VALUE);
+          tmp_pool = new PooledExecutorWithDMStats(new LinkedBlockingQueue(), this.maxThreads,
+              getStats().getCnxPoolHelper(), socketThreadFactory, Integer.MAX_VALUE);
-          tmp_pool
-            = new ThreadPoolExecutor(MINIMUM_MAX_CONNECTIONS,
-                                     this.maxConnections,
-                                     0L,
-                                     TimeUnit.MILLISECONDS,
-                                     new SynchronousQueue(),
-                                     socketThreadFactory);
+          tmp_pool = new ThreadPoolExecutor(MINIMUM_MAX_CONNECTIONS, this.maxConnections, 0L,
+              TimeUnit.MILLISECONDS, new SynchronousQueue(), socketThreadFactory);
-      }
-      catch (IllegalArgumentException poolInitException) {
+      } catch (IllegalArgumentException poolInitException) {
-      String gName = "Handshaker "
-        + serverSock.getInetAddress()
-        + ":" + this.localPort;
-      final ThreadGroup socketThreadGroup
-        = LoggingThreadGroup.createThreadGroup(gName, logger);
-                                          
-      ThreadFactory socketThreadFactory = new ThreadFactory() {
-          int connNum = -1;
+      String gName = "Handshaker " + serverSock.getInetAddress() + ":" + this.localPort;
+      final ThreadGroup socketThreadGroup = LoggingThreadGroup.createThreadGroup(gName, logger);
-          public Thread newThread(Runnable command) {
-            int tnum;
-            synchronized (this) {
-              tnum = ++connNum;
-            }
-            String tName = socketThreadGroup.getName() + " Thread " + tnum;
-            getStats().incAcceptThreadsCreated();
-            return new Thread(socketThreadGroup, command, tName);
+      ThreadFactory socketThreadFactory = new ThreadFactory() {
+        int connNum = -1;
+
+        public Thread newThread(Runnable command) {
+          int tnum;
+          synchronized (this) {
+            tnum = ++connNum;
-        };
+          String tName = socketThreadGroup.getName() + " Thread " + tnum;
+          getStats().incAcceptThreadsCreated();
+          return new Thread(socketThreadGroup, command, tName);
+        }
+      };
-            public void rejectedExecution(Runnable r, ThreadPoolExecutor pool) {
-              try {
-                bq.put(r);
-              }
-              catch (InterruptedException ex) {
-                Thread.currentThread().interrupt(); // preserve the state
-                throw new RejectedExecutionException(LocalizedStrings.AcceptorImpl_INTERRUPTED.toLocalizedString(), ex);
-              }
+          public void rejectedExecution(Runnable r, ThreadPoolExecutor pool) {
+            try {
+              bq.put(r);
+            } catch (InterruptedException ex) {
+              Thread.currentThread().interrupt(); // preserve the state
+              throw new RejectedExecutionException(
+                  LocalizedStrings.AcceptorImpl_INTERRUPTED.toLocalizedString(), ex);
-          };
-        tmp_hsPool = new ThreadPoolExecutor(1,
-                                            HANDSHAKE_POOL_SIZE,
-                                            60, TimeUnit.SECONDS,
-                                            bq,
-                                            socketThreadFactory,
-                                            reh);
-      }
-      catch (IllegalArgumentException poolInitException) {
+          }
+        };
+        tmp_hsPool = new ThreadPoolExecutor(1, HANDSHAKE_POOL_SIZE, 60, TimeUnit.SECONDS, bq,
+            socketThreadFactory, reh);
+      } catch (IllegalArgumentException poolInitException) {
-    String postAuthzFactoryName = this.cache.getDistributedSystem()
-        .getProperties().getProperty(SECURITY_CLIENT_ACCESSOR_PP);
+    String postAuthzFactoryName =
+        this.cache.getDistributedSystem().getProperties().getProperty(SECURITY_CLIENT_ACCESSOR_PP);
-    isPostAuthzCallbackPresent = (postAuthzFactoryName != null && postAuthzFactoryName
-        .length() > 0) ? true : false;
+    isPostAuthzCallbackPresent =
+        (postAuthzFactoryName != null && postAuthzFactoryName.length() > 0) ? true : false;
-  public long getAcceptorId(){
-    return this.acceptorId;  
+  public long getAcceptorId() {
+    return this.acceptorId;
-  
+
-  
+
+
-   * This system property is only used if max-threads == 0.
-   * This is for 5.0.2 backwards compatibility.
+   * This system property is only used if max-threads == 0. This is for 5.0.2 backwards
+   * compatibility.
+   * 
-   * This system property is only used if max-threads == 0.
-   * This is for 5.0.2 backwards compatibility.
+   * This system property is only used if max-threads == 0. This is for 5.0.2 backwards
+   * compatibility.
+   * 
-  private final static int DEPRECATED_SELECTOR_POOL_SIZE = Integer.getInteger("BridgeServer.SELECTOR_POOL_SIZE", 16).intValue();
-  private final static int HANDSHAKE_POOL_SIZE = Integer.getInteger("BridgeServer.HANDSHAKE_POOL_SIZE", 4).intValue();
+  private final static int DEPRECATED_SELECTOR_POOL_SIZE =
+      Integer.getInteger("BridgeServer.SELECTOR_POOL_SIZE", 16).intValue();
+  private final static int HANDSHAKE_POOL_SIZE =
+      Integer.getInteger("BridgeServer.HANDSHAKE_POOL_SIZE", 4).intValue();
-  public void start() throws IOException
-  {
-    ThreadGroup tg = LoggingThreadGroup.createThreadGroup("Acceptor "
-        + this.serverSock.getInetAddress() + ":" + this.localPort, logger);
-    thread = new Thread(tg, this, "Cache Server Acceptor "
-        + this.serverSock.getInetAddress() + ":" + this.localPort
-        + " local port: " + this.serverSock.getLocalPort());
+  public void start() throws IOException {
+    ThreadGroup tg = LoggingThreadGroup.createThreadGroup(
+        "Acceptor " + this.serverSock.getInetAddress() + ":" + this.localPort, logger);
+    thread = new Thread(tg, this, "Cache Server Acceptor " + this.serverSock.getInetAddress() + ":"
+        + this.localPort + " local port: " + this.serverSock.getLocalPort());
-    // in code from exiting immediately.    
+    // in code from exiting immediately.
-    
+
-          public void run() {
-            AcceptorImpl.this.runSelectorLoop();
-          }
-        };
-      this.selectorThread = new Thread(tg, r, "Cache Server Selector "
-                                       + this.serverSock.getInetAddress()
-                                       + ":" + this.localPort
-                                       + " local port: "
-                                       + this.serverSock.getLocalPort());
+        public void run() {
+          AcceptorImpl.this.runSelectorLoop();
+        }
+      };
+      this.selectorThread =
+          new Thread(tg, r, "Cache Server Selector " + this.serverSock.getInetAddress() + ":"
+              + this.localPort + " local port: " + this.serverSock.getLocalPort());
-    GemFireCacheImpl myCache  = (GemFireCacheImpl)cache;
+    GemFireCacheImpl myCache = (GemFireCacheImpl) cache;
-    for(PartitionedRegion pr : prs){
-      Map<Integer, BucketAdvisor.BucketProfile> profiles = new HashMap<Integer,BucketAdvisor.BucketProfile>();
+    for (PartitionedRegion pr : prs) {
+      Map<Integer, BucketAdvisor.BucketProfile> profiles =
+          new HashMap<Integer, BucketAdvisor.BucketProfile>();
-      Map<Integer,BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
-      for(Map.Entry<Integer,BucketAdvisor> entry : advisors.entrySet()){
+      Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
+      for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
-        //advisor.basicAddClientProfile(bp);
+        // advisor.basicAddClientProfile(bp);
-      ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(receipients, pr.getDistributionManager(),
-          pr.getPRId(), profiles, true);
-      if(reply != null) {
+      ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(receipients,
+          pr.getDistributionManager(), pr.getPRId(), profiles, true);
+      if (reply != null) {
-  
+
-      for (int i = 0; i < again.length; i ++) {
-        again[i] = (ServerConnection)it.next();
+      for (int i = 0; i < again.length; i++) {
+        again[i] = (ServerConnection) it.next();
-  
+
-    ServerConnection sc = (ServerConnection)this.selectorQueue.poll();
+    ServerConnection sc = (ServerConnection) this.selectorQueue.poll();
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      sc = (ServerConnection)this.selectorQueue.poll();
+      sc = (ServerConnection) this.selectorQueue.poll();
-        finishCon((ServerConnection)it.next());
-      }
-      catch (CancelException e) {
+        finishCon((ServerConnection) it.next());
+      } catch (CancelException e) {
-  
+
-   * Ensure that the CachedRegionHelper and ServerConnection classes
-   * get loaded.
+   * Ensure that the CachedRegionHelper and ServerConnection classes get loaded.
-    if (emergencyClassesLoaded) return;
+    if (emergencyClassesLoaded)
+      return;
-  
+
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-//    this.selector.close();  might NOT be safe
+    // this.selector.close(); might NOT be safe
-    
-    // TODO I'm worried about a  fat lock to acquire this synchronization
-//    synchronized (this.allSCsLock)
+
+    // TODO I'm worried about a fat lock to acquire this synchronization
+    // synchronized (this.allSCsLock)
-      for (int i = 0; i < snap.length; i ++) {
+      for (int i = 0; i < snap.length; i++) {
-  
+
-        ServerConnection sc = (ServerConnection)it.next();
+        ServerConnection sc = (ServerConnection) it.next();
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-  private static final boolean WORKAROUND_SELECTOR_BUG = Boolean.getBoolean("CacheServer.NIO_SELECTOR_WORKAROUND");
+  private static final boolean WORKAROUND_SELECTOR_BUG =
+      Boolean.getBoolean("CacheServer.NIO_SELECTOR_WORKAROUND");
-    if (!WORKAROUND_SELECTOR_BUG) return;
+    if (!WORKAROUND_SELECTOR_BUG)
+      return;
-        logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_COULD_NOT_CHECK_FOR_STUCK_KEYS, ignore));
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.AcceptorImpl_COULD_NOT_CHECK_FOR_STUCK_KEYS, ignore));
-        
+
-    //logger.info("DEBUG: checking for stuck keys");
+    // logger.info("DEBUG: checking for stuck keys");
-      SelectionKey sk = (SelectionKey)it.next();
-      ServerConnection sc = (ServerConnection)sk.attachment();
-      if (sc == null) continue;
+      SelectionKey sk = (SelectionKey) it.next();
+      ServerConnection sc = (ServerConnection) sk.attachment();
+      if (sc == null)
+        continue;
-        SelectionKey tmpsk = sc.getSelectableChannel().register(this.tmpSel, SelectionKey.OP_WRITE|SelectionKey.OP_READ);
+        SelectionKey tmpsk = sc.getSelectableChannel().register(this.tmpSel,
+            SelectionKey.OP_WRITE | SelectionKey.OP_READ);
-            logger.info(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_STUCK_SELECTION_KEY_DETECTED_ON_0, sc));
+            logger.info(LocalizedMessage
+                .create(LocalizedStrings.AcceptorImpl_STUCK_SELECTION_KEY_DETECTED_ON_0, sc));
-              //             logger.info("DEBUG detected read event on " + sc);
+              // logger.info("DEBUG detected read event on " + sc);
-                if(isRunning()) {
-                  logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
+                if (isRunning()) {
+                  logger.warn(LocalizedMessage
+                      .create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
-                logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, rejected));
+                logger.warn(LocalizedMessage
+                    .create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, rejected));
-            logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
+            logger.warn(
+                LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
-                logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex2));
+                logger.warn(LocalizedMessage
+                    .create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex2));
-          logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
+          logger.warn(
+              LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, ex));
-          logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, npe));
+          logger.warn(
+              LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED_EXCEPTION, npe));
-  
+
-    //int zeroEventsCount = 0;
+    // int zeroEventsCount = 0;
-//          this.cache.getDistributedSystem().getCancelCriterion().checkCancelInProgress(null);
-          if (((GemFireCacheImpl)this.cache).isClosed()) { // bug 38834
+          // this.cache.getDistributedSystem().getCancelCriterion().checkCancelInProgress(null);
+          if (((GemFireCacheImpl) this.cache).isClosed()) { // bug 38834
-            sc = (ServerConnection)this.selectorQueue.take();
+            sc = (ServerConnection) this.selectorQueue.take();
-            sc = (ServerConnection)this.selectorQueue.poll();
+            sc = (ServerConnection) this.selectorQueue.poll();
-//            for bug bug 38474 
-              finishCon(sc); 
+              // for bug bug 38474
+              finishCon(sc);
-           
+
-            sc = (ServerConnection)this.selectorQueue.poll();
+            sc = (ServerConnection) this.selectorQueue.poll();
-//           zeroEventsCount++;
-//           if (zeroEventsCount > 0) {
-//             zeroEventsCount = 0;
-            checkForStuckKeys();
+          // zeroEventsCount++;
+          // if (zeroEventsCount > 0) {
+          // zeroEventsCount = 0;
+          checkForStuckKeys();
-//              try {
-//                this.selector.close(); // this selector is sick!
-//              } catch (IOException ignore) {
-//              }
-//              this.selector = Selector.open();
-//              {
-//                Iterator it = selectorRegistrations.iterator();
-//                while (it.hasNext()) {
-//                  ServerConnection sc = (ServerConnection)it.next();
-//                  sc.registerWithSelector2(this.selector);
-//                }
-//              }
-//             }
-//            ArrayList al = new ArrayList();
-//            Iterator keysIt = this.selector.keys().iterator();
-//            while (keysIt.hasNext()) {
-//              SelectionKey sk = (SelectionKey)keysIt.next();
-//              al.add(sk.attachment());
-//              sk.cancel();
-//            }
-//            events = this.selector.selectNow();
-//            Iterator alIt = al.iterator();
-//            while (alIt.hasNext()) {
-//              ServerConnection sc = (ServerConnection)alIt.next();
-//              sc.registerWithSelector2(this.selector);
-//            }
-//            events = this.selector.select();
-//         } else {
-//           zeroEventsCount = 0;
+          // try {
+          // this.selector.close(); // this selector is sick!
+          // } catch (IOException ignore) {
+          // }
+          // this.selector = Selector.open();
+          // {
+          // Iterator it = selectorRegistrations.iterator();
+          // while (it.hasNext()) {
+          // ServerConnection sc = (ServerConnection)it.next();
+          // sc.registerWithSelector2(this.selector);
+          // }
+          // }
+          // }
+          // ArrayList al = new ArrayList();
+          // Iterator keysIt = this.selector.keys().iterator();
+          // while (keysIt.hasNext()) {
+          // SelectionKey sk = (SelectionKey)keysIt.next();
+          // al.add(sk.attachment());
+          // sk.cancel();
+          // }
+          // events = this.selector.selectNow();
+          // Iterator alIt = al.iterator();
+          // while (alIt.hasNext()) {
+          // ServerConnection sc = (ServerConnection)alIt.next();
+          // sc.registerWithSelector2(this.selector);
+          // }
+          // events = this.selector.select();
+          // } else {
+          // zeroEventsCount = 0;
-            final ServerConnection sc = (ServerConnection)key.attachment();
+            final ServerConnection sc = (ServerConnection) key.attachment();
-            if (key.isValid() && key.isReadable()) {
-              // this is the only event we currently register for
-              try {
-                key.cancel();
-                this.selectorRegistrations.remove(sc);
-                registeredKeys--;
-                cancelCount++;
-                sc.makeBlocking();
-                // we need to say we are processing a message
-                // so that that client health monitor will not
-                // kill us while we wait for a thread in the thread pool.
-                // This is also be used to determine how long we are
-                // in the thread pool queue and to cancel operations that
-                // have waited too long in the queue.
-                sc.setProcessingMessage();
-              } catch (ClosedChannelException ignore) {
-                finishCon(sc);
-                continue;
-              } catch (IOException ex) {
-                finishCon(sc);
-                if(isRunning()) {
-                  logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, ex));
+              if (key.isValid() && key.isReadable()) {
+                // this is the only event we currently register for
+                try {
+                  key.cancel();
+                  this.selectorRegistrations.remove(sc);
+                  registeredKeys--;
+                  cancelCount++;
+                  sc.makeBlocking();
+                  // we need to say we are processing a message
+                  // so that that client health monitor will not
+                  // kill us while we wait for a thread in the thread pool.
+                  // This is also be used to determine how long we are
+                  // in the thread pool queue and to cancel operations that
+                  // have waited too long in the queue.
+                  sc.setProcessingMessage();
+                } catch (ClosedChannelException ignore) {
+                  finishCon(sc);
+                  continue;
+                } catch (IOException ex) {
+                  finishCon(sc);
+                  if (isRunning()) {
+                    logger.warn(
+                        LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, ex));
+                  }
+                  continue;
-                continue;
-              }
-              try {
-                AcceptorImpl.this.stats.incThreadQueueSize();
-                AcceptorImpl.this.pool.execute(sc);
-              } catch (RejectedExecutionException rejected) {
-                finishCon(sc);
-                AcceptorImpl.this.stats.decThreadQueueSize();
-                if (!isRunning()) {
-                  break;
+                try {
+                  AcceptorImpl.this.stats.incThreadQueueSize();
+                  AcceptorImpl.this.pool.execute(sc);
+                } catch (RejectedExecutionException rejected) {
+                  finishCon(sc);
+                  AcceptorImpl.this.stats.decThreadQueueSize();
+                  if (!isRunning()) {
+                    break;
+                  }
+                  logger.warn(
+                      LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, rejected));
-                logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_UNEXPECTED, rejected));
+                // } else if (key.isValid() && key.isConnectable()) {
+                // logger.info("DEBUG isConnectable and isValid key=" + key);
+                // finishCon(sc);
+              } else {
+                finishCon(sc);
+                if (key.isValid()) {
+                  logger.warn(LocalizedMessage.create(
+                      LocalizedStrings.AcceptorImpl_IGNORING_EVENT_ON_SELECTOR_KEY__0, key));
+                  // } else {
+                  // logger.info("DEBUG !isValid key=" + key);
+                }
-//             } else if (key.isValid() && key.isConnectable()) {
-//               logger.info("DEBUG isConnectable and isValid key=" + key);
-//               finishCon(sc);
-            } else {
-              finishCon(sc);
-              if (key.isValid()) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_IGNORING_EVENT_ON_SELECTOR_KEY__0, key));
-//            } else {
-//                 logger.info("DEBUG !isValid key=" + key);
-              }
-            }
-      }
-      finally {
+      } finally {
-  
+
-  public int getPort()
-  {
+  public int getPort() {
-  public InetAddress getServerInetAddr()
-  {
+  public InetAddress getServerInetAddr() {
-  public void run()
-  {
+  public void run() {
-    }
-    catch (CancelException e) { // bug 39462
+    } catch (CancelException e) { // bug 39462
-    }
-    finally {
+    } finally {
-      }
-      catch (IOException ignore) {
+      } catch (IOException ignore) {
+
-      }
-      catch (IOException ignore) {
+      } catch (IOException ignore) {
+
-   * {@linkplain ServerSocket#accept Listens}for a client to connect and then
-   * creates a new {@link ServerConnection}to handle messages from that client.
+   * {@linkplain ServerSocket#accept Listens}for a client to connect and then creates a new
+   * {@link ServerConnection}to handle messages from that client.
-  public void accept()
-  {
+  public void accept() {
-          }
-          catch (IOException e) {
+          } catch (IOException e) {
-      
+
-      
+
-        
+
-        //   at
+        // at
-      }
-      catch (InterruptedIOException e) { // Solaris only
+      } catch (InterruptedIOException e) { // Solaris only
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-            }
-            catch (IOException ex) {
+            } catch (IOException ex) {
-            logger.error(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_UNEXPECTED_IOEXCEPTION_FROM_ACCEPT, e));
+            logger.error(LocalizedMessage.create(
+                LocalizedStrings.AcceptorImpl_CACHE_SERVER_UNEXPECTED_IOEXCEPTION_FROM_ACCEPT, e));
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_UNEXPECTED_EXCEPTION, e));
+          logger.fatal(LocalizedMessage
+              .create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_UNEXPECTED_EXCEPTION, e));
-  
+
-   * Hand off a new client connection to the thread pool that processes handshakes.
-   * If all the threads in this pool are busy then the hand off will block until
-   * a thread is available.
-   * This blocking is good because it will throttle the rate at which we create
-   * new connections.
+   * Hand off a new client connection to the thread pool that processes handshakes. If all the
+   * threads in this pool are busy then the hand off will block until a thread is available. This
+   * blocking is good because it will throttle the rate at which we create new connections.
-      this.stats.incAcceptsInProgress();      
+      this.stats.incAcceptsInProgress();
-          public void run() {
-            boolean finished = false;
-            try {
-              handleNewClientConnection(s);
-              finished = true;
+        public void run() {
+          boolean finished = false;
+          try {
+            handleNewClientConnection(s);
+            finished = true;
+          } catch (RegionDestroyedException rde) {
+            // aborted due to disconnect - bug 42273
+            if (rde.getMessage().indexOf("HARegion") == -1) {
+              throw rde;
-            catch (RegionDestroyedException rde) {
-              // aborted due to disconnect - bug 42273
-              if (rde.getMessage().indexOf("HARegion") == -1) {
-                throw rde;
-              }
-            }
-            catch (CancelException e) {
-              // aborted due to shutdown - bug 37318
-            }
-            catch (java.nio.channels.AsynchronousCloseException expected) {
-              // this is expected when our TimerTask times out an accepted socket
-            } catch (IOException | ToDataException ex) { // added ToDataException to fix bug 44659
-              if (isRunning()) {
-                if (!AcceptorImpl.this.loggedAcceptError) {
-                  AcceptorImpl.this.loggedAcceptError = true;
-                  if (ex instanceof SocketTimeoutException) {
-                    logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION_DUE_TO_SOCKET_TIMEOUT));
-                  }
-                  else {
-                    logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION__0, ex), ex);
-                  }
+          } catch (CancelException e) {
+            // aborted due to shutdown - bug 37318
+          } catch (java.nio.channels.AsynchronousCloseException expected) {
+            // this is expected when our TimerTask times out an accepted socket
+          } catch (IOException | ToDataException ex) { // added ToDataException to fix bug 44659
+            if (isRunning()) {
+              if (!AcceptorImpl.this.loggedAcceptError) {
+                AcceptorImpl.this.loggedAcceptError = true;
+                if (ex instanceof SocketTimeoutException) {
+                  logger.warn(LocalizedMessage.create(
+                      LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION_DUE_TO_SOCKET_TIMEOUT));
+                } else {
+                  logger.warn(LocalizedMessage.create(
+                      LocalizedStrings.AcceptorImpl_CACHE_SERVER_FAILED_ACCEPTING_CLIENT_CONNECTION__0,
+                      ex), ex);
-            finally {
-              if (!finished) {
-                closeSocket(s);
-              }
-              if (isRunning()) {
-                AcceptorImpl.this.stats.decAcceptsInProgress();
-              }
+          } finally {
+            if (!finished) {
+              closeSocket(s);
+            }
+            if (isRunning()) {
+              AcceptorImpl.this.stats.decAcceptsInProgress();
-        });
+        }
+      });
-    ByteBuffer result = (ByteBuffer)this.commBufferQueue.poll();
+    ByteBuffer result = (ByteBuffer) this.commBufferQueue.poll();
+
-    if (bb == null) {  // fix for bug 37107
+    if (bb == null) { // fix for bug 37107
+
-  
-  protected void handleNewClientConnection(final Socket s) throws IOException
-  {
+
+  protected void handleNewClientConnection(final Socket s) throws IOException {
-      }
-      else if (res == 0) {
+      } else if (res == 0) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0, s.getRemoteSocketAddress()));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0,
+                s.getRemoteSocketAddress()));
-      communicationMode = (byte)s.getInputStream().read();
+      communicationMode = (byte) s.getInputStream().read();
-    
+
-    
-    if (communicationMode == CLIENT_TO_SERVER
-        || communicationMode == GATEWAY_TO_GATEWAY
+
+    if (communicationMode == CLIENT_TO_SERVER || communicationMode == GATEWAY_TO_GATEWAY
-      case CLIENT_TO_SERVER:
-        communicationModeStr = "client";
-        break;
-      case GATEWAY_TO_GATEWAY:
-        communicationModeStr = "gateway";
-        break;
-      case MONITOR_TO_SERVER:
-        communicationModeStr = "monitor";
-        break;
-      case CLIENT_TO_SERVER_FOR_QUEUE:
-        communicationModeStr = "clientToServerForQueue";
-        break;
+        case CLIENT_TO_SERVER:
+          communicationModeStr = "client";
+          break;
+        case GATEWAY_TO_GATEWAY:
+          communicationModeStr = "gateway";
+          break;
+        case MONITOR_TO_SERVER:
+          communicationModeStr = "monitor";
+          break;
+        case CLIENT_TO_SERVER_FOR_QUEUE:
+          communicationModeStr = "clientToServerForQueue";
+          break;
-        logger.debug("Bridge server: Initializing {} communication socket: {}", communicationModeStr, s);
+        logger.debug("Bridge server: Initializing {} communication socket: {}",
+            communicationModeStr, s);
-      if (communicationMode != CLIENT_TO_SERVER_FOR_QUEUE)
-      {
+      if (communicationMode != CLIENT_TO_SERVER_FOR_QUEUE) {
-            logger.warn(LocalizedMessage.create(
+          logger.warn(LocalizedMessage.create(
-              new Object[] {s.getInetAddress(), Integer.valueOf(curCnt), Integer.valueOf(this.maxConnections)}));
-//            if (s != null) (cannot be null) 
-            {
-              try {
-                ServerHandShakeProcessor.refuse(s.getOutputStream(),
-                    LocalizedStrings.AcceptorImpl_EXCEEDED_MAX_CONNECTIONS_0
-                    .toLocalizedString(Integer.valueOf(this.maxConnections)));
+              new Object[] {s.getInetAddress(), Integer.valueOf(curCnt),
+                  Integer.valueOf(this.maxConnections)}));
+          // if (s != null) (cannot be null)
+          {
+            try {
+              ServerHandShakeProcessor.refuse(s.getOutputStream(),
+                  LocalizedStrings.AcceptorImpl_EXCEEDED_MAX_CONNECTIONS_0
+                      .toLocalizedString(Integer.valueOf(this.maxConnections)));
+            } catch (Exception ex) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("rejection message failed", ex);
-              catch (Exception ex) {
-                if (logger.isDebugEnabled()) {
-                  logger.debug("rejection message failed", ex);
-                }
-              }
-              closeSocket(s);
+            closeSocket(s);
+          }
-      ServerConnection serverConn = new ServerConnection(s, this.cache,
-          this.crHelper, this.stats, AcceptorImpl.handShakeTimeout,
-          this.socketBufferSize, communicationModeStr, communicationMode, this);
+      ServerConnection serverConn = new ServerConnection(s, this.cache, this.crHelper, this.stats,
+          AcceptorImpl.handShakeTimeout, this.socketBufferSize, communicationModeStr,
+          communicationMode, this);
-        this.allSCList = (ServerConnection[])
-            ArrayUtils.insert(snap, snap.length, serverConn);
+        this.allSCList = (ServerConnection[]) ArrayUtils.insert(snap, snap.length, serverConn);
-            LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_REQUEST_REJECTED_BY_POOL,
-            new Object[] {serverConn}));
+              LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_REQUEST_REJECTED_BY_POOL,
+              new Object[] {serverConn}));
-                .toLocalizedString(Integer.valueOf(this.maxConnections)));
-      
-          }
-          catch (Exception ex) {
+                    .toLocalizedString(Integer.valueOf(this.maxConnections)));
+
+          } catch (Exception ex) {
-    }
-    else if (communicationMode == PRIMARY_SERVER_TO_CLIENT) {
+    } else if (communicationMode == PRIMARY_SERVER_TO_CLIENT) {
-        logger.debug(":Bridge server: Initializing primary server-to-client communication socket: {}", s);
+        logger.debug(
+            ":Bridge server: Initializing primary server-to-client communication socket: {}", s);
-    }
-    else if (communicationMode == SECONDARY_SERVER_TO_CLIENT) {
+    } else if (communicationMode == SECONDARY_SERVER_TO_CLIENT) {
-        logger.debug(":Bridge server: Initializing secondary server-to-client communication socket: {}", s);
+        logger.debug(
+            ":Bridge server: Initializing secondary server-to-client communication socket: {}", s);
-      throw new IOException("Acceptor received unknown communication mode: "
-          + communicationMode);
+      throw new IOException("Acceptor received unknown communication mode: " + communicationMode);
-  public boolean isRunning()
-  {
+  public boolean isRunning() {
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="REC_CATCH_EXCEPTION", justification="Allow this thread to die")
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "REC_CATCH_EXCEPTION",
+      justification = "Allow this thread to die")
-        logger.info(LocalizedMessage.create(LocalizedStrings.AcceptorImpl_CACHE_SERVER_ON_PORT_0_IS_SHUTTING_DOWN, this.localPort)); 
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.AcceptorImpl_CACHE_SERVER_ON_PORT_0_IS_SHUTTING_DOWN, this.localPort));
-        ClientHealthMonitor.shutdownInstance();        
+        ClientHealthMonitor.shutdownInstance();
-          logger.warn(LocalizedMessage.create(LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
-        GemFireCacheImpl myCache = (GemFireCacheImpl)cache;
+        GemFireCacheImpl myCache = (GemFireCacheImpl) cache;
-            Map<Integer, BucketAdvisor.BucketProfile> profiles = new HashMap<Integer, BucketAdvisor.BucketProfile>();
+            Map<Integer, BucketAdvisor.BucketProfile> profiles =
+                new HashMap<Integer, BucketAdvisor.BucketProfile>();
-            Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor()
-                .getAllBucketAdvisors();
+            Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
-              BucketProfile bp = (BucketProfile)advisor.createProfile();
+              BucketProfile bp = (BucketProfile) advisor.createProfile();
-            ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(
-                receipients, pr.getDistributionManager(), pr.getPRId(), profiles,
-                true);
+            ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(receipients,
+                pr.getDistributionManager(), pr.getPRId(), profiles, true);
-  
+
-  
+
-      for (int i = 0; i < snap.length; i ++) {
+      for (int i = 0; i < snap.length; i++) {
-//   protected InetAddress getBindAddress() {
-//     return this.bindAddress;
-//   }
+  // protected InetAddress getBindAddress() {
+  // return this.bindAddress;
+  // }
-//   /**
-//    * Calculates the bind address based on gemfire.properties.
-//    * Returns null if no bind address is configured.
-//    * @since GemFire 5.7
-//    */
-//   public static InetAddress calcBindAddress(Cache cache) throws IOException {
-//     InternalDistributedSystem system = (InternalDistributedSystem)cache
-//         .getDistributedSystem();
-//     DistributionConfig config = system.getConfig();
-//     InetAddress address = null;
+  // /**
+  // * Calculates the bind address based on gemfire.properties.
+  // * Returns null if no bind address is configured.
+  // * @since GemFire 5.7
+  // */
+  // public static InetAddress calcBindAddress(Cache cache) throws IOException {
+  // InternalDistributedSystem system = (InternalDistributedSystem)cache
+  // .getDistributedSystem();
+  // DistributionConfig config = system.getConfig();
+  // InetAddress address = null;
-//     // Get the server-bind-address. If it is not null, use it.
-//     // If it is null, get the bind-address. If it is not null, use it.
-//     // Otherwise set default.
-//     String serverBindAddress = config.getServerBindAddress();
-//     if (serverBindAddress != null && serverBindAddress.length() > 0) {
-//       address = InetAddress.getByName(serverBindAddress);
-//     } else {
-//       String bindAddress = config.getBindAddress();
-//       if (bindAddress != null && bindAddress.length() > 0) {
-//         address = InetAddress.getByName(bindAddress);
-//       }
-//     }
-//     return address;
-//   }
+  // // Get the server-bind-address. If it is not null, use it.
+  // // If it is null, get the bind-address. If it is not null, use it.
+  // // Otherwise set default.
+  // String serverBindAddress = config.getServerBindAddress();
+  // if (serverBindAddress != null && serverBindAddress.length() > 0) {
+  // address = InetAddress.getByName(serverBindAddress);
+  // } else {
+  // String bindAddress = config.getBindAddress();
+  // if (bindAddress != null && bindAddress.length() > 0) {
+  // address = InetAddress.getByName(bindAddress);
+  // }
+  // }
+  // return address;
+  // }
-   * @param bindName the ip address or host name that this acceptor should
-   *                 bind to. If null or "" then calculate it.
-   * @return the ip address or host name this acceptor will listen on.
-   *         An "" if all local addresses will be listened to.
-   
+   * @param bindName the ip address or host name that this acceptor should bind to. If null or ""
+   *        then calculate it.
+   * @return the ip address or host name this acceptor will listen on. An "" if all local addresses
+   *         will be listened to.
+   * 
-    
-    InternalDistributedSystem system = (InternalDistributedSystem)cache
-        .getDistributedSystem();
+
+    InternalDistributedSystem system = (InternalDistributedSystem) cache.getDistributedSystem();
-  
+
-   * Gets the address that this bridge server can be contacted on from external
-   * processes.
+   * Gets the address that this bridge server can be contacted on from external processes.
+   * 
-        InetSocketAddress isa = (InetSocketAddress)ss.getLocalSocketAddress();
+        InetSocketAddress isa = (InetSocketAddress) ss.getLocalSocketAddress();
-   * This method finds a client notifier and returns it.  It is used to
-   * propagate interest registrations to other servers
+   * This method finds a client notifier and returns it. It is used to propagate interest
+   * registrations to other servers
-  public CacheClientNotifier getCacheClientNotifier()
-  {
+  public CacheClientNotifier getCacheClientNotifier() {
-  
+
-  }  
-  
+  }
+
-  
-  public List<GatewayTransportFilter> getGatewayTransportFilters(){
+
+  public List<GatewayTransportFilter> getGatewayTransportFilters() {
-  
-  //IBM J9 sometimes reports "listen failed" instead of BindException
-  //see bug #40589
+
+  // IBM J9 sometimes reports "listen failed" instead of BindException
+  // see bug #40589
-    if(se instanceof BindException) { 
+    if (se instanceof BindException) {
-  public static boolean isIntegratedSecurity(){
+  public static boolean isIntegratedSecurity() {
-  
-  public Set<ServerConnection> getAllServerConnections(){
+
+  public Set<ServerConnection> getAllServerConnections() {
-  
+
-   * This method returns a thread safe structure which can be iterated over without worrying about ConcurrentModificationException.
-   * JMX MBeans/Commands need to iterate over this list to get client info.
-   *   
+   * This method returns a thread safe structure which can be iterated over without worrying about
+   * ConcurrentModificationException. JMX MBeans/Commands need to iterate over this list to get
+   * client info.
+   * 
-  public ServerConnection[] getAllServerConnectionList(){
+  public ServerConnection[] getAllServerConnectionList() {

GEODE-5716: GfshRule improvement (#2454)

* simplify process output to stdout/stderr
* rework debuggable command API
* be more specific about each gfshScript execution in the output.

-import java.util.Arrays;
+import java.util.stream.Collectors;
+/**
+ * All the commands represented in this script is executed within one gfsh session.
+ *
+ * all the commands in this script are executed using this bash command:
+ * gfsh -e command1 -e command2 -e command3 ....
+ *
+ * You can chain commands together to create a gfshScript
+ * GfshScript.of("command1").and("command2").and("command3", "command4")
+ *
+ * If your command started another process and you want to that process to be debuggable, you can do
+ * GfshScript.of("start locator", 30000).and("start server", 30001)
+ * this will allow locator to be debuggable at 30000 and the server to be debuggable at 30001
+ *
+ * By default, each scripts await at most 4 minutes for all the commands to finish
+ * and will expect success. if you want to change this, you can use:
+ * gfshScript.awaitAtMost(1, TimeUnit.MINUTES).expectFailure()
+ *
+ * if you want this gfsh session to be debuggable, you can use:
+ * gfshScript.withDebugPort(30000)
+ * This will allow gfsh to be debuggable at port 30000.
+ *
+ */
-  private final DebuggableCommand[] commands;
+  private List<DebuggableCommand> commands = new ArrayList<>();
-  private boolean awaitQuietly = false;
+  private int debugPort = -1;
-  public GfshScript(DebuggableCommand... commands) {
-    this.commands = commands;
+  public GfshScript() {
-  /**
-   * By default, this GfshScript will await at most 2 minutes and will expect success.
-   */
-    return new GfshScript(
-        Arrays.stream(commands).map(DebuggableCommand::new).toArray(DebuggableCommand[]::new));
+    GfshScript script = new GfshScript();
+    script.and(commands);
+    return script;
-  public static GfshScript of(DebuggableCommand... commands) {
-    return new GfshScript(commands);
+  public static GfshScript of(String command, int debugPort) {
+    GfshScript script = new GfshScript();
+    script.and(command, debugPort);
+    return script;
+  }
+
+  public GfshScript and(String... commands) {
+    for (String command : commands) {
+      this.commands.add(new DebuggableCommand(command));
+    }
+    return this;
+  }
+
+  public GfshScript and(String command, int debugPort) {
+    this.commands.add(new DebuggableCommand(command, debugPort));
+    return this;
-   * Will cause the thread that executes {@link GfshScript#awaitIfNecessary} to wait, if necessary,
+   * Will cause the thread that executes to wait, if necessary,
-  /**
-   * Will cause the thread that executes {@link GfshScript#awaitIfNecessary} to wait, if necessary,
-   * until the subprocess executing this Gfsh script has terminated, or the specified waiting time
-   * elapses.
-   */
-  public GfshScript awaitQuietlyAtMost(int timeout, TimeUnit timeUnit) {
-    this.awaitQuietly = true;
-
-    return awaitAtMost(timeout, timeUnit);
-  }
-
-  public GfshScript awaitQuietly() {
-    this.awaitQuietly = true;
-
+  public GfshScript withDebugPort(int debugPort) {
+    this.debugPort = debugPort;
-    return execute(gfshRule, -1);
+    return gfshRule.execute(this);
-  public GfshExecution execute(GfshRule gfshRule, int gfshDebugPort) {
-    return gfshRule.execute(this, gfshDebugPort);
-  }
-
-  protected void awaitIfNecessary(GfshExecution gfshExecution) {
-    if (shouldAwaitQuietly()) {
-      awaitQuietly(gfshExecution);
-    } else if (shouldAwaitLoudly()) {
-      awaitLoudly(gfshExecution);
-    }
-
-    try {
-      assertThat(gfshExecution.getProcess().exitValue()).isEqualTo(expectedExitValue);
-    } catch (AssertionError e) {
-      gfshExecution.printLogFiles();
-      throw e;
-    }
-
-  }
-
-  private void awaitQuietly(GfshExecution gfshExecution) {
-    try {
-      gfshExecution.getProcess().waitFor(timeout, timeoutTimeUnit);
-    } catch (InterruptedException ignore) {
-      // ignore since we are waiting *quietly*
-    }
-  }
-
-  private void awaitLoudly(GfshExecution gfshExecution) {
-    boolean exited;
-    try {
-      exited = gfshExecution.getProcess().waitFor(timeout, timeoutTimeUnit);
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
-    }
-
-    try {
-      assertThat(exited).isTrue();
-    } catch (AssertionError e) {
-      gfshExecution.printLogFiles();
-      throw e;
-    }
-  }
-
-  private boolean shouldAwait() {
-    return timeoutTimeUnit != null;
-  }
-
-  private boolean shouldAwaitQuietly() {
-    return shouldAwait() && awaitQuietly;
-  }
-
-  private boolean shouldAwaitLoudly() {
-    return shouldAwait() && !awaitQuietly;
-  }
-
-  public DebuggableCommand[] getCommands() {
+  public List<DebuggableCommand> getCommands() {
+  public TimeUnit getTimeoutTimeUnit() {
+    return timeoutTimeUnit;
+  }
+
+  public int getTimeout() {
+    return timeout;
+  }
+
+  public int getExpectedExitValue() {
+    return expectedExitValue;
+  }
+
+  public int getDebugPort() {
+    return debugPort;
+  }
+
+
+  public String toString() {
+    StringBuilder builder = new StringBuilder();
+    builder.append(name).append(": gfsh ");
+    builder.append(commands.stream().map(c -> "-e " + c.command).collect(Collectors.joining(" ")));
+    return builder.toString();
+  }

GEODE-4615 Deadlock shutting down client cache

Disallow adding a new connection to the ConnectionMap when it is being
closed.

This revision replaces the connection map's connection list with a
poisoned list under sync and then closes each connection outside
of the connection map's lock.  This removes the lock inversion since
the closing thread no longer holds the map's lock.  The thread adding
a connection will either see closing==true or it will try to add
the connection to the poisoned list.  Either results in it
throwing a CacheClosedException.

+import java.util.Collection;
+import org.apache.geode.cache.CacheClosedException;
-import org.apache.geode.distributed.internal.DistributionConfig;
-  static long AQUIRE_TIMEOUT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "ConnectionManager.AQUIRE_TIMEOUT", 10 * 1000)
-      .longValue();
-  protected final long prefillRetry; // ms // make this an int
-  // private final long pingInterval; // ms // make this an int
+  protected final long prefillRetry; // ms
-    private final LinkedList/* <PooledConnection> */ allConnections =
-        new LinkedList/* <PooledConnection> */(); // in the order they were created
+    private List/* <PooledConnection> */ allConnections = new LinkedList/* <PooledConnection> */(); // in
+                                                                                                    // the
+                                                                                                    // order
+                                                                                                    // they
+                                                                                                    // were
+                                                                                                    // created
+    volatile boolean closing;
-      addToEndpointMap(connection);
+      if (this.closing) {
+        throw new CacheClosedException("This pool is closing");
+      }
+
+      getPoolStats().incPoolConnections(1);
-      getPoolStats().incPoolConnections(1);
-      // logger.info("DEBUG: addConnection incPoolConnections(1)->" +
-      // getPoolStats().getPoolConnections() + " con="+connection,
-      // new RuntimeException("STACK"));
-      this.allConnections.addLast(connection);
+      this.allConnections.add(connection);
+
+      addToEndpointMap(connection);
+
+      if (this.closing) {
+        throw new CacheClosedException("This pool is closing");
+      }
-        this.allConnections.addLast(con);
+        this.allConnections.add(con);
-    public synchronized void close(boolean keepAlive) {
-      map.clear();
+    public void close(boolean keepAlive) {
+      List<PooledConnection> connections;
-      while (!this.allConnections.isEmpty()) {
-        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
+
+      synchronized (this) {
+        if (closing) {
+          return;
+        }
+        closing = true;
+        map.clear();
+        connections = allConnections;
+        allConnections = new ClosedPoolConnectionList();
+      }
+
+      for (PooledConnection pc : connections) {
+      closing = true;
-        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
+        PooledConnection pc = (PooledConnection) this.allConnections.remove(0);
-     * See if any of the expired connections (that have not idle expired) are already connected to
-     * this sl and have not idle expired. If so then just update them in-place to simulate a
-     * replace.
-     *
-     * @param sl the location of the server we should see if we are connected to
-     * @return true if we were able to extend an existing connection's lifetime or if we have no
-     *         connection's whose lifetime has expired. false if we need to create a replacement
-     *         connection.
-     */
-    public synchronized boolean tryToExtendLifeTime(ServerLocation sl) {
-      // a better approach might be to get the most loaded server
-      // (if they are not balanced) and then scan through and extend the lifetime
-      // of everyone not connected to that server and do a replace on just one
-      // of the guys who has lifetime expired to the most loaded server
-      boolean result = true;
-      if (!this.allConnections.isEmpty()) {
-        final long now = System.nanoTime();
-        for (Iterator it = this.allConnections.iterator(); it.hasNext();) {
-          PooledConnection pc = (PooledConnection) it.next();
-          if (pc.remainingLife(now, lifetimeTimeoutNanos) > 0) {
-            // no more connections whose lifetime could have expired
-            break;
-            // note don't ignore idle guys because they are still connected
-            // } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
-            // // this con has already idle expired so ignore it
-          } else if (pc.shouldDestroy()) {
-            // this con has already been destroyed so ignore it
-          } else if (sl.equals(pc.getEndpoint().getLocation())) {
-            // we found a guy to whose lifetime we can extend
-            it.remove();
-            // logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
-            pc.setBirthDate(now);
-            getPoolStats().incLoadConditioningExtensions();
-            this.allConnections.addLast(pc);
-            return true;
-          } else {
-            // the current pc is a candidate for reconnection to another server
-            // so set result to false which will stick unless we find another con
-            // whose life can be extended.
-            result = false;
-          }
-        }
-      }
-      // if (result) {
-      // logger.fine("DEBUG: tryToExtendLifeTime found no one to extend");
-      // }
-      return result;
-    }
-
-    /**
-            this.allConnections.addLast(pc);
+            this.allConnections.add(pc);
+
+
+  private static class ClosedPoolConnectionList extends ArrayList {
+    @Override
+    public Object set(int index, Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean add(Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public void add(int index, Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public Object remove(int index) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean addAll(Collection c) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean addAll(int index, Collection c) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+  }

GEODE-6883 Move the membership code into a separate gradle sub-project

This commit is focused on removing references to
InternalDistributedMember and DistributionMessage from "gms"
packages.

    GMS classes only refer to GMSMember
    GMS classes use GMSMembershipView.  NetView is now an interface
    GMS classes do not refer to DistributionMessage.  JGroupsMessenger
      expects GMSMessage instances.  Geode messages to be sent over UDP
      are wrapped in a GMSMessageAdapter.
    "gms" messages extend AbstractGMSMessage which implements GMSMessage
    GMSMembershipManager has an inner class that implements the GMS Manager
      interface and is now in the "adapter" package
    GMSMembershipManager translates GMSMembershipView into a MembershipView
      for the rest of Geode to use (this is the old NetView class)
    GMS instantiation allows us to inject the Manager into the new Services
      instance.
    Other adapter classes have been added to translate between Geode
      and GMS.

    GMSUtil has new methods for marshalling/unmarshalling
    InternalDistributedMember instances for backward-compatibility.
    GMSMember now has the same on-wire form as
    InternalDistributedMember.  This allows the GMS classes to
    deserialize a message from a pre-1.10 member whose code writes
    InternalDistributedMembers when serializing something like a
    JoinRequest.

-import java.net.UnknownHostException;
-import org.apache.geode.distributed.DurableClientAttributes;
-import org.apache.geode.distributed.internal.membership.MemberAttributes;
-import org.apache.geode.distributed.internal.membership.NetMember;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.internal.net.SocketCreator;
- * This is the fundamental representation of a member of a GemFire distributed system.
- *
- * Unfortunately, this class serves two distinct functions. First, it is the fundamental element of
- * membership in the GemFire distributed system. As such, it is used in enumerations and properly
- * responds to hashing and equals() comparisons.
- *
- * Second, it is used as a cheap way of representing an address. This is unfortunate, because as a
- * NetMember, it holds two separate port numbers: the "membership" descriptor as well as a direct
- * communication channel.
- *
+ * GMSMember is the membership identifier class for Group Membership Services.
-public class GMSMember implements NetMember, DataSerializableFixedID {
+public class GMSMember implements DataSerializableFixedID {
+  /** The type for regular members */
+  public static final int NORMAL_DM_TYPE = 10;
+
+  /** The DM type for locator members */
+  public static final int LOCATOR_DM_TYPE = 11;
+
+  /** The DM type for deprecated admin-only members */
+  public static final int ADMIN_ONLY_DM_TYPE = 12;
+
+  /** The DM type for stand-alone members (usually clients) */
+  public static final int LONER_DM_TYPE = 13;
+
+  private String hostName;
+
-  private DurableClientAttributes durableClientAttributes;
-
+  private String durableId;
+  private int durableTimeout;
-  @Override
-  public MemberAttributes getAttributes() {
-    return new MemberAttributes(directPort, processId, vmKind, vmViewId, name, groups,
-        durableClientAttributes);
+  @VisibleForTesting
+  public GMSMember(String localhost, int udpPort, Version version) {
+    this.hostName = localhost;
+    this.inetAddr = SocketCreator.toInetAddress(localhost);
+    this.udpPort = udpPort;
+    this.versionOrdinal = version.ordinal();
+    this.vmKind = NORMAL_DM_TYPE;
+    this.preferredForCoordinator = true;
+    this.vmViewId = -1;
+    this.processId = -1;
+    this.directPort = -1;
+    setUUID(UUID.randomUUID());
-  @Override
-  public void setAttributes(MemberAttributes p_attr) {
-    MemberAttributes attr = p_attr;
-    if (attr == null) {
-      attr = MemberAttributes.INVALID;
-    }
-    processId = attr.getVmPid();
-    vmKind = (byte) attr.getVmKind();
-    directPort = attr.getPort();
-    vmViewId = attr.getVmViewId();
-    name = attr.getName();
-    groups = attr.getGroups();
-    durableClientAttributes = attr.getDurableClientAttributes();
-  }
+  @VisibleForTesting
-    udpPort = p;
-    try {
-      inetAddr = InetAddress.getByName(i);
-    } catch (UnknownHostException e) {
-      // oops
-    }
+    this(i, p, Version.CURRENT);
-  public GMSMember(MemberAttributes attr, InetAddress i, int p,
+  public GMSMember(InetAddress i, String hostName, int p, int processId, byte vmKind,
+      int directPort, int vmViewId,
+      String name, String[] groups,
+      String durableId, int durableTimeout,
-    setAttributes(attr);
+    this.hostName = hostName;
+    this.processId = processId;
+    this.vmKind = vmKind;
+    this.directPort = directPort;
+    this.vmViewId = vmViewId;
+    this.name = name;
+    this.groups = groups;
+    this.durableId = durableId;
+    this.durableTimeout = durableTimeout;
+    this.hostName = i.getHostName();
+    this.hostName = other.hostName;
-    this.durableClientAttributes = other.durableClientAttributes;
+    this.durableId = other.durableId;
+    this.durableTimeout = other.durableTimeout;
-  @Override
+
-  @Override
-  public boolean isMulticastAddress() {
-    return false;
-  }
-  @Override
-  @Override
+
-  @Override
+
+  public String getDurableId() {
+    return durableId;
+  }
+
+  public int getDurableTimeout() {
+    return durableTimeout;
+  }
+
-  @Override
+
-  @Override
-  public int compareTo(NetMember o) {
+
+  public int compareTo(GMSMember o) {
+    return compareTo(o, true);
+  }
+
+  public int compareTo(GMSMember o, boolean compareUUIDs) {
-    if (o == null || !(o instanceof GMSMember)) {
+    if (o == null) {
-          "NetMember.compareTo(): comparison between different classes");
+          "GMSMember.compareTo(): comparison between different classes");
-    GMSMember his = (GMSMember) o;
+    GMSMember his = o;
-    if (result == 0 && this.uuidMSBs != 0 && his.uuidMSBs != 0) {
+    if (compareUUIDs && result == 0 && this.uuidMSBs != 0 && his.uuidMSBs != 0) {
-  @Override
-  public int compareAdditionalData(NetMember other) {
-    GMSMember his = (GMSMember) other;
+
+  public int compareAdditionalData(GMSMember his) {
-        .append(";processId=").append(processId).append(";name=").append(name).append(uuid)
+        .append(";kind=").append(vmKind).append(";processId=").append(";viewId=").append(vmViewId)
+        .append(processId).append(";v").append(versionOrdinal).append(";name=")
+        .append(name).append(uuid).append(";weight=").append(memberWeight)
-  @Override
-  public String getUniqueId() {
-    StringBuilder sb = new StringBuilder(100);
-    sb.append("GMSMember[addr=").append(inetAddr);
-    sb.append(";processId=").append(processId);
-    sb.append(";name=").append(name);
-    sb.append(formatUUID()).append("]");
-    return sb.toString();
-  }
-  public int getUdpPort() {
-    return udpPort;
-  }
-
-  @Override
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
-  public DurableClientAttributes getDurableClientAttributes() {
-    return durableClientAttributes;
-  }
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
+
-  @Override
-  public void setDurableClientAttributes(DurableClientAttributes durableClientAttributes) {
-    this.durableClientAttributes = durableClientAttributes;
-  }
-  @Override
-  @Override
+
-  @Override
+
+  static final int VERSION_BIT = 0x8;
+
+  static final int LONER_VM_TYPE = 13; // from ClusterDistributionManager
-    writeEssentialData(out);
-    out.writeInt(directPort);
-    out.writeByte(memberWeight);
-    out.writeByte(vmKind);
-    out.writeInt(processId);
+    DataSerializer.writeInetAddress(getInetAddress(), out);
+    out.writeInt(getPort());
-    DataSerializer.writeString(name, out);
-    DataSerializer.writeStringArray(groups, out);
+    DataSerializer.writeString(hostName, out);
+
+    int flags = 0;
+    if (isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (preferredForCoordinator())
+      flags |= PREFERRED_FOR_COORD_BIT;
+    // always write product version but enable reading from older versions
+    // that do not have it
+    flags |= VERSION_BIT;
+
+    out.writeByte((byte) (flags & 0xff));
+
+    out.writeInt(getDirectPort());
+    out.writeInt(getProcessId());
+    int vmKind = getVmKind();
+    out.writeByte(vmKind);
+    DataSerializer.writeStringArray(getGroups(), out);
+
+    DataSerializer.writeString(getName(), out);
+    if (vmKind == LONER_VM_TYPE) {
+      DataSerializer.writeString("", out);
+    } else { // added in 6.5 for unique identifiers in P2P
+      DataSerializer.writeString(String.valueOf(getVmViewId()), out);
+    }
+    DataSerializer
+        .writeString(durableId == null ? "" : durableId, out);
+    DataSerializer.writeInteger(durableId == null ? 300 : durableTimeout, out);
+
+    Version.writeOrdinal(out, versionOrdinal, true);
+
+    if (versionOrdinal >= Version.GFE_90.ordinal()) {
+      writeAdditionalData(out);
+    }
-    readEssentialData(in);
-    this.directPort = in.readInt();
-    this.memberWeight = in.readByte();
-    this.vmKind = in.readByte();
-    this.processId = in.readInt();
+    inetAddr = DataSerializer.readInetAddress(in);
+    udpPort = in.readInt();
-    this.name = DataSerializer.readString(in);
-    this.groups = DataSerializer.readStringArray(in);
+    this.hostName = DataSerializer.readString(in);
+
+    int flags = in.readUnsignedByte();
+    preferredForCoordinator = (flags & PREFERRED_FOR_COORD_BIT) != 0;
+    this.networkPartitionDetectionEnabled = (flags & NPD_ENABLED_BIT) != 0;
+
+    directPort = in.readInt();
+    processId = in.readInt();
+    vmKind = (byte) in.readUnsignedByte();
+    groups = DataSerializer.readStringArray(in);
+    vmViewId = -1;
+
+    name = DataSerializer.readString(in);
+    if (vmKind == LONER_DM_TYPE) {
+      DataSerializer.readString(in);
+    } else {
+      String str = DataSerializer.readString(in);
+      if (str != null) { // backward compatibility from earlier than 6.5
+        vmViewId = Integer.parseInt(str);
+      }
+    }
+
+    durableId = DataSerializer.readString(in);
+    durableTimeout = in.readInt();
+
+    versionOrdinal = readVersion(flags, in);
+
+    if (versionOrdinal >= Version.GFE_90.ordinal()) {
+      readAdditionalData(in);
+    }
+  }
+
+  private short readVersion(int flags, DataInput in) throws IOException {
+    if ((flags & VERSION_BIT) != 0) {
+      return Version.readOrdinal(in);
+    } else {
+      // prior to 7.1 member IDs did not serialize their version information
+      Version v = InternalDataSerializer.getVersionForDataStreamOrNull(in);
+      if (v != null) {
+        return v.ordinal();
+      }
+      return Version.CURRENT_ORDINAL;
+    }
+  }
+
+  public String getHostName() {
+    return hostName;
+  }
+
+  public void setHostName(String hostName) {
+    this.hostName = hostName;
+    if (this.inetAddr != null) {
+      this.hostName =
+          SocketCreator.resolve_dns ? SocketCreator.getHostName(inetAddr)
+              : inetAddr.getHostAddress();
+    }
-  @Override
+
-  @Override
+
-  @Override
+
-    return ";uuid=" + getUUID().toStringLong();
+    UUID uuid = getUUID();
+    return ";uuid=" + (uuid == null ? "none" : getUUID().toStringLong());
+
+  public void setDurableTimeout(int newValue) {
+    durableTimeout = newValue;
+  }
+
+  public void setDurableId(String id) {
+    durableId = id;
+  }
+
+
+  public static class GMSMemberWrapper {
+    GMSMember mbr;
+
+    public GMSMemberWrapper(GMSMember m) {
+      this.mbr = m;
+    }
+
+    public GMSMember getMbr() {
+      return mbr;
+    }
+
+    @Override
+    public int hashCode() {
+      return mbr.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == null || !(obj instanceof GMSMemberWrapper)) {
+        return false;
+      }
+      GMSMember other = ((GMSMemberWrapper) obj).mbr;
+      return mbr.compareTo(other) == 0;
+    }
+
+    @Override
+    public String toString() {
+      return "GMSMemberWrapper [mbr=" + mbr + "]";
+    }
+  }
+
+

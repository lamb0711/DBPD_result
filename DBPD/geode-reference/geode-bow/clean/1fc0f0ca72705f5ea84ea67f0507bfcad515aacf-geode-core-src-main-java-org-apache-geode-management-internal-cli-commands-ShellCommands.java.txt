GEODE-1597: use Spring shell's parser and delete our own parsing code

* Use Spring's SimpleParser as a basis for command parsing
* reworked help/hint
* removing singleton CommandManager

-import org.apache.geode.management.internal.cli.annotation.CliArgument;
+  // millis that connect --locator will wait for a response from the locator.
+  private final static int CONNECT_LOCATOR_TIMEOUT_MS = 60000; // see bug 45971
+
+  public static int getConnectLocatorTimeoutInMS() {
+    return ShellCommands.CONNECT_LOCATOR_TIMEOUT_MS;
+  }
+
+  /* package-private */
+  static Map<String, String> loadPropertiesFromURL(URL gfSecurityPropertiesUrl) {
+    Map<String, String> propsMap = Collections.emptyMap();
+
+    if (gfSecurityPropertiesUrl != null) {
+      InputStream inputStream = null;
+      try {
+        Properties props = new Properties();
+        inputStream = gfSecurityPropertiesUrl.openStream();
+        props.load(inputStream);
+        if (!props.isEmpty()) {
+          Set<String> jmxSpecificProps = new HashSet<String>();
+          propsMap = new LinkedHashMap<String, String>();
+          Set<Entry<Object, Object>> entrySet = props.entrySet();
+          for (Entry<Object, Object> entry : entrySet) {
+
+            String key = (String) entry.getKey();
+            if (key.endsWith(DistributionConfig.JMX_SSL_PROPS_SUFFIX)) {
+              key =
+                  key.substring(0, key.length() - DistributionConfig.JMX_SSL_PROPS_SUFFIX.length());
+              jmxSpecificProps.add(key);
+
+              propsMap.put(key, (String) entry.getValue());
+            } else if (!jmxSpecificProps.contains(key)) {// Prefer properties ending with "-jmx"
+              // over default SSL props.
+              propsMap.put(key, (String) entry.getValue());
+            }
+          }
+          props.clear();
+          jmxSpecificProps.clear();
+        }
+      } catch (IOException io) {
+        throw new RuntimeException(
+            CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_READ_CONFIG_FROM_0,
+                CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath())),
+            io);
+      } finally {
+        IOUtils.close(inputStream);
+      }
+    }
+    return propsMap;
+  }
+
+  // Copied from DistributedSystem.java
+  public static URL getFileUrl(String fileName) {
+    File file = new File(fileName);
+
+    if (file.exists()) {
+      try {
+        return IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(file).toURI().toURL();
+      } catch (MalformedURLException ignore) {
+      }
+    }
+
+    file = new File(System.getProperty("user.home"), fileName);
+
+    if (file.exists()) {
+      try {
+        return IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(file).toURI().toURL();
+      } catch (MalformedURLException ignore) {
+      }
+    }
+
+    return ClassPathLoader.getLatest().getResource(ShellCommands.class, fileName);
+  }
+
+  public static ConnectToLocatorResult connectToLocator(String host, int port, int timeout,
+      Map<String, String> props) throws IOException {
+    // register DSFID types first; invoked explicitly so that all message type
+    // initializations do not happen in first deserialization on a possibly
+    // "precious" thread
+    DSFIDFactory.registerTypes();
+
+    JmxManagerLocatorResponse locatorResponse =
+        JmxManagerLocatorRequest.send(host, port, timeout, props);
+
+    if (StringUtils.isBlank(locatorResponse.getHost()) || locatorResponse.getPort() == 0) {
+      Throwable locatorResponseException = locatorResponse.getException();
+      String exceptionMessage = CliStrings.CONNECT__MSG__LOCATOR_COULD_NOT_FIND_MANAGER;
+
+      if (locatorResponseException != null) {
+        String locatorResponseExceptionMessage = locatorResponseException.getMessage();
+        locatorResponseExceptionMessage = (!StringUtils.isBlank(locatorResponseExceptionMessage)
+            ? locatorResponseExceptionMessage : locatorResponseException.toString());
+        exceptionMessage = "Exception caused JMX Manager startup to fail because: '"
+            .concat(locatorResponseExceptionMessage).concat("'");
+      }
+
+      throw new IllegalStateException(exceptionMessage, locatorResponseException);
+    }
+
+    ConnectionEndpoint memberEndpoint =
+        new ConnectionEndpoint(locatorResponse.getHost(), locatorResponse.getPort());
+
+    String resultMessage = CliStrings.format(CliStrings.CONNECT__MSG__CONNECTING_TO_MANAGER_AT_0,
+        memberEndpoint.toString(false));
+
+    return new ConnectToLocatorResult(memberEndpoint, resultMessage,
+        locatorResponse.isJmxManagerSslEnabled());
+  }
+
+  private static InfoResultData executeCommand(Gfsh gfsh, String userCommand, boolean useConsole)
+      throws IOException {
+    InfoResultData infoResultData = ResultBuilder.createInfoResultData();
+
+    String cmdToExecute = userCommand;
+    String cmdExecutor = "/bin/sh";
+    String cmdExecutorOpt = "-c";
+    if (SystemUtils.isWindows()) {
+      cmdExecutor = "cmd";
+      cmdExecutorOpt = "/c";
+    } else if (useConsole) {
+      cmdToExecute = cmdToExecute + " </dev/tty >/dev/tty";
+    }
+    String[] commandArray = {cmdExecutor, cmdExecutorOpt, cmdToExecute};
+
+    ProcessBuilder builder = new ProcessBuilder();
+    builder.command(commandArray);
+    builder.directory();
+    builder.redirectErrorStream();
+    Process proc = builder.start();
+
+    BufferedReader input = new BufferedReader(new InputStreamReader(proc.getInputStream()));
+
+    String lineRead = "";
+    while ((lineRead = input.readLine()) != null) {
+      infoResultData.addLine(lineRead);
+    }
+
+    proc.getOutputStream().close();
+
+    try {
+      if (proc.waitFor() != 0) {
+        gfsh.logWarning("The command '" + userCommand + "' did not complete successfully", null);
+      }
+    } catch (final InterruptedException e) {
+      Thread.currentThread().interrupt();
+      throw new IllegalStateException(e.getMessage(), e);
+    }
+    return infoResultData;
+  }
+
-  // millis that connect --locator will wait for a response from the locator.
-  private final static int CONNECT_LOCATOR_TIMEOUT_MS = 60000; // see bug 45971
-
-  public static int getConnectLocatorTimeoutInMS() {
-    return ShellCommands.CONNECT_LOCATOR_TIMEOUT_MS;
-  }
-
-
-
-  private static String getGfshLogsCheckMessage(String logFilePath) {
-    return CliStrings.format(CliStrings.GFSH__PLEASE_CHECK_LOGS_AT_0, logFilePath);
-  }
-
-  /* package-private */
-  static Map<String, String> loadPropertiesFromURL(URL gfSecurityPropertiesUrl) {
-    Map<String, String> propsMap = Collections.emptyMap();
-
-    if (gfSecurityPropertiesUrl != null) {
-      InputStream inputStream = null;
-      try {
-        Properties props = new Properties();
-        inputStream = gfSecurityPropertiesUrl.openStream();
-        props.load(inputStream);
-        if (!props.isEmpty()) {
-          Set<String> jmxSpecificProps = new HashSet<String>();
-          propsMap = new LinkedHashMap<String, String>();
-          Set<Entry<Object, Object>> entrySet = props.entrySet();
-          for (Entry<Object, Object> entry : entrySet) {
-
-            String key = (String) entry.getKey();
-            if (key.endsWith(DistributionConfig.JMX_SSL_PROPS_SUFFIX)) {
-              key =
-                  key.substring(0, key.length() - DistributionConfig.JMX_SSL_PROPS_SUFFIX.length());
-              jmxSpecificProps.add(key);
-
-              propsMap.put(key, (String) entry.getValue());
-            } else if (!jmxSpecificProps.contains(key)) {// Prefer properties ending with "-jmx"
-                                                         // over default SSL props.
-              propsMap.put(key, (String) entry.getValue());
-            }
-          }
-          props.clear();
-          jmxSpecificProps.clear();
-        }
-      } catch (IOException io) {
-        throw new RuntimeException(
-            CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_READ_CONFIG_FROM_0,
-                CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath())),
-            io);
-      } finally {
-        IOUtils.close(inputStream);
-      }
-    }
-    return propsMap;
-  }
-
-  // Copied from DistributedSystem.java
-  public static URL getFileUrl(String fileName) {
-    File file = new File(fileName);
-
-    if (file.exists()) {
-      try {
-        return IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(file).toURI().toURL();
-      } catch (MalformedURLException ignore) {
-      }
-    }
-
-    file = new File(System.getProperty("user.home"), fileName);
-
-    if (file.exists()) {
-      try {
-        return IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(file).toURI().toURL();
-      } catch (MalformedURLException ignore) {
-      }
-    }
-
-    return ClassPathLoader.getLatest().getResource(ShellCommands.class, fileName);
-  }
-
-  public static ConnectToLocatorResult connectToLocator(String host, int port, int timeout,
-      Map<String, String> props) throws IOException {
-    // register DSFID types first; invoked explicitly so that all message type
-    // initializations do not happen in first deserialization on a possibly
-    // "precious" thread
-    DSFIDFactory.registerTypes();
-
-    JmxManagerLocatorResponse locatorResponse =
-        JmxManagerLocatorRequest.send(host, port, timeout, props);
-
-    if (StringUtils.isBlank(locatorResponse.getHost()) || locatorResponse.getPort() == 0) {
-      Throwable locatorResponseException = locatorResponse.getException();
-      String exceptionMessage = CliStrings.CONNECT__MSG__LOCATOR_COULD_NOT_FIND_MANAGER;
-
-      if (locatorResponseException != null) {
-        String locatorResponseExceptionMessage = locatorResponseException.getMessage();
-        locatorResponseExceptionMessage = (!StringUtils.isBlank(locatorResponseExceptionMessage)
-            ? locatorResponseExceptionMessage : locatorResponseException.toString());
-        exceptionMessage = "Exception caused JMX Manager startup to fail because: '"
-            .concat(locatorResponseExceptionMessage).concat("'");
-      }
-
-      throw new IllegalStateException(exceptionMessage, locatorResponseException);
-    }
-
-    ConnectionEndpoint memberEndpoint =
-        new ConnectionEndpoint(locatorResponse.getHost(), locatorResponse.getPort());
-
-    String resultMessage = CliStrings.format(CliStrings.CONNECT__MSG__CONNECTING_TO_MANAGER_AT_0,
-        memberEndpoint.toString(false));
-
-    return new ConnectToLocatorResult(memberEndpoint, resultMessage,
-        locatorResponse.isJmxManagerSslEnabled());
-  }
-
-
-
-
-
-  // Enable when "use region" command is required. See #46110
-  // @CliCommand(value = { CliStrings.USE_REGION }, help = CliStrings.USE_REGION__HELP)
-  // @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH,
-  // CliStrings.TOPIC_GEODE_REGION})
-  // public Result useRegion(
-  // @CliArgument(name = CliStrings.USE_REGION__REGION,
-  // unspecifiedDefaultValue = "/",
-  // argumentContext = CliStrings.PARAM_CONTEXT_REGIONPATH,
-  // help = CliStrings.USE_REGION__REGION__HELP)
-  // String toRegion) {
-  // Gfsh gfsh = Gfsh.getCurrentInstance();
-  //
-  // gfsh.setPromptPath(toRegion);
-  // return ResultBuilder.createInfoResult("");
-  // }
-
-      boolean flagForLineNumbers =
-          (saveHistoryTo != null && saveHistoryTo.length() > 0) ? false : true;
+      boolean flagForLineNumbers = !(saveHistoryTo != null && saveHistoryTo.length() > 0);
-
-
-      @CliArgument(name = CliStrings.SH__COMMAND, mandatory = true,
+      @CliOption(key = {"", CliStrings.SH__COMMAND}, mandatory = true,
-  private static InfoResultData executeCommand(Gfsh gfsh, String userCommand, boolean useConsole)
-      throws IOException {
-    InfoResultData infoResultData = ResultBuilder.createInfoResultData();
-
-    String cmdToExecute = userCommand;
-    String cmdExecutor = "/bin/sh";
-    String cmdExecutorOpt = "-c";
-    if (SystemUtils.isWindows()) {
-      cmdExecutor = "cmd";
-      cmdExecutorOpt = "/c";
-    } else if (useConsole) {
-      cmdToExecute = cmdToExecute + " </dev/tty >/dev/tty";
-    }
-    String[] commandArray = {cmdExecutor, cmdExecutorOpt, cmdToExecute};
-
-    ProcessBuilder builder = new ProcessBuilder();
-    builder.command(commandArray);
-    builder.directory();
-    builder.redirectErrorStream();
-    Process proc = builder.start();
-
-    BufferedReader input = new BufferedReader(new InputStreamReader(proc.getInputStream()));
-
-    String lineRead = "";
-    while ((lineRead = input.readLine()) != null) {
-      infoResultData.addLine(lineRead);
-    }
-
-    proc.getOutputStream().close();
-
-    try {
-      if (proc.waitFor() != 0) {
-        gfsh.logWarning("The command '" + userCommand + "' did not complete successfully", null);
-      }
-    } catch (final InterruptedException e) {
-      throw new IllegalStateException(e);
-    }
-    return infoResultData;
-  }
-
-

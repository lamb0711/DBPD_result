GEODE-4176 locator creates "locator0view.dat" file when started with port 0

Modified the locator to ensure that the wildcard bind has occurred before
GMSLocator creates its persistent view file.  I also did some code
cleanup and addressed GEODE-1243.

This closes #1214

-   * locator state file
-   */
-  private File stateFile;
-
-  /**
-  // TODO: return value of removeLocator is never used
-  private static boolean removeLocator(InternalLocator locator) {
+  private static void removeLocator(InternalLocator locator) {
-      return false;
+      return;
-      if (locator != null && locator.equals(InternalLocator.locator)) {
+      if (locator.equals(InternalLocator.locator)) {
-        return true;
-      return false;
-   * @param stateFile the file that state should be read from / written to for recovery
-  public static InternalLocator createLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      String hostnameForClients, Properties distributedSystemProperties,
-      boolean startDistributedSystem) {
+  public static InternalLocator createLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, String hostnameForClients,
+      Properties distributedSystemProperties, boolean startDistributedSystem) {
-          new InternalLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+          new InternalLocator(port, logFile, logger, securityLogger, bindAddress,
-  public static InternalLocator startLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      boolean startDistributedSystem, Properties dsProperties, String hostnameForClients)
-      throws IOException {
+  public static InternalLocator startLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, boolean startDistributedSystem,
+      Properties dsProperties, String hostnameForClients) throws IOException {
-      newLocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+      newLocator = createLocator(port, logFile, logger, securityLogger, bindAddress,
-      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero
-      // port in a variable to use here
-        newLocator.startPeerLocation(startDistributedSystem);
+        newLocator.startPeerLocation();
+
-            // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
-   * @param stateF the file that state should be read from / written to for recovery
-  private InternalLocator(int port, File logF, File stateF, InternalLogWriter logWriter,
+  private InternalLocator(int port, File logF, InternalLogWriter logWriter,
-    if (stateF == null) {
-      this.stateFile = new File("locator" + port + "view.dat");
-    } else {
-      this.stateFile = stateF;
-    }
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  // Reset the file names with the correct port number if startLocatorAndDS was called with port
-  // number 0
-  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port) {
-    this.stateFile = new File("locator" + port + "view.dat");
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  }
-
-   * <p>
-   * TODO: parameter withDS is never used
-   * @param withDS true if a distributed system has been or will be started
-   *
+   * @return returns the port that the locator to which the locator is bound
-  void startPeerLocation(boolean withDS) throws IOException {
+  int startPeerLocation() throws IOException {
-    boolean locatorsAreCoordinators = false;
+    boolean locatorsAreCoordinators;
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
-        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats,
-        securityUDPDHAlgo);
+    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, locatorsProp,
+        locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats, securityUDPDHAlgo);
+    int boundPort = this.server.getPort();
+    File productUseFile = new File("locator" + boundPort + "views.log");
+    productUseLog = new ProductUseLog(productUseFile);
+
+    return boundPort;
-  public PrimaryHandler getPrimaryHandler() {
-    return this.handler;
-  }
-
-  public static InternalLocator startLocator(int locatorPort, File logFile, File stateFile,
+  public static InternalLocator startLocator(int locatorPort, File logFile,
-    return startLocator(locatorPort, logFile, stateFile, logger, logger1, addr, true, dsProperties,
-        s);
+    return startLocator(locatorPort, logFile, logger, logger1, addr, true, dsProperties, s);
-    this.productUseLog.monitorUse(distributedSystem);
-
+    // the product use is not guaranteed to be initialized until the server is started, so
+    // the last thing we do is tell it to start logging
+    this.productUseLog.monitorUse(distributedSystem);
-    this.productUseLog.close();
+    if (this.productUseLog != null) {
+      this.productUseLog.close();
+    }
-      // TODO: this for-loop is probably not necessary as the if to break is always true
-      for (int i = 0; i < MAX_RETRIES; i++) {
-        if (locator.sharedConfig != null) {
-          SharedConfigurationStatus status = locator.sharedConfig.getStatus();
-          if (status != SharedConfigurationStatus.STARTED
-              || status != SharedConfigurationStatus.NOT_STARTED) {
-            break;
-          }
-        }
-        Thread.sleep(SLEEPTIME);
-      }
+
-      if (this.locator.sharedConfig == null) {
+      if (locator.sharedConfig == null) {
-        this.locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
+        locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
-      this.locator.sharedConfig.initSharedConfiguration(this.locator.loadFromSharedConfigDir());
+      locator.sharedConfig.initSharedConfiguration(locator.loadFromSharedConfigDir());

GEODE-3249: Validate internal client/server messages

This is a squashed commit of the following from feature/GEODE-3249b:

commit c16b151e57169733186f0c029d1957da32d59635
    "spotless" fixes

commit f8e7ddd5e4696907ce60a14f581ef1ca83e65232

    GEODE-3249: Validate internal client/server messages

    This was merely a matter of changing the server to require the credentials
    and changing the client to send credentials.  I removed the general overriding
    of AbstractOp.processSecureBytes() because it made no sense.  If the server
    sends a secure byte "part" in a message the client is obligated to process
    it or the next message it sends will cause a security violation.

    I've added a server-side property that folks can set to allow old clients
    to continue to work.  This must be used to roll the servers forward to the
    new version that contains this change.  Clients must then be rolled
    forward & the servers can then be rolled once again without the property set.

    The system property is
      geode.allow-internal-messages-without-credentials=true

(cherry picked from commit 6be38cad729d56f355c7586ec994bfef933c5e65)

+   * Process the security information in a response from the server. If the server sends a security
+   * "part" we must process it so all subclasses should allow this method to be invoked.
+   *
+   * @see ServerConnection#updateAndGetSecurityPart()
+   */
+  protected void processSecureBytes(Connection cnx, Message message) throws Exception {
+    if (cnx.getServer().getRequiresCredentials()) {
+      if (!message.isSecureMode()) {
+        // This can be seen during shutdown
+        if (logger.isDebugEnabled()) {
+          logger.trace(LogMarker.BRIDGE_SERVER,
+              "Response message from {} for {} has no secure part.", cnx, this);
+        }
+        return;
+      }
+      byte[] partBytes = message.getSecureBytes();
+      if (partBytes == null) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("Response message for {} has no bytes in secure part.", this);
+        }
+        return;
+      }
+      byte[] bytes = ((ConnectionImpl) cnx).getHandShake().decryptBytes(partBytes);
+      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));
+      cnx.setConnectionID(dis.readLong());
+    }
+  }
+
+  /**
+   * New implementations of AbstractOp should override this method to return false if the
+   * implementation should be excluded from client authentication. e.g. PingOp#needsUserId()
+   * <P/>
+   * Also, such an operation's <code>MessageType</code> must be added in the 'if' condition in
+   * {@link ServerConnection#updateAndGetSecurityPart()}
+   *
+   * @return boolean
+   * @see AbstractOp#sendMessage(Connection)
+   * @see ServerConnection#updateAndGetSecurityPart()
+   */
+  protected boolean needsUserId() {
+    return true;
+  }
+
+  /**
-   * New implementations of AbstractOp should override this method if the implementation should be
-   * excluded from client authentication. e.g. PingOp#processSecureBytes(Connection cnx, Message
-   * message)
-   * 
-   * @see AbstractOp#sendMessage(Connection)
-   * @see AbstractOp#needsUserId()
-   * @see ServerConnection#updateAndGetSecurityPart()
-   */
-  protected void processSecureBytes(Connection cnx, Message message) throws Exception {
-    if (cnx.getServer().getRequiresCredentials()) {
-      if (!message.isSecureMode()) {
-        // This can be seen during shutdown
-        if (logger.isDebugEnabled()) {
-          logger.trace(LogMarker.BRIDGE_SERVER,
-              "Response message from {} for {} has no secure part.", cnx, this);
-        }
-        return;
-      }
-      byte[] partBytes = message.getSecureBytes();
-      if (partBytes == null) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("Response message for {} has no bytes in secure part.", this);
-        }
-        return;
-      }
-      byte[] bytes = ((ConnectionImpl) cnx).getHandShake().decryptBytes(partBytes);
-      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));
-      cnx.setConnectionID(dis.readLong());
-    }
-  }
-
-  /**
-   * New implementations of AbstractOp should override this method to return false if the
-   * implementation should be excluded from client authentication. e.g. PingOp#needsUserId()
-   * <P/>
-   * Also, such an operation's <code>MessageType</code> must be added in the 'if' condition in
-   * {@link ServerConnection#updateAndGetSecurityPart()}
-   * 
-   * @return boolean
-   * @see AbstractOp#sendMessage(Connection)
-   * @see AbstractOp#processSecureBytes(Connection, Message)
-   * @see ServerConnection#updateAndGetSecurityPart()
-   */
-  protected boolean needsUserId() {
-    return true;
-  }
-
-  /**

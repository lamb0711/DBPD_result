Merge branch 'release/1.8.0'

-import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
-  static final ExecutorService execService = Executors.newCachedThreadPool(new ThreadFactory() {
-    AtomicInteger threadNum = new AtomicInteger();
-
-    public Thread newThread(final Runnable r) {
-      Thread result = new Thread(r, "Function Execution Thread-" + threadNum.incrementAndGet());
-      result.setDaemon(true);
-      return result;
-    }
-  });
+  static final ExecutorService execService =
+      LoggingExecutors.newCachedThreadPool("Function Execution Thread-", true);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-          function), exception);
+      logger.warn(String.format("Exception on server while executing function: %s",
+          function),
+          exception);
-          LocalizedStrings.ExecuteFunction_THE_INPUT_FUNCTION_FOR_THE_EXECUTE_FUNCTION_REQUEST_IS_NULL
-              .toLocalizedString();
-      logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON,
-          new Object[] {serverConnection.getName(), message}));
+          "The input function for the execute function request is null";
+      logger.warn("{} : {}",
+          new Object[] {serverConnection.getName(), message});
-          final String message = LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED
-              .toLocalizedString(function);
+          final String message =
+              String.format("Function named %s is not registered to FunctionService",
+                  function);
-                LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER
-                    .toLocalizedString(function);
+                "Function attributes at client and server don't match for " +
+                    function;
-      functionObject.getRequiredPermissions(null).forEach(securityService::authorize);
+      functionObject.getRequiredPermissions(null, args).forEach(securityService::authorize);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-          function), ioException);
+      logger.warn(String.format("Exception on server while executing function: %s",
+          function),
+          ioException);
-          LocalizedStrings.ExecuteFunction_SERVER_COULD_NOT_SEND_THE_REPLY.toLocalizedString();
+          "Server could not send the reply";
-        logger.debug(LocalizedMessage.create(
-            LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-            new Object[] {function}), internalfunctionException);
+        logger.debug(String.format("Exception on server while executing function: %s",
+            new Object[] {function}),
+            internalfunctionException);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-          function), e);
+      logger.warn(String.format("Exception on server while executing function: %s",
+          function),
+          e);
-            LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                .toString(fn.getId()));
+            String.format("The function, %s, did not send last result",
+                fn.getId()));
-              if (cache.getLoggerI18n().warningEnabled() && !ASYNC_TX_WARNING_ISSUED) {
+              if (cache.getLogger().warningEnabled() && !ASYNC_TX_WARNING_ISSUED) {
-                cache.getLoggerI18n().warning(
-                    LocalizedStrings.ExecuteFunction66_TRANSACTIONAL_FUNCTION_WITHOUT_RESULT);
+                cache.getLogger().warning(
+                    "Function invoked within transactional context, but hasResults() is false; ordering of transactional operations cannot be guaranteed.  This message is only issued once by a server.");
-              logger.debug(LocalizedMessage.create(
-                  LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-                  new Object[] {fn}), internalfunctionException);
+              logger.debug(String.format("Exception on server while executing function: %s",
+                  new Object[] {fn}),
+                  internalfunctionException);
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-                fn), functionException);
+            logger.warn(String.format("Exception on server while executing function: %s",
+                fn),
+                functionException);
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-                fn), exception);
+            logger.warn(String.format("Exception on server while executing function: %s",
+                fn),
+                exception);

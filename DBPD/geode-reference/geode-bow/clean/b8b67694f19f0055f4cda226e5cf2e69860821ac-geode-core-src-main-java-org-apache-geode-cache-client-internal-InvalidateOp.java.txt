Merge branch 'develop' into feature/GEODE-7049

+import org.apache.geode.cache.CacheClosedException;
+import org.apache.geode.cache.Operation;
+import org.apache.geode.cache.client.AllConnectionsInUseException;
+import org.apache.geode.cache.client.ServerConnectivityException;
+import org.apache.geode.cache.client.ServerOperationException;
+import org.apache.geode.distributed.internal.ServerLocation;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.tier.sockets.Part;
-   * @param region the name of the region to do the entry keySet on
+   * @param regionName the name of the region to do the entry invalidate on.
+   * @param region the region to do the entry invalidate on.
+   * @param event the event for this invalidate operation
-  public static void execute(ExecutablePool pool, String region, EntryEventImpl event) {
-    AbstractOp op = new InvalidateOpImpl(region, event);
-    pool.execute(op);
+  public static Object execute(ExecutablePool pool, String regionName, EntryEventImpl event,
+      boolean prSingleHopEnabled,
+      LocalRegion region) {
+    AbstractOp op = new InvalidateOpImpl(regionName, event, prSingleHopEnabled, region);
+
+    if (prSingleHopEnabled) {
+      ClientMetadataService cms = region.getCache().getClientMetadataService();
+      ServerLocation server =
+          cms.getBucketServerLocation(region, Operation.INVALIDATE, event.getKey(), null,
+              event.getCallbackArgument());
+      if (server != null) {
+        try {
+          PoolImpl poolImpl = (PoolImpl) pool;
+          boolean onlyUseExistingCnx = (poolImpl.getMaxConnections() != -1
+              && poolImpl.getConnectionCount() >= poolImpl.getMaxConnections());
+          op.setAllowDuplicateMetadataRefresh(!onlyUseExistingCnx);
+          return pool.executeOn(new ServerLocation(server.getHostName(), server.getPort()), op,
+              true, onlyUseExistingCnx);
+        } catch (AllConnectionsInUseException e) {
+        } catch (ServerConnectivityException e) {
+          if (e instanceof ServerOperationException) {
+            throw e; // fixed 44656
+          }
+          cms.removeBucketServerLocation(server);
+        }
+      }
+    }
+    return pool.execute(op);
+    private boolean prSingleHopEnabled = false;
+
+    private LocalRegion region = null;
+
-    public InvalidateOpImpl(String region, EntryEventImpl event) {
+    public InvalidateOpImpl(String regionName, EntryEventImpl event, boolean prSingleHopEnabled,
+        LocalRegion region) {
-      getMessage().addStringPart(region, true);
+      this.prSingleHopEnabled = prSingleHopEnabled;
+      this.region = region;
+
+      getMessage().addStringPart(regionName, true);
+
+      if (prSingleHopEnabled) {
+        Part part = msg.getPart(partIdx++);
+        byte[] bytesReceived = part.getSerializedForm();
+        if (bytesReceived[0] != ClientMetadataService.INITIAL_VERSION
+            && bytesReceived.length == ClientMetadataService.SIZE_BYTES_ARRAY_RECEIVED) {
+          if (this.region != null) {
+            try {
+              ClientMetadataService cms = region.getCache().getClientMetadataService();
+              int myVersion =
+                  cms.getMetaDataVersion(region, Operation.UPDATE, event.getKey(), null,
+                      event.getCallbackArgument());
+              if (myVersion != bytesReceived[0] || isAllowDuplicateMetadataRefresh()) {
+                cms.scheduleGetPRMetaData(region, false, bytesReceived[1]);
+              }
+            } catch (CacheClosedException e) {
+              return null;
+            }
+          }
+        }
+      }

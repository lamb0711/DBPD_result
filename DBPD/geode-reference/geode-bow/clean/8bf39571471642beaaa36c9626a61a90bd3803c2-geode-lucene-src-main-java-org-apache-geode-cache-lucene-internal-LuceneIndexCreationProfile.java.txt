Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  public LuceneIndexCreationProfile(String indexName, String regionPath, String[] fieldNames, Analyzer analyzer,
-                                    Map<String, Analyzer> fieldAnalyzers) {
+  public LuceneIndexCreationProfile(String indexName, String regionPath, String[] fieldNames,
+      Analyzer analyzer, Map<String, Analyzer> fieldAnalyzers) {
-     if(fieldAnalyzers != null && !fieldAnalyzers.isEmpty())  {
-        this.fieldAnalyzers.put(field, fieldAnalyzers.get(field) == null ? StandardAnalyzer.class.getSimpleName() : fieldAnalyzers.get(field).getClass().getSimpleName());
+      if (fieldAnalyzers != null && !fieldAnalyzers.isEmpty()) {
+        this.fieldAnalyzers.put(field,
+            fieldAnalyzers.get(field) == null ? StandardAnalyzer.class.getSimpleName()
+                : fieldAnalyzers.get(field).getClass().getSimpleName());
-    return "lucene_"+LuceneServiceImpl.getUniqueIndexName(indexName, regionPath);
+    return "lucene_" + LuceneServiceImpl.getUniqueIndexName(indexName, regionPath);
-      // TODO This can occur if one member defines no indexes but another one does. Currently this is caught by the async event id checks.
+      // TODO This can occur if one member defines no indexes but another one does. Currently this
+      // is caught by the async event id checks.
-            .toString(getIndexName(), regionPath, Arrays.toString(getFieldNames()), Arrays.toString(remoteProfile.getFieldNames()));
+            .toString(getIndexName(), regionPath, Arrays.toString(getFieldNames()),
+                Arrays.toString(remoteProfile.getFieldNames()));
-      // Note: This test will currently only fail if per-field analyzers are used in one member but not another,
-      // This condition will be caught in the tests below so this test is commented out. If we ever allow the user
+      // Note: This test will currently only fail if per-field analyzers are used in one member but
+      // not another,
+      // This condition will be caught in the tests below so this test is commented out. If we ever
+      // allow the user
-      if (!remoteLuceneIndexProfile.getAnalyzerClass().isInstance(getAnalyzer())) {
-        result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_3
-            .toString(indexName, regionPath, remoteLuceneIndexProfile.getAnalyzerClass().getName(), analyzer.getClass().getName());
-      }
-      */
+       * if (!remoteLuceneIndexProfile.getAnalyzerClass().isInstance(getAnalyzer())) { result =
+       * LocalizedStrings.
+       * LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_3
+       * .toString(indexName, regionPath, remoteLuceneIndexProfile.getAnalyzerClass().getName(),
+       * analyzer.getClass().getName()); }
+       */
-      // Note: This is currently destructive to the input field analyzers map which should be ok since its a transient object.
+      // Note: This is currently destructive to the input field analyzers map which should be ok
+      // since its a transient object.
-              .toString(getIndexName(), regionPath, 
+              .toString(getIndexName(), regionPath,
-        for (String field:getFieldAnalyzers().keySet()) {
-          if (!remoteProfile.getFieldAnalyzers().get(field).equals(getFieldAnalyzers().get(field))) {
+        for (String field : getFieldAnalyzers().keySet()) {
+          if (!remoteProfile.getFieldAnalyzers().get(field)
+              .equals(getFieldAnalyzers().get(field))) {
-              .toString(getIndexName(), regionPath,
-                    getFieldAnalyzers().get(field), field,
-                    remoteProfile.getFieldAnalyzers().get(field)); 
+                .toString(getIndexName(), regionPath, getFieldAnalyzers().get(field), field,
+                    remoteProfile.getFieldAnalyzers().get(field));
-    return new StringBuilder()
-        .append(getClass().getSimpleName())
-        .append("[")
-        .append("indexName=")
-        .append(this.indexName)
-        .append("; fieldNames=")
-        .append(Arrays.toString(this.fieldNames))
-        .append("; analyzerClass=")
-        .append(this.analyzerClass)
-        .append("; fieldAnalyzers=")
-        .append(this.fieldAnalyzers)
-        .append("]")
-        .toString();
+    return new StringBuilder().append(getClass().getSimpleName()).append("[").append("indexName=")
+        .append(this.indexName).append("; fieldNames=").append(Arrays.toString(this.fieldNames))
+        .append("; analyzerClass=").append(this.analyzerClass).append("; fieldAnalyzers=")
+        .append(this.fieldAnalyzers).append("]").toString();

GEODE-7884: server hangs due to IllegalStateException (#4822)

* GEODE-7884: server hangs due to IllegalStateException

Added cancellation check before scheduling an idle-timeout or
ack-wait-threshold timer task.  I had to add a new method to
SystemTimerTask and then noticed there were no tests for SystemTimer, so
I cleaned up that class and added tests.

* adding missing copyright header to new test

* fixing LGTM issues

* reinstating 'continue' when encountering a null timer during a sweep

* addressing Bill's comments

renamed swarm everwhere
made the collection of timers associated with a DistributedSystem into a Set
made timer task variables in Connection volatile
added checks in tasks to cancel themselves if their Connection is closed
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.DistributedSystem;
- * Instances of this class are like {@link Timer}, but are associated with a "swarm", which can be
- * cancelled as a group with {@link #cancelSwarm(Object)}.
+ * Instances of this class are like {@link Timer}, but are associated with a DistributedSystem,
+ * which can be
+ * cancelled as a group with {@link #cancelTimers(DistributedSystem)}.
- *      TODO -- with Java 1.5, this will be a template type so that the swarm's class can be
- *      specified.
-   * Extra debugging for this class
-   */
-  // private static final boolean DEBUG = true;
-  static final boolean DEBUG = false;
-
-  /**
-  private boolean cancelled = false;
+  private volatile boolean cancelled = false;
-   * the swarm to which this timer belongs
+   * the DistributedSystem to which this timer belongs
-  private final Object /* T */ swarm;
+  private final DistributedSystem distributedSystem;
-    StringBuffer sb = new StringBuffer();
-    sb.append("SystemTimer[");
-    sb.append("swarm = " + swarm);
-    // sb.append("; timer = " + timer);
-    sb.append("]");
-    return sb.toString();
+    return "SystemTimer["
+        + "system = " + distributedSystem
+        + "]";
-   * List of all of the swarms in the system
+   * Map of all of the timers in the system
-  private static final HashMap allSwarms = new HashMap();
+  private static final HashMap<DistributedSystem, Set<WeakReference<SystemTimer>>> distributedSystemTimers =
+      new HashMap<>();
-   * Add the given timer is in the given swarm. Used only by constructors.
+   * Add the given timer is in the given DistributedSystem. Used only by constructors.
-   * @param swarm swarm to add the timer to
-   * @param t timer to add
+   * @param system DistributedSystem to add the timer to
+   * @param systemTimer timer to add
-  private static void addToSwarm(Object /* T */ swarm, SystemTimer t) {
-    final boolean isDebugEnabled = logger.isTraceEnabled();
-    // Get or add list of timers for this swarm...
-    ArrayList /* ArrayList<WeakReference<SystemTimer>> */ swarmSet;
-    synchronized (allSwarms) {
-      swarmSet = (ArrayList) allSwarms.get(swarm);
-      if (swarmSet == null) {
-        if (isDebugEnabled) {
-          logger.trace("SystemTimer#addToSwarm: created swarm {}", swarm);
-        }
-        swarmSet = new ArrayList();
-        allSwarms.put(swarm, swarmSet);
+  private static void addTimer(DistributedSystem system, SystemTimer systemTimer) {
+    Set<WeakReference<SystemTimer>> timers;
+    synchronized (distributedSystemTimers) {
+      timers = distributedSystemTimers.get(system);
+      if (timers == null) {
+        timers = new HashSet<>();
+        distributedSystemTimers.put(system, timers);
-    } // synchronized
-
-    // Add the timer to the swarm's list
-    if (isDebugEnabled) {
-      logger.trace("SystemTimer#addToSwarm: adding timer <{}>", t);
-    WeakReference /* WeakReference<SystemTimer> */ wr = new WeakReference(t);
-    synchronized (swarmSet) {
-      swarmSet.add(wr);
-    } // synchronized
+
+    WeakReference<SystemTimer> wr = new WeakReference<>(systemTimer);
+    synchronized (timers) {
+      timers.add(wr);
+    }
+  }
+
+  /**
+   * Return the current number of DistributedSystems with timers
+   */
+  public static int distributedSystemCount() {
+    synchronized (distributedSystemTimers) {
+      return distributedSystemTimers.size();
+    }
-   * @see #sweepAllSwarms
+   * @see #sweepAllTimers
-   * Interval, in milliseconds, to sweep all swarms, measured from when the last sweep finished
+   * Interval, in milliseconds, to sweep all timers, measured from when the last sweep finished
-   * @see #sweepAllSwarms
+   * @see #sweepAllTimers
-   * Manually garbage collect {@link #allSwarms}, if it hasn't happened in a while.
+   * Manually garbage collect {@link #distributedSystemTimers}, if it hasn't happened in a while.
-  private static void sweepAllSwarms() {
+  private static void sweepAllTimers() {
-    synchronized (allSwarms) {
-      Iterator it = allSwarms.entrySet().iterator();
-      while (it.hasNext()) { // iterate over allSwarms
-        Map.Entry entry = (Map.Entry) it.next();
-        ArrayList swarm = (ArrayList) entry.getValue();
-        synchronized (swarm) {
-          Iterator it2 = swarm.iterator();
-          while (it2.hasNext()) { // iterate over current swarm
-            WeakReference wr = (WeakReference) it2.next();
-            SystemTimer st = (SystemTimer) wr.get();
-            if (st == null) {
-              // Remove stale reference
-              it2.remove();
-              continue;
+    synchronized (distributedSystemTimers) {
+      Iterator<Map.Entry<DistributedSystem, Set<WeakReference<SystemTimer>>>> allSystemsIterator =
+          distributedSystemTimers.entrySet().iterator();
+      while (allSystemsIterator.hasNext()) {
+        Map.Entry<DistributedSystem, Set<WeakReference<SystemTimer>>> entry =
+            allSystemsIterator.next();
+        Set<WeakReference<SystemTimer>> timers = entry.getValue();
+        synchronized (timers) {
+          Iterator<WeakReference<SystemTimer>> timersIterator = timers.iterator();
+          while (timersIterator.hasNext()) {
+            WeakReference<SystemTimer> wr = timersIterator.next();
+            SystemTimer st = wr.get();
+            if (st == null || st.isCancelled()) {
+              timersIterator.remove();
-            // Get rid of a cancelled timer; it's not interesting.
-            if (st.cancelled) {
-              it2.remove();
-              continue;
-            }
-          } // iterate over current swarm
-          if (swarm.size() == 0) { // Remove unused swarm
-            it.remove();
-            if (isDebugEnabled) {
-              logger.trace("SystemTimer#sweepAllSwarms: removed unused swarm {}", entry.getKey());
-            }
-          } // Remove unused swarm
-        } // synchronized swarm
-      } // iterate over allSwarms
-    } // synchronized allSwarms
+          }
+          if (timers.size() == 0) {
+            allSystemsIterator.remove();
+          }
+        }
+      }
+    }
-   * Remove given timer from the swarm.
+   * Remove given timer.
-   * @param t timer to remove
+   * @param timerToRemove timer to remove
-  private static void removeFromSwarm(SystemTimer t) {
-    final boolean isDebugEnabled = logger.isTraceEnabled();
-    synchronized (allSwarms) {
-      // Get timer's swarm
-      ArrayList swarmSet = (ArrayList) allSwarms.get(t.swarm);
-      if (swarmSet == null) {
-        if (isDebugEnabled) {
-          logger.trace("SystemTimer#removeFromSwarm: timer already removed: {}", t);
-        }
+  private static void removeTimer(SystemTimer timerToRemove) {
+    synchronized (distributedSystemTimers) {
+      // Get the timers for the distributed system
+      Set<WeakReference<SystemTimer>> timers =
+          distributedSystemTimers.get(timerToRemove.distributedSystem);
+      if (timers == null) {
-      // Remove timer from swarm
-      if (isDebugEnabled) {
-        logger.trace("SystemTimer#removeFromSwarm: removing timer <{}>", t);
-      }
-      synchronized (swarmSet) {
-        Iterator it = swarmSet.iterator();
-        while (it.hasNext()) {
-          WeakReference ref = (WeakReference) it.next();
-          SystemTimer t2 = (SystemTimer) ref.get();
-          if (t2 == null) {
-            // Since we've discovered an empty reference, we should remove it.
-            it.remove();
-            continue;
-          }
-          if (t2 == t) {
-            it.remove();
-            // Don't keep sweeping once we've found it; just quit.
+      synchronized (timers) {
+        Iterator<WeakReference<SystemTimer>> timersIterator = timers.iterator();
+        while (timersIterator.hasNext()) {
+          WeakReference<SystemTimer> ref = timersIterator.next();
+          SystemTimer timer = ref.get();
+          if (timer == null) {
+            timersIterator.remove();
+          } else if (timer == timerToRemove) {
+            timersIterator.remove();
-          }
-          if (t2.cancelled) {
-            // But if we happen to run across a cancelled timer,
-            // remove it.
-            it.remove();
-            continue;
-          }
-        } // while
-
-        // While we're here, if the swarm has gone to zero size,
-        // we should remove it.
-        if (swarmSet.size() == 0) {
-          allSwarms.remove(t.swarm); // last reference
-          if (isDebugEnabled) {
-            logger.trace("SystemTimer#removeFromSwarm: removed last reference to {}", t.swarm);
+          } else if (timer.isCancelled()) {
+            timersIterator.remove();
-      } // synchronized swarmSet
-    } // synchronized allSwarms
+        if (timers.size() == 0) {
+          distributedSystemTimers.remove(timerToRemove.distributedSystem); // last reference
+        }
+      }
+    }
-    sweepAllSwarms(); // Occasionally check global list, use any available logger :-)
+    sweepAllTimers(); // Occasionally check global list
-   * @param swarm the swarm to cancel
+   * @param system the DistributedSystem whose timers should be cancelled
-  public static void cancelSwarm(Object /* T */ swarm) {
-    Assert.assertTrue(swarm instanceof InternalDistributedSystem); // TODO
-    // Find the swarmSet and remove it
-    ArrayList swarmSet;
-    synchronized (allSwarms) {
-      swarmSet = (ArrayList) allSwarms.get(swarm);
-      if (swarmSet == null) {
+  public static void cancelTimers(DistributedSystem system) {
+    Set<WeakReference<SystemTimer>> timers;
+    synchronized (distributedSystemTimers) {
+      timers = distributedSystemTimers.get(system);
+      if (timers == null) {
-      allSwarms.remove(swarmSet);
+      distributedSystemTimers.remove(system);
-    // Empty the swarmSet
-    synchronized (swarmSet) {
-      Iterator it = swarmSet.iterator();
-      while (it.hasNext()) {
-        WeakReference wr = (WeakReference) it.next();
-        SystemTimer st = (SystemTimer) wr.get();
+    // cancel all of the timers
+    synchronized (timers) {
+      for (WeakReference<SystemTimer> wr : timers) {
+        SystemTimer st = wr.get();
-      } // while
-    } // synchronized
+      }
+    }
-    if (logger.isTraceEnabled()) {
-      logger.trace("SystemTimer#timerPurge of {}", this);
-    }
-
-  // This creates a non-daemon timer thread. We don't EVER do this...
-  // /**
-  // * @see Timer#Timer()
-  // *
-  // * @param swarm the swarm this timer belongs to
-  // */
-  // public SystemTimer(DistributedSystem swarm) {
-  // this.timer = new Timer();
-  // this.swarm = swarm;
-  // addToSwarm(swarm, this);
-  // }
-
-   * @param swarm the swarm this timer belongs to, currently must be a DistributedSystem
-   * @param isDaemon whether the timer is a daemon. Must be true for GemFire use.
+   * @param distributedSystem the DistributedSystem to which this timer belongs
-  public SystemTimer(Object /* T */ swarm, boolean isDaemon) {
-    Assert.assertTrue(isDaemon); // we don't currently allow non-daemon timers
-    Assert.assertTrue(swarm instanceof InternalDistributedSystem,
-        "Attempt to create swarm on " + swarm); // TODO allow template class?
-    this.timer = new Timer(isDaemon);
-    this.swarm = swarm;
-    addToSwarm(swarm, this);
-  }
-
-  /**
-   * @param name the name to give the timer thread
-   * @param swarm the swarm this timer belongs to, currently must be a DistributedMember
-   * @param isDaemon whether the timer is a daemon. Must be true for GemFire use.
-   */
-  public SystemTimer(String name, Object /* T */ swarm, boolean isDaemon) {
-    Assert.assertTrue(isDaemon); // we don't currently allow non-daemon timers
-    Assert.assertTrue(swarm instanceof InternalDistributedSystem,
-        "Attempt to create swarm on " + swarm); // TODO allow template class?
-    this.timer = new Timer(name, isDaemon);
-    this.swarm = swarm;
-    addToSwarm(swarm, this);
+  public SystemTimer(DistributedSystem distributedSystem) {
+    this.timer = new Timer(true);
+    this.distributedSystem = distributedSystem;
+    addTimer(distributedSystem, this);
-    if (logger.isTraceEnabled()) {
-      Date tilt = new Date(System.currentTimeMillis() + delay);
-      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
-      logger.trace("SystemTimer#schedule (long): {}: expect task {} to fire around {}", this, task,
-          sdf.format(tilt));
-    }
-    if (logger.isTraceEnabled()) {
-      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
-      logger.trace("SystemTimer#schedule (Date): {}: expect task {} to fire around {}", this, task,
-          sdf.format(time));
-    }
-  // Not currently used, so don't complicate things
-  // /**
-  // * @see Timer#schedule(TimerTask, long, long)
-  // */
-  // public void schedule(SystemTimerTask task, long delay, long period) {
-  // // TODO add debug statement
-  // checkCancelled();
-  // timer.schedule(task, delay, period);
-  // }
-
-  // Not currently used, so don't complicate things
-  // /**
-  // * @see Timer#schedule(TimerTask, Date, long)
-  // */
-  // public void schedule(SystemTimerTask task, Date firstTime, long period) {
-  // // TODO add debug statement
-  // checkCancelled();
-  // timer.schedule(task, firstTime, period);
-  // }
-
-    // TODO add debug statement
-    // TODO add debug statement
-  // Not currently used, so don't complicate things
-  // /**
-  // * @see Timer#scheduleAtFixedRate(TimerTask, Date, long)
-  // */
-  // public void scheduleAtFixedRate(SystemTimerTask task, Date firstTime,
-  // long period) {
-  // // TODO add debug statement
-  // checkCancelled();
-  // timer.scheduleAtFixedRate(task, firstTime, period);
-  // }
-
-
-    removeFromSwarm(this);
+    removeTimer(this);
+  }
+
+  /**
+   * has this timer been cancelled?
+   */
+  public boolean isCancelled() {
+    return cancelled;
+    private volatile boolean cancelled;
+
+    public boolean isCancelled() {
+      return cancelled;
+    }
+
+    @Override
+    public boolean cancel() {
+      cancelled = true;
+      return super.cancel();
+    }
-      final boolean isDebugEnabled = logger.isTraceEnabled();
-      if (isDebugEnabled) {
-        logger.trace("SystemTimer.MyTask: starting {}", this);
-      }
-      } catch (VirtualMachineError e) {
-        SystemFailure.initiateFailure(e);
-        throw e;
-        SystemFailure.checkFailure();
-      if (isDebugEnabled) {
-        logger.trace("SystemTimer.MyTask: finished {}", this);
-      }

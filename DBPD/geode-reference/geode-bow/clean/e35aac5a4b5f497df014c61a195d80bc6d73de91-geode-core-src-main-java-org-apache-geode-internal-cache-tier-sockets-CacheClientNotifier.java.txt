Merge branch 'release/1.5.0'

-import static org.apache.geode.distributed.ConfigurationProperties.*;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_ACCESSOR_PP;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_AUTHENTICATOR;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionManager;
-import org.apache.geode.internal.cache.tier.Acceptor;
-    writeMessage(dos, type, p_msg, clientVersion, (byte) 0x00, 0);
+    writeHandshakeMessage(dos, type, p_msg, clientVersion, (byte) 0x00, 0);
-  private void writeMessage(DataOutputStream dos, byte type, String p_msg, Version clientVersion,
-      byte epType, int qSize) throws IOException {
+  private void writeHandshakeMessage(DataOutputStream dos, byte type, String p_msg,
+      Version clientVersion, byte endpointType, int queueSize) throws IOException {
-    // dummy epType
-    dos.writeByte(epType);
-    // dummy qSize
-    dos.writeInt(qSize);
+    dos.writeByte(endpointType);
+    dos.writeInt(queueSize);
+      if (clientVersion.compareTo(Version.GEODE_150) >= 0) {
+        dos.writeInt(CLIENT_PING_TASK_PERIOD);
+      }
-    byte clientConflation = HandShake.CONFLATION_DEFAULT;
+    byte clientConflation;
-        writeException(dos, HandShake.REPLY_INVALID,
+        writeException(dos, Handshake.REPLY_INVALID,
-        byte[] overrides = HandShake.extractOverrides(new byte[] {(byte) dis.read()});
+        byte[] overrides = Handshake.extractOverrides(new byte[] {(byte) dis.read()});
-        case HandShake.CONFLATION_DEFAULT:
-        case HandShake.CONFLATION_OFF:
-        case HandShake.CONFLATION_ON:
+        case Handshake.CONFLATION_DEFAULT:
+        case Handshake.CONFLATION_OFF:
+        case Handshake.CONFLATION_ON:
-          writeException(dos, HandShake.REPLY_INVALID,
+          writeException(dos, Handshake.REPLY_INVALID,
-
-      proxy = registerClient(socket, proxyID, proxy, isPrimary, clientConflation, clientVersion,
-          acceptorId, notifyBySubscription);
-
+      Object subject = null;
-          HandShake.readCredentials(dis, dos, system, this.cache.getSecurityService());
-      if (credentials != null && proxy != null) {
+          Handshake.readCredentials(dis, dos, system, this.cache.getSecurityService());
+      if (credentials != null) {
-        Object subject =
-            HandShake.verifyCredentials(authenticator, credentials, system.getSecurityProperties(),
+        subject =
+            Handshake.verifyCredentials(authenticator, credentials, system.getSecurityProperties(),
+      }
+
+      Subject shiroSubject =
+          subject != null && subject instanceof Subject ? (Subject) subject : null;
+      proxy = registerClient(socket, proxyID, proxy, isPrimary, clientConflation, clientVersion,
+          acceptorId, notifyBySubscription, shiroSubject);
+
+      if (proxy != null && subject != null) {
-        } else if (subject instanceof Subject) {
-          proxy.setSubject((Subject) subject);
-      writeException(dos, HandShake.REPLY_EXCEPTION_AUTHENTICATION_REQUIRED, ex, clientVersion);
+      writeException(dos, Handshake.REPLY_EXCEPTION_AUTHENTICATION_REQUIRED, ex, clientVersion);
-      writeException(dos, HandShake.REPLY_EXCEPTION_AUTHENTICATION_FAILED, ex, clientVersion);
+      writeException(dos, Handshake.REPLY_EXCEPTION_AUTHENTICATION_FAILED, ex, clientVersion);
-      long acceptorId, boolean notifyBySubscription) throws IOException, CacheException {
+      long acceptorId, boolean notifyBySubscription, Subject subject)
+      throws IOException, CacheException {
-    byte epType = 0x00;
-    int qSize = 0;
+    byte endpointType = 0x00;
+    int queueSize = 0;
-          qSize = PoolImpl.PRIMARY_QUEUE_TIMED_OUT;
+          queueSize = PoolImpl.PRIMARY_QUEUE_TIMED_OUT;
-          qSize = PoolImpl.PRIMARY_QUEUE_NOT_AVAILABLE;
+          queueSize = PoolImpl.PRIMARY_QUEUE_NOT_AVAILABLE;
-        l_proxy = new CacheClientProxy(this, socket, proxyId, isPrimary, clientConflation,
-            clientVersion, acceptorId, notifyBySubscription, this.cache.getSecurityService());
+        l_proxy =
+            new CacheClientProxy(this, socket, proxyId, isPrimary, clientConflation, clientVersion,
+                acceptorId, notifyBySubscription, this.cache.getSecurityService(), subject);
+        l_proxy.setSubject(subject);
-          epType = (byte) 2;
+          endpointType = (byte) 2;
-          epType = (byte) 1;
+          endpointType = (byte) 1;
-        qSize = proxy.getQueueSize();
+        queueSize = proxy.getQueueSize();
-            responseByte = HandShake.REPLY_REFUSED;
+            responseByte = Handshake.REPLY_REFUSED;
-          responseByte = HandShake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT;
+          responseByte = Handshake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT;
-        l_proxy = new CacheClientProxy(this, socket, proxyId, isPrimary, clientConflation,
-            clientVersion, acceptorId, notifyBySubscription, this.cache.getSecurityService());
+        l_proxy =
+            new CacheClientProxy(this, socket, proxyId, isPrimary, clientConflation, clientVersion,
+                acceptorId, notifyBySubscription, this.cache.getSecurityService(), subject);
-      responseByte = HandShake.REPLY_REFUSED;
+      responseByte = Handshake.REPLY_REFUSED;
-      writeMessage(dos, responseByte, unsuccessfulMsg, clientVersion, epType, qSize);
+      writeHandshakeMessage(dos, responseByte, unsuccessfulMsg, clientVersion, endpointType,
+          queueSize);
-      final DM dm = ids.getDistributionManager();
+      final DistributionManager dm = ids.getDistributionManager();
-    if (!(proxy.clientConflation == HandShake.CONFLATION_ON)) {
+    if (!(proxy.clientConflation == Handshake.CONFLATION_ON)) {
-    if (!(proxy.clientConflation == HandShake.CONFLATION_ON)) {
+    if (!(proxy.clientConflation == Handshake.CONFLATION_ON)) {
-    DM dm = ((InternalDistributedSystem) this.getCache().getDistributedSystem())
+    DistributionManager dm = ((InternalDistributedSystem) this.getCache().getDistributedSystem())
-  private static final long CLIENT_PING_TASK_PERIOD =
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "serverToClientPingPeriod", 60000);
+  private static final int CLIENT_PING_TASK_PERIOD =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "serverToClientPingPeriod", 60000);
+  /** returns the interval between "ping" messages sent to clients on idle connections */
+  public static int getClientPingInterval() {
+    return CLIENT_PING_TASK_PERIOD;
+  }
+

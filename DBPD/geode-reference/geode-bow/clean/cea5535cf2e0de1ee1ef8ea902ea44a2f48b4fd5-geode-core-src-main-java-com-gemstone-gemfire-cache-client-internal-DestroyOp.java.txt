GEODE-1761 Clients don't fail back when servers are bounced

Servers will send a refresh hint to clients if they detect that a request
had to be send to a different server who owned the primary bucket
affected by the operation.  Clients should always refresh when this
happens unless they have connection-pool size constraints that force
them to use non-optimal servers.

Client-side operation classes have been modified to initiate the refresh.
I've added code in the meta-data service class to avoid performing
multiple concurrent refreshes on the same region.

On the server-side I've cleaned up some of the network-hop detection
code to stop using hard-coded integers and to consolidate some of
the code that resets the ThreadLocals being used to record network-
hops detected.

-    AbstractOp op = new DestroyOpImpl(region, key, expectedOldValue,
+    DestroyOpImpl op = new DestroyOpImpl(region, key, expectedOldValue,
+          op.setAllowDuplicateMetadataRefresh(! onlyUseExistingCnx);
-    private Object callbackArg;
-    
+    private Object callbackArg;
+
+      this.callbackArg = callbackArg;
-        byte version = 0 ;
-            ClientMetadataService cms = null;
-              cms = region.getCache().getClientMetadataService();
-              version = cms.getMetaDataVersion(region, Operation.UPDATE,
-                  key, null, callbackArg);
+              ClientMetadataService cms = region.getCache().getClientMetadataService();
+              int myVersion = cms.getMetaDataVersion(region, Operation.UPDATE,
+                key, null, callbackArg);
+              if (myVersion != bytesReceived[0] || isAllowDuplicateMetadataRefresh()) {
+                cms.scheduleGetPRMetaData(region, false, bytesReceived[1]);
+              }
-            if (bytesReceived[0] != version) {
-              cms.scheduleGetPRMetaData(region, false,bytesReceived[1]);
-            }

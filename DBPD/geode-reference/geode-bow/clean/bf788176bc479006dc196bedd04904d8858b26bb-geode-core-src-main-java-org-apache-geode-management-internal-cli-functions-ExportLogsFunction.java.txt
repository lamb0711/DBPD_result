GEODE-2267:  add validation to the arguments and include export stats in the command

  * use the config to determine where the logs and stats are

-import static java.util.stream.Collectors.toSet;
-
+import org.apache.commons.lang.StringUtils;
+import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.logging.InternalLogWriter;
-import org.apache.geode.internal.logging.LogWriterImpl;
-import org.apache.geode.management.internal.cli.commands.MiscellaneousCommands;
+import org.apache.geode.management.internal.cli.commands.ExportLogCommand;
+import org.apache.logging.log4j.Level;
+import java.io.File;
-import java.nio.file.Paths;
-import java.util.Set;
-import java.util.stream.Stream;
+/**
+ * this function extracts the logs using a LogExporter which creates a zip file, and then writes the
+ * zip file bytes into a replicated region, this in effect, "stream" the zip file bytes to the
+ * locator
+ *
+ * The function only extracts .log and .gfs files under server's working directory
+ */
-      // TODO: change this to get cache from FunctionContext when it becomes available
+      DistributionConfig config = cache.getDistributedSystem().getConfig();
-      Region exportLogsRegion = createOrGetExistingExportLogsRegion(false);
+      Region exportLogsRegion = createOrGetExistingExportLogsRegion(false, cache);
-      LogFilter logFilter =
-          new LogFilter(args.getPermittedLogLevels(), args.getStartTime(), args.getEndTime());
-      Path workingDir = Paths.get(System.getProperty("user.dir"));
+      File baseLogFile = null;
+      File baseStatsFile = null;
+      if (args.isIncludeLogs() && !config.getLogFile().toString().isEmpty()) {
+        baseLogFile = config.getLogFile().getAbsoluteFile();
+      }
+      if (args.isIncludeStats() && !config.getStatisticArchiveFile().toString().isEmpty()) {
+        baseStatsFile = config.getStatisticArchiveFile().getAbsoluteFile();
+      }
-      Path exportedZipFile = new LogExporter(logFilter).export(workingDir);
+      LogFilter logFilter = new LogFilter(args.getLogLevel(), args.isThisLogLevelOnly(),
+          args.getStartTime(), args.getEndTime());
+
+      Path exportedZipFile = new LogExporter(logFilter, baseLogFile, baseStatsFile).export();
+
+      // nothing to return back
+      if (exportedZipFile == null) {
+        context.getResultSender().lastResult(null);
+        return;
+      }
+      e.printStackTrace();
-  public static Region createOrGetExistingExportLogsRegion(boolean isInitiatingMember)
-      throws IOException, ClassNotFoundException {
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+  public static Region createOrGetExistingExportLogsRegion(boolean isInitiatingMember,
+      GemFireCacheImpl cache) throws IOException, ClassNotFoundException {
-  public static void destroyExportLogsRegion() {
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+  public static void destroyExportLogsRegion(GemFireCacheImpl cache) {
-
-
-    private String startTime;
-    private String endTime;
-    private String logLevel;
-    private boolean logLevelOnly;
+    private LocalDateTime startTime;
+    private LocalDateTime endTime;
+    private Level logLevel;
+    private boolean thisLogLevelOnly;
+    private boolean includeLogs;
+    private boolean includeStats;
-    public Args(String startTime, String endTime, String logLevel, boolean logLevelOnly) {
-      this.startTime = startTime;
-      this.endTime = endTime;
-      this.logLevel = logLevel;
-      this.logLevelOnly = logLevelOnly;
+    public Args(String startTime, String endTime, String logLevel, boolean logLevelOnly,
+        boolean logsOnly, boolean statsOnly) {
+      this.startTime = parseTime(startTime);
+      this.endTime = parseTime(endTime);
+
+      if (StringUtils.isBlank(logLevel)) {
+        this.logLevel = Level.INFO;
+      } else {
+        this.logLevel = Level.getLevel(logLevel.toUpperCase());
+      }
+      this.thisLogLevelOnly = logLevelOnly;
+
+      this.includeLogs = !statsOnly;
+      this.includeStats = !logsOnly;
-      return parseTime(startTime);
+      return startTime;
-      return parseTime(endTime);
+      return endTime;
-    public Set<String> getPermittedLogLevels() {
-      if (logLevel == null || StringUtils.isBlank(logLevel)) {
-        return LogFilter.allLogLevels();
-      }
-
-      if (logLevelOnly) {
-        return Stream.of(logLevel).collect(toSet());
-      }
-
-      // Return all log levels lower than or equal to the specified logLevel
-      return Arrays.stream(InternalLogWriter.levelNames).filter((String level) -> {
-        int logLevelCode = LogWriterImpl.levelNameToCode(level);
-        int logLevelCodeThreshold = LogWriterImpl.levelNameToCode(logLevel);
-
-        return logLevelCode >= logLevelCodeThreshold;
-      }).collect(toSet());
+    public Level getLogLevel() {
+      return logLevel;
-    private static LocalDateTime parseTime(String dateString) {
-      if (dateString == null) {
-        return null;
-      }
+    public boolean isThisLogLevelOnly() {
+      return thisLogLevelOnly;
+    }
+    public boolean isIncludeLogs() {
+      return includeLogs;
+    }
+
+    public boolean isIncludeStats() {
+      return includeStats;
+    }
+  }
+
+  public static LocalDateTime parseTime(String dateString) {
+    if (dateString == null) {
+      return null;
+    }
+
+    try {
+      SimpleDateFormat df = new SimpleDateFormat(ExportLogCommand.FORMAT);
+      return df.parse(dateString).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
+    } catch (ParseException e) {
-        SimpleDateFormat df = new SimpleDateFormat(MiscellaneousCommands.FORMAT);
+        SimpleDateFormat df = new SimpleDateFormat(ExportLogCommand.ONLY_DATE_FORMAT);
-      } catch (ParseException e) {
-        try {
-          SimpleDateFormat df = new SimpleDateFormat(MiscellaneousCommands.ONLY_DATE_FORMAT);
-          return df.parse(dateString).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
-        } catch (ParseException e1) {
-          return null;
-        }
+      } catch (ParseException e1) {
+        return null;

Merge branch 'release/1.5.0'

-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Collections;
-import org.apache.geode.cache.TransactionDataNotColocatedException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
+import org.apache.geode.internal.cache.CachedDeserializableFactory;
+import org.apache.geode.internal.cache.DataLocationException;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.KeyInfo;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+import org.apache.geode.internal.cache.TXManagerImpl;
+import org.apache.geode.internal.cache.TXStateProxy;
- * This message is used as the request for a
- * {@link org.apache.geode.cache.Region#get(Object)}operation. The reply is sent in a
- * {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}.
- *
- * Replicate regions can use this message to send a Get request to another peer.
+ * This message is used as the request for a get operation done in a transaction that is hosted on a
+ * remote member. This messsage sends the get to the remote member.
-  public int getProcessorType() {
-    return DistributionManager.SERIAL_EXECUTOR;
-  }
-
-  @Override
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
-  }
-
-  @Override
-  protected boolean operateOnRegion(final DistributionManager dm, LocalRegion r, long startTime)
-      throws RemoteOperationException {
+  protected boolean operateOnRegion(final ClusterDistributionManager dm, LocalRegion r,
+      long startTime) throws RemoteOperationException {
-    if (!(r instanceof PartitionedRegion)) { // prs already wait on initialization
-      r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-    }
+    r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-      // r.getPrStats().endPartitionMessagesProcessing(startTime);
-      // Unless there was an exception thrown, this message handles sending the
-      // response
+      // Unless an exception was thrown, this message handles sending the response
-    } catch (PrimaryBucketException pbe) {
-      sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-      return false;
-    Assert.assertTrue(recipient != null, "PRDistribuedGetReplyMessage NULL reply message");
-    RemoteGetResponse p =
-        new RemoteGetResponse(r.getSystem(), Collections.singleton(recipient), key);
+    Assert.assertTrue(recipient != null, "RemoteGetMessage NULL recipient");
+    RemoteGetResponse p = new RemoteGetResponse(r.getSystem(), recipient);
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-    public void process(final DM dm, ReplyProcessor21 processor) {
+    public void process(final DistributionManager dm, ReplyProcessor21 processor) {
-   * {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}
+   * {@link org.apache.geode.internal.cache.tx.RemoteGetMessage.GetReplyMessage}
-    final Object key;
-    public RemoteGetResponse(InternalDistributedSystem ds, Set recipients, Object key) {
-      super(ds, recipients, false);
-      this.key = key;
+    public RemoteGetResponse(InternalDistributedSystem ds, InternalDistributedMember recipient) {
+      super(ds, recipient, false);
-            return CachedDeserializableFactory.create(reply.valueInBytes);
+            return CachedDeserializableFactory.create(reply.valueInBytes,
+                getDistributionManager().getCache());
-      try {
-        // waitForRepliesUninterruptibly();
-        waitForCacheException();
-        if (DistributionStats.enableClockStats) {
-          getDistributionManager().getStats().incReplyHandOffTime(this.start);
-        }
-      } catch (RemoteOperationException e) {
-        e.checkKey(key);
-        final String msg = "RemoteGetResponse got RemoteOperationException; rethrowing";
-        logger.debug(msg, e);
-        throw e;
-      } catch (TransactionDataNotColocatedException e) {
-        // Throw this up to user!
-        throw e;
+      waitForRemoteResponse();
+      if (DistributionStats.enableClockStats) {
+        getDistributionManager().getStats().incReplyHandOffTime(this.start);

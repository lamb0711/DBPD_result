GEODE-3940: fix deadlock in backup messages

When backup sends FlushToDisk, PrepareBackup, and FinishBackup,
it will no longer wait for all other members to respond before
doing the same work on its own member.
In addition to preventing a distributed deadlock, this will
also improve how long it takes for a backup to complete.
As part of this work the backup classes and tests have been
moved into their own backup package.

+import java.util.ArrayList;
+import java.util.Iterator;
+import org.apache.geode.cache.execute.ResultSender;
+import org.apache.geode.internal.cache.xmlcache.CacheXml;
+import org.apache.geode.management.internal.configuration.domain.XmlEntity;
-
+  public String getId() {
+    return CreateDefinedIndexesFunction.class.getName();
+  }
+
+  XmlEntity createXmlEntity(final String regionName) {
+    return new XmlEntity(CacheXml.REGION, "name", regionName);
+  }
+
+  @Override
-    String memberId = null;
-    List<Index> indexes = null;
+    String memberId = null;
+    boolean lastResultSent = Boolean.FALSE;
+
-      memberId = cache.getDistributedSystem().getDistributedMember().getId();
+      ResultSender sender = context.getResultSender();
+      memberId = cache.getDistributedSystem().getDistributedMember().getId();
+
-        String indexedExpression = indexDefinition.getIndexedExpression();
+        String indexedExpression = indexDefinition.getIndexedExpression();
+
-      indexes = queryService.createDefinedIndexes();
-      context.getResultSender().lastResult(new CliFunctionResult(memberId));
-    } catch (MultiIndexCreationException e) {
+
+      List<Index> indexes = queryService.createDefinedIndexes();
+      // Build the results with one XmlEntity per region.
+      List<String> processedRegions = new ArrayList<>();
+      List<CliFunctionResult> functionResults = new ArrayList<>();
+
+      for (Index index : indexes) {
+        String regionName = index.getRegion().getName();
+
+        if (!processedRegions.contains(regionName)) {
+          XmlEntity xmlEntity = createXmlEntity(regionName);
+          functionResults.add(new CliFunctionResult(memberId, xmlEntity));
+          processedRegions.add(regionName);
+        }
+      }
+
+      for (Iterator<CliFunctionResult> iterator = functionResults.iterator(); iterator.hasNext();) {
+        CliFunctionResult cliFunctionResult = iterator.next();
+
+        if (iterator.hasNext()) {
+          sender.sendResult(cliFunctionResult);
+        } else {
+          sender.lastResult(cliFunctionResult);
+          lastResultSent = Boolean.TRUE;
+        }
+      }
+
+      if (!lastResultSent) {
+        // No indexes were created and no exceptions were thrown during the process.
+        // We still need to make sure the function returns to the caller.
+        sender.lastResult(
+            new CliFunctionResult(memberId, true, CliStrings.DEFINE_INDEX__FAILURE__MSG));
+      }
+    } catch (MultiIndexCreationException multiIndexCreationException) {
-      for (Map.Entry<String, Exception> failedIndex : e.getExceptionsMap().entrySet()) {
+      for (Map.Entry<String, Exception> failedIndex : multiIndexCreationException.getExceptionsMap()
+          .entrySet()) {
-      context.getResultSender().lastResult(new CliFunctionResult(memberId, e, sb.toString()));
-    } catch (Exception e) {
+      context.getResultSender()
+          .lastResult(new CliFunctionResult(memberId, multiIndexCreationException, sb.toString()));
+    } catch (Exception exception) {
-          e.getClass().getName(), e.getMessage());
-      context.getResultSender().lastResult(new CliFunctionResult(memberId, e, exceptionMessage));
+          exception.getClass().getName(), exception.getMessage());
+      context.getResultSender()
+          .lastResult(new CliFunctionResult(memberId, exception, exceptionMessage));
-
-  @Override
-  public String getId() {
-    return CreateDefinedIndexesFunction.class.getName();
-  }
-

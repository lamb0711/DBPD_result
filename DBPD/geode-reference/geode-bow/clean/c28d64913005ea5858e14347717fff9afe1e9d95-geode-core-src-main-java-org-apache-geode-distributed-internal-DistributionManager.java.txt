Merge branch 'release/1.4.0'

+import java.io.NotSerializableException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.cache.CacheClosedException;
-import org.apache.logging.log4j.Logger;
-
-import java.io.NotSerializableException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
- * {@link DistributionMessage messages} queued in {@link MQueue}s.
+ * {@link DistributionMessage messages}. It also reports on who is currently in the distributed
+ * system and tracks the elder member for the distributed lock service. You may also register a
+ * membership listener with the DistributionManager to receive notification of changes in
+ * membership.
- * Prior to GemFire 4.0, <code>DistributionManager</code> was an abstract class with two concrete
- * subclasses, <code>LocalDistributionManager</code> and <code>ConsoleDistributionManager</code>. We
- * decided that <code>ConsoleDistributionManager</code> (which was used for the GUI console and
- * admin APIs) did not offer enough interesting functionality to warrant a separate class. More
- * importantly, it prevented the Cache and admin APIs from being used in the same VM. So, we
- * refactored the code of those two subclasses into <code>DistributionManager</code>.
- *
- * @since GemFire 2.0
- *
-  private static final boolean SYNC_EVENTS = Boolean.getBoolean("DistributionManager.syncEvents");
+  private static final int STARTUP_TIMEOUT =
+      Integer.getInteger("DistributionManager.STARTUP_TIMEOUT", 15000).intValue();
+
+  public static final boolean DEBUG_NO_ACKNOWLEDGEMENTS =
+      Boolean.getBoolean("DistributionManager.DEBUG_NO_ACKNOWLEDGEMENTS");
-   * WARNING: setting this to true may break dunit tests.
-   * <p>
-   * see org.apache.geode.cache30.ClearMultiVmCallBkDUnitTest
+   * maximum time, in milliseconds, to wait for all threads to exit
-  public static final boolean INLINE_PROCESS =
-      !Boolean.getBoolean("DistributionManager.enqueueOrderedMessages");
+  private static final int MAX_STOP_TIME = 20000;
+
+  /**
+   * Time to sleep, in milliseconds, while polling to see if threads have finished
+   */
+  private static final int STOP_PAUSE_TIME = 1000;
+
+  /**
+   * Maximum number of interrupt attempts to stop a thread
+   */
+  private static final int MAX_STOP_ATTEMPTS = 10;
+
+
+
+  private static final boolean SYNC_EVENTS = Boolean.getBoolean("DistributionManager.syncEvents");
-  public static final boolean MULTI_SERIAL_EXECUTORS =
+  private static final boolean MULTI_SERIAL_EXECUTORS =
-  /** The name of the distribution manager (identifies it in GemFire) */
-  public static final String NAME = "GemFire";
-
-  /**
-   * The number of milliseconds to wait for distribution-related things to happen
-   */
-  public static final long TIMEOUT = Long.getLong("DistributionManager.TIMEOUT", -1).longValue();
-
-  public static final int PUSHER_THREADS =
-      Integer.getInteger("DistributionManager.PUSHER_THREADS", 50).intValue();
-
-  public static final int PUSHER_QUEUE_SIZE =
-      Integer.getInteger("DistributionManager.PUSHER_QUEUE_SIZE", 4096).intValue();
-
-
-  public static final int MAX_WAITING_THREADS =
+  private static final int MAX_WAITING_THREADS =
-  public static final int MAX_PR_META_DATA_CLEANUP_THREADS =
+  private static final int MAX_PR_META_DATA_CLEANUP_THREADS =
-  public static final int MAX_PR_THREADS = Integer.getInteger("DistributionManager.MAX_PR_THREADS",
-      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
-  public static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",
-      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
-  // Integer.getInteger("DistributionManager.MAX_THREADS",
-  // max(Runtime.getRuntime().availableProcessors()*2, 2)).intValue();
-  public static final int INCOMING_QUEUE_LIMIT =
+  private static final int MAX_PR_THREADS = Integer.getInteger("DistributionManager.MAX_PR_THREADS",
+      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
+
+  private static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",
+      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
+
+
+
+  private static final int INCOMING_QUEUE_LIMIT =
-  public static final int INCOMING_QUEUE_THROTTLE =
-      Integer.getInteger("DistributionManager.INCOMING_QUEUE_THROTTLE",
-          (int) (INCOMING_QUEUE_LIMIT * 0.75)).intValue();
-  public static final double THROTTLE_PERCENT = (double) (Integer
+  private static final double THROTTLE_PERCENT = (double) (Integer
-  public static final int SERIAL_QUEUE_BYTE_LIMIT = Integer
+
+  static final int SERIAL_QUEUE_BYTE_LIMIT = Integer
-  public static final int SERIAL_QUEUE_THROTTLE =
+
+  static final int SERIAL_QUEUE_THROTTLE =
-  public static final int TOTAL_SERIAL_QUEUE_BYTE_LIMIT =
+
+  static final int TOTAL_SERIAL_QUEUE_BYTE_LIMIT =
-  public static final int TOTAL_SERIAL_QUEUE_THROTTLE =
+
+  static final int TOTAL_SERIAL_QUEUE_THROTTLE =
-  public static final int SERIAL_QUEUE_SIZE_LIMIT =
+  static final int SERIAL_QUEUE_SIZE_LIMIT =
-  public static final int SERIAL_QUEUE_SIZE_THROTTLE =
+
+  static final int SERIAL_QUEUE_SIZE_THROTTLE =
-  public static final int MAX_SERIAL_QUEUE_THREAD =
+  static final int MAX_SERIAL_QUEUE_THREAD =
-  /**
-   * Whether or not to include link local addresses in the list of addresses we use to determine if
-   * two members are no the same host.
-   * 
-   * Added for normura issue 7033 - they have duplicate link local addresses on different boxes
-   */
-  public static volatile boolean INCLUDE_LINK_LOCAL_ADDRESSES =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "IncludeLinkLocalAddresses");
+
-  /**
-   * The DM type for locator distribution managers
-   * 
-   * @since GemFire 7.0
-   */
+  /** The DM type for locator distribution managers */
+  /** The DM type for stand-alone members */
+
+
-   * an NIO priority type
-   * 
-   * @see #SERIAL_EXECUTOR
-   * @see #HIGH_PRIORITY_EXECUTOR
-   * @see #WAITING_POOL_EXECUTOR
-   * an NIO priority type
-   * 
-   * @see #STANDARD_EXECUTOR
-   * an NIO priority type
-   * 
-   * @see #STANDARD_EXECUTOR
-   * an NIO priority type
-   * 
-   * @see #STANDARD_EXECUTOR
-   * an NIO priority type
-   * 
-   * @see #STANDARD_EXECUTOR
-   * 
+   *
-   * @see #STANDARD_EXECUTOR
-  /** The number of open distribution managers in this VM */
-  private static int openDMs = 0;
-  // /** The stack trace of the last time a console DM was opened */
-  // private static Exception openStackTrace;
+
+  /** Is this node running an AdminDistributedSystem? */
+  private static volatile boolean isDedicatedAdminVM = false;
+
+  private static ThreadLocal<Boolean> isStartupThread = new ThreadLocal();
-   * Is this VM dedicated to administration (like a GUI console or a JMX agent)? If so, then it
-   * creates {@link #ADMIN_ONLY_DM_TYPE} type distribution managers.
-   *
-   * @since GemFire 4.0
+   * Identifier for function execution threads and any of their children
-  public static volatile boolean isDedicatedAdminVM = false;
-
-  /**
-   * Is this admin agent used for a command line console. This flag controls whether connect will
-   * throw an exception or just wait for a DS if one is not available. If true, we will throw an
-   * exception.
-   * 
-   */
-  public static volatile boolean isCommandLineAdminVM = false;
+  private static final InheritableThreadLocal<Boolean> isFunctionExecutionThread =
+      new InheritableThreadLocal<Boolean>() {
+        @Override
+        protected Boolean initialValue() {
+          return Boolean.FALSE;
+        }
+      };
+  /**
+   * Mutex to control access to {@link #waitingForElderChange} or {@link #elder}.
+   */
+  private final Object elderMonitor = new Object();
+
+  /**
+   * Must be read/written while holding {@link #elderMonitor}
+   *
+   * @see #elderChangeWait()
+   */
+  private boolean waitingForElderChange = false;
+
+  /**
+   * @see DM#isAdam()
+   */
+  private boolean adam = false;
+
+  /**
+   * This is the "elder" member of the distributed system, responsible for certain types of
+   * arbitration.
+   *
+   * Must hold {@link #elderMonitor} in order to change this.
+   *
+   * @see #getElderId()
+   */
+  protected volatile InternalDistributedMember elder = null;
+
-  final protected InternalDistributedMember myid;
+  protected final InternalDistributedMember localAddress;
-   * </p>
-   * TODO: change this to use an enum
-  private final ConcurrentMap membershipListeners;
+  private final ConcurrentMap<MembershipListener, Boolean> membershipListeners;
-  /** A lock to hold while adding and removing membership listeners */
-  protected final Object membershipListenersLock = new MembershipListenersLock();
-   * 
+   *
-  protected volatile Set allMembershipListeners = Collections.EMPTY_SET;
+  protected volatile Set<MembershipListener> allMembershipListeners = Collections.emptySet();
+
-   * 
+   *
-  protected final Object allMembershipListenersLock = new MembershipListenersLock();
+  private final Object allMembershipListenersLock = new MembershipListenersLock();
+
-  protected final BlockingQueue membershipEventQueue = new LinkedBlockingQueue();
+  private final BlockingQueue<MemberEvent> membershipEventQueue = new LinkedBlockingQueue();
+
-  protected /* final */ DistributionStats stats;
+  protected DistributionStats stats;
-  protected boolean exceptionInThreads;
+  private boolean exceptionInThreads;
-  static ThreadLocal isStartupThread = new ThreadLocal();
-
-  protected volatile boolean shutdownMsgSent = false;
+  private volatile boolean shutdownMsgSent = false;
-  protected volatile boolean closeInProgress = false;
+  private volatile boolean closeInProgress = false;
-  protected MembershipManager membershipManager;
-
-  /** The channel through which distributed communication occurs. */
-  protected DistributionChannel channel;
+  private MembershipManager membershipManager;
-  private Set membersAndAdmin = Collections.emptySet();
+  private Set<InternalDistributedMember> membersAndAdmin = Collections.emptySet();
-   * Since 6.6.2 and hereafter we will save the versions here. But pre-6.6.2's
-   * StartupResponseMessage does not contain version. We will assign a default version for them.
-   */
-  public static final String DEFAULT_VERSION_PRE_6_6_2 = "6.6.0.0";
-  /**
-  /** The pusher thread */
-  // private Thread pusher;
-
-   * 
+   *
+
+  /** Function Execution executors */
-   * 
+   *
-  protected volatile boolean readyForMessages = false;
+  private volatile boolean readyForMessages = false;
-  protected volatile boolean closed = false;
+  private volatile boolean closed = false;
+  /**
+   * TODO why does the distribution manager arbitrate GII operations? That should be a Cache
+   * function
+   */
-  private final HashMap<InetAddress, Set<InetAddress>> equivalentHosts =
-      new HashMap<InetAddress, Set<InetAddress>>();
+  private final HashMap<InetAddress, Set<InetAddress>> equivalentHosts = new HashMap<>();
-  private volatile boolean isSharedConfigEnabledForDS = false;
-
-  @Override
-  public boolean isSharedConfigurationServiceEnabledForDS() {
-    return isSharedConfigEnabledForDS;
-  }
+  /**
+   * root cause of forcibly shutting down the distribution manager
+   */
+  volatile Throwable rootCause = null;
-   * Identifier for function execution threads and any of their children
+   * @see #closeInProgress
-  public static final InheritableThreadLocal<Boolean> isFunctionExecutionThread =
-      new InheritableThreadLocal<Boolean>() {
-        @Override
-        protected Boolean initialValue() {
-          return Boolean.FALSE;
-        }
-      };
+  private final Object shutdownMutex = new Object();
+
+
+
-   * Given two DistributionManager ids, check to see if they are from the same host address.
-   * 
-   * @param id1 a DistributionManager id
-   * @param id2 a DistributionManager id
-   * @return true if id1 and id2 are from the same host, false otherwise
+   * Is the current thread used for executing Functions?
-  public static boolean isSameHost(InternalDistributedMember id1, InternalDistributedMember id2) {
-    return (id1.getInetAddress().equals(id2.getInetAddress()));
+  public static Boolean isFunctionExecutionThread() {
+    return isFunctionExecutionThread.get();
-   * 
+   *
-  public static DistributionManager create(InternalDistributedSystem system) {
+  static DistributionManager create(InternalDistributedSystem system) {
-      } else if (isDedicatedAdminVM) {
+      } else if (isDedicatedAdminVM()) {
-        if (!distributionManager.sendStartupMessage(op, true)) {
+        if (!distributionManager.sendStartupMessage(op)) {
-  void runUntilShutdown(Runnable r) {
-    try {
-      r.run();
-    } catch (CancelException e) {
-      if (logger.isTraceEnabled()) {
-        logger.trace("Caught shutdown exception", e);
-      }
-    } catch (VirtualMachineError err) {
-      SystemFailure.initiateFailure(err);
-      // If this ever returns, rethrow the error. We're poisoned
-      // now, so don't let this thread continue.
-      throw err;
-    } catch (Throwable t) {
-      // Whenever you catch Error or Throwable, you must also
-      // catch VirtualMachineError (see above). However, there is
-      // _still_ a possibility that you are dealing with a cascading
-      // error condition, so you also need to check to see if the JVM
-      // is still usable:
-      SystemFailure.checkFailure();
-      if (isCloseInProgress()) {
-        logger.debug("Caught unusual exception during shutdown: {}", t.getMessage(), t);
-      } else {
-        logger.warn(LocalizedMessage
-            .create(LocalizedStrings.DistributionManager_TASK_FAILED_WITH_EXCEPTION), t);
-      }
-    }
-  }
-
-  volatile Throwable rootCause = null;
-
-  private static class Stopper extends CancelCriterion {
-    private DistributionManager dm;
-
-    // validateDM is commented out because expiry threads hit it with
-    // an ugly failure... use only for debugging lingering DM bugs
-    // private String validateDM() {
-    // GemFireCache cache = GemFireCache.getInstance();
-    // if (cache == null) {
-    // return null; // Distributed system with no cache
-    // }
-    // Object obj = cache.getDistributedSystem();
-    // if (obj == null) {
-    // return null; // Cache is very dead
-    // }
-    // InternalDistributedSystem ids = (InternalDistributedSystem)obj;
-    // DM current = ids.getDistributionManager();
-    // if (current != dm) {
-    // String response =
-    // LocalizedStrings.DistributionManager_CURRENT_CACHE_DISTRIBUTIONMANAGER_0_IS_NOT_THE_SAME_AS_1
-    // .toLocalizedString(new Object[] { current, dm});
-    // return response;
-    // }
-    // return null;
-    // }
-
-    Stopper(DistributionManager dm) {
-      this.dm = dm;
-    }
-
-    @Override
-    public String cancelInProgress() {
-      checkFailure();
-
-      // remove call to validateDM() to fix bug 38356
-
-      if (dm.shutdownMsgSent) {
-        return LocalizedStrings.DistributionManager__0_MESSAGE_DISTRIBUTION_HAS_TERMINATED
-            .toLocalizedString(dm.toString());
-      }
-      if (dm.rootCause != null) {
-        return dm.toString() + ": " + dm.rootCause.getMessage();
-      }
-
-      // Nope.
-      return null;
-    }
-
-    @Override
-    public RuntimeException generateCancelledException(Throwable e) {
-      String reason = cancelInProgress();
-      if (reason == null) {
-        return null;
-      }
-      Throwable rc = dm.rootCause; // volatile read
-      if (rc == null) {
-        // No root cause, specify the one given and be done with it.
-        return new DistributedSystemDisconnectedException(reason, e);
-      }
-
-      if (e == null) {
-        // Caller did not specify any root cause, so just use our own.
-        return new DistributedSystemDisconnectedException(reason, rc);
-      }
-
-      // Attempt to stick rootCause at tail end of the exception chain.
-      Throwable nt = e;
-      while (nt.getCause() != null) {
-        nt = nt.getCause();
-      }
-      if (nt == rc) {
-        // Root cause already in place; we're done
-        return new DistributedSystemDisconnectedException(reason, e);
-      }
-
-      try {
-        nt.initCause(rc);
-        return new DistributedSystemDisconnectedException(reason, e);
-      } catch (IllegalStateException e2) {
-        // Bug 39496 (Jrockit related) Give up. The following
-        // error is not entirely sane but gives the correct general picture.
-        return new DistributedSystemDisconnectedException(reason, rc);
-      }
-    }
-  }
-
-  private final Stopper stopper = new Stopper(this);
-
-  public CancelCriterion getCancelCriterion() {
-    return stopper;
-  }
-
-       * = getChannelId(); }
+       * = getMembershipPort(); }
+      // connect to the cluster
-      // Create direct channel first
-      // DirectChannel dc = new DirectChannel(new MyListener(this), system.getConfig(), logger,
-      // null);
-      // setDirectChannelPort(dc.getPort()); // store in a thread local
-
-      // connect to JGroups
-      start = System.currentTimeMillis();
-
-      MyListener l = new MyListener(this);
+      DMListener l = new DMListener(this);
-      this.myid = membershipManager.getLocalMember();
-
-      // dc.patchUpAddress(this.myid);
-      // id.setDirectChannelPort(dc.getPort());
-
-      // create the distribution channel
-      this.channel = new DistributionChannel(membershipManager);
+      this.localAddress = membershipManager.getLocalMember();
-      // Assert.assertTrue(this.getChannelMap().size() >= 1);
-      // System.out.println("Channel Map:");
-      // for (Iterator iter = this.getChannelMap().entrySet().iterator();
-      // iter.hasNext(); ) {
-      // Map.Entry entry = (Map.Entry) iter.next();
-      // Object key = entry.getKey();
-      // System.out.println(" " + key + " a " +
-      // key.getClass().getName() + " -> " +
-      // entry.getValue());
-      // }
-
-          LocalizedStrings.DistributionManager_STARTING_DISTRIBUTIONMANAGER_0_1,
-          new Object[] {this.myid, (logger.isInfoEnabled(LogMarker.DM) ? sb.toString() : "")}));
+          LocalizedStrings.DistributionManager_STARTING_DISTRIBUTIONMANAGER_0_1, new Object[] {
+              this.localAddress, (logger.isInfoEnabled(LogMarker.DM) ? sb.toString() : "")}));
-      this.description = NAME + " on " + this.myid + " started at "
+      this.description = "Distribution manager on " + this.localAddress + " started at "
-      isStartupThread.set(Boolean.TRUE);
+      setIsStartupThread(Boolean.TRUE);
-      // Since we need a StartupResponseMessage to make sure licenses
-      // are compatible the following has been deadcoded.
-      // // For the time being, invoke processStartupResponse()
-      // String rejectionMessage = null;
-      // if (GemFireVersion.getGemFireVersion().
-      // equals(state.getGemFireVersion())) {
-      // rejectionMessage = "Rejected new system node " +
-      // this.getDistributionManagerId() + " with version \"" +
-      // GemFireVersion.getGemFireVersion() +
-      // "\" because the distributed system's version is \"" +
-      // state.getGemFireVersion() + "\".";
-      // }
-      // this.processStartupResponse(state.getCacheTime(),
-      // rejectionMessage);
-
-      synchronized (DistributionManager.class) {
-        openDMs++;
-      }
+  /**
+   * Is this VM dedicated to administration (like a GUI console or a JMX agent)? If so, then it
+   * creates {@link #ADMIN_ONLY_DM_TYPE} type distribution managers.
+   *
+   * @since GemFire 4.0
+   */
+  public static boolean isDedicatedAdminVM() {
+    return isDedicatedAdminVM;
+  }
+
+  public static void setIsDedicatedAdminVM(boolean isDedicatedAdminVM) {
+    DistributionManager.isDedicatedAdminVM = isDedicatedAdminVM;
+  }
+
+  public static Boolean getIsStartupThread() {
+    return isStartupThread.get();
+  }
+
+  public static void setIsStartupThread(Boolean isStartup) {
+    DistributionManager.isStartupThread.set(isStartup);
+  }
+
+  private void runUntilShutdown(Runnable r) {
+    try {
+      r.run();
+    } catch (CancelException e) {
+      if (logger.isTraceEnabled()) {
+        logger.trace("Caught shutdown exception", e);
+      }
+    } catch (VirtualMachineError err) {
+      SystemFailure.initiateFailure(err);
+      // If this ever returns, rethrow the error. We're poisoned
+      // now, so don't let this thread continue.
+      throw err;
+    } catch (Throwable t) {
+      SystemFailure.checkFailure();
+      if (isCloseInProgress()) {
+        logger.debug("Caught unusual exception during shutdown: {}", t.getMessage(), t);
+      } else {
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.DistributionManager_TASK_FAILED_WITH_EXCEPTION), t);
+      }
+    }
+  }
+
-   * 
+   *
+  @Override
-   * 
+   *
-  public void setEquivalentHosts(Set<InetAddress> equivs) {
+  void setEquivalentHosts(Set<InetAddress> equivs) {
-  public HashMap<InetAddress, Set<InetAddress>> getEquivalentHostsSnapshot() {
-    synchronized (this.equivalentHosts) {
-      return new HashMap<InetAddress, Set<InetAddress>>(this.equivalentHosts);
-    }
-  }
-   * 
+   *
+  @Override
-  public void setRedundancyZone(InternalDistributedMember member, String redundancyZone) {
+  void setRedundancyZone(InternalDistributedMember member, String redundancyZone) {
-  public void setEnforceUniqueZone(boolean enforceUniqueZone) {
+  void setEnforceUniqueZone(boolean enforceUniqueZone) {
+  @Override
-    NetView result = null;
-    DistributionChannel ch = this.channel;
-    if (ch != null) {
-      MembershipManager mgr = ch.getMembershipManager();
-      if (mgr != null) {
-        result = mgr.getView();
-      }
-    }
-    if (result == null) {
-      result = new NetView();
-    }
-    return result.getMembers();
+    return membershipManager.getView().getMembers();
+  @Override
-   * Print a membership view (list of {@link InternalDistributedMember}s)
-   * 
-   * @param v the list
-   * @return String
-   */
-  static public String printView(NetView v) {
-    if (v == null)
-      return "null";
-
-    return v.toString();
-  }
-
-  /**
-  protected void startThreads() {
+  private void startThreads() {
-          LocalizedStrings.DistributionManager_INITIAL_MEMBERSHIPMANAGER_VIEW___0, printView(v)));
+          LocalizedStrings.DistributionManager_INITIAL_MEMBERSHIPMANAGER_VIEW___0,
+          String.valueOf(v)));
-      Iterator<InternalDistributedMember> it = v.getMembers().iterator();
-      while (it.hasNext()) {
-        addNewMember(it.next());
+      for (InternalDistributedMember internalDistributedMember : v.getMembers()) {
+        addNewMember(internalDistributedMember);
-          isStartupThread.set(Boolean.TRUE);
+          setIsStartupThread(Boolean.TRUE);
-  protected void readyForMessages() {
+  private void readyForMessages() {
-  protected void waitUntilReadyForMessages() {
+  private void waitUntilReadyForMessages() {
-    // membershipManager.waitForEventProcessing();
-   * 
+   *
-  protected void waitUntilReadyToSendMsgs(DistributionMessage msg) {
+  private void waitUntilReadyToSendMsgs(DistributionMessage msg) {
-    if (isStartupThread.get() != null) {
+    if (getIsStartupThread() == Boolean.TRUE) {
-    // membershipManager.waitForEventProcessing();
+
-  // DM method
+
-  // DM method
+
+  @Override
+  @Override
-    return this.myid;
+    return this.localAddress;
+  @Override
+  @Override
-
-      if (!this.isSharedConfigEnabledForDS) {
-        this.isSharedConfigEnabledForDS = isSharedConfigurationEnabled;
-      }
-
-          this.hostedLocatorsWithSharedConfiguration =
-              new HashMap<InternalDistributedMember, Collection<String>>();
+          this.hostedLocatorsWithSharedConfiguration = new HashMap<>();
-        tmp = new HashMap<InternalDistributedMember, Collection<String>>(
-            this.hostedLocatorsWithSharedConfiguration);
+        tmp = new HashMap<>(this.hostedLocatorsWithSharedConfiguration);
-            new HashMap<InternalDistributedMember, Collection<String>>(this.hostedLocatorsAll);
+            new HashMap<>(this.hostedLocatorsAll);
-   * 
+   *
+  @Override
-   * 
+   *
-   * 
+   *
+  @Override
-   * Returns the low-level distribution channel for this distribution manager. (brought over from
-   * ConsoleDistributionManager)
-   *
-   * @since GemFire 4.0
-   */
-  public DistributionChannel getDistributionChannel() {
-    return this.channel;
-  }
-
-
-  /**
+  @Override
+  @Override
+  @Override
-  public void addNewMember(InternalDistributedMember member) {
+  private void addNewMember(InternalDistributedMember member) {
+  @Override
-    return this.myid;
+    return this.localAddress;
-  /**
-   * Returns the id of the underlying distribution channel used for communication.
-   *
-   * @since GemFire 3.0
-   */
-  public long getChannelId() {
-    return this.channel.getId();
+  @Override
+  public long getMembershipPort() {
+    return localAddress.getPort();
-  /**
-   * Adds a message to the outgoing queue. Note that <code>message</code> should not be modified
-   * after it has been added to the queue. After <code>message</code> is distributed, it will be
-   * recycled.
-   *
-   * @return list of recipients who did not receive the message
-   * @throws NotSerializableException if the content is not serializable
-   */
-  public Set putOutgoingUserData(final DistributionMessage message)
-      throws NotSerializableException {
-    return sendMessage(message);
-  }
-
-  /**
-   * Send outgoing data; message is guaranteed to be serialized.
-   * 
-   * @return list of recipients who did not receive the message
-   * @throws InternalGemFireException if message is not serializable
-   */
+  @Override
-   * @see #closeInProgress
-   */
-  private final Object shutdownMutex = new Object();
-
-  /**
-        new Object[] {this.myid, exceptionStatus}));
+        new Object[] {this.localAddress, exceptionStatus}));
-                .toLocalizedString(this.myid));
+                .toLocalizedString(this.localAddress));
-   * maximum time, in milliseconds, to wait for all threads to exit
-   */
-  static private final int MAX_STOP_TIME = 20000;
-
-  /**
-   * Time to sleep, in milliseconds, while polling to see if threads have finished
-   */
-  static private final int STOP_PAUSE_TIME = 1000;
-
-  /**
-   * Maximum number of interrupt attempts to stop a thread
-   */
-  static private final int MAX_STOP_ATTEMPTS = 10;
-
-  /**
-   * 
+   *
-   * 
+   *
+  @Override
-      if (this.channel != null) {
-        this.channel.setShutDown();
+      if (membershipManager != null) {
+        membershipManager.setShutdown();
-      // // bug36329: desperation measure, send a second interrupt?
-      // try { Thread.sleep(1000); }
-      // catch (InterruptedException ie) {
-      // // No need to reset interrupt bit, we're really trying to quit...
-      // }
-      // forceThreadsToStop();
-        if (this.channel != null) {
+        if (this.membershipManager != null) {
-              LocalizedStrings.DistributionManager_NOW_CLOSING_DISTRIBUTION_FOR__0, this.myid));
-          this.channel.disconnect(beforeJoined);
-          // this.channel = null; DO NOT NULL OUT INSTANCE VARIABLES AT SHUTDOWN - bug #42087
+              LocalizedStrings.DistributionManager_NOW_CLOSING_DISTRIBUTION_FOR__0,
+              this.localAddress));
+          this.membershipManager.disconnect(beforeJoined);
-  /**
-   * Returns the distributed system to which this distribution manager is connected.
-   */
+  @Override
-   * 
-   * @since GemFire 5.0
-  public RemoteTransportConfig getTransport() {
+  RemoteTransportConfig getTransport() {
-  /**
-   * Adds a <code>MembershipListener</code> to this distribution manager.
-   */
+  @Override
-  /**
-   * Removes a <code>MembershipListener</code> from this distribution manager.
-   *
-   * @throws IllegalArgumentException <code>l</code> was not registered on this distribution manager
-   */
+  @Override
-   * 
-   * @since GemFire 5.7
-  public void addAllMembershipListener(MembershipListener l) {
+  private void addAllMembershipListener(MembershipListener l) {
-  /**
-   * Removes a <code>MembershipListener</code> listening for all members from this distribution
-   * manager.
-   *
-   * @throws IllegalArgumentException <code>l</code> was not registered on this distribution manager
-   * @since GemFire 5.7
-   */
+  @Override
-  public void waitForViewInstallation(long id) throws InterruptedException {
+  void waitForViewInstallation(long id) throws InterruptedException {
-  protected void handleMemberEvent(MemberEvent ev) {
+  private void handleMemberEvent(MemberEvent ev) {
-   * 
+   *
-  /**
-   * Stops the threads associated with this distribution manager and closes the connection to the
-   * transport layer.
-   */
+  @Override
-          LocalizedStrings.DistributionManager_MARKING_DISTRIBUTIONMANAGER_0_AS_CLOSED, this.myid));
-      MembershipLogger.logShutdown(this.myid);
+          LocalizedStrings.DistributionManager_MARKING_DISTRIBUTIONMANAGER_0_AS_CLOSED,
+          this.localAddress));
+      MembershipLogger.logShutdown(this.localAddress);
-      synchronized (DistributionManager.class) {
-        openDMs--;
-      }
+  @Override
-  /**
-   * Makes note of a new administration console (admin-only member).
-   */
+
+  @Override
+  @Override
+  @Override
-  // /**
-  // * Initializes and returns a <code>DistributedSystem</code> to be
-  // * sent to new members of the distributed system.
-  // *
-  // * @since GemFire 3.0
-  // */
-  // protected DistributedState getNewDistributedState() {
-  // DistributedState state = new DistributedState();
-  // state.setGemFireVersion(GemFireVersion.getGemFireVersion());
-  // state.setCacheTime(this.cacheTimeMillis());
-  // return state;
-  // }
-
-  private static final int STARTUP_TIMEOUT =
-      Integer.getInteger("DistributionManager.STARTUP_TIMEOUT", 15000).intValue();
-
-  public static final boolean DEBUG_NO_ACKNOWLEDGEMENTS =
-      Boolean.getBoolean("DistributionManager.DEBUG_NO_ACKNOWLEDGEMENTS");
-
+  @Override
-  @Override // DM method
+  @Override
-  @Override // DM method
+  @Override
-  /**
-   * Add a membership listener for all members and return other DistribtionManagerIds as an atomic
-   * operation
-   * 
-   * @since GemFire 5.7
-   */
+  @Override
-    // TO fix this deadlock:
-    // "View Message Processor":
-    // waiting to lock monitor 0x080f691c (object 0xe3ba7680, a
-    // org.apache.geode.distributed.internal.DistributionManager$MembersLock),
-    // which is held by "RMI TCP Connection(259)-10.80.10.55"
-    // "RMI TCP Connection(259)-10.80.10.55":
-    // waiting to lock monitor 0x080f6598 (object 0xe3bacd90, a
-    // org.apache.geode.distributed.internal.membership.jgroup.JGroupMembershipManager$ViewLock),
-    // which is held by "View Message Processor"
-    // NEED to prevent view changes while installing a listener.
-    DistributionChannel ch = this.channel;
-    if (ch != null) {
-      MembershipManager mgr = ch.getMembershipManager();
-      if (mgr != null) {
-        mgr.getViewLock().writeLock().lock();
-        try {
-          synchronized (this.membersLock) {
-            // Don't let the members come and go while we are adding this
-            // listener. This ensures that the listener (probably a
-            // ReplyProcessor) gets a consistent view of the members.
-            addAllMembershipListener(l);
-            return getDistributionManagerIdsIncludingAdmin();
-          }
-        } finally {
-          mgr.getViewLock().writeLock().unlock();
-        }
+    MembershipManager mgr = membershipManager;
+    mgr.getViewLock().writeLock().lock();
+    try {
+      synchronized (this.membersLock) {
+        // Don't let the members come and go while we are adding this
+        // listener. This ensures that the listener (probably a
+        // ReplyProcessor) gets a consistent view of the members.
+        addAllMembershipListener(l);
+        return getDistributionManagerIdsIncludingAdmin();
-    }
-    // If we have no channel or MembershipManager then the view is empty
-    synchronized (this.membersLock) {
-      // Don't let the members come and go while we are adding this
-      // listener. This ensures that the listener (probably a
-      // ReplyProcessor) gets a consistent view of the members.
-      addAllMembershipListener(l);
-      return Collections.EMPTY_SET;
+    } finally {
+      mgr.getViewLock().writeLock().unlock();
-  protected boolean sendStartupMessage(StartupOperation startupOperation, boolean cancelOnTimeout)
+  private boolean sendStartupMessage(StartupOperation startupOperation)
-        || DistributionManager.isDedicatedAdminVM
+        || DistributionManager.isDedicatedAdminVM()
+  @Override
+  @Override
-  void processStartupResponse(InternalDistributedMember sender, long otherCacheTime,
-      String theRejectionMessage) {
-    removeUnfinishedStartup(sender, false);
-    synchronized (this) {
-      if (!this.receivedStartupResponse) {
-        this.receivedStartupResponse = true;
-      }
-      if (theRejectionMessage != null && this.rejectionMessage == null) {
-        // remember the first non-null rejection. This fixes bug 33266
-        this.rejectionMessage = theRejectionMessage;
-      }
-    }
-  }
-
-  /**
-   * Processes the first startup response.
-   *
-   * @see StartupResponseMessage#process
-   */
-   * 
+   *
-    // && theMembers.contains(this.myid)); // bug36202?
+    // && theMembers.contains(this.localAddress)); // bug36202?
-      if (member.equals(this.myid)) {
+      if (member.equals(this.localAddress)) {
-              LocalizedStrings.DistributionManager_0_IS_THE_ELDER_AND_THE_ONLY_MEMBER, this.myid));
+              LocalizedStrings.DistributionManager_0_IS_THE_ELDER_AND_THE_ONLY_MEMBER,
+              this.localAddress));
-              this.myid));
+              this.localAddress));
-  protected void selectElder() {
+  private void selectElder() {
-    if (this.myid.equals(this.elder)) {
+    if (this.localAddress.equals(this.elder)) {
-    if (!theId.equals(myid) && theId.equals(elder)) {
+    if (!theId.equals(localAddress) && theId.equals(elder)) {
-  /**
-   * Return true if id is a current member of our system.
-   */
+  @Override
-  public void handleIncomingDMsg(DistributionMessage message) {
-    /*
-     * disabled - not being used if (message instanceof OutgoingMessageWrapper) {
-     * putOutgoing(((OutgoingMessageWrapper)message).getMessage()); return; }
-     */
-
-    // long latency = message.getLatency();
-    // this.stats.incMessageTransitTime(latency * 1000000L);
-    // message.resetTimestamp();
+  private void handleIncomingDMsg(DistributionMessage message) {
-    // message.setRecipient(DistributionManager.this.getId());
-
-   * 
+   *
-  /**
-   * used by the DistributedMembershipListener and startup and shutdown operations, this method
-   * decrements the number of nodes and handles lower-level clean up of the resources used by the
-   * departed manager
-   */
+  @Override
-  public void handleManagerSuspect(InternalDistributedMember suspect,
+  private void handleManagerSuspect(InternalDistributedMember suspect,
-  public void handleViewInstalled(NetView view) {
+  private void handleViewInstalled(NetView view) {
-  public void handleQuorumLost(Set<InternalDistributedMember> failures,
+  private void handleQuorumLost(Set<InternalDistributedMember> failures,
-  protected void sendShutdownMessage() {
+  private void sendShutdownMessage() {
-    // ReplyProcessor21 rp = new ReplyProcessor21(this, allOthers);
-    // m.setProcessorId(rp.getProcessorId());
-    // m.setMulticast(system.getConfig().getMcastPort() != 0);
-      channel.send(m.getRecipients(), m, this, stats);
+      sendViaMembershipManager(m.getRecipients(), m, this, stats);
-  // /**
-  // * Return a shortened name of a class that excludes the package
-  // */
-  // private static String shortenClassName(String className) {
-  // int index = className.lastIndexOf('.');
-  // if (index != -1) {
-  // return className.substring(index + 1);
-  //
-  // } else {
-  // return className;
-  // }
-  // }
-
-  /**
-   * Send a message that is guaranteed to be serialized
-   * 
-   * @param msg
-   * @return the recipients who did not receive the message
-   */
-  protected Set sendOutgoingSerialized(DistributionMessage msg) {
-    try {
-      return sendOutgoing(msg);
-    } catch (NotSerializableException e) {
-      throw new InternalGemFireException(e);
-    } catch (ToDataException e) {
-      // exception from user code
-      throw e;
-    }
-  }
-
-  protected Set sendOutgoing(DistributionMessage message) throws NotSerializableException {
+  Set sendOutgoing(DistributionMessage message) throws NotSerializableException {
-    Set result =
-        channel.send(message.getRecipients(), message, DistributionManager.this, this.stats);
+    Set result = sendViaMembershipManager(message.getRecipients(), message,
+        DistributionManager.this, this.stats);
-    } catch (NotSerializableException ex) {
-      throw ex; // serialization error in user data
-    } catch (ToDataException ex) {
-      throw ex; // serialization error in user data
-    } catch (ReenteredConnectException ex) {
-      throw ex; // Recursively tried to get the same connection
-    } catch (CancelException ex) {
-      throw ex; // bug 37194, shutdown conditions
-    } catch (InvalidDeltaException ide) {
-      logger.info(
-          LocalizedMessage
-              .create(LocalizedStrings.DistributionManager_CAUGHT_EXCEPTION_WHILE_SENDING_DELTA),
-          ide.getCause());
-      throw (RuntimeException) ide.getCause();
+    } catch (NotSerializableException | ToDataException | ReenteredConnectException
+        | InvalidDeltaException | CancelException ex) {
+      throw ex;
+  /**
+   * @return list of recipients who did not receive the message because they left the view (null if
+   *         all received it or it was sent to {@link DistributionMessage#ALL_RECIPIENTS}).
+   * @throws NotSerializableException If content cannot be serialized
+   */
+  private Set sendViaMembershipManager(InternalDistributedMember[] destinations,
+      DistributionMessage content, DistributionManager dm, DistributionStats stats)
+      throws NotSerializableException {
+    if (membershipManager == null) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.DistributionChannel_ATTEMPTING_A_SEND_TO_A_DISCONNECTED_DISTRIBUTIONMANAGER));
+      if (destinations.length == 1 && destinations[0] == DistributionMessage.ALL_RECIPIENTS)
+        return null;
+      HashSet result = new HashSet();
+      for (int i = 0; i < destinations.length; i++) {
+        result.add(destinations[i]);
+      }
+      return result;
+    }
+    return membershipManager.send(destinations, content, stats);
+  }
+
-   * 
-   * @param message
-  protected void scheduleIncomingMessage(DistributionMessage message) {
+  void scheduleIncomingMessage(DistributionMessage message) {
-  /**
-   * Mutex to control access to {@link #waitingForElderChange} or {@link #elder}.
-   */
-  protected final Object elderMonitor = new Object();
-
-  /**
-   * Must be read/written while holding {@link #elderMonitor}
-   * 
-   * @see #elderChangeWait()
-   */
-  private boolean waitingForElderChange = false;
-
-  /**
-   * @see DM#isAdam()
-   */
-  private boolean adam = false;
-
-  /**
-   * This is the "elder" member of the distributed system, responsible for certain types of
-   * arbitration.
-   * 
-   * Must hold {@link #elderMonitor} in order to change this.
-   * 
-   * @see #getElderId()
-   */
-  protected volatile InternalDistributedMember elder = null;
-
+  @Override
+  @Override
-    // membershipManager.waitForEventProcessing();
+  @Override
+  @Override
+  @Override
-        if (!this.myid.equals(this.elder)) {
-          logger.debug("Forcing myself, {}, to be the elder.", this.myid);
+        if (!this.localAddress.equals(this.elder)) {
+          logger.debug("Forcing myself, {}, to be the elder.", this.localAddress);
-      changeElder(this.myid);
+      changeElder(this.localAddress);
-    if (force || this.myid.equals(elder)) {
+    if (force || this.localAddress.equals(elder)) {
-   * 
+   *
-          if (this.myid.equals(currentElder)) {
+          if (this.localAddress.equals(currentElder)) {
-  protected void changeElder(InternalDistributedMember newElder) {
+  private void changeElder(InternalDistributedMember newElder) {
-      if (newElder != null && this.myid != null && !this.myid.equals(newElder)) {
-        if (this.myid.equals(this.elder)) {
+      if (newElder != null && this.localAddress != null && !this.localAddress.equals(newElder)) {
+        if (this.localAddress.equals(this.elder)) {
-  protected void notifyElderChangeWaiters() {
+  private void notifyElderChangeWaiters() {
-  /**
-   * getThreadPool gets this distribution manager's message-processing thread pool
-   */
+  @Override
-  /**
-   * Return the high-priority message-processing executor
-   */
+  @Override
-  /**
-   * Return the waiting message-processing executor
-   */
+  @Override
-  /**
-   * Return the waiting message-processing executor
-   */
+  @Override
-  /**
-   * Return the waiting message-processing executor
-   */
-  public Executor getPartitionedRegionExcecutor() {
+  private Executor getPartitionedRegionExcecutor() {
-  /**
-   * Return the waiting message-processing executor
-   */
+
+  @Override
-   *
-   * @since GemFire 4.0
-   * 
-   * @since GemFire 3.5
-   *
-   * @since GemFire 3.5
-  private InternalCache cache;
+  private volatile InternalCache cache;
-   * 
+   *
+  @Override
+  @Override
-   * 
+   *
+  @Override
-  public void removeAllHealthMonitors() {
+  private void removeAllHealthMonitors() {
-  // For feature request #32887
-  public Set getAdminMemberSet() {
+  @Override
+  public Set<InternalDistributedMember> getAdminMemberSet() {
+  @Override
+  @Override
+  @Override
+  @Override
-  static private class SerialQueuedExecutorPool {
+  private static class SerialQueuedExecutorPool {
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-    public void handleMemberDeparture(InternalDistributedMember member) {
+    private void handleMemberDeparture(InternalDistributedMember member) {
-    public void awaitTermination(long time, TimeUnit unit) throws InterruptedException {
+    private void awaitTermination(long time, TimeUnit unit) throws InterruptedException {
-    protected void shutdown() {
+    private void shutdown() {
-  private class MyListener implements DistributedMembershipListener {
+  private class DMListener implements DistributedMembershipListener {
-    public MyListener(DistributionManager dm) {
+    public DMListener(DistributionManager dm) {
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
-        message.setRecipient(myid);
+        message.setRecipient(localAddress);
+    @Override
+    @Override
-    /** this is invoked when quorum is being lost, before the view has been installed */
+    @Override
+    @Override
-  private static abstract class MemberEvent {
+  private abstract static class MemberEvent {
-    public void handleEvent(DistributionManager manager) {
+    void handleEvent(DistributionManager manager) {
-    protected void handleEvent(DistributionManager manager,
+    private void handleEvent(DistributionManager manager,
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  @Override
-   * 
+   *
+  @Override
-   * 
+   *
-   * 
+   *
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-   * this causes all members in the system to log thread dumps If useNative is true we attempt to
-   * use OSProcess native code for the dumps. This goes to stdout instead of the system.log files.
-   */
-  public void printDistributedSystemStacks(boolean useNative) {
-    printStacks(new HashSet(getDistributionManagerIds()), useNative);
-  }
-
-  /**
-    if (ids.contains(myid)) {
+    if (ids.contains(localAddress)) {
-      ids.remove(myid);
+      ids.remove(localAddress);
-        if (mbr.getProcessId() > 0 && mbr.getInetAddress().equals(this.myid.getInetAddress())) {
-          if (!mbr.equals(myid)) {
+        if (mbr.getProcessId() > 0
+            && mbr.getInetAddress().equals(this.localAddress.getInetAddress())) {
+          if (!mbr.equals(localAddress)) {
+  @Override
+  /** test method to get the member IDs of all locators in the distributed system */
+
+  @Override
+  public InternalCache getExistingCache() {
+    InternalCache result = this.cache;
+    if (result == null) {
+      throw new CacheClosedException(
+          LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED.toLocalizedString());
+    }
+    result.getCancelCriterion().checkCancelInProgress(null);
+    if (result.isClosed()) {
+      throw result.getCacheClosedException(
+          LocalizedStrings.CacheFactory_THE_CACHE_HAS_BEEN_CLOSED.toLocalizedString(), null);
+    }
+    return result;
+  }
+
+
+  private static class Stopper extends CancelCriterion {
+    private DistributionManager dm;
+
+    Stopper(DistributionManager dm) {
+      this.dm = dm;
+    }
+
+    @Override
+    public String cancelInProgress() {
+      checkFailure();
+
+      // remove call to validateDM() to fix bug 38356
+
+      if (dm.shutdownMsgSent) {
+        return LocalizedStrings.DistributionManager__0_MESSAGE_DISTRIBUTION_HAS_TERMINATED
+            .toLocalizedString(dm.toString());
+      }
+      if (dm.rootCause != null) {
+        return dm.toString() + ": " + dm.rootCause.getMessage();
+      }
+
+      // Nope.
+      return null;
+    }
+
+    @Override
+    public RuntimeException generateCancelledException(Throwable e) {
+      String reason = cancelInProgress();
+      if (reason == null) {
+        return null;
+      }
+      Throwable rc = dm.rootCause; // volatile read
+      if (rc == null) {
+        // No root cause, specify the one given and be done with it.
+        return new DistributedSystemDisconnectedException(reason, e);
+      }
+
+      if (e == null) {
+        // Caller did not specify any root cause, so just use our own.
+        return new DistributedSystemDisconnectedException(reason, rc);
+      }
+
+      // Attempt to stick rootCause at tail end of the exception chain.
+      Throwable nt = e;
+      while (nt.getCause() != null) {
+        nt = nt.getCause();
+      }
+      if (nt == rc) {
+        // Root cause already in place; we're done
+        return new DistributedSystemDisconnectedException(reason, e);
+      }
+
+      try {
+        nt.initCause(rc);
+        return new DistributedSystemDisconnectedException(reason, e);
+      } catch (IllegalStateException e2) {
+        // Bug 39496 (Jrockit related) Give up. The following
+        // error is not entirely sane but gives the correct general picture.
+        return new DistributedSystemDisconnectedException(reason, rc);
+      }
+    }
+  }
+
+  private final Stopper stopper = new Stopper(this);
+
+  @Override
+  public CancelCriterion getCancelCriterion() {
+    return stopper;
+  }
+

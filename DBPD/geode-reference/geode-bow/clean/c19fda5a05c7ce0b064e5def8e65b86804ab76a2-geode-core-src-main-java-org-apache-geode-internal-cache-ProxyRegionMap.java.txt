GEODE-5135: Refactor AbstractRegionMap dependencies (#3235)

`BaseRegionMap` will be an abstract base class for `AbstractRegionMap`
and `ProxyRegionMap`. Will move common functionality into this class.
Aims to remove dependency between `AbstractRegionMap` and `ProxyRegionMap`

Move ARMLockTestHook to RegionMap to remove circular dependency
while keeping the impact as small as possible.

Move `forceInvalidateEvent`, `shouldInvokeCallbacks` and
`switchEventOwnerAndOriginRemote` to `BaseRegionMap` to reduce
dependency between `ProxyRegionMap` and `AbstractRegionMap`

Move `createCallbackEvent` from `AbstractRegionMap` to `EntryEventImpl`
This reduces dependecy between `AbstractRegionMap` and `ProxyRegionMap`

Add `EntryEventFactory` class and move `createCallbackEvent`.
Also cleanup `BaseRegionMap` prefix refactoring artifact

Change `EntryEventFactory` to `EntryEventFactoryImpl` that
implements new `EntryEventFactory` interface to make it
availiable for Mockito testing. This requires `createCallbackEvent`
to be a non-static method.

Add private EntryEventFactory field in classes where it is used.
Reduce number of object instantiations.

Co-Authored-By: Patric Lantz <herrlantz@users.noreply.github.com>
Co-Authored-By: Sayyed Ali Kiaian Mousavy <sakm2@kth.se>
Co-Authored-By: Nicole Jagelid <nicolej@kth.se>
Co-Authored-By: ddahlgren95 <46962337+ddahlgren95@users.noreply.github.com>
-import org.apache.geode.internal.cache.AbstractRegionMap.ARMLockTestHook;
-import org.apache.geode.internal.cache.eviction.EvictableEntry;
-import org.apache.geode.internal.cache.eviction.EvictionController;
-import org.apache.geode.internal.cache.persistence.DiskRegionView;
-class ProxyRegionMap implements RegionMap {
+class ProxyRegionMap extends BaseRegionMap {
+
+  private final EntryEventFactory entryEventFactory = new EntryEventFactoryImpl();
-        AbstractRegionMap.forceInvalidateEvent(event, this.owner);
+        forceInvalidateEvent(event, this.owner);
-      if (AbstractRegionMap.shouldInvokeCallbacks(this.owner, !inTokenMode)) {
+      if (shouldInvokeCallbacks(this.owner, !inTokenMode)) {
-        EntryEventImpl e = AbstractRegionMap.createCallbackEvent(this.owner, op, key, null,
-            rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
-            txEntryState, versionTag, tailKey);
-        AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
+        EntryEventImpl e =
+            entryEventFactory.createCallbackEvent(this.owner, op, key, null,
+                rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+                txEntryState, versionTag, tailKey);
+        switchEventOwnerAndOriginRemote(e, txEntryState == null);
-      if (AbstractRegionMap.shouldInvokeCallbacks(this.owner, this.owner.isInitialized())) {
+      if (shouldInvokeCallbacks(this.owner, this.owner.isInitialized())) {
-        EntryEventImpl e = AbstractRegionMap.createCallbackEvent(this.owner,
+        EntryEventImpl e = entryEventFactory.createCallbackEvent(this.owner,
-        AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
+        switchEventOwnerAndOriginRemote(e, txEntryState == null);
-      if (AbstractRegionMap.shouldInvokeCallbacks(this.owner, this.owner.isInitialized())) {
+      if (shouldInvokeCallbacks(this.owner, this.owner.isInitialized())) {
-        EntryEventImpl e = AbstractRegionMap.createCallbackEvent(this.owner, putOperation, key,
-            newValue, rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo,
-            bridgeContext, txEntryState, versionTag, tailKey);
-        AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
+        EntryEventImpl e = entryEventFactory
+            .createCallbackEvent(this.owner, putOperation, key,
+                newValue, rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo,
+                bridgeContext, txEntryState, versionTag, tailKey);
+        switchEventOwnerAndOriginRemote(e, txEntryState == null);
-  // LRUMapCallbacks methods
-  @Override
-  public void lruUpdateCallback() {
-    // nothing needed
-  }
-
-  @Override
-  public boolean disableLruUpdateCallback() {
-    // nothing needed
-    return false;
-  }
-
-  @Override
-  public void enableLruUpdateCallback() {
-    // nothing needed
-  }
-
-  public boolean lruLimitExceeded(DiskRegionView diskRegionView) {
-    return false;
-  }
-
-  @Override
-  public void lruCloseStats() {
-    // nothing needed
-  }
-
-  @Override
-  public void resetThreadLocals() {
-    // nothing needed
-  }
-
-  @Override
-  public void lruEntryFaultIn(EvictableEntry entry) {
-    // do nothing.
-
-  }
-
-  @Override
-  public long getEvictions() {
-    return 0;
-  }
-
-  @Override
-  public void incRecentlyUsed() {
-    // nothing
-  }
-
-  @Override
-  public EvictionController getEvictionController() {
-    return null;
-  }
-
-  @Override
-  public boolean beginChangeValueForm(EvictableEntry le,
-      CachedDeserializable vmCachedDeserializable, Object v) {
-    return false;
-  }
-
-  @Override
-  public void finishChangeValueForm() {}
-
-  @Override
-  public int centralizedLruUpdateCallback() {
-    return 0;
-  }
-
-  @Override
-  public void updateEvictionCounter() {}
-
-  @Override
-  public void setEntryMap(ConcurrentMapWithReusableEntries<Object, Object> map) {
-
-  }
+  public void setEntryMap(ConcurrentMapWithReusableEntries<Object, Object> map) {}

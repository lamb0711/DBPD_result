GEODE-7756: Do not use authorization cache for CQs (#4677)

CQs are executed on individual entries whenever an event is triggered
for them and the execution context is always cleared before the actual
evaluation, thus using an internal cache to keep already authorized
methods is useless (will always be a cache miss and the computation
required just adds overhead).

- Fixed the CQ creation to always set the 'cqQueryContext' flag.
- Modified the query engine to avoid using the internal cache for
  already authorized methods when the context belongs to a CQ.
- Avoid the creation and concatenation of unnecessary Strings, using
  the Method class directly instead.
+import org.apache.geode.cache.query.security.MethodInvocationAuthorizer;
-          // Try to use previous result so authorizer gets invoked only once per query.
-          boolean authorizationResult;
-          String cacheKey = target.getClass().getCanonicalName() + "." + method.getName();
-          Boolean cachedResult = (Boolean) executionContext.cacheGet(cacheKey);
+          MethodInvocationAuthorizer authorizer = executionContext.getMethodInvocationAuthorizer();
-          if (cachedResult == null) {
-            // First time, evaluate and cache result.
-            authorizationResult =
-                executionContext.getMethodInvocationAuthorizer().authorize(method, target);
-            executionContext.cachePut(cacheKey, authorizationResult);
+          // CQs are generally executed on individual events, so caching is just an overhead.
+          if (executionContext.isCqQueryContext()) {
+            if (!authorizer.authorize(method, target)) {
+              throw new NotAuthorizedException(UNAUTHORIZED_STRING + method.getName());
+            }
-            // Use cached result.
-            authorizationResult = cachedResult;
-          }
+            // Try to use previous result so authorizer gets invoked only once per query.
+            boolean authorizationResult;
+            Boolean cachedResult = (Boolean) executionContext.cacheGet(method);
-          if (!authorizationResult) {
-            throw new NotAuthorizedException(UNAUTHORIZED_STRING + method.getName());
+            if (cachedResult == null) {
+              // First time, evaluate and cache result.
+              authorizationResult = authorizer.authorize(method, target);
+              executionContext.cachePut(method, authorizationResult);
+            } else {
+              // Use cached result.
+              authorizationResult = cachedResult;
+            }
+
+            if (!authorizationResult) {
+              throw new NotAuthorizedException(UNAUTHORIZED_STRING + method.getName());
+            }

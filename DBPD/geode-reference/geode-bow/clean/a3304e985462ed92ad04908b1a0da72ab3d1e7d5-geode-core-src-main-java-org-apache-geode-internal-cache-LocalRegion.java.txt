GEODE-6754: Remove micrometer timers from LocalRegion (#3567)

Co-authored-by: Mark Hanson mhanson@pivotal.io
-import io.micrometer.core.instrument.Timer;
-  private final Timer createTimer;
-  private final Timer putTimer;
-  private final Timer putIfAbsentTimer;
-  private final Timer replaceTimer;
-  private final Timer getTimer;
-  private final Timer getEntryTimer;
-  private final Timer containsKeyTimer;
-  private final Timer containsValueTimer;
-  private final Timer containsKeyOnServerTimer;
-  private final Timer containsValueForKeyTimer;
-
-    createTimer = Timer.builder("cache.region.operations.puts")
-        .tag("region.name", regionName)
-        .tag("put.type", "create")
-        .register(cache.getMeterRegistry());
-
-    putTimer = Timer.builder("cache.region.operations.puts")
-        .tag("region.name", regionName)
-        .tag("put.type", "put")
-        .register(cache.getMeterRegistry());
-
-    putIfAbsentTimer = Timer.builder("cache.region.operations.puts")
-        .tag("region.name", regionName)
-        .tag("put.type", "put-if-absent")
-        .register(cache.getMeterRegistry());
-
-    replaceTimer = Timer.builder("cache.region.operations.puts")
-        .tag("region.name", regionName)
-        .tag("put.type", "replace")
-        .register(cache.getMeterRegistry());
-
-    getTimer = Timer.builder("cache.region.operations.gets")
-        .tag("region.name", regionName)
-        .tag("get.type", "get")
-        .register(cache.getMeterRegistry());
-
-    getEntryTimer = Timer.builder("cache.region.operations.gets")
-        .tag("region.name", regionName)
-        .tag("get.type", "get-entry")
-        .register(cache.getMeterRegistry());
-
-    containsKeyTimer = Timer.builder("cache.region.operations.contains")
-        .tag("region.name", regionName)
-        .tag("contains.type", "contains-key")
-        .register(cache.getMeterRegistry());
-
-    containsValueTimer = Timer.builder("cache.region.operations.contains")
-        .tag("region.name", regionName)
-        .tag("contains.type", "contains-value")
-        .register(cache.getMeterRegistry());
-
-    containsKeyOnServerTimer = Timer.builder("cache.region.operations.contains")
-        .tag("region.name", regionName)
-        .tag("contains.type", "contains-key-on-server")
-        .register(cache.getMeterRegistry());
-
-    containsValueForKeyTimer = Timer.builder("cache.region.operations.contains")
-        .tag("region.name", regionName)
-        .tag("contains.type", "contains-value-for-key")
-        .register(cache.getMeterRegistry());
-                       // this region
+      // this region
-    createTimer.record(() -> {
-      @Released
-      EntryEventImpl event = newCreateEntryEvent(key, value, aCallbackArgument);
-      try {
-        validatedCreate(event, startPut);
-      } finally {
-        event.release();
-      }
-    });
+    @Released
+    EntryEventImpl event = newCreateEntryEvent(key, value, aCallbackArgument);
+    try {
+      validatedCreate(event, startPut);
+    } finally {
+      event.release();
+    }
-             // create? I think so that the EntryExistsException will have it.
+    // create? I think so that the EntryExistsException will have it.
-    return getTimer.record(() -> {
-      Object result =
-          get(key, aCallbackArgument, generateCallbacks, false, false, null, clientEvent, false);
-      if (Token.isInvalid(result)) {
-        result = null;
-      }
-      return result;
-    });
+    Object result =
+        get(key, aCallbackArgument, generateCallbacks, false, false, null, clientEvent, false);
+    if (Token.isInvalid(result)) {
+      result = null;
+    }
+    return result;
-    return putTimer.record(() -> {
-      @Released
-      EntryEventImpl event = newUpdateEntryEvent(key, value, aCallbackArgument);
-      try {
-        return validatedPut(event, startPut);
-      } finally {
-        event.release();
-      }
-    });
+    @Released
+    EntryEventImpl event = newUpdateEntryEvent(key, value, aCallbackArgument);
+    try {
+      return validatedPut(event, startPut);
+    } finally {
+      event.release();
+    }
-    return getEntryTimer.record(() -> {
-      validateKey(key);
-      checkReadiness();
-      checkForNoAccess();
-      discoverJTA();
-      return getDataView().getEntry(getKeyInfo(key), this, false);
-    });
+    validateKey(key);
+    checkReadiness();
+    checkForNoAccess();
+    discoverJTA();
+    return getDataView().getEntry(getKeyInfo(key), this, false);
-    return containsKeyTimer.record(() -> {
-      checkReadiness();
-      checkForNoAccess();
-      return getDataView().containsKey(getKeyInfo(key), this);
-    });
+    checkReadiness();
+    checkForNoAccess();
+    return getDataView().containsKey(getKeyInfo(key), this);
-    return containsValueForKeyTimer.record(() -> {
-      discoverJTA();
-      return getDataView().containsValueForKey(getKeyInfo(key), this);
-    });
+    discoverJTA();
+    return getDataView().containsValueForKey(getKeyInfo(key), this);
-
-      cache.getMeterRegistry().remove(createTimer);
-      cache.getMeterRegistry().remove(putTimer);
-      cache.getMeterRegistry().remove(putIfAbsentTimer);
-      cache.getMeterRegistry().remove(replaceTimer);
-      cache.getMeterRegistry().remove(getTimer);
-      cache.getMeterRegistry().remove(getEntryTimer);
-      cache.getMeterRegistry().remove(containsKeyTimer);
-      cache.getMeterRegistry().remove(containsValueTimer);
-      cache.getMeterRegistry().remove(containsKeyOnServerTimer);
-      cache.getMeterRegistry().remove(containsValueForKeyTimer);
-    return containsKeyOnServerTimer.record(() -> {
-      checkReadiness();
-      checkForNoAccess();
-      ServerRegionProxy proxy = getServerProxy();
-      if (proxy != null) {
-        return proxy.containsKey(key);
-      } else {
-        throw new UnsupportedOperationException(
-            "Server keySet requires a pool.");
-      }
-    });
+    checkReadiness();
+    checkForNoAccess();
+    ServerRegionProxy proxy = getServerProxy();
+    if (proxy != null) {
+      return proxy.containsKey(key);
+    } else {
+      throw new UnsupportedOperationException(
+          "Server keySet requires a pool.");
+    }
-    return containsValueTimer.record(() -> {
-      if (value == null) {
-        throw new NullPointerException(
-            "Value for containsValue(value) cannot be null");
-      }
-      checkReadiness();
-      checkForNoAccess();
-      boolean result = false;
-      for (Object entry : new EntriesSet(this, false, IteratorType.VALUES, false)) {
-        if (entry != null) {
-          if (value.equals(entry)) {
-            result = true;
-            break;
-          }
+    if (value == null) {
+      throw new NullPointerException(
+          "Value for containsValue(value) cannot be null");
+    }
+    checkReadiness();
+    checkForNoAccess();
+    boolean result = false;
+    for (Object entry : new EntriesSet(this, false, IteratorType.VALUES, false)) {
+      if (entry != null) {
+        if (value.equals(entry)) {
+          result = true;
+          break;
-      return result;
-    });
+    }
+    return result;
-    return putIfAbsentTimer.record(() -> {
-      checkIfConcurrentMapOpsAllowed();
-      validateArguments(key, value, callbackArgument);
+    checkIfConcurrentMapOpsAllowed();
+    validateArguments(key, value, callbackArgument);
-      // TODO ConcurrentMap.putIfAbsent() treats null as an invalidation operation
-      // BUT we need to return the old value, which Invalidate isn't currently doing
+    // TODO ConcurrentMap.putIfAbsent() treats null as an invalidation operation
+    // BUT we need to return the old value, which Invalidate isn't currently doing
-      checkReadiness();
-      checkForLimitedOrNoAccess();
-      discoverJTA();
+    checkReadiness();
+    checkForLimitedOrNoAccess();
+    discoverJTA();
-      // This used to call the constructor which took the old value. It
-      // was modified to call the other EntryEventImpl constructor so that
-      // an id will be generated by default. Null was passed in anyway.
-      // generate EventID
+    // This used to call the constructor which took the old value. It
+    // was modified to call the other EntryEventImpl constructor so that
+    // an id will be generated by default. Null was passed in anyway.
+    // generate EventID
-      @Released
-      EntryEventImpl event = entryEventFactory.create(this, Operation.PUT_IF_ABSENT, key, value,
-          callbackArgument, false, getMyId());
+    @Released
+    EntryEventImpl event = entryEventFactory.create(this, Operation.PUT_IF_ABSENT, key, value,
+        callbackArgument, false, getMyId());
-      try {
-        if (generateEventID()) {
-          event.setNewEventId(cache.getDistributedSystem());
-        }
-        final Object oldValue = null;
-        final boolean ifNew = true;
-        final boolean ifOld = false;
-        final boolean requireOldValue = true;
-        if (!basicPut(event, ifNew, ifOld, oldValue, requireOldValue)) {
-          return event.getOldValue();
-        } else {
-          if (!getDataView().isDeferredStats()) {
-            getCachePerfStats().endPut(startPut, false);
-          }
-          return null;
-        }
-      } catch (EntryNotFoundException ignore) {
-        return event.getOldValue();
-      } finally {
-        event.release();
+    try {
+      if (generateEventID()) {
+        event.setNewEventId(cache.getDistributedSystem());
-    });
+      final Object oldValue = null;
+      final boolean ifNew = true;
+      final boolean ifOld = false;
+      final boolean requireOldValue = true;
+      if (!basicPut(event, ifNew, ifOld, oldValue, requireOldValue)) {
+        return event.getOldValue();
+      } else {
+        if (!getDataView().isDeferredStats()) {
+          getCachePerfStats().endPut(startPut, false);
+        }
+        return null;
+      }
+    } catch (EntryNotFoundException ignore) {
+      return event.getOldValue();
+    } finally {
+      event.release();
+    }
-    return replaceTimer.record(() -> replace(key, oldValue, newValue, null));
+    return replace(key, oldValue, newValue, null);
-    return replaceTimer.record(() -> replaceWithCallbackArgument(key, value, null));
+    return replaceWithCallbackArgument(key, value, null);

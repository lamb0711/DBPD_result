GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-/*
- * RangeIndex.java
- *
- * Created on February 4, 2005, 11:10 AM
- */
+import static java.lang.Integer.*;
+
-/**
- */
+
+
+
+
-  // @todo need more specific list of exceptions
+  // TODO: need more specific list of exceptions
-  void instantiateEvaluator(IndexCreationHelper ich) {
-    this.evaluator = new IMQEvaluator(ich);
+  void instantiateEvaluator(IndexCreationHelper indexCreationHelper) {
+    this.evaluator = new IMQEvaluator(indexCreationHelper);
-  //// AbstractIndex implementation
-
+                // TODO: non-atomic operation on volatile int
+                  // TODO: non-atomic operation on volatile int
-      Iterator valuesIter = ((Collection) oldkeys).iterator();
+      Iterator valuesIter = ((Iterable) oldkeys).iterator();
+          // TODO: non-atomic operation on volatile int
-      Iterator valuesIter = ((Collection) values).iterator();
+      Iterator valuesIter = ((Iterable) values).iterator();
-            size = Integer.MAX_VALUE;
+            size = MAX_VALUE;
-            size = Integer.MAX_VALUE;
+            size = MAX_VALUE;
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-              LocalizedStrings.RangeIndex_OPERATOR_0.toLocalizedString(Integer.valueOf(operator)));
+              LocalizedStrings.RangeIndex_OPERATOR_0.toLocalizedString(valueOf(operator)));
-    if (verifyLimit(result, limit, context)) {
+    if (verifyLimit(result, limit)) {
-      if (((SortedMap) entriesMap).isEmpty()) { // bug#40514
+      if (((Map) entriesMap).isEmpty()) { // bug#40514
-          if (verifyLimit(result, limit, context)) {
+          if (verifyLimit(result, limit)) {
-    if (verifyLimit(result, limit, context)) {
+    if (verifyLimit(result, limit)) {
-    Iterator entriesIter = ((SortedMap) entriesMap).entrySet().iterator();
+    Iterator entriesIter = ((Map) entriesMap).entrySet().iterator();
-        if (verifyLimit(result, limit, context)) {
+        if (verifyLimit(result, limit)) {
-    if (entriesMap == null || result == null
-        || (limitApplied = verifyLimit(result, limit, context))) {
-      if (limitApplied) {
+    if (entriesMap == null || result == null) {
+      if (verifyLimit(result, limit)) {
-      Iterator entriesIter = ((SortedMap) entriesMap).entrySet().iterator();
+      Iterator entriesIter = ((Map) entriesMap).entrySet().iterator();
-          if (verifyLimit(result, limit, context)) {
+          if (verifyLimit(result, limit)) {
-    if (applyLimit != null && applyLimit.booleanValue()) {
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    if (applyLimit != null && applyLimit) {
+      limit = (Integer) context.cacheGet(CompiledValue.RESULT_LIMIT);
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-    StringBuffer sb = new StringBuffer(toString()).append(" {\n");
+    StringBuilder sb = new StringBuilder(toString()).append(" {\n");
-      sb.append(" Key = " + indexEntry.getKey()).append("\n");
-      sb.append(" Value Type = ").append(" " + indexEntry.getValue().getClass().getName())
+      sb.append(" Key = ").append(indexEntry.getKey()).append("\n");
+      sb.append(" Value Type = ").append(" ").append(indexEntry.getValue().getClass().getName())
-        sb.append(" Value Size = ").append(" " + ((Map) indexEntry.getValue()).size()).append("\n");
+        sb.append(" Value Size = ").append(" ").append(((Map) indexEntry.getValue()).size())
+            .append("\n");
-
-
-
-
-    public long getUseTime() {
-      return this.vsdStats.getUseTime();
-    }
-
-      StringBuffer sb = new StringBuffer();
+      StringBuilder sb = new StringBuilder();

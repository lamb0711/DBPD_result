Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalDistributedSystem.java

+import com.gemstone.gemfire.cache.client.internal.*;
+
+  /**
+   * getNetworkHopType byte indicating this was the bucket owner for
+   * the last operation
+   */
+  public static final int NETWORK_HOP_NONE = 0;
+
+  /**
+   * getNetworkHopType byte indicating this was not the bucket owner and
+   * a message had to be sent to a primary in the same server group
+   */
+  public static final int NETWORK_HOP_TO_SAME_GROUP = 1;
+
+  /**
+   * getNetworkHopType byte indicating this was not the bucket owner and
+   * a message had to be sent to a primary in a different server group
+   */
+  public static final int NETWORK_HOP_TO_DIFFERENT_GROUP = 2;
+
+  private ColocationLogger missingColocatedRegionLogger;
+
-  private final ThreadLocal<Byte> isNetworkHop = new ThreadLocal<Byte>() {
+  private final ThreadLocal<Byte> networkHopType = new ThreadLocal<Byte>() {
-      return Byte.valueOf((byte)0);
+      return Byte.valueOf((byte)NETWORK_HOP_NONE);
-  public void setIsNetworkHop(Byte value) {
-    this.isNetworkHop.set(value);
+  public void clearNetworkHopData() {
+    this.networkHopType.remove();
+    this.metadataVersion.remove();
+  }
+  
+  private void setNetworkHopType(Byte value) {
+    this.networkHopType.set(value);
-  public Byte isNetworkHop() {
-    return this.isNetworkHop.get();
+  /**
+   * <p>
+   * If the last operation in the current thread required a one-hop to
+   * another server who held the primary bucket for the operation then
+   * this will return something other than NETWORK_HOP_NONE.
+   * </p>
+   * see NETWORK_HOP_NONE, NETWORK_HOP_TO_SAME_GROUP and NETWORK_HOP_TO_DIFFERENT_GROUP
+   */
+  public byte getNetworkHopType() {
+    return this.networkHopType.get().byteValue();
-      return 0;
+      return ClientMetadataService.INITIAL_VERSION;
-  public void setMetadataVersion(Byte value) {
+  private void setMetadataVersion(Byte value) {
-  public Byte getMetadataVersion() {
-    return this.metadataVersion.get();
+  public byte getMetadataVersion() {
+    return this.metadataVersion.get().byteValue();
-            setNetworkHop(bucketIdInt, (InternalDistributedMember)targetNode);
+            setNetworkHopType(bucketIdInt, (InternalDistributedMember)targetNode);
-        setNetworkHop(bucketId, targetNode);
+        setNetworkHopType(bucketId, targetNode);
-            setNetworkHop(bucketId, (InternalDistributedMember)retryNode);
+            setNetworkHopType(bucketId, (InternalDistributedMember)retryNode);
-            setNetworkHop(bucketId, currentTarget);
+            setNetworkHopType(bucketId, currentTarget);
-  private void setNetworkHop(final Integer bucketId,
-      final InternalDistributedMember targetNode) {
+  private void setNetworkHopType(final Integer bucketId,
+                                 final InternalDistributedMember targetNode) {
-              if (this.isNetworkHop() != 1 && logger.isDebugEnabled()) {
+              if (this.getNetworkHopType() != NETWORK_HOP_TO_SAME_GROUP && logger.isDebugEnabled()) {
-              this.setIsNetworkHop((byte)1);
+              this.setNetworkHopType((byte)NETWORK_HOP_TO_SAME_GROUP);
-              if (this.isNetworkHop() != 2 && logger.isDebugEnabled()) {
+              if (this.getNetworkHopType() != NETWORK_HOP_TO_DIFFERENT_GROUP && logger.isDebugEnabled()) {
-              this.setIsNetworkHop((byte)2);
+              this.setNetworkHopType((byte)NETWORK_HOP_TO_DIFFERENT_GROUP);
+  private void stopMissingColocatedRegionLogger() {
+    if (missingColocatedRegionLogger != null) {
+      missingColocatedRegionLogger.stopLogger();
+    }
+    missingColocatedRegionLogger = null;
+  }
+
+  public void addMissingColocatedRegionLogger() {
+    if (missingColocatedRegionLogger == null) {
+      missingColocatedRegionLogger = new ColocationLogger(this);
+    }
+  }
+
+  public void addMissingColocatedRegionLogger(String childName) {
+    if (missingColocatedRegionLogger == null) {
+      missingColocatedRegionLogger = new ColocationLogger(this);
+    }
+    missingColocatedRegionLogger.addMissingChildRegion(childName);
+  }
+
+  public void addMissingColocatedRegionLogger(PartitionedRegion childRegion) {
+    if (missingColocatedRegionLogger == null) {
+      missingColocatedRegionLogger = new ColocationLogger(this);
+    }
+    missingColocatedRegionLogger.addMissingChildRegions(childRegion);
+  }
+
+  public List<String> getMissingColocatedChildren() {
+    ColocationLogger regionLogger = missingColocatedRegionLogger;
+    if (regionLogger != null) {
+      return regionLogger.getMissingChildRegions();
+    }
+    return Collections.emptyList();
+  }
+
+    stopMissingColocatedRegionLogger();

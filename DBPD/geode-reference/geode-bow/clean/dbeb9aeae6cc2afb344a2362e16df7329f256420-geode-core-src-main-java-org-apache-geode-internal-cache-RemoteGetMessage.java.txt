Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * {@link org.apache.geode.cache.Region#get(Object)}operation. The reply is
- * sent in a {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}. 
+ * {@link org.apache.geode.cache.Region#get(Object)}operation. The reply is sent in a
+ * {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}.
-public final class RemoteGetMessage extends RemoteOperationMessageWithDirectReply
-  {
+public final class RemoteGetMessage extends RemoteOperationMessageWithDirectReply {
-  
+
-  
+
-  public RemoteGetMessage() {
-  }
-  
+  public RemoteGetMessage() {}
+
-      DirectReplyProcessor processor,
-      final Object key, final Object aCallbackArgument, ClientProxyMembershipID context) {
+      DirectReplyProcessor processor, final Object key, final Object aCallbackArgument,
+      ClientProxyMembershipID context) {
-  final public int getProcessorType()
-  {
-      return DistributionManager.SERIAL_EXECUTOR;
-    }
+  final public int getProcessorType() {
+    return DistributionManager.SERIAL_EXECUTOR;
+  }
-  
+
-  protected final boolean operateOnRegion(
-      final DistributionManager dm, LocalRegion r, long startTime)
-      throws RemoteOperationException
-  {
+  protected final boolean operateOnRegion(final DistributionManager dm, LocalRegion r,
+      long startTime) throws RemoteOperationException {
-    
-    if ( ! (r instanceof PartitionedRegion) ) { // prs already wait on initialization
+
+    if (!(r instanceof PartitionedRegion)) { // prs already wait on initialization
-      try {
-        KeyInfo keyInfo = r.getKeyInfo(key, cbArg);
-        val = r.getDataView().getSerializedValue(r, keyInfo, false, this.context, null, false /*for replicate regions*/);
-        valueBytes = val instanceof RawValue ? (RawValue)val : new RawValue(val);
+    try {
+      KeyInfo keyInfo = r.getKeyInfo(key, cbArg);
+      val = r.getDataView().getSerializedValue(r, keyInfo, false, this.context, null,
+          false /* for replicate regions */);
+      valueBytes = val instanceof RawValue ? (RawValue) val : new RawValue(val);
-        if (logger.isTraceEnabled(LogMarker.DM)) {
-          logger.trace(LogMarker.DM, "GetMessage sending serialized value {} back via GetReplyMessage using processorId: {}",
-                       valueBytes, getProcessorId());
-        }
-      
-        //      r.getPrStats().endPartitionMessagesProcessing(startTime); 
-        GetReplyMessage.send(getSender(), getProcessorId(), valueBytes, getReplySender(dm));
+      if (logger.isTraceEnabled(LogMarker.DM)) {
+        logger.trace(LogMarker.DM,
+            "GetMessage sending serialized value {} back via GetReplyMessage using processorId: {}",
+            valueBytes, getProcessorId());
+      }
-        // Unless there was an exception thrown, this message handles sending the
-        // response
-        return false;
-      } 
-      catch(DistributedSystemDisconnectedException sde) {
-        sendReply(getSender(), this.processorId, dm, new ReplyException(new RemoteOperationException(LocalizedStrings.GetMessage_OPERATION_GOT_INTERRUPTED_DUE_TO_SHUTDOWN_IN_PROGRESS_ON_REMOTE_VM.toLocalizedString(), sde)), r, startTime);
-        return false;
-      }
-      catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        return false;
-      }
-      catch (DataLocationException e) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(e), r, startTime);
-        return false;
-      }finally {
-        OffHeapHelper.release(val);
-      }
+      // r.getPrStats().endPartitionMessagesProcessing(startTime);
+      GetReplyMessage.send(getSender(), getProcessorId(), valueBytes, getReplySender(dm));
+
+      // Unless there was an exception thrown, this message handles sending the
+      // response
+      return false;
+    } catch (DistributedSystemDisconnectedException sde) {
+      sendReply(getSender(), this.processorId, dm,
+          new ReplyException(new RemoteOperationException(
+              LocalizedStrings.GetMessage_OPERATION_GOT_INTERRUPTED_DUE_TO_SHUTDOWN_IN_PROGRESS_ON_REMOTE_VM
+                  .toLocalizedString(),
+              sde)),
+          r, startTime);
+      return false;
+    } catch (PrimaryBucketException pbe) {
+      sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
+      return false;
+    } catch (DataLocationException e) {
+      sendReply(getSender(), getProcessorId(), dm, new ReplyException(e), r, startTime);
+      return false;
+    } finally {
+      OffHeapHelper.release(val);
+    }
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-  public void setKey(Object key)
-  {
+  public void setKey(Object key) {
-   * Sends a ReplicateRegion
-   * {@link org.apache.geode.cache.Region#get(Object)} message   
+   * Sends a ReplicateRegion {@link org.apache.geode.cache.Region#get(Object)} message
-   * @param recipient
-   *          the member that the get message is sent to
-   * @param r
-   *          the ReplicateRegion for which get was performed upon
-   * @param key
-   *          the object to which the value should be feteched
+   * @param recipient the member that the get message is sent to
+   * @param r the ReplicateRegion for which get was performed upon
+   * @param key the object to which the value should be feteched
-   * @return the processor used to fetch the returned value associated with the
-   *         key
+   * @return the processor used to fetch the returned value associated with the key
-  public static RemoteGetResponse send(InternalDistributedMember recipient,
-      LocalRegion r, final Object key, final Object aCallbackArgument, ClientProxyMembershipID requestingClient)
-      throws RemoteOperationException
-  {
-    Assert.assertTrue(recipient != null,
-        "PRDistribuedGetReplyMessage NULL reply message");
-    RemoteGetResponse p = new RemoteGetResponse(r.getSystem(), Collections.singleton(recipient), key);
-    RemoteGetMessage m = new RemoteGetMessage(recipient, r.getFullPath(), p,
-        key, aCallbackArgument, requestingClient);
+  public static RemoteGetResponse send(InternalDistributedMember recipient, LocalRegion r,
+      final Object key, final Object aCallbackArgument, ClientProxyMembershipID requestingClient)
+      throws RemoteOperationException {
+    Assert.assertTrue(recipient != null, "PRDistribuedGetReplyMessage NULL reply message");
+    RemoteGetResponse p =
+        new RemoteGetResponse(r.getSystem(), Collections.singleton(recipient), key);
+    RemoteGetMessage m = new RemoteGetMessage(recipient, r.getFullPath(), p, key, aCallbackArgument,
+        requestingClient);
-      throw new RemoteOperationException(LocalizedStrings.GetMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new RemoteOperationException(
+          LocalizedStrings.GetMessage_FAILED_SENDING_0.toLocalizedString(m));
-   * {@link org.apache.geode.cache.Region#get(Object)}operation This is the
-   * reply to a {@link RemoteGetMessage}.
+   * {@link org.apache.geode.cache.Region#get(Object)}operation This is the reply to a
+   * {@link RemoteGetMessage}.
-   * Since the {@link org.apache.geode.cache.Region#get(Object)}operation
-   * is used <bold>very </bold> frequently the performance of this class is
-   * critical.
+   * Since the {@link org.apache.geode.cache.Region#get(Object)}operation is used <bold>very </bold>
+   * frequently the performance of this class is critical.
-  public static final class GetReplyMessage extends ReplyMessage
-   {
-    /** 
-     * The raw value in the cache which may be serialized to the output stream, if 
-     * it is NOT already a byte array 
+  public static final class GetReplyMessage extends ReplyMessage {
+    /**
+     * The raw value in the cache which may be serialized to the output stream, if it is NOT already
+     * a byte array
-    /** Indicates that the value already a byte array (aka user blob) and does 
-     * not need de-serialization
+    /**
+     * Indicates that the value already a byte array (aka user blob) and does not need
+     * de-serialization
-    
+
-     * Used on the fromData side to transfer the value bytes to the requesting
-     * thread
+     * Used on the fromData side to transfer the value bytes to the requesting thread
-    public GetReplyMessage() {
-    }
+    public GetReplyMessage() {}
-    
+
-     * Return the value from the get operation, serialize it bytes as late as
-     * possible to avoid making un-neccesary byte[] copies.  De-serialize those 
-     * same bytes as late as possible to avoid using precious threads (aka P2P readers). 
+     * Return the value from the get operation, serialize it bytes as late as possible to avoid
+     * making un-neccesary byte[] copies. De-serialize those same bytes as late as possible to avoid
+     * using precious threads (aka P2P readers).
+     * 
-     * @param val the raw value that will eventually be serialized 
+     * @param val the raw value that will eventually be serialized
-    public static void send(InternalDistributedMember recipient, 
-        int processorId, RawValue val, ReplySender replySender)
-        throws RemoteOperationException
-    {
-      Assert.assertTrue(recipient != null,
-          "PRDistribuedGetReplyMessage NULL reply message");
+    public static void send(InternalDistributedMember recipient, int processorId, RawValue val,
+        ReplySender replySender) throws RemoteOperationException {
+      Assert.assertTrue(recipient != null, "PRDistribuedGetReplyMessage NULL reply message");
-     * Processes this message. This method is invoked by the receiver of the
-     * message.
+     * Processes this message. This method is invoked by the receiver of the message.
-     * @param dm
-     *          the distribution manager that is processing the message.
+     * @param dm the distribution manager that is processing the message.
-    public void process(final DM dm, ReplyProcessor21 processor)
-    {
+    public void process(final DM dm, ReplyProcessor21 processor) {
-      
+
-        logger.trace(LogMarker.DM, "GetReplyMessage process invoking reply processor with processorId:{}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "GetReplyMessage process invoking reply processor with processorId:{}",
+            this.processorId);
-    public void toData(DataOutput out) throws IOException
-    {
+    public void toData(DataOutput out) throws IOException {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException
-    {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-        this.remoteVersion = InternalDataSerializer
-            .getVersionForDataStreamOrNull(in);
+        this.remoteVersion = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-    public String toString()
-    {
+    public String toString() {
-      sb.append("GetReplyMessage ").append("processorid=").append(
-          this.processorId).append(" reply to sender ")
-          .append(this.getSender())
-          .append(" returning serialized value=")
-          .append(this.rawVal);
+      sb.append("GetReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" reply to sender ").append(this.getSender())
+          .append(" returning serialized value=").append(this.rawVal);
-   * A processor to capture the value returned by {@link 
-   * org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}
+   * A processor to capture the value returned by
+   * {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}
-    public void process(DistributionMessage msg)
-    {
+    public void process(DistributionMessage msg) {
-        GetReplyMessage reply = (GetReplyMessage)msg;
+        GetReplyMessage reply = (GetReplyMessage) msg;
-    
+
-     * De-seralize the value, if the value isn't already a byte array, this 
-     * method should be called in the context of the requesting thread for the
-     * best scalability
-     * @param preferCD 
+     * De-seralize the value, if the value isn't already a byte array, this method should be called
+     * in the context of the requesting thread for the best scalability
+     * 
+     * @param preferCD
-    public Object getValue(boolean preferCD) throws RemoteOperationException
-    {
+    public Object getValue(boolean preferCD) throws RemoteOperationException {
-          }
-          else if (preferCD) {
+          } else if (preferCD) {
-          }
-          else {
-            return BlobHelper.deserializeBlob(reply.valueInBytes,
-                reply.remoteVersion, null);
+          } else {
+            return BlobHelper.deserializeBlob(reply.valueInBytes, reply.remoteVersion, null);
-      }
-      catch (IOException e) {
-        throw new RemoteOperationException(LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_IOEXCEPTION.toLocalizedString(), e);
-      }
-      catch (ClassNotFoundException e) {
-        throw new RemoteOperationException(LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_CLASSNOTFOUNDEXCEPTION.toLocalizedString(), e);
+      } catch (IOException e) {
+        throw new RemoteOperationException(
+            LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_IOEXCEPTION.toLocalizedString(),
+            e);
+      } catch (ClassNotFoundException e) {
+        throw new RemoteOperationException(
+            LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_CLASSNOTFOUNDEXCEPTION
+                .toLocalizedString(),
+            e);
-    public Object waitForResponse(boolean preferCD) 
-        throws RemoteOperationException {
+    public Object waitForResponse(boolean preferCD) throws RemoteOperationException {
-//        waitForRepliesUninterruptibly();
-          waitForCacheException();
-          if (DistributionStats.enableClockStats) {
-            getDistributionManager().getStats().incReplyHandOffTime(this.start);
-          }
-      }
-      catch (RemoteOperationException e) {
+        // waitForRepliesUninterruptibly();
+        waitForCacheException();
+        if (DistributionStats.enableClockStats) {
+          getDistributionManager().getStats().incReplyHandOffTime(this.start);
+        }
+      } catch (RemoteOperationException e) {
-        throw new RemoteOperationException(LocalizedStrings.GetMessage_NO_RETURN_VALUE_RECEIVED.toLocalizedString());
+        throw new RemoteOperationException(
+            LocalizedStrings.GetMessage_NO_RETURN_VALUE_RECEIVED.toLocalizedString());

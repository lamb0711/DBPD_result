GEODE-1751: putting security checks in all applicable client-server commands.

-import java.io.Serializable;
-import com.gemstone.gemfire.i18n.LogWriterI18n;
+import com.gemstone.gemfire.internal.security.GeodeSecurityUtil;
- * 
- *  @since GemFire 6.5
+ * @since GemFire 6.5
-  public void cmdExecute(Message msg, ServerConnection servConn, long start)
-      throws IOException {
+  public void cmdExecute(Message msg, ServerConnection servConn, long start) throws IOException {
-      if(functionState != 1) {
+      if (functionState != 1) {
-      }
-      else  {
+      } else {
-          memberMappedArg = (MemberMappedArgument)obj;
+          memberMappedArg = (MemberMappedArgument) obj;
-      
+
-      
-      if(removedNodesSize != 0){
+
+      if (removedNodesSize != 0) {
-        
+
-      
-    }
-    catch (ClassNotFoundException exception) {
+
+    } catch (ClassNotFoundException exception) {
-    else {
-      Region region = crHelper.getRegion(regionName);
-      if (region == null) {
-        String message = 
-          LocalizedStrings.ExecuteRegionFunction_THE_REGION_NAMED_0_WAS_NOT_FOUND_DURING_EXECUTE_FUNCTION_REQUEST
-          .toLocalizedString(regionName);
-        logger.warn("{}: {}", servConn.getName(), message);
-        sendError(hasResult, msg, message, servConn);
-        return;
-      }
-      HandShake handShake = (HandShake)servConn.getHandshake();
-      int earlierClientReadTimeout = handShake.getClientReadTimeout();
-      handShake.setClientReadTimeout(0);
-      ServerToClientFunctionResultSender resultSender = null;
-      Function functionObject = null;
-      try { 
-        if (function instanceof String) {
-          functionObject = FunctionService.getFunction((String)function);
-          if (functionObject == null) {
-            String message = LocalizedStrings.
-              ExecuteRegionFunction_THE_FUNCTION_0_HAS_NOT_BEEN_REGISTERED
-                .toLocalizedString(function);
+
+    Region region = crHelper.getRegion(regionName);
+    if (region == null) {
+      String message = LocalizedStrings.ExecuteRegionFunction_THE_REGION_NAMED_0_WAS_NOT_FOUND_DURING_EXECUTE_FUNCTION_REQUEST
+        .toLocalizedString(regionName);
+      logger.warn("{}: {}", servConn.getName(), message);
+      sendError(hasResult, msg, message, servConn);
+      return;
+    }
+
+    HandShake handShake = (HandShake) servConn.getHandshake();
+    int earlierClientReadTimeout = handShake.getClientReadTimeout();
+    handShake.setClientReadTimeout(0);
+    ServerToClientFunctionResultSender resultSender = null;
+    Function functionObject = null;
+    try {
+      if (function instanceof String) {
+        functionObject = FunctionService.getFunction((String) function);
+        if (functionObject == null) {
+          String message = LocalizedStrings.
+            ExecuteRegionFunction_THE_FUNCTION_0_HAS_NOT_BEEN_REGISTERED.toLocalizedString(function);
+          logger.warn("{}: {}", servConn.getName(), message);
+          sendError(hasResult, msg, message, servConn);
+          return;
+        } else {
+          byte functionStateOnServerSide = AbstractExecution.getFunctionState(functionObject.isHA(), functionObject.hasResult(), functionObject
+            .optimizeForWrite());
+          if (logger.isDebugEnabled()) {
+            logger.debug("Function State on server side: {} on client: {}", functionStateOnServerSide, functionState);
+          }
+          if (functionStateOnServerSide != functionState) {
+            String message = LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER.toLocalizedString(function);
-          else {
-            byte functionStateOnServerSide = AbstractExecution.getFunctionState(
-                functionObject.isHA(), functionObject.hasResult(),
-                functionObject.optimizeForWrite());
-            if (logger.isDebugEnabled()) {
-              logger.debug("Function State on server side: {} on client: {}", functionStateOnServerSide, functionState);
-            }
-            if (functionStateOnServerSide != functionState) {
-              String message = LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER
-                  .toLocalizedString(function);
-              logger.warn("{}: {}", servConn.getName(), message);
-              sendError(hasResult, msg, message, servConn);
-              return;
-            }
-          }
-        else {
-          functionObject = (Function)function;
-        }
-        // check if the caller is authorized to do this operation on server
-        AuthorizeRequest authzRequest = servConn.getAuthzRequest();
-        final String functionName = functionObject.getId();
-        final String regionPath = region.getFullPath();
-        ExecuteFunctionOperationContext executeContext = null;
-        if (authzRequest != null) {
-          executeContext = authzRequest.executeFunctionAuthorize(functionName,
-              regionPath, filter, args, functionObject.optimizeForWrite());
-        }
-        
-        //Construct execution 
-        AbstractExecution execution = (AbstractExecution)FunctionService.onRegion(region);
-        ChunkedMessage m = servConn.getFunctionResponseMessage();
-        m.setTransactionId(msg.getTransactionId());        
-        resultSender = new ServerToClientFunctionResultSender65(m,
-            MessageType.EXECUTE_REGION_FUNCTION_RESULT, servConn,functionObject,executeContext);
-        
-        
-        if (execution instanceof PartitionedRegionFunctionExecutor) {
-          execution = new PartitionedRegionFunctionExecutor(
-              (PartitionedRegion)region, filter, args, memberMappedArg,
-              resultSender, removedNodesSet, false);
-        }
-        else {
-          execution = new DistributedRegionFunctionExecutor(
-              (DistributedRegion)region, filter, args, memberMappedArg,
-              resultSender);          
-        }
-        if (isReExecute == 1) {
-          execution = execution.setIsReExecute();
-        }
-        if (logger.isDebugEnabled()) {
-          logger.debug("Executing Function: {} on Server: {} with Execution: {} functionState={} reexecute={} hasResult={}", functionObject.getId(), servConn, execution, functionState, isReExecute, hasResult);
-        }
-        if (hasResult == 1) {
-          if (function instanceof String) {
-            switch (functionState) {
-              case AbstractExecution.NO_HA_HASRESULT_NO_OPTIMIZEFORWRITE:
-                execution.execute((String)function, true, false, false).getResult();
-                break;
-              case AbstractExecution.HA_HASRESULT_NO_OPTIMIZEFORWRITE:
-                execution.execute((String)function, true, true, false).getResult();
-                break;
-              case AbstractExecution.HA_HASRESULT_OPTIMIZEFORWRITE:
-                execution.execute((String)function,true, true, true).getResult();
-                break;
-              case AbstractExecution.NO_HA_HASRESULT_OPTIMIZEFORWRITE:
-                execution.execute((String)function, true, false, true).getResult();
-                break;
-            }
-          }
-          else {
-            execution.execute(functionObject).getResult();
-          }
-        }else {
-          if (function instanceof String) {
-            switch (functionState) {
-              case AbstractExecution.NO_HA_NO_HASRESULT_NO_OPTIMIZEFORWRITE:
-                execution.execute((String)function, false, false, false);
-                break;
-              case AbstractExecution.NO_HA_NO_HASRESULT_OPTIMIZEFORWRITE:
-                execution.execute((String)function, false, false, true);
-                break;
-            }
-          }
-          else {
-            execution.execute(functionObject);
-          }
-        }
+      } else {
+        functionObject = (Function) function;
-      catch (IOException ioe) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), ioe);
-        final String message = LocalizedStrings.
-          ExecuteRegionFunction_SERVER_COULD_NOT_SEND_THE_REPLY
-            .toLocalizedString();
-        sendException(hasResult, msg, message, servConn,ioe);
-      }
-      catch (FunctionException fe) {
-        String message = fe.getMessage();
-        
-        if (fe.getCause() instanceof FunctionInvocationTargetException) {
-          if (fe.getCause() instanceof InternalFunctionInvocationTargetException) {
-            // Fix for #44709: User should not be aware of
-            // InternalFunctionInvocationTargetException. No instance of
-            // InternalFunctionInvocationTargetException is giving useful
-            // information to user to take any corrective action hence logging
-            // this at fine level logging
-            // 1> When bucket is moved
-            // 2> Incase of HA FucntionInvocationTargetException thrown. Since
-            // it is HA, fucntion will be reexecuted on right node
-            // 3> Multiple target nodes found for single hop operation
-            // 4> in case of HA member departed
-            if (logger.isDebugEnabled()) {
-              logger.debug(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, new Object[] { function }), fe);
-            }
-          }
-          else if (functionObject.isHA()) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function + " :" + message));
-          }
-          else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), fe);
-          }
-          resultSender.setException(fe);
+      GeodeSecurityUtil.authorizeFunctionExec(functionObject.getId());
+
+      // check if the caller is authorized to do this operation on server
+      AuthorizeRequest authzRequest = servConn.getAuthzRequest();
+      final String functionName = functionObject.getId();
+      final String regionPath = region.getFullPath();
+      ExecuteFunctionOperationContext executeContext = null;
+      if (authzRequest != null) {
+        executeContext = authzRequest.executeFunctionAuthorize(functionName, regionPath, filter, args, functionObject.optimizeForWrite());
+      }
+
+      //Construct execution
+      AbstractExecution execution = (AbstractExecution) FunctionService.onRegion(region);
+      ChunkedMessage m = servConn.getFunctionResponseMessage();
+      m.setTransactionId(msg.getTransactionId());
+      resultSender = new ServerToClientFunctionResultSender65(m, MessageType.EXECUTE_REGION_FUNCTION_RESULT, servConn, functionObject, executeContext);
+
+
+      if (execution instanceof PartitionedRegionFunctionExecutor) {
+        execution = new PartitionedRegionFunctionExecutor((PartitionedRegion) region, filter, args, memberMappedArg, resultSender, removedNodesSet, false);
+      } else {
+        execution = new DistributedRegionFunctionExecutor((DistributedRegion) region, filter, args, memberMappedArg, resultSender);
+      }
+      if (isReExecute == 1) {
+        execution = execution.setIsReExecute();
+      }
+      if (logger.isDebugEnabled()) {
+        logger.debug("Executing Function: {} on Server: {} with Execution: {} functionState={} reexecute={} hasResult={}", functionObject
+          .getId(), servConn, execution, functionState, isReExecute, hasResult);
+      }
+      if (hasResult == 1) {
+        if (function instanceof String) {
+          switch (functionState) {
+            case AbstractExecution.NO_HA_HASRESULT_NO_OPTIMIZEFORWRITE:
+              execution.execute((String) function, true, false, false).getResult();
+              break;
+            case AbstractExecution.HA_HASRESULT_NO_OPTIMIZEFORWRITE:
+              execution.execute((String) function, true, true, false).getResult();
+              break;
+            case AbstractExecution.HA_HASRESULT_OPTIMIZEFORWRITE:
+              execution.execute((String) function, true, true, true).getResult();
+              break;
+            case AbstractExecution.NO_HA_HASRESULT_OPTIMIZEFORWRITE:
+              execution.execute((String) function, true, false, true).getResult();
+              break;
+          }
+        } else {
+          execution.execute(functionObject).getResult();
-        else {
+      } else {
+        if (function instanceof String) {
+          switch (functionState) {
+            case AbstractExecution.NO_HA_NO_HASRESULT_NO_OPTIMIZEFORWRITE:
+              execution.execute((String) function, false, false, false);
+              break;
+            case AbstractExecution.NO_HA_NO_HASRESULT_OPTIMIZEFORWRITE:
+              execution.execute((String) function, false, false, true);
+              break;
+          }
+        } else {
+          execution.execute(functionObject);
+        }
+      }
+    } catch (IOException ioe) {
+      logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), ioe);
+      final String message = LocalizedStrings.
+        ExecuteRegionFunction_SERVER_COULD_NOT_SEND_THE_REPLY.toLocalizedString();
+      sendException(hasResult, msg, message, servConn, ioe);
+    } catch (FunctionException fe) {
+      String message = fe.getMessage();
+
+      if (fe.getCause() instanceof FunctionInvocationTargetException) {
+        if (fe.getCause() instanceof InternalFunctionInvocationTargetException) {
+          // Fix for #44709: User should not be aware of
+          // InternalFunctionInvocationTargetException. No instance of
+          // InternalFunctionInvocationTargetException is giving useful
+          // information to user to take any corrective action hence logging
+          // this at fine level logging
+          // 1> When bucket is moved
+          // 2> Incase of HA FucntionInvocationTargetException thrown. Since
+          // it is HA, fucntion will be reexecuted on right node
+          // 3> Multiple target nodes found for single hop operation
+          // 4> in case of HA member departed
+          if (logger.isDebugEnabled()) {
+            logger.debug(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, new Object[] {
+              function
+            }), fe);
+          }
+        } else if (functionObject.isHA()) {
+          logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function + " :" + message));
+        } else {
-          sendException(hasResult, msg, message, servConn, fe);
-      }
-      catch (Exception e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), e);
-        String message = e.getMessage();
-        sendException(hasResult, msg, message, servConn,e);
+        resultSender.setException(fe);
+      } else {
+        logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), fe);
+        sendException(hasResult, msg, message, servConn, fe);
-      finally{
-        handShake.setClientReadTimeout(earlierClientReadTimeout);
-      }
+    } catch (Exception e) {
+      logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), e);
+      String message = e.getMessage();
+      sendException(hasResult, msg, message, servConn, e);
+    } finally {
+      handShake.setClientReadTimeout(earlierClientReadTimeout);
-  private void sendException(byte hasResult, Message msg, String message,
-      ServerConnection servConn, Throwable e) throws IOException {
+  private void sendException(byte hasResult, Message msg, String message, ServerConnection servConn, Throwable e)
+    throws IOException {
-        writeFunctionResponseException(msg, MessageType.EXCEPTION, message,
-            servConn, e);
+        writeFunctionResponseException(msg, MessageType.EXCEPTION, message, servConn, e);
-  
-  private void sendError(byte hasResult, Message msg, String message,
-      ServerConnection servConn) throws IOException {
+
+  private void sendError(byte hasResult, Message msg, String message, ServerConnection servConn) throws IOException {
-        writeFunctionResponseError(msg,
-            MessageType.EXECUTE_REGION_FUNCTION_ERROR, message, servConn);
+        writeFunctionResponseError(msg, MessageType.EXECUTE_REGION_FUNCTION_ERROR, message, servConn);
-  
+
-      int messageType, String message, ServerConnection servConn, Throwable e)
-      throws IOException {
+                                                       int messageType,
+                                                       String message,
+                                                       ServerConnection servConn,
+                                                       Throwable e) throws IOException {
-      if (e instanceof FunctionException
-          && e.getCause() instanceof InternalFunctionInvocationTargetException) {
+      if (e instanceof FunctionException && e.getCause() instanceof InternalFunctionInvocationTargetException) {
-        InternalFunctionInvocationTargetException fe = (InternalFunctionInvocationTargetException)e
-            .getCause();
+        InternalFunctionInvocationTargetException fe = (InternalFunctionInvocationTargetException) e.getCause();
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-      if (e instanceof FunctionException
-          && e.getCause() instanceof InternalFunctionInvocationTargetException) {
+      if (e instanceof FunctionException && e.getCause() instanceof InternalFunctionInvocationTargetException) {
-        InternalFunctionInvocationTargetException fe = (InternalFunctionInvocationTargetException)e
-            .getCause();
+        InternalFunctionInvocationTargetException fe = (InternalFunctionInvocationTargetException) e.getCause();
-      }
-      else {
+      } else {
-      chunkedResponseMsg.setLastChunkAndNumParts(true,numParts);
+      chunkedResponseMsg.setLastChunkAndNumParts(true, numParts);

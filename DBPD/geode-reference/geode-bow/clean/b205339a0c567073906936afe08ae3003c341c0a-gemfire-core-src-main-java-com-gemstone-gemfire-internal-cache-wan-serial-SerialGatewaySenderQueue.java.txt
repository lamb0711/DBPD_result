Merge branch 'feature/GEODE-8' into develop

+import java.util.concurrent.atomic.AtomicReference;
+import com.gemstone.gemfire.cache.CacheWriterException;
+import com.gemstone.gemfire.cache.RegionDestroyedException;
+import com.gemstone.gemfire.cache.TimeoutException;
+import com.gemstone.gemfire.internal.cache.RegionEventImpl;
+import com.gemstone.gemfire.internal.cache.versions.RegionVersionVector;
+import com.gemstone.gemfire.internal.cache.versions.VersionSource;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-    resetLastPeeked();
-    AsyncEvent object = peekAhead();
-    // If it is not null, destroy it and increment the head key
-    if (object != null) {
-      Long key = this.peekedIds.remove();
-      if (logger.isTraceEnabled()) {
-        logger.trace("{}: Retrieved {} -> {}",this, key, object);
-      }
-      // Remove the entry at that key with a callback arg signifying it is
-      // a WAN queue so that AbstractRegionEntry.destroy can get the value
-      // even if it has been evicted to disk. In the normal case, the
-      // AbstractRegionEntry.destroy only gets the value in the VM.
-      this.region.destroy(key, RegionQueue.WAN_QUEUE_TOKEN);
-      updateHeadKey(key.longValue());
+    // Unsupported since we have no callers.
+    // If we do want to support it then each caller needs
+    // to call freeOffHeapResources and the returned GatewaySenderEventImpl
+    throw new UnsupportedOperationException();
+//     resetLastPeeked();
+//     AsyncEvent object = peekAhead();
+//     // If it is not null, destroy it and increment the head key
+//     if (object != null) {
+//       Long key = this.peekedIds.remove();
+//       if (logger.isTraceEnabled()) {
+//         logger.trace("{}: Retrieved {} -> {}",this, key, object);
+//       }
+//       // Remove the entry at that key with a callback arg signifying it is
+//       // a WAN queue so that AbstractRegionEntry.destroy can get the value
+//       // even if it has been evicted to disk. In the normal case, the
+//       // AbstractRegionEntry.destroy only gets the value in the VM.
+//       this.region.destroy(key, RegionQueue.WAN_QUEUE_TOKEN);
+//       updateHeadKey(key.longValue());
-      if (logger.isTraceEnabled()) {
-        logger.trace("{}: Destroyed {} -> {}", this, key, object);
-      }
-    }
-    return object;
+//       if (logger.isTraceEnabled()) {
+//         logger.trace("{}: Destroyed {} -> {}", this, key, object);
+//       }
+//     }
+//     return object;
-    List<AsyncEvent> batch = new ArrayList<AsyncEvent>(
-        batchSize * 2);
-    for (int i = 0; i < batchSize; i++) {
-      AsyncEvent obj = take();
-      if (obj != null) {
-        batch.add(obj);
-      } else {
-        break;
-      }
-    }
-    if (logger.isTraceEnabled()) {
-      logger.trace("{}: Took a batch of {} entries", this, batch.size());
-    }
-    return batch;
+    // This method has no callers.
+    // If we do want to support it then the callers
+    // need to call freeOffHeapResources on each returned GatewaySenderEventImpl
+    throw new UnsupportedOperationException();
+//     List<AsyncEvent> batch = new ArrayList<AsyncEvent>(
+//         batchSize * 2);
+//     for (int i = 0; i < batchSize; i++) {
+//       AsyncEvent obj = take();
+//       if (obj != null) {
+//         batch.add(obj);
+//       } else {
+//         break;
+//       }
+//     }
+//     if (logger.isTraceEnabled()) {
+//       logger.trace("{}: Took a batch of {} entries", this, batch.size());
+//     }
+//     return batch;
+    // OFFHEAP returned object only used to see if queue is empty
+    // so no need to worry about off-heap refCount.
+      if (object != null && object instanceof GatewaySenderEventImpl) {
+        GatewaySenderEventImpl copy = ((GatewaySenderEventImpl)object).makeHeapCopyIfOffHeap();
+        if (copy == null) {
+          continue;
+        }
+        object = copy;
+      }
+    // OFFHEAP: all returned AsyncEvent end up being removed from queue after the batch is sent
+    // so no need to worry about off-heap refCount.
-                this, deserialize(previous.getValueToConflate()), deserialize(object.getValueToConflate()),
+                this, previous.getValueToConflate(), object.getValueToConflate(),
-  private Object deserialize(Object serializedBytes) {
-    Object deserializedObject = serializedBytes;
-    if (serializedBytes instanceof byte[]) {
-      byte[] serializedBytesCast = (byte[])serializedBytes;
-      // This is a debugging method so ignore all exceptions like
-      // ClassNotFoundException
-      try {
-        deserializedObject = EntryEventImpl.deserialize(serializedBytesCast);
-      } catch (Exception e) {
-      }
-    }
-    return deserializedObject;
-  }
-
-      if (logger.isDebugEnabled()) {
-        logger.debug("{}: Retrieved queue region: {}. Since the region already exists, the sender must have been restarted after being stopped. Clearing the region.",
-            this.region);
-        this.region.clear();
-      }
+      throw new IllegalStateException("Queue region " + this.region.getFullPath() + " already exists.");
+  @Override
+  public void close() {
+    Region r = getRegion();
+    if (r != null && !r.isDestroyed()) {
+      try {
+        r.close();
+      } catch (RegionDestroyedException e) {
+      }
+    }
+  }
+  
-            EntryEventImpl event = new EntryEventImpl((LocalRegion)region,
+            EntryEventImpl event = EntryEventImpl.create((LocalRegion)region,
+            event.disallowOffHeapValues();
-  static private class SerialGatewaySenderQueueMetaRegion extends
+  public static class SerialGatewaySenderQueueMetaRegion extends
+    @Override
+    public void closeEntries() {
+      OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
+        @Override
+        public void run() {
+          SerialGatewaySenderQueueMetaRegion.super.closeEntries();
+        }
+      });
+    }
+    @Override
+    public Set<VersionSource> clearEntries(final RegionVersionVector rvv) {
+      final AtomicReference<Set<VersionSource>> result = new AtomicReference<Set<VersionSource>>();
+      OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
+        @Override
+        public void run() {
+          result.set(SerialGatewaySenderQueueMetaRegion.super.clearEntries(rvv));
+        }
+      });
+      return result.get();
+    }
+    @Override
+    protected void basicDestroy(final EntryEventImpl event,
+        final boolean cacheWrite, Object expectedOldValue)
+        throws EntryNotFoundException, CacheWriterException, TimeoutException {
+
+      super.basicDestroy(event, cacheWrite, expectedOldValue);
+      GatewaySenderEventImpl.release(event.getRawOldValue());
+    }
+    @Override
+    protected boolean virtualPut(EntryEventImpl event, boolean ifNew,
+        boolean ifOld, Object expectedOldValue, boolean requireOldValue,
+        long lastModified, boolean overwriteDestroyed) throws TimeoutException,
+        CacheWriterException {
+      boolean success = super.virtualPut(event, ifNew, ifOld, expectedOldValue,
+          requireOldValue, lastModified, overwriteDestroyed);
+
+      if (success) {
+        GatewaySenderEventImpl.release(event.getRawOldValue());
+      }
+      return success;
+    }

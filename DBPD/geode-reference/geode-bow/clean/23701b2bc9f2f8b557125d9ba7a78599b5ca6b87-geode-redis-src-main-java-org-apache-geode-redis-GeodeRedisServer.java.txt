GEODE-7869: Cleanup warnings in geode-redis

-import io.netty.channel.oio.OioEventLoopGroup;
-import io.netty.channel.socket.oio.OioServerSocketChannel;
-import org.apache.geode.LogWriter;
-  private LogWriter logger;
+  @SuppressWarnings("deprecation")
+  private org.apache.geode.LogWriter logger;
-    this.serverPort = port <= 0 ? DEFAULT_REDIS_SERVER_PORT : port;
+    serverPort = port <= 0 ? DEFAULT_REDIS_SERVER_PORT : port;
-    this.numWorkerThreads = setNumWorkerThreads();
-    this.singleThreadPerConnection = this.numWorkerThreads == 0;
-    this.numSelectorThreads = 1;
-    this.metaListener = new MetaCacheListener();
-    this.expirationFutures = new ConcurrentHashMap<ByteArrayWrapper, ScheduledFuture<?>>();
-    this.expirationExecutor =
+    numWorkerThreads = setNumWorkerThreads();
+    singleThreadPerConnection = numWorkerThreads == 0;
+    numSelectorThreads = 1;
+    metaListener = new MetaCacheListener();
+    expirationFutures = new ConcurrentHashMap<>();
+    expirationExecutor =
-    this.DEFAULT_REGION_TYPE = setRegionType();
-    this.shutdown = false;
-    this.started = false;
+    DEFAULT_REGION_TYPE = setRegionType();
+    shutdown = false;
+    started = false;
-    return this.bindAddress == null || this.bindAddress.isEmpty() ? LocalHostUtil.getLocalHost()
-        : InetAddress.getByName(this.bindAddress);
+    return bindAddress == null || bindAddress.isEmpty() ? LocalHostUtil.getLocalHost()
+        : InetAddress.getByName(bindAddress);
-      } catch (IOException e) {
-        throw new RuntimeException("Could not start Server", e);
-      } catch (InterruptedException e) {
+      } catch (IOException | InterruptedException e) {
+  @SuppressWarnings("deprecation")
-    this.logger = cache.getLogger();
+    logger = cache.getLogger();
-    synchronized (this.cache) {
+    synchronized (cache) {
-            gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
+            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-            gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
+            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-            gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
+            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-            gemFireCache.createRegionFactory(this.DEFAULT_REGION_TYPE);
+            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-      this.keyRegistrar = new KeyRegistrar(redisMetaData);
-      this.hashLockService = new RedisLockService();
-      this.pubSub = new PubSubImpl(new Subscriptions());
-      this.regionCache = new RegionProvider(stringsRegion, hLLRegion, this.keyRegistrar,
-          expirationFutures, expirationExecutor, this.DEFAULT_REGION_TYPE, redisHash, redisSet);
+      keyRegistrar = new KeyRegistrar(redisMetaData);
+      hashLockService = new RedisLockService();
+      pubSub = new PubSubImpl(new Subscriptions());
+      regionCache = new RegionProvider(stringsRegion, hLLRegion, keyRegistrar,
+          expirationFutures, expirationExecutor, DEFAULT_REGION_TYPE, redisHash, redisSet);
-        platformMBeanServer.registerMBean(this.hashLockService, mbeanON);
+        platformMBeanServer.registerMBean(hashLockService, mbeanON);
-          this.regionCache
+          regionCache
-    Class<? extends ServerChannel> socketClass = null;
+    Class<? extends ServerChannel> socketClass;
-      bossGroup = new OioEventLoopGroup(Integer.MAX_VALUE, selectorThreadFactory);
-      workerGroup = new OioEventLoopGroup(Integer.MAX_VALUE, workerThreadFactory);
-      socketClass = OioServerSocketChannel.class;
+      socketClass =
+          startRedisServiceSingleThreadPerConnection(selectorThreadFactory, workerThreadFactory);
-      bossGroup = new NioEventLoopGroup(this.numSelectorThreads, selectorThreadFactory);
-      workerGroup = new NioEventLoopGroup(this.numWorkerThreads, workerThreadFactory);
+      bossGroup = new NioEventLoopGroup(numSelectorThreads, selectorThreadFactory);
+      workerGroup = new NioEventLoopGroup(numWorkerThreads, workerThreadFactory);
-          public void initChannel(SocketChannel ch) throws Exception {
+          public void initChannel(SocketChannel ch) {
-    if (this.logger.infoEnabled()) {
+    if (logger.infoEnabled()) {
-          + "}, Selector threads: " + this.numSelectorThreads;
-      if (this.singleThreadPerConnection) {
+          + "}, Selector threads: " + numSelectorThreads;
+      if (singleThreadPerConnection) {
-        logMessage += ", Worker threads: " + this.numWorkerThreads;
+        logMessage += ", Worker threads: " + numWorkerThreads;
-      this.logger.info(logMessage);
+      logger.info(logMessage);
-    this.serverChannel = f.channel();
+    serverChannel = f.channel();
+  }
+
+  @SuppressWarnings("deprecation")
+  private Class<? extends ServerChannel> startRedisServiceSingleThreadPerConnection(
+      ThreadFactory selectorThreadFactory, ThreadFactory workerThreadFactory) {
+    bossGroup =
+        new io.netty.channel.oio.OioEventLoopGroup(Integer.MAX_VALUE, selectorThreadFactory);
+    workerGroup =
+        new io.netty.channel.oio.OioEventLoopGroup(Integer.MAX_VALUE, workerThreadFactory);
+    return io.netty.channel.socket.oio.OioServerSocketChannel.class;
-      final String key = (String) event.getKey();
+      final String key = event.getKey();
-          this.regionCache.createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(key),
+          regionCache.createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(key),
-      final String key = (String) event.getKey();
+      final String key = event.getKey();
-        Region<?, ?> r = this.regionCache.getRegion(kW);
+        Region<?, ?> r = regionCache.getRegion(kW);
-          this.regionCache.removeRegionReferenceLocally(kW, value);
+          regionCache.removeRegionReferenceLocally(kW, value);
-      ChannelFuture closeFuture = this.serverChannel.closeFuture();
+      ChannelFuture closeFuture = serverChannel.closeFuture();
-      this.serverChannel.close();
+      serverChannel.close();
-      this.regionCache.close();
+      regionCache.close();
-      for (ScheduledFuture<?> f : this.expirationFutures.values()) {
+      for (ScheduledFuture<?> f : expirationFutures.values()) {
-      this.expirationFutures.clear();
-      this.expirationExecutor.shutdownNow();
+      expirationFutures.clear();
+      expirationExecutor.shutdownNow();
-      } catch (Exception e) {
+      } catch (Exception ignored) {

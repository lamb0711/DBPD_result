Merge remote-tracking branch 'upstream/develop' into develop

+import static org.apache.geode.distributed.internal.ClusterDistributionManager.FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.logging.LogService;
+  private static final Logger logger = LogService.getLogger();
+
+  private static final int OFFER_TIME =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "RETRY_INTERVAL", 5000).intValue();
+
-        public void rejectedExecution(final Runnable r, ThreadPoolExecutor executor) {
+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
-            // System.out.println("Asif: Rejection called");
-            if (Thread
-                .currentThread() == ((FunctionExecutionPooledExecutor) executor).bufferConsumer) {
-              Thread th = executor.getThreadFactory().newThread((new Runnable() {
-                public void run() {
-                  r.run();
-                }
-              }));
-              th.start();
+            if (isBufferConsumer(executor)) {
+              handleRejectedExecutionForBufferConsumer(r, executor);
+            } else if (isFunctionExecutionThread()) {
+              handleRejectedExecutionForFunctionExecutionThread(r, executor);
+              // In the normal case, add the rejected request to the blocking queue.
+
+        private boolean isBufferConsumer(ThreadPoolExecutor executor) {
+          return Thread
+              .currentThread() == ((FunctionExecutionPooledExecutor) executor).bufferConsumer;
+        }
+
+        private boolean isFunctionExecutionThread() {
+          return ClusterDistributionManager.isFunctionExecutionThread();
+        }
+
+        /**
+         * Handle rejected execution for the bufferConsumer (the thread that takes from the blocking
+         * queue and offers to the synchronous queue). Spin off a thread directly in this case,
+         * since an offer has already been made to the synchronous queue and failed. This means that
+         * all the function execution threads are in use.
+         */
+        private void handleRejectedExecutionForBufferConsumer(Runnable r,
+            ThreadPoolExecutor executor) {
+          logger.warn("An additional " + FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX
+              + " thread is being launched because all " + executor.getMaximumPoolSize()
+              + " thread pool threads are in use for greater than " + OFFER_TIME + " ms");
+          launchAdditionalThread(r, executor);
+        }
+
+        /**
+         * Handle rejected execution for a function execution thread. Spin off a thread directly in
+         * this case, since that means a function is executing another function. The child function
+         * request shouldn't be in the queue behind the parent request since the parent function is
+         * dependent on the child function executing.
+         */
+        private void handleRejectedExecutionForFunctionExecutionThread(Runnable r,
+            ThreadPoolExecutor executor) {
+          if (logger.isDebugEnabled()) {
+            logger.warn("An additional " + FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX
+                + " thread is being launched to prevent slow performance due to nested function executions");
+          }
+          launchAdditionalThread(r, executor);
+        }
+
+        private void launchAdditionalThread(Runnable r, ThreadPoolExecutor executor) {
+          Thread th = executor.getThreadFactory().newThread(r);
+          th.start();
+        }
-    final int retryFor =
-        Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "RETRY_INTERVAL", 5000).intValue();
-                if (!putQueue.offer(task, retryFor, TimeUnit.MILLISECONDS)) {
+                // In the function case, offer the request to the work queue.
+                // If it fails, execute it anyway. This will cause the RejectedExecutionHandler to
+                // spin off a thread for it.
+                if (!putQueue.offer(task, OFFER_TIME, TimeUnit.MILLISECONDS)) {
+                // In the non-function case, put the request on the work queue.

 GEODE-2668: build tabular command result from a list of function results  (#1127)

* GEODE-2668: build tabular command result from a list of function results

* reduce duplicate code to create the tabular results
* promote presentation consistency
* Add more validation for CreateGatewaySender/Receiver command and reworked the tests

-import java.util.concurrent.atomic.AtomicReference;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.TabularResultData;
-    try {
-      DiskStoreAttributes diskStoreAttributes = new DiskStoreAttributes();
-      diskStoreAttributes.allowForceCompaction = allowForceCompaction;
-      diskStoreAttributes.autoCompact = autoCompact;
-      diskStoreAttributes.compactionThreshold = compactionThreshold;
-      diskStoreAttributes.maxOplogSizeInBytes = maxOplogSize * (1024 * 1024);
-      diskStoreAttributes.queueSize = queueSize;
-      diskStoreAttributes.timeInterval = timeInterval;
-      diskStoreAttributes.writeBufferSize = writeBufferSize;
-      File[] directories = new File[directoriesAndSizes.length];
-      int[] sizes = new int[directoriesAndSizes.length];
-      for (int i = 0; i < directoriesAndSizes.length; i++) {
-        final int hashPosition = directoriesAndSizes[i].indexOf('#');
-        if (hashPosition == -1) {
-          directories[i] = new File(directoriesAndSizes[i]);
-          sizes[i] = Integer.MAX_VALUE;
-        } else {
-          directories[i] = new File(directoriesAndSizes[i].substring(0, hashPosition));
-          sizes[i] = Integer.parseInt(directoriesAndSizes[i].substring(hashPosition + 1));
-        }
+    DiskStoreAttributes diskStoreAttributes = new DiskStoreAttributes();
+    diskStoreAttributes.allowForceCompaction = allowForceCompaction;
+    diskStoreAttributes.autoCompact = autoCompact;
+    diskStoreAttributes.compactionThreshold = compactionThreshold;
+    diskStoreAttributes.maxOplogSizeInBytes = maxOplogSize * (1024 * 1024);
+    diskStoreAttributes.queueSize = queueSize;
+    diskStoreAttributes.timeInterval = timeInterval;
+    diskStoreAttributes.writeBufferSize = writeBufferSize;
+
+    File[] directories = new File[directoriesAndSizes.length];
+    int[] sizes = new int[directoriesAndSizes.length];
+    for (int i = 0; i < directoriesAndSizes.length; i++) {
+      final int hashPosition = directoriesAndSizes[i].indexOf('#');
+      if (hashPosition == -1) {
+        directories[i] = new File(directoriesAndSizes[i]);
+        sizes[i] = Integer.MAX_VALUE;
+      } else {
+        directories[i] = new File(directoriesAndSizes[i].substring(0, hashPosition));
+        sizes[i] = Integer.parseInt(directoriesAndSizes[i].substring(hashPosition + 1));
-      diskStoreAttributes.diskDirs = directories;
-      diskStoreAttributes.diskDirSizes = sizes;
-
-      diskStoreAttributes.setDiskUsageWarningPercentage(diskUsageWarningPercentage);
-      diskStoreAttributes.setDiskUsageCriticalPercentage(diskUsageCriticalPercentage);
-
-      TabularResultData tabularData = ResultBuilder.createTabularResultData();
-      boolean accumulatedData = false;
-
-      Set<DistributedMember> targetMembers = CliUtil.findMembers(groups, null);
-
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
-
-      ResultCollector<?, ?> rc = CliUtil.executeFunction(new CreateDiskStoreFunction(),
-          new Object[] {name, diskStoreAttributes}, targetMembers);
-      List<CliFunctionResult> results = CliFunctionResult.cleanResults((List<?>) rc.getResult());
-
-      AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
-      for (CliFunctionResult result : results) {
-        if (result.getThrowable() != null) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", "ERROR: " + result.getThrowable().getClass().getName()
-              + ": " + result.getThrowable().getMessage());
-          accumulatedData = true;
-          tabularData.setStatus(Result.Status.ERROR);
-        } else if (result.isSuccessful()) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", result.getMessage());
-          accumulatedData = true;
-
-          if (xmlEntity.get() == null) {
-            xmlEntity.set(result.getXmlEntity());
-          }
-        }
-      }
-
-      if (!accumulatedData) {
-        return ResultBuilder.createInfoResult("Unable to create disk store(s).");
-      }
-
-      Result result = ResultBuilder.buildResult(tabularData);
-
-      if (xmlEntity.get() != null) {
-        persistClusterConfiguration(result,
-            () -> getSharedConfiguration().addXmlEntity(xmlEntity.get(), groups));
-      }
-
-      return ResultBuilder.buildResult(tabularData);
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable th) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.CREATE_DISK_STORE__ERROR_WHILE_CREATING_REASON_0,
-              new Object[] {th.getMessage()}));
+    diskStoreAttributes.diskDirs = directories;
+    diskStoreAttributes.diskDirSizes = sizes;
+
+    diskStoreAttributes.setDiskUsageWarningPercentage(diskUsageWarningPercentage);
+    diskStoreAttributes.setDiskUsageCriticalPercentage(diskUsageCriticalPercentage);
+
+    Set<DistributedMember> targetMembers = findMembers(groups, null);
+
+    if (targetMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+
+    List<CliFunctionResult> results = executeAndGetFunctionResult(new CreateDiskStoreFunction(),
+        new Object[] {name, diskStoreAttributes}, targetMembers);
+
+    CommandResult result = ResultBuilder.buildResult(results);
+    XmlEntity xmlEntity = findXmlEntity(results);
+
+    if (xmlEntity != null) {
+      persistClusterConfiguration(result,
+          () -> getSharedConfiguration().addXmlEntity(xmlEntity, groups));
+    }
+
+    return result;

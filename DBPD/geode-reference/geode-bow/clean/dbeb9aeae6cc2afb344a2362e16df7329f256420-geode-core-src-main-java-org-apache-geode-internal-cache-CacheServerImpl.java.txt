Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An implementation of the <code>CacheServer</code> interface that delegates
- * most of the heavy lifting to an {@link Acceptor}.
+ * An implementation of the <code>CacheServer</code> interface that delegates most of the heavy
+ * lifting to an {@link Acceptor}.
-public class CacheServerImpl
-  extends AbstractCacheServer
-  implements DistributionAdvisee {
+public class CacheServerImpl extends AbstractCacheServer implements DistributionAdvisee {
-  private static final int FORCE_LOAD_UPDATE_FREQUENCY = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "BridgeServer.FORCE_LOAD_UPDATE_FREQUENCY", 10)
-      .intValue();
-  
+  private static final int FORCE_LOAD_UPDATE_FREQUENCY =
+      Integer
+          .getInteger(
+              DistributionConfig.GEMFIRE_PREFIX + "BridgeServer.FORCE_LOAD_UPDATE_FREQUENCY", 10)
+          .intValue();
+
+   * 
-   * The monitor used to monitor load on this
-   * bridge server and distribute load to the locators
+   * The monitor used to monitor load on this bridge server and distribute load to the locators
+   * 
-  
+
-  
+
-  
+
+   * 
-  public static final boolean ENABLE_NOTIFY_BY_SUBSCRIPTION_FALSE =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "cache-server.enable-notify-by-subscription-false");
-  
- 
+  public static final boolean ENABLE_NOTIFY_BY_SUBSCRIPTION_FALSE = Boolean.getBoolean(
+      DistributionConfig.GEMFIRE_PREFIX + "cache-server.enable-notify-by-subscription-false");
+
+
-   * Creates a new <code>BridgeServerImpl</code> that serves the contents of
-   * the give <code>Cache</code>. It has the default configuration.
+   * Creates a new <code>BridgeServerImpl</code> that serves the contents of the give
+   * <code>Cache</code>. It has the default configuration.
-  
+
-    return cache.getCancelCriterion();    
+    return cache.getCancelCriterion();
-      throw new IllegalStateException(LocalizedStrings.CacheServerImpl_A_CACHE_SERVERS_CONFIGURATION_CANNOT_BE_CHANGED_ONCE_IT_IS_RUNNING.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.CacheServerImpl_A_CACHE_SERVERS_CONFIGURATION_CANNOT_BE_CHANGED_ONCE_IT_IS_RUNNING
+              .toLocalizedString());
-  
+
-    }
-    else {
+    } else {
+
-  
+
-  public void setGatewayTransportFilter(
-      List<GatewayTransportFilter> transportFilters) {
+  public void setGatewayTransportFilter(List<GatewayTransportFilter> transportFilters) {
-  
+
-  
-  public ClientSubscriptionConfig getClientSubscriptionConfig(){
+
+  public ClientSubscriptionConfig getClientSubscriptionConfig() {
-   * Sets the configuration of <b>this</b> <code>CacheServer</code> based on
-   * the configuration of <b>another</b> <code>CacheServer</code>.
+   * Sets the configuration of <b>this</b> <code>CacheServer</code> based on the configuration of
+   * <b>another</b> <code>CacheServer</code>.
-    
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheServerImpl_FORCING_NOTIFYBYSUBSCRIPTION_TO_SUPPORT_DYNAMIC_REGIONS));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.CacheServerImpl_FORCING_NOTIFYBYSUBSCRIPTION_TO_SUPPORT_DYNAMIC_REGIONS));
-    this.loadMonitor = new LoadMonitor(loadProbe, maxConnections,
-        loadPollInterval, FORCE_LOAD_UPDATE_FREQUENCY, 
-        advisor);
+    this.loadMonitor = new LoadMonitor(loadProbe, maxConnections, loadPollInterval,
+        FORCE_LOAD_UPDATE_FREQUENCY, advisor);
-    this.acceptor = new AcceptorImpl(getPort(), 
-                                     getBindAddress(),
-                                     getNotifyBySubscription(),
-                                     getSocketBufferSize(), 
-                                     getMaximumTimeBetweenPings(), 
-                                     this.cache,
-                                     getMaxConnections(), 
-                                     getMaxThreads(), 
-                                     getMaximumMessageCount(),
-                                     getMessageTimeToLive(),
-                                     this.loadMonitor,
-                                     overflowAttributesList, 
-                                     this.isGatewayReceiver,
-                                     this.gatewayTransportFilters, this.tcpNoDelay);
+    this.acceptor = new AcceptorImpl(getPort(), getBindAddress(), getNotifyBySubscription(),
+        getSocketBufferSize(), getMaximumTimeBetweenPings(), this.cache, getMaxConnections(),
+        getMaxThreads(), getMaximumMessageCount(), getMessageTimeToLive(), this.loadMonitor,
+        overflowAttributesList, this.isGatewayReceiver, this.gatewayTransportFilters,
+        this.tcpNoDelay);
-    this.loadMonitor.start(new ServerLocation(getExternalAddress(),
-        getPort()), acceptor.getStats());
-    
+    this.loadMonitor.start(new ServerLocation(getExternalAddress(), getPort()),
+        acceptor.getStats());
+
-    //Creating ClientHealthMonitoring region.
+    // Creating ClientHealthMonitoring region.
-    if(cache instanceof GemFireCacheImpl) {
-      ClientHealthMonitoringRegion.getInstance((GemFireCacheImpl)cache);
+    if (cache instanceof GemFireCacheImpl) {
+      ClientHealthMonitoringRegion.getInstance((GemFireCacheImpl) cache);
-    this.cache.getLoggerI18n().config(LocalizedStrings.CacheServerImpl_CACHESERVER_CONFIGURATION___0, getConfig());
-    
-    /* 
-     * If the stopped bridge server is restarted, we'll need to re-register the 
-     * client membership listener. If the listener is already registered it 
-     * won't be registered as would the case when start() is invoked for the 
-     * first time.  
+    this.cache.getLoggerI18n()
+        .config(LocalizedStrings.CacheServerImpl_CACHESERVER_CONFIGURATION___0, getConfig());
+
+    /*
+     * If the stopped bridge server is restarted, we'll need to re-register the client membership
+     * listener. If the listener is already registered it won't be registered as would the case when
+     * start() is invoked for the first time.
-    ClientMembershipListener[] membershipListeners = 
-                                ClientMembership.getClientMembershipListeners();
-    
+    ClientMembershipListener[] membershipListeners =
+        ClientMembership.getClientMembershipListeners();
+
-      //just checking by reference as the listener instance is final
+      // just checking by reference as the listener instance is final
-    
+
-    
+
-      InternalDistributedSystem system = ((GemFireCacheImpl) this.cache)
-          .getDistributedSystem();
+      InternalDistributedSystem system = ((GemFireCacheImpl) this.cache).getDistributedSystem();
-    
+
-  
+
-   * Gets the address that this bridge server can be contacted on from external
-   * processes.
+   * Gets the address that this bridge server can be contacted on from external processes.
+   * 
-  
+
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-    
+
-    
+
-      if(this.loadMonitor != null) {
+      if (this.loadMonitor != null) {
-    } catch(RuntimeException e) {
-      cache.getLoggerI18n().warning(LocalizedStrings.CacheServerImpl_CACHESERVER_ERROR_CLOSING_LOAD_MONITOR, e);
+    } catch (RuntimeException e) {
+      cache.getLoggerI18n()
+          .warning(LocalizedStrings.CacheServerImpl_CACHESERVER_ERROR_CLOSING_LOAD_MONITOR, e);
-    
+
-    } catch(RuntimeException e) {
-      cache.getLoggerI18n().warning(LocalizedStrings.CacheServerImpl_CACHESERVER_ERROR_CLOSING_ADVISOR, e);
+    } catch (RuntimeException e) {
+      cache.getLoggerI18n()
+          .warning(LocalizedStrings.CacheServerImpl_CACHESERVER_ERROR_CLOSING_ADVISOR, e);
-    } 
-    
+    }
+
-    } catch(RuntimeException e) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheServerImpl_CACHESERVER_ERROR_CLOSING_ACCEPTOR_MONITOR), e);
+    } catch (RuntimeException e) {
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.CacheServerImpl_CACHESERVER_ERROR_CLOSING_ACCEPTOR_MONITOR), e);
-    
-    if(firstException != null) {
+
+    if (firstException != null) {
-    
-    //TODO : We need to clean up the admin region created for client
-    //monitoring.
-    
+
+    // TODO : We need to clean up the admin region created for client
+    // monitoring.
+
-    
+
-    
+
-      InternalDistributedSystem system = ((GemFireCacheImpl) this.cache)
-          .getDistributedSystem();
+      InternalDistributedSystem system = ((GemFireCacheImpl) this.cache).getDistributedSystem();
-    String str =
-    "port=" + getPort() + " max-connections=" + getMaxConnections()
-        + " max-threads=" + getMaxThreads() + " notify-by-subscription="
-        + getNotifyBySubscription() + " socket-buffer-size="
-        + getSocketBufferSize() + " maximum-time-between-pings="
-        + getMaximumTimeBetweenPings() + " maximum-message-count="
-        + getMaximumMessageCount() + " message-time-to-live="
-        + getMessageTimeToLive() + " eviction-policy=" + csc.getEvictionPolicy()
-        + " capacity=" + csc.getCapacity() + " overflow directory=";
+    String str = "port=" + getPort() + " max-connections=" + getMaxConnections() + " max-threads="
+        + getMaxThreads() + " notify-by-subscription=" + getNotifyBySubscription()
+        + " socket-buffer-size=" + getSocketBufferSize() + " maximum-time-between-pings="
+        + getMaximumTimeBetweenPings() + " maximum-message-count=" + getMaximumMessageCount()
+        + " message-time-to-live=" + getMessageTimeToLive() + " eviction-policy="
+        + csc.getEvictionPolicy() + " capacity=" + csc.getCapacity() + " overflow directory=";
-      str += csc.getOverflowDirectory(); 
+      str += csc.getOverflowDirectory();
-    str += 
-        " groups=" + Arrays.asList(getGroups())
-        + " loadProbe=" + loadProbe
-        + " loadPollInterval=" + loadPollInterval
-        + " tcpNoDelay=" + tcpNoDelay;
+    str += " groups=" + Arrays.asList(getGroups()) + " loadProbe=" + loadProbe
+        + " loadPollInterval=" + loadPollInterval + " tcpNoDelay=" + tcpNoDelay;
-    String str = 
-    "CacheServer on port=" + getPort() + " client subscription config policy="
-        + csc.getEvictionPolicy() + " client subscription config capacity="
-        + csc.getCapacity();
+    String str = "CacheServer on port=" + getPort() + " client subscription config policy="
+        + csc.getEvictionPolicy() + " client subscription config capacity=" + csc.getCapacity();
-      str += " client subscription config overflow disk store="
-        + csc.getDiskStoreName();
+      str += " client subscription config overflow disk store=" + csc.getDiskStoreName();
-      str += " client subscription config overflow directory="
-        + csc.getOverflowDirectory();
+      str += " client subscription config overflow directory=" + csc.getOverflowDirectory();
-  
+
-    return getCacheClientNotifier().getClientProxy(
-        ClientProxyMembershipID.getClientId(member));
+    return getCacheClientNotifier().getClientProxy(ClientProxyMembershipID.getClientId(member));
-  
+
-  public static String clientMessagesRegion(GemFireCacheImpl cache, String ePolicy,
-      int capacity, int port, String overFlowDir, boolean isDiskStore) {
-    AttributesFactory factory = getAttribFactoryForClientMessagesRegion(cache, 
-        ePolicy, capacity, overFlowDir, isDiskStore);
+  public static String clientMessagesRegion(GemFireCacheImpl cache, String ePolicy, int capacity,
+      int port, String overFlowDir, boolean isDiskStore) {
+    AttributesFactory factory =
+        getAttribFactoryForClientMessagesRegion(cache, ePolicy, capacity, overFlowDir, isDiskStore);
-  public static AttributesFactory getAttribFactoryForClientMessagesRegion(
-      GemFireCacheImpl cache,
+  public static AttributesFactory getAttribFactoryForClientMessagesRegion(GemFireCacheImpl cache,
-    } else if  (overflowDir == null || overflowDir.equals(ClientSubscriptionConfig.DEFAULT_OVERFLOW_DIRECTORY)) {
+    } else if (overflowDir == null
+        || overflowDir.equals(ClientSubscriptionConfig.DEFAULT_OVERFLOW_DIRECTORY)) {
-      File dir = new File(overflowDir + File.separatorChar
-          + generateNameForClientMsgsRegion(OSProcess.getId()));
+      File dir = new File(
+          overflowDir + File.separatorChar + generateNameForClientMsgsRegion(OSProcess.getId()));
-        throw new GemFireIOException("Could not create client subscription overflow directory: "
-            + dir.getAbsolutePath());
+        throw new GemFireIOException(
+            "Could not create client subscription overflow directory: " + dir.getAbsolutePath());
-      File[] dirs = { dir };
+      File[] dirs = {dir};
-      .setDiskDirsAndSizes(dirs, new int[] { Integer.MAX_VALUE })
-      .create("bsi");
+          .setDiskDirsAndSizes(dirs, new int[] {Integer.MAX_VALUE}).create("bsi");
-      factory
-          .setEvictionAttributes(EvictionAttributesImpl.createLIFOEntryAttributes(
-              capacity, EvictionAction.OVERFLOW_TO_DISK));
-    }
-    else if (HARegionQueue.HA_EVICTION_POLICY_MEMORY.equals(ePolicy)) { // condition refinement
-      factory
-          .setEvictionAttributes(EvictionAttributesImpl.createLIFOMemoryAttributes(
-              capacity, EvictionAction.OVERFLOW_TO_DISK));
-    }
-    else {
+      factory.setEvictionAttributes(EvictionAttributesImpl.createLIFOEntryAttributes(capacity,
+          EvictionAction.OVERFLOW_TO_DISK));
+    } else if (HARegionQueue.HA_EVICTION_POLICY_MEMORY.equals(ePolicy)) { // condition refinement
+      factory.setEvictionAttributes(EvictionAttributesImpl.createLIFOMemoryAttributes(capacity,
+          EvictionAction.OVERFLOW_TO_DISK));
+    } else {
-        LocalizedStrings.CacheServerImpl__0_INVALID_EVICTION_POLICY.toLocalizedString(ePolicy));
+          LocalizedStrings.CacheServerImpl__0_INVALID_EVICTION_POLICY.toLocalizedString(ePolicy));
-  public static String createClientMessagesRegion(RegionAttributes attr,
-      GemFireCacheImpl cache, int capacity, int port) {
+  public static String createClientMessagesRegion(RegionAttributes attr, GemFireCacheImpl cache,
+      int capacity, int port) {
-          new InternalRegionArguments().setDestroyLockFlag(true)
-              .setRecreateFlag(false).setSnapshotInputStream(null)
-              .setImageTarget(null).setIsUsedForMetaRegion(true));
-    }
-    catch (RegionExistsException ree) {
-      InternalGemFireError assErr = new InternalGemFireError(
-          "unexpected exception");
+          new InternalRegionArguments().setDestroyLockFlag(true).setRecreateFlag(false)
+              .setSnapshotInputStream(null).setImageTarget(null).setIsUsedForMetaRegion(true));
+    } catch (RegionExistsException ree) {
+      InternalGemFireError assErr = new InternalGemFireError("unexpected exception");
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-      InternalGemFireError assErr = new InternalGemFireError(
-          "unexpected exception");
+      InternalGemFireError assErr = new InternalGemFireError("unexpected exception");
-    }
-    catch (ClassNotFoundException e) {
+    } catch (ClassNotFoundException e) {
-      InternalGemFireError assErr = new InternalGemFireError(
-          "unexpected exception");
+      InternalGemFireError assErr = new InternalGemFireError("unexpected exception");
-  public static String createClientMessagesRegionForTesting(GemFireCacheImpl cache,
-      String ePolicy, int capacity, int port, int expiryTime, String overFlowDir, boolean isDiskStore) {
-    AttributesFactory factory = getAttribFactoryForClientMessagesRegion(cache, 
-        ePolicy, capacity, overFlowDir, isDiskStore);
-    ExpirationAttributes ea = new ExpirationAttributes(expiryTime,
-        ExpirationAction.LOCAL_INVALIDATE);
+  public static String createClientMessagesRegionForTesting(GemFireCacheImpl cache, String ePolicy,
+      int capacity, int port, int expiryTime, String overFlowDir, boolean isDiskStore) {
+    AttributesFactory factory =
+        getAttribFactoryForClientMessagesRegion(cache, ePolicy, capacity, overFlowDir, isDiskStore);
+    ExpirationAttributes ea =
+        new ExpirationAttributes(expiryTime, ExpirationAction.LOCAL_INVALIDATE);
-   * Marker class name to identify the lock more easily in thread dumps private
-   * static class ClientMessagesRegionLock extends Object { }
+   * Marker class name to identify the lock more easily in thread dumps private static class
+   * ClientMessagesRegionLock extends Object { }
-  
+
-  
+
-  
+
-  
+
+   * 
-    return (InternalDistributedSystem)this.cache.getDistributedSystem();
+    return (InternalDistributedSystem) this.cache.getDistributedSystem();
-  
+
-  
+
-  
+
-   * Returns an array of all the groups of this bridge server.
-   * This includes those from the groups gemfire property
-   * and those explicitly added to this server.
+   * Returns an array of all the groups of this bridge server. This includes those from the groups
+   * gemfire property and those explicitly added to this server.
-    for (String g: MemberAttributes.parseGroups(null, getSystem().getConfig().getGroups())) {
-      if (!groupList.contains(g)) {
-        groupList.add(g);
+    if (!this.isGatewayReceiver) {
+      for (String g : MemberAttributes.parseGroups(null, getSystem().getConfig().getGroups())) {
+        if (!groupList.contains(g)) {
+          groupList.add(g);
+        }
-    for (String g: getGroups()) {
+    for (String g : getGroups()) {
-  
-  public /*synchronized causes deadlock*/ void fillInProfile(Profile profile) {
+
+  public /* synchronized causes deadlock */ void fillInProfile(Profile profile) {
-    CacheServerProfile bp = (CacheServerProfile)profile;
+    CacheServerProfile bp = (CacheServerProfile) profile;
-  
-   protected CacheClientNotifier getCacheClientNotifier() {
+
+  protected CacheClientNotifier getCacheClientNotifier() {
-  } 
-   
+  }
+
-   * @param listener
-   *                The <code>InterestRegistrationListener</code> to register
+   * @param listener The <code>InterestRegistrationListener</code> to register
-  public void registerInterestRegistrationListener(
-      InterestRegistrationListener listener) {
+  public void registerInterestRegistrationListener(InterestRegistrationListener listener) {
-      throw new IllegalStateException(LocalizedStrings.CacheServerImpl_MUST_BE_RUNNING.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.CacheServerImpl_MUST_BE_RUNNING.toLocalizedString());
-    getCacheClientNotifier().registerInterestRegistrationListener(listener); 
+    getCacheClientNotifier().registerInterestRegistrationListener(listener);
-   * Unregisters an existing <code>InterestRegistrationListener</code> from
-   * the set of <code>InterestRegistrationListener</code>s.
+   * Unregisters an existing <code>InterestRegistrationListener</code> from the set of
+   * <code>InterestRegistrationListener</code>s.
-   * @param listener
-   *                The <code>InterestRegistrationListener</code> to
-   *                unregister
+   * @param listener The <code>InterestRegistrationListener</code> to unregister
-  public void unregisterInterestRegistrationListener(
-      InterestRegistrationListener listener) {
-    getCacheClientNotifier().unregisterInterestRegistrationListener(listener);     
+  public void unregisterInterestRegistrationListener(InterestRegistrationListener listener) {
+    getCacheClientNotifier().unregisterInterestRegistrationListener(listener);
-   * Returns a read-only set of <code>InterestRegistrationListener</code>s
-   * registered with this notifier.
+   * Returns a read-only set of <code>InterestRegistrationListener</code>s registered with this
+   * notifier.
-   * @return a read-only set of <code>InterestRegistrationListener</code>s
-   *         registered with this notifier
+   * @return a read-only set of <code>InterestRegistrationListener</code>s registered with this
+   *         notifier
-    return getCacheClientNotifier().getInterestRegistrationListeners(); 
+    return getCacheClientNotifier().getInterestRegistrationListeners();

GEODE-6033: Support dynamic VMs in DistributedUseJacksonForJsonPathRule

* Cleanup and javadoc DistributedUseJacksonForJsonPathRule
* Create tests for DistributedUseJacksonForJsonPathRule
* Make DistributedUseJacksonForJsonPathRule support create and bounce
VMs

-import static org.apache.geode.test.dunit.VM.getVMCount;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.apache.geode.test.dunit.VM.DEFAULT_VM_COUNT;
+import java.io.Serializable;
+
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.VMEventListener;
+import org.apache.geode.test.junit.rules.serializable.SerializableTestRule;
-public class DistributedUseJacksonForJsonPathRule extends UseJacksonForJsonPathRule {
+/**
+ * Distributed version of UseJacksonForJsonPathRule JUnit Rule that configures json-path to use
+ * {@code JacksonJsonProvider} in all DUnit VMs (except for the hidden Locator VM) in addition to
+ * the JVM running JUnit (known as the Controller VM).
+ *
+ * <p>
+ * DistributedUseJacksonForJsonPathRule can be used in tests that need to use json-path-assert:
+ *
+ * <pre>
+ * {@literal @}ClassRule
+ * public static DistributedUseJacksonForJsonPathRule useJacksonForJsonPathRule = new DistributedUseJacksonForJsonPathRule();
+ *
+ * {@literal @}Test
+ * public void hasAssertionsUsingJsonPathMatchers() {
+ *   ...
+ *   assertThat(json, isJson());
+ *   assertThat(json, hasJsonPath("$.result"));
+ * }
+ * </pre>
+ */
+@SuppressWarnings("serial,unused")
+public class DistributedUseJacksonForJsonPathRule extends UseJacksonForJsonPathRule implements
+    SerializableTestRule {
+  private final int vmCount;
-
-  private volatile int beforeVmCount;
+  private final VMEventListener vmEventListener;
-    this(new RemoteInvoker());
+    this(DEFAULT_VM_COUNT, new RemoteInvoker());
-  public DistributedUseJacksonForJsonPathRule(final RemoteInvoker invoker) {
+  public DistributedUseJacksonForJsonPathRule(final int vmCount) {
+    this(vmCount, new RemoteInvoker());
+  }
+
+  private DistributedUseJacksonForJsonPathRule(final int vmCount, final RemoteInvoker invoker) {
+    this.vmCount = vmCount;
+    vmEventListener = new InternalVMEventListener();
-    DUnitLauncher.launchIfNeeded();
-    beforeVmCount = getVMCount();
+    DUnitLauncher.launchIfNeeded(vmCount);
+    VM.addVMEventListener(vmEventListener);
-    invoker.invokeInEveryVMAndController(() -> invokeBefore());
+    invoker.invokeInEveryVMAndController(() -> doBefore());
-    int afterVmCount = getVMCount();
-    assertThat(afterVmCount).isEqualTo(beforeVmCount);
+    VM.removeVMEventListener(vmEventListener);
-    invoker.invokeInEveryVMAndController(() -> invokeAfter());
+    invoker.invokeInEveryVMAndController(() -> doAfter());
-  private static void invokeBefore() {
+  private void afterCreateVM(VM vm) {
+    vm.invoke(() -> doBefore());
+  }
+
+  private void afterBounceVM(VM vm) {
+    vm.invoke(() -> doBefore());
+  }
+
+  private void doBefore() {
-  private static void invokeAfter() {
+  private void doAfter() {
+
+  /**
+   * VMEventListener for DistributedUseJacksonForJsonPathRule.
+   */
+  private class InternalVMEventListener implements VMEventListener, Serializable {
+
+    @Override
+    public void afterCreateVM(VM vm) {
+      DistributedUseJacksonForJsonPathRule.this.afterCreateVM(vm);
+    }
+
+    @Override
+    public void afterBounceVM(VM vm) {
+      DistributedUseJacksonForJsonPathRule.this.afterBounceVM(vm);
+    }
+  }

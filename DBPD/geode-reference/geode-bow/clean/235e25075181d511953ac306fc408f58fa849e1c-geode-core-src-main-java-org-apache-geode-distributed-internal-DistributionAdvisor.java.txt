GEODE-7577: Log when waiting for missing persistent members (#4476)

* Separate StartupStatusListenerRegistry from StartupStatus to allow
  non-static injection of StartupStatus into classes that use it
* Add CollectionTransformer interface to TransformUtils to facilitate
  unit testing of classes depending on it
* Add new MembershipChangeListenerFactory with validation to ensure that
  warningDelay and pollDuration have correct values in relation to each
  other (to prevent recurrences of GEODE-7577)
* Fixed the formatting of missing persistent members messages in
  PersistenceAdvisorImpl
* Fixed warnings and minor issues primarily for readability and
  testability in every class touched
* Added shouldSyncForCrashedMember to InternalRegion and pulled the
  javadocs up to the interface

GEODE-4267: Fix PersistentRecoveryOrderOldConfigDUnitTest
* Replace thread sleeps with CountDownLatch
* Add a couple await calls
* Actual fix involved preventing late-running asynchronous actions that
  resulted in logging DistributedSystemDisconnectedException AFTER the
  test already removed the IgnoredException
* Major cleanup of PersistentRecoveryOrderDUnitTest including replace
  usage of Admin API with usage of DistributedSystemMXBean
* Replace Region close with Cache close in test that needs to list and
  revoke missing disk-stores
+import static java.lang.System.lineSeparator;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.internal.cache.InternalRegion;
- * <code>DistributionAdvisor</code> and maintains it by giving it a <code>Profile</code> for each of
+ * {@code DistributionAdvisor} and maintains it by giving it a {@code Profile} for each of
+ *
- * Provides <code>advise</code> methods for each type of operation that requires specialized
+ * Provides {@code advise} methods for each type of operation that requires specialized
+ *
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "DistributionAdvisor.startVersionNumber", 1);
+      .getInteger(GEMFIRE_PREFIX + "DistributionAdvisor.startVersionNumber", 1);
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.startSerialNumber", 1
-      // Integer.MAX_VALUE-10
-      );
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.startSerialNumber", 1);
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "CacheDistributionAdvisor.rolloverThreshold",
-          1000);
+      .getInteger(GEMFIRE_PREFIX + "CacheDistributionAdvisor.rolloverThreshold", 1000);
-
-  private volatile boolean initialized = false;
+  private volatile boolean initialized;
-  private int numActiveProfiles = 0;
+  private int numActiveProfiles;
-  private ConcurrentMap<MembershipListener, Boolean> membershipListeners =
+  private final ConcurrentMap<MembershipListener, Boolean> membershipListeners =
-  private ConcurrentMap<ProfileListener, Boolean> profileListeners = new ConcurrentHashMap<>();
+  private final ConcurrentMap<ProfileListener, Boolean> profileListeners =
+      new ConcurrentHashMap<>();
-      public void memberJoined(DistributionManager distributionManager,
-          InternalDistributedMember id) {
-        // Ignore
-      }
-
-      @Override
-      public void quorumLost(DistributionManager distributionManager,
-          Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
-
-      @Override
-      @SuppressWarnings("synthetic-access")
-        boolean removed =
-            removeId(id, crashed, false/* destroyed */, true/* fromMembershipListener */);
+        boolean removed = removeId(id, crashed, false, true);
-
-      @Override
-      public void memberSuspect(DistributionManager distributionManager,
-          InternalDistributedMember id, InternalDistributedMember whoSuspected, String reason) {}
-
-  public static DistributionAdvisor createDistributionAdvisor(DistributionAdvisee advisee) {
-    DistributionAdvisor advisor = new DistributionAdvisor(advisee);
-    advisor.initialize();
-    return advisor;
-  }
-
-    subInit();
-  private void subInit() {
-    // override for any additional initialization specific to subclass
-  }
-
-    return (advisee instanceof DistributedRegion)
-        && ((DistributedRegion) advisee).shouldSyncForCrashedMember(id);
+    return advisee instanceof DistributedRegion
+        && ((InternalRegion) advisee).shouldSyncForCrashedMember(id);
-  /** perform a delta-GII for the given lost member */
+  /**
+   * perform a delta-GII for the given lost member
+   */
+  @VisibleForTesting
+  @VisibleForTesting
-  /** find the region for a delta-gii operation (synch) */
+  /**
+   * find the region for a delta-gii operation (synch)
+   */
-
-
-  public interface InitializationListener {
-    /**
-     * Called after this DistributionAdvisor has been initialized.
-     */
-    void initialized();
-  }
-
-    this.initializationListener = listener;
+    initializationListener = listener;
-  /** Called by CreateRegionProcessor after it does its own profile exchange */
+  /**
+   * Called by CreateRegionProcessor after it does its own profile exchange
+   */
-  /** Return true if exchanged profiles */
+  /**
+   * Return true if exchanged profiles
+   */
-        if (this.initializationListener != null) {
+        if (initializationListener != null) {
-          this.initializationListener.initialized();
+          initializationListener.initialized();
-  // wait for pending profile exchange to complete before returning
+  /**
+   * wait for pending profile exchange to complete before returning
+   */
-
-    buf.append(toString());
-    buf.append(":\n");
+    buf.append(this);
+    buf.append(":").append(lineSeparator());
-    buf.append("\nOther Profiles:\n");
+    buf.append(lineSeparator()).append("Other Profiles:").append(lineSeparator());
-      buf.append(prof.toString());
-      buf.append("\n");
+      buf.append(prof);
+      buf.append(lineSeparator());
-  public void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
+  void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
+   * <p>
-    } else {
-      // if id is not a InternalDistributedMember then return false
-      return false;
+    // if id is not a InternalDistributedMember then return false
+    return false;
+   * <p>
-   * Removes the profile for the given member. This method is meant to be overriden by subclasses.
+   * Removes the profile for the given member. This method is meant to be overridden by subclasses.
-   *        (fixes #42000)
-        // Assert.assertTrue(!crashed); // should not get here :-)
-      } else {
-        // Garbage collect; this profile is no longer pertinent
-        removedProfiles.remove(memberId);
-        boolean result = basicRemoveId(memberId, crashed, destroyed);
-        while (basicRemoveId(memberId, crashed, destroyed)) {
-          // keep removing profiles that match until we have no more
-        }
-        return result;
+      // Garbage collect; this profile is no longer pertinent
+      removedProfiles.remove(memberId);
+      boolean result = basicRemoveId(memberId, crashed, destroyed);
+      while (basicRemoveId(memberId, crashed, destroyed)) {
+        // keep removing profiles that match until we have no more
+      }
+      return result;
-    return (indexOfMemberId(memberId) > -1);
+    return indexOfMemberId(memberId) > -1;
-
-    boolean isIDM = (id instanceof InternalDistributedMember);
+    boolean isIDM = id instanceof InternalDistributedMember;
-  /** exchange profiles to initialize this advisor */
+  /**
+   * exchange profiles to initialize this advisor
+   */
-  /** Creates the current distribution profile for this member */
+  /**
+   * Creates the current distribution profile for this member
+   */
-  /** Instantiate new distribution profile for this member */
+  /**
+   * Instantiate new distribution profile for this member
+   */
-   * following scenarios: 1) We're doing a lazy initialization and synchronization on initializeLock
-   * prevents other threads from causing initialization on this advisor. 2) We're creating a new
-   * region and doing profile exchange as part of region initialization, in which case no other
-   * threads have access to the region or this advisor.
+   * following scenarios:
+   *
+   * <pre>
+   * 1) We're doing a lazy initialization and synchronization on initializeLock prevents other
+   * threads from causing initialization on this advisor.
+   *
+   * 2) We're creating a new region and doing profile exchange as part of region initialization, in
+   * which case no other threads have access to the region or this advisor.
+   * </pre>
-      if (advisee == null)
+      if (advisee == null) {
+      }
-    } else {
-      return getDistributionManager().getAllOtherMembers();
+    return getDistributionManager().getAllOtherMembers();
-        membershipListener.memberDeparted(getDistributionManagerWithNoCheck(), member,
-            crashed);
+        membershipListener.memberDeparted(getDistributionManagerWithNoCheck(), member, crashed);
-      (profileListener).profileRemoved(profile, destroyed);
+      profileListener.profileRemoved(profile, destroyed);
-      (profileListener).profileCreated(profile);
+      profileListener.profileCreated(profile);
-      (profileListener).profileUpdated(profile);
+      profileListener.profileUpdated(profile);
-  protected void profileCreated(Profile profile) {}
+  protected void profileCreated(Profile profile) {
+    // empty by default
+  }
-  protected void profileUpdated(Profile profile) {}
+  protected void profileUpdated(Profile profile) {
+    // empty by default
+  }
-  protected void profileRemoved(Profile profile) {}
+  protected void profileRemoved(Profile profile) {
+    // empty by default
+  }
-  /** All advise methods go through this method */
+  /**
+   * All advise methods go through this method
+   */
-    } else {
-      return recipients;
+    return recipients;
-   * A visitor interface for all the available profiles used by
-   * {@link DistributionAdvisor#accept(ProfileVisitor, Object)}. Unlike the {@link Filter} class
-   * this does not assume of two state visit of inclusion or exclusion rather allows manipulation of
-   * an arbitrary aggregator that has been passed to the {@link #visit} method. In addition this is
-   * public for use by other classes.
-   */
-  public interface ProfileVisitor<T> {
-
-    /**
-     * Visit a given {@link Profile} accumulating the results in the given aggregate. Returns false
-     * when the visit has to be terminated.
-     *
-     * @param advisor the DistributionAdvisor that invoked this visitor
-     * @param profile the profile being visited
-     * @param profileIndex the index of current profile
-     * @param numProfiles the total number of profiles being visited
-     * @param aggregate result aggregated so far, if any
-     *
-     * @return false if the visit has to be terminated immediately and false otherwise
-     */
-    boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex, int numProfiles,
-        T aggregate);
-  }
-
-  /**
-   * Get an unmodifiable list of the <code>Profile</code>s that match the given <code>Filter</code>.
+   * Get an unmodifiable list of the {@code Profile}s that match the given {@code Filter}.
-  public Set adviseProfileUpdate() {
+  public Set<InternalDistributedMember> adviseProfileUpdate() {
-  public Set adviseProfileRemove() {
+  public Set<InternalDistributedMember> adviseProfileRemove() {
-  // must synchronize when modifying profile array
+    // must synchronize when modifying profile array
+
-
-  // must synchronize when modifying profile array
-    // try {
+    // must synchronize when modifying profile array
+
-    } else
-      return null;
-    // } finally {
-    // Assert.assertTrue(-1 == indexOfMemberId(id));
-    // }
+    }
+    return null;
+  @FunctionalInterface
+  public interface InitializationListener {
-  /** Filter interface */
+    /**
+     * Called after this DistributionAdvisor has been initialized.
+     */
+    void initialized();
+  }
+
+  /**
+   * A visitor interface for all the available profiles used by
+   * {@link DistributionAdvisor#accept(ProfileVisitor, Object)}. Unlike the {@link Filter} class
+   * this does not assume of two state visit of inclusion or exclusion rather allows manipulation of
+   * an arbitrary aggregator that has been passed to the {@link #visit} method. In addition this is
+   * public for use by other classes.
+   */
+  @FunctionalInterface
+  public interface ProfileVisitor<T> {
+
+    /**
+     * Visit a given {@link Profile} accumulating the results in the given aggregate. Returns false
+     * when the visit has to be terminated.
+     *
+     * @param advisor the DistributionAdvisor that invoked this visitor
+     * @param profile the profile being visited
+     * @param profileIndex the index of current profile
+     * @param numProfiles the total number of profiles being visited
+     * @param aggregate result aggregated so far, if any
+     *
+     * @return false if the visit has to be terminated immediately and false otherwise
+     */
+    boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex, int numProfiles,
+        T aggregate);
+  }
+
+  @FunctionalInterface
+
+
-    /** Member for whom this profile represents */
+
+    /**
+     * Member for whom this profile represents
+     */
-    /** Serial number incremented every time profile is updated by memberId */
+
+    /**
+     * Serial number incremented every time profile is updated by memberId
+     */
+
+
-    /** for internal use, required for DataSerializable.Helper.readObject */
-    public Profile() {}
+    /**
+     * for internal use, required for DataSerializable.Helper.readObject
+     */
+    public Profile() {
+      // nothing
+    }
-        throw new IllegalArgumentException(
-            "memberId cannot be null");
+        throw new IllegalArgumentException("memberId cannot be null");
-      if (obj == this)
+      if (obj == this) {
-      if (obj == null)
+      }
+      if (obj == null) {
-      if (!getClass().equals(obj.getClass()))
+      }
+      if (!getClass().equals(obj.getClass())) {
+      }
-    public void toData(DataOutput out,
-        SerializationContext context) throws IOException {
+    public void toData(DataOutput out, SerializationContext context) throws IOException {
-    public void fromData(DataInput in,
-        DeserializationContext context) throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in, DeserializationContext context)
+        throws IOException, ClassNotFoundException {
-     * thread, otherwsie spawn another thread to do cleanup
+     * thread, otherwise spawn another thread to do cleanup
-
+      // empty by default
-
-
+
-    synchronized void forceNewMembershipVersion() {
+    private synchronized void forceNewMembershipVersion() {
-    synchronized long startOperation() {
+    private synchronized long startOperation() {
-    synchronized void endOperation(long version) {
+    private synchronized void endOperation(long version) {
-    void waitForCurrentOperations() {
+    private void waitForCurrentOperations() {
-    void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
+    private void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
-        if ((!warned) && System.currentTimeMillis() >= warnTime) {
+        if (!warned && System.currentTimeMillis() >= warnTime) {
-        } else if (warned && !severeAlertIssued && (now >= severeAlertTime)) {
+        } else if (warned && !severeAlertIssued && now >= severeAlertTime) {
-    synchronized boolean operationsAreInProgress() {
+    private synchronized boolean operationsAreInProgress() {
-    synchronized void initNewProfile(Profile newProfile) {
+    private synchronized void initNewProfile(Profile newProfile) {
-      previousVersionOpCount =
-          previousVersionOpCount + currentVersionOpCount;
+      previousVersionOpCount = previousVersionOpCount + currentVersionOpCount;
-    void logNewOperation() {}
+    void logNewOperation() {
+      // empty by default
+    }
-    void logEndOperation(boolean newOperation) {}
+    void logEndOperation(boolean newOperation) {
+      // empty by default
+    }
-      // OSProcess.printStacks(0);
-    void membershipVersionChanged() {}
-
+    void membershipVersionChanged() {
+      // empty by default
+    }
-     * and capture the state when startOperatiopn is invoked
+     * and capture the state when startOperation is invoked
-    private ThreadTrackingOperationMonitor(
-        DistributionAdvisor distributionAdvisor) {
+    private ThreadTrackingOperationMonitor(DistributionAdvisor distributionAdvisor) {
-        logger
-            .debug("Waiting for these threads: {}", previousVersionOperationThreads);
-        logger
-            .debug("New version threads are {}", currentVersionOperationThreads);
+        logger.debug("Waiting for these threads: {}", previousVersionOperationThreads);
+        logger.debug("New version threads are {}", currentVersionOperationThreads);
-        logger
-            .debug("Waiting for these threads: {}", previousVersionOperationThreads);
-        logger
-            .debug("New version threads are {}", currentVersionOperationThreads);
+        logger.debug("Waiting for these threads: {}", previousVersionOperationThreads);
+        logger.debug("New version threads are {}", currentVersionOperationThreads);
-      previousVersionOperationThreads
-          .putAll(currentVersionOperationThreads);
+      previousVersionOperationThreads.putAll(currentVersionOperationThreads);
-
-     * ExceptionWrapper is used in debugging hangs in waitForCurrentOperations(). It
-     * captures the call stack of a thread invoking startOperation().
+     * ExceptionWrapper is used in debugging hangs in waitForCurrentOperations(). It captures the
+     * call stack of a thread invoking startOperation().
-      private Exception exception;
-      ExceptionWrapper(Exception exception) {
+      private final Exception exception;
+
+      private ExceptionWrapper(Exception exception) {
-
-

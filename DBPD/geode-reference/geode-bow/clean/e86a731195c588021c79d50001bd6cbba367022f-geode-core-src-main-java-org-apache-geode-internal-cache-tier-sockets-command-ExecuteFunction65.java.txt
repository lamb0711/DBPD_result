Merge branch 'release/1.3.0'

+import java.util.Optional;
+import org.apache.geode.internal.security.SecurityService;
-  public void cmdExecute(Message clientMessage, ServerConnection servConn, long start)
-      throws IOException {
+  public void cmdExecute(final Message clientMessage, final ServerConnection serverConnection,
+      final SecurityService securityService, long start) throws IOException {
-        servConn.setAsTrue(REQUIRES_RESPONSE);
-        servConn.setAsTrue(REQUIRES_CHUNKED_RESPONSE);
+        serverConnection.setAsTrue(REQUIRES_RESPONSE);
+        serverConnection.setAsTrue(REQUIRES_CHUNKED_RESPONSE);
-        writeChunkedException(clientMessage, exception, servConn);
-        servConn.setAsTrue(RESPONDED);
+        writeChunkedException(clientMessage, exception, serverConnection);
+        serverConnection.setAsTrue(RESPONDED);
-      logger.warn("{}: {}", servConn.getName(), message);
-      sendError(hasResult, clientMessage, message, servConn);
+      logger.warn("{}: {}", serverConnection.getName(), message);
+      sendError(hasResult, clientMessage, message, serverConnection);
-      Function functionObject = null;
+      Function<?> functionObject = null;
-          logger.warn("{}: {}", servConn.getName(), message);
-          sendError(hasResult, clientMessage, message, servConn);
+          logger.warn("{}: {}", serverConnection.getName(), message);
+          sendError(hasResult, clientMessage, message, serverConnection);
-            logger.warn("{}: {}", servConn.getName(), message);
-            sendError(hasResult, clientMessage, message, servConn);
+            logger.warn("{}: {}", serverConnection.getName(), message);
+            sendError(hasResult, clientMessage, message, serverConnection);
-      this.securityService.authorizeDataWrite();
-
-      AuthorizeRequest authzRequest = servConn.getAuthzRequest();
+      functionObject.getRequiredPermissions(null).forEach(securityService::authorize);
+
+      AuthorizeRequest authzRequest = serverConnection.getAuthzRequest();
-      ChunkedMessage m = servConn.getFunctionResponseMessage();
+
+      ChunkedMessage m = serverConnection.getFunctionResponseMessage();
-          MessageType.EXECUTE_FUNCTION_RESULT, servConn, functionObject, executeContext);
+          MessageType.EXECUTE_FUNCTION_RESULT, serverConnection, functionObject, executeContext);
-      InternalDistributedMember localVM = (InternalDistributedMember) servConn.getCache()
-          .getDistributedSystem().getDistributedMember();
+      InternalCache cache = serverConnection.getCache();
+      InternalDistributedMember localVM =
+          (InternalDistributedMember) cache.getDistributedSystem().getDistributedMember();
-        context = new FunctionContextImpl(functionObject.getId(),
+        context = new FunctionContextImpl(cache, functionObject.getId(),
-        context = new FunctionContextImpl(functionObject.getId(), args, resultSender, isReexecute);
+        context =
+            new FunctionContextImpl(cache, functionObject.getId(), args, resultSender, isReexecute);
-      HandShake handShake = (HandShake) servConn.getHandshake();
+
+      HandShake handShake = (HandShake) serverConnection.getHandshake();
-          logger.debug("Executing Function on Server: {} with context: {}", servConn, context);
+          logger.debug("Executing Function on Server: {} with context: {}", serverConnection,
+              context);
-        InternalCache cache = servConn.getCache();
+
-          sendException(hasResult, clientMessage, e.getMessage(), servConn, e);
+          sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
-      sendException(hasResult, clientMessage, message, servConn, ioException);
+      sendException(hasResult, clientMessage, message, serverConnection, ioException);
-      sendException(hasResult, clientMessage, message, servConn, internalfunctionException);
+      sendException(hasResult, clientMessage, message, serverConnection, internalfunctionException);
-      sendException(hasResult, clientMessage, message, servConn, e);
+      sendException(hasResult, clientMessage, message, serverConnection, e);
-  private void sendException(byte hasResult, Message msg, String message, ServerConnection servConn,
-      Throwable e) throws IOException {
+  private void sendException(byte hasResult, Message msg, String message,
+      ServerConnection serverConnection, Throwable e) throws IOException {
-      writeFunctionResponseException(msg, MessageType.EXCEPTION, servConn, e);
-      servConn.setAsTrue(RESPONDED);
+      writeFunctionResponseException(msg, MessageType.EXCEPTION, serverConnection, e);
+      serverConnection.setAsTrue(RESPONDED);
-  private void sendError(byte hasResult, Message msg, String message, ServerConnection servConn)
-      throws IOException {
+  private void sendError(byte hasResult, Message msg, String message,
+      ServerConnection serverConnection) throws IOException {
-      writeFunctionResponseError(msg, MessageType.EXECUTE_FUNCTION_ERROR, message, servConn);
-      servConn.setAsTrue(RESPONDED);
+      writeFunctionResponseError(msg, MessageType.EXECUTE_FUNCTION_ERROR, message,
+          serverConnection);
+      serverConnection.setAsTrue(RESPONDED);

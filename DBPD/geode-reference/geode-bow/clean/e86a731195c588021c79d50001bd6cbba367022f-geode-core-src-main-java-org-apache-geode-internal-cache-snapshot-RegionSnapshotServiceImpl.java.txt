Merge branch 'release/1.3.0'

-import org.apache.geode.cache.execute.*;
+import org.apache.geode.cache.execute.Function;
+import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.cache.execute.FunctionException;
+import org.apache.geode.cache.execute.FunctionService;
+import org.apache.geode.cache.execute.RegionFunctionContext;
+import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.cache.execute.ResultSender;
-import org.apache.geode.internal.cache.*;
+import org.apache.geode.internal.cache.CachePerfStats;
+import org.apache.geode.internal.cache.CachedDeserializable;
+import org.apache.geode.internal.cache.CachedDeserializableFactory;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.LocalDataSet;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.Token;
-import java.io.*;
+import java.io.File;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.Serializable;
+import org.apache.logging.log4j.LogManager;
+
-      return snapshot.listFiles(new FileFilter() {
-        @Override
-        public boolean accept(File pathname) {
-          return !pathname.isDirectory();
-        }
-      });
+      return snapshot.listFiles(pathname -> !pathname.isDirectory());
-    return new SnapshotOptionsImpl<K, V>();
+    return new SnapshotOptionsImpl<>();
-      snapshotInParallel(new ParallelArgs<K, V>(snapshot, format, options),
+      snapshotInParallel(new ParallelArgs<>(snapshot, format, options),
-      return;
-
-      snapshotInParallel(new ParallelArgs<K, V>(snapshot, format, options),
-          new ParallelImportFunction<K, V>());
-      return;
+      snapshotInParallel(new ParallelArgs<>(snapshot, format, options),
+          new ParallelImportFunction<>());
-    return ((SnapshotOptionsImpl<K, V>) options).isParallelMode()
-        && region.getAttributes().getDataPolicy().withPartitioning()
+    return options.isParallelMode() && region.getAttributes().getDataPolicy().withPartitioning()
+    if (snapshot.isDirectory()) {
+      File[] snapshots =
+          snapshot.listFiles((File f) -> f.getName().endsWith(SNAPSHOT_FILE_EXTENSION));
+      if (snapshots == null) {
+        throw new IOException("Unable to access " + snapshot.getCanonicalPath());
+      } else if (snapshots.length == 0) {
+        throw new IllegalArgumentException("Failure to import snapshot: "
+            + snapshot.getAbsolutePath() + " contains no valid .gfd snapshot files");
+      }
+      for (File snapshotFile : snapshots) {
+        importSnapshotFile(snapshotFile, options, local);
+      }
+    } else if (snapshot.getName().endsWith(SNAPSHOT_FILE_EXTENSION)) {
+      importSnapshotFile(snapshot, options, local);
+    } else {
+      throw new IllegalArgumentException("Failure to import snapshot: "
+          + snapshot.getCanonicalPath() + " is not .gfd file or directory containing .gfd files");
+    }
+  }
+  private void importSnapshotFile(File snapshot, SnapshotOptions<K, V> options, LocalRegion local)
+      throws IOException, ClassNotFoundException {
-    LinkedList<Future<?>> puts = new LinkedList<Future<?>>();
+    LinkedList<Future<?>> puts = new LinkedList<>();
-      Map<K, V> buffer = new HashMap<K, V>();
+      Map<K, V> buffer = new HashMap<>();
-            final Map<K, V> copy = new HashMap<K, V>(buffer);
+            final Map<K, V> copy = new HashMap<>(buffer);
-                .getDistributionManager().getWaitingThreadPool().submit(new Runnable() {
-                  @Override
-                  public void run() {
-                    local.basicImportPutAll(copy, !options.shouldInvokeCallbacks());
-                  }
-                });
+                .getDistributionManager().getWaitingThreadPool().submit((Runnable) () -> local
+                    .basicImportPutAll(copy, !options.shouldInvokeCallbacks()));
-            new Object[] {count, bytes, region.getName(), snapshot});
+            new Object[] {count, bytes, region.getName(), snapshot.getAbsolutePath()});
+    if (!snapshot.getName().endsWith(SNAPSHOT_FILE_EXTENSION)) {
+      throw new IllegalArgumentException("Failure to export snapshot: "
+          + snapshot.getCanonicalPath() + " is not a valid .gfd file");
+    }
+    File directory = snapshot.getAbsoluteFile().getParentFile();
+    if (directory == null) {
+      throw new IllegalArgumentException("Failure to export snapshot: "
+          + snapshot.getCanonicalPath() + " is not a valid location");
+    }
+    directory.mkdirs();
-        getLoggerI18n().info(LocalizedStrings.Snapshot_EXPORT_END_0_1_2_3,
-            new Object[] {count, sink.getBytesWritten(), region.getName(), snapshot});
+        getLoggerI18n().info(LocalizedStrings.Snapshot_EXPORT_END_0_1_2_3, new Object[] {count,
+            sink.getBytesWritten(), region.getName(), snapshot.getAbsolutePath()});
-      return new ClientExporter<K, V>(PoolManager.find(pool));
+      return new ClientExporter<>(PoolManager.find(pool));
-        || region instanceof LocalDataSet || (((SnapshotOptionsImpl<K, V>) options).isParallelMode()
+        || region instanceof LocalDataSet || (options.isParallelMode()
-      return new LocalExporter<K, V>();
+      return new LocalExporter<>();
-    return new WindowedExporter<K, V>();
+    return new WindowedExporter<>();
-
-            if (f.isDirectory() || !f.exists()) {
-              throw new IOException(
-                  LocalizedStrings.Snapshot_INVALID_IMPORT_FILE.toLocalizedString(f));
+            if (f.exists()) {
+              local.getSnapshotService().load(f, args.getFormat(), args.getOptions());
+            } else {
+              LogManager.getLogger(RegionSnapshotServiceImpl.class)
+                  .info("Nothing to import as location does not exist: " + f.getAbsolutePath());
-            local.getSnapshotService().load(f, args.getFormat(), args.getOptions());

GEODE-8170: change all hash and set commands to use function (#5125)

All hash and set commands now use the new function+delta data model.
This allowed the synchronized keyword to be removed from RedisHash and RedisSet.

+    boolean useStripedExecutor = true;
+      case SUNIONSTORE: {
+        ArrayList<ByteArrayWrapper> setKeys = (ArrayList<ByteArrayWrapper>) args[1];
+        callable =
+            () -> new RedisSetInRegion(localRegion).sunionstore(stripedExecutor, key, setKeys);
+        useStripedExecutor = false;
+        break;
+      }
+      case SINTERSTORE: {
+        ArrayList<ByteArrayWrapper> setKeys = (ArrayList<ByteArrayWrapper>) args[1];
+        callable =
+            () -> new RedisSetInRegion(localRegion).sinterstore(stripedExecutor, key, setKeys);
+        useStripedExecutor = false;
+        break;
+      }
+      case SDIFFSTORE: {
+        ArrayList<ByteArrayWrapper> setKeys = (ArrayList<ByteArrayWrapper>) args[1];
+        callable =
+            () -> new RedisSetInRegion(localRegion).sdiffstore(stripedExecutor, key, setKeys);
+        useStripedExecutor = false;
+        break;
+      }
+      case HEXISTS: {
+        ByteArrayWrapper field = (ByteArrayWrapper) args[1];
+        callable = () -> new RedisHashInRegion(localRegion).hexists(key, field);
+        break;
+      }
+      case HGET: {
+        ByteArrayWrapper field = (ByteArrayWrapper) args[1];
+        callable = () -> new RedisHashInRegion(localRegion).hget(key, field);
+        break;
+      }
+      case HLEN: {
+        callable = () -> new RedisHashInRegion(localRegion).hlen(key);
+        break;
+      }
+      case HMGET: {
+        List<ByteArrayWrapper> fields = (List<ByteArrayWrapper>) args[1];
+        callable = () -> new RedisHashInRegion(localRegion).hmget(key, fields);
+        break;
+      }
+      case HVALS: {
+        callable = () -> new RedisHashInRegion(localRegion).hvals(key);
+        break;
+      }
+      case HKEYS: {
+        callable = () -> new RedisHashInRegion(localRegion).hkeys(key);
+        break;
+      }
+      case HSCAN: {
+        Object[] hsetArgs = (Object[]) args[1];
+        Pattern pattern = (Pattern) hsetArgs[0];
+        int count = (int) hsetArgs[1];
+        int cursor = (int) hsetArgs[2];
+        callable = () -> new RedisHashInRegion(localRegion).hscan(key, pattern, count, cursor);
+        break;
+      }
+      case HINCRBY: {
+        Object[] hsetArgs = (Object[]) args[1];
+        ByteArrayWrapper field = (ByteArrayWrapper) hsetArgs[0];
+        long increment = (long) hsetArgs[1];
+        callable = () -> new RedisHashInRegion(localRegion).hincrby(key, field, increment);
+        break;
+      }
+      case HINCRBYFLOAT: {
+        Object[] hsetArgs = (Object[]) args[1];
+        ByteArrayWrapper field = (ByteArrayWrapper) hsetArgs[0];
+        double increment = (double) hsetArgs[1];
+        callable = () -> new RedisHashInRegion(localRegion).hincrbyfloat(key, field, increment);
+        break;
+      }
-    return stripedExecutor.execute(key, callable);
+    if (useStripedExecutor) {
+      return stripedExecutor.execute(key, callable);
+    } else {
+      try {
+        return callable.call();
+      } catch (RuntimeException re) {
+        throw re;
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }

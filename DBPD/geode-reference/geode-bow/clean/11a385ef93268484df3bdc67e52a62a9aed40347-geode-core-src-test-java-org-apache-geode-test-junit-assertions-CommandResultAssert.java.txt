GEODE-3940: fix deadlock in backup messages

When backup sends FlushToDisk, PrepareBackup, and FinishBackup,
it will no longer wait for all other members to respond before
doing the same work on its own member.
In addition to preventing a distributed deadlock, this will
also improve how long it takes for a backup to complete.
As part of this work the backup classes and tests have been
moved into their own backup package.

-import java.util.List;
-import java.util.Optional;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
-public class GfshShellConnectionRuleAssert
-    extends AbstractAssert<GfshShellConnectionRuleAssert, GfshShellConnectionRuleExecution> {
-  public GfshShellConnectionRuleAssert(GfshShellConnectionRule gfsh, CommandResult commandResult) {
-    super(new GfshShellConnectionRuleExecution(gfsh, commandResult),
-        GfshShellConnectionRuleAssert.class);
+public class CommandResultAssert
+    extends AbstractAssert<CommandResultAssert, CommandResultExecution> {
+
+  public CommandResultAssert(CommandResult commandResult) {
+    super(new CommandResultExecution(commandResult.toJson(), commandResult),
+        CommandResultAssert.class);
+  }
+
+  public CommandResultAssert(String output, CommandResult commandResult) {
+    super(new CommandResultExecution(output, commandResult), CommandResultAssert.class);
-  public GfshShellConnectionRuleAssert containsKeyValuePair(String key, String value) {
-    assertThat(actual.getGfshOutput()).containsPattern(key + "\\s+: " + value);
+  public CommandResultAssert containsKeyValuePair(String key, String value) {
+    assertThat(actual.getOutput()).containsPattern(key + "\\s+: " + value);
-  public GfshShellConnectionRuleAssert containsOutput(String... expectedOutputs) {
+  public CommandResultAssert containsOutput(String... expectedOutputs) {
-      assertThat(actual.getGfshOutput()).contains(expectedOutput);
+      assertThat(actual.getOutput()).contains(expectedOutput);
-  public GfshShellConnectionRuleAssert doesNotContainOutput(String... expectedOutputs) {
+  public CommandResultAssert doesNotContainOutput(String... expectedOutputs) {
-      assertThat(actual.getGfshOutput()).doesNotContain(expectedOutput);
+      assertThat(actual.getOutput()).doesNotContain(expectedOutput);
-  public GfshShellConnectionRuleAssert statusIsSuccess() {
+  public CommandResultAssert statusIsSuccess() {
-    Assertions.assertThat(result.getStatus()).describedAs(actual.getGfsh().getGfshOutput())
+    Assertions.assertThat(result.getStatus()).describedAs(actual.getOutput())
-  public GfshShellConnectionRuleAssert statusIsError() {
+  public CommandResultAssert statusIsError() {
-    Assertions.assertThat(result.getStatus()).describedAs(actual.getGfsh().getGfshOutput())
+    Assertions.assertThat(result.getStatus()).describedAs(actual.getOutput())
-  public GfshShellConnectionRuleAssert tableHasColumnWithExactValuesInExactOrder(String header,
+  public CommandResultAssert tableHasColumnWithExactValuesInExactOrder(String header,
-    Object content = resultContentJSON.get(header);
+    Object content = getColumnContent(header, resultContentJSON);
-  public GfshShellConnectionRuleAssert tableHasColumnWithExactValuesInAnyOrder(String header,
+  public CommandResultAssert tableHasColumnWithExactValuesInAnyOrder(String header,
-    Object content = resultContentJSON.get(header);
+    Object content = getColumnContent(header, resultContentJSON);
-  public GfshShellConnectionRuleAssert tableHasColumnWithValuesContaining(String header,
+  public CommandResultAssert tableHasColumnWithValuesContaining(String header,
-    Object content = resultContentJSON.get(header);
+    Object content = getColumnContent(header, resultContentJSON);
-  public GfshShellConnectionRuleAssert hasResult() {
+
+  /**
+   * Verifies that each of the actual values in the column with the given header contains at least
+   * one of the expectedValues.
+   */
+  public CommandResultAssert tableHasColumnOnlyWithValues(String header, String... expectedValues) {
+    GfJsonObject resultContentJSON = actual.getCommandResult().getContent();
+    Object content = getColumnContent(header, resultContentJSON);
+
+    if (content == null) {
+      failWithMessage("Command result did not contain a table with column header <" + header + ">: "
+          + resultContentJSON.toString());
+    }
+
+    Object[] actualValues = toArray((JSONArray) content);
+    assertThat(actualValues).containsOnly(expectedValues);
+    return this;
+  }
+
+  private Object getColumnContent(String header, GfJsonObject resultContentJSON) {
+    if (resultContentJSON.get(header) != null) {
+      return resultContentJSON.get(header);
+    }
+    try {
+      // Sometimes, the output is buried in a most questionable way.
+      return resultContentJSON.getJSONObject("__sections__-0").getJSONObject("__tables__-0")
+          .getJSONObject("content").get(header);
+    } catch (NullPointerException ignored) {
+    }
+    return null;
+  }
+
+  public CommandResultAssert hasResult() {
-  public GfshShellConnectionRuleAssert hasNoResult() {
+  public CommandResultAssert hasNoResult() {

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import java.util.AbstractMap.SimpleImmutableEntry;
+import java.util.Map.Entry;
-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-  protected volatile AtomicInteger numIndexKeys = new AtomicInteger(0);
+  private final AtomicInteger numIndexKeys = new AtomicInteger(0);
-  private InternalIndexStatistics internalIndexStats;
+  private final InternalIndexStatistics internalIndexStats;
-  private Cache cache;
-  private Region region;
+  private final InternalCache cache;
+
+  private final Region region;
+
+
-  private Object TRANSITIONING_TOKEN = new IndexElemArray(1);
+  private final Object TRANSITIONING_TOKEN = new IndexElemArray(1);
-  public MemoryIndexStore(Region region, InternalIndexStatistics internalIndexStats) {
+  MemoryIndexStore(Region region, InternalIndexStatistics internalIndexStats) {
-  public MemoryIndexStore(Region region, InternalIndexStatistics internalIndexStats, Cache cache) {
+  private MemoryIndexStore(Region region, InternalIndexStatistics internalIndexStats,
+      InternalCache cache) {
-  public void updateMapping(Object newKey, Object oldKey, RegionEntry entry, Object oldValue)
+  public void updateMapping(Object indexKey, Object oldKey, RegionEntry re, Object oldValue)
-        if (this.entryToValuesMap.containsKey(entry)) {
-          oldKey = this.entryToValuesMap.get(entry);
+        if (this.entryToValuesMap.containsKey(re)) {
+          oldKey = this.entryToValuesMap.get(re);
-        if (oldValue != null && oldValue == getTargetObjectInVM(entry)) {
-          oldKey = getOldKey(newKey, entry);
+        if (oldValue != null && oldValue == getTargetObjectInVM(re)) {
+          oldKey = getOldKey(indexKey, re);
-      if (oldKey != null && oldKey.equals(TypeUtils.indexKeyFor(newKey))) {
+      if (oldKey != null && oldKey.equals(TypeUtils.indexKeyFor(indexKey))) {
-      newKey = TypeUtils.indexKeyFor(newKey);
-      if (newKey.equals(QueryService.UNDEFINED)) {
-        Object targetObject = getTargetObjectForUpdate(entry);
+      indexKey = TypeUtils.indexKeyFor(indexKey);
+      if (indexKey.equals(QueryService.UNDEFINED)) {
+        Object targetObject = getTargetObjectForUpdate(re);
-            basicRemoveMapping(oldKey, entry, false);
+            basicRemoveMapping(oldKey, re, false);
+
-        Object regionEntries = this.valueToEntriesMap.putIfAbsent(newKey, entry);
+        Object regionEntries = this.valueToEntriesMap.putIfAbsent(indexKey, re);
-          elemArray.add(entry);
-          if (!this.valueToEntriesMap.replace(newKey, regionEntries, elemArray)) {
+          elemArray.add(re);
+          if (!this.valueToEntriesMap.replace(indexKey, regionEntries, elemArray)) {
-            ((IndexConcurrentHashSet) regionEntries).add(entry);
+            ((IndexConcurrentHashSet) regionEntries).add(re);
-          if (regionEntries != this.valueToEntriesMap.get(newKey)) {
+          if (regionEntries != this.valueToEntriesMap.get(indexKey)) {
-              if (!this.valueToEntriesMap.replace(newKey, regionEntries, TRANSITIONING_TOKEN)) {
+              if (!this.valueToEntriesMap.replace(indexKey, regionEntries, TRANSITIONING_TOKEN)) {
-                set.add(entry);
+                set.add(re);
-                if (!this.valueToEntriesMap.replace(newKey, TRANSITIONING_TOKEN, set)) {
+                if (!this.valueToEntriesMap.replace(indexKey, TRANSITIONING_TOKEN, set)) {
-              elemArray.add(entry);
-              if (regionEntries != this.valueToEntriesMap.get(newKey)) {
+              elemArray.add(re);
+              if (regionEntries != this.valueToEntriesMap.get(indexKey)) {
-            basicRemoveMapping(oldKey, entry, false);
+            basicRemoveMapping(oldKey, re, false);
-            this.entryToValuesMap.put(entry, newKey);
+            this.entryToValuesMap.put(re, indexKey);
-      throw new IMQException("Could not add object of type " + newKey.getClass().getName(), ex);
+      throw new IMQException("Could not add object of type " + indexKey.getClass().getName(), ex);
-      Object regionEntries = ((SimpleImmutableEntry) mapEntry).getValue();
-      Object indexKey = ((SimpleImmutableEntry) mapEntry).getKey();
+      Object regionEntries = ((Entry) mapEntry).getValue();
+      Object indexKey = ((Entry) mapEntry).getKey();
-  public void addMapping(Object newKey, RegionEntry entry) throws IMQException {
+  public void addMapping(Object indexKey, RegionEntry re) throws IMQException {
-    updateMapping(newKey, null, entry, null);
+    updateMapping(indexKey, null, re, null);
-  public void removeMapping(Object key, RegionEntry entry) throws IMQException {
+  public void removeMapping(Object indexKey, RegionEntry re) throws IMQException {
-    boolean found = basicRemoveMapping(key, entry, true);
+    boolean found = basicRemoveMapping(indexKey, re, true);
-      this.entryToValuesMap.remove(entry);
+      this.entryToValuesMap.remove(re);
-  protected boolean basicRemoveMapping(Object key, RegionEntry entry, boolean findOldKey)
+  private boolean basicRemoveMapping(Object key, RegionEntry entry, boolean findOldKey)
-      boolean retry = false;
+      boolean retry = false;
-            found = (regionEntries == entry);
+            found = regionEntries == entry;
-    } else if ((!found && !possiblyAlreadyRemoved) && !IndexManager.isObjectModificationInplace()
+    } else if (!found && !possiblyAlreadyRemoved && !IndexManager.isObjectModificationInplace()
-      // The entry might have been already removed by other thread
-      // if still not found
-      // if (!found) {
-      // throw new IMQException("index maintenance error: "
-      // + "entry not found for " + key + " entry: " + entry);
-      // }
-  /**
-   * Convert a RegionEntry or THashSet<RegionEntry> to be consistently a Collection
-   */
-  /*
-   * private Collection regionEntryCollection(Object regionEntries) { if (regionEntries instanceof
-   * RegionEntry) { return Collections.singleton(regionEntries); } return (Collection)
-   * regionEntries; }
-   */
-      } catch (EntryDestroyedException ede) {
+      } catch (EntryDestroyedException ignore) {
+  @Override
-  public Object getTargetObjectForUpdate(RegionEntry entry) {
+  private Object getTargetObjectForUpdate(RegionEntry entry) {
-      return (obj instanceof RegionEntry) ? 1 : ((Collection) obj).size();
+      return obj instanceof RegionEntry ? 1 : ((Collection) obj).size();
-
-    protected Iterator<Map.Entry> mapIterator;
-    protected Iterator valuesIterator;
-    protected Object currKey;
-    protected Object currValue; // RegionEntry
+    Iterator<Map.Entry> mapIterator;
+    Iterator valuesIterator;
+    Object currKey;
+    Object currValue; // RegionEntry
-    protected MemoryIndexStoreEntry currentEntry;
+    MemoryIndexStoreEntry currentEntry;
-    private MemoryIndexStoreIterator(Map submap, Object indexKey, Collection keysToRemove) {
+    MemoryIndexStoreIterator(Map submap, Object indexKey, Collection keysToRemove) {

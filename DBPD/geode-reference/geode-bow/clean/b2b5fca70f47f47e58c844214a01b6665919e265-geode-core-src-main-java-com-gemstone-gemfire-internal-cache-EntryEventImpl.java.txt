GEODE-1691: protect EntryEvent off-heap readers

The methods on EntryEvent that can read off-heap
data from the event are now protected from a concurrent
release of the off-heap data.

+import java.util.function.Function;
-          CachedDeserializable cd = (CachedDeserializable)ov;
-          if (doCopyOnRead) {
-            return cd.getDeserializedWritableCopy(this.region, this.re);
-          } else {
-            return cd.getDeserializedValue(this.region, this.re);
-          }
+          return callWithOffHeapLock((CachedDeserializable)ov, oldValueCD -> {
+            if (doCopyOnRead) {
+              return oldValueCD.getDeserializedWritableCopy(this.region, this.re);
+            } else {
+              return oldValueCD.getDeserializedValue(this.region, this.re);
+            }
+          });
-        CachedDeserializable cd = (CachedDeserializable)nv;
-        Object v = null;
-        if (doCopyOnRead) {
-          v = cd.getDeserializedWritableCopy(this.region, this.re);
-        } else {
-          v = cd.getDeserializedValue(this.region, this.re);
-        }
-        assert !(v instanceof CachedDeserializable) : "for key "+this.getKey()+" found nested CachedDeserializable";
-        return v;
+        return callWithOffHeapLock((CachedDeserializable)nv, newValueCD -> {
+          Object v = null;
+          if (doCopyOnRead) {
+            v = newValueCD.getDeserializedWritableCopy(this.region, this.re);
+          } else {
+            v = newValueCD.getDeserializedValue(this.region, this.re);
+          }
+          assert !(v instanceof CachedDeserializable) : "for key "+this.getKey()+" found nested CachedDeserializable";
+          return v;
+        });
+  
+  /**
+   * Invoke the given function with a lock if the given value is offheap.
+   * @return the value returned from invoking the function
+   */
+  private <T,R> R callWithOffHeapLock(T value, Function<T, R> function) {
+    if (isOffHeapReference(value)) {
+      synchronized (this.offHeapLock) {
+        if (!this.offHeapOk) {
+          throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+        }
+        return function.apply(value);
+      }
+    } else {
+      return function.apply(value);
+    }
+  }
+  
+  private final Object offHeapLock = new Object();
-      ArrayUtils.objectStringNonRecursive(basicGetOldValue(), buf);
+      synchronized (this.offHeapLock) {
+        ArrayUtils.objectStringNonRecursive(basicGetOldValue(), buf);
+      }
-      ArrayUtils.objectStringNonRecursive(basicGetNewValue(), buf);
+      synchronized (this.offHeapLock) {
+        ArrayUtils.objectStringNonRecursive(basicGetNewValue(), buf);
+      }
+    @Override
-      return getCd().getSerializedValue();
+      return callWithOffHeapLock(cd -> {
+        return cd.getSerializedValue();
+      });
+    /**
+     * The only methods that need to use this method are those on the external SerializedCacheValue interface
+     * and any other method that a customer could call that may access the off-heap values.
+     * For example if toString was implemented on this class to access the value then it would
+     * need to use this method.
+     */
+    private <R> R callWithOffHeapLock(Function<CachedDeserializable, R> function) {
+      if (this.event != null) {
+        // this call does not use getCd() to access this.cd
+        // because the check for offHeapOk is done by event.callWithOffHeapLock
+        return this.event.callWithOffHeapLock(this.cd, function);
+      } else {
+        return function.apply(getCd());
+      }
+    }
+    @Override
-      return OffHeapHelper.getHeapForm(getCd().getDeserializedForReading());
+      return getCd().getDeserializedForReading();
-      return OffHeapHelper.getHeapForm(getCd().getDeserializedWritableCopy(rgn, entry));
+      return getCd().getDeserializedWritableCopy(rgn, entry);
-      return OffHeapHelper.getHeapForm(getCd().getDeserializedValue(rgn, reentry));
+      return callWithOffHeapLock(cd -> {
+        return cd.getDeserializedValue(rgn, reentry);
+      });
-  private transient boolean offHeapOk = true;
+  transient boolean offHeapOk = true;
-    // Note that this method does not set the old/new values to null but
-    // leaves them set to the off-heap value so that future calls to getOld/NewValue
-    // will fail with an exception.
-    Object ov = basicGetOldValue();
-    Object nv = basicGetNewValue();
-    this.offHeapOk = false;
-    
-    if (ov instanceof StoredObject) {
-      //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
-      if (ReferenceCountHelper.trackReferenceCounts()) {
-        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
-        ((StoredObject) ov).release();
-        ReferenceCountHelper.setReferenceCountOwner(null);
-      } else {
-        ((StoredObject) ov).release();
+    synchronized (this.offHeapLock) {
+      // Note that this method does not set the old/new values to null but
+      // leaves them set to the off-heap value so that future calls to getOld/NewValue
+      // will fail with an exception.
+      testHookReleaseInProgress();
+      Object ov = basicGetOldValue();
+      Object nv = basicGetNewValue();
+      this.offHeapOk = false;
+
+      if (ov instanceof StoredObject) {
+        //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
+        if (ReferenceCountHelper.trackReferenceCounts()) {
+          ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+          ((StoredObject) ov).release();
+          ReferenceCountHelper.setReferenceCountOwner(null);
+        } else {
+          ((StoredObject) ov).release();
+        }
+      OffHeapHelper.releaseAndTrackOwner(nv, this);
-    OffHeapHelper.releaseAndTrackOwner(nv, this);
+  }
+  
+  void testHookReleaseInProgress() {
+    // unit test can mock or override this method
-    this.offHeapOk = false;
+    synchronized (this.offHeapLock) {
+      this.offHeapOk = false;
+    }
-    Object ov = basicGetOldValue();
-    if (isOffHeapReference(ov)) {
-      if (ReferenceCountHelper.trackReferenceCounts()) {
-        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
-        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
-        ReferenceCountHelper.setReferenceCountOwner(null);
-      } else {
-        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+    synchronized (this.offHeapLock) {
+      Object ov = basicGetOldValue();
+      if (isOffHeapReference(ov)) {
+        if (ReferenceCountHelper.trackReferenceCounts()) {
+          ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+          this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+          ReferenceCountHelper.setReferenceCountOwner(null);
+        } else {
+          this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+        }
+      Object nv = basicGetNewValue();
+      if (isOffHeapReference(nv)) {
+        ReferenceCountHelper.setReferenceCountOwner(this);
+        this.newValue = OffHeapHelper.copyAndReleaseIfNeeded(nv);
+        ReferenceCountHelper.setReferenceCountOwner(null);
+      }
+      if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
+        throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
+      }
+      this.offHeapOk = false;
-    Object nv = basicGetNewValue();
-    if (isOffHeapReference(nv)) {
-      ReferenceCountHelper.setReferenceCountOwner(this);
-      this.newValue = OffHeapHelper.copyAndReleaseIfNeeded(nv);
-      ReferenceCountHelper.setReferenceCountOwner(null);
-    }
-    if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
-      throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
-    }
-    this.offHeapOk = false;

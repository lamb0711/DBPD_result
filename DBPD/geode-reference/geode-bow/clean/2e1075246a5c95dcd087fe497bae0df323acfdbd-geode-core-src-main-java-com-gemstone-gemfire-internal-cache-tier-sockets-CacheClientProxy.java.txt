Merge branch 'release/1.0.0-incubating.M3'

+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.ThreadState;
+import com.gemstone.gemfire.GemFireIOException;
-import com.gemstone.gemfire.cache.query.CqQuery;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import com.gemstone.gemfire.i18n.StringId;
-import com.gemstone.gemfire.internal.cache.ClientServerObserver;
-import com.gemstone.gemfire.internal.cache.ClientServerObserverHolder;
+import com.gemstone.gemfire.internal.cache.ClientServerObserver;
+import com.gemstone.gemfire.internal.cache.ClientServerObserverHolder;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl;
+import com.gemstone.gemfire.internal.security.GeodeSecurityUtil;
+import com.gemstone.gemfire.internal.util.BlobHelper;
-import com.gemstone.gemfire.i18n.StringId;
- * @since 4.2
+ * @since GemFire 4.2
-  protected static final int MAXIMUM_SHUTDOWN_PEEKS = Integer.getInteger("gemfire.MAXIMUM_SHUTDOWN_PEEKS",50).intValue();
+  protected static final int MAXIMUM_SHUTDOWN_PEEKS = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAXIMUM_SHUTDOWN_PEEKS", 50).intValue();
-      .getBoolean("gemfire.disableNotificationWarnings");
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableNotificationWarnings");
-  /** @since 5.7 */
+  /** @since GemFire 5.7 */
+  private Subject subject;
-   * @since 6.1
+   * @since GemFire 6.1
-      .getBoolean("gemfire.updateAccessTimeOnClientInterest");   
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "updateAccessTimeOnClientInterest");
+
+  public void setSubject(Subject subject) {
+    //TODO:hitesh synchronization
+    synchronized (this.clientUserAuthsLock) {
+      if (this.subject != null) {
+        subject.logout();
+      }
+      this.subject = subject;
+    }
+  }
-   * @since 5.5
+   * @since GemFire 5.5
-          Get70 request = (Get70)Get70.getCommand();
-          LocalRegion lr = (LocalRegion) this._cache.getRegion(regionName);
-          Get70.Entry entry = request.getValueAndIsObject(lr, keyOfInterest, null,
-              null);
-          boolean isObject = entry.isObject;
-          byte[] value = null;
-          if (entry.value instanceof byte[]) {
-            value = (byte[])entry.value;
-          } else {
-            try {
-              value = CacheServerHelper.serialize(entry.value);
-            } catch (IOException e) {
-              logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_THE_FOLLOWING_EXCEPTION_OCCURRED_0, entry.value), e);
-            }
-          }
-          VersionTag tag = entry.versionTag;
-          ClientUpdateMessage updateMessage = new ClientUpdateMessageImpl(
-              EnumListenerEvent.AFTER_CREATE, lr, keyOfInterest, value, null,
-              (isObject ? (byte) 0x01 : (byte) 0x00), null, this.proxyID,
-              new EventID(this._cache.getDistributedSystem()), tag);
-          CacheClientNotifier.routeSingleClientMessage(updateMessage, this.proxyID);
+          enqueueInitialValue(null, regionName, keyOfInterest);
+    enqueueInterestRegistrationMessage(message);
+  }
+
+  private void enqueueInitialValue(ClientInterestMessageImpl clientInterestMessage, String regionName, Object keyOfInterest) {
+    // Get the initial value
+    Get70 request = (Get70)Get70.getCommand();
+    LocalRegion lr = (LocalRegion) this._cache.getRegion(regionName);
+    Get70.Entry entry = request.getValueAndIsObject(lr, keyOfInterest, null, null);
+    boolean isObject = entry.isObject;
+    byte[] value = null;
+
+    // If the initial value is not null, add it to the client's queue
+    if (entry.value != null) {
+      if (entry.value instanceof byte[]) {
+        value = (byte[])entry.value;
+      } else {
+        try {
+          value = CacheServerHelper.serialize(entry.value);
+        } catch (IOException e) {
+          logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_THE_FOLLOWING_EXCEPTION_OCCURRED_0, entry.value), e);
+        }
+      }
+      VersionTag tag = entry.versionTag;
+
+      // Initialize the event id.
+      EventID eventId = null;
+      if (clientInterestMessage == null) {
+        // If the clientInterestMessage is null, create a new event id
+        eventId = new EventID(this._cache.getDistributedSystem());
+      } else {
+        // If the clientInterestMessage is not null, base the event id off its event id to fix GEM-794.
+        // This will cause the updateMessage created below to have the same event id as the one created
+        // in the primary.
+        eventId = new EventID(clientInterestMessage.getEventId(), 1);
+      }
+      ClientUpdateMessage updateMessage = new ClientUpdateMessageImpl(
+          EnumListenerEvent.AFTER_CREATE, lr, keyOfInterest, value, null,
+          (isObject ? (byte) 0x01 : (byte) 0x00), null, this.proxyID,
+          eventId, tag);
+      CacheClientNotifier.routeSingleClientMessage(updateMessage, this.proxyID);
+    }
+  }
+  
+  private void enqueueInterestRegistrationMessage(ClientInterestMessageImpl message) {
+    // Enqueue the interest registration message for the client.
-        && keyOfInterest instanceof List) {
-      for (Iterator i = ((List) keyOfInterest).iterator(); i.hasNext();) {
-        this._messageDispatcher.enqueueMessage(new ClientInterestMessageImpl(
-            new EventID(this._cache.getDistributedSystem()), regionName,
-            i.next(), interestType, policy.getOrdinal(), isDurable, !receiveValues,
-            ClientInterestMessageImpl.REGISTER));
+        && message.getKeyOfInterest() instanceof List) {
+      for (Iterator i = ((List) message.getKeyOfInterest()).iterator(); i.hasNext();) {
+        this._messageDispatcher.enqueueMessage(new ClientInterestMessageImpl(message, i.next()));
-    // If the client is not 7.0.1 or greater and the key of interest is a list,
-    // then create an individual message for each entry in the list since the
-    // client doesn't support a ClientInterestMessageImpl containing a list.
-    if (Version.GFE_701.compareTo(this.clientVersion) > 0
-        && keyOfInterest instanceof List) {
-      for (Iterator i = ((List) keyOfInterest).iterator(); i.hasNext();) {
-        this._messageDispatcher.enqueueMessage(new ClientInterestMessageImpl(
-            new EventID(this._cache.getDistributedSystem()), regionName,
-            i.next(), interestType, (byte) 0, isDurable, !receiveValues,
-            ClientInterestMessageImpl.UNREGISTER));
-      }
-    } else {
-      this._messageDispatcher.enqueueMessage(message);
-    }
+    enqueueInterestRegistrationMessage(message);
+    // Register or unregister interest depending on the interest type
-    } 
+    }
+    
+    // Enqueue the interest message in this secondary proxy (fix for bug #52088)
+    enqueueInterestRegistrationMessage(message);
+    
+    // Enqueue the initial value if the message is register on a key that is not a list (fix for bug #52088)
+    if (message.isRegister()
+        && message.getInterestType() == InterestType.KEY
+        && !(key instanceof List)
+        && InterestResultPolicy.fromOrdinal(message.getInterestResultPolicy()) == InterestResultPolicy.KEYS_VALUES) {
+      enqueueInitialValue(message, regionName, key);
+    }
+    ThreadState state = GeodeSecurityUtil.bindSubject(this.subject);
+    // post process
+    if(GeodeSecurityUtil.needPostProcess()) {
+      Object oldValue = clientMessage.getValue();
+      if (clientMessage.valueIsObject()) {
+        Object newValue = GeodeSecurityUtil.postProcess(clientMessage.getRegionName(), clientMessage.getKeyOfInterest(), EntryEventImpl
+          .deserialize((byte[]) oldValue));
+        try {
+          clientMessage.setLatestValue(BlobHelper.serializeToBlob(newValue));
+        } catch (IOException e) {
+          throw new GemFireIOException("Exception serializing entry value", e);
+        }
+      } else {
+        Object newValue = GeodeSecurityUtil.postProcess(clientMessage.getRegionName(), clientMessage.getKeyOfInterest(), oldValue);
+        clientMessage.setLatestValue(newValue);
+      }
+    }
+
+
+    if(state!=null)
+      state.clear();
-     * @guarded.By _pausedLock
+     * guarded.By _pausedLock
-        if (this._proxy._cache.getCancelCriterion().cancelInProgress() != null) {
+        if (this._proxy._cache.getCancelCriterion().isCancelInProgress()) {
+      if (logger.isTraceEnabled()) {
+        logger.trace("{}: Sent {}", this, message);
+      }
-   * @since 6.1
+   * @since GemFire 6.1
-   * @since 7.0
+   * @since GemFire 7.0

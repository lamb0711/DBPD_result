Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.distributed.internal.SharedConfiguration;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
-  
+
-  
+
-   * Deploys the jars received from shared configuration, it undeploys any other jars that were not part of shared configuration 
+   * Deploys the jars received from shared configuration, it undeploys any other jars that were not
+   * part of shared configuration
+   * 
-   * @param response {@link ConfigurationResponse} received from the locators 
-   * @throws IOException 
-   * @throws ClassNotFoundException 
+   * @param response {@link ConfigurationResponse} received from the locators
+   * @throws IOException
+   * @throws ClassNotFoundException
-  public static void deployJarsReceivedFromClusterConfiguration(Cache cache , ConfigurationResponse response) throws IOException, ClassNotFoundException {
-    if(response == null)
+  public static void deployJarsReceivedFromClusterConfiguration(Cache cache,
+      ConfigurationResponse response) throws IOException, ClassNotFoundException {
+    if (response == null)
-    String []jarFileNames = response.getJarNames();
-    byte [][]jarBytes = response.getJars();
-    
-    final JarDeployer jarDeployer = new JarDeployer(((GemFireCacheImpl) cache).getDistributedSystem().getConfig().getDeployWorkingDir());
+    String[] jarFileNames = response.getJarNames();
+    byte[][] jarBytes = response.getJars();
+
+    final JarDeployer jarDeployer = new JarDeployer(
+        ((GemFireCacheImpl) cache).getDistributedSystem().getConfig().getDeployWorkingDir());
-        } 
+        }
+   * 
-  public static void applyClusterXmlConfiguration(Cache cache , ConfigurationResponse response, DistributionConfig config) {
-    if(response == null || response.getRequestedConfiguration().isEmpty())
+  public static void applyClusterXmlConfiguration(Cache cache, ConfigurationResponse response,
+      DistributionConfig config) {
+    if (response == null || response.getRequestedConfiguration().isEmpty())
-    Configuration clusterConfiguration = requestedConfiguration.get(SharedConfiguration.CLUSTER_CONFIG);
+    Configuration clusterConfiguration =
+        requestedConfiguration.get(ClusterConfigurationService.CLUSTER_CONFIG);
+   * 
-  public static void applyClusterPropertiesConfiguration(Cache cache , ConfigurationResponse response, DistributionConfig config) {
-    if(response == null || response.getRequestedConfiguration().isEmpty())
+  public static void applyClusterPropertiesConfiguration(Cache cache,
+      ConfigurationResponse response, DistributionConfig config) {
+    if (response == null || response.getRequestedConfiguration().isEmpty())
-    Configuration clusterConfiguration = requestedConfiguration.get(SharedConfiguration.CLUSTER_CONFIG);
+    Configuration clusterConfiguration =
+        requestedConfiguration.get(ClusterConfigurationService.CLUSTER_CONFIG);
-      String attValue = runtimeProps.getProperty(attName) ;
+      String attValue = runtimeProps.getProperty(attName);
-  
+
-   * Request the shared configuration for group(s) from locator(s) this member is bootstrapped with. 
+   * Request the shared configuration for group(s) from locator(s) this member is bootstrapped with.
+   *
+   * This will request the group config this server belongs plus the "cluster" config
+   * 
-   * @throws ClusterConfigurationNotAvailableException 
-   * @throws UnknownHostException 
+   * @throws ClusterConfigurationNotAvailableException
+   * @throws UnknownHostException
-  public static ConfigurationResponse requestConfigurationFromLocators(DistributionConfig config, List<String> locatorList) throws ClusterConfigurationNotAvailableException, UnknownHostException {
+  public static ConfigurationResponse requestConfigurationFromLocators(DistributionConfig config,
+      List<String> locatorList)
+      throws ClusterConfigurationNotAvailableException, UnknownHostException {
-    request.addGroups(SharedConfiguration.CLUSTER_CONFIG);
+    request.addGroups(ClusterConfigurationService.CLUSTER_CONFIG);
-    
+
-    
+
-    //Try talking to all the locators in the list
-    //to get the shared configuration.
+    // Try talking to all the locators in the list
+    // to get the shared configuration.
-      
+
-      
+
-        
+
-          response = (ConfigurationResponse)client.requestToServer(locatorInetAddress, port, request, 10000);
-        } catch (UnknownHostException e) {
-          e.printStackTrace();
-        } catch (IOException e) {
-          // TODO Log
-          e.printStackTrace();
-        } catch (ClassNotFoundException e) {
-          e.printStackTrace();
-        }
+        response = (ConfigurationResponse) client.requestToServer(locatorInetAddress, port, request,
+            10000);
+      } catch (UnknownHostException e) {
+        e.printStackTrace();
+      } catch (IOException e) {
+        // TODO Log
+        e.printStackTrace();
+      } catch (ClassNotFoundException e) {
+        e.printStackTrace();
-    // if the response is null , that means Shared Configuration service is not installed on the locator
+    }
+    // if the response is null , that means Shared Configuration service is not installed on the
+    // locator
-    
+
-      throw new ClusterConfigurationNotAvailableException(LocalizedStrings.Launcher_Command_FAILED_TO_GET_SHARED_CONFIGURATION.toLocalizedString());
-    } 
+      throw new ClusterConfigurationNotAvailableException(
+          LocalizedStrings.Launcher_Command_FAILED_TO_GET_SHARED_CONFIGURATION.toLocalizedString());
+    }
- 
- /***
-  * Get the host and port information of the locators 
-  * @return List made up of a String array containing host and port 
-  */
- public static List<String[]> getLocatorsInfo(String locatorsString) {
-   List<String[]> locatorList = new ArrayList<String[]>();
-
-   if (!StringUtils.isBlank(locatorsString)) {
-     String[] bootstrappedlocators = locatorsString.split(",");
-     for (String bootstrappedlocator : bootstrappedlocators) {
-       locatorList.add(bootstrappedlocator.split("\\[|]"));
-     }
-   }
-   return locatorList;
- }
- 
- public static List<String[]> getLocatorsInfo(List<String> locatorConnectionStrings) {
-   List<String[]> locatorList = new ArrayList<String[]>();
-   
-   for (String locatorConnectionString : locatorConnectionStrings) {
-     locatorList.add(locatorConnectionString.split("\\[|]"));
-   }
-   return locatorList;
- }
- 
- 

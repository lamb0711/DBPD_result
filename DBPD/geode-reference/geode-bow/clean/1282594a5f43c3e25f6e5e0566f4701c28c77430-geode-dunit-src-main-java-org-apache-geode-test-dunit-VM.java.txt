GEODE-7475: Include remote stack trace in AsyncInvocation timeout (#4344)

* Add stack trace of remote thread as the cause of an AsyncInvocation TimeoutException
* Clean up AsyncInvocation and SerializableRunnable/SerializableCallable hierarchy of classes
* New tests for StackTrace, VM.dumpThreads, and AsyncInvocation asyncTimeoutHandler
* Deprecate and reorganize some additional dunit methods that are either not used or have a newer preferred alternative
* Trigger remote VM to dump all threads to stdout when an AsyncInvocation times out
+import static org.apache.geode.test.dunit.internal.AsyncThreadId.nextId;
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadInfo;
+import java.lang.management.ThreadMXBean;
+import java.util.Arrays;
+import java.util.Objects;
+import org.apache.geode.test.dunit.internal.IdentifiableCallable;
+import org.apache.geode.test.dunit.internal.IdentifiableRunnable;
-
+  private static final Object[] EMPTY = new Object[0];
+
-  private int id;
+  private final int id;
+  public static int getVMId() {
+    return DUnitEnv.get().getId();
+  }
+
+  /**
+   * @deprecated Please use {@link #getVMId()} instead.
+   */
+  @Deprecated
-    return DUnitEnv.get().getVMID();
+    return DUnitEnv.get().getId();
+  public static String dumpThreads() {
+    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
+    long[] allThreadIds = threadMXBean.getAllThreadIds();
+    ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(allThreadIds, true, true);
+
+    StringBuilder dumpWriter = new StringBuilder();
+    Arrays.stream(threadInfos)
+        .filter(Objects::nonNull)
+        .forEach(dumpWriter::append);
+    return dumpWriter.toString();
+  }
+
-   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead
+   * @deprecated Please use {@link #invokeAsync(SerializableCallableIF)} instead
-   * @param args Arguments passed to the method call (must be {@link java.io.Serializable}).
+   * @param args Arguments passed to the method call (must be {@link Serializable}).
-   * @param args Arguments passed to the method call (must be {@link java.io.Serializable}).
+   * @param args Arguments passed to the method call (must be {@link Serializable}).
-    return new AsyncInvocation<V>(targetObject, methodName,
-        () -> invoke(targetObject, methodName, args)).start();
+    return AsyncInvocation
+        .<V>create(targetObject, methodName, () -> invoke(targetObject, methodName, args), this)
+        .start();
-   * @param args Arguments passed to the method call (must be {@link java.io.Serializable}).
+   * @param args Arguments passed to the method call (must be {@link Serializable}).
-    return new AsyncInvocation<V>(targetClass, methodName,
-        () -> invoke(targetClass, methodName, args)).start();
+    return AsyncInvocation
+        .<V>create(targetClass, methodName, () -> invoke(targetClass, methodName, args), this)
+        .start();
-    return invokeAsync(runnable, "run", new Object[0]);
+    IdentifiableRunnable target = new IdentifiableRunnable(nextId(), runnable);
+    return AsyncInvocation
+        .<V>create(target, () -> invoke(target, target.getMethodName(), EMPTY), this).start();
-   * {@link NamedRunnable} having the given name so it shows up in DUnit logs.
+   * {@link IdentifiableRunnable} having the given name so it shows up in DUnit logs.
-    return invokeAsync(new NamedRunnable(name, runnable), "run", new Object[0]);
+    IdentifiableRunnable target = new IdentifiableRunnable(nextId(), name, runnable);
+    return AsyncInvocation
+        .<V>create(target, () -> invoke(target, target.getMethodName(), EMPTY), this).start();
-    return invokeAsync(new NamedCallable<>(name, callable), "call", new Object[0]);
+    IdentifiableCallable<V> target = new IdentifiableCallable<>(nextId(), name, callable);
+    return AsyncInvocation.create(target, () -> invoke(target, target.getMethodName(), EMPTY), this)
+        .start();
-    return invokeAsync(callable, "call", new Object[0]);
+    IdentifiableCallable<V> target = new IdentifiableCallable<>(nextId(), callable);
+    return AsyncInvocation.create(target, () -> invoke(target, target.getMethodName(), EMPTY), this)
+        .start();
-    checkAvailability(NamedRunnable.class.getName(), "run");
-    executeMethodOnObject(new NamedRunnable(name, runnable), "run", new Object[0]);
+    checkAvailability(IdentifiableRunnable.class.getName(), "run");
+    executeMethodOnObject(new IdentifiableRunnable(name, runnable), "run", new Object[0]);
-    checkAvailability(NamedCallable.class.getName(), "call");
-    return executeMethodOnObject(new NamedCallable<>(name, callable), "call", new Object[0]);
+    checkAvailability(IdentifiableCallable.class.getName(), "call");
+    return executeMethodOnObject(new IdentifiableCallable<>(name, callable), "call", new Object[0]);
-   * @param args Arguments passed to the method call (must be {@link java.io.Serializable}).
+   * @param args Arguments passed to the method call (must be {@link Serializable}).

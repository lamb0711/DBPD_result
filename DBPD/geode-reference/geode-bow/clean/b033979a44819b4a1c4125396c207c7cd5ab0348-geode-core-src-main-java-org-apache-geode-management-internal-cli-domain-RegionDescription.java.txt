GEODE-3955: Preparing, refactoring, and addition of test utility

* Cleanup of DescribeRegionCommand for better readability and
testability.
* Flattened unnecessarily-nested logic blocks
* Removed dead class fields from RegionDescription,
RegionAttributesDefault
* GetRegionDescriptionFunction implements Function instead of extending
deprecated FunctionAdapter
* Added waitTilGatewaySendersAreReady to MemberVM, MemberStarterRule

-import java.util.Iterator;
-import java.util.List;
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.RegionShortcut;
- *
- *
-  private boolean haslocalDataStorage;
-  private boolean isReplicatedProxy = false;;
-  public RegionDescription() {
-
-  }
+  public RegionDescription() {}
-   * @param regionDescPerMember
-   *
+   * @return boolean describing if description was successfully added
-      regionDescPerMemberMap = new HashMap<String, RegionDescriptionPerMember>();
+      regionDescPerMemberMap = new HashMap<>();
-      haslocalDataStorage = this.dataPolicy.withStorage();
-      this.cndRegionAttributes = new HashMap<String, String>();
+      this.cndRegionAttributes = new HashMap<>();
-      this.cndPartitionAttributes = new HashMap<String, String>();
+      this.cndPartitionAttributes = new HashMap<>();
-      this.cndEvictionAttributes = new HashMap<String, String>();
+      this.cndEvictionAttributes = new HashMap<>();
-      if (this.dataPolicy.equals(DataPolicy.EMPTY) && this.scope.equals(Scope.DISTRIBUTED_ACK)) {
-        isReplicatedProxy = true;
-      }
+      isAdded = true;
+    } else if (this.scope.equals(regionDescPerMember.getScope())
+        && this.name.equals(regionDescPerMember.getName())
+        && this.dataPolicy.equals(regionDescPerMember.getDataPolicy())
+        && this.isAccessor == regionDescPerMember.isAccessor()) {
-      // Don't have to show the scope for PR's
-
+      regionDescPerMemberMap.put(regionDescPerMember.getHostingMember(), regionDescPerMember);
+      findCommon(cndRegionAttributes, regionDescPerMember.getNonDefaultRegionAttributes());
+      findCommon(cndEvictionAttributes, regionDescPerMember.getNonDefaultEvictionAttributes());
+      findCommon(cndPartitionAttributes, regionDescPerMember.getNonDefaultPartitionAttributes());
-    } else {
-      if (this.scope.equals(regionDescPerMember.getScope())
-          && this.name.equals(regionDescPerMember.getName())
-          && this.dataPolicy.equals(regionDescPerMember.getDataPolicy())
-          && this.isAccessor == regionDescPerMember.isAccessor()) {
-
-        regionDescPerMemberMap.put(regionDescPerMember.getHostingMember(), regionDescPerMember);
-        findCommon(cndRegionAttributes, regionDescPerMember.getNonDefaultRegionAttributes());
-        findCommon(cndEvictionAttributes, regionDescPerMember.getNonDefaultEvictionAttributes());
-        findCommon(cndPartitionAttributes, regionDescPerMember.getNonDefaultPartitionAttributes());
-
-        isAdded = true;
-      }
-  private void findCommon(Map<String, String> commonNdMap, Map<String, String> incomingNdMap) {
-    // First get the intersection of the both maps
+  /**
+   * Removes any key-value pairs from @commonValuesMap that do not agree with the respective
+   * key-value pairs of @additionalValuesMap
+   *
+   * @param commonValuesMap Common values map, whose key set will be reduced.
+   * @param additionalValuesMap Incoming values map, against which @commonValuesMap.
+   */
+  static void findCommon(Map<String, String> commonValuesMap,
+      Map<String, String> additionalValuesMap) {
-    Set<String> commonNdKeySet = commonNdMap.keySet();
-    Set<String> incomingNdKeySet = incomingNdMap.keySet();
+    Set<String> sharedKeySet = commonValuesMap.keySet();
+    sharedKeySet.retainAll(additionalValuesMap.keySet());
-    commonNdKeySet.retainAll(incomingNdKeySet);
-
-    // Now compare the values
-    // Take a copy of the set to avoid a CME
-    Iterator<String> commonKeysIter = (new HashSet<String>(commonNdKeySet)).iterator();
-
-    while (commonKeysIter.hasNext()) {
-      String attribute = commonKeysIter.next();
-      String commonNdValue = commonNdMap.get(attribute);
-      String incomingNdValue = incomingNdMap.get(attribute);
-
-      if (commonNdValue != null) {
-        if (!commonNdValue.equals(incomingNdValue)) {
-          // Remove it from the commonNdMa
-          commonNdMap.remove(attribute);
-        }
-      } else {
-        if (incomingNdValue != null) {
-          commonNdMap.remove(attribute);
-        }
+    for (String sharedKey : new HashSet<>(sharedKeySet)) {
+      String commonNdValue = commonValuesMap.get(sharedKey);
+      String incomingNdValue = additionalValuesMap.get(sharedKey);
+      if (commonNdValue != null && !commonNdValue.equals(incomingNdValue)
+          || commonNdValue == null && incomingNdValue != null) {
+        commonValuesMap.remove(sharedKey);
-  public boolean hasLocalStorage() {
-    return this.haslocalDataStorage;
-  }
-
-  public boolean isReplicatedProxy() {
-    return this.isReplicatedProxy;
-  }
-
-
-   * Get
+   * Gets the common, non-default region attributes
-   * Gets the common non-default Eviction Attributes
+   * Gets the common, non-default eviction attributes
-   * Gets the common non-default PartitionAttributes
+   * Gets the common, non-default partition attributes
-
+  public boolean isEmpty() {
+    return regionDescPerMemberMap == null || regionDescPerMemberMap.isEmpty();
+  }

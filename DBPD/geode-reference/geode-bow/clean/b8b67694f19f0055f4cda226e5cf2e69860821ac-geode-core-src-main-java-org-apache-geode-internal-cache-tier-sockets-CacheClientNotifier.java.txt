Merge branch 'develop' into feature/GEODE-7049

-import java.util.concurrent.locks.ReentrantLock;
-import org.apache.geode.internal.Version;
+import org.apache.geode.internal.concurrent.ConcurrentHashSet;
+import org.apache.geode.internal.serialization.Version;
+import org.apache.geode.internal.statistics.StatisticsClock;
-  private final ClientRegistrationEventQueueManager registrationQueueManager =
-      new ClientRegistrationEventQueueManager();
+  private final ClientRegistrationEventQueueManager clientRegistrationEventQueueManager;
+   * @param clientRegistrationEventQueueManager Manages temporary registration queues for clients
-      CacheServerStats acceptorStats, int maximumMessageCount, int messageTimeToLive,
-      ConnectionListener listener, OverflowAttributes overflowAttributes,
+      ClientRegistrationEventQueueManager clientRegistrationEventQueueManager,
+      StatisticsClock statisticsClock,
+      CacheServerStats acceptorStats,
+      int maximumMessageCount,
+      int messageTimeToLive,
+      ConnectionListener listener,
+      OverflowAttributes overflowAttributes,
-      ccnSingleton = new CacheClientNotifier(cache, acceptorStats, maximumMessageCount,
-          messageTimeToLive, listener, isGatewayReceiver);
+      ccnSingleton = new CacheClientNotifier(cache, clientRegistrationEventQueueManager,
+          statisticsClock, acceptorStats,
+          maximumMessageCount, messageTimeToLive, listener, isGatewayReceiver);
-        registrationQueueManager.create(clientProxyMembershipID, new ConcurrentLinkedQueue<>(),
-            new ReentrantReadWriteLock(), new ReentrantLock());
+        ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =
+            clientRegistrationEventQueueManager.create(clientProxyMembershipID,
+                new ConcurrentLinkedQueue<>(),
+                new ReentrantReadWriteLock());
-          if (isProxyInitialized(clientProxyMembershipID)) {
-            registrationQueueManager.drain(clientProxyMembershipID, this);
-          }
+          clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, this);
-                clientVersion,
-                acceptorId, notifyBySubscription, cache.getSecurityService(), subject);
+                clientVersion, acceptorId, notifyBySubscription, cache.getSecurityService(),
+                subject, statisticsClock);
-              clientVersion, acceptorId, notifyBySubscription, cache.getSecurityService(), subject);
+              clientVersion, acceptorId, notifyBySubscription, cache.getSecurityService(), subject,
+              statisticsClock);
-    registrationQueueManager.add(event, conflatable, filterClients, this);
+    clientRegistrationEventQueueManager.add(event, conflatable, filterClients, this);
-    if (ids.remove(event.getContext())) {
-      CacheClientProxy ccp = getClientProxy(event.getContext());
-      if (ccp != null) {
-        ccp.getStatistics().incMessagesNotQueuedOriginator();
+    ClientProxyMembershipID eventOriginator = event.getContext();
+    if (eventOriginator != null) {
+      if (ids.remove(eventOriginator)) {
+        CacheClientProxy ccp = getClientProxy(eventOriginator);
+        if (ccp != null) {
+          ccp.getStatistics().incMessagesNotQueuedOriginator();
+        }
-    Set<ClientProxyMembershipID> result = new HashSet<>();
+    Set<ClientProxyMembershipID> result = new ConcurrentHashSet<>();
-   * Determines whether a client proxy has been initialized
-   *
-   * @param clientProxyMembershipID The client proxy membership ID
-   * @return Whether the client proxy is initialized
-   */
-  private boolean isProxyInitialized(final ClientProxyMembershipID clientProxyMembershipID) {
-    return getClientProxy(clientProxyMembershipID) != null;
-  }
-
-  /**
-  private CacheClientNotifier(InternalCache cache, CacheServerStats acceptorStats,
-      int maximumMessageCount, int messageTimeToLive, ConnectionListener listener,
-      boolean isGatewayReceiver) {
+  private CacheClientNotifier(InternalCache cache,
+      ClientRegistrationEventQueueManager clientRegistrationEventQueueManager,
+      StatisticsClock statisticsClock,
+      CacheServerStats acceptorStats, int maximumMessageCount,
+      int messageTimeToLive,
+      ConnectionListener listener, boolean isGatewayReceiver) {
+    this.clientRegistrationEventQueueManager = clientRegistrationEventQueueManager;
+    this.statisticsClock = statisticsClock;
+  private final StatisticsClock statisticsClock;
+
-    CacheClientNotifier get(InternalCache cache, CacheServerStats acceptorStats,
-        int maximumMessageCount, int messageTimeToLive, ConnectionListener listener,
-        OverflowAttributes overflowAttributes, boolean isGatewayReceiver);
+    CacheClientNotifier get(InternalCache cache,
+        ClientRegistrationEventQueueManager clientRegistrationEventQueueManager,
+        StatisticsClock statisticsClock,
+        CacheServerStats acceptorStats, int maximumMessageCount, int messageTimeToLive,
+        ConnectionListener listener, OverflowAttributes overflowAttributes,
+        boolean isGatewayReceiver);

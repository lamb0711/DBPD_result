Merge branch 'release/1.5.0'

-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Set;
-import org.apache.geode.cache.CacheException;
-import org.apache.geode.cache.CacheFactory;
-import org.apache.geode.cache.LowMemoryException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
-import org.apache.geode.internal.cache.partitioned.PutMessage;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+import org.apache.geode.internal.cache.TXManagerImpl;
+import org.apache.geode.internal.cache.TXStateProxy;
+import org.apache.geode.internal.cache.TransactionMessage;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
- * The base PartitionedRegion message type upon which other messages should be based.
+ * The base message type upon which other messages that need to be sent to a remote member that is
+ * hosting a transaction should be based. Note that, currently, some of these message are not used
+ * by transactions. This is a misuse of these messages and needs to be corrected.
-  /** default exception to ensure a false-positive response is never returned */
-  static final ForceReattemptException UNHANDLED_EXCEPTION =
-      (ForceReattemptException) new ForceReattemptException(
-          LocalizedStrings.PartitionMessage_UNKNOWN_EXCEPTION.toLocalizedString())
-              .fillInStackTrace();
-
+    this(regionPath, processor);
+  }
+
+  private RemoteOperationMessage(String regionPath, ReplyProcessor21 processor) {
-    setIfTransactionDistributed();
-  }
-
-  public RemoteOperationMessage(Set recipients, String regionPath, ReplyProcessor21 processor) {
-    setRecipients(recipients);
-    this.regionPath = regionPath;
-    this.processorId = processor == null ? 0 : processor.getProcessorId();
-    if (processor != null && isSevereAlertCompatible()) {
-      processor.enableSevereAlertProcessing();
-    }
-    this.txUniqId = TXManagerImpl.getCurrentTXUniqueId();
-    TXStateProxy txState = TXManagerImpl.getCurrentTXState();
-    if (txState != null && txState.isMemberIdForwardingRequired()) {
-      this.txMemberId = txState.getOriginatingMember();
-    }
-    setIfTransactionDistributed();
-  }
-
-  /**
-   * Copy constructor that initializes the fields declared in this class
-   */
-  public RemoteOperationMessage(RemoteOperationMessage other) {
-    this.regionPath = other.regionPath;
-    this.processorId = other.processorId;
-    this.txUniqId = other.getTXUniqId();
-    this.txMemberId = other.getTXMemberId();
-    this.isTransactionDistributed = other.isTransactionDistributed;
+    setIfTransactionDistributed(processor);
-    return DistributionManager.PARTITIONED_REGION_EXECUTOR;
+    return ClusterDistributionManager.SERIAL_EXECUTOR;
-  public boolean checkCacheClosing(DistributionManager dm) {
-    InternalCache cache = dm.getCache();
+  public boolean checkCacheClosing(InternalCache cache) {
-  public boolean checkDSClosing(DistributionManager dm) {
+  public boolean checkDSClosing(ClusterDistributionManager dm) {
-   * @throws PartitionedRegionException if the region does not exist (typically, if it has been
-   *         destroyed)
+   * @throws RegionDestroyedException if the region does not exist
-  public void process(final DistributionManager dm) {
+  public void process(final ClusterDistributionManager dm) {
-      if (checkCacheClosing(dm) || checkDSClosing(dm)) {
-        thr = new CacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0
-            .toLocalizedString(dm.getId()));
+      InternalCache cache = getCache(dm);
+      if (checkCacheClosing(cache) || checkDSClosing(dm)) {
+        String message = "Remote cache is closed: " + dm.getId();
+        if (cache == null) {
+          thr = new CacheClosedException(message);
+        } else {
+          thr = cache.getCacheClosedException(message);
+        }
-      InternalCache cache = getCache(dm);
-        // if the distributed system is disconnecting, don't send a reply saying
-        // the partitioned region can't be found (bug 36585)
-      thr = UNHANDLED_EXCEPTION;
-
-      thr = null;
-
-    } catch (RemoteOperationException fre) {
-      thr = fre;
+    } catch (RegionDestroyedException | RemoteOperationException ex) {
+      thr = ex;
-    } catch (RegionDestroyedException rde) {
-      // [bruce] RDE does not always mean that the sender's region is also
-      // destroyed, so we must send back an exception. If the sender's
-      // region is also destroyed, who cares if we send it an exception
-      // if (pr != null && pr.isClosed) {
-      thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_REGION_IS_DESTROYED_IN_0
-          .toLocalizedString(dm.getDistributionManagerId()), rde);
-      // }
+      thr = new RemoteOperationException("VirtualMachineError", err);
-      SystemFailure.checkFailure();
-      // log the exception at fine level if there is no reply to the message
-      thr = null;
+      if (sendReply) {
+        thr = new RemoteOperationException("system failure", SystemFailure.getFailure());
+      }
+      checkForSystemFailure();
-          thr = new ForceReattemptException(
-              LocalizedStrings.PartitionMessage_DISTRIBUTED_SYSTEM_IS_DISCONNECTING
-                  .toLocalizedString());
+          thr = new RemoteOperationException("cache is closing");
+  protected void checkForSystemFailure() {
+    SystemFailure.checkFailure();
+  }
+
-    return internalCache.getRegionByPathForProcessing(this.regionPath);
+    return (LocalRegion) internalCache.getRegionByPathForProcessing(getRegionPath());
-  InternalCache getCache(final DistributionManager dm) {
+  InternalCache getCache(final ClusterDistributionManager dm) {
-   *
-   * @param pr the Partitioned Region for the message whose statistics are incremented
-   * @param startTime the start time of the operation in nanoseconds
-   * @see PutMessage#sendReply
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
-      LocalRegion pr, long startTime) {
-    // if (pr != null && startTime > 0) {
-    // pr.getPrStats().endRemoteOperationMessagesProcessing(startTime);
-    // }
-
-    ReplyMessage.send(member, procId, ex, getReplySender(dm), pr != null && pr.isInternalRegion());
+  protected void sendReply(InternalDistributedMember member, int procId, DistributionManager dm,
+      ReplyException ex, LocalRegion r, long startTime) {
+    ReplyMessage.send(member, procId, ex, getReplySender(dm), r != null && r.isInternalRegion());
-
-  /**
-   * return a new reply processor for this class, for use in relaying a response. This <b>must</b>
-   * be an instance method so subclasses can override it properly.
-   */
-  RemoteOperationResponse createReplyProcessor(PartitionedRegion r, Set recipients) {
-    return new RemoteOperationResponse(r.getSystem(), recipients);
-  }
-
-
-  protected abstract boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
-      throws RemoteOperationException;
+  protected abstract boolean operateOnRegion(ClusterDistributionManager dm, LocalRegion r,
+      long startTime) throws RemoteOperationException;
-   * @see #waitForCacheException()
+   * @see #waitForRemoteResponse()
-    /**
-     * The exception thrown when the recipient does not reply
-     */
-    volatile ForceReattemptException prce;
+
+    private volatile RemoteOperationException memberDepartedException;
-    volatile boolean responseReceived;
+    private volatile boolean responseReceived;
-    boolean responseRequired;
+    private boolean responseRequired;
-    public RemoteOperationResponse(InternalDistributedSystem dm, Collection initMembers) {
-      this(dm, initMembers, true);
-    }
-
-    public RemoteOperationResponse(InternalDistributedSystem dm, Collection initMembers,
+    public RemoteOperationResponse(InternalDistributedSystem dm, Collection<?> initMembers,
-    public void memberDeparted(final InternalDistributedMember id, final boolean crashed) {
+    public void memberDeparted(DistributionManager distributionManager,
+        final InternalDistributedMember id, final boolean crashed) {
-          this.prce = new ForceReattemptException(
-              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
-                  .toLocalizedString(id, crashed));
+          this.memberDepartedException = new RemoteOperationException(
+              "memberDeparted event for <" + id + "> crashed = " + crashed);
-        Exception e = new Exception(
-            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0, crashed),
-            e);
+        Exception e = new Exception("memberDeparted got null memberId");
+        logger.info("memberDeparted got null memberId crashed=" + crashed, e);
+    public RemoteOperationException getMemberDepartedException() {
+      return this.memberDepartedException;
+    }
+
-     * @throws CacheException if the recipient threw a cache exception during message processing
+     * @throws RemoteOperationException if the member we waited for a response from departed
+     * @throws RemoteOperationException if a response was required and not received
+     * @throws RemoteOperationException if the ReplyException was caused by a
+     *         RemoteOperationException
+     * @throws RemoteOperationException if the remote side's cache was closed
-    public void waitForCacheException()
-        throws CacheException, RemoteOperationException, PrimaryBucketException {
+    public void waitForRemoteResponse() throws RemoteOperationException {
-        if (this.prce != null || (this.responseRequired && !this.responseReceived)) {
-          throw new RemoteOperationException(
-              LocalizedStrings.PartitionMessage_ATTEMPT_FAILED.toLocalizedString(), this.prce);
+        RemoteOperationException ex = getMemberDepartedException();
+        if (ex != null) {
+          throw ex;
+        }
+        if (this.responseRequired && !this.responseReceived) {
+          throw new RemoteOperationException("response required but not received");
-        if (t instanceof CacheException) {
-          throw (CacheException) t;
-        } else if (t instanceof RemoteOperationException) {
-          RemoteOperationException ft = (RemoteOperationException) t;
-          // See FetchEntriesMessage, which can marshal a ForceReattempt
-          // across to the sender
-          RemoteOperationException fre = new RemoteOperationException(
-              LocalizedStrings.PartitionMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-          if (ft.hasHash()) {
-            fre.setHash(ft.getHash());
-          }
-          throw fre;
-        } else if (t instanceof PrimaryBucketException) {
-          // See FetchEntryMessage, GetMessage, InvalidateMessage,
-          // PutMessage
-          // which can marshal a ForceReattemptacross to the sender
-          throw new PrimaryBucketException(
-              LocalizedStrings.PartitionMessage_PEER_FAILED_PRIMARY_TEST.toLocalizedString(), t);
-        } else if (t instanceof RegionDestroyedException) {
-          throw (RegionDestroyedException) t;
+        if (t instanceof RemoteOperationException) {
+          // no need to create a local RemoteOperationException to wrap the one from the reply
+          throw (RemoteOperationException) t;
-                "RemoteOperationResponse got CacheClosedException from {}, throwing ForceReattemptException",
+                "RemoteOperationResponse got CacheClosedException from {}, throwing RemoteOperationException",
-          throw new RemoteOperationException(
-              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION
-                  .toLocalizedString(),
-              t);
-        } else if (t instanceof LowMemoryException) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("RemoteOperationResponse re-throwing remote LowMemoryException from {}",
-                e.getSender(), t);
-          }
-          throw (LowMemoryException) t;
+          throw new RemoteOperationException("remote cache was closed", t);
-        e.handleAsUnexpected();
+        e.handleCause();
-  public void setTransactionDistributed(boolean isDistTx) {
-    this.isTransactionDistributed = isDistTx;
-  }
-
-  /*
-   * For Distributed Tx
-   */
-  private void setIfTransactionDistributed() {
-    InternalCache cache = GemFireCacheImpl.getInstance();
-    if (cache != null) {
-      if (cache.getTxManager() != null) {
-        this.isTransactionDistributed = cache.getTxManager().isDistributed();
+  private void setIfTransactionDistributed(ReplyProcessor21 processor) {
+    if (processor != null) {
+      DistributionManager distributionManager = processor.getDistributionManager();
+      if (distributionManager != null) {
+        InternalCache cache = distributionManager.getCache();
+        if (cache != null && cache.getTxManager() != null) {
+          this.isTransactionDistributed = cache.getTxManager().isDistributed();
+        }

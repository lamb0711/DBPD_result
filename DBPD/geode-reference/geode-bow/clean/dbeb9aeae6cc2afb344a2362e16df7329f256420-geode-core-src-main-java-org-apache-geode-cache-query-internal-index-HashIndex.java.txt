Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.cache.EntryNotFoundException;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
- * A HashIndex is an index that can be used for equal and not equals queries It
- * is created only when called explicitly with createHashIndex It requires the
- * indexed expression be a path expression and the from clause has only one
- * iterator. This implies there is only one value in the index for each region
- * entry.
+ * A HashIndex is an index that can be used for equal and not equals queries It is created only when
+ * called explicitly with createHashIndex It requires the indexed expression be a path expression
+ * and the from clause has only one iterator. This implies there is only one value in the index for
+ * each region entry.
-  
+
-   * Map for valueOf(indexedExpression)=>RegionEntries. SortedMap<Object,
-   * (RegionEntry | List<RegionEntry>)>. Package access for unit tests.
+   * Map for valueOf(indexedExpression)=>RegionEntries. SortedMap<Object, (RegionEntry |
+   * List<RegionEntry>)>. Package access for unit tests.
-   * Map for RegionEntries=>value of indexedExpression (reverse map)
- maintained by the HashIndexSet entrieSet
+   * Map for RegionEntries=>value of indexedExpression (reverse map) maintained by the HashIndexSet
+   * entrieSet
-   * @param indexName
-   *          the name of this index, used for statistics collection
-   * @param indexedExpression
-   *          the expression to index on, a function dependent on region entries
-   *          individually, limited to a path expression.
-   * @param fromClause
-   *          expression that evaluates to the collection(s) that will be
-   *          queried over, must contain one and only one region path, and only
-   *          one iterator.
-   * @param projectionAttributes
-   *          not used
-   * @param definitions
-   *          the canonicalized definitions
+   * @param indexName the name of this index, used for statistics collection
+   * @param indexedExpression the expression to index on, a function dependent on region entries
+   *        individually, limited to a path expression.
+   * @param fromClause expression that evaluates to the collection(s) that will be queried over,
+   *        must contain one and only one region path, and only one iterator.
+   * @param projectionAttributes not used
+   * @param definitions the canonicalized definitions
-  public HashIndex(String indexName, Region region, String fromClause,
-      String indexedExpression, String projectionAttributes,
-      String origFromClause, String origIndexExpr, String[] definitions,
-      IndexStatistics stats) {
-    super(indexName, region, fromClause, indexedExpression,
-        projectionAttributes, origFromClause, origIndexExpr, definitions, stats);
+  public HashIndex(String indexName, Region region, String fromClause, String indexedExpression,
+      String projectionAttributes, String origFromClause, String origIndexExpr,
+      String[] definitions, IndexStatistics stats) {
+    super(indexName, region, fromClause, indexedExpression, projectionAttributes, origFromClause,
+        origIndexExpr, definitions, stats);
-      entryToValuesMap = new ConcurrentHashMap(ra.getInitialCapacity(),
-          ra.getLoadFactor(), ra.getConcurrencyLevel());
-    }
-    else {
+      entryToValuesMap = new ConcurrentHashMap(ra.getInitialCapacity(), ra.getLoadFactor(),
+          ra.getConcurrencyLevel());
+    } else {
-    
+
-    this.internalIndexStats.incNumUpdates(((IMQEvaluator) this.evaluator)
-        .getTotalEntriesUpdated());
+    this.internalIndexStats.incNumUpdates(((IMQEvaluator) this.evaluator).getTotalEntriesUpdated());
-   * Add/Updates the index forward and reverse map. If index key for a
-   * RegionEntry is found same as previous key no update is performed.
+   * Add/Updates the index forward and reverse map. If index key for a RegionEntry is found same as
+   * previous key no update is performed.
-   * This also updates the {@link IndexStatistics} numKeys and numValues as and
-   * when appropriate. One thing to notice though is no increment in numValues
-   * is performed if old key and new index key are found equal using
-   * {@link Object#equals(Object)}.
+   * This also updates the {@link IndexStatistics} numKeys and numValues as and when appropriate.
+   * One thing to notice though is no increment in numValues is performed if old key and new index
+   * key are found equal using {@link Object#equals(Object)}.
-  private void basicAddMapping(Object key, RegionEntry entry)
-      throws IMQException {
+  private void basicAddMapping(Object key, RegionEntry entry) throws IMQException {
-          //This should not happen as a token should only be added during gii
-          //meaning we do not have an old mapping
+          // This should not happen as a token should only be added during gii
+          // meaning we do not have an old mapping
-          if (IndexManager.isObjectModificationInplace() && this.entryToValuesMap.containsKey(entry)){
+          if (IndexManager.isObjectModificationInplace()
+              && this.entryToValuesMap.containsKey(entry)) {
-          }
-          else if (!IndexManager.isObjectModificationInplace() && this.entryToOldKeysMap != null) {
+          } else if (!IndexManager.isObjectModificationInplace()
+              && this.entryToOldKeysMap != null) {
-            if (logger.isDebugEnabled()) { 
-              logger.debug("A removed or invalid token was being added, and we had an old mapping.");
+            if (logger.isDebugEnabled()) {
+              logger
+                  .debug("A removed or invalid token was being added, and we had an old mapping.");
-      
+
-      
+
-      
+
-      throw new IMQException("Could not add object of type "
-          + key.getClass().getName(), ex);
+      throw new IMQException("Could not add object of type " + key.getClass().getName(), ex);
-  
+
-   * @param opCode
-   *          one of OTHER_OP, BEFORE_UPDATE_OP, AFTER_UPDATE_OP.
+   * @param opCode one of OTHER_OP, BEFORE_UPDATE_OP, AFTER_UPDATE_OP.
-   * Remove an index entry for a RegionEntry when invalidate/destroy is called
-   * OR new index key is inserted for the RegionEntry. In case of update only
-   * forward map is cleared of old key and NO update is performed on reverse map
-   * as that has already been done during
+   * Remove an index entry for a RegionEntry when invalidate/destroy is called OR new index key is
+   * inserted for the RegionEntry. In case of update only forward map is cleared of old key and NO
+   * update is performed on reverse map as that has already been done during
-   * @param key
-   *          - Index key.
-   * @param entry
-   *          RegionEntry for which is being updated by user.
-   * @param updateReverseMap
-   *          true only when RegionEntry is invalidated/destroyed.
+   * @param key - Index key.
+   * @param entry RegionEntry for which is being updated by user.
+   * @param updateReverseMap true only when RegionEntry is invalidated/destroyed.
-  private void basicRemoveMapping(Object key, RegionEntry entry,
-      boolean updateReverseMap) throws IMQException {
+  private void basicRemoveMapping(Object key, RegionEntry entry, boolean updateReverseMap)
+      throws IMQException {
-      throw new IMQException("Could not add object of type "
-          + key.getClass().getName(), ex);
+      throw new IMQException("Could not add object of type " + key.getClass().getName(), ex);
-  
+
-  
-  private void removeFromEntriesSet(Object newKey, RegionEntry entry, boolean updateReverseMap, int ignoreThisSlot) {
+
+  private void removeFromEntriesSet(Object newKey, RegionEntry entry, boolean updateReverseMap,
+      int ignoreThisSlot) {
-  public List queryEquijoinCondition(IndexProtocol indx,
-      ExecutionContext context) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
+  public List queryEquijoinCondition(IndexProtocol indx, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-    ((AbstractIndex)indx).updateIndexUseStats();
+    ((AbstractIndex) indx).updateIndexUseStats();
-    Iterator  inner = null;
+    Iterator inner = null;
-      if(indx instanceof CompactRangeIndex){
+      if (indx instanceof CompactRangeIndex) {
-      } else{
+      } else {
-    outer: 
-      while (outer.hasNext()) {
+      outer: while (outer.hasNext()) {
-        //}
+        // }
-      inner:
-        while (!incrementInner || inner.hasNext()) {
+        inner: while (!incrementInner || inner.hasNext()) {
-            if(innerEntry instanceof IndexStoreEntry){
-              innerKey = ((IndexStoreEntry)innerEntry).getDeserializedKey();
-            } else{
-              innerKey = ((Map.Entry)innerEntry).getKey();
+            if (innerEntry instanceof IndexStoreEntry) {
+              innerKey = ((IndexStoreEntry) innerEntry).getDeserializedKey();
+            } else {
+              innerKey = ((Map.Entry) innerEntry).getKey();
-            if(innerEntry instanceof IndexStoreEntry){
+            if (innerEntry instanceof IndexStoreEntry) {
-            } else{
-              innerValue = ((Map.Entry)innerEntry).getValue();
+            } else {
+              innerValue = ((Map.Entry) innerEntry).getValue();
-            populateListForEquiJoin(data,
-                outerEntry.getValue(),
-                innerValue, context, innerKey);            
-            
+            populateListForEquiJoin(data, outerEntry.getValue(), innerValue, context, innerKey);
+
-          }
-          else if (compare < 0) {
-            //Asif :The outer key is smaller than the inner key. That means
+          } else if (compare < 0) {
+            // Asif :The outer key is smaller than the inner key. That means
-            //incrementOuter = true;
+            // incrementOuter = true;
-          }
-          else {
-            //The outer key is greater than inner key , so increment the
+          } else {
+            // The outer key is greater than inner key , so increment the
-    }
-    finally {
-      ((AbstractIndex)indx).updateIndexUseEndStats(start);
+    } finally {
+      ((AbstractIndex) indx).updateIndexUseEndStats(start);
-   * This evaluates the left and right side of a EQUI-JOIN where condition for
-   * which this Index was used. Like, if condition is "p.ID = e.ID",
-   * {@link IndexInfo} will contain Left as p.ID, Right as e.ID and operator as
-   * TOK_EQ. This method will evaluate p.ID OR e.ID based on if it is inner or
-   * outer RegionEntry, and verify the p.ID = e.ID.
+   * This evaluates the left and right side of a EQUI-JOIN where condition for which this Index was
+   * used. Like, if condition is "p.ID = e.ID", {@link IndexInfo} will contain Left as p.ID, Right
+   * as e.ID and operator as TOK_EQ. This method will evaluate p.ID OR e.ID based on if it is inner
+   * or outer RegionEntry, and verify the p.ID = e.ID.
-  private boolean verifyInnerAndOuterEntryValues(RegionEntry entry,
-      ExecutionContext context, IndexInfo indexInfo, Object keyVal)
-      throws FunctionDomainException, TypeMismatchException,
+  private boolean verifyInnerAndOuterEntryValues(RegionEntry entry, ExecutionContext context,
+      IndexInfo indexInfo, Object keyVal) throws FunctionDomainException, TypeMismatchException,
-   * @param outerEntries
-   *          is a Set<RegionEntry>
-   * @param innerEntries
-   *          is a Set<RegionEntry>
+   * @param outerEntries is a Set<RegionEntry>
+   * @param innerEntries is a Set<RegionEntry>
-  private void populateListForEquiJoin(List list, Collection outerEntries,
-      Collection innerEntries, ExecutionContext context, Object key)
-      throws FunctionDomainException, TypeMismatchException,
+  private void populateListForEquiJoin(List list, Collection outerEntries, Collection innerEntries,
+      ExecutionContext context, Object key) throws FunctionDomainException, TypeMismatchException,
-          IndexInfo[] indexInfo = (IndexInfo[]) context
-              .cacheGet(CompiledValue.INDEX_INFO);
+          IndexInfo[] indexInfo = (IndexInfo[]) context.cacheGet(CompiledValue.INDEX_INFO);
-      case OQLLexerTokenTypes.TOK_EQ: {
-        key = TypeUtils.indexKeyFor(key);
-        size = this.entriesSet.size(key);
-      }
-      break;
-      case OQLLexerTokenTypes.TOK_NE_ALT:
-      case OQLLexerTokenTypes.TOK_NE:
-        size = this.region.size();
-        key = TypeUtils.indexKeyFor(key);
-        size = this.entriesSet.size(key);
-        break;
+        case OQLLexerTokenTypes.TOK_EQ: {
+          key = TypeUtils.indexKeyFor(key);
+          size = this.entriesSet.size(key);
+        }
+          break;
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE:
+          size = this.region.size();
+          key = TypeUtils.indexKeyFor(key);
+          size = this.entriesSet.size(key);
+          break;
-   * Convert a RegionEntry or THashSet<RegionEntry> to be consistently a
-   * Collection
+   * Convert a RegionEntry or THashSet<RegionEntry> to be consistently a Collection
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, Set keysToRemove, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-      throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
+      CompiledValue iterOps, RuntimeIterator runtimeItr, ExecutionContext context, Set keysToRemove,
+      List projAttrib, SelectResults intermediateResults, boolean isIntersection)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-    Boolean applyLimit = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+    Boolean applyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT))
-          .intValue();
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
-    Boolean orderByClause = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    evaluate(key, operator, results, iterOps, runtimeItr, context,
-        keysToRemove, projAttrib, intermediateResults, isIntersection, limit,
-        applyOrderBy, orderByAttrs);
+    evaluate(key, operator, results, iterOps, runtimeItr, context, keysToRemove, projAttrib,
+        intermediateResults, isIntersection, limit, applyOrderBy, orderByAttrs);
-  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator,
-      Object upperBoundKey, int upperBoundOperator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
+  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-  private void evaluate(Object key, int operator, Collection results,
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, Set keysToRemove, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection, int limit,
-      boolean applyOrderBy, List orderByAttribs) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException {
+  private void evaluate(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, Set keysToRemove, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit, boolean applyOrderBy,
+      List orderByAttribs) throws TypeMismatchException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
-    if(key == null) {
+    if (key == null) {
-      
+
-      case OQLLexerTokenTypes.TOK_EQ:
-        assert keysToRemove.isEmpty();
-        addToResultsFromEntries(this.entriesSet.get(key), results, iterOps,
-            runtimeItr, context, projAttrib, intermediateResults,
-            isIntersection, multiColOrderBy ? -1 : limit, keysToRemove, applyOrderBy, asc, iteratorCreationTime);
-        break;
-      case OQLLexerTokenTypes.TOK_NE_ALT:
-      case OQLLexerTokenTypes.TOK_NE: {
-        keysToRemove.add(key);
-        addToResultsFromEntries(this.entriesSet.getAllNotMatching(keysToRemove), results, iterOps,
-            runtimeItr, context, projAttrib, intermediateResults,
-            isIntersection, multiColOrderBy ? -1 : limit, keysToRemove, applyOrderBy, asc, iteratorCreationTime);
+        case OQLLexerTokenTypes.TOK_EQ:
+          assert keysToRemove.isEmpty();
+          addToResultsFromEntries(this.entriesSet.get(key), results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit,
+              keysToRemove, applyOrderBy, asc, iteratorCreationTime);
+          break;
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE: {
+          keysToRemove.add(key);
+          addToResultsFromEntries(this.entriesSet.getAllNotMatching(keysToRemove), results, iterOps,
+              runtimeItr, context, projAttrib, intermediateResults, isIntersection,
+              multiColOrderBy ? -1 : limit, keysToRemove, applyOrderBy, asc, iteratorCreationTime);
-        break;
-      default:
-        throw new AssertionError("Operator = " + operator);
+          break;
+        default:
+          throw new AssertionError("Operator = " + operator);
-            runtimeItr, context, projAttrib, intermediateResults,
-            isIntersection, multiColOrderBy ? -1 : limit, keysToRemove, applyOrderBy, asc,
-                iteratorCreationTime);
+            runtimeItr, context, projAttrib, intermediateResults, isIntersection,
+            multiColOrderBy ? -1 : limit, keysToRemove, applyOrderBy, asc, iteratorCreationTime);
-    this.entriesSet.setEvaluator((HashIndex.IMQEvaluator)evaluator);
+    this.entriesSet.setEvaluator((HashIndex.IMQEvaluator) evaluator);
-   * @param entriesIter
-   *          is Iterable<RegionEntry>
+   * @param entriesIter is Iterable<RegionEntry>
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection, int limit, Set keysToRemove, boolean applyOrderBy, boolean asc, long iteratorCreationTime)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      CompiledValue iterOps, RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit, Set keysToRemove,
+      boolean applyOrderBy, boolean asc, long iteratorCreationTime) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    if ( result == null
-        || (limit != -1 && result != null && result.size() == limit)) {
+    if (result == null || (limit != -1 && result != null && result.size() == limit)) {
-    if(applyOrderBy) {
+    if (applyOrderBy) {
-          key = ((HashIndex.IMQEvaluator)evaluator).evaluateKey(obj);
-          orderedKeys.add(new Object[]{key,i++});
-          addValueToResultSet(re, orderedResults, iterOps, runtimeItr, context, projAttrib, intermediateResults, isIntersection, limit, observer, iteratorCreationTime);
+          key = ((HashIndex.IMQEvaluator) evaluator).evaluateKey(obj);
+          orderedKeys.add(new Object[] {key, i++});
+          addValueToResultSet(re, orderedResults, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit, observer, iteratorCreationTime);
-          addValueToResultSet(re, result, iterOps, runtimeItr, context, projAttrib, intermediateResults, isIntersection, limit, observer, iteratorCreationTime);
+          addValueToResultSet(re, result, iterOps, runtimeItr, context, projAttrib,
+              intermediateResults, isIntersection, limit, observer, iteratorCreationTime);
-       * For orderby queries, 
-       * 1. Store the keys in a list along with the order.
-       * 2. Store the results in another temp list.
-       * 3. Sort the keys. The order will also get sorted.
-       * 4. Fetch the result objects from the temp list according to 
-       *    the sorted orders from the sorted list and add to the result 
-       *    collection.
+       * For orderby queries, 1. Store the keys in a list along with the order. 2. Store the results
+       * in another temp list. 3. Sort the keys. The order will also get sorted. 4. Fetch the result
+       * objects from the temp list according to the sorted orders from the sorted list and add to
+       * the result collection.
-        int index = (Integer) ((Object[])o)[1];
+        int index = (Integer) ((Object[]) o)[1];
-  private void addValueToResultSet(RegionEntry re, Collection result,
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection, int limit,
-      QueryObserver observer, long iteratorCreationTime) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+  private void addValueToResultSet(RegionEntry re, Collection result, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit, QueryObserver observer,
+      long iteratorCreationTime) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-      //If the region entry is currently being updated or it has been modified since starting iteration
-      //we will reevaluate to be sure the value still matches the key
-      if (re.isUpdateInProgress() || IndexManager.needsRecalculation(iteratorCreationTime, re.getLastModified())) {
-        IndexInfo indexInfo = (IndexInfo) context
-            .cacheGet(CompiledValue.INDEX_INFO);
+      // If the region entry is currently being updated or it has been modified since starting
+      // iteration
+      // we will reevaluate to be sure the value still matches the key
+      if (re.isUpdateInProgress()
+          || IndexManager.needsRecalculation(iteratorCreationTime, re.getLastModified())) {
+        IndexInfo indexInfo = (IndexInfo) context.cacheGet(CompiledValue.INDEX_INFO);
-            //could not match index with iterator
+            // could not match index with iterator
-          applyProjection(projAttrib, context, result, value,
-              intermediateResults, isIntersection);
+          applyProjection(projAttrib, context, result, value, intermediateResults, isIntersection);
-  
+
-   * This evaluates the left and right side of a where condition for which this
-   * Index was used. Like, if condition is "ID > 1", {@link IndexInfo} will
-   * contain Left as ID, Right as '1' and operator as TOK_GT. This method will
-   * evaluate ID from region entry value and verify the ID > 1.
+   * This evaluates the left and right side of a where condition for which this Index was used.
+   * Like, if condition is "ID > 1", {@link IndexInfo} will contain Left as ID, Right as '1' and
+   * operator as TOK_GT. This method will evaluate ID from region entry value and verify the ID > 1.
-   * Note: IndexInfo is created for each query separately based on the condition
-   * being evaluated using the Index.
+   * Note: IndexInfo is created for each query separately based on the condition being evaluated
+   * using the Index.
-   * @return true if RegionEntry value satisfies the where condition (contained
-   *         in IndexInfo).
+   * @return true if RegionEntry value satisfies the where condition (contained in IndexInfo).
-  private boolean evaluateEntry(IndexInfo indexInfo, ExecutionContext context,
-      Object keyVal) throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  private boolean evaluateEntry(IndexInfo indexInfo, ExecutionContext context, Object keyVal)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      return ((Boolean) TypeUtils.compare(left, right, operator))
-          .booleanValue();
+      return ((Boolean) TypeUtils.compare(left, right, operator)).booleanValue();
-   * Get the object of interest from the region entry. For now it always gets
-   * the deserialized value.
+   * Get the object of interest from the region entry. For now it always gets the deserialized
+   * value.
-  
+
-          o = ((CachedDeserializable)o).getDeserializedForReading();
+          o = ((CachedDeserializable) o).getDeserializedForReading();
-//    sb.append("Null Values\n");
-//    Iterator nI = nullMappedEntries.iterator();
-//    while (nI.hasNext()) {
-//      RegionEntry e = (RegionEntry) nI.next();
-//      Object value = getTargetObject(e);
-//      sb.append("  RegionEntry.key = ").append(e.getKey());
-//      sb.append("  Value.type = ").append(value.getClass().getName());
-//      if (value instanceof Collection) {
-//        sb.append("  Value.size = ").append(((Collection) value).size());
-//      }
-//      sb.append("\n");
-//    }
-//    sb.append(" -----------------------------------------------\n");
-//    sb.append("Undefined Values\n");
-//    Iterator uI = undefinedMappedEntries.iterator();
-//    while (uI.hasNext()) {
-//      RegionEntry e = (RegionEntry) uI.next();
-//      Object value = getTargetObject(e);
-//      sb.append("  RegionEntry.key = ").append(e.getKey());
-//      sb.append("  Value.type = ").append(value.getClass().getName());
-//      if (value instanceof Collection) {
-//        sb.append("  Value.size = ").append(((Collection) value).size());
-//      }
-//      sb.append("\n");
-//    }
+    // sb.append("Null Values\n");
+    // Iterator nI = nullMappedEntries.iterator();
+    // while (nI.hasNext()) {
+    // RegionEntry e = (RegionEntry) nI.next();
+    // Object value = getTargetObject(e);
+    // sb.append(" RegionEntry.key = ").append(e.getKey());
+    // sb.append(" Value.type = ").append(value.getClass().getName());
+    // if (value instanceof Collection) {
+    // sb.append(" Value.size = ").append(((Collection) value).size());
+    // }
+    // sb.append("\n");
+    // }
+    // sb.append(" -----------------------------------------------\n");
+    // sb.append("Undefined Values\n");
+    // Iterator uI = undefinedMappedEntries.iterator();
+    // while (uI.hasNext()) {
+    // RegionEntry e = (RegionEntry) uI.next();
+    // Object value = getTargetObject(e);
+    // sb.append(" RegionEntry.key = ").append(e.getKey());
+    // sb.append(" Value.type = ").append(value.getClass().getName());
+    // if (value instanceof Collection) {
+    // sb.append(" Value.size = ").append(((Collection) value).size());
+    // }
+    // sb.append("\n");
+    // }
-      sb.append(" Value Type = ")
-          .append(" " + indexEntry.getValue().getClass().getName())
+      sb.append(" Value Type = ").append(" " + indexEntry.getValue().getClass().getName())
-        sb.append(" Value Size = ")
-            .append(" " + ((Collection) indexEntry.getValue()).size())
+        sb.append(" Value Size = ").append(" " + ((Collection) indexEntry.getValue()).size())
-        throw new AssertionError("value instance of "
-            + indexEntry.getValue().getClass().getName());
+        throw new AssertionError("value instance of " + indexEntry.getValue().getClass().getName());
-     * Returns the total amount of time (in nanoseconds) spent updating this
-     * index.
+     * Returns the total amount of time (in nanoseconds) spent updating this index.
-     * Returns the total number of times this index has been accessed by a
-     * query.
+     * Returns the total number of times this index has been accessed by a query.
-      sb.append("Total Update time = ").append(getTotalUpdateTime())
-          .append("\n");
+      sb.append("Total Update time = ").append(getTotalUpdateTime()).append("\n");
-     * The boolean if true indicates that the 0th iterator is on entries
-     * . If the 0th iterator is on collection of Region.Entry objects, then the
-     * RegionEntry object used in Index data objects is obtained directly from
-     * its corresponding Region.Entry object. However if the 0th iterator is not
-     * on entries then the boolean is false. In this case the additional
-     * projection attribute gives us the original value of the iterator while
-     * the Region.Entry object is obtained from 0th iterator. It is possible to
-     * have index being created on a Region Entry itself , instead of a Region.
-     * A Map operator( Compiled Index Operator) used with Region enables, us to
-     * create such indexes. In such case the 0th iterator, even if it represents
-     * a collection of Objects which are not Region.Entry objects, still the
-     * boolean remains true, as the Entry object can be easily obtained from the
-     * 0th iterator. In this case, the additional projection attribute s not
-     * null as it is used to evaluate the Entry object from the 0th iterator.
+     * The boolean if true indicates that the 0th iterator is on entries . If the 0th iterator is on
+     * collection of Region.Entry objects, then the RegionEntry object used in Index data objects is
+     * obtained directly from its corresponding Region.Entry object. However if the 0th iterator is
+     * not on entries then the boolean is false. In this case the additional projection attribute
+     * gives us the original value of the iterator while the Region.Entry object is obtained from
+     * 0th iterator. It is possible to have index being created on a Region Entry itself , instead
+     * of a Region. A Map operator( Compiled Index Operator) used with Region enables, us to create
+     * such indexes. In such case the 0th iterator, even if it represents a collection of Objects
+     * which are not Region.Entry objects, still the boolean remains true, as the Entry object can
+     * be easily obtained from the 0th iterator. In this case, the additional projection attribute s
+     * not null as it is used to evaluate the Entry object from the 0th iterator.
-      Object params1[] = { new QRegion(rgn, false) };
+      Object params1[] = {new QRegion(rgn, false)};
-    public void expansion(List expandedResults, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
-      //no-op
+    public void expansion(List expandedResults, Object lowerBoundKey, Object upperBoundKey,
+        int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
+      // no-op
-    
+
-     * @param add
-     *          true if adding to index, false if removing
+     * @param add true if adding to index, false if removing
-          //This code relies on current implementation of remove mapping, relying on behavior that will force a
-          //crawl through the index to remove the entry if it exists, even if it is not present at the provided key
+          // This code relies on current implementation of remove mapping, relying on behavior that
+          // will force a
+          // crawl through the index to remove the entry if it exists, even if it is not present at
+          // the provided key
-        }
-        else {
+        } else {
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) this.indexInitIterators
-              .get(i);
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) this.indexInitIterators.get(i);
-            this.initContext
-                .addToIndependentRuntimeItrMapForIndexCreation(iterDef);
+            this.initContext.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
-        if(loadEntries) {
-          doNestedIterationsForIndexInit(0,
-             this.initContext.getCurrentIterators());
+        if (loadEntries) {
+          doNestedIterationsForIndexInit(0, this.initContext.getCurrentIterators());
-        throws TypeMismatchException, AmbiguousNameException,
-        FunctionDomainException, NameResolutionException,
-        QueryInvocationTargetException, IMQException {
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+        NameResolutionException, QueryInvocationTargetException, IMQException {
-     * This function is used to obtain Indxe data at the time of index
-     * creation. Each element of the List is an Object Array of size 3. The 0th
-     * element of Object Array stores the value of Index Expression. The 1st
-     * element of ObjectArray contains the RegionEntry object ( If the booelan
-     * isFirstItrOnEntry is false, then the 0th iterator will give us the
-     * Region.Entry object which can be used to obtain the underlying
-     * RegionEntry object. If the boolean is true & additional projection
-     * attribute is not null, then the Region.Entry object can be obtained by
-     * evaluating the additional projection attribute. If the boolean
-     * isFirstItrOnEntry is tru e& additional projection attribute is null, then
-     * teh 0th iterator itself will evaluate to Region.Entry Object.
+     * This function is used to obtain Indxe data at the time of index creation. Each element of the
+     * List is an Object Array of size 3. The 0th element of Object Array stores the value of Index
+     * Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the booelan
+     * isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry object which
+     * can be used to obtain the underlying RegionEntry object. If the boolean is true & additional
+     * projection attribute is not null, then the Region.Entry object can be obtained by evaluating
+     * the additional projection attribute. If the boolean isFirstItrOnEntry is tru e& additional
+     * projection attribute is null, then teh 0th iterator itself will evaluate to Region.Entry
+     * Object.
-     * The 2nd element of Object Array contains the Struct object ( tuple)
-     * created. If the boolean isFirstItrOnEntry is false, then the first
-     * attribute of the Struct object is obtained by evaluating the additional
-     * projection attribute.
+     * The 2nd element of Object Array contains the Struct object ( tuple) created. If the boolean
+     * isFirstItrOnEntry is false, then the first attribute of the Struct object is obtained by
+     * evaluating the additional projection attribute.
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException, IMQException {
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException, IMQException {
-        throw new IMQException(LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
+        throw new IMQException(
+            LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
-      
+
-      indexKey = this.isFirstItrOnEntry ? this.indexedExpr
-          .evaluate(this.initContext) : modifiedIndexExpr
-          .evaluate(this.initContext);
+      indexKey = this.isFirstItrOnEntry ? this.indexedExpr.evaluate(this.initContext)
+          : modifiedIndexExpr.evaluate(this.initContext);
-        temp = (LocalRegion.NonTXEntry) additionalProj
-            .evaluate(this.initContext);
+        temp = (LocalRegion.NonTXEntry) additionalProj.evaluate(this.initContext);
-        temp = (LocalRegion.NonTXEntry) (((RuntimeIterator) currentRuntimeIters
-            .get(0)).evaluate(this.initContext));
+        temp = (LocalRegion.NonTXEntry) (((RuntimeIterator) currentRuntimeIters.get(0))
+            .evaluate(this.initContext));
-     * @param add
-     *          true if adding to index, false if removing
+     * @param add true if adding to index, false if removing
-    private void doNestedIterations(int level, boolean add,
-        ExecutionContext context) throws TypeMismatchException,
-        AmbiguousNameException, FunctionDomainException,
+    private void doNestedIterations(int level, boolean add, ExecutionContext context)
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
-     * @param add
-     *          true if adding, false if removing from index
+     * @param add true if adding, false if removing from index
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException, IMQException {
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException, IMQException {
-      RegionEntry entry = ((DummyQRegion) context.getBindArgument(1))
-          .getEntry();
+      RegionEntry entry = ((DummyQRegion) context.getBindArgument(1)).getEntry();
-          }
-          else {
+          } else {
-        }
-        else {
+        } else {
-      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(
-          this.canonicalIterNames, fieldTypes);
+      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(this.canonicalIterNames, fieldTypes);
-    private ExecutionContext createExecutionContext(RegionEntry target) throws NameResolutionException, TypeMismatchException {
+    private ExecutionContext createExecutionContext(RegionEntry target)
+        throws NameResolutionException, TypeMismatchException {
-      Object params[] = { dQRegion };
+      Object params[] = {dQRegion};
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators
-              .get(i);
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators.get(i);
-        Support
-            .Assert(
-                this.indexResultSetType != null,
-                "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
+        Support.Assert(this.indexResultSetType != null,
+            "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
-      
+
-      
+
-        //This comparator is used to sort results from the hash index
-        //However some values may have been updated since being added to the result set.
-        //In these cases UNDEFINED values could be present.  So we 
-        //don't really care how UNDEFINED is sorted, in the end, this doesn't really matter anyways.
-        //We check to see if an update was in progress.  If so (and is the way these turn to undefined),
-        //the value is reevaluated and removed from the result set if it does not match the 
-        //search criteria.  This occurs in addToResultsFromEntries()
-        Object key0 = ((Object[])arg0)[0];
-        Object key1 = ((Object[])arg1)[0];
-      
+        // This comparator is used to sort results from the hash index
+        // However some values may have been updated since being added to the result set.
+        // In these cases UNDEFINED values could be present. So we
+        // don't really care how UNDEFINED is sorted, in the end, this doesn't really matter
+        // anyways.
+        // We check to see if an update was in progress. If so (and is the way these turn to
+        // undefined),
+        // the value is reevaluated and removed from the result set if it does not match the
+        // search criteria. This occurs in addToResultsFromEntries()
+        Object key0 = ((Object[]) arg0)[0];
+        Object key1 = ((Object[]) arg1)[0];
+
-  void lockedQuery(Object key, int operator, Collection results,
-      CompiledValue iterOps, RuntimeIterator indpndntItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-      throws TypeMismatchException, FunctionDomainException,
+  void lockedQuery(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator indpndntItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+    this.lockedQueryPrivate(key, operator, results, iterOps, indpndntItr, context, null, projAttrib,
+        intermediateResults, isIntersection);
+  }
+
+  void lockedQuery(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-    this.lockedQueryPrivate(key, operator, results, iterOps, indpndntItr,
-        context, null, projAttrib, intermediateResults, isIntersection);
-  }
-
-  void lockedQuery(Object key, int operator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException {
-    this.lockedQueryPrivate(key, operator, results, null, null, context,
-        keysToRemove, null, null, true);
+    this.lockedQueryPrivate(key, operator, results, null, null, context, keysToRemove, null, null,
+        true);
-  void addMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException {
+  void addMapping(Object key, Object value, RegionEntry entry) throws IMQException {
-  void saveMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException {
+  void saveMapping(Object key, Object value, RegionEntry entry) throws IMQException {
-  
+
-  
-//  public String printAll() {
-//    return this.entriesSet.printAll();
-//  }
+
+  // public String printAll() {
+  // return this.entriesSet.printAll();
+  // }

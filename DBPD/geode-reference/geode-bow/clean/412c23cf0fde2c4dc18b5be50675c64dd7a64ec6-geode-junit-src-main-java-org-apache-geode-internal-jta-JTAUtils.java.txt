GEODE-7560: Fix LGTM JTAUtils Issues (#4413)

* Remove unused container
* Remove empty conditional
* Use try with resources
* Rewrite do while loop without a break to help LGTM
* Remove unused functions from internal class
* Remove unneeded variables and deprecated usages
* Cleanup names/spellings

Authored-by: Michael Oleske <moleske@pivotal.io>
-import java.util.HashMap;
-import org.apache.geode.cache.AttributesFactory;
-  /** This is used to store each Regions original attributes for reset purposes */
-  private HashMap regionDefaultAttrMap = new HashMap();
-    long beginTime = getCurrentTimeMillis();
-    return beginTime;
+    return getCurrentTimeMillis();
-    long endTime = getCurrentTimeMillis();
-    return endTime;
-  }
-
-  public static long elapsedTime(long endTime, long beginTime) {
-    return endTime - beginTime;
+    return getCurrentTimeMillis();
-  public void mkrgn(String command) throws Exception {
+  private void makeRegion(String command) throws Exception {
-      String name = command;
-      AttributesFactory fac = new AttributesFactory(this.currRegion.getAttributes());
-      Region nr = this.currRegion.createSubregion(name, fac.create());
-      regionDefaultAttrMap.put(nr.getFullPath(), fac.create());
+      cache.createRegionFactory(currRegion.getAttributes()).createSubregion(currRegion, command);
-      // fail (" unable to make region..." + e.getMessage ());
-      throw new Exception(" failed in mkrgn " + command);
+      throw new Exception(" failed in makeRegion " + command);
-      Region subr = this.currRegion.getSubregion(region);
+      Region subregion = this.currRegion.getSubregion(region);
-      if (subr == null) {
-        mkrgn(region);
+      if (subregion == null) {
+        makeRegion(region);
-        currRegion = subr;
+        currRegion = subregion;
-      // fail (" unable to get sub-region...");
-  public boolean parseCommand(String command, List list) {
-    // String strTemp = command;
-    boolean done = false;
-    boolean success = false;
-    int space = -1;
-    do {
-      space = command.indexOf(' ');
-      if (space < 0) {
-        done = true;
-        list.add(command);
-        break;
-      }
+  public List<String> parseCommand(String command) {
+    int space;
+    List<String> list = new LinkedList<>();
+    while ((space = command.indexOf(' ')) > 0) {
-      command = command.substring(space + 1, command.length());
-      success = true;
-    } while (!done);
-    return success;
+      command = command.substring(space + 1);
+    }
+    list.add(command);
+    return list;
-    String value = null;
-
-    // try {
-    String name = command;
-    Object valueBytes = this.currRegion.get(name);
-    value = printEntry(name, valueBytes);
-    // }
-    // catch (CacheException e) {
-    // //fail (" unable to get value..." + e.getMessage ());
-    // throw new CacheExistsException("failed getting region: " + command);
-    // }
-    return value;
+    Object valueBytes = this.currRegion.get(command);
+    return printEntry(command, valueBytes);
-      LinkedList list = new LinkedList();
-      // syntax of put from CacheRunner cli help-- prabir
-      parseCommand(command, list);
+      List<String> list = parseCommand(command);
-        String name = (String) list.get(1);
-        String value = (String) list.get(2);
+        String name = list.get(1);
+        String value = list.get(2);
-          String objectType = (String) list.get(3);
+          String objectType = list.get(3);
-      // fail (" unable to put..." + e.getMessage ());
-        value = new String("byte[]: \"" + new String((byte[]) valueBytes) + "\"");
+        value = "byte[]: \"" + new String((byte[]) valueBytes) + "\"";
-        value = new String("String: \"" + valueBytes + "\"");
+        value = "String: \"" + valueBytes + "\"";
-        value = new String("Integer: \"" + valueBytes.toString() + "\"");
+        value = "Integer: \"" + valueBytes.toString() + "\"";
-        value = new String("No value in cache.");
+        value = "No value in cache.";
-   * Returns a constant width space to stdout This method is used to print test pass/fail msg after
-   * a constant width from the test execution stage
-   */
-
-  public static String repeatChar(char character, int repeatCount) {
-
-    StringBuffer stringBuffer = new StringBuffer(repeatCount);
-    for (int i = 1; i <= repeatCount; i++) {
-      stringBuffer.append(character);
-    }
-    return stringBuffer.toString();
-  }
-
-  /**
-   * This method is used to parse the string with delimeter ':'returned by get(). The delimeter is
+   * This method is used to parse the string with delimiter ':'returned by get(). The delimiter is
-    if (str == null) {
-      // returnVal = str; (redundant assignment)
-    }
-      String tokens[] = str.split(":");
+      String[] tokens = str.split(":");
-  public int deleteRows(String tableName) throws NamingException, SQLException {
+  public void deleteRows(String tableName) throws NamingException, SQLException {
-    int rowsDeleted = 0; // assume that rows are always inserted in CacheUtils
-    String sql = "";
-    sql = "select * from " + tableName;
+    String sql = "select * from " + tableName;
-      rowsDeleted = stmt.executeUpdate(sql);
+      stmt.executeUpdate(sql);
-
-    return rowsDeleted;
-    Connection conn = ds.getConnection();
-    Statement sm = conn.createStatement();
-    ResultSet rs = sm.executeQuery(sql);
-    while (rs.next()) {
-      counter++;
-      // System.out.println("id "+rs.getString(1)+ " name "+rs.getString(2));
+    try (Connection conn = ds.getConnection();
+        Statement sm = conn.createStatement();
+        ResultSet rs = sm.executeQuery(sql)) {
+      while (rs.next()) {
+        counter++;
+      }
-    rs.close();
-    conn.close();
-    Connection conn = ds.getConnection();
-    Statement sm = conn.createStatement();
-    ResultSet rs = sm.executeQuery(sql);
-    while (rs.next()) {
-      System.out.println("id:" + rs.getString(1));
-      System.out.println("name:" + rs.getString(2));
-      id_str = rs.getString(1);
-      if (id_str.equals(pattern)) {
-        found = true;
-        break;
-      } else
-        continue;
+    try (Connection conn = ds.getConnection();
+        Statement sm = conn.createStatement();
+        ResultSet rs = sm.executeQuery(sql)) {
+      while (rs.next()) {
+        System.out.println("id:" + rs.getString(1));
+        System.out.println("name:" + rs.getString(2));
+        id_str = rs.getString(1);
+        if (id_str.equals(pattern)) {
+          found = true;
+          break;
+        }
+      }
-    rs.close();
-    conn.close();
+
-
-
-} // end of class
+}

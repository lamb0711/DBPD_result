GEODE-6944: add support for *REDUNDANT* regionType (#3957)

Co-authored-by: Darrel Schneider <dschneider@pivotal.io>


+
+import java.util.Optional;
+
-    if (xmlObject.getType() == null) {
-      // older gfsh would generate the region xml without the refid/type. we will not
-      // support showing these regions in management rest api for now.
-      region.setType(RegionType.UNSUPPORTED);
-    } else {
-      try {
-        region.setType(RegionType.valueOf(xmlObject.getType()));
-      } catch (IllegalArgumentException e) {
-        // Management rest api will not support showing regions with "LOCAL*" types or user defined
-        // refids
-        region.setType(RegionType.UNSUPPORTED);
-      }
-    }
+    region.setType(getRegionType(xmlObject.getType(), regionAttributes));
+      Optional.ofNullable(regionAttributes.getPartitionAttributes())
+          .flatMap(
+              partitionAttributes -> Optional.ofNullable(partitionAttributes.getRedundantCopies()))
+          .ifPresent(copies -> region.setRedundantCopies(Integer.parseInt(copies)));
+
+    if (configObject.getRedundantCopies() != null) {
+      RegionAttributesType.PartitionAttributes partitionAttributes =
+          new RegionAttributesType.PartitionAttributes();
+      partitionAttributes.setRedundantCopies(configObject.getRedundantCopies().toString());
+      attributesType.setPartitionAttributes(partitionAttributes);
+    }
+  /**
+   * Data policy to regionType is almost a 1-to-1 mapping, except in
+   * the case of DataPolicy.PARTITION, we will need to see the local max memory
+   * to determine if it's a PARTITION type or a PARTITION_PROXY type.
+   *
+   * we do our best to infer the type from the existing xml attributes. For data
+   * policies not supported by management rest api (for example, NORMAL and PRELOADED)
+   * it will show as UNSUPPORTED
+   */
+  public RegionType getRegionType(String refid, RegionAttributesType regionAttributes) {
+    if (refid != null) {
+      try {
+        return RegionType.valueOf(refid);
+      } catch (Exception e) {
+        return RegionType.UNSUPPORTED;
+      }
+    }
+
+    // if refid is null, we will try to determine the type based on the region attributes
+    if (regionAttributes == null) {
+      return RegionType.UNSUPPORTED;
+    }
+    RegionAttributesDataPolicy dataPolicy = regionAttributes.getDataPolicy();
+
+    if (dataPolicy == null) {
+      return RegionType.UNSUPPORTED;
+    }
+
+    switch (dataPolicy) {
+      case PARTITION: {
+        RegionAttributesType.PartitionAttributes partitionAttributes =
+            regionAttributes.getPartitionAttributes();
+        if (partitionAttributes != null && "0".equals(partitionAttributes.getLocalMaxMemory())) {
+          return RegionType.PARTITION_PROXY;
+        }
+        return RegionType.PARTITION;
+      }
+      case PERSISTENT_PARTITION: {
+        return RegionType.PARTITION_PERSISTENT;
+      }
+      case PERSISTENT_REPLICATE: {
+        return RegionType.REPLICATE_PERSISTENT;
+      }
+      case REPLICATE: {
+        return RegionType.REPLICATE;
+      }
+      case EMPTY: {
+        return RegionType.REPLICATE_PROXY;
+      }
+    }
+    return RegionType.UNSUPPORTED;
+  }
+
+
+      // these are supported by the management rest api
+      case "PARTITION_PERSISTENT": {
+        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.PERSISTENT_PARTITION);
+        break;
+      }
+      case "PARTITION_PROXY": {
+        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.PARTITION);
+        regionAttributes.setLocalMaxMemory("0");
+        break;
+      }
+      case "REPLICATE_PERSISTENT": {
+        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.PERSISTENT_REPLICATE);
+        regionAttributes.setScope(RegionAttributesScope.DISTRIBUTED_ACK);
+        break;
+      }
+      case "REPLICATE_PROXY": {
+        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.EMPTY);
+        regionAttributes.setScope(RegionAttributesScope.DISTRIBUTED_ACK);
+        break;
+      }
-      case "PARTITION_PERSISTENT": {
-        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.PERSISTENT_PARTITION);
-        break;
-      }
+
-
-      case "REPLICATE_PERSISTENT": {
-        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.PERSISTENT_REPLICATE);
-        regionAttributes.setScope(RegionAttributesScope.DISTRIBUTED_ACK);
-        break;
-      }
-
-      case "PARTITION_PROXY": {
-        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.PARTITION);
-        regionAttributes.setLocalMaxMemory("0");
-        break;
-      }
+
-      case "REPLICATE_PROXY": {
-        regionAttributes.setDataPolicy(RegionAttributesDataPolicy.EMPTY);
-        regionAttributes.setScope(RegionAttributesScope.DISTRIBUTED_ACK);
-        break;
-      }
+

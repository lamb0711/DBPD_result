GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4781)

* Revert "Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)"

This reverts commit f0982cdedf1b122f734919d0647434cca33ec254.

* Fix sporadic test failures for concurrent HSetNX
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.redis.internal.CoderException;
+import org.apache.geode.redis.internal.RedisConstants;
-    @SuppressWarnings("unchecked")
-    Region<ByteArrayWrapper, Boolean> keyRegion =
-        (Region<ByteArrayWrapper, Boolean>) context.getRegionProvider().getRegion(key);
-    int count = 1;
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      Region<ByteArrayWrapper, Set<ByteArrayWrapper>> region = getRegion(context);
-    if (commandElems.size() > 2) {
-      try {
-        count = Coder.bytesToInt(commandElems.get(2));
-      } catch (NumberFormatException e) {
-        command
-            .setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_NOT_NUMERIC));
+      int count = 1;
+
+      if (commandElems.size() > 2) {
+        try {
+          count = Coder.bytesToInt(commandElems.get(2));
+        } catch (NumberFormatException e) {
+          command.setResponse(
+              Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_NOT_NUMERIC));
+          return;
+        }
+      }
+
+      Set<ByteArrayWrapper> set = region.get(key);
+
+      if (set == null || count == 0) {
+        command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
-    }
-    if (keyRegion == null || count == 0) {
-      command.setResponse(Coder.getNilResponse(context.getByteBufAllocator()));
-      return;
-    }
+      int members = set.size();
-    int members = keyRegion.size();
-
-    if (members <= count && count != 1) {
-      respondBulkStrings(command, context, new HashSet<ByteArrayWrapper>(keyRegion.keySet()));
-      return;
-    }
-
-    Random rand = new Random();
-
-    ByteArrayWrapper[] entries = keyRegion.keySet().toArray(new ByteArrayWrapper[members]);
-
-    if (count == 1) {
-      ByteArrayWrapper randEntry = entries[rand.nextInt(entries.length)];
-      respondBulkStrings(command, context, randEntry);
-    } else if (count > 0) {
-      Set<ByteArrayWrapper> randEntries = new HashSet<ByteArrayWrapper>();
-      do {
-        ByteArrayWrapper s = entries[rand.nextInt(entries.length)];
-        randEntries.add(s);
-      } while (randEntries.size() < count);
-      respondBulkStrings(command, context, randEntries);
-    } else {
-      count = -count;
-      List<ByteArrayWrapper> randEntries = new ArrayList<ByteArrayWrapper>();
-      for (int i = 0; i < count; i++) {
-        ByteArrayWrapper s = entries[rand.nextInt(entries.length)];
-        randEntries.add(s);
+      if (members <= count && count != 1) {
+        respondBulkStrings(command, context, new HashSet<ByteArrayWrapper>(set));
+        return;
-      respondBulkStrings(command, context, randEntries);
+
+      Random rand = new Random();
+
+      ByteArrayWrapper[] entries = set.toArray(new ByteArrayWrapper[members]);
+
+      try {
+        if (count == 1) {
+          ByteArrayWrapper randEntry = entries[rand.nextInt(entries.length)];
+          command.setResponse(
+              Coder.getBulkStringResponse(context.getByteBufAllocator(), randEntry.toBytes()));
+        } else if (count > 0) {
+          Set<ByteArrayWrapper> randEntries = new HashSet<>();
+          do {
+            ByteArrayWrapper s = entries[rand.nextInt(entries.length)];
+            randEntries.add(s);
+          } while (randEntries.size() < count);
+          command.setResponse(Coder.getArrayResponse(context.getByteBufAllocator(), randEntries));
+        } else {
+          count = -count;
+          List<ByteArrayWrapper> randEntries = new ArrayList<>();
+          for (int i = 0; i < count; i++) {
+            ByteArrayWrapper s = entries[rand.nextInt(entries.length)];
+            randEntries.add(s);
+          }
+          command.setResponse(Coder.getArrayResponse(context.getByteBufAllocator(), randEntries));
+        }
+      } catch (CoderException e) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+            RedisConstants.SERVER_ERROR_MESSAGE));
+      }
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      command.setResponse(
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
+      return;

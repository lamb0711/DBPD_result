Merge branch 'release/1.4.0'

+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.logging.log4j.Logger;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
- * 
+ *
- * 
+ *
-  public final static boolean THROW_EXCEPTION_ON_TIMEOUT =
+  public static final boolean THROW_EXCEPTION_ON_TIMEOUT =
-  public final static double PR_SEVERE_ALERT_RATIO;
+  public static final double PR_SEVERE_ALERT_RATIO;
-  protected final static ProcessorKeeper21 keeper = new ProcessorKeeper21();
+  protected static final ProcessorKeeper21 keeper = new ProcessorKeeper21();
-  protected boolean keeperCleanedUp;
+  private boolean keeperCleanedUp;
-  protected long statStart;
+  long statStart;
-  protected long initTime;
+  private long initTime;
-  protected boolean severeAlertEnabled;
+  private boolean severeAlertEnabled;
-  protected volatile boolean severeAlertTimerReset;
+  private volatile boolean severeAlertTimerReset;
-  public final static ThreadLocal SevereAlertShorten = new ThreadLocal() {
-    @Override
-    protected Object initialValue() {
-      return Boolean.FALSE;
-    }
-  };
+  private static final ThreadLocal<Boolean> severeAlertShorten =
+      ThreadLocal.withInitial(() -> Boolean.FALSE);
-  private static ThreadLocal ForceSevereAlertProcessing = new ThreadLocal() {
-    @Override
-    protected Object initialValue() {
-      return Boolean.FALSE;
-    }
-  };
+  private static ThreadLocal<Boolean> forceSevereAlertProcessing =
+      ThreadLocal.withInitial(() -> Boolean.FALSE);
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-  protected void postWait() {
+  private void postWait() {
-  // start waiting for replies without explicitly waiting for all of them using
-  // waitForReplies* methods; useful for streaming of results in function execution
-  public void startWait() {
-    if (!this.waiting && stillWaiting()) {
-      preWait();
-    }
-  }
-
-  // end waiting for replies without explicitly invoking waitForReplies*
-  // methods; useful for streaming of results in function execution
-  public void endWait(boolean doCleanup) {
-    try {
-      postWait();
-    } finally {
-      if (doCleanup) {
-        cleanup();
-      }
-    }
-  }
-   * 
+   *
-  protected boolean basicWait(long msecs, StoppableCountDownLatch latch)
+  private boolean basicWait(long msecs, StoppableCountDownLatch latch)
-      long severeAlertTimeout = getAckSevereAlertThresholdMS();
+      final long severeAlertTimeout = getAckSevereAlertThresholdMS();
+      // only start SUSPECT processing if severe alerts are enabled
+      final boolean doSuspectProcessing =
+          isSevereAlertProcessingEnabled() && (severeAlertTimeout > 0);
-          // only start SUSPECT processing if severe alerts are enabled
-          timeout(isSevereAlertProcessingEnabled() && (severeAlertTimeout > 0), false);
+          timeout(doSuspectProcessing, false);
-          if (isSevereAlertProcessingEnabled() && severeAlertTimeout > 0) {
-            boolean timedout;
+          if (doSuspectProcessing) {
+            boolean wasNotUnlatched;
-              timedout = !latch.await(severeAlertTimeout);
-            } while (timedout && this.severeAlertTimerReset);
-            if (timedout) {
+              wasNotUnlatched = !latch.await(severeAlertTimeout);
+            } while (wasNotUnlatched && this.severeAlertTimerReset);
+            if (wasNotUnlatched) {
-              // for consistency, we must now wait for a membership view
-              // that ejects the removed members
-              latch.await();
+
+              long suspectProcessingErrorAlertTimeout = severeAlertTimeout * 3;
+              if (!latch.await(suspectProcessingErrorAlertTimeout)) {
+                long now = System.currentTimeMillis();
+                long totalTimeElapsed = now - this.initTime;
+
+                String waitingOnMembers;
+                synchronized (members) {
+                  waitingOnMembers = Arrays.toString(members);
+                }
+                logger.fatal("An additional " + suspectProcessingErrorAlertTimeout
+                    + " milliseconds have elapsed while waiting for replies. Total of "
+                    + totalTimeElapsed + " milliseconds elapsed (init time:" + this.initTime
+                    + ", now: " + now + ") Waiting for members: " + waitingOnMembers);
+
+                // for consistency, we must now wait indefinitely for a membership view
+                // that ejects the removed members
+                latch.await();
+              }
-      } else {
-        if (msecs > timeout) {
-          if (!latch.await(timeout)) {
-            timeout(isSevereAlertProcessingEnabled() && (severeAlertTimeout > 0), false);
-            // after timeout alert, wait remaining time
-            if (!latch.await(msecs - timeout)) {
-              logger.info(LocalizedMessage.create(
-                  LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_TIMING_OUT_AFTER_0_SEC,
-                  Long.valueOf(msecs / 1000)));
-              return false;
-            }
-            // Give an info message since timeout gave a warning.
+      } else if (msecs > timeout) {
+        if (!latch.await(timeout)) {
+          timeout(doSuspectProcessing, false);
+          // after timeout alert, wait remaining time
+          if (!latch.await(msecs - timeout)) {
-                LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, shortName()));
-          }
-        } else {
-          if (!latch.await(msecs)) {
+                LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_TIMING_OUT_AFTER_0_SEC,
+                Long.valueOf(msecs / 1000)));
+          // Give an info message since timeout gave a warning.
+          logger.info(LocalizedMessage
+              .create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, shortName()));
+        }
+      } else {
+        if (!latch.await(msecs)) {
+          return false;
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    SevereAlertShorten.set(Boolean.valueOf(flag));
+    severeAlertShorten.set(flag);
-    return ((Boolean) SevereAlertShorten.get()).booleanValue();
+    return severeAlertShorten.get();
-    ForceSevereAlertProcessing.set(Boolean.TRUE);
+    forceSevereAlertProcessing.set(Boolean.TRUE);
-    ForceSevereAlertProcessing.set(Boolean.FALSE);
+    forceSevereAlertProcessing.set(Boolean.FALSE);
-    return ((Boolean) ForceSevereAlertProcessing.get()).booleanValue();
+    return forceSevereAlertProcessing.get();
-    if (disconnectTimeout > 0 && ((Boolean) SevereAlertShorten.get()).booleanValue()) {
+    if (disconnectTimeout > 0 && severeAlertShorten.get()) {
-  private final static ThreadLocal messageId = new ThreadLocal();
+  private static final ThreadLocal<Integer> messageId = new ThreadLocal<>();
-  private final static Integer VOID_RPID = Integer.valueOf(0);
+  private static final Integer VOID_RPID = 0;
-    messageId.set(Integer.valueOf(id));
+    messageId.set(id);
-      result = ((Integer) v).intValue();
+      result = (Integer) v;
-   * 
+   *

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   
+
- * Identifies the host, port, and bindAddress a distribution locator is 
- * listening on.
+ * Identifies the host, port, and bindAddress a distribution locator is listening on.
-  
+
-  public DistributionLocatorId(InetAddress host, 
-                               int port, 
-                               String bindAddress, 
-                               SSLConfig sslConfig) {
+  public DistributionLocatorId(InetAddress host, int port, String bindAddress,
+      SSLConfig sslConfig) {
-  
+
-   * Constructs a DistributionLocatorId with the given port. The host will be 
-   * set to the local host.
+   * Constructs a DistributionLocatorId with the given port. The host will be set to the local host.
-  
+
-      throw new InternalGemFireException(LocalizedStrings.DistributionLocatorId_FAILED_GETTING_LOCAL_HOST.toLocalizedString(), ex);
+      throw new InternalGemFireException(
+          LocalizedStrings.DistributionLocatorId_FAILED_GETTING_LOCAL_HOST.toLocalizedString(), ex);
-  
-  public DistributionLocatorId(InetAddress host, 
-                               int port, 
-                               String bindAddress,
-                               SSLConfig sslConfig,
-                               boolean peerLocator,
-                               boolean serverLocator,
-                               String hostnameForClients) {
+
+  public DistributionLocatorId(InetAddress host, int port, String bindAddress, SSLConfig sslConfig,
+      boolean peerLocator, boolean serverLocator, String hostnameForClients) {
-  
+
-   * Constructs a DistributionLocatorId with a String of the form:
-   * hostname[port] or hostname:bindaddress[port] or hostname@bindaddress[port]
+   * Constructs a DistributionLocatorId with a String of the form: hostname[port] or
+   * hostname:bindaddress[port] or hostname@bindaddress[port]
-   * The :bindaddress portion is optional.  hostname[port] is the more common
-   * form.
+   * The :bindaddress portion is optional. hostname[port] is the more common form.
-   * Use bindaddress[port] or hostname[port].  This object doesn't need to
-   * differentiate between the two.
+   * Use bindaddress[port] or hostname[port]. This object doesn't need to differentiate between the
+   * two.
-    
+
-      throw new IllegalArgumentException(LocalizedStrings.DistributionLocatorId__0_IS_NOT_IN_THE_FORM_HOSTNAMEPORT.toLocalizedString(marshalled));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributionLocatorId__0_IS_NOT_IN_THE_FORM_HOSTNAMEPORT
+              .toLocalizedString(marshalled));
-    
+
-    
+
-      throw new InternalGemFireException(LocalizedStrings.DistributionLocatorId_FAILED_GETTING_HOST_FROM_NAME_0.toLocalizedString(hostname));
+      throw new InternalGemFireException(
+          LocalizedStrings.DistributionLocatorId_FAILED_GETTING_HOST_FROM_NAME_0
+              .toLocalizedString(hostname));
-    
+
-      this.port = Integer.parseInt(
-          marshalled.substring(portStartIdx+1, portEndIdx));
+      this.port = Integer.parseInt(marshalled.substring(portStartIdx + 1, portEndIdx));
-      throw new IllegalArgumentException(LocalizedStrings.DistributionLocatorId_0_DOES_NOT_CONTAIN_A_VALID_PORT_NUMBER.toLocalizedString(marshalled));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributionLocatorId_0_DOES_NOT_CONTAIN_A_VALID_PORT_NUMBER
+              .toLocalizedString(marshalled));
-    
+
-      this.bindAddress = validateBindAddress(marshalled.substring(bindIdx+1, portStartIdx));
-    }
-    else {
+      this.bindAddress = validateBindAddress(marshalled.substring(bindIdx + 1, portStartIdx));
+    } else {
-    
+
-    if(optionsIndex > 0) {
+    if (optionsIndex > 0) {
-      for(int i = 0; i < options.length; i++) {
-        String[] optionFields= options[i].split("=");
-        if(optionFields.length == 2) {
-          if(optionFields[0].equalsIgnoreCase("peer")) {
+      for (int i = 0; i < options.length; i++) {
+        String[] optionFields = options[i].split("=");
+        if (optionFields.length == 2) {
+          if (optionFields[0].equalsIgnoreCase("peer")) {
-          }
-          else if(optionFields[0].equalsIgnoreCase("server")) {
+          } else if (optionFields[0].equalsIgnoreCase("server")) {
-          }
-          else if(optionFields[0].equalsIgnoreCase("hostname-for-clients")) {
+          } else if (optionFields[0].equalsIgnoreCase("hostname-for-clients")) {
-            throw new IllegalArgumentException(marshalled + " invalid option " + optionFields[0] + ". valid options are \"peer\" or \"server\"");
+            throw new IllegalArgumentException(marshalled + " invalid option " + optionFields[0]
+                + ". valid options are \"peer\" or \"server\"");
-  
+
-    this(address,
-         locator.getPort(),
-         locator.getBindAddress() == null ? null : locator.getBindAddress().getHostAddress(),
-         null,
-         locator.isPeerLocator(),
-         locator.isServerLocator(),
-         locator.getHostnameForClients());
+    this(address, locator.getPort(),
+        locator.getBindAddress() == null ? null : locator.getBindAddress().getHostAddress(), null,
+        locator.isPeerLocator(), locator.isServerLocator(), locator.getHostnameForClients());
-  
+
-   * Returns marshaled string that is compatible as input for {@link
-   * #DistributionLocatorId(String)}.
+   * Returns marshaled string that is compatible as input for
+   * {@link #DistributionLocatorId(String)}.
-      }
-      else {
+      } else {
-    if (sslConfig == null) return new SSLConfig(); // uses defaults
+    if (sslConfig == null)
+      return new SSLConfig(); // uses defaults
-  
+
+
-  
+
-  
+
-  
+
-  
-  /** 
-   * Returns the bindAddress; value is "" unless host has multiple network 
-   * interfaces. 
+
+  /**
+   * Returns the bindAddress; value is "" unless host has multiple network interfaces.
-  
+
-  
+
-//  private String hostNameToString() {
-//    if (this.host.isMulticastAddress()) {
-//      return this.host.getHostAddress();
-//    } else {
-//      return this.host.getHostName();
-//    }
-//  }
+  // private String hostNameToString() {
+  // if (this.host.isMulticastAddress()) {
+  // return this.host.getHostAddress();
+  // } else {
+  // return this.host.getHostName();
+  // }
+  // }
-  
-	/**
-	 * Returns a string representation of the object.
-	 * 
-	 * @return a string representation of the object
-	 */
-  @Override
-	public String toString() {
-          StringBuffer sb = new StringBuffer();
-  
-          // If hostnameForClients is set, use that
-          if (this.hostnameForClients != null && this.hostnameForClients.length() > 0) {
-            sb.append(this.hostnameForClients);
-          } else if (this.bindAddress != null && this.bindAddress.length() > 0) {
-            // if bindAddress then use that instead of host...
-            sb.append(this.bindAddress);
-          }
-          else {
-            if (isMcastId()) {
-              sb.append(this.host.getHostAddress());
-            }
-            else {
-              sb.append(SocketCreator.getHostName(this.host));
-            }
-          }
-    
-	  sb.append("[").append(this.port).append("]");
-	  return sb.toString();
-	}
-	/**
-	 * Indicates whether some other object is "equal to" this one.
-	 *
-	 * @param  other  the reference object with which to compare.
-	 * @return true if this object is the same as the obj argument;
-	 *         false otherwise.
-	 */
-  @Override
-	public boolean equals(Object other) {
-	  if (other == this) return true;
-	  if (other == null) return false;
-	  if (!(other instanceof DistributionLocatorId)) return  false;
-	  final DistributionLocatorId that = (DistributionLocatorId) other;
-
-	  if (this.host != that.host &&
-	  	  !(this.host != null &&
-	  	  this.host.equals(that.host))) return false;
-	  if (this.port != that.port) return false;
-	  if (!StringUtils.equals(this.bindAddress, that.bindAddress)) return false;
-
-	  return true;
-	}
-
-	/**
-	 * Returns a hash code for the object. This method is supported for the
-	 * benefit of hashtables such as those provided by java.util.Hashtable.
-	 *
-	 * @return the integer 0 if description is null; otherwise a unique integer.
-	 */
-  @Override
-	public int hashCode() {
-	  int result = 17;
-	  final int mult = 37;
-
-	  result = mult * result + 
-		  (this.host == null ? 0 : this.host.hashCode());
-	  result = mult * result + this.port;
-	  result = mult * result + 
-		  (this.bindAddress == null ? 0 : this.bindAddress.hashCode());
-
-	  return result;
-	}
-  
-   * Converts a collection of {@link Locator} instances to a collection of
-   * DistributionLocatorId instances. Note this will use {@link 
-   * SocketCreator#getLocalHost()} as the host for DistributionLocatorId.
-   * This is because all instances of Locator are local only.
+   * Returns a string representation of the object.
+   * 
+   * @return a string representation of the object
+   */
+  @Override
+  public String toString() {
+    StringBuffer sb = new StringBuffer();
+
+    // If hostnameForClients is set, use that
+    if (this.hostnameForClients != null && this.hostnameForClients.length() > 0) {
+      sb.append(this.hostnameForClients);
+    } else if (this.bindAddress != null && this.bindAddress.length() > 0) {
+      // if bindAddress then use that instead of host...
+      sb.append(this.bindAddress);
+    } else {
+      if (isMcastId()) {
+        sb.append(this.host.getHostAddress());
+      } else {
+        sb.append(SocketCreator.getHostName(this.host));
+      }
+    }
+
+    sb.append("[").append(this.port).append("]");
+    return sb.toString();
+  }
+
+  /**
+   * Indicates whether some other object is "equal to" this one.
+   *
+   * @param other the reference object with which to compare.
+   * @return true if this object is the same as the obj argument; false otherwise.
+   */
+  @Override
+  public boolean equals(Object other) {
+    if (other == this)
+      return true;
+    if (other == null)
+      return false;
+    if (!(other instanceof DistributionLocatorId))
+      return false;
+    final DistributionLocatorId that = (DistributionLocatorId) other;
+
+    if (this.host != that.host && !(this.host != null && this.host.equals(that.host)))
+      return false;
+    if (this.port != that.port)
+      return false;
+    if (!StringUtils.equals(this.bindAddress, that.bindAddress))
+      return false;
+
+    return true;
+  }
+
+  /**
+   * Returns a hash code for the object. This method is supported for the benefit of hashtables such
+   * as those provided by java.util.Hashtable.
+   *
+   * @return the integer 0 if description is null; otherwise a unique integer.
+   */
+  @Override
+  public int hashCode() {
+    int result = 17;
+    final int mult = 37;
+
+    result = mult * result + (this.host == null ? 0 : this.host.hashCode());
+    result = mult * result + this.port;
+    result = mult * result + (this.bindAddress == null ? 0 : this.bindAddress.hashCode());
+
+    return result;
+  }
+
+  /**
+   * Converts a collection of {@link Locator} instances to a collection of DistributionLocatorId
+   * instances. Note this will use {@link SocketCreator#getLocalHost()} as the host for
+   * DistributionLocatorId. This is because all instances of Locator are local only.
-  public static Collection<DistributionLocatorId> asDistributionLocatorIds(Collection<Locator> locators) throws UnknownHostException {
+  public static Collection<DistributionLocatorId> asDistributionLocatorIds(
+      Collection<Locator> locators) throws UnknownHostException {
-      DistributionLocatorId locatorId = new DistributionLocatorId(
-          SocketCreator.getLocalHost(), locator);
+      DistributionLocatorId locatorId =
+          new DistributionLocatorId(SocketCreator.getLocalHost(), locator);
-  
+
-   * Marshals a collection of {@link Locator} instances to a collection of
-   * DistributionLocatorId instances. Note this will use {@link 
-   * SocketCreator#getLocalHost()} as the host for DistributionLocatorId.
-   * This is because all instances of Locator are local only.
+   * Marshals a collection of {@link Locator} instances to a collection of DistributionLocatorId
+   * instances. Note this will use {@link SocketCreator#getLocalHost()} as the host for
+   * DistributionLocatorId. This is because all instances of Locator are local only.
-  
+

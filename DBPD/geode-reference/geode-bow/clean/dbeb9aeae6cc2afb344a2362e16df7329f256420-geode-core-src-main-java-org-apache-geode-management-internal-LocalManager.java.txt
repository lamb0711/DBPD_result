Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * a) Handles proxy creation when Management node comes up b) Handles proxy
- * creation when a member joins c) Remove proxies when a member leaves or node
- * stops being management node. d) Takes care to create resources like hidden
- * regions for MBean and notification federation.
+ * a) Handles proxy creation when Management node comes up b) Handles proxy creation when a member
+ * joins c) Remove proxies when a member leaves or node stops being management node. d) Takes care
+ * to create resources like hidden regions for MBean and notification federation.
-   * This service will be responsible for executing ManagementTasks and
-   * periodically push data to localMonitoringRegion
+   * This service will be responsible for executing ManagementTasks and periodically push data to
+   * localMonitoringRegion
-   * This map holds all the components which are eligible for federation.
-   * Although filters might prevent any of the component from getting federated.
+   * This map holds all the components which are eligible for federation. Although filters might
+   * prevent any of the component from getting federated.
-  
-  
+
+
-  
+
-   * @param repo
-   *          management resource repo
-   * @param system
-   *          internal distributed system
+   * @param repo management resource repo
+   * @param system internal distributed system
-  public LocalManager(ManagementResourceRepo repo,
-      InternalDistributedSystem system, SystemManagementService service, Cache cache) {
-    super(repo, system,cache);
+  public LocalManager(ManagementResourceRepo repo, InternalDistributedSystem system,
+      SystemManagementService service, Cache cache) {
+    super(repo, system, cache);
-   * Management Region : its a Replicated NO_ACK region Notification Region :
-   * its a Replicated Proxy NO_ACK region
+   * Management Region : its a Replicated NO_ACK region Notification Region : its a Replicated Proxy
+   * NO_ACK region
-  private void startLocalManagement(
-      Map<ObjectName, FederationComponent> federatedComponentMap) {
+  private void startLocalManagement(Map<ObjectName, FederationComponent> federatedComponentMap) {
-            final ThreadGroup group = LoggingThreadGroup.createThreadGroup(ManagementStrings.MANAGEMENT_TASK_THREAD_GROUP
-                .toLocalizedString(), logger);
-            Thread thread = new Thread(group, r, ManagementStrings.MANAGEMENT_TASK.toLocalizedString());
+            final ThreadGroup group = LoggingThreadGroup.createThreadGroup(
+                ManagementStrings.MANAGEMENT_TASK_THREAD_GROUP.toLocalizedString(), logger);
+            Thread thread =
+                new Thread(group, r, ManagementStrings.MANAGEMENT_TASK.toLocalizedString());
-        singleThreadFederationScheduler = Executors
-            .newSingleThreadScheduledExecutor(tf);
-        
-        if(logger.isDebugEnabled()){
+        singleThreadFederationScheduler = Executors.newSingleThreadScheduledExecutor(tf);
+
+        if (logger.isDebugEnabled()) {
-        
+
-         * Sharing the same Internal Argument for both notification region and
-         * monitoring region
+         * Sharing the same Internal Argument for both notification region and monitoring region
-            return new CachePerfStats(cache.getDistributedSystem(),
-                "managementRegionStats");
+            return new CachePerfStats(cache.getDistributedSystem(), "managementRegionStats");
-        AttributesFactory<String, Object> monitorRegionAttributeFactory = new AttributesFactory<String, Object>();
+        AttributesFactory<String, Object> monitorRegionAttributeFactory =
+            new AttributesFactory<String, Object>();
-        MonitoringRegionCacheListener localListener = new MonitoringRegionCacheListener(
-            service);
+        MonitoringRegionCacheListener localListener = new MonitoringRegionCacheListener(service);
-        RegionAttributes<String, Object> monitoringRegionAttrs = monitorRegionAttributeFactory
-            .create();
+        RegionAttributes<String, Object> monitoringRegionAttrs =
+            monitorRegionAttributeFactory.create();
-        AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory = new AttributesFactory<NotificationKey, Notification>();
+        AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
+            new AttributesFactory<NotificationKey, Notification>();
-        RegionAttributes<NotificationKey, Notification> notifRegionAttrs = notificationRegionAttributeFactory
-            .create();
+        RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
+            notificationRegionAttributeFactory.create();
-        String appender = MBeanJMXAdapter.getUniqueIDForMember(cache
-            .getDistributedSystem().getDistributedMember());
+        String appender = MBeanJMXAdapter
+            .getUniqueIDForMember(cache.getDistributedSystem().getDistributedMember());
-          repo.setLocalMonitoringRegion(cache.createVMRegion(
-              ManagementConstants.MONITORING_REGION + "_" + appender,
-              monitoringRegionAttrs, internalArgs));
+          repo.setLocalMonitoringRegion(
+              cache.createVMRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
+                  monitoringRegionAttrs, internalArgs));
-          repo.setLocalNotificationRegion(cache.createVMRegion(
-              ManagementConstants.NOTIFICATION_REGION + "_" + appender,
-              notifRegionAttrs, internalArgs));
+          repo.setLocalNotificationRegion(
+              cache.createVMRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
+                  notifRegionAttrs, internalArgs));
-        singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate, TimeUnit.MILLISECONDS);
+        singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
+            TimeUnit.MILLISECONDS);
-          logger.debug("Management Region created with Name : {}", repo.getLocalMonitoringRegion().getName());
-          logger.debug("Notification Region created with Name : {}", repo.getLocalNotificationRegion().getName());
+          logger.debug("Management Region created with Name : {}",
+              repo.getLocalMonitoringRegion().getName());
+          logger.debug("Notification Region created with Name : {}",
+              repo.getLocalNotificationRegion().getName());
-    if (!cache.isClosed() && InternalDistributedSystem.getConnectedInstance() !=null) {
+    if (!cache.isClosed() && InternalDistributedSystem.getConnectedInstance() != null) {
-   *For internal Use only
+   * For internal Use only
-  
+
-   * Internal testing hook.Not to be used from any where else.
-   * As soon as a mbean is created we can push the data into local region
-   * which will make the data available at managing node site.
+   * Internal testing hook.Not to be used from any where else. As soon as a mbean is created we can
+   * push the data into local region which will make the data available at managing node site.
-  public void runManagementTaskAdhoc(){
+  public void runManagementTaskAdhoc() {
-   * This task is responsible for pushing data to the hidden region. It is
-   * executed in a single thread from
-   * Executors.newSingleThreadScheduledExecutor(); Only one thread will be
-   * responsible for pushing the data to the hidden region.
+   * This task is responsible for pushing data to the hidden region. It is executed in a single
+   * thread from Executors.newSingleThreadScheduledExecutor(); Only one thread will be responsible
+   * for pushing the data to the hidden region.
-   * (Note however that if this single thread terminates due to a failure during
-   * execution prior to shutdown, a new one will take its place if needed to
-   * execute subsequent tasks.) Tasks are guaranteed to execute sequentially,
-   * and no more than one task will be active at any given time. Unlike the
-   * otherwise equivalent <tt>newScheduledThreadPool(1)</tt> the returned
-   * executor is guaranteed not to be reconfigurable to use additional threads.
+   * (Note however that if this single thread terminates due to a failure during execution prior to
+   * shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are
+   * guaranteed to execute sequentially, and no more than one task will be active at any given time.
+   * Unlike the otherwise equivalent <tt>newScheduledThreadPool(1)</tt> the returned executor is
+   * guaranteed not to be reconfigurable to use additional threads.
-    public ManagementTask(Map<ObjectName, FederationComponent> federatedComponentMap) throws ManagementException {
+    public ManagementTask(Map<ObjectName, FederationComponent> federatedComponentMap)
+        throws ManagementException {
-     
+
-  
-  public void stopCacheOps(){
+
+  public void stopCacheOps() {
-  
-  public void startCacheOps(){
+
+  public void startCacheOps() {
-  
-  public Map<ObjectName, FederationComponent> getFedComponents(){
+
+  public Map<ObjectName, FederationComponent> getFedComponents() {

Merge branch 'release/1.5.0'

+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_ACCESSOR;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_ACCESSOR_PP;
+import java.io.EOFException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import org.apache.commons.lang.mutable.MutableInt;
+import org.apache.geode.cache.UnsupportedVersionException;
-import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
-import org.apache.geode.internal.cache.tier.ClientHandShake;
+import org.apache.geode.internal.cache.tier.ServerSideHandshake;
-  private final SecurityService securityService;
+  protected final SecurityService securityService;
-  // private static boolean useDataStream =
-  // System.getProperty("hct.useDataStream", "false").equals("true");
+  private final ServerSideHandshakeFactory handshakeFactory = new ServerSideHandshakeFactory();
+  private ServerConnectionCollection serverConnectionCollection;
-  protected ClientHandShake handshake;
-  private int handShakeTimeout;
-  private final Object handShakeMonitor = new Object();
+  protected ServerSideHandshake handshake;
+  private int handshakeTimeout;
+  private final Object handshakeMonitor = new Object();
-  /*
-   * Uniquely identifying the client's Distributed System
-   *
-   *
-   * private String membershipId;
-   *
-   *
-   * Uniquely identifying the client's ConnectionProxy object
-   *
-   *
-   * private String proxyID ;
+  /**
+   * Client identity from handshake
-      this.handShakeTimeout = hsTimeout;
+      this.handshakeTimeout = hsTimeout;
-    synchronized (this.handShakeMonitor) {
+    synchronized (this.handshakeMonitor) {
-        // synchronized (getCleanupTable()) {
-        boolean readHandShake = ServerHandShakeProcessor.readHandShake(this, getSecurityService());
-        if (readHandShake) {
-          if (this.handshake.isOK()) {
-            try {
-              return processHandShake();
-            } catch (CancelException e) {
-              if (!crHelper.isShutdown()) {
-                logger.warn(LocalizedMessage.create(
-                    LocalizedStrings.ServerConnection_0_UNEXPECTED_CANCELLATION, getName()), e);
-              }
-              cleanup();
-              return false;
+        ServerSideHandshake readHandshake;
+        try {
+
+          readHandshake = handshakeFactory.readHandshake(getSocket(), getHandShakeTimeout(),
+              getCommunicationMode(), getDistributedSystem(), getSecurityService());
+
+        } catch (SocketTimeoutException timeout) {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.ServerHandShakeProcessor_0_HANDSHAKE_REPLY_CODE_TIMEOUT_NOT_RECEIVED_WITH_IN_1_MS,
+              new Object[] {getName(), Integer.valueOf(handshakeTimeout)}));
+          failConnectionAttempt();
+          return false;
+        } catch (EOFException | SocketException e) {
+          // no need to warn client just gave up on this server before we could
+          // handshake
+          logger.info("{} {}", getName(), e);
+          failConnectionAttempt();
+          return false;
+        } catch (IOException e) {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.ServerHandShakeProcessor_0_RECEIVED_NO_HANDSHAKE_REPLY_CODE,
+              getName()), e);
+          failConnectionAttempt();
+          return false;
+        } catch (AuthenticationRequiredException | AuthenticationFailedException ex) {
+          handleHandshakeAuthenticationException(ex);
+          return false;
+        } catch (UnsupportedVersionException uve) {
+          // Server logging
+          logger.warn("{} {}", getName(), uve.getMessage(), uve);
+          handleHandshakeException(uve);
+          return false;
+        } catch (Exception ex) {
+          logger.warn("{} {}", getName(), ex.getLocalizedMessage());
+          handleHandshakeException(ex);
+          return false;
+        }
+
+        setHandshake(readHandshake);
+        setProxyId(readHandshake.getMembershipId());
+        if (readHandshake.getVersion().compareTo(Version.GFE_65) < 0
+            || getCommunicationMode().isWAN()) {
+          try {
+            setAuthAttributes();
+
+          } catch (AuthenticationRequiredException | AuthenticationFailedException ex) {
+            handleHandshakeAuthenticationException(ex);
+            return false;
+          } catch (Exception ex) {
+            logger.warn("{} {}", getName(), ex.getLocalizedMessage());
+            handleHandshakeException(ex);
+            return false;
+          }
+        }
+
+        // readHandshake will establish a handshake object in this ServerConnection
+        if (this.handshake.isOK()) {
+          try {
+            return processHandShake();
+          } catch (CancelException e) {
+            if (!crHelper.isShutdown()) {
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.ServerConnection_0_UNEXPECTED_CANCELLATION, getName()), e);
-          } else {
-            this.crHelper.checkCancelInProgress(null); // bug 37113?
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.ServerConnection_0_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE_1,
-                new Object[] {this.name, new Byte(this.handshake.getCode())}));
-            refuseHandshake(LocalizedStrings.ServerConnection_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE
-                .toLocalizedString(), ServerHandShakeProcessor.REPLY_INVALID);
+            cleanup();
-          this.stats.incFailedConnectionAttempts();
-          cleanup();
+          // is this branch ever taken?
+          this.crHelper.checkCancelInProgress(null); // bug 37113?
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.ServerConnection_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE));
+          refuseHandshake(LocalizedStrings.ServerConnection_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE
+              .toLocalizedString(), AcceptorImpl.REPLY_INVALID);
-        // }
+  private void failConnectionAttempt() {
+    stats.incFailedConnectionAttempts();
+    cleanup();
+  }
+
+  private void handleHandshakeException(Exception ex) {
+    refuseHandshake(ex.getMessage(), AcceptorImpl.REPLY_REFUSED);
+    failConnectionAttempt();
+  }
+
+  private void handleHandshakeAuthenticationException(Exception ex) {
+    if (ex instanceof AuthenticationRequiredException) {
+      AuthenticationRequiredException noauth = (AuthenticationRequiredException) ex;
+      String exStr = noauth.getLocalizedMessage();
+      if (noauth.getCause() != null) {
+        exStr += " : " + noauth.getCause().getLocalizedMessage();
+      }
+      if (securityLogWriter.warningEnabled()) {
+        securityLogWriter.warning(LocalizedStrings.ONE_ARG,
+            getName() + ": Security exception: " + exStr);
+      }
+      refuseHandshake(noauth.getMessage(), Handshake.REPLY_EXCEPTION_AUTHENTICATION_REQUIRED);
+      failConnectionAttempt();
+    } else if (ex instanceof AuthenticationFailedException) {
+      AuthenticationFailedException failed = (AuthenticationFailedException) ex;
+      String exStr = failed.getLocalizedMessage();
+      if (failed.getCause() != null) {
+        exStr += " : " + failed.getCause().getLocalizedMessage();
+      }
+      if (securityLogWriter.warningEnabled()) {
+        securityLogWriter.warning(LocalizedStrings.ONE_ARG,
+            getName() + ": Security exception: " + exStr);
+      }
+      refuseHandshake(failed.getMessage(), Handshake.REPLY_EXCEPTION_AUTHENTICATION_FAILED);
+      failConnectionAttempt();
+    } else {
+      logger.warn(
+          "Unexpected exception type in ServerConnection handleHandshakeAuthenticationException");
+      throw new RuntimeException(
+          "Invalid exception type, must be either AuthenticationRequiredException or AuthenticationFailedException",
+          ex);
+    }
+  }
+
-    return this.handShakeTimeout;
+    return this.handshakeTimeout;
-  public ClientHandShake getHandshake() {
+  public ServerSideHandshake getHandshake() {
-  public void setHandshake(ClientHandShake handshake) {
+  public void setHandshake(ServerSideHandshake handshake) {
-    // LogWriterI18n log = InternalDistributedSystem.getLoggerI18n();
-    // byte[] oldIdArray = proxyId.getMembershipByteArray();
-    // log.warning(LocalizedStrings.DEBUG, "Size comparison for " + proxyId.getDistributedMember()
-    // + " old=" + oldIdArray.length + " new=" + memberIdByteArray.length
-    // + " diff=" + (oldIdArray.length - memberIdByteArray.length));
-  private Map getCleanupTable() {
+  private Map<ServerSideHandshake, MutableInt> getCleanupTable() {
-  private Map getCleanupProxyIdTable() {
+  private Map<ClientProxyMembershipID, MutableInt> getCleanupProxyIdTable() {
-  private ClientHealthMonitor getClientHealthMonitor() {
-    return acceptor.getClientHealthMonitor();
-  }
-
-  private boolean processHandShake() {
+  protected boolean processHandShake() {
-        Counter numRefs = (Counter) getCleanupTable().get(this.handshake);
-        byte epType = (byte) 0;
-        int qSize = 0;
+        MutableInt numRefs = getCleanupTable().get(this.handshake);
+        byte endpointType = (byte) 0;
+        int queueSize = 0;
-              epType = (byte) 2;
-              qSize = proxy.getQueueSize();
+              endpointType = (byte) 2;
+              queueSize = proxy.getQueueSize();
-              epType = (byte) 1;
-              qSize = proxy.getQueueSize();
+              endpointType = (byte) 1;
+              queueSize = proxy.getQueueSize();
-                  HandShake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT);
+                  Handshake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT);
-          if (acceptHandShake(epType, qSize)) {
-            numRefs.incr();
+          if (acceptHandShake(endpointType, queueSize)) {
+            numRefs.increment();
-          if (acceptHandShake(epType, qSize)) {
+          if (acceptHandShake(endpointType, queueSize)) {
-            numRefs = new Counter();
-            getCleanupTable().put(this.handshake, numRefs);
-            numRefs.incr();
+            getCleanupTable().put(this.handshake, new MutableInt(1));
-        Counter numRefs = (Counter) getCleanupProxyIdTable().get(this.proxyId);
+        MutableInt numRefs = getCleanupProxyIdTable().get(this.proxyId);
-          numRefs.incr();
+          numRefs.increment();
-          numRefs = new Counter();
-          numRefs.incr();
-          getCleanupProxyIdTable().put(this.proxyId, numRefs);
-          InternalDistributedMember idm =
-              (InternalDistributedMember) this.proxyId.getDistributedMember();
+          getCleanupProxyIdTable().put(this.proxyId, new MutableInt(1));
-      chm.addConnection(this.proxyId, this);
+      serverConnectionCollection = chm.addConnection(this.proxyId, this);
-      ServerHandShakeProcessor.refuse(this.theSocket.getOutputStream(), msg, exception);
+      acceptor.refuseHandshake(this.theSocket.getOutputStream(), msg, exception);
-  protected boolean acceptHandShake(byte epType, int qSize) {
-    return doHandShake(epType, qSize) && handshakeAccepted();
+  protected boolean acceptHandShake(byte endpiontType, int queueSize) {
+    return doHandShake(endpiontType, queueSize) && handshakeAccepted();
-        secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+        secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
-  static class Counter {
-    int cnt;
-
-    void incr() {
-      ++cnt;
-    }
-
-    int decr() {
-      return --cnt;
-    }
-
-    int getCnt() {
-      return cnt;
-    }
-  }
-
+    if (serverConnectionCollection == null) {
+      // return here if we haven't successfully completed handshake
+      logger.warn("Continued processing ServerConnection after handshake failed");
+      this.processMessages = false;
+      return;
+    }
+    synchronized (serverConnectionCollection) {
+      if (serverConnectionCollection.isTerminating) {
+        // Client is being disconnected, don't try to process message.
+        this.processMessages = false;
+        return;
+      }
+      serverConnectionCollection.connectionsProcessing.incrementAndGet();
+    }
-        if (AcceptorImpl.isIntegratedSecurity()
+        if (securityService.isIntegratedSecurity()
+      serverConnectionCollection.connectionsProcessing.decrementAndGet();
-
-        Counter numRefs = (Counter) getCleanupTable().get(this.handshake);
+        MutableInt numRefs = getCleanupTable().get(this.handshake);
-          numRefs.decr();
-          if (numRefs.getCnt() <= 0) {
+          numRefs.decrement();
+          if (numRefs.toInteger() <= 0) {
-        Counter numRefs = (Counter) getCleanupProxyIdTable().get(this.proxyId);
+        MutableInt numRefs = getCleanupProxyIdTable().get(this.proxyId);
-          numRefs.decr();
-          if (numRefs.getCnt() <= 0) {
+          numRefs.decrement();
+          if (numRefs.toInteger() <= 0) {
-            InternalDistributedMember idm =
-                (InternalDistributedMember) this.proxyId.getDistributedMember();
-  private void initializeCommands() {
+  protected void initializeCommands() {
-      secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+      secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
-      secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+      secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
-      credBytes = ((HandShake) this.handshake).decryptBytes(credBytes);
+      credBytes = this.handshake.getEncryptor().decryptBytes(credBytes);
-      Object principal = HandShake.verifyCredentials(methodName, credentials,
+      Object principal = Handshake.verifyCredentials(methodName, credentials,
-        uniqueId = ServerHandShakeProcessor.getUniqueId(this, (Principal) principal);
+        uniqueId = getUniqueId((Principal) principal);
+    processMessages = false;
-  boolean getFlagProcessMessages() {
-    return this.processMessages;
-  }
-
-      return ((HandShake) this.handshake).encryptBytes(hdos.toByteArray());
+      return this.handshake.getEncryptor().encryptBytes(hdos.toByteArray());
-          (HandShake) this.handshake, this.connectionId);
+          this.handshake.getEncryptor(), this.connectionId);
-    if (AcceptorImpl.isIntegratedSecurity()) {
+    if (securityService.isIntegratedSecurity()) {
-    if (AcceptorImpl.isIntegratedSecurity()) {
+    if (securityService.isIntegratedSecurity()) {
-  public MessageIdExtractor getMessageIdExtractor() {
-    return this.messageIdExtractor;
+  void setAuthAttributes() throws Exception {
+    logger.debug("setAttributes()");
+    Object principal = getHandshake().verifyCredentials();
+
+    long uniqueId;
+    if (principal instanceof Subject) {
+      uniqueId = getClientUserAuths(getProxyID()).putSubject((Subject) principal);
+    } else {
+      // this sets principal in map as well....
+      uniqueId = getUniqueId((Principal) principal);
+      setPrincipal((Principal) principal);
+    }
+    setUserAuthId(uniqueId);
+  }
+
+  /**
+   * For legacy auth?
+   */
+  private long getUniqueId(Principal principal) throws Exception {
+    InternalLogWriter securityLogWriter = getSecurityLogWriter();
+    DistributedSystem system = getDistributedSystem();
+    Properties systemProperties = system.getProperties();
+    String authzFactoryName = systemProperties.getProperty(SECURITY_CLIENT_ACCESSOR);
+    String postAuthzFactoryName = systemProperties.getProperty(SECURITY_CLIENT_ACCESSOR_PP);
+    AuthorizeRequest authzRequest = null;
+    AuthorizeRequestPP postAuthzRequest = null;
+
+    if (authzFactoryName != null && authzFactoryName.length() > 0) {
+      if (securityLogWriter.fineEnabled())
+        securityLogWriter.fine(
+            getName() + ": Setting pre-process authorization callback to: " + authzFactoryName);
+      if (principal == null) {
+        if (securityLogWriter.warningEnabled()) {
+          securityLogWriter.warning(
+              LocalizedStrings.ServerHandShakeProcessor_0_AUTHORIZATION_ENABLED_BUT_AUTHENTICATION_CALLBACK_1_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_2,
+              new Object[] {getName(), SECURITY_CLIENT_AUTHENTICATOR, getProxyID()});
+        }
+      }
+      authzRequest = new AuthorizeRequest(authzFactoryName, getProxyID(), principal, getCache());
+    }
+    if (postAuthzFactoryName != null && postAuthzFactoryName.length() > 0) {
+      if (securityLogWriter.fineEnabled())
+        securityLogWriter.fine(getName() + ": Setting post-process authorization callback to: "
+            + postAuthzFactoryName);
+      if (principal == null) {
+        if (securityLogWriter.warningEnabled()) {
+          securityLogWriter.warning(
+              LocalizedStrings.ServerHandShakeProcessor_0_POSTPROCESS_AUTHORIZATION_ENABLED_BUT_NO_AUTHENTICATION_CALLBACK_2_IS_CONFIGURED,
+              new Object[] {getName(), SECURITY_CLIENT_AUTHENTICATOR});
+        }
+      }
+      postAuthzRequest =
+          new AuthorizeRequestPP(postAuthzFactoryName, getProxyID(), principal, getCache());
+    }
+    return setUserAuthorizeAndPostAuthorizeRequest(authzRequest, postAuthzRequest);

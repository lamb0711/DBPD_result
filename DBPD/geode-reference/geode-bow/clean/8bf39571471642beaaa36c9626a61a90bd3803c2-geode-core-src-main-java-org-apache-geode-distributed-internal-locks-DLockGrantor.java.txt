Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Provides lock grantor authority to a distributed lock service. This is
- * responsible for granting, releasing, and timing out locks as well as
- * exposing hooks for recovery or transfer of lock grantor.
+ * Provides lock grantor authority to a distributed lock service. This is responsible for granting,
+ * releasing, and timing out locks as well as exposing hooks for recovery or transfer of lock
+ * grantor.
-  
+
-  
-  /** 
-   * Default wait before grantor thread will reawaken to check for expirations
-   * and timeouts.
+
+  /**
+   * Default wait before grantor thread will reawaken to check for expirations and timeouts.
-   * Newly constructed grantor is INITIALIZING. All lock requests and related
-   * messages will block.
+   * Newly constructed grantor is INITIALIZING. All lock requests and related messages will block.
-  private static final int INITIALIZING = 0;  // msgs will block until READY
-  
+  private static final int INITIALIZING = 0; // msgs will block until READY
+
-  private static final int READY = 1;         // msgs will be processed
-  
+  private static final int READY = 1; // msgs will be processed
+
-  private static final int DESTROYED = 5;     // NOT_GRANTOR
-  
-  /** 
+  private static final int DESTROYED = 5; // NOT_GRANTOR
+
+  /**
-  
+
-   * Map of grant tokens for tracking grantor-side state of distributed locks.
-   * Key: Object name, Value: DLockGrantToken grant
+   * Map of grant tokens for tracking grantor-side state of distributed locks. Key: Object name,
+   * Value: DLockGrantToken grant
-  /** 
-   * Dedicated thread responsible for handling expirations and timeouts. 
+  /**
+   * Dedicated thread responsible for handling expirations and timeouts.
-  
-  /** 
-   * The current state of this grantor. Volatile for read access. Mutation
-   * must occur while synchronized on this grantor.
+
+  /**
+   * The current state of this grantor. Volatile for read access. Mutation must occur while
+   * synchronized on this grantor.
-   * State starts out as INITIALIZING and moves to READY at which point the
-   * grantor will start servicing requests.
+   * State starts out as INITIALIZING and moves to READY at which point the grantor will start
+   * servicing requests.
-   * If a newcomer requests transfer of grantorship, then the state will
-   * change to HALTED and then finally become DESTROYED when transfer is
-   * complete. During HALTED, the elder recognizes the newcomer as the current
-   * grantor.
+   * If a newcomer requests transfer of grantorship, then the state will change to HALTED and then
+   * finally become DESTROYED when transfer is complete. During HALTED, the elder recognizes the
+   * newcomer as the current grantor.
-   * If this service is shutting down, it will seek out a successor to become 
-   * the new grantor. During this phase, the state will be PENDING_SHUTDOWN which means
-   * no requests or releases will be replied to until a successor is found,
-   * registers transfer intentions with the elder and sends this process a
-   * transfer grantorship request. At that point the state will be HALTED as
+   * If this service is shutting down, it will seek out a successor to become the new grantor.
+   * During this phase, the state will be PENDING_SHUTDOWN which means no requests or releases will
+   * be replied to until a successor is found, registers transfer intentions with the elder and
+   * sends this process a transfer grantorship request. At that point the state will be HALTED as
-  /** 
-   * ReadWriteLock to protect in-progress operations from destroying service. 
+  /**
+   * ReadWriteLock to protect in-progress operations from destroying service.
-  
-  /** 
+
+  /**
-  
-  /** 
+
+  /**
-  /** 
-   * Enforces waiting until this grantor is initialized. Used to block all
-   * lock requests until INITIALIZED. 
+  /**
+   * Enforces waiting until this grantor is initialized. Used to block all lock requests until
+   * INITIALIZED.
-  /** 
-   * Enforces waiting until this grantor is destroyed. Used to block all
-   * lock requests while destroying. Latch opens after state becomes DESTROYED
-   * and grantor begins replying with NOT_GRANTOR. 
+  /**
+   * Enforces waiting until this grantor is destroyed. Used to block all lock requests while
+   * destroying. Latch opens after state becomes DESTROYED and grantor begins replying with
+   * NOT_GRANTOR.
-  
-  /** 
-   * If -1 then it has not yet been fetched from elder. Otherwise it is the 
-   * versionId that the elder gave us. During explicit becomeGrantor, the
-   * value is -1, and then the elder provides a real versionId. 
+
+  /**
+   * If -1 then it has not yet been fetched from elder. Otherwise it is the versionId that the elder
+   * gave us. During explicit becomeGrantor, the value is -1, and then the elder provides a real
+   * versionId.
-  
-  /** 
-   * Used to verify that requestor member is still in view when granting. 
+
+  /**
+   * Used to verify that requestor member is still in view when granting.
-  
+
-  //   SuspendLocking state (BEGIN)
-  
-  /** 
-   * Synchronization for protecting all SuspendLocking state. Guards all
-   * suspend locking state. 
+  // SuspendLocking state (BEGIN)
+
+  /**
+   * Synchronization for protecting all SuspendLocking state. Guards all suspend locking state.
-  /** 
+  /**
-  
+
-  /** 
-   * Identifies the lockId used by the remote thread to suspend locking. 
+  /**
+   * Identifies the lockId used by the remote thread to suspend locking.
-  
-  /** 
+
+  /**
-  
+
-   * <p> 
-   * Key=RemoteThread, Value=ReadLockCount 
+   * <p>
+   * Key=RemoteThread, Value=ReadLockCount
-  
-  /** 
-   * Number of suspend waiters waiting for write lock. 
+
+  /**
+   * Number of suspend waiters waiting for write lock.
-  
-  /** 
-   * Total number of read locks held against suspend write lock. 
+
+  /**
+   * Total number of read locks held against suspend write lock.
-  
-  /** 
-   * List of next requests to process after handling an unlock or resume. 
+
+  /**
+   * List of next requests to process after handling an unlock or resume.
-  /** 
-   * List of active drains of permittedRequests. TODO: does this need to be
-   * a synchronizedList?
+  /**
+   * List of active drains of permittedRequests. TODO: does this need to be a synchronizedList?
-  private final List permittedRequestsDrain = 
-      Collections.synchronizedList(new LinkedList());
-  
-  //   SuspendLocking state (END)
+  private final List permittedRequestsDrain = Collections.synchronizedList(new LinkedList());
+
+  // SuspendLocking state (END)
-  //   Static methods
+  // Static methods
-  
+
-  static DLockGrantor createGrantor(DLockService dlock,
-                                    long versionId) {
+  static DLockGrantor createGrantor(DLockService dlock, long versionId) {
-   * @return instance of grantor for the lock service or null if no local 
-   * grantor has been created
+   * @return instance of grantor for the lock service or null if no local grantor has been created
-    if (dlock == null) return null;
+    if (dlock == null)
+      return null;
-  /** 
-   * Returns instance of DLockGrantor that will handle distributed lock
-   * granting for specified service.
-   * <p> 
-   * Returns null if unable to get ready grantor or if this process is not the 
-   * grantor for the service.
+  /**
+   * Returns instance of DLockGrantor that will handle distributed lock granting for specified
+   * service.
+   * <p>
+   * Returns null if unable to get ready grantor or if this process is not the grantor for the
+   * service.
-    if (svc == null) return null;
+    if (svc == null)
+      return null;
-      if (grantor == null || grantor.isDestroyed()) return null;
+      if (grantor == null || grantor.isDestroyed())
+        return null;
-      if (svc.isDestroyed()) return null;
+      if (svc.isDestroyed())
+        return null;
-      if (!svc.isCurrentlyOrIsMakingLockGrantor()) return null;
-      if (!grantor.isReady()) return null;
+      if (!svc.isCurrentlyOrIsMakingLockGrantor())
+        return null;
+      if (!grantor.isReady())
+        return null;
-    
+
-  //   Constructor
+  // Constructor
-  
+
-  private DLockGrantor(DLockService dlock, 
-                       long vId) {
+  private DLockGrantor(DLockService dlock, long vId) {
-  
+
-  //   Public and package methods
+  // Public and package methods
-   * Returns the grantor's version id which was assigned by an elder. Required
-   * to help uniquely identify this grantor instance.
+   * Returns the grantor's version id which was assigned by an elder. Required to help uniquely
+   * identify this grantor instance.
-   * Sets the version id after the elder tells us what it is. This is called
-   * during the explicit become grantor process.
+   * Sets the version id after the elder tells us what it is. This is called during the explicit
+   * become grantor process.
-  
-  /** 
-   * Waits uninterruptibly while this grantor is initializing. Returns when
-   * grantor is ready to handle lock requests.
+
+  /**
+   * Waits uninterruptibly while this grantor is initializing. Returns when grantor is ready to
+   * handle lock requests.
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-  
-  /** 
-   * Waits uninterruptibly until this service is destroyed. Returns when
-   * grantor has been completely destroyed.
-   *  
+
+  /**
+   * Waits uninterruptibly until this service is destroyed. Returns when grantor has been completely
+   * destroyed.
+   * 
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
-        if (interrupted) Thread.currentThread().interrupt();
+      } finally {
+        if (interrupted)
+          Thread.currentThread().interrupt();
-  
+
-    buffer.append('<')
-      .append("DLockGrantor")
-      .append("@")
-      .append(Integer.toHexString(System.identityHashCode(this)))
-      .append(" state=")
-      .append(stateToString(this.state))
-      .append(" name=")
-      .append(this.dlock.getName())
-      .append(" version=")
-      .append(this.getVersionId())
-      .append('>');
+    buffer.append('<').append("DLockGrantor").append("@")
+        .append(Integer.toHexString(System.identityHashCode(this))).append(" state=")
+        .append(stateToString(this.state)).append(" name=").append(this.dlock.getName())
+        .append(" version=").append(this.getVersionId()).append('>');
-  
+
-   * Returns true if this grantor is still initializing and not yet ready
-   * for lock requests.
+   * Returns true if this grantor is still initializing and not yet ready for lock requests.
-  
+
-  
+
-      throw new LockGrantorDestroyedException(LocalizedStrings.DLockGrantor_GRANTOR_IS_DESTROYED.toLocalizedString());
+      throw new LockGrantorDestroyedException(
+          LocalizedStrings.DLockGrantor_GRANTOR_IS_DESTROYED.toLocalizedString());
-  
+
-      
+
-        this.resMgr.makeReservation((IdentityArrayList)batch.getReqs());
+        this.resMgr.makeReservation((IdentityArrayList) batch.getReqs());
-          logger.trace(LogMarker.DLS, "[DLockGrantor.handleLockBatch] granting {}", batch.getBatchId());
+          logger.trace(LogMarker.DLS, "[DLockGrantor.handleLockBatch] granting {}",
+              batch.getBatchId());
-//         // try-lock every lock in batch...
-//         Object name = null;
-//         Set lockNames = batch.getLockNames();
-//         Set acquiredLocks = new HashSet();
-//         long leaseExpireTime = -1;
-        
-//         for (Iterator iter = lockNames.iterator(); iter.hasNext();) {
-//           name = iter.next();
-//           DLockGrantToken grant = getOrCreateGrant(
-//               this.dlock.getOrCreateToken(name));
+        // // try-lock every lock in batch...
+        // Object name = null;
+        // Set lockNames = batch.getLockNames();
+        // Set acquiredLocks = new HashSet();
+        // long leaseExpireTime = -1;
-//           // calc lease expire time just once...              
-//           if (leaseExpireTime == -1) {
-//             leaseExpireTime = grant.calcLeaseExpireTime(request.getLeaseTime());
-//           }
-          
-//           // try to grant immediately else fail...
-//           if (grant.grantBatchLock(request.getSender(), leaseExpireTime)) {
-//             acquiredLocks.add(grant);
-//           } else {
-//             // fail out and release all..
-//             break;
-//           }
-//         } // for-loop
-        
-//         if (acquiredLocks.size() == lockNames.size()) {
-//           // got the locks!
-//           logFine("[DLockGrantor.handleLockBatch] granting " + 
-//               batch.getBatchId() + "; leaseExpireTime=" + leaseExpireTime);
-          
-//           // save the batch for later release...
-//           this.batchLocks.put(batch.getBatchId(), batch);
-//           request.respondWithGrant(leaseExpireTime);
-//         }
-//         else {
-//           // failed... release them all...
-//           for (Iterator iter = acquiredLocks.iterator(); iter.hasNext();) {
-//             DLockGrantToken grant = (DLockGrantToken) iter.next();
-//             grant.release();
-//           }
-//           request.respondWithTryLockFailed(name);
-//         }
-      }
-      catch (CommitConflictException ex) {
+        // for (Iterator iter = lockNames.iterator(); iter.hasNext();) {
+        // name = iter.next();
+        // DLockGrantToken grant = getOrCreateGrant(
+        // this.dlock.getOrCreateToken(name));
+
+        // // calc lease expire time just once...
+        // if (leaseExpireTime == -1) {
+        // leaseExpireTime = grant.calcLeaseExpireTime(request.getLeaseTime());
+        // }
+
+        // // try to grant immediately else fail...
+        // if (grant.grantBatchLock(request.getSender(), leaseExpireTime)) {
+        // acquiredLocks.add(grant);
+        // } else {
+        // // fail out and release all..
+        // break;
+        // }
+        // } // for-loop
+
+        // if (acquiredLocks.size() == lockNames.size()) {
+        // // got the locks!
+        // logFine("[DLockGrantor.handleLockBatch] granting " +
+        // batch.getBatchId() + "; leaseExpireTime=" + leaseExpireTime);
+
+        // // save the batch for later release...
+        // this.batchLocks.put(batch.getBatchId(), batch);
+        // request.respondWithGrant(leaseExpireTime);
+        // }
+        // else {
+        // // failed... release them all...
+        // for (Iterator iter = acquiredLocks.iterator(); iter.hasNext();) {
+        // DLockGrantToken grant = (DLockGrantToken) iter.next();
+        // grant.release();
+        // }
+        // request.respondWithTryLockFailed(name);
+        // }
+      } catch (CommitConflictException ex) {
-      }
-      finally {
+      } finally {
-  
+
-   * Returns transaction optimized lock batches that were created by the 
-   * specified owner. 
+   * Returns transaction optimized lock batches that were created by the specified owner.
-   *  
+   * 
-      return (DLockBatch[]) batchList.toArray(new DLockBatch[batchList.size()]);  
+      return (DLockBatch[]) batchList.toArray(new DLockBatch[batchList.size()]);
-  /**  
-   * Get the batch for the given batchId (for example use a txLockId from 
-   * TXLockBatch in order to update its participants).  This operation was 
-   * added as part of the solution to bug 32999. 
+  /**
+   * Get the batch for the given batchId (for example use a txLockId from TXLockBatch in order to
+   * update its participants). This operation was added as part of the solution to bug 32999.
-   *  
+   * 
-    synchronized(this.batchLocks) {
-      waitWhileInitializing();      
+    synchronized (this.batchLocks) {
+      waitWhileInitializing();
-      }
-      finally {
+      } finally {
-  /**  
-   * Update the batch for the given batch. This operation was added as part of 
-   * the solution to bug 32999. 
+  /**
+   * Update the batch for the given batch. This operation was added as part of the solution to bug
+   * 32999.
-    synchronized(this.batchLocks) {
-      waitWhileInitializing();      
+    synchronized (this.batchLocks) {
+      waitWhileInitializing();
-        if (oldBatch!=null) {
+        if (oldBatch != null) {
-      }
-      finally {
+      } finally {
-  public void releaseLockBatch(Object batchId, InternalDistributedMember owner) 
+  public void releaseLockBatch(Object batchId, InternalDistributedMember owner)
-          this.resMgr.releaseReservation((IdentityArrayList)batch.getReqs());
+          this.resMgr.releaseReservation((IdentityArrayList) batch.getReqs());
-//         Set lockNames = batch.getLockNames();
-//         for (Iterator iter = lockNames.iterator(); iter.hasNext();) {
-//           Object name = iter.next();
-//           DLockGrantToken grant = getOrCreateGrant(
-//               this.dlock.getOrCreateToken(name));
-//           grant.releaseIfLockedBy(owner);
-//         }
-      } 
-      finally {
+        // Set lockNames = batch.getLockNames();
+        // for (Iterator iter = lockNames.iterator(); iter.hasNext();) {
+        // Object name = iter.next();
+        // DLockGrantToken grant = getOrCreateGrant(
+        // this.dlock.getOrCreateToken(name));
+        // grant.releaseIfLockedBy(owner);
+        // }
+      } finally {
-  
+
-  
-  /** 
-   * TEST HOOK: Allows testing to determine if there are waiting requests for 
-   * a lock. 
+
+  /**
+   * TEST HOOK: Allows testing to determine if there are waiting requests for a lock.
-    if (grant == null) return false;
-    synchronized(grant) {
+    if (grant == null)
+      return false;
+    synchronized (grant) {
-   * Handles a DLockQueryMessage. Returns DLockGrantToken for the lock or
-   * null. 
+   * Handles a DLockQueryMessage. Returns DLockGrantToken for the lock or null.
-   *  
+   * 
-      }
-      finally {
+      } finally {
-  
+
-   * Handles the provided lock request. The lock will either be granted,
-   * refused if try-lock, or scheduled at end of waiting queue to eventually
-   * be granted or timed out.
+   * Handles the provided lock request. The lock will either be granted, refused if try-lock, or
+   * scheduled at end of waiting queue to eventually be granted or timed out.
-   * Acquires destroyReadLock. Synchronizes on grantTokens, suspendLock and
-   * the grant token.
+   * Acquires destroyReadLock. Synchronizes on grantTokens, suspendLock and the grant token.
-      
+
-    
+
-      }
-      else {
+      } else {
-          logger.trace(LogMarker.DLS, "[DLockGrantor.handleLockRequest] about to waitUntilDestroyed");
+          logger.trace(LogMarker.DLS,
+              "[DLockGrantor.handleLockRequest] about to waitUntilDestroyed");
-      }
-      else {
+      } else {
-    }
-    finally {
+    } finally {
-  /** 
+  /**
-   * Calling thread must hold destroyReadLock. Synchronizes on grantTokens, 
-   * suspendLock and the grant token.
+   * Calling thread must hold destroyReadLock. Synchronizes on grantTokens, suspendLock and the
+   * grant token.
-   * @param request the lock request to be processed by this grantor
-   * guarded.By {@link #acquireDestroyReadLock(long)}
+   * @param request the lock request to be processed by this grantor guarded.By
+   *        {@link #acquireDestroyReadLock(long)}
-      
+
-      
+
-    
+
-      
+
-    
+
-    }
-    finally {
+    } finally {
-  
-  /** 
-   * Initializes this new grantor with previously held locks as provided during
-   * grantor recovery. 
+
+  /**
+   * Initializes this new grantor with previously held locks as provided during grantor recovery.
-   * Acquires destroyReadLock. Synchronizes on this grantor, grantTokens, 
-   * suspendLock, the grant token.
-   *  
+   * Acquires destroyReadLock. Synchronizes on this grantor, grantTokens, suspendLock, the grant
+   * token.
+   * 
-  void initializeHeldLocks(InternalDistributedMember owner, Set tokens) 
+  void initializeHeldLocks(InternalDistributedMember owner, Set tokens)
-      if (isDestroyed()) return;
+      if (isDestroyed())
+        return;
-    
+
-        Set members = 
-            this.dlock.getDistributionManager().getDistributionManagerIds();
-        
+        Set members = this.dlock.getDistributionManager().getDistributionManagerIds();
+
-            
+
-                logger.trace(LogMarker.DLS, "Initialization of held locks is skipping {} because owner {} is not in view: ", token, owner, members);
+                logger.trace(LogMarker.DLS,
+                    "Initialization of held locks is skipping {} because owner {} is not in view: ",
+                    token, owner, members);
-              
+
-            
-            synchronized(grantToken) {
+
+            synchronized (grantToken) {
-                logger.error(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockGrantor_INITIALIZATION_OF_HELD_LOCKS_IS_SKIPPING_0_BECAUSE_LOCK_IS_ALREADY_HELD_1, new Object[] { token, grantToken }));
+                logger.error(LogMarker.DLS,
+                    LocalizedMessage.create(
+                        LocalizedStrings.DLockGrantor_INITIALIZATION_OF_HELD_LOCKS_IS_SKIPPING_0_BECAUSE_LOCK_IS_ALREADY_HELD_1,
+                        new Object[] {token, grantToken}));
-              
-              grantToken.grantLock(owner, 
-                                   token.getLeaseExpireTime(), 
-                                   token.getLeaseId(), 
-                                   token.getLesseeThread());
+
+              grantToken.grantLock(owner, token.getLeaseExpireTime(), token.getLeaseId(),
+                  token.getLesseeThread());
-              if (grantToken.getLeaseExpireTime() > -1 
+              if (grantToken.getLeaseExpireTime() > -1
-              
+
-            
+
-            synchronized(suspendLock) {
+            synchronized (suspendLock) {
-              }
-              else {
-                Assert.assertTrue(
-                    !isLockingSuspended() || isLockingSuspendedBy(rThread),
+              } else {
+                Assert.assertTrue(!isLockingSuspended() || isLockingSuspendedBy(rThread),
-            
-          }
-          finally {
+
+          } finally {
-            
+
-    }
-    finally {
+    } finally {
-  
-  /** 
+
+  /**
-   * @return new extended leaseExpireTime or 0 if requestor no longer holds lock 
+   * @return new extended leaseExpireTime or 0 if requestor no longer holds lock
-          logger.trace(LogMarker.DLS, "[DLockGrantor.reenterLock] no grantToken found for {}", request.getObjectName());
+          logger.trace(LogMarker.DLS, "[DLockGrantor.reenterLock] no grantToken found for {}",
+              request.getObjectName());
-    
+
-        if (!this.dm.isCurrentMember(request.getSender())
-            || grant.isDestroyed()) {
+        if (!this.dm.isCurrentMember(request.getSender()) || grant.isDestroyed()) {
-            logger.trace(LogMarker.DLS, "[DLockGrantor.reenterLock] grant is not locked by sender={} lockId={} grant={}", request.getSender(), request.getLockId(), grant);
+            logger.trace(LogMarker.DLS,
+                "[DLockGrantor.reenterLock] grant is not locked by sender={} lockId={} grant={}",
+                request.getSender(), request.getLockId(), grant);
-      
-        long leaseExpireTime = 
-            Math.max(grant.getLeaseExpireTime(),
-                     grant.calcLeaseExpireTime(request.getLeaseTime()));
-        
-        grant.grantLock(request.getSender(), 
-                        leaseExpireTime, 
-                        request.getLockId(), 
-                        grant.getRemoteThread());
-          
+
+        long leaseExpireTime =
+            Math.max(grant.getLeaseExpireTime(), grant.calcLeaseExpireTime(request.getLeaseTime()));
+
+        grant.grantLock(request.getSender(), leaseExpireTime, request.getLockId(),
+            grant.getRemoteThread());
+
-  
+
-   * Release named lock if held by owner using lockId. Called from 
-   * DLockReleaseMessage.basicProcess for remote unlock. 
+   * Release named lock if held by owner using lockId. Called from DLockReleaseMessage.basicProcess
+   * for remote unlock.
-  void releaseIfLocked(Object name, 
-                       InternalDistributedMember owner, 
-                       int lockId) throws InterruptedException {
+  void releaseIfLocked(Object name, InternalDistributedMember owner, int lockId)
+      throws InterruptedException {
-    }
-    finally {
+    } finally {
-    } 
+    }
-  
+
-   * Fetches the actual grant token and releases it if leased by owner using 
-   * lockId.
-   * DLockReleaseMessage.basicProcess -> releaseIfLocked -> 
-   *     getAndReleaseGrantIfLockedBy
+   * Fetches the actual grant token and releases it if leased by owner using lockId.
+   * DLockReleaseMessage.basicProcess -> releaseIfLocked -> getAndReleaseGrantIfLockedBy
-   * Caller must hold destroyReadLock. Synchronizes on grantTokens and the 
-   * grant token.
-   *     
+   * Caller must hold destroyReadLock. Synchronizes on grantTokens and the grant token.
+   * 
-   * @param lockId the id of the lease used by the owner
-   * guarded.By {@link #acquireDestroyReadLock(long)}
+   * @param lockId the id of the lease used by the owner guarded.By
+   *        {@link #acquireDestroyReadLock(long)}
-  private void getAndReleaseGrantIfLockedBy(Object name, 
-                                            InternalDistributedMember owner,
-                                            int lockId) {
+  private void getAndReleaseGrantIfLockedBy(Object name, InternalDistributedMember owner,
+      int lockId) {
-          //if (!grantToken.isTokenDestroyed())
+          // if (!grantToken.isTokenDestroyed())
-          }
-          catch (IllegalStateException e) {
+          } catch (IllegalStateException e) {
-  
+
-   * Fetches the grant token for named lock and attempts to grant it to the
-   * next waiting requestor if one exists. Called from DLockReleaseProcessor 
-   * when another process releases a lock and after the reply has been sent.
+   * Fetches the grant token for named lock and attempts to grant it to the next waiting requestor
+   * if one exists. Called from DLockReleaseProcessor when another process releases a lock and after
+   * the reply has been sent.
-    }
-    finally {
+    } finally {
-    } 
+    }
-   * Acquires destroyReadLock. Synchronizes on grantTokens, suspendLock, and
-   * the grant token.
+   * Acquires destroyReadLock. Synchronizes on grantTokens, suspendLock, and the grant token.
-  void handleDepartureOf(InternalDistributedMember owner) 
-      throws InterruptedException {
+  void handleDepartureOf(InternalDistributedMember owner) throws InterruptedException {
-    // connection/channel layer caused acquireDestroyReadLock to fail... 
+    // connection/channel layer caused acquireDestroyReadLock to fail...
-            logger.trace(LogMarker.DLS, "[DLockGrantor.handleDepartureOf] grantor is destroyed; ignoring {}", owner);
+            logger.trace(LogMarker.DLS,
+                "[DLockGrantor.handleDepartureOf] grantor is destroyed; ignoring {}", owner);
-          DLockLessorDepartureHandler handler = 
-              this.dlock.getDLockLessorDepartureHandler();
+          DLockLessorDepartureHandler handler = this.dlock.getDLockLessorDepartureHandler();
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-            logger.trace(LogMarker.DLS, "[DlockGrantor.handleDepartureOf] ignored cancellation (1)");
+            logger.trace(LogMarker.DLS,
+                "[DlockGrantor.handleDepartureOf] ignored cancellation (1)");
-        }
-        finally {
+        } finally {
-            for (Iterator it=readLockCountMap.entrySet().iterator(); it.hasNext(); ) {
-              Map.Entry entry = (Map.Entry)it.next();
-              RemoteThread rThread = (RemoteThread)entry.getKey();
+            for (Iterator it = readLockCountMap.entrySet().iterator(); it.hasNext();) {
+              Map.Entry entry = (Map.Entry) it.next();
+              RemoteThread rThread = (RemoteThread) entry.getKey();
-            for (Iterator it=removals.iterator(); it.hasNext(); ) {
+            for (Iterator it = removals.iterator(); it.hasNext();) {
-                postReleaseLock((RemoteThread)it.next(), null);
-              }
-              catch (CancelException e) {
+                postReleaseLock((RemoteThread) it.next(), null);
+              } catch (CancelException e) {
-                  logger.trace(LogMarker.DLS, "[DlockGrantor.handleDepartureOf] ignored cancellation (2)");
+                  logger.trace(LogMarker.DLS,
+                      "[DlockGrantor.handleDepartureOf] ignored cancellation (2)");
-            //   changes fix bug 39172 (ConcurrentModificationException)
-            
+            // changes fix bug 39172 (ConcurrentModificationException)
+
-              }
-              catch (CancelException e) {
+              } catch (CancelException e) {
-                  logger.trace(LogMarker.DLS, "[DlockGrantor.handleDepartureOf] ignored cancellation (3)");
+                  logger.trace(LogMarker.DLS,
+                      "[DlockGrantor.handleDepartureOf] ignored cancellation (3)");
-            
+
-            for (Iterator iter = grantsReferencingMember.iterator(); 
-                 iter.hasNext();) {
+            for (Iterator iter = grantsReferencingMember.iterator(); iter.hasNext();) {
-              }
-              catch (CancelException e) {
+              } catch (CancelException e) {
-                  logger.trace(LogMarker.DLS, "[DlockGrantor.handleDepartureOf] ignored cancellation (4)");
+                  logger.trace(LogMarker.DLS,
+                      "[DlockGrantor.handleDepartureOf] ignored cancellation (4)");
-            
+
-            for (Iterator iter = grantsToRemoveIfUnused.iterator(); 
-                 iter.hasNext();) {
+            for (Iterator iter = grantsToRemoveIfUnused.iterator(); iter.hasNext();) {
-              }
-              catch (CancelException e) {
+              } catch (CancelException e) {
-                  logger.trace(LogMarker.DLS, "[DlockGrantor.handleDepartureOf] ignored cancellation (5)");
+                  logger.trace(LogMarker.DLS,
+                      "[DlockGrantor.handleDepartureOf] ignored cancellation (5)");
-      }
-      finally {
+      } finally {
-   * Destroys this grantor without attempting to transfer grant tokens to
-   * a successor.
+   * Destroys this grantor without attempting to transfer grant tokens to a successor.
-   * Acquires destroyWriteLock. Synchronizes on this grantor, grantTokens, 
-   * and each grant token.
+   * Acquires destroyWriteLock. Synchronizes on this grantor, grantTokens, and each grant token.
-      if (isDestroyed()) return;
+      if (isDestroyed())
+        return;
-          
+
-          }
-          else {
+          } else {
-            logger.trace(LogMarker.DLS, "[simpleDestroy] {} locks held", (locksHeld ? "with" : "without"));
+            logger.trace(LogMarker.DLS, "[simpleDestroy] {} locks held",
+                (locksHeld ? "with" : "without"));
-        }
-        finally {
+        } finally {
-          
+
-          }
-          finally {
+          } finally {
-      }
-      finally {
+      } finally {
-  
+
-   * Send replies to all waiting requestors to notify them that this is no
-   * longer the grantor.
+   * Send replies to all waiting requestors to notify them that this is no longer the grantor.
-   * Caller must acquire destroyWriteLock. Synchronizes on suspendLock,
-   * grantTokens, and each grant token.
+   * Caller must acquire destroyWriteLock. Synchronizes on suspendLock, grantTokens, and each grant
+   * token.
-    Assert.assertHoldsLock(this,true);
+    Assert.assertHoldsLock(this, true);
-//        catch (VirtualMachineError err) {
-//          SystemFailure.initiateFailure(err);
-//          // If this ever returns, rethrow the error.  We're poisoned
-//          // now, so don't let this thread continue.
-//          throw err;
-//        }
-//        catch (Throwable t) {
-//          // Whenever you catch Error or Throwable, you must also
-//          // catch VirtualMachineError (see above).  However, there is
-//          // _still_ a possibility that you are dealing with a cascading
-//          // error condition, so you also need to check to see if the JVM
-//          // is still usable:
-//          SystemFailure.checkFailure();
-//        }
+        // catch (VirtualMachineError err) {
+        // SystemFailure.initiateFailure(err);
+        // // If this ever returns, rethrow the error. We're poisoned
+        // // now, so don't let this thread continue.
+        // throw err;
+        // }
+        // catch (Throwable t) {
+        // // Whenever you catch Error or Throwable, you must also
+        // // catch VirtualMachineError (see above). However, there is
+        // // _still_ a possibility that you are dealing with a cascading
+        // // error condition, so you also need to check to see if the JVM
+        // // is still usable:
+        // SystemFailure.checkFailure();
+        // }
-          
+
-    
-    synchronized(suspendLock) {
+
+    synchronized (suspendLock) {
-        logger.trace(LogMarker.DLS, "[DLockGrantor.destroyAndRemove] responding to {} permitted requests.", permittedRequests.size());
+        logger.trace(LogMarker.DLS,
+            "[DLockGrantor.destroyAndRemove] responding to {} permitted requests.",
+            permittedRequests.size());
-        logger.trace(LogMarker.DLS, "[DLockGrantor.destroyAndRemove] responding to {} requests awaiting permission.", suspendQueue.size());
+        logger.trace(LogMarker.DLS,
+            "[DLockGrantor.destroyAndRemove] responding to {} requests awaiting permission.",
+            suspendQueue.size());
-          logger.trace(LogMarker.DLS, "[DLockGrantor.destroyAndRemove] responding to {} drained permitted requests.", drain.size());
+          logger.trace(LogMarker.DLS,
+              "[DLockGrantor.destroyAndRemove] responding to {} drained permitted requests.",
+              drain.size());
-  
+
-   * Send responses to specified requests informing the senders that this
-   * is no longer the grantor.
+   * Send responses to specified requests informing the senders that this is no longer the grantor.
-   * @param requests the requests to respond to
-   * guarded.By {@link #acquireDestroyWriteLock(long)}
+   * @param requests the requests to respond to guarded.By {@link #acquireDestroyWriteLock(long)}
-//      catch (VirtualMachineError err) {
-//        SystemFailure.initiateFailure(err);
-//        // If this ever returns, rethrow the error.  We're poisoned
-//        // now, so don't let this thread continue.
-//        throw err;
-//      }
-//      catch (Throwable t) {
-//        // Whenever you catch Error or Throwable, you must also
-//        // catch VirtualMachineError (see above).  However, there is
-//        // _still_ a possibility that you are dealing with a cascading
-//        // error condition, so you also need to check to see if the JVM
-//        // is still usable:
-//        SystemFailure.checkFailure();
-//      }
+      // catch (VirtualMachineError err) {
+      // SystemFailure.initiateFailure(err);
+      // // If this ever returns, rethrow the error. We're poisoned
+      // // now, so don't let this thread continue.
+      // throw err;
+      // }
+      // catch (Throwable t) {
+      // // Whenever you catch Error or Throwable, you must also
+      // // catch VirtualMachineError (see above). However, there is
+      // // _still_ a possibility that you are dealing with a cascading
+      // // error condition, so you also need to check to see if the JVM
+      // // is still usable:
+      // SystemFailure.checkFailure();
+      // }
-        
+
-  
+
-    logger.info(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.TESTING,
-        "[DLockGrantor.debug] svc=" + this.dlock.getName() +
-        "; state=" + this.state + 
-        "; initLatch.ct=" + this.whileInitializing.getCount()));
+    logger.info(LogMarker.DLS,
+        LocalizedMessage.create(LocalizedStrings.TESTING,
+            "[DLockGrantor.debug] svc=" + this.dlock.getName() + "; state=" + this.state
+                + "; initLatch.ct=" + this.whileInitializing.getCount()));
-  
+
-      StringBuffer sb = new StringBuffer(
-          "DLockGrantor " + this.dlock.getName() + " initialized with:");
+      StringBuffer sb =
+          new StringBuffer("DLockGrantor " + this.dlock.getName() + " initialized with:");
-  //   Private methods
+  // Private methods
-  
+
-   * Acquires destroyReadLock. Synchronizes on suspendLock, grantTokens,
-   * and the grant token.
+   * Acquires destroyReadLock. Synchronizes on suspendLock, grantTokens, and the grant token.
-    }
-    catch (LockServiceDestroyedException e) {
+    } catch (LockServiceDestroyedException e) {
-    }
-    catch (LockGrantorDestroyedException e) {
+    } catch (LockGrantorDestroyedException e) {
-    }
-    finally {
+    } finally {
-    } 
+    }
-  
+
-   * Acquires a read lock on the destroy ReadWrite lock uninterruptibly using 
-   * millis for try-lock attempt.
+   * Acquires a read lock on the destroy ReadWrite lock uninterruptibly using millis for try-lock
+   * attempt.
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-  
+
-   * Acquires the write lock on the destroy ReadWrite lock within specified
-   * millis.
+   * Acquires the write lock on the destroy ReadWrite lock within specified millis.
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-  
-  /** 
+
+  /**
-   */  
+   */
-      long now = DLockService.getLockTimeStamp(
-        this.dlock.getDistributionManager());
+      long now = DLockService.getLockTimeStamp(this.dlock.getDistributionManager());
-  
+
-      this.dlock.getDistributionManager()
-        .removeMembershipListener(this.membershipListener);
-    }
-    finally {
+      this.dlock.getDistributionManager().removeMembershipListener(this.membershipListener);
+    } finally {
-  
+
-  
+
-      }
-      else {
+      } else {
-          }
-          else {
+          } else {
-   * TEST HOOK: Returns an unmodifible collection backed by the values of the 
-   * DLockGrantToken map for testing purposes only.
+   * TEST HOOK: Returns an unmodifible collection backed by the values of the DLockGrantToken map
+   * for testing purposes only.
-  
+
-   * Remove the grant token if it is unused. 
+   * Remove the grant token if it is unused.
-        }
-        else if (grant.grantLockToNextRequest()) {
+        } else if (grant.grantLockToNextRequest()) {
-        }
-        else if (!grant.isBeingAccessed() &&
-                 !grant.isGranted(false) && 
-                 !grant.hasWaitingRequests()) {
+        } else if (!grant.isBeingAccessed() && !grant.isGranted(false)
+            && !grant.hasWaitingRequests()) {
-  
+
-  
+
-   * Returns the DLockGrantToken from grant tokens map stored under the key 
-   * name.
+   * Returns the DLockGrantToken from grant tokens map stored under the key name.
-  
+
-   * @return the grant token stored under key name
-   * guarded.By {@link #grantTokens}
+   * @return the grant token stored under key name guarded.By {@link #grantTokens}
-  
+
-   * @param grantToken the grant token to store in the map
-   * guarded.By {@link #grantTokens}
+   * @param grantToken the grant token to store in the map guarded.By {@link #grantTokens}
-   * Removes the grant token from the map. 
+   * Removes the grant token from the map.
-   * @param grantToken the grant token to remove from the map.
-   * guarded.By {@link #grantTokens} and grantToken
+   * @param grantToken the grant token to remove from the map. guarded.By {@link #grantTokens} and
+   *        grantToken
-        logger.trace(LogMarker.DLS, "[DLockGrantor.basicRemoveGrantToken] removed {}; removed={}",  grantToken, removed);
+        logger.trace(LogMarker.DLS, "[DLockGrantor.basicRemoveGrantToken] removed {}; removed={}",
+            grantToken, removed);
-  
+
-        continue;    
+        continue;
-  
+
-   * TEST HOOK: Specifies time to sleep while handling suspend in order to
-   * cause a timeout.
+   * TEST HOOK: Specifies time to sleep while handling suspend in order to cause a timeout.
-  
+
-  
+
-   * Iterates through a copy of suspendQueue and handles any requests that
-   * have timed out.
+   * Iterates through a copy of suspendQueue and handles any requests that have timed out.
-      if (suspendQueue.isEmpty()) return smallestTimeout;
-      if (isDestroyed()) return smallestTimeout;
+      if (suspendQueue.isEmpty())
+        return smallestTimeout;
+      if (isDestroyed())
+        return smallestTimeout;
-      
+
-      }
-      else {
+      } else {
-        logger.info(LogMarker.DLS, LocalizedMessage.create(
-            LocalizedStrings.DLockGrantor_DEBUGHANDLESUSPENDTIMEOUTS_SLEEPING_FOR__0, localDebugHandleSuspendTimeouts));
+        logger.info(LogMarker.DLS,
+            LocalizedMessage.create(
+                LocalizedStrings.DLockGrantor_DEBUGHANDLESUSPENDTIMEOUTS_SLEEPING_FOR__0,
+                localDebugHandleSuspendTimeouts));
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-    
+
-          
+
-        }
-        else {
+        } else {
-            "Grantor state writeLockWaiters changed while holding suspendLock");
+              "Grantor state writeLockWaiters changed while holding suspendLock");
-      checkWriteLockWaiters();
+        checkWriteLockWaiters();
-  
+
-      case INITIALIZING:  stateDesc = "INITIALIZING"; break;
-      case READY:         stateDesc = "READY"; break;
-      case DESTROYED:     stateDesc = "DESTROYED"; break;
-      default:            stateDesc = null; break;
+      case INITIALIZING:
+        stateDesc = "INITIALIZING";
+        break;
+      case READY:
+        stateDesc = "READY";
+        break;
+      case DESTROYED:
+        stateDesc = "DESTROYED";
+        break;
+      default:
+        stateDesc = null;
+        break;
-      throw new IllegalArgumentException(LocalizedStrings.DLockGrantor_UNKNOWN_STATE_FOR_GRANTOR_0.toLocalizedString(Integer.valueOf(state)));
+      throw new IllegalArgumentException(LocalizedStrings.DLockGrantor_UNKNOWN_STATE_FOR_GRANTOR_0
+          .toLocalizedString(Integer.valueOf(state)));
-  
+
-      throw new IllegalStateException(LocalizedStrings.DLockGrantor_DLOCKGRANTOR_OPERATION_ONLY_ALLOWED_WHEN_INITIALIZING_NOT_0.toLocalizedString(stateDesc));
+      throw new IllegalStateException(
+          LocalizedStrings.DLockGrantor_DLOCKGRANTOR_OPERATION_ONLY_ALLOWED_WHEN_INITIALIZING_NOT_0
+              .toLocalizedString(stateDesc));
-  
-  /** 
-   * Suspends locking by the remote thread and lease id. 
+
+  /**
+   * Suspends locking by the remote thread and lease id.
-      Assert.assertHoldsLock(this.suspendLock,true);
+      Assert.assertHoldsLock(this.suspendLock, true);
-      logger.trace(LogMarker.DLS, "Suspend locking of {} by {} with lockId of {}", this.dlock, myRThread, lockId);
+      logger.trace(LogMarker.DLS, "Suspend locking of {} by {} with lockId of {}", this.dlock,
+          myRThread, lockId);
-    Assert.assertTrue(myRThread != null,
-        "Attempted to suspend locking for null RemoteThread");
-    Assert.assertTrue(this.lockingSuspendedBy == null || 
-        this.lockingSuspendedBy.equals(myRThread),
-        "Attempted to suspend locking for " + myRThread + 
-        " but locking is already suspended by " + this.lockingSuspendedBy); // KIRK: assert fails in bug 37945
+    Assert.assertTrue(myRThread != null, "Attempted to suspend locking for null RemoteThread");
+    Assert.assertTrue(this.lockingSuspendedBy == null || this.lockingSuspendedBy.equals(myRThread),
+        "Attempted to suspend locking for " + myRThread + " but locking is already suspended by "
+            + this.lockingSuspendedBy); // KIRK: assert fails in bug 37945
-  
-  /** 
-   * Resume locking after it has been suspended. 
+
+  /**
+   * Resume locking after it has been suspended.
-   */ 
+   */
-      Assert.assertHoldsLock(this.suspendLock,true);
+      Assert.assertHoldsLock(this.suspendLock, true);
-  
-  /** 
-   * Returns true if locking has been suspended. 
+
+  /**
+   * Returns true if locking has been suspended.
-      Assert.assertHoldsLock(this.suspendLock,true);
+      Assert.assertHoldsLock(this.suspendLock, true);
-  
-  /** 
-   * Returns true if locking has been suspended. 
+
+  /**
+   * Returns true if locking has been suspended.
-  
-  /** 
-   * Returns true if locking has been suspended by the remote thread. 
+
+  /**
+   * Returns true if locking has been suspended by the remote thread.
-      Assert.assertHoldsLock(this.suspendLock,true);
+      Assert.assertHoldsLock(this.suspendLock, true);
-    if (rThread == null) return false;
+    if (rThread == null)
+      return false;
-  
+
-      sb.append(" permittedRequests (" + permittedRequests.size() + ")=" 
+      sb.append(" permittedRequests (" + permittedRequests.size() + ")="
-      sb.append("\nsuspendQueue (" + suspendQueue.size() + ")=" 
-          + suspendQueue.toString());
+      sb.append("\nsuspendQueue (" + suspendQueue.size() + ")=" + suspendQueue.toString());
-                + ")" /* + "=" + readLockCountMap.toString()*/);
+          + ")" /* + "=" + readLockCountMap.toString() */);
-  
+
-        logger.trace(LogMarker.DLS, "[postReleaseSuspendLock] locking is no longer suspended by {}", rThread);
+        logger.trace(LogMarker.DLS, "[postReleaseSuspendLock] locking is no longer suspended by {}",
+            rThread);
-      final DLockRequestMessage nextRequest = 
-	  (DLockRequestMessage) suspendQueue.getFirst();
+      final DLockRequestMessage nextRequest = (DLockRequestMessage) suspendQueue.getFirst();
-	resume = false;
-	//final RemoteThread myRemoteThread = nextRequest.getRemoteThread();
-	// hand-off suspendLocking while under sync...
-	resumeLocking();
-	suspendLocking(nextRequest.getRemoteThread(), nextRequest.getLockId());
-	permittedRequests.add(suspendQueue.removeFirst());
-	writeLockWaiters--;
-	checkWriteLockWaiters();
+        resume = false;
+        // final RemoteThread myRemoteThread = nextRequest.getRemoteThread();
+        // hand-off suspendLocking while under sync...
+        resumeLocking();
+        suspendLocking(nextRequest.getRemoteThread(), nextRequest.getLockId());
+        permittedRequests.add(suspendQueue.removeFirst());
+        writeLockWaiters--;
+        checkWriteLockWaiters();
-	final DLockRequestMessage nextRequest = 
-	    (DLockRequestMessage) suspendQueue.getFirst();
-	if (nextRequest.isSuspendLockingRequest()) {
-	  Assert.assertTrue(writeLockWaiters > 0,
-	    "SuspendLocking request is waiting but writeLockWaiters is 0");
-	  break;
-	}
-	RemoteThread nextRThread = nextRequest.getRemoteThread();
-	integer =(Integer)  readLockCountMap.get(nextRThread);
-	readLockCount = integer == null ? 0 : integer.intValue();
-	readLockCount++;
-	readLockCountMap.put(nextRThread, Integer.valueOf(readLockCount));
-	totalReadLockCount++;
-	checkTotalReadLockCount();
-	permittedRequests.add(suspendQueue.removeFirst());
+        final DLockRequestMessage nextRequest = (DLockRequestMessage) suspendQueue.getFirst();
+        if (nextRequest.isSuspendLockingRequest()) {
+          Assert.assertTrue(writeLockWaiters > 0,
+              "SuspendLocking request is waiting but writeLockWaiters is 0");
+          break;
+        }
+        RemoteThread nextRThread = nextRequest.getRemoteThread();
+        integer = (Integer) readLockCountMap.get(nextRThread);
+        readLockCount = integer == null ? 0 : integer.intValue();
+        readLockCount++;
+        readLockCountMap.put(nextRThread, Integer.valueOf(readLockCount));
+        totalReadLockCount++;
+        checkTotalReadLockCount();
+        permittedRequests.add(suspendQueue.removeFirst());
-      logger.trace(LogMarker.DLS, "[postReleaseSuspendLock] new status {}", displayStatus(rThread, null));
+      logger.trace(LogMarker.DLS, "[postReleaseSuspendLock] new status {}",
+          displayStatus(rThread, null));
-    
+
-    //boolean permitSuspend = false;
+    // boolean permitSuspend = false;
-    //Assert.assertTrue(readLockCount > 0, rThread + " not found in " + readLockCountMap); // KIRK
+    // Assert.assertTrue(readLockCount > 0, rThread + " not found in " + readLockCountMap); // KIRK
-        logger.trace(LogMarker.DLS, "[postReleaseReadLock] no locks are currently held by {}", rThread);
+        logger.trace(LogMarker.DLS, "[postReleaseReadLock] no locks are currently held by {}",
+            rThread);
-    }
-    else {
+    } else {
-        logger.trace(LogMarker.DLS, "Total readlock count has dropped to {} for {}", totalReadLockCount, this);
+        logger.trace(LogMarker.DLS, "Total readlock count has dropped to {} for {}",
+            totalReadLockCount, this);
-      final DLockRequestMessage nextRequest = 
-	  (DLockRequestMessage) suspendQueue.getFirst();
+      final DLockRequestMessage nextRequest = (DLockRequestMessage) suspendQueue.getFirst();
-	suspendLocking(nextRequest.getRemoteThread(), nextRequest.getLockId());
-	writeLockWaiters--;
-	permittedRequests.add(suspendQueue.removeFirst());
-	checkWriteLockWaiters();
-      }
-      else {
+        suspendLocking(nextRequest.getRemoteThread(), nextRequest.getLockId());
+        writeLockWaiters--;
+        permittedRequests.add(suspendQueue.removeFirst());
+        checkWriteLockWaiters();
+      } else {
-                  .append(", totalReadLockCount=").append(totalReadLockCount)
-                  .append(", writeLockWaiters=").append(writeLockWaiters)
-                  .append(",\nsuspendQueue=").append(suspendQueue)
-                  .append(",\npermittedRequests=").append(permittedRequests).toString();
-        logger.warn(LocalizedMessage.create(LocalizedStrings.DLockGrantor_RELEASED_REGULAR_LOCK_WITH_WAITING_READ_LOCK_0, s));
-	Assert.assertTrue(false, LocalizedStrings.DLockGrantor_RELEASED_REGULAR_LOCK_WITH_WAITING_READ_LOCK_0.toString(s));
+            .append(", totalReadLockCount=").append(totalReadLockCount)
+            .append(", writeLockWaiters=").append(writeLockWaiters).append(",\nsuspendQueue=")
+            .append(suspendQueue).append(",\npermittedRequests=").append(permittedRequests)
+            .toString();
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.DLockGrantor_RELEASED_REGULAR_LOCK_WITH_WAITING_READ_LOCK_0, s));
+        Assert.assertTrue(false,
+            LocalizedStrings.DLockGrantor_RELEASED_REGULAR_LOCK_WITH_WAITING_READ_LOCK_0
+                .toString(s));
-      logger.trace(LogMarker.DLS, "[postReleaseReadLock] new status {}", displayStatus(rThread, null));
+      logger.trace(LogMarker.DLS, "[postReleaseReadLock] new status {}",
+          displayStatus(rThread, null));
-   * Handles post release lock tasks including tracking the current suspend
-   * locking states.
+   * Handles post release lock tasks including tracking the current suspend locking states.
-    synchronized(suspendLock) {
+    synchronized (suspendLock) {
-      if (logger.isTraceEnabled(LogMarker.DLS)){ 
-        logger.trace(LogMarker.DLS, "[postReleaseLock] rThread={} lock={} permittedRequests={} suspendQueue={}", rThread, lock, permittedRequests, suspendQueue);
+      if (logger.isTraceEnabled(LogMarker.DLS)) {
+        logger.trace(LogMarker.DLS,
+            "[postReleaseLock] rThread={} lock={} permittedRequests={} suspendQueue={}", rThread,
+            lock, permittedRequests, suspendQueue);
-      }
-      else {
+      } else {
-  
+
-   * Departure or other codepath NOT specific to unlock requires that we
-   * cleanup suspend state that was already permitted to request. This needs
-   * to be invoked for both regular and suspend locks.
+   * Departure or other codepath NOT specific to unlock requires that we cleanup suspend state that
+   * was already permitted to request. This needs to be invoked for both regular and suspend locks.
-  
-  /** 
-   * Drains newly permitted requests that have been removed from suspendQueue.
-   * All requests in the permittedRequests queue already have permission to proceed
-   * with granting or scheduling.
+
+  /**
+   * Drains newly permitted requests that have been removed from suspendQueue. All requests in the
+   * permittedRequests queue already have permission to proceed with granting or scheduling.
-   * Caller must acquire destroyReadLock. Synchronizes on suspendLock,
-   * grantTokens and each grant token.
+   * Caller must acquire destroyReadLock. Synchronizes on suspendLock, grantTokens and each grant
+   * token.
-   * Concurrency: protected by {@link #destroyLock} via invoking {@link #acquireDestroyReadLock(long)}
+   * Concurrency: protected by {@link #destroyLock} via invoking
+   * {@link #acquireDestroyReadLock(long)}
-    synchronized(suspendLock) {
+    synchronized (suspendLock) {
-    
+
-    
+
-      }
-      catch (LockGrantorDestroyedException e) {
+      } catch (LockGrantorDestroyedException e) {
-            logger.trace(LogMarker.DLS, "LockGrantorDestroyedException respondWithNotGrantor to {}", request);
+            logger.trace(LogMarker.DLS, "LockGrantorDestroyedException respondWithNotGrantor to {}",
+                request);
+        } finally {
+
-        finally {
-          
-        }
-      }
-      catch (LockServiceDestroyedException e) {
+      } catch (LockServiceDestroyedException e) {
-            logger.trace(LogMarker.DLS, "LockServiceDestroyedException respondWithNotGrantor to {}", request);
+            logger.trace(LogMarker.DLS, "LockServiceDestroyedException respondWithNotGrantor to {}",
+                request);
+        } finally {
+
-        finally {
-          
-        }
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-            LocalizedStrings.DLockGrantor_PROCESSING_OF_POSTREMOTERELEASELOCK_THREW_UNEXPECTED_RUNTIMEEXCEPTION, e));
+            LocalizedStrings.DLockGrantor_PROCESSING_OF_POSTREMOTERELEASELOCK_THREW_UNEXPECTED_RUNTIMEEXCEPTION,
+            e));
-      }
-      finally {
-        
+      } finally {
+
-    
-    synchronized(suspendLock) {
+
+    synchronized (suspendLock) {
-  
+
-    synchronized(suspendLock) {
+    synchronized (suspendLock) {
-        logger.info(LogMarker.DLS, LocalizedMessage.create(
-            LocalizedStrings.DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0, request));
+        logger.info(LogMarker.DLS, LocalizedMessage
+            .create(LocalizedStrings.DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0, request));
-          logger.trace(LogMarker.DLS, "[DLockGrantor.acquireSuspend] added '{}' to end of suspendQueue.", request);
+          logger.trace(LogMarker.DLS,
+              "[DLockGrantor.acquireSuspend] added '{}' to end of suspendQueue.", request);
-      }
-      else {
+      } else {
-          logger.trace(LogMarker.DLS, "[DLockGrantor.acquireSuspendLockPermission] permitted and suspended for {}", request);
+          logger.trace(LogMarker.DLS,
+              "[DLockGrantor.acquireSuspendLockPermission] permitted and suspended for {}",
+              request);
-        logger.trace(LogMarker.DLS, "[DLockGrantor.acquireSuspendLockPermission] new status  permitLockRequest = {}{}", permitLockRequest, displayStatus(rThread, null));
+        logger.trace(LogMarker.DLS,
+            "[DLockGrantor.acquireSuspendLockPermission] new status  permitLockRequest = {}{}",
+            permitLockRequest, displayStatus(rThread, null));
-    synchronized(suspendLock) {
+    synchronized (suspendLock) {
-        logger.info(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0, request));
+        logger.info(LogMarker.DLS, LocalizedMessage
+            .create(LocalizedStrings.DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0, request));
-      boolean threadHoldsLock = 
-	  readLockCount > 0 || isLockingSuspendedBy(rThread);
+      boolean threadHoldsLock = readLockCount > 0 || isLockingSuspendedBy(rThread);
-      if (!threadHoldsLock &&
-         (isLockingSuspended() || writeLockWaiters > 0)) {
+      if (!threadHoldsLock && (isLockingSuspended() || writeLockWaiters > 0)) {
-          logger.trace(LogMarker.DLS, "[DLockGrantor.acquireReadLockPermission] added {} to end of suspendQueue.", request);
+          logger.trace(LogMarker.DLS,
+              "[DLockGrantor.acquireReadLockPermission] added {} to end of suspendQueue.", request);
-      }
-      else {
+      } else {
-          logger.trace(LogMarker.DLS, "[DLockGrantor.acquireReadLockPermission] permitted {}", request);
+          logger.trace(LogMarker.DLS, "[DLockGrantor.acquireReadLockPermission] permitted {}",
+              request);
-        logger.trace(LogMarker.DLS, "[DLockGrantor.acquireReadLockPermission] new status  threadHoldsLock = {} permitLockRequest = {}{}", threadHoldsLock, permitLockRequest, displayStatus(rThread, null));
+        logger.trace(LogMarker.DLS,
+            "[DLockGrantor.acquireReadLockPermission] new status  threadHoldsLock = {} permitLockRequest = {}{}",
+            threadHoldsLock, permitLockRequest, displayStatus(rThread, null));
-  /** 
-   * Returns true if lock request has permission to proceed; else adds the
-   * request to the end of suspendQueue and returns false.
+  /**
+   * Returns true if lock request has permission to proceed; else adds the request to the end of
+   * suspendQueue and returns false.
-    
+
-    }
-    else {
+    } else {
-    
+
-  /** 
-   * Throws InterruptedException if local lock request exists and is 
-   * interruptible or CancelException if DistributionManager is forcing us to cancel
-   * for shutdown.
+  /**
+   * Throws InterruptedException if local lock request exists and is interruptible or
+   * CancelException if DistributionManager is forcing us to cancel for shutdown.
-    
+
-  
+
-   * TEST HOOK: Logs all grant tokens and other lock information for this 
-   * service at INFO level. 
+   * TEST HOOK: Logs all grant tokens and other lock information for this service at INFO level.
-        Map.Entry entry = (Map.Entry)iter.next();
+        Map.Entry entry = (Map.Entry) iter.next();
-        DLockGrantToken token = (DLockGrantToken)entry.getValue();
+        DLockGrantToken token = (DLockGrantToken) entry.getValue();
-      logger.info(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.TESTING, "\nreadLockCountMap:\n" + readLockCountMap));
+      logger.info(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.TESTING,
+          "\nreadLockCountMap:\n" + readLockCountMap));
-  
+
-    Assert.assertHoldsLock(this.suspendLock,true);
+    Assert.assertHoldsLock(this.suspendLock, true);
-      DLockRequestMessage r = (DLockRequestMessage)it.next();
+      DLockRequestMessage r = (DLockRequestMessage) it.next();
-        result ++;
+        result++;
-  
+
-    Assert.assertHoldsLock(this.suspendLock,true);
+    Assert.assertHoldsLock(this.suspendLock, true);
-      result += ((Integer)it.next()).intValue();
-    } 
+      result += ((Integer) it.next()).intValue();
+    }
-  
+
-  //   DLockGrantToken (static inner class)
+  // DLockGrantToken (static inner class)
-    
+
-    
+
-    
-    /** 
+
+    /**
-    
-    /** 
+
+    /**
-    
-    /** 
-     * The reply processor id is used to identify the specific lock operation
-     * used by the lessee to lease this lock 
+
+    /**
+     * The reply processor id is used to identify the specific lock operation used by the lessee to
+     * lease this lock
-    
-    /** 
+
+    /**
-     * Absolute time in milliseconds when the current lease will expire.
-     * When this lock is not leased out, the value is -1. When the lock is
-     * leased out, the value is > 0. A value of Long.MAX_VALUE indicates a
-     * non-expiring (infinite) lease.
+     * Absolute time in milliseconds when the current lease will expire. When this lock is not
+     * leased out, the value is -1. When the lock is leased out, the value is > 0. A value of
+     * Long.MAX_VALUE indicates a non-expiring (infinite) lease.
-    
-    /** 
+
+    /**
-    
-    /** 
+
+    /**
-    
-    /** 
+
+    /**
-    
+
-    protected DLockGrantToken(DLockService dlock,
-                              DLockGrantor grantor,
-                              Object name) {
+    protected DLockGrantToken(DLockService dlock, DLockGrantor grantor, Object name) {
-     * Schedules the lock request for immediate or later granting of lock.
-     * This will grant the lock if it is available, otherwise it will add
-     * the request at the end of the pending requests queue. 
+     * Schedules the lock request for immediate or later granting of lock. This will grant the lock
+     * if it is available, otherwise it will add the request at the end of the pending requests
+     * queue.
-      
+
-    
+
-     * Sends NOT_GRANTOR replies to every request waiting for this grant token
-     * and then destroys the grant token.
+     * Sends NOT_GRANTOR replies to every request waiting for this grant token and then destroys the
+     * grant token.
-      }
-      finally {
+      } finally {
-    
+
-     * Checks current lock for expiration and attempts to grant the lock if
-     * it is available.
+     * Checks current lock for expiration and attempts to grant the lock if it is available.
-     * NOTE: expiration is only as accurate as clock synchronization on the
-     *       hardware that the members are running on
-     * probably should have Requestors handle expirations and send Release msg
-     * - need an Evictor thread in each Requestor
+     * NOTE: expiration is only as accurate as clock synchronization on the hardware that the
+     * members are running on probably should have Requestors handle expirations and send Release
+     * msg - need an Evictor thread in each Requestor
-     * @return the lease expiration time in millis for the currently held lock
-     * or Long.MAX_VALUE if lock has no owner
+     * @return the lease expiration time in millis for the currently held lock or Long.MAX_VALUE if
+     *         lock has no owner
-      if (this.grantor.isDestroyed()) return Long.MAX_VALUE;
+      if (this.grantor.isDestroyed())
+        return Long.MAX_VALUE;
-      if (result <=0) {
+      if (result <= 0) {
-    
+
-     * Returns true if there are pending requests waiting to lock this grant
-     * token. 
+     * Returns true if there are pending requests waiting to lock this grant token.
-      if (this.pendingRequests == null) return false;
+      if (this.pendingRequests == null)
+        return false;
-    
+
-     * Grant this lock to the request if possible. Returns true if lock was
-     * granted to the request.
+     * Grant this lock to the request if possible. Returns true if lock was granted to the request.
-    protected synchronized boolean grantLockToRequest(
-                           DLockRequestMessage request) {
-      Assert.assertTrue(request.getRemoteThread() != null); // KIRK search for these assertions and remove
+    protected synchronized boolean grantLockToRequest(DLockRequestMessage request) {
+      Assert.assertTrue(request.getRemoteThread() != null); // KIRK search for these assertions and
+                                                            // remove
-      
+
-      
+
-      if (newLeaseExpireTime == -1) return false;
+      if (newLeaseExpireTime == -1)
+        return false;
-        long now = DLockService.getLockTimeStamp(
-            this.grantor.dm);
+        long now = DLockService.getLockTimeStamp(this.grantor.dm);
-      
+
-    }      
-    
+    }
+
-     * Called to release a remote lock when processing a DLockReleaseMessage. 
+     * Called to release a remote lock when processing a DLockReleaseMessage.
-     * Call stack: DLockReleaseMessage -> releaseIfLocked -> 
-     *             getAndReleaseGrantIfLockedBy -> grant.releaseIfLockedBy
-     *             
+     * Call stack: DLockReleaseMessage -> releaseIfLocked -> getAndReleaseGrantIfLockedBy ->
+     * grant.releaseIfLockedBy
+     * 
-    protected void releaseIfLockedBy(InternalDistributedMember owner, 
-                                     int lockId) {
+    protected void releaseIfLockedBy(InternalDistributedMember owner, int lockId) {
-      }
-      catch (IllegalStateException e) {
+      } catch (IllegalStateException e) {
-            logger.trace(LogMarker.DLS, "[DLockGrantToken.releaseIfLockedBy] pending requests: {}", 
-                (this.pendingRequests == null ? "none" : ""+this.pendingRequests.size()));
+            logger.trace(LogMarker.DLS, "[DLockGrantToken.releaseIfLockedBy] pending requests: {}",
+                (this.pendingRequests == null ? "none" : "" + this.pendingRequests.size()));
-    
+
-     * Returns true if lock is currently leased by the owner with the
-     * specified lock id.
+     * Returns true if lock is currently leased by the owner with the specified lock id.
-     * @return true if lock is currently leased by the owner with the
-     * specified lock id
+     * @return true if lock is currently leased by the owner with the specified lock id
-    protected boolean isLockedBy(InternalDistributedMember owner, 
-                                 int lockId) {
+    protected boolean isLockedBy(InternalDistributedMember owner, int lockId) {
-    
+
-     * Handle timeouts for requests waiting on this lock. Any requests that
-     * have timed out will be removed. Calculates and returns the next
-     * smallest timeout of the requests still waiting on this lock.
+     * Handle timeouts for requests waiting on this lock. Any requests that have timed out will be
+     * removed. Calculates and returns the next smallest timeout of the requests still waiting on
+     * this lock.
-        if (this.pendingRequests == null) return smallestTimeout;
-        if (this.grantor.isDestroyed()) return smallestTimeout;
+        if (this.pendingRequests == null)
+          return smallestTimeout;
+        if (this.grantor.isDestroyed())
+          return smallestTimeout;
-      
+
-          }
-          else {
+          } else {
-      
+
-    
+
-     * Cleans up any state for the departed member. If the lock is held by
-     * this member, it will be released. Any pending lock requests for this
-     * member will be removed.
+     * Cleans up any state for the departed member. If the lock is held by this member, it will be
+     * released. Any pending lock requests for this member will be removed.
-                                     final ArrayList grantsToRemoveIfUnused) {
+        final ArrayList grantsToRemoveIfUnused) {
-            if (isDestroyed()) return;
-            if (this.pendingRequests == null) return;
+            if (isDestroyed())
+              return;
+            if (this.pendingRequests == null)
+              return;
-                }
-                catch (CancelException e) {
+                } catch (CancelException e) {
-                    logger.trace(LogMarker.DLS, "[DLockGrantToken.handleDepartureOf] ignored cancellation (1)");
+                    logger.trace(LogMarker.DLS,
+                        "[DLockGrantToken.handleDepartureOf] ignored cancellation (1)");
-          }
-          finally {
+          } finally {
-              //   because release will grant to first request in queued requests
+              // because release will grant to first request in queued requests
-              }
-              catch (IllegalStateException e) {
+              } catch (IllegalStateException e) {
-                  logger.trace(LogMarker.DLS, "[DLockGrantToken.handleDepartureOf] pending requests: {}", (this.pendingRequests == null ? "none" : ""+this.pendingRequests.size()));
+                  logger.trace(LogMarker.DLS,
+                      "[DLockGrantToken.handleDepartureOf] pending requests: {}",
+                      (this.pendingRequests == null ? "none" : "" + this.pendingRequests.size()));
-      }
-      finally {
+      } finally {
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-              logger.trace(LogMarker.DLS, "[DLockGrantToken.handleDepartureOf] ignored cancellation (2)");
+              logger.trace(LogMarker.DLS,
+                  "[DLockGrantToken.handleDepartureOf] ignored cancellation (2)");
-    
+
-     * Adds this grant to the list if it references the departed member. 
+     * Adds this grant to the list if it references the departed member.
-     * @param grantsReferencingMember list to add grant to if it references
-     * departed member
+     * @param grantsReferencingMember list to add grant to if it references departed member
-    protected synchronized void checkDepartureOf(
-                           final InternalDistributedMember member,
-                           final List grantsReferencingMember) {
-      
+    protected synchronized void checkDepartureOf(final InternalDistributedMember member,
+        final List grantsReferencingMember) {
+
-    
+
-     * @param requestsToRemove the pending requests to remove
-     * guarded.By this
+     * @param requestsToRemove the pending requests to remove guarded.By this
-    
+
-        logger.trace(LogMarker.DLS, "[DLockGrantToken.grantLock] {} isGranted={} hasWaitingRequests={}", getName(), isLeaseHeld(), hasWaitingRequests());
+        logger.trace(LogMarker.DLS,
+            "[DLockGrantToken.grantLock] {} isGranted={} hasWaitingRequests={}", getName(),
+            isLeaseHeld(), hasWaitingRequests());
-                                                          
+
-        
-          // grant lock to the request unless it is timed out... 
+
+          // grant lock to the request unless it is timed out...
-          
+
-            logger.trace(LogMarker.DLS, "[DLockGrantToken.grantLock] granting {} to {}", getName(), request.getSender());
+            logger.trace(LogMarker.DLS, "[DLockGrantToken.grantLock] granting {} to {}", getName(),
+                request.getSender());
-          
+
-          if (newLeaseExpireTime == -1) continue;
-          
+          if (newLeaseExpireTime == -1)
+            continue;
+
-            long now = DLockService.getLockTimeStamp(
-                this.grantor.dm);
+            long now = DLockService.getLockTimeStamp(this.grantor.dm);
-      
-        }
-        catch (IndexOutOfBoundsException e) {
+
+        } catch (IndexOutOfBoundsException e) {
-      
+
-    
-    /** 
-     * Grants the lock to the specified request and sends a reply to the
-     * member that initiated the request.
+
+    /**
+     * Grants the lock to the specified request and sends a reply to the member that initiated the
+     * request.
-     * @return leaseExpireTime or -1 if failed to grant. 
-     * guarded.By this
+     * @return leaseExpireTime or -1 if failed to grant. guarded.By this
-      
+
-          
+
-        
+
-                this.grantor.lockingSuspendedBy == null ||
-                this.grantor.isLockingSuspendedBy(request.getRemoteThread()),
-                "Locking is suspended by " + this.grantor.lockingSuspendedBy +
-                " with lockId of " + this.grantor.suspendedLockId +
-                " instead of " + request.getRemoteThread() +
-                " with lockId of " + request.getLockId());
+                this.grantor.lockingSuspendedBy == null
+                    || this.grantor.isLockingSuspendedBy(request.getRemoteThread()),
+                "Locking is suspended by " + this.grantor.lockingSuspendedBy + " with lockId of "
+                    + this.grantor.suspendedLockId + " instead of " + request.getRemoteThread()
+                    + " with lockId of " + request.getLockId());
-        
+
-        
-        grantLock(request.getSender(), 
-                  newLeaseExpireTime, 
-                  request.getLockId(), 
-                  request.getRemoteThread());
-        
+
+        grantLock(request.getSender(), newLeaseExpireTime, request.getLockId(),
+            request.getRemoteThread());
+
-            Assert.assertTrue(
-                this.grantor.isLockingSuspendedBy(request.getRemoteThread()),
-                "Locking should now be suspended by " + request.getRemoteThread() +
-                " with lockId of " + request.getLockId() +
-                " instead of " + this.grantor.lockingSuspendedBy +
-                " with lockId of " + this.grantor.suspendedLockId);
+            Assert.assertTrue(this.grantor.isLockingSuspendedBy(request.getRemoteThread()),
+                "Locking should now be suspended by " + request.getRemoteThread()
+                    + " with lockId of " + request.getLockId() + " instead of "
+                    + this.grantor.lockingSuspendedBy + " with lockId of "
+                    + this.grantor.suspendedLockId);
-  
+
-        //   following will release the lock because the reply processor is gone
+        // following will release the lock because the reply processor is gone
-    
+
-     * Returns the absolute time at which the specified lease time will expire
-     * from now. This call does not change or check any state other than 
-     * current time.
+     * Returns the absolute time at which the specified lease time will expire from now. This call
+     * does not change or check any state other than current time.
-      
+
-        logger.trace(LogMarker.DLS, "[DLockGrantToken.calcLeaseExpireTime] currentTime={} newLeaseExpireTime={}", currentTime, newLeaseExpireTime);
+        logger.trace(LogMarker.DLS,
+            "[DLockGrantToken.calcLeaseExpireTime] currentTime={} newLeaseExpireTime={}",
+            currentTime, newLeaseExpireTime);
-    
+
-     * @param checkForExpiration true if expiration should be attempted before
-     * checking if this grant token is currently granted
+     * @param checkForExpiration true if expiration should be attempted before checking if this
+     *        grant token is currently granted
-      return isLeaseHeld(); 
+      return isLeaseHeld();
-     * @return a string of the pending requests for logging or debugging
-     * guarded.By this
+     * @return a string of the pending requests for logging or debugging guarded.By this
-    
+
-    
+
+     * 
-      synchronized(this) {
+      synchronized (this) {
-    
+
-    
+
-    
+
-     * @return the lock id used to lease this lock
-     * guarded.By this
+     * @return the lock id used to lease this lock guarded.By this
-    
+
-     * @return the identity of the thread that has this lock leased
-     * guarded.By this
+     * @return the identity of the thread that has this lock leased guarded.By this
-    
+
-        Assert.assertTrue(this.accessCount-amount >= 0, amount +
-            " cannot be subtracted from accessCount " + this.accessCount);
+        Assert.assertTrue(this.accessCount - amount >= 0,
+            amount + " cannot be subtracted from accessCount " + this.accessCount);
-    
+
-    
+
-    
+
-    
+
-     * Returns the lease expiration time. This the absolute time in milliseconds
-     * when the current lease will expire.
+     * Returns the lease expiration time. This the absolute time in milliseconds when the current
+     * lease will expire.
-    
+
-    
+
-    
+
-     * Handle expiration if the lease expire time has been reached for the
-     * current lease on this grant token.
+     * Handle expiration if the lease expire time has been reached for the current lease on this
+     * grant token.
-        if (this.leaseExpireTime == Long.MAX_VALUE) return false;
+        if (this.leaseExpireTime == Long.MAX_VALUE)
+          return false;
-          
+
-          
+
-            logger.trace(LogMarker.DLS, "[checkForExpiration] Expired token at {}: {}", currentTime, toString(true));
+            logger.trace(LogMarker.DLS, "[checkForExpiration] Expired token at {}: {}", currentTime,
+                toString(true));
-          
+
-          
+
-        /*else if (this.log.fineEnabled()) {
-          this.log.fine("[checkForExpiration] not expired: " + this);
-        }*/
+        /*
+         * else if (this.log.fineEnabled()) { this.log.fine("[checkForExpiration] not expired: " +
+         * this); }
+         */
-    
+
-     * @param remoteThread identity of the locking thread
-     * guarded.By this
+     * @param remoteThread identity of the locking thread guarded.By this
-    void grantLock(InternalDistributedMember owner, 
-                   long newLeaseExpireTime, 
-                   int lockId,
-                   RemoteThread remoteThread) {
+    void grantLock(InternalDistributedMember owner, long newLeaseExpireTime, int lockId,
+        RemoteThread remoteThread) {
-    }  
-    
+    }
+
-     * @param remoteThread identity of the locking thread
-     * guarded.By this
+     * @param remoteThread identity of the locking thread guarded.By this
-    private void basicGrantLock(InternalDistributedMember owner, 
-                                long newLeaseExpireTime, 
-                                int lockId,
-                                RemoteThread remoteThread) {
+    private void basicGrantLock(InternalDistributedMember owner, long newLeaseExpireTime,
+        int lockId, RemoteThread remoteThread) {
-        logger.trace(LogMarker.DLS, "[DLockGrantToken.grantLock.grantor] Granting {}", toString(false));
+        logger.trace(LogMarker.DLS, "[DLockGrantToken.grantLock.grantor] Granting {}",
+            toString(false));
-     * @return true if this lock is currently leased out
-     * guarded.By this
+     * @return true if this lock is currently leased out guarded.By this
-     * Mark this grant token as destroyed. This should only happen to a token
-     * that is no longer in use.
+     * Mark this grant token as destroyed. This should only happen to a token that is no longer in
+     * use.
-     * Caller must synchronize on this grant token.
-     * guarded.By this
+     * Caller must synchronize on this grant token. guarded.By this
-     * @throws IllegalStateException if this grant token has been destroyed
-     * guarded.By this
+     * @throws IllegalStateException if this grant token has been destroyed guarded.By this
-        //log.warning(e); -enable for debugging
+        // log.warning(e); -enable for debugging
-    
-    /** 
-     * Called by the grantor. Releases lock on this token if it is currently
-     * locked by the specified member and lockId.
+
+    /**
+     * Called by the grantor. Releases lock on this token if it is currently locked by the specified
+     * member and lockId.
-     * @return true if lock was released
-     * guarded.By this
+     * @return true if lock was released guarded.By this
-    private boolean releaseLock(InternalDistributedMember member, 
-                                int lockId) {
-      if (lockId == -1) return false;
+    private boolean releaseLock(InternalDistributedMember member, int lockId) {
+      if (lockId == -1)
+        return false;
-      
+
-          logger.trace(LogMarker.DLS, "[DLockGrantToken.releaseLock] releasing ownership: {}", this);
+          logger.trace(LogMarker.DLS, "[DLockGrantToken.releaseLock] releasing ownership: {}",
+              this);
-        
+
-        
+
-        logger.trace(LogMarker.DLS, "[DLockGrantToken.releaseLock] {} attempted to release: {}", member, this);
+        logger.trace(LogMarker.DLS, "[DLockGrantToken.releaseLock] {} attempted to release: {}",
+            member, this);
-    
+
-     * @return true if the sender holds a lease on this lock
-     * guarded.By this
+     * @return true if the sender holds a lease on this lock guarded.By this
-    private boolean isLeaseHeldBy(InternalDistributedMember sender, 
-                                       int lockId) {
+    private boolean isLeaseHeldBy(InternalDistributedMember sender, int lockId) {
-  
+
-  //   DLockGrantorThread (static inner class)
+  // DLockGrantorThread (static inner class)
-    
+
-    
-    DLockGrantorThread(DLockGrantor grantor, CancelCriterion stopper) { 
-      super(DLockService.getThreadGroup(), 
-            "Lock Grantor for " + grantor.dlock.getName());
+
+    DLockGrantorThread(DLockGrantor grantor, CancelCriterion stopper) {
+      super(DLockService.getThreadGroup(), "Lock Grantor for " + grantor.dlock.getName());
-    
+
-    
+
-      synchronized(this.lock) {
+      synchronized (this.lock) {
-            long newWakeupTimeStamp = now()+newTimeToWait;
+            long newWakeupTimeStamp = now() + newTimeToWait;
-            /*if (this.log.fineEnabled()) {
-              this.log.fine("[DLockGrantorThread.checkTimeToWait.k2]" +
-                  " newTimeToWait=" + newTimeToWait +
-                  " expire=" + expire +
-                  " newWakeupTimeStamp=" + newWakeupTimeStamp +
-                  " expectedWakeupTimeStamp=" + expectedWakeupTimeStamp +
-                  " nextExpire=" + this.nextExpire +
-                  " nextTimeout=" + this.nextTimeout +
-                  " timeToWait=" + this.timeToWait +
-                  " goIntoWait=" + this.goIntoWait
-                  );
-            }*/
-          }
-          else {
+            /*
+             * if (this.log.fineEnabled()) { this.log.fine("[DLockGrantorThread.checkTimeToWait.k2]"
+             * + " newTimeToWait=" + newTimeToWait + " expire=" + expire + " newWakeupTimeStamp=" +
+             * newWakeupTimeStamp + " expectedWakeupTimeStamp=" + expectedWakeupTimeStamp +
+             * " nextExpire=" + this.nextExpire + " nextTimeout=" + this.nextTimeout +
+             * " timeToWait=" + this.timeToWait + " goIntoWait=" + this.goIntoWait ); }
+             */
+          } else {
-            /*if (this.log.fineEnabled()) {
-              this.log.fine("[DLockGrantorThread.checkTimeToWait.k3]" +
-                  " newTimeToWait=" + newTimeToWait +
-                  " expire=" + expire +
-                  " expectedWakeupTimeStamp=" + expectedWakeupTimeStamp +
-                  " nextExpire=" + this.nextExpire +
-                  " nextTimeout=" + this.nextTimeout +
-                  " timeToWait=" + this.timeToWait +
-                  " goIntoWait=" + this.goIntoWait
-                  );
-            }*/
+            /*
+             * if (this.log.fineEnabled()) { this.log.fine("[DLockGrantorThread.checkTimeToWait.k3]"
+             * + " newTimeToWait=" + newTimeToWait + " expire=" + expire +
+             * " expectedWakeupTimeStamp=" + expectedWakeupTimeStamp + " nextExpire=" +
+             * this.nextExpire + " nextTimeout=" + this.nextTimeout + " timeToWait=" +
+             * this.timeToWait + " goIntoWait=" + this.goIntoWait ); }
+             */
-        
-        /*else if (this.log.fineEnabled()) {
-          this.log.fine("[DLockGrantorThread.checkTimeToWait.k4]" +
-              " newTimeToWait=" + newTimeToWait +
-              " expire=" + expire +
-              " expectedWakeupTimeStamp=" + expectedWakeupTimeStamp +
-              " nextExpire=" + this.nextExpire +
-              " nextTimeout=" + this.nextTimeout +
-              " timeToWait=" + this.timeToWait +
-              " goIntoWait=" + this.goIntoWait
-              );
-        }*/
+
+        /*
+         * else if (this.log.fineEnabled()) {
+         * this.log.fine("[DLockGrantorThread.checkTimeToWait.k4]" + " newTimeToWait=" +
+         * newTimeToWait + " expire=" + expire + " expectedWakeupTimeStamp=" +
+         * expectedWakeupTimeStamp + " nextExpire=" + this.nextExpire + " nextTimeout=" +
+         * this.nextTimeout + " timeToWait=" + this.timeToWait + " goIntoWait=" + this.goIntoWait );
+         * }
+         */
-      
+
-//        SystemFailure.checkFailure(); stopper checks this
+        // SystemFailure.checkFailure(); stopper checks this
-          synchronized(this.lock) { // synchronized
+          synchronized (this.lock) { // synchronized
-                
+
-                }
-                else {
+                } else {
-                
-                if (this.timeToWait < 0) this.timeToWait = 0;
+
+                if (this.timeToWait < 0)
+                  this.timeToWait = 0;
-                  logger.trace(LogMarker.DLS, "DLockGrantorThread will wait for {} ms. nextExpire={} nextTimeout={} now={}",
+                  logger.trace(LogMarker.DLS,
+                      "DLockGrantorThread will wait for {} ms. nextExpire={} nextTimeout={} now={}",
-                logger.trace(LogMarker.DLS, "DLockGrantorThread is about to wait for {} ms.", this.timeToWait);
+                logger.trace(LogMarker.DLS, "DLockGrantorThread is about to wait for {} ms.",
+                    this.timeToWait);
-              }
-              else {
+              } else {
-                  if (this.goIntoWait) break; // out of for loop
+                  if (this.goIntoWait)
+                    break; // out of for loop
-                  if (timeToWaitThisTime <= 0) break; // out of for loop
+                  if (timeToWaitThisTime <= 0)
+                    break; // out of for loop
-              if (this.shutdown) break;
+              if (this.shutdown)
+                break;
-          
+
-              synchronized(this.lock) {
+              synchronized (this.lock) {
-  
+
-              synchronized(this.lock) {
+              synchronized (this.lock) {
-  
+
-  
-          }
-          catch (CancelException e) {
+
+          } catch (CancelException e) {
-          }
-          finally {
+          } finally {
-          
-        } 
-        catch (InterruptedException e) {
+
+        } catch (InterruptedException e) {
-          
+
-          
+
-          }
-          else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.DLockGrantor_DLOCKGRANTORTHREAD_WAS_UNEXPECTEDLY_INTERRUPTED), e);
+          } else {
+            logger.warn(
+                LocalizedMessage.create(
+                    LocalizedStrings.DLockGrantor_DLOCKGRANTORTHREAD_WAS_UNEXPECTEDLY_INTERRUPTED),
+                e);
-//        catch (VirtualMachineError err) {
-//          SystemFailure.initiateFailure(err);
-//          // If this ever returns, rethrow the error.  We're poisoned
-//          // now, so don't let this thread continue.
-//          throw err;
-//        }
-//        catch (Throwable e) {
-//          // Whenever you catch Error or Throwable, you must also
-//          // catch VirtualMachineError (see above).  However, there is
-//          // _still_ a possibility that you are dealing with a cascading
-//          // error condition, so you also need to check to see if the JVM
-//          // is still usable:
-//          SystemFailure.checkFailure();
-//          this.log.warning(LocalizedStrings.DLockGrantor_DLOCKGRANTORTHREAD_CAUGHT_EXCEPTION, e);
-//        }
+        // catch (VirtualMachineError err) {
+        // SystemFailure.initiateFailure(err);
+        // // If this ever returns, rethrow the error. We're poisoned
+        // // now, so don't let this thread continue.
+        // throw err;
+        // }
+        // catch (Throwable e) {
+        // // Whenever you catch Error or Throwable, you must also
+        // // catch VirtualMachineError (see above). However, there is
+        // // _still_ a possibility that you are dealing with a cascading
+        // // error condition, so you also need to check to see if the JVM
+        // // is still usable:
+        // SystemFailure.checkFailure();
+        // this.log.warning(LocalizedStrings.DLockGrantor_DLOCKGRANTORTHREAD_CAUGHT_EXCEPTION, e);
+        // }
-          
+
-  //   MembershipListener inner classes
+  // MembershipListener inner classes
-  
+
-    public void memberJoined(InternalDistributedMember id) {
-    }
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-    }
-    public void memberSuspect(InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {
-    }
+    public void memberJoined(InternalDistributedMember id) {}
+
+    public void quorumLost(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {}
+
+    public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+        String reason) {}
+
-          logger.trace(LogMarker.DLS, "[DLockGrantor.memberDeparted] waiting thread pool will process id={}", id);
+          logger.trace(LogMarker.DLS,
+              "[DLockGrantor.memberDeparted] waiting thread pool will process id={}", id);
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
-      }
-      catch (RejectedExecutionException e) {
+      } catch (RejectedExecutionException e) {
-          logger.trace(LogMarker.DLS, "[DLockGrantor.memberDeparted] rejected handling of id={}", id);
+          logger.trace(LogMarker.DLS, "[DLockGrantor.memberDeparted] rejected handling of id={}",
+              id);
-    protected void processMemberDeparted(InternalDistributedMember id, boolean crashed, DLockGrantor me) 
-        throws InterruptedException {
+
+    protected void processMemberDeparted(InternalDistributedMember id, boolean crashed,
+        DLockGrantor me) throws InterruptedException {
-  
+
-      }
-      catch (LockGrantorDestroyedException e) {
+      } catch (LockGrantorDestroyedException e) {

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NetworkInterface;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.Enumeration;
+import java.util.Properties;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.cache.Region.Entry;
-
-import java.io.*;
-import java.net.*;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.Properties;
-
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+import org.apache.geode.internal.logging.LogService;
-  final static boolean VERBOSE = Boolean.getBoolean("Migration.VERBOSE");
+  private static final Logger logger = LogService.getLogger();
-  final static int VERSION = 551; // version for backward communications compatibility
+  static final boolean VERBOSE = Boolean.getBoolean("Migration.VERBOSE");
-  protected static final int CODE_ERROR = 0;
-  protected static final int CODE_ENTRY = 1; /* serialized key, serialized value */
-  protected static final int CODE_COMPLETED = 2;
+  // version for backward communications compatibility
+  private static final int VERSION = 551;
+
+  static final int CODE_ERROR = 0;
+
+  /* serialized key, serialized value */
+  static final int CODE_ENTRY = 1;
+
+  static final int CODE_COMPLETED = 2;
-    String bindAddressName = null;
-    int listenPort = 10533;
+    int listenPort = 10533;
+    String bindAddressName = null;
-
-  private int listenPort;
+  private final int listenPort;
-
-  public MigrationServer(String bindAddressName, int listenPort) {
+  private MigrationServer(String bindAddressName, int listenPort) {
-            "Error - bind address is not an address of this machine: '" + bindAddressName + "'");
+            "Error - bind address is not an address of this machine: '" + bindAddressName + '\'');
-      } catch (IOException e) {
+      } catch (IOException ignore) {
-            "Error - bind address cannot be resolved: '" + bindAddressName + "'");
+            "Error - bind address cannot be resolved: '" + bindAddressName + '\'');
-        System.out.println("created server socket " + serverSocket);
+        System.out.println("created server socket " + this.serverSocket);
-      System.err.println("Warning - file not found in local directory: '" + cacheXmlFileName + "'");
+      System.err
+          .println("Warning - file not found in local directory: '" + cacheXmlFileName + '\'');
-
-
-        } catch (java.net.SocketException e) {
+        } catch (SocketException ignored) {
-        (new RequestHandler(clientSocket)).serveClientRequest();
+        new RequestHandler(clientSocket).serveClientRequest();
-      } catch (Exception e) {
+      } catch (Exception ignore) {
-
-
-          Enumeration en = NetworkInterface.getNetworkInterfaces();
+          Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces();
-            NetworkInterface i = (NetworkInterface) en.nextElement();
-            for (Enumeration en2 = i.getInetAddresses(); en2.hasMoreElements();) {
-              InetAddress addr = (InetAddress) en2.nextElement();
+            NetworkInterface i = en.nextElement();
+            for (Enumeration<InetAddress> en2 = i.getInetAddresses(); en2.hasMoreElements();) {
+              InetAddress addr = en2.nextElement();
-      if (host.indexOf("/") > -1) {
-        return InetAddress.getByName(host.substring(host.indexOf("/") + 1));
+      if (host.contains("/")) {
+        return InetAddress.getByName(host.substring(host.indexOf('/') + 1));
-    } catch (java.net.UnknownHostException e) {
+    } catch (UnknownHostException e) {
-
-
-  // R E Q U E S T H A N D L E R
-
-
-      dos = new DataOutputStream(this.clientSocket.getOutputStream());
-      dis = new DataInputStream(this.clientSocket.getInputStream());
+      this.dos = new DataOutputStream(this.clientSocket.getOutputStream());
+      this.dis = new DataInputStream(this.clientSocket.getInputStream());
-
-            e.printStackTrace();
+            logger.debug(e);
+    @Override
-        dos.writeShort(VERSION);
-        int version = dis.readShort();
+        this.dos.writeShort(VERSION);
+        int version = this.dis.readShort();
-        return;
-          System.err.println("Trouble closing client socket: " + e.getMessage());
+          logger.debug("Trouble closing client socket", e);
-     * 
-     * @param clientVersion
-        ClientRequest req = ClientRequest.readRequest(this.clientSocket, dis, dos);
+        ClientRequest req = ClientRequest.readRequest(this.clientSocket, this.dis, this.dos);
-          dos.flush();
+          this.dos.flush();
-        e.printStackTrace();
+        logger.debug(e);
-
-
-  // R E Q U E S T C L A S S E S
-
-
-
-  static abstract class ClientRequest {
+  abstract static class ClientRequest {
-    final static int REGION_REQUEST = 1;
+    static final int REGION_REQUEST = 1;
-     * @param clientSocket
-     * @throws IOException
-      String errorMessage = "Type of request is not implemented in this server";
+      String errorMessage = "Type of request is not implemented in this server";
-
-      regionName = dsi.readUTF();
+      this.regionName = dsi.readUTF();
-      return "request for contents of region '" + this.regionName + "'";
+      return "request for contents of region '" + this.regionName + '\'';
-        region = cache.getRegion(regionName);
+        region = cache.getRegion(this.regionName);
-        System.err.println(errorMessage);
+        logger.warn(errorMessage, e);
-        for (Iterator it = region.entrySet().iterator(); it.hasNext();) {
-          sendEntry((Region.Entry) it.next());
+        for (Object o : region.entrySet()) {
+          sendEntry((Entry) o);
-    private void sendEntry(Region.Entry entry) throws Exception {
+    private void sendEntry(Region.Entry entry) throws IOException {
-        throw new IOException("Could not serialize entry for '" + key + "'");
+        throw new IOException("Could not serialize entry for '" + key + '\'');
-        throw new IOException("Could not serialize entry for '" + key + "'");
+        throw new IOException("Could not serialize entry for '" + key + '\'');
-      dso.writeShort(CODE_ENTRY);
-      (new ObjectOutputStream(clientSocket.getOutputStream())).writeObject(key);
-      (new ObjectOutputStream(clientSocket.getOutputStream())).writeObject(value);
+      this.dso.writeShort(CODE_ENTRY);
+      new ObjectOutputStream(clientSocket.getOutputStream()).writeObject(key);
+      new ObjectOutputStream(clientSocket.getOutputStream()).writeObject(value);
-

Merge branch 'release/1.8.0'

+import java.util.concurrent.TimeUnit;
+import org.apache.geode.distributed.ConfigurationProperties;
+ * <p>
+ * There's only one dedicated thread that wakes up at the
+ * {@link ConfigurationProperties#STATISTIC_SAMPLE_RATE} configured, samples all the statistics,
+ * writes them to the {@link ConfigurationProperties#STATISTIC_ARCHIVE_FILE} configured (if any) and
+ * notifies listeners of changes. The mutable fields are declared as {@code volatile} to make sure
+ * readers of the statistics get the latest recorded value.
+ * <p>
+ * This class is conditionally thread-safe, there can be multiple concurrent readers accessing a
+ * instance, but concurrent writers need to be synchronized externally.
- *
+ * @see org.apache.geode.internal.statistics.HostStatSampler
+ * @see org.apache.geode.distributed.ConfigurationProperties
+ * @see org.apache.geode.management.internal.beans.stats.MBeanStatsMonitor
-
-  private static final int VALUE_NOT_AVAILABLE = -1;
-
-  private volatile float cpuUsage = 0;
-
-  private static String processCPUTimeAttr = "ProcessCpuTime";
-
+  static final int VALUE_NOT_AVAILABLE = -1;
+  private static final String PROCESS_CPU_TIME_ATTRIBUTE = "ProcessCpuTime";
-
+  private volatile float cpuUsage = 0;
+  private final boolean processCPUTimeAvailable;
-  private boolean processCPUTimeAvailable;
+  public float getCpuUsage() {
+    return cpuUsage;
+  }
+
+  long getLastSystemTime() {
+    return lastSystemTime;
+  }
+
+  long getLastProcessCpuTime() {
+    return lastProcessCpuTime;
+  }
-    processCPUTimeAvailable = MBeanJMXAdapter.isAttributeAvailable(processCPUTimeAttr,
+    processCPUTimeAvailable = MBeanJMXAdapter.isAttributeAvailable(PROCESS_CPU_TIME_ATTRIBUTE,
-
-
-  @Override
-  public void handleNotification(StatisticsNotification notification) {
-
-    for (StatisticId statId : notification) {
-      StatisticDescriptor descriptor = statId.getStatisticDescriptor();
-      String name = descriptor.getName();
-      Number value;
-      try {
-        value = notification.getValue(statId);
-      } catch (StatisticNotFoundException e) {
-        value = 0;
-      }
-      log(name, value);
-      statsMap.put(name, value);
-    }
-    refreshStats();
+  long currentTimeMillis() {
+    return TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
+  /**
+   *
+   * @param systemTime Current system time.
+   * @param cpuTime Last gathered cpu time.
+   * @return The time (as a percentage) that this member's process time with respect to Statistics
+   *         sample time interval. If process time between two sample time t1 & t2 is p1 and p2
+   *         cpuUsage = ((p2-p1) * 100) / ((t2-t1).
+   */
+  float calculateCpuUsage(long systemTime, long cpuTime) {
+    // 10000 = (Nano conversion factor / 100 for percentage)
+    long denom = (systemTime - getLastSystemTime()) * 10000;
+    return (float) (cpuTime - getLastProcessCpuTime()) / denom;
+  }
-   *
-   * Returns the time (as a percentage) that this member's process time with respect to Statistics
-   * sample time interval. If process time between two sample time t1 & t2 is p1 and p2 cpuUsage =
-   * ((p2-p1) * 100) / ((t2-t1)
-   *
-  private void refreshStats() {
-
+  synchronized void refreshStats() {
-      Number processCpuTime = statsMap.get(StatsKey.VM_PROCESS_CPU_TIME);
+      Number processCpuTime = statsMap.getOrDefault(StatsKey.VM_PROCESS_CPU_TIME, 0);
-
-        lastSystemTime = System.currentTimeMillis();
+        lastSystemTime = currentTimeMillis();
-      long systemTime = System.currentTimeMillis();
-      // 10000 = (Nano conversion factor / 100 for percentage)
-      long denom = (systemTime - lastSystemTime) * 10000;
-
-      float processCpuUsage = (float) (cpuTime - lastProcessCpuTime) / denom;
-
+      long systemTime = currentTimeMillis();
+      cpuUsage = calculateCpuUsage(systemTime, cpuTime);
-      cpuUsage = processCpuUsage;
+    }
+  }
+
+  @Override
+  public void handleNotification(StatisticsNotification notification) {
+    for (StatisticId statId : notification) {
+      StatisticDescriptor descriptor = statId.getStatisticDescriptor();
+      String name = descriptor.getName();
+      Number value;
+
+      try {
+        value = notification.getValue(statId);
+      } catch (StatisticNotFoundException e) {
+        value = 0;
+      }
+
+      log(name, value);
+      statsMap.put(name, value);
+    refreshStats();
-
-  public float getCpuUsage() {
-    return cpuUsage;
-  }
-

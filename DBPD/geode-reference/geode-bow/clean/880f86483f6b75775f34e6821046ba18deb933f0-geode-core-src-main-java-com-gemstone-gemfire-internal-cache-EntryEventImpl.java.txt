GEODE-1464: remove sqlf code

-import com.gemstone.gemfire.cache.query.internal.IndexUpdater;
-import com.gemstone.gemfire.internal.cache.delta.Delta;
-  protected Delta delta = null;
-   * A custom context object that can be used for any other contextual
-   * information. Currently used by SQL Fabric to pass around evaluated rows
-   * from raw byte arrays and routing object.
-   */
-  private transient Object contextObj = null;
-
-  /**
-  private transient boolean isPutDML = false;
-
-      this.delta = (Delta)DataSerializer.readObject(in);
+      assert false : "isDelta should never be true";
-    if (newVal instanceof Delta) {
-      this.delta = (Delta)newVal;
-    }
-    else if (!Token.isInvalid(newVal)) {
+    if (!Token.isInvalid(newVal)) {
-    this.delta = other.delta;
-   * ALERT: If there is a Delta, returns that, not the (applied) new value.
-    if (this.delta != null) {
-      return this.delta;
-    }
-   * If new value is a Delta return it.
-   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * If new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
-    if (this.delta != null) return this.delta;
-  /**
-   * Returns the delta that represents the new value; null if no delta.
-   * @return the delta that represents the new value; null if no delta.
-   */
-  public final Delta getDeltaNewValue() {
-    return this.delta;
-  }
-
-  /**
-   *  Applies the delta 
-   */
-  private Object applyDeltaWithCopyOnRead(boolean doCopyOnRead) {
-    //try {
-      if (applyDelta(true)) {
-        Object applied = basicGetNewValue();
-        // if applyDelta returns true then newValue should not be off-heap
-        assert !(applied instanceof StoredObject);
-        if (applied == this.oldValue && doCopyOnRead) {
-          applied = CopyHelper.copy(applied);
-        }
-        return applied;
-      }
-    //} catch (EntryNotFoundException ex) {
-      // only (broken) product code has the opportunity to call this before
-      // this.oldValue is set. If oldValue is not set yet, then
-      // we most likely haven't synchronized on the region entry yet.
-      // (If we have, then make sure oldValue is set before
-      // calling this method).
-      //throw new AssertionError("too early to call getNewValue");
-    //}
-    return null;
-  }
-
-    try {
-      if (applyDelta(true)) {
-        @Unretained(ENTRY_EVENT_NEW_VALUE)
-        Object applied = basicGetNewValue();
-        if (applied == this.oldValue && doCopyOnRead) {
-          applied = CopyHelper.copy(applied);
-        }
-        return applied;
-      }
-    } catch (EntryNotFoundException ex) {
-      // only (broken) product code has the opportunity to call this before
-      // this.oldValue is set. If oldValue is not set yet, then
-      // we most likely haven't synchronized on the region entry yet.
-      // (If we have, then make sure oldValue is set before
-      // calling this method).
-      throw new AssertionError("too early to call getNewValue");
-    }
-  protected boolean applyDelta(boolean throwOnNullOldValue)
-      throws EntryNotFoundException {
-    if (this.newValue != null || this.delta == null) {
-      return false;
-    }
-    if (this.oldValue == null) {
-      if (throwOnNullOldValue) {
-        // !!!:ezoerner:20080611 It would be nice if the client got this
-        // exception
-        throw new EntryNotFoundException(
-            "Cannot apply a delta without an existing value");
-      }
-      return false;
-    }
-    // swizzle BucketRegion in event for Delta.
-    // !!!:ezoerner:20090602 this is way ugly; this whole class severely
-    // needs refactoring
-    LocalRegion originalRegion = this.region;
-    try {
-      if (originalRegion instanceof BucketRegion) {
-        this.region = ((BucketRegion)this.region).getPartitionedRegion();
-      }
-      basicSetNewValue(this.delta.apply(this));
-    } finally {
-      this.region = originalRegion;
-    }
-    return true;
-  }
-
-    if (obj instanceof Delta) {
-      this.delta = (Delta)obj;
-      basicSetNewValue(null);
-    }
-    else {
-      basicSetNewValue(obj);
-    }
+    basicSetNewValue(obj);
-   * If applyDelta is true then first attempt to apply a delta (if we have one) and return the value.
-   * Else if new value is a Delta return it.
-   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
-   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
-   * Else return the raw form.
-   */
-  @Unretained(ENTRY_EVENT_NEW_VALUE)
-  public final Object getRawNewValue(boolean applyDelta) {
-    if (applyDelta) {
-      boolean doCopyOnRead = getRegion().isCopyOnRead();
-      Object newValueWithDelta = applyDeltaWithCopyOnRead(doCopyOnRead);
-      if (newValueWithDelta != null) {
-        return newValueWithDelta;
-      }
-      // if applyDelta is true and we have already applied the delta then
-      // just return the applied value instead of the delta object.
-      @Unretained(ENTRY_EVENT_NEW_VALUE)
-      Object newValue = basicGetNewValue();
-      if (newValue != null) return newValue;
-    }
-    return getRawNewValue();
-  }
-  /**
-    Object result = getRawNewValue(true);
+    Object result = getRawNewValue();
-    if (this.delta == null) {
-    }
-    else {
-      return this.delta;
-    }
-      if (this.delta == null) {
-      }
-      else {
-        val = this.delta;
-      }
-    else if (obj == null && this.delta != null) {
-      // defer serialization until setNewValueInRegion
-      this.setSerializationDeferred(true);
-      return;
-    }
-                            || obj instanceof com.gemstone.gemfire.Delta
-                            || obj instanceof Delta) { // internal delta
+                            || obj instanceof com.gemstone.gemfire.Delta) { // internal delta
-    // avoid unneeded serialization of byte[][] used by SQLFabric that
+    // avoid unneeded serialization of byte[][] that
-      if (CachedDeserializableFactory.preferObject()) {
-        newVal = deserialize(serializedValue);
-      } else {
-        newVal = CachedDeserializableFactory.create(serializedValue);
-      }
-      if (newVal instanceof Delta) {
-        this.delta = (Delta)newVal;
-        newVal = null;
-        // We need the newValueBytes field and the newValue field to be in sync.
-        // In the case of non-null delta set both fields to null.
-        serializedValue = null;
-      }
+      newVal = CachedDeserializableFactory.create(serializedValue);
-    if (CachedDeserializableFactory.preferObject()) {
-      ov = deserialize(serializedOldValue);
-    }
-    else if (serializedOldValue != null) {
+    if (serializedOldValue != null) {
-    if (applyDelta(this.op.isCreate())) {
-      if (this.isSerializationDeferred()) {
-        makeSerializedNewValue(true);
-      }
-    }
-
-    Object preparedV = reentry.prepareValueForCache(this.region, v, this, this.hasDelta());
+    Object preparedV = reentry.prepareValueForCache(this.region, v, this, false);
-    final IndexUpdater indexUpdater = this.region.getIndexUpdater();
-    if (indexUpdater != null) {
-      final LocalRegion indexRegion;
-      if (owner != null) {
-        indexRegion = owner;
-      }
-      else {
-        indexRegion = this.region;
-      }
-      try {
-        indexUpdater.onEvent(indexRegion, this, reentry);
-        calledSetValue = true;
-        reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
-        success = true;
-      } finally {
-        indexUpdater.postEvent(indexRegion, this, reentry, success);
-      }
-    }
-    else {
-      calledSetValue = true;
-      reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
-      success = true;
-    }
+    calledSetValue = true;
+    reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
+    success = true;
-      } else if (this.delta != null) {
-        v = this.delta;
-    if (tmp == null && hasDelta()) {
-      // ???:ezoerner:20080611 what if applying the delta would produce
-      // null or (strangely) NOT_AVAILABLE.. do we need to apply it here to
-      // find out?
-      return true;
-    }
-  /**
-   * This should only be used in case of internal delta and <B>not for Delta of
-   * Delta Propagation feature</B>.
-   * 
-   * @return boolean
-   */
-  public boolean hasDelta() {
-    return (this.delta != null);
-  }
-
-      boolean isDelta = this.delta != null;
-      out.writeBoolean(isDelta);
-      if (isDelta) {
-        DataSerializer.writeObject(this.delta, out);
-      }
-      else {
+      out.writeBoolean(false);
+      {
-    applyDelta(false);
-  public final void setContextObject(Object ctx) {
-    this.contextObj = ctx;
-  }
-
-  public final Object getContextObject() {
-    return this.contextObj;
-  }
-
-
-  public final boolean isPutDML() {
-    return this.isPutDML;
-  }
-
-  public final void setPutDML(boolean val) {
-    this.isPutDML = val;
-  }

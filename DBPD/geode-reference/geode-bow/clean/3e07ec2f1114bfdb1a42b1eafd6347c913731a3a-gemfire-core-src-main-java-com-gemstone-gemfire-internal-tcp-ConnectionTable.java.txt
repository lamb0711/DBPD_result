Merge remote-tracking branch 'origin/develop' into feature/GEODE-11

+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import com.gemstone.gemfire.internal.SocketCloser;
+import com.gemstone.gemfire.internal.logging.LoggingThreadGroup;
-
+  /**
+   * Executor used by p2p reader and p2p handshaker threads.
+   */
+  private final Executor p2pReaderThreadPool;
+  /** Number of seconds to wait before timing out an unused p2p reader thread. Default is 120 (2 minutes). */
+  private final static long READER_POOL_KEEP_ALIVE_TIME = Long.getLong("p2p.READER_POOL_KEEP_ALIVE_TIME", 120).longValue();
+  
+  private final SocketCloser socketCloser;
+  
+    this.p2pReaderThreadPool = createThreadPoolForIO(c.getDM().getSystem().isShareSockets());
+    this.socketCloser = new SocketCloser();
+  
+  private Executor createThreadPoolForIO(boolean conserveSockets) { 
+    Executor executor = null; 
+    final ThreadGroup connectionRWGroup = LoggingThreadGroup.createThreadGroup("P2P Reader Threads", logger);
+    if (conserveSockets) { 
+      executor = new Executor() { 
+        @Override 
+        public void execute(Runnable command) { 
+          Thread th = new Thread(connectionRWGroup, command); 
+          th.setDaemon(true); 
+          th.start(); 
+        } 
+      }; 
+    } 
+    else { 
+      BlockingQueue synchronousQueue = new SynchronousQueue(); 
+      ThreadFactory tf = new ThreadFactory() { 
+        public Thread newThread(final Runnable command) { 
+          Thread thread = new Thread(connectionRWGroup, command); 
+          thread.setDaemon(true); 
+          return thread; 
+        } 
+      }; 
+      executor = new ThreadPoolExecutor(1, Integer.MAX_VALUE, READER_POOL_KEEP_ALIVE_TIME, 
+          TimeUnit.SECONDS, synchronousQueue, tf); 
+    } 
+    return executor; 
+  } 
+    {
+      Executor localExec = this.p2pReaderThreadPool;
+      if (localExec != null) {
+        if (localExec instanceof ExecutorService) {
+          ((ExecutorService)localExec).shutdown();
+        }
+      }
+    }
+    this.socketCloser.close();
+  public void executeCommand(Runnable runnable) { 
+    Executor local = this.p2pReaderThreadPool;
+    if (local != null) {
+      local.execute(runnable);
+    }
+  }
+  
+      InternalDistributedMember remoteAddress = null;
-           closeCon(reason, this.orderedConnectionMap.remove(stub));
+        Object c = this.orderedConnectionMap.remove(stub);
+        if (c instanceof Connection) {
+          remoteAddress = ((Connection) c).getRemoteAddress();
+        }
+        closeCon(reason, c);
-         closeCon(reason, this.unorderedConnectionMap.remove(stub));
+        Object c = this.unorderedConnectionMap.remove(stub);
+        if (remoteAddress == null && (c instanceof Connection)) {
+          remoteAddress = ((Connection) c).getRemoteAddress();
+        }
+        closeCon(reason, c);
-              for (Iterator it=al.iterator(); it.hasNext();)
-                closeCon(reason, it.next());
+              for (Iterator it=al.iterator(); it.hasNext();) {
+                Object c = it.next();
+                if (remoteAddress == null && (c instanceof Connection)) {
+                  remoteAddress = ((Connection) c).getRemoteAddress();
+                }
+                closeCon(reason, c);
+              }
+      
+      if (remoteAddress != null) {
+        this.socketCloser.releaseResourcesForAddress(remoteAddress.toString());
+      }
+  SocketCloser getSocketCloser() {
+    return this.socketCloser;
+  }
+  

Merge branch 'release/1.8.0'

+import org.apache.geode.distributed.ConfigurationProperties;
+/**
+ * This class acts as a monitor and listen for Gateway Sender Overflow statistics updates on
+ * behalf of MemberMBean.
+ * <p>
+ * There's only one dedicated thread that wakes up at the
+ * {@link ConfigurationProperties#STATISTIC_SAMPLE_RATE} configured, samples all the statistics,
+ * writes them to the {@link ConfigurationProperties#STATISTIC_ARCHIVE_FILE} configured (if any) and
+ * notifies listeners of changes. The mutable fields are declared as {@code volatile} to make sure
+ * readers of the statistics get the latest recorded value.
+ * <p>
+ * This class is conditionally thread-safe, there can be multiple concurrent readers accessing a
+ * instance, but concurrent writers need to be synchronized externally.
+ *
+ * @see org.apache.geode.internal.statistics.HostStatSampler
+ * @see org.apache.geode.distributed.ConfigurationProperties
+ * @see org.apache.geode.management.internal.beans.stats.MBeanStatsMonitor
+ */
-
-  private volatile long entriesOverflowedToDisk = 0;
-
-  private volatile long bytesOverflowedToDisk = 0;
-
+  private volatile long bytesOverflowedToDisk = 0;
+  private volatile long entriesOverflowedToDisk = 0;
+  private final Map<Statistics, ValueMonitor> monitors;
+  private final Map<Statistics, StatisticsListener> listeners;
-  private Map<Statistics, ValueMonitor> monitors;
+  long getLruEvictions() {
+    return lruEvictions;
+  }
-  private Map<Statistics, StatisticsListener> listeners;
+  public long getBytesOverflowedToDisk() {
+    return bytesOverflowedToDisk;
+  }
+
+  public long getEntriesOverflowedToDisk() {
+    return entriesOverflowedToDisk;
+  }
+
+  Map<Statistics, ValueMonitor> getMonitors() {
+    return monitors;
+  }
+
+  Map<Statistics, StatisticsListener> getListeners() {
+    return listeners;
+  }
+  Number computeDelta(Map<String, Number> statsMap, String name, Number currentValue) {
+    if (name.equals(StatsKey.GATEWAYSENDER_LRU_EVICTIONS)) {
+      Number prevValue = statsMap.getOrDefault(StatsKey.GATEWAYSENDER_LRU_EVICTIONS, 0);
+      return currentValue.longValue() - prevValue.longValue();
+    }
+
+    if (name.equals(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK)) {
+      Number prevValue =
+          statsMap.getOrDefault(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK, 0);
+      return currentValue.longValue() - prevValue.longValue();
+    }
+
+    if (name.equals(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK)) {
+      Number prevValue = statsMap.getOrDefault(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK, 0);
+      return currentValue.longValue() - prevValue.longValue();
+    }
+
+    return 0;
+  }
+
+  void increaseStats(String name, Number value) {
+    if (name.equals(StatsKey.GATEWAYSENDER_LRU_EVICTIONS)) {
+      lruEvictions += value.longValue();
+      return;
+    }
+
+    if (name.equals(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK)) {
+      entriesOverflowedToDisk += value.longValue();
+      return;
+    }
+
+    if (name.equals(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK)) {
+      bytesOverflowedToDisk += value.longValue();
+      return;
+    }
+  }
+
+  @Override
+  public Number getStatistic(String name) {
+    if (name.equals(StatsKey.GATEWAYSENDER_LRU_EVICTIONS)) {
+      return getLruEvictions();
+    }
+
+    if (name.equals(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK)) {
+      return getEntriesOverflowedToDisk();
+    }
+
+    if (name.equals(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK)) {
+      return getBytesOverflowedToDisk();
+    }
+
+    return 0;
+  }
+
+
-  public void removeStatisticsFromMonitor(Statistics stats) {}
-
-  @Override
+
-  public Number getStatistic(String name) {
-    if (name.equals(StatsKey.GATEWAYSENDER_LRU_EVICTIONS)) {
-      return getLruEvictions();
-    }
-    if (name.equals(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK)) {
-      return getEntriesOverflowedToDisk();
-    }
-    if (name.equals(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK)) {
-      return getBytesOverflowedToDisk();
-    }
-    return 0;
-  }
+  public void removeStatisticsFromMonitor(Statistics stats) {}
-
-  private class GatewaySenderOverflowStatisticsListener implements StatisticsListener {
-
-    DefaultHashMap statsMap = new DefaultHashMap();
+  class GatewaySenderOverflowStatisticsListener implements StatisticsListener {
+    Map<String, Number> statsMap = new HashMap<>();
+
-          log(name, value);
+          log(name, value);
-  };
-
-  private Number computeDelta(DefaultHashMap statsMap, String name, Number currentValue) {
-    if (name.equals(StatsKey.GATEWAYSENDER_LRU_EVICTIONS)) {
-      Number prevValue = statsMap.get(StatsKey.GATEWAYSENDER_LRU_EVICTIONS).longValue();
-      Number deltaValue = currentValue.longValue() - prevValue.longValue();
-      return deltaValue;
-    }
-    if (name.equals(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK)) {
-      Number prevValue =
-          statsMap.get(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK).longValue();
-      Number deltaValue = currentValue.longValue() - prevValue.longValue();
-      return deltaValue;
-    }
-    if (name.equals(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK)) {
-      Number prevValue = statsMap.get(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK).longValue();
-      Number deltaValue = currentValue.longValue() - prevValue.longValue();
-      return deltaValue;
-    }
-    return 0;
-  }
-
-  private void increaseStats(String name, Number value) {
-    if (name.equals(StatsKey.GATEWAYSENDER_LRU_EVICTIONS)) {
-      lruEvictions += value.longValue();
-      return;
-    }
-    if (name.equals(StatsKey.GATEWAYSENDER_ENTRIES_OVERFLOWED_TO_DISK)) {
-      entriesOverflowedToDisk += value.longValue();
-      return;
-    }
-    if (name.equals(StatsKey.GATEWAYSENDER_BYTES_OVERFLOWED_TO_DISK)) {
-      bytesOverflowedToDisk += value.longValue();
-      return;
-    }
-  }
-
-  public long getLruEvictions() {
-    return lruEvictions;
-  }
-
-  public long getEntriesOverflowedToDisk() {
-    return entriesOverflowedToDisk;
-  }
-
-  public long getBytesOverflowedToDisk() {
-    return bytesOverflowedToDisk;

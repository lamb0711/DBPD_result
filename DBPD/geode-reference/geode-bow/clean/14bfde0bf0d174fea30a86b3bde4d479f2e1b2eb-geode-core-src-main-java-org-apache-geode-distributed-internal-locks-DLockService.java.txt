Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-    return LocalizedStrings.DLockService_0_HAS_BEEN_DESTROYED.toLocalizedString(this);
+    return String.format("%s has been destroyed", this);
-          // older grantor couldn't depose us, so null him out...
+          // older grantor couldn't depose us, so null it out...
-              LocalizedMessage.create(LocalizedStrings.DLockService_GRANTOR_IS_STILL_INITIALIZING));
+              "Grantor is still initializing");
-          logger.error(LogMarker.DLS_MARKER, LocalizedMessage.create(
-              LocalizedStrings.DLockService_GRANTOR_CREATION_WAS_ABORTED_BUT_GRANTOR_WAS_NOT_DESTROYED));
+          logger.error(LogMarker.DLS_MARKER,
+              "Grantor creation was aborted but grantor was not destroyed");
-   * @param predecessor non-null if a predecessor asked us to take over for him
+   * @param predecessor non-null if a predecessor asked us to take over for it
-      logger.error(LogMarker.DLS_MARKER,
-          LocalizedMessage.create(LocalizedStrings.DLockService_LOCK_WAS_INTERRUPTED), ex);
+      logger.error(LogMarker.DLS_MARKER, "lock() was interrupted", ex);
-                    LocalizedStrings.DLockService_0_ATTEMPTED_TO_REENTER_NONREENTRANT_LOCK_1
-                        .toLocalizedString(new Object[] {Thread.currentThread(), token}));
+                    String.format("%s attempted to reenter non-reentrant lock %s",
+                        new Object[] {Thread.currentThread(), token}));
-                logger.warn(LogMarker.DLS_MARKER,
-                    LocalizedMessage.create(
-                        LocalizedStrings.DLockService_GRANTOR_REPORTS_REENTRANT_LOCK_NOT_HELD_0,
-                        token));
+                logger.warn(LogMarker.DLS_MARKER, "Grantor reports reentrant lock not held: {}",
+                    token);
-            LocalizedStrings.DLockService_CURRENT_THREAD_HAS_ALREADY_LOCKED_ENTIRE_SERVICE
-                .toLocalizedString());
+            "Current thread has already locked entire service");
-    if (this.ds.isDisconnectListenerThread()) {
-      if (isDebugEnabled_DLS) {
-        logger.trace(LogMarker.DLS_VERBOSE,
-            "{}, name: {} - disconnect listener thread is exiting unlock()", this, name);
-      }
-      return;
-    }
-
-              LocalizedStrings.DLockService_ATTEMPTING_TO_UNLOCK_0_1_BUT_THIS_THREAD_DOESNT_OWN_THE_LOCK
-                  .toLocalizedString(new Object[] {this, name}));
+              String.format(
+                  "Attempting to unlock %s : %s , but this thread does not own the lock.",
+                  new Object[] {this, name}));
-                LocalizedStrings.DLockService_ATTEMPTING_TO_UNLOCK_0_1_BUT_THIS_THREAD_DOESNT_OWN_THE_LOCK_2
-                    .toLocalizedString(new Object[] {this, name, token}));
+                String.format(
+                    "Attempting to unlock %s : %s , but this thread does not own the lock. %s",
+                    new Object[] {this, name, token}));
-          LocalizedStrings.DLockService_KEYIFFAILED_MUST_HAVE_A_LENGTH_OF_ONE_OR_GREATER
-              .toLocalizedString());
+          "keyIfFailed must have a length of one or greater");
-          LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+          String.format("Service named %s not created", serviceName));
-    if (!isCurrentlyLockGrantor && maybeHasActiveLocks && !this.ds.isDisconnectListenerThread()) {
+    if (!isCurrentlyLockGrantor && maybeHasActiveLocks && !this.ds.isDisconnectThread()) {
-                LocalizedMessage.create(
-                    LocalizedStrings.DLockService_FAILED_TO_NOTIFY_GRANTOR_OF_DESTRUCTION_WITHIN_0_ATTEMPTS,
-                    Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)));
+                "Failed to notify grantor of destruction within {} attempts.",
+                Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT));
-                LocalizedStrings.DLockService_FAILED_TO_NOTIFY_GRANTOR_OF_DESTRUCTION_WITHIN_0_ATTEMPTS
-                    .toLocalizedString(
-                        new Object[] {Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)}));
+                String.format("Failed to notify grantor of destruction within %s attempts.",
+
+                    new Object[] {Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)}));
-    // KIRK: probably don't need to do the following if isMakingLockGrantor
-        // KIRK: probably don't need to waitForGrantor
-      logger.info(LogMarker.DLS_MARKER, LocalizedMessage.create(LocalizedStrings.ONE_ARG, buffer));
+      logger.info(LogMarker.DLS_MARKER, buffer);
-          return LocalizedStrings.DLockService_DISCONNECT_LISTENER_FOR_DISTRIBUTEDLOCKSERVICE
-              .toLocalizedString();
+          return "Disconnect listener for DistributedLockService";
-
-        // make sure thread group is ready...
-        readyThreadGroup(ds);
-
-              LocalizedStrings.DLockService_SERVICE_NAMED_0_ALREADY_CREATED
-                  .toLocalizedString(serviceName));
+              String.format("Service named %s already created",
+                  serviceName));
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_NOT_VALID
-          .toLocalizedString(serviceName));
+      throw new IllegalArgumentException(String.format("Service named '%s' is not valid",
+          serviceName));
-          LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+          String.format("Service named %s not created", serviceName));
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_NOT_VALID
-          .toLocalizedString(serviceName));
+      throw new IllegalArgumentException(String.format("Service named '%s' is not valid",
+          serviceName));
-          LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+          String.format("Service named %s not created", serviceName));
-  public static void recoverLocalElder(DistributionManager dm, Map grantors, Set needsRecovery) {
+  public static void recoverLocalElder(DistributionManager dm, Map<String, GrantorInfo> grantors,
+      Set<String> needsRecovery) {
-          GrantorInfo oldgi = (GrantorInfo) grantors.get(serviceName);
+          GrantorInfo oldgi = grantors.get(serviceName);
-        // fix for elder init bug... adam elder was hitting the following
-        // block and found no grantors for services that were just created
-        // and flagged them as needing recovery even though it's not needed
-        if (!foundGrantor && !(dm.isAdam() && !service.hasHeldLocks())) {
-          // !F && !(T && !T) ==> T && !F ==> T
+        if (!foundGrantor && !dm.isLoner()) {
-          LocalizedStrings.DLockService_LOCK_SERVICE_NAME_MUST_NOT_BE_NULL_OR_EMPTY
-              .toLocalizedString());
+          "Lock service name must not be null or empty");
-            LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_RESERVED_FOR_INTERNAL_USE_ONLY
-                .toLocalizedString(serviceName));
+            String.format("Service named %s is reserved for internal use only",
+                serviceName));
-      logger.info(LogMarker.DLS_MARKER, LocalizedMessage.create(LocalizedStrings.TESTING,
-          "DLockService.dumpAllServices() - " + services.size() + " services:\n"));
+      logger.info(LogMarker.DLS_MARKER,
+          "DLockService.dumpAllServices() - " + services.size() + " services:\n");
-    threadGroup = null;
-  // Internal
-  // -------------------------------------------------------------------------
-
-  protected static synchronized void readyThreadGroup(InternalDistributedSystem ds) {
-    if (threadGroup == null) {
-      Assert.assertTrue(ds != null, "Cannot find any instance of InternalDistributedSystem");
-      String threadGroupName =
-          LocalizedStrings.DLockService_DISTRIBUTED_LOCKING_THREADS.toLocalizedString();
-      final ThreadGroup group = LoggingThreadGroup.createThreadGroup(threadGroupName);
-      threadGroup = group;
-    }
-  }
-
-  // -------------------------------------------------------------------------

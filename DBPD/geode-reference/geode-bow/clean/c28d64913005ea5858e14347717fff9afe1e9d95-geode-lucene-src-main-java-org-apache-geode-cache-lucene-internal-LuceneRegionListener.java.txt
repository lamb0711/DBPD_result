Merge branch 'release/1.4.0'

+import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.geode.cache.EvictionAlgorithm;
-import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.lucene.LuceneSerializer;
+  private LuceneSerializer serializer;
+
+  private AtomicBoolean beforeCreateInvoked = new AtomicBoolean();
+
+  private AtomicBoolean afterCreateInvoked = new AtomicBoolean();
+
-      String regionPath, String[] fields, Analyzer analyzer, Map<String, Analyzer> fieldAnalyzers) {
+      String regionPath, String[] fields, Analyzer analyzer, Map<String, Analyzer> fieldAnalyzers,
+      LuceneSerializer serializer) {
+    this.serializer = serializer;
-    if (path.equals(this.regionPath)) {
+    if (path.equals(this.regionPath) && this.beforeCreateInvoked.compareAndSet(false, true)) {
-      if (!attrs.getDataPolicy().withPartitioning()) {
-        // replicated region
-        throw new UnsupportedOperationException(
-            "Lucene indexes on replicated regions are not supported");
-      }
-
-      // For now we cannot support eviction with local destroy.
-      // Eviction with overflow to disk still needs to be supported
-      EvictionAttributes evictionAttributes = attrs.getEvictionAttributes();
-      EvictionAlgorithm evictionAlgorithm = evictionAttributes.getAlgorithm();
-      if (evictionAlgorithm != EvictionAlgorithm.NONE
-          && evictionAttributes.getAction().isLocalDestroy()) {
-        throw new UnsupportedOperationException(
-            "Lucene indexes on regions with eviction and action local destroy are not supported");
-      }
+      LuceneServiceImpl.validateRegionAttributes(attrs);
-          this.regionPath, this.fields, this.analyzer, this.fieldAnalyzers));
+          this.regionPath, this.fields, this.analyzer, this.fieldAnalyzers, serializer));
-          this.analyzer, this.fieldAnalyzers, aeqId, this.fields);
+          this.analyzer, this.fieldAnalyzers, aeqId, serializer, this.fields);
-    if (region.getFullPath().equals(this.regionPath)) {
+    if (region.getFullPath().equals(this.regionPath)
+        && this.afterCreateInvoked.compareAndSet(false, true)) {
-      String aeqId = LuceneServiceImpl.getUniqueIndexName(this.indexName, this.regionPath);
-      AsyncEventQueueImpl aeq = (AsyncEventQueueImpl) cache.getAsyncEventQueue(aeqId);
-      AbstractPartitionedRepositoryManager repositoryManager =
-          (AbstractPartitionedRepositoryManager) luceneIndex.getRepositoryManager();
-      repositoryManager.allowRepositoryComputation();
-      this.cache.removeRegionListener(this);
+    }
+  }
+
+  @Override
+  public void beforeDestroyed(Region region) {
+    if (region.getFullPath().equals(this.regionPath)) {
+      this.service.beforeRegionDestroyed(region);
+    }
+  }
+
+  @Override
+  public void cleanupFailedInitialization(Region region) {
+    // Reset the booleans
+    this.beforeCreateInvoked.set(false);
+    this.afterCreateInvoked.set(false);
+
+    // Clean up the region in the LuceneService
+    if (region.getFullPath().equals(this.regionPath)) {
+      this.service.cleanupFailedInitialization(region);

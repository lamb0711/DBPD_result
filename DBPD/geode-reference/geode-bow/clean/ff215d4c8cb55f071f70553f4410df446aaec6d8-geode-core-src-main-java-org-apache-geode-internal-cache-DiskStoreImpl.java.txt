GEODE-4435 Move queueSize stat increment to after writing to disk. (#1397)

* GEODE-4435 Move queueSize stat increment to after writing to disk.

* Changes for review comments.

-  PersistentOplogSet persistentOplogs = new PersistentOplogSet(this);
+  private PersistentOplogSet persistentOplogs = new PersistentOplogSet(this);
-      return persistentOplogs;
+      return getPersistentOplogs();
-    return persistentOplogs;
+    return getPersistentOplogs();
-    return persistentOplogs;
+    return getPersistentOplogs();
-    long start = async ? this.stats.startFlush() : this.stats.startWrite();
+    long start = async ? getStats().startFlush() : getStats().startWrite();
-        this.stats.endFlush(start);
+        getStats().endFlush(start);
-        dr.getStats().endWrite(start, this.stats.endWrite(start));
+        dr.getStats().endWrite(start, getStats().endWrite(start));
-        long start = this.stats.startRemove();
+        long start = getStats().startRemove();
-        dr.getStats().endRemove(start, this.stats.endRemove(start));
+        dr.getStats().endRemove(start, getStats().endRemove(start));
-    persistentOplogs.forceRoll(null);
+    getPersistentOplogs().forceRoll(null);
-        this.asyncQueue.forcePut(item);
+        getAsyncQueue().forcePut(item);
-        if (!this.asyncQueue.offer(item)) {
+        if (!getAsyncQueue().offer(item)) {
-      this.stats.incQueueSize(1);
+      getStats().incQueueSize(1);
-        synchronized (this.asyncMonitor) {
-          this.asyncMonitor.notifyAll();
+        synchronized (getAsyncMonitor()) {
+          getAsyncMonitor().notifyAll();
-    if (this.asyncQueue.remove(item)) {
-      this.stats.incQueueSize(-1);
+    if (getAsyncQueue().remove(item)) {
+      getStats().incQueueSize(-1);
-    return this.stats.startWrite();
+    return getStats().startWrite();
-    dr.getStats().endWrite(start, this.stats.endWrite(start));
+    dr.getStats().endWrite(start, getStats().endWrite(start));
-  private int fillDrainList() {
-    synchronized (this.drainSync) {
-      this.drainList = new ArrayList(asyncQueue.size());
-      return asyncQueue.drainTo(this.drainList);
+  int fillDrainList() {
+    synchronized (getDrainSync()) {
+      ForceableLinkedBlockingQueue<Object> queue = getAsyncQueue();
+      this.drainList = new ArrayList(queue.size());
+      return queue.drainTo(this.drainList);
-  private ArrayList getDrainList() {
+  ArrayList getDrainList() {
-    synchronized (this.drainSync) {
+    synchronized (getDrainSync()) {
-        new FlusherThread(), thName);
+        new FlusherThread(this), thName);
-    synchronized (asyncMonitor) {
+    synchronized (getAsyncMonitor()) {
-      this.asyncMonitor.notifyAll();
+      getAsyncMonitor().notifyAll();
-    return this.stopFlusher || this.flusherThreadTerminated || this.flusherThread == null
+    return isStopFlusher() || this.flusherThreadTerminated || this.flusherThread == null
-    synchronized (this.asyncMonitor) {
-      this.forceFlushCount.incrementAndGet(); // moved inside sync to fix bug
-                                              // 41654
-      this.asyncMonitor.notifyAll();
+    Object monitor = getAsyncMonitor();
+    synchronized (monitor) {
+      getForceFlushCount().incrementAndGet(); // moved inside sync to fix bug
+      // 41654
+      monitor.notifyAll();
-  private boolean checkAndClearForceFlush() {
-    if (stopFlusher) {
+  boolean checkAndClearForceFlush() {
+    if (isStopFlusher()) {
-      int v = this.forceFlushCount.get();
+      int v = getForceFlushCount().get();
-        done = this.forceFlushCount.compareAndSet(v, 0);
+        done = getForceFlushCount().compareAndSet(v, 0);
+  Object getAsyncMonitor() {
+    return asyncMonitor;
+  }
+
+  AtomicInteger getForceFlushCount() {
+    return forceFlushCount;
+  }
+
+  Object getDrainSync() {
+    return drainSync;
+  }
+
+  ForceableLinkedBlockingQueue<Object> getAsyncQueue() {
+    return asyncQueue;
+  }
+
+  PersistentOplogSet getPersistentOplogs() {
+    return persistentOplogs;
+  }
+
+  boolean isStopFlusher() {
+    return stopFlusher;
+  }
+
-    return this.asyncQueue.size() >= this.maxAsyncItems;
+    return getAsyncQueue().size() >= this.maxAsyncItems;
-  private class FlusherThread implements Runnable {
+  protected static class FlusherThread implements Runnable {
+    private DiskStoreImpl diskStore;
+
+    public FlusherThread(DiskStoreImpl diskStore) {
+      this.diskStore = diskStore;
+    }
+
-      if (maxAsyncItems > 0) {
-        final long time = getTimeInterval();
-        synchronized (asyncMonitor) {
+      if (diskStore.maxAsyncItems > 0) {
+        final long time = diskStore.getTimeInterval();
+        synchronized (diskStore.getAsyncMonitor()) {
-            boolean done = checkAndClearForceFlush() || checkAsyncItemLimit();
+            boolean done = diskStore.checkAndClearForceFlush() || diskStore.checkAsyncItemLimit();
-              TimeUnit.NANOSECONDS.timedWait(asyncMonitor, nanosRemaining);
-              done = checkAndClearForceFlush() || checkAsyncItemLimit();
+              TimeUnit.NANOSECONDS.timedWait(diskStore.getAsyncMonitor(), nanosRemaining);
+              done = diskStore.checkAndClearForceFlush() || diskStore.checkAsyncItemLimit();
-            boolean done = checkAndClearForceFlush() || checkAsyncItemLimit();
+            boolean done = diskStore.checkAndClearForceFlush() || diskStore.checkAsyncItemLimit();
-              asyncMonitor.wait();
-              done = checkAndClearForceFlush() || checkAsyncItemLimit();
+              diskStore.getAsyncMonitor().wait();
+              done = diskStore.checkAndClearForceFlush() || diskStore.checkAsyncItemLimit();
-        long time = getTimeInterval();
+        long time = diskStore.getTimeInterval();
-          synchronized (asyncMonitor) {
-            boolean done = checkAndClearForceFlush();
+          synchronized (diskStore.getAsyncMonitor()) {
+            boolean done = diskStore.checkAndClearForceFlush();
-              TimeUnit.NANOSECONDS.timedWait(asyncMonitor, nanosRemaining);
-              done = checkAndClearForceFlush();
+              TimeUnit.NANOSECONDS.timedWait(diskStore.getAsyncMonitor(), nanosRemaining);
+              done = diskStore.checkAndClearForceFlush();
-          synchronized (asyncMonitor) {
-            boolean done = checkAndClearForceFlush();
+          synchronized (diskStore.getAsyncMonitor()) {
+            boolean done = diskStore.checkAndClearForceFlush();
-              asyncMonitor.wait();
-              done = checkAndClearForceFlush();
+              diskStore.getAsyncMonitor().wait();
+              done = diskStore.checkAndClearForceFlush();
-      return !stopFlusher;
+      return !diskStore.isStopFlusher();
-      persistentOplogs.flushChild();
+      diskStore.getPersistentOplogs().flushChild();
+      doAsyncFlush();
+    }
+
+    void doAsyncFlush() {
-          int drainCount = fillDrainList();
+          int drainCount = diskStore.fillDrainList();
-            stats.incQueueSize(-drainCount);
-            Iterator it = getDrainList().iterator();
+            Iterator it = diskStore.getDrainList().iterator();
+            diskStore.getStats().incQueueSize(-drainCount);
-        getCache().getCancelCriterion().checkCancelInProgress(ie);
+        diskStore.getCache().getCancelCriterion().checkCancelInProgress(ie);
-        if (!okToIgnore || !stopFlusher) {
+        if (!okToIgnore || !diskStore.isStopFlusher()) {
-            LocalizedStrings.DiskStoreImpl_FATAL_ERROR_ON_FLUSH.toLocalizedString(), t,
-            DiskStoreImpl.this);
+            LocalizedStrings.DiskStoreImpl_FATAL_ERROR_ON_FLUSH.toLocalizedString(), t, diskStore);
-          logger.debug("Async writer thread stopped. Pending opcount={}", asyncQueue.size());
+          logger.debug("Async writer thread stopped. Pending opcount={}",
+              diskStore.getAsyncQueue().size());
-        flusherThreadTerminated = true;
-        stopFlusher = true; // set this before calling handleDiskAccessException
+        diskStore.flusherThreadTerminated = true;
+        diskStore.stopFlusher = true; // set this before calling handleDiskAccessException
-          handleDiskAccessException(fatalDae);
+          diskStore.handleDiskAccessException(fatalDae);
-          persistentOplogs.findFiles(partialFileName);
+          getPersistentOplogs().findFiles(partialFileName);
-      persistentOplogs.createOplogs(needsOplogs, persistentBackupFiles);
+      getPersistentOplogs().createOplogs(needsOplogs, persistentBackupFiles);
-    this.stats.close();
+    getStats().close();
-    if (!persistentOplogs.alreadyRecoveredOnce.get()) {
+    if (!getPersistentOplogs().alreadyRecoveredOnce.get()) {
-    persistentOplogs.recoverRegionsThatAreReady();
+    getPersistentOplogs().recoverRegionsThatAreReady();
-      for (final Object o : this.asyncQueue) {
+      for (final Object o : getAsyncQueue()) {
-        RuntimeException exception = persistentOplogs.close();
+        RuntimeException exception = getPersistentOplogs().close();
-    persistentOplogs.prepareForClose();
+    getPersistentOplogs().prepareForClose();
-    PersistentOplogSet oplogSet = persistentOplogs;
+    PersistentOplogSet oplogSet = getPersistentOplogs();
-    persistentOplogs.destroyAllOplogs();
+    getPersistentOplogs().destroyAllOplogs();
-    persistentOplogs.getCompactableOplogs(l, max);
+    getPersistentOplogs().getCompactableOplogs(l, max);
-    return persistentOplogs.getAllOplogs();
+    return getPersistentOplogs().getAllOplogs();
-    persistentOplogs.recoverRegionsThatAreReady();
-    persistentOplogs.offlineCompact();
+    getPersistentOplogs().recoverRegionsThatAreReady();
+    getPersistentOplogs().offlineCompact();
-    return persistentOplogs.getChild() != null;
+    return getPersistentOplogs().getChild() != null;

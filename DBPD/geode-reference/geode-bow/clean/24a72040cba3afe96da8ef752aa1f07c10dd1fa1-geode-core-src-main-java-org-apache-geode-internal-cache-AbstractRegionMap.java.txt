GEODE-706 Fixed race condition between expiry thread and user thread.

ExpirationManager tracks the regionEntry as reference to expiryTask. It
assumes, it is unique for that key. But consistency check mechanism
keeps that regionEntry around and that enforces re-use of that for new
update. That introduces the race condition between expiry thread and
user thread, it endup not scheduling the entry for expiration. As a fix,
now "consistency check mechanism" unschedules the expiry task to avoid
this race condition.

Unmarked flaky from testEntryIdleDestroy test

-                owner.cancelExpiryTask(re, event.getExpiryTask());
-              } else if (tombstone != null) {
-                owner.cancelExpiryTask(tombstone, event.getExpiryTask());
+                // we only want to cancel if concurrency-check is not enabled
+                // re(regionentry) will be null when concurrency-check is enable and removeTombstone
+                // method
+                // will call cancelExpiryTask on regionEntry
+                owner.cancelExpiryTask(re);
+              _getOwner().cancelExpiryTask(re);

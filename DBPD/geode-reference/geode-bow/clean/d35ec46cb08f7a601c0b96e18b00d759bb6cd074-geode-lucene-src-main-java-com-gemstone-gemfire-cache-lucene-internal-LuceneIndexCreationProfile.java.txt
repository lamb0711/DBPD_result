Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalDistributedSystem.java

+import org.apache.lucene.analysis.standard.StandardAnalyzer;
-  private Class<? extends Analyzer> analyzerClass;
+  private String analyzerClass;
-  private Map<String, Class<? extends Analyzer>> fieldAnalyzers;
+  private Map<String, String> fieldAnalyzers;
-    this.analyzerClass = analyzer.getClass();
+    this.analyzerClass = analyzer.getClass().getSimpleName();
-    this.analyzerClass = analyzer.getClass();
+    this.analyzerClass = analyzer.getClass().getSimpleName();
-  public Class<? extends Analyzer> getAnalyzerClass() {
+  public String getAnalyzerClass() {
-  public Map<String, Class<? extends Analyzer>> getFieldAnalyzers() {
+  public Map<String, String> getFieldAnalyzers() {
-    if (fieldAnalyzers != null && !fieldAnalyzers.isEmpty()) {
-      this.fieldAnalyzers = new HashMap<>();
-      for (Map.Entry<String, Analyzer> entry : fieldAnalyzers.entrySet()) {
-        // Null values are allowed in analyzers which means the default Analyzer is used
-        this.fieldAnalyzers.put(entry.getKey(), entry.getValue() == null ? null : entry.getValue().getClass());
+    this.fieldAnalyzers = new HashMap<>();
+    for (String field : fieldNames) {
+     if(fieldAnalyzers != null && !fieldAnalyzers.isEmpty())  {
+        this.fieldAnalyzers.put(field, fieldAnalyzers.get(field) == null ? StandardAnalyzer.class.getSimpleName() : fieldAnalyzers.get(field).getClass().getSimpleName());
+      } else {
+        this.fieldAnalyzers.put(field, StandardAnalyzer.class.getSimpleName());
-    LuceneIndexCreationProfile myProfile = (LuceneIndexCreationProfile) profile;
-    if (myProfile == null) {
+    LuceneIndexCreationProfile remoteProfile = (LuceneIndexCreationProfile) profile;
+    if (remoteProfile == null) {
-      if (!Arrays.equals(myProfile.getFieldNames(), getFieldNames())) {
-        result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELDS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELDS_3
-            .toString(myProfile.getIndexName(), regionPath, Arrays.toString(getFieldNames()),
-                Arrays.toString(myProfile.getFieldNames()));
+      if (!Arrays.equals(remoteProfile.getFieldNames(), getFieldNames())) {
+        return LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELDS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELDS_3
+            .toString(getIndexName(), regionPath, Arrays.toString(getFieldNames()), Arrays.toString(remoteProfile.getFieldNames()));
-      // Verify the field analyzer fields and classes are the same if either member sets field analyzers
-      if (myProfile.getFieldAnalyzers() != null || getFieldAnalyzers() != null) {
-        // Check for one member defining field analyzers while the other member does not
-        if (myProfile.getFieldAnalyzers() == null) {
-          result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELD_ANALYZERS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_NO_FIELD_ANALYZERS
-              .toString(myProfile.getIndexName(), regionPath, getFieldAnalyzers());
-        } else if (getFieldAnalyzers() == null) {
-          result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_NO_FIELD_ANALYZERS_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELD_ANALYZERS_2
-              .toString(myProfile.getIndexName(), regionPath, myProfile.getFieldAnalyzers());
-        } else {
-          // Both local and remote analyzers are set. Verify the sizes of the field analyzers are identical
-          if (myProfile.getFieldAnalyzers().size() != getFieldAnalyzers().size()) {
-            result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELD_ANALYZERS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELD_ANALYZERS_3
-                .toString(myProfile.getIndexName(), regionPath, getFieldAnalyzers(),
-                    myProfile.getFieldAnalyzers());
-          }
-
-          // Iterate the existing analyzers and compare them to the input analyzers
-          // Note: This is currently destructive to the input field analyzers map which should be ok since its a transient object.
-          for (Iterator<Map.Entry<String, Class<? extends Analyzer>>> i = myProfile.getFieldAnalyzers().entrySet().iterator(); i.hasNext(); ) {
-            Map.Entry<String, Class<? extends Analyzer>> entry = i.next();
-            // Remove the existing field's analyzer from the input analyzers
-            Class<? extends Analyzer> analyzerClass = getFieldAnalyzers().remove(entry.getKey());
-
-            // Verify the input field analyzer matches the current analyzer
-            if (analyzerClass == null && entry.getValue() != null) {
-              // The input field analyzers do not include the existing field analyzer
-              result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_NO_ANALYZER_ON_FIELD_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_3_ON_THAT_FIELD
-                  .toString(myProfile.getIndexName(), regionPath, entry.getKey(), entry.getValue().getName());
-              break;
-            } else if (analyzerClass != null && entry.getValue() == null) {
-              // The existing field analyzers do not include the input field analyzer
-              result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_ON_FIELD_3_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_NO_ANALYZER_ON_THAT_FIELD
-                  .toString(myProfile.getIndexName(), regionPath, analyzerClass.getName(), entry.getKey());
-              break;
-            } else {
-              if (analyzerClass != entry.getValue()) {
-                // The class of the input analyzer does not match the existing analyzer for the field
-                result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_ON_FIELD_3_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_4_ON_THAT_FIELD
-                    .toString(myProfile.getIndexName(), regionPath, analyzerClass.getName(), entry.getKey(), entry.getValue().getName());
-                break;
-              }
-            }
+      // Iterate the existing analyzers and compare them to the input analyzers
+      // Note: This is currently destructive to the input field analyzers map which should be ok since its a transient object.
+      if (!getFieldAnalyzers().equals(remoteProfile.getFieldAnalyzers())) {
+        if (getFieldAnalyzers().size() != remoteProfile.getFieldAnalyzers().size()) {
+          return LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELDS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELDS_3
+              .toString(getIndexName(), regionPath, 
+                  Arrays.toString(getFieldAnalyzers().keySet().toArray()),
+                  Arrays.toString(remoteProfile.getFieldAnalyzers().keySet().toArray()));
+        }
+        // now the 2 maps should have the same size
+        for (String field:getFieldAnalyzers().keySet()) {
+          if (!remoteProfile.getFieldAnalyzers().get(field).equals(getFieldAnalyzers().get(field))) {
+            return LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_ON_FIELD_3_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_4_ON_THAT_FIELD
+              .toString(getIndexName(), regionPath,
+                    getFieldAnalyzers().get(field), field,
+                    remoteProfile.getFieldAnalyzers().get(field)); 
-    DataSerializer.writeClass(this.analyzerClass, out);
+    DataSerializer.writeString(this.analyzerClass, out);
-    this.analyzerClass = (Class<? extends Analyzer>) DataSerializer.readClass(in);
+    this.analyzerClass = DataSerializer.readString(in);

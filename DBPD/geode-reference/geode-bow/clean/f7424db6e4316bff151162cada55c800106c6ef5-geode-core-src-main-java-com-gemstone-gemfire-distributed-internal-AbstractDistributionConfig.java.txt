GEODE-420: Amended method signature in SSLConfigurationFactory.java and SocketCreatorFactory.java to be more generic.
Deprecated Cluster-ssl-* configuration and replaced it with new ssl-* configuration properties.

-import com.gemstone.gemfire.distributed.SSLEnabledComponents;
-import com.gemstone.gemfire.internal.net.SocketCreator;
+import com.gemstone.gemfire.internal.net.SSLEnabledComponent;
+import com.gemstone.gemfire.internal.net.SocketCreator;
-    if (value != null && value.length() > 0 &&
-        !SocketCreator.isLocalHost(value)) {
+    if (value != null && value.length() > 0 && !SocketCreator.isLocalHost(value)) {
-    if (value != null && value.length() > 0 &&
-        !SocketCreator.isLocalHost(value)) {
+    if (value != null && value.length() > 0 && !SocketCreator.isLocalHost(value)) {
-    if (value != null && value.length() > 0 &&
-        !SocketCreator.isLocalHost(value)) {
+    if (value != null && value.length() > 0 && !SocketCreator.isLocalHost(value)) {
-        if(0 == portVal){
+        if (0 == portVal) {
-        }
-        else if (portVal < 1 || portVal > 65535) {
-          throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0_THE_PORT_1_WAS_NOT_GREATER_THAN_ZERO_AND_LESS_THAN_65536.toLocalizedString(new Object[] {value, Integer.valueOf(portVal)}));
+        } else if (portVal < 1 || portVal > 65535) {
+          throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0_THE_PORT_1_WAS_NOT_GREATER_THAN_ZERO_AND_LESS_THAN_65536
+            .toLocalizedString(new Object[] { value, Integer.valueOf(portVal) }));
-    if (!(value.equals(CLIENT_CONFLATION_PROP_VALUE_DEFAULT) ||
-          value.equals(CLIENT_CONFLATION_PROP_VALUE_ON) ||
-          value.equals(CLIENT_CONFLATION_PROP_VALUE_OFF))) {
+    if (!(value.equals(CLIENT_CONFLATION_PROP_VALUE_DEFAULT) || value.equals(CLIENT_CONFLATION_PROP_VALUE_ON) || value.equals(CLIENT_CONFLATION_PROP_VALUE_OFF))) {
-    if (value != null && value.length() > 0 &&
-        !SocketCreator.isLocalHost(value)) {
+    if (value != null && value.length() > 0 && !SocketCreator.isLocalHost(value)) {
-    if (value != null && value.length() > 0 &&
-        !SocketCreator.isLocalHost(value)) {
+    if (value != null && value.length() > 0 && !SocketCreator.isLocalHost(value)) {
-  protected String[] checkLegacySSLWhenSSLEnabledComponentsSet(String[] value) {
-    if (value != null && value.length > 0) {
-      for (String component : value) {
-        switch (component) {
-          case SSLEnabledComponents.ALL:
-          case SSLEnabledComponents.CLUSTER:
-          case SSLEnabledComponents.SERVER:
-          case SSLEnabledComponents.GATEWAY:
-          case SSLEnabledComponents.JMX:
-          case SSLEnabledComponents.HTTP_SERVICE:
-          case SSLEnabledComponents.LOCATOR:
-            continue;
-          default:
-            throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_COMPONENTS_0_INVALID_TRY_1.toLocalizedString(new Object[] {
-              value, StringUtils.join(new String[] {
-              SSLEnabledComponents.ALL,
-              SSLEnabledComponents.CLUSTER,
-              SSLEnabledComponents.SERVER,
-              SSLEnabledComponents.GATEWAY,
-              SSLEnabledComponents.JMX,
-              SSLEnabledComponents.HTTP_SERVICE,
-              SSLEnabledComponents.LOCATOR
-            }, ",")
-            }));
-        }
+  protected SSLEnabledComponent[] checkLegacySSLWhenSSLEnabledComponentsSet(SSLEnabledComponent[] value) {
+    for (SSLEnabledComponent component : value) {
+      switch (component) {
+        case ALL:
+        case CLUSTER:
+        case SERVER:
+        case GATEWAY:
+        case JMX:
+        case HTTP_SERVICE:
+        case LOCATOR:
+          continue;
+        default:
+          throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_COMPONENTS_0_INVALID_TRY_1.toLocalizedString(new Object[] {
+            value, StringUtils.join(new String[] {
+            SSLEnabledComponent.ALL.getConstant(),
+            SSLEnabledComponent.CLUSTER.getConstant(),
+            SSLEnabledComponent.SERVER.getConstant(),
+            SSLEnabledComponent.GATEWAY.getConstant(),
+            SSLEnabledComponent.JMX.getConstant(),
+            SSLEnabledComponent.HTTP_SERVICE.getConstant(),
+            SSLEnabledComponent.LOCATOR.getConstant()
+          }, ",")
+          }));
-      if (getJmxManagerSSLEnabled() || getHttpServiceSSLEnabled() || getServerSSLEnabled() || getGatewaySSLEnabled()) {
+    }
+    for (SSLEnabledComponent component : value) {
+      if (getClusterSSLEnabled() || getJmxManagerSSLEnabled() || getHttpServiceSSLEnabled() || getServerSSLEnabled() || getGatewaySSLEnabled()) {
-      if (attName.startsWith(SECURITY_PREFIX) ||
-          attName.startsWith(SSL_SYSTEM_PROPS_NAME) ||
-          attName.startsWith(SYS_PROP_NAME)) {
+      if (attName.startsWith(SECURITY_PREFIX) || attName.startsWith(SSL_SYSTEM_PROPS_NAME) || attName.startsWith(SYS_PROP_NAME)) {
-    checkAttribute(attName,attValue);
+    checkAttribute(attName, attValue);
-    m.put(NAME, "A name that uniquely identifies a member in its distributed system." +
-                " Multiple members in the same distributed system can not have the same name." +
-                " Defaults to \"\".");
+    m.put(NAME, "A name that uniquely identifies a member in its distributed system." + " Multiple members in the same distributed system can not have the same name." + " Defaults to \"\".");
-    m.put(CLUSTER_SSL_ENABLED, LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_NAME_0.toLocalizedString(Boolean.valueOf(DEFAULT_CLUSTER_SSL_ENABLED)));
+    m.put(CLUSTER_SSL_ENABLED, LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_NAME_0.toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ENABLED)));
-    m.put(CLUSTER_SSL_PROTOCOLS, LocalizedStrings.AbstractDistributionConfig_SSL_PROTOCOLS_NAME_0.toLocalizedString(DEFAULT_CLUSTER_SSL_PROTOCOLS));
+    m.put(CLUSTER_SSL_PROTOCOLS, LocalizedStrings.AbstractDistributionConfig_SSL_PROTOCOLS_NAME_0.toLocalizedString(DEFAULT_SSL_PROTOCOLS));
-    m.put(CLUSTER_SSL_CIPHERS, LocalizedStrings.AbstractDistributionConfig_SSL_CIPHERS_NAME_0.toLocalizedString(DEFAULT_CLUSTER_SSL_CIPHERS));
+    m.put(CLUSTER_SSL_CIPHERS, LocalizedStrings.AbstractDistributionConfig_SSL_CIPHERS_NAME_0.toLocalizedString(DEFAULT_SSL_CIPHERS));
-    m.put(CLUSTER_SSL_REQUIRE_AUTHENTICATION, LocalizedStrings.AbstractDistributionConfig_SSL_REQUIRE_AUTHENTICATION_NAME.toLocalizedString(Boolean.valueOf(DEFAULT_CLUSTER_SSL_REQUIRE_AUTHENTICATION)));
+    m.put(CLUSTER_SSL_REQUIRE_AUTHENTICATION, LocalizedStrings.AbstractDistributionConfig_SSL_REQUIRE_AUTHENTICATION_NAME.toLocalizedString(Boolean.valueOf(DEFAULT_SSL_REQUIRE_AUTHENTICATION)));
-    m.put(DISTRIBUTED_SYSTEM_ID, "An id that uniquely idenitifies this distributed system. " +
-                                 "Required when using portable data exchange objects and the WAN." +
-                                 "Must be the same on each member in this distributed system if set.");
+    m.put(DISTRIBUTED_SYSTEM_ID, "An id that uniquely idenitifies this distributed system. " + "Required when using portable data exchange objects and the WAN." + "Must be the same on each member in this distributed system if set.");
+    m.put(SSL_CIPHERS, "List of available SSL cipher suites that are to be enabled. Defaults to \"" + DEFAULT_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+    m.put(SSL_PROTOCOLS, "List of available SSL protocols that are to be enabled. Defaults to \"" + DEFAULT_SSL_PROTOCOLS + "\" meaning defaults of your provider.");
+    m.put(SSL_REQUIRE_AUTHENTICATION, "If set to false, ciphers and protocols that permit anonymous clients are allowed. Defaults to \"" + DEFAULT_SSL_REQUIRE_AUTHENTICATION + "\".");
+    m.put(SSL_KEYSTORE, "Location of the Java keystore file containing the certificate and private key.");
+    m.put(SSL_KEYSTORE_TYPE, "For Java keystore file format, this property has the value jks (or JKS).");
+    m.put(SSL_KEYSTORE_PASSWORD, "Password to access the private key from the keystore.");
+    m.put(SSL_TRUSTSTORE, "Location of the Java keystore file containing the collection of trusted certificates.");
+    m.put(SSL_TRUSTSTORE_PASSWORD, "Password to unlock the truststore.");
+

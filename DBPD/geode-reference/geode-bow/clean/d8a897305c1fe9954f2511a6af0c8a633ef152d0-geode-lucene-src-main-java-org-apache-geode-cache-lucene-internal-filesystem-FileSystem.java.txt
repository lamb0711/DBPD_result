GEODE-2643: Combine chunk and file region into a single region

* removed file and chunk count from stat
* removed tests that were doing checks against chunk bucketRegions

- * 
+ *
- * 
+ *
-import org.apache.geode.cache.Region;
-import java.util.concurrent.ConcurrentMap;
+import java.util.stream.Collectors;
- * 
+ *
- * 
+ *
-  private final Map<String, File> fileRegion;
-  private final Map<ChunkKey, byte[]> chunkRegion;
+  private final Map fileAndChunkRegion;
-   * Create filesystem that will store data in the two provided regions. The fileRegion contains
-   * metadata about the files, and the chunkRegion contains the actual data. If data from either
-   * region is missing or inconsistent, no guarantees are made about what this class will do, so
-   * it's best if these regions are colocated and in the same disk store to ensure the data remains
-   * together.
-   * 
-   * @param fileRegion the region to store metadata about the files
-   * @param chunkRegion the region to store actual file data.
+   * Create filesystem that will store data in the two provided regions. The fileAndChunkRegion
+   * contains metadata about the files, and the chunkRegion contains the actual data. If data from
+   * either region is missing or inconsistent, no guarantees are made about what this class will do,
+   * so it's best if these regions are colocated and in the same disk store to ensure the data
+   * remains together.
+   *
+   * @param fileAndChunkRegion the region to store metadata about the files
-  public FileSystem(Map<String, File> fileRegion, Map<ChunkKey, byte[]> chunkRegion,
-      FileSystemStats stats) {
-    this.fileRegion = fileRegion;
-    this.chunkRegion = chunkRegion;
+  public FileSystem(Map fileAndChunkRegion, FileSystemStats stats) {
+    this.fileAndChunkRegion = fileAndChunkRegion;
-    return fileRegion.keySet();
+    return (Collection<String>) fileAndChunkRegion.keySet().stream()
+        .filter(entry -> (entry instanceof String)).collect(Collectors.toList());
-    if (null != fileRegion.putIfAbsent(name, file)) {
+    if (null != fileAndChunkRegion.putIfAbsent(name, file)) {
-    if (null != fileRegion.putIfAbsent(name, file)) {
+    if (null != fileAndChunkRegion.putIfAbsent(name, file)) {
-    final File file = fileRegion.get(name);
+    final File file = (File) fileAndChunkRegion.get(name);
-    File file = fileRegion.remove(name);
+    File file = (File) fileAndChunkRegion.remove(name);
-        if (null == chunkRegion.remove(key)) {
+        if (null == fileAndChunkRegion.remove(key)) {
-    final File sourceFile = fileRegion.get(source);
+    final File sourceFile = (File) fileAndChunkRegion.get(source);
-    fileRegion.remove(source);
+    fileAndChunkRegion.remove(source);
-      while (chunkRegion.containsKey(key)) {
-        chunkRegion.remove(key);
+      while (fileAndChunkRegion.containsKey(key)) {
+        fileAndChunkRegion.remove(key);
-    final byte[] chunk = chunkRegion.get(key);
+    final byte[] chunk = (byte[]) fileAndChunkRegion.get(key);
-    chunkRegion.put(key, chunk);
+    fileAndChunkRegion.put(key, chunk);
-    fileRegion.put(file.getName(), file);
+    fileAndChunkRegion.put(file.getName(), file);
-  public Map<String, File> getFileRegion() {
-    return fileRegion;
+  public Map getFileAndChunkRegion() {
+    return fileAndChunkRegion;
-  public Map<ChunkKey, byte[]> getChunkRegion() {
-    return chunkRegion;
-  }
-

Merge branch 'release/1.5.0'

-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Iterator;
+import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.cache.DistributedRemoveAllOperation;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.EventID;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+import org.apache.geode.internal.cache.TXManagerImpl;
- * data.
+ * data. It is also used to implement non-transactional removeAlls, see:
+ * DistributedRemoveAllOperation.initMessage
-  private transient InternalDistributedSystem internalDs;
-
-  @Override
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
-  }
-
-   *
-    Collection replicates = r.getCacheDistributionAdvisor().adviseInitializedReplicates();
+    Collection<InternalDistributedMember> replicates =
+        r.getCacheDistributionAdvisor().adviseInitializedReplicates();
-      ArrayList l = new ArrayList(replicates);
+      ArrayList<InternalDistributedMember> l = new ArrayList<>(replicates);
-    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      InternalDistributedMember replicate = it.next();
+    for (InternalDistributedMember replicate : replicates) {
-        RemoveAllResponse response = send(replicate, event, data, dataCount, false,
-            DistributionManager.SERIAL_EXECUTOR, posDup);
-        response.waitForCacheException();
+        RemoveAllResponse response = send(replicate, event, data, dataCount, false, posDup);
+        response.waitForRemoteResponse();
-        List successfulKeys = result.getKeys();
+        List<Object> successfulKeys = result.getKeys();
+        @SuppressWarnings("rawtypes")
-      } catch (RemoteOperationException e) {
+      } catch (RegionDestroyedException | RemoteOperationException e) {
-              "RemoteRemoveAllMessage caught an unexpected exception during distribution", e);
+              "RemoteRemoveAllMessage caught an exception during distribution; retrying to another member",
+              e);
-  RemoteRemoveAllMessage(EntryEventImpl event, Set recipients, DirectReplyProcessor p,
+  RemoteRemoveAllMessage(EntryEventImpl event, DistributedMember recipient, DirectReplyProcessor p,
-      int processorType, boolean possibleDuplicate) {
-    super(recipients, event.getRegion().getFullPath(), p);
-    this.resetRecipients();
-    if (recipients != null) {
-      setRecipients(recipients);
-    }
+      boolean possibleDuplicate) {
+    super((InternalDistributedMember) recipient, event.getRegion().getFullPath(), p);
-   * @throws ForceReattemptException if the peer is no longer available
+   * @throws RemoteOperationException if the peer is no longer available
-      int processorType, boolean possibleDuplicate) throws RemoteOperationException {
-    // Assert.assertTrue(recipient != null, "RemoteRemoveAllMessage NULL recipient"); recipient can
-    // be null for event notifications
-    Set recipients = Collections.singleton(recipient);
-    RemoveAllResponse p = new RemoveAllResponse(event.getRegion().getSystem(), recipients);
-    RemoteRemoveAllMessage msg = new RemoteRemoveAllMessage(event, recipients, p, removeAllData,
-        removeAllDataCount, useOriginRemote, processorType, possibleDuplicate);
-    msg.setTransactionDistributed(event.getRegion().getCache().getTxManager().isDistributed());
-    Set failures = event.getRegion().getDistributionManager().putOutgoing(msg);
+      boolean possibleDuplicate) throws RemoteOperationException {
+    RemoveAllResponse p = new RemoveAllResponse(event.getRegion().getSystem(), recipient);
+    RemoteRemoveAllMessage msg = new RemoteRemoveAllMessage(event, recipient, p, removeAllData,
+        removeAllDataCount, useOriginRemote, possibleDuplicate);
+    Set<?> failures = event.getRegion().getDistributionManager().putOutgoing(msg);
-  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+  protected boolean operateOnRegion(ClusterDistributionManager dm, LocalRegion r, long startTime)
-  /* we need a event with content for waitForNodeOrCreateBucket() */
-   * @param r partitioned region
+   * @param r region
-    // create a base event and a op for RemoveAllMessage distributed btw redundant buckets
-            new VersionedObjectList(removeAllDataCount, true, dr.concurrencyChecksEnabled);
+            new VersionedObjectList(removeAllDataCount, true, dr.getConcurrencyChecksEnabled());
-                versions.addKeyAndVersion(removeAllData[i].key, ev.getVersionTag());
+                versions.addKeyAndVersion(removeAllData[i].getKey(), ev.getVersionTag());
-
-  // override reply processor type from PartitionMessage
-  RemoteOperationResponse createReplyProcessor(LocalRegion r, Set recipients, Object key) {
-    return new RemoveAllResponse(r.getSystem(), recipients);
-  }
-
-  // override reply message type from PartitionMessage
-  @Override
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
-      LocalRegion r, long startTime) {
-    ReplyMessage.send(member, procId, ex, getReplySender(dm), r != null && r.isInternalRegion());
-  }
-
-
-    /** Result of the RemoveAll operation */
-    public void process(final DM dm, final ReplyProcessor21 rp) {
+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {
-    public RemoveAllResponse(InternalDistributedSystem ds, Set recipients) {
-      super(ds, recipients, false);
+    public RemoveAllResponse(InternalDistributedSystem ds, DistributedMember recipient) {
+      super(ds, (InternalDistributedMember) recipient, false);

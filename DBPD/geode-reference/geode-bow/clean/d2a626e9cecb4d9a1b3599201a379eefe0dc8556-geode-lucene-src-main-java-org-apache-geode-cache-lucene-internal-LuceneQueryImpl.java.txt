GEODE-2410: Lucene afterPrimary and afterSecondary calls pass through the same crit section.

	* afterPrimary and afterSecondary calls are passed through the same critical section.
	* If the caller is primary bucket, it will try to acquire a Dlock on the bucket and create the index repo.
	* If it is secondary it will clean up the repo - close the writer and release the locks.
	* If the primary changes to secondary while waiting for indexes to be created, it will exit from the critical section without acquiring the lock.

-  private final static int MAX_TRIES = 500;
-    int numTries = 0;
-    while (entries == null && numTries++ < MAX_TRIES) {
-      try {
-        TopEntriesFunctionCollector collector = new TopEntriesFunctionCollector(context);
-        ResultCollector<TopEntriesCollector, TopEntries<K>> rc =
-            (ResultCollector<TopEntriesCollector, TopEntries<K>>) onRegion().withArgs(context)
-                .withCollector(collector).execute(LuceneFunction.ID);
-        entries = rc.getResult();
-      } catch (FunctionException e) {
-        if (e.getCause() instanceof LuceneQueryException) {
-          throw new LuceneQueryException(e);
-        } else if (e.getCause() instanceof BucketNotFoundException) {
-          logger.debug("Retrying due to index on bucket not found:" + e);
-          // throw e;
-        } else {
-          e.printStackTrace();
-          throw e;
-        }
+    try {
+      TopEntriesFunctionCollector collector = new TopEntriesFunctionCollector(context);
+      ResultCollector<TopEntriesCollector, TopEntries<K>> rc =
+          (ResultCollector<TopEntriesCollector, TopEntries<K>>) onRegion().withArgs(context)
+              .withCollector(collector).execute(LuceneFunction.ID);
+      entries = rc.getResult();
+    } catch (FunctionException e) {
+      if (e.getCause() instanceof LuceneQueryException) {
+        throw new LuceneQueryException(e);
+      } else {
+        e.printStackTrace();
+        throw e;

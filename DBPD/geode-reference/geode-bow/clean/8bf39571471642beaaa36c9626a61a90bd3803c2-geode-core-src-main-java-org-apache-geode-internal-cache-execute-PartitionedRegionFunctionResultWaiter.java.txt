Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * ResultReciever (which could be resultCollector?)will be instantiated and will be used
- * to send messages and receive results from other nodes.
- * It takes a set of nodes to which functionExecution message has to be sent. Creates one message for each and sends
- * it to each of them. Then it gets result in processData where it adds them to the resultCollector.
+ * ResultReciever (which could be resultCollector?)will be instantiated and will be used to send
+ * messages and receive results from other nodes. It takes a set of nodes to which functionExecution
+ * message has to be sent. Creates one message for each and sends it to each of them. Then it gets
+ * result in processData where it adds them to the resultCollector.
-  
+
-  
-  public PartitionedRegionFunctionResultWaiter(InternalDistributedSystem sys,
-      int regionId, ResultCollector rc, final Function function,
-      PartitionedRegionFunctionResultSender sender) {
-    super(sys,rc,function,sender);
+
+  public PartitionedRegionFunctionResultWaiter(InternalDistributedSystem sys, int regionId,
+      ResultCollector rc, final Function function, PartitionedRegionFunctionResultSender sender) {
+    super(sys, rc, function, sender);
-  
+
-  public DistributionMessage createRequestMessage(
-      Set<InternalDistributedMember> singleton,
-      FunctionStreamingResultCollector processor, boolean isReExecute, boolean isFnSerializationReqd) {
+  public DistributionMessage createRequestMessage(Set<InternalDistributedMember> singleton,
+      FunctionStreamingResultCollector processor, boolean isReExecute,
+      boolean isFnSerializationReqd) {
+
-   * Returns normally if succeeded to get data, otherwise throws an exception
-   * Have to wait outside this function and when getResult() is called. For the
-   * time being get the correct results.
+   * Returns normally if succeeded to get data, otherwise throws an exception Have to wait outside
+   * this function and when getResult() is called. For the time being get the correct results.
-      Map<InternalDistributedMember, FunctionRemoteContext> recipMap,
-      PartitionedRegion pr, AbstractExecution execution) {
+      Map<InternalDistributedMember, FunctionRemoteContext> recipMap, PartitionedRegion pr,
+      AbstractExecution execution) {
-    if (recipMap.isEmpty()){
+    if (recipMap.isEmpty()) {
-    for (InternalDistributedMember member : recipMap.keySet()){
+    for (InternalDistributedMember member : recipMap.keySet()) {
-    
-    PRFunctionStreamingResultCollector processor = new PRFunctionStreamingResultCollector(
-        this, this.sys, recipientsSet, this.rc, functionObject, pr, execution);
-    
+
+    PRFunctionStreamingResultCollector processor = new PRFunctionStreamingResultCollector(this,
+        this.sys, recipientsSet, this.rc, functionObject, pr, execution);
+
-    
-    for (Map.Entry<InternalDistributedMember, FunctionRemoteContext> entry :  recipMap.entrySet()) {
+
+    for (Map.Entry<InternalDistributedMember, FunctionRemoteContext> entry : recipMap.entrySet()) {
-  protected DistributionMessage createRequestMessage(
-      InternalDistributedMember recipient, ReplyProcessor21 processor,
-      FunctionRemoteContext context) {
+  protected DistributionMessage createRequestMessage(InternalDistributedMember recipient,
+      ReplyProcessor21 processor, FunctionRemoteContext context) {
-    PartitionedRegionFunctionStreamingMessage msg = new PartitionedRegionFunctionStreamingMessage(
-        recipient, this.regionId, processor,context);
+    PartitionedRegionFunctionStreamingMessage msg =
+        new PartitionedRegionFunctionStreamingMessage(recipient, this.regionId, processor, context);
-   * This function processes the result data it receives. Adds the result to
-   * resultCollector as it gets the objects. On getting the last msg from all
-   * the sender it will call endResult on ResultSender.
+   * This function processes the result data it receives. Adds the result to resultCollector as it
+   * gets the objects. On getting the last msg from all the sender it will call endResult on
+   * ResultSender.
-  public void processData(Object result, boolean lastMsg,
-      DistributedMember memberID) {
+  public void processData(Object result, boolean lastMsg, DistributedMember memberID) {
-    ((PartitionedRegionFunctionResultSender)resultSender).lastResult(
-        result, completelyDone, this.reply, memberID);
+    ((PartitionedRegionFunctionResultSender) resultSender).lastResult(result, completelyDone,
+        this.reply, memberID);
-  }  
+  }

Merge branch 'release/1.0.0-incubating.M1'

- * ========================================================================= 
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved. 
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- * =========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.Comparator;
+import com.gemstone.gemfire.cache.query.Struct;
+import com.gemstone.gemfire.cache.query.internal.CompiledGroupBySelect;
+import com.gemstone.gemfire.cache.query.internal.CumulativeNonDistinctResults;
+import com.gemstone.gemfire.cache.query.internal.CumulativeNonDistinctResults.Metadata;
+import com.gemstone.gemfire.cache.query.internal.NWayMergeResults;
+import com.gemstone.gemfire.cache.query.internal.OrderByComparator;
+import com.gemstone.gemfire.cache.query.internal.ResultsSet;
+import com.gemstone.gemfire.cache.query.internal.SortedResultsBag;
+import com.gemstone.gemfire.cache.query.internal.SortedStructBag;
+import com.gemstone.gemfire.cache.query.internal.StructSet;
+import com.gemstone.gemfire.cache.query.internal.parse.OQLLexerTokenTypes;
+import com.gemstone.gemfire.cache.query.internal.types.StructTypeImpl;
+import com.gemstone.gemfire.cache.query.internal.utils.PDXUtils;
+import com.gemstone.gemfire.internal.Version;
-  private volatile Map node2bucketIds;
+  private volatile Map<InternalDistributedMember,List<Integer>> node2bucketIds;
-    this.node2bucketIds = Collections.EMPTY_MAP;
+    this.node2bucketIds = Collections.emptyMap();
+    //check if sender is pre gfe_90. In that case the results coming from them are not sorted
+    // we will have to sort it
+    boolean sortNeeded = false;
+    List<CompiledSortCriterion> orderByAttribs = null;
+    if(sender.getVersionObject().compareTo(Version.GFE_90) < 0 ) {
+      CompiledSelect cs = this.query.getSimpleSelect();
+      if(cs != null && cs.isOrderBy()) {
+        sortNeeded = true;
+        orderByAttribs = cs.getOrderByAttrs();
+      }
+      
+      
+    }
+    if(sortNeeded) {
+      objects = sortIncomingData(objects, orderByAttribs);
+    }
-      if (!QueryMonitor.isLowMemory()) {
-        results.add(objects);
+      if (!QueryMonitor.isLowMemory()) {        
+          results.add(objects);        
+
+  //TODO Asif: optimize it by creating a Sorted SelectResults Object at the time of fromData , so 
+  // that processData already recieves ordered data.
+  private List sortIncomingData(List objects,
+      List<CompiledSortCriterion> orderByAttribs) {
+    ObjectType resultType = cumulativeResults.getCollectionType().getElementType();
+    ExecutionContext local = new ExecutionContext(null, this.pr.cache);
+    Comparator comparator = new OrderByComparator(orderByAttribs, resultType, local);
+    boolean nullAtStart = !orderByAttribs.get(0).getCriterion();
+    final SelectResults newResults; 
+    //Asif: There is a bug in the versions < 9.0, such that the struct results coming from the 
+    // bucket nodes , do not contain approrpiate ObjectTypes. All the projection fields have 
+    // have the types as ObjectType. The resultset being created here has the right more selective type.
+    // so the addition of objects throw exception due to type mismatch. To handle this problem, instead
+    // of adding the struct objects as is, add fieldValues.
+    if(resultType != null && resultType.isStructType() )  {
+      SortedStructBag sortedStructBag = new SortedStructBag(comparator, (StructType) resultType, 
+          nullAtStart);
+      for(Object o : objects) {
+        Struct s = (Struct)o;
+        sortedStructBag.addFieldValues(s.getFieldValues());
+      }
+      newResults = sortedStructBag;
+    }else {
+      newResults = new SortedResultsBag(comparator,resultType, nullAtStart);
+      newResults.addAll(objects) ;
+    }
+        
+   
+    objects = newResults.asList();
+    return objects;
+  }
+  
-    HashMap n2b = new HashMap(this.node2bucketIds);
+    HashMap<InternalDistributedMember,List<Integer>> n2b = new HashMap<InternalDistributedMember,List<Integer>>(this.node2bucketIds);
-        for (Iterator itr = n2b.entrySet().iterator(); itr.hasNext();) {
-          Map.Entry me = (Map.Entry) itr.next();
-          final InternalDistributedMember rcp = (InternalDistributedMember) me.getKey();
-          final List bucketIds = (List) me.getValue();
+        for (Iterator<Map.Entry<InternalDistributedMember,List<Integer>>> itr = n2b.entrySet().iterator(); itr.hasNext();) {
+          Map.Entry<InternalDistributedMember , List<Integer>> me =  itr.next();
+          final InternalDistributedMember rcp =  me.getKey();
+          final List<Integer> bucketIds =  me.getValue();
-  public void queryBuckets(final TestHook th) throws QueryException, InterruptedException {
+  public SelectResults queryBuckets(final TestHook th) throws QueryException, InterruptedException {
-    addResultsToResultSet();
+    return addResultsToResultSet();
-    Iterator memberToBucketList = node2bucketIds.entrySet().iterator();
+    Iterator<Map.Entry<InternalDistributedMember,List<Integer>>> memberToBucketList = node2bucketIds.entrySet().iterator();
-      Map.Entry<InternalDistributedMember, ArrayList<Integer>> e = (Map.Entry)memberToBucketList.next();
+      Map.Entry<InternalDistributedMember, List<Integer>> e = memberToBucketList.next();
-  private void addResultsToResultSet() throws QueryException {
+  private SelectResults addResultsToResultSet() throws QueryException {
-    boolean isStructBag = false;
-    boolean isResultBag = false;
-
+    
+
+    int limit = -1; // -1 indicates no limit wsa specified in the query
+    // passed as null. Not sure if it can happen in real life situation.
+    // So instead of modifying test , using a null check in constructor
+    CompiledSelect cs = null;
+
-    int limit = -1; //-1 indicates no limit wsa specified in the query
-    //passed as null. Not sure if it can happen in real life situation.
-    //So instead of modifying test , using a null check in constructor
-    CompiledSelect cs =null;
-    
-    // Indicates whether to check for PdxInstance and convert them to 
-    // domain object. 
-    // In case of local queries the domain objects are stored in the result set
-    // for client/server queries PdxInstance are stored in result set. 
-    boolean getDomainObjectForPdx;
-    //indicated results from remote nodes need to be deserialized
-    //for local queries
-    boolean getDeserializedObject = false;
-    
-    if(this.query != null) {
-      cs =  this.query.getSimpleSelect();
+
+    if (this.query != null) {
+      cs = this.query.getSimpleSelect();
-      isDistinct = (cs != null)? cs.isDistinct():true;
-      isCount = (cs != null)? cs.isCount():false;
-    }
-    
-    if (isCount && !isDistinct) {
-      addTotalCountForMemberToResults(limit);
-      return;
-    } 
-    
-    if (this.cumulativeResults instanceof StructBag) {
-    	isStructBag = true;
-    } else if (this.cumulativeResults instanceof ResultsBag) {
-    	isResultBag = true;
-    	//TODO:Asif: Idealy the isOrdered should  be the sufficient condtion. Remove the orderbyAttribs null check
-    } else if (this.cumulativeResults.getCollectionType().isOrdered() && cs.getOrderByAttrs() != null) {
-      // If its a sorted result set, sort local and remote results using query.
-      buildSortedResult(cs, limit);
-      return;
+      isDistinct = (cs != null) ? cs.isDistinct() : true;
+      isCount = (cs != null) ? cs.isCount() : false;
+    if (isCount && !isDistinct) {
+      addTotalCountForMemberToResults(limit);
+      return this.cumulativeResults;
+    }
+
+    boolean isGroupByResults = cs.getType() == CompiledValue.GROUP_BY_SELECT;
+    if(isGroupByResults) {
+      SelectResults baseResults = null;
+      CompiledGroupBySelect cgs = (CompiledGroupBySelect) cs;
+      if(cgs.getOrderByAttrs() != null && !cgs.getOrderByAttrs().isEmpty()) {
+        baseResults = this.buildSortedResult(cs, limit);        
+      }else {
+        baseResults = this.buildCumulativeResults(isDistinct, limit);
+      }
+      ExecutionContext context = new ExecutionContext(null, pr.cache);
+      context.setIsPRQueryNode(true);
+      return cgs.applyAggregateAndGroupBy(baseResults, context);
+    }else {
+
+      if (this.cumulativeResults.getCollectionType().isOrdered()
+        && cs.getOrderByAttrs() != null) {
+      // If its a sorted result set, sort local and remote results using query.
+        return buildSortedResult(cs, limit);        
+      }else {  
+        return buildCumulativeResults(isDistinct, limit);
+      }
+    }
+  }
+
+  private SelectResults buildCumulativeResults(boolean isDistinct, int limit) {
+    // Indicates whether to check for PdxInstance and convert them to
+    // domain object.
+    // In case of local queries the domain objects are stored in the result set
+    // for client/server queries PdxInstance are stored in result set.
+    boolean getDomainObjectForPdx;
+    // indicated results from remote nodes need to be deserialized
+    // for local queries
+    boolean getDeserializedObject = false;
+    int numElementsInResult = 0;
+    
+    ObjectType elementType = this.cumulativeResults.getCollectionType().getElementType();
+    boolean isStruct = elementType != null && elementType.isStructType();
+  
-    for (Map.Entry<InternalDistributedMember, Collection<Collection>> e : this.resultsPerMember.entrySet()) {
+    
+    List<CumulativeNonDistinctResults.Metadata> collectionsMetadata =null;
+    List<Collection> results = null;
+    
+    if(isDistinct) {
+      if(isStruct) {
+        StructType stype = (StructType)elementType;
+        this.cumulativeResults = new StructSet(stype);
+      }else {
+        this.cumulativeResults = new ResultsSet(elementType);
+      }
+    }else {
+      collectionsMetadata = new ArrayList<CumulativeNonDistinctResults.Metadata>();
+      results =  new ArrayList<Collection>();
+    }
+    
+    for (Map.Entry<InternalDistributedMember, Collection<Collection>> e : this.resultsPerMember
+        .entrySet()) {
-        getDomainObjectForPdx = !(this.pr.getCache().getPdxReadSerializedByAnyGemFireServices());
+        getDomainObjectForPdx = !(this.pr.getCache()
+            .getPdxReadSerializedByAnyGemFireServices());
-        if(!getDeserializedObject && !((DefaultQuery)this.query).isKeepSerialized()){
+        if (!getDeserializedObject
+            && !((DefaultQuery) this.query).isKeepSerialized()) {
-      
-      for (Collection res : e.getValue()) {
-        checkLowMemory();
-        //final TaintableArrayList res = (TaintableArrayList) e.getValue();      
-        if (res != null) {
-          if (isDebugEnabled) {
-            logger.debug("Query Result from member :{}: {}", e.getKey(), res.size());
-          }
-          if (limit == -1 && !getDomainObjectForPdx && !getDeserializedObject && 
-              (!isDistinct && localResults /* This check is to convert PdxString in projection lists to String */)) {
-            this.cumulativeResults.addAll(res);
-          } else {
+      if (!isDistinct) {
+        CumulativeNonDistinctResults.Metadata wrapper = CumulativeNonDistinctResults
+            .getCollectionMetadata(getDomainObjectForPdx,
+                getDeserializedObject, localResults);
+       
+          for (Collection res : e.getValue()) {
+            results.add(res);
+            collectionsMetadata.add(wrapper);    
+          }        
+      } else {
+        for (Collection res : e.getValue()) {
+          checkLowMemory();
+          // final TaintableArrayList res = (TaintableArrayList) e.getValue();
+          if (res != null) {
+            if (isDebugEnabled) {
+              logger.debug("Query Result from member :{}: {}", e.getKey(),
+                  res.size());
+            }
+
+            boolean[] objectChangedMarker = new boolean[1];
+            
-              if (isStructBag) {
-                StructImpl simpl = (StructImpl) obj;
-                if (getDomainObjectForPdx) {
-                  try {
-                    if (simpl.isHasPdx()) {
-                      occurence = ((ResultsBag) this.cumulativeResults).addAndGetOccurence(simpl.getPdxFieldValues());
-                    } else {
-                      occurence = ((ResultsBag) this.cumulativeResults).addAndGetOccurence(simpl.getFieldValues());
-                    }
-                  } catch (Exception ex) {
-                    throw new QueryException(
-                        "Unable to retrieve domain object from PdxInstance while building the ResultSet. "
-                        + ex.getMessage());
-                  }
-                } else {
-                  Object[] values = simpl.getFieldValues();
-                  if(getDeserializedObject){
-                    for (int i = 0; i < values.length; i++) {
-                      if(values[i] instanceof VMCachedDeserializable){
-                        values[i] = ((VMCachedDeserializable)values[i]).getDeserializedForReading();
-                      }
-                    }
-                  }
-                  /* This is to convert PdxString to String */                
-                  if (simpl.isHasPdx() && isDistinct && localResults) {
-                    for (int i = 0; i < values.length; i++) {
-                      if(values[i] instanceof PdxString){
-                        values[i] = ((PdxString)values[i]).toString();
-                      }
-                    }
-                  }
-                  occurence = ((ResultsBag) this.cumulativeResults).addAndGetOccurence(values);
-                }
-              } else {
-                if (getDomainObjectForPdx) {
-                  if(obj instanceof PdxInstance){
-                    try {
-                      obj = ((PdxInstance) obj).getObject();
-                    } catch (Exception ex) {
-                      throw new QueryException(
-                          "Unable to retrieve domain object from PdxInstance while building the ResultSet. "
-                          + ex.getMessage());
-                    }
-                  }
-                  else if (obj instanceof PdxString){
-                    obj = ((PdxString)obj).toString();
-                  }
-                } else if (isDistinct && localResults && obj instanceof PdxString) {
-                  /* This is to convert PdxString to String */
-                  obj = ((PdxString)obj).toString();
-                }
-                
-                if (isResultBag) {
-                  if(getDeserializedObject && obj instanceof VMCachedDeserializable) {
-                    obj = ((VMCachedDeserializable)obj).getDeserializedForReading();
-                  }
-                    occurence = ((ResultsBag) this.cumulativeResults)
-                  .addAndGetOccurence(obj);
-                } else {
-                  if(getDeserializedObject && obj instanceof VMCachedDeserializable) {
-                      obj = ((VMCachedDeserializable)obj).getDeserializedForReading();
-                  } 
-                  
-                  // Resultset or StructSet, SortedResultSet, SortedStructSet.
-                  // Once we start passing Object[] in the List , the below should
-                  // change for StructSet and possibly SortedStructSet
-                  occurence = this.cumulativeResults.add(obj) ? 1 : 0;
-                }
-              }
-
+              obj = PDXUtils.convertPDX(obj, isStruct,
+                  getDomainObjectForPdx, getDeserializedObject, localResults, objectChangedMarker, true);
+              boolean elementGotAdded = isStruct? ((StructSet)this.cumulativeResults).addFieldValues((Object[])obj):
+                this.cumulativeResults.add(obj);
+              occurence = elementGotAdded ? 1 : 0;
-              if (occurence == 1 || (occurence > 1 && !isDistinct)) {
+              if (occurence == 1) {
-    
-    if (prQueryTraceInfoList != null && this.query.isTraced() && logger.isInfoEnabled()) {
+
+    if (prQueryTraceInfoList != null && this.query.isTraced()
+        && logger.isInfoEnabled()) {
-      sb.append(LocalizedStrings.PartitionedRegion_QUERY_TRACE_LOG.toLocalizedString(this.query.getQueryString())).append("\n");
-      for (PRQueryTraceInfo queryTraceInfo: prQueryTraceInfoList) {
+      sb.append(
+          LocalizedStrings.PartitionedRegion_QUERY_TRACE_LOG
+              .toLocalizedString(this.query.getQueryString())).append("\n");
+      for (PRQueryTraceInfo queryTraceInfo : prQueryTraceInfoList) {
-      logger.info(sb.toString());;
+      logger.info(sb.toString());
+      ;
+    if (!isDistinct) {
+      this.cumulativeResults =  new CumulativeNonDistinctResults(results, limit,
+          this.cumulativeResults.getCollectionType().getElementType(),
+          collectionsMetadata);
+
+    } 
+    return this.cumulativeResults;
+  
-  private void buildSortedResult(CompiledSelect cs, int limit) throws QueryException {
-    List projAttrs = cs.getProjectionAttributes();
-    List orderByAttrs = cs.getOrderByAttrs();
-    //boolean isCount = cs.isCount();
-    //List pIterators = cs.getIterators();
-    
-    String eMsg = "Unable to apply order-by on the partition region cumulative results.";
-    Assert.assertTrue(!(orderByAttrs == null), eMsg + " Null order-by attributes.");
-    List iterators = cs.getIterators();
-   
-    String projFields = null;
-    //Map<String, Boolean> orderByFields = new LinkedHashMap<String,Boolean>();
-    List<String> projectionFields = new LinkedList<String>();
+  private SelectResults buildSortedResult(CompiledSelect cs, int limit) throws QueryException {
-      // Evaluate projection attributes.
-      //Create local execution context
-    //If order by clause is present , then compute dependency locally
-      
-      ExecutionContext localContext = new QueryExecutionContext(this.parameters,
+     ExecutionContext localContext = new QueryExecutionContext(this.parameters,
-      localContext.newScope(0);
-
-      Iterator iter = iterators.iterator();
-      while (iter.hasNext()) {
-
-        CompiledIteratorDef iterDef = (CompiledIteratorDef)iter.next();
-        // compute dependencies on this iter first before adding its
-        // RuntimeIterator to the current scope.
-        // this makes sure it doesn't bind attributes to itself
-        localContext.addDependencies(cs, iterDef
-            .computeDependencies(localContext));
-        RuntimeIterator rIter = iterDef.getRuntimeIterator(localContext);
-        localContext.addToIndependentRuntimeItrMap(iterDef);
-        localContext.bindIterator(rIter);
-
-      }
-
-      ObjectType type = cs.prepareResultType(localContext);
-      StringBuffer tempQueryBuffer = new StringBuffer(" order by ");
-      if (type.isStructType()) {
-        StructType structType = (StructType)type;
-        String[] fieldNames = structType.getFieldNames();
-        if (projAttrs == null) {
-          // Evaluate path iterators, in case of multiple paths appropriate
-          // alias needs to be added.
-          // E.g.: select distinct * from /r p, p.positions.values pos order by
-          // p.ID =>
-          // select distinct * from $1 m order by r.p.ID
-          List<RuntimeIterator> runTimeItrs = localContext
-              .getCurrentIterators();
-          Iterator<RuntimeIterator> itr = runTimeItrs.iterator();
-          while (itr.hasNext()) {
-            StringBuffer temp = new StringBuffer();
-            RuntimeIterator rIter = itr.next();
-            rIter.setIndexInternalID(null);
-            rIter.generateCanonicalizedExpression(temp, localContext);
-            projectionFields.add(temp.toString());
-          }
-
-        }
-        else {
-          Iterator<Object[]> itr = projAttrs.iterator();
-          while (itr.hasNext()) {
-            StringBuffer temp = new StringBuffer();
-            Object[] values = itr.next();
-            ((CompiledValue)values[1]).generateCanonicalizedExpression(temp,
-                localContext);
-            projectionFields.add(temp.toString());
-          }
-        }
-        // Evaluate order by attributes.
-        for (int i = 0; i < orderByAttrs.size(); i++) {
-          Object o = orderByAttrs.get(i);
-          if (o instanceof CompiledSortCriterion) {
-            CompiledSortCriterion csc = (CompiledSortCriterion)o;
-            CompiledValue cv = csc.getExpr();
-            StringBuffer temp = new StringBuffer();
-            cv.generateCanonicalizedExpression(temp, localContext);
-            Iterator<String> projFieldItr = projectionFields.iterator();
-            int index = 0;
-            boolean foundMatch = false;
-            String orderBy = temp.toString();
-            while (projFieldItr.hasNext() && !foundMatch) {
-              String projStr = projFieldItr.next();
-              // int indexOfDot = orderBy.indexOf('.');
-              if (orderBy.equals(projStr)) {
-                // exact match , just append the field name
-                tempQueryBuffer.append(' ');
-                tempQueryBuffer.append(fieldNames[index]);
-                tempQueryBuffer.append(' ');
-                tempQueryBuffer.append(csc.getCriterion() ? " desc " : " asc ");
-                tempQueryBuffer.append(',');
-                foundMatch = true;
-              }
-              else if (orderBy.startsWith(projStr)) {
-                tempQueryBuffer.append(fieldNames[index]);
-                tempQueryBuffer.append(temp.substring(projStr.length()));
-
-                tempQueryBuffer.append(' ');
-                tempQueryBuffer.append(csc.getCriterion() ? " desc " : " asc ");
-                tempQueryBuffer.append(',');
-                foundMatch = true;
-              }
-              ++index;
-            }
-            if (!foundMatch) {
-              throw new QueryException("Order by clause " + orderBy
-                  + " not derivable from any projection attribute");
-            }
-
-            // orderByFields.put(temp.toString(), !csc.getCriterion());
-          }
-        }
-        tempQueryBuffer.deleteCharAt(tempQueryBuffer.length() - 1);
-
-      }
-      else {
-        String projStr = null;
-        if (projAttrs == null) {
-          List<RuntimeIterator> runTimeItrs = localContext
-              .getCurrentIterators();
-          Iterator<RuntimeIterator> itr = runTimeItrs.iterator();
-
-          StringBuffer temp = new StringBuffer();
-          RuntimeIterator rIter = itr.next();
-          rIter.setIndexInternalID(null);
-          rIter.generateCanonicalizedExpression(temp, localContext);
-          projStr = temp.toString();
-        }
-
-        else {
-          Iterator<Object[]> itr = projAttrs.iterator();
-          StringBuffer temp = new StringBuffer();
-          Object[] values = itr.next();
-          ((CompiledValue)values[1]).generateCanonicalizedExpression(temp,
-              localContext);
-          projStr = temp.toString();
-
-        }
-        // Evaluate order by attributes.
-        for (int i = 0; i < orderByAttrs.size(); i++) {
-          Object o = orderByAttrs.get(i);
-
-          if (o instanceof CompiledSortCriterion) {
-            CompiledSortCriterion csc = (CompiledSortCriterion)o;
-            CompiledValue cv = csc.getExpr();
-            StringBuffer temp = new StringBuffer();
-            cv.generateCanonicalizedExpression(temp, localContext);
-
-            String orderBy = temp.toString();
-            // int indexOfDot = temp.indexOf(".");
-
-            if (orderBy.equals(projStr)) {
-              // exact match , just append the field name
-              tempQueryBuffer.append(' ');
-              tempQueryBuffer.append("iter");
-              tempQueryBuffer.append(' ');
-
-            }
-            else if (orderBy.startsWith(projStr)) {
-              tempQueryBuffer.append(' ');
-              String attr = temp.substring(projStr.length() + 1);
-              // escape reserved keywords
-              attr = checkReservedKeyword(attr);
-              tempQueryBuffer.append(attr);
-            }
-            else {
-              throw new QueryException("Order by clause " + orderBy
-                  + " not derivable from projection attribute " + projStr);
-            }
-
-            tempQueryBuffer.append(' ');
-            tempQueryBuffer.append(csc.getCriterion() ? " desc " : " asc ");
-            tempQueryBuffer.append(',');
-          }
-        }
-        tempQueryBuffer.deleteCharAt(tempQueryBuffer.length() - 1);
-      }
-
-      tempQueryBuffer.insert(0, " SELECT DISTINCT * FROM $1 iter ");
-      if (logger.isDebugEnabled()) {
-        logger.debug("The temp query generated to evaluate order-by on PR commulative results: {}", tempQueryBuffer.toString());
-      }
-
-      DefaultQuery q = (DefaultQuery)this.pr.getCache().getQueryService()
-          .newQuery(tempQueryBuffer.toString());
-      ExecutionContext context;
-      
-      final DistributedMember me = this.pr.getMyId();
-
+      List<Collection> allResults = new ArrayList<Collection>();
-            context = new QueryExecutionContext((new Object[] { res }), this.pr
-                .getCache(), this.cumulativeResults, q);
-            q.executeUsingContext(context);
+            allResults.add(res);
+      
+      this.cumulativeResults = new NWayMergeResults(allResults, cs.isDistinct(), limit, cs.getOrderByAttrs(), 
+          localContext, cs.getElementTypeForOrderByQueries());
+      return this.cumulativeResults;
+    
-    if (cv instanceof CompiledID)  {
+    if (cv.getType() == OQLLexerTokenTypes.Identifier)  {
-        if (cv instanceof CompiledPath || cv instanceof CompiledIndexOperation) {
-          if (cv instanceof CompiledIndexOperation) {
+        if (cv.getType() == CompiledPath.PATH || cv.getType() == OQLLexerTokenTypes.TOK_LBRACK) {
+          if (cv.getType() == OQLLexerTokenTypes.TOK_LBRACK) {
-        } else if (cv instanceof CompiledOperation) {
+        } else if (cv.getType() == OQLLexerTokenTypes.METHOD_INV) {
-      } while (!(cv instanceof CompiledID));
+      } while (!(cv.getType() == OQLLexerTokenTypes.Identifier));
-      if (cv instanceof CompiledID) {
+      if (cv.getType() == OQLLexerTokenTypes.Identifier) {
-  private void buildSortedResultBackup(CompiledSelect cs, int limit) throws QueryException {
-    List projAttrs = cs.getProjectionAttributes();
-    List orderByAttrs = cs.getOrderByAttrs();
-    List pIterators = cs.getIterators();
-    //boolean isDistinct = (cs != null)? cs.isDistinct():true;
-    
-    String eMsg = "Unable to apply order-by on the partition region cumulative results.";
-    Assert.assertTrue(!(orderByAttrs == null), eMsg + " Null order-by attributes.");
-    
-    StringBuffer fromPath =  new StringBuffer();
-    String projFields = null;
-    HashMap<String, String> orderByFields = new HashMap<String, String>();
-    
-    try {
-      // Evaluate projection attributes.
-      String fromIter = "";
-      if (projAttrs == null) {
-        // Evaluate path iterators, in case of multiple paths appropriate alias needs to be added.
-        // E.g.: select distinct * from /r p, p.positions.values pos order by p.ID =>
-        //         select distinct * from $1 m order by r.p.ID
-        for (int i = 1; i < pIterators.size(); i++) {
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) pIterators.get(i-1);   
-          fromIter += (iterDef.getName() + ("."));
-        }
-      } else if (projAttrs.size() == 1) {
-        // In case single projections, it should be treated as the ordered field.
-        // E.g: select distinct status from /r order by status => select distinct * from $1 p order by p 
-        Object projDef[] = (Object[])projAttrs.get(0);
-        if (projDef[1] instanceof CompiledID) {
-          projFields = ((CompiledID)projDef[1]).getId();
-        } else if (projDef[1] instanceof CompiledPath) {
-          CompiledPath cp = (CompiledPath)projDef[1];
-          projFields = ((CompiledID)cp.getReceiver()).getId() + "." + cp.getTailID();
-        } else if (projDef[1] instanceof CompiledOperation) {
-          // Function call.
-          CompiledOperation cp = (CompiledOperation)projDef[1];
-          projFields = ((CompiledID)cp.getReceiver(null)).getId() + "." + cp.getMethodName() + "()";
-        } else {
-          throw new QueryException("Failed to evaluate projection attributes. " + eMsg);
-        }
-      }
-     
-      // Evaluate order by attributes.
-      for (int i = 0; i < orderByAttrs.size(); i++) {
-        Object o = orderByAttrs.get(i);
-        String orderByClause = "";
-        if (o instanceof CompiledSortCriterion) {
-          CompiledSortCriterion csc = (CompiledSortCriterion)o;
-          CompiledValue cv = csc.getExpr();  
-          
-          // field with multiple level like p.pos.secId
-          if (cv instanceof CompiledID)  {
-            // It will be p.pos.secId
-            orderByClause = ((CompiledID)cv).getId() + orderByClause;
-          } else {
-            do {
-            if (cv instanceof CompiledPath || cv instanceof CompiledIndexOperation) {
-              if (cv instanceof CompiledIndexOperation) {
-                CompiledIndexOperation cio = (CompiledIndexOperation)cv;
-                CompiledLiteral cl = (CompiledLiteral)cio.getExpression();
-                StringBuffer sb = new StringBuffer();
-                cl.generateCanonicalizedExpression(sb, null);
-                cv = ((CompiledIndexOperation)cv).getReceiver();
-                if (sb.length() > 0) {
-                  orderByClause = "[" + sb.toString() + "]" + orderByClause;
-                }
-              }
-              orderByClause = ("." + ((CompiledPath)cv).getTailID() + orderByClause);
-            } else if (cv instanceof CompiledOperation) {
-              // Function call.
-              orderByClause = "." + ((CompiledOperation)cv).getMethodName() + "()" + orderByClause;
-            } else if (cv instanceof CompiledIndexOperation) {
-              StringBuffer sb = new StringBuffer();
-              
-              //((CompiledIndexOperation)cv).generateCanonicalizedExpression(sb, null);
-              //if (cv2 instanceof CompiledPath) {
-              
-              //orderByClause = "." + ((CompiledIndexOperation)cv).+ "()";
-              //}
-            } else {
-              throw new QueryException("Failed to evaluate order by attributes, found unsupported type  " + cv.getType() + " " + eMsg);
-            }
-            // Ignore subsequent paths.
-            //do {
-                cv = cv.getReceiver();
-            } while (!(cv instanceof CompiledID));
-            
-            if (cv instanceof CompiledID) {
-              orderByClause = ((CompiledID)cv).getId() + orderByClause;
-              // Append region iterator alias. p
-              if (i == 0) {
-                fromPath.append(((CompiledID)cv).getId());
-                //if ((i+1) < orderByAttrs.size()) {
-                //  fromPath.append(", ");
-                //}
-              }
-            }
-            
-          } 
-          /*
-          else if (cv instanceof CompiledOperation) {
-            orderByClause = ((CompiledID)cv).getId() + orderByClause;
-          } else {
-            throw new QueryException("Failed to evaluate order-by attributes. " + eMsg);              
-          }
-          */
-          orderByFields.put(fromIter + orderByClause, (csc.getCriterion()? " desc " : " asc "));
-        }
-      }
-
-      StringBuffer tmpSortQuery =  new StringBuffer("SELECT DISTINCT * FROM $1 ");    
-      if (projFields != null && orderByFields.containsKey(projFields)) {
-        // Select distinct p.status from /region p order by p.status asc
-        // => Select distinct * from $1 p order by p asc
-        if (fromPath.length() > 0) {
-          tmpSortQuery.append(fromPath).append(" ORDER BY ").append(fromPath).append(" ").append(orderByFields.get(projFields));
-        } else {
-          tmpSortQuery.append(fromPath).append("p ORDER BY p").append(orderByFields.get(projFields));
-        }
-      } else {
-        /*
-        if (fromPath.length() > 0) {
-          tmpSortQuery.append(fromPath).append(" ORDER BY ").append(fromPath).append(".");
-        } else {
-        */
-        tmpSortQuery.append(fromPath).append(" ORDER BY ");
-        //}
-        Iterator iter = orderByFields.entrySet().iterator();
-        while (iter.hasNext()) {
-          Map.Entry<String, String> e = (Map.Entry<String, String>)iter.next();
-          tmpSortQuery.append(e.getKey()).append(" ").append(e.getValue());
-          if (iter.hasNext()) {
-            tmpSortQuery.append(", ");
-          }
-        }
-      }
-
-      if (logger.isDebugEnabled()) {
-        logger.debug("The temp query generated to evaluate order-by on PR commulative results: {}", tmpSortQuery);
-      }
-      
-      DefaultQuery q = (DefaultQuery)this.pr.getCache().getQueryService().newQuery(tmpSortQuery.toString());
-      ExecutionContext context;
-      for (Iterator i=this.resultsPerMember.values().iterator(); i.hasNext(); ) {
-        final TaintableArrayList res = (TaintableArrayList)i.next();
-        if (res!=null && res.isConsumable()) {
-          context = new QueryExecutionContext((new Object[] {res}), this.pr.getCache(), this.cumulativeResults, q);
-          q.executeUsingContext(context);
-          res.clear();
-        }
-      }   
-    } catch (Exception ex) {
-      throw new QueryException("Unable to apply order-by on the partition region cumulative results.", ex);
-    }
-  }
-  Map buildNodeToBucketMap() throws QueryException
+  Map<InternalDistributedMember, List<Integer>> buildNodeToBucketMap() throws QueryException
-  private Map buildNodeToBucketMapForBuckets(final Set<Integer> bucketIdsToConsider) 
+  private Map<InternalDistributedMember, List<Integer>> buildNodeToBucketMapForBuckets(final Set<Integer> bucketIdsToConsider) 
-    final HashMap<InternalDistributedMember, ArrayList<Integer>> ret = new 
-    HashMap<InternalDistributedMember, ArrayList<Integer>>();
+    final HashMap<InternalDistributedMember, List<Integer>> ret = new 
+    HashMap<InternalDistributedMember,List<Integer>>();
-    final ArrayList<Integer> bucketIds = new ArrayList<Integer>();
+    final List<Integer> bucketIds = new ArrayList<Integer>();
-      final ArrayList<Integer> buckets = new ArrayList<Integer>();
+      final List<Integer> buckets = new ArrayList<Integer>();
-      List bucketList = (List)this.node2bucketIds.get(me);
+      List<Integer> bucketList = this.node2bucketIds.get(me);
-    for (Iterator itr = this.node2bucketIds.entrySet().iterator(); itr.hasNext(); ) {
-      Map.Entry entry = (Map.Entry)itr.next();
-      List blist = (List)entry.getValue();
-      for (Iterator itr2 = blist.iterator(); itr2.hasNext(); ) {
-        Integer bid = (Integer)itr2.next();
+    for (Iterator<Map.Entry<InternalDistributedMember,List<Integer>>> itr = this.node2bucketIds.entrySet().iterator(); itr.hasNext(); ) {
+      Map.Entry<InternalDistributedMember,List<Integer>> entry = itr.next();
+      List<Integer> blist = entry.getValue();
+      for (Iterator<Integer> itr2 = blist.iterator(); itr2.hasNext(); ) {
+        Integer bid = itr2.next();
+    public ObjectType getResultType() {
+      return PartitionedRegionQueryEvaluator.this.cumulativeResults.getCollectionType().getElementType();
+    }

Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import com.gemstone.gemfire.distributed.internal.*;
-import com.gemstone.gemfire.internal.*;
-import com.gemstone.gemfire.internal.admin.*;
-import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Properties;
+import java.util.Set;
-import java.util.*;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import com.gemstone.gemfire.internal.Assert;
+import com.gemstone.gemfire.internal.admin.SSLConfig;
+import com.gemstone.gemfire.internal.admin.TransportConfig;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-  private final boolean mcastDiscovery;
+  private int vmKind = -1;
-  
-  public RemoteTransportConfig(int port) {
-    this(port, null);
-  }
-  
-  /**
-   * Constructs a simple transport config that specifies just a port.
-   * The port must be the one a DistributionLocator is listening
-   * to on the local host. 
-   */
-  public RemoteTransportConfig(int port, String bindAddress) {
-    if (bindAddress == null) {
-      this.bindAddress = DistributionConfig.DEFAULT_BIND_ADDRESS;
-    } else {
-      this.bindAddress = bindAddress;
-    }
-    this.sslConfig = new SSLConfig();
-    this.mcastEnabled = false;
-    this.mcastDiscovery = false;
-    this.tcpDisabled = false;
-    this.disableAutoReconnect = false;
-    this.mcastId = null;
-    this.ids = Collections.singleton(new DistributionLocatorId(port, bindAddress));
-    this.membershipPortRange = 
-       getMembershipPortRangeString(DistributionConfig.DEFAULT_MEMBERSHIP_PORT_RANGE);
-  }
-  public RemoteTransportConfig(DistributionConfig config) {
+  public RemoteTransportConfig(DistributionConfig config, int vmKind) {
+    this.vmKind = vmKind;
-      if (!this.mcastEnabled) {
-        // loner system
-        this.mcastDiscovery = false;
-        this.ids = Collections.EMPTY_SET;
-      }
-      else {
-        // multicast discovery
-        this.mcastDiscovery = true;
-        this.ids = Collections.singleton(this.mcastId);
-      }
+      // loner system
+      this.ids = Collections.EMPTY_SET;
-      // locator-based discovery
-      this.mcastDiscovery = false;
-
-    boolean isMcastDiscovery, 
-    int tcpPort)
+    int tcpPort, int vmKind)
-    this.mcastDiscovery = isMcastDiscovery;
+    this.vmKind = vmKind;
-  /**
-   * Returns true if config picked multicast.
-   * Returns false if config picked locators.
-   */
-  public boolean isMcastDiscovery() {
-    return this.mcastDiscovery;
-  }
+  public int getVmKind() {
+    return this.vmKind;
+  }
+  
-//System.out.println("RemoteTransportConfig.mcastEnabled=" + this.mcastEnabled);
-//System.out.println("RemoteTransportConfig.mcastDiscovery=" + this.mcastDiscovery);
-//Thread.currentThread().dumpStack();
-    if (!this.mcastDiscovery) {
-      // Create locator string
-      StringBuffer locators = new StringBuffer();
-      for (Iterator iter = this.ids.iterator(); iter.hasNext(); ) {
-        DistributionLocatorId locator =
+    // Create locator string
+    StringBuffer locators = new StringBuffer();
+    for (Iterator iter = this.ids.iterator(); iter.hasNext(); ) {
+      DistributionLocatorId locator =
-        if (!locator.isMcastId()) {
-          String baddr = locator.getBindAddress();
-          if (baddr != null && baddr.trim().length() > 0) {
-            locators.append(baddr);
-          }
-          else {
-            locators.append(locator.getHost().getCanonicalHostName());
-          }
-          locators.append("[");
-          locators.append(locator.getPort());
-          locators.append("]");
+      if (!locator.isMcastId()) {
+        String baddr = locator.getBindAddress();
+        if (baddr != null && baddr.trim().length() > 0) {
+          locators.append(baddr);
+        }
+        else {
+          locators.append(locator.getHost().getCanonicalHostName());
+        }
+        locators.append("[");
+        locators.append(locator.getPort());
+        locators.append("]");
-          if (iter.hasNext()) {
-            locators.append(",");
-          }
+        if (iter.hasNext()) {
+          locators.append(",");
-
-      props.setProperty(DistributionConfig.LOCATORS_NAME,
-                        locators.toString());
+
+    props.setProperty(DistributionConfig.LOCATORS_NAME,
+        locators.toString());
+
-        && (this.mcastDiscovery == other.mcastDiscovery)
-    return this.ids.hashCode() + (isMcastDiscovery() ? 1 : 0);
+    return this.ids.hashCode();

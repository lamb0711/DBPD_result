Merge branch 'release/1.3.0'

-import org.apache.geode.CancelException;
-import org.apache.geode.DataSerializer;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.distributed.internal.DistributionConfigImpl;
-import org.apache.geode.distributed.internal.DistributionStats;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.PoolStatHelper;
-import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
-import org.apache.geode.internal.DSFIDFactory;
-import org.apache.geode.internal.GemFireVersion;
-import org.apache.geode.internal.Version;
-import org.apache.geode.internal.VersionedDataInputStream;
-import org.apache.geode.internal.VersionedDataOutputStream;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.cache.tier.Acceptor;
-import org.apache.geode.internal.cache.tier.sockets.HandShake;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.net.SocketCreator;
-import org.apache.geode.internal.net.SocketCreatorFactory;
-import org.apache.geode.internal.security.SecurableCommunicationChannel;
-import org.apache.logging.log4j.Logger;
-
-import java.text.SimpleDateFormat;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.CancelException;
+import org.apache.geode.DataSerializer;
+import org.apache.geode.SystemFailure;
+import org.apache.geode.cache.IncompatibleVersionException;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.DistributionConfigImpl;
+import org.apache.geode.distributed.internal.DistributionStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.distributed.internal.PoolStatHelper;
+import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
+import org.apache.geode.internal.DSFIDFactory;
+import org.apache.geode.internal.GemFireVersion;
+import org.apache.geode.internal.Version;
+import org.apache.geode.internal.VersionedDataInputStream;
+import org.apache.geode.internal.VersionedDataOutputStream;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.tier.CommunicationMode;
+import org.apache.geode.internal.cache.tier.sockets.ClientProtocolProcessor;
+import org.apache.geode.internal.cache.tier.sockets.ClientProtocolService;
+import org.apache.geode.internal.cache.tier.sockets.HandShake;
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.net.SocketCreatorFactory;
+import org.apache.geode.internal.security.SecurableCommunicationChannel;
+
+   * 0 - special indicator of a non-gossip message from a client<br>
+  public final static int NON_GOSSIP_REQUEST_VERSION = 0;
+  /**
+   * For the new client-server protocol, which ignores the usual handshake mechanism.
+   */
+  public static final byte PROTOBUF_CLIENT_SERVER_PROTOCOL = (byte) 110;
+
+  private final InternalLocator internalLocator;
+  private final ClientProtocolService clientProtocolService;
+
+  /**
+   * returns the message handler used for client/locator communications processing
+   */
+  public ClientProtocolService getClientProtocolService() {
+    return clientProtocolService;
+  }
+
-      ThreadGroup threadGroup, String threadName) {
+      ThreadGroup threadGroup, String threadName, InternalLocator internalLocator,
+      ClientProtocolService clientProtocolService) {
+    this.internalLocator = internalLocator;
+    this.clientProtocolService = clientProtocolService;
-    // this.log.info("TcpServer@"+System.identityHashCode(this)+" join() invoked. Server
-    // thread="+serverThread+"@"+System.identityHashCode(serverThread)+";alive="+serverThread.isAlive());
-  private void processRequest(final Socket sock) {
+  private void processRequest(final Socket socket) {
-        sock.setSoTimeout(READ_TIMEOUT);
-        getSocketCreator().configureServerSSLSocket(sock);
+        socket.setSoTimeout(READ_TIMEOUT);
+        getSocketCreator().configureServerSSLSocket(socket);
-          input = new DataInputStream(sock.getInputStream());
+          input = new DataInputStream(socket.getInputStream());
-              + (sock.getInetAddress().getHostAddress() + ":" + sock.getPort()), e);
+              + (socket.getInetAddress().getHostAddress() + ":" + socket.getPort()), e);
-        int gossipVersion = readGossipVersion(sock, input);
+        int gossipVersion = readGossipVersion(socket, input);
-        if (gossipVersion <= getCurrentGossipVersion()
+        if (gossipVersion == NON_GOSSIP_REQUEST_VERSION) {
+          if (input.readUnsignedByte() == PROTOBUF_CLIENT_SERVER_PROTOCOL
+              && Boolean.getBoolean("geode.feature-protobuf-protocol")) {
+            if (clientProtocolService == null) {
+              // this shouldn't happen.
+              log.error("Client protocol service not initialized but a request was received");
+              socket.close();
+              throw new IOException(
+                  "Client protocol service not initialized but a request was received");
+            } else {
+              try (ClientProtocolProcessor pipeline =
+                  clientProtocolService.createProcessorForLocator(internalLocator)) {
+                pipeline.processMessage(input, socket.getOutputStream());
+              } catch (IncompatibleVersionException e) {
+                // should not happen on the locator as there is no handshake.
+                log.error("Unexpected exception in client message processing", e);
+              }
+            }
+          } else {
+            rejectUnknownProtocolConnection(socket, gossipVersion);
+          }
+        } else if (gossipVersion <= getCurrentGossipVersion()
+
+          if (Version.GFE_71.compareTo(versionOrdinal) <= 0) {
+            // Recent versions of TcpClient will send the version ordinal
+            versionOrdinal = input.readShort();
+          }
+
+          if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
+            log.debug("Locator reading request from " + socket.getInetAddress() + " with version "
+                + Version.fromOrdinal(versionOrdinal, false));
+          }
+          input = new VersionedDataInputStream(input, Version.fromOrdinal(versionOrdinal, false));
+          request = DataSerializer.readObject(input);
+          if (log.isDebugEnabled()) {
+            log.debug("Locator received request " + request + " from " + socket.getInetAddress());
+          }
+          if (request instanceof ShutdownRequest) {
+            shuttingDown = true;
+            // Don't call shutdown from within the worker thread, see java bug #6576792.
+            // Closing the socket will cause our acceptor thread to shutdown the executor
+            this.serverSocketPortAtClose = srv_sock.getLocalPort();
+            srv_sock.close();
+            response = new ShutdownResponse();
+          } else if (request instanceof InfoRequest) {
+            response = handleInfoRequest(request);
+          } else if (request instanceof VersionRequest) {
+            response = handleVersionRequest(request);
+          } else {
+            response = handler.processRequest(request);
+          }
+
+          handler.endRequest(request, startTime);
+
+          startTime = DistributionStats.getStatTime();
+          if (response != null) {
+            DataOutputStream output = new DataOutputStream(socket.getOutputStream());
+            if (versionOrdinal != Version.CURRENT_ORDINAL) {
+              output =
+                  new VersionedDataOutputStream(output, Version.fromOrdinal(versionOrdinal, false));
+            }
+            DataSerializer.writeObject(response, output);
+            output.flush();
+          }
+
+          handler.endResponse(request, startTime);
-          try {
-            sock.getOutputStream().write("unknown protocol version".getBytes());
-            sock.getOutputStream().flush();
-          } catch (IOException e) {
-            log.debug(
-                "exception in sending reply to process using unknown protocol " + gossipVersion, e);
-          }
-          sock.close();
-          return;
+          rejectUnknownProtocolConnection(socket, gossipVersion);
-        if (Version.GFE_71.compareTo(versionOrdinal) <= 0) {
-          // Recent versions of TcpClient will send the version ordinal
-          versionOrdinal = input.readShort();
-        }
-
-        if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
-          log.debug("Locator reading request from " + sock.getInetAddress() + " with version "
-              + Version.fromOrdinal(versionOrdinal, false));
-        }
-        input = new VersionedDataInputStream(input, Version.fromOrdinal(versionOrdinal, false));
-        request = DataSerializer.readObject(input);
-        if (log.isDebugEnabled()) {
-          log.debug("Locator received request " + request + " from " + sock.getInetAddress());
-        }
-        if (request instanceof ShutdownRequest) {
-          shuttingDown = true;
-          // Don't call shutdown from within the worker thread, see java bug #6576792.
-          // Closing the socket will cause our acceptor thread to shutdown the executor
-          this.serverSocketPortAtClose = srv_sock.getLocalPort();
-          srv_sock.close();
-          response = new ShutdownResponse();
-        } else if (request instanceof InfoRequest) {
-          response = handleInfoRequest(request);
-        } else if (request instanceof VersionRequest) {
-          response = handleVersionRequest(request);
-        } else {
-          response = handler.processRequest(request);
-        }
-
-        handler.endRequest(request, startTime);
-
-        startTime = DistributionStats.getStatTime();
-        if (response != null) {
-          DataOutputStream output = new DataOutputStream(sock.getOutputStream());
-          if (versionOrdinal != Version.CURRENT_ORDINAL) {
-            output =
-                new VersionedDataOutputStream(output, Version.fromOrdinal(versionOrdinal, false));
-          }
-          DataSerializer.writeObject(response, output);
-          output.flush();
-        }
-
-        handler.endResponse(request, startTime);
-
-        if (sock != null) {
-          sender = sock.getInetAddress().getHostAddress();
+        if (socket != null) {
+          sender = socket.getInetAddress().getHostAddress();
-        if (sock != null) {
-          sender = sock.getInetAddress().getHostAddress();
+        if (socket != null) {
+          sender = socket.getInetAddress().getHostAddress();
-          if (!sock.isClosed()) {
+          if (!socket.isClosed()) {
-        if (sock != null) {
-          sender = sock.getInetAddress().getHostAddress();
+        if (socket != null) {
+          sender = socket.getInetAddress().getHostAddress();
-          sock.close();
+          socket.close();
+  private void rejectUnknownProtocolConnection(Socket socket, int gossipVersion)
+      throws IOException {
+    try {
+      socket.getOutputStream().write("unknown protocol version".getBytes());
+      socket.getOutputStream().flush();
+    } catch (IOException e) {
+      log.debug("exception in sending reply to process using unknown protocol " + gossipVersion, e);
+    }
+    socket.close();
+  }
+
-    if (firstByte >= Acceptor.CLIENT_TO_SERVER) {
+    if (CommunicationMode.isValidMode(firstByte)) {
+

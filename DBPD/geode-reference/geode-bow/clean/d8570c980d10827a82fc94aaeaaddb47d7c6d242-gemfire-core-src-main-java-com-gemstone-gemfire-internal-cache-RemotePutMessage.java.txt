GEODE-324: defer deserialization of old value in PR put

When a PR put returns the old value our internal messages were deserializing
the values before we get back to the user thread that initiated the operation.
If a thread local class loader is used for the class we need to load during
deserialization then the early deserialization will fail.

Now the deserialization is delayed until the serialized old value gets through
our messaging layer and back to the thread that performed the pr put.

Added junit tests that verify that both PutReplyMessage classes no longer
deserialize their old value.

-
-    Object oldValue;
+    private Object oldValue;
-    private PutReplyMessage(int processorId,
+    // unit tests may call this constructor
+    PutReplyMessage(int processorId,
-    /** Return oldValue in deserialized form */
+    /** Return oldValue as a byte[] or as a CachedDeserializable.
+     * This method used to deserialize a CachedDeserializable but that is too soon.
+     * This method is called during message processing. The deserialization needs
+     * to be deferred until we get back to the application thread which happens
+     * for this oldValue when they call EntryEventImpl.getOldValue.
+     */
-      if (this.oldValue instanceof CachedDeserializable) {
-        return ((CachedDeserializable)this.oldValue).getDeserializedValue(null, null);
-      }
-    @Override
+    public static void oldValueToData(DataOutput out, Object ov, boolean ovIsSerialized) throws IOException {
+      if (ovIsSerialized && ov != null) {
+        byte[] oldValueBytes;
+        if (ov instanceof byte[]) {
+          oldValueBytes = (byte[]) ov;
+          DataSerializer.writeObject(new VMCachedDeserializable(oldValueBytes), out);
+        } else if (ov instanceof CachedDeserializable) {
+          if (ov instanceof StoredObject) {
+            ((StoredObject) ov).sendAsCachedDeserializable(out);
+          } else {
+            DataSerializer.writeObject(ov, out);
+          }
+        } else {
+          oldValueBytes = EntryEventImpl.serialize(ov);
+          DataSerializer.writeObject(new VMCachedDeserializable(oldValueBytes), out);
+        }
+      } else {
+        DataSerializer.writeObject(ov, out);
+      }
+      
+    }
+    
+     @Override
-      if (this.oldValueIsSerialized) {
-        byte[] oldValueBytes = (byte[]) this.oldValue;
-        out.write(oldValueBytes);
-      } else {
-        DataSerializer.writeObject(this.oldValue, out);
-      }
+      oldValueToData(out, getOldValue(), this.oldValueIsSerialized);
-      // isSerialized does not matter.
-      // toData will just call writeObject
-      // and fromData will just call readObject
+      this.oldValueIsSerialized = isSerialized;
-      if (isSerialized) {
-        this.oldValueIsSerialized = true;
-      }
-      this.oldValue = ov;
+      importOldObject(ov, isSerialized);

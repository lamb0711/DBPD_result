Merge remote-tracking branch 'upstream/develop' into develop

+import java.net.UnknownHostException;
-import org.apache.geode.SystemFailure;
+  static final String NATIVE_VERSION = "Native version";
+
+  static final String RUNNING_ON = "Running on";
+
-    pw.println("Native version: " + getNativeCodeVersion());
-    printHostInfo(pw);
+    pw.println(NATIVE_VERSION + ": " + getNativeCodeVersion());
+    pw.println(getRunningOnInfo());
-  private void printHostInfo(PrintWriter pw) throws Error {
+  private static String getRunningOnInfo() {
+    String line = getLocalHost() + ", " + Runtime.getRuntime().availableProcessors() + " cpu(s), "
+        + getOsArchitecture() + ' ' + getOsName() + ' ' + getOsVersion() + ' ';
+    return String.format(RUNNING_ON + ": %s", line);
+  }
+
+  private static String getLocalHost() {
-      String sb = SocketCreator.getLocalHost().toString() + ", "
-          + Runtime.getRuntime().availableProcessors() + " cpu(s), " + getOsArchitecture() + ' '
-          + getOsName() + ' ' + getOsVersion() + ' ';
-      pw.println(String.format("Running on: %s", sb));
-    } catch (VirtualMachineError err) {
-      SystemFailure.initiateFailure(err);
-      // If this ever returns, rethrow the error. We're poisoned
-      // now, so don't let this thread continue.
-      throw err;
-    } catch (Throwable t) {
-      // Whenever you catch Error or Throwable, you must also
-      // catch VirtualMachineError (see above). However, there is
-      // _still_ a possibility that you are dealing with a cascading
-      // error condition, so you also need to check to see if the JVM
-      // is still usable:
-      SystemFailure.checkFailure();
+      return SocketCreator.getLocalHost().toString();
+    } catch (UnknownHostException e) {
+      return e.getMessage();

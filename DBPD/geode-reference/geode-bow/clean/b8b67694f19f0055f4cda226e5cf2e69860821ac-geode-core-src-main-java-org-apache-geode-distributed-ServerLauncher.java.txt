Merge branch 'develop' into feature/GEODE-7049

+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+import org.apache.geode.internal.process.FileControllableProcess;
+  private final ServerLauncherCacheProvider serverLauncherCacheProvider;
+  private final Supplier<ControllableProcess> controllableProcessFactory;
+    serverLauncherCacheProvider = builder.getServerLauncherCacheProvider();
+    controllableProcessFactory = builder.getControllableProcessFactory();
-        process = new ControllableProcess(controlHandler, new File(getWorkingDirectory()),
-            ProcessType.SERVER, isForcing());
+        process = getControllableProcess();
-          startCacheServer(cache, startTime);
+          startCacheServer(cache);
+        awaitStartupTasks(cache, startTime);
+
-    ServiceLoader<ServerLauncherCacheProvider> loader =
-        ServiceLoader.load(ServerLauncherCacheProvider.class);
+    Iterable<ServerLauncherCacheProvider> loader = getServerLauncherCacheProviders();
+  private Iterable<ServerLauncherCacheProvider> getServerLauncherCacheProviders() {
+    return serverLauncherCacheProvider != null
+        ? Collections.singleton(serverLauncherCacheProvider)
+        : ServiceLoader.load(ServerLauncherCacheProvider.class);
+  }
+
-   * @param startTime the system clock time at which the start method was called
-  @VisibleForTesting
-  void startCacheServer(final Cache cache, long startTime) throws IOException {
+  private void startCacheServer(final Cache cache) throws IOException {
+  }
+  private void awaitStartupTasks(Cache cache, long startTime) {
-    ((InternalResourceManager) cache.getResourceManager())
-        .runWhenStartupTasksComplete(afterStartup, exceptionAction);
+    CompletableFuture<Void> startupTasks =
+        ((InternalResourceManager) cache.getResourceManager())
+            .allOfStartupTasks();
+
+    startupTasks
+        .thenRun(afterStartup)
+        .exceptionally((throwable) -> {
+          exceptionAction.accept(throwable);
+          return null;
+        })
+        .join();
+  private ControllableProcess getControllableProcess()
+      throws IOException, FileAlreadyExistsException, PidUnavailableException {
+    return controllableProcessFactory != null
+        ? controllableProcessFactory.get()
+        : new FileControllableProcess(controlHandler, new File(getWorkingDirectory()),
+            ProcessType.SERVER, isForcing());
+  }
+
+    private ServerLauncherCacheProvider serverLauncherCacheProvider;
+    private Supplier<ControllableProcess> controllableProcessFactory;
-      return this.startupExceptionAction;
+      return startupExceptionAction;
+    }
+
+    /**
+     * Sets the ServerLauncherCacheProvider to use when creating the cache.
+     *
+     * @param serverLauncherCacheProvider the cache provider to use
+     * @return this builder
+     */
+    Builder setServerLauncherCacheProvider(
+        ServerLauncherCacheProvider serverLauncherCacheProvider) {
+      this.serverLauncherCacheProvider = serverLauncherCacheProvider;
+      return this;
+    }
+
+    /**
+     * Gets the ServerLauncherCacheProvider to use when creating the cache.
+     *
+     * @return the cache provider
+     */
+    ServerLauncherCacheProvider getServerLauncherCacheProvider() {
+      return serverLauncherCacheProvider;
+    }
+
+    /**
+     * Sets the factory to use to get a {@code ControllableProcess} when starting the server.
+     *
+     * @param controllableProcessFactory the controllable process factory to use
+     * @return this builder
+     */
+    Builder setControllableProcessFactory(
+        Supplier<ControllableProcess> controllableProcessFactory) {
+      this.controllableProcessFactory = controllableProcessFactory;
+      return this;
+    }
+
+    /**
+     * Gets the factory used to get a {@code ControllableProcess} when starting the server.
+     *
+     * @return the controllable process factory
+     */
+    Supplier<ControllableProcess> getControllableProcessFactory() {
+      return controllableProcessFactory;

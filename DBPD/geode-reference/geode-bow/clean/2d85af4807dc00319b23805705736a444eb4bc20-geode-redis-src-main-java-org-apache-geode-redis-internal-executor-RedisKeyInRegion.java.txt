GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

-import org.apache.geode.redis.internal.RegionProvider;
-class RedisKeyInRegion {
-  private Region localRegion;
-  private RegionProvider regionProvider;
+public class RedisKeyInRegion implements RedisKeyCommands {
+  protected final Region<ByteArrayWrapper, RedisData> region;
-  public RedisKeyInRegion(Region localRegion, RegionProvider regionProvider) {
-    this.localRegion = localRegion;
-    this.regionProvider = regionProvider;
+  @SuppressWarnings("unchecked")
+  public RedisKeyInRegion(Region region) {
+    this.region = region;
+  @Override
-    RedisData redisData = (RedisData) localRegion.get(key);
+    RedisData redisData = getRedisData(key);
-    boolean result = localRegion.remove(key) != null;
-    if (result) {
-      regionProvider.cancelKeyExpiration(key);
-    }
-    return result;
+    return region.remove(key) != null;
+  @Override
-    return localRegion.containsKey(key);
+    return getRedisData(key) != null;
+  }
+
+  @Override
+  public long pttl(ByteArrayWrapper key) {
+    RedisData redisData = getRedisData(key);
+    if (redisData == null) {
+      return -2;
+    }
+    return redisData.pttl(region, key);
+  }
+
+  @Override
+  public int pexpireat(ByteArrayWrapper key, long timestamp) {
+    RedisData redisData = getRedisData(key);
+    if (redisData == null) {
+      return 0;
+    }
+    long now = System.currentTimeMillis();
+    if (now >= timestamp) {
+      // already expired
+      del(key);
+    } else {
+      redisData.setExpirationTimestamp(region, key, timestamp);
+    }
+    return 1;
+  }
+
+  @Override
+  public int persist(ByteArrayWrapper key) {
+    RedisData redisData = getRedisData(key);
+    if (redisData == null) {
+      return 0;
+    }
+    return redisData.persist(region, key);
+  }
+
+  @Override
+  public String type(ByteArrayWrapper key) {
+    RedisData redisData = getRedisData(key);
+    if (redisData == null) {
+      return "none";
+    }
+    return redisData.getType().toString();
+  }
+
+  protected RedisData getRedisData(ByteArrayWrapper key) {
+    return getRedisDataOrDefault(key, null);
+  }
+
+  protected RedisData getRedisDataOrDefault(ByteArrayWrapper key, RedisData defaultValue) {
+    RedisData result = region.get(key);
+    if (result != null) {
+      if (result.hasExpired()) {
+        region.remove(key);
+        result = null;
+      }
+    }
+    if (result == null) {
+      return defaultValue;
+    } else {
+      return result;
+    }

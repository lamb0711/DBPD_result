GEODE-8175: remove unsupported redis commands (#5146)

Removed list and zset commands.
Removed redis HyperLog commands.
Removed redis transaction commands.
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import org.apache.geode.cache.CacheTransactionManager;
-import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.cache.TransactionException;
-import org.apache.geode.cache.TransactionId;
-import org.apache.geode.cache.UnsupportedOperationInTransactionException;
-import org.apache.geode.cache.query.QueryInvocationTargetException;
-import org.apache.geode.cache.query.RegionNotFoundException;
- * command. It abstracts transactions, provides access to the {@link RegionProvider} and anything
+ * command. It provides access to the {@link RegionProvider} and anything
-  /**
-   * TransactionId for any transactions started by this client
-   */
-  private TransactionId transactionID;
-
-  /**
-   * Queue of commands for a given transaction
-   */
-  private Queue<Command> transactionQueue;
-    this.transactionID = null;
-    this.transactionQueue = null; // Lazy
-    } else if (cause instanceof RegionCreationException) {
-      logger.error(cause);
-      response = RedisResponse.error(RedisConstants.ERROR_REGION_CREATION);
-      if (hasTransaction() && !command.isTransactional()) {
-        response = executeWithTransaction(ctx, command);
-      } else {
-        response = executeWithoutTransaction(command);
-      }
+      response = command.execute(this);
-      if (hasTransaction() && command.isOfType(RedisCommandType.MULTI)) {
-        response = RedisResponse.string(RedisConstants.COMMAND_QUEUED);
-      }
-   * Private helper method to execute a command without a transaction, done for special exception
-   * handling neatness
-   *
-   * @param command Command to execute
-   * @throws Exception Throws exception if exception is from within execution and not to be handled
-   */
-  private RedisResponse executeWithoutTransaction(Command command) throws Exception {
-    Exception cause = null;
-    for (int i = 0; i < MAXIMUM_NUM_RETRIES; i++) {
-      try {
-        return command.execute(this);
-      } catch (Exception e) {
-        logger.error(e);
-
-        cause = e;
-        if (e instanceof RegionDestroyedException || e instanceof RegionNotFoundException
-            || e.getCause() instanceof QueryInvocationTargetException) {
-          Thread.sleep(WAIT_REGION_DSTRYD_MILLIS);
-        }
-      }
-    }
-    throw cause;
-  }
-
-  private RedisResponse executeWithTransaction(ChannelHandlerContext ctx,
-      Command command) throws Exception {
-    CacheTransactionManager txm = cache.getCacheTransactionManager();
-    TransactionId transactionId = getTransactionID();
-    txm.resume(transactionId);
-
-    RedisResponse response;
-    try {
-      response = command.execute(this);
-    } catch (UnsupportedOperationInTransactionException e) {
-      response = RedisResponse.error(RedisConstants.ERROR_UNSUPPORTED_OPERATION_IN_TRANSACTION);
-    } catch (TransactionException e) {
-      response = RedisResponse.error(RedisConstants.ERROR_TRANSACTION_EXCEPTION);
-    } catch (Exception e) {
-      response = getExceptionResponse(ctx, e);
-    }
-
-    getTransactionQueue().add(command);
-    transactionId = txm.suspend();
-    setTransactionID(transactionId);
-
-    return response;
-  }
-
-  /**
-   * Get the current transacationId
-   *
-   * @return The current transactionId, null if one doesn't exist
-   */
-  public TransactionId getTransactionID() {
-    return this.transactionID;
-  }
-
-  /**
-   * Check if client has transaction
-   *
-   * @return True if client has transaction, false otherwise
-   */
-  public boolean hasTransaction() {
-    return transactionID != null;
-  }
-
-  /**
-   * Setter method for transaction
-   *
-   * @param id TransactionId of current transaction for client
-   */
-  public void setTransactionID(TransactionId id) {
-    this.transactionID = id;
-  }
-
-  /**
-   * Reset the transaction of client
-   */
-  public void clearTransaction() {
-    this.transactionID = null;
-    if (this.transactionQueue != null) {
-      for (Command c : this.transactionQueue) {
-        ByteBuf r = c.getResponse();
-        if (r != null) {
-          r.release();
-        }
-      }
-      this.transactionQueue.clear();
-    }
-  }
-
-  /**
-   * Getter for transaction command queue
-   *
-   * @return Command queue
-   */
-  public Queue<Command> getTransactionQueue() {
-    if (this.transactionQueue == null) {
-      this.transactionQueue = new ConcurrentLinkedQueue<Command>();
-    }
-    return this.transactionQueue;
-  }
-
-  /**
-   * Getter for manager to allow pausing and resuming transactions
-   */
-  public CacheTransactionManager getCacheTransactionManager() {
-    return this.cache.getCacheTransactionManager();
-  }
-
-  /**

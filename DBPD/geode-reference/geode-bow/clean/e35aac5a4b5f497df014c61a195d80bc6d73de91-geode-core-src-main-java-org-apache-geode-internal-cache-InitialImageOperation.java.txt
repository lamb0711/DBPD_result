Merge branch 'release/1.5.0'

-import java.io.*;
-import java.util.*;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
-import org.apache.geode.*;
+import org.apache.geode.CancelException;
+import org.apache.geode.DataSerializable;
+import org.apache.geode.DataSerializer;
+import org.apache.geode.InternalGemFireError;
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.SystemFailure;
-import org.apache.geode.distributed.DistributedSystem;
-import org.apache.geode.distributed.internal.*;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.distributed.internal.DistributionMessage;
+import org.apache.geode.distributed.internal.HighPriorityDistributionMessage;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.MessageWithReply;
+import org.apache.geode.distributed.internal.ReplyException;
+import org.apache.geode.distributed.internal.ReplyMessage;
+import org.apache.geode.distributed.internal.ReplyProcessor21;
-import org.apache.geode.internal.*;
+import org.apache.geode.internal.Assert;
+import org.apache.geode.internal.ByteArrayDataInput;
+import org.apache.geode.internal.DataSerializableFixedID;
+import org.apache.geode.internal.InternalDataSerializer;
+import org.apache.geode.internal.NullDataOutputStream;
+import org.apache.geode.internal.Version;
-import org.apache.geode.internal.cache.versions.*;
+import org.apache.geode.internal.cache.versions.DiskRegionVersionVector;
+import org.apache.geode.internal.cache.versions.DiskVersionTag;
+import org.apache.geode.internal.cache.versions.RegionVersionHolder;
+import org.apache.geode.internal.cache.versions.RegionVersionVector;
+import org.apache.geode.internal.cache.versions.VersionSource;
+import org.apache.geode.internal.cache.versions.VersionStamp;
+import org.apache.geode.internal.cache.versions.VersionTag;
-      final DistributionManager dm = (DistributionManager) this.region.getDistributionManager();
+      final ClusterDistributionManager dm =
+          (ClusterDistributionManager) this.region.getDistributionManager();
-      if (this.region.concurrencyChecksEnabled
+      if (this.region.getConcurrencyChecksEnabled()
-            int processorType = targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR
-                : DistributionManager.HIGH_PRIORITY_EXECUTOR;
+            int processorType =
+                targetReinitialized ? ClusterDistributionManager.WAITING_POOL_EXECUTOR
+                    : ClusterDistributionManager.HIGH_PRIORITY_EXECUTOR;
-        int processorType = targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR
-            : DistributionManager.HIGH_PRIORITY_EXECUTOR;
+        int processorType = targetReinitialized ? ClusterDistributionManager.WAITING_POOL_EXECUTOR
+            : ClusterDistributionManager.HIGH_PRIORITY_EXECUTOR;
-      if (this.region.concurrencyChecksEnabled) {
+      if (this.region.getConcurrencyChecksEnabled()) {
-            e.handleAsUnexpected();
+            e.handleCause();
-          if (this.region.dataPolicy.withPersistence()) {
+          if (this.region.getDataPolicy().withPersistence()) {
-    final DistributionManager dm = (DistributionManager) this.region.getDistributionManager();
+    final ClusterDistributionManager dm =
+        (ClusterDistributionManager) this.region.getDistributionManager();
-          e.handleAsUnexpected();
+          e.handleCause();
-    if (this.region.concurrencyChecksEnabled && rvv != null) {
+    if (this.region.getConcurrencyChecksEnabled() && rvv != null) {
-    final DM dm = this.region.getDistributionManager();
+    final DistributionManager dm = this.region.getDistributionManager();
-        e.handleAsUnexpected();
+        e.handleCause();
-                  tmpValue = CachedDeserializableFactory.create((byte[]) tmpValue);
+                  tmpValue =
+                      CachedDeserializableFactory.create((byte[]) tmpValue, region.getCache());
-            tmpValue = CachedDeserializableFactory.create((byte[]) tmpValue);
+            tmpValue = CachedDeserializableFactory.create((byte[]) tmpValue, region.getCache());
-  protected RegionVersionVector getRVVFromProvider(final DistributionManager dm,
+  protected RegionVersionVector getRVVFromProvider(final ClusterDistributionManager dm,
-        e.handleAsUnexpected();
+        e.handleCause();
-  protected static LocalRegion getGIIRegion(final DistributionManager dm, final String regionPath,
-      final boolean targetReinitialized) {
+  protected static LocalRegion getGIIRegion(final ClusterDistributionManager dm,
+      final String regionPath, final boolean targetReinitialized) {
-      DistributedSystem system = dm.getSystem();
-      // GemFireCache cache = (GemFireCache)CacheFactory.getInstance(system);
-      lclRgn = LocalRegion.getRegionFromPath(system, regionPath);
+      InternalCache cache = dm.getCache();
+      lclRgn = cache == null ? null : (LocalRegion) cache.getRegionByPath(regionPath);
-    if (lclRgn.scope.isLocal()) {
+    if (lclRgn.getScope().isLocal()) {
-      return this.targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR
-          : DistributionManager.HIGH_PRIORITY_EXECUTOR;
+      return this.targetReinitialized ? ClusterDistributionManager.WAITING_POOL_EXECUTOR
+          : ClusterDistributionManager.HIGH_PRIORITY_EXECUTOR;
-    protected void process(final DistributionManager dm) {
+    protected void process(final ClusterDistributionManager dm) {
-            if (rgn.concurrencyChecksEnabled && this.versionVector == null
+            if (rgn.getConcurrencyChecksEnabled() && this.versionVector == null
-              && rgn.concurrencyChecksEnabled) {
+              && rgn.getConcurrencyChecksEnabled()) {
-      DistributionManager dm = (DistributionManager) rgn.getDistributionManager();
+      ClusterDistributionManager dm = (ClusterDistributionManager) rgn.getDistributionManager();
-      chunkEntries =
-          new InitialImageVersionedEntryList(rgn.concurrencyChecksEnabled, MAX_ENTRIES_PER_CHUNK);
+      chunkEntries = new InitialImageVersionedEntryList(rgn.getConcurrencyChecksEnabled(),
+          MAX_ENTRIES_PER_CHUNK);
-    private void replyNoData(DistributionManager dm, boolean isDeltaGII,
+    private void replyNoData(ClusterDistributionManager dm, boolean isDeltaGII,
-    protected void replyWithData(DistributionManager dm, List entries, int seriesNum, int msgNum,
-        int numSeries, boolean lastInSeries, int flowControlId, boolean isDeltaGII,
+    protected void replyWithData(ClusterDistributionManager dm, List entries, int seriesNum,
+        int msgNum, int numSeries, boolean lastInSeries, int flowControlId, boolean isDeltaGII,
-    private void initiateLocalAbortForTest(final DM dm) {
+    private void initiateLocalAbortForTest(final DistributionManager dm) {
-      return DistributionManager.HIGH_PRIORITY_EXECUTOR;
+      return ClusterDistributionManager.HIGH_PRIORITY_EXECUTOR;
-    protected void process(final DistributionManager dm) {
+    protected void process(final ClusterDistributionManager dm) {
-      LocalRegion lclRgn = null;
+      InternalRegion lclRgn = null;
-        DistributedSystem system = dm.getSystem();
-        lclRgn = LocalRegion.getRegionFromPath(system, this.regionPath);
+        InternalCache cache = dm.getCache();
+        lclRgn = cache == null ? null : cache.getRegionByPath(regionPath);
-          FilterInfoMessage.send(dm, getSender(), this.processorId, lclRgn, rex);
+          FilterInfoMessage.send(dm, getSender(), this.processorId, (LocalRegion) lclRgn, rex);
-    public static void send(DM dm, InternalDistributedMember dest, int processorId,
+    public static void send(DistributionManager dm, InternalDistributedMember dest, int processorId,
-      return this.targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR
-          : DistributionManager.HIGH_PRIORITY_EXECUTOR;
+      return this.targetReinitialized ? ClusterDistributionManager.WAITING_POOL_EXECUTOR
+          : ClusterDistributionManager.HIGH_PRIORITY_EXECUTOR;
-    protected void process(final DistributionManager dm) {
+    protected void process(final ClusterDistributionManager dm) {
-    protected void process(final DistributionManager dm) {
+    protected void process(final ClusterDistributionManager dm) {
-        ReplyException exception, DistributionManager dm, List entries, int seriesNum, int msgNum,
-        int numSeries, boolean lastInSeries, int flowControlId, boolean isDeltaGII,
+        ReplyException exception, ClusterDistributionManager dm, List entries, int seriesNum,
+        int msgNum, int numSeries, boolean lastInSeries, int flowControlId, boolean isDeltaGII,
-    public void process(DM dm, ReplyProcessor21 processor) {
+    public void process(DistributionManager dm, ReplyProcessor21 processor) {
-    public void setLastModified(DM dm, long localMillis) {
+    public void setLastModified(DistributionManager dm, long localMillis) {
-    public long getLastModified(DM dm) {
+    public long getLastModified(DistributionManager dm) {
-    public static void send(DM dm, InternalDistributedMember dest, int processorId,
+    public static void send(DistributionManager dm, InternalDistributedMember dest, int processorId,
+      msg.setSender(dm.getId()); // for EventStateHelper.dataSerialize
-    public static void send(DM dm, InternalDistributedMember dest, int processorId,
+    public static void send(DistributionManager dm, InternalDistributedMember dest, int processorId,
+      msg.setSender(dm.getId()); // for EventStateHelper.dataSerialize
-        EventStateHelper.dataSerialize(dop, eventState, isHARegion);
+        EventStateHelper.dataSerialize(dop, eventState, isHARegion, getSender());
-    public static void send(DM dm, InternalDistributedMember dest, int processorId, LocalRegion rgn,
-        ReplyException ex) {
+    public static void send(DistributionManager dm, InternalDistributedMember dest, int processorId,
+        LocalRegion rgn, ReplyException ex) {

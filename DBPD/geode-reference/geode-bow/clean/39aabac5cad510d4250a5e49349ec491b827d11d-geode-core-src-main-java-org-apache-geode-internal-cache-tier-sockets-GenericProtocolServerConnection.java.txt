Merge remote-tracking branch 'origin/develop' into feature/GEODE-3239

-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.cache.tier.Acceptor;
-import org.apache.geode.internal.cache.tier.CachedRegionHelper;
-import org.apache.geode.internal.security.SecurityService;
-import org.apache.geode.security.SecurityManager;
-import org.apache.geode.security.server.Authenticator;
-
+import java.net.InetSocketAddress;
+import org.apache.geode.cache.IncompatibleVersionException;
+import org.apache.geode.cache.client.PoolFactory;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.distributed.internal.ServerLocation;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.tier.Acceptor;
+import org.apache.geode.internal.cache.tier.CachedRegionHelper;
+import org.apache.geode.internal.cache.tier.CommunicationMode;
+import org.apache.geode.internal.security.SecurityService;
+
-  private final ClientProtocolMessageHandler messageHandler;
-  private final SecurityManager securityManager;
-  private final Authenticator authenticator;
+  private final ClientProtocolProcessor protocolPipeline;
+  private boolean cleanedUp;
+  private ClientProxyMembershipID clientProxyMembershipID;
-  public GenericProtocolServerConnection(Socket s, InternalCache c, CachedRegionHelper helper,
+  public GenericProtocolServerConnection(Socket socket, InternalCache c, CachedRegionHelper helper,
-      byte communicationMode, Acceptor acceptor, ClientProtocolMessageHandler newClientProtocol,
-      SecurityService securityService, Authenticator authenticator) {
-    super(s, c, helper, stats, hsTimeout, socketBufferSize, communicationModeStr, communicationMode,
-        acceptor, securityService);
-    securityManager = securityService.getSecurityManager();
-    this.messageHandler = newClientProtocol;
-    this.authenticator = authenticator;
+      byte communicationMode, Acceptor acceptor, ClientProtocolProcessor clientProtocolProcessor,
+      SecurityService securityService) {
+    super(socket, c, helper, stats, hsTimeout, socketBufferSize, communicationModeStr,
+        communicationMode, acceptor, securityService);
+    this.protocolPipeline = clientProtocolProcessor;
+
+    setClientProxyMembershipId();
+
+    doHandShake(CommunicationMode.ProtobufClientServerProtocol.getModeNumber(), 0);
-      if (!authenticator.isAuthenticated()) {
-        authenticator.authenticate(inputStream, outputStream, securityManager);
-      } else {
-        messageHandler.receiveMessage(inputStream, outputStream,
-            new MessageExecutionContext(this.getCache(), authenticator.getAuthorizer()));
-      }
+      protocolPipeline.processMessage(inputStream, outputStream);
-    } catch (IOException e) {
+      logger.debug("Encountered EOF while processing message: {}", e);
+    } catch (IOException | IncompatibleVersionException e) {
+    } finally {
+      acceptor.getClientHealthMonitor().receivedPing(this.clientProxyMembershipID);
+  private void setClientProxyMembershipId() {
+    ServerLocation serverLocation = new ServerLocation(
+        ((InetSocketAddress) this.getSocket().getRemoteSocketAddress()).getHostName(),
+        this.getSocketPort());
+    DistributedMember distributedMember = new InternalDistributedMember(serverLocation);
+    // no handshake for new client protocol.
+    clientProxyMembershipID = new ClientProxyMembershipID(distributedMember);
+  }
+
+  @Override
+  public boolean cleanup() {
+    synchronized (this) {
+      if (!cleanedUp) {
+        cleanedUp = true;
+        protocolPipeline.close();
+      }
+    }
+    return super.cleanup();
+  }
+
-    // no handshake for new client protocol.
+    ClientHealthMonitor clientHealthMonitor = getAcceptor().getClientHealthMonitor();
+    clientHealthMonitor.registerClient(clientProxyMembershipID);
+    clientHealthMonitor.addConnection(clientProxyMembershipID, this);
+
+  protected int getClientReadTimeout() {
+    return PoolFactory.DEFAULT_READ_TIMEOUT;
+  }
+
+  @Override

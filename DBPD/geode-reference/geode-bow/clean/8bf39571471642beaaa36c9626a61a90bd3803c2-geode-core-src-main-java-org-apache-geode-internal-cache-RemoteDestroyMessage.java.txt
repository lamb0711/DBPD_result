Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A class that specifies a destroy operation.
- * Used by ReplicateRegions.
- * Note: The reason for different classes for Destroy and Invalidate is to
- * prevent sending an extra bit for every RemoteDestroyMessage to differentiate an
- * invalidate versus a destroy. The assumption is that these operations are used
- * frequently, if they are not then it makes sense to fold the destroy and the
- * invalidate into the same message and use an extra bit to differentiate
+ * A class that specifies a destroy operation. Used by ReplicateRegions. Note: The reason for
+ * different classes for Destroy and Invalidate is to prevent sending an extra bit for every
+ * RemoteDestroyMessage to differentiate an invalidate versus a destroy. The assumption is that
+ * these operations are used frequently, if they are not then it makes sense to fold the destroy and
+ * the invalidate into the same message and use an extra bit to differentiate
- *  
+ * 
-public class RemoteDestroyMessage extends RemoteOperationMessageWithDirectReply implements OldValueImporter {
-  
+public class RemoteDestroyMessage extends RemoteOperationMessageWithDirectReply
+    implements OldValueImporter {
+
-  
+
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-  
+
-  
+
-  
-  /**whether the message has old value */
+
+  /** whether the message has old value */
-  
-  /**whether old value is serialized*/
+
+  /** whether old value is serialized */
-  
+
-  
+
-  
+
-  
+
-  public RemoteDestroyMessage() {
-  }
+  public RemoteDestroyMessage() {}
-  protected RemoteDestroyMessage(Set recipients,
-                           String regionPath,
-                           DirectReplyProcessor processor,
-                           EntryEventImpl event,
-                           Object expectedOldValue, int processorType,
-                           boolean useOriginRemote,
-                           boolean possibleDuplicate) {
+  protected RemoteDestroyMessage(Set recipients, String regionPath, DirectReplyProcessor processor,
+      EntryEventImpl event, Object expectedOldValue, int processorType, boolean useOriginRemote,
+      boolean possibleDuplicate) {
-    
+
-    
+
-  private void setOldValBytes(byte[] valBytes){
+  private void setOldValBytes(byte[] valBytes) {
-  
+
-  
-  private Object getOldValObj(){
+
+  private Object getOldValObj() {
-  
-  protected boolean getHasOldValue(){
+
+  protected boolean getHasOldValue() {
-  
+
-  
+
-   * Set the old value for this message, only used if there are cqs registered 
-   * on one of the bridge servers.
+   * Set the old value for this message, only used if there are cqs registered on one of the bridge
+   * servers.
-  public void setOldValue(EntryEventImpl event){
+  public void setOldValue(EntryEventImpl event) {
-            setOldValBytes((byte[])o);
+            setOldValBytes((byte[]) o);
-    
-  
-  public static boolean distribute(EntryEventImpl event, Object expectedOldValue, boolean onlyPersistent) {
+
+
+  public static boolean distribute(EntryEventImpl event, Object expectedOldValue,
+      boolean onlyPersistent) {
-    DistributedRegion r = (DistributedRegion)event.getRegion();
-    Collection replicates = onlyPersistent ? r.getCacheDistributionAdvisor()
-        .adviseInitializedPersistentMembers().keySet() : r
-        .getCacheDistributionAdvisor().adviseInitializedReplicates();
+    DistributedRegion r = (DistributedRegion) event.getRegion();
+    Collection replicates = onlyPersistent
+        ? r.getCacheDistributionAdvisor().adviseInitializedPersistentMembers().keySet()
+        : r.getCacheDistributionAdvisor().adviseInitializedReplicates();
-    for (Iterator<InternalDistributedMember> it=replicates.iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-        RemoteDestroyReplyProcessor processor = send(replicate, event.getRegion(), 
-            event, expectedOldValue, DistributionManager.SERIAL_EXECUTOR, false,
-            posDup);
+        RemoteDestroyReplyProcessor processor = send(replicate, event.getRegion(), event,
+            expectedOldValue, DistributionManager.SERIAL_EXECUTOR, false, posDup);
-            event.getRegion().getVersionVector().recordVersion(versionTag.getMemberID(), versionTag);
+            event.getRegion().getVersionVector().recordVersion(versionTag.getMemberID(),
+                versionTag);
-        throw new EntryNotFoundException(""+event.getKey());
-        
+        throw new EntryNotFoundException("" + event.getKey());
+
-      
+
-      
+
-      } catch(RemoteOperationException e) {
+      } catch (RemoteOperationException e) {
-          logger.trace(LogMarker.DM, "RemoteDestroyMessage caught an unexpected exception during distribution", e);
+          logger.trace(LogMarker.DM,
+              "RemoteDestroyMessage caught an unexpected exception during distribution", e);
-   * Sends a RemoteDestroyMessage
-   * {@link org.apache.geode.cache.Region#destroy(Object)}message to the
-   * recipient
+   * Sends a RemoteDestroyMessage {@link org.apache.geode.cache.Region#destroy(Object)}message to
+   * the recipient
-   * @param r
-   *          the ReplicateRegion for which the destroy was performed
+   * @param r the ReplicateRegion for which the destroy was performed
-   * @return the processor used to await the potential
-   *         {@link org.apache.geode.cache.CacheException}
+   * @return the processor used to await the potential {@link org.apache.geode.cache.CacheException}
-  public static RemoteDestroyReplyProcessor send(DistributedMember recipient,
-                                       LocalRegion r,
-                                       EntryEventImpl event,
-                                       Object expectedOldValue, int processorType,
-                                       boolean useOriginRemote,
-                                       boolean possibleDuplicate) 
-  throws RemoteOperationException {
-    //Assert.assertTrue(recipient != null, "RemoteDestroyMessage NULL recipient"); recipient may be null for event notification
+  public static RemoteDestroyReplyProcessor send(DistributedMember recipient, LocalRegion r,
+      EntryEventImpl event, Object expectedOldValue, int processorType, boolean useOriginRemote,
+      boolean possibleDuplicate) throws RemoteOperationException {
+    // Assert.assertTrue(recipient != null, "RemoteDestroyMessage NULL recipient"); recipient may be
+    // null for event notification
-    RemoteDestroyReplyProcessor p = new RemoteDestroyReplyProcessor(r.getSystem(), recipients, false);
+    RemoteDestroyReplyProcessor p =
+        new RemoteDestroyReplyProcessor(r.getSystem(), recipients, false);
-    RemoteDestroyMessage m = new RemoteDestroyMessage(recipients,
-                                          r.getFullPath(),
-                                          p,
-                                          event,
-                                          expectedOldValue, processorType,
-                                          useOriginRemote, possibleDuplicate);
+    RemoteDestroyMessage m = new RemoteDestroyMessage(recipients, r.getFullPath(), p, event,
+        expectedOldValue, processorType, useOriginRemote, possibleDuplicate);
-    Set failures =r.getDistributionManager().putOutgoing(m); 
-    if (failures != null && failures.size() > 0 ) {
-      throw new RemoteOperationException(LocalizedStrings.RemoteDestroyMessage_FAILED_SENDING_0.toLocalizedString(m));
+    Set failures = r.getDistributionManager().putOutgoing(m);
+    if (failures != null && failures.size() > 0) {
+      throw new RemoteOperationException(
+          LocalizedStrings.RemoteDestroyMessage_FAILED_SENDING_0.toLocalizedString(m));
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected boolean operateOnRegion(DistributionManager dm,
-      LocalRegion r, long startTime)
-      throws EntryExistsException, RemoteOperationException
-  {
+  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws EntryExistsException, RemoteOperationException {
-       eventSender = getSender();
+      eventSender = getSender();
-    @Released EntryEventImpl event = null;
+    @Released
+    EntryEventImpl event = null;
-    if (this.bridgeContext != null) {
-      event = EntryEventImpl.create(r, getOperation(), getKey(), null/*newValue*/,
-          getCallbackArg(), false/*originRemote*/, eventSender, 
-          true/*generateCallbacks*/);
-      event.setContext(this.bridgeContext);
-      
-      // for cq processing and client notification by BS.
-      if (this.hasOldValue){
-        if (this.oldValueIsSerialized){
-          event.setSerializedOldValue(getOldValueBytes());
+      if (this.bridgeContext != null) {
+        event = EntryEventImpl.create(r, getOperation(), getKey(), null/* newValue */,
+            getCallbackArg(), false/* originRemote */, eventSender, true/* generateCallbacks */);
+        event.setContext(this.bridgeContext);
+
+        // for cq processing and client notification by BS.
+        if (this.hasOldValue) {
+          if (this.oldValueIsSerialized) {
+            event.setSerializedOldValue(getOldValueBytes());
+          } else {
+            event.setOldValue(getOldValueBytes());
+          }
-        else{
+      } // bridgeContext != null
+      else {
+        event = EntryEventImpl.create(r, getOperation(), getKey(), null, /* newValue */
+            getCallbackArg(), this.useOriginRemote, eventSender, true/* generateCallbacks */,
+            false/* initializeId */);
+      }
+
+      event.setCausedByMessage(this);
+
+      if (this.versionTag != null) {
+        this.versionTag.replaceNullIDs(getSender());
+        event.setVersionTag(this.versionTag);
+      }
+      // for cq processing and client notification by BS.
+      if (this.hasOldValue) {
+        if (this.oldValueIsSerialized) {
+          event.setSerializedOldValue(getOldValueBytes());
+        } else {
-    } // bridgeContext != null
-    else {
-      event = EntryEventImpl.create(
-        r,
-        getOperation(),
-        getKey(),
-        null, /*newValue*/
-        getCallbackArg(),
-        this.useOriginRemote,
-        eventSender,
-        true/*generateCallbacks*/,
-        false/*initializeId*/);
-    }
-    event.setCausedByMessage(this);
-    
-    if (this.versionTag != null) {
-      this.versionTag.replaceNullIDs(getSender());
-      event.setVersionTag(this.versionTag);
-    }
- // for cq processing and client notification by BS.
-    if (this.hasOldValue){
-      if (this.oldValueIsSerialized){
-        event.setSerializedOldValue(getOldValueBytes());
-      }
-      else{
-        event.setOldValue(getOldValueBytes());
-      }
-    }
-    
-    Assert.assertTrue(eventId != null);
-    event.setEventId(eventId);
+      Assert.assertTrue(eventId != null);
+      event.setEventId(eventId);
-    event.setPossibleDuplicate(this.possibleDuplicate);
-    
+      event.setPossibleDuplicate(this.possibleDuplicate);
+
-      }
-      catch (CacheWriterException cwe) {
+      } catch (CacheWriterException cwe) {
-      }
-      catch (EntryNotFoundException eee) {
+      } catch (EntryNotFoundException eee) {
-        ReplyMessage.send(getSender(), getProcessorId(), 
-            new ReplyException(eee), getReplySender(dm), r.isInternalRegion());
+        ReplyMessage.send(getSender(), getProcessorId(), new ReplyException(eee),
+            getReplySender(dm), r.isInternalRegion());
-        ReplyMessage.send(getSender(), getProcessorId(), 
-            new ReplyException(e), getReplySender(dm), r.isInternalRegion());
+        ReplyMessage.send(getSender(), getProcessorId(), new ReplyException(e), getReplySender(dm),
+            r.isInternalRegion());
-    return false;
+      return false;
-  
+
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    if (this.hasOldValue){
-      //out.writeBoolean(this.hasOldValue);
+    if (this.hasOldValue) {
+      // out.writeBoolean(this.hasOldValue);
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-    if (this.hasOldValue){
+    if (this.hasOldValue) {
-  protected void setFlags(short flags, DataInput in) throws IOException,
-          ClassNotFoundException {
+  protected void setFlags(short flags, DataInput in) throws IOException, ClassNotFoundException {
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-    buff.append("; hasOldValue= ").append(this.hasOldValue);    
+    buff.append("; hasOldValue= ").append(this.hasOldValue);
-  protected final Object getKey()
-  {
+  protected final Object getKey() {
-  private final void setKey(Object key)
-  {
+  private final void setKey(Object key) {
-  public final Operation getOperation()
-  {
+  public final Operation getOperation() {
-  protected final Object getCallbackArg()
-  {
+  protected final Object getCallbackArg() {
-  
+
-  
+
-      this.oldValueIsSerialized = true; //VALUE_IS_SERIALIZED_OBJECT;
+      this.oldValueIsSerialized = true; // VALUE_IS_SERIALIZED_OBJECT;
-      this.oldValueIsSerialized = false; //VALUE_IS_BYTES;
+      this.oldValueIsSerialized = false; // VALUE_IS_BYTES;
-  
+
-    
+
-    private static final byte PERSISTENT  = 0x02;
-    
+    private static final byte PERSISTENT = 0x02;
+
-    public DestroyReplyMessage() {
-    }
+    public DestroyReplyMessage() {}
-    static void send(InternalDistributedMember recipient, ReplySender dm, int procId, VersionTag versionTag) {
+    static void send(InternalDistributedMember recipient, ReplySender dm, int procId,
+        VersionTag versionTag) {
-    
+
-        logger.trace(LogMarker.DM, "DestroyReplyMessage process invoking reply processor with processorId:{}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "DestroyReplyMessage process invoking reply processor with processorId:{}",
+            this.processorId);
-        RemoteDestroyReplyProcessor processor = (RemoteDestroyReplyProcessor)rp;
+        RemoteDestroyReplyProcessor processor = (RemoteDestroyReplyProcessor) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-      if(this.versionTag != null) {
+      if (this.versionTag != null) {
-      if(this.versionTag instanceof DiskVersionTag) {
+      if (this.versionTag instanceof DiskVersionTag) {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      boolean hasTag = (b & HAS_VERSION) != 0; 
+      boolean hasTag = (b & HAS_VERSION) != 0;
-    
+
-    
+
-    
+

This closes #205

GEODE-11: Adding stats option to list lucene index gfsh command

Added an option to display lucene index stats in the list lucene index command. Added junit and dunit tests to verify the same.

GEODE-11: Added describe lucene index gfsh command

Added describe lucene index gfsh command that takes the index name and region as arguments and displays information about the lucene index (fields, analyzers and stats). Also added junit and dunit tests for the same.

Signed-off-by: Gester Zhou <gzhou@pivotal.io>

+import static com.gemstone.gemfire.cache.operations.OperationContext.*;
+
+import java.util.ArrayList;
+
+import com.gemstone.gemfire.cache.execute.FunctionAdapter;
+import com.gemstone.gemfire.cache.lucene.internal.cli.functions.LuceneDescribeIndexFunction;
-
+  private static final LuceneDescribeIndexFunction describeIndexFunction = new LuceneDescribeIndexFunction();
-  public Result listIndex() {
+  public Result listIndex(
+    @CliOption(key = LuceneCliStrings.LUCENE_LIST_INDEX__STATS,
+      mandatory=false,
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = LuceneCliStrings.LUCENE_LIST_INDEX__STATS__HELP) final boolean stats) {
+
-      return toTabularResult(getIndexListing());
+      return toTabularResult(getIndexListing(),stats);
-  protected Result toTabularResult(final List<LuceneIndexDetails> indexDetailsList) {
+  protected Result toTabularResult(final List<LuceneIndexDetails> indexDetailsList, boolean stats) {
+
+        if (stats==true) {
+          indexData.accumulate("Query Executions",indexDetails.getIndexStats().get("queryExecutions"));
+          indexData.accumulate("Updates",indexDetails.getIndexStats().get("updates"));
+          indexData.accumulate("Commits",indexDetails.getIndexStats().get("commits"));
+          indexData.accumulate("Documents",indexDetails.getIndexStats().get("documents"));
+        }
-    @CliOption(key = LuceneCliStrings.LUCENE_CREATE_INDEX__NAME,
+    @CliOption(key = LuceneCliStrings.LUCENE__INDEX_NAME,
-    @CliOption (key = LuceneCliStrings.LUCENE_CREATE_INDEX__REGION,
+    @CliOption (key = LuceneCliStrings.LUCENE__REGION_PATH,
-      final ResultCollector<?, ?> rc = this.createIndexOnGroups(groups, indexInfo);
+      final ResultCollector<?, ?> rc = this.executeFunctionOnGroups(createIndexFunction, groups, indexInfo);
-  protected ResultCollector<?, ?> createIndexOnGroups( String[] groups, final LuceneIndexInfo indexInfo) throws CommandResultException {
-    final Set<DistributedMember> targetMembers = CliUtil.findAllMatchingMembers(groups, null);
-    return CliUtil.executeFunction(createIndexFunction, indexInfo, targetMembers);
+  @CliCommand(value = LuceneCliStrings.LUCENE_DESCRIBE_INDEX, help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__HELP)
+  @CliMetaData(shellOnly = false, relatedTopic={CliStrings.TOPIC_GEODE_REGION, CliStrings.TOPIC_GEODE_DATA })
+  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.READ)
+  public Result describeIndex(
+    @CliOption(key = LuceneCliStrings.LUCENE__INDEX_NAME,
+      mandatory=true,
+      help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__NAME__HELP) final String indexName,
+
+    @CliOption (key = LuceneCliStrings.LUCENE__REGION_PATH,
+      mandatory = true,
+      optionContext = ConverterHint.REGIONPATH,
+      help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__REGION_HELP) final String regionPath) {
+    try {
+      LuceneIndexInfo indexInfo = new LuceneIndexInfo(indexName, regionPath);
+      return toTabularResult(getIndexDetails(indexInfo),true);
+    }
+    catch (FunctionInvocationTargetException ignore) {
+      return ResultBuilder.createGemFireErrorResult(CliStrings.format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN,
+        LuceneCliStrings.LUCENE_DESCRIBE_INDEX));
+    }
+    catch (VirtualMachineError e) {
+      SystemFailure.initiateFailure(e);
+      throw e;
+    }
+    catch (Throwable t) {
+      SystemFailure.checkFailure();
+      getCache().getLogger().error(t);
+      return ResultBuilder.createGemFireErrorResult(String.format(LuceneCliStrings.LUCENE_DESCRIBE_INDEX__ERROR_MESSAGE,
+        toString(t, isDebugging())));
+    }
-}
+
+  @SuppressWarnings("unchecked")
+  protected List<LuceneIndexDetails> getIndexDetails(LuceneIndexInfo indexInfo) throws Exception {
+    GeodeSecurityUtil.authorizeRegionManage(indexInfo.getRegionPath());
+    final String[] groups = {};
+    final ResultCollector<?, ?> rc = this.executeFunctionOnGroups(describeIndexFunction, groups, indexInfo);
+    final List<LuceneIndexDetails> funcResults = (List<LuceneIndexDetails>) rc.getResult();
+    return funcResults.stream().filter(indexDetails -> indexDetails != null).collect(Collectors.toList());
+  }
+
+  protected ResultCollector<?, ?> executeFunctionOnGroups(FunctionAdapter function, String[]groups, final LuceneIndexInfo indexInfo) throws CommandResultException {
+    final Set<DistributedMember> targetMembers = CliUtil.findAllMatchingMembers(groups, null);
+    return CliUtil.executeFunction(function, indexInfo, targetMembers);
+  }
+}

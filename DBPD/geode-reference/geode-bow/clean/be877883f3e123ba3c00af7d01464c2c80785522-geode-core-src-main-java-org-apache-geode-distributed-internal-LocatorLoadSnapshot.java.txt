GEODE-7565: Allow gateway receivers with same host and port (2nd try)

This reverts the revert of the original commit, adds extra tests and
also fixes the originally introduced issues.

----

There was a problem with Geode WAN replication when GW receivers are
configured with the same hostname-for-senders and port on all servers.
The reason for such a setup is deploying Geode cluster on a Kubernetes
cluster where all GW receivers are reachable from the outside world on
the same VIP and port.

The problem experienced is that shutting down one server is stopping
replication to this cluster until the server is up again. This is
because Geode incorrectly assumes there are no more alive servers when
just one of them is down, because since they share hostname-for-senders
and port, they are treated as one same server.

With these changes locator is able to distinguish the different
receivers using the same hostname and port so replication is not
impacted when one server is stopped.
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.annotations.VisibleForTesting;
-  private final Map<String, Map<ServerLocation, LoadHolder>> connectionLoadMap = new HashMap<>();
+  private final Map<String, Map<ServerLocationAndMemberId, LoadHolder>> connectionLoadMap =
+      new HashMap<>();
-  public void addServer(ServerLocation location, String[] groups, ServerLoad initialLoad) {
-    addServer(location, groups, initialLoad, 30000);
-  }
-
-  public synchronized void addServer(ServerLocation location, String[] groups,
+  public synchronized void addServer(ServerLocation location, String memberId, String[] groups,
-    LoadHolder connectionLoad = new LoadHolder(location, initialLoad.getConnectionLoad(),
-        initialLoad.getLoadPerConnection(), loadPollInterval);
-    addGroups(connectionLoadMap, groups, connectionLoad);
-    LoadHolder queueLoad = new LoadHolder(location, initialLoad.getSubscriptionConnectionLoad(),
+    LoadHolder connectionLoad =
+        new LoadHolder(location, initialLoad.getConnectionLoad(),
+            initialLoad.getLoadPerConnection(), loadPollInterval);
+    addGroups(connectionLoadMap, groups, connectionLoad, memberId);
+    LoadHolder queueLoad = new LoadHolder(location,
+        initialLoad.getSubscriptionConnectionLoad(),
-    updateLoad(location, initialLoad);
+    updateLoad(location, memberId, initialLoad);
-  public synchronized void removeServer(ServerLocation location) {
+  public synchronized void removeServer(ServerLocation location, String memberId) {
-      removeFromMap(connectionLoadMap, groups, location);
+      removeFromMap(connectionLoadMap, groups, location, memberId);
-  public void updateLoad(ServerLocation location, ServerLoad newLoad) {
-    updateLoad(location, newLoad, null);
+  public void updateLoad(ServerLocation location, String memberId, ServerLoad newLoad) {
+    updateLoad(location, memberId, newLoad, null);
-  synchronized void updateLoad(ServerLocation location, ServerLoad newLoad,
+  synchronized void updateLoad(ServerLocation location, String memberId, ServerLoad newLoad,
+
-    updateMap(connectionLoadMap, location, newLoad.getConnectionLoad(),
+    updateMap(connectionLoadMap, location, memberId, newLoad.getConnectionLoad(),
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers) {
+  private synchronized boolean isBalanced(Map<ServerLocationAndMemberId, LoadHolder> groupServers) {
-  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers,
+  private synchronized boolean isBalanced(Map<ServerLocationAndMemberId, LoadHolder> groupServers,
-    for (Entry<ServerLocation, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
+    for (Entry<ServerLocationAndMemberId, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-
-    return new ArrayList<>(groupServers.keySet());
+    ArrayList result = new ArrayList<>();
+    for (ServerLocationAndMemberId locationAndMemberId : groupServers.keySet()) {
+      result.add(locationAndMemberId.getServerLocation());
+    }
+    return result;
-   * Pick the least loaded server in the given group if currentServer is the most loaded server. n
+   * Pick the least loaded server in the given group if currentServer is the most loaded server.
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-    Map<ServerLocation, LoadHolder> connectionMap = connectionLoadMap.get(null);
+    Map<ServerLocationAndMemberId, LoadHolder> connectionMap = connectionLoadMap.get(null);
-    for (Entry<ServerLocation, LoadHolder> entry : connectionMap
+    for (Entry<ServerLocationAndMemberId, LoadHolder> entry : connectionMap
-      ServerLocation location = entry.getKey();
+      ServerLocation location = entry.getKey().getServerLocation();
-  private void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
+  @VisibleForTesting
+  void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
-  private void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
+  @VisibleForTesting
+  void addGroups(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,
+      String[] groups,
+      LoadHolder holder, String memberId) {
+    for (String group : groups) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap =
+          map.computeIfAbsent(group, k -> new HashMap<>());
+      groupMap.put(new ServerLocationAndMemberId(holder.getLocation(), memberId), holder);
+    }
+    // Special case for GatewayReceiver where we don't put those serverlocation against holder
+    if (!(groups.length > 0 && groups[0].equals(GatewayReceiver.RECEIVER_GROUP))) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap =
+          map.computeIfAbsent(null, k -> new HashMap<>());
+      groupMap.put(new ServerLocationAndMemberId(holder.getLocation(), memberId), holder);
+    }
+  }
+
+  @VisibleForTesting
+  void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
-  private void updateMap(Map map, ServerLocation location, float load, float loadPerConnection) {
+  @VisibleForTesting
+  void removeFromMap(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,
+      String[] groups,
+      ServerLocation location, String memberId) {
+    ServerLocationAndMemberId locationAndMemberId =
+        new ServerLocationAndMemberId(location, memberId);
+    for (String group : groups) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap = map.get(group);
+      if (groupMap != null) {
+        groupMap.remove(locationAndMemberId);
+        if (groupMap.size() == 0) {
+          map.remove(group);
+        }
+      }
+    }
+    Map groupMap = map.get(null);
+    groupMap.remove(locationAndMemberId);
+  }
+
+  @VisibleForTesting
+  void updateMap(Map map, ServerLocation location, float load, float loadPerConnection) {
+    updateMap(map, location, "", load, loadPerConnection);
+  }
+
+  @VisibleForTesting
+  void updateMap(Map map, ServerLocation location, String memberId, float load,
+      float loadPerConnection) {
-    LoadHolder holder = (LoadHolder) groupMap.get(location);
+    LoadHolder holder;
+    if (memberId.equals("")) {
+      holder = (LoadHolder) groupMap.get(location);
+    } else {
+      ServerLocationAndMemberId locationAndMemberId =
+          new ServerLocationAndMemberId(location, memberId);
+      holder = (LoadHolder) groupMap.get(locationAndMemberId);
+    }
-  private List<LoadHolder> findBestServers(Map<ServerLocation, LoadHolder> groupServers,
+  @VisibleForTesting
+  List<LoadHolder> findBestServers(
+      Map<?, LoadHolder> groupServers,
+    if (count == 0) {
+      return new ArrayList<>();
+    }
+
-    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
-      ServerLocation location = loadEntry.getKey();
+    for (Map.Entry<?, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location;
+      Object key = loadEntry.getKey();
+      if (key instanceof ServerLocationAndMemberId) {
+        location = ((ServerLocationAndMemberId) key).getServerLocation();
+      } else if (key instanceof ServerLocation) {
+        location = ((ServerLocation) key);
+      } else {
+        throw new InternalGemFireException(
+            "findBestServers method was called with incorrect type parameters.");
+      }
-  private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,
-      Map<ServerLocation, LoadHolder> groupServers) {
-    final LoadHolder currentLH = groupServers.get(currentServer);
+  @VisibleForTesting
+  LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,
+      Map<ServerLocationAndMemberId, LoadHolder> groupServers) {
+
+    // Check if there are keys in the map that contains currentServer.
+    LoadHolder currentLH = null;
+    for (ServerLocationAndMemberId locationAndMemberId : groupServers.keySet()) {
+      if (currentServer.equals(locationAndMemberId.getServerLocation())) {
+        currentLH = groupServers.get(locationAndMemberId);
+        break;
+      }
+    }
-    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
-      ServerLocation location = loadEntry.getKey();
+    for (Map.Entry<ServerLocationAndMemberId, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location = loadEntry.getKey().getServerLocation();
-  private static class LoadHolder {
+  @VisibleForTesting
+  static class LoadHolder {

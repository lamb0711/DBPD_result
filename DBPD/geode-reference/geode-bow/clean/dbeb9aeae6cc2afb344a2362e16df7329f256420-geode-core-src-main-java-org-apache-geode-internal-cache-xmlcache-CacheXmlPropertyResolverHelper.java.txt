Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * This <code>HashMap </code> contains valid suffixes and prefixes to be 
-   * parsed by {@link CacheXmlPropertyResolverHelper} like {}, [] or ().
+   * This <code>HashMap </code> contains valid suffixes and prefixes to be parsed by
+   * {@link CacheXmlPropertyResolverHelper} like {}, [] or ().
-  public CacheXmlPropertyResolverHelper(String propPrefix,
-      String propSuffix) {
-    if(propPrefix != null && propSuffix != null){
+  public CacheXmlPropertyResolverHelper(String propPrefix, String propSuffix) {
+    if (propPrefix != null && propSuffix != null) {
-      if(validPrefix != null && propPrefix.endsWith(validPrefix)){
+      if (validPrefix != null && propPrefix.endsWith(validPrefix)) {
-      
+
-   * Parses the given string which are supposed to be like ${} for system and/or Gemfire
-   * properties to be replaced. This will return property.name from ${property.name}.
+   * Parses the given string which are supposed to be like ${} for system and/or Gemfire properties
+   * to be replaced. This will return property.name from ${property.name}.
+   * 
-  protected String parseResolvablePropString(String unparsedString, PropertyResolver resolver, Set<String> visitedReplaceableStrings){
+  protected String parseResolvablePropString(String unparsedString, PropertyResolver resolver,
+      Set<String> visitedReplaceableStrings) {
-    while(prefixIndex != -1){
-      int suffixIndex = findSuffixIndex(buf, prefixIndex+propertyPrefix.length());
-      if(suffixIndex != -1){
-        String replaceableString = buf.substring(prefixIndex+propertyPrefix.length(), suffixIndex);
-        //Check for circular references
-        if(!visitedReplaceableStrings.add(replaceableString)){
-          logger.info(LocalizedMessage.create(LocalizedStrings.CacheXmlPropertyResolverHelper_SOME_UNRESOLVED_STRING_REPLACED_CIRCULAR_ERROR__0, replaceableString));
-          throw new IllegalArgumentException("Some still unresolved string "+ replaceableString+" was replaced by resolver, leading to circular references.");
+    while (prefixIndex != -1) {
+      int suffixIndex = findSuffixIndex(buf, prefixIndex + propertyPrefix.length());
+      if (suffixIndex != -1) {
+        String replaceableString =
+            buf.substring(prefixIndex + propertyPrefix.length(), suffixIndex);
+        // Check for circular references
+        if (!visitedReplaceableStrings.add(replaceableString)) {
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.CacheXmlPropertyResolverHelper_SOME_UNRESOLVED_STRING_REPLACED_CIRCULAR_ERROR__0,
+              replaceableString));
+          throw new IllegalArgumentException("Some still unresolved string " + replaceableString
+              + " was replaced by resolver, leading to circular references.");
-        replaceableString = parseResolvablePropString(replaceableString, resolver, visitedReplaceableStrings);
+        replaceableString =
+            parseResolvablePropString(replaceableString, resolver, visitedReplaceableStrings);
-        if(replacement != null){
-          /** put replacement in <code>unparsedString</code> and call <code>parseResolvablePropString</code> recursively to find more 
-           * unparsedStrings in the replaced value of given unparsedString.*/
+        if (replacement != null) {
+          /**
+           * put replacement in <code>unparsedString</code> and call
+           * <code>parseResolvablePropString</code> recursively to find more unparsedStrings in the
+           * replaced value of given unparsedString.
+           */
-          buf.replace(prefixIndex, suffixIndex+propertySuffix.length(), replacement);
-          prefixIndex = buf.indexOf(propertyPrefix, prefixIndex+replacement.length());
-        } else if(resolver.isIgnoreUnresolvedProperties()) {
+          buf.replace(prefixIndex, suffixIndex + propertySuffix.length(), replacement);
+          prefixIndex = buf.indexOf(propertyPrefix, prefixIndex + replacement.length());
+        } else if (resolver.isIgnoreUnresolvedProperties()) {
-          prefixIndex = buf.indexOf(propertyPrefix, suffixIndex+propertySuffix.length());
+          prefixIndex = buf.indexOf(propertyPrefix, suffixIndex + propertySuffix.length());
-          throw new IllegalArgumentException("No replacement found for property : "+ replaceableString);
+          throw new IllegalArgumentException(
+              "No replacement found for property : " + replaceableString);
-        //Before iterating again remove replaceable string from visitedReplaceableStrings as it can appear again.
+        // Before iterating again remove replaceable string from visitedReplaceableStrings as it can
+        // appear again.
-    
+
-   * Finds index of suffix in a string from a specified index. Like finds index of
-   * "}" in string "${my.prop.name}" starting from index 2, which is 14.
+   * Finds index of suffix in a string from a specified index. Like finds index of "}" in string
+   * "${my.prop.name}" starting from index 2, which is 14.
+   * 
-      if (buf.substring(index, index+this.propertySuffix.length()).equalsIgnoreCase(this.propertySuffix)) {
+      if (buf.substring(index, index + this.propertySuffix.length())
+          .equalsIgnoreCase(this.propertySuffix)) {
-      } else if (buf.substring(index, index+this.prefixForSuffix.length()).equalsIgnoreCase(this.prefixForSuffix)) {
+      } else if (buf.substring(index, index + this.prefixForSuffix.length())
+          .equalsIgnoreCase(this.prefixForSuffix)) {

Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-
+import java.io.IOException;
+import java.io.Serializable;
-import java.security.Principal;
+import org.apache.commons.lang.SerializationException;
-import org.apache.geode.security.GeodePermission;
-import org.apache.geode.security.GeodePermission.Operation;
-import org.apache.geode.security.GeodePermission.Resource;
+import org.apache.geode.security.ResourcePermission;
+import org.apache.geode.security.ResourcePermission.Operation;
+import org.apache.geode.security.ResourcePermission.Resource;
+import com.gemstone.gemfire.GemFireIOException;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl;
+import com.gemstone.gemfire.internal.util.BlobHelper;
-  private static Logger logger = LogService.getLogger();
+  private static Logger logger = LogService.getLogger(LogService.SECURITY_LOGGER_NAME);
+  private static PostProcessor postProcessor;
+  private static SecurityManager securityManager;
+  private static boolean isIntegratedSecurity;
+  private static boolean isClientAuthenticator;
+  private static boolean isPeerAuthenticator;
-   * It first looks the shiro subject in AccessControlContext since JMX will use multiple threads to process operations from the same client.
-   * then it looks into Shiro's thead context.
+   * It first looks the shiro subject in AccessControlContext since JMX will
+   * use multiple threads to process operations from the same client, then it
+   * looks into Shiro's thead context.
+   *
-   * @param username
-   * @param password
-   * this binds the passed-in subject to the executing thread, normally, you would do this:
+   * this binds the passed-in subject to the executing thread, normally, you
+   * would do this:
+   *
-    authorize(new GeodePermission(resource, operation, regionName, key));
+    authorize(new ResourcePermission(resource, operation, regionName, key));
-  public static void authorize(GeodePermission context) {
+  public static void authorize(ResourcePermission context) {
-  private static PostProcessor postProcessor;
-  private static SecurityManager securityManager;
-  private static boolean isIntegratedSecurity;
-  private static boolean isClientAuthenticator;
-  private static boolean isPeerAuthenticator;
-
-   * @param securityProps
-   * postProcess call already has this logic built in, you don't need to call this everytime you call postProcess.
-   * But if your postProcess is pretty involved with preparations and you need to bypass it entirely, call this first.
+   * postProcess call already has this logic built in, you don't need to call
+   * this everytime you call postProcess. But if your postProcess is pretty
+   * involved with preparations and you need to bypass it entirely, call this
+   * first.
-  public static Object postProcess(String regionPath, Object key, Object result){
-    if(postProcessor == null)
-      return result;
-
-    Subject subject = getSubject();
-
-    if(subject == null)
-      return result;
-
-    String regionName = StringUtils.stripStart(regionPath, "/");
-    return postProcessor.processRegionValue((Principal)subject.getPrincipal(), regionName, key,  result);
+  public static Object postProcess(String regionPath, Object key, Object value, boolean valueIsSerialized){
+    return postProcess(null, regionPath, key, value, valueIsSerialized);
+  public static Object postProcess(Serializable principal, String regionPath, Object key, Object value, boolean valueIsSerialized) {
+    if (!needPostProcess())
+      return value;
+
+    if (principal == null) {
+      Subject subject = getSubject();
+      if (subject == null)
+        return value;
+      principal = (Serializable) subject.getPrincipal();
+    }
+
+    String regionName = StringUtils.stripStart(regionPath, "/");
+    Object newValue = null;
+
+    // if the data is a byte array, but the data itself is supposed to be an object, we need to desearized it before we pass
+    // it to the callback.
+    if (valueIsSerialized && value instanceof byte[]) {
+      try {
+        Object oldObj = EntryEventImpl.deserialize((byte[]) value);
+        Object newObj = postProcessor.processRegionValue(principal, regionName, key,  oldObj);
+        newValue = BlobHelper.serializeToBlob(newObj);
+      } catch (IOException|SerializationException e) {
+        throw new GemFireIOException("Exception de/serializing entry value", e);
+      }
+    }
+    else {
+      newValue = postProcessor.processRegionValue(principal, regionName, key, value);
+    }
+
+    return newValue;
+  }
+
+  private static void checkSameClass(Object obj1, Object obj2){
+
+  }
-   * this method would never return null, it either throws an exception or returns an object
-   * @param className
-   * @param expectedClazz
-   * @param <T>
-   * @return
+   * this method would never return null, it either throws an exception or
+   * returns an object
-   * this method would never return null, it either throws an exception or returns an object
-   * @param factoryMethodName
-   * @param expectedClazz
-   * @param <T>
-   * @return
+   * this method would never return null, it either throws an exception or
+   * returns an object
-   * this method would never return null, it either throws an exception or returns an object
-   * @param classOrMethod
-   * @param expectedClazz
-   * @param <T>
-   * @return an object of type expectedClazz. This method would never return null. It either returns an non-null
-   * object or throws exception.
+   * this method would never return null, it either throws an exception or
+   * returns an object
+   *
+   * @return an object of type expectedClazz. This method would never return
+   * null. It either returns an non-null object or throws exception.
+  public static PostProcessor getPostProcessor() {
+    return postProcessor;
+  }

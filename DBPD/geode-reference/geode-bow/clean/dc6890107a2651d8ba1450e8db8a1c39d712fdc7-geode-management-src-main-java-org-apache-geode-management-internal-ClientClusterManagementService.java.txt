GEODE-6897: implement CMS rebalance operation (#3820)


+import java.util.Date;
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.Collectors;
+import org.apache.geode.management.api.ClusterManagementListOperationsResult;
+import org.apache.geode.management.api.ClusterManagementRealizationResult;
-import org.apache.geode.management.api.JsonSerializable;
+import org.apache.geode.management.runtime.OperationResult;
-  // runner's
-  // injected RequestFactory can work
+  // runner's injected RequestFactory can work
-  public <T extends CacheElement> ClusterManagementResult create(T config) {
+  public <T extends CacheElement> ClusterManagementRealizationResult create(T config) {
-        .postForEntity(endPoint, config, ClusterManagementResult.class)
+        .postForEntity(endPoint, config, ClusterManagementRealizationResult.class)
-  public <T extends CacheElement> ClusterManagementResult delete(
+  public <T extends CacheElement> ClusterManagementRealizationResult delete(
-            ClusterManagementResult.class,
+            ClusterManagementRealizationResult.class,
-  public <T extends CacheElement> ClusterManagementResult update(
+  public <T extends CacheElement> ClusterManagementRealizationResult update(
-  public <A extends ClusterManagementOperation<V>, V extends JsonSerializable> ClusterManagementOperationResult<V> startOperation(
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> ClusterManagementOperationResult<V> start(
-    final ClusterManagementResult result;
+    final ClusterManagementOperationResult result;
-        ClusterManagementResult.class).getBody();
+        ClusterManagementOperationResult.class).getBody();
+    return reAnimate(result);
+  }
+
+  private <V extends OperationResult> ClusterManagementOperationResult<V> reAnimate(
+      ClusterManagementOperationResult<V> result) {
+    CompletableFuture<Date> futureOperationEnded = new CompletableFuture<>();
-        new CompletableFutureProxy<>(restTemplate, uri, longRunningStatusPollingThreadPool);
+        new CompletableFutureProxy<>(restTemplate, uri, longRunningStatusPollingThreadPool,
+            futureOperationEnded);
-    return new ClusterManagementOperationResult<>(result, operationResult);
+    return new ClusterManagementOperationResult<>(result, operationResult,
+        result.getOperationStart(), futureOperationEnded, result.getOperator());
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> ClusterManagementListOperationsResult<V> list(
+      A opType) {
+    final ClusterManagementListOperationsResult<V> result;
+
+    // make the REST call to list in-progress operations
+    result = restTemplate.getForEntity(RestfulEndpoint.URI_VERSION + opType.getEndpoint(),
+        ClusterManagementListOperationsResult.class).getBody();
+
+    return new ClusterManagementListOperationsResult<>(
+        result.getResult().stream().map(this::reAnimate).collect(Collectors.toList()));

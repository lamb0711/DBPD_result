GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-/*
- * IndexCreationHelper.java
- *
- * Created on March 16, 2005, 6:20 PM
- */
+import static org.apache.commons.lang.StringUtils.isEmpty;
+
-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-/**
- *
- */
+
-  // If true means pattern is *, if false & still map type index that means
-  // more than 1 specific keys
+
+  /**
+   * If true means pattern is *, if false & still map type index that means more than 1 specific
+   * keys
+   */
-  CompiledValue indexedExpr;
-  List fromClauseIterators;
+
+  private CompiledValue indexedExpr;
+
+  private List fromClauseIterators;
+
+
+
+
-   * Asif : The Iterators for index creation are different then those which are used for index
-   * updates as in case of Index creation the 0th iterator is modified such that it always
-   * represents collection of Region.Entry objects. As a result all the rest of iterators as well as
-   * indexed expression have to be modified to appropriately resolve the dependency on 0th
-   * iterator.The missing link indicates the dependency. The original 0th iterator is evaluated as
-   * additional projection attribute. These changes provide significant improvement in Index
-   * creation as compared to previous method. In this approach the IMQ acts on all the entries of
-   * the region while in previous , it iterated over the individual entry of the Region & applied
-   * IMQ to it.
+   * The Iterators for index creation are different then those which are used for index updates as
+   * in case of Index creation the 0th iterator is modified such that it always represents
+   * collection of Region.Entry objects. As a result all the rest of iterators as well as indexed
+   * expression have to be modified to appropriately resolve the dependency on 0th iterator.The
+   * missing link indicates the dependency. The original 0th iterator is evaluated as additional
+   * projection attribute. These changes provide significant improvement in Index creation as
+   * compared to previous method. In this approach the IMQ acts on all the entries of the region
+   * while in previous , it iterated over the individual entry of the Region & applied IMQ to it.
-
-  CompiledValue missingLink = null;
-  CompiledValue additionalProj = null;
-  ObjectType addnlProjType = null;
-  CompiledValue modifiedIndexExpr = null;
-  boolean isFirstIteratorRegionEntry = false;
-  boolean isFirstIteratorRegionKey = false;
-  final String imports;
-  // TODO: Asif Remove the fromClause being passed as parameter to the
-  // constructor
+  CompiledValue missingLink = null;
+
+  CompiledValue additionalProj = null;
+
+  ObjectType addnlProjType = null;
+
+  CompiledValue modifiedIndexExpr = null;
+
+  boolean isFirstIteratorRegionEntry = false;
+
+  boolean isFirstIteratorRegionKey = false;
+
+  private final String imports;
+
+  // TODO: Remove the fromClause being passed as parameter to the constructor
-      String projectionAttributes, String imports, Cache cache, ExecutionContext externalContext,
-      IndexManager imgr) throws IndexInvalidException {
+      String projectionAttributes, String imports, InternalCache cache,
+      ExecutionContext externalContext, IndexManager imgr) throws IndexInvalidException {
-    Object data[] = modfiyIterDefToSuiteIMQ((CompiledIteratorDef) fromClauseIterators.get(0));
+    Object[] data = modifyIterDefToSuiteIMQ((CompiledIteratorDef) this.fromClauseIterators.get(0));
-    fromClauseIterators.remove(0);
-    fromClauseIterators.add(0, data[1]);
-    region = (QRegion) data[0];
+    this.fromClauseIterators.remove(0);
+    this.fromClauseIterators.add(0, data[1]);
+    this.region = (QRegion) data[0];
+  @Override
-    return fromClauseIterators;
+    return this.fromClauseIterators;
+  @Override
-    return indexedExpr;
+    return this.indexedExpr;
+  @Override
-    return region.getRegion();
+    return this.region.getRegion();
-
-
-  /*
-   * Asif : The function is modified to optmize the index creation code. If the 0th iterator of from
+  /**
+   * The function is modified to optimize the index creation code. If the 0th iterator of from
+   * <p>
+   * TODO: method is too complex for IDE to analyze -- refactor prepareFromClause
-    if (imports != null) {
+    if (this.imports != null) {
-    List list = this.compiler.compileFromClause(fromClause);
+    List list = this.compiler.compileFromClause(this.fromClause);
-              .toLocalizedString(fromClause));
+              .toLocalizedString(this.fromClause));
-    boolean isFromClauseNull = true;
-    CompiledIteratorDef newItr = null;
-    StringBuffer tempBuff = new StringBuffer();
+    StringBuilder tempBuff = new StringBuilder();
+    boolean isFromClauseNull = true;
+
-        context.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
+        this.context.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
-                  .toLocalizedString(fromClause));
+                  .toLocalizedString(this.fromClause));
+
-        // Asif: Bind the Index_Internal_ID to the RuntimeIterator
+
+        // Bind the Index_Internal_ID to the RuntimeIterator
-          // if (iterDef.getCollectionExpr() instanceof CompiledRegion ||
-          // iterDef.getCollectionExpr() instanceof CompiledPath) {
-          // pr.getIndexManager().putCanonicalizedIteratorName(pr.getFullPath(),
-          // this.canonicalizedIteratorNames[i]);
-          // } else {
-          // }
+        CompiledIteratorDef newItr;
+
-          addnlProjType = rIter.getElementType();
-          String name = null;
-          if ((name = iterDef.getName()) == null || name.equals("")) {
-            // In case the name of iterator is null or balnk set it to
-            // index_internal_id
+          this.addnlProjType = rIter.getElementType();
+          String name = iterDef.getName();
+          if (isEmpty(name)) {
+            // In case the name of iterator is null or blank set it to index_internal_id
-          // TODO Asif : What if cv is not an instance of CompiledRegion
+
+          // TODO: What if cv is not an instance of CompiledRegion
-            missingLink = new CompiledPath(new CompiledID(name), "value");
-            // missingLinkPath = name + ".value";
-            additionalProj = missingLink;
+            this.missingLink = new CompiledPath(new CompiledID(name), "value");
+            this.additionalProj = this.missingLink;
+
-            CompiledValue prevCV = null;
+            CompiledValue prevCV;
-                cv = ((CompiledOperation) cv).getReceiver(context);
+                cv = ((CompiledOperation) cv).getReceiver(this.context);
-                cv = ((CompiledPath) cv).getReceiver();
+                cv = cv.getReceiver();
-                cv = ((CompiledIndexOperation) cv).getReceiver();
+                cv = cv.getReceiver();
-              reconstruct.add(0, Integer.valueOf(prevCV.getType()));
+              reconstruct.add(0, prevCV.getType());
-            int firstTokenType = ((Integer) reconstruct.get(0)).intValue();
+
+            int firstTokenType = (Integer) reconstruct.get(0);
-              // CompiledPath cp = (CompiledPath) reconstruct.get(1);
+
-                missingLink = new CompiledPath(new CompiledID(name), "value");
-                // missingLinkPath = name + ".value";
+                this.missingLink = new CompiledPath(new CompiledID(name), "value");
-                missingLink = new CompiledPath(new CompiledID(name), "key");
-                isFirstIteratorRegionKey = true;
-                // missingLinkPath = name + ".key";
+                this.missingLink = new CompiledPath(new CompiledID(name), "key");
+                this.isFirstIteratorRegionKey = true;
-                isFirstIteratorRegionEntry = true;
+                this.isFirstIteratorRegionEntry = true;
+
-              int secondTokenType =
-                  (reconstruct.size() > 1) ? ((Integer) reconstruct.get(0)).intValue() : -1;
-              if (!isFirstIteratorRegionEntry
-                  && (secondTokenType == OQLLexerTokenTypes.TOK_LBRACK)) {
-                // Asif: If the field just next to region , is values or
-                // getValues & next to it is
-                // CompiledIndexOpn, it indirectly means Map operation & we are
-                // able to take care of it by adding a flag in CompiledIndexOp
-                // which
-                // indicates to it whether to return entry or value.But if the
-                // field
-                // is asList or toArray , we have a problem as we don't have a
-                // corresponding
-                // list of entries. If the field is keys , an exception should
-                // be thrown
-                // as IndexOpn on set is not defined.
+              int secondTokenType = reconstruct.size() > 1 ? (Integer) reconstruct.get(0) : -1;
+              if (!this.isFirstIteratorRegionEntry
+                  && secondTokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+
+                // If the field just next to region , is values or getValues & next to it is
+                // CompiledIndexOpn, it indirectly means Map operation & we are able to take care of
+                // it by adding a flag in CompiledIndexOp which indicates to it whether to return
+                // entry or value. But if the field is asList or toArray , we have a problem as we
+                // don't have a corresponding list of entries. If the field is keys , an exception
+                // should be thrown as IndexOpn on set is not defined.
-                  additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+                  this.additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+
-                  // TODO:Asif . This needs to be supported
+                  // TODO: add support for toList and toArray
+
-              } else if (!isFirstIteratorRegionEntry
+
+              } else if (!this.isFirstIteratorRegionEntry
-                // Asif :Check if the second token name is toList or toArray or
-                // asSet.We need to remove those
+
+                // Check if the second token name is toList or toArray or asSet.We need to remove
+                // those
-                  remove(reconstruct, ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3 : 2),
-                      0);
+                  remove(reconstruct, secondTokenType == OQLLexerTokenTypes.METHOD_INV ? 3 : 2, 0);
+
-              additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+              this.additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+
-                missingLink = new CompiledPath(new CompiledID(name), "value");
-                // missingLinkPath = name + ".value";
+                this.missingLink = new CompiledPath(new CompiledID(name), "value");
-                missingLink = new CompiledPath(new CompiledID(name), "key");
-                isFirstIteratorRegionKey = true;
-                // missingLinkPath = name + ".key";
+                this.missingLink = new CompiledPath(new CompiledID(name), "key");
+                this.isFirstIteratorRegionKey = true;
-                isFirstIteratorRegionEntry = true;
+                this.isFirstIteratorRegionEntry = true;
+
-              int secondTokenType =
-                  (reconstruct.size() > 1) ? ((Integer) reconstruct.get(0)).intValue() : -1;
-              if (!isFirstIteratorRegionEntry
-                  && (secondTokenType == OQLLexerTokenTypes.TOK_LBRACK)) {
+              int secondTokenType = reconstruct.size() > 1 ? (Integer) reconstruct.get(0) : -1;
+              if (!this.isFirstIteratorRegionEntry
+                  && secondTokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+
-                  // TODO:Asif . This needs to be supported
+                  // TODO: add support for toList and toArray
+
-              } else if (!isFirstIteratorRegionEntry
+              } else if (!this.isFirstIteratorRegionEntry
-                // Asif :Check if the second token name is toList or toArray or
-                // asSet.We need to remove those
+
+                // Check if the second token name is toList or toArray or asSet.We need to remove
+                // those
-                  remove(reconstruct, ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3 : 2),
-                      0);
+                  remove(reconstruct, secondTokenType == OQLLexerTokenTypes.METHOD_INV ? 3 : 2, 0);
-            if (!isFirstIteratorRegionEntry) {
-              additionalProj = missingLink;
+
+            if (!this.isFirstIteratorRegionEntry) {
+              this.additionalProj = this.missingLink;
-                  int tokenType = ((Integer) obj).intValue();
+                  int tokenType = (Integer) obj;
-                    additionalProj =
-                        new CompiledPath(additionalProj, (String) reconstruct.get(++j));
+                    this.additionalProj =
+                        new CompiledPath(this.additionalProj, (String) reconstruct.get(++j));
-                    additionalProj = new CompiledIndexOperation(additionalProj,
+                    this.additionalProj = new CompiledIndexOperation(this.additionalProj,
-                    additionalProj = new CompiledOperation(additionalProj,
+                    this.additionalProj = new CompiledOperation(this.additionalProj,
+
-            indexInitIterators.add(newItr);
+            this.indexInitIterators.add(newItr);
+
-          if (rIter.getDefinition().indexOf(this.canonicalizedIteratorNames[0]) != -1) {
-            newItr =
-                (CompiledIteratorDef) getModifiedDependentCompiledValue(context, i, iterDef, true);
+          if (rIter.getDefinition().contains(this.canonicalizedIteratorNames[0])) {
+            newItr = (CompiledIteratorDef) getModifiedDependentCompiledValue(this.context, i,
+                iterDef, true);
+    } catch (IndexInvalidException e) {
+      throw e;
-      if (e instanceof IndexInvalidException)
-        throw (IndexInvalidException) e;
-              .toLocalizedString(fromClause));
+              .toLocalizedString(this.fromClause));
-  /*
-   * Asif: This fuinction is modified so that if the indexed expression has any dependency on the
-   * 0th iterator, then it needs to modified by using the missing link so that it is derivable from
-   * the 0th iterator.
+  /**
+   * This function is modified so that if the indexed expression has any dependency on the 0th
+   * iterator, then it needs to modified by using the missing link so that it is derivable from the
+   * 0th iterator.
+   * <p>
+   * TODO: refactor large method prepareIndexExpression
-    // List indexedExprs = this.compiler.compileProjectionAttributes(indexedExpression);
-        || expr instanceof CompiledNegation)
+        || expr instanceof CompiledNegation) {
+    }
+
-      StringBuffer sb = new StringBuffer();
+      StringBuilder sb = new StringBuilder();
-        // CompiledIndexOperation cio = (CompiledIndexOperation)expr;
+
-          expr.generateCanonicalizedExpression(sb, context);
+          expr.generateCanonicalizedExpression(sb, this.context);
-          expr.generateCanonicalizedExpression(sb, context);
+          expr.generateCanonicalizedExpression(sb, this.context);
+
-          expr.generateCanonicalizedExpression(sb, context);
+          expr.generateCanonicalizedExpression(sb, this.context);
-          StringBuffer buff2 = new StringBuffer();
+          StringBuilder sb2 = new StringBuilder();
-            this.mapKeys[size - j - 1] = cv.evaluate(context);
-            StringBuffer sbuff = new StringBuffer();
-            cv.generateCanonicalizedExpression(sbuff, context);
-            sbuff.insert(0, prefixStr);
-            sbuff.append(']');
-            this.multiIndexKeysPattern[j] = sbuff.toString();
-            cv.generateCanonicalizedExpression(buff2, context);
-            buff2.insert(0, ',');
+            this.mapKeys[size - j - 1] = cv.evaluate(this.context);
+            StringBuilder sb3 = new StringBuilder();
+            cv.generateCanonicalizedExpression(sb3, this.context);
+            sb3.insert(0, prefixStr);
+            sb3.append(']');
+            this.multiIndexKeysPattern[j] = sb3.toString();
+            cv.generateCanonicalizedExpression(sb2, this.context);
+            sb2.insert(0, ',');
-          buff2.deleteCharAt(0);
-          sb.append(buff2.toString());
+          sb2.deleteCharAt(0);
+          sb.append(sb2);
-        expr.generateCanonicalizedExpression(sb, context);
+        expr.generateCanonicalizedExpression(sb, this.context);
-      // expr.generateCanonicalizedExpression(sb, this.context);
-      // String tempStr = this.indexedExpression;
-      modifiedIndexExpr = expr;
+      this.modifiedIndexExpr = expr;
-          && this.indexedExpression.indexOf(this.canonicalizedIteratorNames[0]) >= 0) {
-        modifiedIndexExpr = getModifiedDependentCompiledValue(context, -1, expr, true);
+          && this.indexedExpression.contains(this.canonicalizedIteratorNames[0])) {
+        this.modifiedIndexExpr = getModifiedDependentCompiledValue(this.context, -1, expr, true);
-      // e.printStackTrace();
-    indexedExpr = expr;
+    this.indexedExpr = expr;
-  private Object[] modfiyIterDefToSuiteIMQ(CompiledIteratorDef iterDef)
+  private Object[] modifyIterDefToSuiteIMQ(CompiledIteratorDef iterDef)
-    Object retValues[] = {null, null};
+    Object[] retValues = {null, null};
-      // System.out.println("def = "+def);
-        retValues[0] = def.evaluate(context);
+        retValues[0] = def.evaluate(this.context);
+
-        CompiledValue prevCV = null;
+
-          prevCV = cv;
+          CompiledValue prevCV = cv;
-            cv = ((CompiledOperation) cv).getReceiver(context);
+            cv = ((CompiledOperation) cv).getReceiver(this.context);
-          reconstruct.add(0, Integer.valueOf(prevCV.getType()));
+          reconstruct.add(0, prevCV.getType());
+
-            int tokenType = ((Integer) obj).intValue();
+            int tokenType = (Integer) obj;
+
-        retValues[0] = v.evaluate(context);
+        retValues[0] = v.evaluate(this.context);
-  /*
-   * Asif : This function is used to correct the complied value's dependency , in case the
-   * compiledvalue is dependent on the 0th RuntimeIterator in some way. Thus the dependent compiled
-   * value is prefixed with the missing link so that it is derivable from the 0th iterator.
+  /**
+   * This function is used to correct the complied value's dependency , in case the compiledValue is
+   * dependent on the 0th RuntimeIterator in some way. Thus the dependent compiled value is prefixed
+   * with the missing link so that it is derivable from the 0th iterator.
+
-      if (canonFrmClause.startsWith(this.canonicalizedIteratorNames[0]))
-        isDependent = true;
-      else
-        isDependent = false;
+
+      // TODO: original value of isDependent is always ignored
+      isDependent = canonFrmClause.startsWith(this.canonicalizedIteratorNames[0]);
+
+
+
-      int len = list.size();
-      for (int i = 0; i < len; ++i) {
-        CompiledValue cv1 = (CompiledValue) list.get(i);
-        StringBuffer sbuff = new StringBuffer();
-        cv1.generateCanonicalizedExpression(sbuff, context);
-        if (sbuff.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+      for (Object aList : list) {
+        CompiledValue cv1 = (CompiledValue) aList;
+        StringBuilder sb = new StringBuilder();
+        cv1.generateCanonicalizedExpression(sb, context);
+        if (sb.toString().startsWith(this.canonicalizedIteratorNames[0])) {
-      // Asif: What if the receiver is null?
+
+      // What if the receiver is null?
+
-        StringBuffer sbuff = new StringBuffer();
-        cv1.generateCanonicalizedExpression(sbuff, context);
-        if (sbuff.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+        StringBuilder sb = new StringBuilder();
+        cv1.generateCanonicalizedExpression(sb, context);
+        if (sb.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+
-        String name = null;
+        String name;
-          // Asif: The CompiledID is a RuneTimeIterator & so it needs to be
-          // replaced by the missing link
+          // The CompiledID is a RuneTimeIterator & so it needs to be replaced by the missing link
-          // Asif: The compiledID is a compiledpath
-          return new CompiledPath(missingLink, id.getId());
+          // The compiledID is a compiledPath
+          return new CompiledPath(this.missingLink, id.getId());
+
-      StringBuffer sbuff = new StringBuffer();
-      cv1.generateCanonicalizedExpression(sbuff, context);
-      if (sbuff.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+      StringBuilder sb = new StringBuilder();
+      cv1.generateCanonicalizedExpression(sb, context);
+      if (sb.toString().startsWith(this.canonicalizedIteratorNames[0])) {

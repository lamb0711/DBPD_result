GEODE-3780: Fixing monitoring of suspected member after passed final check

- Suspected member is never watched again after passing final check

- This restores our original behavior (pre-1.0) behavior of performing a
final check on a member if UDP communications with that member fail.

- We now also send exonoration messages to all other members if a suspect is
cleared.  We need to do that because another member may have sent a
Suspect message that was ignored because the suspect was already
undergoing a final check.

- I also noticed that our tcp/ip final check loop was performing more than
one check in many cases because the nanosecond clock has a coarse
granularity.  A socket so-timeout based on the millisecond clock was
timing out but the nanosecond clock didn't line up with that timeout and
caused the "for" loop to make another attempt.  I changed that loop to
convert the nanosecond clock value to milliseconds.


-      if (GMSHealthMonitor.this.isStopping) {
-        return;
+      GMSMember neighbor = nextNeighbor;
+      if (logger.isDebugEnabled()) {
+        logger.debug("cluster health monitor invoked with {}", neighbor);
-
-      GMSMember neighbour = nextNeighbor;
-
-      long currentTime = System.currentTimeMillis();
-      // this is the start of interval to record member activity
-      GMSHealthMonitor.this.currentTimeStamp = currentTime;
-
-
-      long oldTimeStamp = currentTimeStamp;
-      currentTimeStamp = System.currentTimeMillis();
-
-      GMSMembershipView myView = GMSHealthMonitor.this.currentView;
-      if (myView == null) {
-        return;
-      }
-
-      if (currentTimeStamp - oldTimeStamp > monitorInterval + MONITOR_DELAY_THRESHOLD) {
-        // delay in running this task - don't suspect anyone for a while
-        logger.info(
-            "Failure detector has noticed a JVM pause and is giving all members a heartbeat in view {}",
-            currentView);
-        for (GMSMember member : myView.getMembers()) {
-          contactedBy(member);
-        }
-        return;
-      }
-
-      if (neighbour != null) {
-        TimeStamp nextNeighborTS;
-        synchronized (GMSHealthMonitor.this) {
-          nextNeighborTS = GMSHealthMonitor.this.memberTimeStamps.get(neighbour);
-        }
-
-        if (nextNeighborTS == null) {
-          logger.debug("timestamp for {} was found null - setting current time as timestamp",
-              neighbour);
-          TimeStamp customTS = new TimeStamp(currentTime);
-          memberTimeStamps.put(neighbour, customTS);
+      try {
+        if (GMSHealthMonitor.this.isStopping) {
-        long interval = memberTimeoutInMillis / GMSHealthMonitor.LOGICAL_INTERVAL;
-        long lastTS = currentTime - nextNeighborTS.getTime();
-        if (lastTS + interval >= memberTimeoutInMillis) {
-          logger.debug("Checking member {} ", neighbour);
-          // now do check request for this member;
-          checkMember(neighbour);
+        long currentTime = System.currentTimeMillis();
+        // this is the start of interval to record member activity
+        GMSHealthMonitor.this.currentTimeStamp = currentTime;
+
+        long oldTimeStamp = currentTimeStamp;
+        currentTimeStamp = System.currentTimeMillis();
+
+        GMSMembershipView myView = GMSHealthMonitor.this.currentView;
+        if (myView == null) {
+          return;
+        }
+
+        if (currentTimeStamp - oldTimeStamp > monitorInterval + MONITOR_DELAY_THRESHOLD) {
+          // delay in running this task - don't suspect anyone for a while
+          logger.info(
+              "Failure detector has noticed a JVM pause and is giving all members a heartbeat in view {}",
+              currentView);
+          for (GMSMember member : myView.getMembers()) {
+            contactedBy(member);
+          }
+          return;
+        }
+
+        if (neighbor != null) {
+          TimeStamp nextNeighborTS;
+          synchronized (GMSHealthMonitor.this) {
+            nextNeighborTS = GMSHealthMonitor.this.memberTimeStamps.get(neighbor);
+          }
+
+          if (nextNeighborTS == null) {
+            logger.debug("timestamp for {} was found null - setting current time as timestamp",
+                neighbor);
+            TimeStamp customTS = new TimeStamp(currentTime);
+            memberTimeStamps.put(neighbor, customTS);
+            return;
+          }
+
+          long interval = memberTimeoutInMillis / GMSHealthMonitor.LOGICAL_INTERVAL;
+          long lastTS = currentTime - nextNeighborTS.getTime();
+          if (lastTS + interval >= memberTimeoutInMillis) {
+            logger.debug("Checking member {} ", neighbor);
+            // now do check request for this member;
+            checkMember(neighbor);
+          }
+        }
+      } finally {
+        if (logger.isDebugEnabled()) {
+          logger.debug("cluster health monitor pausing");
-    // in case a timed socket.connect() returns immediately
-    long giveupTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(
-        services.getConfig().getMemberTimeout(), TimeUnit.MILLISECONDS);
+    // in case a timed socket.connect() returns immediately. Use milliseconds to be in
+    // sync with the socket timeout parameter unit of measure
+    long giveupTime = System.currentTimeMillis() + services.getConfig().getMemberTimeout();
-        && System.nanoTime() < giveupTime);
+        && System.currentTimeMillis() < giveupTime);
+    if (membersInFinalCheck.contains(mbr)) {
+      return true; // status unknown for now but someone is checking
+    }
-            + "Current suspects are {}", suspectedMemberIds);
+            + "Current suspects are {}", suspectedMemberIds.keySet());
+    logSuspectRequests(incomingRequest, incomingRequest.getSender());
+
-    logger.debug(
-        "Processing suspect requests {}\nproposed view is currently {}\nwith coordinator {}",
-        suspectRequests, cv, cv.getCoordinator());
+    logger.debug("Processing {}", incomingRequest);
-      logSuspectRequests(incomingRequest, sender);
-      logger.trace(
+      logger.debug(
-        logSuspectRequests(incomingRequest, sender);
+  /**
+   * Check to see if a member is available
+   *
+   * @param initiator member who initiated this check
+   * @param cv the view we're basing the check upon
+   * @param isFinalCheck whether the member should be kicked out if it fails the check
+   * @param mbr the member to check
+   * @param reason why we're doing this check
+   * @return true if the check passes
+   */
-      final GMSMembershipView cv, boolean forceRemovalIfCheckFails, final GMSMember mbr,
+      final GMSMembershipView cv, boolean isFinalCheck, final GMSMember mbr,
-        final boolean retryIfConnectFails = forceRemovalIfCheckFails;
+        final boolean retryIfConnectFails = isFinalCheck;
-          if (forceRemovalIfCheckFails) {
+          if (isFinalCheck) {
-              "Availability check failed but detected recent message traffic for suspect member "
+              "Availability check detected recent message traffic for suspect member "
-        if (!isStopping && !initiator.equals(localAddress)
+        if (!isStopping
-          // let the sender know that it's okay to monitor this member again
+          // let others know that this member is no longer suspect
-          services.getMessenger().send(message);
+          List<GMSMember> members = cv.getMembers();
+          List<GMSMember> recipients = new ArrayList<>(members.size());
+          for (GMSMember member : members) {
+            if (!isSuspectMember(member) && !membersInFinalCheck.contains(member) &&
+                !member.equals(localAddress)) {
+              recipients.add(member);
+            }
+          }
+          if (recipients.size() > 0) {
+            message.setRecipients(recipients);
+            services.getMessenger().send(message);
+          }

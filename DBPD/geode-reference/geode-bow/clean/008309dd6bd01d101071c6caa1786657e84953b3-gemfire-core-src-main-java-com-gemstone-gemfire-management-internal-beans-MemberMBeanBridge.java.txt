Merge branch 'release/1.0.0-incubating.M1'

- * =========================================================================
- *  Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- *  This product is protected by U.S. and international copyright
- *  and intellectual property laws. Pivotal products are covered by
- *  more patents listed at http://www.pivotal.io/patents.
- * ========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSStoreImpl;
+import com.gemstone.gemfire.internal.offheap.MemoryAllocator;
+import com.gemstone.gemfire.internal.offheap.OffHeapMemoryStats;
-      logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage(), e);
+      logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
-      logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage(), e);
+      logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
-        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage(), e);
+        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
-        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage(), e);
+        logger.info(LogMarker.CONFIG, "Command Service could not be initialized. {}", e.getMessage());
+    MemoryAllocator allocator = ((GemFireCacheImpl) cache).getOffHeapStore();
+    if((null != allocator) ) {
+      OffHeapMemoryStats offHeapStats = allocator.getStats();
+      
+      if(null != offHeapStats) {
+        addOffHeapStats(offHeapStats);
+      }
+    }
+
+    
-
+  public void addOffHeapStats(OffHeapMemoryStats offHeapStats) {
+    Statistics offHeapMemoryStatistics = offHeapStats.getStats();
+    monitor.addStatisticsToMonitor(offHeapMemoryStatistics);
+  }
+  
+
+  
+  /**
+   * @return list all the HDFSStore's name at cache level
+   */
+  
+  public String[] getHDFSStores() {
+    GemFireCacheImpl cacheImpl = (GemFireCacheImpl) cache;
+    String[] retStr = null;
+    Collection<HDFSStoreImpl> hdfsStoreCollection = null;
+    hdfsStoreCollection = cacheImpl.getHDFSStores();
+      
+    if (hdfsStoreCollection != null && hdfsStoreCollection.size() > 0) {
+      retStr = new String[hdfsStoreCollection.size()];
+      Iterator<HDFSStoreImpl> it = hdfsStoreCollection.iterator();
+      int i = 0;
+      while (it.hasNext()) {
+        retStr[i] = it.next().getName();
+        i++;
+
+      }
+    }
+    return retStr;
+  }
+      
+      t.setDaemon(false);
-    String[] thrdStr = new String[threadInfos.length];
-    int j = 0;
+    ArrayList<String> thrdStr = new ArrayList<String>(threadInfos.length);
-      thrdStr[j] = thInfo.getThreadName();
-      j++;
+      if (thInfo != null) {
+        thrdStr.add(thInfo.getThreadName());
+      }
-    return thrdStr;
+    String[] result = new String[thrdStr.size()];
+    return thrdStr.toArray(result);
-   * @return maximum heap size in MB
-   */
-  public long getMaximumHeapSize() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.maxMemory() / MBFactor;
-  }
-
-  /**
-   * 
-  /**
-   * 
-   * @return get free heap size
-   */
-  public long getFreeHeapSize() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.freeMemory() / MBFactor;
+  public int getOffHeapObjects() {
+    int objects = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      objects = stats.getObjects();
+    }
+    
+    return objects;
+  @Deprecated
+  public long getOffHeapFreeSize() {
+    return getOffHeapFreeMemory();
+  }
+  
+  @Deprecated
+  public long getOffHeapUsedSize() {
+    return getOffHeapUsedMemory();
+  }
+  
+  public long getOffHeapMaxMemory() {
+    long usedSize = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      usedSize = stats.getMaxMemory();
+    }
+    
+    return usedSize;
+  }
+  
+  public long getOffHeapFreeMemory() {
+    long freeSize = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      freeSize = stats.getFreeMemory();
+    }
+    
+    return freeSize;
+  }
+  
+  public long getOffHeapUsedMemory() {
+    long usedSize = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      usedSize = stats.getUsedMemory();
+    }
+    
+    return usedSize;
+  }
+  
+  public int getOffHeapFragmentation() {
+    int fragmentation = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      fragmentation = stats.getFragmentation();
+    }
+    
+    return fragmentation;        
+  }
+  
+  public long getOffHeapCompactionTime() {
+    long compactionTime = 0;
+    OffHeapMemoryStats stats = getOffHeapStats();
+    
+    if(null != stats) {
+      compactionTime = stats.getCompactionTime();
+    }
+    
+    return compactionTime;            
+  }
+  
-   * 
-   * @return current heap size
+   * Returns the OffHeapMemoryStats for this VM.
-  public long getCurrentHeapSize() {
-    return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue()
-    / MBFactor;
-  }
+  private OffHeapMemoryStats getOffHeapStats() {
+    OffHeapMemoryStats stats = null;
+    
+    MemoryAllocator offHeap = this.cache.getOffHeapStore();
+    
+    if(null != offHeap) {
+      stats = offHeap.getStats();
+    }
-  public long getMaxMemory() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.maxMemory() / MBFactor;
-  }
-  
-  public long getFreeMemory() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.freeMemory() / MBFactor;
-  }
-  
-  public long getUsedMemory() {
-    return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue() / MBFactor;
+    return stats;    
+  public long getMaxMemory() {
+    Runtime rt = Runtime.getRuntime();
+    return rt.maxMemory() / MBFactor;
+  }
+  
+  public long getFreeMemory() {
+    Runtime rt = Runtime.getRuntime();
+    return rt.freeMemory() / MBFactor;
+  }
+  
+  public long getUsedMemory() {
+    return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue() / MBFactor;
+  }

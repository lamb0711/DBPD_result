Geode 4263 (#4691)

GEODE-4263: Cleaned up and phase 1 ready.

- Initial refactor to cleanup
- removing a bunch of thread sleeps
- adding awaits
- One key fix was to increase the latch wait time.
- Added a latch to fix an issue where we might not be waiting long enough
- Requested changes made.

+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.internal.cache.PRQueryProcessor;
+import org.apache.geode.logging.internal.log4j.api.LogService;
+  private static final Logger logger = LogService.getLogger();
+
-  private boolean traceOn = false;
+  private boolean traceOn;
-  /**
-   * Use to represent null result. Used while adding PR results to the results-queue, which is a
-   * blocking queue.
-   */
-  public static final Object NULL_RESULT = new Object();
-
-  public static Map<String, Set<String>> getPdxClasstofieldsmap() {
+  static Map<String, Set<String>> getPdxClasstofieldsmap() {
-
-    final ExecutionContext context = new QueryExecutionContext(params, this.cache, this);
+    final QueryExecutionContext context = new QueryExecutionContext(params, this.cache, this);
-              || (((QueryExecutionContext) context).isIndexUsed()
+              || (context.isIndexUsed()
-    Object result = null;
+    Object result;
-  /**
-   * Execute a PR Query on the specified bucket. Assumes query already meets restrictions for PR
-   * Query, and the first iterator in the FROM clause can be replaced with the BucketRegion.
-   */
-  public Object prExecuteOnBucket(Object[] parameters, PartitionedRegion pr, BucketRegion bukRgn)
-      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    if (parameters == null) {
-      parameters = EMPTY_ARRAY;
-    }
-
-    long startTime = 0L;
-    if (this.traceOn && this.cache != null) {
-      startTime = NanoTimer.getTime();
-    }
-
-    IndexTrackingQueryObserver indexObserver = null;
-    String otherObserver = null;
-    if (this.traceOn) {
-      QueryObserver qo = QueryObserverHolder.getInstance();
-      if (qo instanceof IndexTrackingQueryObserver) {
-        indexObserver = (IndexTrackingQueryObserver) qo;
-      } else if (!QueryObserverHolder.hasObserver()) {
-        indexObserver = new IndexTrackingQueryObserver();
-        QueryObserverHolder.setInstance(indexObserver);
-      } else {
-        otherObserver = qo.getClass().getName();
-      }
-    }
-
-    final ExecutionContext context = new QueryExecutionContext(parameters, this.cache, this);
-    context.setBucketRegion(pr, bukRgn);
-
-    // Check if QueryMonitor is enabled, if enabled add query to be monitored.
-    QueryMonitor queryMonitor = this.cache.getQueryMonitor();
-
-    // PRQueryProcessor executes the query using single thread(in-line) or ThreadPool.
-    // In case of threadPool each individual threads needs to be added into
-    // QueryMonitor Service.
-    if (queryMonitor != null && PRQueryProcessor.NUM_THREADS > 1) {
-      // Add current thread to be monitored by QueryMonitor.
-      queryMonitor.monitorQueryExecution(context);
-    }
-
-    Object result = null;
-    try {
-      result = executeUsingContext(context);
-    } finally {
-      if (queryMonitor != null && PRQueryProcessor.NUM_THREADS > 1) {
-        queryMonitor.stopMonitoringQueryExecution(context);
-      }
-
-      int resultSize = 0;
-      if (this.traceOn) {
-        if (result instanceof Collection) {
-          resultSize = ((Collection) result).size();
-        }
-      }
-
-      String queryVerboseMsg = DefaultQuery.getLogMessage(indexObserver, startTime, otherObserver,
-          resultSize, this.queryString, bukRgn);
-
-      if (this.traceOn) {
-        if (this.cache.getLogger().fineEnabled()) {
-          this.cache.getLogger().fine(queryVerboseMsg);
-        }
-      }
-    }
-    return result;
-  }
-
-
-
-      itrDef.visitNodes(new CompiledValue.NodeVisitor() {
-        @Override
-        public boolean visit(CompiledValue node) {
-          if (node instanceof CompiledSelect) {
-            throw new UnsupportedOperationException(
-                "When querying a PartitionedRegion, the first FROM clause iterator must not contain a subquery");
-          }
-          return true;
+      itrDef.visitNodes(node -> {
+        if (node instanceof CompiledSelect) {
+          throw new UnsupportedOperationException(
+              "When querying a PartitionedRegion, the first FROM clause iterator must not contain a subquery");
+        return true;
-    StringBuilder sb = new StringBuilder("Query String = ");
-    sb.append(this.queryString);
-    sb.append("; Total Executions = ");
-    sb.append(this.numExecutions);
-    sb.append("; Total Execution Time = ");
-    sb.append(this.totalExecutionTime);
-    return sb.toString();
+    return "Query String = " + this.queryString
+        + "; Total Executions = "
+        + this.numExecutions
+        + "; Total Execution Time = "
+        + this.totalExecutionTime;
-
-    };
+    }

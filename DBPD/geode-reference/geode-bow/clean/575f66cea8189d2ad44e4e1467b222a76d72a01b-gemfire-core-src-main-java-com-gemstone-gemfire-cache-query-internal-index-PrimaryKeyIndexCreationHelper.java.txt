GEODE-323: Primary Key indexes are not being properly used for Partitioned Region Queries

Iterator naming is set at the bucket index level, however lookups are done on the PartitionIndex level.
When a lookup occurs, it will not find the correct mapping to index iterator name. This leads to no
matching indexes when expecting a primary key index lookup.
The fix is to populate a shared map at the PartitionIndex level for all bucket indexes and do the look
up at the PartitionIndex level.

Fix bug where isPopulate flag is not being set on PrimaryKey indexes that prevented them from being used.

-import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
+import java.util.List;
+
-import com.gemstone.gemfire.cache.query.internal.*;
+import com.gemstone.gemfire.cache.query.internal.CompiledIteratorDef;
+import com.gemstone.gemfire.cache.query.internal.CompiledValue;
+import com.gemstone.gemfire.cache.query.internal.ExecutionContext;
+import com.gemstone.gemfire.cache.query.internal.RuntimeIterator;
-import java.util.List;
+import com.gemstone.gemfire.internal.cache.PartitionedRegion;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-      //    Asif: Bind the Index_Internal_ID to the RuntimeIterator
-      String name = imgr.putCanonicalizedIteratorNameIfAbsent(definition);
+      //    Asif: Bind the Index_Internal_ID to the RuntimeIterator      
+      PartitionedRegion pr = this.context.getPartitionedRegion();
+      this.canonicalizedIteratorNames = new String[1];
+      String name = null;
+      if (pr != null) {
+        name = pr.getIndexManager().putCanonicalizedIteratorNameIfAbsent(definition);
+      } else {
+        name = imgr.putCanonicalizedIteratorNameIfAbsent(definition);
+      }
-      this.fromClause = new StringBuffer(definition).append(' ').append(name)
-          .toString();
+      this.fromClause = new StringBuffer(definition).append(' ').append(name).toString();

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class FunctionStreamingResultCollector extends ReplyProcessor21 implements
-    ResultCollector {
+public class FunctionStreamingResultCollector extends ReplyProcessor21 implements ResultCollector {
-  
+
-  
+
-  
+
-  
+
-  
-  private final Map<InternalDistributedMember,Status> statusMap = new HashMap<InternalDistributedMember,Status>();
-  
+
+  private final Map<InternalDistributedMember, Status> statusMap =
+      new HashMap<InternalDistributedMember, Status>();
+
-  
+
-  
-  protected AbstractExecution execution;  
-  
+
+  protected AbstractExecution execution;
+
-  public FunctionStreamingResultCollector(
-      StreamingFunctionOperation streamingFunctionOperation,
-      InternalDistributedSystem system, Set members, ResultCollector rc,
-      Function function, AbstractExecution execution) {
+  public FunctionStreamingResultCollector(StreamingFunctionOperation streamingFunctionOperation,
+      InternalDistributedSystem system, Set members, ResultCollector rc, Function function,
+      AbstractExecution execution) {
-      ((LocalResultCollector<?, ?>)rc).setProcessor(this);
+      ((LocalResultCollector<?, ?>) rc).setProcessor(this);
-      }
-      catch (RuntimeException badre) {
+      } catch (RuntimeException badre) {
-      }
-      catch (Exception bade) {
+      } catch (Exception bade) {
-  
+
-          LocalizedStrings.ExecuteFunction_RESULTS_ALREADY_COLLECTED
-              .toLocalizedString());
+          LocalizedStrings.ExecuteFunction_RESULTS_ALREADY_COLLECTED.toLocalizedString());
-        }
-        else {
+        } else {
-            }
-            else {
+            } else {
-      }
-      catch (FunctionInvocationTargetException fite) {
-        if (!(execution instanceof DistributedRegionFunctionExecutor || execution instanceof MultiRegionFunctionExecutor)
-            || !fn.isHA()) {
+      } catch (FunctionInvocationTargetException fite) {
+        if (!(execution instanceof DistributedRegionFunctionExecutor
+            || execution instanceof MultiRegionFunctionExecutor) || !fn.isHA()) {
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-          FunctionInvocationTargetException iFITE = new InternalFunctionInvocationTargetException(
-              fite.getMessage());
+          FunctionInvocationTargetException iFITE =
+              new InternalFunctionInvocationTargetException(fite.getMessage());
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-      }
-      catch (CacheClosedException e) {
-        if (!(execution instanceof DistributedRegionFunctionExecutor || execution instanceof MultiRegionFunctionExecutor)
-            || !fn.isHA()) {
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
+      } catch (CacheClosedException e) {
+        if (!(execution instanceof DistributedRegionFunctionExecutor
+            || execution instanceof MultiRegionFunctionExecutor) || !fn.isHA()) {
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-          FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-              e.getMessage());
+          FunctionInvocationTargetException fite =
+              new InternalFunctionInvocationTargetException(e.getMessage());
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-//      catch (CacheException e) {
-//        throw new FunctionException(e);
-//      }
+      // catch (CacheException e) {
+      // throw new FunctionException(e);
+      // }
-        if (!(execution instanceof DistributedRegionFunctionExecutor || execution instanceof MultiRegionFunctionExecutor)
-            || !fn.isHA()) {
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
+        if (!(execution instanceof DistributedRegionFunctionExecutor
+            || execution instanceof MultiRegionFunctionExecutor) || !fn.isHA()) {
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-          FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-              e.getMessage());
+          FunctionInvocationTargetException fite =
+              new InternalFunctionInvocationTargetException(e.getMessage());
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          LocalizedStrings.ExecuteFunction_RESULTS_ALREADY_COLLECTED
-              .toLocalizedString());
+          LocalizedStrings.ExecuteFunction_RESULTS_ALREADY_COLLECTED.toLocalizedString());
-          isNotTimedOut = this
-              .waitForCacheOrFunctionException(timeoutInMillis);
-        }
-        else {
+          isNotTimedOut = this.waitForCacheOrFunctionException(timeoutInMillis);
+        } else {
-            }
-            else {
+            } else {
-      }
-      catch (FunctionInvocationTargetException fite) {  //this is case of WrapperException which enforce the re execution of the function.
-        if (!(execution instanceof DistributedRegionFunctionExecutor || execution instanceof MultiRegionFunctionExecutor)
-            || !fn.isHA()) {
+      } catch (FunctionInvocationTargetException fite) { // this is case of WrapperException which
+                                                         // enforce the re execution of the
+                                                         // function.
+        if (!(execution instanceof DistributedRegionFunctionExecutor
+            || execution instanceof MultiRegionFunctionExecutor) || !fn.isHA()) {
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-          FunctionInvocationTargetException iFITE = new InternalFunctionInvocationTargetException(
-              fite.getMessage());
+          FunctionInvocationTargetException iFITE =
+              new InternalFunctionInvocationTargetException(fite.getMessage());
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-      }
-      catch (CacheClosedException e) {
-        if (!(execution instanceof DistributedRegionFunctionExecutor || execution instanceof MultiRegionFunctionExecutor)
-            || !fn.isHA()) {
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
+      } catch (CacheClosedException e) {
+        if (!(execution instanceof DistributedRegionFunctionExecutor
+            || execution instanceof MultiRegionFunctionExecutor) || !fn.isHA()) {
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-          FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-              e.getMessage());
+          FunctionInvocationTargetException fite =
+              new InternalFunctionInvocationTargetException(e.getMessage());
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-//      catch (CacheException e) {
-//        endResults();
-//        throw new FunctionException(e);
-//      }
+      // catch (CacheException e) {
+      // endResults();
+      // throw new FunctionException(e);
+      // }
-        if (!(execution instanceof DistributedRegionFunctionExecutor || execution instanceof MultiRegionFunctionExecutor)
-            || !fn.isHA()) {
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
+        if (!(execution instanceof DistributedRegionFunctionExecutor
+            || execution instanceof MultiRegionFunctionExecutor) || !fn.isHA()) {
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-          FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-              e.getMessage());
+          FunctionInvocationTargetException fite =
+              new InternalFunctionInvocationTargetException(e.getMessage());
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-  public void memberDeparted(final InternalDistributedMember id,
-      final boolean crashed) {
+  public void memberDeparted(final InternalDistributedMember id, final boolean crashed) {
-      if (removeMember(id, true)) {
-        FunctionInvocationTargetException fe;
-        if (execution instanceof DistributedRegionFunctionExecutor
-            || execution instanceof MultiRegionFunctionExecutor) {
-          if (!this.fn.isHA()) {
-            // need to add LocalizedStrings messages
+        if (removeMember(id, true)) {
+          FunctionInvocationTargetException fe;
+          if (execution instanceof DistributedRegionFunctionExecutor
+              || execution instanceof MultiRegionFunctionExecutor) {
+            if (!this.fn.isHA()) {
+              // need to add LocalizedStrings messages
+              fe = new FunctionInvocationTargetException(
+                  LocalizedStrings.MemberMessage_MEMBERRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
+                      .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}),
+                  id);
+            } else {
+              fe = new InternalFunctionInvocationTargetException(
+                  LocalizedStrings.DistributionMessage_DISTRIBUTIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
+                      .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}),
+                  id);
+              if (execution.isClientServerMode()) {
+                if (this.userRC != null) {
+                  this.endResultRecieved = false;
+                  this.userRC.endResults();
+                  this.userRC.clearResults();
+                }
+              } else {
+                if (removedNodes == null) {
+                  removedNodes = new HashSet<InternalDistributedMember>();
+                }
+                removedNodes.add(id);
+              }
+            }
+            this.fites.add(fe);
+          } else {
-                    .toLocalizedString(new Object[] { id,
-                        Boolean.valueOf(crashed) }), id);
-          } else {
-            fe = new InternalFunctionInvocationTargetException(
-                LocalizedStrings.DistributionMessage_DISTRIBUTIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
-                    .toLocalizedString(new Object[] { id,
-                        Boolean.valueOf(crashed) }), id);
-            if (execution.isClientServerMode()) {
-              if (this.userRC != null) {
-                this.endResultRecieved = false;
-                this.userRC.endResults();
-                this.userRC.clearResults();
-              }
-            } else {
-              if (removedNodes == null) {
-                removedNodes = new HashSet<InternalDistributedMember>();
-              }
-              removedNodes.add(id);
-            }
+                    .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}),
+                id);
-        } else {
-          fe = new FunctionInvocationTargetException(
-              LocalizedStrings.MemberMessage_MEMBERRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
-                  .toLocalizedString(new Object[] { id,
-                      Boolean.valueOf(crashed) }), id);
-        this.fites.add(fe);
-      }
-   * @throws CacheException
-   *                 if the recipient threw a cache exception during message
-   *                 processing
-   * @throws ForceReattemptException
-   *                 if the recipient left the distributed system before the
-   *                 response was received.
-   * @throws RegionDestroyedException
-   *                 if the peer has closed its copy of the region
+   * @throws CacheException if the recipient threw a cache exception during message processing
+   * @throws ForceReattemptException if the recipient left the distributed system before the
+   *         response was received.
+   * @throws RegionDestroyedException if the peer has closed its copy of the region
-      }
-      else {
+      } else {
-    }
-    catch (ReplyException e) {
+    } catch (ReplyException e) {
-        throw (CacheException)t;
-      }
-      else if (t instanceof RegionDestroyedException) {
-        throw (RegionDestroyedException)t;
-      }
-      else if (t instanceof ForceReattemptException) {
+        throw (CacheException) t;
+      } else if (t instanceof RegionDestroyedException) {
+        throw (RegionDestroyedException) t;
+      } else if (t instanceof ForceReattemptException) {
-      }
-      else if (t instanceof PrimaryBucketException) {
+      } else if (t instanceof PrimaryBucketException) {
-        String msg = "PartitionResponse got remote CacheClosedException, throwing PartitionedRegionCommunicationException";
+        String msg =
+            "PartitionResponse got remote CacheClosedException, throwing PartitionedRegionCommunicationException";
-        throw (CancelException)t;
+        throw (CancelException) t;
-      if(e.getCause() instanceof FunctionException){
-        throw (FunctionException)e.getCause();
+      if (e.getCause() instanceof FunctionException) {
+        throw (FunctionException) e.getCause();
-  
+
+
-      
+
-  
+
-      ReplyMessage m = (ReplyMessage)msg;
+      ReplyMessage m = (ReplyMessage) msg;
-        FunctionStreamingReplyMessage functionReplyMsg = (FunctionStreamingReplyMessage)m;
+        FunctionStreamingReplyMessage functionReplyMsg = (FunctionStreamingReplyMessage) m;
-          this.functionResultWaiter
-              .processData(result, isLast, msg.getSender());
+          this.functionResultWaiter.processData(result, isLast, msg.getSender());
-        if(isLast) {
+        if (isLast) {
-      }
-      else {
-        if (execution.forwardExceptions || (execution.waitOnException 
-            /*&& !(m.getException().getCause() instanceof BucketMovedException)*/)) {
+      } else {
+        if (execution.forwardExceptions || (execution.waitOnException
+        /* && !(m.getException().getCause() instanceof BucketMovedException) */)) {
-            this.functionResultWaiter.processData(m.getException().getCause(), true, msg.getSender());
+            this.functionResultWaiter.processData(m.getException().getCause(), true,
+                msg.getSender());
-    }
-    finally {
+    } finally {
-      checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signalling to proceed
+      checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signalling to
+                     // proceed
-  
+
+
-   * Overridden to wait for messages being currently processed: This situation
-   * can come about if a member departs while we are still processing data
-   * from that member
+   * Overridden to wait for messages being currently processed: This situation can come about if a
+   * member departs while we are still processing data from that member
- @Override
+  @Override
-      ReplyException re = new ReplyException(
-          new DistributedSystemDisconnectedException(
-              LocalizedStrings.ReplyProcessor21_ABORTED_DUE_TO_SHUTDOWN
-                  .toLocalizedString()));
+      ReplyException re = new ReplyException(new DistributedSystemDisconnectedException(
+          LocalizedStrings.ReplyProcessor21_ABORTED_DUE_TO_SHUTDOWN.toLocalizedString()));
-  
+
-    
+
-    }
-    else if (!execution.getWaitOnExceptionFlag()) {
+    } else if (!execution.getWaitOnExceptionFlag()) {
-    if (this.execution.isIgnoreDepartedMembers() ) {
+    if (this.execution.isIgnoreDepartedMembers()) {
-    // this exception will be saved in this.exception 
+    // this exception will be saved in this.exception
-    if(this.execution.waitOnException) {
+    if (this.execution.waitOnException) {

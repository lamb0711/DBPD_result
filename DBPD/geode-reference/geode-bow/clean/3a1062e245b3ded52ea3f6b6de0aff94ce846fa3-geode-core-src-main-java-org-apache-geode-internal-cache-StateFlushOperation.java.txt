GEODE-2787: StateFlushOperation will now wait for in flight operations from the recipient

-                       boolean flushNewOps) throws InterruptedException {
+      boolean flushNewOps) throws InterruptedException {
+        // wait for inflight operations to the aeqs even if the recipient is the primary
+        Set<DistributedRegion> regions = getRegions(dm);
+        for (DistributedRegion r : regions) {
+          if (r != null) {
+            if (this.allRegions && r.doesNotDistribute()) {
+              // no need to flush a region that does no distribution
+              continue;
+            }
+            waitForCurrentOperations(r, r.isInitialized());
+          }
+        }
-          Set<DistributedRegion> regions;
-          if (this.allRegions) {
-            regions = getAllRegions(dm);
-          } else {
-            regions = Collections.singleton(this.getRegion(dm));
-          }
+          Set<DistributedRegion> regions = getRegions(dm);
-              if (initialized) {
-                if (this.flushNewOps) {
-                  r.getDistributionAdvisor().forceNewMembershipVersion(); // force a new "view" so
-                  // we can track current
-                  // ops
-                }
-                try {
-                  r.getDistributionAdvisor().waitForCurrentOperations();
-                } catch (RegionDestroyedException e) {
-                  // continue with the next region
-                }
-              }
+              waitForCurrentOperations(r, initialized);
+    private void waitForCurrentOperations(final DistributedRegion r, final boolean initialized) {
+      if (initialized) {
+        if (this.flushNewOps) {
+          r.getDistributionAdvisor().forceNewMembershipVersion(); // force a new "view" so
+          // we can track current
+          // ops
+        }
+        try {
+          r.getDistributionAdvisor().waitForCurrentOperations();
+        } catch (RegionDestroyedException e) {
+          // continue with the next region
+        }
+      }
+    }
+
+    private Set<DistributedRegion> getRegions(final DistributionManager dm) {
+      Set<DistributedRegion> regions;
+      if (this.allRegions) {
+        regions = getAllRegions(dm);
+      } else {
+        regions = Collections.singleton(this.getRegion(dm));
+      }
+      return regions;
+    }
+
+

Merge branch 'release/1.0.0-incubating.M1'

- * =========================================================================
- *  Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- *  This product is protected by U.S. and international copyright
- *  and intellectual property laws. Pivotal products are covered by
- *  more patents listed at http://www.pivotal.io/patents.
- * =========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.StringTokenizer;
+
+  public static final String AZUL_JVM_VENDOR_NAME = "Azul";
+   * In the Azul JVM java.version does not have the "_NN" suffix. Instead it has the azul product version
+   * as the suffix like so "-zing_NN.NN.N.N". So on azul we instead use the "java.specification.version" sys prop
+   * and only compare the major and minor version numbers. All the stuff after the second "." in expectedVersion
+   * is ignored.
-   * @param expectedVersion an int value specifying the minimum expected version of the Java Runtime.
+   * @param expectedVersion an string value specifying the minimum expected version of the Java Runtime.
-  public static boolean isJavaVersionAtLeast(final String expectedVersion) {
-    String actualVersionDigits = StringUtils.getDigitsOnly(System.getProperty("java.version"));
+  public static boolean isJavaVersionAtLeast(String expectedVersion) {
+    String actualVersionDigits;
+    if (isAzulJVM()) {
+      actualVersionDigits = StringUtils.getDigitsOnly(System.getProperty("java.specification.version"));
+      int dotIdx = expectedVersion.indexOf('.');
+      if (dotIdx != -1) {
+        dotIdx = expectedVersion.indexOf('.', dotIdx+1);
+        if (dotIdx != -1) {
+          // strip off everything after the second dot.
+          expectedVersion = expectedVersion.substring(0, dotIdx);
+        }
+      }
+    } else {
+      actualVersionDigits = StringUtils.getDigitsOnly(System.getProperty("java.version"));
+    }
+  /**
+   * Utility method to determine whether the Java application process is executing on the Azul JVM.
+   *
+   * @return a boolean value indicating whether the Java application process is executing and running 
+   * on the Azul JVM.
+   * @see #isJvmVendor(String)
+   */
+  public static boolean isAzulJVM() {
+    return isJvmVendor(AZUL_JVM_VENDOR_NAME);
+  }
+  
+
+  /**
+   * Returns true if the specified location is in the JVM classpath. This may
+   * ignore additions to the classpath that are not reflected by the value in
+   * <code>System.getProperty("java.class.path")</code>.
+   * 
+   * @param location the directory or jar name to test for
+   * @return true if location is in the JVM classpath
+   * @throws MalformedURLException
+   */
+  public static boolean isInClassPath(String location) throws MalformedURLException {
+    return isInClassPath(new File(location).toURI().toURL());
+  }
+  
+  /**
+   * Returns true if the specified location is in the JVM classpath. This may
+   * ignore additions to the classpath that are not reflected by the value in
+   * <code>System.getProperty("java.class.path")</code>.
+   * 
+   * @param location the directory or jar URL to test for
+   * @return true if location is in the JVM classpath
+   * @throws MalformedURLException
+   */
+  public static boolean isInClassPath(URL location) throws MalformedURLException {
+    String classPath = System.getProperty("java.class.path");
+    StringTokenizer st = new StringTokenizer(classPath, File.pathSeparator);
+    while (st.hasMoreTokens()) {
+      String path =st.nextToken();
+      if (location.equals(new File(path).toURI().toURL())) {
+        return true;
+      }
+    }
+    return false;
+  }
+  

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * Constructor for the index creation message to be sent over the wire
-   * with all the relevant information.
+   * Constructor for the index creation message to be sent over the wire with all the relevant
+   * information.
-   * @param recipients
-   *          members to which this message has to be sent
-   * @param regionId
-   *          partitioned region id
-   * @param processor
-   *          The processor to reply to
-   * @param indexDefinitions
-   *          definitions for the indexes
+   * @param recipients members to which this message has to be sent
+   * @param regionId partitioned region id
+   * @param processor The processor to reply to
+   * @param indexDefinitions definitions for the indexes
-  IndexCreationMsg(Set recipients, int regionId,
-      ReplyProcessor21 processor, HashSet<IndexCreationData> indexDefinitions) {
+  IndexCreationMsg(Set recipients, int regionId, ReplyProcessor21 processor,
+      HashSet<IndexCreationData> indexDefinitions) {
-   * This message may be sent to nodes before the PartitionedRegion is
-   * completely initialized due to the RegionAdvisor(s) knowing about the
-   * existance of a partitioned region at a very early part of the
-   * initialization
+   * This message may be sent to nodes before the PartitionedRegion is completely initialized due to
+   * the RegionAdvisor(s) knowing about the existance of a partitioned region at a very early part
+   * of the initialization
-   * This method actually operates on the partitioned region and creates given
-   * list of indexes from a index creation message.
+   * This method actually operates on the partitioned region and creates given list of indexes from
+   * a index creation message.
-   * @param dm
-   *          distribution manager.
-   * @param pr
-   *          partitioned region on which to create an index.
-   * @throws CacheException
-   *           indicating a cache level error
-   * @throws ForceReattemptException
-   *           if the peer is no longer available
+   * @param dm distribution manager.
+   * @param pr partitioned region on which to create an index.
+   * @throws CacheException indicating a cache level error
+   * @throws ForceReattemptException if the peer is no longer available
-  protected boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion pr, long startTime) throws CacheException,
-      ForceReattemptException {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr,
+      long startTime) throws CacheException, ForceReattemptException {
-      logger.debug("Processing index creation message on this remote partitioned region vm for indexes: {}", sb);
+      logger.debug(
+          "Processing index creation message on this remote partitioned region vm for indexes: {}",
+          sb);
-          LocalizedStrings.IndexCreationMsg_REMOTE_INDEX_CREAION_FAILED
-              .toLocalizedString(),
-          e1);
+          LocalizedStrings.IndexCreationMsg_REMOTE_INDEX_CREAION_FAILED.toLocalizedString(), e1);
-      
+
-        for(Exception ex: exx.getExceptionsMap().values()) {
+        for (Exception ex : exx.getExceptionsMap().values()) {
-          LocalizedStrings.IndexCreationMsg_REMOTE_INDEX_CREAION_FAILED
-              .toLocalizedString(),
-          exx);
+          LocalizedStrings.IndexCreationMsg_REMOTE_INDEX_CREAION_FAILED.toLocalizedString(), exx);
-      for(Index index : indexes) {
-        PartitionedIndex prIndex = (PartitionedIndex)index;
+      for (Index index : indexes) {
+        PartitionedIndex prIndex = (PartitionedIndex) index;
-      sendReply(getSender(), getProcessorId(), dm, replyEx, result, indexBucketsMap, pr.getDataStore().getAllLocalBuckets().size());
+      sendReply(getSender(), getProcessorId(), dm, replyEx, result, indexBucketsMap,
+          pr.getDataStore().getAllLocalBuckets().size());
-        if(!failedIndexNames.contains(icd.getIndexName())) {
-          PartitionedIndex prIndex = (PartitionedIndex)pr.getIndex(icd.getIndexName());
+        if (!failedIndexNames.contains(icd.getIndexName())) {
+          PartitionedIndex prIndex = (PartitionedIndex) pr.getIndex(icd.getIndexName());
-      sendReply(getSender(), getProcessorId(), dm, replyEx, result, indexBucketsMap, pr.getDataStore().getAllLocalBuckets().size());
+      sendReply(getSender(), getProcessorId(), dm, replyEx, result, indexBucketsMap,
+          pr.getDataStore().getAllLocalBuckets().size());
-      logger.debug("Multi Index creation completed on remote host and has sent the reply to the originating vm.");
+      logger.debug(
+          "Multi Index creation completed on remote host and has sent the reply to the originating vm.");
-              logger.debug("Waiting for Partitioned Region to be intialized with id {}for processing index creation messages",
+              logger.debug(
+                  "Waiting for Partitioned Region to be intialized with id {}for processing index creation messages",
-                logger.debug("IndexCreationMsg waiting for pr to be properly created with prId : {}", this.regionId);
+                logger.debug(
+                    "IndexCreationMsg waiting for pr to be properly created with prId : {}",
+                    this.regionId);
-          logger.debug("Waiting for notification from pr being properly created on {}", this.regionId);
+          logger.debug("Waiting for notification from pr being properly created on {}",
+              this.regionId);
-              logger.debug("IndexCreationMsg waiting for pr to be properly created with prId : {}", this.regionId);
+              logger.debug("IndexCreationMsg waiting for pr to be properly created with prId : {}",
+                  this.regionId);
-        String msg = LocalizedStrings.IndexCreationMsg_COULD_NOT_GET_PARTITIONED_REGION_FROM_ID_0_FOR_MESSAGE_1_RECEIVED_ON_MEMBER_2_MAP_3
-            .toLocalizedString(new Object[] { Integer.valueOf(this.regionId),
-                this, dm.getId(), PartitionedRegion.dumpPRId() });
-        throw new PartitionedRegionException(msg, new RegionNotFoundException(
-            msg));
+        String msg =
+            LocalizedStrings.IndexCreationMsg_COULD_NOT_GET_PARTITIONED_REGION_FROM_ID_0_FOR_MESSAGE_1_RECEIVED_ON_MEMBER_2_MAP_3
+                .toLocalizedString(new Object[] {Integer.valueOf(this.regionId), this, dm.getId(),
+                    PartitionedRegion.dumpPRId()});
+        throw new PartitionedRegionException(msg, new RegionNotFoundException(msg));
-        logger.debug(LogMarker.DM, "Exception caught while processing message: {}", t.getMessage(), t);
+        logger.debug(LogMarker.DM, "Exception caught while processing message: {}", t.getMessage(),
+            t);
-          logger.info(LocalizedMessage.create(LocalizedStrings.IndexCreationMsg_REGION_IS_LOCALLY_DESTROYED_THROWING_REGIONDESTROYEDEXCEPTION_FOR__0, pr));
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.IndexCreationMsg_REGION_IS_LOCALLY_DESTROYED_THROWING_REGIONDESTROYEDEXCEPTION_FOR__0,
+              pr));
-                  .toLocalizedString(dm.getId()), pr.getFullPath());
+                  .toLocalizedString(dm.getId()),
+              pr.getFullPath());
-   * @param recipient
-   *          set of members.
-   * @param pr
-   *          partitoned region associated with the index.
-   * @param indexDefinitions
-   *          set of index definitions
+   * @param recipient set of members.
+   * @param pr partitoned region associated with the index.
+   * @param indexDefinitions set of index definitions
-  public static PartitionResponse send(InternalDistributedMember recipient,
-      PartitionedRegion pr, HashSet<IndexCreationData> indexDefinitions) {
+  public static PartitionResponse send(InternalDistributedMember recipient, PartitionedRegion pr,
+      HashSet<IndexCreationData> indexDefinitions) {
-    
+
-        throw new UnsupportedOperationException("Indexes should not be created during rolling upgrade");
+        throw new UnsupportedOperationException(
+            "Indexes should not be created during rolling upgrade");
-    
+
-      processor = (IndexCreationResponse) (new IndexCreationMsg())
-          .createReplyProcessor(pr, recipients);
+      processor =
+          (IndexCreationResponse) (new IndexCreationMsg()).createReplyProcessor(pr, recipients);
-    IndexCreationMsg indMsg = new IndexCreationMsg(recipients,
-        pr.getPRId(), processor, indexDefinitions);
+    IndexCreationMsg indMsg =
+        new IndexCreationMsg(recipients, pr.getPRId(), processor, indexDefinitions);
-   * @param member
-   *          representing the actual index creatro in the system
-   * @param procId
-   *          waiting processor
-   * @param dm
-   *          distribution manager to send the message
-   * @param ex
-   *          any exceptions
-   * @param result
-   *          represents index created properly or not.
-   * @param indexBucketsMap
-   *          Map of indexes created and number of buckets indexed
-   * @param numTotalBuckets
-   *          Number of total buckets in this vm
+   * @param member representing the actual index creatro in the system
+   * @param procId waiting processor
+   * @param dm distribution manager to send the message
+   * @param ex any exceptions
+   * @param result represents index created properly or not.
+   * @param indexBucketsMap Map of indexes created and number of buckets indexed
+   * @param numTotalBuckets Number of total buckets in this vm
-  void sendReply(InternalDistributedMember member, int procId, DM dm,
-      ReplyException ex, boolean result, Map<String, Integer> indexBucketsMap, int numTotalBuckets) {
-    IndexCreationReplyMsg.send(member, procId, dm, ex, result,
-        indexBucketsMap, numTotalBuckets);
+  void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      boolean result, Map<String, Integer> indexBucketsMap, int numTotalBuckets) {
+    IndexCreationReplyMsg.send(member, procId, dm, ex, result, indexBucketsMap, numTotalBuckets);
-  public final void fromData(DataInput in) throws IOException,
-      ClassNotFoundException {
+  public final void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  
+
-  
+
-   * Class representing index creation response. This class has all the
-   * information for successful or unsuccessful index creation on this member of
-   * the partitioned region.
+   * Class representing index creation response. This class has all the information for successful
+   * or unsuccessful index creation on this member of the partitioned region.
-     * @param ds
-     *          distributed system for this member.
-     * @param recipients
-     *          all the member associated with the index
+     * @param ds distributed system for this member.
+     * @param recipients all the member associated with the index
-     * @return IndexCreationResult for creation of  indexes
-     * @throws CacheException
-     *           indicating a cache level error
-     * @throws ForceReattemptException
-     *           if the peer is no longer available
+     * @return IndexCreationResult for creation of indexes
+     * @throws CacheException indicating a cache level error
+     * @throws ForceReattemptException if the peer is no longer available
-    public IndexCreationResult waitForResult() throws CacheException,
-        ForceReattemptException {
+    public IndexCreationResult waitForResult() throws CacheException, ForceReattemptException {
-     * @param result
-     *          true if index created properly
-     * @param indexBucketsMap
-     *          Map of indexes created and number of buckets indexed
-     * @param numTotalBuckets
-     *          Number of total buckets in this vm
+     * @param result true if index created properly
+     * @param indexBucketsMap Map of indexes created and number of buckets indexed
+     * @param numTotalBuckets Number of total buckets in this vm
-    public void setResponse(boolean result, Map<String, Integer> indexBucketsMap, int numTotalBuckets) {
+    public void setResponse(boolean result, Map<String, Integer> indexBucketsMap,
+        int numTotalBuckets) {
-     * @param indexBucketsMap
-     *          Map of indexes created and number of buckets indexed
-     * @param numTotalBuckets
-     *          Number of total buckets in this vm
+     * @param indexBucketsMap Map of indexes created and number of buckets indexed
+     * @param numTotalBuckets Number of total buckets in this vm
-   * Class for index creation reply. This class has the information about
-   * successful index creation.
+   * Class for index creation reply. This class has the information about successful index creation.
-     * @param processorId
-     *          processor id of the waiting processor
-     * @param ex
-     *          any exceptions
-     * @param result
-     *          true if index created properly else false
-     * @param indexBucketsMap
-     *          Map of indexes created and number of buckets indexed
-     * @param numTotalBuckets
-     *          Number of total buckets in this vm
+     * @param processorId processor id of the waiting processor
+     * @param ex any exceptions
+     * @param result true if index created properly else false
+     * @param indexBucketsMap Map of indexes created and number of buckets indexed
+     * @param numTotalBuckets Number of total buckets in this vm
-    IndexCreationReplyMsg(int processorId, ReplyException ex,
-        boolean result, boolean isDataStore, Map<String, Integer> indexBucketsMap, int numTotalBuckets) {
+    IndexCreationReplyMsg(int processorId, ReplyException ex, boolean result, boolean isDataStore,
+        Map<String, Integer> indexBucketsMap, int numTotalBuckets) {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-     * @param recipient
-     *          the originator of index creation message
-     * @param processorId
-     *          waiting processor id
-     * @param dm
-     *          distribution manager
-     * @param ex
-     *          any exceptions
-     * @param result
-     *          true is index created successfully
-     * @param indexBucketsMap
-     *          Map of indexes created and number of buckets indexed
-     * @param numTotalBuckets
-     *          Number of total buckets in this vm
+     * @param recipient the originator of index creation message
+     * @param processorId waiting processor id
+     * @param dm distribution manager
+     * @param ex any exceptions
+     * @param result true is index created successfully
+     * @param indexBucketsMap Map of indexes created and number of buckets indexed
+     * @param numTotalBuckets Number of total buckets in this vm
-    public static void send(InternalDistributedMember recipient,
-        int processorId, DM dm, ReplyException ex, boolean result,
-        Map<String, Integer> indexBucketsMap, int numTotalBuckets) {
-      IndexCreationReplyMsg indMsg = new IndexCreationReplyMsg(
-          processorId, ex, result, result, indexBucketsMap, numTotalBuckets);
+    public static void send(InternalDistributedMember recipient, int processorId, DM dm,
+        ReplyException ex, boolean result, Map<String, Integer> indexBucketsMap,
+        int numTotalBuckets) {
+      IndexCreationReplyMsg indMsg = new IndexCreationReplyMsg(processorId, ex, result, result,
+          indexBucketsMap, numTotalBuckets);
-     * @param dm
-     *          distribution manager
+     * @param dm distribution manager

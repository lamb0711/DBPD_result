GEODE-8338: change redis commands not be repeated when a server dies (#5351)

The redis functions are no longer HA.
The product does have some cases when it can safely retry the function
but if a server dies the client will see a redis error containing "memberDeparted".
In that case the client app can check to see if the redis operation should be done
again, or if it already happened even though a server died.

Co-authored-by: Sarah Abbey <sabbey@vmware.com>
Co-authored-by: Darrel Schneider <darrel@vmware.com>
-import java.util.Collections;
+import org.apache.geode.cache.execute.FunctionException;
-@SuppressWarnings("unchecked")
-  public static <T> T invoke(RedisCommandType command,
-      ByteArrayWrapper key,
-      Object commandArguments, Region<ByteArrayWrapper, RedisData> region) {
-    SingleResultCollector<T> resultsCollector = new SingleResultCollector<>();
-    FunctionService
-        .onRegion(region)
-        .withFilter(Collections.singleton(key))
-        .setArguments(new Object[] {command, commandArguments})
-        .withCollector(resultsCollector)
-        .execute(CommandFunction.ID)
-        .getResult();
-
-    return resultsCollector.getResult();
+  public static Throwable getInitialCause(FunctionException ex) {
+    Throwable result = ex.getCause();
+    while (result != null && result.getCause() != null) {
+      result = result.getCause();
+    }
+    if (result == null) {
+      if (!ex.getExceptions().isEmpty()) {
+        result = ex.getExceptions().get(0);
+      }
+    }
+    return result;
-
+  @SuppressWarnings("unchecked")
-        Object[] argArgs = (Object[]) args[1];
-        ByteArrayWrapper value = (ByteArrayWrapper) argArgs[0];
-        SetOptions options = (SetOptions) argArgs[1];
+        ByteArrayWrapper value = (ByteArrayWrapper) args[1];
+        SetOptions options = (SetOptions) args[2];
-        Object[] argArgs = (Object[]) args[1];
-        long start = (long) argArgs[0];
-        long end = (long) argArgs[1];
+        long start = (long) args[1];
+        long end = (long) args[2];
-        Object[] argArgs = (Object[]) args[1];
-        int offset = (int) argArgs[0];
-        byte[] value = (byte[]) argArgs[1];
+        int offset = (int) args[1];
+        byte[] value = (byte[]) args[2];
-        Object[] argArgs = (Object[]) args[1];
-        if (argArgs == null) {
+        if (args.length == 1) {
-          int start = (int) argArgs[0];
-          int end = (int) argArgs[1];
+          int start = (int) args[1];
+          int end = (int) args[2];
-        Object[] argArgs = (Object[]) args[1];
-        int bit = (int) argArgs[0];
-        int start = (int) argArgs[1];
-        Integer end = (Integer) argArgs[2];
+        int bit = (int) args[1];
+        int start = (int) args[2];
+        Integer end = (Integer) args[3];
-        Object[] argArgs = (Object[]) args[1];
-        long offset = (long) argArgs[0];
-        int value = (int) argArgs[1];
+        long offset = (long) args[1];
+        int value = (int) args[2];
-        Object[] argArgs = (Object[]) args[1];
-        String operation = (String) argArgs[0];
-        List<ByteArrayWrapper> sources = (List<ByteArrayWrapper>) argArgs[1];
+        String operation = (String) args[1];
+        List<ByteArrayWrapper> sources = (List<ByteArrayWrapper>) args[2];
-        Object[] sscanArgs = (Object[]) args[1];
-        Pattern matchPattern = (Pattern) sscanArgs[0];
-        int count = (int) sscanArgs[1];
-        int cursor = (int) sscanArgs[2];
+        Pattern matchPattern = (Pattern) args[1];
+        int count = (int) args[2];
+        int cursor = (int) args[3];
-        Object[] hsetArgs = (Object[]) args[1];
-        List<ByteArrayWrapper> fieldsToSet = (List<ByteArrayWrapper>) hsetArgs[0];
-        boolean NX = (boolean) hsetArgs[1];
+        List<ByteArrayWrapper> fieldsToSet = (List<ByteArrayWrapper>) args[1];
+        boolean NX = (boolean) args[2];
-        Object[] hscanArgs = (Object[]) args[1];
-        Pattern pattern = (Pattern) hscanArgs[0];
-        int count = (int) hscanArgs[1];
-        int cursor = (int) hscanArgs[2];
+        Pattern pattern = (Pattern) args[1];
+        int count = (int) args[2];
+        int cursor = (int) args[3];
-        Object[] hsetArgs = (Object[]) args[1];
-        ByteArrayWrapper field = (ByteArrayWrapper) hsetArgs[0];
-        long increment = (long) hsetArgs[1];
+        ByteArrayWrapper field = (ByteArrayWrapper) args[1];
+        long increment = (long) args[2];
-        Object[] hsetArgs = (Object[]) args[1];
-        ByteArrayWrapper field = (ByteArrayWrapper) hsetArgs[0];
-        double increment = (double) hsetArgs[1];
+        ByteArrayWrapper field = (ByteArrayWrapper) args[1];
+        double increment = (double) args[2];

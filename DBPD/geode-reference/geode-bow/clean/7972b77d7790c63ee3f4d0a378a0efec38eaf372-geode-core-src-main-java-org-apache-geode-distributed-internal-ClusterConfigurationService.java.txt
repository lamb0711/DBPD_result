GEODE-4029: Deployed jars may not be correct when multiple locators aâ€¦ (#1103)

* GEODE-4029: Deployed jars may not be correct when multiple locators are in use

* GEODE-4029: Review updates

+import java.util.ArrayList;
-import java.util.Objects;
+
+        String memberId = cache.getMyId().getId();
+
-        configRegion.put(group, configurationCopy);
+        configRegion.put(group, configurationCopy, memberId);
+
+        for (String jarRemoved : jarNames) {
+          File jar = this.getPathToJarOnThisLocator(group, jarRemoved).toFile();
+          if (jar.exists()) {
+            try {
+              FileUtils.forceDelete(jar);
+            } catch (IOException e) {
+              logger.error(
+                  "Exception occurred while attempting to delete a jar from the filesystem: {}",
+                  jarRemoved, e);
+            }
+          }
+        }
+
-  // used in the cluster config change listener when jarnames are changed in the internal region
+  // Only used when a locator is initially starting up
-    Set<DistributedMember> locators =
-        new HashSet<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
+    List<DistributedMember> locators =
+        new ArrayList<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-    byte[] jarBytes = locators.stream()
-        .map((DistributedMember locator) -> downloadJarFromLocator(locator, groupName, jarName))
-        .filter(Objects::nonNull).findFirst().orElseThrow(() -> new IllegalStateException(
-            "No locators have a deployed jar named " + jarName + " in " + groupName));
+    if (locators.isEmpty()) {
+      throw new IllegalStateException(
+          "Request to download jar " + jarName + " but no other locators are present");
+    }
+
+    byte[] jarBytes = downloadJar(locators.get(0), groupName, jarName);
+  // used in the cluster config change listener when jarnames are changed in the internal region
+  public void downloadJarFromLocator(String groupName, String jarName,
+      DistributedMember sourceLocator) throws IllegalStateException, IOException {
+    logger.info("Downloading jar {} from locator {}", jarName, sourceLocator.getName());
+
+    createConfigDirIfNecessary(groupName);
+
+    byte[] jarBytes = downloadJar(sourceLocator, groupName, jarName);
+
+    if (jarBytes == null) {
+      throw new IllegalStateException("Could not download jar " + jarName + " in " + groupName
+          + " from " + sourceLocator.getName());
+    }
+
+    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
+    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
+  }
+
+  private byte[] downloadJar(DistributedMember locator, String groupName, String jarName) {
+    ResultCollector<byte[], List<byte[]>> rc =
+        (ResultCollector<byte[], List<byte[]>>) CliUtil.executeFunction(new UploadJarFunction(),
+            new Object[] {groupName, jarName}, Collections.singleton(locator));
+
+    List<byte[]> result = rc.getResult();
+
+    // we should only get one byte[] back in the list
+    return result.get(0);
+  }
+
-      clusterRegion.putAll(sharedConfiguration);
+
+      String memberId = cache.getMyId().getId();
+      clusterRegion.putAll(sharedConfiguration, memberId);
-  private byte[] downloadJarFromLocator(DistributedMember locator, String groupName,
-      String jarName) {
-    ResultCollector<byte[], List<byte[]>> rc =
-        (ResultCollector<byte[], List<byte[]>>) CliUtil.executeFunction(new UploadJarFunction(),
-            new Object[] {groupName, jarName}, Collections.singleton(locator));
-
-    List<byte[]> result = rc.getResult();
-
-    // we should only get one byte[] back in the list
-    return result.stream().filter(Objects::nonNull).findFirst().orElse(null);
-  }
-

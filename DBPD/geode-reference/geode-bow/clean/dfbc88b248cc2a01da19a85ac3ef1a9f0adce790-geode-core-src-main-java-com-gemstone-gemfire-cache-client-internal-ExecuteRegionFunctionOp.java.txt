Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/AbstractDistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfigImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalLocator.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/StartupMessage.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/SystemAdmin.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheServerStats.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/i18n/LocalizedStrings.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/HostStatHelper.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/HostStatSampler.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/StatArchiveWriter.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/internal/DistributionConfigJUnitTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/internal/statistics/GemFireStatSamplerIntegrationTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/internal/statistics/SimpleStatSamplerIntegrationTest.java

+import com.gemstone.gemfire.cache.CacheClosedException;
+import com.gemstone.gemfire.cache.execute.FunctionInvocationTargetException;
+import com.gemstone.gemfire.internal.cache.execute.BucketMovedException;
+      
-    private final boolean executeOnBucketSet;
-    /**
-     * @param removedNodes TODO
-     * @throws com.gemstone.gemfire.SerializationException if serialization fails
-     */
+    private final boolean executeOnBucketSet;
+    
+    private final boolean isHA;
+
+    private FunctionException functionException;
+
+      this.isHA = function.isHA();
+      this.isHA = isHA;
+      this.isHA = op.isHA;
+            boolean throwServerOp = false;
+              
+              // if the function is HA throw exceptions
+              // if nonHA collect these exceptions and wait till you get last chunk
+                  addFunctionException((FunctionException) result);
-                executeFunctionResponseMsg.clear();
-                throw ex;
+                else{
+                  addFunctionException((FunctionException) result);
+                }
-                String s = "While performing a remote " + getOpName();
-                executeFunctionResponseMsg.clear();
-                throw new ServerOperationException(s, (Throwable)result);
+                Throwable t = (Throwable)result;
+                  if (this.functionException == null) {
+                    if(result instanceof BucketMovedException){
+                      FunctionInvocationTargetException fite;
+                      if(isHA){
+                        fite = new InternalFunctionInvocationTargetException(
+                                              ((BucketMovedException)result).getMessage());
+                      }else {
+                        fite = new FunctionInvocationTargetException(
+                            ((BucketMovedException)result).getMessage());
+                      }
+                      this.functionException =  new FunctionException(fite);
+                      this.functionException.addException(fite);
+                    }
+                    else if (result instanceof CacheClosedException) {
+                      FunctionInvocationTargetException fite;
+                      if(isHA) {
+                        fite = new InternalFunctionInvocationTargetException(((CacheClosedException)result).getMessage());
+                      }
+                      else{
+                        fite = new FunctionInvocationTargetException(((CacheClosedException)result).getMessage());
+                      }
+                      if (resultResponse instanceof ArrayList) {
+                        DistributedMember memberID = (DistributedMember) ((ArrayList) resultResponse)
+                            .get(1);
+                        this.failedNodes.add(memberID.getId());
+                      }                   
+                      this.functionException = new FunctionException(fite);
+                      this.functionException.addException(fite);
+                    }
+                    else {
+                      throwServerOp = true;
+                      this.functionException = new FunctionException(t);
+                      this.functionException.addException(t);
+                    }
+                  } else {
+                    this.functionException.addException(t);
+                  }
+
+
+            if (isHA && throwServerOp) {
+              String s = "While performing a remote " + getOpName();
+              throw new ServerOperationException(s, this.functionException);
+            }
+
+            // add all the exceptions here.
+            if (this.functionException != null) {
+              throw this.functionException;
+            }
-              executeFunctionResponseMsg.clear();
-              executeFunctionResponseMsg.clear();
-            executeFunctionResponseMsg.clear();
+    private void addFunctionException(final FunctionException result) {
+      if (this.functionException == null) {
+        this.functionException = result;
+      }
+      this.functionException.addException(result);
+    }
+

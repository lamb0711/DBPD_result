Merge branch 'release/1.4.0'

- * 
+ *
- * 
+ *
-import org.apache.geode.cache.CacheXmlException;
-import org.apache.geode.internal.InternalDataSerializer;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.cache.xmlcache.AbstractXmlParser;
-import org.apache.geode.internal.cache.xmlcache.RegionCreation;
+import org.apache.geode.cache.CacheXmlException;
+import org.apache.geode.cache.Declarable;
+import org.apache.geode.cache.lucene.LuceneSerializer;
+import org.apache.geode.internal.InternalDataSerializer;
+import org.apache.geode.internal.cache.xmlcache.*;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+  private CacheCreation cache;
+    if (SERIALIZER.equals(localName)) {
+      startSerializer(atts);
+    }
+
+  }
+
+  private void startSerializer(Attributes atts) {
+    // Ignore any whitespace noise between fields
+    if (stack.peek() instanceof StringBuffer) {
+      stack.pop();
+    }
+
+    if (!(stack.peek() instanceof LuceneIndexCreation)) {
+      throw new CacheXmlException(
+          "lucene <serializer> elements must occur within lucene <index> elements");
+    }
+    LuceneIndexCreation creation = (LuceneIndexCreation) stack.peek();
+    cache = (CacheCreation) region.getCache();
+
+    if (SERIALIZER.equals(localName)) {
+      endSerializer();
+    }
+  private void endSerializer() {
+    Declarable d = CacheXmlParser.createDeclarable(cache, stack);
+    if (!(d instanceof LuceneSerializer)) {
+      throw new CacheXmlException(
+          d.getClass().getName() + " is not an instance of LuceneSerializer");
+    }
+
+    LuceneIndexCreation indexCreation = (LuceneIndexCreation) stack.peek();
+    indexCreation.setLuceneSerializer((LuceneSerializer) d);
+
+  }
+

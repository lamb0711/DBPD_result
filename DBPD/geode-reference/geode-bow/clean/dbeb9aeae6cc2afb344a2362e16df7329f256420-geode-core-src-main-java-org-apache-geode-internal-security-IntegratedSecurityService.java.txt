Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import static org.apache.geode.distributed.ConfigurationProperties.*;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.security.AccessController;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.Callable;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_AUTHENTICATOR;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_PEER_AUTHENTICATOR;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_POST_PROCESSOR;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_SHIRO_INIT;
+import org.apache.geode.internal.logging.log4j.LogMarker;
+import org.apache.shiro.UnavailableSecurityManagerException;
+import org.apache.shiro.session.mgt.DefaultSessionManager;
+import org.apache.shiro.session.mgt.SessionManager;
-public class IntegratedSecurityService implements SecurityService{
+import java.io.IOException;
+import java.io.Serializable;
+import java.security.AccessController;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.Callable;
+
+public class IntegratedSecurityService implements SecurityService {
-  private IntegratedSecurityService() {
-  }
+  private IntegratedSecurityService() {}
-  private boolean isIntegratedSecurity;
+  private Boolean isIntegratedSecurity;
-   * It first looks the shiro subject in AccessControlContext since JMX will
-   * use multiple threads to process operations from the same client, then it
-   * looks into Shiro's thead context.
+   * It first looks the shiro subject in AccessControlContext since JMX will use multiple threads to
+   * process operations from the same client, then it looks into Shiro's thead context.
-    if (!isIntegratedSecurity) {
+    if (!isIntegratedSecurity()) {
-      javax.security.auth.Subject.getSubject(AccessController.getContext());
+        javax.security.auth.Subject.getSubject(AccessController.getContext());
-    // in other cases like admin rest call or pulse authorization
+    // in other cases like rest call, client operations, we get it from the current thread
-  public Subject login(String username, String password){
-    if(StringUtils.isBlank(username) || StringUtils.isBlank(password))
+  public Subject login(String username, String password) {
+    if (StringUtils.isBlank(username) || StringUtils.isBlank(password))
-    if (!isIntegratedSecurity) {
+    if (!isIntegratedSecurity()) {
-    if(credentials == null)
+    if (credentials == null)
-    }
-    catch (ShiroException e) {
+    } catch (ShiroException e) {
-      throw new AuthenticationFailedException("Authentication error. Please check your credentials.", e);
+      throw new AuthenticationFailedException(
+          "Authentication error. Please check your credentials.", e);
-    }
-    catch (ShiroException e) {
+    } catch (ShiroException e) {
-   * this binds the passed-in subject to the executing thread, normally, you
-   * would do this:
+   * this binds the passed-in subject to the executing thread, normally, you would do this:
-   * ThreadState state = null;
-   * try{
-   *   state = IntegratedSecurityService.bindSubject(subject);
-   *   //do the rest of the work as this subject
-   * }
-   * finally{
-   *   if(state!=null)
-   *      state.clear();
-   * }
+   * ThreadState state = null; try{ state = IntegratedSecurityService.bindSubject(subject); //do the
+   * rest of the work as this subject } finally{ if(state!=null) state.clear(); }
-  public ThreadState bindSubject(Subject subject){
+  public ThreadState bindSubject(Subject subject) {
-    authorize(resourceOperation.resource().name(),
-      resourceOperation.operation().name(),
-      null);
+    authorize(resourceOperation.resource().name(), resourceOperation.operation().name(), null);
-  private void authorize(String resource, String operation, String regionName){
+  public void authorize(String resource, String operation, String regionName) {
-  private void authorize(String resource, String operation, String regionName, String key) {
+  public void authorize(String resource, String operation, String regionName, String key) {
-    }
-    catch (ShiroException e) {
+    } catch (ShiroException e) {
-    String securityConfig = securityProps.getProperty(SECURITY_MANAGER);
+    String securityManagerConfig = securityProps.getProperty(SECURITY_MANAGER);
-      main.put("geodePermissionResolver", "org.apache.geode.internal.security.shiro.GeodePermissionResolver");
+      main.put("geodePermissionResolver",
+          "org.apache.geode.internal.security.shiro.GeodePermissionResolver");
-    }
-    // only set up shiro realm if user has implemented SecurityManager
-    else if (!StringUtils.isBlank(securityConfig)) {
-      securityManager = SecurityService.getObjectOfTypeFromClassName(securityConfig, SecurityManager.class);
-      securityManager.init(securityProps);
-      Realm realm = new CustomAuthRealm(securityManager);
-      org.apache.shiro.mgt.SecurityManager shiroManager = new DefaultSecurityManager(realm);
-      SecurityUtils.setSecurityManager(shiroManager);
-      isIntegratedSecurity = true;
-    }
-    else if( !StringUtils.isBlank(clientAuthenticatorConfig)) {
-      isClientAuthenticator = true;
-    }
-    else if (!StringUtils.isBlank(peerAuthenticatorConfig)) {
-      isPeerAuthenticator = true;
-    }
-    else {
-      isIntegratedSecurity = false;
+    // only set up shiro realm if user has implemented SecurityManager
+    else if (!StringUtils.isBlank(securityManagerConfig)) {
+      SecurityManager securityManager = SecurityService
+          .getObjectOfTypeFromClassName(securityManagerConfig, SecurityManager.class);
+      securityManager.init(securityProps);
+      this.setSecurityManager(securityManager);
+    } else {
+      isIntegratedSecurity = null;
+      isClientAuthenticator = !StringUtils.isBlank(clientAuthenticatorConfig);
+      isPeerAuthenticator = !StringUtils.isBlank(peerAuthenticatorConfig);
+    }
-    if( !StringUtils.isBlank(customPostProcessor)) {
-      postProcessor = SecurityService.getObjectOfTypeFromClassName(customPostProcessor, PostProcessor.class);
+    if (!StringUtils.isBlank(customPostProcessor)) {
+      postProcessor =
+          SecurityService.getObjectOfTypeFromClassName(customPostProcessor, PostProcessor.class);
-    }
-    else{
+    } else {
-    isIntegratedSecurity = false;
+    SecurityUtils.setSecurityManager(null);
+    isIntegratedSecurity = null;
-   * postProcess call already has this logic built in, you don't need to call
-   * this everytime you call postProcess. But if your postProcess is pretty
-   * involved with preparations and you need to bypass it entirely, call this
-   * first.
+   * postProcess call already has this logic built in, you don't need to call this everytime you
+   * call postProcess. But if your postProcess is pretty involved with preparations and you need to
+   * bypass it entirely, call this first.
-  public boolean needPostProcess(){
-    return (isIntegratedSecurity && postProcessor != null);
+  public boolean needPostProcess() {
+    return (isIntegratedSecurity() && postProcessor != null);
-  public Object postProcess(String regionPath, Object key, Object value, boolean valueIsSerialized){
+  public Object postProcess(String regionPath, Object key, Object value,
+      boolean valueIsSerialized) {
-  public Object postProcess(Object principal, String regionPath, Object key, Object value, boolean valueIsSerialized) {
+  public Object postProcess(Object principal, String regionPath, Object key, Object value,
+      boolean valueIsSerialized) {
-    // if the data is a byte array, but the data itself is supposed to be an object, we need to desearized it before we pass
+    // if the data is a byte array, but the data itself is supposed to be an object, we need to
+    // desearized it before we pass
-        Object newObj = postProcessor.processRegionValue(principal, regionName, key,  oldObj);
+        Object newObj = postProcessor.processRegionValue(principal, regionName, key, oldObj);
-      } catch (IOException|SerializationException e) {
+      } catch (IOException | SerializationException e) {
-    }
-    else {
+    } else {
-  public SecurityManager getSecurityManager(){
+  public SecurityManager getSecurityManager() {
+  public void setSecurityManager(SecurityManager securityManager) {
+    if (securityManager == null) {
+      return;
+    }
+
+    this.securityManager = securityManager;
+    Realm realm = new CustomAuthRealm(securityManager);
+    DefaultSecurityManager shiroManager = new DefaultSecurityManager(realm);
+    SecurityUtils.setSecurityManager(shiroManager);
+    increaseShiroGlobalSessionTimeout(shiroManager);
+
+    isIntegratedSecurity = true;
+    isClientAuthenticator = false;
+    isPeerAuthenticator = false;
+  }
+
+  private void increaseShiroGlobalSessionTimeout(final DefaultSecurityManager shiroManager) {
+    SessionManager sessionManager = shiroManager.getSessionManager();
+    if (DefaultSessionManager.class.isInstance(sessionManager)) {
+      DefaultSessionManager defaultSessionManager = (DefaultSessionManager) sessionManager;
+      defaultSessionManager.setGlobalSessionTimeout(Long.MAX_VALUE);
+      long value = defaultSessionManager.getGlobalSessionTimeout();
+      if (value != Long.MAX_VALUE) {
+        logger.error("Unable to set Shiro Global Session Timeout. Current value is '{}'.", value);
+      }
+    } else {
+      logger.error("Unable to set Shiro Global Session Timeout. Current SessionManager is '{}'.",
+          sessionManager == null ? "null" : sessionManager.getClass());
+    }
+  }
+
-  public boolean isIntegratedSecurity(){
+  public void setPostProcessor(PostProcessor postProcessor) {
+    if (postProcessor == null) {
+      return;
+    }
+
+    this.postProcessor = postProcessor;
+  }
+
+  /**
+   * check if Shiro's security manager is configured
+   * 
+   * @return true if configured, false if not
+   */
+  public boolean isIntegratedSecurity() {
+    if (isIntegratedSecurity != null) {
+      return isIntegratedSecurity;
+    }
+
+    try {
+      isIntegratedSecurity = (SecurityUtils.getSecurityManager() != null);
+    } catch (UnavailableSecurityManagerException e) {
+      isIntegratedSecurity = false;
+    }
-    return isClientAuthenticator || isIntegratedSecurity;
+    return isClientAuthenticator || isIntegratedSecurity();
-    return isPeerAuthenticator || isIntegratedSecurity;
+    return isPeerAuthenticator || isIntegratedSecurity();

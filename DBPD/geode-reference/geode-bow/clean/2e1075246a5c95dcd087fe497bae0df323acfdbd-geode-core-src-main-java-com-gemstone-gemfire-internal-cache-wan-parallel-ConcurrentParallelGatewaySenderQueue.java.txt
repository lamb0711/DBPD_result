Merge branch 'release/1.0.0-incubating.M3'

-import com.gemstone.gemfire.cache.hdfs.internal.HDFSBucketRegionQueue;
-import com.gemstone.gemfire.cache.hdfs.internal.HDFSGatewayEventImpl;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySender;
+  private final AbstractGatewaySender sender;
+
-  public ConcurrentParallelGatewaySenderQueue(
+  public ConcurrentParallelGatewaySenderQueue(AbstractGatewaySender sender,
+    this.sender = sender;
-	for(int i =0; i< processors.length; i++){
-	  processors[i].addShadowPartitionedRegionForUserPR(pr);
-	 }
+    // Reset enqueuedAllTempQueueEvents if the sender is running
+    // This is done so that any events received while the shadow PR is added are queued in the tmpQueuedEvents
+    // instead of blocking the distribute call which could cause a deadlock. See GEM-801.
+    if (this.sender.isRunning()) {
+      this.sender.setEnqueuedAllTempQueueEvents(false);
+    }
+    this.sender.getLifeCycleLock().writeLock().lock();
+    try {
+      for (int i = 0; i < processors.length; i++) {
+        processors[i].addShadowPartitionedRegionForUserPR(pr);
+      }
+    } finally {
+      this.sender.getLifeCycleLock().writeLock().unlock();
+    }
-  public HDFSBucketRegionQueue getBucketRegionQueue(PartitionedRegion region,
-    int bucketId) throws ForceReattemptException {
-	return getPGSProcessor(bucketId).getBucketRegionQueue(region, bucketId);
-  }
-  
-  public HDFSGatewayEventImpl get(PartitionedRegion region, byte[] regionKey,
-      int bucketId) throws ForceReattemptException {
-    return getPGSProcessor(bucketId).get(region, regionKey, bucketId);
-  }
-  

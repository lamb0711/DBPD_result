GEODE-6133: Use System.lineSeparator() for line feeds (#4152)

Cleanup any classes and tests touched for line feeds.
-import static org.apache.commons.lang3.SystemUtils.LINE_SEPARATOR;
+import static java.lang.System.lineSeparator;
+import java.io.Serializable;
+import org.apache.geode.internal.logging.LogFileParser.LogEntry;
- * <p>
+ * <p>
- * <p>
+ * <p>
- * <p>
+ * <p>
- * <p>
+ * <p>
- * <p>
- *
- * <CENTER> <IMG SRC="{@docRoot}/javadoc-images/merge-log-files.gif" WIDTH="353" HEIGHT="246"/>
- * </CENTER>
-   * Merges the log files from a given set of <code>InputStream</code>s into a
-   * <code>PrintWriter</code>.
+   * Merges the log files from a given set of {@code InputStream}s into a
+   * {@code PrintWriter}.
-   * @throws IllegalArgumentException If the length of <code>logFiles</code> is not the same as the
-   *         length of <code>logFileNames</code>
+   * @throws IllegalArgumentException If the length of {@code logFiles} is not the same as the
+   *         length of {@code logFileNames}
-    return mergeLogFiles(logFiles, mergedFile, false, false, false, new LinkedList());
+    return mergeLogFiles(logFiles, mergedFile, false, false, false, new LinkedList<>());
-   * Merges the log files from a given set of <code>InputStream</code>s into a
-   * <code>PrintWriter</code>.
+   * Merges the log files from a given set of {@code InputStream}s into a
+   * {@code PrintWriter}.
-   * @throws IllegalArgumentException If the length of <code>logFiles</code> is not the same as the
-   *         length of <code>logFileNames</code>
+   * @throws IllegalArgumentException If the length of {@code logFiles} is not the same as the
+   *         length of {@code logFileNames}
-    err.println(LINE_SEPARATOR + "** " + s + LINE_SEPARATOR);
+    err.println(lineSeparator() + "** " + s + lineSeparator());
-  static ArrayList<File> getLogFiles(final String dirName) {
-    ArrayList<File> result = new ArrayList<>();
+  static List<File> getLogFiles(final String dirName) {
+    List<File> result = new ArrayList<>();
-    File names[] = dir.listFiles();
+    File[] names = dir.listFiles();
-        String n = name.getAbsolutePath();
-        if (n.endsWith(".log") || n.endsWith(".log.gz")) {
+        String path = name.getAbsolutePath();
+        if (path.endsWith(".log") || path.endsWith(".log.gz")) {
-      } // for
+      }
-    ArrayList files = new ArrayList();
-    List nickNames = null;
+    List<File> files = new ArrayList<>();
-      if (args[i].equals("-align")) {
-        tabOut = true;
-      } else if (args[i].equals("-noblanks")) {
-        suppressBlanks = true;
-      } else if (args[i].equals("-pids")) {
-        findPIDs = true;
-      } else if (args[i].equals("-threaded")) {
-        multithreaded = true;
-      } else if (args[i].equals("-regex")) {
-        if (i + 1 >= args.length) {
-          usage("missing pattern for -regex option");
-        }
-        patterns.add(args[i + 1]);
-        i++;
-      } else if (args[i].equals("-dirCount")) {
-        if (++i >= args.length) {
-          usage("Missing number of parent directories");
-        }
+      switch (args[i]) {
+        case "-align":
+          tabOut = true;
+          break;
+        case "-noblanks":
+          suppressBlanks = true;
+          break;
+        case "-pids":
+          findPIDs = true;
+          break;
+        case "-threaded":
+          multithreaded = true;
+          break;
+        case "-regex":
+          if (i + 1 >= args.length) {
+            usage("missing pattern for -regex option");
+          }
+          patterns.add(args[i + 1]);
+          i++;
+          break;
+        case "-dirCount":
+          if (++i >= args.length) {
+            usage("Missing number of parent directories");
+          }
-        try {
-          dirCount = Integer.parseInt(args[i]);
+          try {
+            dirCount = Integer.parseInt(args[i]);
-        } catch (NumberFormatException ex) {
-          usage(String.format("Not a number: %s", args[i]));
-        }
+          } catch (NumberFormatException ex) {
+            usage(String.format("Not a number: %s", args[i]));
+          }
-      } else if (args[i].equals("-mergeFile")) {
-        if (++i >= args.length) {
-          usage("Missing merge file name");
-        }
+          break;
+        case "-mergeFile":
+          if (++i >= args.length) {
+            usage("Missing merge file name");
+          }
-        mergeFile = new File(args[i]);
+          mergeFile = new File(args[i]);
-      } else {
-        File file = new File(args[i]);
-        if (!file.exists()) {
-          usage(String.format("File %s does not exist", file));
-        }
+          break;
+        default:
+          File file = new File(args[i]);
+          if (!file.exists()) {
+            usage(String.format("File %s does not exist", file));
+          }
-        files.add(file.getAbsoluteFile());
+          files.add(file.getAbsoluteFile());
+          break;
-    ArrayList expandedFiles = new ArrayList();
-    for (int i = 0; i < files.size(); i++) {
-      File f = (File) files.get(i);
-      String n = f.getAbsolutePath();
-      if (!f.exists()) {
-        usage(String.format("File %s does not exist", n));
+    List<File> expandedFiles = new ArrayList<>();
+    for (File file : files) {
+      String path = file.getAbsolutePath();
+      if (!file.exists()) {
+        usage(String.format("File %s does not exist", path));
-      if (f.isFile()) {
-        expandedFiles.add(f);
+      if (file.isFile()) {
+        expandedFiles.add(file);
-      if (f.isDirectory()) {
-        ArrayList moreFiles = getLogFiles(n);
+      if (file.isDirectory()) {
+        List<File> moreFiles = getLogFiles(path);
-      usage(String.format("File '%s' is neither a file nor a directory.",
-          n));
+      usage(String.format("File '%s' is neither a file nor a directory.", path));
+
-    for (int i = 0; i < expandedFiles.size(); i++) {
-      ps.println("  " + expandedFiles.get(i));
+    for (File expandedFile : expandedFiles) {
+      ps.println("  " + expandedFile);
-    ps.println("");
+    ps.println();
+    List nickNames = null;
-      File file = (File) files.get(i);
+      File file = files.get(i);
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
-  private static ArrayList findPIDs(final ArrayList files, final PrintWriter output) {
-    int pidTable[] = new int[files.size()];
-    int pidTableCounter[] = new int[pidTable.length];
-    ArrayList nickNames = new ArrayList();
-    char sep = File.separatorChar;
+  private static List<String> findPIDs(final Collection<File> files, final PrintWriter output) {
+    int[] pidTable = new int[files.size()];
+    int[] pidTableCounter = new int[pidTable.length];
+    List<String> nickNames = new ArrayList<>();
+    char fileSeparatorChar = File.separatorChar;
-    for (Iterator it = files.iterator(); it.hasNext();) {
-      File f = (File) it.next();
-      String name = f.getPath();
+    for (File file : files) {
+      String name = file.getPath();
-      String slashdotslash = "" + sep + "." + sep;
+      String slashdotslash = fileSeparatorChar + "." + fileSeparatorChar;
-      startIdx = name.lastIndexOf(sep);
+      startIdx = name.lastIndexOf(fileSeparatorChar);
-      String PID;
-        // System.out.println("charAt("+i+")="+c);
-            PID = name.substring(i + 1, startIdx + 1);
-            // System.out.println("parsing '" + PID + "'");
+            String PID = name.substring(i + 1, startIdx + 1);
-                // System.out.println("Found PID " + iPID);
-                  } else if (pidTable[p] == iPID) {
+                  }
+                  if (pidTable[p] == iPID) {
-                nickNames.add("" + iPID + "-" + pidTableCounter[p]);
+                nickNames.add(iPID + "-" + pidTableCounter[p]);
-          } // have a number
-          else {
+          } else {
-        } // not a digit
-      } // for(i)
+        }
+      }
-    LogFileParser.LogEntry peek();
+    LogEntry peek();
-    LogFileParser.LogEntry poll();
+    LogEntry poll();
-    private LogFileParser.LogEntry nextEntry;
+    private LogEntry nextEntry;
-     * Creates a new <code>Reader</code> that reads from the given log file with the given name.
+     * Creates a new {@code Reader} that reads from the given log file with the given name.
-     * @return <code>null</code> if interrupted while waiting
+     * @return {@code null} if interrupted while waiting
-    public synchronized LogFileParser.LogEntry peek() {
+    public synchronized LogEntry peek() {
-    private boolean patternMatch(final LogFileParser.LogEntry entry) {
+    private boolean patternMatch(final LogEntry entry) {
-    public LogFileParser.LogEntry poll() {
-      LogFileParser.LogEntry returnValue = null;
+    public LogEntry poll() {
+      LogEntry returnValue = null;
-    private final BlockingQueue queue;
+    private final BlockingQueue<LogEntry> queue;
-     * Creates a new <code>Reader</code> that reads from the given log file with the given name.
+     * Creates a new {@code Reader} that reads from the given log file with the given name.
-      queue = new LinkedBlockingQueue(QUEUE_CAPACITY);
+      queue = new LinkedBlockingQueue<>(QUEUE_CAPACITY);
-     * Reads the log file and places {@link LogFileParser.LogEntry} objects into the queue. When it
-     * is finished, it places a <code>LogEntry</code> that whose
-     * {@link LogFileParser.LogEntry#isLast isLast} method will return <code>true</code>.
+     * Reads the log file and places {@link LogEntry} objects into the queue. When it
+     * is finished, it places a {@code LogEntry} that whose
+     * {@link LogEntry#isLast isLast} method will return {@code true}.
-          LogFileParser.LogEntry entry = parser.getNextEntry();
+          LogEntry entry = parser.getNextEntry();
-              notify();
+              notifyAll();
-    private boolean patternMatch(final LogFileParser.LogEntry entry) {
+    private boolean patternMatch(final LogEntry entry) {
-     * @return <code>null</code> if interrupted while waiting
+     * @return {@code null} if interrupted while waiting
-    public LogFileParser.LogEntry peek() {
-      LogFileParser.LogEntry entry = (LogFileParser.LogEntry) queue.peek();
+    public LogEntry peek() {
+      LogEntry entry = queue.peek();
-          entry = (LogFileParser.LogEntry) queue.peek();
+          entry = queue.peek();
-              entry = (LogFileParser.LogEntry) queue.peek();
+              entry = queue.peek();
-          } // while
-        } // synchronized
+          }
+        }
-    public LogFileParser.LogEntry poll() {
-      return (LogFileParser.LogEntry) queue.poll();
+    public LogEntry poll() {
+      return queue.poll();
-        SystemFailure.setFailure((VirtualMachineError) e); // don't throw
+        SystemFailure.setFailure((Error) e); // don't throw
-     * Merges the log files from a given set of <code>InputStream</code>s into a
-     * <code>PrintWriter</code>.
+     * Merges the log files from a given set of {@code InputStream}s into a
+     * {@code PrintWriter}.
+     *
-     * @throws IllegalArgumentException If the length of <code>logFiles</code> is not the same as
-     *         the length of <code>logFileNames</code>
+     * @throws IllegalArgumentException If the length of {@code logFiles} is not the same as
+     *         the length of {@code logFileNames}
-        final boolean multithreaded, final List<String> patterns) {
+        final boolean multithreaded, final Iterable<String> patterns) {
-      Collection readers = new ArrayList(logFiles.size());
+      Collection<Reader> readers = new ArrayList<>(logFiles.size());
-      Set sorted = sortReaders(readers);
+      Set<Reader> sorted = sortReaders(readers);
-        Reader oldest;
-        oldest = (Reader) sortedIt.next();
+        Reader oldest = (Reader) sortedIt.next();
-        Reader nextInLine;
-          nextInLine = (Reader) sortedIt.next();
+          Reader nextInLine = (Reader) sortedIt.next();
-        LogFileParser.LogEntry entry;
+        LogEntry entry;
-    private static Set sortReaders(final Collection readers) {
-      Set sorted = new TreeSet(new ReaderComparator());
+    private static Set<Reader> sortReaders(final Iterable<Reader> readers) {
+      Set<Reader> sorted = new TreeSet<>(new ReaderComparator());
-      for (Iterator iter = readers.iterator(); iter.hasNext();) {
-        Reader reader = (Reader) iter.next();
+      for (Reader reader : readers) {
-  protected static class ReaderComparator implements Comparator {
+  @SuppressWarnings("serial")
+  protected static class ReaderComparator implements Comparator<Reader>, Serializable {
-    public int compare(final Object o1, final Object o2) {
-      Reader reader1 = (Reader) o1;
+    public int compare(final Reader reader1, final Reader reader2) {
-      Reader reader2 = (Reader) o2;
-      LogFileParser.LogEntry entry1 = reader1.peek();
-      LogFileParser.LogEntry entry2 = reader2.peek();
+      LogEntry entry1 = reader1.peek();
+      LogEntry entry2 = reader2.peek();
-          if (id1 < id2) {
-            return -1;
-          }
-          // IDs are unique, so no need for == test
-          return 1;
+          return Integer.compare(id1, id2);

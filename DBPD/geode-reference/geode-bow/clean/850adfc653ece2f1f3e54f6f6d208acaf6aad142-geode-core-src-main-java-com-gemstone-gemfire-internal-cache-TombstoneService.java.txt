the expiredTombstones collection is now an ArrayList and is final

-  public static long EXPIRED_TOMBSTONE_LIMIT = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "tombstone-gc-threshold", 100000);
+  public static int EXPIRED_TOMBSTONE_LIMIT = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "tombstone-gc-threshold", 100000);
-  /**
-   * Test Hook - slow operation
-   * verify whether a tombstone is scheduled for expiration
-   */
-  public boolean isTombstoneScheduled(LocalRegion r, RegionEntry re) {
-    TombstoneSweeper sweeper = this.getSweeper(r);
-    VersionSource myId = r.getVersionMember();
-    VersionTag entryTag = re.getVersionStamp().asVersionTag();
-    int entryVersion = entryTag.getEntryVersion();
-    for (Tombstone t: sweeper.getQueue()) {
-      if (t.region == r) {
-        VersionSource destroyingMember = t.getMemberID();
-        if (destroyingMember == null) {
-          destroyingMember = myId;
-        }
-        if (t.region == r
-            && t.entry.getKey().equals(re.getKey())
-            && t.getEntryVersion() == entryVersion) {
-          return true;
-        }
-      }
-    }
-    return sweeper.hasExpiredTombstone(r, re, entryTag);
-  }
-
-    private Set<Tombstone> expiredTombstones;
+    private final List<Tombstone> expiredTombstones;
+     * Part of expireBatch is done in a background thread
+     * and until that completes batch expiration is in progress.
-        this.expiredTombstones = new HashSet<Tombstone>();
+        this.expiredTombstones = new ArrayList<Tombstone>();
+      } else {
+        this.expiredTombstones = null;
-    /** test hook - unsafe since not synchronized */
-    boolean hasExpiredTombstone(LocalRegion r, RegionEntry re, VersionTag tag) {
-      if (this.expiredTombstones == null) {
-        return false;
-      }
-      int entryVersion = tag.getEntryVersion();
-      boolean retry;
-      do {
-        retry = false;
-        try {
-          for (Tombstone t: this.expiredTombstones) {
-            if (t.region == r
-                && t.entry.getKey().equals(re.getKey())
-                && t.getEntryVersion() == entryVersion) {
-              return true;
-            }
-          }
-        } catch (ConcurrentModificationException e) {
-          retry = true;
-        }
-      } while (retry);
-      return false;
-    }
-    
-    
-    
-        Set<Tombstone> expired = expiredTombstones;
-        if (expired.isEmpty()) {
-          return;
-        }
-        expiredTombstones = new HashSet<Tombstone>();
-          for (Tombstone t: expired) {
+          for (Tombstone t: expiredTombstones) {
+        // TODO seems like no need for the value of this map to be a Set.
+        // It could instead be a List, which would be nice because the per entry
+        // memory overhead for a set is much higher than an ArrayList
+        // BUT we send it to clients and the old
+        // version of them expects it to be a Set.
-        for (Tombstone t: expired) {
+        for (Tombstone t: expiredTombstones) {
+        expiredTombstones.clear();
-              if (batchMode && IDLE_EXPIRATION && sleepTime >= expiryTime) {
-                if (this.expiredTombstones.size() > 0) {
-                  expireBatch();
-                }
+              if (batchMode && IDLE_EXPIRATION && sleepTime >= expiryTime && !this.expiredTombstones.isEmpty()) {
+                expireBatch();

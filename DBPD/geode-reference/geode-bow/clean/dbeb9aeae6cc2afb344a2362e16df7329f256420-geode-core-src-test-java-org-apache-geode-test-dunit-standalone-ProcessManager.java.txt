Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.test.dunit.VM;
-  private Map<Integer, ProcessHolder> processes = new HashMap<Integer, ProcessHolder>();
+  private Map<Integer, ProcessHolder> processes = new HashMap<>();
+  private VersionManager versionManager;
+    this.versionManager = VersionManager.getInstance();
+    launchVM(VersionManager.CURRENT_VERSION, vmNum, false);
+  }
+
+  public synchronized void launchVM(String version, int vmNum, boolean bouncedVM)
+      throws IOException {
-    String[] cmd = buildJavaCommand(vmNum, namingPort);
+    String[] cmd = buildJavaCommand(vmNum, namingPort, version);
-    File workingDir = getVMDir(vmNum);
-    try {
-      FileUtil.delete(workingDir);
-    } catch (IOException e) {
-      //This delete is occasionally failing on some platforms, maybe due to a lingering
-      //process. Allow the process to be launched anyway.
-      System.err.println("Unable to delete " + workingDir + ". Currently contains "
-          + Arrays.asList(workingDir.list()));
+    File workingDir = getVMDir(version, vmNum);
+    if (!workingDir.exists()) {
+      workingDir.mkdirs();
+    } else if (!bouncedVM || DUnitLauncher.MAKE_NEW_WORKING_DIRS) {
+      try {
+        FileUtil.delete(workingDir);
+      } catch (IOException e) {
+        // This delete is occasionally failing on some platforms, maybe due to a lingering
+        // process. Allow the process to be launched anyway.
+        System.err.println("Unable to delete " + workingDir + ". Currently contains "
+            + Arrays.asList(workingDir.list()));
+      }
+      workingDir.mkdirs();
-    workingDir.mkdirs();
-    //TODO - delete directory contents, preferably with commons io FileUtils
+    // TODO - delete directory contents, preferably with commons io FileUtils
-    linkStreams(vmNum, holder, process.getErrorStream(), System.err);
-    linkStreams(vmNum, holder, process.getInputStream(), System.out);
+    linkStreams(version, vmNum, holder, process.getErrorStream(), System.err);
+    linkStreams(version, vmNum, holder, process.getInputStream(), System.out);
-  public static File getVMDir(int vmNum) {
-    return new File(DUnitLauncher.DUNIT_DIR, "vm" + vmNum);
+  public void validateVersion(String version) {
+    if (!versionManager.isValidVersion(version)) {
+      throw new IllegalArgumentException("Version " + version + " is not configured for use");
+    }
+  }
+
+  public static File getVMDir(String version, int vmNum) {
+    return new File(DUnitLauncher.DUNIT_DIR, VM.getVMName(VersionManager.CURRENT_VERSION, vmNum));
-  public synchronized void bounce(int vmNum) {
+  public synchronized void bounce(String version, int vmNum) {
-      launchVM(vmNum);
+      launchVM(version, vmNum, true);
-  private void linkStreams(final int vmNum, final ProcessHolder holder, final InputStream in, final PrintStream out) {
+  private void linkStreams(final String version, final int vmNum, final ProcessHolder holder,
+      final InputStream in, final PrintStream out) {
-        String vmName = (vmNum == -2) ? "[locator]" : "[vm_" + vmNum + "]";
+        String vmName = "[" + VM.getVMName(version, vmNum) + "] ";
-  private String[] buildJavaCommand(int vmNum, int namingPort) {
+  private String[] buildJavaCommand(int vmNum, int namingPort, String version) {
-    String classPath = System.getProperty("java.class.path");
-    //String tmpDir = System.getProperty("java.io.tmpdir");
+    String dunitClasspath = System.getProperty("java.class.path");
+    String classPath;
+    if (!VersionManager.isCurrentVersion(version)) {
+      classPath = versionManager.getClasspath(version) + File.pathSeparator + dunitClasspath;
+    } else {
+      classPath = dunitClasspath;
+    }
+
+    // String tmpDir = System.getProperty("java.io.tmpdir");
-    String jdkSuspend = vmNum == suspendVM ? "y" : "n";
+    String jdkSuspend = vmNum == suspendVM ? "y" : "n"; // ignore version
+    cmds.add("-D" + DUnitLauncher.VM_VERSION_PARAM + "=" + version);
-//      cmds.add("-D" + InternalLocator.INHIBIT_DM_BANNER + "=true");
+      if (version.equals(VersionManager.CURRENT_VERSION)) { // enable the banner for older versions
+        cmds.add("-D" + InternalLocator.INHIBIT_DM_BANNER + "=true");
+      }
-      // detection is disabled, so we turn it off in the locator.  Tests for network partition
+      // detection is disabled, so we turn it off in the locator. Tests for network partition
-      cmds.add("-D"+DistributionConfig.GEMFIRE_PREFIX+ENABLE_NETWORK_PARTITION_DETECTION+"=false");
+      cmds.add(
+          "-D" + DistributionConfig.GEMFIRE_PREFIX + ENABLE_NETWORK_PARTITION_DETECTION + "=false");
-    cmds.add("-D"+LOG_LEVEL+"=" + DUnitLauncher.logLevel);
+    cmds.add("-D" + LOG_LEVEL + "=" + DUnitLauncher.logLevel);
-    String jtests = System.getProperty("JTESTS");
-    if (jtests != null) {
-      cmds.add("-DJTESTS="+jtests);
-    }
-  
+
-    for (String jar: jars) {
+    for (String jar : jars) {
-   * Get the java agent passed to this process and pass it to the child VMs.
-   * This was added to support jacoco code coverage reports
+   * Get the java agent passed to this process and pass it to the child VMs. This was added to
+   * support jacoco code coverage reports
-          //HACK for gradle bug  GRADLE-2859. Jacoco is passing a relative path
-          //That won't work when we pass this to dunit VMs in a different 
-          //directory
-          arg = arg.replace("-javaagent:..", "-javaagent:" + System.getProperty("user.dir") + File.separator + "..");
-          arg = arg.replace("destfile=..", "destfile=" + System.getProperty("user.dir") + File.separator + "..");
+          // HACK for gradle bug GRADLE-2859. Jacoco is passing a relative path
+          // That won't work when we pass this to dunit VMs in a different
+          // directory
+          arg = arg.replace("-javaagent:..",
+              "-javaagent:" + System.getProperty("user.dir") + File.separator + "..");
+          arg = arg.replace("destfile=..",
+              "destfile=" + System.getProperty("user.dir") + File.separator + "..");
-  public RemoteDUnitVMIF getStub(int i) throws AccessException, RemoteException, NotBoundException, InterruptedException {
+  public RemoteDUnitVMIF getStub(int i)
+      throws AccessException, RemoteException, NotBoundException, InterruptedException {
+    return getStub(VersionManager.CURRENT_VERSION, i);
+  }
+
+  public RemoteDUnitVMIF getStub(String version, int i)
+      throws AccessException, RemoteException, NotBoundException, InterruptedException {
+
+  private static class VersionedVMNumber {
+    String version;
+    int number;
+
+    VersionedVMNumber(String version, int number) {
+      this.version = version;
+      this.number = number;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      VersionedVMNumber that = (VersionedVMNumber) o;
+
+      if (number != that.number) {
+        return false;
+      }
+      return version.equals(that.version);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = version.hashCode();
+      result = 31 * result + number;
+      return result;
+    }
+  }

Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
-  private final HashSet<Role> missingRequiredRoles = new HashSet<>();
+  final HashSet missingRequiredRoles = new HashSet(); // package-private to avoid synthetic accessor
-    initializationLatchAfterMemberTimeout =
+    this.initializationLatchAfterMemberTimeout =
-    distAdvisor = createDistributionAdvisor(internalRegionArgs);
+    this.distAdvisor = createDistributionAdvisor(internalRegionArgs);
-    Set<Role> reqRoles = new HashSet<>(attrs.getMembershipAttributes().getRequiredRoles());
+    Set reqRoles = new HashSet(attrs.getMembershipAttributes().getRequiredRoles());
-    requiresReliabilityCheck = setRequiresReliabilityCheck;
+    this.requiresReliabilityCheck = setRequiresReliabilityCheck;
-      persistenceAdvisor = internalRegionArgs.getPersistenceAdvisor();
+      this.persistenceAdvisor = internalRegionArgs.getPersistenceAdvisor();
-        persistenceAdvisor = new PersistenceAdvisorImpl(distAdvisor, dl, storage,
-            getFullPath(), diskStats, memberManager);
+        this.persistenceAdvisor = new PersistenceAdvisorImpl(this.distAdvisor, dl, storage,
+            this.getFullPath(), diskStats, memberManager);
-      persistenceAdvisor = null;
+      this.persistenceAdvisor = null;
-    if (persistenceAdvisor != null) {
-      persistentId = persistenceAdvisor.generatePersistentID();
+    if (this.persistenceAdvisor != null) {
+      this.persistentId = this.persistenceAdvisor.generatePersistentID();
-      persistentId = null;
+      this.persistentId = null;
-    if (!generateVersionTag) {
+    if (!this.generateVersionTag) {
-    return getConcurrencyChecksEnabled() && (getServerProxy() == null) && !isTX()
-        && scope.isDistributed() && !getDataPolicy().withReplication();
+    return this.getConcurrencyChecksEnabled() && (getServerProxy() == null) && !isTX()
+        && this.scope.isDistributed() && !this.getDataPolicy().withReplication();
-    if (scope.isGlobal() && // lock only applies to global scope
+    if (this.scope.isGlobal() && // lock only applies to global scope
-      dlock = getDistributedLockIfGlobal(event.getKey());
+      dlock = this.getDistributedLockIfGlobal(event.getKey());
-        if (requiresOneHopForMissingEntry(event)) {
+        if (this.requiresOneHopForMissingEntry(event)) {
-          if (re == null /* || re.isTombstone() */ || !generateVersionTag) {
-            if (!event.isBulkOpInProgress() || getDataPolicy().withStorage()) {
+          if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
+            if (!event.isBulkOpInProgress() || this.getDataPolicy().withStorage()) {
-                  expectedOldValue, requireOldValue, !generateVersionTag);
+                  expectedOldValue, requireOldValue, !this.generateVersionTag);
-              if (!generateVersionTag && !didDistribute) {
+              if (!this.generateVersionTag && !didDistribute) {
-    if (requiresOneHopForMissingEntry(event)) {
+    if (this.requiresOneHopForMissingEntry(event)) {
-      if (re == null /* || re.isTombstone() */ || !generateVersionTag) {
+      if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
-            false, !generateVersionTag);
-        if (!generateVersionTag && !didDistribute) {
+            false, !this.generateVersionTag);
+        if (!this.generateVersionTag && !didDistribute) {
-              getName());
+              this.getName());
-    boolean isDuplicate;
+    boolean isDuplicate = false;
-    return generateVersionTag;
+    return this.generateVersionTag;
-          generateVersionTag, getConcurrencyChecksEnabled(), getDataPolicy(), event);
+          this.generateVersionTag, this.getConcurrencyChecksEnabled(), this.getDataPolicy(), event);
-    if (!getConcurrencyChecksEnabled() || getDataPolicy() == DataPolicy.EMPTY
-        || !generateVersionTag) {
+    if (!this.getConcurrencyChecksEnabled() || this.getDataPolicy() == DataPolicy.EMPTY
+        || !this.generateVersionTag) {
-    if (!event.isOriginRemote() && getDataPolicy().withReplication()) {
+    if (!event.isOriginRemote() && this.getDataPolicy().withReplication()) {
-    if (!getDataPolicy().withReplication() && !getDataPolicy().withPersistence()) {
-      // do not generate a version stamp in a region that has no replication if it's not based
-      // on an existing version from a replicate region
-      return entry.getVersionStamp().hasValidVersion();
+    if (!this.getDataPolicy().withReplication() && !this.getDataPolicy().withPersistence()) {
+      if (!entry.getVersionStamp().hasValidVersion()) {
+        // do not generate a version stamp in a region that has no replication if it's not based
+        // on an existing version from a replicate region
+        return false;
+      }
+      return true;
-      if (!event.getDistributedMember().equals(getMyId())) {
+      if (!event.getDistributedMember().equals(this.getMyId())) {
-    if (requiresReliabilityCheck && isMissingRequiredRoles) {
+    if (this.requiresReliabilityCheck && this.isMissingRequiredRoles) {
-        synchronized (missingRequiredRoles) {
-          if (!isMissingRequiredRoles)
+        synchronized (this.missingRequiredRoles) {
+          if (!this.isMissingRequiredRoles)
-          Set<Role> roles = Collections.unmodifiableSet(new HashSet<>(missingRequiredRoles));
+          Set roles = Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
-    if (requiresReliabilityCheck && isMissingRequiredRoles) {
+    if (this.requiresReliabilityCheck && this.isMissingRequiredRoles) {
-        synchronized (missingRequiredRoles) {
-          if (!isMissingRequiredRoles)
+        synchronized (this.missingRequiredRoles) {
+          if (!this.isMissingRequiredRoles)
-          Set<Role> roles = Collections.unmodifiableSet(new HashSet<>(missingRequiredRoles));
+          Set roles = Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
-    if (requiresReliabilityCheck) {
+    if (this.requiresReliabilityCheck) {
-      Set<Role> roles = new HashSet<>();
+      Set roles = new HashSet();
-      Set<Role> failedRoles = new HashSet<>(ra.getRequiredRoles());
+      Set failedRoles = new HashSet(ra.getRequiredRoles());
-    if (requiresReliabilityCheck) {
+    if (this.requiresReliabilityCheck) {
-    return requiresReliabilityCheck;
+    return this.requiresReliabilityCheck;
-    if (requiresReliabilityCheck && isMissingRequiredRoles) {
+    if (this.requiresReliabilityCheck && this.isMissingRequiredRoles) {
-      return !getMembershipAttributes().getLossAction().isLimitedAccess()
-          || !expiry.isDistributedAction();
+      if (getMembershipAttributes().getLossAction().isLimitedAccess()
+          && expiry.isDistributedAction()) {
+        return false;
+      }
-    getDistributionManager().getWaitingThreadPool().execute(() -> {
-      try {
-        if (ra.isReinitialize()) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Reliability resumption for action of reinitialize");
-          }
-          if (!isDestroyed() && !cache.isClosed()) {
-            RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_REINITIALIZE, null,
-                false, getMyId(), generateEventID());
-            reinitialize(null, event);
-          }
-          synchronized (missingRequiredRoles) {
-            // any number of threads may be waiting on missingRequiredRoles
-            missingRequiredRoles.notifyAll();
-            if (hasListener() && id != null) {
-              // fire afterRoleGain event
-              RoleEventImpl relEvent = new RoleEventImpl(this, Operation.REGION_CREATE, null, true,
-                  id, newlyAcquiredRoles);
-              dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_GAIN, relEvent);
+    getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          if (ra.isReinitialize()) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Reliability resumption for action of reinitialize");
+            }
+            if (!isDestroyed() && !cache.isClosed()) {
+              RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
+                  Operation.REGION_REINITIALIZE, null, false, getMyId(), generateEventID());
+              reinitialize(null, event);
+            }
+            synchronized (missingRequiredRoles) {
+              // any number of threads may be waiting on missingRequiredRoles
+              missingRequiredRoles.notifyAll();
+              if (hasListener() && id != null) {
+                // fire afterRoleGain event
+                RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
+                    Operation.REGION_CREATE, null, true, id, newlyAcquiredRoles);
+                dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_GAIN, relEvent);
+              }
+        } catch (Exception e) {
+          logger.fatal("Unexpected exception:", e);
-      } catch (Exception e) {
-        logger.fatal("Unexpected exception:", e);
-    if (getEntryTimeToLive().getTimeout() > 0 && (isNoAccess || getEntryTimeToLive().getAction()
-        .isDistributed())) {
+    if (getEntryTimeToLive().getTimeout() > 0
+        && (isNoAccess || (isLimitedAccess && getEntryTimeToLive().getAction().isDistributed()))) {
-    } else if (getEntryIdleTimeout().getTimeout() > 0 && (isNoAccess || getEntryIdleTimeout()
-        .getAction().isDistributed())) {
+    } else if (getEntryIdleTimeout().getTimeout() > 0
+        && (isNoAccess || (isLimitedAccess && getEntryIdleTimeout().getAction().isDistributed()))) {
-    if (getRegionTimeToLive().getTimeout() > 0 && (isNoAccess || getRegionTimeToLive().getAction()
-        .isDistributed())) {
+    if (getRegionTimeToLive().getTimeout() > 0
+        && (isNoAccess || (isLimitedAccess && getRegionTimeToLive().getAction().isDistributed()))) {
-    if (getRegionIdleTimeout().getTimeout() > 0 && (isNoAccess || getRegionIdleTimeout().getAction()
-        .isDistributed())) {
+    if (getRegionIdleTimeout().getTimeout() > 0 && (isNoAccess
+        || (isLimitedAccess && getRegionIdleTimeout().getAction().isDistributed()))) {
-                RoleEventImpl relEvent = new RoleEventImpl(this,
+                RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
-        synchronized (missingRequiredRoles) {
+        synchronized (this.missingRequiredRoles) {
-          missingRequiredRoles.notifyAll();
+          this.missingRequiredRoles.notifyAll();
-            RoleEventImpl relEvent = new RoleEventImpl(this,
+            RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
-  private void lockCheckReadiness() { // package-private to avoid synthetic accessor
+  void lockCheckReadiness() { // package-private to avoid synthetic accessor
-    cache.getCancelCriterion().checkCancelInProgress(null);
+    this.cache.getCancelCriterion().checkCancelInProgress(null);
-    Lock dlock = getDistributedLockIfGlobal(key);
+    Lock dlock = this.getDistributedLockIfGlobal(key);
-        getLockService().freeResources(key);
+        this.getLockService().freeResources(key);
-        getLockService().freeResources(key);
+        this.getLockService().freeResources(key);
-    Lock dlock = getDistributedLockIfGlobal(key);
+    Lock dlock = this.getDistributedLockIfGlobal(key);
-    if (!scope.isGlobal()) {
+    if (!this.scope.isGlobal()) {
-              scope));
+              this.scope));
-    if (!scope.isGlobal()) {
+    if (!this.scope.isGlobal()) {
-              scope));
+              this.scope));
-      for (GatewaySender sender : cache.getAllGatewaySenders()) {
+      for (GatewaySender sender : this.cache.getAllGatewaySenders()) {
-                    getFullPath()));
+                    this.getFullPath()));
-                    sender.getId(), getFullPath()));
+                    sender.getId(), this.getFullPath()));
-    if (scope.isGlobal()) {
+    if (this.scope.isGlobal()) {
-        handleDiskAccessException(dae, true);
+        this.handleDiskAccessException(dae, true);
-      isInitializingThread = false;
+      this.isInitializingThread = false;
-        getName());
+        this.getName());
-              true, snapshotInputStream));
+              new Object[] {true, snapshotInputStream}));
-    if (getDataPolicy().withPersistence()) {
+    if (this.getDataPolicy().withPersistence()) {
-    if (getDataPolicy().withPersistence()) {
-      recovered_rvv = getVersionVector() == null ? null
-          : getVersionVector().getCloneForTransmission();
+    if (this.getDataPolicy().withPersistence()) {
+      recovered_rvv = this.getVersionVector() == null ? null
+          : this.getVersionVector().getCloneForTransmission();
-    if (persistenceAdvisor != null) {
-      persistenceAdvisor.initialize();
+    if (this.persistenceAdvisor != null) {
+      this.persistenceAdvisor.initialize();
-      if (!isDestroyed) {
-        cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
+      if (!this.isDestroyed) {
+        this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
-      } catch (IOException | ClassNotFoundException e) {
-        throw new RuntimeException(e);
+      } catch (IOException e) {
+        throw new RuntimeException(e); // TODO: change this exception?
+      } catch (ClassNotFoundException e) {
+        throw new RuntimeException(e); // TODO: change this exception?
-    InitialImageOperation iiop = new InitialImageOperation(this, entries);
+    InitialImageOperation iiop = new InitialImageOperation(this, this.entries);
-    while (!isDestroyed()) {
+    boolean done = false;
+    while (!done && !isDestroyed()) {
-          || getDataPolicy().withPreloaded() && !advice.preloaded.isEmpty() // this is a
-                                                                            // preloaded
+          || this.getDataPolicy().withPreloaded() && !advice.preloaded.isEmpty() // this is a
+                                                                                 // preloaded
-                giiMissingRequiredRoles = false;
+                this.giiMissingRequiredRoles = false;
+                done = true;
+            done = true;
-          if (getDataPolicy().isPreloaded()) {
+          if (this.getDataPolicy().isPreloaded()) {
+              done = true;
-                new Object[] {getFullPath(), persistentId, getPersistentID()});
+                new Object[] {this.getFullPath(), persistentId, getPersistentID()});
-              RegionLogger.logRecovery(getFullPath(), persistentId,
+              RegionLogger.logRecovery(this.getFullPath(), persistentId,
-            RegionLogger.logCreate(getFullPath(),
+            RegionLogger.logCreate(this.getFullPath(),
-              RegionLogger.logPersistence(getFullPath(),
+              RegionLogger.logPersistence(this.getFullPath(),
-                  new Object[] {getFullPath(), getPersistentID()});
+                  new Object[] {this.getFullPath(), getPersistentID()});
+          done = true;
-    if (!getConcurrencyChecksEnabled()) {
+    if (!this.getConcurrencyChecksEnabled()) {
-    InitialImageOperation op = new InitialImageOperation(this, entries);
+    InitialImageOperation op = new InitialImageOperation(this, this.entries);
-        if (indexManager != null) {
+        if (this.indexManager != null) {
-            indexManager.rerunIndexCreationQuery();
+            this.indexManager.rerunIndexCreationQuery();
-  private void unlockFailedInitialImageReadLock() {
+  void unlockFailedInitialImageReadLock() {
-    synchronized (advisorListener) {
+    synchronized (this.advisorListener) {
-      Set<InternalDistributedMember> others =
-          distAdvisor.addMembershipListenerAndAdviseGeneric(advisorListener);
-      advisorListener.addMembers(others);
+      Set others = this.distAdvisor.addMembershipListenerAndAdviseGeneric(this.advisorListener);
+      this.advisorListener.addMembers(others);
-        synchronized (missingRequiredRoles) {
-          missingRequiredRoles.addAll(getMembershipAttributes().getRequiredRoles());
+        synchronized (this.missingRequiredRoles) {
+          this.missingRequiredRoles.addAll(getMembershipAttributes().getRequiredRoles());
-          missingRequiredRoles.removeAll(getSystem().getDistributedMember().getRoles());
+          this.missingRequiredRoles.removeAll(getSystem().getDistributedMember().getRoles());
-            missingRequiredRoles.removeAll(other.getRoles());
+            this.missingRequiredRoles.removeAll(other.getRoles());
-        if (giiMissingRequiredRoles) {
+        if (this.giiMissingRequiredRoles) {
-          isInitializingThread = true;
-          synchronized (advisorListener) {
-            synchronized (missingRequiredRoles) {
+          this.isInitializingThread = true;
+          synchronized (this.advisorListener) {
+            synchronized (this.missingRequiredRoles) {
-              isMissingRequiredRoles = true;
+              this.isMissingRequiredRoles = true;
-              isInitializingThread = true;
+              this.isInitializingThread = true;
-              if (missingRequiredRoles.isEmpty()) {
+              if (this.missingRequiredRoles.isEmpty()) {
-                isMissingRequiredRoles = false;
+                this.isMissingRequiredRoles = false;
-                  advisorListener.destroyed = true;
+                  this.advisorListener.destroyed = true;
-          synchronized (advisorListener) {
-            synchronized (missingRequiredRoles) {
-              if (missingRequiredRoles.isEmpty()) {
-                Assert.assertTrue(!isMissingRequiredRoles);
+          synchronized (this.advisorListener) {
+            synchronized (this.missingRequiredRoles) {
+              if (this.missingRequiredRoles.isEmpty()) {
+                Assert.assertTrue(!this.isMissingRequiredRoles);
-                isMissingRequiredRoles = true;
+                this.isMissingRequiredRoles = true;
-                      missingRequiredRoles);
+                      this.missingRequiredRoles);
-                isInitializingThread = true;
+                this.isInitializingThread = true;
-        if (isInitializingThread) {
+        if (this.isInitializingThread) {
-    initializationLatchAfterMemberTimeout.countDown();
+    this.initializationLatchAfterMemberTimeout.countDown();
-      Iterator<Object> keysIt = getImageState().getDestroyedEntries();
+      Iterator/* <Object> */ keysIt = getImageState().getDestroyedEntries();
-        entries.removeIfDestroyed(keysIt.next());
+        this.entries.removeIfDestroyed(keysIt.next());
-      if (persistenceAdvisor != null) {
-        persistenceAdvisor.setOnline(GIIStatus.didGII(giiStatus), false, getPersistentID());
+      if (this.persistenceAdvisor != null) {
+        this.persistenceAdvisor.setOnline(GIIStatus.didGII(giiStatus), false, getPersistentID());
-    logger.info("Initialization of region {} completed", getName());
+    logger.info("Initialization of region {} completed", this.getName());
-      if (requiresOneHopForMissingEntry(event)) {
+      if (this.requiresOneHopForMissingEntry(event)) {
-        if (re == null /* || re.isTombstone() */ || !generateVersionTag) {
+        if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
-            Assert.assertTrue(!getDataPolicy().withReplication() || !generateVersionTag);
+            Assert.assertTrue(!this.getDataPolicy().withReplication() || !this.generateVersionTag);
-          if (!event.isBulkOpInProgress() || getDataPolicy().withStorage()) {
+          if (!event.isBulkOpInProgress() || this.getDataPolicy().withStorage()) {
-                RemoteDestroyMessage.distribute(event, expectedOldValue, !generateVersionTag);
+                RemoteDestroyMessage.distribute(event, expectedOldValue, !this.generateVersionTag);
-            if (!generateVersionTag && !didDistribute) {
+            if (!this.generateVersionTag && !didDistribute) {
-      if (scope.isGlobal() && event.isOriginRemote()) {
+      if (this.scope.isGlobal() && event.isOriginRemote()) {
-      if (scope.isGlobal()) {
+      if (this.scope.isGlobal()) {
-      cache.beginDestroy(path, this);
+      this.cache.beginDestroy(path, this);
-        cache.endDestroy(path, this);
+        this.cache.endDestroy(path, this);
-    if (persistenceAdvisor != null) {
-      persistenceAdvisor.releaseTieLock();
+    if (this.persistenceAdvisor != null) {
+      this.persistenceAdvisor.releaseTieLock();
-      if (requiresOneHopForMissingEntry(event)) {
+      if (this.requiresOneHopForMissingEntry(event)) {
-        if (re == null/* || re.isTombstone() */ || !generateVersionTag) {
+        if (re == null/* || re.isTombstone() */ || !this.generateVersionTag) {
-            Assert.assertTrue(!getDataPolicy().withReplication() || !generateVersionTag);
+            Assert.assertTrue(!this.getDataPolicy().withReplication() || !this.generateVersionTag);
-              RemoteInvalidateMessage.distribute(event, !generateVersionTag);
-          if (!generateVersionTag && !didDistribute) {
+              RemoteInvalidateMessage.distribute(event, !this.generateVersionTag);
+          if (!this.generateVersionTag && !didDistribute) {
-    if (!isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
+    if (!this.isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
-    if (!isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
+    if (!this.isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
-    Lock dlock = getRegionDistributedLockIfGlobal();
+    Lock dlock = this.getRegionDistributedLockIfGlobal();
-    if (getConcurrencyChecksEnabled() && !getDataPolicy().withReplication()) {
+    if (this.getConcurrencyChecksEnabled() && !this.getDataPolicy().withReplication()) {
-        Set<InternalDistributedMember> repls = distAdvisor.adviseReplicates();
+        Set<InternalDistributedMember> repls = this.distAdvisor.adviseReplicates();
-    boolean enableRVV = useRVV && getDataPolicy().withReplication()
-        && getConcurrencyChecksEnabled() && !getDistributionManager().isLoner();
+    boolean enableRVV = useRVV && this.getDataPolicy().withReplication()
+        && this.getConcurrencyChecksEnabled() && !getDistributionManager().isLoner();
-    synchronized (clearLock) {
+    synchronized (this.clearLock) {
-    if (!scope.isGlobal()) { // non-global regions must lock when using RVV
+    if (!this.scope.isGlobal()) { // non-global regions must lock when using RVV
-    if (!scope.isGlobal()) {
+    if (!this.scope.isGlobal()) {
-      if (getAttributes().getScope().isDistributedNoAck()) {
+      if (this.getAttributes().getScope().isDistributedNoAck()) {
-      synchronized (clearLock) {
+      synchronized (this.clearLock) {
-    getCachePerfStats().incTombstoneGCCount();
+    this.getCachePerfStats().incTombstoneGCCount();
-    return distAdvisor;
+    return this.distAdvisor;
-    return distAdvisor;
+    return this.distAdvisor;
-    return persistenceAdvisor;
+    return this.persistenceAdvisor;
-    return persistentId;
+    return this.persistentId;
-    return distAdvisor.createProfile();
+    return this.distAdvisor.createProfile();
-    Assert.assertTrue(scope.isDistributed());
-    cacheProfile.scope = scope;
+    Assert.assertTrue(this.scope.isDistributed());
+    cacheProfile.scope = this.scope;
-    cacheProfile.hasCacheServer = !cache.getCacheServers().isEmpty();
-    cacheProfile.requiresOldValueInEvents = getDataPolicy().withReplication()
-        && filterProfile != null && filterProfile.hasCQs();
+    cacheProfile.hasCacheServer = this.cache.getCacheServers().size() > 0 ? true : false;
+    cacheProfile.requiresOldValueInEvents = this.getDataPolicy().withReplication()
+        && this.filterProfile != null && this.filterProfile.hasCQs();
-    synchronized (dlockMonitor) {
+    synchronized (this.dlockMonitor) {
-      if (dlockService == null) {
-        dlockService = DistributedLockService.getServiceNamed(dlsName);
-        if (dlockService == null) {
+      if (this.dlockService == null) {
+        this.dlockService = DistributedLockService.getServiceNamed(dlsName);
+        if (this.dlockService == null) {
-          dlockService = DLockService.create(getFullPath(), getSystem(), true, false, false);
+          this.dlockService = DLockService.create(getFullPath(), getSystem(), true, false, false);
-        if (isLockGrantor) {
-          dlockService.becomeLockGrantor();
+        if (this.isLockGrantor) {
+          this.dlockService.becomeLockGrantor();
-      return dlockService;
+      return this.dlockService;
-    return scope.isGlobal() && getLockService().isLockGrantor();
+    return this.scope.isGlobal() && getLockService().isLockGrantor();
-    return scope.isGlobal() && isLockGrantor;
+    return this.scope.isGlobal() && this.isLockGrantor;
-    if (!scope.isGlobal()) {
+    if (!this.scope.isGlobal()) {
-              scope));
+              this.scope));
-    final boolean disabled = entries.disableLruUpdateCallback();
+    final boolean disabled = this.entries.disableLruUpdateCallback();
-        synchronized (re) {
-          // value & version must be obtained atomically
+        synchronized (re) { // bug #51059 value & version must be obtained atomically
-        entries.enableLruUpdateCallback();
+        this.entries.enableLruUpdateCallback();
-        entries.lruUpdateCallback();
+        this.entries.lruUpdateCallback();
-        handleDiskAccessException(dae);
+        this.handleDiskAccessException(dae);
-      Set netWriteRecipients = localWriter == null ? distAdvisor.adviseNetWrite() : null;
+      Set netWriteRecipients = localWriter == null ? this.distAdvisor.adviseNetWrite() : null;
-      Set netWriteRecipients = localWriter == null ? distAdvisor.adviseNetWrite() : null;
+      Set netWriteRecipients = localWriter == null ? this.distAdvisor.adviseNetWrite() : null;
-      synchronized (missingRequiredRoles) {
-        missingRequiredRoles.notifyAll();
+      synchronized (this.missingRequiredRoles) {
+        this.missingRequiredRoles.notifyAll();
-    if (persistenceAdvisor != null) {
-      persistenceAdvisor.close(); // fix for bug 41094
+    if (this.persistenceAdvisor != null) {
+      this.persistenceAdvisor.close(); // fix for bug 41094
-    distAdvisor.close();
+    this.distAdvisor.close();
-    synchronized (dlockMonitor) {
-      if (dlockService != null) {
-        dls = (DLockService) dlockService;
+    synchronized (this.dlockMonitor) {
+      if (this.dlockService != null) {
+        dls = (DLockService) this.dlockService;
-            getFullPath(),
+            this.getFullPath(),
-  private void waitForCurrentOperations() {
+  protected void waitForCurrentOperations() {
-    if (!cache.forcedDisconnect() && flushOnClose
-        && getDistributionManager().getMembershipManager() != null
-        && getDistributionManager().getMembershipManager().isConnected()) {
+    if (!this.cache.forcedDisconnect() && flushOnClose
+        && this.getDistributionManager().getMembershipManager() != null
+        && this.getDistributionManager().getMembershipManager().isConnected()) {
-        logger.warn(String.format("%s: error closing region %s", this, getFullPath()), e);
+        logger.warn(String.format("%s: error closing region %s",
+            new Object[] {this, getFullPath()}), e);
-    synchronized (advisorListener) {
-      Set<InternalDistributedMember> others = advisorListener.getInitialMembers();
+    synchronized (this.advisorListener) {
+      Set others = this.advisorListener.getInitialMembers();
-              DistributedMember[] otherDms = others.toArray(new DistributedMember[0]);
+              DistributedMember[] otherDms = new DistributedMember[others.size()];
+              others.toArray(otherDms);
-      advisorListener.initRMLWrappers();
+      this.advisorListener.initRMLWrappers();
-        getCacheDistributionAdvisor().adviseSameGatewaySenderIds(getGatewaySenderIds());
+        this.getCacheDistributionAdvisor().adviseSameGatewaySenderIds(getGatewaySenderIds());
-              getName(), senderIds.get(0), senderIds.get(1)));
+              new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
-    List<Set<String>> asycnQueueIds = getCacheDistributionAdvisor()
+    List<Set<String>> asycnQueueIds = this.getCacheDistributionAdvisor()
-              getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)));
+              new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
-        cache.getCancelCriterion().checkCancelInProgress(null);
+        this.cache.getCancelCriterion().checkCancelInProgress(null);
-          cache.getCancelCriterion().checkCancelInProgress(ex);
+          this.cache.getCancelCriterion().checkCancelInProgress(ex);
-    DiskRegion dr = getDiskRegion();
+    DiskRegion dr = this.getDiskRegion();
-    return entries.regionEntries().iterator();
+    return this.entries.regionEntries().iterator();
-      if (subIt != null) {
-        result = subIt.hasNext();
+      if (this.subIt != null) {
+        result = this.subIt.hasNext();
-          subIt = null;
+          this.subIt = null;
-      result = it.hasNext();
-      if (usingIt && !result) {
-        usingIt = false;
-        it = diskMap.values().iterator();
-        result = it.hasNext();
+      result = this.it.hasNext();
+      if (this.usingIt && !result) {
+        this.usingIt = false;
+        this.it = this.diskMap.values().iterator();
+        result = this.it.hasNext();
-        if (subIt != null) {
-          return subIt.next();
+        if (this.subIt != null) {
+          return this.subIt.next();
-        if (usingIt) {
-          RegionEntry regionEntry = (RegionEntry) it.next();
+        if (this.usingIt) {
+          RegionEntry regionEntry = (RegionEntry) this.it.next();
-            Object value = diskMap.get(dPage);
+            Object value = this.diskMap.get(dPage);
-              diskMap.put(dPage, regionEntry);
+              this.diskMap.put(dPage, regionEntry);
-              List<Object> list = (ArrayList<Object>) value;
+              List list = (List) value;
-              List<Object> list = new ArrayList<>();
+              List list = new ArrayList();
-              diskMap.put(dPage, list);
+              this.diskMap.put(dPage, list);
-            assert hasNext(); // must be true
+            if (!hasNext()) {
+              assert false; // must be true
+            }
-          Object value = it.next();
+          Object value = this.it.next();
-            List<RegionEntry> list = (List<RegionEntry>) value;
-            subIt = list.iterator();
-            return subIt.next();
+            List list = (List) value;
+            this.subIt = list.iterator();
+            return this.subIt.next();
-      return Long.valueOf(oplogId ^ offset).hashCode();
+      return Long.valueOf(this.oplogId ^ this.offset).hashCode();
-        return oplogId == other.oplogId && offset == other.offset;
+        return this.oplogId == other.oplogId && this.offset == other.offset;
-      int result = Long.signum(oplogId - o.oplogId);
+      int result = Long.signum(this.oplogId - o.oplogId);
-        result = Long.signum(offset - o.offset);
+        result = Long.signum(this.offset - o.offset);
-      return "<" + oplogId + ':' + offset + '>';
+      StringBuilder sb = new StringBuilder();
+      sb.append('<').append(this.oplogId).append(':').append(this.offset).append('>');
+      return sb.toString();
-      setPosition(diskPosition.oplogId, diskPosition.offset / DISK_PAGE_SIZE);
+      this.setPosition(diskPosition.oplogId, diskPosition.offset / DISK_PAGE_SIZE);
-  private long getLockLeaseForLock() { // package-private to avoid synthetic accessor
+  long getLockLeaseForLock() { // package-private to avoid synthetic accessor
-  private long getLockTimeoutForLock(long time, TimeUnit unit) { // package-private to avoid
-                                                                 // synthetic
-    // accessor
+  long getLockTimeoutForLock(long time, TimeUnit unit) { // package-private to avoid synthetic
+                                                         // accessor
-        return getLockService().lock(key, 0, getLockLeaseForLock());
+        return getLockService().lock(this.key, 0, getLockLeaseForLock());
-                getLockService().lockInterruptibly(key, waitInterval, getLockLeaseForLock());
+                getLockService().lockInterruptibly(this.key, waitInterval, getLockLeaseForLock());
-            gotLock = getLockService().lock(key, waitInterval, getLockLeaseForLock());
+            gotLock = getLockService().lock(this.key, waitInterval, getLockLeaseForLock());
-        getLockService().unlock(key);
-        if (!entries.containsKey(key)) {
-          getLockService().freeResources(key);
+        getLockService().unlock(this.key);
+        if (!DistributedRegion.this.entries.containsKey(this.key)) {
+          getLockService().freeResources(this.key);
-    Lock dlock = getRegionDistributedLockIfGlobal();
+    Lock dlock = this.getRegionDistributedLockIfGlobal();
-    Lock dlock = getRegionDistributedLockIfGlobal();
+    Lock dlock = this.getRegionDistributedLockIfGlobal();
-    if (!isMissingRequiredRoles) { // should we delete this check?
+    if (!this.isMissingRequiredRoles) { // should we delete this check?
-        while (isMissingRequiredRoles) {
+        while (this.isMissingRequiredRoles) {
-          cache.getCancelCriterion().checkCancelInProgress(null);
-          synchronized (missingRequiredRoles) {
+          this.cache.getCancelCriterion().checkCancelInProgress(null);
+          synchronized (this.missingRequiredRoles) {
-            if (isMissingRequiredRoles) {
+            if (this.isMissingRequiredRoles) {
-              missingRequiredRoles.wait(); // spurious wakeup ok
+              this.missingRequiredRoles.wait(); // spurious wakeup ok
-        while (isMissingRequiredRoles) {
+        while (this.isMissingRequiredRoles) {
-          cache.getCancelCriterion().checkCancelInProgress(null);
-          synchronized (missingRequiredRoles) {
+          this.cache.getCancelCriterion().checkCancelInProgress(null);
+          synchronized (this.missingRequiredRoles) {
-            if (isMissingRequiredRoles) {
+            if (this.isMissingRequiredRoles) {
-                missingRequiredRoles.wait(timeToWait); // spurious wakeup ok
+                this.missingRequiredRoles.wait(timeToWait); // spurious wakeup ok
-    if (isMissingRequiredRoles) {
+    if (this.isMissingRequiredRoles) {
-      synchronized (missingRequiredRoles) {
-        return Collections.unmodifiableSet(new HashSet<>(missingRequiredRoles));
+      synchronized (this.missingRequiredRoles) {
+        return Collections.unmodifiableSet(new HashSet<>(this.missingRequiredRoles));
-    for (DistributedMember member : distAdvisor.adviseGeneric()) {
+    for (DistributedMember member : this.distAdvisor.adviseGeneric()) {
-    synchronized (advisorListener) {
-      if (advisorListener.members == null && hasListener()) {
+    synchronized (this.advisorListener) {
+      if (this.advisorListener.members == null && hasListener()) {
-    Set<InternalDistributedMember> members = new HashSet<>(); // package-private to avoid synthetic
-                                                              // accessor
+    Set members = new HashSet(); // package-private to avoid synthetic accessor
-    synchronized void addMembers(Set<InternalDistributedMember> newMembers) {
-      members.addAll(newMembers);
+    synchronized void addMembers(Set newMembers) {
+      this.members.addAll(newMembers);
-    protected synchronized Set<InternalDistributedMember> getInitialMembers() {
-      Set<InternalDistributedMember> initMembers = members;
-      members = null;
+    protected synchronized Set getInitialMembers() {
+      Set initMembers = this.members;
+      this.members = null;
-          distAdvisor.adviseGeneric();
+          DistributedRegion.this.distAdvisor.adviseGeneric();
-      if (destroyed) {
+      if (this.destroyed) {
-      if (members != null) {
-        members.add(id);
+      if (this.members != null) {
+        this.members.add(id);
-        Set<Role> newlyAcquiredRoles = Collections.emptySet();
+        Set newlyAcquiredRoles = Collections.emptySet();
-            Set<Role> roles = id.getRoles();
-            newlyAcquiredRoles = new HashSet<>(missingRequiredRoles);
+            Set roles = id.getRoles();
+            newlyAcquiredRoles = new HashSet(missingRequiredRoles);
-              if (members == null && missingRequiredRoles.isEmpty()) {
+              if (this.members == null && missingRequiredRoles.isEmpty()) {
-                  destroyed = true;
+                  this.destroyed = true;
-          if (!destroyed) {
+          if (!this.destroyed) {
-        if (!destroyed && members == null && hasListener()) {
+        if (!this.destroyed && this.members == null && hasListener()) {
-      if (destroyed) {
+      if (this.destroyed) {
-      if (members != null) {
-        members.remove(id);
+      if (this.members != null) {
+        this.members.remove(id);
-      if (members == null && hasListener()) {
+      if (this.members == null && hasListener()) {
-        Set<Role> newlyMissingRoles = Collections.emptySet();
+        Set newlyMissingRoles = Collections.emptySet();
-          Set<Role> roles = id.getRoles();
-          for (Role role : roles) {
+          Set roles = id.getRoles();
+          for (Iterator iter = roles.iterator(); iter.hasNext();) {
+            Role role = (Role) iter.next();
-              if (newlyMissingRoles.isEmpty()) {
-                newlyMissingRoles = new HashSet<>();
+              if (newlyMissingRoles == Collections.emptySet()) {
+                newlyMissingRoles = new HashSet();
-              if (members == null && !isMissingRequiredRoles) {
+              if (this.members == null && !isMissingRequiredRoles) {
-                if (getMembershipAttributes().getLossAction().isAllAccess()) {
+                if (getMembershipAttributes().getLossAction().isAllAccess())
-                } else if (getMembershipAttributes().getLossAction().isLimitedAccess()) {
+                else if (getMembershipAttributes().getLossAction().isLimitedAccess())
-                } else if (getMembershipAttributes().getLossAction().isNoAccess()) {
+                else if (getMembershipAttributes().getLossAction().isNoAccess())
-                }
-                  destroyed = true;
+                  this.destroyed = true;
-          if (!destroyed) {
+          if (!this.destroyed) {
-        if (!destroyed && members == null && hasListener()) {
+        if (!this.destroyed && this.members == null && hasListener()) {
-    assert !isInternalRegion() || isMetaRegionWithTransactions();
-    if (!getAttributes().getDataPolicy().withStorage() || (getConcurrencyChecksEnabled()
-        && getAttributes().getDataPolicy() == DataPolicy.NORMAL)) {
+    assert !this.isInternalRegion() || this.isMetaRegionWithTransactions();
+    if (!this.getAttributes().getDataPolicy().withStorage() || (this.getConcurrencyChecksEnabled()
+        && this.getAttributes().getDataPolicy() == DataPolicy.NORMAL)) {
-    if (getConcurrencyChecksEnabled() && !generateVersionTag) {
+    if (this.getConcurrencyChecksEnabled() && !generateVersionTag) {
-    } else if (getAttributes().getDataPolicy().withReplication()
-        || getAttributes().getDataPolicy().withPreloaded()) {
+    } else if (this.getAttributes().getDataPolicy().withReplication()
+        || this.getAttributes().getDataPolicy().withPreloaded()) {
-    final Set<InternalDistributedMember> singleMember =
-        Collections.singleton((InternalDistributedMember) target);
+    final Set singleMember = Collections.singleton(target);
-    HashMap<InternalDistributedMember, Object> memberArgs = new HashMap<>();
+    HashMap<InternalDistributedMember, Object> memberArgs =
+        new HashMap<InternalDistributedMember, Object>();
-        new DistributedRegionFunctionResultWaiter(getSystem(), getFullPath(), rc,
+        new DistributedRegionFunctionResultWaiter(this.getSystem(), this.getFullPath(), rc,
-    GetRandomReplicate() {}
+    public GetRandomReplicate() {}
-    GetRandomReplicate(boolean onlyPersistent) {
+    public GetRandomReplicate(boolean onlyPersistent) {
-      if (randIndex < 0) {
-        randIndex = PartitionedRegion.RANDOM.nextInt(numProfiles);
+      if (this.randIndex < 0) {
+        this.randIndex = PartitionedRegion.RANDOM.nextInt(numProfiles);
-        return profileIndex < randIndex;
+        if (profileIndex >= this.randIndex) {
+          return false;
+        }
-  private InternalDistributedMember getRandomReplicate() {
+  public InternalDistributedMember getRandomReplicate() {
-    getCacheDistributionAdvisor().accept(getReplicate, null);
+    this.getCacheDistributionAdvisor().accept(getReplicate, null);
-  private InternalDistributedMember getRandomPersistentReplicate() {
+  public InternalDistributedMember getRandomPersistentReplicate() {
-    getCacheDistributionAdvisor().accept(getPersistentReplicate, null);
+    this.getCacheDistributionAdvisor().accept(getPersistentReplicate, null);
-  private ResultCollector executeLocally(final DistributedRegionFunctionExecutor execution,
-      final Function function, final Object args, int prid,
-      final ResultCollector rc,
-      final Set filter,
-      final ServerToClientFunctionResultSender sender) {
+  ResultCollector executeLocally(final DistributedRegionFunctionExecutor execution,
+      final Function function, final Object args, int prid, final ResultCollector rc,
+      final Set filter, final ServerToClientFunctionResultSender sender) {
-        this, args, filter, null, null, resultSender, execution.isReExecute());
+        DistributedRegion.this, args, filter, null, null, resultSender, execution.isReExecute());
-    synchronized (memoryThresholdReachedMembers) {
-      memoryThresholdReachedMembers.remove(member);
-      if (memoryThresholdReachedMembers.isEmpty()) {
+    synchronized (this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.remove(member);
+      if (this.memoryThresholdReachedMembers.isEmpty()) {
-    synchronized (memoryThresholdReachedMembers) {
-      if (memoryThresholdReachedMembers.isEmpty()) {
+    synchronized (this.memoryThresholdReachedMembers) {
+      if (this.memoryThresholdReachedMembers.isEmpty()) {
-      memoryThresholdReachedMembers.add(idm);
+      this.memoryThresholdReachedMembers.add(idm);
-          new HashSet<>(memoryThresholdReachedMembers));
+          new HashSet<DistributedMember>(memoryThresholdReachedMembers));
-    assert getDataPolicy() != DataPolicy.REPLICATE;
+    assert this.getDataPolicy() != DataPolicy.REPLICATE;
-    return hasNetLoader(getCacheDistributionAdvisor());
+    return this.hasNetLoader(getCacheDistributionAdvisor());
-    LatestLastAccessTimeOperation op = new LatestLastAccessTimeOperation<>(this, key);
+    LatestLastAccessTimeOperation op = new LatestLastAccessTimeOperation(this, key);

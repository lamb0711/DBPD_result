Merge branch 'release/1.0.0-incubating.M3'

-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.atomic.AtomicInteger;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
-import com.gemstone.gemfire.internal.cache.RegionEntry;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
-  private ReferenceCountHelper() {
-    // no instances allowed
-  }
-  final static private boolean trackRefCounts = Boolean.getBoolean("gemfire.trackOffHeapRefCounts");
-  final static private boolean trackFreedRefCounts = Boolean.getBoolean("gemfire.trackOffHeapFreedRefCounts");
-  final static private ConcurrentMap<Long, List<RefCountChangeInfo>> stacktraces;
-  final static private ConcurrentMap<Long, List<RefCountChangeInfo>> freedStacktraces;
-  final static private ThreadLocal<Object> refCountOwner;
-  final static private ThreadLocal<AtomicInteger> refCountReenterCount;
-  final static private Object SKIP_REF_COUNT_TRACKING = new Object();
-  final static private List<RefCountChangeInfo> LOCKED = Collections.emptyList();
-  static {
-    if (trackRefCounts) {
-      stacktraces = new ConcurrentHashMap<Long, List<RefCountChangeInfo>>();
-      if (trackFreedRefCounts) {
-        freedStacktraces = new ConcurrentHashMap<Long, List<RefCountChangeInfo>>();
-      } else {
-        freedStacktraces = null;
-      }
-      refCountOwner = new ThreadLocal<Object>();
-      refCountReenterCount = new ThreadLocal<AtomicInteger>();
-    } else {
-      stacktraces = null;
-      freedStacktraces = null;
-      refCountOwner = null;
-      refCountReenterCount = null;
-    }
+  public static final String TRACK_OFFHEAP_REFERENCES = DistributionConfig.GEMFIRE_PREFIX + "trackOffHeapRefCounts";
+  public static final String TRACK_OFFHEAP_FREES = DistributionConfig.GEMFIRE_PREFIX + "trackOffHeapFreedRefCounts";
+
+  private static final ReferenceCountHelperImpl inst = new ReferenceCountHelperImpl(Boolean.getBoolean(TRACK_OFFHEAP_REFERENCES), Boolean.getBoolean(TRACK_OFFHEAP_FREES));
+
+  /* Do not allow any instances */
+  private ReferenceCountHelper() {}
+  
+  static ReferenceCountHelperImpl getInstance() {
+    return inst;
-    return trackRefCounts;
+    return getInstance().trackReferenceCounts();
-    return trackFreedRefCounts;
+    return getInstance().trackFreedReferenceCounts();
-    if (trackReferenceCounts()) {
-      if (refCountOwner.get() != null) {
-        AtomicInteger ai = refCountReenterCount.get();
-        if (owner != null) {
-          ai.incrementAndGet();
-        } else {
-          if (ai.decrementAndGet() <= 0) {
-            refCountOwner.set(null);
-            ai.set(0);
-          }
-        }
-      } else {
-        AtomicInteger ai = refCountReenterCount.get();
-        if (ai == null) {
-          ai = new AtomicInteger(0);
-          refCountReenterCount.set(ai);
-        }
-        if (owner != null) {
-          ai.set(1);
-        } else {
-          ai.set(0);
-        }
-        refCountOwner.set(owner);
-      }
-    }
+    getInstance().setReferenceCountOwner(owner);
-    Object result = null;
-    if (trackReferenceCounts()) {
-      result = new Object();
-      setReferenceCountOwner(result);
-    }
-    return result;
+    return getInstance().createReferenceCountOwner();
-    setReferenceCountOwner(SKIP_REF_COUNT_TRACKING);
+    getInstance().skipRefCountTracking();
+  }
+
+  /**
+   * Returns true if currently tracking reference counts.
+   */
+  public static boolean isRefCountTracking() {
+    return getInstance().isRefCountTracking();
-    setReferenceCountOwner(null);
+    getInstance().unskipRefCountTracking();
-    if (!trackReferenceCounts()) return null;
-    List<RefCountChangeInfo> result = stacktraces.get(address);
-    while (result != null && !stacktraces.replace(address, result, LOCKED)) {
-      result = stacktraces.get(address);
-    }
-    return result;
+    return getInstance().getRefCountInfo(address);
+  }
+
+  /**
+   * Used internally to report that a reference count has changed.
+   */  
+  static void refCountChanged(Long address, boolean decRefCount, int rc) {
+    getInstance().refCountChanged(address, decRefCount, rc);
+  }
+
+  /**
+   * Called internally when free operations are tracked to record
+   * that a free has happened of the given address.
+   */
+  static void freeRefCountInfo(Long address) {
+    getInstance().freeRefCountInfo(address);
+  }
+  
+  /**
+   * Returns the thread local owner
+   */
+  static Object getReferenceCountOwner() {
+    return getInstance().getReferenceCountOwner();
+  }
+
+  /**
+   * Returns the thread local count of the
+   * number of times ref count has been updated
+   */
+  static AtomicInteger getReenterCount() {
+    return getInstance().getReenterCount();
-    if (!trackReferenceCounts() || !trackFreedReferenceCounts()) return null;
-    return freedStacktraces.get(address);
+    return getInstance().getFreeRefCountInfo(address);
-   * Used internally to report that a reference count has changed.
+   * Returns a list of any reference count tracking information for
+   * the given Chunk address without locking.
-  
-  static void refCountChanged(Long address, boolean decRefCount, int rc) {
-    final Object owner = refCountOwner.get();
-    if (owner == SKIP_REF_COUNT_TRACKING) {
-      return;
-    }
-    List<RefCountChangeInfo> list = stacktraces.get(address);
-    if (list == null) {
-      List<RefCountChangeInfo> newList = new ArrayList<RefCountChangeInfo>();
-      List<RefCountChangeInfo> old = stacktraces.putIfAbsent(address, newList);
-      if (old == null) {
-        list = newList;
-      } else {
-        list = old;
-      }
-    }
-    if (decRefCount) {
-      if (owner != null) {
-        synchronized (list) {
-          for (int i=0; i < list.size(); i++) {
-            RefCountChangeInfo info = list.get(i);
-            if (owner instanceof RegionEntry) {
-              // use identity comparison on region entries since sqlf does some wierd stuff in the equals method
-              if (owner == info.getOwner()) {
-                if (info.getUseCount() > 0) {
-                  info.decUseCount();
-                } else {
-                  list.remove(i);
-                }
-                return;
-              }
-            } else if (owner.equals(info.getOwner())) {
-              if (info.getUseCount() > 0) {
-                info.decUseCount();
-              } else {
-                list.remove(i);
-              }
-              return;
-            }
-          }
-        }
-      }
-    }
-    if (list == LOCKED) {
-      MemoryAllocatorImpl.debugLog("refCount " + (decRefCount ? "deced" : "inced") + " after orphan detected for @" + Long.toHexString(address), true);
-      return;
-    }
-    RefCountChangeInfo info = new RefCountChangeInfo(decRefCount, rc, owner);
-    synchronized (list) {
-      //      if (list.size() == 16) {
-      //        debugLog("dumping @" + Long.toHexString(address) + " history=" + list, false);
-      //        list.clear();
-      //      }
-      for (RefCountChangeInfo e: list) {
-        if (e.isSameCaller(info)) {
-          // No need to add it just increment useCount
-          e.incUseCount();
-          return;
-        }
-      }
-      list.add(info);
-    }
-  }
-
-  /**
-   * Called internally when free operations are tracked to record
-   * that a free has happened of the given address.
-   */
-  static void freeRefCountInfo(Long address) {
-    if (!trackReferenceCounts()) return;
-    List<RefCountChangeInfo> freedInfo = stacktraces.remove(address);
-    if (freedInfo == LOCKED) {
-      MemoryAllocatorImpl.debugLog("freed after orphan detected for @" + Long.toHexString(address), true);
-    } else if (trackFreedReferenceCounts()) {
-      if (freedInfo != null) {
-        freedStacktraces.put(address, freedInfo);
-      } else {
-        freedStacktraces.remove(address);
-      }
-    }
+  static List<RefCountChangeInfo> peekRefCountInfo(long address) {
+    return getInstance().peekRefCountInfo(address);

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Encapsulates native C/C++ calls via JNA. To obtain an instance of
- * implementation for a platform, use {@link NativeCalls#getInstance()}.
+ * Encapsulates native C/C++ calls via JNA. To obtain an instance of implementation for a platform,
+ * use {@link NativeCalls#getInstance()}.
-   * Static instance of NativeCalls implementation. This can be one of JNA
-   * implementations in <code>NativeCallsJNAImpl</code> or can fall back to a
-   * generic implementation in case JNA is not available for the platform.
+   * Static instance of NativeCalls implementation. This can be one of JNA implementations in
+   * <code>NativeCallsJNAImpl</code> or can fall back to a generic implementation in case JNA is not
+   * available for the platform.
-   * Note: this variable is deliberately not final so that other clients 
-   * can plug in their own native implementations of NativeCalls.
+   * Note: this variable is deliberately not final so that other clients can plug in their own
+   * native implementations of NativeCalls.
-      final Class<?> c = Class
-          .forName("org.apache.geode.internal.shared.NativeCallsJNAImpl");
-      inst = (NativeCalls)c.getMethod("getInstance").invoke(null);
+      final Class<?> c = Class.forName("org.apache.geode.internal.shared.NativeCallsJNAImpl");
+      inst = (NativeCalls) c.getMethod("getInstance").invoke(null);
-  public NativeCalls() {
-  }
+  public NativeCalls() {}
-   * Get an instance of implementation of {@link NativeCalls} for the current
-   * platform.
+   * Get an instance of implementation of {@link NativeCalls} for the current platform.
-      return (Map<String, String>)m.get(env);
+      return (Map<String, String>) m.get(env);
-      return (Map<String, String>)envField.get(null);
+      return (Map<String, String>) envField.get(null);
-   * Get the native kernel descriptor given the java Socket. This is a horribly
-   * implementation dependent code checking various cases to get to the
-   * underlying kernel socket descriptor but works for the JDK's we support or
-   * intend to support directly or indirectly (e.g. GCJ for ODBC clients).
+   * Get the native kernel descriptor given the java Socket. This is a horribly implementation
+   * dependent code checking various cases to get to the underlying kernel socket descriptor but
+   * works for the JDK's we support or intend to support directly or indirectly (e.g. GCJ for ODBC
+   * clients).
-   * @param sock
-   *          the java socket
-   * @param sockStream
-   *          the {@link InputStream} of the java socket, if available
+   * @param sock the java socket
+   * @param sockStream the {@link InputStream} of the java socket, if available
-   * @throws UnsupportedOperationException
-   *           if the kernel descriptor could not be extracted
+   * @throws UnsupportedOperationException if the kernel descriptor could not be extracted
-          sock = (Socket)self;
+          sock = (Socket) self;
-        fd = ((FileInputStream)sockStream).getFD();
+        fd = ((FileInputStream) sockStream).getFD();
-                fd = ((FileInputStream)sockStream).getFD();
+                fd = ((FileInputStream) sockStream).getFD();
-            }
-            else {
+            } else {
-          final SocketImpl sockImpl = (SocketImpl)m.invoke(sock);
+          final SocketImpl sockImpl = (SocketImpl) m.invoke(sock);
-                fd = (FileDescriptor)m.invoke(sockImpl);
+                fd = (FileDescriptor) m.invoke(sockImpl);
-            return ((Integer)obj).intValue();
+            return ((Integer) obj).intValue();
-  protected static Method getAnyMethod(Class<?> c, String name,
-      Class<?>... parameterTypes) throws NoSuchMethodException,
-      SecurityException {
+  protected static Method getAnyMethod(Class<?> c, String name, Class<?>... parameterTypes)
+      throws NoSuchMethodException, SecurityException {
-    return "setSocketOption(): socket option " + opt
-        + " not supported by current platform " + getOSType();
+    return "setSocketOption(): socket option " + opt + " not supported by current platform "
+        + getOSType();
-   * {@link System#getenv(String)} in that it returns the current value of the
-   * environment variable in the process rather than from a static unmodifiable
-   * map created on the first call.
+   * {@link System#getenv(String)} in that it returns the current value of the environment variable
+   * in the process rather than from a static unmodifiable map created on the first call.
-   * @param name
-   *          the name of the environment variable to be modified
+   * @param name the name of the environment variable to be modified
-   * Set the value of an environment variable. This modifies both the value in
-   * the process, and the cached static map maintained by JVM on the first call
-   * so further calls to {@link System#getenv(String)} will also return the
-   * modified value.
+   * Set the value of an environment variable. This modifies both the value in the process, and the
+   * cached static map maintained by JVM on the first call so further calls to
+   * {@link System#getenv(String)} will also return the modified value.
-   * @param name
-   *          the name of the environment variable to be modified
-   * @param value
-   *          the new value of the environment variable; a value of null clears
-   *          the existing value
+   * @param name the name of the environment variable to be modified
+   * @param value the new value of the environment variable; a value of null clears the existing
+   *        value
-   * @throws UnsupportedOperationException
-   *           if no native API to determine the process status could be invoked
+   * @throws UnsupportedOperationException if no native API to determine the process status could be
+   *         invoked
-  public abstract boolean isProcessActive(int processId)
-      throws UnsupportedOperationException;
+  public abstract boolean isProcessActive(int processId) throws UnsupportedOperationException;
-   * Kill the process with given process ID immediately (i.e. without giving it
-   * a chance to cleanup properly).
+   * Kill the process with given process ID immediately (i.e. without giving it a chance to cleanup
+   * properly).
-   * @param processId
-   *          the PID of the process to be kill
+   * @param processId the PID of the process to be kill
-   * @throws UnsupportedOperationException
-   *           if no native API to kill the process could be invoked
+   * @throws UnsupportedOperationException if no native API to kill the process could be invoked
-  public abstract boolean killProcess(int processId)
-      throws UnsupportedOperationException;
+  public abstract boolean killProcess(int processId) throws UnsupportedOperationException;
-   * @param callback
-   *          register callback to be invoked on catching a SIGHUP signal;
-   *          SIGHUP signal is ignored if the callback is null
+   * @param callback register callback to be invoked on catching a SIGHUP signal; SIGHUP signal is
+   *        ignored if the callback is null
-   * @throws UnsupportedOperationException
-   *           if the native calls could not be completed for some reason or are
-   *           not available
-   * @throws IllegalStateException
-   *           for a non-UNIX platform
+   * @throws UnsupportedOperationException if the native calls could not be completed for some
+   *         reason or are not available
+   * @throws IllegalStateException for a non-UNIX platform
-    throw new UnsupportedOperationException(
-        "daemonize() not available in base implementation");
+    throw new UnsupportedOperationException("daemonize() not available in base implementation");
-  public void preBlow(String path, long maxSize, boolean preAllocate)
-      throws IOException {
+  public void preBlow(String path, long maxSize, boolean preAllocate) throws IOException {
-  
+
-   * This will return whether the path passed in as arg is
-   * part of a local file system or a remote file system.
-   * This method is mainly used by the DiskCapacityMonitor thread
-   * and we don't want to monitor remote fs available space as
-   * due to network problems/firewall issues the call to getUsableSpace
-   * can hang. See bug #49155. On platforms other than Linux this will
-   * return false even if it on local file system for now.
+   * This will return whether the path passed in as arg is part of a local file system or a remote
+   * file system. This method is mainly used by the DiskCapacityMonitor thread and we don't want to
+   * monitor remote fs available space as due to network problems/firewall issues the call to
+   * getUsableSpace can hang. See bug #49155. On platforms other than Linux this will return false
+   * even if it on local file system for now.
+
-   * @throws UnsupportedOperationException
-   *           if the native API to set the option could not be found or invoked
+   * @throws UnsupportedOperationException if the native API to set the option could not be found or
+   *         invoked
-   * @return the unsupported {@link TCPSocketOptions} for the current platform
-   *         and the underlying exception
+   * @return the unsupported {@link TCPSocketOptions} for the current platform and the underlying
+   *         exception
-  public abstract Map<TCPSocketOptions, Throwable> setSocketOptions(
-      Socket sock, InputStream sockStream,
-      Map<TCPSocketOptions, Object> optValueMap)
+  public abstract Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock,
+      InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
+
-   * A generic implementation of {@link #setSocketOptions} for POSIX like
-   * systems that requires the child classes to implement a few platform
-   * specific methods.
+   * A generic implementation of {@link #setSocketOptions} for POSIX like systems that requires the
+   * child classes to implement a few platform specific methods.
-  protected final Map<TCPSocketOptions, Throwable> setGenericSocketOptions(
-      Socket sock, InputStream sockStream,
-      Map<TCPSocketOptions, Object> optValueMap)
+  protected final Map<TCPSocketOptions, Throwable> setGenericSocketOptions(Socket sock,
+      InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
-    final Set<Map.Entry<TCPSocketOptions, Object>> optValueEntries =
-        optValueMap.entrySet();
+    final Set<Map.Entry<TCPSocketOptions, Object>> optValueEntries = optValueMap.entrySet();
-            + (value != null ? value.getClass().getName() : "NULL") + " for "
-            + opt);
+            + (value != null ? value.getClass().getName() : "NULL") + " for " + opt);
-    Map<TCPSocketOptions, Throwable> failures =
-        new HashMap<TCPSocketOptions, Throwable>(4);
+    Map<TCPSocketOptions, Throwable> failures = new HashMap<TCPSocketOptions, Throwable>(4);
-        failures.put(opt, new UnsupportedOperationException(
-            getUnsupportedSocketOptionMessage(opt)));
+        failures.put(opt,
+            new UnsupportedOperationException(getUnsupportedSocketOptionMessage(opt)));
-        if (setPlatformSocketOption(sockfd, OPT_IPPROTO_TCP, optName, opt,
-            (Integer)value, optSize) != 0) {
-          failures.put(opt, new SocketException(getOSType()
-              + ": error setting option " + opt + " to " + value));
+        if (setPlatformSocketOption(sockfd, OPT_IPPROTO_TCP, optName, opt, (Integer) value,
+            optSize) != 0) {
+          failures.put(opt,
+              new SocketException(getOSType() + ": error setting option " + opt + " to " + value));
-          failures.put(opt, new UnsupportedOperationException(
-              getUnsupportedSocketOptionMessage(opt), ne));
-        }
-        else {
-          final SocketException se = new SocketException(getOSType()
-              + ": failed to set " + opt + " to " + value);
+          failures.put(opt,
+              new UnsupportedOperationException(getUnsupportedSocketOptionMessage(opt), ne));
+        } else {
+          final SocketException se =
+              new SocketException(getOSType() + ": failed to set " + opt + " to " + value);
-  protected int getPlatformOption(TCPSocketOptions opt)
-      throws UnsupportedOperationException {
+  protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-  protected int setPlatformSocketOption(int sockfd, int level, int optName,
-      TCPSocketOptions opt, Integer optVal, int optSize)
-      throws UnsupportedOperationException, NativeErrorException {
+  protected int setPlatformSocketOption(int sockfd, int level, int optName, TCPSocketOptions opt,
+      Integer optVal, int optSize) throws UnsupportedOperationException, NativeErrorException {
-  protected boolean isNoProtocolOptionCode(int errno)
-      throws UnsupportedOperationException {
+  protected boolean isNoProtocolOptionCode(int errno) throws UnsupportedOperationException {
-   * Callback invoked when an OS-level SIGHUP signal is caught after handler has
-   * been installed by {@link NativeCalls#daemonize}. This is provided to allow
-   * for re-reading configuration files or any other appropriate actions on
-   * receiving HUP signal as is the convention in other servers.
+   * Callback invoked when an OS-level SIGHUP signal is caught after handler has been installed by
+   * {@link NativeCalls#daemonize}. This is provided to allow for re-reading configuration files or
+   * any other appropriate actions on receiving HUP signal as is the convention in other servers.
-   * whether o/s supports high resolution clock or equivalent 
-   * perf counter.
+   * whether o/s supports high resolution clock or equivalent perf counter.
-  
+
-   * This is fall back for jni based library implementation of NanoTimer which
-   * is more efficient than current impl through jna.
+   * This is fall back for jni based library implementation of NanoTimer which is more efficient
+   * than current impl through jna.
-   * Linux impls create temporary timespec object and marshals that for invoking
-   * native api. Shouldn't be used if to be called too many times, instead jni
-   * implementation is more desirable.
+   * Linux impls create temporary timespec object and marshals that for invoking native api.
+   * Shouldn't be used if to be called too many times, instead jni implementation is more desirable.
-  
+
-  
+
-   * A generic fallback implementation of {@link NativeCalls} when no JNA based
-   * implementation could be initialized (e.g. if JNA itself does not provide an
-   * implementation for the platform, or JNA is not found).
+   * A generic fallback implementation of {@link NativeCalls} when no JNA based implementation could
+   * be initialized (e.g. if JNA itself does not provide an implementation for the platform, or JNA
+   * is not found).
-        }
-        else {
+        } else {
-      final String name = java.lang.management.ManagementFactory
-          .getRuntimeMXBean().getName();
+      final String name = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
-    public boolean isProcessActive(int processId)
-        throws UnsupportedOperationException {
+    public boolean isProcessActive(int processId) throws UnsupportedOperationException {
-    public boolean killProcess(int processId)
-        throws UnsupportedOperationException {
+    public boolean killProcess(int processId) throws UnsupportedOperationException {
-    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock,
-        InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
-        throws UnsupportedOperationException {
+    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock, InputStream sockStream,
+        Map<TCPSocketOptions, Object> optValueMap) throws UnsupportedOperationException {

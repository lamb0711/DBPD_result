Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.internal.net.SocketCreator;
- * Handles registration and event notification duties for
- * <code>ClientMembershipListener</code>s. The public counterpart for this
- * class is {@link org.apache.geode.management.membership.ClientMembership}.
+ * Handles registration and event notification duties for <code>ClientMembershipListener</code>s.
+ * The public counterpart for this class is
+ * {@link org.apache.geode.management.membership.ClientMembership}.
-public final class InternalClientMembership  {
+public final class InternalClientMembership {
-  
-  /** 
+
+  /**
-   * This list is never modified in place, and a new list is installed
-   * only under the control of (@link #membershipLock}.
+   * This list is never modified in place, and a new list is installed only under the control of
+   * (@link #membershipLock}.
-  private static volatile List<ClientMembershipListener> clientMembershipListeners = Collections.emptyList();
-  
+  private static volatile List<ClientMembershipListener> clientMembershipListeners =
+      Collections.emptyList();
+
-   * Must be locked whenever references to the volatile field 
-   * {@link #clientMembershipListeners} is changed.
+   * Must be locked whenever references to the volatile field {@link #clientMembershipListeners} is
+   * changed.
-  /** 
-   * QueuedExecutor for firing ClientMembershipEvents 
+  /**
+   * QueuedExecutor for firing ClientMembershipEvents
-      LoggingThreadGroup.createThreadGroup(
-          "ClientMembership Event Invoker Group", logger);
+      LoggingThreadGroup.createThreadGroup("ClientMembership Event Invoker Group", logger);
-  
+
-   * This work used to be in a class initializer.  Unfortunately, this allowed
-   * the class to escape before it was fully initialized, so now we just
-   * make sure this work is done before any public static method on it
-   * is invoked.
+   * This work used to be in a class initializer. Unfortunately, this allowed the class to escape
+   * before it was fully initialized, so now we just make sure this work is done before any public
+   * static method on it is invoked.
-    
-    synchronized(systems) {
+
+    synchronized (systems) {
-      List existingSystems = InternalDistributedSystem.addConnectListener(
-        new InternalDistributedSystem.ConnectListener() {
-          public void onConnect(InternalDistributedSystem sys) {
-            addInternalDistributedSystem(sys);
-          }
-        });
-      
+      List existingSystems = InternalDistributedSystem
+          .addConnectListener(new InternalDistributedSystem.ConnectListener() {
+            public void onConnect(InternalDistributedSystem sys) {
+              addInternalDistributedSystem(sys);
+            }
+          });
+
-      
+
-        }
-        catch (DistributedSystemDisconnectedException e) {
+        } catch (DistributedSystemDisconnectedException e) {
-      
+
-  
+
-   * Registers a {@link ClientMembershipListener} for notification of connection
-   * changes for CacheServer and clients.
+   * Registers a {@link ClientMembershipListener} for notification of connection changes for
+   * CacheServer and clients.
-   * @param listener
-   *          a ClientMembershipListener to be registered
+   * @param listener a ClientMembershipListener to be registered
-        List<ClientMembershipListener> newListeners = new ArrayList<ClientMembershipListener>(oldListeners);
+        List<ClientMembershipListener> newListeners =
+            new ArrayList<ClientMembershipListener>(oldListeners);
-  
+
-   * Removes registration of a previously registered
-   * {@link ClientMembershipListener}.
+   * Removes registration of a previously registered {@link ClientMembershipListener}.
-   * @param listener
-   *          a ClientMembershipListener to be unregistered
+   * @param listener a ClientMembershipListener to be unregistered
-        List<ClientMembershipListener> newListeners = new ArrayList<ClientMembershipListener>(oldListeners);
+        List<ClientMembershipListener> newListeners =
+            new ArrayList<ClientMembershipListener>(oldListeners);
-   * Returns an array of all the currently registered
-   * <code>ClientMembershipListener</code>s. Modifications to the returned array
-   * will not effect the registration of these listeners.
+   * Returns an array of all the currently registered <code>ClientMembershipListener</code>s.
+   * Modifications to the returned array will not effect the registration of these listeners.
-   * @return the registered <code>ClientMembershipListener</code>s; an empty
-   *         array if no listeners
+   * @return the registered <code>ClientMembershipListener</code>s; an empty array if no listeners
-    ClientMembershipListener[] listeners = (ClientMembershipListener[]) l
-        .toArray(new ClientMembershipListener[l.size()]);
+    ClientMembershipListener[] listeners =
+        (ClientMembershipListener[]) l.toArray(new ClientMembershipListener[l.size()]);
-   * Removes registration of all currently registered
-   * <code>ClientMembershipListener<code>s. and <code>ClientMembershipListener<code>s.
+   * Removes registration of all currently registered <code>ClientMembershipListener<code>s. and
+   * <code>ClientMembershipListener<code>s.
-  
-  
-  
+
+
+
-   * Returns a map of client memberIds to count of connections to that client.
-   * The map entry key is a String representation of the client memberId, and
-   * the map entry value is an Integer count of connections to that client.
-   * Since a single client can have multiple ConnectionProxy objects, this 
-   * map will contain all the Connection objects across the ConnectionProxies
-   * @param onlyClientsNotifiedByThisServer true will return only those clients
-   * that are actively being updated by this server
+   * Returns a map of client memberIds to count of connections to that client. The map entry key is
+   * a String representation of the client memberId, and the map entry value is an Integer count of
+   * connections to that client. Since a single client can have multiple ConnectionProxy objects,
+   * this map will contain all the Connection objects across the ConnectionProxies
+   * 
+   * @param onlyClientsNotifiedByThisServer true will return only those clients that are actively
+   *        being updated by this server
-    if(onlyClientsNotifiedByThisServer) {
-      // Note it is not necessary to synchronize on the list of Client servers here, 
+    if (onlyClientsNotifiedByThisServer) {
+      // Note it is not necessary to synchronize on the list of Client servers here,
-      for (Iterator bsii = CacheFactory.getAnyInstance().getCacheServers().iterator(); bsii.hasNext(); ) {
+      for (Iterator bsii = CacheFactory.getAnyInstance().getCacheServers().iterator(); bsii
+          .hasNext();) {
-          }
-          else {
+          } else {
-   /*if (onlyClientsNotifiedByThisServer) {
-      Map notifyMap = new HashMap();
-      
-      for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {
-        String memberId = (String) iter.next();
-        if (notifierClients.contains(memberId)) {
-          // found memberId that is notified by this server
-          notifyMap.put(memberId, map.get(memberId));
-        }
-      }
-      map = notifyMap;
-    }*/
+    /*
+     * if (onlyClientsNotifiedByThisServer) { Map notifyMap = new HashMap();
+     * 
+     * for (Iterator iter = map.keySet().iterator(); iter.hasNext();) { String memberId = (String)
+     * iter.next(); if (notifierClients.contains(memberId)) { // found memberId that is notified by
+     * this server notifyMap.put(memberId, map.get(memberId)); } } map = notifyMap; }
+     */
-  
+
-   * This method returns the CacheClientStatus for all the clients that are
-   * connected to this server. This method returns all clients irrespective of
-   * whether subscription is enabled or not. 
+   * This method returns the CacheClientStatus for all the clients that are connected to this
+   * server. This method returns all clients irrespective of whether subscription is enabled or not.
-  }  
+  }
+   * 
-    for (Iterator bsii = CacheFactory.getAnyInstance().getCacheServers().iterator(); bsii.hasNext(); ) {
+    for (Iterator bsii = CacheFactory.getAnyInstance().getCacheServers().iterator(); bsii
+        .hasNext();) {
-    if (ClientHealthMonitor.getInstance()!=null)
-        ClientHealthMonitor.getInstance().fillInClientInfo(allClients);
+    if (ClientHealthMonitor.getInstance() != null)
+      ClientHealthMonitor.getInstance().fillInClientInfo(allClients);
-    GemFireCacheImpl c =  (GemFireCacheImpl)CacheFactory.getAnyInstance();
-    if (c==null) // Add a NULL Check
+    GemFireCacheImpl c = (GemFireCacheImpl) CacheFactory.getAnyInstance();
+    if (c == null) // Add a NULL Check
-    for (Iterator bsii = c.getCacheServers().iterator(); bsii.hasNext(); ) {
+    for (Iterator bsii = c.getCacheServers().iterator(); bsii.hasNext();) {
-   * Returns a map of servers to count of pools connected to that server.
-   * The map entry key is a String representation of the server, 
+   * Returns a map of servers to count of pools connected to that server. The map entry key is a
+   * String representation of the server,
+   * 
-    Map/*<String,Pool>*/ poolMap = PoolManager.getAll();
+    Map/* <String,Pool> */ poolMap = PoolManager.getAll();
-    while(pools.hasNext()) {
-      PoolImpl pi = (PoolImpl)pools.next();
-      Map/*<ServerLocation,Endpoint>*/ eps = pi.getEndpointMap();
+    while (pools.hasNext()) {
+      PoolImpl pi = (PoolImpl) pools.next();
+      Map/* <ServerLocation,Endpoint> */ eps = pi.getEndpointMap();
-      while(it.hasNext()) {
-        Map.Entry entry = (Map.Entry)it.next();
-        ServerLocation loc = (ServerLocation)entry.getKey();
-        org.apache.geode.cache.client.internal.Endpoint ep = (org.apache.geode.cache.client.internal.Endpoint)entry.getValue();
-        String server = loc.getHostName()+"["+loc.getPort()+"]";
-        Integer count = (Integer)map.get(server);
-        if(count==null) {
-          map.put(server,Integer.valueOf(1));  
+      while (it.hasNext()) {
+        Map.Entry entry = (Map.Entry) it.next();
+        ServerLocation loc = (ServerLocation) entry.getKey();
+        org.apache.geode.cache.client.internal.Endpoint ep =
+            (org.apache.geode.cache.client.internal.Endpoint) entry.getValue();
+        String server = loc.getHostName() + "[" + loc.getPort() + "]";
+        Integer count = (Integer) map.get(server);
+        if (count == null) {
+          map.put(server, Integer.valueOf(1));
-          map.put(server,Integer.valueOf(count.intValue()+1));
+          map.put(server, Integer.valueOf(count.intValue() + 1));
-  
-  
+
+
-   * Notifies registered listeners that a Client member has joined. The new
-   * member may be a client connecting to this process or a
-   * server that this process has just connected to.
+   * Notifies registered listeners that a Client member has connected
+   * @param clientId the representing the client
+   */
+  public static void notifyClientJoined(final DistributedMember clientId) {
+    notifyListeners(clientId, true, EventType.JOINED);
+  }
+
+  /**
+   * Notifies registered listeners that a Client member has left
+   *
+   * @param clientId the representing the client
+   */
+  public static void notifyClientLeft(final DistributedMember clientId) {
+    notifyListeners(clientId, true, EventType.LEFT);
+  }
+
+  /**
+   * Notifies registered listeners that a Client member has crashed
+   *
+   * @param clientId the representing the client
+   */
+  public static void notifyClientCrashed(final DistributedMember clientId) {
+    notifyListeners(clientId, true, EventType.CRASHED);
+  }
+
+
+
+  /**
+   * Notifies registered listeners that a Client member has connected
+   *
+   * @param location the address of the server
+   */
+  public static void notifyServerJoined(final ServerLocation location) {
+    DistributedMember id = new InternalDistributedMember(location);
+    notifyListeners(id, false, EventType.JOINED);
+  }
+
+  /**
+   * Notifies registered listeners that a Client member has left
+   *
+   * @param location the address of the server
+   */
+  public static void notifyServerLeft(final ServerLocation location) {
+    DistributedMember id = new InternalDistributedMember(location);
+    notifyListeners(id, false, EventType.LEFT);
+  }
+
+  /**
+   * Notifies registered listeners that a Client member has crashed
+   *
+   * @param location the address of the server
+   */
+  public static void notifyServerCrashed(final ServerLocation location) {
+    DistributedMember id = new InternalDistributedMember(location);
+    notifyListeners(id, false, EventType.CRASHED);
+  }
+
+
+
+  /**
+   * Notifies registered listeners that a Client member has joined. The new member may be a client
+   * connecting to this process or a server that this process has just connected to.
+   * 
+   * @param typeOfEvent joined/left/crashed
-  public static void notifyJoined(final DistributedMember member, final boolean client) {
+  private static void notifyListeners(final DistributedMember member, final boolean client,
+      final EventType typeOfEvent) {
-    final ClientMembershipEvent event =
-        new InternalClientMembershipEvent(member, client);
+    final ClientMembershipEvent event = new InternalClientMembershipEvent(member, client);
-      doNotifyClientMembershipListener(member, client, event,EventType.CLIENT_JOINED);
-    }
-    else {
+      doNotifyClientMembershipListener(member, client, event, typeOfEvent);
+    } else {
-          queuedExecutor.execute(new Runnable() {
-              public void run() {
-                doNotifyClientMembershipListener(member, client, event,EventType.CLIENT_JOINED);
-              }
-            });
-      }
-      catch (RejectedExecutionException e) {
+        queuedExecutor.execute(() -> {
+          doNotifyClientMembershipListener(member, client, event, typeOfEvent);
+        });
+      } catch (RejectedExecutionException e) {
-        }
+      }
-
-  /**
-   * Notifies registered listeners that a member has left. The departed
-   * member may be a client previously connected to this process or a
-   * server that this process was connected to.
-   *
-   * @param member the <code>DistributedMember</code>
-   * @param client true if the member is a client; false if server
-   */
-  public static void notifyLeft(final DistributedMember member, final boolean client) {
-    startMonitoring();
-    ThreadPoolExecutor queuedExecutor = executor;
-    if (queuedExecutor == null) {
-      return;
-    }
-
-    
-    final ClientMembershipEvent event =
-        new InternalClientMembershipEvent(member, client);
-    if (forceSynchronous) {
-      doNotifyClientMembershipListener(member, client, event,EventType.CLIENT_LEFT);
-    }
-    else {
-      try {
-          queuedExecutor.execute(new Runnable() {
-              public void run() {
-                doNotifyClientMembershipListener(member, client, event,EventType.CLIENT_LEFT);
-              }
-            });
-      }
-      catch (RejectedExecutionException e) {
-        // executor must have been shutdown
-        }
-    }
-  }
-
-
-  /**
-   * Notifies registered listeners that a member has crashed. The
-   * departed member may be a client previously connected to this
-   * process or a server that this process was connected to.
-   *
-   * @param member the <code>DistributedMember</code>
-   * @param client true if the member is a client; false if server
-   */
-  public static void notifyCrashed(final DistributedMember member, final boolean client) {
-    ThreadPoolExecutor queuedExecutor = executor;
-    if (queuedExecutor == null) {
-      return;
-    }
-
-    final ClientMembershipEvent event =
-        new InternalClientMembershipEvent(member, client);
-    if (forceSynchronous) {
-      doNotifyClientMembershipListener(member, client, event,EventType.CLIENT_CRASHED);
-    }
-    else {
-
-      try {
-          queuedExecutor.execute(new Runnable() {
-            public void run() {
-              doNotifyClientMembershipListener(member, client, event,EventType.CLIENT_CRASHED);
-            }
-          });
-      }
-      catch (RejectedExecutionException e) {
-        // executor must have been shutdown
-        }
-    }
-  }
-
-    for (Iterator<ClientMembershipListener> iter = clientMembershipListeners.iterator(); iter.hasNext();) {
+    for (Iterator<ClientMembershipListener> iter = clientMembershipListeners.iterator(); iter
+        .hasNext();) {
-        if (eventType.equals(EventType.CLIENT_JOINED)) {
+        if (eventType.equals(EventType.JOINED)) {
-        } else if (eventType.equals(EventType.CLIENT_LEFT)) {
+        } else if (eventType.equals(EventType.LEFT)) {
-  
-//  /**
-//   * Returns true if there are any registered
-//   * <code>ClientMembershipListener</code>s.
-//   */
-//  private static boolean hasClientMembershipListeners() {
-//    synchronized (membershipLock) {
-//      return !membershipListeners.isEmpty();
-//    }
-//  }
+
+  // /**
+  // * Returns true if there are any registered
+  // * <code>ClientMembershipListener</code>s.
+  // */
+  // private static boolean hasClientMembershipListeners() {
+  // synchronized (membershipLock) {
+  // return !membershipListeners.isEmpty();
+  // }
+  // }
-    synchronized(systems) {
-      s.addDisconnectListener(
-        new InternalDistributedSystem.DisconnectListener() {
-          @Override
-          public String toString() {
-            return "Disconnect listener for InternalClientMembership";
-          }
-          
-          public void onDisconnect(InternalDistributedSystem ss) {
-            removeInternalDistributedSystem(ss);
-          }
-        });
+    synchronized (systems) {
+      s.addDisconnectListener(new InternalDistributedSystem.DisconnectListener() {
+        @Override
+        public String toString() {
+          return "Disconnect listener for InternalClientMembership";
+        }
+
+        public void onDisconnect(InternalDistributedSystem ss) {
+          removeInternalDistributedSystem(ss);
+        }
+      });
-    synchronized(systems) {
+    synchronized (systems) {
-/*
-Object[] queueElementsBefore = new Object[executorQueue.size()];
-queueElementsBefore = executorQueue.toArray(queueElementsBefore);
-System.out.println("Before shut down, the executor's queue contains the following " + queueElementsBefore.length + " elements");
-for (int i=0; i<queueElementsBefore.length; i++) {
-  System.out.println("\t" + queueElementsBefore[i]);
-}
-*/
+        /*
+         * Object[] queueElementsBefore = new Object[executorQueue.size()]; queueElementsBefore =
+         * executorQueue.toArray(queueElementsBefore);
+         * System.out.println("Before shut down, the executor's queue contains the following " +
+         * queueElementsBefore.length + " elements"); for (int i=0; i<queueElementsBefore.length;
+         * i++) { System.out.println("\t" + queueElementsBefore[i]); }
+         */
-/*
-Object[] queueElementsAfter = new Object[executorQueue.size()];
-queueElementsAfter = executorQueue.toArray(queueElementsAfter);
-System.out.println("After shut down, the executor's queue contains the following " + queueElementsAfter.length + " elements");
-for (int i=0; i<queueElementsAfter.length; i++) {
-  System.out.println("\t" + queueElementsAfter[i]);
-}
-*/
-        // deadcoded this clear to fix bug 35675 - clearing removed the shutdown token from the queue!
+        /*
+         * Object[] queueElementsAfter = new Object[executorQueue.size()]; queueElementsAfter =
+         * executorQueue.toArray(queueElementsAfter);
+         * System.out.println("After shut down, the executor's queue contains the following " +
+         * queueElementsAfter.length + " elements"); for (int i=0; i<queueElementsAfter.length; i++)
+         * { System.out.println("\t" + queueElementsAfter[i]); }
+         */
+        // deadcoded this clear to fix bug 35675 - clearing removed the shutdown token from the
+        // queue!
-          public Thread newThread(Runnable command) {
-            Thread thread =
-                new Thread(group, command, "ClientMembership Event Invoker");
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
+        public Thread newThread(Runnable command) {
+          Thread thread = new Thread(group, command, "ClientMembership Event Invoker");
+          thread.setDaemon(true);
+          return thread;
+        }
+      };
-      executor = new ThreadPoolExecutor(1, 1/*max unused*/,
-                                        15, TimeUnit.SECONDS, q, tf);
+      executor = new ThreadPoolExecutor(1, 1/* max unused */, 15, TimeUnit.SECONDS, q, tf);
-   * Internal implementation of ClientMembershipEvent.
+   * Internal implementation of ClientMembershipEvent. This class is used in both clients and
+   * servers to notify listeners about events concerning client/server communications. In servers
+   * listeners are notified about clients connecting/disconnecting. In clients listeners notified
+   * about new connections being formed to servers. The instance variable "client" is used to
+   * distinguish between the two.
-  protected static class InternalClientMembershipEvent
-  implements ClientMembershipEvent {
+  protected static class InternalClientMembershipEvent implements ClientMembershipEvent {
+
+    /**
+     * If true this means that a client has joined/left/crashed.
+     * <p>
+     * If false this means that a server has joined/left/crashed
+     */
-    /** Constructs new instance of event */
-    protected InternalClientMembershipEvent(DistributedMember member, boolean client) {
+    protected InternalClientMembershipEvent(DistributedMember member, boolean isClient) {
-      this.client = client;
+      this.client = isClient;
-  
+
+
-  
-  private static enum EventType{
-    CLIENT_JOINED,
-    CLIENT_LEFT,
-    CLIENT_CRASHED
+
+  private static enum EventType {
+    JOINED, LEFT, CRASHED

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Holds on to one or many instances of LogWriterAppender and provides
- * convenience methods for controlling their lifecycles.
+ * Holds on to one or many instances of LogWriterAppender and provides convenience methods for
+ * controlling their lifecycles.
-  
+
-    MAIN(false),
-    SECURITY(true);
+    MAIN(false), SECURITY(true);
+
+
-  private static Map<Identifier, LogWriterAppender> appenders = new HashMap<Identifier, LogWriterAppender>();
-  private static Map<Identifier, AtomicInteger> references = new HashMap<Identifier, AtomicInteger>();
-  
+  private static Map<Identifier, LogWriterAppender> appenders =
+      new HashMap<Identifier, LogWriterAppender>();
+  private static Map<Identifier, AtomicInteger> references =
+      new HashMap<Identifier, AtomicInteger>();
+
-  
+
-                                                                   final boolean appendToFile,
-                                                                   final boolean isLoner,
-                                                                   final LogConfig config,
-                                                                   final boolean logConfig) {
+      final boolean appendToFile, final boolean isLoner, final LogConfig config,
+      final boolean logConfig) {
-  public static LogWriterAppender getOrCreateAppender(final Identifier id,
-                                                      final boolean isLoner,
-                                                      final LogConfig config,
-                                                      final boolean logConfig) {
+  public static LogWriterAppender getOrCreateAppender(final Identifier id, final boolean isLoner,
+      final LogConfig config, final boolean logConfig) {
-   * Creates the log writer appender for a distributed system based on the system's
-   * parsed configuration. The initial banner and messages are also entered into
-   * the log by this method.
+   * Creates the log writer appender for a distributed system based on the system's parsed
+   * configuration. The initial banner and messages are also entered into the log by this method.
-   * @param isLoner
-   *                Whether the distributed system is a loner or not
-   * @param isSecurity
-   *                Whether a log for security related messages has to be
-   *                created
-   * @param config
-   *                The DistributionConfig for the target distributed system
+   * @param isLoner Whether the distributed system is a loner or not
+   * @param isSecurity Whether a log for security related messages has to be created
+   * @param config The DistributionConfig for the target distributed system
-   * @throws GemFireIOException
-   *                 if the log file can't be opened for writing
+   * @throws GemFireIOException if the log file can't be opened for writing
-                                                   final boolean isLoner,
-                                                   final boolean isSecurity,
-                                                   final LogConfig config,
-                                                   final boolean logConfig) {
-    
+      final boolean isLoner, final boolean isSecurity, final LogConfig config,
+      final boolean logConfig) {
+
-    
+
-    
+
-    
+
-      //out = System.out;
+      // out = System.out;
-    
+
-      final boolean useChildLogging = config.getLogFile() != null && !config.getLogFile().equals(new File("")) && config.getLogFileSizeLimit() != 0;
-      final boolean statArchivesRolling = isDistributionConfig && dsConfig.getStatisticArchiveFile() != null && !dsConfig.getStatisticArchiveFile().equals(new File("")) && dsConfig.getArchiveFileSizeLimit() != 0 && dsConfig.getStatisticSamplingEnabled();
-      
-      if (!appendToFile || useChildLogging || statArchivesRolling) { // check useChildLogging for bug 50659
-        final File oldMain = ManagerLogWriter.getLogNameForOldMainLog(logFile, isSecurity || useChildLogging || statArchivesRolling);
-        final boolean succeeded = LogFileUtils.renameAggressively(logFile,oldMain);
-        
+      final boolean useChildLogging = config.getLogFile() != null
+          && !config.getLogFile().equals(new File("")) && config.getLogFileSizeLimit() != 0;
+      final boolean statArchivesRolling =
+          isDistributionConfig && dsConfig.getStatisticArchiveFile() != null
+              && !dsConfig.getStatisticArchiveFile().equals(new File(""))
+              && dsConfig.getArchiveFileSizeLimit() != 0 && dsConfig.getStatisticSamplingEnabled();
+
+      if (!appendToFile || useChildLogging || statArchivesRolling) { // check useChildLogging for
+                                                                     // bug 50659
+        final File oldMain = ManagerLogWriter.getLogNameForOldMainLog(logFile,
+            isSecurity || useChildLogging || statArchivesRolling);
+        final boolean succeeded = LogFileUtils.renameAggressively(logFile, oldMain);
+
-          firstMsg = LocalizedStrings.InternalDistributedSystem_RENAMED_OLD_LOG_FILE_TO_0.toLocalizedString(oldMain);
+          firstMsg = LocalizedStrings.InternalDistributedSystem_RENAMED_OLD_LOG_FILE_TO_0
+              .toLocalizedString(oldMain);
-          firstMsg = LocalizedStrings.InternalDistributedSystem_COULD_NOT_RENAME_0_TO_1.toLocalizedString(new Object[] {logFile, oldMain});
+          firstMsg = LocalizedStrings.InternalDistributedSystem_COULD_NOT_RENAME_0_TO_1
+              .toLocalizedString(new Object[] {logFile, oldMain});
-    
+
-      String s = LocalizedStrings.InternalDistributedSystem_COULD_NOT_OPEN_LOG_FILE_0.toLocalizedString(logFile);
+      String s = LocalizedStrings.InternalDistributedSystem_COULD_NOT_OPEN_LOG_FILE_0
+          .toLocalizedString(logFile);
-//    if (mlw.infoEnabled()) { -- skip here and instead do this in LogWriterFactory when creating the LogWriterLogger
-//      if (!isLoner /* do this on a loner to fix bug 35602 */
-//          || !Boolean.getBoolean(InternalLocator.INHIBIT_DM_BANNER)) {
-//        mlw.info(Banner.getString(null));
-//      }
-//    }
-    
+    // if (mlw.infoEnabled()) { -- skip here and instead do this in LogWriterFactory when creating
+    // the LogWriterLogger
+    // if (!isLoner /* do this on a loner to fix bug 35602 */
+    // || !Boolean.getBoolean(InternalLocator.INHIBIT_DM_BANNER)) {
+    // mlw.info(Banner.getString(null));
+    // }
+    // }
+
-      appenderContext[0] = LogService.getAppenderContext(); // ROOT or gemfire.logging.appenders.LOGGER
+      appenderContext[0] = LogService.getAppenderContext(); // ROOT or
+                                                            // gemfire.logging.appenders.LOGGER
-    
+
-    final LogWriterAppender appender = LogWriterAppender.create(appenderContext, logWriterLoggerName, mlw, fos);
-    
-    // remove stdout appender from MAIN_LOGGER_NAME only if isUsingGemFireDefaultConfig -- see #51819
-    if (!isSecurity && LogService.MAIN_LOGGER_NAME.equals(logWriterLoggerName) && LogService.isUsingGemFireDefaultConfig()) {
+    final LogWriterAppender appender =
+        LogWriterAppender.create(appenderContext, logWriterLoggerName, mlw, fos);
+
+    // remove stdout appender from MAIN_LOGGER_NAME only if isUsingGemFireDefaultConfig -- see
+    // #51819
+    if (!isSecurity && LogService.MAIN_LOGGER_NAME.equals(logWriterLoggerName)
+        && LogService.isUsingGemFireDefaultConfig()) {
-    
+
-        logWriter.info(LocalizedStrings.InternalDistributedSystem_STARTUP_CONFIGURATIONN_0, config.toLoggerString());
+        logWriter.info(LocalizedStrings.InternalDistributedSystem_STARTUP_CONFIGURATIONN_0,
+            config.toLoggerString());
-          //throw new GemFireIOException("Unable to redirect output to " + config.getLogFile(), e);
+          // throw new GemFireIOException("Unable to redirect output to " + config.getLogFile(), e);
-  
+
-      throw new IllegalStateException("Count is non-positive integer for " + id + ": " + count.get());
+      throw new IllegalStateException(
+          "Count is non-positive integer for " + id + ": " + count.get());
-  
+

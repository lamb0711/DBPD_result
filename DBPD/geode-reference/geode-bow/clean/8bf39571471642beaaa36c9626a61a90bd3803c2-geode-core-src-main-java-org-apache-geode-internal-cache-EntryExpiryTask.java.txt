Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * This was added to accommodate a session replication requirement where an
-   * empty client has a need to access the expired entry so that additional
-   * processing can be performed on it.
+   * This was added to accommodate a session replication requirement where an empty client has a
+   * need to access the expired entry so that additional processing can be performed on it.
-   * This field is nether private nor final so that dunits can manipulate it as
-   * necessary.
+   * This field is nether private nor final so that dunits can manipulate it as necessary.
-  @Override 
+  @Override
-    
+
+
-   * Returns the tasks region entry if it "checks" out. The check is to
-   * see if the region entry still exists.
-   * @throws EntryNotFoundException if the task no longer has a region entry or
-   * if the region entry it has is removed.
+   * Returns the tasks region entry if it "checks" out. The check is to see if the region entry
+   * still exists.
+   * 
+   * @throws EntryNotFoundException if the task no longer has a region entry or if the region entry
+   *         it has is removed.
-  
+
-  protected long getLastAccessedTime() throws EntryNotFoundException
-  {
+  protected long getLastAccessedTime() throws EntryNotFoundException {
-    }
-    catch (InternalStatisticsDisabledException e) {
+    } catch (InternalStatisticsDisabledException e) {
-  protected long getLastModifiedTime() throws EntryNotFoundException
-  {
+  protected long getLastModifiedTime() throws EntryNotFoundException {
-    Region.Entry<?,?> e = r.getEntry(k);
+    Region.Entry<?, ?> e = r.getEntry(k);
-  protected boolean destroy(boolean isPending) throws CacheException
-  {
+  protected boolean destroy(boolean isPending) throws CacheException {
-    @Released EntryEventImpl event = EntryEventImpl.create(
-        lr, Operation.EXPIRE_DESTROY, key, null,
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(lr, Operation.EXPIRE_DESTROY, key, null,
-    event.setPendingSecondaryExpireDestroy(isPending);
-    if (lr.generateEventID()) {
-      event.setNewEventId(lr.getCache().getDistributedSystem());
-    }
-    lr.expireDestroy(event, true); // expectedOldValue
-    return true;
+      event.setPendingSecondaryExpireDestroy(isPending);
+      if (lr.generateEventID()) {
+        event.setNewEventId(lr.getCache().getDistributedSystem());
+      }
+      lr.expireDestroy(event, true); // expectedOldValue
+      return true;
-  
+
-  protected boolean invalidate() throws TimeoutException,
-      EntryNotFoundException
-  {
+  protected boolean invalidate() throws TimeoutException, EntryNotFoundException {
-    @Released EntryEventImpl event = EntryEventImpl.create(lr,
-        Operation.EXPIRE_INVALIDATE, key, null,
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(lr, Operation.EXPIRE_INVALIDATE, key, null,
-    if (lr.generateEventID()) {
-      event.setNewEventId(lr.getCache().getDistributedSystem());
-    }
-    lr.expireInvalidate(event);
+      if (lr.generateEventID()) {
+        event.setNewEventId(lr.getCache().getDistributedSystem());
+      }
+      lr.expireInvalidate(event);
-  protected boolean localDestroy() throws CacheException
-  {
+  protected boolean localDestroy() throws CacheException {
-    @Released EntryEventImpl event = EntryEventImpl.create(lr,
-        Operation.EXPIRE_LOCAL_DESTROY, key, null,
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(lr, Operation.EXPIRE_LOCAL_DESTROY, key, null,
-    if (lr.generateEventID()) {
-      event.setNewEventId(lr.getCache().getDistributedSystem());
-    }
-    lr.expireDestroy(event, false); // expectedOldValue
+      if (lr.generateEventID()) {
+        event.setNewEventId(lr.getCache().getDistributedSystem());
+      }
+      lr.expireDestroy(event, false); // expectedOldValue
-  protected boolean localInvalidate() throws EntryNotFoundException
-  {
+  protected boolean localInvalidate() throws EntryNotFoundException {
-    @Released EntryEventImpl event = EntryEventImpl.create(lr,
-        Operation.EXPIRE_LOCAL_INVALIDATE, key, null,
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(lr, Operation.EXPIRE_LOCAL_INVALIDATE, key, null,
-    if (lr.generateEventID()) {
-      event.setNewEventId(lr.getCache().getDistributedSystem());
-    }
-    lr.expireInvalidate(event);
+      if (lr.generateEventID()) {
+        event.setNewEventId(lr.getCache().getDistributedSystem());
+      }
+      lr.expireInvalidate(event);
-  final protected void reschedule() throws CacheException
-  {
+  final protected void reschedule() throws CacheException {
-  protected void addExpiryTask() throws EntryNotFoundException
-  {
+  protected void addExpiryTask() throws EntryNotFoundException {
-  public String toString()
-  {
+  public String toString() {
-  protected void performTimeout() throws CacheException
-  {
+  protected void performTimeout() throws CacheException {
-  
+
-    if(re == null) {
+    if (re == null) {
-    if((action.isInvalidate() || action.isLocalInvalidate()) && re.isInvalid()) {
+    if ((action.isInvalidate() || action.isLocalInvalidate()) && re.isInvalid()) {
-  
+
-    }
-    else
-    if (idle != 0 && idle < ttl) {
+    } else if (idle != 0 && idle < ttl) {
-    }
-    else {
+    } else {
-  protected void basicPerformTimeout(boolean isPending) throws CacheException
-  {
+  protected void basicPerformTimeout(boolean isPending) throws CacheException {
-    }
-    else
-    if (idle != 0 && idle < ttl) {
+    } else if (idle != 0 && idle < ttl) {
-    }
-    else {
+    } else {
-    if (getLocalRegion().getScope().isGlobal()
-        && (action.isDestroy() || action.isInvalidate())) {
+    if (getLocalRegion().getScope().isGlobal() && (action.isDestroy() || action.isInvalidate())) {
-            logger.trace("{}.performTimeout().getExpirationTime() is {}; {}.expire({}). ttlExpiration: {}, idleExpiration: {}, ttlAttrs: {}, idleAttrs: {} action is: {}",
+            logger.trace(
+                "{}.performTimeout().getExpirationTime() is {}; {}.expire({}). ttlExpiration: {}, idleExpiration: {}, ttlAttrs: {}, idleAttrs: {} action is: {}",
-      }
-      finally {
+      } finally {
-    }
-    else {
+    } else {

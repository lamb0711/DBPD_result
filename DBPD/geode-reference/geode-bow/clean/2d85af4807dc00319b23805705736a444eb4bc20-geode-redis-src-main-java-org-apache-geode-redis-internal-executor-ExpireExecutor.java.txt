GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+import static java.util.concurrent.TimeUnit.SECONDS;
-import org.apache.geode.redis.internal.RegionProvider;
-    int NOT_SET = 0;
-    int SET = 1;
-    RegionProvider regionProvider = context.getRegionProvider();
-    if (delay <= 0) {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_SET));
-      return;
-    }
-
-    // If time unit given is not in millis convert to millis
-      delay = delay * millisInSecond;
+      delay = SECONDS.toMillis(delay);
-    boolean expirationSucessfullySet;
+    long timestamp = System.currentTimeMillis() + delay;
-    if (regionProvider.hasExpiration(key)) {
-      expirationSucessfullySet = regionProvider.modifyExpiration(key, delay);
-    } else {
-      expirationSucessfullySet = regionProvider.setExpiration(key, delay);
-    }
-
-    if (expirationSucessfullySet) {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), SET));
-    } else {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_SET));
-    }
+    RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(
+        context.getRegionProvider().getDataRegion());
+    int result = redisKeyCommands.pexpireat(key, timestamp);
+    command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), result));

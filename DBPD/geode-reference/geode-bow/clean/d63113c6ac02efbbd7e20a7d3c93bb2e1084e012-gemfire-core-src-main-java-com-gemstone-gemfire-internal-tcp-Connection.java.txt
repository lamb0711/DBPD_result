Merge branch 'feature/GEODE-77' into develop

Conflicts:
	gemfire-core/src/test/java/com/gemstone/gemfire/cache/management/MemoryThresholdsOffHeapDUnitTest.java

+import com.gemstone.gemfire.i18n.StringId;
-import com.gemstone.org.jgroups.util.StringId;
-  private Connection(ConnectionTable t, Socket s)
+  protected Connection(ConnectionTable t, Socket s)
-  private void handshakeNio() throws IOException {
-    // We jump through some extra hoops to use a MsgOutputStream
-    // This keeps us from allocating an extra DirectByteBuffer.
+  /**
+   * waits until we've joined the distributed system
+   * before returning
+   */
+  private void waitForAddressCompletion() {
-      while (myAddr.getIpAddress() == null) {
+      while ((owner.getConduit().getCancelCriterion().cancelInProgress() == null)
+          && myAddr.getInetAddress() == null && myAddr.getVmViewId() < 0) {
-          myAddr.wait(); // spurious wakeup ok
+          myAddr.wait(100); // spurious wakeup ok
+      Assert.assertTrue(myAddr.getDirectChannelPort() == this.owner.getConduit().getPort());
+  }
-    Assert.assertTrue(myAddr.getDirectChannelPort() == this.owner.getConduit().getPort());
-
+  private void handshakeNio() throws IOException {
+    waitForAddressCompletion();
+    
+    InternalDistributedMember myAddr = this.owner.getConduit().getLocalAddress();
+    waitForAddressCompletion();
+
+      initiateSuspicionIfSharedUnordered();
+  /** initiate suspect processing if a shared/ordered connection is lost and we're not shutting down */
+  private void initiateSuspicionIfSharedUnordered() {
+    if (this.isReceiver && this.handshakeRead && !this.preserveOrder && this.sharedResource) {
+      if (this.owner.getConduit().getCancelCriterion().cancelInProgress() == null) {
+        String reason = "member unexpectedly shut down shared, unordered connection";
+        this.owner.getDM().getMembershipManager().suspectMember(this.getRemoteAddress(),
+            reason);
+      }
+    }
+  }
+
-              Stub stub = new Stub(remote.getIpAddress()/*fix for bug 33615*/, remote.getDirectChannelPort(), remote.getVmViewId());
+              Stub stub = new Stub(remote.getInetAddress()/*fix for bug 33615*/, remote.getDirectChannelPort(), remote.getVmViewId());
+  /**
+   * For testing we want to configure the connection without having
+   * to read a handshake
+   */
+  protected void setSharedUnorderedForTest() {
+    this.preserveOrder = false;
+    this.sharedResource = true;
+    this.handshakeRead = true;
+  }
+  
-                Stub stub = new Stub(remote.getIpAddress()/*fix for bug 33615*/, remote.getDirectChannelPort(), remote.getVmViewId());
+                Stub stub = new Stub(remote.getInetAddress()/*fix for bug 33615*/, remote.getDirectChannelPort(), remote.getVmViewId());

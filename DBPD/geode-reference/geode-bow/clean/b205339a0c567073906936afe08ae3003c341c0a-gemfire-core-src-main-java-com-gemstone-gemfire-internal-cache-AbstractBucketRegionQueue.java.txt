Merge branch 'feature/GEODE-8' into develop

+import java.util.concurrent.atomic.AtomicReference;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSBucketRegionQueue;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSGatewayEventImpl;
+import com.gemstone.gemfire.internal.cache.versions.RegionVersionVector;
+import com.gemstone.gemfire.internal.cache.versions.VersionSource;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
-  private static final Logger logger = LogService.getLogger();
+  protected static final Logger logger = LogService.getLogger();
-      //merge42180: are we considering offheap in cedar. Comment freeOffHeapReference intentionally
-      //event.freeOffHeapReferences();
+      event.release();
-              /*if (event != null) {
-                event.release();  // merge44873: this is offheap related change from cheetah
-              }*/
+              if (event != null) {
+                event.release();
+              }
-              /*for (GatewaySenderEventImpl e: tempQueue) {
-                e.release(); // merge44873: this is offheap related change from cheetah
-              }*/
+              for (GatewaySenderEventImpl e: tempQueue) {
+                e.release();
+              }
-     
+       GatewaySenderEventImpl.release(event.getRawOldValue());
+	GatewaySenderEventImpl.release(event.getRawOldValue());
-    EntryEventImpl event = new EntryEventImpl(this, Operation.UPDATE, key,
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE, key,
-    //event.copyOffHeapToHeap();
+    event.copyOffHeapToHeap();
-
+    
+    int sizeOfHdfsEvent = -1;
+      if (this instanceof HDFSBucketRegionQueue) {
+        // need to fetch the size before event is inserted in queue.
+        // fix for #50016
+        if (this.getBucketAdvisor().isPrimary()) {
+          HDFSGatewayEventImpl hdfsEvent = (HDFSGatewayEventImpl)event.getValue();
+          sizeOfHdfsEvent = hdfsEvent.getSizeOnHDFSInBytes(!((HDFSBucketRegionQueue)this).isBucketSorted);
+        }
+      }
+      
-      //if (!didPut) {
-      //  GatewaySenderEventImpl gwVal = (GatewaySenderEventImpl) value;
-      //  gwVal.release();
-      //}
+      if (!didPut) {
+        GatewaySenderEventImpl.release(value);
+      }
-      addToEventQueue(key, didPut, event);
+      addToEventQueue(key, didPut, event, sizeOfHdfsEvent);
+  @Override
+  public void closeEntries() {
+    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
+      @Override
+      public void run() {
+        AbstractBucketRegionQueue.super.closeEntries();
+      }
+    });
+    clearQueues();
+    
+  }
-//  @Override
-//  public void closeEntries() {
-//    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
-//      @Override
-//      public void run() {
-//        AbstractBucketRegionQueue.super.closeEntries();
-//      }
-//    });
-//    clearQueues();
-//    
-//  }
-//  
-//  @Override
-//  public Set<VersionSource> clearEntries(final RegionVersionVector rvv) {
-//    final AtomicReference<Set<VersionSource>> result = new AtomicReference<Set<VersionSource>>();
-//    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
-//      @Override
-//      public void run() {
-//        result.set(AbstractBucketRegionQueue.super.clearEntries(rvv));
-//      }
-//    });
-//    clearQueues();
-//    return result.get();
-//  }
+  @Override
+  public Set<VersionSource> clearEntries(final RegionVersionVector rvv) {
+    final AtomicReference<Set<VersionSource>> result = new AtomicReference<Set<VersionSource>>();
+    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
+      @Override
+      public void run() {
+        result.set(AbstractBucketRegionQueue.super.clearEntries(rvv));
+      }
+    });
+    clearQueues();
+    return result.get();
+  }
-  protected abstract void addToEventQueue(Object key, boolean didPut, EntryEventImpl event);
+  protected abstract void addToEventQueue(Object key, boolean didPut, EntryEventImpl event, 
+      int sizeOfHdfsEvent);

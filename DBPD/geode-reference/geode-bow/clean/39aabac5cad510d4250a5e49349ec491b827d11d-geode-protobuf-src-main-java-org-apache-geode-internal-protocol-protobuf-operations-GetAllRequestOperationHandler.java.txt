Merge remote-tracking branch 'origin/develop' into feature/GEODE-3239

-package org.apache.geode.protocol.protobuf.operations;
+package org.apache.geode.internal.protocol.protobuf.operations;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.internal.protocol.operations.OperationHandler;
-import org.apache.geode.protocol.operations.OperationHandler;
-import org.apache.geode.protocol.protobuf.Failure;
-import org.apache.geode.protocol.protobuf.ProtocolErrorCode;
-import org.apache.geode.protocol.protobuf.Result;
-import org.apache.geode.protocol.protobuf.Success;
-import org.apache.geode.protocol.protobuf.utilities.ProtobufResponseUtilities;
-import org.apache.geode.protocol.protobuf.utilities.ProtobufUtilities;
-import org.apache.geode.serialization.SerializationService;
-import org.apache.geode.serialization.exception.UnsupportedEncodingTypeException;
-import org.apache.geode.serialization.registry.exception.CodecNotRegisteredForTypeException;
+import org.apache.geode.internal.protocol.protobuf.Failure;
+import org.apache.geode.internal.protocol.protobuf.ProtocolErrorCode;
+import org.apache.geode.internal.protocol.protobuf.Result;
+import org.apache.geode.internal.protocol.protobuf.Success;
+import org.apache.geode.internal.protocol.protobuf.utilities.ProtobufResponseUtilities;
+import org.apache.geode.internal.protocol.protobuf.utilities.ProtobufUtilities;
+import org.apache.geode.internal.serialization.SerializationService;
+import org.apache.geode.internal.serialization.exception.UnsupportedEncodingTypeException;
+import org.apache.geode.internal.serialization.registry.exception.CodecNotRegisteredForTypeException;
+
+import static org.apache.geode.internal.protocol.protobuf.ProtocolErrorCode.*;
+  private static final Logger logger = LogService.getLogger();
-      return Failure.of(ProtobufResponseUtilities
-          .makeErrorResponse(ProtocolErrorCode.REGION_NOT_FOUND.codeValue, "Region not found"));
+      logger.error("Received GetAll request for non-existing region {}", regionName);
+      return Failure
+          .of(ProtobufResponseUtilities.makeErrorResponse(REGION_NOT_FOUND, "Region not found"));
-      return BasicTypes.KeyedError.newBuilder().setKey(key)
-          .setError(BasicTypes.Error.newBuilder()
-              .setErrorCode(ProtocolErrorCode.VALUE_ENCODING_ERROR.codeValue)
-              .setMessage("Encoding not supported."))
-          .build();
+      logger.error("Encoding not supported: {}", ex);
+      return createKeyedError(key, "Encoding not supported.", VALUE_ENCODING_ERROR);
-      return BasicTypes.KeyedError.newBuilder().setKey(key)
-          .setError(BasicTypes.Error.newBuilder()
-              .setErrorCode(ProtocolErrorCode.OPERATION_TIMEOUT.codeValue)
-              .setMessage("Operation timed out: " + e.getMessage()))
-          .build();
+      logger.error("Operation timed out: {}", e);
+      return createKeyedError(key, "Operation timed out: " + e.getMessage(), OPERATION_TIMEOUT);
-      return BasicTypes.KeyedError.newBuilder().setKey(key)
-          .setError(BasicTypes.Error.newBuilder()
-              .setErrorCode(ProtocolErrorCode.DATA_UNREACHABLE.codeValue)
-              .setMessage("Data unreachable: " + e.getMessage()))
-          .build();
+      logger.error("Data unreachable: {}", e);
+      return createKeyedError(key, "Data unreachable: " + e.getMessage(), DATA_UNREACHABLE);
-      return BasicTypes.KeyedError.newBuilder().setKey(key)
-          .setError(BasicTypes.Error.newBuilder()
-              .setErrorCode(ProtocolErrorCode.CONSTRAINT_VIOLATION.codeValue)
-              .setMessage("Invalid input: " + e.getMessage()))
-          .build();
+      logger.error("Invalid input: {}", e);
+      return createKeyedError(key, "Invalid input: " + e.getMessage(), CONSTRAINT_VIOLATION);
+
+  private Object createKeyedError(BasicTypes.EncodedValue key, String errorMessage,
+      ProtocolErrorCode errorCode) {
+    return BasicTypes.KeyedError.newBuilder().setKey(key).setError(
+        BasicTypes.Error.newBuilder().setErrorCode(errorCode.codeValue).setMessage(errorMessage))
+        .build();
+  }

GEODE-7886 Update strings tests to cover sad as well as happy paths (#4821)


Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+    long value;
-    ByteArrayWrapper valueWrapper = r.get(key);
-    /*
-     * Value does not exist
-     */
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      ByteArrayWrapper valueWrapper = r.get(key);
-    if (valueWrapper == null) {
-      byte[] newValue = INIT_VALUE_BYTES;
-      r.put(key, new ByteArrayWrapper(newValue));
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
-      return;
-    }
+      /*
+       * Value does not exist
+       */
-    /*
-     * Value exists
-     */
+      if (valueWrapper == null) {
+        byte[] newValue = INIT_VALUE_BYTES;
+        r.put(key, new ByteArrayWrapper(newValue));
+        command
+            .setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
+        return;
+      }
-    String stringValue = valueWrapper.toString();
-    long value;
-    try {
-      value = Long.parseLong(stringValue);
-    } catch (NumberFormatException e) {
+      /*
+       * Value exists
+       */
+
+      String stringValue = valueWrapper.toString();
+      try {
+        value = Long.parseLong(stringValue);
+      } catch (NumberFormatException e) {
+        command.setResponse(
+            Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
+        return;
+      }
+
+      if (value == Long.MIN_VALUE) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
+        return;
+      }
+
+      value--;
+
+      stringValue = "" + value;
+
+      r.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
-          Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
-
-    if (value == Long.MIN_VALUE) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
-      return;
-    }
-
-    value--;
-
-    stringValue = "" + value;
-
-    r.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
-
-

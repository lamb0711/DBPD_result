Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-//  /** a flag to turn off automatic replay of transactions.  Maybe this should be a pool property? */
-//  private static final boolean ENABLE_REPLAY = Boolean.getBoolean("gemfire.enable-transaction-replay");
-//  
-//  /** time to pause between transaction replays, in millis */
-//  private static final int TRANSACTION_REPLAY_PAUSE = Integer.getInteger("gemfire.transaction-replay-pause", 500).intValue();
+
+  // /** a flag to turn off automatic replay of transactions. Maybe this should be a pool property?
+  // */
+  // private static final boolean ENABLE_REPLAY =
+  // Boolean.getBoolean("gemfire.enable-transaction-replay");
+  //
+  // /** time to pause between transaction replays, in millis */
+  // private static final int TRANSACTION_REPLAY_PAUSE =
+  // Integer.getInteger("gemfire.transaction-replay-pause", 500).intValue();
-  private static ThreadLocal<List<TransactionalOperation>> recordedTransactionalOperations = null; 
-  
+  private static ThreadLocal<List<TransactionalOperation>> recordedTransactionalOperations = null;
+
-  
+
-  private List<TransactionalOperation> recordedOperations
-    = Collections.synchronizedList(new LinkedList<TransactionalOperation>());
+  private List<TransactionalOperation> recordedOperations =
+      Collections.synchronizedList(new LinkedList<TransactionalOperation>());
-  private static final boolean DISABLE_CONFLICT_CHECK_ON_CLIENT = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableConflictChecksOnClient");
+  private static final boolean DISABLE_CONFLICT_CHECK_ON_CLIENT =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableConflictChecksOnClient");
-  
+
-   *   
+   * 
-  public static void setTransactionalOperationContainer(ThreadLocal<List<TransactionalOperation>> t) {
+  public static void setTransactionalOperationContainer(
+      ThreadLocal<List<TransactionalOperation>> t) {
-  
-  public ClientTXStateStub(TXStateProxy stateProxy, DistributedMember target,LocalRegion firstRegion) {
+
+  public ClientTXStateStub(TXStateProxy stateProxy, DistributedMember target,
+      LocalRegion firstRegion) {
-  
+
-   * @throws CommitConflictException
-   *           if the key is already locked by some other transaction
+   * @throws CommitConflictException if the key is already locked by some other transaction
-        TXRegionLockRequest rlr = lockReq.getRegionLockRequest(txOp
-            .getRegionName());
+        TXRegionLockRequest rlr = lockReq.getRegionLockRequest(txOp.getRegionName());
-          rlr = new TXRegionLockRequestImpl(cache.getRegionByPath(txOp
-              .getRegionName()));
+          rlr = new TXRegionLockRequestImpl(cache.getRegionByPath(txOp.getRegionName()));
-        if (txOp.getOperation() == ServerRegionOperation.PUT_ALL || txOp.getOperation() == ServerRegionOperation.REMOVE_ALL) {
+        if (txOp.getOperation() == ServerRegionOperation.PUT_ALL
+            || txOp.getOperation() == ServerRegionOperation.REMOVE_ALL) {
-  
+
-  
-  @Override 
+
+  @Override
-  
-  @Override 
+
+  @Override
-    if(!region.hasServerProxy()) {
-      throw new TransactionException("Region " + region.getName() + " is local to this client and cannot be used in a transaction.");
-    } else if (this.firstProxy != null && this.firstProxy.getPool() != region.getServerProxy().getPool()) {
-      throw new TransactionException("Region " + region.getName() + " is using a different server pool than other regions in this transaction.");
+    if (!region.hasServerProxy()) {
+      throw new TransactionException("Region " + region.getName()
+          + " is local to this client and cannot be used in a transaction.");
+    } else if (this.firstProxy != null
+        && this.firstProxy.getPool() != region.getServerProxy().getPool()) {
+      throw new TransactionException("Region " + region.getName()
+          + " is using a different server pool than other regions in this transaction.");
-      if (status == Status.STATUS_COMMITTED) { 
+      if (status == Status.STATUS_COMMITTED) {
-        throw new TransactionInDoubtException(LocalizedStrings.ClientTXStateStub_COMMIT_FAILED_ON_SERVER.toLocalizedString());
+          throw new TransactionInDoubtException(
+              LocalizedStrings.ClientTXStateStub_COMMIT_FAILED_ON_SERVER.toLocalizedString());
-      } else if (status == Status.STATUS_ROLLEDBACK){
+      } else if (status == Status.STATUS_ROLLEDBACK) {
-  
+
-     * Client member id is implied from the connection so we don't need this
-     * Forwarding will occur on the server-side stub
+     * Client member id is implied from the connection so we don't need this Forwarding will occur
+     * on the server-side stub
-      logger.debug("TX: suspending transaction: {} server delegate: {}", getTransactionId(), this.serverAffinityLocation);
+      logger.debug("TX: suspending transaction: {} server delegate: {}", getTransactionId(),
+          this.serverAffinityLocation);
-      logger.debug("TX: resuming transaction: {} server delegate: {}", getTransactionId(), this.serverAffinityLocation);
+      logger.debug("TX: resuming transaction: {} server delegate: {}", getTransactionId(),
+          this.serverAffinityLocation);
-  public void recordTXOperation(ServerRegionDataAccess region, ServerRegionOperation op, Object key, Object arguments[]) {
+  public void recordTXOperation(ServerRegionDataAccess region, ServerRegionOperation op, Object key,
+      Object arguments[]) {
-      this.recordedOperations.add(new TransactionalOperation(this, region.getRegionName(), op, key, arguments));
+      this.recordedOperations
+          .add(new TransactionalOperation(this, region.getRegionName(), op, key, arguments));
-  /** Add an internal callback which is run after the the local locks
-   * are obtained
+  /**
+   * Add an internal callback which is run after the the local locks are obtained

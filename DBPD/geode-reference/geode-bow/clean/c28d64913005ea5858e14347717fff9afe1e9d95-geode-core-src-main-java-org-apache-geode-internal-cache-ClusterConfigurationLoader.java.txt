Merge branch 'release/1.4.0'

+import java.io.File;
+import java.io.FileOutputStream;
-import java.net.InetAddress;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
-import java.util.stream.Stream;
+import java.util.stream.Collectors;
-import org.apache.commons.lang.ArrayUtils;
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import org.apache.geode.cache.execute.FunctionService;
+import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.internal.tcpserver.TcpClient;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
-import org.apache.geode.internal.admin.remote.DistributionLocatorId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.configuration.messages.ConfigurationRequest;
+import org.apache.geode.management.internal.configuration.functions.DownloadJarFunction;
+import org.apache.geode.management.internal.configuration.functions.GetClusterConfigurationFunction;
-   * 
-   * @param cache Cache of this member
+   *
-  public static void deployJarsReceivedFromClusterConfiguration(Cache cache,
-      ConfigurationResponse response) throws IOException, ClassNotFoundException {
+  public void deployJarsReceivedFromClusterConfiguration(ConfigurationResponse response)
+      throws IOException, ClassNotFoundException {
-    String[] jarFileNames = response.getJarNames();
-    byte[][] jarBytes = response.getJars();
+    List<String> jarFileNames =
+        response.getJarNames().values().stream().flatMap(Set::stream).collect(Collectors.toList());
-    if (jarFileNames != null && jarBytes != null) {
-      logger.info("Got response with jars: {}", Stream.of(jarFileNames).collect(joining(",")));
+    if (jarFileNames != null && !jarFileNames.isEmpty()) {
+      logger.info("Got response with jars: {}", jarFileNames.stream().collect(joining(",")));
-                .filter(jarName -> !ArrayUtils.contains(jarFileNames, jarName)).collect(toList());
+                .filter(jarName -> !jarFileNames.contains(jarName)).collect(toList());
-        List<DeployedJar> deployedJars = jarDeployer.deploy(jarFileNames, jarBytes);
+        Map<String, File> stagedJarFiles =
+            getJarsFromLocator(response.getMember(), response.getJarNames());
+
+        List<DeployedJar> deployedJars = jarDeployer.deploy(stagedJarFiles);
+  private Map<String, File> getJarsFromLocator(DistributedMember locator,
+      Map<String, Set<String>> jarNames) throws IOException {
+    Map<String, File> results = new HashMap<>();
+
+    for (String group : jarNames.keySet()) {
+      for (String jar : jarNames.get(group)) {
+        results.put(jar, downloadJar(locator, group, jar));
+      }
+    }
+
+    return results;
+  }
+
+  public File downloadJar(DistributedMember locator, String groupName, String jarName)
+      throws IOException {
+    ResultCollector<RemoteInputStream, List<RemoteInputStream>> rc =
+        (ResultCollector<RemoteInputStream, List<RemoteInputStream>>) CliUtil.executeFunction(
+            new DownloadJarFunction(), new Object[] {groupName, jarName},
+            Collections.singleton(locator));
+
+    List<RemoteInputStream> result = rc.getResult();
+    RemoteInputStream jarStream = result.get(0);
+
+    Set<PosixFilePermission> perms = new HashSet<>();
+    perms.add(PosixFilePermission.OWNER_READ);
+    perms.add(PosixFilePermission.OWNER_WRITE);
+    perms.add(PosixFilePermission.OWNER_EXECUTE);
+    Path tempDir =
+        Files.createTempDirectory("deploy-", PosixFilePermissions.asFileAttribute(perms));
+    Path tempJar = Paths.get(tempDir.toString(), jarName);
+    FileOutputStream fos = new FileOutputStream(tempJar.toString());
+
+    int packetId = 0;
+    while (true) {
+      byte[] data = jarStream.readPacket(packetId);
+      if (data == null) {
+        break;
+      }
+      fos.write(data);
+      packetId++;
+    }
+    fos.close();
+    jarStream.close(true);
+
+    return tempJar.toFile();
+  }
+
-   *
-   * @param cache Cache created for this member
-   * @param response {@link ConfigurationResponse} containing the requested {@link Configuration}
-   * @param config this member's config.
-  public static void applyClusterXmlConfiguration(Cache cache, ConfigurationResponse response,
-      DistributionConfig config) {
+  public void applyClusterXmlConfiguration(Cache cache, ConfigurationResponse response,
+      String groupList) {
-    List<String> groups = getGroups(config);
+    Set<String> groups = getGroups(groupList);
-   * 
+   *
-  public static void applyClusterPropertiesConfiguration(ConfigurationResponse response,
+  public void applyClusterPropertiesConfiguration(ConfigurationResponse response,
-    List<String> groups = getGroups(config);
+    Set<String> groups = getGroups(config.getGroups());
+    final Properties groupProps = new Properties();
+
-        runtimeProps.putAll(groupConfiguration.getGemfireProperties());
+        for (Map.Entry<Object, Object> e : groupConfiguration.getGemfireProperties().entrySet()) {
+          if (groupProps.containsKey(e.getKey())) {
+            logger.warn("Conflicting property {} from group {}", e.getKey(), group);
+          } else {
+            groupProps.put(e.getKey(), e.getValue());
+          }
+        }
+    runtimeProps.putAll(groupProps);
+
-   * 
-   * @param config this member's configuration.
+   *
-  public static ConfigurationResponse requestConfigurationFromLocators(DistributionConfig config,
-      List<String> locatorList)
+  public ConfigurationResponse requestConfigurationFromLocators(String groupList,
+      Set<InternalDistributedMember> locatorList)
-    List<String> groups = ClusterConfigurationLoader.getGroups(config);
-    ConfigurationRequest request = new ConfigurationRequest();
-    request.addGroups(ClusterConfigurationService.CLUSTER_CONFIG);
-    for (String group : groups) {
-      request.addGroups(group);
-    }
-
-    request.setNumAttempts(10);
+    Set<String> groups = getGroups(groupList);
+    GetClusterConfigurationFunction function = new GetClusterConfigurationFunction();
-    // Try talking to all the locators in the list
-    // to get the shared configuration.
-
-    TcpClient client = new TcpClient();
-
-    for (String locatorInfo : locatorList) {
-      DistributionLocatorId dlId = new DistributionLocatorId(locatorInfo);
-      String ipaddress = dlId.getBindAddress();
-      InetAddress locatorInetAddress = null;
-
-      if (StringUtils.isNotBlank(ipaddress)) {
-        locatorInetAddress = InetAddress.getByName(ipaddress);
+    for (InternalDistributedMember locator : locatorList) {
+      ResultCollector resultCollector =
+          FunctionService.onMember(locator).setArguments(groups).execute(function);
+      Object result = ((ArrayList) resultCollector.getResult()).get(0);
+      if (result instanceof ConfigurationResponse) {
+        response = (ConfigurationResponse) result;
+        response.setMember(locator);
+        break;
-        locatorInetAddress = dlId.getHost().getAddress();
-      }
-
-      int port = dlId.getPort();
-
-      try {
-        response = (ConfigurationResponse) client.requestToServer(locatorInetAddress, port, request,
-            10000);
-      } catch (UnknownHostException e) {
-        e.printStackTrace();
-      } catch (IOException e) {
-        // TODO Log
-        e.printStackTrace();
-      } catch (ClassNotFoundException e) {
-        e.printStackTrace();
+        logger.error("Received invalid result from {}: {}", locator.toString(), result);
+        if (result instanceof Throwable) {
+          // log the stack trace.
+          logger.error(result.toString(), result);
+        }
-    // if the response is null , that means Shared Configuration service is not installed on the
-    // locator
-    // and hence it returns null
-    if (response == null || response.failedToGetSharedConfig()) {
+    // if the response is null
+    if (response == null) {
-          LocalizedStrings.Launcher_Command_FAILED_TO_GET_SHARED_CONFIGURATION.toLocalizedString());
+          "Unable to retrieve cluster configuration from the locator.");
-  private static List<String> getGroups(DistributionConfig config) {
-    String groupString = config.getGroups();
-    List<String> groups = new ArrayList<String>();
-    if (StringUtils.isNotBlank(groupString)) {
-      groups.addAll((Arrays.asList(groupString.split(","))));
+  Set<String> getGroups(String groupString) {
+    if (StringUtils.isBlank(groupString)) {
+      return new HashSet<>();
-    return groups;
+
+    return (Arrays.stream(groupString.split(",")).collect(Collectors.toSet()));

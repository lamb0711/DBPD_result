GEODE-8168: Redis pipelined command responses can be corrupted (#5145)


-import static org.apache.geode.redis.internal.RedisCommandType.PUBLISH;
+import static org.apache.geode.redis.internal.RedisCommandType.SUBSCRIBE;
+import java.util.concurrent.CountDownLatch;
+import io.netty.buffer.UnpooledByteBufAllocator;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.EventLoopGroup;
+  private final EventLoopGroup subscriberEventLoopGroup;
-      RedisLockService lockService) {
+      RedisLockService lockService, EventLoopGroup subscriberEventLoopGroup) {
+    this.subscriberEventLoopGroup = subscriberEventLoopGroup;
-      logResponse(command);
-
-    // PUBLISH responses are always deferred
+    logResponse(response);
+
+    moveSubscribeToNewEventLoopGroup(ctx, command);
+
-    if (response == null && !command.isOfType(PUBLISH)) {
+    if (response == null) {
-  private void logResponse(Command command) {
-    if (logger.isDebugEnabled() && command.getResponse() != null) {
-      ByteBuf response = null;
-      try {
-        response = command.getResponse()
-            .copy(0, Math.min(command.getResponse().readableBytes(), 100));
-        logger.debug("Redis command returned: {}", getPrintableByteBuf(response));
-      } finally {
-        if (response != null) {
-          response.release();
-        }
-      }
+  /**
+   * SUBSCRIBE commands run in their own {@link EventLoopGroup}
+   */
+  private void moveSubscribeToNewEventLoopGroup(ChannelHandlerContext ctx, Command command)
+      throws InterruptedException {
+    if (command.isOfType(SUBSCRIBE)) {
+      CountDownLatch latch = new CountDownLatch(0);
+      ctx.channel().deregister().addListener((ChannelFutureListener) future -> {
+        subscriberEventLoopGroup.register(ctx.channel()).sync();
+        latch.countDown();
+      });
+      latch.await();
-  private String getPrintableByteBuf(ByteBuf buf) {
-    StringBuilder builder = new StringBuilder();
-    for (int i = 0; i < buf.readableBytes(); i++) {
-      byte aByte = buf.getByte(i);
-      if (aByte > 31 && aByte < 127) {
-        builder.append((char) aByte);
-      } else {
-        builder.append(String.format("\\x%02x", aByte));
-      }
+  private void logResponse(RedisResponse response) {
+    if (logger.isDebugEnabled() && response != null) {
+      ByteBuf buf = response.encode(new UnpooledByteBufAllocator(false));
+      logger.debug("Redis command returned: {}",
+          Command.getHexEncodedString(buf.array(), buf.readableBytes()));
-
-    return builder.toString();
-

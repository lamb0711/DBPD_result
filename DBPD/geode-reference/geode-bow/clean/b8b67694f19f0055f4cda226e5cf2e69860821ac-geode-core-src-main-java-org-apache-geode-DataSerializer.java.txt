Merge branch 'develop' into feature/GEODE-7049

-import java.net.UnknownHostException;
-import org.apache.geode.internal.DSCODE;
-import org.apache.geode.internal.Version;
+import org.apache.geode.internal.serialization.DSCODE;
+import org.apache.geode.internal.serialization.StaticSerialization;
+import org.apache.geode.internal.serialization.Version;
-    writeByteArray((address != null) ? address.getAddress() : null, out);
+    StaticSerialization.writeInetAddress(address, out);
+    InetAddress address = StaticSerialization.readInetAddress(in);
-    byte[] address = readByteArray(in);
-    if (address == null) {
-      return null;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read InetAddress {}", address);
-    try {
-      InetAddress addr = InetAddress.getByAddress(address);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read InetAddress {}", addr);
-      }
-      return addr;
-    } catch (UnknownHostException ex) {
-      throw new IOException("While reading an InetAddress", ex);
-    }
-
+    return address;
-    if (value == null) {
-      if (isTraceSerialzerVerbose) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing NULL_STRING");
-      }
-      out.writeByte(DSCODE.NULL_STRING.toByte());
-
-    } else {
-      // writeUTF is expensive - it creates a char[] to fetch
-      // the string's contents, iterates over the array to compute the
-      // encoded length, creates a byte[] to hold the encoded bytes,
-      // iterates over the char[] again to create the encode bytes,
-      // then writes the bytes. Since we usually deal with ISO-8859-1
-      // strings, we can accelerate this by accessing chars directly
-      // with charAt and fill a single-byte buffer. If we run into
-      // a multibyte char, we revert to using writeUTF()
-      int len = value.length();
-      int utfLen = len; // added for bug 40932
-      for (int i = 0; i < len; i++) {
-        char c = value.charAt(i);
-        if ((c <= 0x007F) && (c >= 0x0001)) {
-          // nothing needed
-        } else if (c > 0x07FF) {
-          utfLen += 2;
-        } else {
-          utfLen += 1;
-        }
-        // Note we no longer have an early out when we detect the first
-        // non-ascii char because we need to compute the utfLen for bug 40932.
-        // This is not a performance problem because most strings are ascii
-        // and they never did the early out.
-      }
-      boolean writeUTF = utfLen > len;
-      if (writeUTF) {
-        if (utfLen > 0xFFFF) {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing utf HUGE_STRING of len={}", len);
-          }
-          out.writeByte(DSCODE.HUGE_STRING.toByte());
-          out.writeInt(len);
-          out.writeChars(value);
-        } else {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing utf STRING of len={}", len);
-          }
-          out.writeByte(DSCODE.STRING.toByte());
-          out.writeUTF(value);
-        }
-      } else {
-        if (len > 0xFFFF) {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing HUGE_STRING_BYTES of len={}", len);
-          }
-          out.writeByte(DSCODE.HUGE_STRING_BYTES.toByte());
-          out.writeInt(len);
-          out.writeBytes(value);
-        } else {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing STRING_BYTES of len={}", len);
-          }
-          out.writeByte(DSCODE.STRING_BYTES.toByte());
-          out.writeShort(len);
-          out.writeBytes(value);
-        }
-      }
-    }
+    StaticSerialization.writeString(value, out);
-    return InternalDataSerializer.readString(in, in.readByte());
+    return StaticSerialization.readString(in);
-    int length = InternalDataSerializer.readArrayLength(in);
-    if (length == -1) {
-      return null;
-    } else {
-      byte[] array = new byte[length];
-      in.readFully(array, 0, length);
+    byte[] result = StaticSerialization.readByteArray(in);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read byte array of length {}", length);
-      }
-
-      return array;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read byte array of length {}",
+          result == null ? "null" : result.length);
+
+    return result;
-    int length;
-    if (array == null) {
-      length = -1;
-    } else {
-      length = array.length;
-    }
-    InternalDataSerializer.writeArrayLength(length, out);
+
+    StaticSerialization.writeStringArray(array, out);
+
-      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing String array of length {}", length);
-    }
-    if (length > 0) {
-      for (int i = 0; i < length; i++) {
-        writeString(array[i], out);
+      int length;
+      if (array == null) {
+        length = -1;
+      } else {
+        length = array.length;
+
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing String array of length {}", length);
-    int length = InternalDataSerializer.readArrayLength(in);
-    if (length == -1) {
-      return null;
-    } else {
-      String[] array = new String[length];
-      for (int i = 0; i < length; i++) {
-        array[i] = readString(in);
-      }
+    String array[] = StaticSerialization.readStringArray(in);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read String array of length {}", length);
-      }
-
-      return array;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read String array of length {}",
+          array == null ? "null" : array.length);
+
+    return array;
-    int length;
-    if (array == null) {
-      length = -1;
-    } else {
-      length = array.length;
-    }
-    InternalDataSerializer.writeArrayLength(length, out);
+    StaticSerialization.writeIntArray(array, out);
-      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing int array of length {}", length);
-    }
-    if (length > 0) {
-      for (int i = 0; i < length; i++) {
-        out.writeInt(array[i]);
-      }
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing int array of length {}",
+          array == null ? "null" : array.length);
-    int length = InternalDataSerializer.readArrayLength(in);
-    if (length == -1) {
-      return null;
-    } else {
-      int[] array = new int[length];
-      for (int i = 0; i < length; i++) {
-        array[i] = in.readInt();
-      }
+    int[] result = StaticSerialization.readIntArray(in);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read int array of length {}", length);
-      }
-
-      return array;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read int array of length {}",
+          result == null ? "null" : result.length);
+
+    return result;

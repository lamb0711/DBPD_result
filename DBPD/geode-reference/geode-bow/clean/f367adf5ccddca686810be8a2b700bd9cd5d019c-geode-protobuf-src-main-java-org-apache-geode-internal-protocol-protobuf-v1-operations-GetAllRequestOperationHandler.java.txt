Merge branch 'develop' of https://github.com/apache/geode into feature/GEODE-4528

-
-import static org.apache.geode.internal.protocol.protobuf.v1.ProtobufErrorCode.INVALID_REQUEST;
-import static org.apache.geode.internal.protocol.protobuf.v1.ProtobufErrorCode.SERVER_ERROR;
-
-import java.util.List;
-import java.util.Map;
-import java.util.stream.Collectors;
+import static org.apache.geode.internal.protocol.protobuf.v1.BasicTypes.ErrorCode.INVALID_REQUEST;
+import static org.apache.geode.internal.protocol.protobuf.v1.BasicTypes.ErrorCode.SERVER_ERROR;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.protocol.protobuf.v1.ProtobufErrorCode;
+import org.apache.geode.internal.protocol.protobuf.v1.serialization.exception.DecodingException;
-      MessageExecutionContext messageExecutionContext) throws InvalidExecutionContextException {
+      MessageExecutionContext messageExecutionContext)
+      throws InvalidExecutionContextException, DecodingException {
-      return Failure
-          .of(ProtobufResponseUtilities.makeErrorResponse(SERVER_ERROR, "Region not found"));
+      return Failure.of(ProtobufResponseUtilities
+          .makeErrorResponse(BasicTypes.ErrorCode.SERVER_ERROR, "Region not found"));
-    Map<Boolean, List<Object>> resultsCollection;
-    try {
-      ((InternalCache) messageExecutionContext.getCache()).setReadSerializedForCurrentThread(true);
-
-      resultsCollection = request.getKeyList().stream()
-          .map((key) -> processOneMessage(serializationService, region, key))
-          .collect(Collectors.partitioningBy(x -> x instanceof BasicTypes.Entry));
-    } finally {
-      ((InternalCache) messageExecutionContext.getCache()).setReadSerializedForCurrentThread(false);
-      messageExecutionContext.getStatistics().endOperation(startTime);
-    }
-
-    for (Object entry : resultsCollection.get(true)) {
-      responseBuilder.addEntries((BasicTypes.Entry) entry);
-    }
-
-    for (Object entry : resultsCollection.get(false)) {
-      responseBuilder.addFailures((BasicTypes.KeyedError) entry);
+    try {
+      messageExecutionContext.getCache().setReadSerializedForCurrentThread(true);
+      request.getKeyList().stream()
+          .forEach((key) -> processSingleKey(responseBuilder, serializationService, region, key));
+    } finally {
+      messageExecutionContext.getCache().setReadSerializedForCurrentThread(false);
+      messageExecutionContext.getStatistics().endOperation(startTime);
-  private Object processOneMessage(ProtobufSerializationService serializationService, Region region,
+  private void processSingleKey(RegionAPI.GetAllResponse.Builder responseBuilder,
+      ProtobufSerializationService serializationService, Region region,
+
-      return ProtobufUtilities.createEntry(serializationService, decodedKey, value);
+      BasicTypes.Entry entry =
+          ProtobufUtilities.createEntry(serializationService, decodedKey, value);
+      responseBuilder.addEntries(entry);
+
+    } catch (DecodingException ex) {
+      logger.info("Key encoding not supported: {}", ex);
+      responseBuilder
+          .addFailures(buildKeyedError(key, "Key encoding not supported.", INVALID_REQUEST));
-      logger.error("Encoding not supported: {}", ex);
-      return createKeyedError(key, "Encoding not supported.", INVALID_REQUEST);
+      logger.info("Value encoding not supported: {}", ex);
+      responseBuilder
+          .addFailures(buildKeyedError(key, "Value encoding not supported.", INVALID_REQUEST));
-      logger.error("Failure in protobuf getAll operation for key: " + key, ex);
-      return createKeyedError(key, ex.toString(), SERVER_ERROR);
+      logger.warn("Failure in protobuf getAll operation for key: " + key, ex);
+      responseBuilder.addFailures(buildKeyedError(key, ex.toString(), SERVER_ERROR));
-  private Object createKeyedError(BasicTypes.EncodedValue key, String errorMessage,
-      ProtobufErrorCode errorCode) {
-    return BasicTypes.KeyedError.newBuilder().setKey(key).setError(BasicTypes.Error.newBuilder()
-        .setErrorCode(ProtobufUtilities.getProtobufErrorCode(errorCode)).setMessage(errorMessage))
+  private BasicTypes.KeyedError buildKeyedError(BasicTypes.EncodedValue key, String errorMessage,
+      BasicTypes.ErrorCode errorCode) {
+    return BasicTypes.KeyedError.newBuilder().setKey(key)
+        .setError(BasicTypes.Error.newBuilder().setErrorCode(errorCode).setMessage(errorMessage))
+

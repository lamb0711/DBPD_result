Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileFilter;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PrintWriter;
-import java.io.Serializable;
-import java.io.StringWriter;
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Scanner;
-import java.util.Set;
-import java.util.Map.Entry;
-import java.util.zip.DataFormatException;
-import java.util.zip.Deflater;
-import java.util.zip.Inflater;
-
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PrintWriter;
+import java.io.Serializable;
+import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
- * This class contains utility methods used by classes used to build the Command
- * Line Interface (CLI).
+ * This class contains utility methods used by classes used to build the Command Line Interface
+ * (CLI).
-    jarProductName = checkLibraryByLoadingClass("org.springframework.shell.core.Parser", "Spring Shell");
-    jarProductName = checkLibraryByLoadingClass("org.springframework.shell.core.annotation.CliCommand", "Spring Shell");
+    jarProductName =
+        checkLibraryByLoadingClass("org.springframework.shell.core.Parser", "Spring Shell");
+    jarProductName = checkLibraryByLoadingClass(
+        "org.springframework.shell.core.annotation.CliCommand", "Spring Shell");
-    jarProductName = checkLibraryByLoadingClass("org.springframework.core.SpringVersion", "Spring Core");
+    jarProductName =
+        checkLibraryByLoadingClass("org.springframework.core.SpringVersion", "Spring Core");
-      //ignore & return null
+      // ignore & return null
-  public static byte[][] filesToBytes(String[] fileNames) throws FileNotFoundException, IOException {
+  public static byte[][] filesToBytes(String[] fileNames)
+      throws FileNotFoundException, IOException {
-        throw new FileNotFoundException("Could not find "+file.getCanonicalPath());
+        throw new FileNotFoundException("Could not find " + file.getCanonicalPath());
-      if (file.isDirectory()) { //TODO - Abhishek: (1) No recursive search yet. (2) Do we need to check/limit size of the files too?
+      if (file.isDirectory()) { // TODO - Abhishek: (1) No recursive search yet. (2) Do we need to
+                                // check/limit size of the files too?
-          //1. add name of the file as bytes at even index
+          // 1. add name of the file as bytes at even index
-          //2. add file contents as bytes at odd index
+          // 2. add file contents as bytes at odd index
-        throw new UnsupportedOperationException("Couldn't create required directory structure for "+parentDirPath);
+        throw new UnsupportedOperationException(
+            "Couldn't create required directory structure for " + parentDirPath);
-      if (i%2 == 0) {
+      if (i % 2 == 0) {
-  
-  public static boolean isValidFileName (String filePath, String extension) {
+
+  public static boolean isValidFileName(String filePath, String extension) {
-  
+
-    Set<Region<?,?>> rootRegions = cache.rootRegions();
+    Set<Region<?, ?>> rootRegions = cache.rootRegions();
-    Iterator<Region<?,?>> rootRegionIters = rootRegions.iterator();
+    Iterator<Region<?, ?>> rootRegionIters = rootRegions.iterator();
-      Region<?,?> rootRegion = rootRegionIters.next();
+      Region<?, ?> rootRegion = rootRegionIters.next();
-      Iterator<Region<?,?>> subRegionIters = subRegions.iterator();
+      Iterator<Region<?, ?>> subRegionIters = subRegions.iterator();
-        Region<?,?> subRegion = subRegionIters.next();
+        Region<?, ?> subRegion = subRegionIters.next();
-  
-        
-  public static Set<DistributedMember> findAllMatchingMembers(final String groups, final String members)
+
+
+  public static Set<DistributedMember> findMembersOrThrow(final String groups, final String members)
-    
-    String[] groupsArray = (groups == null ? null : groups.split(","));
-    String[] membersArray = (members == null ? null : members.split(","));
-    
-    return findAllMatchingMembers(groupsArray, membersArray);
+
+    String[] groupsArray = (groups == null ? new String[] {} : groups.split(","));
+    String[] membersArray = (members == null ? new String[] {} : members.split(","));
+
+    return findMembersOrThrow(groupsArray, membersArray);
-  
-  public static Set<DistributedMember> findAllMatchingMembers(final String[] groups, final String[] members) throws CommandResultException {
-    Set<DistributedMember> matchingMembers = new HashSet<DistributedMember>();
-    Cache cache = CacheFactory.getAnyInstance();
-    if ((members != null && members.length > 0) && (groups != null && groups.length > 0)) {
-      throw new CommandResultException(ResultBuilder.createUserErrorResult(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    }
+  public static Set<DistributedMember> findMembersOrThrow(final String[] groups,
+      final String[] members) throws CommandResultException {
-    if (members != null && members.length > 0) {
-      for (String memberNameOrId : members) {
-        DistributedMember member = getDistributedMemberByNameOrId(memberNameOrId);
-        if (member != null) {
-          matchingMembers.add(member);
-        } else {
-          throw new CommandResultException(ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberNameOrId)));
-        }
-      }
-    } else if (groups != null && groups.length > 0) {
-      Set<DistributedMember> allNormalMembers = getAllNormalMembers(cache);
-      for (String group : groups) {
-        Set<DistributedMember> groupMembers = new HashSet<DistributedMember>();
-        for (DistributedMember member : allNormalMembers) {
-          if (member.getGroups().contains(group)) {
-            groupMembers.add(member);
-          }
-        }
-
-        if (!groupMembers.isEmpty()) {
-          matchingMembers.addAll(groupMembers);
-
-        } else {
-          throw new CommandResultException(ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.NO_MEMBERS_IN_GROUP_ERROR_MESSAGE, group)));
-        }
-      }
-    } else {
-      matchingMembers.addAll(getAllNormalMembers(cache));
-      if (matchingMembers.isEmpty()) {
-        throw new CommandResultException(ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE));
-      }
+    Set<DistributedMember> matchingMembers = findMembers(groups, members);
+    if (matchingMembers.isEmpty()) {
+      throw new CommandResultException(
+          ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE));
-  public static DistributedMember getDistributedMemberByNameOrId (String memberNameOrId) {
+  public static Set<DistributedMember> findMembers(String[] groups, String[] members) {
+    if (groups == null) {
+      groups = new String[] {};
+    }
+
+    if (members == null) {
+      members = new String[] {};
+    }
+
+    Cache cache = CacheFactory.getAnyInstance();
+
+    if ((members.length > 0) && (groups.length > 0)) {
+      throw new IllegalArgumentException(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
+    }
+
+    Set<DistributedMember> allNormalMembers = getAllNormalMembers(cache);
+    if (members.length == 0 && groups.length == 0) {
+      return allNormalMembers;
+    }
+
+    Set<DistributedMember> matchingMembers = new HashSet<DistributedMember>();
+    // it will either go into this loop or the following loop, not both.
+    for (String memberNameOrId : members) {
+      for (DistributedMember member : allNormalMembers) {
+        if (memberNameOrId.equalsIgnoreCase(member.getId())
+            || memberNameOrId.equals(member.getName())) {
+          matchingMembers.add(member);
+        }
+      }
+    }
+
+    for (String group : groups) {
+      for (DistributedMember member : allNormalMembers) {
+        if (member.getGroups().contains(group)) {
+          matchingMembers.add(member);
+        }
+      }
+    }
+    return matchingMembers;
+  }
+
+  public static DistributedMember getDistributedMemberByNameOrId(String memberNameOrId) {
-      Set<DistributedMember>memberSet = CliUtil.getAllMembers(cache);
-      for (DistributedMember member: memberSet) {
-        if (memberNameOrId.equalsIgnoreCase(member.getId()) || memberNameOrId.equals(member.getName())) {
+      Set<DistributedMember> memberSet = CliUtil.getAllMembers(cache);
+      for (DistributedMember member : memberSet) {
+        if (memberNameOrId.equalsIgnoreCase(member.getId())
+            || memberNameOrId.equals(member.getName())) {
-      throw new RuntimeException(CliStrings.format(CliStrings.CREATE_REGION__MSG__COULDNOT_FIND_CLASS_0_SPECIFIED_FOR_1, new Object[] {classToLoadName, neededFor}), e);
-    }
-    catch (ClassCastException e) {
-      throw new RuntimeException(CliStrings.format(CliStrings.CREATE_REGION__MSG__CLASS_SPECIFIED_FOR_0_SPECIFIED_FOR_1_IS_NOT_OF_EXPECTED_TYPE, new Object[] {classToLoadName, neededFor}), e);
+      throw new RuntimeException(
+          CliStrings.format(CliStrings.CREATE_REGION__MSG__COULDNOT_FIND_CLASS_0_SPECIFIED_FOR_1,
+              new Object[] {classToLoadName, neededFor}),
+          e);
+    } catch (ClassCastException e) {
+      throw new RuntimeException(CliStrings.format(
+          CliStrings.CREATE_REGION__MSG__CLASS_SPECIFIED_FOR_0_SPECIFIED_FOR_1_IS_NOT_OF_EXPECTED_TYPE,
+          new Object[] {classToLoadName, neededFor}), e);
-      throw new RuntimeException(CliStrings.format(CliStrings.CREATE_REGION__MSG__COULDNOT_INSTANTIATE_CLASS_0_SPECIFIED_FOR_1, new Object[] {klass, neededFor}), e);
+      throw new RuntimeException(CliStrings.format(
+          CliStrings.CREATE_REGION__MSG__COULDNOT_INSTANTIATE_CLASS_0_SPECIFIED_FOR_1,
+          new Object[] {klass, neededFor}), e);
-      throw new RuntimeException(CliStrings.format(CliStrings.CREATE_REGION__MSG__COULDNOT_ACCESS_CLASS_0_SPECIFIED_FOR_1, new Object[] {klass, neededFor}), e);
+      throw new RuntimeException(
+          CliStrings.format(CliStrings.CREATE_REGION__MSG__COULDNOT_ACCESS_CLASS_0_SPECIFIED_FOR_1,
+              new Object[] {klass, neededFor}),
+          e);
-//      System.out.println(compressedDataLength);
-//      System.out.println("uc: b  "+buffer.length);
-//      System.out.println("uc: r  "+result.length);
-//      System.out.println("uc: nr "+newResult.length);
-//      System.out.println();
+      // System.out.println(compressedDataLength);
+      // System.out.println("uc: b "+buffer.length);
+      // System.out.println("uc: r "+result.length);
+      // System.out.println("uc: nr "+newResult.length);
+      // System.out.println();
-  public static DeflaterInflaterData uncompressBytes(byte[] output, int compressedDataLength) throws DataFormatException {
+  public static DeflaterInflaterData uncompressBytes(byte[] output, int compressedDataLength)
+      throws DataFormatException {
-//    System.out.println(new String(result));
+    // System.out.println(new String(result));
+
-      byte[][] filesToBytes = filesToBytes(new String[] {"/export/abhishek1/work/aspenmm/GFTryouts/test.json"});
+      byte[][] filesToBytes =
+          filesToBytes(new String[] {"/export/abhishek1/work/aspenmm/GFTryouts/test.json"});
-      DeflaterInflaterData uncompressBytes = uncompressBytes(compressBytes.data, compressBytes.dataLength);
+      DeflaterInflaterData uncompressBytes =
+          uncompressBytes(compressBytes.data, compressBytes.dataLength);
-    return new HashSet<DistributedMember>(((InternalDistributedSystem)cache.getDistributedSystem()).getDistributionManager().getNormalDistributionManagerIds());
+    return new HashSet<DistributedMember>(((InternalDistributedSystem) cache.getDistributedSystem())
+        .getDistributionManager().getNormalDistributionManagerIds());
-    return new HashSet<DistributedMember>(((InternalDistributedSystem)cache.getDistributedSystem()).getDistributionManager().getDistributionManagerIds());
+    return new HashSet<DistributedMember>(((InternalDistributedSystem) cache.getDistributedSystem())
+        .getDistributionManager().getDistributionManagerIds());
-    return new HashSet<DistributedMember>(internalDS.getDistributionManager().getDistributionManagerIds());
+    return new HashSet<DistributedMember>(
+        internalDS.getDistributionManager().getDistributionManagerIds());
-  public static Set<DistributedMember> getDistributedMembersByGroup(Cache cache,  String[] groups) {
+  public static Set<DistributedMember> getDistributedMembersByGroup(Cache cache, String[] groups) {
-    for(String group : groups){
-      groupMembers.addAll(((InternalDistributedSystem)cache.getDistributedSystem()).getDistributionManager().getGroupMembers(group));
+    for (String group : groups) {
+      groupMembers.addAll(((InternalDistributedSystem) cache.getDistributedSystem())
+          .getDistributionManager().getGroupMembers(group));
+   * 
-   * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the function.
+   * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the
+   *        function.
-  public static ResultCollector<?, ?> executeFunction(final Function function, Object args , final Set<DistributedMember> targetMembers) {
+  public static ResultCollector<?, ?> executeFunction(final Function function, Object args,
+      final Set<DistributedMember> targetMembers) {
+   * 
-   * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the function.
+   * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the
+   *        function.
-  public static ResultCollector<?, ?> executeFunction(final Function function, Object args , final DistributedMember targetMember) {
+  public static ResultCollector<?, ?> executeFunction(final Function function, Object args,
+      final DistributedMember targetMember) {
-   * <code>returnAll</code> indicates whether to return all members or only the first member we find.
+   * <code>returnAll</code> indicates whether to return all members or only the first member we
+   * find.
-   * @param returnAll whether to return all members or only the first member we find. Returns all when <code>true</code>
+   * @param returnAll whether to return all members or only the first member we find. Returns all
+   *        when <code>true</code>
-  public static Set<DistributedMember> getRegionAssociatedMembers(final String region, final Cache cache, boolean returnAll) {
+  public static Set<DistributedMember> getRegionAssociatedMembers(final String region,
+      final Cache cache, boolean returnAll) {
-    DistributedSystemMXBean distributedSystemMXBean = managementService.getDistributedSystemMXBean();
+    DistributedSystemMXBean distributedSystemMXBean =
+        managementService.getDistributedSystemMXBean();
-        if (distributedSystemMXBean.fetchRegionObjectName(CliUtil.getMemberNameOrId(member), region) != null) {
+        if (distributedSystemMXBean.fetchRegionObjectName(CliUtil.getMemberNameOrId(member),
+            region) != null) {
-        //ignore for now
+        // ignore for now
-    return nameOrId ;
+    return nameOrId;
-  public static <T>String arrayToString(T[] array) {
+  public static <T> String arrayToString(T[] array) {
-   * Resolves file system path relative to Gfsh. If the pathname is not specified, then pathname is returned.
+   * Resolves file system path relative to Gfsh. If the pathname is not specified, then pathname is
+   * returned.
-   * @param pathname
-   *          a String value specifying the file system pathname to resolve.
+   * @param pathname a String value specifying the file system pathname to resolve.
-    return (StringUtils.isBlank(pathname) ? pathname : IOUtils.tryGetCanonicalPathElseGetAbsolutePath(new File(pathname)));
+    return (StringUtils.isBlank(pathname) ? pathname
+        : IOUtils.tryGetCanonicalPathElseGetAbsolutePath(new File(pathname)));
-  
-  
-  public static void runLessCommandAsExternalViewer(Result commandResult, boolean isError){
-    
+
+
+  public static void runLessCommandAsExternalViewer(Result commandResult, boolean isError) {
+
-    String NEW_LINE = System.getProperty("line.separator");    
-    
+    String NEW_LINE = System.getProperty("line.separator");
+
-    
+
-      file = File.createTempFile("gfsh_output", "less");      
+      file = File.createTempFile("gfsh_output", "less");
-          new String[] {
-              "sh",
-              "-c",
-              "LESSOPEN=\"|color %s\" less -SR " + file.getName()
-                  + " < /dev/tty > /dev/tty " }, null, workingDir);
-      p.waitFor();      
+          new String[] {"sh", "-c",
+              "LESSOPEN=\"|color %s\" less -SR " + file.getName() + " < /dev/tty > /dev/tty "},
+          null, workingDir);
+      p.waitFor();
-      Gfsh.printlnErr(e.getMessage());     
+      Gfsh.printlnErr(e.getMessage());
-      if(file!=null)
+      if (file != null)
-    }    
-    
+    }
+
-  
-    public static String getClientIdFromCacheClientProxy(CacheClientProxy p){
-      if(p == null){
-        return null;
-      }
-      StringBuffer buffer = new StringBuffer();
-      buffer.append("[").append(p.getProxyID()).append(":port=").append(p.getRemotePort()).append(":primary=")
-          .append(p.isPrimary()).append("]");
-      return buffer.toString();
+
+  public static String getClientIdFromCacheClientProxy(CacheClientProxy p) {
+    if (p == null) {
+      return null;
+    }
+    StringBuffer buffer = new StringBuffer();
+    buffer.append("[").append(p.getProxyID()).append(":port=").append(p.getRemotePort())
+        .append(":primary=").append(p.isPrimary()).append("]");
+    return buffer.toString();
- 
-  public static Set<DistributedMember> getMembersForeRegionViaFunction(
-      Cache cache, String regionPath) {
+
+  public static Set<DistributedMember> getMembersForeRegionViaFunction(Cache cache,
+      String regionPath, boolean returnAll) {
-      List<?> resultList = (List<?>) CliUtil.executeFunction(membersForRegionFunction, regionPath, targetMembers).getResult();
+      List<?> resultList = (List<?>) CliUtil
+          .executeFunction(membersForRegionFunction, regionPath, targetMembers).getResult();
-            LogWrapper.getInstance().warning("Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(), ((Throwable) object));
+            LogWrapper.getInstance().warning(
+                "Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(),
+                ((Throwable) object));
-            LogWrapper.getInstance().warning( "Exception in getMembersForeRegionViaFunction "+ ((Throwable) object).getMessage(), ((Throwable) object));
+            LogWrapper.getInstance().warning(
+                "Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(),
+                ((Throwable) object));
+                  if (!returnAll) {
+                    return regionMembers;
+                  }
-  
+

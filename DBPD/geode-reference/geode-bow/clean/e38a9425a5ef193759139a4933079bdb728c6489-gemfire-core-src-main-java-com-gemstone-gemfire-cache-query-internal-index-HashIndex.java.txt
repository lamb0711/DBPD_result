Merge branch 'develop' into feature/GEODE-584

-import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
+import com.gemstone.gemfire.internal.offheap.Chunk;
-    entriesSet = new HashIndexSet(entryToValuesMap, entryToOldKeysMap, internalIndexStats);
+    entriesSet = new HashIndexSet();
-            entriesSet.remove(oldKey, entry, true);
+            removeFromEntriesSet(oldKey, entry, true);
-      this.entriesSet.add(newKey, entry);
+      
+      // Before adding the entry with new value, remove it from reverse map and
+      // using the oldValue remove entry from the forward map.
+      // Reverse-map is used based on the system property
+      Object oldKey = getOldKey(entry);
+      
+      int indexSlot = this.entriesSet.add(newKey, entry);
+      
+      if (indexSlot >= 0) {
+        // Update the reverse map
+        if (IndexManager.isObjectModificationInplace()) {
+          this.entryToValuesMap.put(entry, newKey);
+        }
+        if (newKey != null && oldKey != null) {
+          removeFromEntriesSet(oldKey, entry, false, indexSlot);
+        }
+        // Update Stats after real addition
+        internalIndexStats.incNumValues(1);
+
+      }
+  
+  private Object getOldKey(RegionEntry entry) throws TypeMismatchException {
+    Object oldKey = null;
+    if (IndexManager.isObjectModificationInplace() && this.entryToValuesMap.containsKey(entry)) {
+      oldKey = this.entryToValuesMap.get(entry);
+    } else if (!IndexManager.isObjectModificationInplace() && this.entryToOldKeysMap != null) {
+      Map oldKeyMap = this.entryToOldKeysMap.get();
+      if (oldKeyMap != null) {
+        oldKey = TypeUtils.indexKeyFor(oldKeyMap.get(entry));
+      }
+    }
+    return oldKey;
+  }
-    boolean found = false;
-      found = this.entriesSet.remove(newKey, entry, updateReverseMap);       
+      removeFromEntriesSet(newKey, entry, updateReverseMap);
+  
+  private void removeFromEntriesSet(Object newKey, RegionEntry entry, boolean updateReverseMap) {
+    removeFromEntriesSet(newKey, entry, updateReverseMap, -1);
+  }
+  
+  private void removeFromEntriesSet(Object newKey, RegionEntry entry, boolean updateReverseMap, int ignoreThisSlot) {
+    if (this.entriesSet.remove(newKey, entry, ignoreThisSlot)) {
+      if (updateReverseMap && IndexManager.isObjectModificationInplace()) {
+        entryToValuesMap.remove(entry);
+      }
+      internalIndexStats.incNumValues(-1);
+    }
+  }
-    this.entriesSet.setHashIndexStrategy(new HashStrategy(
-        (IMQEvaluator) evaluator));
+    this.entriesSet.setEvaluator((HashIndex.IMQEvaluator)evaluator);
-        
+          key = ((HashIndex.IMQEvaluator)evaluator).evaluateKey(obj);
-	int numKeys = (int) this.internalIndexStats.getNumberOfKeys();
-	if (numKeys > 0) {
-		this.internalIndexStats.incNumKeys(-numKeys);
-	}
-	int numValues = (int) this.internalIndexStats.getNumberOfValues();
-	if (numValues > 0) {
-		this.internalIndexStats.incNumValues(-numValues);
-	}
-	int updates = (int) this.internalIndexStats.getNumUpdates();
-	if (updates > 0) {
-		this.internalIndexStats.incNumUpdates(updates);
-	}
-	this.initializeIndex(true);
+    if (IndexManager.isObjectModificationInplace()) {
+      entryToValuesMap.clear();
+    }
+    int numKeys = (int) this.internalIndexStats.getNumberOfKeys();
+    if (numKeys > 0) {
+      this.internalIndexStats.incNumKeys(-numKeys);
+    }
+    int numValues = (int) this.internalIndexStats.getNumberOfValues();
+    if (numValues > 0) {
+      this.internalIndexStats.incNumValues(-numValues);
+    }
+    int updates = (int) this.internalIndexStats.getNumUpdates();
+    if (updates > 0) {
+      this.internalIndexStats.incNumUpdates(updates);
+    }
+    this.initializeIndex(true);
-    Object evaluateKey(Object object) {
+    public Object evaluateKey(Object object) {
+      
+      if (key == null) {
+        key = IndexManager.NULL;
+      }
-        Object key0 = ((Object[])arg0)[1];
-        Object key1 = ((Object[])arg1)[1];
+        Object key0 = ((Object[])arg0)[0];
+        Object key1 = ((Object[])arg1)[0];
-
-  private class HashStrategy implements HashIndexStrategy {
-
-    private AttributeDescriptor attDesc;
-
-    private IMQEvaluator evaluator;
-    
-    public HashStrategy(IMQEvaluator evaluator) {
-      this.evaluator = evaluator;
-    }
-
-    public final int computeHashCode(Object o) {
-      return computeHashCode(o, false);
-    }
-
-    public final int computeHashCode(Object o, boolean reevaluateKey) {
-      if (reevaluateKey) {
-        return computeKey(o).hashCode();
-      }
-      return o.hashCode();
-    }
-
-    public final Object computeKey(Object o) {
-      Object key = evaluator.evaluateKey(o);
-      if (key == null) {
-        key = IndexManager.NULL;
-      }
-      return key;
-    }
-
-    public final boolean equalsOnAdd(Object o1, Object o2) {
-      if (o1 == null) {
-        return o2 == null;
-      }
-      try {
-        return TypeUtils.compare(o1, o2, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
-      }
-      catch (TypeMismatchException e) {
-        return o1.equals(o2);
-      }
-    }
-
-    /*
-     * expects object o to be a region entry
-     */
-    public boolean equalsOnGet(Object indexKey, Object o) {
-      Object fieldValue = evaluator.evaluateKey(o);
-     
-      if (fieldValue == null && indexKey == IndexManager.NULL) {
-        return true;
-      } else {
-        try {
-          if (fieldValue instanceof PdxString) {
-           if (indexKey instanceof String) {
-             fieldValue = ((PdxString) fieldValue).toString(); 
-           }
-         }
-         else if (indexKey instanceof PdxString) {
-           if (fieldValue instanceof String) {
-             fieldValue = new PdxString((String)fieldValue);
-           }
-         }
-         return TypeUtils.compare(fieldValue, indexKey, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
-        }
-        catch (TypeMismatchException e) {
-          return fieldValue.equals(indexKey);
-        }
-      }
-    }
-  }
-
+  
-  public String printAll() {
-    return this.entriesSet.printAll();
-  }
+//  public String printAll() {
+//    return this.entriesSet.printAll();
+//  }

GEODE-6515: refactor ConnectionManagerImpl (#3304)

Refactors the ConnectionManagerImpl to a non-locking implementation to allow gets to scale with more threads. The previous implementation locked around all logic for getting, creating, or returning a connection to the pool, which resulted in a high degree of contention for that lock.

Additionally, much of the logic for accounting for the number of total connections, and the dequeue of available connections have been extracted to ConnectionAccounting and AvailableConnectionManager respectively. This was done in order to add unit and concurrent tests for that logic.

* Refactor ConnectionManagerImpl to a non-locking implementation
* add unit tests for ConnectionManagerImpl
* update ConnectionManagerImpl Javadocs
* extract ConnectionAccounting from ConnectionManagerImpl
* add unit test for ConnectionAccounting
* add concurrency tests for ConnectionAccounting
* extract AvailableConnectionManager from ConnectionManagerImpl
* add unit tests for AvailableConnectionManager
* add concurrency tests for AvailableConnectionManager
* add unit test for ConcurrentTestRunner
* add javadocs to AvailableConnectionManager and improved the method names
* activate returns false if the connection has been destroyed instead of throwing ConnectionDestroyedException
* start background prefill if under the minimum number of connections in ConnectionManagerImpl#borrowConnection when create fails
* add generic <ServerLocation> to Set in ConnectionManagerImpl
* Correct invalidateServer logic in ConnectionManagerImpl
* make NOT_WAITING private in ConnectionManagerImpl
* made createLifetimeReplacementConnection private since it is only
used by ConnectionMap

Signed-off-by: Helena Bales <hbales@pivotal.io>
Signed-off-by: Jacob Barrett <jbarrett@pivotal.io>
Signed-off-by: Darrel Schneider <dschneider@pivotal.io>

+
+import java.lang.reflect.InvocationTargetException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+        } catch (InvocationTargetException ex) {
+          Throwable exceptionToReturn = ex.getCause();
+          if (exceptionToReturn == null) {
+            exceptionToReturn = ex;
+          }
+          return Collections.singletonList(ex.getCause());
-    List<Future<?>> futures;
+    private List<Future<?>> futures;
+    private final AtomicInteger callablesStarting = new AtomicInteger(0);
+    private final CountDownLatch start = new CountDownLatch(1);
-      futures = new ArrayList<Future<?>>();
+      futures = new ArrayList<>();
-      Future<T> future = executorService.submit(callable);
+      callablesStarting.getAndIncrement();
+      Future<T> future = executorService.submit(() -> {
+        callablesStarting.getAndDecrement();
+        start.await();
+        return callable.call();
+      });
+      while (callablesStarting.get() > 0);
+
+      start.countDown();
+      futures.clear();
+

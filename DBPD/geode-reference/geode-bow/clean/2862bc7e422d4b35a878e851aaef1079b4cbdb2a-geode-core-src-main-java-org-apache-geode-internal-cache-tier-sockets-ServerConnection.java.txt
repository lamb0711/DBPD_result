GEODE-6639: Cleanup static analyzer warnings.

+
-import org.apache.geode.cache.client.internal.AbstractOp;
+  @Deprecated
+  @Deprecated
-  private Thread owner;
-  ClientProxyMembershipID proxyId;
+  private ClientProxyMembershipID proxyId;
-  private Object processingMessageLock = new Object();
+  private final Object processingMessageLock = new Object();
-    this.name = buffer.toString();
+    name = buffer.toString();
-    this.crHelper = helper;
-    this.logWriter = (InternalLogWriter) internalCache.getLogger();
-    this.securityLogWriter = (InternalLogWriter) internalCache.getSecurityLoggerI18n();
+    crHelper = helper;
+    logWriter = (InternalLogWriter) internalCache.getLogger();
+    securityLogWriter = (InternalLogWriter) internalCache.getSecurityLoggerI18n();
-    this.principal = null;
-    this.postAuthzRequest = null;
-    this.randomConnectionIdGen = new Random(this.hashCode());
+    principal = null;
+    postAuthzRequest = null;
+    randomConnectionIdGen = new Random(hashCode());
-      this.handshakeTimeout = hsTimeout;
+      handshakeTimeout = hsTimeout;
-    return this.acceptor;
+    return acceptor;
-    synchronized (this.handshakeMonitor) {
-      if (this.handshake == null) {
+    synchronized (handshakeMonitor) {
+      if (handshake == null) {
-        if (this.handshake.isOK()) {
+        if (handshake.isOK()) {
-          this.crHelper.checkCancelInProgress(null); // bug 37113?
+          crHelper.checkCancelInProgress(null);
-    return this.commands;
+    return commands;
-    return this.theSocket;
+    return theSocket;
-    return this.handshakeTimeout;
+    return handshakeTimeout;
-    return this.crHelper.getCache();
+    return crHelper.getCache();
-    return this.handshake;
+    return handshake;
-    this.replyMessage.setVersion(v);
-    this.requestMessage.setVersion(v);
-    this.responseMessage.setVersion(v);
-    this.errorMessage.setVersion(v);
+    replyMessage.setVersion(v);
+    requestMessage.setVersion(v);
+    responseMessage.setVersion(v);
+    errorMessage.setVersion(v);
-    this.queryResponseMessage.setVersion(v);
-    this.chunkedResponseMessage.setVersion(v);
-    this.executeFunctionResponseMessage.setVersion(v);
-    this.registerInterestResponseMessage.setVersion(v);
-    this.keySetResponseMessage.setVersion(v);
+    queryResponseMessage.setVersion(v);
+    chunkedResponseMessage.setVersion(v);
+    executeFunctionResponseMessage.setVersion(v);
+    registerInterestResponseMessage.setVersion(v);
+    keySetResponseMessage.setVersion(v);
-    return this.handshake.getVersion();
+    return handshake.getVersion();
-    this.memberIdByteArray = EventID.getMembershipId(proxyId);
-    this.name = "Server connection from [" + proxyId + "; port=" + this.theSocket.getPort() + "]";
+    memberIdByteArray = EventID.getMembershipId(proxyId);
+    name = "Server connection from [" + proxyId + "; port=" + theSocket.getPort() + "]";
-  // hitesh:this is for backward compability
-    if (this.clientUserAuths == null) {
-      this.initializeClientUserAuths();
+    if (clientUserAuths == null) {
+      initializeClientUserAuths();
-      return this.clientUserAuths.putUserAuth(userAuthAttr);
+      return clientUserAuths.putUserAuth(userAuthAttr);
-      if (this.isTerminated()) {
-        // Bug #52023.
+      if (isTerminated()) {
+  @Deprecated
-    return this.securityLogWriter;
+    return securityLogWriter;
-    return this.securityService;
+    return securityService;
-        MutableInt numRefs = getCleanupTable().get(this.handshake);
+        MutableInt numRefs = getCleanupTable().get(handshake);
-        if (this.proxyId.isDurable()) {
+        if (proxyId.isDurable()) {
-                this.proxyId);
+                proxyId);
-              getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
+              getAcceptor().getCacheClientNotifier().getClientProxy(proxyId);
-            proxy = getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
+            proxy = getAcceptor().getCacheClientNotifier().getClientProxy(proxyId);
-              logger.debug("Proxy existed for this durable client :{} and proxy : {}", this.proxyId,
+              logger.debug("Proxy existed for this durable client :{} and proxy : {}", proxyId,
-          // Bug Fix for 37986
-                  new Object[] {this.name, handshakeRefusalMessage});
+                  new Object[] {name, handshakeRefusalMessage});
-            this.incedCleanupTableRef = true;
+            incedCleanupTableRef = true;
-            getCleanupTable().put(this.handshake, new MutableInt(1));
-            this.incedCleanupTableRef = true;
-            this.stats.incCurrentClients();
+            getCleanupTable().put(handshake, new MutableInt(1));
+            incedCleanupTableRef = true;
+            stats.incCurrentClients();
-        MutableInt numRefs = getCleanupProxyIdTable().get(this.proxyId);
+        MutableInt numRefs = getCleanupProxyIdTable().get(proxyId);
-          getCleanupProxyIdTable().put(this.proxyId, new MutableInt(1));
+          getCleanupProxyIdTable().put(proxyId, new MutableInt(1));
-        this.incedCleanupProxyIdTableRef = true;
+        incedCleanupProxyIdTableRef = true;
-      this.crHelper.checkCancelInProgress(null);
+      crHelper.checkCancelInProgress(null);
-        // This is a new client. Notify bridge membership and heartbeat monitor.
-        InternalClientMembership.notifyClientJoined(this.proxyId.getDistributedMember());
+        InternalClientMembership.notifyClientJoined(proxyId.getDistributedMember());
-      ClientHealthMonitor chm = this.acceptor.getClientHealthMonitor();
-      synchronized (this.chmLock) {
-        this.chmRegistered = true;
+      ClientHealthMonitor chm = acceptor.getClientHealthMonitor();
+      synchronized (chmLock) {
+        chmRegistered = true;
-        // hitesh: it will add client
-        chm.registerClient(this.proxyId);
+        chm.registerClient(proxyId);
-      // hitesh:it will add client connection in set
-      serverConnectionCollection = chm.addConnection(this.proxyId, this);
-      this.acceptor.getConnectionListener().connectionOpened(registerClient, communicationMode);
-      // Hitesh: add user creds in map for single user case.
+      serverConnectionCollection = chm.addConnection(proxyId, this);
+      acceptor.getConnectionListener().connectionOpened(registerClient, communicationMode);
-    return this.acceptor.isRunning()
-        && !(this.acceptor.getCachedRegionHelper().getCache()).isClosed()
+    return acceptor.isRunning()
+        && !(acceptor.getCachedRegionHelper().getCache()).isClosed()
-      acceptor.refuseHandshake(this.theSocket.getOutputStream(), message, exception);
+      acceptor.refuseHandshake(theSocket.getOutputStream(), message, exception);
-      this.stats.incFailedConnectionAttempts();
+      stats.incFailedConnectionAttempts();
-      logger.debug("{}: Accepted handshake", this.name);
+      logger.debug("{}: Accepted handshake", name);
-    if (this.communicationMode == CommunicationMode.ClientToServerForQueue) {
-      this.stats.incCurrentQueueConnections();
+    if (communicationMode == CommunicationMode.ClientToServerForQueue) {
+      stats.incCurrentQueueConnections();
-      this.stats.incCurrentClientConnections();
+      stats.incCurrentClientConnections();
-    if (this.requestMessage.isSecureMode()) {
+    if (requestMessage.isSecureMode()) {
-        byte[] secureBytes = this.requestMessage.getSecureBytes();
+        byte[] secureBytes = requestMessage.getSecureBytes();
-        secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
+        secureBytes = handshake.getEncryptor().decryptBytes(secureBytes);
-            getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
+            getAcceptor().getCacheClientNotifier().getClientProxy(proxyId);
-    if (this.requestMessage.isSecureMode()) {
+    if (requestMessage.isSecureMode()) {
-        this.clientUserAuths.removeUserAuthAttributesForCq(cqName, isDurable);
+        clientUserAuths.removeUserAuthAttributesForCq(cqName, isDurable);
-  public void setProcessMessages(boolean newValue) {
-    processMessages = newValue;
-  }
-
-    // hitesh:to create new connection handshake
-      // Initialize the commands after the handshake so that the version
-      // can be used.
-      // its initialized in verifyClientConnection call
-      Assert.assertTrue((this.handshake.getVersion().ordinal() == testVersionAfterHandshake),
+      Assert.assertTrue((handshake.getVersion().ordinal() == testVersionAfterHandshake),
-      // return here if we haven't successfully completed handshake
-      this.processMessages = false;
+      processMessages = false;
-      this.processMessages = false;
+      processMessages = false;
-        if (!this.processMessages || (crHelper.isShutdown())) {
+        if (!processMessages || (crHelper.isShutdown())) {
-                getName(), MessageType.getString(message.getMessageType()), this.proxyId);
+                getName(), MessageType.getString(message.getMessageType()), proxyId);
-              this.processMessages = false;
+              processMessages = false;
-          if (message.getTransactionId() < -1) { // TODO: why is this happening?
+          if (message.getTransactionId() < -1) {
-          acceptor.getClientHealthMonitor().receivedPing(this.proxyId);
+          acceptor.getClientHealthMonitor().receivedPing(proxyId);
-            && !isInternalMessage(this.requestMessage, allowInternalMessagesWithoutCredentials)
-            && !this.communicationMode.isWAN()) {
+            && !isInternalMessage(requestMessage, allowInternalMessagesWithoutCredentials)
+            && !communicationMode.isWAN()) {
-          String messageType = MessageType.getString(this.requestMessage.getMessageType());
-          Subject subject = this.clientUserAuths.getSubject(uniqueId);
+          String messageType = MessageType.getString(requestMessage.getMessageType());
+          Subject subject = clientUserAuths.getSubject(uniqueId);
-                uniqueId, messageType, this.getName());
+                uniqueId, messageType, getName());
-            logger.debug("No unique ID yet. {}, {}", messageType, this.getName());
+            logger.debug("No unique ID yet. {}, {}", messageType, getName());
-                uniqueId, messageType, this.getName());
+                uniqueId, messageType, getName());
-        command.execute(message, this, this.securityService);
+        command.execute(message, this, securityService);
-    synchronized (this.terminationLock) {
-      return this.terminated;
+    synchronized (terminationLock) {
+      return terminated;
-    if (this.clientUserAuths != null) {
-      this.clientUserAuths.cleanup(false);
+    if (clientUserAuths != null) {
+      clientUserAuths.cleanup(false);
-    if (this.crHelper.isShutdown()) {
+    if (crHelper.isShutdown()) {
-    synchronized (this.terminationLock) {
-      if (this.terminated) {
+    synchronized (terminationLock) {
+      if (terminated) {
-      this.terminated = true;
+      terminated = true;
-      if (this.incedCleanupTableRef) {
-        this.incedCleanupTableRef = false;
+      if (incedCleanupTableRef) {
+        incedCleanupTableRef = false;
-        MutableInt numRefs = getCleanupTable().get(this.handshake);
+        MutableInt numRefs = getCleanupTable().get(handshake);
-            getCleanupTable().remove(this.handshake);
-            this.stats.decCurrentClients();
+            getCleanupTable().remove(handshake);
+            stats.decCurrentClients();
-        if (this.communicationMode == CommunicationMode.ClientToServerForQueue) {
-          this.stats.decCurrentQueueConnections();
+        if (communicationMode == CommunicationMode.ClientToServerForQueue) {
+          stats.decCurrentQueueConnections();
-          this.stats.decCurrentClientConnections();
+          stats.decCurrentClientConnections();
-      if (this.incedCleanupProxyIdTableRef) {
-        this.incedCleanupProxyIdTableRef = false;
-        MutableInt numRefs = getCleanupProxyIdTable().get(this.proxyId);
+      if (incedCleanupProxyIdTableRef) {
+        incedCleanupProxyIdTableRef = false;
+        MutableInt numRefs = getCleanupProxyIdTable().get(proxyId);
-            getCleanupProxyIdTable().remove(this.proxyId);
+            getCleanupProxyIdTable().remove(proxyId);
-            proxyIdVsClientUserAuths.remove(this.proxyId);
+            proxyIdVsClientUserAuths.remove(proxyId);
-        if (this.clientDisconnectedCleanly && !forceClientCrashEvent) {
+        if (clientDisconnectedCleanly && !forceClientCrashEvent) {
-          InternalClientMembership.notifyClientCrashed(this.proxyId.getDistributedMember());
+          InternalClientMembership.notifyClientCrashed(proxyId.getDistributedMember());
-    // moved out of above if to fix bug 36751
-    synchronized (this.chmLock) {
-      if (this.chmRegistered) {
+    synchronized (chmLock) {
+      if (chmRegistered) {
-        this.chmRegistered = false;
+        chmRegistered = false;
-    if (unregisterClient)// last serverconnection call all close on auth objects
-    {
+    if (unregisterClient) {
+      // last serverconnection call all close on auth objects
-    this.clientUserAuths = null;
+    clientUserAuths = null;
-      this.acceptor.getClientHealthMonitor().removeConnection(this.proxyId, this);
+      acceptor.getClientHealthMonitor().removeConnection(proxyId, this);
-        this.acceptor.getClientHealthMonitor().unregisterClient(this.proxyId, getAcceptor(),
-            this.clientDisconnectedCleanly, this.clientDisconnectedException);
+        acceptor.getClientHealthMonitor().unregisterClient(proxyId, getAcceptor(),
+            clientDisconnectedCleanly, clientDisconnectedException);
-      this.acceptor.getConnectionListener().connectionClosed(clientDeparted, communicationMode);
+      acceptor.getConnectionListener().connectionClosed(clientDeparted, communicationMode);
-    this.clientUserAuths = getClientUserAuths(this.proxyId);
+    clientUserAuths = getClientUserAuths(proxyId);
-    this.commands = CommandInitializer.getCommands(this);
+    commands = CommandInitializer.getCommands(this);
-    return (Command) this.commands.get(messageType);
+    return (Command) commands.get(messageType);
-      secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
+      secureBytes = handshake.getEncryptor().decryptBytes(secureBytes);
-      if (connId != this.connectionId) {
+      if (connId != connectionId) {
-        boolean removed = this.clientUserAuths.removeSubject(aIds.getUniqueId());
+        boolean removed = clientUserAuths.removeSubject(aIds.getUniqueId());
-          this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepAlive);
+          clientUserAuths.removeUserId(aIds.getUniqueId(), keepAlive);
-        // Bug #52023.
-        logger.debug("Exception {}", exception);
+        logger.debug("Exception", exception);
-      secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
+      secureBytes = handshake.getEncryptor().decryptBytes(secureBytes);
-      if (connId != this.connectionId) {
+      if (connId != connectionId) {
-      credBytes = this.handshake.getEncryptor().decryptBytes(credBytes);
+      credBytes = handshake.getEncryptor().decryptBytes(credBytes);
-      DistributedSystem system = this.getDistributedSystem();
+      DistributedSystem system = getDistributedSystem();
-          (InternalLogWriter) system.getSecurityLogWriter(), this.proxyId.getDistributedMember(),
-          this.securityService);
+          (InternalLogWriter) system.getSecurityLogWriter(), proxyId.getDistributedMember(),
+          securityService);
-        uniqueId = this.clientUserAuths.putSubject(subject);
+        uniqueId = clientUserAuths.putSubject(subject);
-    return this.clientUserAuths;
+    return clientUserAuths;
-      this.connectionId = randomConnectionIdGen.nextLong();
-      this.securePart = new Part();
-      byte[] id = encryptId(this.connectionId);
-      this.securePart.setPartState(id, false);
+      connectionId = randomConnectionIdGen.nextLong();
+      securePart = new Part();
+      byte[] id = encryptId(connectionId);
+      securePart.setPartState(id, false);
-   *
-   * @see AbstractOp#processSecureBytes(Connection, Message)
-   * @see AbstractOp#needsUserId()
-   * @see AbstractOp#sendMessage(Connection)
-        && this.handshake.getVersion().compareTo(Version.GFE_65) >= 0
-        && !this.communicationMode.isWAN() && !this.requestMessage.getAndResetIsMetaRegion()
-        && !isInternalMessage(this.requestMessage, allowInternalMessagesWithoutCredentials)) {
+        && handshake.getVersion().compareTo(Version.GFE_65) >= 0
+        && !communicationMode.isWAN() && !requestMessage.getAndResetIsMetaRegion()
+        && !isInternalMessage(requestMessage, allowInternalMessagesWithoutCredentials)) {
-      return this.securePart;
+      return securePart;
-            MessageType.getString(this.requestMessage.messageType));
+            MessageType.getString(requestMessage.messageType));
-        this.stats.decThreadQueueSize();
+        stats.decThreadQueueSize();
-          if (this.processMessages && !(this.crHelper.isShutdown())) {
+          if (processMessages && !(crHelper.isShutdown())) {
-        this.unsetRequestSpecificTimeout();
+        unsetRequestSpecificTimeout();
-        while (this.processMessages && !(this.crHelper.isShutdown())) {
+        while (processMessages && !(crHelper.isShutdown())) {
-            this.unsetRequestSpecificTimeout();
+            unsetRequestSpecificTimeout();
-          this.unsetRequestSpecificTimeout();
+          unsetRequestSpecificTimeout();
-    return this.theSocket.getChannel();
+    return theSocket.getChannel();
-    SelectableChannel c = this.theSocket.getChannel();
+    SelectableChannel c = theSocket.getChannel();
-    return this.proxyId.getDSMembership();
+    return proxyId.getDSMembership();
-    return this.communicationMode;
+    return communicationMode;
-    this.requestSpecificTimeout = -1;
+    requestSpecificTimeout = -1;
-    if (this.requestSpecificTimeout == -1) {
-      return this.handshake.getClientReadTimeout();
+    if (requestSpecificTimeout == -1) {
+      return handshake.getClientReadTimeout();
-      return this.requestSpecificTimeout;
+      return requestSpecificTimeout;
-    synchronized (this.processingMessageLock) {
+    synchronized (processingMessageLock) {
-      this.processingMessageStartTime = System.currentTimeMillis();
+      processingMessageStartTime = System.currentTimeMillis();
-    synchronized (this.processingMessageLock) {
+    synchronized (processingMessageLock) {
-      if (this.processingMessageStartTime != -1) {
-        this.processingMessageStartTime = System.currentTimeMillis();
+      if (processingMessageStartTime != -1) {
+        processingMessageStartTime = System.currentTimeMillis();
-    synchronized (this.processingMessageLock) {
-      this.processingMessageStartTime = -1;
+    synchronized (processingMessageLock) {
+      processingMessageStartTime = -1;
-    synchronized (this.processingMessageLock) {
-      result = this.processingMessageStartTime;
+    synchronized (processingMessageLock) {
+      result = processingMessageStartTime;
-      synchronized (this.processingMessageLock) {
+      synchronized (processingMessageLock) {
-    if (justProcessed - this.latestBatchIdReplied != 1) {
-      this.stats.incOutOfOrderBatchIds();
+    if (justProcessed - latestBatchIdReplied != 1) {
+      stats.incOutOfOrderBatchIds();
-              this.latestBatchIdReplied});
+              latestBatchIdReplied});
-    this.latestBatchIdReplied = justProcessed;
+    latestBatchIdReplied = justProcessed;
-    return this.latestBatchIdReplied;
+    return latestBatchIdReplied;
-    synchronized (this.ownerLock) {
-      this.owner = Thread.currentThread();
+    synchronized (ownerLock) {
-    synchronized (this.ownerLock) {
-      this.owner = null;
+    synchronized (ownerLock) {
-    return this.theSocket == null || !this.theSocket.isConnected() || this.theSocket.isClosed();
+    return theSocket == null || !theSocket.isConnected() || theSocket.isClosed();
-      this.stats.incConnectionsTimedOut();
+      stats.incConnectionsTimedOut();
-    if (this.communicationMode.isWAN()
-        || this.communicationMode.isCountedAsClientServerConnection()) {
+    if (communicationMode.isWAN()
+        || communicationMode.isCountedAsClientServerConnection()) {
-      if (this.postAuthzRequest != null) {
-        this.postAuthzRequest.close();
-        this.postAuthzRequest = null;
+      if (postAuthzRequest != null) {
+        postAuthzRequest.close();
+        postAuthzRequest = null;
-                new Object[] {this.name, ex}));
+                name, ex));
-      logger.debug("{}: Closed connection", this.name);
+      logger.debug("{}: Closed connection", name);
-    ByteBuffer byteBuffer = this.commBuffer;
+    ByteBuffer byteBuffer = commBuffer;
-      this.commBuffer = null;
+      commBuffer = null;
-    this.terminated = true;
-    Socket s = this.theSocket;
+    terminated = true;
+    Socket s = theSocket;
-    return this.name;
+    return name;
-    return this.name;
+    return name;
-    return this.proxyId;
+    return proxyId;
-    return this.crHelper;
+    return crHelper;
-    return this.stats;
+    return stats;
-    return this.replyMessage;
+    return replyMessage;
-    return this.chunkedResponseMessage;
+    return chunkedResponseMessage;
-    return this.errorMessage;
+    return errorMessage;
-    return this.responseMessage;
+    return responseMessage;
-    return this.requestMessage;
+    return requestMessage;
-    return this.queryResponseMessage;
+    return queryResponseMessage;
-    return this.executeFunctionResponseMessage;
+    return executeFunctionResponseMessage;
-    return this.keySetResponseMessage;
+    return keySetResponseMessage;
-    return this.registerInterestResponseMessage;
+    return registerInterestResponseMessage;
-    this.potentialModification = false;
-    this.requiresResponse = false;
-    this.responded = false;
-    this.requiresChunkedResponse = false;
-    this.modKey = null;
-    this.modRegion = null;
+    potentialModification = false;
+    requiresResponse = false;
+    responded = false;
+    requiresChunkedResponse = false;
+    modKey = null;
+    modRegion = null;
-    return this.modRegion;
+    return modRegion;
-    return this.modKey;
+    return modKey;
-    return this.potentialModification;
+    return potentialModification;
-        this.responded = true;
+        responded = true;
-        this.requiresResponse = true;
+        requiresResponse = true;
-        this.requiresChunkedResponse = true;
+        requiresChunkedResponse = true;
-        retVal = this.responded;
+        retVal = responded;
-        retVal = this.requiresResponse;
+        retVal = requiresResponse;
-        retVal = this.requiresChunkedResponse;
+        retVal = requiresChunkedResponse;
-    this.processMessages = false;
+    processMessages = false;
+  @Deprecated
-    return this.logWriter; // TODO:LOG:CONVERT: remove getLogWriter after callers are converted
+    return logWriter; // TODO:LOG:CONVERT: remove getLogWriter after callers are converted
-    this.userAuthId = uniqueId;
+    userAuthId = uniqueId;
-      return this.handshake.getEncryptor().encryptBytes(heapDataOutputStream.toByteArray());
+      return handshake.getEncryptor().encryptBytes(heapDataOutputStream.toByteArray());
-    if (this.handshake.getVersion().isPre65() || communicationMode.isWAN()) {
-      uniqueId = this.userAuthId;
-    } else if (this.requestMessage.isSecureMode()) {
-      uniqueId = messageIdExtractor.getUniqueIdFromMessage(this.requestMessage,
-          this.handshake.getEncryptor(), this.connectionId);
+    if (handshake.getVersion().isPre65() || communicationMode.isWAN()) {
+      uniqueId = userAuthId;
+    } else if (requestMessage.isSecureMode()) {
+      uniqueId = messageIdExtractor.getUniqueIdFromMessage(requestMessage,
+          handshake.getEncryptor(), connectionId);
-  public AuthorizeRequest getAuthzRequest() throws AuthenticationRequiredException, IOException {
+  private UserAuthAttributes getUserAuthAttributes() throws IOException {
-      uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);
+      uaa = clientUserAuths.getUserAuthAttributes(uniqueId);
-      if (this.isTerminated()) {
-        // Bug #52023.
+      if (isTerminated()) {
-        logger.debug("Unexpected exception {}", npe);
+        logger.debug("Unexpected exception", npe);
+    return uaa;
+  }
+
+  public AuthorizeRequest getAuthzRequest() throws AuthenticationRequiredException, IOException {
+    UserAuthAttributes uaa = getUserAuthAttributes();
+    if (uaa == null) {
+      return null;
+    }
+
-    if (!AcceptorImpl.isAuthenticationRequired()) {
+    UserAuthAttributes uaa = getUserAuthAttributes();
+    if (uaa == null)
-    }
-
-    if (securityService.isIntegratedSecurity()) {
-      return null;
-    }
-
-    // look client version and return authzrequest
-    // for backward client it will be store in member variable userAuthId
-    // for other look "requestMessage" here and get unique-id from this to get the authzrequest
-    long uniqueId = getUniqueId();
-
-    UserAuthAttributes uaa = null;
-    try {
-      uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);
-    } catch (NullPointerException npe) {
-      if (this.isTerminated()) {
-        // Bug #52023.
-        throw new IOException("Server connection is terminated.");
-      } else {
-        logger.debug("Unexpected exception {}", npe);
-      }
-    }
-    if (uaa == null) {
-      throw new AuthenticationRequiredException("User authorization attributes not found.");
-    }
-    return this.memberIdByteArray;
+    return memberIdByteArray;
-    this.clientDisconnectedCleanly = true;
+    clientDisconnectedCleanly = true;
-    this.clientDisconnectedException = e;
+    clientDisconnectedException = e;
-                  new Object[] {getName(), SECURITY_CLIENT_AUTHENTICATOR, getProxyID()}));
+                  getName(), SECURITY_CLIENT_AUTHENTICATOR, getProxyID()));
-                  new Object[] {getName(), SECURITY_CLIENT_AUTHENTICATOR}));
+                  getName(), SECURITY_CLIENT_AUTHENTICATOR));

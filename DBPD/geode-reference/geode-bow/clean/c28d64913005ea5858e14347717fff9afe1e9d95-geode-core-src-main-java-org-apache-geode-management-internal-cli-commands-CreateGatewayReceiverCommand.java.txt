Merge branch 'release/1.4.0'

-import java.util.concurrent.atomic.AtomicReference;
-import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.cache.wan.GatewayReceiver;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
+import org.apache.geode.management.internal.cli.AbstractCliAroundInterceptor;
+import org.apache.geode.management.internal.cli.GfshParseResult;
+import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.TabularResultData;
-  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)
+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN,
+      interceptor = "org.apache.geode.management.internal.cli.commands.CreateGatewayReceiverCommand$Interceptor")
-    Result result;
+    GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs =
+        new GatewayReceiverFunctionArgs(manualStart, startPort, endPort, bindAddress,
+            socketBufferSize, maximumTimeBetweenPings, gatewayTransportFilters, hostnameForSenders);
-    AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
-    try {
-      GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs = new GatewayReceiverFunctionArgs(
-          manualStart, startPort, endPort, bindAddress, socketBufferSize, maximumTimeBetweenPings,
-          gatewayTransportFilters, hostnameForSenders);
+    Set<DistributedMember> membersToCreateGatewayReceiverOn = getMembers(onGroups, onMember);
-      Set<DistributedMember> membersToCreateGatewayReceiverOn =
-          CliUtil.findMembers(onGroups, onMember);
+    List<CliFunctionResult> gatewayReceiverCreateResults =
+        executeAndGetFunctionResult(GatewayReceiverCreateFunction.INSTANCE,
+            gatewayReceiverFunctionArgs, membersToCreateGatewayReceiverOn);
-      if (membersToCreateGatewayReceiverOn.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
-
-      ResultCollector<?, ?> resultCollector =
-          CliUtil.executeFunction(GatewayReceiverCreateFunction.INSTANCE,
-              gatewayReceiverFunctionArgs, membersToCreateGatewayReceiverOn);
-      @SuppressWarnings("unchecked")
-      List<CliFunctionResult> gatewayReceiverCreateResults =
-          (List<CliFunctionResult>) resultCollector.getResult();
-
-      TabularResultData tabularResultData = ResultBuilder.createTabularResultData();
-      final String errorPrefix = "ERROR: ";
-
-      for (CliFunctionResult gatewayReceiverCreateResult : gatewayReceiverCreateResults) {
-        boolean success = gatewayReceiverCreateResult.isSuccessful();
-        tabularResultData.accumulate("Member", gatewayReceiverCreateResult.getMemberIdOrName());
-        tabularResultData.accumulate("Status",
-            (success ? "" : errorPrefix) + gatewayReceiverCreateResult.getMessage());
-
-        if (success && xmlEntity.get() == null) {
-          xmlEntity.set(gatewayReceiverCreateResult.getXmlEntity());
-        }
-      }
-      result = ResultBuilder.buildResult(tabularResultData);
-    } catch (IllegalArgumentException e) {
-      LogWrapper.getInstance().info(e.getMessage());
-      result = ResultBuilder.createUserErrorResult(e.getMessage());
+    CommandResult result = ResultBuilder.buildResult(gatewayReceiverCreateResults);
+    XmlEntity xmlEntity = findXmlEntity(gatewayReceiverCreateResults);
+    // no xml needs to be updated, simply return
+    if (xmlEntity == null) {
+      return result;
-    if (xmlEntity.get() != null) {
-      persistClusterConfiguration(result,
-          () -> getSharedConfiguration().addXmlEntity(xmlEntity.get(), onGroups));
+    // has xml but unable to persist to cluster config, need to print warning message and return
+    if (onMember != null || getSharedConfiguration() == null) {
+      result.setCommandPersisted(false);
+      return result;
+
+    // update cluster config
+    getSharedConfiguration().addXmlEntity(xmlEntity, onGroups);
+
+  public static class Interceptor extends AbstractCliAroundInterceptor {
+    @Override
+    public Result preExecution(GfshParseResult parseResult) {
+      Integer startPort = (Integer) parseResult.getParamValue("start-port");
+      Integer endPort = (Integer) parseResult.getParamValue("end-port");
+
+      if (startPort == null) {
+        startPort = GatewayReceiver.DEFAULT_START_PORT;
+      }
+
+      if (endPort == null) {
+        endPort = GatewayReceiver.DEFAULT_END_PORT;
+      }
+
+      if (startPort > endPort) {
+        return ResultBuilder.createUserErrorResult("start-port must be smaller than end-port.");
+      }
+
+      return ResultBuilder.createInfoResult("");
+    }
+  }

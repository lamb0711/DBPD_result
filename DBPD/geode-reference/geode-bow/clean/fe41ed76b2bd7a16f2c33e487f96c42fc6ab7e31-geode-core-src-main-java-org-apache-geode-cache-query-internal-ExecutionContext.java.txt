GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Stack;
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.query.*;
+import org.apache.geode.cache.query.AmbiguousNameException;
+import org.apache.geode.cache.query.NameResolutionException;
+import org.apache.geode.cache.query.Query;
+import org.apache.geode.cache.query.TypeMismatchException;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.cache.query.internal.types.*;
-import org.apache.geode.internal.Assert;
-import org.apache.geode.internal.cache.PartitionedRegion;
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import org.apache.geode.cache.query.internal.types.TypeUtils;
+import org.apache.geode.internal.Assert;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.PartitionedRegion;
- * 
-  protected Object[] bindArguments;
+  Object[] bindArguments;
+
-  private final Cache cache;
+
+  private final InternalCache cache;
-   * constraints. Type of this map: map <CompiledValue, set <RuntimeIterator>>
+   * constraints. Type of this map: map &lt;CompiledValue, set &lt;RuntimeIterator&gt;&gt;
-  Map dependencyGraph = new HashMap();
+  private Map dependencyGraph = new HashMap();
+
-   * final Independent RuntimeIterator or Iterators , ie. those refering to a Region or
-   * BindArgument, on which the CompiledIteratorDef depends upon . TODO:Asif: For a single vale ,
-   * should we still use a Set?
-   * 
+   * final Independent RuntimeIterator or Iterators , ie. those referring to a Region or
+   * BindArgument, on which the CompiledIteratorDef depends upon .
+
-   * Asif : This Map will store its Region Path String against an Independent RuntimeIterator An
-   * entry in this Map will be only for those RuntimeIteartors which have an underlying Region as
-   * its Collection Expression
-   * 
+   * This Map will store its Region Path String against an Independent RuntimeIterator An entry in
+   * this Map will be only for those RuntimeIterators which have an underlying Region as its
+   * Collection Expression
-  public ExecutionContext(Object[] bindArguments, Cache cache) {
-    this.bindArguments = bindArguments;
-    this.cache = cache;
-  }
-
-  public ExecutionContext(Object[] bindArguments, Cache cache, SelectResults results) {
-    this.bindArguments = bindArguments;
-    this.cache = cache;
-  }
-
-  public ExecutionContext(Object[] bindArguments, Cache cache, Query query) {
+  public ExecutionContext(Object[] bindArguments, InternalCache cache) {
-    return ((GemFireCacheImpl) this.cache).getCachePerfStats();
+    return this.cache.getCachePerfStats();
-  // TODO:ASIF:QUERY
-   * 
-        return Collections.EMPTY_SET;
+        return Collections.emptySet();
-   * {@link ExecutionContext} for concurrent updates on indexes.
+   * ExecutionContext for concurrent updates on indexes.
-  // TODO:ASIF:Query
-    // int currScopeID = this.scopes.size();
-    // attribute name or operation name (no args) of a variable in the current
-    // scope
-    // when there is no ambiguity, i.e. this property name belongs to only one
-    // variable in the scope
+    // attribute name or operation name (no args) of a variable in the current scope when there is
+    // no ambiguity, i.e. this property name belongs to only one variable in the scope
-   * 
-   * @return int indentifying the scope ID which can be assosciated with the scope
+   * @return the scope ID which can be associated with the scope
-  int assosciateScopeID() {
-    // this.scopeIDMap.put(cs, Integer.valueOf(num));
+  int associateScopeID() {
-   * List TODO:Asif If we are storing a single Iterator instead of Set , in the
-   * itrDefToIndpndtRuntimeItrMap , we need to take care of this function.
-   * 
-   * <P>
-   * author Asif
+   * List
+   * <p>
+   * TODO: If we are storing a single Iterator instead of Set , in the itrDefToIndpndtRuntimeItrMap
+   * , we need to take care of this function.
-  public List getAllIterators() {
-    int numScopes = scopes.size();
-    List iterators = new ArrayList();
-    for (int i = 1; i <= numScopes; i++) {
-      iterators.addAll(((QScope) scopes.get(numScopes - i)).getIterators());
-    }
-    return iterators;
-  }
-
-
-  void setCurrent(RuntimeIterator iter, Object obj) {
-    currentScope().setCurrent(iter, obj);
-  }
-
-  public Cache getCache() {
+  public InternalCache getCache() {
-    // System.out.println("In resolveImplicitOperationName");
-        // Shobhit: If Element type is ObjectType then we don't need to
-        // apply reflection to find out field or method. This save lot of CPU time.
+        // If Element type is ObjectType then we don't need to apply reflection to find out field or
+        // method. This save lot of CPU time.
-    if (hits.size() == 1)
+    if (hits.size() == 1) {
+    }
-                .toLocalizedString(new Object[] {name, Integer.valueOf(numArgs)}));
+                .toLocalizedString(name, numArgs));
-  protected CompiledValue resolveScopeVariable(String name) {
-    CompiledValue value = null;
-    for (int i = scopes.size() - 1; i >= 0; i--) {
-      QScope scope = (QScope) scopes.get(i);
-      value = scope.resolve(name);
-      if (value != null)
-        break;
-    }
-    return value;
-  }
-
-      RuntimeIterator rIter = (RuntimeIterator) expr;
-      return rIter;
+      return (RuntimeIterator) expr;
-          RuntimeIterator rcvrItr = resolveImplicitOperationName(operation.getMethodName(),
+          return resolveImplicitOperationName(operation.getMethodName(),
-          return rcvrItr;
-    } catch (TypeMismatchException e) {
-    } catch (NameResolutionException e) {
+    } catch (TypeMismatchException | NameResolutionException ignore) {
-  int getScopeCount() {
-    return this.scopes.size();
-  }
-
-   * 
-   * 
-   * <P>
-   * author Asif/Ketan
-   * 
-   * @param cv
-   * @param set
+   * <p>
+   * This function will populate the set to its independent RuntimeIterators. However if the
+   * CompiledValue happens to be a CompiledIteratorDef & if it is independent of any other
+   * RuntimeIterators then no addition will be done in the Set.
+   * <p>
+   * TODO: the behavior of this function will change if we modify the computeDependency function of
+   * the CompiledIteratorDef as in that case the Set will be added with the self RuntimeIterator (
+   * if the CompiledIteratorDef is independent) which is not the case now.
+   * <p>
+   * TODO: If a CompiledIteratorDef has only one dependent RuntimeIterator should it still be stored
+   * in a Set or should it be a single value?
-  // Ketan - Asif:This function will populate the set to its independent
-  // RuntimeIterators
-  // However if the CompiledValue happens to be a CompiledIteratorDef & if it is
-  // independent of any other RuntimeIterators then no adition will be done in
-  // the Set
-  // TODO: Asif : The behaviour of this function will change if we modify the
-  // computeDependency
-  // function of the CompiledIteratorDef as in that case the Set will be added
-  // with the self RuntimeIterator ( if the CompiledIteratorDef is independent)
-  // which is
-  // not the case now
-  // TODO:Asif : If a CompiledIteratorDef has only one dependent RuntimeIterator
-  // should it still be
-  // stored in a Set or should it be a single value?
-  public void computeUtlimateDependencies(CompiledValue cv, Set set) {
+  void computeUltimateDependencies(CompiledValue cv, Set set) {
-    if (dependencySet != Collections.EMPTY_SET) {
+    if (dependencySet != Collections.emptySet()) {
-   * Asif : This function populates the Map itrDefToIndpndtRuntimeItrMap. It creates a Set of
+   * This function populates the Map itrDefToIndpndtRuntimeItrMap. It creates a Set of
-   * @throws AmbiguousNameException
-   * @throws TypeMismatchException
-    this.computeUtlimateDependencies(itrDef, set);
+    this.computeUltimateDependencies(itrDef, set);
-      // Asif : Since it is a an independent RuntimeIterator , check if its
-      // Collection Expr
-      // boils down to a Region. If it is , we need to store the QRegion in the
-      // Map
+      // Since it is a an independent RuntimeIterator , check if its Collection Expr boils down to a
+      // Region. If it is , we need to store the QRegion in the Map
-    // Asif : Set the canonicalized index_internal_id if the condition is
-    // satisfied
+    // Set the canonicalized index_internal_id if the condition is satisfied
-        // if (itr.getScopeID() == this.getScopeCount()) {
-
-   * Asif : This method returns the Region path for the independent RuntimeIterator if itr exists
-   * else returns null. It is the caller's responsibility to ensure that the passed Iterator is the
+   * This method returns the Region path for the independent RuntimeIterator if itr exists else
+   * returns null. It is the caller's responsibility to ensure that the passed Iterator is the
-   * @param riter
-   * <p>
-   * author Asif
-   * 
-   * @param itrDef
-   * @throws AmbiguousNameException
-   * @throws TypeMismatchException
-    this.computeUtlimateDependencies(itrDef, set);
-    RuntimeIterator itr = null;
+    this.computeUltimateDependencies(itrDef, set);
-      itr = itrDef.getRuntimeIterator(this);
+      RuntimeIterator itr = itrDef.getRuntimeIterator(this);
-  // General purpose caching methods for data that is only valid for one
-  // query execution
-  void cachePut(Object key, Object value) {
-    // throw new UnsupportedOperationException("Method should not have been called");
-  }
+  void cachePut(Object key, Object value) {}
-  public void addToSuccessfulBuckets(int bId) {
-    throw new UnsupportedOperationException("Method should not have been called");
-  }
-
-  public int[] getSuccessfulBuckets() {
-    throw new UnsupportedOperationException("Method should not have been called");
-  }
-

Merge branch 'develop' into feature/GEODE-7049

+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
-import org.apache.geode.cache.configuration.CacheElement;
-import org.apache.geode.cache.configuration.GatewayReceiverConfig;
-import org.apache.geode.cache.configuration.RegionConfig;
-import org.apache.geode.management.api.CorrespondWith;
-import org.apache.geode.management.api.RestfulEndpoint;
+import org.apache.geode.management.configuration.AbstractConfiguration;
+import org.apache.geode.management.configuration.GatewayReceiver;
+import org.apache.geode.management.configuration.GroupableConfiguration;
+import org.apache.geode.management.configuration.Index;
+import org.apache.geode.management.configuration.Region;
+import org.apache.geode.management.internal.configuration.mutators.IndexConfigManager;
-import org.apache.geode.management.internal.configuration.validators.CacheElementValidator;
+import org.apache.geode.management.internal.configuration.validators.CommonConfigurationValidator;
-  private final CacheElementValidator commonValidator;
+  private final CommonConfigurationValidator commonValidator;
-        new MemberValidator(cache, persistenceService), new CacheElementValidator(),
+        new MemberValidator(cache, persistenceService), new CommonConfigurationValidator(),
-    managers.put(RegionConfig.class, new RegionConfigManager());
+    managers.put(Region.class, new RegionConfigManager());
-    managers.put(GatewayReceiverConfig.class, new GatewayReceiverConfigManager(cache));
+    managers.put(GatewayReceiver.class, new GatewayReceiverConfigManager());
+    managers.put(Index.class, new IndexConfigManager());
-    validators.put(RegionConfig.class, new RegionConfigValidator(cache));
-    validators.put(GatewayReceiverConfig.class, new GatewayReceiverConfigValidator());
+    validators.put(Region.class, new RegionConfigValidator(cache));
+    validators.put(GatewayReceiver.class, new GatewayReceiverConfigValidator());
-      CacheElementValidator commonValidator,
+      CommonConfigurationValidator commonValidator,
-  public <T extends CacheElement> ClusterManagementRealizationResult create(T config) {
+  public <T extends AbstractConfiguration<?>> ClusterManagementRealizationResult create(T config) {
-    String group = config.getConfigGroup();
+    String group = config.getGroup();
+    final String groupName =
+        AbstractConfiguration.isCluster(group) ? AbstractConfiguration.CLUSTER : group;
-    final String finalGroup = group; // the below lambda requires a reference that is final
-    persistenceService.updateCacheConfig(finalGroup, cacheConfigForGroup -> {
+    persistenceService.updateCacheConfig(groupName, cacheConfigForGroup -> {
-            "Successfully updated configuration for " + finalGroup + ".");
+            "Successfully updated configuration for " + groupName + ".");
-        String message = "Failed to update cluster configuration for " + finalGroup + ".";
+        String message = "Failed to update cluster configuration for " + groupName + ".";
-    // add the config object which includes the HATOS information of the element created
-    if (result.isSuccessful() && config instanceof RestfulEndpoint) {
-      result.setUri(((RestfulEndpoint) config).getUri());
+    // add the config object which includes the HATEOAS information of the element created
+    if (result.isSuccessful()) {
+      result.setUri(config.getUri());
-  public <T extends CacheElement> ClusterManagementRealizationResult delete(
+  public <T extends AbstractConfiguration<?>> ClusterManagementRealizationResult delete(
-  public <T extends CacheElement> ClusterManagementRealizationResult update(
+  public <T extends AbstractConfiguration<?>> ClusterManagementRealizationResult update(
-  public <T extends CacheElement & CorrespondWith<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> list(
+  public <T extends AbstractConfiguration<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> list(
-      // gather elements on all the groups, consolidate the group information and then do the filter
-      // so that when we filter by a specific group, we still show that a particular element might
-      // also belong to another group.
-      for (String group : persistenceService.getGroups()) {
-        CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
-        List<T> listInGroup = manager.list(filter, currentPersistedConfig);
-        for (T element : listInGroup) {
-          element.setGroup(group);
-          resultList.add(element);
-        }
-      }
-
-      // if empty result, return immediately
-      if (resultList.size() == 0) {
-        return result;
-      }
-
-      // right now the list contains [{regionA, group1}, {regionA, group2}...], if the elements are
-      // MultiGroupCacheElement, we need to consolidate the list into [{regionA, [group1, group2]}
-      List<T> consolidatedResultList = new ArrayList<>();
-      for (T element : resultList) {
-        int index = consolidatedResultList.indexOf(element);
-        if (index >= 0) {
-          T exist = consolidatedResultList.get(index);
-          exist.addGroup(element.getGroup());
-        } else {
-          consolidatedResultList.add(element);
-        }
-      }
+      Set<String> groups;
-        consolidatedResultList = consolidatedResultList.stream()
-            .filter(e -> (e.getGroups().contains(filter.getConfigGroup())))
-            .collect(Collectors.toList());
+        groups = Collections.singleton(filter.getGroup());
+      } else {
+        groups = persistenceService.getGroups();
-      resultList = consolidatedResultList;
+
+      for (String group : groups) {
+        CacheConfig currentPersistedConfig =
+            persistenceService.getCacheConfig(
+                AbstractConfiguration.isCluster(group) ? AbstractConfiguration.CLUSTER : group,
+                true);
+        List<T> listInGroup = manager.list(filter, currentPersistedConfig);
+        if (!AbstractConfiguration.isCluster(group)) {
+          listInGroup.forEach(t -> {
+            if (t instanceof GroupableConfiguration) {
+              ((GroupableConfiguration<?>) t).setGroup(group);
+            }
+          });
+        }
+        resultList.addAll(listInGroup);
+      }
-    boolean hasRuntimeInfo = filter.hasRuntimeInfo();
+    boolean hasRuntimeInfo = hasRuntimeInfo(filter.getClass());
-      List<String> groups = element.getGroups();
-      // if "cluster" is the only group, clear it, so that the returning json does not show
-      // "cluster" as a group value
-      if (element.getGroups().size() == 1 && CacheElement.CLUSTER.equals(element.getGroup())) {
-        element.getGroups().clear();
-      }
-
-            memberValidator.findMembers(filter.getId(), filter.getGroups().toArray(new String[0]));
+            memberValidator.findMembers(filter.getId(), filter.getGroup());
-        members = memberValidator.findServers(groups.toArray(new String[0]));
+        members = memberValidator.findServers(element.getGroup());
-  public <T extends CacheElement & CorrespondWith<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> get(
+  public <T extends AbstractConfiguration<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> get(
-    result.setUri(RestfulEndpoint.URI_CONTEXT + RestfulEndpoint.URI_VERSION
+    result.setUri(AbstractConfiguration.URI_CONTEXT + AbstractConfiguration.URI_VERSION
-  private <T extends CacheElement> ConfigurationManager<T> getConfigurationManager(
+  private <T extends AbstractConfiguration> ConfigurationManager<T> getConfigurationManager(
+
+
+  /**
+   * for internal use only
+   */
+  @VisibleForTesting
+  Class<?> getRuntimeClass(Class<?> configClass) {
+    Type genericSuperclass = configClass.getGenericSuperclass();
+
+    if (genericSuperclass instanceof ParameterizedType) {
+      return (Class<?>) ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0];
+    }
+
+    return null;
+  }
+
+  @VisibleForTesting
+  boolean hasRuntimeInfo(Class<?> configClass) {
+    return !RuntimeInfo.class.equals(getRuntimeClass(configClass));
+  }
+

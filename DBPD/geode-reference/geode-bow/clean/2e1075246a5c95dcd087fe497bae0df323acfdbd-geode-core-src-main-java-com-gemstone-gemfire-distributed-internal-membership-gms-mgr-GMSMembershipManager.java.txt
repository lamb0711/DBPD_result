Merge branch 'release/1.0.0-incubating.M3'

+import java.util.concurrent.locks.Lock;
-import com.gemstone.gemfire.cache.server.CacheServer;
-  
+  private final Lock latestViewReadLock = latestViewLock.readLock();
+  private final Lock latestViewWriteLock = latestViewLock.writeLock();
+
-      "gemfire.shunned-member-timeout", 300).intValue();
+      DistributionConfig.GEMFIRE_PREFIX + "shunned-member-timeout", 300).intValue();
-   @since 5.0
+   @since GemFire 5.0
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    surpriseMemberTimeout = Integer.getInteger("gemfire.surprise-member-timeout", surpriseMemberTimeout).intValue();
+    surpriseMemberTimeout = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "surprise-member-timeout", surpriseMemberTimeout).intValue();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-            latestViewLock.writeLock().lock();
+            latestViewWriteLock.lock();
-              latestViewLock.writeLock().unlock();
+              latestViewWriteLock.unlock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    // First grab the lock: check the sender against our stabilized view.
-    latestViewLock.writeLock().lock();
-    try {
-      if (isShunned(m)) {
-        if (msg instanceof StartupMessage) {
-          endShun(m);
+    // If this member is shunned or new, grab the latestViewWriteLock: update the appropriate data structure.
+    //    synchronized (latestViewLock) {
+    if (isShunnedOrNew(m)) {
+      latestViewWriteLock.lock();
+      try {
+        if (isShunned(m)) {
+          if (msg instanceof StartupMessage) {
+            endShun(m);
+          } else {
+            // fix for bug 41538 - sick alert listener causes deadlock
+            // due to view latestViewReadWriteLock being held during messaging
+            shunned = true;
+          }
-        else {
-          // fix for bug 41538 - sick alert listener causes deadlock
-          // due to view lock being held during messaging
-          shunned = true;
+
+        if (!shunned) {
+          // If it's a new sender, wait our turn, generate the event
+          if (isNew(m)) {
+            shunned = !addSurpriseMember(m);
+          }
-      } // isShunned
-
-      if (!shunned) {
-        isNew = !latestView.contains(m) && !surpriseMembers.containsKey(m);
-
-        // If it's a new sender, wait our turn, generate the event
-        if (isNew) {
-          shunned = !addSurpriseMember(m);
-        } // isNew
+      } finally {
+        latestViewWriteLock.unlock();
-
-      // Latch the view before we unlock
-    } finally {
-      latestViewLock.writeLock().unlock();
-    
+
-      logger.info("Membership: Ignoring message from shunned member <{}>:{}", m, msg);
+      if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
+        logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: Ignoring message from shunned member <{}>:{}", m, msg);
+      }
-    
+
-  /**
-   * Process a new view object, or place on the startup queue
-   * @param viewArg the new view
-   */
+
+    /**
+     * Process a new view object, or place on the startup queue
+     * @param viewArg the new view
+     */
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-    latestViewLock.readLock().unlock();
+    latestViewReadLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-      latestViewLock.readLock().unlock();
+      latestViewReadLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-      latestViewLock.readLock().unlock();
+      latestViewReadLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-    latestViewLock.readLock().unlock();
+    latestViewReadLock.unlock();
-        latestViewLock.writeLock().lock();
+        latestViewWriteLock.lock();
-          latestViewLock.writeLock().unlock();
+          latestViewWriteLock.unlock();
-      if (!Boolean.getBoolean("gemfire.autoReconnect-useCacheXMLFile")
-          && !cache.isSqlfSystem() && !sharedConfigEnabled) {
+      if (!Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "autoReconnect-useCacheXMLFile")
+          && !sharedConfigEnabled) {
-      latestViewLock.writeLock().lock();
+      latestViewReadLock.lock();
-        latestViewLock.writeLock().unlock();
+        latestViewReadLock.unlock();
-        if (services.getCancelCriterion().cancelInProgress() != null) {
+        if (services.getCancelCriterion().isCancelInProgress()) {
-    if (services.getCancelCriterion().cancelInProgress() != null) {
+    if (services.getCancelCriterion().isCancelInProgress()) {
-      if(m != null) {
+      if (m != null) {
-          latestViewLock.readLock().lock();
+          latestViewReadLock.lock();
-            latestViewLock.readLock().unlock();
+            latestViewReadLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-    latestViewLock.writeLock().unlock();
+    latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-   * 
+   *
-    latestViewLock.writeLock().lock();
+    if (!shunnedMembers.containsKey(m)) {
+      return false;
+    }
+
+    latestViewWriteLock.lock();
-      if (!shunnedMembers.containsKey(m))
-        return false;
-      
-      if (shunTime + SHUNNED_SUNSET * 1000 > now)
+      if (shunTime + SHUNNED_SUNSET * 1000 > now) {
+      }
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
+  private final boolean isShunnedOrNew(final InternalDistributedMember m) {
+    latestViewReadLock.lock();
+    try {
+      return shunnedMembers.containsKey(m) || isNew(m);
+    } finally { // synchronized
+      latestViewReadLock.unlock();
+    }
+  }
+
+  // must be invoked under view read or write lock
+  private final boolean isNew(final InternalDistributedMember m) {
+    return !latestView.contains(m) && !surpriseMembers.containsKey(m);
+  }
+
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-      latestViewLock.readLock().unlock();
+      latestViewReadLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-        latestViewLock.readLock().lock();
+        latestViewReadLock.lock();
-          latestViewLock.readLock().unlock();
+          latestViewReadLock.unlock();
-        && services.getCancelCriterion().cancelInProgress()==null );
+        && !services.getCancelCriterion().isCancelInProgress());
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();

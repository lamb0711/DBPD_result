GEODE-17: more cleanup

* break the cirucular dependency in MBeanServerWrapper and ManagementInterceptor
* Now custom authenticator and authorizer can be set independant of each other
* re-arrange the tests
* add test to test local JMX calls to make sure they don't go through the MBeanServerWrapper

Merge branch 'feature/GEODE-17-2' of https://git-wip-us.apache.org/repos/asf/incubator-geode into feature/GEODE-17-2

-import com.gemstone.gemfire.cache.operations.OperationContext.OperationCode;
+import javax.management.Query;
-import java.util.HashSet;
-import static com.gemstone.gemfire.management.internal.security.ResourceConstants.ACCESS_DENIED_MESSAGE;
-
- *
- *
- * @author tushark
-  
+
-  
+
+    // allow operations which requires no permissions
+    if(context == null)
+      return;
+
+    if(context == null)
+      return;
+
-      InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException, NotCompliantMBeanException {
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+      InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException {
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException,
+      throws ReflectionException, InstanceAlreadyExistsException, MBeanException,
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException,
+      throws ReflectionException, InstanceAlreadyExistsException, MBeanException,
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      String[] signature) throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException,
+      String[] signature) throws ReflectionException, InstanceAlreadyExistsException,
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
+  private static QueryExp notAccessControlMBean = Query.not(Query.isInstanceOf(Query.value(AccessControlMXBean.class.getName())));
-    ResourceOperationContext ctx = new ResourceOperationContext(Resource.MBEAN, OperationCode.QUERY);
-    return filterAccessControlMBeanInstance(mbs.queryMBeans(name, query));
-  }
-
-  private Set<ObjectInstance> filterAccessControlMBeanInstance(Set<ObjectInstance> queryMBeans) {
-    Set<ObjectInstance> set = new HashSet<ObjectInstance>();
-    for(ObjectInstance oi : queryMBeans) {
-      if(!oi.getObjectName().equals(interceptor.getAccessControlMBeanON())){
-        set.add(oi);
-      }
-    }
-    return set;
+    // We need to filter out the AccessControlMXBean so that the clients wouldn't see it
+    if(query!=null)
+      return mbs.queryMBeans(name, Query.and(query, notAccessControlMBean));
+    else
+      return mbs.queryMBeans(name,notAccessControlMBean);
-    return filterAccessControlMBean(mbs.queryNames(name, query));
-  }
-
-  private Set<ObjectName> filterAccessControlMBean(Set<ObjectName> queryNames) {
-    Set<ObjectName> set = new HashSet<ObjectName>();
-    for(ObjectName oi : queryNames) {
-      if(!oi.equals(interceptor.getAccessControlMBeanON())){
-        set.add(oi);
-      }
-    }
-    return set;
+    if(query!=null)
+      return mbs.queryNames(name, Query.and(query, notAccessControlMBean));
+    else
+      return mbs.queryNames(name,notAccessControlMBean);
-    ctx.setPostOperationResult(result);
+    if(ctx != null) {
+      ctx.setPostOperationResult(result);
+    }
-    ctx.setPostOperationResult(result);
+    if(ctx!=null)
+      ctx.setPostOperationResult(result);
-    // Initialize the context with the default value
-    ResourceOperationContext result = new ResourceOperationContext(Resource.DEFAULT, OperationCode.LIST_DS);
+    // If there is no annotation defined either in the class level or method level, we should consider this operation/attribute freely accessible
+    ResourceOperationContext result = null;
+  public ManagementInterceptor getInterceptor() {
+    return interceptor;
+  }
+

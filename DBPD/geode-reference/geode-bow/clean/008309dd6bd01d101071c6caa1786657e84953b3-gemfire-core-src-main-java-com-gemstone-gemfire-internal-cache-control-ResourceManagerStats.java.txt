Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import com.gemstone.gemfire.internal.Assert;
+  private static final int autoRebalanceAttemptsId;
+  private static final int offHeapCriticalEventsId;
+  private static final int offHeapSafeEventsId;
-  private static final int evictMoreEventsId;
+  private static final int offHeapEvictionStartEventsId;
+  private static final int offHeapEvictionStopEventsId;
+  private static final int offHeapCriticalThresholdId;
+  private static final int offHeapEvictionThresholdId;
+            f.createIntCounter(
+                "autoRebalanceAttempts",
+                "Total number of cache auto-rebalance attempts.",
+                "operations"),
+                "offHeapCriticalEvents",
+                "Total number of times off-heap usage went over critical threshold.",
+                "events"),
+            f.createIntGauge(
+                "offHeapSafeEvents", 
+                "Total number of times off-heap usage fell below critical threshold.",
+                "events"),
+            f.createIntGauge(
-            f.createIntCounter(
-                "evictMoreEvents",
-                "Total number of times evict more event was delivered",
+            f.createIntGauge(
+                "offHeapEvictionStartEvents",
+                "Total number of times off-heap usage went over eviction threshold.",
+            f.createIntGauge(
+                "offHeapEvictionStopEvents",
+                "Total number of times off-heap usage fell below eviction threshold.",
+                "events"),
-                "The currently set critical threshold value in bytes",
+                "The currently set heap critical threshold value in bytes",
+                "bytes"),
+            f.createLongGauge(
+                "offHeapCriticalThreshold",
+                "The currently set off-heap critical threshold value in bytes",
-                "The currently set eviction threshold value in bytes",
+                "The currently set heap eviction threshold value in bytes",
+                "offHeapEvictionThreshold", 
+                "The currently set off-heap eviction threshold value in bytes",
+                "bytes"),            
+            f.createLongGauge(
+    autoRebalanceAttemptsId = type.nameToId("autoRebalanceAttempts");
+    offHeapCriticalEventsId = type.nameToId("offHeapCriticalEvents");
+    offHeapSafeEventsId = type.nameToId("offHeapSafeEvents");
-    evictMoreEventsId = type.nameToId("evictMoreEvents");
+    offHeapEvictionStartEventsId = type.nameToId("offHeapEvictionStartEvents");
+    offHeapEvictionStopEventsId = type.nameToId("offHeapEvictionStopEvents");
+    offHeapCriticalThresholdId = type.nameToId("offHeapCriticalThreshold");
+    offHeapEvictionThresholdId = type.nameToId("offHeapEvictionThreshold");
+  public void incAutoRebalanceAttempts() {
+    this.stats.incInt(autoRebalanceAttemptsId, 1);
+  }
+  
+  public int getAutoRebalanceAttempts() {
+    return this.stats.getInt(autoRebalanceAttemptsId);
+  }
-
+  
+  public void incOffHeapCriticalEvents() {
+    this.stats.incInt(offHeapCriticalEventsId, 1);
+  }
+  
+  public int getOffHeapCriticalEvents() {
+    return this.stats.getInt(offHeapCriticalEventsId);
+  }
+  
+  public void incOffHeapSafeEvents() {
+    this.stats.incInt(offHeapSafeEventsId, 1);
+  }
+  
+  public int getOffHeapSafeEvents() {
+    return this.stats.getInt(offHeapSafeEventsId);
+  }
+  
-
-  public void incEvictMoreEvents() {
-    this.stats.incInt(evictMoreEventsId, 1);
+  
+  public void incOffHeapEvictionStartEvents() {
+    this.stats.incInt(offHeapEvictionStartEventsId, 1);
-
-  public int getEvictMoreEvents() {
-    return this.stats.getInt(evictMoreEventsId);
+  
+  public int getOffHeapEvictionStartEvents() {
+    return this.stats.getInt(offHeapEvictionStartEventsId);
-
+  
+  public void incOffHeapEvictionStopEvents() {
+    this.stats.incInt(offHeapEvictionStopEventsId, 1);
+  }
+  
+  public int getOffHeapEvictionStopEvents() {
+    return this.stats.getInt(offHeapEvictionStopEventsId);
+  }
+  
+  public void changeOffHeapCriticalThreshold(long newValue) {
+    this.stats.setLong(offHeapCriticalThresholdId, newValue);
+  }
+  
+  public long getOffHeapCriticalThreshold() {
+    return this.stats.getLong(offHeapCriticalThresholdId);    
+  }
+  
+  public void changeOffHeapEvictionThreshold(long newValue) {
+    this.stats.setLong(offHeapEvictionThresholdId, newValue);
+  }
+  
+  public long getOffHeapEvictionThreshold() {
+    return this.stats.getLong(offHeapEvictionThresholdId);
+  }
+  
+      @Override
+      @Override
+      @Override
+      @Override
+      @Override

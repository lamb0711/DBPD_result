Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Used to keep track of what interest a client has registered.
- * This code was extracted from the old ConnectionProxyImpl.
+ * Used to keep track of what interest a client has registered. This code was extracted from the old
+ * ConnectionProxyImpl.
+ * 
-  
+
-  
+
-  
+
-  private final ConcurrentMap cqs /* <CqQuery,Boolean> */= new ConcurrentHashMap();
-  
+  private final ConcurrentMap cqs /* <CqQuery,Boolean> */ = new ConcurrentHashMap();
+
-  
+
-  
-  public List getInterestList(String regionName, int interestType)
-  {
+
+  public List getInterestList(String regionName, int interestType) {
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-      InterestResultPolicy pol, boolean isDurable, boolean receiveUpdatesAsInvalidates)
-  {
-    RegionInterestEntry rie = getRegionInterests(r, interestType, false,
-        isDurable, receiveUpdatesAsInvalidates);
+      InterestResultPolicy pol, boolean isDurable, boolean receiveUpdatesAsInvalidates) {
+    RegionInterestEntry rie =
+        getRegionInterests(r, interestType, false, isDurable, receiveUpdatesAsInvalidates);
-  public boolean removeSingleInterest(LocalRegion r, Object key,
-      int interestType, boolean isDurable, boolean receiveUpdatesAsInvalidates)
-  {
-    RegionInterestEntry rie = getRegionInterests(r, interestType, true,
-        isDurable, receiveUpdatesAsInvalidates);
+  public boolean removeSingleInterest(LocalRegion r, Object key, int interestType,
+      boolean isDurable, boolean receiveUpdatesAsInvalidates) {
+    RegionInterestEntry rie =
+        getRegionInterests(r, interestType, true, isDurable, receiveUpdatesAsInvalidates);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.RegisterInterestTracker_REMOVESINGLEINTEREST_KEY_0_NOT_REGISTERED_IN_THE_CLIENT, key));
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.RegisterInterestTracker_REMOVESINGLEINTEREST_KEY_0_NOT_REGISTERED_IN_THE_CLIENT,
+          key));
-    }
-    else {
+    } else {
-    //return rie.getInterests().remove(key) != null;
+    // return rie.getInterests().remove(key) != null;
-  public void addInterestList(LocalRegion r, List keys,
-      InterestResultPolicy pol, boolean isDurable, boolean receiveUpdatesAsInvalidates)
-  {
-    RegionInterestEntry rie = getRegionInterests(r, InterestType.KEY, false,
-        isDurable, receiveUpdatesAsInvalidates);
+  public void addInterestList(LocalRegion r, List keys, InterestResultPolicy pol, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates) {
+    RegionInterestEntry rie =
+        getRegionInterests(r, InterestType.KEY, false, isDurable, receiveUpdatesAsInvalidates);
-  public void addCq(InternalCqQuery cqi, boolean isDurable)
-  {
+  public void addCq(InternalCqQuery cqi, boolean isDurable) {
-    RegionInterestEntry rie = getRegionInterests(r, InterestType.CQ, false, isDurable);
-      rie.getInterests().put(cqi.getName(), cqi);
-      */
-  }
-  
-  public void removeCq(InternalCqQuery cqi, boolean isDurable)
-  {
-    this.cqs.remove(cqi);
-    /*
-    RegionInterestEntry rie = getRegionInterests(r, InterestType.CQ, false, isDurable);
-      rie.getInterests().remove(cqi.getName());
-      */
+     * RegionInterestEntry rie = getRegionInterests(r, InterestType.CQ, false, isDurable);
+     * rie.getInterests().put(cqi.getName(), cqi);
+     */
-  public Map getCqsMap(){
+  public void removeCq(InternalCqQuery cqi, boolean isDurable) {
+    this.cqs.remove(cqi);
+    /*
+     * RegionInterestEntry rie = getRegionInterests(r, InterestType.CQ, false, isDurable);
+     * rie.getInterests().remove(cqi.getName());
+     */
+  }
+
+  public Map getCqsMap() {
-  
+
-  public void unregisterRegion(ServerRegionProxy srp,
-                               boolean keepalive) {
+  public void unregisterRegion(ServerRegionProxy srp, boolean keepalive) {
-    //durable
+    // durable
-  
+
-   * @param interestType
-   *          the interest type
-   * @param durable
-   *          a boolean stating whether to remove durable or non-durable registrations
+   * 
+   * @param interestType the interest type
+   * @param durable a boolean stating whether to remove durable or non-durable registrations
-  private void removeAllInterests(ServerRegionProxy srp, int interestType,
-      boolean durable, boolean keepAlive, boolean receiveUpdatesAsInvalidates)
-  {
+  private void removeAllInterests(ServerRegionProxy srp, int interestType, boolean durable,
+      boolean keepAlive, boolean receiveUpdatesAsInvalidates) {
-    ConcurrentMap allInterests = getRegionToInterestsMap(interestType, durable, receiveUpdatesAsInvalidates);
+    ConcurrentMap allInterests =
+        getRegionToInterestsMap(interestType, durable, receiveUpdatesAsInvalidates);
-        logger.debug("removeAllInterests region={} type={}", regName, InterestType.getString(interestType));
+        logger.debug("removeAllInterests region={} type={}", regName,
+            InterestType.getString(interestType));
-        UnregisterInterestOp.execute(srp.getPool(), regName, key, interestType,
-                                     true/*isClosing*/, keepAlive);
-      }
-      catch (Exception e) {
+        UnregisterInterestOp.execute(srp.getPool(), regName, key, interestType, true/* isClosing */,
+            keepAlive);
+      } catch (Exception e) {
-              new Object[] {regName, InterestType.getString(interestType), e.getLocalizedMessage()}));
+              new Object[] {regName, InterestType.getString(interestType),
+                  e.getLocalizedMessage()}));
-      boolean receiveUpdatesAsInvalidates)
-  {
-    RegionInterestEntry rie = getRegionInterests(r, InterestType.KEY, true,
-        isDurable, receiveUpdatesAsInvalidates);
+      boolean receiveUpdatesAsInvalidates) {
+    RegionInterestEntry rie =
+        getRegionInterests(r, InterestType.KEY, true, isDurable, receiveUpdatesAsInvalidates);
-      }
-      else {
+      } else {
-   * Return keys of interest for a given region. The keys in this Map are the
-   * full names of the regions. The values are instances of RegionInterestEntry.
+   * Return keys of interest for a given region. The keys in this Map are the full names of the
+   * regions. The values are instances of RegionInterestEntry.
-   * @param interestType
-   *          the type to return
+   * @param interestType the type to return
-      boolean receiveUpdatesAsInvalidates)
-  {
+      boolean receiveUpdatesAsInvalidates) {
-      this.fils[getInterestLookupIndex(isDurable, receiveUpdatesAsInvalidates)];
-    
+        this.fils[getInterestLookupIndex(isDurable, receiveUpdatesAsInvalidates)];
+
-    
+
-    case InterestType.KEY:
-      mapOfInterest = fil.keysOfInterest;
-      break;
-    case InterestType.REGULAR_EXPRESSION:
-      mapOfInterest = fil.regexOfInterest;
-      break;
-    case InterestType.FILTER_CLASS:
-      mapOfInterest = fil.filtersOfInterest;
-      break;
-    case InterestType.CQ:
-      mapOfInterest = fil.cqsOfInterest;
-      break;
-    case InterestType.OQL_QUERY:
-      mapOfInterest = fil.queriesOfInterest;
-      break;
-    default:
-      throw new InternalGemFireError("Unknown interestType");
+      case InterestType.KEY:
+        mapOfInterest = fil.keysOfInterest;
+        break;
+      case InterestType.REGULAR_EXPRESSION:
+        mapOfInterest = fil.regexOfInterest;
+        break;
+      case InterestType.FILTER_CLASS:
+        mapOfInterest = fil.filtersOfInterest;
+        break;
+      case InterestType.CQ:
+        mapOfInterest = fil.cqsOfInterest;
+        break;
+      case InterestType.OQL_QUERY:
+        mapOfInterest = fil.queriesOfInterest;
+        break;
+      default:
+        throw new InternalGemFireError("Unknown interestType");
-   * Return the RegionInterestEntry for the given region. Create one if none
-   * exists and forRemoval is false.
+   * Return the RegionInterestEntry for the given region. Create one if none exists and forRemoval
+   * is false.
-   * @param r
-   *          specified region
-   * @param interestType
-   *          desired interest type
-   * @param forRemoval
-   *          true if calls wants one for removal
+   * @param r specified region
+   * @param interestType desired interest type
+   * @param forRemoval true if calls wants one for removal
-  private RegionInterestEntry getRegionInterests(LocalRegion r,
-                                                 int interestType,
-                                                 boolean forRemoval,
-                                                 boolean isDurable,
-                                                 boolean receiveUpdatesAsInvalidates)
-  {
+  private RegionInterestEntry getRegionInterests(LocalRegion r, int interestType,
+      boolean forRemoval, boolean isDurable, boolean receiveUpdatesAsInvalidates) {
-    ConcurrentMap mapOfInterest = getRegionToInterestsMap(interestType, isDurable, receiveUpdatesAsInvalidates);
-    RegionInterestEntry result = (RegionInterestEntry)
-      mapOfInterest.get(regionName);
+    ConcurrentMap mapOfInterest =
+        getRegionToInterestsMap(interestType, isDurable, receiveUpdatesAsInvalidates);
+    RegionInterestEntry result = (RegionInterestEntry) mapOfInterest.get(regionName);
-      result = (RegionInterestEntry)mapOfInterest.putIfAbsent(regionName, rie);
+      result = (RegionInterestEntry) mapOfInterest.putIfAbsent(regionName, rie);
-  private RegionInterestEntry readRegionInterests(String regionName,
-                                                  int interestType,
-                                                  boolean isDurable,
-                                                  boolean receiveUpdatesAsInvalidates)
-  {
-    ConcurrentMap mapOfInterest = getRegionToInterestsMap(interestType, isDurable, receiveUpdatesAsInvalidates);
-    return (RegionInterestEntry)mapOfInterest.get(regionName);
+
+  private RegionInterestEntry readRegionInterests(String regionName, int interestType,
+      boolean isDurable, boolean receiveUpdatesAsInvalidates) {
+    ConcurrentMap mapOfInterest =
+        getRegionToInterestsMap(interestType, isDurable, receiveUpdatesAsInvalidates);
+    return (RegionInterestEntry) mapOfInterest.get(regionName);
-   * A Holder object for client's register interest, this is required when 
-   * a client fails over to another server and does register interest based on 
-   * this Data structure 
+   * A Holder object for client's register interest, this is required when a client fails over to
+   * another server and does register interest based on this Data structure
-   static protected class FailoverInterestList {
+  static protected class FailoverInterestList {
-     * This list is maintained here in case an endpoint (server) bounces. In that
-     * case, a message will be sent to the endpoint as soon as it has restarted.
+     * This list is maintained here in case an endpoint (server) bounces. In that case, a message
+     * will be sent to the endpoint as soon as it has restarted.
-     * The keys in this Map are the full names of the regions. The values are
-     * instances of {@link RegionInterestEntry}.
+     * The keys in this Map are the full names of the regions. The values are instances of
+     * {@link RegionInterestEntry}.
-     * This list is maintained here in case an endpoint (server) bounces. In that
-     * case, a message will be sent to the endpoint as soon as it has restarted.
+     * This list is maintained here in case an endpoint (server) bounces. In that case, a message
+     * will be sent to the endpoint as soon as it has restarted.
-     * The keys in this Map are the full names of the regions. The values are
-     * instances of {@link RegionInterestEntry}.
+     * The keys in this Map are the full names of the regions. The values are instances of
+     * {@link RegionInterestEntry}.
-     final ConcurrentMap regexOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap regexOfInterest = new ConcurrentHashMap();
-     * This list is maintained here in case an endpoint (server) bounces. In that
-     * case, a message will be sent to the endpoint as soon as it has restarted.
+     * This list is maintained here in case an endpoint (server) bounces. In that case, a message
+     * will be sent to the endpoint as soon as it has restarted.
-     * The keys in this Map are the full names of the regions. The values are
-     * instances of {@link RegionInterestEntry}.
+     * The keys in this Map are the full names of the regions. The values are instances of
+     * {@link RegionInterestEntry}.
-     final ConcurrentMap filtersOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap filtersOfInterest = new ConcurrentHashMap();
-     * This list is maintained here in case an endpoint (server) bounces. In that
-     * case, a message will be sent to the endpoint as soon as it has restarted.
+     * This list is maintained here in case an endpoint (server) bounces. In that case, a message
+     * will be sent to the endpoint as soon as it has restarted.
-     * The keys in this Map are the full names of the regions. The values are
-     * instances of {@link RegionInterestEntry}.
+     * The keys in this Map are the full names of the regions. The values are instances of
+     * {@link RegionInterestEntry}.
-     final ConcurrentMap queriesOfInterest = new ConcurrentHashMap();
-     
-     /**
-      * Record of registered CQs
-      *
-      */
-      final ConcurrentMap cqsOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap queriesOfInterest = new ConcurrentHashMap();
+
+    /**
+     * Record of registered CQs
+     *
+     */
+    final ConcurrentMap cqsOfInterest = new ConcurrentHashMap();
-  static public class RegionInterestEntry
-  {
+  static public class RegionInterestEntry {

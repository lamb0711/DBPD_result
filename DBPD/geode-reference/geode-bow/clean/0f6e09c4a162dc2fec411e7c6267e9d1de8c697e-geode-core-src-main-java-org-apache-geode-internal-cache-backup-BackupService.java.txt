GEODE-3800: Replace BackupManager with BackupService (#1372)

* GEODE-3800: Convert backups into a service
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicReference;
-import org.apache.geode.distributed.internal.DistributionManager;
-public class BackupManager {
+public class BackupService {
-  private final InternalDistributedMember sender;
-  private BackupTask task;
-  private Future<HashSet<PersistentID>> taskFuture;
+  private transient Future<HashSet<PersistentID>> taskFuture;
+  final AtomicReference<BackupTask> currentTask = new AtomicReference<>();
-  public BackupManager(InternalDistributedMember sender, InternalCache cache) {
+  public BackupService(InternalCache cache) {
-    this.sender = sender;
-    LoggingThreadGroup group = LoggingThreadGroup.createThreadGroup("BackupManager Thread", logger);
+    LoggingThreadGroup group = LoggingThreadGroup.createThreadGroup("BackupService Thread", logger);
-            new Thread(group, command, "BackupManagerThread" + this.threadId.incrementAndGet());
+            new Thread(group, command, "BackupServiceThread" + this.threadId.incrementAndGet());
-  public void startBackup() {
-    task = new BackupTask(cache);
-    taskFuture = executor.submit(task::backup);
+  public HashSet<PersistentID> prepareBackup(InternalDistributedMember sender)
+      throws IOException, InterruptedException {
+    validateRequestingAdmin(sender);
+    BackupTask backupTask = new BackupTask(cache);
+    if (!currentTask.compareAndSet(null, backupTask)) {
+      throw new IOException("Another backup already in progress");
+    }
+    taskFuture = executor.submit(() -> backupTask.backup());
+    return backupTask.awaitLockAcquisition();
-  public HashSet<PersistentID> getDiskStoreIdsToBackup() throws InterruptedException {
-    return task.awaitLockAcquisition();
-  }
-
-  public HashSet<PersistentID> doBackup(File targetDir, File baselineDir, boolean abort) {
+  public HashSet<PersistentID> doBackup(File targetDir, File baselineDir, boolean abort)
+      throws IOException {
+    BackupTask task = currentTask.get();
+    if (task == null) {
+      if (abort) {
+        return new HashSet<>();
+      }
+      throw new IOException("No backup currently in progress");
+    }
+    } finally {
+      cleanup();
-    task.waitForBackup();
+    BackupTask task = currentTask.get();
+    if (task != null) {
+      task.waitTillBackupFilesAreCopiedToTemporaryLocation();
+    }
-    return task.getBackupForDiskStore(diskStore);
+    BackupTask task = currentTask.get();
+    return task == null ? null : task.getBackupForDiskStore(diskStore);
-  public void validateRequestingAdmin() {
+  void validateRequestingAdmin(InternalDistributedMember sender) {
-    Set allIds = getDistributionManager().addAllMembershipListenerAndGetAllIds(membershipListener);
+    Set allIds =
+        cache.getDistributionManager().addAllMembershipListenerAndGetAllIds(membershipListener);
-  private void cleanup() {
-    getDistributionManager().removeAllMembershipListener(membershipListener);
-    cache.clearBackupManager();
-  }
-
-  private DistributionManager getDistributionManager() {
-    return cache.getInternalDistributedSystem().getDistributionManager();
+  void cleanup() {
+    cache.getDistributionManager().removeAllMembershipListener(membershipListener);
+    currentTask.set(null);

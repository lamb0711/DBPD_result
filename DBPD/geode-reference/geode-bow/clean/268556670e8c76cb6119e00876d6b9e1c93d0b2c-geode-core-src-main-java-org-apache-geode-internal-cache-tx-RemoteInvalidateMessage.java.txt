GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Iterator;
+import org.apache.geode.cache.RegionDestroyedException;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+/**
+ * This message is used by transactions to invalidate an entry on a transaction hosted on a remote
+ * member. It is also used by non-transactional region invalidates that need to generate a
+ * VersionTag on a remote member.
+ */
-  private RemoteInvalidateMessage(Set recipients, String regionPath, DirectReplyProcessor processor,
-      EntryEventImpl event, boolean useOriginRemote, boolean possibleDuplicate) {
-    super(recipients, regionPath, processor, event, null,
-        ClusterDistributionManager.PARTITIONED_REGION_EXECUTOR, useOriginRemote, possibleDuplicate);
+  private RemoteInvalidateMessage(DistributedMember recipient, String regionPath,
+      DirectReplyProcessor processor, EntryEventImpl event, boolean useOriginRemote,
+      boolean possibleDuplicate) {
+    super(recipient, regionPath, processor, event, null, useOriginRemote, possibleDuplicate);
+  @SuppressWarnings("unchecked")
-    Collection replicates = onlyPersistent
+    Collection<InternalDistributedMember> replicates = onlyPersistent
-      ArrayList l = new ArrayList(replicates);
+      ArrayList<InternalDistributedMember> l = new ArrayList<>(replicates);
-    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      InternalDistributedMember replicate = it.next();
+    for (InternalDistributedMember replicate : replicates) {
-        InvalidateResponse processor = send(replicate, event.getRegion(), event,
-            ClusterDistributionManager.SERIAL_EXECUTOR, false, posDup);
-        processor.waitForCacheException();
-        VersionTag versionTag = processor.getVersionTag();
+        InvalidateResponse processor = send(replicate, event.getRegion(), event, false, posDup);
+        processor.waitForRemoteResponse();
+        VersionTag<?> versionTag = processor.getVersionTag();
-          logger.debug("RemoteDestroyMessage caught CacheException during distribution", e);
+          logger.debug("RemoteInvalidateMessage caught CacheException during distribution", e);
-      } catch (RemoteOperationException e) {
+      } catch (RegionDestroyedException | RemoteOperationException e) {
-              "RemoteDestroyMessage caught an unexpected exception during distribution", e);
+              "RemoteInvalidateMessage caught an exception during distribution; retrying to another member",
+              e);
-   * @param processorType the type of executor to use
-      EntryEventImpl event, int processorType, boolean useOriginRemote, boolean possibleDuplicate)
+      EntryEventImpl event, boolean useOriginRemote, boolean possibleDuplicate)
-    // Assert.assertTrue(recipient != null, "RemoteInvalidateMessage NULL recipient"); recipient may
-    // be null for remote notifications
-    Set recipients = Collections.singleton(recipient);
-    InvalidateResponse p = new InvalidateResponse(r.getSystem(), recipients, event.getKey());
-    RemoteInvalidateMessage m = new RemoteInvalidateMessage(recipients, r.getFullPath(), p, event,
+    InvalidateResponse p = new InvalidateResponse(r.getSystem(), recipient, event.getKey());
+    RemoteInvalidateMessage m = new RemoteInvalidateMessage(recipient, r.getFullPath(), p, event,
-    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
-   * It is very important that this message does NOT cause any deadlocks as the sender will wait
-   * indefinitely for the acknowledgement
-   *
-   * @throws EntryExistsException
+   * This method is called upon receipt and make the desired changes to the region. Note: It is very
+   * important that this message does NOT cause any deadlocks as the sender will wait indefinitely
+   * for the acknowledgement
-      } catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        return false;
-
-  // override reply processor type from PartitionMessage
-  RemoteOperationResponse createReplyProcessor(PartitionedRegion r, Set recipients, Object key) {
-    return new InvalidateResponse(r.getSystem(), recipients, key);
-  }
-
-  // override reply message type from PartitionMessage
-      ReplyException ex, LocalRegion r, VersionTag versionTag, long startTime) {
-    /*
-     * if (pr != null && startTime > 0) { pr.getPrStats().endPartitionMessagesProcessing(startTime);
-     * }
-     */
+      ReplyException ex, LocalRegion r, VersionTag<?> versionTag, long startTime) {
-    private VersionTag versionTag;
+    private VersionTag<?> versionTag;
-    private InvalidateReplyMessage(int processorId, VersionTag versionTag, ReplyException ex) {
+    private InvalidateReplyMessage(int processorId, VersionTag<?> versionTag, ReplyException ex) {
-        ReplySender replySender, VersionTag versionTag, ReplyException ex) {
+        ReplySender replySender, VersionTag<?> versionTag, ReplyException ex) {
-    VersionTag versionTag;
+    VersionTag<?> versionTag;
-    public InvalidateResponse(InternalDistributedSystem ds, Set recipients, Object key) {
-      super(ds, recipients, true);
+    public InvalidateResponse(InternalDistributedSystem ds, DistributedMember recipient,
+        Object key) {
+      super(ds, (InternalDistributedMember) recipient, true);
-    public void setResponse(VersionTag versionTag) {
+    public void setResponse(VersionTag<?> versionTag) {
-      try {
-        waitForCacheException();
-      } catch (RemoteOperationException e) {
-        e.checkKey(key);
-        throw e;
-      }
+      waitForRemoteResponse();
-    public VersionTag getVersionTag() {
+    public VersionTag<?> getVersionTag() {
-
-
-

Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.GemFireIOException;
+import com.gemstone.gemfire.internal.cache.CustomEvictionAttributesImpl;
+    this.regionAttributes.customEvictionAttributes = regionAttributes
+        .getCustomEvictionAttributes();
+    this.regionAttributes.offHeap = regionAttributes.getOffHeap();
-    if (cacheLoader != null) {
-      if (AbstractRegion.isBridgeLoader(cacheLoader) && this.regionAttributes.getPoolName() != null) {
-        throw new IllegalStateException("A region with a pool name can not have a BridgeLoader or BridgeClient. Please use pools OR BridgeClient.");
-      }
-    }
-    if (cacheWriter != null) {
-      if (AbstractRegion.isBridgeWriter(cacheWriter) &&  this.regionAttributes.getPoolName() != null) {
-        throw new IllegalStateException("A region with a pool name can not have a BridgeWriter or BridgeClient. Please use pools OR BridgeClient.");
-      }
-    }
-  /** Sets the mirror type for the next <code>RegionAttributes</code> created.
+  /**
+   * Set custom {@link EvictionCriteria} for the region with start time and
+   * frequency of evictor task to be run in milliseconds, or evict incoming rows
+   * in case both start and frequency are specified as zero.
+   * 
+   * @param criteria
+   *          an {@link EvictionCriteria} to be used for eviction for HDFS
+   *          persistent regions
+   * @param start
+   *          the start time at which periodic evictor task should be first
+   *          fired to apply the provided {@link EvictionCriteria}; if this is
+   *          zero then current time is used for the first invocation of evictor
+   * @param interval
+   *          the periodic frequency at which to run the evictor task after the
+   *          initial start; if this is if both start and frequency are zero
+   *          then {@link EvictionCriteria} is applied on incoming insert/update
+   *          to determine whether it is to be retained
+   */
+  public void setCustomEvictionAttributes(EvictionCriteria<K, V> criteria,
+      long start, long interval) {
+    this.regionAttributes.customEvictionAttributes =
+        new CustomEvictionAttributesImpl(criteria, start, interval,
+            start == 0 && interval == 0);
+    this.regionAttributes.setHasCustomEviction(true);
+  }
+
+   /** Sets the mirror type for the next <code>RegionAttributes</code> created.
-   * @throws IllegalArgumentException if a directory does not exist
+   * @throws GemFireIOException if a directory does not exist
+      
+      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).setOffHeap(this.regionAttributes.offHeap);
-   * @throws IllegalStateException if a cache loader or cache writer has already
-   * been set.
-    if (nm != null) {
-      // make sure a cache listener or writer has not already been installed
-      if (this.regionAttributes.getCacheLoader() != null 
-          && AbstractRegion.isBridgeLoader(this.regionAttributes.getCacheLoader())) {
-        throw new IllegalStateException("A region with a bridge loader can not have a pool name.");
-      }
-      if (this.regionAttributes.getCacheWriter() != null 
-          && AbstractRegion.isBridgeWriter(this.regionAttributes.getCacheWriter())) {
-        throw new IllegalStateException("A region with a bridge writer can not have a pool name.");
-      }
-    }
+  /**
+   * Enables this region's usage of off-heap memory if true.
+   * @since 9.0
+   * @param offHeap boolean flag to enable off-heap memory
+   */
+  public void setOffHeap(boolean offHeap) {
+    this.regionAttributes.offHeap = offHeap;
+    this.regionAttributes.setHasOffHeap(true);
+    
+    if (this.regionAttributes.partitionAttributes != null) {
+      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).setOffHeap(offHeap);
+    }
+  }
+  
+      // fix bug #52033 by invoking setOffHeap now (localMaxMemory may now be the temporary placeholder for off-heap until DistributedSystem is created
+      ((PartitionAttributesImpl)this.regionAttributes.partitionAttributes).setOffHeap(this.regionAttributes.getOffHeap());
+    
+    if (attrs.getHDFSStoreName() != null) {
+      if (!attrs.getDataPolicy().withHDFS() && (attrs.getPartitionAttributes() == null || attrs.getPartitionAttributes().getLocalMaxMemory() != 0)) {
+        throw new IllegalStateException(LocalizedStrings.HDFSSTORE_IS_USED_IN_NONHDFS_REGION.toLocalizedString());        
+      }
+    }
-    if (attrs.getPoolName() != null) {
-      if (attrs.getCacheLoader() != null && AbstractRegion.isBridgeLoader(attrs.getCacheLoader())) {
-        throw new IllegalStateException("A region with a pool name can not have a BridgeLoader or BridgeClient. Please use pools OR BridgeClient.");
-      }
-      if (attrs.getCacheWriter() != null && AbstractRegion.isBridgeWriter(attrs.getCacheWriter())) {
-        throw new IllegalStateException("A region with a pool name can not have a BridgeWriter or BridgeClient. Please use pools OR BridgeClient.");
-      }
-    }
-      if ((regionIdleTimeout.getAction().isInvalidate() && regionIdleTimeout.getTimeout() > 0)
-          || (regionIdleTimeout.getAction().isLocalInvalidate() && regionIdleTimeout.getTimeout() > 0)
-          || (regionTimeToLive.getAction().isInvalidate() && regionTimeToLive.getTimeout() > 0)
-          || (regionTimeToLive.getAction().isLocalInvalidate()) && regionTimeToLive.getTimeout() > 0 ) {
-        throw new IllegalStateException(
-            LocalizedStrings.AttributesFactory_INVALIDATE_REGION_NOT_SUPPORTED_FOR_PR.toLocalizedString());
-      }
-      
-      if ((regionIdleTimeout.getAction().isDestroy() && regionIdleTimeout.getTimeout() > 0)
-          || (regionIdleTimeout.getAction().isLocalDestroy() && regionIdleTimeout.getTimeout() > 0)
-          || (regionTimeToLive.getAction().isDestroy() && regionTimeToLive.getTimeout() > 0)
-          || (regionTimeToLive.getAction().isLocalDestroy() && regionTimeToLive.getTimeout() > 0)) {
-        throw new IllegalStateException(
-            LocalizedStrings.AttributesFactory_DESTROY_REGION_NOT_SUPPORTED_FOR_PR
-                .toLocalizedString());
-      }
+      AbstractRegion.validatePRRegionExpirationAttributes(regionIdleTimeout);
+      AbstractRegion.validatePRRegionExpirationAttributes(regionTimeToLive);
-      if (pa.getLocalMaxMemory() < 0) {
+      
+      // fix bug #52033 by invoking getLocalMaxMemoryForValidation here
+      if (((PartitionAttributesImpl)pa).getLocalMaxMemoryForValidation() < 0) {
+      
-      if (pa.getLocalMaxMemory() == 0 && attrs.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
+      
+      // fix bug #52033 by invoking getLocalMaxMemoryForValidation here
+      if (((PartitionAttributesImpl)pa).getLocalMaxMemoryForValidation() == 0 && attrs.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
+    transient CustomEvictionAttributes customEvictionAttributes;
+    String hdfsStoreName = null;
+    private boolean hdfsWriteOnly = false;
+    boolean offHeap = false;
+
+      buf.append("; hdfsStoreName=").append(hdfsStoreName);
+      buf.append("; hdfsWriteOnly=").append(hdfsWriteOnly);
+      buf.append("; offHeap=").append(offHeap);
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public CustomEvictionAttributes getCustomEvictionAttributes() {
+      return this.customEvictionAttributes;
+    }
+
+    @Override
+    public String getHDFSStoreName() {
+      return hdfsStoreName;
+    }
+    
+    @Override
+    public boolean getHDFSWriteOnly() {
+      return hdfsWriteOnly;
+    }
+
+    @Override
+    
+    @Override
+    public boolean getOffHeap() {
+      return this.offHeap;
+    }

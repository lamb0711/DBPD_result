GEODE-4792: Expand ArgumentRedactor regular expression logic for better self-documentation.


-  private static final List<String> tabooForKeyToStartWith =
+  private static final List<String> tabooForOptionToStartWith =
-  // This pattern consists of three capture groups:
-  // The option, consisting of
-  // (a) A leading space or starting string boundary, followed by one or two hyphens
-  // (b) one or more non-whitespace, non-"=" characters, matching greedily
-  // The option-value separator, consisting of: any amount of whitespace surrounding at most 1 "="
-  // The value, consisting of:
-  // (a) If not wrapped in quotes, all non-whitespace characters, matching greedily.
-  // (b) If wrapped in quotes, any non-quote character, matching greedily, until the closing quote.
-  // -- -- This will therefore break on, e.g., --opt="escaped \" quote" and only redact "escaped."
-  // Positive lookahead between groups 1 and 2 to require space or "=", while * and ? match empty.
-  // Negative lookahead between groups 2 and 3 to avoid "--boolFlag --newOption" matching as a pair.
-  private static final Pattern optionWithValuePattern =
-      Pattern.compile("([^ ]--?[^\\s=]+)(?=[ =])( *=? *)(?!-)((?:\"[^\"]*\"|\\S+))");
+  private static final Pattern optionWithArgumentPattern = getOptionWithArgumentPattern();
+
+
+  /**
+   * This method returns the {@link java.util.regex.Pattern} given below, used to capture
+   * command-line options that accept an argument. For clarity, the regex is given here without
+   * the escape characters required by Java's string handling.
+   * <p>
+   *
+   * {@code ((?:^| )(?:--J=)?--?)([^\s=]+)(?=[ =])( *[ =] *)(?! *-)((?:"[^"]*"|\S+))}
+   *
+   * <p>
+   * This pattern consists of one captured boundary,
+   * three additional capture groups, and two look-ahead boundaries.
+   *
+   * <p>
+   * The four capture groups are:
+   * <ul>
+   * <li>[1] The beginning boundary, including at most one leading space,
+   * possibly including "--J=", and including the option's leading "-" or "--"</li>
+   * <li>[2] The option, which cannot include spaces</li>
+   * <li>[3] The option / argument separator, consisting of at least one character
+   * made of spaces and/or at most one "="</li>
+   * <li>[4] The argument, which terminates at the next space unless it is encapsulated by
+   * quotation-marks, in which case it terminates at the next quotation mark.</li>
+   * </ul>
+   *
+   * Look-ahead groups avoid falsely identifying two flag options (e.g. `{@code --help --all}`) from
+   * interpreting the second flag as the argument to the first option
+   * (here, misinterpreting as `{@code --help="--all"}`).
+   * <p>
+   *
+   * Note that at time of writing, the argument (capture group 4) is not consumed by this class's
+   * logic, but its capture has proven repeatedly useful during iteration and testing.
+   */
+  private static Pattern getOptionWithArgumentPattern() {
+    String capture_beginningBoundary;
+    {
+      String spaceOrBeginningAnchor = "(?:^| )";
+      String maybeLeadingWithDashDashJEquals = "(?:--J=)?";
+      String oneOrTwoDashes = "--?";
+      capture_beginningBoundary =
+          "(" + spaceOrBeginningAnchor + maybeLeadingWithDashDashJEquals + oneOrTwoDashes + ")";
+    }
+
+    String capture_optionNameHasNoSpaces = "([^\\s=]+)";
+
+    String boundary_lookAheadForSpaceOrEquals = "(?=[ =])";
+
+    String capture_optionArgumentSeparator = "( *[ =] *)";
+
+    String boundary_negativeLookAheadToPreventNextOptionAsThisArgument = "(?! *-)";
+
+    String capture_Argument;
+    {
+      String argumentCanBeAnythingBetweenQuotes = "\"[^\"]*\"";
+      String argumentCanHaveNoSpacesWithoutQuotes = "\\S+";
+      String argumentCanBeEitherOfTheAbove = "(?:" + argumentCanBeAnythingBetweenQuotes + "|"
+          + argumentCanHaveNoSpacesWithoutQuotes + ")";
+      capture_Argument = "(" + argumentCanBeEitherOfTheAbove + ")";
+    }
+
+    String fullPattern = capture_beginningBoundary + capture_optionNameHasNoSpaces
+        + boundary_lookAheadForSpaceOrEquals + capture_optionArgumentSeparator
+        + boundary_negativeLookAheadToPreventNextOptionAsThisArgument + capture_Argument;
+    return Pattern.compile(fullPattern);
+  }
-   * Parse a string to find key-value pairs and redact the values if necessary.<br>
+   * Parse a string to find option/argument pairs and redact the arguments if necessary.<br>
-   * - Each key-value pair should be separated by spaces.<br>
-   * - The key of each key-value pair must be preceded by a hyphen '-'.<br>
-   * - Values may or may not be wrapped in quotation marks.<br>
-   * - If a value is wrapped in quotation marks, the actual value should not contain any quotation
-   * mark.<br>
-   * - Keys and values may be separated by an equals sign '=' or any number of spaces.<br>
+   * - Each option/argument pair should be separated by spaces.<br>
+   * - The option of each pair must be preceded by at least one hyphen '-'.<br>
+   * - Arguments may or may not be wrapped in quotation marks.<br>
+   * - Options and arguments may be separated by an equals sign '=' or any number of spaces.<br>
-   * "-Dflag -Dkey=value"<br>
+   * "-Dflag -Dopt=arg"<br>
+   * See {@link #getOptionWithArgumentPattern()} for more information on
+   * the regular expression used.
+   *
-    // We capture the key, separator, and values separately, replacing only the value at print.
-    Matcher matcher = optionWithValuePattern.matcher(line);
+    Matcher matcher = optionWithArgumentPattern.matcher(line);
-      String option = matcher.group(1);
+      String option = matcher.group(2);
-      String separator = matcher.group(2);
-      String withRedaction = option + separator + redacted;
+      String leadingBoundary = matcher.group(1);
+      String separator = matcher.group(3);
+      String withRedaction = leadingBoundary + option + separator + redacted;
-   * This alias permits the first key-value pair to be given without a leading hyphen, so that
-   * "password=secret" will be properly redacted.
-   *
-   * See {@link org.apache.geode.internal.util.ArgumentRedactor#redact(java.lang.String, boolean)}
+   * Alias for {@code redact(line, true)}. See
+   * {@link org.apache.geode.internal.util.ArgumentRedactor#redact(java.lang.String, boolean)}
-   * Return a redacted value if the key indicates redaction is necessary. Otherwise, return the
-   * value unchanged.
+   * Return the redaction string if the provided option's argument should be redacted.
+   * Otherwise, return the provided argument unchanged.
-   * @param key A string such as a system property, jvm parameter or similar in a key=value
-   *        situation.
-   * @param value A string that is the value assigned to the key.
+   * @param option A string such as a system property, jvm parameter or command-line option.
+   * @param argument A string that is the argument assigned to the option.
-   * @return A redacted string if the key indicates it should be redacted, otherwise the string is
-   *         unchanged.
+   * @return A redacted string if the option indicates it should be redacted, otherwise the
+   *         provided argument.
-  public static String redactValueIfNecessary(String key, String value) {
-    if (isTaboo(key)) {
+  public static String redactArgumentIfNecessary(String option, String argument) {
+    if (isTaboo(option)) {
-    return value;
+    return argument;
-
-   * Determine whether a key's value should be redacted.
+   * Determine whether a option's argument should be redacted.
-   * @param key The option key in question.
+   * @param option The option option in question.
-  static boolean isTaboo(String key) {
-    if (key == null) {
+  static boolean isTaboo(String option) {
+    if (option == null) {
-    for (String taboo : tabooForKeyToStartWith) {
-      if (key.toLowerCase().startsWith(taboo)) {
+    for (String taboo : tabooForOptionToStartWith) {
+      // If a parameter is passed with -Dsecurity-option=argument, the option option is
+      // "Dsecurity-option".
+      // With respect to taboo words, also check for the addition of the extra D
+      if (option.toLowerCase().startsWith(taboo) || option.toLowerCase().startsWith("d" + taboo)) {
-      if (key.toLowerCase().contains(taboo)) {
+      if (option.toLowerCase().contains(taboo)) {
-  public static List<String> redactEachInList(List<String> inputArguments) {
-    return inputArguments.stream().map(ArgumentRedactor::redact).collect(Collectors.toList());
+  public static List<String> redactEachInList(List<String> argList) {
+    return argList.stream().map(ArgumentRedactor::redact).collect(Collectors.toList());

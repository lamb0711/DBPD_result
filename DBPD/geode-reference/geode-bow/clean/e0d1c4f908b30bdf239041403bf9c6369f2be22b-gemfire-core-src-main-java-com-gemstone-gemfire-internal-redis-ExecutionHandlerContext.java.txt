Merge remote-tracking branch 'origin/develop' into feature/GEODE-77

+import com.gemstone.gemfire.cache.CacheClosedException;
+import com.gemstone.gemfire.cache.query.QueryInvocationTargetException;
+/**
+ * This class extends {@link ChannelInboundHandlerAdapter} from Netty and it is
+ * the last part of the channel pipeline. The {@link ByteToCommandDecoder} forwards a
+ * {@link Command} to this class which executes it and sends the result back to the
+ * client. Additionally, all exception handling is done by this class. 
+ * <p>
+ * Besides being part of Netty's pipeline, this class also serves as a context to the
+ * execution of a command. It abstracts transactions, provides access to the {@link RegionProvider}
+ * and anything else an executing {@link Command} may need.
+ * 
+ * @author Vitaliy Gavrilov
+ *
+ */
-  private static final int MAXIMUM_NUM_RETRIES = 5;
+  private static final int WAIT_REGION_DSTRYD_MILLIS = 100;
+  private static final int MAXIMUM_NUM_RETRIES = (1000*60)/WAIT_REGION_DSTRYD_MILLIS; // 60 seconds total
-  private final RegionCache regionCache;
+  private final RegionProvider regionProvider;
-  public ExecutionHandlerContext(Channel ch, Cache cache, RegionCache regions, GemFireRedisServer server, byte[] pwd) {
+  /**
+   * Default constructor for execution contexts. 
+   * 
+   * @param ch Channel used by this context, should be one to one
+   * @param cache The Geode cache instance of this vm
+   * @param regionProvider The region provider of this context
+   * @param server Instance of the server it is attached to, only used so that any execution can initiate a shutdwon
+   * @param pwd Authentication password for each context, can be null
+   */
+  public ExecutionHandlerContext(Channel ch, Cache cache, RegionProvider regionProvider, GemFireRedisServer server, byte[] pwd) {
+    if (ch == null || cache == null || regionProvider == null || server == null)
+      throw new IllegalArgumentException("Only the authentication password may be null");
-    this.regionCache = regions;
+    this.regionProvider = regionProvider;
-  private void writeToChannel(Object message) {
+  private void writeToChannel(ByteBuf message) {
+  /**
+   * This will handle the execution of received commands
+   */
+  /**
+   * Exception handler for the entire pipeline
+   */
-    else if (cause instanceof RegionCreationException)
+    else if (cause instanceof RegionCreationException) {
+      this.logger.error(cause);
-    else if (cause instanceof InterruptedException)
+    } else if (cause instanceof InterruptedException || cause instanceof CacheClosedException)
-      response = Coder.getErrorResponse(this.byteBufAllocator,  cause.getMessage());
+      response = Coder.getErrorResponse(this.byteBufAllocator, cause.getMessage());
-        this.logger.error("GemFireRedisServer-Unexpected error handler", cause);
+        this.logger.error("GemFireRedisServer-Unexpected error handler for " + ctx.channel(), cause);
-  /**
-   * This method is used to execute the command. The executor is 
-   * determined by the {@link RedisCommandType} and then the execution
-   * is started.
-   * 
-   * @param command Command to be executed
-   * @param cache The Cache instance of this server
-   * @param client The client data associated with the client
-   * @throws Exception 
-   */
-  public void executeCommand(ChannelHandlerContext ctx, Command command) throws Exception {
+  private void executeCommand(ChannelHandlerContext ctx, Command command) throws Exception {
-        executeWithoutTransaction(exec, command, MAXIMUM_NUM_RETRIES); 
+        executeWithoutTransaction(exec, command); 
-   * @param cache Cache instance
-   * @param client Client data associated with client
-   * @param n Recursive max depth of retries
-  private void executeWithoutTransaction(final Executor exec, Command command, int n) throws Exception {
-    try {
-      exec.executeCommand(command, this);
-    } catch (RegionDestroyedException e) {
-      if (n > 0)
-        executeWithoutTransaction(exec, command, n - 1);
-      else
-        throw e;
+  private void executeWithoutTransaction(final Executor exec, Command command) throws Exception {
+    Exception cause = null;
+    for (int i = 0; i < MAXIMUM_NUM_RETRIES; i++) {
+      try {
+        exec.executeCommand(command, this);
+        return;
+      } catch (Exception e) {
+        cause = e;
+        if (e instanceof RegionDestroyedException || e.getCause() instanceof QueryInvocationTargetException)
+          Thread.sleep(WAIT_REGION_DSTRYD_MILLIS);
+      }
+    throw cause;
-  /**
-   * Private method to execute a command when a transaction has been started
-   * 
-   * @param exec Executor to use
-   * @param command Command to execute
-   * @param cache Cache instance
-   * @param client Client data associated with client
-   * @throws Exception Throws exception if exception is from within execution and unrelated to transactions
-   */
+  /**
+   * {@link ByteBuf} allocator for this context. All executors
+   * must use this pooled allocator as opposed to having unpooled buffers
+   * for maximum performance
+   * 
+   * @return allocator instance
+   */
-  public RegionCache getRegionCache() {
-    return this.regionCache;
+  /**
+   * Gets the provider of Regions
+   * 
+   * @return Provider
+   */
+  public RegionProvider getRegionProvider() {
+    return this.regionProvider;
+  /**
+   * Getter for manager to allow pausing and resuming transactions
+   * @return Instance
+   */
+  /**
+   * Getter for logger
+   * @return instance
+   */
+  /**
+   * Get the channel for this context
+   * @return instance
+   *
+   */
+  /**
+   * Get the authentication password, this will be same server wide.
+   * It is exposed here as opposed to {@link GemFireRedisServer}.
+   * @return password
+   */
+  /**
+   * Checker if user has authenticated themselves
+   * @return True if no authentication required or authentication complete, false otherwise
+   */
+  /**
+   * Lets this context know the authentication is complete
+   */

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class GlobalTransaction  {
+public class GlobalTransaction {
-   * GTid is a byte array identifying every instance of a global transaction
-   * uniquely
+   * GTid is a byte array identifying every instance of a global transaction uniquely
-   * to enable VERBOSE = true pass System parameter jta.VERBOSE = true while
-   * running the test.
+   * to enable VERBOSE = true pass System parameter jta.VERBOSE = true while running the test.
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-      if (writer.severeEnabled()) writer.severe(LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_CONSTRUCTOR_ERROR_WHILE_TRYING_TO_CREATE_XID_DUE_TO_0, e, e);
-      String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_CONSTRUCTOR_ERROR_WHILE_TRYING_TO_CREATE_XID_DUE_TO_0.toLocalizedString(new Object[] {e});
+      if (writer.severeEnabled())
+        writer.severe(
+            LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_CONSTRUCTOR_ERROR_WHILE_TRYING_TO_CREATE_XID_DUE_TO_0,
+            e, e);
+      String exception =
+          LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_CONSTRUCTOR_ERROR_WHILE_TRYING_TO_CREATE_XID_DUE_TO_0
+              .toLocalizedString(new Object[] {e});
-   * Add a transaction to the list of transactions participating in this global
-   * Transaction The list of transactions is being maintained so that we can
-   * remove the local transaction to global transaction entries from the map
-   * being maintained by the Transaction Manager
+   * Add a transaction to the list of transactions participating in this global Transaction The list
+   * of transactions is being maintained so that we can remove the local transaction to global
+   * transaction entries from the map being maintained by the Transaction Manager
-   * @param txn Transaction instance which is participating in this Global
-   *          Transaction
+   * @param txn Transaction instance which is participating in this Global Transaction
-      String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ADDTRANSACTION_CANNOT_ADD_A_NULL_TRANSACTION.toLocalizedString();
+      String exception =
+          LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ADDTRANSACTION_CANNOT_ADD_A_NULL_TRANSACTION
+              .toLocalizedString();
-      if (VERBOSE) writer.fine(exception);
+      if (VERBOSE)
+        writer.fine(exception);
-   * Delists the XAResources associated with the Global Transaction and
-   * Completes the Global transaction associated with the current thread. If any
-   * exception is encountered, rollback is called on the current transaction.
+   * Delists the XAResources associated with the Global Transaction and Completes the Global
+   * transaction associated with the current thread. If any exception is encountered, rollback is
+   * called on the current transaction.
-   * Concurrency: Some paths invoke this method after taking a lock on "this" while 
-   * other paths invoke this method without taking a lock on "this". Since both types of path do
-   * act on the resourceMap collection, it is being protected by a lock on resourceMap too.
+   * Concurrency: Some paths invoke this method after taking a lock on "this" while other paths
+   * invoke this method without taking a lock on "this". Since both types of path do act on the
+   * resourceMap collection, it is being protected by a lock on resourceMap too.
-   * @throws RollbackException -
-   *           Thrown to indicate that the transaction has been rolled back
-   *           rather than committed.
-   * @throws HeuristicMixedException -
-   *           Thrown to indicate that a heuristic decision was made and that
-   *           some relevant updates have been committed while others have been
-   *           rolled back.
-   * @throws HeuristicRollbackException -
-   *           Thrown to indicate that a heuristic decision was made and that
-   *           all relevant updates have been rolled back.
-   * @throws java.lang.SecurityException -
-   *           Thrown to indicate that the thread is not allowed to commit the
-   *           transaction.
-   * @throws java.lang.IllegalStateException -
-   *           Thrown if the current thread is not associated with a
-   *           transaction.
-   * @throws SystemException -
-   *           Thrown if the transaction manager encounters an unexpected error
-   *           condition.
+   * @throws RollbackException - Thrown to indicate that the transaction has been rolled back rather
+   *         than committed.
+   * @throws HeuristicMixedException - Thrown to indicate that a heuristic decision was made and
+   *         that some relevant updates have been committed while others have been rolled back.
+   * @throws HeuristicRollbackException - Thrown to indicate that a heuristic decision was made and
+   *         that all relevant updates have been rolled back.
+   * @throws java.lang.SecurityException - Thrown to indicate that the thread is not allowed to
+   *         commit the transaction.
+   * @throws java.lang.IllegalStateException - Thrown if the current thread is not associated with a
+   *         transaction.
+   * @throws SystemException - Thrown if the transaction manager encounters an unexpected error
+   *         condition.
-  //Asif : Changed the return type to int indicating the nature of Exception
+  // Asif : Changed the return type to int indicating the nature of Exception
-      HeuristicRollbackException, SecurityException, SystemException
-  {
+      HeuristicRollbackException, SecurityException, SystemException {
-            entry = (Map.Entry)iterator.next();
-            xar = (XAResource)entry.getKey();
-            isActive = (Boolean)entry.getValue();
+            entry = (Map.Entry) iterator.next();
+            xar = (XAResource) entry.getKey();
+            isActive = (Boolean) entry.getValue();
-          }
-          catch (Exception e) {
+          } catch (Exception e) {
-              writer.info(
-                LocalizedStrings.ONE_ARG,  
-                "GlobalTransaction::commit:Exception in delisting XAResource",
-                e);
+              writer.info(LocalizedStrings.ONE_ARG,
+                  "GlobalTransaction::commit:Exception in delisting XAResource", e);
-        writer
-            .fine("GlobalTransaction::commit:Transaction committed successfully");
-    }
-    catch (Exception e) {
+        writer.fine("GlobalTransaction::commit:Transaction committed successfully");
+    } catch (Exception e) {
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_COMMIT_ERROR_IN_COMMITTING_BUT_TRANSACTION_COULD_NOT_BE_ROLLED_BACK_DUE_TO_EXCEPTION_0.toLocalizedString(t); 
+        String exception =
+            LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_COMMIT_ERROR_IN_COMMITTING_BUT_TRANSACTION_COULD_NOT_BE_ROLLED_BACK_DUE_TO_EXCEPTION_0
+                .toLocalizedString(t);
-      String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_COMMIT_ERROR_IN_COMMITTING_THE_TRANSACTION_TRANSACTION_ROLLED_BACK_EXCEPTION_0_1.toLocalizedString(new Object[] {e, 
-          " " + (e instanceof XAException ? ("Error Code =" + ((XAException)e).errorCode)
-              : "")});
+      String exception =
+          LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_COMMIT_ERROR_IN_COMMITTING_THE_TRANSACTION_TRANSACTION_ROLLED_BACK_EXCEPTION_0_1
+              .toLocalizedString(new Object[] {e, " " + (e instanceof XAException
+                  ? ("Error Code =" + ((XAException) e).errorCode) : "")});
-    }
-    finally {
-      //Map globalTransactions = tm.getGlobalTransactionMap();
-      TransactionManagerImpl.getTransactionManager().cleanGlobalTransactionMap(
-          transactions);
-      //Asif : Clear the list of transactions
+    } finally {
+      // Map globalTransactions = tm.getGlobalTransactionMap();
+      TransactionManagerImpl.getTransactionManager().cleanGlobalTransactionMap(transactions);
+      // Asif : Clear the list of transactions
-   * Delists the XAResources associated with the Global Transaction and Roll
-   * back the transaction associated with the current thread.
+   * Delists the XAResources associated with the Global Transaction and Roll back the transaction
+   * associated with the current thread.
-   * Concurrency: Some paths invoke this method after taking a lock on "this" while 
-   * other paths invoke this method without taking a lock on "this". Since both types of path do
-   * act on the resourceMap collection, it is being protected by a lock on resourceMap too.
+   * Concurrency: Some paths invoke this method after taking a lock on "this" while other paths
+   * invoke this method without taking a lock on "this". Since both types of path do act on the
+   * resourceMap collection, it is being protected by a lock on resourceMap too.
-   * @throws java.lang.SecurityException -
-   *           Thrown to indicate that the thread is not allowed to roll back
-   *           the transaction.
-   * @throws java.lang.IllegalStateException -
-   *           Thrown if the current thread is not associated with a
-   *           transaction.
-   * @throws SystemException -
-   *           Thrown if the transaction manager encounters an unexpected error
-   *           condition.
+   * @throws java.lang.SecurityException - Thrown to indicate that the thread is not allowed to roll
+   *         back the transaction.
+   * @throws java.lang.IllegalStateException - Thrown if the current thread is not associated with a
+   *         transaction.
+   * @throws SystemException - Thrown if the transaction manager encounters an unexpected error
+   *         condition.
-  public void rollback() throws IllegalStateException, SystemException
-  {
+  public void rollback() throws IllegalStateException, SystemException {
-            entry = (Map.Entry)iterator.next();
-            xar = (XAResource)entry.getKey();
-            isActive = (Boolean)entry.getValue();
+            entry = (Map.Entry) iterator.next();
+            xar = (XAResource) entry.getKey();
+            isActive = (Boolean) entry.getValue();
-          }
-          catch (Exception e) {
+          } catch (Exception e) {
-              writer.info(
-                LocalizedStrings.ONE_ARG,  
-                "GlobalTransaction::rollback:Exception in delisting XAResource",
-                e);
+              writer.info(LocalizedStrings.ONE_ARG,
+                  "GlobalTransaction::rollback:Exception in delisting XAResource", e);
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-      String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ROLLBACK_ROLLBACK_NOT_SUCCESSFUL_DUE_TO_EXCEPTION_0_1.toLocalizedString(new Object[] {e, " " + (e instanceof XAException ? ("Error Code =" + ((XAException)e).errorCode) : "")});
+      String exception =
+          LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ROLLBACK_ROLLBACK_NOT_SUCCESSFUL_DUE_TO_EXCEPTION_0_1
+              .toLocalizedString(new Object[] {e, " " + (e instanceof XAException
+                  ? ("Error Code =" + ((XAException) e).errorCode) : "")});
-    }
-    finally {
+    } finally {
-      TransactionManagerImpl.getTransactionManager().cleanGlobalTransactionMap(
-          transactions);
-      //    Asif : Clear the list of transactions
+      TransactionManagerImpl.getTransactionManager().cleanGlobalTransactionMap(transactions);
+      // Asif : Clear the list of transactions
-   * Enlist the specified XAResource with this transaction. Currently only one
-   * Resource Manager is being supported. enlistResource checks if there is no
-   * XAResource, then enlists the current XAResource. For subsequent
-   * XAResources, it checks if is the same Resource Manager. If it is, then the
-   * XAResources are addded, else an exception is thrown
+   * Enlist the specified XAResource with this transaction. Currently only one Resource Manager is
+   * being supported. enlistResource checks if there is no XAResource, then enlists the current
+   * XAResource. For subsequent XAResources, it checks if is the same Resource Manager. If it is,
+   * then the XAResources are addded, else an exception is thrown
-   * Concurrency: The order of acquiring lock will be lock on "this" followed
-   * by lock on resourceMap. It is possible that in some functions of this
-   * class both the locks are not needed , but if the two are acquired then the realitive
-   * order will always be"this" followed by resourceMap. 
+   * Concurrency: The order of acquiring lock will be lock on "this" followed by lock on
+   * resourceMap. It is possible that in some functions of this class both the locks are not needed
+   * , but if the two are acquired then the realitive order will always be"this" followed by
+   * resourceMap.
-   * @throws SystemException - Thrown if the transaction manager encounters an
-   *           unexpected error condition.
-   * @throws IllegalStateException - Thrown if the transaction in the target
-   *           object is in the prepared state or the transaction is inactive.
-   * @throws RollbackException - Thrown to indicate that the transaction has
-   *           been marked for rollback only.
+   * @throws SystemException - Thrown if the transaction manager encounters an unexpected error
+   *         condition.
+   * @throws IllegalStateException - Thrown if the transaction in the target object is in the
+   *         prepared state or the transaction is inactive.
+   * @throws RollbackException - Thrown to indicate that the transaction has been marked for
+   *         rollback only.
-  public boolean enlistResource(XAResource xaRes) throws RollbackException,
-      IllegalStateException, SystemException {
+  public boolean enlistResource(XAResource xaRes)
+      throws RollbackException, IllegalStateException, SystemException {
-          String exception = "GlobalTransaction::enlistResource::Cannot enlist resource as the transaction has been marked for rollback";
+          String exception =
+              "GlobalTransaction::enlistResource::Cannot enlist resource as the transaction has been marked for rollback";
-          if (VERBOSE) writer.fine(exception);
+          if (VERBOSE)
+            writer.fine(exception);
-        }
-        else if (status != Status.STATUS_ACTIVE) {
-          String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ENLISTRESOURCE_CANNOT_ENLIST_A_RESOURCE_TO_A_TRANSACTION_WHICH_IS_NOT_ACTIVE.toLocalizedString(); 
+        } else if (status != Status.STATUS_ACTIVE) {
+          String exception =
+              LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ENLISTRESOURCE_CANNOT_ENLIST_A_RESOURCE_TO_A_TRANSACTION_WHICH_IS_NOT_ACTIVE
+                  .toLocalizedString();
-          if (VERBOSE) writer.fine(exception);
+          if (VERBOSE)
+            writer.fine(exception);
-            if(!DISABLE_TRANSACTION_TIMEOUT_SETTING) {
+            if (!DISABLE_TRANSACTION_TIMEOUT_SETTING) {
-          }
-          catch (XAException xe) {
-            String exception = LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ENLISTRESOURCE_EXCEPTION_OCCURED_IN_TRYING_TO_SET_XARESOURCE_TIMEOUT_DUE_TO_0_ERROR_CODE_1.toLocalizedString(new Object[] {xe, Integer.valueOf(xe.errorCode)});
+          } catch (XAException xe) {
+            String exception =
+                LocalizedStrings.GlobalTransaction_GLOBALTRANSACTION_ENLISTRESOURCE_EXCEPTION_OCCURED_IN_TRYING_TO_SET_XARESOURCE_TIMEOUT_DUE_TO_0_ERROR_CODE_1
+                    .toLocalizedString(new Object[] {xe, Integer.valueOf(xe.errorCode)});
-            if (VERBOSE) writer.fine(exception);
+            if (VERBOSE)
+              writer.fine(exception);
-        }
-        else {
+        } else {
-            if (writer.severeEnabled()) writer.severe(
-                LocalizedStrings.GlobalTransaction_GLOBALTRANSACTIONENLISTRESOURCEONLY_ONE_RESOUCE_MANAGER_SUPPORTED);
-            throw new SystemException(LocalizedStrings.GlobalTransaction_GLOBALTRANSACTIONENLISTRESOURCEONLY_ONE_RESOUCE_MANAGER_SUPPORTED.toLocalizedString());
-          }
-          else {
+            if (writer.severeEnabled())
+              writer.severe(
+                  LocalizedStrings.GlobalTransaction_GLOBALTRANSACTIONENLISTRESOURCEONLY_ONE_RESOUCE_MANAGER_SUPPORTED);
+            throw new SystemException(
+                LocalizedStrings.GlobalTransaction_GLOBALTRANSACTIONENLISTRESOURCEONLY_ONE_RESOUCE_MANAGER_SUPPORTED
+                    .toLocalizedString());
+          } else {
-    }
-    catch (Exception e) {
-      String addon = (e instanceof XAException ? ("Error Code =" + ((XAException) e).errorCode)
-              : "");
+    } catch (Exception e) {
+      String addon =
+          (e instanceof XAException ? ("Error Code =" + ((XAException) e).errorCode) : "");
-      if (VERBOSE) writer.fine(LocalizedStrings.GLOBALTRANSACTION__ENLISTRESOURCE__ERROR_WHILE_ENLISTING_XARESOURCE_0_1.toLocalizedString(new Object[] {e, addon}), e);
-      SystemException sysEx = new SystemException(LocalizedStrings.GLOBALTRANSACTION__ENLISTRESOURCE__ERROR_WHILE_ENLISTING_XARESOURCE_0_1.toLocalizedString(new Object[] {e, addon}));
+      if (VERBOSE)
+        writer.fine(
+            LocalizedStrings.GLOBALTRANSACTION__ENLISTRESOURCE__ERROR_WHILE_ENLISTING_XARESOURCE_0_1
+                .toLocalizedString(new Object[] {e, addon}),
+            e);
+      SystemException sysEx = new SystemException(
+          LocalizedStrings.GLOBALTRANSACTION__ENLISTRESOURCE__ERROR_WHILE_ENLISTING_XARESOURCE_0_1
+              .toLocalizedString(new Object[] {e, addon}));
-   * In the current implementation this call will never be made by the
-   * application server. The delisting is happening at the time of
-   * commit/rollback
+   * In the current implementation this call will never be made by the application server. The
+   * delisting is happening at the time of commit/rollback
-   * @throws SystemException Thrown if the transaction manager encounters an
-   *           unexpected error condition.
-   * @throws IllegalStateException Thrown if the transaction in the target
-   *           object is not active.
+   * @throws SystemException Thrown if the transaction manager encounters an unexpected error
+   *         condition.
+   * @throws IllegalStateException Thrown if the transaction in the target object is not active.
-   * @see javax.transaction.Transaction#delistResource(javax.transaction.xa.XAResource,
-   *      int)
+   * @see javax.transaction.Transaction#delistResource(javax.transaction.xa.XAResource, int)
-    }
-    catch (Exception e) {
-      String exception = LocalizedStrings.GlobalTransaction_ERROR_WHILE_DELISTING_XARESOURCE_0_1.toLocalizedString(new Object[] {e, " " + (e instanceof XAException ? ("Error Code =" + ((XAException) e).errorCode) : "")});
+    } catch (Exception e) {
+      String exception = LocalizedStrings.GlobalTransaction_ERROR_WHILE_DELISTING_XARESOURCE_0_1
+          .toLocalizedString(new Object[] {e, " "
+              + (e instanceof XAException ? ("Error Code =" + ((XAException) e).errorCode) : "")});
-      if (VERBOSE) writer.fine(exception, e);
+      if (VERBOSE)
+        writer.fine(exception, e);
-   * suspends the current transaction by deactivating the XAResource (delist)    
+   * suspends the current transaction by deactivating the XAResource (delist)
-  public void suspend() throws SystemException
-  {
+  public void suspend() throws SystemException {
-        entry = (Map.Entry)iterator.next();
-        xar = (XAResource)entry.getKey();
-        isActive = (Boolean)entry.getValue();
+        entry = (Map.Entry) iterator.next();
+        xar = (XAResource) entry.getKey();
+        isActive = (Boolean) entry.getValue();
-          }
-          catch (Exception e) {
-            String exception = LocalizedStrings.GlobalTransaction_ERROR_WHILE_DELISTING_XARESOURCE_0_1.toLocalizedString(new Object[] {e, " " + (e instanceof XAException ? ("Error Code =" + ((XAException) e).errorCode) : "")});
+          } catch (Exception e) {
+            String exception =
+                LocalizedStrings.GlobalTransaction_ERROR_WHILE_DELISTING_XARESOURCE_0_1
+                    .toLocalizedString(new Object[] {e, " " + (e instanceof XAException
+                        ? ("Error Code =" + ((XAException) e).errorCode) : "")});
-         * "GlobaTransaction::suspend not succesful due to " + e; LogWriterI18n
-         * writer = TransactionUtils.getLogWriter(); if (VERBOSE)
-         * writer.fine(exception); throw new SystemException(exception); }
+         * "GlobaTransaction::suspend not succesful due to " + e; LogWriterI18n writer =
+         * TransactionUtils.getLogWriter(); if (VERBOSE) writer.fine(exception); throw new
+         * SystemException(exception); }
-   * resume the current transaction by activating all the XAResources associated
-   * with the current transaction
+   * resume the current transaction by activating all the XAResources associated with the current
+   * transaction
-  public void resume() throws SystemException
-  {
+  public void resume() throws SystemException {
-        entry = (Map.Entry)iterator.next();
-        xar = (XAResource)entry.getKey();
-        isActive = (Boolean)entry.getValue();
+        entry = (Map.Entry) iterator.next();
+        xar = (XAResource) entry.getKey();
+        isActive = (Boolean) entry.getValue();
-          }
-          catch (Exception e) {
-            String exception = LocalizedStrings.GlobalTransaction_GLOBATRANSACTION_RESUME_RESUME_NOT_SUCCESFUL_DUE_TO_0.toLocalizedString(e);
+          } catch (Exception e) {
+            String exception =
+                LocalizedStrings.GlobalTransaction_GLOBATRANSACTION_RESUME_RESUME_NOT_SUCCESFUL_DUE_TO_0
+                    .toLocalizedString(e);
-  
+
+   * 
-  
+
+   * 
-  
+
+   * 
-      InternalDistributedSystem ids = InternalDistributedSystem
-      .getAnyInstance();
+      InternalDistributedSystem ids = InternalDistributedSystem.getAnyInstance();
-  
+
-   * Returns a byte array which uses a static synchronized counter to ensure
-   * uniqueness
-   *  
+   * Returns a byte array which uses a static synchronized counter to ensure uniqueness
+   * 
-    //Asif: The counter should be attached to the string inside Synch block
+    // Asif: The counter should be attached to the string inside Synch block
-   * A timer task cleaup method. This is called when Transaction timeout occurs.
-   * On timeout the transaction is rolled back and the thread removed from
-   * thread-Transaction Map.
+   * A timer task cleaup method. This is called when Transaction timeout occurs. On timeout the
+   * transaction is rolled back and the thread removed from thread-Transaction Map.
-    if (timedOut) return; // this method is only called by a single thread so this is safe
+    if (timedOut)
+      return; // this method is only called by a single thread so this is safe
-          writer
-              .info(LocalizedStrings.GlobalTransaction_TRANSACTION_0_HAS_TIMED_OUT, this);
-      TransactionManagerImpl.getTransactionManager()
-          .removeTranxnMappings(transactions);
+        writer.info(LocalizedStrings.GlobalTransaction_TRANSACTION_0_HAS_TIMED_OUT, this);
+      TransactionManagerImpl.getTransactionManager().removeTranxnMappings(transactions);
-    }
-    catch (Exception e) {
-      if (writer.severeEnabled()) writer.severe(LocalizedStrings.GlobalTransaction_GLOBATRANSACTION_EXPIREGTX_ERROR_OCCURED_WHILE_REMOVING_TRANSACTIONAL_MAPPINGS_0, e, e);
+    } catch (Exception e) {
+      if (writer.severeEnabled())
+        writer.severe(
+            LocalizedStrings.GlobalTransaction_GLOBATRANSACTION_EXPIREGTX_ERROR_OCCURED_WHILE_REMOVING_TRANSACTIONAL_MAPPINGS_0,
+            e, e);
-   * Set the transaction TimeOut of the Global Transaction Asif : It returns the
-   * new expiry time for the GTX.
+   * Set the transaction TimeOut of the Global Transaction Asif : It returns the new expiry time for
+   * the GTX.
-  long setTransactionTimeoutForXARes(int seconds) throws SystemException
-  {
+  long setTransactionTimeoutForXARes(int seconds) throws SystemException {
-        entry= (Map.Entry)iterator.next();
-        xar = (XAResource)entry.getKey();        
-        if (((Boolean)entry.getValue()).booleanValue()) {
+        entry = (Map.Entry) iterator.next();
+        xar = (XAResource) entry.getKey();
+        if (((Boolean) entry.getValue()).booleanValue()) {
-          }
-          catch (XAException e) {
-            String exception = LocalizedStrings.GlobalTransaction_EXCEPTION_OCCURED_WHILE_TRYING_TO_SET_THE_XARESOURCE_TIMEOUT_DUE_TO_0_ERROR_CODE_1.toLocalizedString(new Object[] {e, Integer.valueOf(e.errorCode)});
+          } catch (XAException e) {
+            String exception =
+                LocalizedStrings.GlobalTransaction_EXCEPTION_OCCURED_WHILE_TRYING_TO_SET_THE_XARESOURCE_TIMEOUT_DUE_TO_0_ERROR_CODE_1
+                    .toLocalizedString(new Object[] {e, Integer.valueOf(e.errorCode)});
+
-   * Returns the List of Transactions associated with this GlobalTransaction
-   * Asif : Reduced the visibility
+   * Returns the List of Transactions associated with this GlobalTransaction Asif : Reduced the
+   * visibility
-  
+
-    for (int i=0; i < this.GTid.length; i++) {
+    for (int i = 0; i < this.GTid.length; i++) {
-      throw new IllegalStateException(
-        LocalizedStrings.GlobalTransaction_COULD_NOT_COMPARE_0_TO_1
+      throw new IllegalStateException(LocalizedStrings.GlobalTransaction_COULD_NOT_COMPARE_0_TO_1
-  
-//   public String toString() {
-//     StringBuffer sb = new StringBuffer();
-//     sb.append("<");
-//     sb.append(super.toString());
-//     sb.append(" expireTime=" + getExpirationTime());
-//     sb.append(">");
-//     return sb.toString();
-//   }
+
+  // public String toString() {
+  // StringBuffer sb = new StringBuffer();
+  // sb.append("<");
+  // sb.append(super.toString());
+  // sb.append(" expireTime=" + getExpirationTime());
+  // sb.append(">");
+  // return sb.toString();
+  // }

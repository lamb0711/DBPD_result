GEODE-7076: remove "group" for pdx configuration (#4035)

Co-authored-by: Darrel Schneider <dschneider@pivotal.io>

* moved RestfulEndpoint up to AbstractConfiguration
* moved CorrespondsWith to AbstractConfiguration
-import static org.apache.geode.management.configuration.AbstractConfiguration.CLUSTER;
-import static org.apache.geode.management.configuration.AbstractConfiguration.isCluster;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
-import org.apache.geode.management.api.CorrespondWith;
-import org.apache.geode.management.api.RestfulEndpoint;
+import org.apache.geode.management.configuration.GroupableConfiguration;
-  public <T extends AbstractConfiguration> ClusterManagementRealizationResult create(T config) {
+  public <T extends AbstractConfiguration<?>> ClusterManagementRealizationResult create(T config) {
-        isCluster(group) ? CLUSTER : group;
+        AbstractConfiguration.isCluster(group) ? AbstractConfiguration.CLUSTER : group;
-    if (result.isSuccessful() && config instanceof RestfulEndpoint) {
-      result.setUri(((RestfulEndpoint) config).getUri());
+    if (result.isSuccessful()) {
+      result.setUri(config.getUri());
-  public <T extends AbstractConfiguration> ClusterManagementRealizationResult delete(
+  public <T extends AbstractConfiguration<?>> ClusterManagementRealizationResult delete(
-  public <T extends AbstractConfiguration> ClusterManagementRealizationResult update(
+  public <T extends AbstractConfiguration<?>> ClusterManagementRealizationResult update(
-  public <T extends AbstractConfiguration & CorrespondWith<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> list(
+  public <T extends AbstractConfiguration<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> list(
-            persistenceService.getCacheConfig(isCluster(group) ? CLUSTER : group, true);
+            persistenceService.getCacheConfig(
+                AbstractConfiguration.isCluster(group) ? AbstractConfiguration.CLUSTER : group,
+                true);
-        if (!isCluster(group)) {
-          listInGroup.forEach(t -> t.setGroup(group));
+        if (!AbstractConfiguration.isCluster(group)) {
+          listInGroup.forEach(t -> {
+            if (t instanceof GroupableConfiguration) {
+              ((GroupableConfiguration<?>) t).setGroup(group);
+            }
+          });
-    boolean hasRuntimeInfo = filter.hasRuntimeInfo();
+    boolean hasRuntimeInfo = hasRuntimeInfo(filter.getClass());
-  public <T extends AbstractConfiguration & CorrespondWith<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> get(
+  public <T extends AbstractConfiguration<R>, R extends RuntimeInfo> ClusterManagementListResult<T, R> get(
-    result.setUri(RestfulEndpoint.URI_CONTEXT + RestfulEndpoint.URI_VERSION
+    result.setUri(AbstractConfiguration.URI_CONTEXT + AbstractConfiguration.URI_VERSION
+
+
+  /**
+   * for internal use only
+   */
+  @VisibleForTesting
+  Class<?> getRuntimeClass(Class<?> configClass) {
+    Type genericSuperclass = configClass.getGenericSuperclass();
+
+    if (genericSuperclass instanceof ParameterizedType) {
+      return (Class<?>) ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0];
+    }
+
+    return null;
+  }
+
+  @VisibleForTesting
+  boolean hasRuntimeInfo(Class<?> configClass) {
+    return !RuntimeInfo.class.equals(getRuntimeClass(configClass));
+  }
+

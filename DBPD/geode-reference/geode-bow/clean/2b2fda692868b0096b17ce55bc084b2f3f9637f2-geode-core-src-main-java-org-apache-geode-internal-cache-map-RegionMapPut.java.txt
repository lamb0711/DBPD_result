GEODE-6195 putIfAbsent may get a returned value caused by the same operation due to retry

Moving the check for a retried putIfAbsent to be under the RegionEntry
lock.  This allows the operation to propagate throughout the cluster and
allows the client to receive a valid version tag, if concurrency checks
are enabled.

+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.cache.ValueComparisonHelper;
+import org.apache.geode.internal.logging.LogService;
+  protected static final Logger logger = LogService.getLogger();
+
+  private boolean overwritePutIfAbsent;
+  boolean isOverwritePutIfAbsent() {
+    return overwritePutIfAbsent;
+  }
+
+    if (isOverwritePutIfAbsent()) {
+      getEvent().setOldValue(null);
+    }
+        // retain the version stamp of the existing entry for use in processing failures
+        EntryEventImpl event = getEvent();
+        if (getOwner().getConcurrencyChecksEnabled() &&
+            event.getOperation() == Operation.PUT_IF_ABSENT &&
+            !event.hasValidVersionTag() &&
+            event.isPossibleDuplicate()) {
+          Object retainedValue = getRegionEntry().getValueRetain(getOwner());
+          try {
+            if (ValueComparisonHelper.checkEquals(retainedValue,
+                getEvent().getRawNewValue(),
+                isCompressedOffHeap(event), getOwner().getCache())) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("retried putIfAbsent found same value already in cache "
+                    + "- allowing the operation.  entry={}; event={}", getRegionEntry(),
+                    getEvent());
+              }
+              this.overwritePutIfAbsent = true;
+              return true;
+            }
+          } finally {
+            OffHeapHelper.release(retainedValue);
+          }
+        }
+
+  private boolean isCompressedOffHeap(EntryEventImpl event) {
+    return event.getRegion().getAttributes().getOffHeap()
+        && event.getRegion().getAttributes().getCompressor() != null;
+  }
+
-      // Note that v will be null instead of INVALID because setOldValue
+      // Note that v will be null instead of INVALID because setOldValue`

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * MigrationServer creates a cache using a supplied cache.xml and then
- * opens a server socket that a MigrationClient connects to and requests
- * the data from a Region.  MigrationServer sends the data to
- * the MigrationClient using normal java serialization in
- * order to allow migration from incompatible versions of DataSerializer.
- * Keys and values stored in the cache must serialize and deserialize correctly.
+ * MigrationServer creates a cache using a supplied cache.xml and then opens a server socket that a
+ * MigrationClient connects to and requests the data from a Region. MigrationServer sends the data
+ * to the MigrationClient using normal java serialization in order to allow migration from
+ * incompatible versions of DataSerializer. Keys and values stored in the cache must serialize and
+ * deserialize correctly.
- * Both the MigrationClient and MigrationServer must be configured to have
- * the appropriate domain classes in their CLASSPATH, or errors will be
- * encountered during deserialization.
+ * Both the MigrationClient and MigrationServer must be configured to have the appropriate domain
+ * classes in their CLASSPATH, or errors will be encountered during deserialization.
- * Details of the transfers can be viewed by setting the system property
- * Migration.VERBOSE=true.
+ * Details of the transfers can be viewed by setting the system property Migration.VERBOSE=true.
+ * 
- * </pre><p>
+ * </pre>
+ * <p>
+ * 
-
- * </pre><p>
- * The client is then run with a different cache description having different
- * disk-dirs to hold the migrated information.
+ * 
+ * </pre>
+ * <p>
+ * The client is then run with a different cache description having different disk-dirs to hold the
+ * migrated information.
-  
+
-  
+
-    
+
-    
+
-  
-  
+
+
-   * Create a MigrationServer to be used with a DistributedSystem and Cache
-   * that are created using GemFire APIs
+   * Create a MigrationServer to be used with a DistributedSystem and Cache that are created using
+   * GemFire APIs
+   * 
-        throw new IllegalArgumentException("Error - bind address is not an address of this machine: '" + bindAddressName + "'");
+        throw new IllegalArgumentException(
+            "Error - bind address is not an address of this machine: '" + bindAddressName + "'");
-        throw new IllegalArgumentException("Error - bind address cannot be resolved: '" + bindAddressName + "'");
+        throw new IllegalArgumentException(
+            "Error - bind address cannot be resolved: '" + bindAddressName + "'");
-  
+
-   * Create a distributed system.  If this method is not invoked before running
-   * the MigrationServer, an existing distributed system must exist for the
-   * server to use.
+   * Create a distributed system. If this method is not invoked before running the MigrationServer,
+   * an existing distributed system must exist for the server to use.
-    // if no discovery information has been explicitly given, use a loner ds 
+    // if no discovery information has been explicitly given, use a loner ds
-  
-  
+
+
+   * 
-    
+
-   * This locates the distributed system and cache, if they have not been
-   * created by this server, and then listens for requests from MigrationClient
-   * processes.
+   * This locates the distributed system and cache, if they have not been created by this server,
+   * and then listens for requests from MigrationClient processes.
+   * 
-        System.out.println("Migration server on port " + this.listenPort +
-            " bound to " + this.bindAddress + " is ready for client requets");
+        System.out.println("Migration server on port " + this.listenPort + " bound to "
+            + this.bindAddress + " is ready for client requets");
-        System.out.println("Migration server on port " + this.listenPort +
-            " is ready for client requests");
+        System.out.println(
+            "Migration server on port " + this.listenPort + " is ready for client requests");
-  
+
-   * this causes the migration server to stop serving after it finishes dispatching
-   * any in-process requests
+   * this causes the migration server to stop serving after it finishes dispatching any in-process
+   * requests
+   * 
+   * 
-  
+
-   * @return the distributed system, or null if a system has not yet been associated with this server
+   * 
+   * @return the distributed system, or null if a system has not yet been associated with this
+   *         server
-  
-  
-  
-  
-  
+
+
-      }
-      else {
+      } else {
-          Enumeration en=NetworkInterface.getNetworkInterfaces();
-          while(en.hasMoreElements()) {
-            NetworkInterface i=(NetworkInterface)en.nextElement();
-            for(Enumeration en2=i.getInetAddresses(); en2.hasMoreElements();) {
-              InetAddress addr=(InetAddress)en2.nextElement();
+          Enumeration en = NetworkInterface.getNetworkInterfaces();
+          while (en.hasMoreElements()) {
+            NetworkInterface i = (NetworkInterface) en.nextElement();
+            for (Enumeration en2 = i.getInetAddresses(); en2.hasMoreElements();) {
+              InetAddress addr = (InetAddress) en2.nextElement();
-        }
-        catch (SocketException e) {
-          throw new IllegalArgumentException(LocalizedStrings.InetAddressUtil_UNABLE_TO_QUERY_NETWORK_INTERFACE.toLocalizedString(), e);
+        } catch (SocketException e) {
+          throw new IllegalArgumentException(
+              LocalizedStrings.InetAddressUtil_UNABLE_TO_QUERY_NETWORK_INTERFACE
+                  .toLocalizedString(),
+              e);
-    }
-    else {
+    } else {
-      }
-      else {
+      } else {
-  
-  
-  
-  
-  //               R E Q U E S T   H A N D L E R
-  
-  
+
+
+  // R E Q U E S T H A N D L E R
+
+
-    
-    
+
+
-      }
-      finally {
+      } finally {
-    
+
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-      }
-      finally {
+      } finally {
-    
+
+     * 
-      // for now we ignore the client version in the server.  The client
+      // for now we ignore the client version in the server. The client
-          System.out.println("Processing " + req + " from " + this.clientSocket.getInetAddress().getHostAddress());
+          System.out.println(
+              "Processing " + req + " from " + this.clientSocket.getInetAddress().getHostAddress());
-    
+
-  
-  
-  //           R E Q U E S T   C L A S S E S
-  
-  
-  
+
+
+  // R E Q U E S T C L A S S E S
+
+
+
-    
+
-    
+
-     * Use readRequest to create a new request object, not this constructor.
-     * Subclasses may refine this constructor to perform other initialization
+     * Use readRequest to create a new request object, not this constructor. Subclasses may refine
+     * this constructor to perform other initialization
+     * 
-    ClientRequest(Socket clientSocket, DataInputStream dsi, DataOutputStream dso) throws IOException {
+    ClientRequest(Socket clientSocket, DataInputStream dsi, DataOutputStream dso)
+        throws IOException {
+     * 
-    static ClientRequest readRequest(Socket clientSocket, DataInputStream dsi, DataOutputStream dso) throws IOException {
+    static ClientRequest readRequest(Socket clientSocket, DataInputStream dsi, DataOutputStream dso)
+        throws IOException {
-      case REGION_REQUEST:
-        return new RegionRequest(clientSocket, dsi, dso);
+        case REGION_REQUEST:
+          return new RegionRequest(clientSocket, dsi, dso);
-      System.err.println("Migration server received unknown type of request ("
-          + requestType + ") from " + clientSocket.getInetAddress().getHostAddress());
+      System.err.println("Migration server received unknown type of request (" + requestType
+          + ") from " + clientSocket.getInetAddress().getHostAddress());
-    
+
-    abstract void process(MigrationServer server) throws IOException ;
-    
+    abstract void process(MigrationServer server) throws IOException;
+
-  
+
-   * RegionRequest represents a request for the keys and values of a Region
-   * from a client.
+   * RegionRequest represents a request for the keys and values of a Region from a client.
-    
-    RegionRequest(Socket clientSocket, DataInputStream dsi, DataOutputStream dso) throws IOException {
+
+    RegionRequest(Socket clientSocket, DataInputStream dsi, DataOutputStream dso)
+        throws IOException {
-    
+
-    
+
-          String errorMessage = "Error: region " + this.regionName + " not found in cache"; 
+          String errorMessage = "Error: region " + this.regionName + " not found in cache";
-        String errorMessage = "Error: malformed region name"; 
+        String errorMessage = "Error: malformed region name";
-        for (Iterator it = region.entrySet().iterator(); it.hasNext(); ) {
-          sendEntry((Region.Entry)it.next());
+        for (Iterator it = region.entrySet().iterator(); it.hasNext();) {
+          sendEntry((Region.Entry) it.next());
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-    
+
-      if ( !(key instanceof Serializable) ) {
+      if (!(key instanceof Serializable)) {
-      if ( !(value instanceof Serializable) ) {
+      if (!(value instanceof Serializable)) {

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public final class FetchKeysMessage extends PartitionMessage
-  {
+public final class FetchKeysMessage extends PartitionMessage {
-  
+
-  
+
-  
-  /** the argument for the interest type (regex string, className, list of keys)*/
+
+  /** the argument for the interest type (regex string, className, list of keys) */
-  
-  private FetchKeysMessage(
-      InternalDistributedMember recipient,
-      int regionId,
-      ReplyProcessor21 processor,
-      Integer bucketId,
-      int itype,
-      Object interestArg,
-      boolean allowTombstones)
-  {
+
+  private FetchKeysMessage(InternalDistributedMember recipient, int regionId,
+      ReplyProcessor21 processor, Integer bucketId, int itype, Object interestArg,
+      boolean allowTombstones) {
-  
+
-   * @param recipient the member that the fetch keys message is sent to 
-   * @param r  the PartitionedRegion that contains the bucket
+   * 
+   * @param recipient the member that the fetch keys message is sent to
+   * @param r the PartitionedRegion that contains the bucket
-  public static FetchKeysResponse send(InternalDistributedMember recipient, 
-      PartitionedRegion r, Integer bucketId, boolean allowTombstones) 
-      throws ForceReattemptException
-  {
+  public static FetchKeysResponse send(InternalDistributedMember recipient, PartitionedRegion r,
+      Integer bucketId, boolean allowTombstones) throws ForceReattemptException {
-    FetchKeysResponse p = (FetchKeysResponse)tmp.createReplyProcessor(r, Collections.singleton(recipient));
+    FetchKeysResponse p =
+        (FetchKeysResponse) tmp.createReplyProcessor(r, Collections.singleton(recipient));
-      throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new ForceReattemptException(
+          LocalizedStrings.FetchKeysMessage_FAILED_SENDING_0.toLocalizedString(m));
-  public static FetchKeysResponse sendInterestQuery(InternalDistributedMember recipient, 
-      PartitionedRegion r, Integer bucketId, int itype, Object arg, boolean allowTombstones) 
-      throws ForceReattemptException
-  {
+  public static FetchKeysResponse sendInterestQuery(InternalDistributedMember recipient,
+      PartitionedRegion r, Integer bucketId, int itype, Object arg, boolean allowTombstones)
+      throws ForceReattemptException {
-    FetchKeysResponse p = (FetchKeysResponse)tmp.createReplyProcessor(r, Collections.singleton(recipient));
-    FetchKeysMessage m = new FetchKeysMessage(recipient, r.getPRId(), p, bucketId, itype, arg, allowTombstones);
-    Set failures =r.getDistributionManager().putOutgoing(m); 
-    if (failures != null && failures.size() > 0 ) {
-      throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_FAILED_SENDING_0.toLocalizedString(m));
+    FetchKeysResponse p =
+        (FetchKeysResponse) tmp.createReplyProcessor(r, Collections.singleton(recipient));
+    FetchKeysMessage m =
+        new FetchKeysMessage(recipient, r.getPRId(), p, bucketId, itype, arg, allowTombstones);
+    Set failures = r.getDistributionManager().putOutgoing(m);
+    if (failures != null && failures.size() > 0) {
+      throw new ForceReattemptException(
+          LocalizedStrings.FetchKeysMessage_FAILED_SENDING_0.toLocalizedString(m));
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r, long startTime)
-      throws CacheException, ForceReattemptException
-  {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws CacheException, ForceReattemptException {
-      logger.debug("FetchKeysMessage operateOnRegion: {} bucketId: {} type: {} {}",
-          r.getFullPath(), this.bucketId, InterestType.getString(interestType), (allowTombstones? " with tombstones" : " without tombstones"));
+      logger.debug("FetchKeysMessage operateOnRegion: {} bucketId: {} type: {} {}", r.getFullPath(),
+          this.bucketId, InterestType.getString(interestType),
+          (allowTombstones ? " with tombstones" : " without tombstones"));
-        Set keys = ds.handleRemoteGetKeys(this.bucketId, interestType,
-            interestArg, allowTombstones);
+        Set keys =
+            ds.handleRemoteGetKeys(this.bucketId, interestType, interestArg, allowTombstones);
-          logger.debug("FetchKeysMessage sending {} keys back using processorId: : {}", keys.size(), getProcessorId(), keys);
+          logger.debug("FetchKeysMessage sending {} keys back using processorId: : {}", keys.size(),
+              getProcessorId(), keys);
-        r.getPrStats().endPartitionMessagesProcessing(startTime); 
+        r.getPrStats().endPartitionMessagesProcessing(startTime);
-      }
-      catch (PRLocallyDestroyedException pde) {
+      } catch (PRLocallyDestroyedException pde) {
-        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_ENCOUNTERED_PRLOCALLYDESTROYEDEXCEPTION.toLocalizedString(), pde);
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchKeysMessage_ENCOUNTERED_PRLOCALLYDESTROYEDEXCEPTION
+                .toLocalizedString(),
+            pde);
+    } else {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.FetchKeysMessage_FETCHKEYSMESSAGE_DATA_STORE_NOT_CONFIGURED_FOR_THIS_MEMBER));
-    else {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.FetchKeysMessage_FETCHKEYSMESSAGE_DATA_STORE_NOT_CONFIGURED_FOR_THIS_MEMBER));
-    }
-    
+
-  
+
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-  
+
-  
+
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public void toData(DataOutput out) throws IOException  {
+  public void toData(DataOutput out) throws IOException {
-    
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public FetchKeysReplyMessage() {
-    }
-  
-    private FetchKeysReplyMessage(InternalDistributedMember recipient, int processorId, HeapDataOutputStream chunk,
-                                  int seriesNum, int msgNum, int numSeries, boolean lastInSeries)
-    {
+    public FetchKeysReplyMessage() {}
+
+    private FetchKeysReplyMessage(InternalDistributedMember recipient, int processorId,
+        HeapDataOutputStream chunk, int seriesNum, int msgNum, int numSeries,
+        boolean lastInSeries) {
-    
-    /** 
-     * Send an ack 
+
+    /**
+     * Send an ack
+     * 
-        
+
-        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,
-          new ObjectIntProcedure() {
-            int msgNum = 0;
-              
-            boolean last = false;
-            /**
-              * @param a byte[] chunk
-              * @param b positive if last chunk
-              * @return true to continue to next chunk
-              */
-            public boolean executeWith(Object a, int b) {
-//              if (this.last)
-//                throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
-              HeapDataOutputStream chunk = (HeapDataOutputStream)a;
-              this.last = b > 0;
-              try {
-                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);
-                return okay;
+        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES,
+            false, new ObjectIntProcedure() {
+              int msgNum = 0;
+
+              boolean last = false;
+
+              /**
+               * @param a byte[] chunk
+               * @param b positive if last chunk
+               * @return true to continue to next chunk
+               */
+              public boolean executeWith(Object a, int b) {
+                // if (this.last)
+                // throw new
+                // InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
+                HeapDataOutputStream chunk = (HeapDataOutputStream) a;
+                this.last = b > 0;
+                try {
+                  boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++,
+                      numSeries, this.last);
+                  return okay;
+                } catch (CancelException e) {
+                  return false;
+                }
-              catch (CancelException e) {
-                return false;
-              }
-            }
-          });
-  
+            });
+
-          logger.debug("{} pr keys chunking", (finished?"Finished" : "DID NOT complete"));
+          logger.debug("{} pr keys chunking", (finished ? "Finished" : "DID NOT complete"));
-      }
-      catch (IOException io) {
-        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);
+      } catch (IOException io) {
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST
+                .toLocalizedString(),
+            io);
-      //Assert.assertTrue(!cache is closed, "chunking interrupted but cache is still open");
+      // Assert.assertTrue(!cache is closed, "chunking interrupted but cache is still open");
-    
-    
-    static boolean sendChunk(InternalDistributedMember recipient, int processorId, DM dm, HeapDataOutputStream chunk,
-                                      int seriesNum, int msgNum, int numSeries, boolean lastInSeries) {
-      FetchKeysReplyMessage reply = new FetchKeysReplyMessage(recipient, processorId, chunk, seriesNum,
-                                      msgNum, numSeries, lastInSeries);
+
+
+    static boolean sendChunk(InternalDistributedMember recipient, int processorId, DM dm,
+        HeapDataOutputStream chunk, int seriesNum, int msgNum, int numSeries,
+        boolean lastInSeries) {
+      FetchKeysReplyMessage reply = new FetchKeysReplyMessage(recipient, processorId, chunk,
+          seriesNum, msgNum, numSeries, lastInSeries);
-    
+
-     * Serialize the given set's elments into byte[] chunks, calling proc for each
-     * one. proc args: the byte[] chunk and an int indicating whether it
-     * is the last chunk (positive means last chunk, zero othewise).
-     * The return value of proc indicates whether to continue to the next
+     * Serialize the given set's elments into byte[] chunks, calling proc for each one. proc args:
+     * the byte[] chunk and an int indicating whether it is the last chunk (positive means last
+     * chunk, zero othewise). The return value of proc indicates whether to continue to the next
-    static boolean chunkSet(InternalDistributedMember recipient, Set set, int CHUNK_SIZE_IN_BYTES, boolean includeValues,
-                      ObjectIntProcedure proc)
-    throws IOException
-    {
+    static boolean chunkSet(InternalDistributedMember recipient, Set set, int CHUNK_SIZE_IN_BYTES,
+        boolean includeValues, ObjectIntProcedure proc) throws IOException {
-          InitialImageOperation.CHUNK_SIZE_IN_BYTES+2048, recipient.getVersionObject());
+          InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048, recipient.getVersionObject());
-        while ((mos.size()+avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES && it.hasNext()) {
+        while ((mos.size() + avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES
+            && it.hasNext()) {
-        DataSerializer.writeObject((Object)null, mos);
+        DataSerializer.writeObject((Object) null, mos);
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-      FetchKeysResponse processor = (FetchKeysResponse)p;
-  
+      FetchKeysResponse processor = (FetchKeysResponse) p;
+
-      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime()
-          - startTime);
+      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime() - startTime);
-    
+
-  
+
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  
+
-      sb.append("FetchKeysReplyMessage ")
-        .append("processorid=").append(this.processorId);
-      if (getSender() != null) { 
+      sb.append("FetchKeysReplyMessage ").append("processorid=").append(this.processorId);
+      if (getSender() != null) {
-      sb.append(",seriesNum=").append(seriesNum)
-        .append(",msgNum=").append(msgNum)
-        .append(",numSeries=").append(numSeries)
-        .append(",lastInSeries=").append(lastInSeries);
+      sb.append(",seriesNum=").append(seriesNum).append(",msgNum=").append(msgNum)
+          .append(",numSeries=").append(numSeries).append(",lastInSeries=").append(lastInSeries);
-      }
-      else if (chunk != null) {
+      } else if (chunk != null) {
-   * A processor to capture the value returned by {@link 
-   * org.apache.geode.internal.cache.partitioned.GetMessage.GetReplyMessage}
+   * A processor to capture the value returned by
+   * {@link org.apache.geode.internal.cache.partitioned.GetMessage.GetReplyMessage}
+   * 
-  public static class FetchKeysResponse extends PartitionResponse  {
+  public static class FetchKeysResponse extends PartitionResponse {
-    
+
-    
+
-    
+
-    public FetchKeysResponse(InternalDistributedSystem ds,
-        PartitionedRegion pr, Set recipients) {
+    public FetchKeysResponse(InternalDistributedSystem ds, PartitionedRegion pr, Set recipients) {
-      // this processing algorighm won't work well if there are multiple recipients.  currently the
-      // retry logic for failed recipients is in PartitionedRegion.  If we parallelize the sending
+      // this processing algorighm won't work well if there are multiple recipients. currently the
+      // retry logic for failed recipients is in PartitionedRegion. If we parallelize the sending
-      }
-      else {
+      } else {
-              synchronized(returnValue) {
+              synchronized (returnValue) {
-            }
-            else {
+            } else {
-  
-          synchronized(this.endLock) {
+
+          synchronized (this.endLock) {
-  
-            if (((msg.seriesNum+1) == msg.numSeries)  &&  msg.lastInSeries) {
+
+            if (((msg.seriesNum + 1) == msg.numSeries) && msg.lastInSeries) {
-  
-            if (lastChunkReceived  &&  (chunksExpected == chunksProcessed)) {
+
+            if (lastChunkReceived && (chunksExpected == chunksProcessed)) {
-        }
-        catch (Exception e) {
-          processException(new ReplyException(LocalizedStrings.FetchKeysMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(), e));
+        } catch (Exception e) {
+          processException(new ReplyException(
+              LocalizedStrings.FetchKeysMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(), e));
-  
+
-    
+
-    public Set waitForKeys() throws ForceReattemptException
-    {
+    public Set waitForKeys() throws ForceReattemptException {
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          logger.debug("FetchKeysResponse got remote CacheClosedException; forcing reattempt. {}", t.getMessage(), t);
-          throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION_FORCING_REATTEMPT.toLocalizedString(), t);
+          logger.debug("FetchKeysResponse got remote CacheClosedException; forcing reattempt. {}",
+              t.getMessage(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchKeysMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION_FORCING_REATTEMPT
+                  .toLocalizedString(),
+              t);
-          logger.debug("FetchKeysResponse got remote ForceReattemptException; rethrowing. {}", e.getMessage(), e);
-          throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
+          logger.debug("FetchKeysResponse got remote ForceReattemptException; rethrowing. {}",
+              e.getMessage(), e);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchKeysMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_NO_REPLIES_RECEIVED.toLocalizedString());
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchKeysMessage_NO_REPLIES_RECEIVED.toLocalizedString());

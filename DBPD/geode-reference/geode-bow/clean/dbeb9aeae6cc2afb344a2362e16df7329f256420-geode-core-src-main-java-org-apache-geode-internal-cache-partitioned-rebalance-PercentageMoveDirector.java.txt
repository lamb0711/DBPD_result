Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Move buckets from one node to another, up to a certain
- * percentage of the source node. Each call to nextStep
- * attempts to move a single bucket.
+ * Move buckets from one node to another, up to a certain percentage of the source node. Each call
+ * to nextStep attempts to move a single bucket.
- * This uses a  first fit decreasing strategy to choose which buckets to
- * move. It sorts the buckets by size, and then moves the largest bucket
- * that is below the load we are trying to move.
+ * This uses a first fit decreasing strategy to choose which buckets to move. It sorts the buckets
+ * by size, and then moves the largest bucket that is below the load we are trying to move.
- * An improvement would be find the bucket that can be moved with the least
- * cost for the most load change, but because the load probe currently
- * use the same value for load and cost, there's no need to complicate things
- * now.
+ * An improvement would be find the bucket that can be moved with the least cost for the most load
+ * change, but because the load probe currently use the same value for load and cost, there's no
+ * need to complicate things now.
-  
+
-  
+
-  
-  public PercentageMoveDirector(DistributedMember source,
-      DistributedMember target, float percentage) {
+
+  public PercentageMoveDirector(DistributedMember source, DistributedMember target,
+      float percentage) {
-    if(sourceMember == null) {
-      throw new IllegalStateException(LocalizedStrings.PERCENTAGE_MOVE_DIRECTORY_SOURCE_NOT_DATA_STORE.toLocalizedString(model.getName(), source));
+    if (sourceMember == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.PERCENTAGE_MOVE_DIRECTORY_SOURCE_NOT_DATA_STORE
+              .toLocalizedString(model.getName(), source));
-    
-    //Figure out how much load we are moving, based on the percentage.
+
+    // Figure out how much load we are moving, based on the percentage.
-    
+
-    
-    //We don't reset the total load to move after a membership change
+
+    // We don't reset the total load to move after a membership change
-    if(sourceMember == null) {
-      throw new IllegalStateException(LocalizedStrings.PERCENTAGE_MOVE_DIRECTORY_SOURCE_NOT_DATA_STORE.toLocalizedString(model.getName(), source));
+    if (sourceMember == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.PERCENTAGE_MOVE_DIRECTORY_SOURCE_NOT_DATA_STORE
+              .toLocalizedString(model.getName(), source));
-    
-   
-    //Build the set of of buckets
+
+
+    // Build the set of of buckets
-    for(Bucket bucket : sourceMember.getBuckets()) {
+    for (Bucket bucket : sourceMember.getBuckets()) {
-      if(bucketLoad <= loadToMove) {
+      if (bucketLoad <= loadToMove) {
-    if(targetMember == null) {
-      throw new IllegalStateException(LocalizedStrings.PERCENTAGE_MOVE_DIRECTORY_TARGET_NOT_DATA_STORE.toLocalizedString(model.getName(), target));
+    if (targetMember == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.PERCENTAGE_MOVE_DIRECTORY_TARGET_NOT_DATA_STORE
+              .toLocalizedString(model.getName(), target));
-    
-    if(targetMember.equals(sourceMember)) {
-      throw new IllegalStateException(LocalizedStrings.PERCENTAGE_MOVE_TARGET_SAME_AS_SOURCE.toLocalizedString(model.getName(), target));
+
+    if (targetMember.equals(sourceMember)) {
+      throw new IllegalStateException(LocalizedStrings.PERCENTAGE_MOVE_TARGET_SAME_AS_SOURCE
+          .toLocalizedString(model.getName(), target));
-    
-    //if there is no largest bucket that we can move, we are done.
-    if(orderedBuckets.isEmpty()) {
+
+    // if there is no largest bucket that we can move, we are done.
+    if (orderedBuckets.isEmpty()) {
-    //Take the largest bucket, and try to move that.
+    // Take the largest bucket, and try to move that.
-    
+
-    
-    //See if we can move this bucket to the taret node.
-    if(targetMember.willAcceptBucket(bucket, sourceMember, model.enforceUniqueZones()).willAccept()) {
-      
-      if(model.moveBucket(new Move(sourceMember, targetMember, bucket))) {
-        //If we had a successful move, decrement the load we should move.
+
+    // See if we can move this bucket to the taret node.
+    if (targetMember.willAcceptBucket(bucket, sourceMember, model.enforceUniqueZones())
+        .willAccept()) {
+
+      if (model.moveBucket(new Move(sourceMember, targetMember, bucket))) {
+        // If we had a successful move, decrement the load we should move.
-      
-        //Remove all of the remaining buckets that are to big to move.
-        //TODO - this could be O(log(n)), rather an O(n)
+
+        // Remove all of the remaining buckets that are to big to move.
+        // TODO - this could be O(log(n)), rather an O(n)
-        while(itr.hasNext()) {
+        while (itr.hasNext()) {
-          if(next.getLoad() > loadToMove) {
+          if (next.getLoad() > loadToMove) {
-    
-    //In any case, remove the bucket from the list of buckets we'll try to move.
+
+    // In any case, remove the bucket from the list of buckets we'll try to move.
-    
+
-      int result = Float.compare(o1.getLoad(),o2.getLoad());
-      if(result == 0) {
+      int result = Float.compare(o1.getLoad(), o2.getLoad());
+      if (result == 0) {
-    
+

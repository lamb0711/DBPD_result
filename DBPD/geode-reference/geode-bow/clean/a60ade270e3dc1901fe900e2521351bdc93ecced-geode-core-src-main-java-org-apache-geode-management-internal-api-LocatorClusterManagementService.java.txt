GEODE-6861: Generify ClusterManagementService (#3708)

* GEODE-6861: Generify ClusterManagementService
+import org.apache.geode.management.api.RespondsWith;
-  private Map<Class, ConfigurationManager<? extends CacheElement>> managers;
+  private Map<Class, ConfigurationManager> managers;
+  private CacheElementValidator commonValidator;
-    this(persistenceService, new HashMap(), new HashMap(), null);
+    this(persistenceService, new HashMap<>(), new HashMap<>(), null, null);
-    validators.put(CacheElement.class, new CacheElementValidator());
+    commonValidator = new CacheElementValidator();
-      Map managers, Map validators, MemberValidator memberValidator) {
+      Map<Class, ConfigurationManager> managers, Map<Class, ConfigurationValidator> validators,
+      MemberValidator memberValidator, CacheElementValidator commonValidator) {
+    this.commonValidator = commonValidator;
-  public ClusterManagementResult create(CacheElement config) {
+  public <T extends CacheElement & RespondsWith<R>, R extends CacheElement> ClusterManagementResult<T> create(
+      T config) {
-      return new ClusterManagementResult(false,
+      return new ClusterManagementResult<>(false,
-    validators.get(CacheElement.class).validate(CacheElementOperation.CREATE, config);
-
+    commonValidator.validate(CacheElementOperation.CREATE, config);
-    ClusterManagementResult result = new ClusterManagementResult();
+    ClusterManagementResult<T> result = new ClusterManagementResult<>();
-  public ClusterManagementResult delete(CacheElement config) {
+  public <T extends CacheElement & RespondsWith<R>, R extends CacheElement> ClusterManagementResult<T> delete(
+      T config) {
-      return new ClusterManagementResult(false,
+      return new ClusterManagementResult<>(false,
-    validators.get(CacheElement.class).validate(CacheElementOperation.DELETE, config);
+    commonValidator.validate(CacheElementOperation.DELETE, config);
-    ClusterManagementResult result = new ClusterManagementResult();
+    ClusterManagementResult<T> result = new ClusterManagementResult<>();
-  public ClusterManagementResult update(CacheElement config) {
+  public <T extends CacheElement & RespondsWith<R>, R extends CacheElement> ClusterManagementResult<T> update(
+      T config) {
-  public <T extends CacheElement> ClusterManagementResult list(T filter) {
-    ConfigurationManager<T> manager = (ConfigurationManager<T>) managers.get(filter.getClass());
+  public <T extends CacheElement & RespondsWith<R>, R extends CacheElement> ClusterManagementResult<R> list(
+      T filter) {
+    ConfigurationManager<T, R> manager = managers.get(filter.getClass());
-    ClusterManagementResult result = new ClusterManagementResult();
+    ClusterManagementResult<R> result = new ClusterManagementResult<>();
-      List<? extends T> listResults = manager.list(filter, null);
+      List<R> listResults = manager.list(filter, null);
-      return new ClusterManagementResult(false,
+      return new ClusterManagementResult<>(false,
-    List<T> resultList = new ArrayList<>();
+    List<R> resultList = new ArrayList<>();
-      List<? extends T> listInGroup = manager.list(filter, currentPersistedConfig);
-      for (T element : listInGroup) {
+      List<R> listInGroup = manager.list(filter, currentPersistedConfig);
+      for (R element : listInGroup) {
-      List<MultiGroupCacheElement> multiGroupList = new ArrayList<>();
-      for (T element : resultList) {
+      List<R> multiGroupList = new ArrayList<>();
+      for (R element : resultList) {
-          MultiGroupCacheElement exist = multiGroupList.get(index);
+          MultiGroupCacheElement exist = (MultiGroupCacheElement) multiGroupList.get(index);
-          multiGroupList.add((MultiGroupCacheElement) element);
+          multiGroupList.add(element);
-            .filter(e -> e.getGroups().contains(filter.getConfigGroup()))
+            .filter(e -> ((MultiGroupCacheElement) e).getGroups().contains(filter.getConfigGroup()))
-      for (MultiGroupCacheElement element : multiGroupList) {
-        if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
+      for (R elem : multiGroupList) {
+        MultiGroupCacheElement element = (MultiGroupCacheElement) elem;
+        if (element.getGroups().size() == 1 && CacheElement.CLUSTER.equals(element.getGroup())) {
-      resultList =
-          (List<T>) multiGroupList.stream().map(CacheElement.class::cast)
-              .collect(Collectors.toList());
+      resultList = multiGroupList;
-      for (T element : resultList) {
-        if ("cluster".equals(element.getGroup())) {
+      for (R element : resultList) {
+        if (CacheElement.CLUSTER.equals(element.getGroup())) {
-  public ClusterManagementResult get(CacheElement config) {
-    ClusterManagementResult list = list(config);
-    List<CacheElement> result = list.getResult(CacheElement.class);
+  public <T extends CacheElement & RespondsWith<R>, R extends CacheElement> ClusterManagementResult<R> get(
+      T config) {
+    ClusterManagementResult<R> list = list(config);
+    List<R> result = list.getResult();
-
-  private ConfigurationManager getConfigurationManager(CacheElement config) {
+  @SuppressWarnings("unchecked")
+  private <T extends CacheElement & RespondsWith<R>, R extends CacheElement> ConfigurationManager<T, R> getConfigurationManager(
+      T config) {

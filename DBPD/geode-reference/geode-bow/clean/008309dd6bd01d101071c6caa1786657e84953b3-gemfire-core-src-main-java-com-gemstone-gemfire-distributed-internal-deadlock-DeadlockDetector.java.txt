Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.ObjectInputStream;
+import java.util.List;
+ * This class also has a main() method that can read serialized DependencyGraphs
+ * from multiple JVMs, merge them and perform various analysis on them.
+ * 
-    for (Dependency dep : dependencies) {
-      graph.addEdge(dep);
-    }
+    graph.addEdges(dependencies);
-   * @return All of the dependencies between threads an locks or other resources
+   * @arg locality a name tag to stick on entities to help associate them with
+   * this JVM and distinguish them from entities from other jvms
+   * 
+   * @return All of the dependencies between threads and locks or other resources
+    
+    Set<Object> seenDependers = new HashSet<>();
+    Object lastDependsOn = text;
+    Object lastDepender = text;
+    
+      
+      String dependerString;
+      if (lastDependsOn.equals(depender)) {
+        dependerString = "which";
+      } else if (lastDepender.equals(depender)){
+        dependerString = "and";
+      } else {
+        dependerString = String.valueOf(depender);
+      }
+      lastDepender = depender;
+      lastDependsOn = dependsOn;
+      
+      String also = seenDependers.contains(depender)? " also" : "";
+      seenDependers.add(depender);
+      
-        text.append(depender + " is waiting on " + dependsOn + "\n");
+        text.append(dependerString).append(" is").append(also).append(" waiting on ").append(dependsOn).append("\n");
-        text.append(depender + " is held by " + dependsOn + "\n");
+        text.append(dependerString).append(" is held by thread ").append(dependsOn).append("\n");
-        text.append(depender + " is waiting for " + dependsOn + "\n");
+        text.append(dependerString).append(" is").append(also).append(" waiting for ").append(dependsOn).append("\n");
+      text.append("\n");
-      text.append(
-          threadInfo.getLocatility() + ":" + threadInfo.getThreadStack())
+      text.append(threadInfo.getLocatility())
+          .append(":")
+          .append(threadInfo.getThreadStack())
+  
+  
+  /**
+   * attempts to sort the given dependencies according to their contents
+   * so that dependents come after dependers.
+   * @param dependencies
+   * TODO this method needs more work
+   */
+  public static List<Dependency> sortDependencies(Collection<Dependency> dependencies) {
+    List<Dependency> result = new LinkedList<>();
+    for (Dependency dep: dependencies) {
+      boolean added = false;
+      for (int i=0; i<result.size(); i++) {
+        Dependency other = result.get(i);
+        if (other.depender.equals(dep.depender)) {
+          result.add(i, dep);
+          added = true;
+          break;
+        }
+        if (other.depender.equals(dep.dependsOn)) {
+          result.add(i, dep);
+          added = true;
+          break;
+        }
+      }
+      if (!added) {
+        result.add(dep);
+      }
+    }
+    return result;
+  }
+  
+  private static DependencyGraph loadGraphs(int startingAt, String... mainArgs) throws Exception {
+    String filename;
+    if (mainArgs.length < startingAt+1) {
+      return loadGraph("thread_dependency_graph.ser");
+    }
+    
+    DependencyGraph result = new DependencyGraph();
+    
+    for (int i=startingAt; i<mainArgs.length; i++) {
+      filename = mainArgs[i];
+      DependencyGraph gr = loadGraph(filename);
+      if (gr == null) {
+        return null;
+      }
+      result.addEdges(gr.getEdges());
+    }
+    
+    return result;
+  }
+  
+  private static DependencyGraph loadGraph(String filename) throws Exception {
+    File file = new File(filename);
+    if (!file.exists()) {
+      System.err.println("unable to find " + filename);
+      System.exit(-1);
+    }
+
+    ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file)));
+    DependencyGraph graph = (DependencyGraph) ois.readObject();
+
+    return graph;
+  }
+  
+  
+  private static void printHelp() {
+    System.out.println("DeadlockDetector reads serialized graphs of the state of the distributed");
+    System.out.println("system created by collectDependencies.");
+    System.out.println();
+    System.out.println("usage: ");
+    System.out.println("[print | findImpasse | findCycle | findObject objectName ] file1 ...");
+    System.out.println();
+    System.out.println("print - prints all dependencies and threads in the graph");
+    System.out.println("findImpasse - looks for either a deadlock or the longest call chain in the graph");
+    System.out.println("findCycle - looks for a deadlock");
+    System.out.println("findObject - finds the given object (thread, lock, message) by name/partial name and finds all call chains leading to that object");
+  }
+
+  public static void main(String... args) throws Exception {
+    if (args.length == 0) {
+      printHelp();
+      return;
+    }
+    
+    DependencyGraph graph;
+
+    switch (args[0]) {
+    case "print":
+      graph = loadGraphs(1, args);
+      System.out.println(prettyFormat(graph));
+      break;
+    case "findCycle":
+      graph = loadGraphs(1, args);
+      List<Dependency> cycle = graph.findCycle();
+      if (cycle == null) {
+        System.out.println("no deadlock found");
+      } else {
+        System.out.println("deadlocked threads: \n" + cycle);
+      }
+      break;
+    case "findImpasse":
+      graph = loadGraphs(1, args);
+      graph = graph.findLongestCallChain();
+      if (graph == null) {
+        System.out.println("no long call chain could be found!");
+      } else {
+        System.out.println("longest call chain: \n" + prettyFormat(graph));
+      }
+      break;
+    case "findObject":
+      graph = loadGraphs(2, args);
+      List<DependencyGraph> graphs = graph.findDependenciesWith(args[1]);
+      if (graphs.isEmpty()) {
+        System.out.println("thread not found! Try using the print command to see all threads and locate the name of the one you're interested in?");
+      } else {
+        int numGraphs = graphs.size();
+        int i=0;
+        System.out.println("findObject \"" + args[1]+"\"\n\n");
+        for (DependencyGraph g: graphs) {
+          i += 1;
+          System.out.println("graph " + i + " of " + numGraphs + ":");
+          System.out.println(prettyFormat(sortDependencies(g.getEdges())));
+          if (i < numGraphs) {
+            System.out.println("\n\n\n");
+          }
+        }
+      }
+      break;
+    default:
+      printHelp();
+      break;
+    }
+    
+  }
+  

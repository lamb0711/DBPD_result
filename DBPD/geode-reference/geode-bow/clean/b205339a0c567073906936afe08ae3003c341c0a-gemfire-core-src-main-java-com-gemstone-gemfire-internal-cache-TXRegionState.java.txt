Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.internal.cache.TXEntryState.DistTxThinEntryState;
-import com.gemstone.gemfire.internal.util.concurrent.StoppableReentrantReadWriteLock;
+import com.gemstone.gemfire.internal.logging.LogService;
+import org.apache.logging.log4j.Logger;
+
+  private static final Logger logger = LogService.getLogger();
+  
-  private LocalRegion region;
+  private LocalRegion region;
-  
+  /*
+   * For Distributed Tx
+   * Created during precommit, to apply changes on secondaries/replicates from coordinator.
+   */
+  private boolean createdDuringCommit;
-    TXEntryState result = cache.getTXEntryStateFactory().createEntry(re, vId, pendingValue, entryKey, this);
+    boolean isDistributed = false;
+    if (cache.getTxManager().getTXState() != null) {
+      isDistributed = cache.getTxManager().getTXState().isDistTx(); 
+    }
+    else {
+      // TXCoordinator and datanode are same
+      isDistributed = cache.getTxManager().isDistributed();
+    }
+    TXEntryState result = cache.getTXEntryStateFactory().createEntry(re, vId, pendingValue, entryKey, this, isDistributed);
+  
+  TXEntryState getTXEntryState(Object key) {
+    return this.entryMods.get(key);
+  }
+    if (this.txState.logger.isDebugEnabled()) {
+      this.txState.logger.debug("TXRegionState.createLockRequest 1 "
+          + r.getClass().getSimpleName() + " region-state=" + this);
+    }
+      // [DISTTX] Do not take lock for RR on replicates
+      if (this.isCreatedDuringCommit()) {
+        return;
+      }
+    if (this.txState.logger.isDebugEnabled()) {
+      this.txState.logger.debug("TXRegionState.createLockRequest 2");
+    }
+    if (this.isCreatedDuringCommit()) {
+      return;
+    }
-  
-  
+    
-}
+
+  public void close() {
+    for (TXEntryState e: this.entryMods.values()) {
+      e.close();
+    }
+  }
+  
+  @Override
+  public String toString() {
+    StringBuilder str = new StringBuilder();
+    str.append("{").append(super.toString()).append(" ");
+    str.append(" ,entryMods=").append(this.entryMods);
+    str.append(" ,isCreatedDuringCommit=").append(this.isCreatedDuringCommit());
+    str.append("}");
+    return str.toString();
+  }
+
+  /**
+   * @return the createdDuringCommit
+   */
+  public boolean isCreatedDuringCommit() {
+    return createdDuringCommit;
+  }
+
+  /**
+   * @param createdDuringCommit
+   *          the createdDuringCommit to set
+   */
+  public void setCreatedDuringCommit(boolean createdDuringCommit) {
+    this.createdDuringCommit = createdDuringCommit;
+  }
+  
+  public boolean populateDistTxEntryStateList(
+      ArrayList<DistTxThinEntryState> entryStateList) {
+    String regionFullPath = this.getRegion().getFullPath();
+    try {
+      if (!this.entryMods.isEmpty()) {
+        // [DISTTX] TODO Sort this first
+        for (Entry<Object, TXEntryState> em : this.entryMods.entrySet()) {
+          Object mKey = em.getKey();
+          TXEntryState txes = em.getValue();
+          DistTxThinEntryState thinEntryState = txes.getDistTxEntryStates();
+          entryStateList.add(thinEntryState);
+          if (logger.isDebugEnabled()) {
+            logger.debug("TXRegionState.populateDistTxEntryStateList Added "
+                + thinEntryState + " for key=" + mKey + " ,op="
+                + txes.opToString() + " ,region=" + regionFullPath);
+          }
+        }
+      }
+      return true;
+    } catch (RegionDestroyedException ex) {
+      // region was destroyed out from under us; after conflict checking
+      // passed. So act as if the region destroy happened right after the
+      // commit. We act this way by doing nothing; including distribution
+      // of this region's commit data.
+    } catch (CancelException ex) {
+      // cache was closed out from under us; after conflict checking
+      // passed. So do nothing.
+    }
+    if (logger.isDebugEnabled()) {
+      logger
+          .debug("TXRegionState.populateDistTxEntryStateList Got exception for region "
+              + regionFullPath);
+    }
+    return false;
+  }
+  
+  public void setDistTxEntryStates(
+      ArrayList<DistTxThinEntryState> entryEventList) {
+    String regionFullPath = this.getRegion().getFullPath();
+    int entryModsSize = this.entryMods.size();
+    int entryEventListSize = entryEventList.size();
+    if (entryModsSize != entryEventListSize) {
+      throw new UnsupportedOperationInTransactionException(
+          LocalizedStrings.DISTTX_TX_EXPECTED.toLocalizedString(
+              "entry size of " + entryModsSize + " for region "
+                  + regionFullPath, entryEventListSize));
+    }
+
+    int index = 0;
+    // [DISTTX] TODO Sort this first
+    for (Entry<Object, TXEntryState> em : this.entryMods.entrySet()) {
+      Object mKey = em.getKey();
+      TXEntryState txes = em.getValue();
+      DistTxThinEntryState thinEntryState = entryEventList.get(index++);
+      txes.setDistTxEntryStates(thinEntryState);
+      if (logger.isDebugEnabled()) {
+        logger.debug("TxRegionState.setDistTxEntryStates Added "
+            + thinEntryState + " for key=" + mKey + " ,op=" + txes.opToString()
+            + " ,region=" + regionFullPath);
+      }
+    }
+  }
+}

GEODE-6412: Improve concurrency for getBucketIndex (#3198)

  * Caching an arbitrary index instead of finding one for every getBucketIndex call
  * Refactored to use jmh asych group threads
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
+import org.openjdk.jmh.annotations.Group;
+import org.openjdk.jmh.annotations.GroupThreads;
-import org.openjdk.jmh.annotations.TearDown;
+
-  private static final int TIME_TO_QUIESCE_BEFORE_SAMPLING = 1;
-
-  private static final int THREAD_POOL_PROCESSOR_MULTIPLE = 2;
-
-  private ScheduledThreadPoolExecutor loadGenerationExecutorService;
-
-  private static boolean testRunning = true;
-
-  public void trialSetup() throws InterruptedException {
+  public void trialSetup() throws InterruptedException {}
-    final int numberOfThreads =
-        THREAD_POOL_PROCESSOR_MULTIPLE * Runtime.getRuntime().availableProcessors();
-    loadGenerationExecutorService =
-        (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(
-            numberOfThreads);
-
-    System.out.println(String.format("Pool has %d threads", numberOfThreads));
-
-    loadGenerationExecutorService.setRemoveOnCancelPolicy(true);
-
-    generateLoad(
-        loadGenerationExecutorService, numberOfThreads);
-
-    // allow system to quiesce
-    Thread.sleep(TIME_TO_QUIESCE_BEFORE_SAMPLING);
-  }
-
-  @TearDown(Level.Trial)
-  public void trialTeardown() {
-    testRunning = false;
-    loadGenerationExecutorService.shutdownNow();
+  @Group("getBucketIndexThroughput")
+  @GroupThreads(10)
+  @Benchmark
+  public void getBucketIndexLoad() {
+    JavaWorkarounds.computeIfAbsent(map, 1, k -> k);
+  @Group("computeIfAbsentThroughput")
+  @GroupThreads(1)
-  private void generateLoad(final ScheduledExecutorService executorService, int numThreads) {
-    for (int i = 0; i < numThreads; i++) {
-      executorService.schedule(() -> {
-        while (testRunning) {
-          JavaWorkarounds.computeIfAbsent(map, 1, k -> k);
-        }
-      }, 0, TimeUnit.MILLISECONDS);
-    }
-  }
-

Merge branch 'develop' of https://git-wip-us.apache.org/repos/asf/geode into develop

* 'develop' of https://git-wip-us.apache.org/repos/asf/geode: (57 commits)
  GEODE-2551 Fix code issues found by AppChecker
  Revert "GEODE-1887: Now Size api goes through ServerProxy when cache is of type client and DataPolicy is Empty."
  GEODE-2538: Don't deserialize values on the server when getting results
  GEODE-2461: remove json4s-ast_2.10 as explicit dependency
  GEODE-2547: Interest registration no longer causes a CacheLoader to be invoked
  GEODE-2526: Enhance log statement to include ResourceTypeName
  GEODE-880 Remove unused classes
  GEODE-2460: update dependency versions
  GEODE-1995: Removed ReliableMessageQueue, ReliableMessageQueueFactory, ReliableMessageQueueFactoryImpl and it's usage in the code from GemfireCacheImpl and DistributedRegion.
  GEODE-2550 Improve README and BUILDING
  GEODE-2538: Don't invoke a cache loader when fetching values for a lucene query
  GEODE-2404: Added support for destroying lucene indexes
  GEODE-2545: NPE during lucene query execution when cache is closing or region is destroyed
  GEODE-2515: Disabling BaseLineAndCompareQueryPerfJUnitTest
  GEODE-2142: Removing JSON licence stuff from NOTICE files
  GEODE-2142: removing tests so run precheckin
  GEODE-2142: final compiling build
  GEODE-2142: cyclical dependency in gradle build
  GEODE-2142: spotless
  GEODE-2142: Refactoring of tests to work with new JSONObject class. Changing file export to use Base64 encoding.
  ...

+import org.apache.geode.CancelException;
+import org.apache.geode.cache.asyncqueue.internal.AsyncEventQueueImpl;
+import org.apache.geode.distributed.internal.ReplyException;
+import org.apache.geode.distributed.internal.ReplyProcessor21;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import java.util.Set;
+
+  public static final String FILES_REGION_SUFFIX = ".files";
+  public static final String CHUNKS_REGION_SUFFIX = ".chunks";
+
-    return LuceneServiceImpl.getUniqueIndexName(indexName, regionPath) + ".files";
+    return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);
-    return LuceneServiceImpl.getUniqueIndexName(indexName, regionPath) + ".chunks";
+    return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, CHUNKS_REGION_SUFFIX);
+
+  @Override
+  public void destroy(boolean initiator) {
+    if (logger.isDebugEnabled()) {
+      logger.debug("Destroying index regionPath=" + regionPath + "; indexName=" + indexName
+          + "; initiator=" + initiator);
+    }
+
+    // Invoke super destroy to remove the extension
+    super.destroy(initiator);
+
+    // Destroy the AsyncEventQueue
+    PartitionedRegion pr = (PartitionedRegion) getDataRegion();
+    destroyAsyncEventQueue(pr);
+
+    // Destroy the chunk region (colocated with the file region)
+    // localDestroyRegion can't be used because locally destroying regions is not supported on
+    // colocated regions
+    if (!chunkRegion.isDestroyed()) {
+      chunkRegion.destroyRegion();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Destroyed chunkRegion=" + chunkRegion.getName());
+      }
+    }
+
+    // Destroy the file region (colocated with the application region)
+    // localDestroyRegion can't be used because locally destroying regions is not supported on
+    // colocated regions
+    if (!fileRegion.isDestroyed()) {
+      fileRegion.destroyRegion();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Destroyed fileRegion=" + fileRegion.getName());
+      }
+    }
+
+    // Destroy index on remote members if necessary
+    if (initiator) {
+      destroyOnRemoteMembers(pr);
+    }
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("Destroyed index regionPath=" + regionPath + "; indexName=" + indexName
+          + "; initiator=" + initiator);
+    }
+  }
+
+  private void destroyAsyncEventQueue(PartitionedRegion pr) {
+    String aeqId = LuceneServiceImpl.getUniqueIndexName(indexName, regionPath);
+
+    // Get the AsyncEventQueue
+    AsyncEventQueueImpl aeq = (AsyncEventQueueImpl) cache.getAsyncEventQueue(aeqId);
+
+    // Stop the AsyncEventQueue (this stops the AsyncEventQueue's underlying GatewaySender)
+    aeq.stop();
+
+    // Remove the id from the dataRegion's AsyncEventQueue ids
+    // Note: The region may already have been destroyed by a remote member
+    if (!pr.isDestroyed()) {
+      pr.getAttributesMutator().removeAsyncEventQueueId(aeqId);
+    }
+
+    // Destroy the aeq (this also removes it from the GemFireCacheImpl)
+    aeq.destroy();
+    if (logger.isDebugEnabled()) {
+      logger.debug("Destroyed aeqId=" + aeqId);
+    }
+  }
+
+  private void destroyOnRemoteMembers(PartitionedRegion pr) {
+    DM dm = pr.getDistributionManager();
+    Set<InternalDistributedMember> recipients = pr.getRegionAdvisor().adviseDataStore();
+    if (!recipients.isEmpty()) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("LuceneIndexForPartitionedRegion: About to send destroy message recipients="
+            + recipients);
+      }
+      ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);
+      DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients,
+          processor.getProcessorId(), regionPath, indexName);
+      dm.putOutgoing(message);
+      if (logger.isDebugEnabled()) {
+        logger.debug("LuceneIndexForPartitionedRegion: Sent message recipients=" + recipients);
+      }
+      try {
+        processor.waitForReplies();
+      } catch (ReplyException e) {
+        if (!(e.getCause() instanceof CancelException)) {
+          throw e;
+        }
+      } catch (InterruptedException e) {
+        dm.getCancelCriterion().checkCancelInProgress(e);
+        Thread.currentThread().interrupt();
+      }
+    }
+  }

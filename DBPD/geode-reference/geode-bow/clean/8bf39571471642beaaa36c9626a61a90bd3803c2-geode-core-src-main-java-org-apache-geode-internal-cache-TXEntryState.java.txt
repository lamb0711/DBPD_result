Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * TXEntryState is the entity that tracks transactional changes, except for
- * those tracked by {@link TXEntryUserAttrState}, to an entry.
+ * TXEntryState is the entity that tracks transactional changes, except for those tracked by
+ * {@link TXEntryUserAttrState}, to an entry.
- *  
+ * 
-public class TXEntryState implements Releasable
-  {
+public class TXEntryState implements Releasable {
-  
+
-   * Serial number that is set each time this entry is modified. Used to order
-   * the events in a TransactionEvent.
+   * Serial number that is set each time this entry is modified. Used to order the events in a
+   * TransactionEvent.
+   * 
+   * 
-  
+
-   * System property to be set when read conflicts should be detected.
-   * Benefits of read conflict detection are at:
-   * https://wiki.gemstone.com/display/PR/Read+conflict+detection
+   * System property to be set when read conflicts should be detected. Benefits of read conflict
+   * detection are at: https://wiki.gemstone.com/display/PR/Read+conflict+detection
-  private static final boolean DETECT_READ_CONFLICTS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "detectReadConflicts");
+  private static final boolean DETECT_READ_CONFLICTS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "detectReadConflicts");
-  //      that is only created by TXRegionState when it knows its region needs refCounts.
+  // that is only created by TXRegionState when it knows its region needs refCounts.
-   * A reference to the RegionEntry, in committed state, that this tx entry has
-   * referenced. Note: this field is only needed if the committed region
-   * has eviction or expiration enabled. In both those cases the tx needs to do
-   * reference counting.
+   * A reference to the RegionEntry, in committed state, that this tx entry has referenced. Note:
+   * this field is only needed if the committed region has eviction or expiration enabled. In both
+   * those cases the tx needs to do reference counting.
-  
+
-   * Set to true if this operation is result of a bulk op. We use this
-   * boolean to determine op type rather than extending the operation algebra.
+   * Set to true if this operation is result of a bulk op. We use this boolean to determine op type
+   * rather than extending the operation algebra.
-  private FilterRoutingInfo filterRoutingInfo =null;
+  private FilterRoutingInfo filterRoutingInfo = null;
-   * versionTag to be sent to other members. This is propogated up from AbstractRegionMap
-   * and then used while building TXCommitMessage
+   * versionTag to be sent to other members. This is propogated up from AbstractRegionMap and then
+   * used while building TXCommitMessage
-   * tailKey (used by wan) to be sent to other members. This is propagated up from
-   * AbstractRegionMap and then used while building TXCommitMessage
+   * tailKey (used by wan) to be sent to other members. This is propagated up from AbstractRegionMap
+   * and then used while building TXCommitMessage
-   * versionTag that is fetched from remote members, if this member's data policy
-   * is not REPLICATE
+   * versionTag that is fetched from remote members, if this member's data policy is not REPLICATE
-  
+
-   * For Distributed Transaction.
-   * THis value is set when applying commit
+   * For Distributed Transaction. THis value is set when applying commit
-  
+
-  private static final boolean VERBOSE_CONFLICT_STRING = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "verboseConflictString");
+  private static final boolean VERBOSE_CONFLICT_STRING =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "verboseConflictString");
-   * This constructor is used to create a singleton used by LocalRegion to
-   * signal that noop invalidate op has been performed. The instance returned by
-   * this constructor is just a marker; it is not good for anything else.
+   * This constructor is used to create a singleton used by LocalRegion to signal that noop
+   * invalidate op has been performed. The instance returned by this constructor is just a marker;
+   * it is not good for anything else.
-  
-  
+
+
-  protected TXEntryState(RegionEntry re, Object pvId, Object pv, TXRegionState txRegionState, boolean isDistributed) {
+  protected TXEntryState(RegionEntry re, Object pvId, Object pv, TXRegionState txRegionState,
+      boolean isDistributed) {
-  
+
-  
-  public Object getOriginalVersionId()
-  {
+
+  public Object getOriginalVersionId() {
-  public Object getPendingValue()
-  {
+  public Object getPendingValue() {
-  
-  public Object getCallbackArgument()
-  {
+
+  public Object getCallbackArgument() {
-   * Gets the pending value for near side operations. Special cases local
-   * destroy and local invalidate to fix bug 34387.
+   * Gets the pending value for near side operations. Special cases local destroy and local
+   * invalidate to fix bug 34387.
-  public Object getNearSidePendingValue()
-  {
+  public Object getNearSidePendingValue() {
-    }
-    else if (isOpLocalInvalidate()) {
+    } else if (isOpLocalInvalidate()) {
-    }
-    else {
+    } else {
-  void setPendingValue(Object pv)
-  {
+  void setPendingValue(Object pv) {
-  
-  void setCallbackArgument(Object callbackArgument)
-  {
+
+  void setCallbackArgument(Object callbackArgument) {
-   * Fetches the current modification serial number from the txState and puts it in
-   * this entry.
+   * Fetches the current modification serial number from the txState and puts it in this entry.
+   * 
-  public void updateForWrite(final int modNum)
-  {
+  public void updateForWrite(final int modNum) {
+   * 
+
+   * 
+
-   * Returns true if the transaction state has this entry existing "locally".
-   * Returns false if the transaction is going to remove this entry.
+   * Returns true if the transaction state has this entry existing "locally". Returns false if the
+   * transaction is going to remove this entry.
-  public boolean existsLocally()
-  {
+  public boolean existsLocally() {
-    }
-    else {
+    } else {
-  private boolean isOpLocalDestroy()
-  {
+  private boolean isOpLocalDestroy() {
-  private boolean isOpLocalInvalidate()
-  {
+  private boolean isOpLocalInvalidate() {
-   * Return true if this transaction has completely invalidated or destroyed the
-   * value of this entry in the entire distributed system. Return false if a
-   * netsearch should be done.
+   * Return true if this transaction has completely invalidated or destroyed the value of this entry
+   * in the entire distributed system. Return false if a netsearch should be done.
-  public boolean noValueInSystem()
-  {
-    if (this.op == OP_D_DESTROY || this.op == OP_D_INVALIDATE_LD
-        || this.op == OP_D_INVALIDATE) {
+  public boolean noValueInSystem() {
+    if (this.op == OP_D_DESTROY || this.op == OP_D_INVALIDATE_LD || this.op == OP_D_INVALIDATE) {
-    }
-    else if (getNearSidePendingValue() == Token.INVALID) {
+    } else if (getNearSidePendingValue() == Token.INVALID) {
-      return (this.op >= OP_CREATE_LD && this.op != OP_L_INVALIDATE
-          && this.op != OP_SEARCH_CREATE && this.op != OP_LOCAL_CREATE && this.op != OP_SEARCH_PUT);
-    }
-    else {
+      return (this.op >= OP_CREATE_LD && this.op != OP_L_INVALIDATE && this.op != OP_SEARCH_CREATE
+          && this.op != OP_LOCAL_CREATE && this.op != OP_SEARCH_PUT);
+    } else {
-   * Returns true if the transaction state has this entry existing locally and
-   * has a valid local value. Returns false if the transaction is going to
-   * remove this entry or its local value is invalid.
+   * Returns true if the transaction state has this entry existing locally and has a valid local
+   * value. Returns false if the transaction is going to remove this entry or its local value is
+   * invalid.
-  public boolean isLocallyValid(boolean isProxy)
-  {
+  public boolean isLocallyValid(boolean isProxy) {
-      }
-      else {
+      } else {
-    }
-    else {
-      return this.op >= OP_CREATE
-          && !Token.isInvalid(getNearSidePendingValue());
+    } else {
+      return this.op >= OP_CREATE && !Token.isInvalid(getNearSidePendingValue());
-  public Object getValueInVM(Object key) throws EntryNotFoundException
-  {
+  public Object getValueInVM(Object key) throws EntryNotFoundException {
-   * @return the value, or null if the value does not exist in the cache,
-   *         Token.INVALID or Token.LOCAL_INVALID if the value is invalid
+   * @return the value, or null if the value does not exist in the cache, Token.INVALID or
+   *         Token.LOCAL_INVALID if the value is invalid
-  public Object getValue(Object key, Region r, boolean preferCD)
-  {
+  public Object getValue(Object key, Region r, boolean preferCD) {
-      v = ((CachedDeserializable)v).getDeserializedValue(r, this.refCountEntry);
+      v = ((CachedDeserializable) v).getDeserializedValue(r, this.refCountEntry);
-    
+
-  private final boolean isOpCreate()
-  {
+  private final boolean isOpCreate() {
-  final boolean isOpCreateEvent()
-  {
+  final boolean isOpCreateEvent() {
-  private final boolean isOpPut()
-  {
+  private final boolean isOpPut() {
-  protected final boolean isOpPutEvent()
-  {
+  protected final boolean isOpPutEvent() {
-  private final boolean isOpInvalidate()
-  {
+  private final boolean isOpInvalidate() {
-  final boolean isOpInvalidateEvent()
-  {
+  final boolean isOpInvalidateEvent() {
-  private final boolean isOpDestroy()
-  {
+  private final boolean isOpDestroy() {
-  final boolean isOpDestroyEvent(LocalRegion r)
-  {
+  final boolean isOpDestroyEvent(LocalRegion r) {
-  final boolean isOpAnyEvent(LocalRegion r)
-  {
-    return isOpPutEvent() || isOpCreateEvent() || isOpInvalidateEvent()
-        || isOpDestroyEvent(r);
+  final boolean isOpAnyEvent(LocalRegion r) {
+    return isOpPutEvent() || isOpCreateEvent() || isOpInvalidateEvent() || isOpDestroyEvent(r);
-  final boolean isOpSearchOrLoad()
-  {
-    return this.op >= OP_SEARCH_CREATE && this.op != OP_PUT
-        && this.op != OP_LOCAL_CREATE;
+  final boolean isOpSearchOrLoad() {
+    return this.op >= OP_SEARCH_CREATE && this.op != OP_PUT && this.op != OP_LOCAL_CREATE;
-  final boolean isOpSearch()
-  {
+  final boolean isOpSearch() {
-  final boolean isOpLocalLoad()
-  {
+  final boolean isOpLocalLoad() {
-  final boolean isOpNetLoad()
-  {
+  final boolean isOpNetLoad() {
-  final boolean isOpLoad()
-  {
+  final boolean isOpLoad() {
-//  private final boolean isLocalEventDistributed()
-//  {
-//    return this.op == OP_D_DESTROY
-//        || (this.op >= OP_D_INVALIDATE && this.op != OP_SEARCH_CREATE
-//            && this.op != OP_LOCAL_CREATE && this.op != OP_SEARCH_PUT);
-//  }
+  // private final boolean isLocalEventDistributed()
+  // {
+  // return this.op == OP_D_DESTROY
+  // || (this.op >= OP_D_INVALIDATE && this.op != OP_SEARCH_CREATE
+  // && this.op != OP_LOCAL_CREATE && this.op != OP_SEARCH_PUT);
+  // }
-  String opToString()
-  {
+  String opToString() {
-  private String opToString(byte opCode)
-  {
+  private String opToString(byte opCode) {
-    case OP_NULL:
-      return "OP_NULL";
-    case OP_L_DESTROY:
-      return "OP_L_DESTROY";
-    case OP_CREATE_LD:
-      return "OP_CREATE_LD";
-    case OP_LLOAD_CREATE_LD:
-      return "OP_LLOAD_CREATE_LD";
-    case OP_NLOAD_CREATE_LD:
-      return "OP_NLOAD_CREATE_LD";
-    case OP_PUT_LD:
-      return "OP_PUT_LD";
-    case OP_LLOAD_PUT_LD:
-      return "OP_LLOAD_PUT_LD";
-    case OP_NLOAD_PUT_LD:
-      return "OP_NLOAD_PUT_LD";
-    case OP_D_INVALIDATE_LD:
-      return "OP_D_INVALIDATE_LD";
-    case OP_D_DESTROY:
-      return "OP_D_DESTROY";
-    case OP_L_INVALIDATE:
-      return "OP_L_INVALIDATE";
-    case OP_PUT_LI:
-      return "OP_PUT_LI";
-    case OP_LLOAD_PUT_LI:
-      return "OP_LLOAD_PUT_LI";
-    case OP_NLOAD_PUT_LI:
-      return "OP_NLOAD_PUT_LI";
-    case OP_D_INVALIDATE:
-      return "OP_D_INVALIDATE";
-    case OP_CREATE_LI:
-      return "OP_CREATE_LI";
-    case OP_LLOAD_CREATE_LI:
-      return "OP_LLOAD_CREATE_LI";
-    case OP_NLOAD_CREATE_LI:
-      return "OP_NLOAD_CREATE_LI";
-    case OP_CREATE:
-      return "OP_CREATE";
-    case OP_SEARCH_CREATE:
-      return "OP_SEARCH_CREATE";
-    case OP_LLOAD_CREATE:
-      return "OP_LLOAD_CREATE";
-    case OP_NLOAD_CREATE:
-      return "OP_NLOAD_CREATE";
-    case OP_LOCAL_CREATE:
-      return "OP_LOCAL_CREATE";
-    case OP_PUT:
-      return "OP_PUT";
-    case OP_SEARCH_PUT:
-      return "OP_SEARCH_PUT";
-    case OP_LLOAD_PUT:
-      return "OP_LLOAD_PUT";
-    case OP_NLOAD_PUT:
-      return "OP_NLOAD_PUT";
-    default:
-      return "<unhandled op " + opCode + " >";
+      case OP_NULL:
+        return "OP_NULL";
+      case OP_L_DESTROY:
+        return "OP_L_DESTROY";
+      case OP_CREATE_LD:
+        return "OP_CREATE_LD";
+      case OP_LLOAD_CREATE_LD:
+        return "OP_LLOAD_CREATE_LD";
+      case OP_NLOAD_CREATE_LD:
+        return "OP_NLOAD_CREATE_LD";
+      case OP_PUT_LD:
+        return "OP_PUT_LD";
+      case OP_LLOAD_PUT_LD:
+        return "OP_LLOAD_PUT_LD";
+      case OP_NLOAD_PUT_LD:
+        return "OP_NLOAD_PUT_LD";
+      case OP_D_INVALIDATE_LD:
+        return "OP_D_INVALIDATE_LD";
+      case OP_D_DESTROY:
+        return "OP_D_DESTROY";
+      case OP_L_INVALIDATE:
+        return "OP_L_INVALIDATE";
+      case OP_PUT_LI:
+        return "OP_PUT_LI";
+      case OP_LLOAD_PUT_LI:
+        return "OP_LLOAD_PUT_LI";
+      case OP_NLOAD_PUT_LI:
+        return "OP_NLOAD_PUT_LI";
+      case OP_D_INVALIDATE:
+        return "OP_D_INVALIDATE";
+      case OP_CREATE_LI:
+        return "OP_CREATE_LI";
+      case OP_LLOAD_CREATE_LI:
+        return "OP_LLOAD_CREATE_LI";
+      case OP_NLOAD_CREATE_LI:
+        return "OP_NLOAD_CREATE_LI";
+      case OP_CREATE:
+        return "OP_CREATE";
+      case OP_SEARCH_CREATE:
+        return "OP_SEARCH_CREATE";
+      case OP_LLOAD_CREATE:
+        return "OP_LLOAD_CREATE";
+      case OP_NLOAD_CREATE:
+        return "OP_NLOAD_CREATE";
+      case OP_LOCAL_CREATE:
+        return "OP_LOCAL_CREATE";
+      case OP_PUT:
+        return "OP_PUT";
+      case OP_SEARCH_PUT:
+        return "OP_SEARCH_PUT";
+      case OP_LLOAD_PUT:
+        return "OP_LLOAD_PUT";
+      case OP_NLOAD_PUT:
+        return "OP_NLOAD_PUT";
+      default:
+        return "<unhandled op " + opCode + " >";
-   * Returns an Operation instance that matches what the transactional operation
-   * done on this entry in the cache the the transaction was performed in.
+   * Returns an Operation instance that matches what the transactional operation done on this entry
+   * in the cache the the transaction was performed in.
-  protected Operation getNearSideOperation()
-  {
+  protected Operation getNearSideOperation() {
-    case OP_NULL:
-      return null;
-    case OP_L_DESTROY:
-      return Operation.LOCAL_DESTROY;
-    case OP_CREATE_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_LLOAD_CREATE_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_NLOAD_CREATE_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_PUT_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_LLOAD_PUT_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_NLOAD_PUT_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_D_INVALIDATE_LD:
-      return Operation.LOCAL_DESTROY;
-    case OP_D_DESTROY:
-      return getDestroyOperation();
-    case OP_L_INVALIDATE:
-      return Operation.LOCAL_INVALIDATE;
-    case OP_PUT_LI:
-      return Operation.LOCAL_INVALIDATE;
-    case OP_LLOAD_PUT_LI:
-      return Operation.LOCAL_INVALIDATE;
-    case OP_NLOAD_PUT_LI:
-      return Operation.LOCAL_INVALIDATE;
-    case OP_D_INVALIDATE:
-      return Operation.INVALIDATE;
-    case OP_CREATE_LI:
-      return getCreateOperation();
-    case OP_LLOAD_CREATE_LI:
-      return getCreateOperation();
-    case OP_NLOAD_CREATE_LI:
-      return getCreateOperation();
-    case OP_CREATE:
-      return getCreateOperation();
-    case OP_SEARCH_CREATE:
-      return Operation.SEARCH_CREATE;
-    case OP_LLOAD_CREATE:
-      return Operation.LOCAL_LOAD_CREATE;
-    case OP_NLOAD_CREATE:
-      return Operation.NET_LOAD_CREATE;
-    case OP_LOCAL_CREATE:
-      return getCreateOperation();
-    case OP_PUT:
-      return getUpdateOperation();
-    case OP_SEARCH_PUT:
-      return Operation.SEARCH_UPDATE;
-    case OP_LLOAD_PUT:
-      return Operation.LOCAL_LOAD_UPDATE;
-    case OP_NLOAD_PUT:
-      return Operation.NET_LOAD_CREATE;
-    default:
-      throw new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_OP_0.toLocalizedString(Byte.valueOf(this.op)));
+      case OP_NULL:
+        return null;
+      case OP_L_DESTROY:
+        return Operation.LOCAL_DESTROY;
+      case OP_CREATE_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_LLOAD_CREATE_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_NLOAD_CREATE_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_PUT_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_LLOAD_PUT_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_NLOAD_PUT_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_D_INVALIDATE_LD:
+        return Operation.LOCAL_DESTROY;
+      case OP_D_DESTROY:
+        return getDestroyOperation();
+      case OP_L_INVALIDATE:
+        return Operation.LOCAL_INVALIDATE;
+      case OP_PUT_LI:
+        return Operation.LOCAL_INVALIDATE;
+      case OP_LLOAD_PUT_LI:
+        return Operation.LOCAL_INVALIDATE;
+      case OP_NLOAD_PUT_LI:
+        return Operation.LOCAL_INVALIDATE;
+      case OP_D_INVALIDATE:
+        return Operation.INVALIDATE;
+      case OP_CREATE_LI:
+        return getCreateOperation();
+      case OP_LLOAD_CREATE_LI:
+        return getCreateOperation();
+      case OP_NLOAD_CREATE_LI:
+        return getCreateOperation();
+      case OP_CREATE:
+        return getCreateOperation();
+      case OP_SEARCH_CREATE:
+        return Operation.SEARCH_CREATE;
+      case OP_LLOAD_CREATE:
+        return Operation.LOCAL_LOAD_CREATE;
+      case OP_NLOAD_CREATE:
+        return Operation.NET_LOAD_CREATE;
+      case OP_LOCAL_CREATE:
+        return getCreateOperation();
+      case OP_PUT:
+        return getUpdateOperation();
+      case OP_SEARCH_PUT:
+        return Operation.SEARCH_UPDATE;
+      case OP_LLOAD_PUT:
+        return Operation.LOCAL_LOAD_UPDATE;
+      case OP_NLOAD_PUT:
+        return Operation.NET_LOAD_CREATE;
+      default:
+        throw new IllegalStateException(
+            LocalizedStrings.TXEntryState_UNHANDLED_OP_0.toLocalizedString(Byte.valueOf(this.op)));
+
+   * 
-    int offset = (int)(seqId - txState.getBaseSequenceId());
-    return offset; 
+    int offset = (int) (seqId - txState.getBaseSequenceId());
+    return offset;
-   * Generate offsets for different eventIds; one for nearside and one for farside
-   * for the ops for this entry.
+   * Generate offsets for different eventIds; one for nearside and one for farside for the ops for
+   * this entry.
+   * 
+
-   * Generate the offset for an eventId that will be used for both a farside and nearside
-   * op for this entry.
+   * Generate the offset for an eventId that will be used for both a farside and nearside op for
+   * this entry.
+   * 
+
-   * Generate the offset for an eventId that will be used for the nearside
-   * op for this entry. No farside op will be done.
+   * Generate the offset for an eventId that will be used for the nearside op for this entry. No
+   * farside op will be done.
+   * 
-    return new EventID(txState.getBaseMembershipId(),
-                       txState.getBaseThreadId(),
-                       txState.getBaseSequenceId() + offset);
+    return new EventID(txState.getBaseMembershipId(), txState.getBaseThreadId(),
+        txState.getBaseSequenceId() + offset);
+
-   * Calculate (if farside has not already done so) and return then eventID
-   * to use for near side op applications.
+   * Calculate (if farside has not already done so) and return then eventID to use for near side op
+   * applications.
+   * 
+   * 
-    case OP_NULL:
-      // no eventIds needed
-      break;
-    case OP_L_DESTROY:
-      generateNearSideOnlyEventOffset(txState);
-      break;
-    case OP_CREATE_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_LLOAD_CREATE_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_NLOAD_CREATE_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_PUT_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_LLOAD_PUT_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_NLOAD_PUT_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_D_INVALIDATE_LD:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_D_DESTROY:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_L_INVALIDATE:
-      generateNearSideOnlyEventOffset(txState);
-      break;
-    case OP_PUT_LI:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_LLOAD_PUT_LI:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_NLOAD_PUT_LI:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_D_INVALIDATE:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_CREATE_LI:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_LLOAD_CREATE_LI:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_NLOAD_CREATE_LI:
-      generateBothEventOffsets(txState);
-      break;
-    case OP_CREATE:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_SEARCH_CREATE:
-      generateNearSideOnlyEventOffset(txState);
-      break;
-    case OP_LLOAD_CREATE:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_NLOAD_CREATE:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_LOCAL_CREATE:
-      generateNearSideOnlyEventOffset(txState);
-      break;
-    case OP_PUT:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_SEARCH_PUT:
-      generateNearSideOnlyEventOffset(txState);
-      break;
-    case OP_LLOAD_PUT:
-      generateSharedEventOffset(txState);
-      break;
-    case OP_NLOAD_PUT:
-      generateSharedEventOffset(txState);
-      break;
-    default:
-      throw new IllegalStateException("<unhandled op " + this.op + " >");
-    }
-  }
-  /**
-   * Gets the operation code for the operation done on this entry in caches
-   * remote from the originator of the tx (i.e. the "far side").
-   * 
-   * @return null if no far side operation
-   */
-  private Operation getFarSideOperation()
-  {
-    switch (this.op) {
-    case OP_NULL:
-      return null;
-    case OP_L_DESTROY:
-      return null;
-    case OP_CREATE_LD:
-      return getCreateOperation();
-    case OP_LLOAD_CREATE_LD:
-      return Operation.LOCAL_LOAD_CREATE;
-    case OP_NLOAD_CREATE_LD:
-      return Operation.NET_LOAD_CREATE;
-    case OP_PUT_LD:
-      return getUpdateOperation();
-    case OP_LLOAD_PUT_LD:
-      return Operation.LOCAL_LOAD_UPDATE;
-    case OP_NLOAD_PUT_LD:
-      return Operation.NET_LOAD_UPDATE;
-    case OP_D_INVALIDATE_LD:
-      return Operation.INVALIDATE;
-    case OP_D_DESTROY:
-      return getDestroyOperation();
-    case OP_L_INVALIDATE:
-      return null;
-    case OP_PUT_LI:
-      return getUpdateOperation();
-    case OP_LLOAD_PUT_LI:
-      return Operation.LOCAL_LOAD_UPDATE;
-    case OP_NLOAD_PUT_LI:
-      return Operation.NET_LOAD_UPDATE;
-    case OP_D_INVALIDATE:
-      return Operation.INVALIDATE;
-    case OP_CREATE_LI:
-      return getCreateOperation();
-    case OP_LLOAD_CREATE_LI:
-      return Operation.LOCAL_LOAD_CREATE;
-    case OP_NLOAD_CREATE_LI:
-      return Operation.NET_LOAD_CREATE;
-    case OP_CREATE:
-      return getCreateOperation();
-    case OP_SEARCH_CREATE:
-      return null;
-    case OP_LLOAD_CREATE:
-      return Operation.LOCAL_LOAD_CREATE;
-    case OP_NLOAD_CREATE:
-      return Operation.NET_LOAD_CREATE;
-    case OP_LOCAL_CREATE:
-      return getCreateOperation();
-    case OP_PUT:
-      return getUpdateOperation();
-    case OP_SEARCH_PUT:
-      return null;
-    case OP_LLOAD_PUT:
-      return Operation.LOCAL_LOAD_UPDATE;
-    case OP_NLOAD_PUT:
-      return Operation.NET_LOAD_UPDATE;
-    default:
-      throw new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_OP_0.toLocalizedString(Byte.valueOf(this.op)));
+      case OP_NULL:
+        // no eventIds needed
+        break;
+      case OP_L_DESTROY:
+        generateNearSideOnlyEventOffset(txState);
+        break;
+      case OP_CREATE_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_LLOAD_CREATE_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_NLOAD_CREATE_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_PUT_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_LLOAD_PUT_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_NLOAD_PUT_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_D_INVALIDATE_LD:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_D_DESTROY:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_L_INVALIDATE:
+        generateNearSideOnlyEventOffset(txState);
+        break;
+      case OP_PUT_LI:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_LLOAD_PUT_LI:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_NLOAD_PUT_LI:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_D_INVALIDATE:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_CREATE_LI:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_LLOAD_CREATE_LI:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_NLOAD_CREATE_LI:
+        generateBothEventOffsets(txState);
+        break;
+      case OP_CREATE:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_SEARCH_CREATE:
+        generateNearSideOnlyEventOffset(txState);
+        break;
+      case OP_LLOAD_CREATE:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_NLOAD_CREATE:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_LOCAL_CREATE:
+        generateNearSideOnlyEventOffset(txState);
+        break;
+      case OP_PUT:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_SEARCH_PUT:
+        generateNearSideOnlyEventOffset(txState);
+        break;
+      case OP_LLOAD_PUT:
+        generateSharedEventOffset(txState);
+        break;
+      case OP_NLOAD_PUT:
+        generateSharedEventOffset(txState);
+        break;
+      default:
+        throw new IllegalStateException("<unhandled op " + this.op + " >");
-  //  private void dumpOp() {
-  //    System.out.println("DEBUG: op=" + opToString()
-  //                       + " destroy=" + this.destroy
-  //                       + " isDis=" + isLocalEventDistributed());
-  //    System.out.flush();
-  //  }
+  /**
+   * Gets the operation code for the operation done on this entry in caches remote from the
+   * originator of the tx (i.e. the "far side").
+   * 
+   * @return null if no far side operation
+   */
+  private Operation getFarSideOperation() {
+    switch (this.op) {
+      case OP_NULL:
+        return null;
+      case OP_L_DESTROY:
+        return null;
+      case OP_CREATE_LD:
+        return getCreateOperation();
+      case OP_LLOAD_CREATE_LD:
+        return Operation.LOCAL_LOAD_CREATE;
+      case OP_NLOAD_CREATE_LD:
+        return Operation.NET_LOAD_CREATE;
+      case OP_PUT_LD:
+        return getUpdateOperation();
+      case OP_LLOAD_PUT_LD:
+        return Operation.LOCAL_LOAD_UPDATE;
+      case OP_NLOAD_PUT_LD:
+        return Operation.NET_LOAD_UPDATE;
+      case OP_D_INVALIDATE_LD:
+        return Operation.INVALIDATE;
+      case OP_D_DESTROY:
+        return getDestroyOperation();
+      case OP_L_INVALIDATE:
+        return null;
+      case OP_PUT_LI:
+        return getUpdateOperation();
+      case OP_LLOAD_PUT_LI:
+        return Operation.LOCAL_LOAD_UPDATE;
+      case OP_NLOAD_PUT_LI:
+        return Operation.NET_LOAD_UPDATE;
+      case OP_D_INVALIDATE:
+        return Operation.INVALIDATE;
+      case OP_CREATE_LI:
+        return getCreateOperation();
+      case OP_LLOAD_CREATE_LI:
+        return Operation.LOCAL_LOAD_CREATE;
+      case OP_NLOAD_CREATE_LI:
+        return Operation.NET_LOAD_CREATE;
+      case OP_CREATE:
+        return getCreateOperation();
+      case OP_SEARCH_CREATE:
+        return null;
+      case OP_LLOAD_CREATE:
+        return Operation.LOCAL_LOAD_CREATE;
+      case OP_NLOAD_CREATE:
+        return Operation.NET_LOAD_CREATE;
+      case OP_LOCAL_CREATE:
+        return getCreateOperation();
+      case OP_PUT:
+        return getUpdateOperation();
+      case OP_SEARCH_PUT:
+        return null;
+      case OP_LLOAD_PUT:
+        return Operation.LOCAL_LOAD_UPDATE;
+      case OP_NLOAD_PUT:
+        return Operation.NET_LOAD_UPDATE;
+      default:
+        throw new IllegalStateException(
+            LocalizedStrings.TXEntryState_UNHANDLED_OP_0.toLocalizedString(Byte.valueOf(this.op)));
+    }
+  }
+
+  // private void dumpOp() {
+  // System.out.println("DEBUG: op=" + opToString()
+  // + " destroy=" + this.destroy
+  // + " isDis=" + isLocalEventDistributed());
+  // System.out.flush();
+  // }
-  EntryEvent getEvent(LocalRegion r, Object key, TXState txs)
-  {
+  EntryEvent getEvent(LocalRegion r, Object key, TXState txs) {
-    @Retained EntryEventImpl result = new TxEntryEventImpl(eventRegion, key);
+    @Retained
+    EntryEventImpl result = new TxEntryEventImpl(eventRegion, key);
-    if (this.destroy == DESTROY_NONE || isOpDestroy()) {
-      result.setOldValue(getOriginalValue());
-    }
-    if(txs.isOriginRemoteForEvents()) {
-      result.setOriginRemote(true);
-    } else {
-      result.setOriginRemote(false);
-    }
-    result.setTransactionId(txs.getTransactionId());
-    returnedResult = true;
-    return result;
+      if (this.destroy == DESTROY_NONE || isOpDestroy()) {
+        result.setOldValue(getOriginalValue());
+      }
+      if (txs.isOriginRemoteForEvents()) {
+        result.setOriginRemote(true);
+      } else {
+        result.setOriginRemote(false);
+      }
+      result.setTransactionId(txs.getTransactionId());
+      returnedResult = true;
+      return result;
-      if (!returnedResult) result.release();
+      if (!returnedResult)
+        result.release();
-  public boolean invalidate(EntryEventImpl event) throws EntryNotFoundException
-  {
-//    LocalRegion lr = event.getRegion();
-//    boolean isProxy = lr.isProxy();
-//    if (!isLocallyValid(isProxy)) {
-//      return false;
-//    }
+  public boolean invalidate(EntryEventImpl event) throws EntryNotFoundException {
+    // LocalRegion lr = event.getRegion();
+    // boolean isProxy = lr.isProxy();
+    // if (!isLocallyValid(isProxy)) {
+    // return false;
+    // }
-    }
-    else {
+    } else {
-    
+
-      throws CacheWriterException, EntryNotFoundException, TimeoutException
-  {
+      throws CacheWriterException, EntryNotFoundException, TimeoutException {
-    
+
-      }
-      else {
+      } else {
-    
+
-   * @param event
-   *          the event object for this operation, with the exception that the
-   *          oldValue parameter is not yet filled in. The oldValue will be
-   *          filled in by this operation.
+   * @param event the event object for this operation, with the exception that the oldValue
+   *        parameter is not yet filled in. The oldValue will be filled in by this operation.
-   * @param ifNew
-   *          true if this operation must not overwrite an existing key
+   * @param ifNew true if this operation must not overwrite an existing key
-      throws CacheWriterException, TimeoutException
-  {
+      throws CacheWriterException, TimeoutException {
-    }
-    else {
+    } else {
-      putOp += (byte)(OP_SEARCH_PUT - OP_PUT);
-    }
-    else if (event.isLocalLoad()) {
-      putOp += (byte)(OP_LLOAD_PUT - OP_PUT);
-    }
-    else if (event.isNetLoad()) {
-      putOp += (byte)(OP_NLOAD_PUT - OP_PUT);
+      putOp += (byte) (OP_SEARCH_PUT - OP_PUT);
+    } else if (event.isLocalLoad()) {
+      putOp += (byte) (OP_LLOAD_PUT - OP_PUT);
+    } else if (event.isNetLoad()) {
+      putOp += (byte) (OP_NLOAD_PUT - OP_PUT);
-        }
-        else {
+        } else {
-    
+
-   * We will try to establish TXState on members with dataPolicy REPLICATE, this
-   * is done for the first region to be involved in a transaction. For
-   * subsequent region if the dataPolicy is not REPLICATE, we fetch the
-   * VersionTag from replicate members.
+   * We will try to establish TXState on members with dataPolicy REPLICATE, this is done for the
+   * first region to be involved in a transaction. For subsequent region if the dataPolicy is not
+   * REPLICATE, we fetch the VersionTag from replicate members.
-      if (dr.dataPolicy == DataPolicy.NORMAL
-          || dr.dataPolicy == DataPolicy.PRELOADED) {
+      if (dr.dataPolicy == DataPolicy.NORMAL || dr.dataPolicy == DataPolicy.PRELOADED) {
-  
+
-  private byte adviseOp(byte requestedOpCode, EntryEventImpl event)
-  {
+  private byte adviseOp(byte requestedOpCode, EntryEventImpl event) {
-      }
-      else {
+      } else {
-                 || region instanceof BucketRegion;
+          || region instanceof BucketRegion;
-    case OP_L_DESTROY:
-      switch (this.op) {
-      case OP_NULL:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_CREATE_LD:
-      case OP_LLOAD_CREATE_LD:
-      case OP_NLOAD_CREATE_LD:
-      case OP_PUT_LD:
-      case OP_LLOAD_PUT_LD:
-      case OP_NLOAD_PUT_LD:
-      case OP_D_INVALIDATE_LD:
-      case OP_D_DESTROY:
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1.toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
-      case OP_L_INVALIDATE:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_PUT_LI:
-        advisedOpCode = OP_PUT_LD;
-        break;
-      case OP_LLOAD_PUT_LI:
-        advisedOpCode = OP_LLOAD_PUT_LD;
-        break;
-      case OP_NLOAD_PUT_LI:
-        advisedOpCode = OP_NLOAD_PUT_LD;
-        break;
-      case OP_D_INVALIDATE:
-        advisedOpCode = OP_D_INVALIDATE_LD;
-        break;
-      case OP_CREATE_LI:
-        advisedOpCode = OP_CREATE_LD;
-        break;
-      case OP_LLOAD_CREATE_LI:
-        advisedOpCode = OP_LLOAD_CREATE_LD;
-        break;
-      case OP_NLOAD_CREATE_LI:
-        advisedOpCode = OP_NLOAD_CREATE_LD;
-        break;
-      case OP_CREATE:
-        advisedOpCode = OP_CREATE_LD;
-        break;
-      case OP_SEARCH_CREATE:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_LLOAD_CREATE:
-        advisedOpCode = OP_LLOAD_CREATE_LD;
-        break;
-      case OP_NLOAD_CREATE:
-        advisedOpCode = OP_NLOAD_CREATE_LD;
-        break;
-      case OP_LOCAL_CREATE:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_PUT:
-        advisedOpCode = OP_PUT_LD;
-        break;
-      case OP_SEARCH_PUT:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_LLOAD_PUT:
-        advisedOpCode = OP_LLOAD_PUT_LD;
-        break;
-      case OP_NLOAD_PUT:
-        advisedOpCode = OP_NLOAD_PUT_LD;
-        break;
-      default:
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));
-      }
-      break;
-    case OP_D_DESTROY:
-      Assert.assertTrue(!isOpDestroy(),
-                        "Transactional destroy assertion op=" + this.op);
-      advisedOpCode = requestedOpCode;
-      break;
-    case OP_L_INVALIDATE:
-      switch (this.op) {
-      case OP_NULL:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_L_DESTROY:
-      case OP_CREATE_LD:
-      case OP_LLOAD_CREATE_LD:
-      case OP_NLOAD_CREATE_LD:
-      case OP_PUT_LD:
-      case OP_LLOAD_PUT_LD:
-      case OP_NLOAD_PUT_LD:
-      case OP_D_DESTROY:
-      case OP_D_INVALIDATE_LD:
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1.toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
-      case OP_L_INVALIDATE:
-    	  advisedOpCode = requestedOpCode;
-    	  break;
-      case OP_LLOAD_PUT_LI:
-      case OP_NLOAD_PUT_LI:
-      case OP_LLOAD_CREATE_LI:
-      case OP_NLOAD_CREATE_LI:
-    	  advisedOpCode = this.op;
-    	  break;
-      case OP_PUT_LI:
-    	  advisedOpCode = OP_PUT_LI;
-    	  break;
-      case OP_CREATE_LI:
-    	  advisedOpCode = OP_CREATE_LI;
-    	  break;
-      case OP_D_INVALIDATE:
-    	  advisedOpCode = OP_D_INVALIDATE;
-    	  break;
-      case OP_CREATE:
-        advisedOpCode = OP_CREATE_LI;
-        break;
-      case OP_SEARCH_CREATE:
-        advisedOpCode = OP_LOCAL_CREATE;
-        // pendingValue will be set to LOCAL_INVALID
-        break;
-      case OP_LLOAD_CREATE:
-        advisedOpCode = OP_LLOAD_CREATE_LI;
-        break;
-      case OP_NLOAD_CREATE:
-        advisedOpCode = OP_NLOAD_CREATE_LI;
-        break;
-      case OP_LOCAL_CREATE:
-        advisedOpCode = OP_LOCAL_CREATE;
-        break;
-      case OP_PUT:
-        advisedOpCode = OP_PUT_LI;
-        break;
-      case OP_SEARCH_PUT:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_LLOAD_PUT:
-        advisedOpCode = OP_LLOAD_PUT_LI;
-        break;
-      case OP_NLOAD_PUT:
-        advisedOpCode = OP_NLOAD_PUT_LI;
-        break;
-      default:
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));
-      }
-      break;
-    case OP_D_INVALIDATE:
-      switch (this.op) {
-      case OP_NULL:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_L_DESTROY:
-      case OP_CREATE_LD:
-      case OP_LLOAD_CREATE_LD:
-      case OP_NLOAD_CREATE_LD:
-      case OP_PUT_LD:
-      case OP_LLOAD_PUT_LD:
-      case OP_NLOAD_PUT_LD:
-      case OP_D_INVALIDATE_LD:
-      case OP_D_DESTROY:
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1.toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
-      case OP_D_INVALIDATE:
-      case OP_L_INVALIDATE:
-    	advisedOpCode = OP_D_INVALIDATE;
-    	break;
-    	
-      case OP_PUT_LI:
-      case OP_LLOAD_PUT_LI:
-      case OP_NLOAD_PUT_LI:
-      case OP_CREATE_LI:
-      case OP_LLOAD_CREATE_LI:
-      case OP_NLOAD_CREATE_LI:
-    	  /*
-    	   * No change, keep it how it was.
-    	   */
-    	  advisedOpCode = this.op;
-    	  break;
-      case OP_CREATE:
-        advisedOpCode = OP_CREATE;
-        // pendingValue will be set to INVALID turning it into create invalid
-        break;
-      case OP_SEARCH_CREATE:
-        advisedOpCode = OP_LOCAL_CREATE;
-        // pendingValue will be set to INVALID to indicate dinvalidate
-        break;
-      case OP_LLOAD_CREATE:
-        advisedOpCode = OP_CREATE;
-        // pendingValue will be set to INVALID turning it into create invalid
-        break;
-      case OP_NLOAD_CREATE:
-        advisedOpCode = OP_CREATE;
-        // pendingValue will be set to INVALID turning it into create invalid
-        break;
-      case OP_LOCAL_CREATE:
-        advisedOpCode = OP_LOCAL_CREATE;
-        // pendingValue will be set to INVALID to indicate dinvalidate
-        break;
-      case OP_PUT:
-      case OP_SEARCH_PUT:
-      case OP_LLOAD_PUT:
-      case OP_NLOAD_PUT:
-        advisedOpCode = requestedOpCode;
-        break;
-      default:
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));
-      }
-      break;
-    case OP_CREATE:
-    case OP_SEARCH_CREATE:
-    case OP_LLOAD_CREATE:
-    case OP_NLOAD_CREATE:
-      advisedOpCode = requestedOpCode;
-      break;
-    case OP_PUT:
-      switch (this.op) {
-      case OP_CREATE:
-      case OP_SEARCH_CREATE:
-      case OP_LLOAD_CREATE:
-      case OP_NLOAD_CREATE:
-      case OP_LOCAL_CREATE:
-      case OP_CREATE_LI:
-      case OP_LLOAD_CREATE_LI:
-      case OP_NLOAD_CREATE_LI:
-      case OP_CREATE_LD:
-      case OP_LLOAD_CREATE_LD:
-      case OP_NLOAD_CREATE_LD:
-      case OP_PUT_LD:
-      case OP_LLOAD_PUT_LD:
-      case OP_NLOAD_PUT_LD:
-      case OP_D_INVALIDATE_LD:
-      case OP_L_DESTROY:
-      case OP_D_DESTROY:
-        advisedOpCode = OP_CREATE;
-        break;
-      default:
-        advisedOpCode = requestedOpCode;
-        break;
-      }
-      break;
-    case OP_SEARCH_PUT:
-      switch (this.op) {
-      case OP_NULL:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_L_INVALIDATE:
-        advisedOpCode = requestedOpCode;
-        break;
-      // The incoming search put value should match
-      // the pendingValue from the previous tx operation.
-      // So it is ok to simply drop the _LI from the op
-      case OP_PUT_LI:
-        advisedOpCode = OP_PUT;
-        break;
-      case OP_LLOAD_PUT_LI:
-        advisedOpCode = OP_LLOAD_PUT;
-        break;
-      case OP_NLOAD_PUT_LI:
-        advisedOpCode = OP_NLOAD_PUT;
-        break;
-      case OP_CREATE_LI:
-        advisedOpCode = OP_CREATE;
-        break;
-      case OP_LLOAD_CREATE_LI:
-        advisedOpCode = OP_LLOAD_CREATE;
-        break;
-      case OP_NLOAD_CREATE_LI:
-        advisedOpCode = OP_NLOAD_CREATE;
-        break;
-      default:
-        // Note that OP_LOCAL_CREATE and OP_CREATE with invalid values
-        // are not possible because they would cause the netsearch to
-        // fail and we would do a load or a total miss.
-        // Note that OP_D_INVALIDATE followed by OP_SEARCH_PUT is not
-        // possible since the netsearch will alwsys "miss" in this case.
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_PREVIOUS_OP_0_UNEXPECTED_FOR_REQUESTED_OP_1.toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
-      }
-      break;
-    case OP_LLOAD_PUT:
-    case OP_NLOAD_PUT:
-      switch (this.op) {
-      case OP_NULL:
-      case OP_L_INVALIDATE:
-      case OP_PUT_LI:
-      case OP_LLOAD_PUT_LI:
-      case OP_NLOAD_PUT_LI:
-      case OP_D_INVALIDATE:
-        advisedOpCode = requestedOpCode;
-        break;
-      case OP_CREATE:
-      case OP_LOCAL_CREATE:
-      case OP_CREATE_LI:
-      case OP_LLOAD_CREATE_LI:
-      case OP_NLOAD_CREATE_LI:
-        if (requestedOpCode == OP_LLOAD_PUT) {
-          advisedOpCode = OP_LLOAD_CREATE;
+        switch (this.op) {
+          case OP_NULL:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_L_DESTROY:
+          case OP_CREATE_LD:
+          case OP_LLOAD_CREATE_LD:
+          case OP_NLOAD_CREATE_LD:
+          case OP_PUT_LD:
+          case OP_LLOAD_PUT_LD:
+          case OP_NLOAD_PUT_LD:
+          case OP_D_INVALIDATE_LD:
+          case OP_D_DESTROY:
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1
+                    .toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
+          case OP_L_INVALIDATE:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_PUT_LI:
+            advisedOpCode = OP_PUT_LD;
+            break;
+          case OP_LLOAD_PUT_LI:
+            advisedOpCode = OP_LLOAD_PUT_LD;
+            break;
+          case OP_NLOAD_PUT_LI:
+            advisedOpCode = OP_NLOAD_PUT_LD;
+            break;
+          case OP_D_INVALIDATE:
+            advisedOpCode = OP_D_INVALIDATE_LD;
+            break;
+          case OP_CREATE_LI:
+            advisedOpCode = OP_CREATE_LD;
+            break;
+          case OP_LLOAD_CREATE_LI:
+            advisedOpCode = OP_LLOAD_CREATE_LD;
+            break;
+          case OP_NLOAD_CREATE_LI:
+            advisedOpCode = OP_NLOAD_CREATE_LD;
+            break;
+          case OP_CREATE:
+            advisedOpCode = OP_CREATE_LD;
+            break;
+          case OP_SEARCH_CREATE:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_LLOAD_CREATE:
+            advisedOpCode = OP_LLOAD_CREATE_LD;
+            break;
+          case OP_NLOAD_CREATE:
+            advisedOpCode = OP_NLOAD_CREATE_LD;
+            break;
+          case OP_LOCAL_CREATE:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_PUT:
+            advisedOpCode = OP_PUT_LD;
+            break;
+          case OP_SEARCH_PUT:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_LLOAD_PUT:
+            advisedOpCode = OP_LLOAD_PUT_LD;
+            break;
+          case OP_NLOAD_PUT:
+            advisedOpCode = OP_NLOAD_PUT_LD;
+            break;
+          default:
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));
-        else {
-          advisedOpCode = OP_NLOAD_CREATE;
+        break;
+      case OP_D_DESTROY:
+        Assert.assertTrue(!isOpDestroy(), "Transactional destroy assertion op=" + this.op);
+        advisedOpCode = requestedOpCode;
+        break;
+      case OP_L_INVALIDATE:
+        switch (this.op) {
+          case OP_NULL:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_L_DESTROY:
+          case OP_CREATE_LD:
+          case OP_LLOAD_CREATE_LD:
+          case OP_NLOAD_CREATE_LD:
+          case OP_PUT_LD:
+          case OP_LLOAD_PUT_LD:
+          case OP_NLOAD_PUT_LD:
+          case OP_D_DESTROY:
+          case OP_D_INVALIDATE_LD:
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1
+                    .toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
+          case OP_L_INVALIDATE:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_LLOAD_PUT_LI:
+          case OP_NLOAD_PUT_LI:
+          case OP_LLOAD_CREATE_LI:
+          case OP_NLOAD_CREATE_LI:
+            advisedOpCode = this.op;
+            break;
+          case OP_PUT_LI:
+            advisedOpCode = OP_PUT_LI;
+            break;
+          case OP_CREATE_LI:
+            advisedOpCode = OP_CREATE_LI;
+            break;
+          case OP_D_INVALIDATE:
+            advisedOpCode = OP_D_INVALIDATE;
+            break;
+          case OP_CREATE:
+            advisedOpCode = OP_CREATE_LI;
+            break;
+          case OP_SEARCH_CREATE:
+            advisedOpCode = OP_LOCAL_CREATE;
+            // pendingValue will be set to LOCAL_INVALID
+            break;
+          case OP_LLOAD_CREATE:
+            advisedOpCode = OP_LLOAD_CREATE_LI;
+            break;
+          case OP_NLOAD_CREATE:
+            advisedOpCode = OP_NLOAD_CREATE_LI;
+            break;
+          case OP_LOCAL_CREATE:
+            advisedOpCode = OP_LOCAL_CREATE;
+            break;
+          case OP_PUT:
+            advisedOpCode = OP_PUT_LI;
+            break;
+          case OP_SEARCH_PUT:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_LLOAD_PUT:
+            advisedOpCode = OP_LLOAD_PUT_LI;
+            break;
+          case OP_NLOAD_PUT:
+            advisedOpCode = OP_NLOAD_PUT_LI;
+            break;
+          default:
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));
+        }
+        break;
+      case OP_D_INVALIDATE:
+        switch (this.op) {
+          case OP_NULL:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_L_DESTROY:
+          case OP_CREATE_LD:
+          case OP_LLOAD_CREATE_LD:
+          case OP_NLOAD_CREATE_LD:
+          case OP_PUT_LD:
+          case OP_LLOAD_PUT_LD:
+          case OP_NLOAD_PUT_LD:
+          case OP_D_INVALIDATE_LD:
+          case OP_D_DESTROY:
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1
+                    .toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
+          case OP_D_INVALIDATE:
+          case OP_L_INVALIDATE:
+            advisedOpCode = OP_D_INVALIDATE;
+            break;
+
+          case OP_PUT_LI:
+          case OP_LLOAD_PUT_LI:
+          case OP_NLOAD_PUT_LI:
+          case OP_CREATE_LI:
+          case OP_LLOAD_CREATE_LI:
+          case OP_NLOAD_CREATE_LI:
+            /*
+             * No change, keep it how it was.
+             */
+            advisedOpCode = this.op;
+            break;
+          case OP_CREATE:
+            advisedOpCode = OP_CREATE;
+            // pendingValue will be set to INVALID turning it into create invalid
+            break;
+          case OP_SEARCH_CREATE:
+            advisedOpCode = OP_LOCAL_CREATE;
+            // pendingValue will be set to INVALID to indicate dinvalidate
+            break;
+          case OP_LLOAD_CREATE:
+            advisedOpCode = OP_CREATE;
+            // pendingValue will be set to INVALID turning it into create invalid
+            break;
+          case OP_NLOAD_CREATE:
+            advisedOpCode = OP_CREATE;
+            // pendingValue will be set to INVALID turning it into create invalid
+            break;
+          case OP_LOCAL_CREATE:
+            advisedOpCode = OP_LOCAL_CREATE;
+            // pendingValue will be set to INVALID to indicate dinvalidate
+            break;
+          case OP_PUT:
+          case OP_SEARCH_PUT:
+          case OP_LLOAD_PUT:
+          case OP_NLOAD_PUT:
+            advisedOpCode = requestedOpCode;
+            break;
+          default:
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));
+        }
+        break;
+      case OP_CREATE:
+      case OP_SEARCH_CREATE:
+      case OP_LLOAD_CREATE:
+      case OP_NLOAD_CREATE:
+        advisedOpCode = requestedOpCode;
+        break;
+      case OP_PUT:
+        switch (this.op) {
+          case OP_CREATE:
+          case OP_SEARCH_CREATE:
+          case OP_LLOAD_CREATE:
+          case OP_NLOAD_CREATE:
+          case OP_LOCAL_CREATE:
+          case OP_CREATE_LI:
+          case OP_LLOAD_CREATE_LI:
+          case OP_NLOAD_CREATE_LI:
+          case OP_CREATE_LD:
+          case OP_LLOAD_CREATE_LD:
+          case OP_NLOAD_CREATE_LD:
+          case OP_PUT_LD:
+          case OP_LLOAD_PUT_LD:
+          case OP_NLOAD_PUT_LD:
+          case OP_D_INVALIDATE_LD:
+          case OP_L_DESTROY:
+          case OP_D_DESTROY:
+            advisedOpCode = OP_CREATE;
+            break;
+          default:
+            advisedOpCode = requestedOpCode;
+            break;
+        }
+        break;
+      case OP_SEARCH_PUT:
+        switch (this.op) {
+          case OP_NULL:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_L_INVALIDATE:
+            advisedOpCode = requestedOpCode;
+            break;
+          // The incoming search put value should match
+          // the pendingValue from the previous tx operation.
+          // So it is ok to simply drop the _LI from the op
+          case OP_PUT_LI:
+            advisedOpCode = OP_PUT;
+            break;
+          case OP_LLOAD_PUT_LI:
+            advisedOpCode = OP_LLOAD_PUT;
+            break;
+          case OP_NLOAD_PUT_LI:
+            advisedOpCode = OP_NLOAD_PUT;
+            break;
+          case OP_CREATE_LI:
+            advisedOpCode = OP_CREATE;
+            break;
+          case OP_LLOAD_CREATE_LI:
+            advisedOpCode = OP_LLOAD_CREATE;
+            break;
+          case OP_NLOAD_CREATE_LI:
+            advisedOpCode = OP_NLOAD_CREATE;
+            break;
+          default:
+            // Note that OP_LOCAL_CREATE and OP_CREATE with invalid values
+            // are not possible because they would cause the netsearch to
+            // fail and we would do a load or a total miss.
+            // Note that OP_D_INVALIDATE followed by OP_SEARCH_PUT is not
+            // possible since the netsearch will alwsys "miss" in this case.
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_PREVIOUS_OP_0_UNEXPECTED_FOR_REQUESTED_OP_1
+                    .toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
+        }
+        break;
+      case OP_LLOAD_PUT:
+      case OP_NLOAD_PUT:
+        switch (this.op) {
+          case OP_NULL:
+          case OP_L_INVALIDATE:
+          case OP_PUT_LI:
+          case OP_LLOAD_PUT_LI:
+          case OP_NLOAD_PUT_LI:
+          case OP_D_INVALIDATE:
+            advisedOpCode = requestedOpCode;
+            break;
+          case OP_CREATE:
+          case OP_LOCAL_CREATE:
+          case OP_CREATE_LI:
+          case OP_LLOAD_CREATE_LI:
+          case OP_NLOAD_CREATE_LI:
+            if (requestedOpCode == OP_LLOAD_PUT) {
+              advisedOpCode = OP_LLOAD_CREATE;
+            } else {
+              advisedOpCode = OP_NLOAD_CREATE;
+            }
+            break;
+          default:
+            // note that other invalid states are covered by this default
+            // case because they should have caused a OP_SEARCH_PUT
+            // to be requested.
+            throw new IllegalStateException(
+                LocalizedStrings.TXEntryState_PREVIOUS_OP_0_UNEXPECTED_FOR_REQUESTED_OP_1
+                    .toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
-        // note that other invalid states are covered by this default
-        // case because they should have caused a OP_SEARCH_PUT
-        // to be requested.
-        throw new IllegalStateException(LocalizedStrings.TXEntryState_PREVIOUS_OP_0_UNEXPECTED_FOR_REQUESTED_OP_1.toLocalizedString(new Object[] {opToString(), opToString(requestedOpCode)}));
-      }
-      break;
-    default:
-      throw new IllegalStateException(LocalizedStrings.TXEntryState_OPCODE_0_SHOULD_NEVER_BE_REQUESTED.toLocalizedString(opToString(requestedOpCode)));
+        throw new IllegalStateException(
+            LocalizedStrings.TXEntryState_OPCODE_0_SHOULD_NEVER_BE_REQUESTED
+                .toLocalizedString(opToString(requestedOpCode)));
-  private void performOp(byte advisedOpCode, EntryEventImpl event)
-  {
+  private void performOp(byte advisedOpCode, EntryEventImpl event) {
-  
+
-    if (o1 == o2) return true;
+    if (o1 == o2)
+      return true;
-      if (o1.equals(o2)) return true;
+      if (o1.equals(o2))
+        return true;
-  void checkForConflict(LocalRegion r, Object key)
-      throws CommitConflictException
-  {
+  void checkForConflict(LocalRegion r, Object key) throws CommitConflictException {
-      if ((re == null) || re.isValueNull()) {
-        curCmtVersionId = Token.REMOVED_PHASE1;
-      }
-      else {
-        if (re.getValueWasResultOfSearch()) {
-          return;
-        }
-        
-        /*
-         * The originalVersionId may be compressed so grab the value as stored in the map
-         * which will match if compression is turned on.
-         */
-        curCmtVersionId = re.getTransformedValue();
-      }
-      if (!areIdentical(getOriginalVersionId(), curCmtVersionId)) {
-        // I'm not sure it is a good idea to call getDeserializedValue.
-        // Might be better to add a toString impl on CachedDeserializable.
-        //         if (curCmtVersionId instanceof CachedDeserializable) {
-        //           curCmtVersionId =
-        // ((CachedDeserializable)curCmtVersionId).getDeserializedValue();
-        //         }
-        if (VERBOSE_CONFLICT_STRING || logger.isDebugEnabled()) {
-          String fromString = calcConflictString(getOriginalVersionId());
-          String toString = calcConflictString(curCmtVersionId);
-          if (!fromString.equals(toString)) {
-            throw new CommitConflictException(LocalizedStrings.TXEntryState_ENTRY_FOR_KEY_0_ON_REGION_1_HAD_ALREADY_BEEN_CHANGED_FROM_2_TO_3.toLocalizedString(new Object[] {key, r.getDisplayName(), fromString, toString}));
+        if ((re == null) || re.isValueNull()) {
+          curCmtVersionId = Token.REMOVED_PHASE1;
+        } else {
+          if (re.getValueWasResultOfSearch()) {
+            return;
+
+          /*
+           * The originalVersionId may be compressed so grab the value as stored in the map which
+           * will match if compression is turned on.
+           */
+          curCmtVersionId = re.getTransformedValue();
-        throw new CommitConflictException(LocalizedStrings.TXEntryState_ENTRY_FOR_KEY_0_ON_REGION_1_HAD_A_STATE_CHANGE.toLocalizedString(new Object[]{key, r.getDisplayName()}));
-      }
+        if (!areIdentical(getOriginalVersionId(), curCmtVersionId)) {
+          // I'm not sure it is a good idea to call getDeserializedValue.
+          // Might be better to add a toString impl on CachedDeserializable.
+          // if (curCmtVersionId instanceof CachedDeserializable) {
+          // curCmtVersionId =
+          // ((CachedDeserializable)curCmtVersionId).getDeserializedValue();
+          // }
+          if (VERBOSE_CONFLICT_STRING || logger.isDebugEnabled()) {
+            String fromString = calcConflictString(getOriginalVersionId());
+            String toString = calcConflictString(curCmtVersionId);
+            if (!fromString.equals(toString)) {
+              throw new CommitConflictException(
+                  LocalizedStrings.TXEntryState_ENTRY_FOR_KEY_0_ON_REGION_1_HAD_ALREADY_BEEN_CHANGED_FROM_2_TO_3
+                      .toLocalizedString(
+                          new Object[] {key, r.getDisplayName(), fromString, toString}));
+            }
+          }
+          throw new CommitConflictException(
+              LocalizedStrings.TXEntryState_ENTRY_FOR_KEY_0_ON_REGION_1_HAD_A_STATE_CHANGE
+                  .toLocalizedString(new Object[] {key, r.getDisplayName()}));
+        }
-    }
-    catch (CacheRuntimeException ex) {
+    } catch (CacheRuntimeException ex) {
-      throw new CommitConflictException(LocalizedStrings.TXEntryState_CONFLICT_CAUSED_BY_CACHE_EXCEPTION.toLocalizedString(), ex);
+      throw new CommitConflictException(
+          LocalizedStrings.TXEntryState_CONFLICT_CAUSED_BY_CACHE_EXCEPTION.toLocalizedString(), ex);
-  private String calcConflictString(Object obj)
-  {
+  private String calcConflictString(Object obj) {
-        o = ((CachedDeserializable)o).getDeserializedForReading();
+        o = ((CachedDeserializable) o).getDeserializedForReading();
-    }
-    else if (Token.isRemoved(o)) {
+    } else if (Token.isRemoved(o)) {
-    }
-    else if (o == Token.INVALID) {
+    } else if (o == Token.INVALID) {
-    }
-    else if (o == Token.LOCAL_INVALID) {
+    } else if (o == Token.LOCAL_INVALID) {
-  private final boolean didDestroy()
-  {
+  private final boolean didDestroy() {
-  private final boolean didDistributedDestroy()
-  {
+  private final boolean didDistributedDestroy() {
-   * Returns the total number of modifications made by this transaction to this
-   * entry. The result will be +1 for a create and -1 for a destroy.
+   * Returns the total number of modifications made by this transaction to this entry. The result
+   * will be +1 for a create and -1 for a destroy.
-  int entryCountMod()
-  {
+  int entryCountMod() {
-    case OP_L_DESTROY:
-    case OP_CREATE_LD:
-    case OP_LLOAD_CREATE_LD:
-    case OP_NLOAD_CREATE_LD:
-    case OP_PUT_LD:
-    case OP_LLOAD_PUT_LD:
-    case OP_NLOAD_PUT_LD:
-    case OP_D_INVALIDATE_LD:
-    case OP_D_DESTROY:
-      if (getOriginalValue() == null
-          || Token.isRemoved(getOriginalValue())) {
+      case OP_L_DESTROY:
+      case OP_CREATE_LD:
+      case OP_LLOAD_CREATE_LD:
+      case OP_NLOAD_CREATE_LD:
+      case OP_PUT_LD:
+      case OP_LLOAD_PUT_LD:
+      case OP_NLOAD_PUT_LD:
+      case OP_D_INVALIDATE_LD:
+      case OP_D_DESTROY:
+        if (getOriginalValue() == null || Token.isRemoved(getOriginalValue())) {
+          return 0;
+        } else {
+          return -1;
+        }
+      case OP_CREATE_LI:
+      case OP_LLOAD_CREATE_LI:
+      case OP_NLOAD_CREATE_LI:
+      case OP_CREATE:
+      case OP_SEARCH_CREATE:
+      case OP_LLOAD_CREATE:
+      case OP_NLOAD_CREATE:
+      case OP_LOCAL_CREATE:
+        if (getOriginalValue() == null || Token.isRemoved(getOriginalValue())) {
+          return 1;
+        } else {
+          return 0;
+        }
+      case OP_NULL:
+      case OP_L_INVALIDATE:
+      case OP_PUT_LI:
+      case OP_LLOAD_PUT_LI:
+      case OP_NLOAD_PUT_LI:
+      case OP_D_INVALIDATE:
+      case OP_PUT:
+      case OP_SEARCH_PUT:
+      case OP_LLOAD_PUT:
+      case OP_NLOAD_PUT:
+      default:
-      }
-      else {
-        return -1;
-      }
-    case OP_CREATE_LI:
-    case OP_LLOAD_CREATE_LI:
-    case OP_NLOAD_CREATE_LI:
-    case OP_CREATE:
-    case OP_SEARCH_CREATE:
-    case OP_LLOAD_CREATE:
-    case OP_NLOAD_CREATE:
-    case OP_LOCAL_CREATE:
-      if (getOriginalValue() == null
-          || Token.isRemoved(getOriginalValue())) {
-        return 1;
-      }
-      else {
-        return 0;
-      }
-    case OP_NULL:
-    case OP_L_INVALIDATE:
-    case OP_PUT_LI:
-    case OP_LLOAD_PUT_LI:
-    case OP_NLOAD_PUT_LI:
-    case OP_D_INVALIDATE:
-    case OP_PUT:
-    case OP_SEARCH_PUT:
-    case OP_LLOAD_PUT:
-    case OP_NLOAD_PUT:
-    default:
-      return 0;
-  boolean wasCreatedByTX()
-  {
+  boolean wasCreatedByTX() {
-  private final void txApplyDestroyLocally(LocalRegion r, Object key, TXState txState)
-  {
-      boolean invokeCallbacks = isOpDestroyEvent(r);
-      List<EntryEventImpl> pendingCallbacks = invokeCallbacks ? txState.getPendingCallbacks() : new ArrayList<EntryEventImpl>();
-      try {
-        r.txApplyDestroy(key, 
-            txState.getTransactionId(), null, false/*inTokenMode*/,
-            getDestroyOperation(),
-            getNearSideEventId(txState), callBackArgument,
-            pendingCallbacks ,getFilterRoutingInfo(),
-            txState.bridgeContext, false, this, null, -1);
-      }
-      catch (RegionDestroyedException ignore) {
-      }
-      catch (EntryDestroyedException ignore) {
-      }
+  private final void txApplyDestroyLocally(LocalRegion r, Object key, TXState txState) {
+    boolean invokeCallbacks = isOpDestroyEvent(r);
+    List<EntryEventImpl> pendingCallbacks =
+        invokeCallbacks ? txState.getPendingCallbacks() : new ArrayList<EntryEventImpl>();
+    try {
+      r.txApplyDestroy(key, txState.getTransactionId(), null, false/* inTokenMode */,
+          getDestroyOperation(), getNearSideEventId(txState), callBackArgument, pendingCallbacks,
+          getFilterRoutingInfo(), txState.bridgeContext, false, this, null, -1);
+    } catch (RegionDestroyedException ignore) {
+    } catch (EntryDestroyedException ignore) {
+    }
-  private final void txApplyInvalidateLocally(LocalRegion r, Object key,
-      Object newValue, boolean didDestroy, TXState txState)
-  {
+  private final void txApplyInvalidateLocally(LocalRegion r, Object key, Object newValue,
+      boolean didDestroy, TXState txState) {
-      r.txApplyInvalidate(key, newValue, didDestroy,
-          txState.getTransactionId(), null,
-          isOpLocalInvalidate() ? true : false,
-          getNearSideEventId(txState), callBackArgument,txState.getPendingCallbacks(),
-          getFilterRoutingInfo(),
-          txState.bridgeContext, this, null, -1);
-    }
-    catch (RegionDestroyedException ignore) {
-    }
-    catch (EntryDestroyedException ignore) {
+      r.txApplyInvalidate(key, newValue, didDestroy, txState.getTransactionId(), null,
+          isOpLocalInvalidate() ? true : false, getNearSideEventId(txState), callBackArgument,
+          txState.getPendingCallbacks(), getFilterRoutingInfo(), txState.bridgeContext, this, null,
+          -1);
+    } catch (RegionDestroyedException ignore) {
+    } catch (EntryDestroyedException ignore) {
-  private final void txApplyPutLocally(LocalRegion r, Operation putOp,
-      Object key, Object newValue, boolean didDestroy, TXState txState)
-  {    
-    try {      
-      r.txApplyPut(putOp, key, newValue, didDestroy,
-          txState.getTransactionId(), null,
-          getNearSideEventId(txState), callBackArgument,txState.getPendingCallbacks(),
-          getFilterRoutingInfo(),
-          txState.bridgeContext, this, null, -1);
-    }
-    catch (RegionDestroyedException ignore) {
-    }
-    catch (EntryDestroyedException ignore) {
+  private final void txApplyPutLocally(LocalRegion r, Operation putOp, Object key, Object newValue,
+      boolean didDestroy, TXState txState) {
+    try {
+      r.txApplyPut(putOp, key, newValue, didDestroy, txState.getTransactionId(), null,
+          getNearSideEventId(txState), callBackArgument, txState.getPendingCallbacks(),
+          getFilterRoutingInfo(), txState.bridgeContext, this, null, -1);
+    } catch (RegionDestroyedException ignore) {
+    } catch (EntryDestroyedException ignore) {
+   * 
-    }
-    else {
+    } else {
-  
-  void buildMessage(LocalRegion r, Object key, TXCommitMessage msg,Set otherRecipients)
-  {
+
+  void buildMessage(LocalRegion r, Object key, TXCommitMessage msg, Set otherRecipients) {
-        msg.addOp(r,key, this,otherRecipients);
+        msg.addOp(r, key, this, otherRecipients);
-  
-  void buildCompleteMessage(LocalRegion r, Object key, TXCommitMessage msg,Set otherRecipients)
-  {
+
+  void buildCompleteMessage(LocalRegion r, Object key, TXCommitMessage msg, Set otherRecipients) {
-        msg.addOp(r,key, this,otherRecipients);
+        msg.addOp(r, key, this, otherRecipients);
-  
-  
-  
-  void applyChanges(LocalRegion r, Object key, TXState txState)
-  {
+
+
+
+  void applyChanges(LocalRegion r, Object key, TXState txState) {
-      logger.debug(
-          "applyChanges txState=" + txState + " ,key=" + key + " ,r="
-              + r.getDisplayName() + " ,op=" + this.op + " ,isDirty="
-              + isDirty());
+      logger.debug("applyChanges txState=" + txState + " ,key=" + key + " ,r=" + r.getDisplayName()
+          + " ,op=" + this.op + " ,isDirty=" + isDirty());
-    case OP_NULL:
-      // do nothing
-      break;
-    case OP_L_DESTROY:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_CREATE_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_LLOAD_CREATE_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_NLOAD_CREATE_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_PUT_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_LLOAD_PUT_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_NLOAD_PUT_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_D_INVALIDATE_LD:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_D_DESTROY:
-      txApplyDestroyLocally(r, key, txState);
-      break;
-    case OP_L_INVALIDATE:
-      txApplyInvalidateLocally(r, key, Token.LOCAL_INVALID, didDestroy(), txState);
-      break;
-    case OP_PUT_LI:
-      txApplyPutLocally(r, getUpdateOperation(), key, Token.LOCAL_INVALID,
-          didDestroy(), txState);
-      break;
-    case OP_LLOAD_PUT_LI:
-      txApplyPutLocally(r, getUpdateOperation(), key, Token.LOCAL_INVALID,
-          didDestroy(), txState);
-      break;
-    case OP_NLOAD_PUT_LI:
-      txApplyPutLocally(r, getUpdateOperation(), key, Token.LOCAL_INVALID,
-          didDestroy(), txState);
-      break;
-    case OP_D_INVALIDATE:
-      txApplyInvalidateLocally(r, key, Token.INVALID, didDestroy(), txState);
-      break;
-    case OP_CREATE_LI:
-      txApplyPutLocally(r, getCreateOperation(), key, Token.LOCAL_INVALID,
-          didDestroy(), txState);
-      break;
-    case OP_LLOAD_CREATE_LI:
-      txApplyPutLocally(r, getCreateOperation(), key, Token.LOCAL_INVALID,
-          didDestroy(), txState);
-      break;
-    case OP_NLOAD_CREATE_LI:
-      txApplyPutLocally(r, getCreateOperation(), key, Token.LOCAL_INVALID,
-          didDestroy(), txState);
-      break;
-    case OP_CREATE:
-      txApplyPutLocally(r, getCreateOperation(), key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_SEARCH_CREATE:
-      txApplyPutLocally(r, Operation.SEARCH_CREATE, key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_LLOAD_CREATE:
-      txApplyPutLocally(r, Operation.LOCAL_LOAD_CREATE, key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_NLOAD_CREATE:
-      txApplyPutLocally(r, Operation.NET_LOAD_CREATE, key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_LOCAL_CREATE:
-      txApplyPutLocally(r, getCreateOperation(), key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_PUT:
-      txApplyPutLocally(r, getUpdateOperation(), key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_SEARCH_PUT:
-      txApplyPutLocally(r, Operation.SEARCH_UPDATE, key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_LLOAD_PUT:
-      txApplyPutLocally(r, Operation.LOCAL_LOAD_UPDATE, key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    case OP_NLOAD_PUT:
-      txApplyPutLocally(r, Operation.NET_LOAD_UPDATE, key, getPendingValue(),
-          didDestroy(), txState);
-      break;
-    default:
-      throw new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_OP_0.toLocalizedString(opToString()));
+      case OP_NULL:
+        // do nothing
+        break;
+      case OP_L_DESTROY:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_CREATE_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_LLOAD_CREATE_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_NLOAD_CREATE_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_PUT_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_LLOAD_PUT_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_NLOAD_PUT_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_D_INVALIDATE_LD:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_D_DESTROY:
+        txApplyDestroyLocally(r, key, txState);
+        break;
+      case OP_L_INVALIDATE:
+        txApplyInvalidateLocally(r, key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_PUT_LI:
+        txApplyPutLocally(r, getUpdateOperation(), key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_LLOAD_PUT_LI:
+        txApplyPutLocally(r, getUpdateOperation(), key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_NLOAD_PUT_LI:
+        txApplyPutLocally(r, getUpdateOperation(), key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_D_INVALIDATE:
+        txApplyInvalidateLocally(r, key, Token.INVALID, didDestroy(), txState);
+        break;
+      case OP_CREATE_LI:
+        txApplyPutLocally(r, getCreateOperation(), key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_LLOAD_CREATE_LI:
+        txApplyPutLocally(r, getCreateOperation(), key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_NLOAD_CREATE_LI:
+        txApplyPutLocally(r, getCreateOperation(), key, Token.LOCAL_INVALID, didDestroy(), txState);
+        break;
+      case OP_CREATE:
+        txApplyPutLocally(r, getCreateOperation(), key, getPendingValue(), didDestroy(), txState);
+        break;
+      case OP_SEARCH_CREATE:
+        txApplyPutLocally(r, Operation.SEARCH_CREATE, key, getPendingValue(), didDestroy(),
+            txState);
+        break;
+      case OP_LLOAD_CREATE:
+        txApplyPutLocally(r, Operation.LOCAL_LOAD_CREATE, key, getPendingValue(), didDestroy(),
+            txState);
+        break;
+      case OP_NLOAD_CREATE:
+        txApplyPutLocally(r, Operation.NET_LOAD_CREATE, key, getPendingValue(), didDestroy(),
+            txState);
+        break;
+      case OP_LOCAL_CREATE:
+        txApplyPutLocally(r, getCreateOperation(), key, getPendingValue(), didDestroy(), txState);
+        break;
+      case OP_PUT:
+        txApplyPutLocally(r, getUpdateOperation(), key, getPendingValue(), didDestroy(), txState);
+        break;
+      case OP_SEARCH_PUT:
+        txApplyPutLocally(r, Operation.SEARCH_UPDATE, key, getPendingValue(), didDestroy(),
+            txState);
+        break;
+      case OP_LLOAD_PUT:
+        txApplyPutLocally(r, Operation.LOCAL_LOAD_UPDATE, key, getPendingValue(), didDestroy(),
+            txState);
+        break;
+      case OP_NLOAD_PUT:
+        txApplyPutLocally(r, Operation.NET_LOAD_UPDATE, key, getPendingValue(), didDestroy(),
+            txState);
+        break;
+      default:
+        throw new IllegalStateException(
+            LocalizedStrings.TXEntryState_UNHANDLED_OP_0.toLocalizedString(opToString()));
-   * {@link Operation#CREATE} otherwise
+   *         {@link Operation#CREATE} otherwise
-   * {@link Operation#UPDATE} otherwise
+   *         {@link Operation#UPDATE} otherwise
-  
+
-   * Serializes this entry state to a data output stream for a far side consumer.
-   * Make sure this method is backwards compatible if changes are made.
-   * @param largeModCount
-   *          true if modCount needs to be represented by an int; false if a
-   *          byte is enough
-   * @param sendVersionTag
-   *          true if versionTag should be sent to clients 7.0 and above
-   * @param sendShadowKey
-   *          true if wan shadowKey should be sent to peers 7.0.1 and above
-   *          
+   * Serializes this entry state to a data output stream for a far side consumer. Make sure this
+   * method is backwards compatible if changes are made.
+   * 
+   * @param largeModCount true if modCount needs to be represented by an int; false if a byte is
+   *        enough
+   * @param sendVersionTag true if versionTag should be sent to clients 7.0 and above
+   * @param sendShadowKey true if wan shadowKey should be sent to peers 7.0.1 and above
+   * 
-  void toFarSideData(DataOutput out, boolean largeModCount, boolean sendVersionTag, boolean sendShadowKey) throws IOException
-  {
+  void toFarSideData(DataOutput out, boolean largeModCount, boolean sendVersionTag,
+      boolean sendShadowKey) throws IOException {
-    }
-    else {
+    } else {
-    DataSerializer.writeObject(getCallbackArgument(),out);
-    DataSerializer.writeObject(getFilterRoutingInfo(),out);
+    DataSerializer.writeObject(getCallbackArgument(), out);
+    DataSerializer.writeObject(getFilterRoutingInfo(), out);
-      assert getVersionTag() != null
-          || !txRegionState.getRegion().concurrencyChecksEnabled
-          || txRegionState.getRegion().dataPolicy != DataPolicy.REPLICATE : "tag:"+getVersionTag()+" r:"+txRegionState.getRegion()+" op:"+opToString()+" key:";
+      assert getVersionTag() != null || !txRegionState.getRegion().concurrencyChecksEnabled
+          || txRegionState.getRegion().dataPolicy != DataPolicy.REPLICATE : "tag:" + getVersionTag()
+              + " r:" + txRegionState.getRegion() + " op:" + opToString() + " key:";
-   * Creates a queued op and returns it for this entry on the far side of the
-   * tx.
+   * Creates a queued op and returns it for this entry on the far side of the tx.
-   * @param key
-   *          the key for this op
+   * @param key the key for this op
-  QueuedOperation toFarSideQueuedOp(Object key)
-  {
+  QueuedOperation toFarSideQueuedOp(Object key) {
-        valueBytes = (byte[])v;
-      }
-      else {
+        valueBytes = (byte[]) v;
+      } else {
-    return new QueuedOperation(operation, key, valueBytes, null,
-        deserializationPolicy, null);
+    return new QueuedOperation(operation, key, valueBytes, null, deserializationPolicy, null);
-  void cleanup(LocalRegion r)
-  {
+  void cleanup(LocalRegion r) {
-  
+
-   * Just like an EntryEventImpl but also has access to TxEntryState to make it
-   * Comparable
+   * Just like an EntryEventImpl but also has access to TxEntryState to make it Comparable
-  public final class TxEntryEventImpl extends EntryEventImpl implements Comparable
-  {
+  public final class TxEntryEventImpl extends EntryEventImpl implements Comparable {
-      //TODO:ASIF :Check if the eventID should be created. Currently not
+      // TODO:ASIF :Check if the eventID should be created. Currently not
-      super(r, getNearSideOperation(), key,
-          getNearSidePendingValue(),TXEntryState.this.getCallbackArgument(), false, r.getMyId()
-          , true/* generateCallbacks */, true /*initializeId*/);
+      super(r, getNearSideOperation(), key, getNearSidePendingValue(),
+          TXEntryState.this.getCallbackArgument(), false, r.getMyId(), true/* generateCallbacks */,
+          true /* initializeId */);
-    private int getSortValue()
-    {
+    private int getSortValue() {
-    public int compareTo(Object o)
-    {
-      TxEntryEventImpl other = (TxEntryEventImpl)o;
+    public int compareTo(Object o) {
+      TxEntryEventImpl other = (TxEntryEventImpl) o;
-    public boolean equals(Object o)
-    {
-      if (o == null || !(o instanceof TxEntryEventImpl)) return false;
+    public boolean equals(Object o) {
+      if (o == null || !(o instanceof TxEntryEventImpl))
+        return false;
-    public int hashCode()
-    {
+    public int hashCode() {
-  
+
-    public TXEntryState createEntry()
-    {
+    public TXEntryState createEntry() {
-    public TXEntryState createEntry(RegionEntry re, Object vId, Object pendingValue, Object entryKey,TXRegionState txrs,boolean isDistributed)
-    {
+    public TXEntryState createEntry(RegionEntry re, Object vId, Object pendingValue,
+        Object entryKey, TXRegionState txrs, boolean isDistributed) {
-  public static TXEntryStateFactory getFactory()
-  {
+  public static TXEntryStateFactory getFactory() {
-   this.filterRoutingInfo = fri;
+    this.filterRoutingInfo = fri;
-  
+
-  
+
-  
+
-  
+
-  
+
-   * This class is used to bring relevant information for DistTxEntryEvent from
-   * primary, after end of precommit. Same information are sent to all
-   * replicates during commit.
+   * This class is used to bring relevant information for DistTxEntryEvent from primary, after end
+   * of precommit. Same information are sent to all replicates during commit.
-   * Whereas @see DistTxEntryEvent is used forstoring entry event information on
-   * TxCordinator and carry same to replicates.
+   * Whereas @see DistTxEntryEvent is used forstoring entry event information on TxCordinator and
+   * carry same to replicates.
-    private long regionVersion =1L;
+    private long regionVersion = 1L;
-    public DistTxThinEntryState() {
-    }
+    public DistTxThinEntryState() {}
-}
+}

GEODE-8070: rework handling of "any" in SSLUtils (#5075)

* GEODE-8070: rework handling of "any" in SSLUtils

Rewrite of the sslContext location method to fix these problems:
  requesting a specific but non-existent protocol would not result in an
  exception

  requesting "any" (the default) would result in a less-secure protocol
  than is actually available (e.g., SSL instead of TLSv1.2)

I also changed processing so that if "any" is in the list but none of
the default protocols are available we continue to search through the
provided list.  For instance, {X, any, Y} would result in a search for Y
if X and all of the default protocols cannot be found.

* updated documentation for ssl-protocols and ssl-ciphers

* updated documentation for ssl-protocols and ssl-ciphers

* fixing docs
-package org.apache.geode.management.internal;
+package org.apache.geode.internal.net;
+import org.apache.geode.annotations.VisibleForTesting;
-/**
- *
- * @since GemFire 8.1
- */
-  public static SSLContext getSSLContextInstance(SSLConfig sslConfig) {
+  /**
+   * This is a list of the algorithms that are tried, in order, when "any" is specified. Update
+   * this list as new algorithms become available and are supported by Geode. Remove old,
+   * no-longer trusted algorithms.
+   */
+  protected static final String[] DEFAULT_ALGORITMS = {
+      "TLSv1.3",
+      "TLSv1.2"}; // TLSv1.3 is not available in JDK 8 at this time
+
+
+
+  public static SSLContext getSSLContextInstance(SSLConfig sslConfig)
+      throws NoSuchAlgorithmException {
-    SSLContext sslContext = null;
-    if (protocols != null && protocols.length > 0) {
-      for (String protocol : protocols) {
-        if (!protocol.equals("any")) {
-          try {
-            sslContext = SSLContext.getInstance(protocol);
-            break;
-          } catch (NoSuchAlgorithmException e) {
-            // continue
-          }
+    return findSSLContextForProtocols(protocols, DEFAULT_ALGORITMS);
+  }
+
+  /**
+   * Search for a context supporting one of the given prioritized list of
+   * protocols. The second argument is a list of protocols to try if the
+   * first list contains "any". The second argument should also be in prioritized
+   * order. If there are no matches for any of the protocols in the second
+   * argument we will continue in the first argument list.
+   * with a first argument of A, B, any, C
+   * and a second argument of D, E
+   * the search order would be A, B, D, E, C
+   */
+  @VisibleForTesting
+  protected static SSLContext findSSLContextForProtocols(final String[] protocols,
+      final String[] protocolsForAny)
+      throws NoSuchAlgorithmException {
+    for (String protocol : protocols) {
+      if (protocol.equalsIgnoreCase("any")) {
+        try {
+          return findSSLContextForProtocols(protocolsForAny, new String[0]);
+        } catch (NoSuchAlgorithmException e) {
+          // none of the default algorithms is available - continue to see if there
+          // are any others in the requested list
-    }
-    if (sslContext != null) {
-      return sslContext;
-    }
-    // lookup known algorithms
-    String[] knownAlgorithms = {"SSL", "SSLv2", "SSLv3", "TLS", "TLSv1", "TLSv1.1", "TLSv1.2"};
-    for (String algo : knownAlgorithms) {
-        sslContext = SSLContext.getInstance(algo);
-        break;
+        return SSLContext.getInstance(protocol);
-    return sslContext;
+    throw new NoSuchAlgorithmException();

GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Collections;
+import org.apache.geode.internal.cache.CachedDeserializableFactory;
+import org.apache.geode.internal.cache.DataLocationException;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.KeyInfo;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+import org.apache.geode.internal.cache.TXManagerImpl;
+import org.apache.geode.internal.cache.TXStateProxy;
- * This message is used as the request for a
- * {@link org.apache.geode.cache.Region#get(Object)}operation. The reply is sent in a
- * {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}.
- *
- * Replicate regions can use this message to send a Get request to another peer.
+ * This message is used as the request for a get operation done in a transaction that is hosted on a
+ * remote member. This messsage sends the get to the remote member.
-  public int getProcessorType() {
-    return ClusterDistributionManager.SERIAL_EXECUTOR;
-  }
-
-  @Override
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
-  }
-
-  @Override
-    if (!(r instanceof PartitionedRegion)) { // prs already wait on initialization
-      r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-    }
+    r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-      // r.getPrStats().endPartitionMessagesProcessing(startTime);
-      // Unless there was an exception thrown, this message handles sending the
-      // response
+      // Unless an exception was thrown, this message handles sending the response
-    } catch (PrimaryBucketException pbe) {
-      sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-      return false;
-    Assert.assertTrue(recipient != null, "PRDistribuedGetReplyMessage NULL reply message");
-    RemoteGetResponse p =
-        new RemoteGetResponse(r.getSystem(), Collections.singleton(recipient), key);
+    Assert.assertTrue(recipient != null, "RemoteGetMessage NULL recipient");
+    RemoteGetResponse p = new RemoteGetResponse(r.getSystem(), recipient);
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-   * {@link org.apache.geode.internal.cache.RemoteGetMessage.GetReplyMessage}
+   * {@link org.apache.geode.internal.cache.tx.RemoteGetMessage.GetReplyMessage}
-    final Object key;
-    public RemoteGetResponse(InternalDistributedSystem ds, Set recipients, Object key) {
-      super(ds, recipients, false);
-      this.key = key;
+    public RemoteGetResponse(InternalDistributedSystem ds, InternalDistributedMember recipient) {
+      super(ds, recipient, false);
-      try {
-        // waitForRepliesUninterruptibly();
-        waitForCacheException();
-        if (DistributionStats.enableClockStats) {
-          getDistributionManager().getStats().incReplyHandOffTime(this.start);
-        }
-      } catch (RemoteOperationException e) {
-        e.checkKey(key);
-        final String msg = "RemoteGetResponse got RemoteOperationException; rethrowing";
-        logger.debug(msg, e);
-        throw e;
+      waitForRemoteResponse();
+      if (DistributionStats.enableClockStats) {
+        getDistributionManager().getStats().incReplyHandOffTime(this.start);

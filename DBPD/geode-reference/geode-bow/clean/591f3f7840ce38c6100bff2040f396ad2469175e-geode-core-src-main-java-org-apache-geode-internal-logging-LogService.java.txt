GEODE-2644: Make LogWriterAppender optional and support log4j2.xml

LogWriterAppender is now configured in log4j2.xml and it supports
sessions that correspond with Cache lifecycle. This allows Geode to
pause and resume LogWriterAppender and GeodeConsoleAppender without
resorting to dynamically adding and removing appenders.

When the Cache exists, log events stop going to the Console and instead
go to the Geode log file. Whenever the Cache does not exist, log events
go only to the Console.

These changes remove as much of the Log4j2 Core manipulation as
possible.

Also fixed:
* GEODE-5789: Geode now updates log level of all Geode loggers.

List of changes:
* Change LogWriterAppender to be pausable and session-oriented
* Add GeodeConsoleAppender which is pausable
* Log4j2 Core dependency is now optional
* Internal Logging interfaces allow Logging service to be pluggable
* Log4j2 xml integration testing now uses JUnit Rule from Log4j2
* Reduce coupling between Logging and the rest of Geode
* Greatly increase test coverage for Logging

-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.io.File;
-
-import org.apache.logging.log4j.Level;
-import org.apache.logging.log4j.core.Appender;
-import org.apache.logging.log4j.core.LoggerContext;
-import org.apache.logging.log4j.core.config.Configuration;
-import org.apache.logging.log4j.core.config.LoggerConfig;
-import org.apache.logging.log4j.core.lookup.StrLookup;
-import org.apache.logging.log4j.core.lookup.StrSubstitutor;
-import org.apache.logging.log4j.status.StatusLogger;
+import org.apache.logging.log4j.util.StackLocator;
-import org.apache.geode.internal.logging.log4j.AppenderContext;
-import org.apache.geode.internal.logging.log4j.ConfigLocator;
-import org.apache.geode.internal.logging.log4j.Configurator;
+import org.apache.geode.cache.Region;
+import org.apache.geode.internal.cache.EntriesSet;
+import org.apache.geode.internal.logging.log4j.message.GemFireParameterizedMessage;
- * Centralizes log configuration and initialization.
+ * Provides Log4J2 Loggers with customized optimizations for Geode:
+ *
+ * <p>
+ * Returned Logger is wrapped inside an instance of {@link FastLogger} which skips expensive
+ * filtering, debug and trace handling with a volatile boolean. This optimization is turned on only
+ * when using the default Geode {@code log4j2.xml} by checking for the existence of this property:
+ *
+ * <pre>
+ * &lt;Property name="geode-default"&gt;true&lt;/Property&gt;
+ * </pre>
+ *
+ * <p>
+ * Returned Logger uses {@link GemFireParameterizedMessageFactory} to create
+ * {@link GemFireParameterizedMessage} which excludes {@link Region}s from being handled as a
+ * {@code Map} and {@link EntriesSet} from being handled as a {@code Collection}. Without this
+ * change, using a {@code Region} or {@code EntriesSet} in a log statement can result in an
+ * expensive operation or even a hang in the case of a {@code PartitionedRegion}.
+ *
+ * <p>
+ * {@code LogService} only uses Log4J2 API so that any logging backend may be used.
-  private static final Logger LOGGER = StatusLogger.getLogger();
-
-  // This is highest point in the hierarchy for all Geode logging
-  public static final String ROOT_LOGGER_NAME = "";
-  public static final String BASE_LOGGER_NAME = "org.apache.geode";
-  public static final String MAIN_LOGGER_NAME = "org.apache.geode";
-  public static final String SECURITY_LOGGER_NAME = "org.apache.geode.security";
-
-  public static final String GEODE_VERBOSE_FILTER = "{GEODE_VERBOSE}";
-  public static final String GEMFIRE_VERBOSE_FILTER = "{GEMFIRE_VERBOSE}";
-  public static final String DEFAULT_CONFIG = "/log4j2.xml";
-  public static final String CLI_CONFIG = "/log4j2-cli.xml";
-
-  protected static final String STDOUT = "STDOUT";
-
-  private static final PropertyChangeListener propertyChangeListener =
-      new PropertyChangeListenerImpl();
-
-  /**
-   * Name of variable that is set to "true" in log4j2.xml to indicate that it is the default geode
-   * config xml.
-   */
-  private static final String GEMFIRE_DEFAULT_PROPERTY = "geode-default";
-
-  /**
-   * Protected by static synchronization. Used for removal and adding stdout back in.
-   */
-  private static Appender stdoutAppender;
-
-  static {
-    init();
-  }
-
-  private static void init() {
-    LoggerContext loggerContext = getLoggerContext(BASE_LOGGER_NAME);
-    loggerContext.removePropertyChangeListener(propertyChangeListener);
-    loggerContext.addPropertyChangeListener(propertyChangeListener);
-    loggerContext.reconfigure(); // propertyChangeListener invokes configureFastLoggerDelegating
-    configureLoggers(false, false);
-  }
-
-  public static void reconfigure() {
-    init();
-  }
-
-  public static void configureLoggers(final boolean hasLogFile, final boolean hasSecurityLogFile) {
-    Configurator.getOrCreateLoggerConfig(BASE_LOGGER_NAME, true, false);
-    Configurator.getOrCreateLoggerConfig(MAIN_LOGGER_NAME, true, hasLogFile);
-    boolean useMainLoggerForSecurity = !hasSecurityLogFile;
-    Configurator.getOrCreateLoggerConfig(SECURITY_LOGGER_NAME, useMainLoggerForSecurity,
-        hasSecurityLogFile);
-  }
-
-  public static AppenderContext getAppenderContext() {
-    return new AppenderContext();
-  }
-
-  public static AppenderContext getAppenderContext(final String name) {
-    return new AppenderContext(name);
-  }
-
-  public static boolean isUsingGemFireDefaultConfig() {
-    Configuration configuration = getConfiguration();
-
-    StrSubstitutor strSubstitutor = configuration.getStrSubstitutor();
-    StrLookup variableResolver = strSubstitutor.getVariableResolver();
-
-    String value = variableResolver.lookup(GEMFIRE_DEFAULT_PROPERTY);
-
-    return "true".equals(value);
-  }
-
-  public static String getConfigurationInfo() {
-    return getConfiguration().getConfigurationSource().toString();
-  }
-
-  /**
-   * Finds a Log4j configuration file in the current directory. The names of the files to look for
-   * are the same as those that Log4j would look for on the classpath.
-   *
-   * @return A File for the configuration file or null if one isn't found.
-   */
-  public static File findLog4jConfigInCurrentDir() {
-    return ConfigLocator.findConfigInWorkingDirectory();
-  }
-
+    String name = StackLocator.getInstance().getCallerClass(2).getName();
-        LogManager.getLogger(getClassName(2), GemFireParameterizedMessageFactory.INSTANCE));
+        LogManager.getLogger(name, GemFireParameterizedMessageFactory.INSTANCE));
+   *
-
-  /**
-   * Return the Log4j Level associated with the int level.
-   *
-   * @param intLevel The int value of the Level to return.
-   *
-   * @return The Level.
-   *
-   * @throws IllegalArgumentException if the Level int is not registered.
-   */
-  public static Level toLevel(final int intLevel) {
-    for (Level level : Level.values()) {
-      if (level.intLevel() == intLevel) {
-        return level;
-      }
-    }
-
-    throw new IllegalArgumentException("Unknown int level [" + intLevel + "].");
-  }
-
-  /**
-   * Gets the class name of the caller in the current stack at the given {@code depth}.
-   *
-   * @param depth a 0-based index in the current stack.
-   *
-   * @return a class name
-   */
-  public static String getClassName(final int depth) {
-    return new Throwable().getStackTrace()[depth].getClassName();
-  }
-
-  public static Configuration getConfiguration() {
-    return getRootLoggerContext().getConfiguration();
-  }
-
-  public static void configureFastLoggerDelegating() {
-    Configuration configuration = getConfiguration();
-    if (Configurator.hasContextWideFilter(configuration)
-        || Configurator.hasAppenderFilter(configuration)
-        || Configurator.hasDebugOrLower(configuration)
-        || Configurator.hasLoggerFilter(configuration)
-        || Configurator.hasAppenderRefFilter(configuration)) {
-      FastLogger.setDelegating(true);
-    } else {
-      FastLogger.setDelegating(false);
-    }
-  }
-
-  public static void setSecurityLogLevel(Level level) {
-    Configurator.setLevel(SECURITY_LOGGER_NAME, level);
-  }
-
-  public static Level getBaseLogLevel() {
-    return Configurator.getLevel(BASE_LOGGER_NAME);
-  }
-
-  public static void setBaseLogLevel(Level level) {
-    if (isUsingGemFireDefaultConfig()) {
-      Configurator.setLevel(ROOT_LOGGER_NAME, level);
-    }
-    Configurator.setLevel(BASE_LOGGER_NAME, level);
-    Configurator.setLevel(MAIN_LOGGER_NAME, level);
-  }
-
-  private static LoggerContext getLoggerContext(final String name) {
-    return ((org.apache.logging.log4j.core.Logger) LogManager
-        .getLogger(name, GemFireParameterizedMessageFactory.INSTANCE)).getContext();
-  }
-
-  static LoggerContext getRootLoggerContext() {
-    return ((org.apache.logging.log4j.core.Logger) LogManager.getRootLogger()).getContext();
-  }
-
-  /**
-   * Removes STDOUT ConsoleAppender from ROOT logger. Only called when using the log4j2-default.xml
-   * configuration. This is done when creating the LogWriterAppender for log-file. The Appender
-   * instance is stored in stdoutAppender so it can be restored later using restoreConsoleAppender.
-   */
-  public static synchronized void removeConsoleAppender() {
-    AppenderContext appenderContext = getAppenderContext(ROOT_LOGGER_NAME);
-    LoggerConfig loggerConfig = appenderContext.getLoggerConfig();
-    Appender stdoutAppender = loggerConfig.getAppenders().get(STDOUT);
-    if (stdoutAppender != null) {
-      loggerConfig.removeAppender(STDOUT);
-      LogService.stdoutAppender = stdoutAppender;
-      appenderContext.getLoggerContext().updateLoggers();
-    }
-  }
-
-  /**
-   * Restores STDOUT ConsoleAppender to ROOT logger. Only called when using the log4j2-default.xml
-   * configuration. This is done when the LogWriterAppender for log-file is destroyed. The Appender
-   * instance stored in stdoutAppender is used.
-   */
-  public static synchronized void restoreConsoleAppender() {
-    if (stdoutAppender == null) {
-      return;
-    }
-    AppenderContext appenderContext = getAppenderContext(ROOT_LOGGER_NAME);
-    LoggerConfig loggerConfig = appenderContext.getLoggerConfig();
-    Appender stdoutAppender = loggerConfig.getAppenders().get(STDOUT);
-    if (stdoutAppender == null) {
-      loggerConfig.addAppender(LogService.stdoutAppender, Level.ALL, null);
-      appenderContext.getLoggerContext().updateLoggers();
-    }
-  }
-
-  private static class PropertyChangeListenerImpl implements PropertyChangeListener {
-
-    @Override
-    public void propertyChange(final PropertyChangeEvent evt) {
-      LOGGER.debug("LogService responding to a property change event. Property name is {}.",
-          evt.getPropertyName());
-
-      if (evt.getPropertyName().equals(LoggerContext.PROPERTY_CONFIG)) {
-        configureFastLoggerDelegating();
-      }
-    }
-  }

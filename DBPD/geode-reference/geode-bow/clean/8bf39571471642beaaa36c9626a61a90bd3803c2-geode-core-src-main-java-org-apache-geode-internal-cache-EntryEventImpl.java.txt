Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  implements EntryEvent, InternalCacheEvent, DataSerializableFixedID, EntryOperation
-             , Releasable
-{
+    implements EntryEvent, InternalCacheEvent, DataSerializableFixedID, EntryOperation, Releasable {
-  
+
-  //private long eventId;
+  // private long eventId;
-   * If we ever serialize the new value then it should be
-   * stored in this field in case we need the serialized form
-   * again later. This was added to fix bug 43781.
-   * Note that we also have the "newValueBytes" field.
-   * But it is only non-null if setSerializedNewValue was called.
+   * If we ever serialize the new value then it should be stored in this field in case we need the
+   * serialized form again later. This was added to fix bug 43781. Note that we also have the
+   * "newValueBytes" field. But it is only non-null if setSerializedNewValue was called.
- 
+
-  
+
-  
-  
-  //private static long eventID = 0;
+
+
+  // private static long eventID = 0;
-  
+
-   * this holds the bytes representing the change in value effected by this
-   * event.  It is used when the value implements the Delta interface.
+   * this holds the bytes representing the change in value effected by this event. It is used when
+   * the value implements the Delta interface.
-  
+
-  
-  /**new value stored in serialized form*/
+
+  /** new value stored in serialized form */
-  /**old value stored in serialized form*/
+  /** old value stored in serialized form */
-  
+
-  /** boolean to indicate that the RegionEntry for this event has been evicted*/
+  /** boolean to indicate that the RegionEntry for this event has been evicted */
-  
+
-  
+
-  
-  public EntryEventImpl() {
-  }
-  
+
+  public EntryEventImpl() {}
+
-    this.eventID = (EventID)DataSerializer.readObject(in);
+    this.eventID = (EventID) DataSerializer.readObject(in);
-    this.txId = (TXId)DataSerializer.readObject(in);
+    this.txId = (TXId) DataSerializer.readObject(in);
-    if (in.readBoolean()) {     // isDelta
+    if (in.readBoolean()) { // isDelta
-    }
-    else {
-      // OFFHEAP Currently values are never deserialized to off heap memory. If that changes then this code needs to change.
-      if (in.readBoolean()) {     // newValueSerialized
+    } else {
+      // OFFHEAP Currently values are never deserialized to off heap memory. If that changes then
+      // this code needs to change.
+      if (in.readBoolean()) { // newValueSerialized
-      }
-      else {
+      } else {
-    // OFFHEAP Currently values are never deserialized to off heap memory. If that changes then this code needs to change.
-    if (in.readBoolean()) {     // oldValueSerialized
+    // OFFHEAP Currently values are never deserialized to off heap memory. If that changes then this
+    // code needs to change.
+    if (in.readBoolean()) { // oldValueSerialized
-    }
-    else {
+    } else {
-  protected EntryEventImpl(LocalRegion region, Operation op, Object key,
-      boolean originRemote, DistributedMember distributedMember,
-      boolean generateCallbacks, boolean fromRILocalDestroy) {
+  protected EntryEventImpl(LocalRegion region, Operation op, Object key, boolean originRemote,
+      DistributedMember distributedMember, boolean generateCallbacks, boolean fromRILocalDestroy) {
-   * Doesn't specify oldValue as this will be filled in later as part of an
-   * operation on the region, or lets it default to null.
+   * Doesn't specify oldValue as this will be filled in later as part of an operation on the region,
+   * or lets it default to null.
-  protected EntryEventImpl(
-      final LocalRegion region,
-      Operation op, Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal,
-      Object callbackArgument,
-      boolean originRemote, DistributedMember distributedMember,
-      boolean generateCallbacks, boolean initializeId) {
+  protected EntryEventImpl(final LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal, Object callbackArgument, boolean originRemote,
+      DistributedMember distributedMember, boolean generateCallbacks, boolean initializeId) {
-     * this might set txId for events done from a thread that has a tx even
-     * though the op is non-tx. For example region ops.
+     * this might set txId for events done from a thread that has a tx even though the op is non-tx.
+     * For example region ops.
-      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument, boolean originRemote,
-      DistributedMember distributedMember, boolean generateCallbacks,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember, boolean generateCallbacks,
-    this(region, op, key, newValue,
-        callbackArgument, originRemote, distributedMember, generateCallbacks,
-        true /* initializeId */);
+    this(region, op, key, newValue, callbackArgument, originRemote, distributedMember,
+        generateCallbacks, true /* initializeId */);
-  public EntryEventImpl(@Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other) {
+  public EntryEventImpl(
+      @Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other) {
-  
+
-  public EntryEventImpl(@Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other, boolean setOldValue) {
+  public EntryEventImpl(
+      @Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other,
+      boolean setOldValue) {
-    this.keyInfo = other.keyInfo.isDistKeyInfo() ? new DistTxKeyInfo(
-        (DistTxKeyInfo) other.keyInfo) : new KeyInfo(other.keyInfo);
+    this.keyInfo = other.keyInfo.isDistKeyInfo() ? new DistTxKeyInfo((DistTxKeyInfo) other.keyInfo)
+        : new KeyInfo(other.keyInfo);
-      this.keyInfo
-          .setCallbackArg((new GatewaySenderEventCallbackArgument(
-              (GatewaySenderEventCallbackArgument) other
-                  .getRawCallbackArgument())));
+      this.keyInfo.setCallbackArg((new GatewaySenderEventCallbackArgument(
+          (GatewaySenderEventCallbackArgument) other.getRawCallbackArgument())));
-    //set possible duplicate 
-    this.setPossibleDuplicate(other.isPossibleDuplicate()); 
+    // set possible duplicate
+    this.setPossibleDuplicate(other.isPossibleDuplicate());
-   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
-   * EntryEventImpl if the region parameter is a PartitionedRegion.
-   */  
-  @Retained
-  public static EntryEventImpl create(LocalRegion region,
-      Operation op,
-      Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
-      boolean originRemote, DistributedMember distributedMember) {
-    return create(region,op,key,newValue,callbackArgument,originRemote,distributedMember,true,true);
-  }
-  
-  /**
-   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
-   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * Creates and returns an EntryEventImpl. Generates and assigns a bucket id to the EntryEventImpl
+   * if the region parameter is a PartitionedRegion.
-  public static EntryEventImpl create(LocalRegion region,
-      Operation op,
-      Object key,
-      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue,
-      Object callbackArgument,
-      boolean originRemote,
-      DistributedMember distributedMember,
-      boolean generateCallbacks) {
-    return create(region, op, key, newValue, callbackArgument, originRemote,
-        distributedMember, generateCallbacks,true);
+  public static EntryEventImpl create(LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember) {
+    return create(region, op, key, newValue, callbackArgument, originRemote, distributedMember,
+        true, true);
-  
+
-   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
-   * EntryEventImpl if the region parameter is a PartitionedRegion.
-   *  
+   * Creates and returns an EntryEventImpl. Generates and assigns a bucket id to the EntryEventImpl
+   * if the region parameter is a PartitionedRegion.
+   */
+  @Retained
+  public static EntryEventImpl create(LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember, boolean generateCallbacks) {
+    return create(region, op, key, newValue, callbackArgument, originRemote, distributedMember,
+        generateCallbacks, true);
+  }
+
+  /**
+   * Creates and returns an EntryEventImpl. Generates and assigns a bucket id to the EntryEventImpl
+   * if the region parameter is a PartitionedRegion.
+   * 
-   */ 
+   */
-      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument, boolean originRemote,
-      DistributedMember distributedMember, boolean generateCallbacks,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember, boolean generateCallbacks,
-    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,newValue,callbackArgument,originRemote,distributedMember,generateCallbacks,eventID);
+    EntryEventImpl entryEvent = new EntryEventImpl(region, op, key, newValue, callbackArgument,
+        originRemote, distributedMember, generateCallbacks, eventID);
-  
+
-   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
-   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * Creates and returns an EntryEventImpl. Generates and assigns a bucket id to the EntryEventImpl
+   * if the region parameter is a PartitionedRegion.
-      boolean originRemote, DistributedMember distributedMember,
-      boolean generateCallbacks, boolean fromRILocalDestroy) {
-    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,originRemote,distributedMember,generateCallbacks,fromRILocalDestroy);
+      boolean originRemote, DistributedMember distributedMember, boolean generateCallbacks,
+      boolean fromRILocalDestroy) {
+    EntryEventImpl entryEvent = new EntryEventImpl(region, op, key, originRemote, distributedMember,
+        generateCallbacks, fromRILocalDestroy);
-  }  
-  
+  }
+
-   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
-   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * Creates and returns an EntryEventImpl. Generates and assigns a bucket id to the EntryEventImpl
+   * if the region parameter is a PartitionedRegion.
-  public static EntryEventImpl create(final LocalRegion region,
-      Operation op, Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal,
-      Object callbackArgument,
-      boolean originRemote, DistributedMember distributedMember,
-      boolean generateCallbacks, boolean initializeId)  {
-    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,newVal,callbackArgument,
-        originRemote,distributedMember,generateCallbacks,initializeId);
+  public static EntryEventImpl create(final LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal, Object callbackArgument, boolean originRemote,
+      DistributedMember distributedMember, boolean generateCallbacks, boolean initializeId) {
+    EntryEventImpl entryEvent = new EntryEventImpl(region, op, key, newVal, callbackArgument,
+        originRemote, distributedMember, generateCallbacks, initializeId);
-  
+
-   * Creates a PutAllEvent given the distributed operation, the region, and the
-   * entry data.
+   * Creates a PutAllEvent given the distributed operation, the region, and the entry data.
-  static EntryEventImpl createPutAllEvent(
-      DistributedPutAllOperation putAllOp, LocalRegion region,
-      Operation entryOp, Object entryKey, @Retained(ENTRY_EVENT_NEW_VALUE) Object entryNewValue)
-  {
-    @Retained EntryEventImpl e;
+  static EntryEventImpl createPutAllEvent(DistributedPutAllOperation putAllOp, LocalRegion region,
+      Operation entryOp, Object entryKey, @Retained(ENTRY_EVENT_NEW_VALUE) Object entryNewValue) {
+    @Retained
+    EntryEventImpl e;
-        e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, event.getCallbackArgument(),
-            false, region.getMyId(), event.isGenerateCallbacks());
+        e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue,
+            event.getCallbackArgument(), false, region.getMyId(), event.isGenerateCallbacks());
-      
+
-      e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, null,
-          false, region.getMyId(), true);
+      e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, null, false,
+          region.getMyId(), true);
-    
+
-  
+
-  protected static EntryEventImpl createRemoveAllEvent(
-      DistributedRemoveAllOperation op, 
-      LocalRegion region,
-      Object entryKey) {
-    @Retained EntryEventImpl e;
+  protected static EntryEventImpl createRemoveAllEvent(DistributedRemoveAllOperation op,
+      LocalRegion region, Object entryKey) {
+    @Retained
+    EntryEventImpl e;
-        e = EntryEventImpl.create(region, entryOp, entryKey, null,
-            event.getRawCallbackArgument(), false, event.distributedMember,
-            event.isGenerateCallbacks());
+        e = EntryEventImpl.create(region, entryOp, entryKey, null, event.getRawCallbackArgument(),
+            false, event.distributedMember, event.isGenerateCallbacks());
-      
+
-      e = EntryEventImpl.create(region, entryOp, entryKey, null, null,
-          false, region.getMyId(), true);
+      e = EntryEventImpl.create(region, entryOp, entryKey, null, null, false, region.getMyId(),
+          true);
-    
+
+
-  
+
+
+
+
-  private final boolean testEventFlag(short mask)
-  {
+  private final boolean testEventFlag(short mask) {
-  private final void setEventFlag(short mask, boolean on)
-  {
+  private final void setEventFlag(short mask, boolean on) {
-  public DistributedMember getDistributedMember()
-  {
+  public DistributedMember getDistributedMember() {
-  public void setOriginRemote(boolean b)
-  {
+  public void setOriginRemote(boolean b) {
-  public void setLocalInvalid(boolean b)
-  {
+  public void setLocalInvalid(boolean b) {
-  void setGenerateCallbacks(boolean b)
-  {
+  void setGenerateCallbacks(boolean b) {
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-   * get the PartitionMessage that caused this event, or null if
-   * the event was not caused by a PartitionMessage
+   * get the PartitionMessage that caused this event, or null if the event was not caused by a
+   * PartitionMessage
-      return (PartitionMessage)this.causedByMessage;
-  }
+      return (PartitionMessage) this.causedByMessage;
+    }
-   * get the RemoteOperationMessage that caused this event, or null if
-   * the event was not caused by a RemoteOperationMessage
+   * get the RemoteOperationMessage that caused this event, or null if the event was not caused by a
+   * RemoteOperationMessage
-      return (RemoteOperationMessage)this.causedByMessage;
+      return (RemoteOperationMessage) this.causedByMessage;
-  public boolean isLocalLoad()
-  {
+  public boolean isLocalLoad() {
-  public boolean isNetSearch()
-  {
+  public boolean isNetSearch() {
-  public boolean isNetLoad()
-  {
+  public boolean isNetLoad() {
-  public boolean isDistributed()
-  {
+  public boolean isDistributed() {
-  public boolean isExpiration()
-  {
+  public boolean isExpiration() {
-  
+
-  
+
-  
+
-  
-  public final void setPendingSecondaryExpireDestroy (boolean value) {
+
+  public final void setPendingSecondaryExpireDestroy(boolean value) {
+
-  // was received from a peer.  This is done to force distribution of the
+  // was received from a peer. This is done to force distribution of the
-  public boolean isOriginRemote()
-  {
+  public boolean isOriginRemote() {
-  
+
-  public boolean isGenerateCallbacks()
-  {
+  public boolean isGenerateCallbacks() {
-        logger.trace(LogMarker.BRIDGE_SERVER, "Replacing event ID with {} in event {}", newID, this);
+        logger.trace(LogMarker.BRIDGE_SERVER, "Replacing event ID with {} in event {}", newID,
+            this);
-  
+
-      this.eventID.reserveSequenceId(count-1);
+      this.eventID.reserveSequenceId(count - 1);
-  public void setEventId(EventID id)
-  {
+  public void setEventId(EventID id) {
+   * 
+
-   * gets the ID of the client that initiated this event.  Null if a server-initiated event
+   * gets the ID of the client that initiated this event. Null if a server-initiated event
-  public ClientProxyMembershipID getContext()
-  {
+  public ClientProxyMembershipID getContext() {
-  boolean isLocalInvalid()
-  {
+  boolean isLocalInvalid() {
-  public Object getKey()
-  {
+  public Object getKey() {
-   * Returns the value in the cache prior to this event. When passed to an event
-   * handler after an event occurs, this value reflects the value that was in
-   * the cache in this VM, not necessarily the value that was in the cache VM
-   * that initiated the operation.
+   * Returns the value in the cache prior to this event. When passed to an event handler after an
+   * event occurs, this value reflects the value that was in the cache in this VM, not necessarily
+   * the value that was in the cache VM that initiated the operation.
-      @Unretained Object ov = basicGetOldValue();
+      @Unretained
+      Object ov = basicGetOldValue();
-          return callWithOffHeapLock((CachedDeserializable)ov, oldValueCD -> {
+          return callWithOffHeapLock((CachedDeserializable) ov, oldValueCD -> {
-        }
-        else {
+        } else {
-    } catch(IllegalArgumentException i) {
-      IllegalArgumentException iae = new IllegalArgumentException(LocalizedStrings.DONT_RELEASE.toLocalizedString("Error while deserializing value for key="+getKey()));
+    } catch (IllegalArgumentException i) {
+      IllegalArgumentException iae = new IllegalArgumentException(LocalizedStrings.DONT_RELEASE
+          .toLocalizedString("Error while deserializing value for key=" + getKey()));
-   * Like getRawNewValue except that if the result is an off-heap reference then copy it to the heap.
-   * Note: to prevent the heap copy use getRawNewValue instead
+   * Like getRawNewValue except that if the result is an off-heap reference then copy it to the
+   * heap. Note: to prevent the heap copy use getRawNewValue instead
-  
+
-   * If new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
-   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
-   * Else return the raw form.
+   * If new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). Its
+   * refcount is not inced by this call and the returned object can only be safely used for the
+   * lifetime of the EntryEventImpl instance that returned the value. Else return the raw form.
-  
+
-    if (v == this.newValue) return;
+    if (v == this.newValue)
+      return;
-  
+
-      //this.region.getCache().getLogger().info("DEBUG new value already freed " + System.identityHashCode(result));
-      throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+      // this.region.getCache().getLogger().info("DEBUG new value already freed " +
+      // System.identityHashCode(result));
+      throw new IllegalStateException(
+          "Attempt to access off heap value after the EntryEvent was released.");
-  
+
-  
+
+
+
-   * Note if v might be an off-heap reference that you did not retain for this EntryEventImpl
-   * then call retainsAndSetOldValue instead of this method.
+   * Note if v might be an off-heap reference that you did not retain for this EntryEventImpl then
+   * call retainsAndSetOldValue instead of this method.
+   * 
-    @Released final Object curOldValue = this.oldValue;
-    if (v == curOldValue) return;
+    @Released
+    final Object curOldValue = this.oldValue;
+    if (v == curOldValue)
+      return;
-    
+
-    if (v == this.oldValue) return;
-    
+    if (v == this.oldValue)
+      return;
+
-      //this.region.getCache().getLogger().info("DEBUG old value already freed " + System.identityHashCode(result));
-      throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+      // this.region.getCache().getLogger().info("DEBUG old value already freed " +
+      // System.identityHashCode(result));
+      throw new IllegalStateException(
+          "Attempt to access off heap value after the EntryEvent was released.");
-   * Like getRawOldValue except that if the result is an off-heap reference then copy it to the heap.
-   * To avoid the heap copy use getRawOldValue instead.
+   * Like getRawOldValue except that if the result is an off-heap reference then copy it to the
+   * heap. To avoid the heap copy use getRawOldValue instead.
+
-   * If the old value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
-   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
-   * Else return the raw form.
+   * If the old value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). Its
+   * refcount is not inced by this call and the returned object can only be safely used for the
+   * lifetime of the EntryEventImpl instance that returned the value. Else return the raw form.
+
-   * Added this function to expose isCopyOnRead function to the
-   * child classes of EntryEventImpl  
+   * Added this function to expose isCopyOnRead function to the child classes of EntryEventImpl
- 
+
-    
+
-        return callWithOffHeapLock((CachedDeserializable)nv, newValueCD -> {
+        return callWithOffHeapLock((CachedDeserializable) nv, newValueCD -> {
-          assert !(v instanceof CachedDeserializable) : "for key "+this.getKey()+" found nested CachedDeserializable";
+          assert !(v instanceof CachedDeserializable) : "for key " + this.getKey()
+              + " found nested CachedDeserializable";
-      }
-      else {
+      } else {
-  
+
+   * 
-  private <T,R> R callWithOffHeapLock(T value, Function<T, R> function) {
+  private <T, R> R callWithOffHeapLock(T value, Function<T, R> function) {
-          throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+          throw new IllegalStateException(
+              "Attempt to access off heap value after the EntryEvent was released.");
-  
+
+
-  
+
-  public TransactionId getTransactionId()
-  {
+  public TransactionId getTransactionId() {
-  public void setTransactionId(TransactionId txId)
-  {
-    this.txId = (TXId)txId;
+  public void setTransactionId(TransactionId txId) {
+    this.txId = (TXId) txId;
-  public boolean isLoad()
-  {
+  public boolean isLoad() {
-  public void setRegion(LocalRegion r)
-  {
+  public void setRegion(LocalRegion r) {
-  public Operation getOperation()
-  {
+  public Operation getOperation() {
-  public void setOperation(Operation op)
-  {
+  public void setOperation(Operation op) {
-  public Object getCallbackArgument()
-  {
+  public Object getCallbackArgument() {
-      WrappedCallbackArgument wca = (WrappedCallbackArgument)result;
+      WrappedCallbackArgument wca = (WrappedCallbackArgument) result;
+
-   * Returns the value of the EntryEventImpl field.
-   * This is for internal use only. Customers should always call
-   * {@link #getCallbackArgument}
+   * Returns the value of the EntryEventImpl field. This is for internal use only. Customers should
+   * always call {@link #getCallbackArgument}
+   * 
-  
+
-      ((WrappedCallbackArgument)this.keyInfo.getCallbackArg())
+      ((WrappedCallbackArgument) this.keyInfo.getCallbackArg())
-    }
-    else {
+    } else {
-   * @return null if new value is not serialized; otherwise returns a SerializedCacheValueImpl containing the new value.
+   * @return null if new value is not serialized; otherwise returns a SerializedCacheValueImpl
+   *         containing the new value.
-  
+
-     * Only return true if the importer can use the value before the event that exported it is released.
-     * If false is returned then off-heap values will be copied to the heap for the importer.
+     * Only return true if the importer can use the value before the event that exported it is
+     * released. If false is returned then off-heap values will be copied to the heap for the
+     * importer.
+     * 
+     * 
-     * @param isSerialized true if the imported new value represents data that needs to be serialized; false if the imported new value is a simple sequence of bytes.
+     * @param isSerialized true if the imported new value represents data that needs to be
+     *        serialized; false if the imported new value is a simple sequence of bytes.
+     * 
-     * @param isSerialized true if the imported new value represents data that needs to be serialized; false if the imported new value is a simple sequence of bytes.
+     * @param isSerialized true if the imported new value represents data that needs to be
+     *        serialized; false if the imported new value is a simple sequence of bytes.
-  
+
-    @Unretained(ENTRY_EVENT_NEW_VALUE) 
+    @Unretained(ENTRY_EVENT_NEW_VALUE)
-      importer.importNewBytes((byte[])nv, false);
+      importer.importNewBytes((byte[]) nv, false);
+
-     * Only return true if the importer can use the value before the event that exported it is released.
+     * Only return true if the importer can use the value before the event that exported it is
+     * released.
+     * 
-    
+
-     * @return return true if you want the old value to possibly be an instanceof CachedDeserializable; false if you want the value contained in a CachedDeserializable.
+     * @return return true if you want the old value to possibly be an instanceof
+     *         CachedDeserializable; false if you want the value contained in a
+     *         CachedDeserializable.
+     * 
-     * @param isSerialized true if the imported old value represents data that needs to be serialized; false if the imported old value is a simple sequence of bytes.
+     * @param isSerialized true if the imported old value represents data that needs to be
+     *        serialized; false if the imported old value is a simple sequence of bytes.
+     * 
-     * @param isSerialized true if the imported old value represents data that needs to be serialized; false if the imported old value is a simple sequence of bytes.
+     * @param isSerialized true if the imported old value represents data that needs to be
+     *        serialized; false if the imported old value is a simple sequence of bytes.
-  
+
-      importer.importOldBytes((byte[])ov, false);
+      importer.importOldBytes((byte[]) ov, false);
+   * 
-  
+
+   * 
-  
+
-      final Object val = basicGetNewValue();
-      if (val instanceof CachedDeserializable) {
-        return ((CachedDeserializable)val).getDeserializedForReading();
-      }
-      else {
-        return val;
-      }
+    final Object val = basicGetNewValue();
+    if (val instanceof CachedDeserializable) {
+      return ((CachedDeserializable) val).getDeserializedForReading();
+    } else {
+      return val;
+    }
-        val = basicGetNewValue();
-        if (val instanceof byte[]) {
-          return (byte[])val;
-        }
-        else if (val instanceof CachedDeserializable) {
-          return ((CachedDeserializable)val).getSerializedValue();
-        }
+      val = basicGetNewValue();
+      if (val instanceof byte[]) {
+        return (byte[]) val;
+      } else if (val instanceof CachedDeserializable) {
+        return ((CachedDeserializable) val).getSerializedValue();
+      }
-    }
-    else {
+    } else {
+   * 
-    // under synchronization (isSynced is true) 
+    // under synchronization (isSynced is true)
-    if (obj instanceof byte[]
-                            || obj == null
-                            || obj instanceof CachedDeserializable
-                            || obj == Token.NOT_AVAILABLE
-                            || Token.isInvalidOrRemoved(obj)
-                            // don't serialize delta object already serialized
-                            || obj instanceof org.apache.geode.Delta) { // internal delta
+    if (obj instanceof byte[] || obj == null || obj instanceof CachedDeserializable
+        || obj == Token.NOT_AVAILABLE || Token.isInvalidOrRemoved(obj)
+        // don't serialize delta object already serialized
+        || obj instanceof org.apache.geode.Delta) { // internal delta
-    //   for byte[][] anyways)
+    // for byte[][] anyways)
-      for (byte[] bytes : (byte[][])obj) {
+      for (byte[] bytes : (byte[][]) obj) {
-        }
-        else {
+        } else {
-    }
-    else {
+    } else {
+
+
-  public void setSerializedOldValue(byte[] serializedOldValue){
+  public void setSerializedOldValue(byte[] serializedOldValue) {
-    }
-    else {
+    } else {
-   * If true (the default) then preserve old values in events.
-   * If false then mark non-null values as being NOT_AVAILABLE.
+   * If true (the default) then preserve old values in events. If false then mark non-null values as
+   * being NOT_AVAILABLE.
-  private static final boolean EVENT_OLD_VALUE = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disable-event-old-value");
+  private static final boolean EVENT_OLD_VALUE =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disable-event-old-value");
-  
+
-  
+
-   * Put a newValue into the given, write synced, existing, region entry.
-   * Sets oldValue in event if hasn't been set yet.
+   * Put a newValue into the given, write synced, existing, region entry. Sets oldValue in event if
+   * hasn't been set yet.
+   * 
-  void putExistingEntry(final LocalRegion owner, final RegionEntry reentry,
-     boolean requireOldValue, Object oldValueForDelta) throws RegionClearedException {
+  void putExistingEntry(final LocalRegion owner, final RegionEntry reentry, boolean requireOldValue,
+      Object oldValueForDelta) throws RegionClearedException {
-        if (requireOldValue ||
-            EVENT_OLD_VALUE
-            || this.region instanceof HARegion // fix for bug 37909
-            ) {
-          @Retained Object ov;
+        if (requireOldValue || EVENT_OLD_VALUE || this.region instanceof HARegion // fix for bug
+                                                                                  // 37909
+        ) {
+          @Retained
+          Object ov;
-          if (ov == null) ov = Token.NOT_AVAILABLE;
+          if (ov == null)
+            ov = Token.NOT_AVAILABLE;
-      if (this.op.guaranteesOldValue() || 
-          (fp != null /* #41532 */&& fp.entryRequiresOldValue(this.getKey()))) {
+      if (this.op.guaranteesOldValue()
+          || (fp != null /* #41532 */ && fp.entryRequiresOldValue(this.getKey()))) {
-    //setNewValueInRegion(null);
+    // setNewValueInRegion(null);
-  void makeUpdate()
-  {
+  void makeUpdate() {
-  void makeCreate()
-  {
+  void makeCreate() {
+   * 
-    if (!this.op.guaranteesOldValue()) {  // preserves oldValue for CM ops in clients
+    if (!this.op.guaranteesOldValue()) { // preserves oldValue for CM ops in clients
-  private void setNewValueInRegion(final LocalRegion owner,
-      final RegionEntry reentry, Object oldValueForDelta) throws RegionClearedException {
-    
+  private void setNewValueInRegion(final LocalRegion owner, final RegionEntry reentry,
+      Object oldValueForDelta) throws RegionClearedException {
+
-    
+
-    if (owner!=null) {
+    if (owner != null) {
-    
+
-    }
-    else {
+    } else {
-    //dsmith:20090524
-    //This is a horrible hack, but we need to get the size of the object
-    //When we store an entry. This code is only used when we do a put
-    //in the primary.
-    if(v instanceof org.apache.geode.Delta && region.isUsedForPartitionedRegionBucket()) {
+    // dsmith:20090524
+    // This is a horrible hack, but we need to get the size of the object
+    // When we store an entry. This code is only used when we do a put
+    // in the primary.
+    if (v instanceof org.apache.geode.Delta && region.isUsedForPartitionedRegionBucket()) {
-      if(ov instanceof CachedDeserializable && !GemFireCacheImpl.DELTAS_RECALCULATE_SIZE) {
+      if (ov instanceof CachedDeserializable && !GemFireCacheImpl.DELTAS_RECALCULATE_SIZE) {
-    setNewValueBucketSize(owner, v);
-    
-    // ezoerner:20081030 
-    // last possible moment to do index maintenance with old value in
-    // RegionEntry before new value is set.
-    // As part of an update, this is a remove operation as prelude to an add that
-    // will come after the new value is set.
-    // If this is an "update" from INVALID state, treat this as a create instead
-    // for the purpose of index maintenance since invalid entries are not
-    // indexed.
-    
-    if ((this.op.isUpdate() && !reentry.isInvalid()) || this.op.isInvalidate()) {
-      IndexManager idxManager = IndexUtils.getIndexManager(this.region, false);
-      if (idxManager != null) {
-        try {
-          idxManager.updateIndexes(reentry,
-                                   IndexManager.REMOVE_ENTRY,
-                                   this.op.isUpdate() ?
-                                     IndexProtocol.BEFORE_UPDATE_OP :
-                                     IndexProtocol.OTHER_OP);
-        }
-        catch (QueryException e) {
-          throw new IndexMaintenanceException(e);
+      setNewValueBucketSize(owner, v);
+
+      // ezoerner:20081030
+      // last possible moment to do index maintenance with old value in
+      // RegionEntry before new value is set.
+      // As part of an update, this is a remove operation as prelude to an add that
+      // will come after the new value is set.
+      // If this is an "update" from INVALID state, treat this as a create instead
+      // for the purpose of index maintenance since invalid entries are not
+      // indexed.
+
+      if ((this.op.isUpdate() && !reentry.isInvalid()) || this.op.isInvalidate()) {
+        IndexManager idxManager = IndexUtils.getIndexManager(this.region, false);
+        if (idxManager != null) {
+          try {
+            idxManager.updateIndexes(reentry, IndexManager.REMOVE_ENTRY,
+                this.op.isUpdate() ? IndexProtocol.BEFORE_UPDATE_OP : IndexProtocol.OTHER_OP);
+          } catch (QueryException e) {
+            throw new IndexMaintenanceException(e);
+          }
-    }
-    calledSetValue = true;
-    reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
-    success = true;
+      calledSetValue = true;
+      reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
+      success = true;
-        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (StoredObject)v);
-      }      
+        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry) reentry, (StoredObject) v);
+      }
-            this.getKey(), ((CachedDeserializable)v).getStringForm());
-      }
-      else {
-        logger.trace("EntryEventImpl.setNewValueInRegion: put({},{})",
-            this.getKey(), StringUtils.forceToString(v));
+            this.getKey(), ((CachedDeserializable) v).getStringForm());
+      } else {
+        logger.trace("EntryEventImpl.setNewValueInRegion: put({},{})", this.getKey(),
+            StringUtils.forceToString(v));
-    if (!isTombstone  &&  wasTombstone) {
+    if (!isTombstone && wasTombstone) {
-   * The size the new value contributes to a pr bucket.
-   * Note if this event is not on a pr then this value will be 0.
+   * The size the new value contributes to a pr bucket. Note if this event is not on a pr then this
+   * value will be 0.
+
+
-        throw new InvalidDeltaException("Old value not found for key "
-            + this.keyInfo.getKey());
+        throw new InvalidDeltaException("Old value not found for key " + this.keyInfo.getKey());
-      boolean copy = this.region.getCompressor() == null &&
-          (this.region.isCopyOnRead()
-          || this.region.getCloningEnabled()
-          || (fp != null && fp.getCqCount() > 0));
+      boolean copy = this.region.getCompressor() == null && (this.region.isCopyOnRead()
+          || this.region.getCloningEnabled() || (fp != null && fp.getCqCount() > 0));
-          value = ((CachedDeserializable)value).getDeserializedWritableCopy(this.region, re);
+          value = ((CachedDeserializable) value).getDeserializedWritableCopy(this.region, re);
-          value = ((CachedDeserializable)value).getDeserializedValue(
-              this.region, re);
+          value = ((CachedDeserializable) value).getDeserializedValue(this.region, re);
-        ((org.apache.geode.Delta)value).fromDelta(new DataInputStream(
-            new ByteArrayInputStream(getDeltaBytes())));
+        ((org.apache.geode.Delta) value)
+            .fromDelta(new DataInputStream(new ByteArrayInputStream(getDeltaBytes())));
-        throw new DeltaSerializationException(
-            "Exception while deserializing delta bytes.", t);
+        throw new DeltaSerializationException("Exception while deserializing delta bytes.", t);
-        CachedDeserializable old = (CachedDeserializable)oldValueInVM;
+        CachedDeserializable old = (CachedDeserializable) oldValueInVM;
-          valueSize = CachedDeserializableFactory.calcMemSize(value, region
-              .getObjectSizer(), false);
+          valueSize =
+              CachedDeserializableFactory.calcMemSize(value, region.getObjectSizer(), false);
-      if (this.causedByMessage != null
-          && this.causedByMessage instanceof PutMessage) {
-        ((PutMessage)this.causedByMessage).setDeltaValObj(value);
+      if (this.causedByMessage != null && this.causedByMessage instanceof PutMessage) {
+        ((PutMessage) this.causedByMessage).setDeltaValObj(value);
-    }
-    else {
+    } else {
-      }
-      else {
+      } else {
-    if (this.op != Operation.LOCAL_INVALIDATE
-        && this.op != Operation.LOCAL_DESTROY) {
+    if (this.op != Operation.LOCAL_INVALIDATE && this.op != Operation.LOCAL_DESTROY) {
-  public boolean setOldValueFromRegion()
-  {
+  public boolean setOldValueFromRegion() {
-      if (re == null) return false;
+      if (re == null)
+        return false;
-    }
-    catch (EntryNotFoundException ex) {
+    } catch (EntryNotFoundException ex) {
-  boolean oldValueIsDestroyedToken()
-  {
+  boolean oldValueIsDestroyedToken() {
-  void setOldValueDestroyedToken()
-  {
+  void setOldValueDestroyedToken() {
-  
-  
+
+
-   * @param force true if the old value should be forcibly set, used
-   * for HARegions, methods like putIfAbsent, etc.,
-   * where the old value must be available.
+   * @param force true if the old value should be forcibly set, used for HARegions, methods like
+   *        putIfAbsent, etc., where the old value must be available.
-    }
-    else {
+    } else {
-      }
-      else {
-        if (force ||
-            (this.region instanceof HARegion) // fix for bug 37909
-            ) {
+      } else {
+        if (force || (this.region instanceof HARegion) // fix for bug 37909
+        ) {
-   * sets the old value for concurrent map operation results received
-   * from a server.
+   * sets the old value for concurrent map operation results received from a server.
-      }   
+      }
-    return  tmp != null && tmp != Token.NOT_AVAILABLE;
+    return tmp != null && tmp != Token.NOT_AVAILABLE;
+
-  
+
-  public static Object deserialize(byte[] bytes, Version version,
-      ByteArrayDataInput in) {
+  public static Object deserialize(byte[] bytes, Version version, ByteArrayDataInput in) {
-    }
-    catch (IOException e) {
-      throw new SerializationException(LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_DESERIALIZING.toLocalizedString(), e);
-    }
-    catch (ClassNotFoundException e) {
+    } catch (IOException e) {
+      throw new SerializationException(
+          LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_DESERIALIZING
+              .toLocalizedString(),
+          e);
+    } catch (ClassNotFoundException e) {
-      throw new SerializationException(LocalizedStrings.EntryEventImpl_A_CLASSNOTFOUNDEXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE_CACHED_VALUE.toLocalizedString(), e);
+      throw new SerializationException(
+          LocalizedStrings.EntryEventImpl_A_CLASSNOTFOUNDEXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE_CACHED_VALUE
+              .toLocalizedString(),
+          e);
-   * If a PdxInstance is returned then it will have an unretained reference
-   * to the StoredObject's off-heap address.
+   * If a PdxInstance is returned then it will have an unretained reference to the StoredObject's
+   * off-heap address.
-    }
-    catch (IOException e) {
-      throw new SerializationException(LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_DESERIALIZING.toLocalizedString(), e);
-    }
-    catch (ClassNotFoundException e) {
+    } catch (IOException e) {
+      throw new SerializationException(
+          LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_DESERIALIZING
+              .toLocalizedString(),
+          e);
+    } catch (ClassNotFoundException e) {
-      throw new SerializationException(LocalizedStrings.EntryEventImpl_A_CLASSNOTFOUNDEXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE_CACHED_VALUE.toLocalizedString(), e);
+      throw new SerializationException(
+          LocalizedStrings.EntryEventImpl_A_CLASSNOTFOUNDEXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE_CACHED_VALUE
+              .toLocalizedString(),
+          e);
-   * @throws IllegalArgumentException
-   *           If <code>obj</code> should not be serialized
+   * @throws IllegalArgumentException If <code>obj</code> should not be serialized
-   /**
-     * Serialize an object into a <code>byte[]</code>
-     *
-     * @throws IllegalArgumentException
-     *           If <code>obj</code> should not be serialized
-     */
-  public static byte[] serialize(Object obj, Version version)
-  {
-    if (obj == null || obj == Token.NOT_AVAILABLE
-        || Token.isInvalidOrRemoved(obj))
-      throw new IllegalArgumentException(LocalizedStrings.EntryEventImpl_MUST_NOT_SERIALIZE_0_IN_THIS_CONTEXT.toLocalizedString(obj));
+  /**
+   * Serialize an object into a <code>byte[]</code>
+   *
+   * @throws IllegalArgumentException If <code>obj</code> should not be serialized
+   */
+  public static byte[] serialize(Object obj, Version version) {
+    if (obj == null || obj == Token.NOT_AVAILABLE || Token.isInvalidOrRemoved(obj))
+      throw new IllegalArgumentException(
+          LocalizedStrings.EntryEventImpl_MUST_NOT_SERIALIZE_0_IN_THIS_CONTEXT
+              .toLocalizedString(obj));
-    }
-    catch (IOException e) {
-      throw new SerializationException(LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING.toLocalizedString(), e);
+    } catch (IOException e) {
+      throw new SerializationException(
+          LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
+              .toLocalizedString(),
+          e);
-  
-  
+
+
-   * Serialize an object into a <code>byte[]</code> . If the byte array
-   * provided by the wrapper is sufficient to hold the data, it is used
-   * otherwise a new byte array gets created & its reference is stored in the
-   * wrapper. The User Bit is also appropriately set as Serialized
+   * Serialize an object into a <code>byte[]</code> . If the byte array provided by the wrapper is
+   * sufficient to hold the data, it is used otherwise a new byte array gets created & its reference
+   * is stored in the wrapper. The User Bit is also appropriately set as Serialized
-   * @param wrapper
-   *                Object of type BytesAndBitsForCompactor which is used to fetch
-   *                the serialized data. The byte array of the wrapper is used
-   *                if possible else a the new byte array containing the data is
-   *                set in the wrapper.
-   * @throws IllegalArgumentException
-   *                 If <code>obj</code> should not be serialized
+   * @param wrapper Object of type BytesAndBitsForCompactor which is used to fetch the serialized
+   *        data. The byte array of the wrapper is used if possible else a the new byte array
+   *        containing the data is set in the wrapper.
+   * @throws IllegalArgumentException If <code>obj</code> should not be serialized
-  public static void fillSerializedValue(BytesAndBitsForCompactor wrapper,
-                                         Object obj, byte userBits) {
-    if (obj == null || obj == Token.NOT_AVAILABLE
-        || Token.isInvalidOrRemoved(obj))
+  public static void fillSerializedValue(BytesAndBitsForCompactor wrapper, Object obj,
+      byte userBits) {
+    if (obj == null || obj == Token.NOT_AVAILABLE || Token.isInvalidOrRemoved(obj))
-        LocalizedStrings.EntryEvents_MUST_NOT_SERIALIZE_0_IN_THIS_CONTEXT.toLocalizedString(obj));
+          LocalizedStrings.EntryEvents_MUST_NOT_SERIALIZE_0_IN_THIS_CONTEXT.toLocalizedString(obj));
-      }
-      else {
+      } else {
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-        LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING.toLocalizedString());
+          LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
+              .toLocalizedString());
-    return cname.substring(getClass().getPackage().getName().length()+1);
+    return cname.substring(getClass().getPackage().getName().length() + 1);
-//    if (this.partitionMessage != null) {
-//      buf.append("; partitionMessage=");
-//      buf.append(this.partitionMessage);
-//    }
+    // if (this.partitionMessage != null) {
+    // buf.append("; partitionMessage=");
+    // buf.append(this.partitionMessage);
+    // }
-    if (callbacksInvoked()) { 
+    if (callbacksInvoked()) {
-//    else {
-//      buf.append(";[no deltaBytes]");
-//    }
+    // else {
+    // buf.append(";[no deltaBytes]");
+    // }
-  public void toData(DataOutput out) throws IOException
-  {
-    DataSerializer.writeObject(this.eventID, out);    
+  public void toData(DataOutput out) throws IOException {
+    DataSerializer.writeObject(this.eventID, out);
-            CachedDeserializable cd = (CachedDeserializable)nv;
+            CachedDeserializable cd = (CachedDeserializable) nv;
-        }
-        else {
+        } else {
-      }  
+      }
-        }
-        else {
-          CachedDeserializable cd = (CachedDeserializable)ov;
+        } else {
+          CachedDeserializable cd = (CachedDeserializable) ov;
-      }
-      else {
+      } else {
-    InternalDataSerializer.invokeToData((InternalDistributedMember)this.distributedMember, out);
+    InternalDataSerializer.invokeToData((InternalDistributedMember) this.distributedMember, out);
-  private static abstract class EventFlags
-   {
+  private static abstract class EventFlags {
-    private static final short FLAG_INHIBIT_ALL_NOTIFICATIONS= 0x4000;
-    
+    private static final short FLAG_INHIBIT_ALL_NOTIFICATIONS = 0x4000;
+
-    private static final short FLAG_TRANSIENT_MASK =
-      ~(FLAG_CALLBACKS_INVOKED
-          | FLAG_ISCREATE
-          | FLAG_INHIBIT_LISTENER_NOTIFICATION
-          | FLAG_SERIALIZATION_DEFERRED
-          | FLAG_FROM_SERVER
-          | FLAG_FROM_RI_LOCAL_DESTROY
-          | FLAG_INHIBIT_DISTRIBUTION
-          | FLAG_REDESTROYED_TOMBSTONE
-          );
-    
-    protected static final boolean isSet(short flags, short mask)
-    {
+    private static final short FLAG_TRANSIENT_MASK = ~(FLAG_CALLBACKS_INVOKED | FLAG_ISCREATE
+        | FLAG_INHIBIT_LISTENER_NOTIFICATION | FLAG_SERIALIZATION_DEFERRED | FLAG_FROM_SERVER
+        | FLAG_FROM_RI_LOCAL_DESTROY | FLAG_INHIBIT_DISTRIBUTION | FLAG_REDESTROYED_TOMBSTONE);
+
+    protected static final boolean isSet(short flags, short mask) {
-    protected static final short set(short flags, short mask, boolean on)
-    {
-      return (short)(on ? (flags | mask) : (flags & ~mask));
+    protected static final short set(short flags, short mask, boolean on) {
+      return (short) (on ? (flags | mask) : (flags & ~mask));
-   * @return null if old value is not serialized; otherwise returns a SerializedCacheValueImpl containing the old value.
+   * @return null if old value is not serialized; otherwise returns a SerializedCacheValueImpl
+   *         containing the old value.
-    }
-    else {
+    } else {
-  
+
-   * Compute an estimate of the size of the new value
-   * for a PR. Since PR's always store values in a cached deserializable
-   * we need to compute its size as a blob.
+   * Compute an estimate of the size of the new value for a PR. Since PR's always store values in a
+   * cached deserializable we need to compute its size as a blob.
-  public int getNewValSizeForPR()
-  {
+  public int getNewValSizeForPR() {
-          + CachedDeserializableFactory.overhead();
+            + CachedDeserializableFactory.overhead();
-        logger.warn(LocalizedMessage.create(LocalizedStrings.EntryEventImpl_DATASTORE_FAILED_TO_CALCULATE_SIZE_OF_NEW_VALUE), iae);
+        logger.warn(
+            LocalizedMessage.create(
+                LocalizedStrings.EntryEventImpl_DATASTORE_FAILED_TO_CALCULATE_SIZE_OF_NEW_VALUE),
+            iae);
-  public int getOldValSize()
-  {
+  public int getOldValSize() {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.EntryEventImpl_DATASTORE_FAILED_TO_CALCULATE_SIZE_OF_OLD_VALUE), iae);
+        logger.warn(
+            LocalizedMessage.create(
+                LocalizedStrings.EntryEventImpl_DATASTORE_FAILED_TO_CALCULATE_SIZE_OF_OLD_VALUE),
+            iae);
+   * 
-  
+
-  
+
-  
+
-   * set this to true to inhibit application cache listener notification
-   * during event dispatching
+   * set this to true to inhibit application cache listener notification during event dispatching
-  
+
-   * are events being inhibited from dispatch to application cache listeners
-   * for this event?
+   * are events being inhibited from dispatch to application cache listeners for this event?
-  
-  
+
+
+   * 
-  void invokeCallbacks(LocalRegion rgn,boolean skipListeners, boolean notifyGateways) {
+  void invokeCallbacks(LocalRegion rgn, boolean skipListeners, boolean notifyGateways) {
-        rgn.invokePutCallbacks(EnumListenerEvent.AFTER_UPDATE, this,
-            !skipListeners, notifyGateways); // gateways are notified in part2 processing
-      }
-      else if (this.op.isCreate()) {
-        rgn.invokePutCallbacks(EnumListenerEvent.AFTER_CREATE, this,
-            !skipListeners, notifyGateways);
-      }
-      else if (this.op.isDestroy()) {
-        rgn.invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY,
-            this, !skipListeners, notifyGateways);
-      }
-      else if (this.op.isInvalidate()) {
-        rgn.invokeInvalidateCallbacks(EnumListenerEvent.AFTER_INVALIDATE,
-            this, !skipListeners);
+        rgn.invokePutCallbacks(EnumListenerEvent.AFTER_UPDATE, this, !skipListeners,
+            notifyGateways); // gateways are notified in part2 processing
+      } else if (this.op.isCreate()) {
+        rgn.invokePutCallbacks(EnumListenerEvent.AFTER_CREATE, this, !skipListeners,
+            notifyGateways);
+      } else if (this.op.isDestroy()) {
+        rgn.invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, this, !skipListeners,
+            notifyGateways);
+      } else if (this.op.isInvalidate()) {
+        rgn.invokeInvalidateCallbacks(EnumListenerEvent.AFTER_INVALIDATE, this, !skipListeners);
-  
+
-  
-  public boolean isFromRILocalDestroy(){
+
+  public boolean isFromRILocalDestroy() {
-   * Used to store next region version generated for a change on this entry
-   * by phase-1 commit on the primary.  
+   * Used to store next region version generated for a change on this entry by phase-1 commit on the
+   * primary.
-  
+
-  
+
-  
+
+   * 
+
-   * Sets the fromServer flag to v.  This must be set to true if an event
-   * comes from a server while the affected region entry is not locked.  Among
-   * other things it causes version conflict checks to be performed to protect
-   * against overwriting a newer version of the entry.
+   * Sets the fromServer flag to v. This must be set to true if an event comes from a server while
+   * the affected region entry is not locked. Among other things it causes version conflict checks
+   * to be performed to protect against overwriting a newer version of the entry.
+   * 
-   * If true, the region associated with this event had already
-   * applied the operation it encapsulates when an attempt was
-   * made to apply the event.
+   * If true, the region associated with this event had already applied the operation it
+   * encapsulates when an attempt was made to apply the event.
+   * 
-   * If the operation encapsulated by this event has already been
-   * seen by the region to which it pertains, this flag should be
-   * set to true. 
+   * If the operation encapsulated by this event has already been seen by the region to which it
+   * pertains, this flag should be set to true.
+   * 
-   * are events being inhibited from dispatch to to gateway/async queues, 
-   * client queues, cache listener and cache write. If set, sending
-   * notifications for the data that is read from a persistent store (HDFS) and 
-   * is being reinserted in the cache is skipped.
+   * are events being inhibited from dispatch to to gateway/async queues, client queues, cache
+   * listener and cache write. If set, sending notifications for the data that is read from a
+   * persistent store (HDFS) and is being reinserted in the cache is skipped.
-    
+
-  
+
-   * set this to true to inhibit notifications that are sent to gateway/async queues, 
-   * client queues, cache listener and cache write. This is used to skip sending
-   * notifications for the data that is read from a persistent store (HDFS) and 
-   * is being reinserted in the cache 
+   * set this to true to inhibit notifications that are sent to gateway/async queues, client queues,
+   * cache listener and cache write. This is used to skip sending notifications for the data that is
+   * read from a persistent store (HDFS) and is being reinserted in the cache
-  
+
-  
+
-  
+
-   * This method returns the delta bytes used in Delta Propagation feature.
-   * <B>For internal delta, see getRawNewValue().</B>
+   * This method returns the delta bytes used in Delta Propagation feature. <B>For internal delta,
+   * see getRawNewValue().</B>
-   * This method sets the delta bytes used in Delta Propagation feature. <B>For
-   * internal delta, see setNewValue().</B>
+   * This method sets the delta bytes used in Delta Propagation feature. <B>For internal delta, see
+   * setNewValue().</B>
-   * this is used to distinguish an event that merely has Operation.CREATE
-   * from one that originated from Region.create() for delta processing
-   * purposes.
+   * this is used to distinguish an event that merely has Operation.CREATE from one that originated
+   * from Region.create() for delta processing purposes.
-   * establish the old value in this event as the current cache value,
-   * whether in memory or on disk
+   * establish the old value in this event as the current cache value, whether in memory or on disk
-      @Retained Object v = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
-      if ( !(v instanceof Token) ) {
+      @Retained
+      Object v = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+      if (!(v instanceof Token)) {
-  
+
-  
+
-  
+
-   * this method joins together version tag timestamps and the "lastModified"
-   * timestamps generated and stored in entries.  If a change does not already
-   * carry a lastModified timestamp 
+   * this method joins together version tag timestamps and the "lastModified" timestamps generated
+   * and stored in entries. If a change does not already carry a lastModified timestamp
+   * 
-    implements SerializedCacheValue, CachedDeserializable, Sendable
-  {
+      implements SerializedCacheValue, CachedDeserializable, Sendable {
-    @Unretained private final CachedDeserializable cd;
+    @Unretained
+    private final CachedDeserializable cd;
-    
-    SerializedCacheValueImpl(EntryEventImpl event, Region r, RegionEntry re, @Unretained CachedDeserializable cd, byte[] serializedBytes) {
+
+    SerializedCacheValueImpl(EntryEventImpl event, Region r, RegionEntry re,
+        @Unretained CachedDeserializable cd, byte[] serializedBytes) {
-      if(this.serializedValue != null){
+      if (this.serializedValue != null) {
-    
+
-        throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+        throw new IllegalStateException(
+            "Attempt to access off heap value after the EntryEvent was released.");
+
-     * The only methods that need to use this method are those on the external SerializedCacheValue interface
-     * and any other method that a customer could call that may access the off-heap values.
-     * For example if toString was implemented on this class to access the value then it would
-     * need to use this method.
+     * The only methods that need to use this method are those on the external SerializedCacheValue
+     * interface and any other method that a customer could call that may access the off-heap
+     * values. For example if toString was implemented on this class to access the value then it
+     * would need to use this method.
-    
+
+
+
+
-      if(this.serializedValue != null){
+      if (this.serializedValue != null) {
+
+
-        wrapper.setData(this.serializedValue, userBits, this.serializedValue.length, 
-                        false /* Not Reusable as it refers to underlying value */);
+        wrapper.setData(this.serializedValue, userBits, this.serializedValue.length,
+            false /* Not Reusable as it refers to underlying value */);
+
+
-//////////////////////////////////////////////////////////////////////////////////////////
-  
+  //////////////////////////////////////////////////////////////////////////////////////////
+
-  
+
-   * Mark this event as having its callbacks invoked by the current thread.
-   * Note this is done just before the actual invocation of the callbacks.
+   * Mark this event as having its callbacks invoked by the current thread. Note this is done just
+   * before the actual invocation of the callbacks.
-  
+
-   * Return true if this event was marked as having its callbacks invoked
-   * by the current thread.
+   * Return true if this event was marked as having its callbacks invoked by the current thread.
-    if (this.invokeCallbacksThread == null) return false;
+    if (this.invokeCallbacksThread == null)
+      return false;
-  
+
+   * 
-  
+
-   * returns true if it is okay to process this event even though it has
-   * a null version
+   * returns true if it is okay to process this event even though it has a null version
-    return versionTag == null
-      && region.concurrencyChecksEnabled
-      && region.getServerProxy() != null
-      && !op.isLocal()
-      && !isOriginRemote()
-      ;
+    return versionTag == null && region.concurrencyChecksEnabled && region.getServerProxy() != null
+        && !op.isLocal() && !isOriginRemote();
-  
+
-  public TimestampedEntryEvent getTimestampedEvent(
-      final int newDSID, final int oldDSID,
+  public TimestampedEntryEvent getTimestampedEvent(final int newDSID, final int oldDSID,
-  
+
-   * True if it is ok to use old/new values that are stored off heap.
-   * False if an exception should be thrown if an attempt is made to access old/new offheap values.
+   * True if it is ok to use old/new values that are stored off heap. False if an exception should
+   * be thrown if an attempt is made to access old/new offheap values.
- 
+
-    if (!this.offHeapOk) return;
+    if (!this.offHeapOk)
+      return;
-        //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
+        // this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " +
+        // System.identityHashCode(ov));
-  
+
-   * Make sure that this event will never own an off-heap value.
-   * Once this is called on an event it does not need to have release called.
+   * Make sure that this event will never own an off-heap value. Once this is called on an event it
+   * does not need to have release called.
-  
+
-   * This copies the off-heap new and/or old value to the heap.
-   * As a result the current off-heap new/old will be released.
+   * This copies the off-heap new and/or old value to the heap. As a result the current off-heap
+   * new/old will be released.
-      if (StoredObject.isOffHeapReference(this.newValue) || StoredObject.isOffHeapReference(this.oldValue)) {
-        throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
+      if (StoredObject.isOffHeapReference(this.newValue)
+          || StoredObject.isOffHeapReference(this.oldValue)) {
+        throw new IllegalStateException(
+            "event's old/new value still off-heap after calling copyOffHeapToHeap");
-}
+}

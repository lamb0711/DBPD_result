Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The base PartitionedRegion message type upon which other messages should be
- * based.
+ * The base PartitionedRegion message type upon which other messages should be based.
-public abstract class RemoteOperationMessage extends DistributionMessage implements 
-    MessageWithReply, TransactionMessage
-{
+public abstract class RemoteOperationMessage extends DistributionMessage
+    implements MessageWithReply, TransactionMessage {
-  
+
-  static final ForceReattemptException UNHANDLED_EXCEPTION
-     = (ForceReattemptException)new ForceReattemptException(LocalizedStrings.PartitionMessage_UNKNOWN_EXCEPTION.toLocalizedString()).fillInStackTrace();
+  static final ForceReattemptException UNHANDLED_EXCEPTION =
+      (ForceReattemptException) new ForceReattemptException(
+          LocalizedStrings.PartitionMessage_UNKNOWN_EXCEPTION.toLocalizedString())
+              .fillInStackTrace();
-  
+
-  
-  /** The unique transaction Id on the sending member, used to construct a TXId on the receiving side */
+
+  /**
+   * The unique transaction Id on the sending member, used to construct a TXId on the receiving side
+   */
-  
-  /*TODO [DISTTX] Convert into flag*/
+
+  /* TODO [DISTTX] Convert into flag */
-  public RemoteOperationMessage() {
-  }
+  public RemoteOperationMessage() {}
- 
+
-    this.processorId = processor==null? 0 : processor.getProcessorId();
+    this.processorId = processor == null ? 0 : processor.getProcessorId();
-    if(txState!=null && txState.isMemberIdForwardingRequired()) {
+    if (txState != null && txState.isMemberIdForwardingRequired()) {
-    this.processorId = processor==null? 0 : processor.getProcessorId();
+    this.processorId = processor == null ? 0 : processor.getProcessorId();
-    if(txState!=null && txState.isMemberIdForwardingRequired()) {
+    if (txState != null && txState.isMemberIdForwardingRequired()) {
+   * 
-   * Severe alert processing enables suspect processing at the ack-wait-threshold
-   * and issuing of a severe alert at the end of the ack-severe-alert-threshold.
-   * Some messages should not support this type of processing
-   * (e.g., GII, or DLockRequests)
-   * @return whether severe-alert processing may be performed on behalf
-   * of this message
+   * Severe alert processing enables suspect processing at the ack-wait-threshold and issuing of a
+   * severe alert at the end of the ack-severe-alert-threshold. Some messages should not support
+   * this type of processing (e.g., GII, or DLockRequests)
+   * 
+   * @return whether severe-alert processing may be performed on behalf of this message
-  
+
-      return DistributionManager.PARTITIONED_REGION_EXECUTOR;
+    return DistributionManager.PARTITIONED_REGION_EXECUTOR;
-  public final String getRegionPath()
-  {
+  public final String getRegionPath() {
-   * @return the {@link ReplyProcessor21}id associated with the message, null
-   *         if no acknowlegement is required.
+   * @return the {@link ReplyProcessor21}id associated with the message, null if no acknowlegement
+   *         is required.
-  public final int getProcessorId()
-  {
+  public final int getProcessorId() {
-   * @param processorId1 the {@link 
-   * org.apache.geode.distributed.internal.ReplyProcessor21} id associated 
-   * with the message, null if no acknowlegement is required.
+   * @param processorId1 the {@link org.apache.geode.distributed.internal.ReplyProcessor21} id
+   *        associated with the message, null if no acknowlegement is required.
-  public final void registerProcessor(int processorId1)
-  {
+  public final void registerProcessor(int processorId1) {
-  
+
+   * 
-   * Upon receipt of the message, both process the message and send an
-   * acknowledgement, not necessarily in that order. Note: Any hang in this
-   * message may cause a distributed deadlock for those threads waiting for an
-   * acknowledgement.
+   * Upon receipt of the message, both process the message and send an acknowledgement, not
+   * necessarily in that order. Note: Any hang in this message may cause a distributed deadlock for
+   * those threads waiting for an acknowledgement.
-   * @throws PartitionedRegionException if the region does not exist (typically, if it has been destroyed)
+   * @throws PartitionedRegionException if the region does not exist (typically, if it has been
+   *         destroyed)
-  public void process(final DistributionManager dm) 
-  {
+  public void process(final DistributionManager dm) {
-    long startTime = 0;    
+    long startTime = 0;
-        thr = new CacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0.toLocalizedString(dm.getId()));
+        thr = new CacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0
+            .toLocalizedString(dm.getId()));
-        thr = new RegionDestroyedException(LocalizedStrings.RemoteOperationMessage_0_COULD_NOT_FIND_REGION_1
-                .toLocalizedString(new Object[] {dm.getDistributionManagerId(), regionPath }), regionPath);
-        return;  // reply sent in finally block below
+        thr = new RegionDestroyedException(
+            LocalizedStrings.RemoteOperationMessage_0_COULD_NOT_FIND_REGION_1.toLocalizedString(
+                new Object[] {dm.getDistributionManagerId(), regionPath}),
+            regionPath);
+        return; // reply sent in finally block below
-      
+
-        sendReply = operateOnRegion(dm, r, startTime);        
+        sendReply = operateOnRegion(dm, r, startTime);
-          }  
+          }
-          
+
-    }
-    catch (DistributedSystemDisconnectedException se) {
+    } catch (DistributedSystemDisconnectedException se) {
-//      throw new CacheClosedException("remote system shutting down");
-//      thr = se; cache is closed, no point trying to send a reply
+      // throw new CacheClosedException("remote system shutting down");
+      // thr = se; cache is closed, no point trying to send a reply
-    }
-    catch (RegionDestroyedException rde) {
+    } catch (RegionDestroyedException rde) {
-      //         destroyed, so we must send back an exception.  If the sender's
-      //         region is also destroyed, who cares if we send it an exception
-      //if (pr != null && pr.isClosed) {
-        thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_REGION_IS_DESTROYED_IN_0.toLocalizedString(dm.getDistributionManagerId()), rde);
-      //}
-    }
-    catch (VirtualMachineError err) {
+      // destroyed, so we must send back an exception. If the sender's
+      // region is also destroyed, who cares if we send it an exception
+      // if (pr != null && pr.isClosed) {
+      thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_REGION_IS_DESTROYED_IN_0
+          .toLocalizedString(dm.getDistributionManagerId()), rde);
+      // }
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-        }
-        else {
+        } else {
-          thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_DISTRIBUTED_SYSTEM_IS_DISCONNECTING.toLocalizedString());
+          thr = new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_DISTRIBUTED_SYSTEM_IS_DISCONNECTING
+                  .toLocalizedString());
-    }
-    finally {
+    } finally {
-        
+
-            rex = new ReplyException(thr);
+          rex = new ReplyException(thr);
-      } 
+      }
-    return (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
+    return (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
-  
-  /** Send a generic ReplyMessage.  This is in a method so that subclasses can override the reply message type
+
+  /**
+   * Send a generic ReplyMessage. This is in a method so that subclasses can override the reply
+   * message type
+   * 
-   *  @see PutMessage#sendReply
+   * @see PutMessage#sendReply
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, LocalRegion pr, long startTime) {
-//    if (pr != null && startTime > 0) {
-      //pr.getPrStats().endRemoteOperationMessagesProcessing(startTime); 
-//    }
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      LocalRegion pr, long startTime) {
+    // if (pr != null && startTime > 0) {
+    // pr.getPrStats().endRemoteOperationMessagesProcessing(startTime);
+    // }
-  
+
-   * Allow classes that over-ride to choose whether 
-   * a RegionDestroyException is thrown if no partitioned region is found (typically occurs if the message will be sent 
-   * before the PartitionedRegion has been fully constructed.
+   * Allow classes that over-ride to choose whether a RegionDestroyException is thrown if no
+   * partitioned region is found (typically occurs if the message will be sent before the
+   * PartitionedRegion has been fully constructed.
+   * 
-  
+
-   * return a new reply processor for this class, for use in relaying a response.
-   * This <b>must</b> be an instance method so subclasses can override it
-   * properly.
+   * return a new reply processor for this class, for use in relaying a response. This <b>must</b>
+   * be an instance method so subclasses can override it properly.
-  
-  protected abstract boolean operateOnRegion(DistributionManager dm,
-      LocalRegion r,long startTime) throws RemoteOperationException;
+
+  protected abstract boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws RemoteOperationException;
-   * Fill out this instance of the message using the <code>DataInput</code>
-   * Required to be a {@link org.apache.geode.DataSerializable}Note: must
-   * be symmetric with {@link #toData(DataOutput)}in what it reads
+   * Fill out this instance of the message using the <code>DataInput</code> Required to be a
+   * {@link org.apache.geode.DataSerializable}Note: must be symmetric with
+   * {@link #toData(DataOutput)}in what it reads
-  
+
-      DataSerializer.writeObject(this.getTXMemberId(),out);
+      DataSerializer.writeObject(this.getTXMemberId(), out);
-    DataSerializer.writeString(this.regionPath,out);
+    DataSerializer.writeString(this.regionPath, out);
-    if (this.processorId != 0) flags |= HAS_PROCESSOR_ID;
-    if (this.processorType != 0) flags |= HAS_PROCESSOR_TYPE;
-    if (this.getTXUniqId() != TXManagerImpl.NOTX) flags |= HAS_TX_ID;
-    if (this.getTXMemberId() != null) flags |= HAS_TX_MEMBERID;
+    if (this.processorId != 0)
+      flags |= HAS_PROCESSOR_ID;
+    if (this.processorType != 0)
+      flags |= HAS_PROCESSOR_TYPE;
+    if (this.getTXUniqId() != TXManagerImpl.NOTX)
+      flags |= HAS_TX_ID;
+    if (this.getTXMemberId() != null)
+      flags |= HAS_TX_MEMBERID;
-  protected void setFlags(short flags, DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void setFlags(short flags, DataInput in) throws IOException, ClassNotFoundException {
-  private final static String PN_TOKEN = ".cache."; 
+  private final static String PN_TOKEN = ".cache.";
+
-  public String toString()
-  {
+  public String toString() {
-//    className.substring(className.lastIndexOf('.', className.lastIndexOf('.') - 1) + 1);  // partition.<foo> more generic version 
+    // className.substring(className.lastIndexOf('.', className.lastIndexOf('.') - 1) + 1); //
+    // partition.<foo> more generic version
-   * @param buff
-   *          buffer in which to append the state of this instance
+   * @param buff buffer in which to append the state of this instance
-  protected void appendFields(StringBuffer buff)
-  {
-    buff.append("; sender=").append(getSender())
-      .append("; recipients=[");
+  protected void appendFields(StringBuffer buff) {
+    buff.append("; sender=").append(getSender()).append("; recipients=[");
-    for(int i=0; i<recips.length-1; i++) {
+    for (int i = 0; i < recips.length - 1; i++) {
-      buff.append(recips[recips.length-1]);
+      buff.append(recips[recips.length - 1]);
-  
+
-  
+
+   * 
-  
+
-  
+
-    if(txMemberId==null) {
+    if (txMemberId == null) {
-  
+
-  
+
-  
+
-   * A processor on which to await a response from the {@link RemoteOperationMessage}
-   * recipient, capturing any CacheException thrown by the recipient and handle
-   * it as an expected exception.
+   * A processor on which to await a response from the {@link RemoteOperationMessage} recipient,
+   * capturing any CacheException thrown by the recipient and handle it as an expected exception.
-    
+
-    
+
-    
+
-    
-    public RemoteOperationResponse(InternalDistributedSystem dm, Collection initMembers, boolean register) {
+
+    public RemoteOperationResponse(InternalDistributedSystem dm, Collection initMembers,
+        boolean register) {
-      if(register) {
+      if (register) {
-    
+
-    
-    public RemoteOperationResponse(InternalDistributedSystem dm, InternalDistributedMember member, boolean register) {
+
+    public RemoteOperationResponse(InternalDistributedSystem dm, InternalDistributedMember member,
+        boolean register) {
-      if(register) {
+      if (register) {
+
-    
+
-          this.prce =  new ForceReattemptException(LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1.toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}));
+          this.prce = new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
+                  .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}));
-        Exception e = new Exception(LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
-        logger.info(LocalizedMessage.create(LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0, Boolean.valueOf(crashed)), e);
+        Exception e = new Exception(
+            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0,
+            Boolean.valueOf(crashed)), e);
-     * @throws CacheException  if the recipient threw a cache exception during message processing 
-     * @throws PrimaryBucketException 
+     * 
+     * @throws CacheException if the recipient threw a cache exception during message processing
+     * @throws PrimaryBucketException
-    final public void waitForCacheException() 
+    final public void waitForCacheException()
-        if (this.prce!=null || (this.responseRequired && !this.responseReceived)) {
-          throw new RemoteOperationException(LocalizedStrings.PartitionMessage_ATTEMPT_FAILED.toLocalizedString(), this.prce);
+        if (this.prce != null || (this.responseRequired && !this.responseReceived)) {
+          throw new RemoteOperationException(
+              LocalizedStrings.PartitionMessage_ATTEMPT_FAILED.toLocalizedString(), this.prce);
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          throw (CacheException)t;
-        }
-        else if (t instanceof RemoteOperationException) {
-          RemoteOperationException ft = (RemoteOperationException)t;
+          throw (CacheException) t;
+        } else if (t instanceof RemoteOperationException) {
+          RemoteOperationException ft = (RemoteOperationException) t;
-          RemoteOperationException fre = new RemoteOperationException(LocalizedStrings.PartitionMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
+          RemoteOperationException fre = new RemoteOperationException(
+              LocalizedStrings.PartitionMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-        }
-        else if (t instanceof PrimaryBucketException) {
+        } else if (t instanceof PrimaryBucketException) {
-          throw new PrimaryBucketException(LocalizedStrings.PartitionMessage_PEER_FAILED_PRIMARY_TEST.toLocalizedString(), t);
-        }
-        else if (t instanceof RegionDestroyedException) {
+          throw new PrimaryBucketException(
+              LocalizedStrings.PartitionMessage_PEER_FAILED_PRIMARY_TEST.toLocalizedString(), t);
+        } else if (t instanceof RegionDestroyedException) {
-        }
-        else if (t instanceof CancelException) {
+        } else if (t instanceof CancelException) {
-            logger.debug("RemoteOperationResponse got CacheClosedException from {}, throwing ForceReattemptException", e.getSender(), t);
+            logger.debug(
+                "RemoteOperationResponse got CacheClosedException from {}, throwing ForceReattemptException",
+                e.getSender(), t);
-          throw new RemoteOperationException(LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION.toLocalizedString(), t);
-        }
-        else if (t instanceof LowMemoryException) {
+          throw new RemoteOperationException(
+              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION
+                  .toLocalizedString(),
+              t);
+        } else if (t instanceof LowMemoryException) {
-            logger.debug("RemoteOperationResponse re-throwing remote LowMemoryException from {}", e.getSender(), t);
+            logger.debug("RemoteOperationResponse re-throwing remote LowMemoryException from {}",
+                e.getSender(), t);
-    }    
+    }
-  
+
-  
+
-   this.isTransactionDistributed = isDistTx;
+    this.isTransactionDistributed = isDistTx;
-  
+

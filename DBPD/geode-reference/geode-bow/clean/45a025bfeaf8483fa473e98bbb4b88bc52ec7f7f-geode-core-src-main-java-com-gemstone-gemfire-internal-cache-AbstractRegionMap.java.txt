Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

+import com.gemstone.gemfire.internal.cache.tier.sockets.ClientUpdateMessageImpl;
-        Map.Entry entry = null;
-        synchronized (haContainer) {
-          entry = (Map.Entry)haContainer.getEntry(haEventWrapper);
-          if (entry != null) {
-            original = (HAEventWrapper)entry.getKey();
-            original.incAndGetReferenceCount();
+//      synchronized (haContainer) {
+      do {
+        ClientUpdateMessageImpl oldMsg = (ClientUpdateMessageImpl) haContainer
+            .putIfAbsent(haEventWrapper,
+                haEventWrapper.getClientUpdateMessage());
+        if (oldMsg != null) {
+          original = (HAEventWrapper) haContainer.getKey(haEventWrapper);
+          if (original == null) {
+            continue;
-          else {
+          synchronized (original) {
+            if ((HAEventWrapper) haContainer.getKey(original) != null) {
+              original.incAndGetReferenceCount();
+              HARegionQueue.addClientCQsAndInterestList(oldMsg,
+                  haEventWrapper, haContainer, owner.getName());
+              haEventWrapper.setClientUpdateMessage(null);
+              newValue = CachedDeserializableFactory.create(original,
+                  ((CachedDeserializable) newValue).getSizeInBytes());
+            } else {
+              original = null;
+            }
+          }
+        } else { // putIfAbsent successful
+          synchronized (haEventWrapper) {
-            haContainer.put(haEventWrapper, haEventWrapper
-                .getClientUpdateMessage());
+          break;
+        // try until we either get a reference to HAEventWrapper from
+        // HAContainer or successfully put one into it.
+      } while (original == null);
+      /*
+        entry = (Map.Entry)haContainer.getEntry(haEventWrapper);
-          HARegionQueue.addClientCQsAndInterestList(entry, haEventWrapper,
-              haContainer, owner.getName());
-          haEventWrapper.setClientUpdateMessage(null);
-          newValue = CachedDeserializableFactory.create(original,
-              ((CachedDeserializable)newValue).getSizeInBytes());
+          original = (HAEventWrapper)entry.getKey();
+          original.incAndGetReferenceCount();
+        else {
+          haEventWrapper.incAndGetReferenceCount();
+          haEventWrapper.setHAContainer(haContainer);
+          haContainer.put(haEventWrapper, haEventWrapper
+              .getClientUpdateMessage());
+          haEventWrapper.setClientUpdateMessage(null);
+          haEventWrapper.setIsRefFromHAContainer(true);
+        }
+      }
+      if (entry != null) {
+        HARegionQueue.addClientCQsAndInterestList(entry, haEventWrapper,
+            haContainer, owner.getName());
+        haEventWrapper.setClientUpdateMessage(null);
+        newValue = CachedDeserializableFactory.create(original,
+            ((CachedDeserializable)newValue).getSizeInBytes());
+      }
+*/
-      ReferenceCountHelper.skipRefCountTracking();
-      
-      @Retained @Released Object v = re._getValueRetain(event.getLocalRegion(), true);
-      
-      ReferenceCountHelper.unskipRefCountTracking();
-      try {
-        if (!AbstractRegionEntry.checkExpectedOldValue(expectedOldValue, v, event.getLocalRegion())) {
-          return false;
-        }
-      } finally {
-        OffHeapHelper.releaseWithNoTracking(v);
+      assert event.getOperation().guaranteesOldValue();
+      // We already called setOldValueInEvent so the event will have the old value.
+      @Unretained Object v = event.getRawOldValue();
+      // Note that v will be null instead of INVALID because setOldValue
+      // converts INVALID to null.
+      // But checkExpectedOldValue handle this and says INVALID equals null.
+      if (!AbstractRegionEntry.checkExpectedOldValue(expectedOldValue, v, event.getLocalRegion())) {
+        return false;
-          event.setOldValue(oldValueInVMOrDisk, requireOldValue);
+          event.setOldValue(oldValueInVMOrDisk, needToSetOldValue);
-          event.setOldValue(oldValueInVM, requireOldValue);
+          event.setOldValue(oldValueInVM, needToSetOldValue);

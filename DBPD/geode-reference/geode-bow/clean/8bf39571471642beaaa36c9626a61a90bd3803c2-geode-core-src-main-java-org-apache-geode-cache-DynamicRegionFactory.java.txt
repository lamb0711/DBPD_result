Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * DynamicRegionFactory provides a distributed region creation service. 
- * Any other member of the GemFire DistributedSystem that has created 
- * an instance of this class will automatically instantiate regions created
- * through the factory from anywhere else in the DistributedSystem.
- * <p><p>
+ * DynamicRegionFactory provides a distributed region creation service. Any other member of the
+ * GemFire DistributedSystem that has created an instance of this class will automatically
+ * instantiate regions created through the factory from anywhere else in the DistributedSystem.
+ * <p>
+ * <p>
- * <li> If your application is a client in a client/server installation,
- * either specify the pool name in the
- * {@link DynamicRegionFactory.Config} you'll use to create a
- * DynamicRegionFactory <i>or</i> specify it
- * in a dynamic-region-factory element in your cache.xml.
+ * <li>If your application is a client in a client/server installation, either specify the pool name
+ * in the {@link DynamicRegionFactory.Config} you'll use to create a DynamicRegionFactory <i>or</i>
+ * specify it in a dynamic-region-factory element in your cache.xml.
- * <li> Before you've created a GemFire Cache in your application, add a
- * line of code as follows:<br>
- * <pre><code>  DynamicRegionFactory factory = DynamicRegionFactory.get();
- *  factory.open(config);</code></pre>
- * <pre><code>  DynamicRegionFactory myFactoryHandle = DynamicRegionFactory.get().open(config);</code></pre>
+ * <li>Before you've created a GemFire Cache in your application, add a line of code as follows:<br>
+ * 
+ * <pre>
+ * <code>  DynamicRegionFactory factory = DynamicRegionFactory.get();
+ *  factory.open(config);</code>
+ * </pre>
+ * 
+ * <pre>
+ * <code>  DynamicRegionFactory myFactoryHandle = DynamicRegionFactory.get().open(config);</code>
+ * </pre>
+ * 
- * <li> Create the GemFire Cache.  During cache creation, the list of dynamic Regions will either be discovered
- * by recovering
- * their names from disk (see {@link DynamicRegionFactory.Config#persistBackup}) or from other members of the
- * distributed system.
- * These dynamic Regions will be created before Cache creation completes.
+ * <li>Create the GemFire Cache. During cache creation, the list of dynamic Regions will either be
+ * discovered by recovering their names from disk (see
+ * {@link DynamicRegionFactory.Config#persistBackup}) or from other members of the distributed
+ * system. These dynamic Regions will be created before Cache creation completes.
- * <li> Thereafter, when you want to create dynamic distributed Regions,
- * create them using the {@link #createDynamicRegion}.  Regions created with the factory will
- * inherit their RegionAttributes from their parent Region, though you can override
- * callbacks when you configure the factory.
+ * <li>Thereafter, when you want to create dynamic distributed Regions, create them using the
+ * {@link #createDynamicRegion}. Regions created with the factory will inherit their
+ * RegionAttributes from their parent Region, though you can override callbacks when you configure
+ * the factory.
- * <p>All other instances of GemFire across the distributed system that
- * instantiate and open a DynamicRegionFactory will also get the dynamic distributed Regions.
+ * <p>
+ * All other instances of GemFire across the distributed system that instantiate and open a
+ * DynamicRegionFactory will also get the dynamic distributed Regions.
- * the dynamic Region factory goes active and starts creating Regions.  You will have cache creation
+ * the dynamic Region factory goes active and starts creating Regions. You will have cache creation
- * <li>A DynamicRegionListener can be registered before open is called and before cache creation
- * so that the listener will be called if dynamic Regions are created during cache creation.
+ * <li>A DynamicRegionListener can be registered before open is called and before cache creation so
+ * that the listener will be called if dynamic Regions are created during cache creation.
- * <p>Saving the factory on disk:  
- * If {@link DynamicRegionFactory.Config#persistBackup} is configured for the factory, dynamic Region information
- * is written to disk for recovery.
- * By default the current directory is used for this information. The {@link DynamicRegionFactory.Config#diskDir}
+ * <p>
+ * Saving the factory on disk: If {@link DynamicRegionFactory.Config#persistBackup} is configured
+ * for the factory, dynamic Region information is written to disk for recovery. By default the
+ * current directory is used for this information. The {@link DynamicRegionFactory.Config#diskDir}
- * Registering interest in cache server information: The {@link DynamicRegionFactory.Config#registerInterest}
- * setting determines whether clients will register interest in server keys or not.  You will generally want
- * this to be turned on so that clients will see updates made to servers.  In server processes, DynamicRegionFactory
- * forces use of NotifyBySubscription.
+ * Registering interest in cache server information: The
+ * {@link DynamicRegionFactory.Config#registerInterest} setting determines whether clients will
+ * register interest in server keys or not. You will generally want this to be turned on so that
+ * clients will see updates made to servers. In server processes, DynamicRegionFactory forces use of
+ * NotifyBySubscription.
- * <li>If {@link #open()} is called before cache creation and the cache.xml has a dynamic-region-factory
- * element then the cache.xml will override the open call's configuration.
+ * <li>If {@link #open()} is called before cache creation and the cache.xml has a
+ * dynamic-region-factory element then the cache.xml will override the open call's configuration.
- * <li>Since the RegionAttributes of a dynamically created Region are copied
- * from the parent Region, any callbacks, ({@link CacheListener},
- * {@link CacheWriter}, and {@link CacheLoader}
- * are shared by the parent and all its dynamic children
- * so make sure the callback is thread-safe and that its
- * {@link CacheCallback#close} implementation does not stop it from functioning.
- * However the products LRUAlgorithm instances will
- * be cloned so that each dynamic Region has its own callback.
+ * <li>Since the RegionAttributes of a dynamically created Region are copied from the parent Region,
+ * any callbacks, ({@link CacheListener}, {@link CacheWriter}, and {@link CacheLoader} are shared by
+ * the parent and all its dynamic children so make sure the callback is thread-safe and that its
+ * {@link CacheCallback#close} implementation does not stop it from functioning. However the
+ * products LRUAlgorithm instances will be cloned so that each dynamic Region has its own callback.
- * <li>The root Region name "DynamicRegions" is reserved. The factory creates a root Region of
- * that name and uses it to keep track of what dynamic Regions exist. Applications should
- * not directly access this Region; instead use the methods on this factory.
+ * <li>The root Region name "DynamicRegions" is reserved. The factory creates a root Region of that
+ * name and uses it to keep track of what dynamic Regions exist. Applications should not directly
+ * access this Region; instead use the methods on this factory.
+ * 
- * @deprecated This class is deprecated. Use {@link FunctionService} to create regions on
- * other members instead.
+ * @deprecated This class is deprecated. Use {@link FunctionService} to create regions on other
+ *             members instead.
-public abstract class DynamicRegionFactory  {
+public abstract class DynamicRegionFactory {
-   * This controls the delay introduced to try and avoid any race conditions
-   * between propagation of newly created Dynamic Regions
-   * and the Entries put into them.
+   * This controls the delay introduced to try and avoid any race conditions between propagation of
+   * newly created Dynamic Regions and the Entries put into them.
-  private static final long regionCreateSleepMillis = Long.getLong("DynamicRegionFactory.msDelay", 250).longValue();
-  private static DynamicRegionFactory singleInstance = new DynamicRegionFactoryImpl ( );
+  private static final long regionCreateSleepMillis =
+      Long.getLong("DynamicRegionFactory.msDelay", 250).longValue();
+  private static DynamicRegionFactory singleInstance = new DynamicRegionFactoryImpl();
-   * Opens the factory with the given settings.
-   * This should be sent to the factory before creating a cache.  The cache
-   * will otherwise open a factory with default settings.
-   * This does not need to be sent if the cache.xml declares the use of dynamic regions.
+   * Opens the factory with the given settings. This should be sent to the factory before creating a
+   * cache. The cache will otherwise open a factory with default settings. This does not need to be
+   * sent if the cache.xml declares the use of dynamic regions.
+   * 
+
-   * Closes the dynamic region factory, disabling any further creation or
-   * destruction of dynamic regions in this cache.
+   * Closes the dynamic region factory, disabling any further creation or destruction of dynamic
+   * regions in this cache.
+
+
-   * Returns true if this factory is open and can produce dynamic regions.
-   * Factories are only active after their cache has been created.
+   * Returns true if this factory is open and can produce dynamic regions. Factories are only active
+   * after their cache has been created.
+
-   * Returns the configuration for this factory.
-   * Returns null if the factory is closed;
+   * Returns the configuration for this factory. Returns null if the factory is closed;
+   * 
-  protected void _internalInit ( GemFireCacheImpl theCache ) throws CacheException
-  {
+  protected void _internalInit(GemFireCacheImpl theCache) throws CacheException {
-     * This method is called internally during cache initialization at the correct time.
-     * Initialize the factory with a GemFire Cache.  We create the metadata Region which holds all our
+     * This method is called internally during cache initialization at the correct time. Initialize
+     * the factory with a GemFire Cache. We create the metadata Region which holds all our
-      final boolean isClient = this.config.getPoolName()!=null;
+      final boolean isClient = this.config.getPoolName() != null;
-        InternalRegionArguments ira = new InternalRegionArguments()
-        .setDestroyLockFlag(true)
-        .setInternalRegion(true)
-        .setSnapshotInputStream(null)
-        .setImageTarget(null);
-        AttributesFactory af = new AttributesFactory ();       
+        InternalRegionArguments ira = new InternalRegionArguments().setDestroyLockFlag(true)
+            .setInternalRegion(true).setSnapshotInputStream(null).setImageTarget(null);
+        AttributesFactory af = new AttributesFactory();
-            af.setDiskDirs(new File[]{this.config.getDiskDir()});
+            af.setDiskDirs(new File[] {this.config.getDiskDir()});
-          af.setDataPolicy(DataPolicy.NORMAL); //MirrorType(MirrorType.NONE);
+          af.setDataPolicy(DataPolicy.NORMAL); // MirrorType(MirrorType.NONE);
-            if(cp==null)   {
-              throw new IllegalStateException("Invalid pool name specified. This pool is not registered with the cache: " + cpName);
+            if (cp == null) {
+              throw new IllegalStateException(
+                  "Invalid pool name specified. This pool is not registered with the cache: "
+                      + cpName);
-                throw new IllegalStateException("The client pool of a DynamicRegionFactory must be configured with queue-enabled set to true.");
+                throw new IllegalStateException(
+                    "The client pool of a DynamicRegionFactory must be configured with queue-enabled set to true.");
-          if (!this.config.getPersistBackup()) {  // if persistBackup, the data policy has already been set
-	    af.setDataPolicy(DataPolicy.REPLICATE); //setMirrorType(MirrorType.KEYS_VALUES);
-	  }
+          if (!this.config.getPersistBackup()) { // if persistBackup, the data policy has already
+                                                 // been set
+            af.setDataPolicy(DataPolicy.REPLICATE); // setMirrorType(MirrorType.KEYS_VALUES);
+          }
-    
-        try { 
-          dynamicRegionList = theCache.createVMRegion(dynamicRegionListName,  af.create(), ira);
-        }
-        catch (IOException e) {
+
+        try {
+          dynamicRegionList = theCache.createVMRegion(dynamicRegionListName, af.create(), ira);
+        } catch (IOException e) {
-          InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString());
+          InternalGemFireError assErr = new InternalGemFireError(
+              LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString());
-        }
-        catch (ClassNotFoundException e) {
+        } catch (ClassNotFoundException e) {
-          InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString());
+          InternalGemFireError assErr = new InternalGemFireError(
+              LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString());
-      createDefinedDynamicRegions ( );
+      createDefinedDynamicRegions();
-    } catch ( CacheException e ) {
+    } catch (CacheException e) {
-      theCache.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_ERROR_INITIALIZING_DYNAMICREGIONFACTORY, e);
+      theCache.getLoggerI18n().warning(
+          LocalizedStrings.DynamicRegionFactory_ERROR_INITIALIZING_DYNAMICREGIONFACTORY, e);
-   *  This creates Dynamic Regions that already exist in other publishing processes
+   * This creates Dynamic Regions that already exist in other publishing processes
-  private void createDefinedDynamicRegions ( ) throws CacheException {
+  private void createDefinedDynamicRegions() throws CacheException {
-    Set s = dynamicRegionList.entrySet( false );
+    Set s = dynamicRegionList.entrySet(false);
-    while ( i.hasNext() ) {
-      Region.Entry e = (Region.Entry)i.next();
-      DynamicRegionAttributes dda = (DynamicRegionAttributes)e.getValue();
+    while (i.hasNext()) {
+      Region.Entry e = (Region.Entry) i.next();
+      DynamicRegionAttributes dda = (DynamicRegionAttributes) e.getValue();
-    
-    while ( i.hasNext() ) {
-      DynamicRegionAttributes dda = (DynamicRegionAttributes)i.next();
-      doBeforeRegionCreated ( dda.rootRegionName, dda.name, null );
-      Region region = createDynamicRegionImpl ( dda.rootRegionName, dda.name, false );
-      doAfterRegionCreated ( region, false, false, null );
+    while (i.hasNext()) {
+      DynamicRegionAttributes dda = (DynamicRegionAttributes) i.next();
+
+      doBeforeRegionCreated(dda.rootRegionName, dda.name, null);
+      Region region = createDynamicRegionImpl(dda.rootRegionName, dda.name, false);
+      doAfterRegionCreated(region, false, false, null);
+   * 
+   * 
+   * 
-  private void doBeforeRegionCreated( String parentRegion, String regionName, DistributedMember mbr ) {
-    for ( Iterator i = regionListeners.iterator(); i.hasNext(); ) {
-      DynamicRegionListener listener = ( DynamicRegionListener ) i.next();
+  private void doBeforeRegionCreated(String parentRegion, String regionName,
+      DistributedMember mbr) {
+    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
+      DynamicRegionListener listener = (DynamicRegionListener) i.next();
-        listener.beforeRegionCreate( parentRegion, regionName );
-      } 
-      catch (VirtualMachineError err) {
+        listener.beforeRegionCreate(parentRegion, regionName);
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        this.c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_BEFOREREGIONCREATED, listener, t); 
+        this.c.getLoggerI18n().warning(
+            LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_BEFOREREGIONCREATED,
+            listener, t);
-  private void doAfterRegionCreated( Region region, boolean distributed, boolean isOriginRemote, DistributedMember mbr ) {
-    RegionEvent event = new RegionEventImpl(region, Operation.REGION_CREATE, null, isOriginRemote, getMember(mbr));
-    for ( Iterator i = regionListeners.iterator(); i.hasNext(); ) {
-      DynamicRegionListener listener = ( DynamicRegionListener ) i.next();
+  private void doAfterRegionCreated(Region region, boolean distributed, boolean isOriginRemote,
+      DistributedMember mbr) {
+    RegionEvent event =
+        new RegionEventImpl(region, Operation.REGION_CREATE, null, isOriginRemote, getMember(mbr));
+    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
+      DynamicRegionListener listener = (DynamicRegionListener) i.next();
-        listener.afterRegionCreate( event /*region*/ );
-      } 
-      catch (VirtualMachineError err) {
+        listener.afterRegionCreate(event /* region */ );
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        this.c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_AFTERREGIONCREATED, listener, t);
+        this.c.getLoggerI18n().warning(
+            LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_AFTERREGIONCREATED,
+            listener, t);
-  private void doBeforeRegionDestroyed( Region region, boolean distributed, boolean isOriginRemote, boolean expiration, DistributedMember mbr ) {
+  private void doBeforeRegionDestroyed(Region region, boolean distributed, boolean isOriginRemote,
+      boolean expiration, DistributedMember mbr) {
-      op = expiration? Operation.REGION_EXPIRE_LOCAL_DESTROY : Operation.REGION_LOCAL_DESTROY;
-    }
-    else {
-       op = expiration? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_DESTROY;
+      op = expiration ? Operation.REGION_EXPIRE_LOCAL_DESTROY : Operation.REGION_LOCAL_DESTROY;
+    } else {
+      op = expiration ? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_DESTROY;
-    for ( Iterator i = regionListeners.iterator(); i.hasNext(); ) {
-      DynamicRegionListener listener = ( DynamicRegionListener ) i.next();
+    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
+      DynamicRegionListener listener = (DynamicRegionListener) i.next();
-        listener.beforeRegionDestroy( event /*fullRegionName*/ );
-      }
-      catch (VirtualMachineError err) {
+        listener.beforeRegionDestroy(event /* fullRegionName */ );
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        this.c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_BEFOREREGIONDESTROYED, listener, t);
+        this.c.getLoggerI18n().warning(
+            LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_BEFOREREGIONDESTROYED,
+            listener, t);
-  private void doAfterRegionDestroyed( Region region, boolean distributed, boolean isOriginRemote, boolean expiration, DistributedMember mbr ) {
+  private void doAfterRegionDestroyed(Region region, boolean distributed, boolean isOriginRemote,
+      boolean expiration, DistributedMember mbr) {
-      op = expiration? Operation.REGION_EXPIRE_LOCAL_DESTROY : Operation.REGION_LOCAL_DESTROY;
-    }
-    else {
-       op = expiration? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_DESTROY;
+      op = expiration ? Operation.REGION_EXPIRE_LOCAL_DESTROY : Operation.REGION_LOCAL_DESTROY;
+    } else {
+      op = expiration ? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_DESTROY;
-    for ( Iterator i = regionListeners.iterator(); i.hasNext(); ) {
-      DynamicRegionListener listener = ( DynamicRegionListener ) i.next();
+    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
+      DynamicRegionListener listener = (DynamicRegionListener) i.next();
-        listener.afterRegionDestroy( event /*fullRegionName*/ );
-      } 
-      catch (VirtualMachineError err) {
+        listener.afterRegionDestroy(event /* fullRegionName */ );
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        this.c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_AFTERREGIONDESTROYED, listener, t);
+        this.c.getLoggerI18n().warning(
+            LocalizedStrings.DynamicRegionFactory_DYNAMICREGIONLISTENER__0__THREW_EXCEPTION_ON_AFTERREGIONDESTROYED,
+            listener, t);
-  
+
-    }
-    else {
-     return null;
+    } else {
+      return null;
-    
+
-   * Creates the dynamic Region in the local cache and distributes the
-   * creation to other caches.
+   * Creates the dynamic Region in the local cache and distributes the creation to other caches.
-  public Region createDynamicRegion ( String parentRegionName, String regionName ) throws CacheException {
+  public Region createDynamicRegion(String parentRegionName, String regionName)
+      throws CacheException {
-    doBeforeRegionCreated ( parentRegionName, regionName, null );
-    Region region = createDynamicRegionImpl ( parentRegionName, regionName, true );
-    doAfterRegionCreated ( region, false, false, null );
+    doBeforeRegionCreated(parentRegionName, regionName, null);
+    Region region = createDynamicRegionImpl(parentRegionName, regionName, true);
+    doAfterRegionCreated(region, false, false, null);
-   * Destroys the dynamic Region in the local cache and distributes the
-   * destruction to other caches.
-   * @param fullRegionName The full path of the <code>Region</code> to be
-   * dynamically destroyed
+   * Destroys the dynamic Region in the local cache and distributes the destruction to other caches.
+   * 
+   * @param fullRegionName The full path of the <code>Region</code> to be dynamically destroyed
-   * @throws RegionDestroyedException if the dynamic region was never created
-   * or has already been destroyed
+   * @throws RegionDestroyedException if the dynamic region was never created or has already been
+   *         destroyed
-  public void destroyDynamicRegion ( String fullRegionName ) throws CacheException {    
+  public void destroyDynamicRegion(String fullRegionName) throws CacheException {
-      throw new RegionDestroyedException(LocalizedStrings.DynamicRegionFactory_DYNAMIC_REGION_0_HAS_NOT_BEEN_CREATED.toLocalizedString(fullRegionName), fullRegionName);
+      throw new RegionDestroyedException(
+          LocalizedStrings.DynamicRegionFactory_DYNAMIC_REGION_0_HAS_NOT_BEEN_CREATED
+              .toLocalizedString(fullRegionName),
+          fullRegionName);
-    Region region = c.getRegion( fullRegionName );
+    Region region = c.getRegion(fullRegionName);
-      doBeforeRegionDestroyed ( region, false, false, false, mbr );
+      doBeforeRegionDestroyed(region, false, false, false, mbr);
-      doAfterRegionDestroyed ( region, false, false, false, mbr );
+      doAfterRegionDestroyed(region, false, false, false, mbr);
-  private Region createDynamicRegionImpl ( String parentRegionName, String newRegionName, boolean addEntry )
-  throws CacheException {
+  private Region createDynamicRegionImpl(String parentRegionName, String newRegionName,
+      boolean addEntry) throws CacheException {
-    Region parentRegion = c.getRegion ( parentRegionName );
+    Region parentRegion = c.getRegion(parentRegionName);
-    if ( parentRegion == null ) {
-      String errMsg = LocalizedStrings.DynamicRegionFactory_ERROR__COULD_NOT_FIND_A_REGION_NAMED___0_.toLocalizedString(parentRegionName);
+    if (parentRegion == null) {
+      String errMsg =
+          LocalizedStrings.DynamicRegionFactory_ERROR__COULD_NOT_FIND_A_REGION_NAMED___0_
+              .toLocalizedString(parentRegionName);
-      c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_ERROR__COULD_NOT_FIND_A_REGION_NAMED___0_, parentRegionName, e);
+      c.getLoggerI18n().warning(
+          LocalizedStrings.DynamicRegionFactory_ERROR__COULD_NOT_FIND_A_REGION_NAMED___0_,
+          parentRegionName, e);
-    AttributesFactory af = new AttributesFactory( rra );
+    AttributesFactory af = new AttributesFactory(rra);
-        EvictionAttributes rev = new EvictionAttributesImpl( (EvictionAttributesImpl)ev );
-        af.setEvictionAttributes( rev );
+        EvictionAttributes rev = new EvictionAttributesImpl((EvictionAttributesImpl) ev);
+        af.setEvictionAttributes(rev);
-    
+
-      newRegion = parentRegion.createSubregion( newRegionName, newRegionAttributes );
+      newRegion = parentRegion.createSubregion(newRegionName, newRegionAttributes);
-      c.getLoggerI18n().fine("DynamicRegion " + newRegionName + " in parent " + parentRegionName + " already existed");
+      c.getLoggerI18n().fine(
+          "DynamicRegion " + newRegionName + " in parent " + parentRegionName + " already existed");
-//    } catch ( CacheException e ) {
-//      c.getLoggerI18n().warning ( "Error creating new Dynamic Region '" + newRegionName, e );
-//      throw e;
+      // } catch ( CacheException e ) {
+      // c.getLoggerI18n().warning ( "Error creating new Dynamic Region '" + newRegionName, e );
+      // throw e;
-      DynamicRegionAttributes dra = new DynamicRegionAttributes ( );
+      DynamicRegionAttributes dra = new DynamicRegionAttributes();
-        c.getLoggerI18n().fine ("Putting entry into dynamic region list at key: " + newRegion.getFullPath());
+        c.getLoggerI18n()
+            .fine("Putting entry into dynamic region list at key: " + newRegion.getFullPath());
-      dynamicRegionList.put ( newRegion.getFullPath(), dra );
+      dynamicRegionList.put(newRegion.getFullPath(), dra);
-      ServerRegionProxy proxy = ((LocalRegion)newRegion).getServerProxy();
+      ServerRegionProxy proxy = ((LocalRegion) newRegion).getServerProxy();
-        if (((Pool)proxy.getPool()).getSubscriptionEnabled()) {
+        if (((Pool) proxy.getPool()).getSubscriptionEnabled()) {
-          }
-          catch (GemFireSecurityException ex) {
+          } catch (GemFireSecurityException ex) {
-              LocalizedStrings.DynamicRegionFactory_EXCEPTION_WHEN_REGISTERING_INTEREST_FOR_ALL_KEYS_IN_DYNAMIC_REGION_0_1,  
-              new Object[] {newRegion.getFullPath(), ex});
+                LocalizedStrings.DynamicRegionFactory_EXCEPTION_WHEN_REGISTERING_INTEREST_FOR_ALL_KEYS_IN_DYNAMIC_REGION_0_1,
+                new Object[] {newRegion.getFullPath(), ex});
-    
+
-        Thread.sleep( regionCreateSleepMillis );
-      } catch ( InterruptedException e ) {
+        Thread.sleep(regionCreateSleepMillis);
+      } catch (InterruptedException e) {
-      c.getLoggerI18n().fine ( "Created Dynamic Region " + newRegion.getFullPath() );
+      c.getLoggerI18n().fine("Created Dynamic Region " + newRegion.getFullPath());
-  private void destroyDynamicRegionImpl(String fullRegionName)
-  throws CacheException {
+  private void destroyDynamicRegionImpl(String fullRegionName) throws CacheException {
-        c.getLoggerI18n().fine ("Destroying entry from dynamic region list at key: " + fullRegionName);
+        c.getLoggerI18n()
+            .fine("Destroying entry from dynamic region list at key: " + fullRegionName);
-      dynamicRegionList.destroy ( fullRegionName );
+      dynamicRegionList.destroy(fullRegionName);
-      c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_ERROR_DESTROYING_DYNAMIC_REGION__0, fullRegionName, e);
+      c.getLoggerI18n().warning(
+          LocalizedStrings.DynamicRegionFactory_ERROR_DESTROYING_DYNAMIC_REGION__0, fullRegionName,
+          e);
-      c.getLoggerI18n().fine ( "Destroyed Dynamic Region " + fullRegionName );
+      c.getLoggerI18n().fine("Destroyed Dynamic Region " + fullRegionName);
-   * Configuration for dynamic region factory.
-   * The default attributes are:
+   * Configuration for dynamic region factory. The default attributes are:
+   * 
-  public static class Config  {
-    private static final boolean DISABLE_REGISTER_INTEREST = Boolean.getBoolean("DynamicRegionFactory.disableRegisterInterest");
-    private static final boolean DISABLE_PERSIST_BACKUP = Boolean.getBoolean("DynamicRegionFactory.disablePersistence");
+  public static class Config {
+    private static final boolean DISABLE_REGISTER_INTEREST =
+        Boolean.getBoolean("DynamicRegionFactory.disableRegisterInterest");
+    private static final boolean DISABLE_PERSIST_BACKUP =
+        Boolean.getBoolean("DynamicRegionFactory.disablePersistence");
-    /** Causes the factory to be persisted on disk.  See {@link #diskDir}  */
+    /** Causes the factory to be persisted on disk. See {@link #diskDir} */
-    /** Causes regions created by the factory to register interest in all keys in a corresponding server cache region */
-    public final boolean registerInterest;
-    
-     * The ${link Pool} to be used by a client factory to communicate with 
-     * the server-side factory.
+     * Causes regions created by the factory to register interest in all keys in a corresponding
+     * server cache region
+     */
+    public final boolean registerInterest;
+
+    /**
+     * The ${link Pool} to be used by a client factory to communicate with the server-side factory.
+
-    public Config(
-      File diskDir,
-      String poolName,
-      boolean persistBackup,
-      boolean registerInterest)
-    {
+    public Config(File diskDir, String poolName, boolean persistBackup, boolean registerInterest) {
-    
+
-     * Returns true if the region will register interest in all keys of a corresponding
-     * server cache region
+     * Returns true if the region will register interest in all keys of a corresponding server cache
+     * region
-    
+
-     * Returns the disk directory that the dynamic region factory data
-     * will be written to.
-     * Returns null if no directory has been specified.
-     * The diskDir is only used if <code>persistBackup</code> is true.
+     * Returns the disk directory that the dynamic region factory data will be written to. Returns
+     * null if no directory has been specified. The diskDir is only used if
+     * <code>persistBackup</code> is true.
-    
-    
+
+
-     * Returns the name of the {@link Pool} associated with the dynamic region factory.
-     * Returns null if there is no connection pool for dynamic regions.
+     * Returns the name of the {@link Pool} associated with the dynamic region factory. Returns null
+     * if there is no connection pool for dynamic regions.
-    
+
-  
+
-    
+
-    if ( !event.isOriginRemote() && !event.isBridgeEvent() ) return;
+    if (!event.isOriginRemote() && !event.isBridgeEvent())
+      return;
-    DynamicRegionAttributes dra = (DynamicRegionAttributes)event.getNewValue();
+    DynamicRegionAttributes dra = (DynamicRegionAttributes) event.getNewValue();
-      doBeforeRegionCreated ( parentRegionName, newRegionName, event.getDistributedMember() );
-      Region region = createDynamicRegionImpl ( parentRegionName, newRegionName, false);
-      doAfterRegionCreated ( region, true, true, event.getDistributedMember() );
-    } catch ( Exception e ) {
-      c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_ERROR_ATTEMPTING_TO_LOCALLY_CREATE_DYNAMIC_REGION__0, newRegionName, e);
+      doBeforeRegionCreated(parentRegionName, newRegionName, event.getDistributedMember());
+      Region region = createDynamicRegionImpl(parentRegionName, newRegionName, false);
+      doAfterRegionCreated(region, true, true, event.getDistributedMember());
+    } catch (Exception e) {
+      c.getLoggerI18n().warning(
+          LocalizedStrings.DynamicRegionFactory_ERROR_ATTEMPTING_TO_LOCALLY_CREATE_DYNAMIC_REGION__0,
+          newRegionName, e);
-  
+
-//     // Ignore the callback if it originated in this process (because the region
-//     // will already have been destroyed)
-//     if ( !event.isOriginRemote() && !(event instanceof BridgeEntryEventImpl)) return;
+    // // Ignore the callback if it originated in this process (because the region
+    // // will already have been destroyed)
+    // if ( !event.isOriginRemote() && !(event instanceof BridgeEntryEventImpl)) return;
-    String fullRegionName = ( String ) event.getKey();
-    Region drRegion = c.getRegion( fullRegionName );
+    String fullRegionName = (String) event.getKey();
+    Region drRegion = c.getRegion(fullRegionName);
-        doBeforeRegionDestroyed ( drRegion, true, event.getOperation().isDistributed(), event.getOperation().isExpiration(), event.getDistributedMember() );
+        doBeforeRegionDestroyed(drRegion, true, event.getOperation().isDistributed(),
+            event.getOperation().isExpiration(), event.getDistributedMember());
-        doAfterRegionDestroyed ( drRegion, true, event.getOperation().isDistributed(), event.getOperation().isExpiration(), event.getDistributedMember() );
-      } catch ( Exception e ) {
-        c.getLoggerI18n().warning(LocalizedStrings.DynamicRegionFactory_ERROR_ATTEMPTING_TO_LOCALLY_DESTROY_DYNAMIC_REGION__0, fullRegionName, e);
+        doAfterRegionDestroyed(drRegion, true, event.getOperation().isDistributed(),
+            event.getOperation().isExpiration(), event.getDistributedMember());
+      } catch (Exception e) {
+        c.getLoggerI18n().warning(
+            LocalizedStrings.DynamicRegionFactory_ERROR_ATTEMPTING_TO_LOCALLY_DESTROY_DYNAMIC_REGION__0,
+            fullRegionName, e);
-  
-//  private class DRListener implements CacheListener {
-//    public void afterCreate(EntryEvent arg0) {
-//      buildDynamicRegion(arg0);
-//    }
-//
-//    public void afterDestroy(EntryEvent arg0) {
-//      razeDynamicRegion(arg0);
-//    }
-//
-//    public void afterInvalidate(EntryEvent arg0) {
-//      // Stub, nothing to do.
-//    }
-//
-//    public void afterRegionDestroy(RegionEvent arg0) {
-//      // Stub, nothing to do.
-//    }
-//
-//    public void afterRegionInvalidate(RegionEvent arg0) {
-//      // Stub, nothing to do.
-//    }
-//
-//    public void afterUpdate(EntryEvent arg0) {
-//      // Stub, nothing to do.
-//    }
-//
-//    public void close() {
-//      // Stub, nothing to do.
-//    }
-//  }
-  
-  // Introduced to keep symmetry with DistributedMetaRegion and potentially provide improved control of
+
+  // private class DRListener implements CacheListener {
+  // public void afterCreate(EntryEvent arg0) {
+  // buildDynamicRegion(arg0);
+  // }
+  //
+  // public void afterDestroy(EntryEvent arg0) {
+  // razeDynamicRegion(arg0);
+  // }
+  //
+  // public void afterInvalidate(EntryEvent arg0) {
+  // // Stub, nothing to do.
+  // }
+  //
+  // public void afterRegionDestroy(RegionEvent arg0) {
+  // // Stub, nothing to do.
+  // }
+  //
+  // public void afterRegionInvalidate(RegionEvent arg0) {
+  // // Stub, nothing to do.
+  // }
+  //
+  // public void afterUpdate(EntryEvent arg0) {
+  // // Stub, nothing to do.
+  // }
+  //
+  // public void close() {
+  // // Stub, nothing to do.
+  // }
+  // }
+
+  // Introduced to keep symmetry with DistributedMetaRegion and potentially provide improved control
+  // of
-  private class LocalMetaRegion extends LocalRegion  {
+  private class LocalMetaRegion extends LocalRegion {
-    
+
-    protected boolean isSecret()
-    {
+    protected boolean isSecret() {
-//    //@override event tracker not needed for this type of region
-//    void initEventTracker() {
-//    }
+    // //@override event tracker not needed for this type of region
+    // void initEventTracker() {
+    // }
-    // while internal, its contents should be communicated with bridge clients 
+    // while internal, its contents should be communicated with bridge clients
-    protected boolean shouldNotifyBridgeClients()
-    {
+    protected boolean shouldNotifyBridgeClients() {
-    public void invokeDestroyCallbacks(EnumListenerEvent eventType, EntryEventImpl event, boolean callDispatchEventsCallback, boolean notifyGateways )
-    {
+    public void invokeDestroyCallbacks(EnumListenerEvent eventType, EntryEventImpl event,
+        boolean callDispatchEventsCallback, boolean notifyGateways) {
-    protected long basicPutPart2(EntryEventImpl event, RegionEntry entry,
-        boolean isInitialized, long lastModified,
-        boolean clearConflict)  {
-    
-    boolean isCreate = event.getOperation().isCreate();
-    boolean set = false;
-    
-    if (isCreate && !event.callbacksInvoked()) {
-      // don't notify clients until all peers have created the region so that
-      // their register-interest operations will be sure to find data
-      event.callbacksInvoked(true);
-      set = true;
+    protected long basicPutPart2(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+        long lastModified, boolean clearConflict) {
+
+      boolean isCreate = event.getOperation().isCreate();
+      boolean set = false;
+
+      if (isCreate && !event.callbacksInvoked()) {
+        // don't notify clients until all peers have created the region so that
+        // their register-interest operations will be sure to find data
+        event.callbacksInvoked(true);
+        set = true;
+      }
+
+      long result = super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
+
+      if (set) {
+        event.callbacksInvoked(false);
+      }
+
+      if (isCreate) {
+        buildDynamicRegion(event);
+      }
+      return result;
-    
-    long result = super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
-    
-    if (set) {
-      event.callbacksInvoked(false);
-    }
-    
-    if (isCreate) {
-      buildDynamicRegion(event);
-    }
-    return result;
-  }
-  
+
-    public void basicPutPart3(EntryEventImpl event, RegionEntry entry,
-        boolean isInitialized, long lastModified, boolean invokeCallbacks,
-        boolean ifNew, boolean ifOld, Object expectedOldValue,
-        boolean requireOldValue) {
-      
-      super.basicPutPart3(event, entry, isInitialized, lastModified, invokeCallbacks, ifNew, ifOld, expectedOldValue, requireOldValue);
-      
+    public void basicPutPart3(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+        long lastModified, boolean invokeCallbacks, boolean ifNew, boolean ifOld,
+        Object expectedOldValue, boolean requireOldValue) {
+
+      super.basicPutPart3(event, entry, isInitialized, lastModified, invokeCallbacks, ifNew, ifOld,
+          expectedOldValue, requireOldValue);
+
-          notifyGatewaySender(event.getOperation().isUpdate()? EnumListenerEvent.AFTER_UPDATE
-                                               : EnumListenerEvent.AFTER_CREATE, event);
+          notifyGatewaySender(event.getOperation().isUpdate() ? EnumListenerEvent.AFTER_UPDATE
+              : EnumListenerEvent.AFTER_CREATE, event);
-            }
-            catch (InterruptedException ie) {
+            } catch (InterruptedException ie) {
-    }   
+    }
-  // Part of the fix for bug 35432, which required a change to the 
+  // Part of the fix for bug 35432, which required a change to the
-  private class DistributedMetaRegion extends DistributedRegion  {
+  private class DistributedMetaRegion extends DistributedRegion {
-      super(dynamicRegionListName, attrs, null, DynamicRegionFactory.this.c, new InternalRegionArguments());
+      super(dynamicRegionListName, attrs, null, DynamicRegionFactory.this.c,
+          new InternalRegionArguments());
+
-    protected boolean isSecret()
-    {
+    protected boolean isSecret() {
-    
-//    //@override event tracker not needed for this type of region
-//    void initEventTracker() {
-//    }
+
+    // //@override event tracker not needed for this type of region
+    // void initEventTracker() {
+    // }
-    // while internal, its contents should be communicated with bridge clients 
+    // while internal, its contents should be communicated with bridge clients
-    final public boolean shouldNotifyBridgeClients()
-    {
+    final public boolean shouldNotifyBridgeClients() {
-    }    
-   
+    }
+
-    // 
+    //
-    public void invokeDestroyCallbacks(EnumListenerEvent eventType, EntryEventImpl event, boolean callDispatchEventsCallback, boolean notifyGateways)
-    {
+    public void invokeDestroyCallbacks(EnumListenerEvent eventType, EntryEventImpl event,
+        boolean callDispatchEventsCallback, boolean notifyGateways) {
-    protected long basicPutPart2(EntryEventImpl event, RegionEntry entry,
-        boolean isInitialized, long lastModified,
-        boolean clearConflict)
-    {
+    protected long basicPutPart2(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+        long lastModified, boolean clearConflict) {
-      
+
-      
+
-      
+
-        }
-        finally {
+        } finally {
-    
+
-    public void basicPutPart3(EntryEventImpl event, RegionEntry entry,
-        boolean isInitialized, long lastModified, boolean invokeCallbacks,
-        boolean ifNew, boolean ifOld, Object expectedOldValue,
-        boolean requireOldValue) {
+    public void basicPutPart3(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+        long lastModified, boolean invokeCallbacks, boolean ifNew, boolean ifOld,
+        Object expectedOldValue, boolean requireOldValue) {
-      super.basicPutPart3(event, entry, isInitialized, lastModified, invokeCallbacks, ifNew, ifOld, expectedOldValue, requireOldValue);
-      
+      super.basicPutPart3(event, entry, isInitialized, lastModified, invokeCallbacks, ifNew, ifOld,
+          expectedOldValue, requireOldValue);
+
-          notifyGatewaySender(event.getOperation().isUpdate()? EnumListenerEvent.AFTER_UPDATE
-                                               : EnumListenerEvent.AFTER_CREATE, event);
+          notifyGatewaySender(event.getOperation().isUpdate() ? EnumListenerEvent.AFTER_UPDATE
+              : EnumListenerEvent.AFTER_CREATE, event);
-            }
-            catch (InterruptedException ie) {
+            } catch (InterruptedException ie) {

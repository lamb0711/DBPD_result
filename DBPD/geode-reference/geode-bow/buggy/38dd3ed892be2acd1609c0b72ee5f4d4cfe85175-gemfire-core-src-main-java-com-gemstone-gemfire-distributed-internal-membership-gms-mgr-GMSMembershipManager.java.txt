Adding code-coverage testing for GMSMembershipManager and removing unused code.

+import com.gemstone.gemfire.distributed.internal.direct.DirectChannelListener;
+import com.gemstone.gemfire.distributed.internal.membership.gms.GMSUtil;
-import com.gemstone.gemfire.internal.logging.InternalLogWriter;
-    static final int DEPARTURE = 1;
-    static final int CONNECT = 2;
-    static final int VIEW = 3;
-    static final int MESSAGE = 4;
+    static final int SURPRISE_CONNECT = 1;
+    static final int VIEW = 2;
+    static final int MESSAGE = 3;
-     * @see #DEPARTURE
-     * @see #CONNECT
+     * @see #SURPRISE_CONNECT
-      case DEPARTURE:
-        sb.append("departure; member = <")
-          .append(member)
-          .append(">; crashed = ")
-          .append(crashed)
-          .append("; reason = ");
-        if (reason != null && (reason.indexOf("NoSuchMemberException") >= 0)) {
-          sb.append(LocalizedStrings.GroupMembershipService_TCPIP_CONNECTIONS_CLOSED.toLocalizedString());
-        }
-        else {
-          sb.append(reason);
-        }
-        break;
-      case CONNECT:
+      case SURPRISE_CONNECT:
-    /**
-     * Create a departure event
-     * @param dm the member that left
-     * @param crashed true if this member crashed
-     * @param reason reason string, esp. if crashed
-     */
-    StartupEvent(InternalDistributedMember dm, boolean crashed, String reason) {
-      this.kind = DEPARTURE;
-      this.member = dm;
-      this.crashed = crashed;
-      this.reason = reason;
-    }
-    /**
-     * Indicate if this is a departure
-     * @return true if this is a departure event
-     */
-    boolean isDepartureEvent() {
-      return this.kind == DEPARTURE;
-    }
-     * Create a connect event
+     * Create a surprise connect event
-      this.kind = CONNECT;
+      this.kind = SURPRISE_CONNECT;
-     * Indicate if this is a connect event
+     * Indicate if this is a surprise connect event
-    boolean isConnect() {
-      return this.kind == CONNECT;
+    boolean isSurpriseConnect() {
+      return this.kind == SURPRISE_CONNECT;
-  /** sleep period, in millis, that the user of this manager should slumber after creating
-      the manager.  This is advice from the JChannel itself when it detects a concurrent
-      startup race condition that requires a settling period. */
-  private long channelPause = 0;  
-
-  class MyDCReceiver implements DistributedMembershipListener
+  class MyDCReceiver implements DirectChannelListener
-    DistributedMembershipListener upCall;
+    DirectChannelListener upCall;
-   MyDCReceiver(DistributedMembershipListener up) {
+   MyDCReceiver(DirectChannelListener up) {
-    public void messageReceived(DistributionMessage msg)
-    {
+    public void messageReceived(DistributionMessage msg) {
-    public void newMemberConnected(final InternalDistributedMember member, final Stub id)
-    {
-      handleOrDeferSurpriseConnect(member, id);
-    }
-
-    public void memberDeparted(InternalDistributedMember id, boolean crashed, String reason)
-    {
-      try {
-        handleOrDeferRemove(id, crashed, reason);
-      }
-      catch (DistributedSystemDisconnectedException ignore) {
-        // ignore
-      }
-      catch (RuntimeException e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GroupMembershipService_MEMBERSHIP_ERROR_HANDLING_MEMBER_DEPARTURE__0), e);
-      }
-    }
-    
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-    }
-
-    public void memberSuspect(InternalDistributedMember suspect, InternalDistributedMember whoSuspected) {
-      // the direct channel isn't currently a source of suspect events, though
-      // it does request initiation of suspicion through the membership
-      // manager
-    }
-
-    public boolean isShutdownMsgSent()
-    {
-      return upCall.isShutdownMsgSent();
-    }
-
-    public void membershipFailure(String reason, Throwable t)
-    {
-      upCall.membershipFailure(reason, t);
-    }
-    
-    public void viewInstalled(NetView view) {
-      upCall.viewInstalled(view);
-    }
-
-    public DistributionManager getDM()
-    {
+    public DistributionManager getDM() {
-      if (logger.isDebugEnabled()) {
-        logger.debug(LogMarker.DM_VIEWS, msg);
-      }
-        if (newViewId < latestViewId && logger.isDebugEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-          logger.debug(LogMarker.DISTRIBUTION_VIEWS, "Membership: Ignoring view (with id {}) since it is older than the last view (with id {}); ignoredView={}",
-              newViewId, latestViewId, newView);
-        }
-          logger.info(LogMarker.DM_VIEWS, LocalizedMessage.create(
-              LocalizedStrings.GroupMembershipService_MEMBERSHIP_SHUNNING_MEMBER__0__DURING_OUR_SHUTDOWN, m));
-          listener.newMemberConnected(m, getStubForMember(m));
+          listener.newMemberConnected(m);
-          logger.info(LogMarker.DM_VIEWS, LocalizedMessage.create(
-              LocalizedStrings.GroupMembershipService_MEMBERSHIP_PROCESSING_DEPARTING_MEMBER__0_, m));
-          if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-            logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: expiring suspect member <{}>", m);
-          }
-    logger.info(LogMarker.DM_VIEWS, LocalizedMessage.create(
-        LocalizedStrings.GroupMembershipService_MEMBERSHIP_FINISHED_VIEW_PROCESSING_VIEWID___0, Long.valueOf(newViewId)));
-      directChannel = new DirectChannel(this, dcReceiver, config, null);
+      directChannel = new DirectChannel(this, dcReceiver, config);
-   * Remove a member, or queue a startup operation to do so
-   * @param dm the member to shun
-   * @param crashed true if crashed
-   * @param reason the reason, esp. if crashed
-   */
-  protected void handleOrDeferRemove(InternalDistributedMember dm,
-      boolean crashed, String reason) {
-    synchronized(startupLock) {
-      if (!processingEvents) {
-        startupMessages.add(new StartupEvent(dm, crashed, reason));
-        return;
-      }
-    }
-    removeMember(dm, crashed, reason);
-  }
-  
-  /**
-    if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-      logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: dispatching uplevel departure event for < {} >", dm);
-    }
-    
-   * Automatic removal of a member (for internal
-   * use only).  Write-locks {@link #latestViewLock} and then deletes
-   * the member.
-   * 
-   * @param dm
-   * @param crashed
-   * @param reason
-   */
-  protected void removeMember(InternalDistributedMember dm,
-      boolean crashed, String reason)
-  {
-    if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-      StringBuffer sb = new StringBuffer(200);
-      sb.append("Membership: removing <")
-         .append(dm)
-         .append(">; crashed = ")
-         .append(crashed)
-         .append("; reason = ");
-      if (reason != null && (reason.indexOf("NoSuchMemberException") >= 0)) {
-        sb.append("tcp/ip connections closed");
-      }
-      else {
-        sb.append(reason);
-      }
-      logger.trace(LogMarker.DISTRIBUTION_VIEWS, sb);
-    }
-    latestViewLock.writeLock().lock();
-    try {
-      removeWithViewLock(dm, crashed, reason);
-    } finally {
-      latestViewLock.writeLock().unlock();
-    }
-  }
-  
- 
-  /**
-  protected void handleOrDeferSurpriseConnect(InternalDistributedMember member,
-      Stub stub) {
+  protected void handleOrDeferSurpriseConnect(InternalDistributedMember member) {
+    Stub stub = new Stub(member.getInetAddress(), member.getDirectChannelPort(), member.getVmViewId());
-        logger.warn("attempt to add a surprise member that has not yet joined the distributed system: " + member, new Exception("stack trace"));
+        logger.warn("adding a surprise member that has not yet joined the distributed system: " + member, new Exception("stack trace"));
-      if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-        logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: Received message from surprise member: <{}>.  My view number is {} it is {}", 
-            member, latestView.getViewId(), member.getVmViewId());
-      }
-
-        if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-          logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: new member during shutdown ignored: <{}>", member); 
-        }
-
-        if (logger.isTraceEnabled(LogMarker.DM_VIEWS)) {
-          logger.trace(LogMarker.DM_VIEWS, "Membership: Processing surprise addition <{}>", member);
-        }
-
-      listener.newMemberConnected(member, s);
+      listener.newMemberConnected(member);
-      if (logger.isTraceEnabled(LogMarker.DM_VIEWS)) {
-        logger.trace(LogMarker.DM_VIEWS, "Membership: queuing new view for processing, id = {}, view = {}", 
-            newId, newView);
-      }
-    else if (o.isDepartureEvent()) { // departure
-      removeMember(o.member, o.crashed, o.reason);
-    }
-    else if (o.isConnect()) { // connect
+    else if (o.isSurpriseConnect()) { // connect
+  /**
+   * for testing we need to validate the startup event list
+   */
+  public List<StartupEvent> getStartupEvents() {
+    return this.startupMessages;
+  }
-  public void postConnect()
-  {
-    if (channelPause > 0) {
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.GroupMembershipService_MEMBERSHIP_PAUSING_TO_ALLOW_OTHER_CONCURRENT_PROCESSES_TO_JOIN_THE_DISTRIBUTED_SYSTEM));
-      try {
-        Thread.sleep(channelPause);
-      }
-      catch (InterruptedException ie) {
-        Thread.currentThread().interrupt();
-      }
-      channelPause = 0;
-    }
+  public void postConnect() {
-  private Set<InternalDistributedMember> directChannelSend(InternalDistributedMember[] destinations,
+  protected Set<InternalDistributedMember> directChannelSend(InternalDistributedMember[] destinations,
-      // no alerts while shutting down - this can cause threads to hang
+      // no admin messages while shutting down - this can cause threads to hang
-          if (idm.getInetAddress().equals(s.getInetAddress())
+          if (GMSUtil.compareAddresses(idm.getInetAddress(), s.getInetAddress()) == 0
-    if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS))
-      logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: destroying < {} >", member);
-  public Stub getDirectChannel()
-  {
-    Stub result;
-    latestViewLock.readLock().lock();
-    try {
-      result = (Stub)memberToStubMap.get(address);
-    } finally {
-      latestViewLock.readLock().unlock();
-    }
-    return result;
-  }
-
-      if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
-        logger.debug("Membership: no longer shunning <  {} >", m);
-      }
-  /**
-   * returns the shunned member shunset interval, in milliseconds
-   */
-  public int getShunnedMemberTimeout() {
-    return SHUNNED_SUNSET * 1000;
-  }
-  
-
-      if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS))
-        logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: added shunned member < {} >", m);
-   * Set thread-local data for hydra
-   */
-  public void setThreadLocalData(Object data) {
-    Map dataMap = (Map)data;
-  }
-  
-  /**
+  /**
+   * for mock testing this allows insertion of a DirectChannel mock
+   */
+  protected void setDirectChannel(DirectChannel dc) {
+    this.directChannel = dc;
+    this.tcpDisabled = false;
+  }
+  
+  // TODO remove this overly complex method and replace its use with
+  // waitForViewChange using the remote member's view ID
-      // ARB: wait for hardcoded 1000 ms for latch to open.
-      // if-stmt precondition: currentLatch is non-null
-      if (logger.isInfoEnabled()) {
-        logger.info("GroupMembershipService.beSick invoked for {} - simulating sickness", this.address);
-      }
+      logger.info("GroupMembershipService.beSick invoked for {} - simulating sickness", this.address);
-      if (logger.isDebugEnabled()) {
-        logger.debug("GroupMembershipService.playDead invoked for {}", this.address);
-      }
+      logger.info("GroupMembershipService.playDead invoked for {}", this.address);
-      if (logger.isDebugEnabled()) {
-        logger.debug("GroupMembershipService.beHealthy invoked for {} - recovering health now", this.address);
-      }
+      logger.info("GroupMembershipService.beHealthy invoked for {} - recovering health now", this.address);
-  @Override
-  public void setSecurityLogWriter(InternalLogWriter writer) {
-    Services.setSecurityLogWriter(writer);
-  }
-
-     * @param initialCapacity The initial capacity.
-     * @param loadFactor The load factor
-     * @param maximumNumberOfEntries The maximum number of allowed entries
-     */
-    public BoundedLinkedHashMap(int initialCapacity, float loadFactor, int maximumNumberOfEntries) {
-      super(initialCapacity, loadFactor);
-      this._maximumNumberOfEntries = maximumNumberOfEntries;
-    }
-
-    /**
-     * Constructor.
-     *
-     * @param initialCapacity The initial capacity.
-     * @param maximumNumberOfEntries The maximum number of allowed entries
-     */
-    public BoundedLinkedHashMap(int initialCapacity, int maximumNumberOfEntries) {
-      super(initialCapacity);
-      this._maximumNumberOfEntries = maximumNumberOfEntries;
-    }
-
-    /**
-     * Constructor.
-     *
-    /**
-     * Returns the maximum number of entries.
-     * @return the maximum number of entries
-     */
-    public int getMaximumNumberOfEntries(){
-      return this._maximumNumberOfEntries;
-    }
-

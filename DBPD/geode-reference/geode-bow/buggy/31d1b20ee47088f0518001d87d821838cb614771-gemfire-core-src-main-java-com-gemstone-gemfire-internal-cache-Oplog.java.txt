Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

-import com.gemstone.gemfire.internal.InternalDataSerializer.Sendable;
+import com.gemstone.gemfire.internal.Sendable;
+import com.gemstone.gemfire.internal.cache.DiskEntry.Helper.Flushable;
+import com.gemstone.gemfire.internal.cache.DiskEntry.Helper.ValueWrapper;
+import com.gemstone.gemfire.internal.offheap.MemoryChunkWithRefCount;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
-public final class Oplog implements CompactableOplog {
+public final class Oplog implements CompactableOplog, Flushable {
+  final ByteBuffer[] bbArray = new ByteBuffer[2];
-  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, byte[] value, byte userBits, boolean notToUseUserBits)
-      throws IOException {
-    int len = value != null ? value.length : 0;
-    initOpState(opCode, dr, entry, value, len, userBits, notToUseUserBits);
-  }
-
-  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits,
+  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
-    this.opState.initialize(opCode, dr, entry, value, valueLength, userBits, notToUseUserBits);
+    this.opState.initialize(opCode, dr, entry, value, userBits, notToUseUserBits);
-  private byte calcUserBits(byte[] value, boolean isSerializedObject) {
-    byte userBits = 0x0;
-
-    if (isSerializedObject) {
-      if (value == DiskEntry.INVALID_BYTES) {
-        // its the invalid token
-        userBits = EntryBits.setInvalid(userBits, true);
-      } else if (value == DiskEntry.LOCAL_INVALID_BYTES) {
-        // its the local-invalid token
-        userBits = EntryBits.setLocalInvalid(userBits, true);
-      } else if (value == DiskEntry.TOMBSTONE_BYTES) {
-        // its the tombstone token
-        userBits = EntryBits.setTombstone(userBits, true);
-      } else {
-        if (value == null) {
-          throw new IllegalStateException("userBits==1 and value is null");
-        } else if (value.length == 0) {
-          throw new IllegalStateException("userBits==1 and value is zero length");
-        }
-        userBits = EntryBits.setSerialized(userBits, true);
-      }
-    }
-    return userBits;
+  private byte calcUserBits(ValueWrapper vw) {
+    return vw.getUserBits();
-   * @param isSerializedObject
-   *          boolean indicating whether the byte array is a serialized value or
-   *          not Do the bytes in <code>value</code> contain a serialized object
-   *          (or an actually <code>byte</code> array)?
-  public final void create(LocalRegion region, DiskEntry entry, byte[] value, boolean isSerializedObject, boolean async) {
+  public final void create(LocalRegion region, DiskEntry entry, ValueWrapper value, boolean async) {
-      getOplogSet().getChild().create(region, entry, value, isSerializedObject, async);
+      getOplogSet().getChild().create(region, entry, value, async);
-        byte userBits = calcUserBits(value, isSerializedObject);
+        byte userBits = calcUserBits(value);
-  private void basicCreate(DiskRegion dr, DiskEntry entry, byte[] value, byte userBits, boolean async) throws IOException,
+  private void basicCreate(DiskRegion dr, DiskEntry entry, ValueWrapper value, byte userBits, boolean async) throws IOException,
-          id.setValueLength(value.length);
+          id.setValueLength(value.getLength());
-              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, (value != null ? value.length : 0),
-              baToString(value), dr.getId(), tag, getOplogId());
+              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, (value != null ? value.getLength() : 0),
+              value.getBytesAsString(), dr.getId(), tag, getOplogId());
+      this.krf.dos.flush();
+      this.krf.fos.getChannel().force(true);
+
-      throw new DiskAccessException("Fail to close krf file " + this.krf.f, e, getParent());
+      if (getParent().getDiskAccessException() == null) {
+        throw new DiskAccessException("Fail to close krf file " + this.krf.f, e, getParent());
+      } else {
+        logger.info("Fail to close krf file " + this.krf.f+", but a DiskAccessException happened ealier", getParent().getDiskAccessException());
+      }
-    Object value = entry._getValueUse(dr, true); // OFFHEAP for now copy into
-                                                 // heap CD; todo optimize by
-                                                 // keeping offheap for life of
-                                                 // wrapper
+    SimpleMemoryAllocatorImpl.skipRefCountTracking();
+    // TODO OFFHEAP: no need to retain. We just use it while we have the RegionEntry synced.
+    @Retained @Released Object value = entry._getValueRetain(dr, true);
+    SimpleMemoryAllocatorImpl.unskipRefCountTracking();
-        userBits = EntryBits.setSerialized(userBits, true);
-        proxy.fillSerializedValue(wrapper, userBits);
+        if (proxy instanceof StoredObject) {
+          @Released StoredObject ohproxy = (StoredObject) proxy;
+          try {
+            ohproxy.fillSerializedValue(wrapper, userBits);
+          } finally {
+            OffHeapHelper.releaseWithNoTracking(ohproxy);
+          }
+        } else {
+          userBits = EntryBits.setSerialized(userBits, true);
+          proxy.fillSerializedValue(wrapper, userBits);
+        }
-   * @param isSerializedObject
-   *          Do the bytes in <code>value</code> contain a serialized object (or
-   *          an actually <code>byte</code> array)?
-  public final void modify(LocalRegion region, DiskEntry entry, byte[] value, boolean isSerializedObject, boolean async) {
+  public final void modify(LocalRegion region, DiskEntry entry, ValueWrapper value, boolean async) {
-      getOplogSet().getChild().modify(region, entry, value, isSerializedObject, async);
+      getOplogSet().getChild().modify(region, entry, value, async);
-        byte userBits = calcUserBits(value, isSerializedObject);
+        byte userBits = calcUserBits(value);
-        int valueLen = value != null ? value.length : 0;
-        basicModify(region.getDiskRegion(), entry, value, valueLen, userBits, async, false);
+        basicModify(region.getDiskRegion(), entry, value, userBits, async, false);
-      byte userBits = calcUserBits(value, isSerializedObject);
+      ValueWrapper vw = new DiskEntry.Helper.ByteArrayValueWrapper(isSerializedObject, value);
+      byte userBits = calcUserBits(vw);
-      int valueLen = value != null ? value.length : 0;
-      basicModify(drv, entry, value, valueLen, userBits, false, false);
+      basicModify(drv, entry, vw, userBits, false, false);
-  private final void copyForwardModifyForCompact(DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits) {
+  private final void copyForwardModifyForCompact(DiskRegionView dr, DiskEntry entry, BytesAndBitsForCompactor wrapper) {
-      getOplogSet().getChild().copyForwardModifyForCompact(dr, entry, value, valueLength, userBits);
+      getOplogSet().getChild().copyForwardModifyForCompact(dr, entry, wrapper);
+        // TODO: compaction needs to get version?
+        byte userBits = wrapper.getBits();
+        ValueWrapper vw;
+        if (wrapper.getDataChunk() != null) {
+          vw = new DiskEntry.Helper.ChunkValueWrapper(wrapper.getDataChunk());
+        } else {
+          vw = new DiskEntry.Helper.CompactorValueWrapper(wrapper.getBytes(), wrapper.getValidLength());
+        }
-        basicModify(dr, entry, value, valueLength, userBits, true, true);
+        basicModify(dr, entry, vw, userBits, true, true);
+        if (wrapper.getDataChunk() != null) {
+          wrapper.setChunkData(null, (byte) 0);
+        }
-  private void basicModify(DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits, boolean async,
+  private void basicModify(DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits, boolean async,
-        initOpState(OPLOG_MOD_ENTRY_1ID, dr, entry, value, valueLength, userBits, false);
+        initOpState(OPLOG_MOD_ENTRY_1ID, dr, entry, value, userBits, false);
-              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, valueLength, baToString(value, valueLength),
+              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, value.getLength(), value.getBytesAsString(),
-            id.setValueLength(valueLength);
+            id.setValueLength(value.getLength());
-      getOplogSet().getChild().basicModify(dr, entry, value, valueLength, userBits, async, calledByCompactor);
+      getOplogSet().getChild().basicModify(dr, entry, value, userBits, async, calledByCompactor);
+  
+  @Override
+  public void flush() throws IOException {
+    flushAllNoSync(false);
+  }
+
+  @Override
+  public void flush(ByteBuffer b1, ByteBuffer b2) throws IOException {
+    if (b1 == this.drf.writeBuf) {
+      flush(this.drf, b1, b2);
+      flush(this.crf, false);
+    } else {
+      flush(this.drf, false);
+      flush(this.crf, b1, b2);
+    }
+  }
+  private final void flush(OplogFile olf, ByteBuffer b1, ByteBuffer b2) throws IOException {
+    try {
+      synchronized (this.lock/* olf */) {
+        if (olf.RAFClosed) {
+          return;
+        }
+        this.bbArray[0] = b1;
+        this.bbArray[1] = b2;
+        b1.flip();
+        long flushed = olf.channel.write(this.bbArray);
+        this.bbArray[0] = null;
+        this.bbArray[1] = null;
+        // update bytesFlushed after entire writeBuffer is flushed to fix bug 41201
+        olf.bytesFlushed += flushed;
+        b1.clear();
+      }
+    } catch (ClosedChannelException ignore) {
+      // It is possible for a channel to be closed when our code does not
+      // explicitly call channel.close (when we will set RAFclosed).
+      // This can happen when a thread is doing an io op and is interrupted.
+      // That thread will see ClosedByInterruptException but it will also
+      // close the channel and then we will see ClosedChannelException.
+    }
+  }
+  
-                  byte[] valueBytes = wrapper.getBytes();
-                  int length = wrapper.getValidLength();
-                  byte userBits = wrapper.getBits();
-                  // TODO: compaction needs to get version?
-                    // @todo: Is this even possible? Perhaps I should just
-                    // assert here
+                    // @todo: Is this even possible? Perhaps I should just assert here
+                    } else if (wrapper.getDataChunk() != null) {
+                      wrapper.setChunkData(null, (byte) 0);
-                  getOplogSet().getChild().copyForwardModifyForCompact(dr, de, valueBytes, length, userBits);
-                  // the did's oplogId will now be set to the current active
-                  // oplog
+                  getOplogSet().getChild().copyForwardModifyForCompact(dr, de, wrapper);
+                  // the did's oplogId will now be set to the current active oplog
-    private byte[] value;
-    private int valueLength;
+    private ValueWrapper value;
-      sb.append(" opcode=").append(this.opCode).append(" len=").append(this.valueLength).append(" vb=").append(
-          baToString(this.value, this.valueLength));
+      sb.append(" opcode=").append(this.opCode).append(" len=").append(this.value.getLength()).append(" vb=").append(this.value.getBytesAsString());
+    
+    private final void write(OplogFile olf, ValueWrapper vw) throws IOException {
+      vw.sendTo(olf.writeBuf, Oplog.this);
+    }
-      this.value = rvvBytes;
+      this.value = new DiskEntry.Helper.ByteArrayValueWrapper(true, rvvBytes);
-      this.valueLength = rvvBytes.length;
-      this.value = valueBytes;
-      this.valueLength = this.value.length;
-      if (this.userBits == 1 && this.valueLength == 0) {
+      this.value = new DiskEntry.Helper.CompactorValueWrapper(valueBytes, valueBytes.length);
+      if (this.userBits == 1 && this.value.getLength() == 0) {
-        this.size += 4 + this.valueLength;
+        this.size += 4 + this.value.getLength();
-    public void initialize(byte opCode, DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits,
+    public void initialize(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
-      this.valueLength = valueLength;
-      if (this.userBits == 1 && this.valueLength == 0) {
+      if (this.userBits == 1 && this.value.getLength() == 0) {
-        this.size += 4 + this.valueLength;
+        this.size += 4 + this.value.getLength();
-        write(olf, this.value, this.valueLength);
-        bytesWritten += this.valueLength;
+        write(olf, this.value);
+        bytesWritten += this.value.getLength();
-          writeInt(olf, this.valueLength);
+          int len = this.value.getLength();
+          writeInt(olf, len);
-          if (this.valueLength > 0) {
-            write(olf, this.value, this.valueLength);
-            bytesWritten += this.valueLength;
+          if (len > 0) {
+            write(olf, this.value);
+            bytesWritten += len;
-    public Object _getValueUse(RegionEntryContext context, boolean decompress) {
+    public void handleValueOverflow(RegionEntryContext context) {throw new IllegalStateException();}
+
+    @Override
+    public void afterValueOverflow(RegionEntryContext context) {throw new IllegalStateException();}
+    @Override
+    public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate) { throw new IllegalStateException("Should never be called");  }
+
+    @Override
+    public Object _getValueRetain(RegionEntryContext context, boolean decompress) {
+    @Override
+    public Object getValueRetain(RegionEntryContext context) {
+      return null;
+    }
+
+    @Override
-
+    @Override
+    public boolean isMarkedForEviction() {
+      // TODO Auto-generated method stub
+      return false;
+    }
+    @Override
+    public void setMarkedForEviction() {
+      // TODO Auto-generated method stub
+    }
+    @Override
+    public void clearMarkedForEviction() {
+      // TODO Auto-generated method stub
+    }
+
+    @Override
+    public Object prepareValueForCache(RegionEntryContext r, Object val,
+        EntryEventImpl event, boolean isEntryUpdate) {
+      throw new IllegalStateException("Should never be called");
+    }
+    

GEODE-7152: Send alert messages using executor

AlertAppender uses a ThreadLocal to prevent recursive calls from
actually doing anything. However, a recent upgrade to our log4j
dependencies seems to have changed the behavior such that log4j refuses
to invoke doAppend if the thread is currently handling a sendAlert
initiated from doAppend. To fix this bug, sendAlert must be async.

+import static org.apache.geode.internal.logging.LoggingExecutors.newFixedThreadPool;
+
+import java.util.concurrent.ExecutorService;
+  private final ExecutorService executor;
-        new AlertListenerMessageFactory());
+        new AlertListenerMessageFactory(),
+        newFixedThreadPool("AlertingMessaging Processor", true, 1));
-      final AlertListenerMessageFactory alertListenerMessageFactory) {
+      final AlertListenerMessageFactory alertListenerMessageFactory,
+      final ExecutorService executor) {
+    this.executor = executor;
-    try {
-      String connectionName = system.getConfig().getName();
+    executor.submit(() -> {
+      try {
+        String connectionName = system.getConfig().getName();
-      AlertListenerMessage message =
-          alertListenerMessageFactory.createAlertListenerMessage(member, alertLevel, timestamp,
-              connectionName, threadName, threadId, formattedMessage, stackTrace);
+        AlertListenerMessage message =
+            alertListenerMessageFactory.createAlertListenerMessage(member, alertLevel, timestamp,
+                connectionName, threadName, threadId, formattedMessage, stackTrace);
-      if (member.equals(system.getDistributedMember())) {
-        // process in local member
-        logger.debug("Processing local alert message: {}, {}, {}, {}, {}, {}, [{}], [{}].",
-            member, alertLevel, timestamp, connectionName, threadName, threadId, formattedMessage,
-            stackTrace);
-        processAlertListenerMessage(message);
+        if (member.equals(system.getDistributedMember())) {
+          // process in local member
+          logger.debug("Processing local alert message: {}, {}, {}, {}, {}, {}, [{}], [{}].",
+              member, alertLevel, timestamp, connectionName, threadName, threadId, formattedMessage,
+              stackTrace);
+          processAlertListenerMessage(message);
-      } else {
-        // send to remote member
-        logger.debug("Sending remote alert message: {}, {}, {}, {}, {}, {}, [{}], [{}].",
-            member, alertLevel, timestamp, connectionName, threadName, threadId, formattedMessage,
-            stackTrace);
-        dm.putOutgoing(message);
+        } else {
+          // send to remote member
+          logger.debug("Sending remote alert message: {}, {}, {}, {}, {}, {}, [{}], [{}].",
+              member, alertLevel, timestamp, connectionName, threadName, threadId, formattedMessage,
+              stackTrace);
+          dm.putOutgoing(message);
+        }
+      } catch (ReenteredConnectException ignore) {
+        // OK. We can't send to this recipient because we're in the middle of
+        // trying to connect to it.
-    } catch (ReenteredConnectException ignore) {
-      // OK. We can't send to this recipient because we're in the middle of
-      // trying to connect to it.
-    }
+    });
-    // nothing
+    executor.shutdownNow();

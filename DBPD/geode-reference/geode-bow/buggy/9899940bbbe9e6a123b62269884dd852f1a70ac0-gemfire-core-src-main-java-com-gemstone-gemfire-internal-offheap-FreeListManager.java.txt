GEODE-831: unit test FreeListManager

* moved state from SimpleMemoryAllocatorImpl to FreeListManager
* refactored and cleaned up release/free code
* Removed ChunkType and ChunkFactory. They were no longer used by GemFire and complicated the code
* removed BATCH_SIZE; it was an expirement that was not longer used
* combined Chunk and GemFireChunk to the new ObjectChunk class

-import com.gemstone.gemfire.internal.offheap.MemoryBlock.State;
-  final private AtomicReferenceArray<SyncChunkStack> tinyFreeLists = new AtomicReferenceArray<SyncChunkStack>(SimpleMemoryAllocatorImpl.TINY_FREE_LIST_COUNT);
+  /** The MemoryChunks that this allocator is managing by allocating smaller chunks of them.
+   * The contents of this array never change.
+   */
+  private final AddressableMemoryChunk[] slabs;
+  private final long totalSlabSize;
+  
+  final private AtomicReferenceArray<SyncChunkStack> tinyFreeLists = new AtomicReferenceArray<SyncChunkStack>(TINY_FREE_LIST_COUNT);
-  private final ConcurrentSkipListSet<Chunk> hugeChunkSet = new ConcurrentSkipListSet<Chunk>();
+  private final ConcurrentSkipListSet<ObjectChunk> hugeChunkSet = new ConcurrentSkipListSet<ObjectChunk>();
-    return (size-1)/SimpleMemoryAllocatorImpl.TINY_MULTIPLE;
+    return (size-1)/TINY_MULTIPLE;
-  List<Chunk> getLiveChunks() {
-    ArrayList<Chunk> result = new ArrayList<Chunk>();
-    UnsafeMemoryChunk[] slabs = this.ma.getSlabs();
+  List<ObjectChunk> getLiveChunks() {
+    ArrayList<ObjectChunk> result = new ArrayList<ObjectChunk>();
-  private void getLiveChunks(UnsafeMemoryChunk slab, List<Chunk> result) {
+  private void getLiveChunks(AddressableMemoryChunk slab, List<ObjectChunk> result) {
-    while (addr <= (slab.getMemoryAddress() + slab.getSize() - Chunk.MIN_CHUNK_SIZE)) {
+    while (addr <= (slab.getMemoryAddress() + slab.getSize() - ObjectChunk.MIN_CHUNK_SIZE)) {
-        int curChunkSize = Chunk.getSize(addr);
-        int refCount = Chunk.getRefCount(addr);
+        int curChunkSize = ObjectChunk.getSize(addr);
+        int refCount = ObjectChunk.getRefCount(addr);
-          result.add(this.ma.chunkFactory.newChunk(addr));
+          result.add(new ObjectChunk(addr));
-    return this.ma.getTotalMemory() - getUsedMemory();
+    return getTotalMemory() - getUsedMemory();
-      if (freeSpace >= Chunk.MIN_CHUNK_SIZE) {
+      if (freeSpace >= ObjectChunk.MIN_CHUNK_SIZE) {
-    for (Chunk c: this.hugeChunkSet) {
+    for (ObjectChunk c: this.hugeChunkSet) {
-  public FreeListManager(SimpleMemoryAllocatorImpl ma) {
+  public FreeListManager(SimpleMemoryAllocatorImpl ma, final AddressableMemoryChunk[] slabs) {
-    UnsafeMemoryChunk[] slabs = ma.getSlabs();
+    this.slabs = slabs;
+    long total = 0;
-      tmp[i] = new Fragment(slabs[i].getMemoryAddress(), slabs[i].getSize());
+      tmp[i] = createFragment(slabs[i].getMemoryAddress(), slabs[i].getSize());
+      total += slabs[i].getSize();
+    this.totalSlabSize = total;
-    if(ma.validateMemoryWithFill) {
-      fillFragments();
-    }
+    fillFragments();
-   * Fills all fragments with a fill used for data integrity validation.
+   * Create and return a Fragment.
+   * This method exists so that tests can override it.
+   */
+  protected Fragment createFragment(long addr, int size) {
+    return new Fragment(addr, size);
+  }
+  
+  /**
+   * Fills all fragments with a fill used for data integrity validation 
+   * if fill validation is enabled.
+    if (!this.validateMemoryWithFill) {
+      return;
+    }
-   * @param chunkType TODO
-  public Chunk allocate(int size, ChunkType chunkType) {
-    Chunk result = null;
-    {
-      assert size > 0;
-      if (chunkType == null) {
-        chunkType = GemFireChunk.TYPE;
-      }
-      result = basicAllocate(size, true, chunkType);
-      result.setDataSize(size);
-    }
-    this.ma.stats.incObjects(1);
-    int resultSize = result.getSize();
-    this.allocatedSize.addAndGet(resultSize);
-    this.ma.stats.incUsedMemory(resultSize);
-    this.ma.stats.incFreeMemory(-resultSize);
+  public ObjectChunk allocate(int size) {
+    assert size > 0;
+    
+    ObjectChunk result = basicAllocate(size, true);
+
+    result.setDataSize(size);
+    this.allocatedSize.addAndGet(result.getSize());
-    this.ma.notifyListeners();
-  private Chunk basicAllocate(int size, boolean useSlabs, ChunkType chunkType) {
+  private ObjectChunk basicAllocate(int size, boolean useSlabs) {
-      size += Chunk.OFF_HEAP_HEADER_SIZE;
+      size += ObjectChunk.OFF_HEAP_HEADER_SIZE;
-    if (size <= SimpleMemoryAllocatorImpl.MAX_TINY) {
-      return allocateTiny(size, useSlabs, chunkType);
+    if (size <= MAX_TINY) {
+      return allocateTiny(size, useSlabs);
-      return allocateHuge(size, useSlabs, chunkType);
+      return allocateHuge(size, useSlabs);
-  private Chunk allocateFromFragments(int chunkSize, ChunkType chunkType) {
+  private ObjectChunk allocateFromFragments(int chunkSize) {
-        Chunk result = allocateFromFragment(i, chunkSize, chunkType);
+        ObjectChunk result = allocateFromFragment(i, chunkSize);
-        Chunk result = allocateFromFragment(i, chunkSize, chunkType);
+        ObjectChunk result = allocateFromFragment(i, chunkSize);
-      this.ma.ooohml.outOfOffHeapMemory(failure);
+      this.ma.getOutOfOffHeapMemoryListener().outOfOffHeapMemory(failure);
-      lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " compactions=" + this.compactCount.get() + " objects=" + this.ma.stats.getObjects() + " free=" + this.ma.stats.getFreeMemory() + " fragments=" + this.ma.stats.getFragments() + " largestFragment=" + this.ma.stats.getLargestFragment() + " fragmentation=" + this.ma.stats.getFragmentation());
-      logFragmentState(lw);
-      logTinyState(lw);
-      logHugeState(lw);
+      logOffHeapState(lw, chunkSize);
+  void logOffHeapState(LogWriter lw, int chunkSize) {
+    OffHeapMemoryStats stats = this.ma.getStats();
+    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " compactions=" + this.compactCount.get() + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments=" + stats.getFragments() + " largestFragment=" + stats.getLargestFragment() + " fragmentation=" + stats.getFragmentation());
+    logFragmentState(lw);
+    logTinyState(lw);
+    logHugeState(lw);
+  }
+
-    for (Chunk c: this.hugeChunkSet) {
+    for (ObjectChunk c: this.hugeChunkSet) {
-  private final AtomicInteger compactCount = new AtomicInteger();
+  protected final AtomicInteger compactCount = new AtomicInteger();
+  /*
+   * Set this to "true" to perform data integrity checks on allocated and reused Chunks.  This may clobber 
+   * performance so turn on only when necessary.
+   */
+  final boolean validateMemoryWithFill = Boolean.getBoolean("gemfire.validateOffHeapWithFill");
+  /**
+   * Every allocated chunk smaller than TINY_MULTIPLE*TINY_FREE_LIST_COUNT will allocate a chunk of memory that is a multiple of this value.
+   * Sizes are always rounded up to the next multiple of this constant
+   * so internal fragmentation will be limited to TINY_MULTIPLE-1 bytes per allocation
+   * and on average will be TINY_MULTIPLE/2 given a random distribution of size requests.
+   * This does not account for the additional internal fragmentation caused by the off-heap header
+   * which currently is always 8 bytes.
+   */
+  public final static int TINY_MULTIPLE = Integer.getInteger("gemfire.OFF_HEAP_ALIGNMENT", 8);
+  static {
+    verifyOffHeapAlignment(TINY_MULTIPLE);
+  }
+  /**
+   * Number of free lists to keep for tiny allocations.
+   */
+  public final static int TINY_FREE_LIST_COUNT = Integer.getInteger("gemfire.OFF_HEAP_FREE_LIST_COUNT", 16384);
+  static {
+    verifyOffHeapFreeListCount(TINY_FREE_LIST_COUNT);
+  }
+  /**
+   * How many unused bytes are allowed in a huge memory allocation.
+   */
+  public final static int HUGE_MULTIPLE = 256;
+  static {
+    verifyHugeMultiple(HUGE_MULTIPLE);
+  }
+  public final static int MAX_TINY = TINY_MULTIPLE*TINY_FREE_LIST_COUNT;
-  private boolean compact(int chunkSize) {
+  boolean compact(int chunkSize) {
+    afterCompactCountFetched();
-            //System.out.println("DEBUG addr=" + addr + " size=" + Chunk.getSize(addr) + " idx="+idx + " sortedSize=" + sortedSize);
-            if (idx >= 0) {
-              throw new IllegalStateException("duplicate memory address found during compaction!");
-            }
-                int lowSize = Chunk.getSize(lowAddr);
+                int lowSize = ObjectChunk.getSize(lowAddr);
-                  Chunk.setSize(lowAddr, lowSize + Chunk.getSize(addr));
+                  ObjectChunk.setSize(lowAddr, lowSize + ObjectChunk.getSize(addr));
-              int addrSize = Chunk.getSize(addr);
+              int addrSize = ObjectChunk.getSize(addr);
-                Chunk.setSize(addr, addrSize + Chunk.getSize(highAddr));
+                ObjectChunk.setSize(addr, addrSize + ObjectChunk.getSize(highAddr));
-                  int lowSize = Chunk.getSize(lowAddr);
+                  int lowSize = ObjectChunk.getSize(lowAddr);
-                    Chunk.setSize(lowAddr, lowSize + addrSize);
+                    ObjectChunk.setSize(lowAddr, lowSize + addrSize);
-          int lowSize = Chunk.getSize(lowAddr);
+          int lowSize = ObjectChunk.getSize(lowAddr);
-            Chunk.setSize(lowAddr, lowSize + Chunk.getSize(addr));
+            ObjectChunk.setSize(lowAddr, lowSize + ObjectChunk.getSize(addr));
-          int addrSize = Chunk.getSize(addr);
-          Fragment f = new Fragment(addr, addrSize);
+          int addrSize = ObjectChunk.getSize(addr);
+          Fragment f = createFragment(addr, addrSize);
-        // Reinitialize fragments with fill pattern data
-        if(this.ma.validateMemoryWithFill) {
-          fillFragments();
-        }
+        fillFragments();
-        updateFragmentation();
+        updateFragmentation(largestFragment);
-  private void updateFragmentation() {      
-    long freeSize = this.ma.getStats().getFreeMemory();
+  /**
+   * Unit tests override this method to get better test coverage
+   */
+  protected void afterCompactCountFetched() {
+  }
+  
+  static void verifyOffHeapAlignment(int tinyMultiple) {
+    if (tinyMultiple <= 0 || (tinyMultiple & 3) != 0) {
+      throw new IllegalStateException("gemfire.OFF_HEAP_ALIGNMENT must be a multiple of 8.");
+    }
+    if (tinyMultiple > 256) {
+      // this restriction exists because of the dataSize field in the object header.
+      throw new IllegalStateException("gemfire.OFF_HEAP_ALIGNMENT must be <= 256 and a multiple of 8.");
+    }
+  }
+  static void verifyOffHeapFreeListCount(int tinyFreeListCount) {
+    if (tinyFreeListCount <= 0) {
+      throw new IllegalStateException("gemfire.OFF_HEAP_FREE_LIST_COUNT must be >= 1.");
+    }
+  }
+  static void verifyHugeMultiple(int hugeMultiple) {
+    if (hugeMultiple > 256 || hugeMultiple < 0) {
+      // this restriction exists because of the dataSize field in the object header.
+      throw new IllegalStateException("HUGE_MULTIPLE must be >= 0 and <= 256 but it was " + hugeMultiple);
+    }
+  }
+  
+  private void updateFragmentation(long largestFragment) {      
+    long freeSize = getFreeMemory();
-      long largestFragment = this.ma.getStats().getLargestFragment();
+  List<Fragment> getFragmentList() {
+    return this.fragmentList;
+  }
-      } while (diff >= Chunk.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
-      if (diff < Chunk.MIN_CHUNK_SIZE) {
-        if (diff > 0) {
-          SimpleMemoryAllocatorImpl.logger.debug("Lost memory of size {}", diff);
-        }
-        // fragment is too small to turn into a chunk
-        // TODO we need to make sure this never happens
-        // by keeping sizes rounded. I think I did this
-        // by introducing MIN_CHUNK_SIZE and by rounding
-        // the size of huge allocations.
+      } while (diff >= ObjectChunk.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
+      if (diff < ObjectChunk.MIN_CHUNK_SIZE) {
+        // If diff > 0 then that memory will be lost during compaction.
+        // This should never happen since we keep the sizes rounded
+        // based on MIN_CHUNK_SIZE.
+        assert diff == 0;
+        // The current fragment is completely allocated so just skip it.
-      Chunk.setSize(chunkAddr, diff);
+      ObjectChunk.setSize(chunkAddr, diff);
-    Chunk c = this.hugeChunkSet.pollFirst();
+    ObjectChunk c = this.hugeChunkSet.pollFirst();
-  private Chunk allocateFromFragment(final int fragIdx, final int chunkSize, ChunkType chunkType) {
+  ObjectChunk allocateFromFragment(final int fragIdx, final int chunkSize) {
-        // Try to allocate up to BATCH_SIZE more chunks from it
-        int allocSize = chunkSize * SimpleMemoryAllocatorImpl.BATCH_SIZE;
-        if (allocSize > fragmentFreeSize) {
-          allocSize = (fragmentFreeSize / chunkSize) * chunkSize;
-        }
-        int newOffset = oldOffset + allocSize;
+        int newOffset = oldOffset + chunkSize;
-        if (extraSize < Chunk.MIN_CHUNK_SIZE) {
+        if (extraSize < ObjectChunk.MIN_CHUNK_SIZE) {
-          Chunk result = this.ma.chunkFactory.newChunk(fragment.getMemoryAddress()+oldOffset, chunkSize+extraSize, chunkType);
-          allocSize -= chunkSize+extraSize;
-          oldOffset += extraSize;
-          while (allocSize > 0) {
-            oldOffset += chunkSize;
-            // we add the batch ones immediately to the freelist
-            result.readyForFree();
-            free(result.getMemoryAddress(), false);
-            result = this.ma.chunkFactory.newChunk(fragment.getMemoryAddress()+oldOffset, chunkSize, chunkType);
-            allocSize -= chunkSize;
-          }
-
-          if(this.ma.validateMemoryWithFill) {
-            result.validateFill();
-          }
-
+          ObjectChunk result = new ObjectChunk(fragment.getMemoryAddress()+oldOffset, chunkSize+extraSize);
+          checkDataIntegrity(result);
-          // TODO OFFHEAP: if batch allocations are disabled should we not call basicAllocate here?
-          // Since we know another thread did a concurrent alloc
-          // that possibly did a batch check the free list again.
-          Chunk result = basicAllocate(chunkSize, false, chunkType);
+          ObjectChunk result = basicAllocate(chunkSize, false);
-  private Chunk allocateTiny(int size, boolean useFragments, ChunkType chunkType) {
-    return basicAllocate(getNearestTinyMultiple(size), SimpleMemoryAllocatorImpl.TINY_MULTIPLE, 0, this.tinyFreeLists, useFragments, chunkType);
+  private ObjectChunk allocateTiny(int size, boolean useFragments) {
+    return basicAllocate(getNearestTinyMultiple(size), TINY_MULTIPLE, 0, this.tinyFreeLists, useFragments);
-  private Chunk basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<SyncChunkStack> freeLists, boolean useFragments, ChunkType chunkType) {
+  private ObjectChunk basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<SyncChunkStack> freeLists, boolean useFragments) {
-        Chunk result = this.ma.chunkFactory.newChunk(memAddr, chunkType);
-
-        // Data integrity check.
-        if(this.ma.validateMemoryWithFill) {          
-          result.validateFill();
-        }
-
-        result.readyForAllocation(chunkType);
+        ObjectChunk result = new ObjectChunk(memAddr);
+        checkDataIntegrity(result);
+        result.readyForAllocation();
-      return allocateFromFragments(((idx+1)*multiple)+offset, chunkType);
+      return allocateFromFragments(((idx+1)*multiple)+offset);
-  private Chunk allocateHuge(int size, boolean useFragments, ChunkType chunkType) {
+  private ObjectChunk allocateHuge(int size, boolean useFragments) {
-    Chunk sizeHolder = new FakeChunk(size);
-    NavigableSet<Chunk> ts = this.hugeChunkSet.tailSet(sizeHolder);
-    Chunk result = ts.pollFirst();
+    ObjectChunk sizeHolder = new FakeChunk(size);
+    NavigableSet<ObjectChunk> ts = this.hugeChunkSet.tailSet(sizeHolder);
+    ObjectChunk result = ts.pollFirst();
-      if (result.getSize() - (SimpleMemoryAllocatorImpl.HUGE_MULTIPLE - Chunk.OFF_HEAP_HEADER_SIZE) < size) {
+      if (result.getSize() - (HUGE_MULTIPLE - ObjectChunk.OFF_HEAP_HEADER_SIZE) < size) {
-
-        // Data integrity check.
-        if(this.ma.validateMemoryWithFill) {          
-          result.validateFill();
-        }
-        if (chunkType.getSrcType() != Chunk.getSrcType(result.getMemoryAddress())) {
-          // The java wrapper class that was cached in the huge chunk list is the wrong type.
-          // So allocate a new one and garbage collect the old one.
-          result = this.ma.chunkFactory.newChunk(result.getMemoryAddress(), chunkType);
-        }
-        result.readyForAllocation(chunkType);
+        checkDataIntegrity(result);
+        result.readyForAllocation();
-      return allocateFromFragments(round(SimpleMemoryAllocatorImpl.TINY_MULTIPLE, size), chunkType);
+      return allocateFromFragments(round(TINY_MULTIPLE, size));
+  private void checkDataIntegrity(ObjectChunk data) {
+    if (this.validateMemoryWithFill) {
+      data.validateFill();
+    }
+  }
-  private static class FakeChunk extends Chunk {
+  private static class FakeChunk extends ObjectChunk {
+    if (this.validateMemoryWithFill) {
+      ObjectChunk.fill(addr);
+    }
+    
-    int cSize = Chunk.getSize(addr);
+    int cSize = ObjectChunk.getSize(addr);
-      this.ma.stats.incObjects(-1);
+      OffHeapMemoryStats stats = this.ma.getStats();
+      stats.incObjects(-1);
-      this.ma.stats.incUsedMemory(-cSize);
-      this.ma.stats.incFreeMemory(cSize);
+      stats.incUsedMemory(-cSize);
+      stats.incFreeMemory(cSize);
-    if (cSize <= SimpleMemoryAllocatorImpl.MAX_TINY) {
+    if (cSize <= MAX_TINY) {
-      clq = new SyncChunkStack();
+      clq = createFreeListForEmptySlot(freeLists, idx);
-
+  /**
+   * Tests override this method to simulate concurrent modification
+   */
+  protected SyncChunkStack createFreeListForEmptySlot(AtomicReferenceArray<SyncChunkStack> freeLists, int idx) {
+    return new SyncChunkStack();
+  }
+  
-    this.hugeChunkSet.add(this.ma.chunkFactory.newChunk(addr)); // TODO make this a collection of longs
+    this.hugeChunkSet.add(new ObjectChunk(addr)); // TODO make this a collection of longs
-  private void addBlocksFromChunks(Collection<Chunk> src, List<MemoryBlock> dest) {
-    for (Chunk chunk : src) {
+  private void addBlocksFromChunks(Collection<ObjectChunk> src, List<MemoryBlock> dest) {
+    for (ObjectChunk chunk : src) {
-        addr = Chunk.getNext(addr);
+        addr = ObjectChunk.getNext(addr);
-      return Chunk.getSize(address);
+      return ObjectChunk.getSize(address);
-    public ChunkType getChunkType() {
-      return null;
-    }
-    
-    @Override
+
+  long getTotalMemory() {
+    return this.totalSlabSize;
+  }
+  
+  void freeSlabs() {
+    for (int i=0; i < slabs.length; i++) {
+      slabs[i].release();
+    }
+  }
+  /**
+   * newSlabs will be non-null in unit tests.
+   * If the unit test gave us a different array
+   * of slabs then something is wrong because we
+   * are trying to reuse the old already allocated
+   * array which means that the new one will never
+   * be used. Note that this code does not bother
+   * comparing the contents of the arrays.
+   */
+  boolean okToReuse(AddressableMemoryChunk[] newSlabs) {
+    return newSlabs == null || newSlabs == this.slabs;
+  }
+  
+  int getLargestSlabSize() {
+    return this.slabs[0].getSize();
+  }
+  int findSlab(long addr) {
+    for (int i=0; i < this.slabs.length; i++) {
+      AddressableMemoryChunk slab = this.slabs[i];
+      long slabAddr = slab.getMemoryAddress();
+      if (addr >= slabAddr) {
+        if (addr < slabAddr + slab.getSize()) {
+          return i;
+        }
+      }
+    }
+    throw new IllegalStateException("could not find a slab for addr " + addr);
+  }
+  void getSlabDescriptions(StringBuilder sb) {
+    for (int i=0; i < slabs.length; i++) {
+      long startAddr = slabs[i].getMemoryAddress();
+      long endAddr = startAddr + slabs[i].getSize();
+      sb.append("[").append(Long.toString(startAddr, 16)).append("..").append(Long.toString(endAddr, 16)).append("] ");
+    }
+  }
+  boolean validateAddressAndSizeWithinSlab(long addr, int size) {
+    for (int i=0; i < slabs.length; i++) {
+      if (slabs[i].getMemoryAddress() <= addr && addr < (slabs[i].getMemoryAddress() + slabs[i].getSize())) {
+        // validate addr + size is within the same slab
+        if (size != -1) { // skip this check if size is -1
+          if (!(slabs[i].getMemoryAddress() <= (addr+size-1) && (addr+size-1) < (slabs[i].getMemoryAddress() + slabs[i].getSize()))) {
+            throw new IllegalStateException(" address 0x" + Long.toString(addr+size-1, 16) + " does not address the original slab memory");
+          }
+        }
+        return true;
+      }
+    }
+    return false;
+  }
+  

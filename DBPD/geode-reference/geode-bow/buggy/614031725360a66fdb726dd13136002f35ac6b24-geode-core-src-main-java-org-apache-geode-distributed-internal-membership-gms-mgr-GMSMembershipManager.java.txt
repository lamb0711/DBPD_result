GEODE-2865 data loss in initial-image replication with multicast

The state-flush algorithm relies on MembershipManager.waitForMessageState()
to ensure that all operations have been received and applied to the cache
prior to state replication starting.  For multicast there was a flaw in
the algorithm caused by two things: 1) cache operations were being sent
out-of-band, allowing them to be processed out of order with the state-
flush message, and 2) JGroupsMessenger was only waiting for the messages
to be dispatched by NAKACK2, which isn't necessarily the same as being
dispatched to the DistributionManager Executor that processes the message.

Cache operation messages are now sent in-band.

JGroupsMessenger now tracks NAKACK2 (multicast) sequence numbers of
messages dispatched to the DistributionManager and this is used in
waitForMessageState() to make sure the messages have been queued.
If multicast is enabled we now flush the serial executor to in
waitForMessageState() to make sure that all messages queued in it have
been applied to the region.

+
+    if (services.getConfig().getTransport().isMcastEnabled()
+        && !services.getConfig().getDistributionConfig().getDisableTcp()) {
+      // GEODE-2865: wait for scheduled multicast messages to be applied to the cache
+      waitForSerialMessageProcessing((InternalDistributedMember) otherMember);
+    }
-        // run a message through the member's serial execution queue to ensure that all of its
-        // current messages have been processed
-        OverflowQueueWithDMStats serialQueue = listener.getDM().getSerialQueue(idm);
-        if (serialQueue != null) {
-          final boolean done[] = new boolean[1];
-          final FlushingMessage msg = new FlushingMessage(done);
-          serialQueue.add(new SizeableRunnable(100) {
-            public void run() {
-              msg.invoke();
-            }
-
-            public String toString() {
-              return "Processing fake message";
-            }
-          });
-          synchronized (done) {
-            while (!done[0]) {
-              done.wait(10);
-            }
-            result = true;
-          }
+        if (waitForSerialMessageProcessing(idm)) {
+          result = true;
+  /**
+   * wait for serial executor messages from the given member to be processed
+   */
+  public boolean waitForSerialMessageProcessing(InternalDistributedMember idm)
+      throws InterruptedException {
+    // run a message through the member's serial execution queue to ensure that all of its
+    // current messages have been processed
+    boolean result = false;
+    OverflowQueueWithDMStats serialQueue = listener.getDM().getSerialQueue(idm);
+    if (serialQueue != null) {
+      final boolean done[] = new boolean[1];
+      final FlushingMessage msg = new FlushingMessage(done);
+      serialQueue.add(new SizeableRunnable(100) {
+        public void run() {
+          msg.invoke();
+        }
+
+        public String toString() {
+          return "Processing fake message";
+        }
+      });
+      synchronized (done) {
+        while (!done[0]) {
+          done.wait(10);
+        }
+        result = true;
+      }
+    }
+    return result;
+  }
+

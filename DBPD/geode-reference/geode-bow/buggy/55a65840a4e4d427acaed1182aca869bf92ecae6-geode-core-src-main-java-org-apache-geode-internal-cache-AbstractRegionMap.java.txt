GEODE-1885: fix infinite loop

The previous fix for GEODE-1885 introduced a hang on off-heap regions.
If a concurrent close/destroy of the region happens while other threads
are modifying it then the thread doing the modification can get stuck
in a hot loop that never terminates.
The hot loop is in AbstractRegionMap when it tests the existing
region entry it finds to see if it can be modified.
If the region entry has a value that says it is removed
then the operation spins around and tries again.
It expects the thread that marked it as being removed
to also remove it from the map.
The previous fix for GEODE-1885 can cause a remove to not happen.
So this fix does two things:
 1. On retry remove the existing removed region entry from the map.
 2. putEntryIfAbsent now only releases the current entry if it has an off-heap reference.
    This prevents an infinite loop that was caused by the current thread who just added
    a new entry with REMOVE_PHASE1 from releasing it (changing it to REMOVE_PHASE2)
    because it sees that the region is closed/destroyed.

+import org.apache.geode.internal.offheap.StoredObject;
-    RegionEntry value = (RegionEntry)_getMap().putIfAbsent(key, re);
-    if (value == null && (re instanceof OffHeapRegionEntry) 
+    RegionEntry oldRe = (RegionEntry)_getMap().putIfAbsent(key, re);
+    if (oldRe == null && (re instanceof OffHeapRegionEntry) 
-      if (_getMap().remove(key, re)) {
-        ((OffHeapRegionEntry)re).release();
+      Object v = re._getValue();
+      if (v != Token.REMOVED_PHASE1 && v != Token.REMOVED_PHASE2
+          && v instanceof StoredObject && ((StoredObject)v).hasRefCount()) {
+        if (_getMap().remove(key, re)) {
+          ((OffHeapRegionEntry)re).release();
+        }
-    return value;
+    return oldRe;
-            oldRe = putEntryIfAbsent(key, newRe);
-            if (oldRe != null) {
-              if (_isOwnerALocalRegion()) {
-                _getOwner().getCachePerfStats().incRetries();
-              }
+            if (_isOwnerALocalRegion()) {
+              _getOwner().getCachePerfStats().incRetries();
+            _getMap().remove(key, oldRe);
+            oldRe = putEntryIfAbsent(key, newRe);
+                owner.getCachePerfStats().incRetries();
+                _getMap().remove(key, oldRe);
-                if (oldRe != null) {
-                  owner.getCachePerfStats().incRetries();
-                }
+                        owner.getCachePerfStats().incRetries();
+                        _getMap().remove(event.getKey(), oldRe);
-                        if (oldRe != null) {
-                          owner.getCachePerfStats().incRetries();
-                        }
+                    _getMap().remove(event.getKey(), re);
+                    owner.getCachePerfStats().incRetries();
+                  owner.getCachePerfStats().incRetries();
+                  _getMap().remove(key, oldRe);
-                  if (oldRe != null) {
-                    owner.getCachePerfStats().incRetries();
-                  }
+                      owner.getCachePerfStats().incRetries();
+                      _getMap().remove(event.getKey(), oldRe);
-                      if (oldRe != null) {
-                        owner.getCachePerfStats().incRetries();
-                      }
+                    owner.getCachePerfStats().incRetries();
+                    _getMap().remove(key, oldRe);
-                    if (oldRe != null) {
-                      owner.getCachePerfStats().incRetries();
-                    }
-              re = getOrCreateRegionEntry(owner, event, Token.REMOVED_PHASE1, null, onlyExisting, false);
+              _getMap().remove(event.getKey(), re);
+              re = getOrCreateRegionEntry(owner, event, Token.REMOVED_PHASE1, null, onlyExisting, false);
+                  owner.getCachePerfStats().incRetries();
+                  _getMap().remove(key, oldRe);
-                  if (oldRe != null) {
-                    owner.getCachePerfStats().incRetries();
-                  }

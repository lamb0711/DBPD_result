Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The ServerLauncher class is a launcher class with main method to start a GemFire Server (implying a GemFire Cache
- * Server process).
+ * The ServerLauncher class is a launcher class with main method to start a GemFire Server (implying
+ * a GemFire Cache Server process).
-@SuppressWarnings({ "unused" })
+@SuppressWarnings({"unused"})
-   * @deprecated This is specific to the internal implementation and may go away in a future release.
+   * @deprecated This is specific to the internal implementation and may go away in a future
+   *             release.
-    helpMap.put("launcher", LocalizedStrings.ServerLauncher_SERVER_LAUNCHER_HELP.toLocalizedString());
-    helpMap.put(Command.START.getName(), LocalizedStrings.ServerLauncher_START_SERVER_HELP.toLocalizedString(String.valueOf(getDefaultServerPort())));
-    helpMap.put(Command.STATUS.getName(), LocalizedStrings.ServerLauncher_STATUS_SERVER_HELP.toLocalizedString());
-    helpMap.put(Command.STOP.getName(), LocalizedStrings.ServerLauncher_STOP_SERVER_HELP.toLocalizedString());
-    helpMap.put(Command.VERSION.getName(), LocalizedStrings.ServerLauncher_VERSION_SERVER_HELP.toLocalizedString());
-    helpMap.put("assign-buckets", LocalizedStrings.ServerLauncher_SERVER_ASSIGN_BUCKETS_HELP.toLocalizedString());
+    helpMap.put("launcher",
+        LocalizedStrings.ServerLauncher_SERVER_LAUNCHER_HELP.toLocalizedString());
+    helpMap.put(Command.START.getName(), LocalizedStrings.ServerLauncher_START_SERVER_HELP
+        .toLocalizedString(String.valueOf(getDefaultServerPort())));
+    helpMap.put(Command.STATUS.getName(),
+        LocalizedStrings.ServerLauncher_STATUS_SERVER_HELP.toLocalizedString());
+    helpMap.put(Command.STOP.getName(),
+        LocalizedStrings.ServerLauncher_STOP_SERVER_HELP.toLocalizedString());
+    helpMap.put(Command.VERSION.getName(),
+        LocalizedStrings.ServerLauncher_VERSION_SERVER_HELP.toLocalizedString());
+    helpMap.put("assign-buckets",
+        LocalizedStrings.ServerLauncher_SERVER_ASSIGN_BUCKETS_HELP.toLocalizedString());
-    helpMap.put("disable-default-server", LocalizedStrings.ServerLauncher_SERVER_DISABLE_DEFAULT_SERVER_HELP.toLocalizedString());
+    helpMap.put("disable-default-server",
+        LocalizedStrings.ServerLauncher_SERVER_DISABLE_DEFAULT_SERVER_HELP.toLocalizedString());
-    helpMap.put("help", LocalizedStrings.SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_OUT_INFORMATION_INSTEAD_OF_PERFORMING_THE_COMMAND_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS.toLocalizedString());
+    helpMap.put("help",
+        LocalizedStrings.SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_OUT_INFORMATION_INSTEAD_OF_PERFORMING_THE_COMMAND_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS
+            .toLocalizedString());
-    helpMap.put("rebalance", LocalizedStrings.ServerLauncher_SERVER_REBALANCE_HELP.toLocalizedString());
-    helpMap.put("redirect-output", LocalizedStrings.ServerLauncher_SERVER_REDIRECT_OUTPUT_HELP.toLocalizedString());
-    helpMap.put(SERVER_BIND_ADDRESS, LocalizedStrings.ServerLauncher_SERVER_BIND_ADDRESS_HELP.toLocalizedString());
-    helpMap.put("hostname-for-clients", LocalizedStrings.ServerLauncher_SERVER_HOSTNAME_FOR_CLIENT_HELP.toLocalizedString());
-    helpMap.put("server-port", LocalizedStrings.ServerLauncher_SERVER_PORT_HELP.toLocalizedString(String.valueOf(getDefaultServerPort())));
+    helpMap.put("rebalance",
+        LocalizedStrings.ServerLauncher_SERVER_REBALANCE_HELP.toLocalizedString());
+    helpMap.put("redirect-output",
+        LocalizedStrings.ServerLauncher_SERVER_REDIRECT_OUTPUT_HELP.toLocalizedString());
+    helpMap.put(SERVER_BIND_ADDRESS,
+        LocalizedStrings.ServerLauncher_SERVER_BIND_ADDRESS_HELP.toLocalizedString());
+    helpMap.put("hostname-for-clients",
+        LocalizedStrings.ServerLauncher_SERVER_HOSTNAME_FOR_CLIENT_HELP.toLocalizedString());
+    helpMap.put("server-port", LocalizedStrings.ServerLauncher_SERVER_PORT_HELP
+        .toLocalizedString(String.valueOf(getDefaultServerPort())));
-    usageMap.put(Command.START, "start <member-name> [--assign-buckets] [--disable-default-server] [--rebalance] [--server-bind-address=<IP-address>] [--server-port=<port>] [--force] [--debug] [--help]");
-    usageMap.put(Command.STATUS, "status [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Server-working-directory>] [--debug] [--help]");
-    usageMap.put(Command.STOP, "stop [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Server-working-directory>] [--debug] [--help]");
+    usageMap.put(Command.START,
+        "start <member-name> [--assign-buckets] [--disable-default-server] [--rebalance] [--server-bind-address=<IP-address>] [--server-port=<port>] [--force] [--debug] [--help]");
+    usageMap.put(Command.STATUS,
+        "status [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Server-working-directory>] [--debug] [--help]");
+    usageMap.put(Command.STOP,
+        "stop [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Server-working-directory>] [--debug] [--help]");
-   * @deprecated This is specific to the internal implementation and may go away in a future release.
+   * @deprecated This is specific to the internal implementation and may go away in a future
+   *             release.
-  private static final ServerLauncherCacheProvider DEFAULT_CACHE_PROVIDER = new DefaultServerLauncherCacheProvider();
+  private static final ServerLauncherCacheProvider DEFAULT_CACHE_PROVIDER =
+      new DefaultServerLauncherCacheProvider();
-  
+
-  
+
-  
+
-  
-  private final String hostNameForClients; 
+
+  private final String hostNameForClients;
-  
+
-  
+
-    }
-    catch (AttachAPINotFoundException e) {
+    } catch (AttachAPINotFoundException e) {
-    return Integer.getInteger(AbstractCacheServer.TEST_OVERRIDE_DEFAULT_PORT_PROPERTY, CacheServer.DEFAULT_PORT);
+    return Integer.getInteger(AbstractCacheServer.TEST_OVERRIDE_DEFAULT_PORT_PROPERTY,
+        CacheServer.DEFAULT_PORT);
-   * Gets the instance of the ServerLauncher used to launch the GemFire Cache Server, or null if this VM does not
-   * have an instance of ServerLauncher indicating no GemFire Cache Server is running.
+   * Gets the instance of the ServerLauncher used to launch the GemFire Cache Server, or null if
+   * this VM does not have an instance of ServerLauncher indicating no GemFire Cache Server is
+   * running.
-   * Private constructor used to properly construct an immutable instance of the ServerLauncher using a Builder.
-   * The Builder is used to configure a ServerLauncher instance.  The Builder can process user input from the
-   * command-line or be used programmatically to properly construct an instance of the ServerLauncher using the API.
+   * Private constructor used to properly construct an immutable instance of the ServerLauncher
+   * using a Builder. The Builder is used to configure a ServerLauncher instance. The Builder can
+   * process user input from the command-line or be used programmatically to properly construct an
+   * instance of the ServerLauncher using the API.
-   * @param builder an instance of ServerLauncher.Builder for configuring and constructing an instance of the
-   * ServerLauncher.
+   * @param builder an instance of ServerLauncher.Builder for configuring and constructing an
+   *        instance of the ServerLauncher.
+
-   * Gets the CacheConfig object used to configure additional GemFire Cache components and features (e.g. PDX).
+   * Gets the CacheConfig object used to configure additional GemFire Cache components and features
+   * (e.g. PDX).
-   * @return a CacheConfig object with additional GemFire Cache configuration meta-data used on startup to configure
-   * the Cache.
+   * @return a CacheConfig object with additional GemFire Cache configuration meta-data used on
+   *         startup to configure the Cache.
-   * Gets an identifier that uniquely identifies and represents the Server associated with this launcher.
+   * Gets an identifier that uniquely identifies and represents the Server associated with this
+   * launcher.
-   * Determines whether buckets should be assigned to partitioned regions in the cache upon Server start.
+   * Determines whether buckets should be assigned to partitioned regions in the cache upon Server
+   * start.
-   * Determines whether the PID file is allowed to be overwritten when the Server is started and a PID file
-   * already exists in the Server's specified working directory.
+   * Determines whether the PID file is allowed to be overwritten when the Server is started and a
+   * PID file already exists in the Server's specified working directory.
-   * Determines whether this launcher will be used to display help information.  If so, then none of the standard
-   * Server launcher commands will be used to affect the state of the Server.  A launcher is said to be 'helping'
-   * if the user entered the "--help" option (switch) on the command-line.
+   * Determines whether this launcher will be used to display help information. If so, then none of
+   * the standard Server launcher commands will be used to affect the state of the Server. A
+   * launcher is said to be 'helping' if the user entered the "--help" option (switch) on the
+   * command-line.
-   * Determines whether a rebalance operation on the cache will occur upon starting the GemFire server using this
-   * launcher.
+   * Determines whether a rebalance operation on the cache will occur upon starting the GemFire
+   * server using this launcher.
-   * Determines whether this launcher will redirect output to system logs when
-   * starting a new Locator process.
+   * Determines whether this launcher will redirect output to system logs when starting a new
+   * Locator process.
-   * @return a boolean value indicating if this launcher will redirect output 
-   * to system logs when starting a new Locator process
+   * @return a boolean value indicating if this launcher will redirect output to system logs when
+   *         starting a new Locator process
-    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_SERVER_LOG_NAME).concat(DEFAULT_SERVER_LOG_EXT);
+    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_SERVER_LOG_NAME)
+        .concat(DEFAULT_SERVER_LOG_EXT);
-   * Gets the name of this member (this Server) in the GemFire distributed system as determined by the 'name' GemFire
-   * property.
+   * Gets the name of this member (this Server) in the GemFire distributed system as determined by
+   * the 'name' GemFire property.
-   * @return a String indicating the name of the member (this Server) in the GemFire distributed system.
+   * @return a String indicating the name of the member (this Server) in the GemFire distributed
+   *         system.
-   * Gets the user-specified process ID (PID) of the running Server that ServerLauncher uses to issue status and
-   * stop commands to the Server.
+   * Gets the user-specified process ID (PID) of the running Server that ServerLauncher uses to
+   * issue status and stop commands to the Server.
-   * @return a Properties object containing the configuration settings for the GemFire Distributed System (cluster).
+   * @return a Properties object containing the configuration settings for the GemFire Distributed
+   *         System (cluster).
-   * Gets the IP address to which the Server is bound listening for and accepting cache client connections.  This
-   * property should not be confused with 'bindAddress' ServerLauncher property, which is the port for binding the
-   * Server's ServerSocket used in distribution and messaging between the peers of the GemFire distributed system.
+   * Gets the IP address to which the Server is bound listening for and accepting cache client
+   * connections. This property should not be confused with 'bindAddress' ServerLauncher property,
+   * which is the port for binding the Server's ServerSocket used in distribution and messaging
+   * between the peers of the GemFire distributed system.
-   * @return an InetAddress indicating the IP address that the Server is bound to listening for and accepting cache
-   * client connections in a client/server topology.
+   * @return an InetAddress indicating the IP address that the Server is bound to listening for and
+   *         accepting cache client connections in a client/server topology.
-   * Gets the host, as either hostname or IP address, on which the Server was bound and running.  An attempt is made
-   * to get the canonical hostname for IP address to which the Server was bound for accepting client requests.  If
-   * the server bind address is null or localhost is unknown, then a default String value of "localhost/127.0.0.1"
-   * is returned.
+   * Gets the host, as either hostname or IP address, on which the Server was bound and running. An
+   * attempt is made to get the canonical hostname for IP address to which the Server was bound for
+   * accepting client requests. If the server bind address is null or localhost is unknown, then a
+   * default String value of "localhost/127.0.0.1" is returned.
-   * Note, this information is purely information and should not be used to re-construct state or for
-   * other purposes.
+   * Note, this information is purely information and should not be used to re-construct state or
+   * for other purposes.
-   * @return the hostname or IP address of the host running the Server, based on the bind-address, or
-   * 'localhost/127.0.0.1' if the bind address is null and localhost is unknown.
+   * @return the hostname or IP address of the host running the Server, based on the bind-address,
+   *         or 'localhost/127.0.0.1' if the bind address is null and localhost is unknown.
-    }
-    catch (UnknownHostException ignore) {
+    } catch (UnknownHostException ignore) {
-      // NOTE returning localhost/127.0.0.1 implies the serverBindAddress was null and no IP address for localhost
+      // NOTE returning localhost/127.0.0.1 implies the serverBindAddress was null and no IP address
+      // for localhost
-   * Gets the port on which the Server is listening for cache client connections.  This property should not be confused
-   * with the 'port' ServerLauncher property, which is used by the Server to set the 'tcp-port' distribution config
-   * property and is used by the ServerSocket for peer distribution and messaging.
+   * Gets the port on which the Server is listening for cache client connections. This property
+   * should not be confused with the 'port' ServerLauncher property, which is used by the Server to
+   * set the 'tcp-port' distribution config property and is used by the ServerSocket for peer
+   * distribution and messaging.
-   * @return an Integer value indicating the port the Server is listening on for cache client connections in the
-   * client/server topology.
+   * @return an Integer value indicating the port the Server is listening on for cache client
+   *         connections in the client/server topology.
-   * Gets the server port on which the Server is listening for client requests represented as a String value.
+   * Gets the server port on which the Server is listening for client requests represented as a
+   * String value.
-   * @return a String representing the server port on which the Server is listening for client requests.
+   * @return a String representing the server port on which the Server is listening for client
+   *         requests.
-   * Gets the location of the Spring XML configuration meta-data file used to bootstrap, configure and initialize
-   * the GemFire Server on start.
+   * Gets the location of the Spring XML configuration meta-data file used to bootstrap, configure
+   * and initialize the GemFire Server on start.
+   * 
-   * Determines whether this GemFire Server was configured and initialized with Spring configuration meta-data.
+   * Determines whether this GemFire Server was configured and initialized with Spring configuration
+   * meta-data.
-   * @return a boolean value indicating whether this GemFire Server was configured with Spring configuration meta-data.
+   * 
+   * @return a boolean value indicating whether this GemFire Server was configured with Spring
+   *         configuration meta-data.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-   * Displays help for the specified Server launcher command to standard err.  If the Server launcher command
-   * is unspecified, then usage information is displayed instead.
+   * Displays help for the specified Server launcher command to standard err. If the Server launcher
+   * command is unspecified, then usage information is displayed instead.
-    }
-    else {
+    } else {
-      info(StringUtils.wrap("> java ... " + getClass().getName() + " " + usageMap.get(command), 80, "\t\t"));
+      info(StringUtils.wrap("> java ... " + getClass().getName() + " " + usageMap.get(command), 80,
+          "\t\t"));
-   * Displays usage information on the proper invocation of the ServerLauncher from the command-line to standard err.
+   * Displays usage information on the proper invocation of the ServerLauncher from the command-line
+   * to standard err.
-   * A Runnable method used to invoke the GemFire server (cache server) with the specified command.  From run, a user
-   * can invoke 'start', 'status', 'stop' and 'version'.  Note, that 'version' is also a command-line option, but can
-   * be treated as a "command" as well.
+   * A Runnable method used to invoke the GemFire server (cache server) with the specified command.
+   * From run, a user can invoke 'start', 'status', 'stop' and 'version'. Note, that 'version' is
+   * also a command-line option, but can be treated as a "command" as well.
-    }
-    else {
+    } else {
-  
+
-   * @return a boolean indicating whether a GemFire Cache Server can be started with this instance of ServerLauncher,
-   * which is true if the ServerLauncher has not already started a Server or a Server is not already running.
+   * @return a boolean indicating whether a GemFire Cache Server can be started with this instance
+   *         of ServerLauncher, which is true if the ServerLauncher has not already started a Server
+   *         or a Server is not already running.
-   * Invokes the 'start' command and operation to startup a GemFire server (a cache server).  Note, this method will
-   * cause the JVM to block upon server start, providing the calling Thread is a non-daemon Thread.
+   * Invokes the 'start' command and operation to startup a GemFire server (a cache server). Note,
+   * this method will cause the JVM to block upon server start, providing the calling Thread is a
+   * non-daemon Thread.
-        process = new ControllableProcess(this.controlHandler, new File(getWorkingDirectory()), ProcessType.SERVER, isForcing());
+        process = new ControllableProcess(this.controlHandler, new File(getWorkingDirectory()),
+            ProcessType.SERVER, isForcing());
-        ProcessLauncherContext.set(isRedirectingOutput(), getOverriddenDefaults(), new StartupStatusListener() {
-          @Override
-          public void setStatus(final String statusMessage) {
-            debug("Callback setStatus(String) called with message (%1$s)...", statusMessage);
-            ServerLauncher.this.statusMessage = statusMessage;
-          }
-        });
+        ProcessLauncherContext.set(isRedirectingOutput(), getOverriddenDefaults(),
+            new StartupStatusListener() {
+              @Override
+              public void setStatus(final String statusMessage) {
+                debug("Callback setStatus(String) called with message (%1$s)...", statusMessage);
+                ServerLauncher.this.statusMessage = statusMessage;
+              }
+            });
-          
-          //Set the resource manager options
+
+          // Set the resource manager options
-          } 
+          }
-            this.cache.getResourceManager().setCriticalOffHeapPercentage(getCriticalOffHeapPercentage());
-          } 
-          if (this.evictionOffHeapPercentage != null) {
-            this.cache.getResourceManager().setEvictionOffHeapPercentage(getEvictionOffHeapPercentage());
+            this.cache.getResourceManager()
+                .setCriticalOffHeapPercentage(getCriticalOffHeapPercentage());
-          
+          if (this.evictionOffHeapPercentage != null) {
+            this.cache.getResourceManager()
+                .setEvictionOffHeapPercentage(getEvictionOffHeapPercentage());
+          }
+
-        }
-        finally {
+        } finally {
-        
-        debug("Running Server on (%1$s) in (%2$s) as (%2$s)...", getId(), getWorkingDirectory(), getMember());
+
+        debug("Running Server on (%1$s) in (%2$s) as (%2$s)...", getId(), getWorkingDirectory(),
+            getMember());
-      }
-      catch(AuthenticationRequiredException e){
+      } catch (AuthenticationRequiredException e) {
-        throw new AuthenticationRequiredException("user/password required. Please start your server with --user and --password. "+ e.getMessage());
-      }
-      catch(GemFireSecurityException e){
+        throw new AuthenticationRequiredException(
+            "user/password required. Please start your server with --user and --password. "
+                + e.getMessage());
+      } catch (GemFireSecurityException e) {
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_IO_ERROR_MESSAGE.toLocalizedString(
-          getServiceName(), getWorkingDirectory(), getId(), e.getMessage()), e);
-      }
-      catch (FileAlreadyExistsException e) {
+        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_IO_ERROR_MESSAGE
+            .toLocalizedString(getServiceName(), getWorkingDirectory(), getId(), e.getMessage()),
+            e);
+      } catch (FileAlreadyExistsException e) {
-        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_PID_FILE_ALREADY_EXISTS_ERROR_MESSAGE.
-           toLocalizedString(getServiceName(), getWorkingDirectory(), getId()), e);
-      }
-      catch (PidUnavailableException e) {
+        throw new RuntimeException(
+            LocalizedStrings.Launcher_Command_START_PID_FILE_ALREADY_EXISTS_ERROR_MESSAGE
+                .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()),
+            e);
+      } catch (PidUnavailableException e) {
-        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_PID_UNAVAILABLE_ERROR_MESSAGE
-          .toLocalizedString(getServiceName(), getId(), getWorkingDirectory(), e.getMessage()), e);
-      }
-      catch (ClusterConfigurationNotAvailableException e) {
+        throw new RuntimeException(
+            LocalizedStrings.Launcher_Command_START_PID_UNAVAILABLE_ERROR_MESSAGE.toLocalizedString(
+                getServiceName(), getId(), getWorkingDirectory(), e.getMessage()),
+            e);
+      } catch (ClusterConfigurationNotAvailableException e) {
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-      }
-      catch (Error e) {
+      } catch (Error e) {
-      }
-      finally {
+      } finally {
-    }
-    else {
-      throw new IllegalStateException(LocalizedStrings.Launcher_Command_START_SERVICE_ALREADY_RUNNING_ERROR_MESSAGE
-        .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()));
+    } else {
+      throw new IllegalStateException(
+          LocalizedStrings.Launcher_Command_START_SERVICE_ALREADY_RUNNING_ERROR_MESSAGE
+              .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()));
-    ServiceLoader<ServerLauncherCacheProvider> loader = ServiceLoader.load(ServerLauncherCacheProvider.class);
-    for(ServerLauncherCacheProvider provider : loader) {
+    ServiceLoader<ServerLauncherCacheProvider> loader =
+        ServiceLoader.load(ServerLauncherCacheProvider.class);
+    for (ServerLauncherCacheProvider provider : loader) {
-      if(cache != null) {
+      if (cache != null) {
-    
+
-   * @return a boolean value indicating whether the GemFire data member should continue running, as determined
-   * by the running flag and a connection to the distributed system (GemFire cluster).
+   * @return a boolean value indicating whether the GemFire data member should continue running, as
+   *         determined by the running flag and a connection to the distributed system (GemFire
+   *         cluster).
-    //return (isRunning() && !getCache().isClosed());
+    // return (isRunning() && !getCache().isClosed());
-          }
-          catch (InterruptedException ignore) {
+          } catch (InterruptedException ignore) {
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-      }
-      finally {
+      } finally {
-   * Determines whether a default server (a cache server) should be created on startup as determined by the absence
-   * of specifying the --disable-default-server command-line option (switch).  In addition, a default cache server
-   * is started only if no cache servers have been added to the Cache by way of cache.xml.
+   * Determines whether a default server (a cache server) should be created on startup as determined
+   * by the absence of specifying the --disable-default-server command-line option (switch). In
+   * addition, a default cache server is started only if no cache servers have been added to the
+   * Cache by way of cache.xml.
-   * If the default server (cache server) has not been disabled and no prior cache servers were added to the cache,
-   * then this method will add a cache server to the Cache and start the server Thread on the specified bind address
-   * and port.
+   * If the default server (cache server) has not been disabled and no prior cache servers were
+   * added to the cache, then this method will add a cache server to the Cache and start the server
+   * Thread on the specified bind address and port.
-      final String serverBindAddress = (getServerBindAddress() == null ? null : getServerBindAddress().getHostAddress());
+      final String serverBindAddress =
+          (getServerBindAddress() == null ? null : getServerBindAddress().getHostAddress());
-      
+
-      
+
-      
+
-      
+
-      
+
-      
+
-   * Determines whether the user indicated that buckets should be assigned on cache server start using the
-   * --assign-buckets command-line option (switch) at the command-line as well as whether the option is technically
-   * allowed.  The option is only allowed if the instance of the Cache is the internal GemFireCacheImpl at present.
+   * Determines whether the user indicated that buckets should be assigned on cache server start
+   * using the --assign-buckets command-line option (switch) at the command-line as well as whether
+   * the option is technically allowed. The option is only allowed if the instance of the Cache is
+   * the internal GemFireCacheImpl at present.
+   * 
-   * Invokes the 'status' command and operation to check the status of a GemFire server (a cache server).
+   * Invokes the 'status' command and operation to check the status of a GemFire server (a cache
+   * server).
-      debug("Getting status from the ServerLauncher instance that actually launched the GemFire Cache Server.%n");
+      debug(
+          "Getting status from the ServerLauncher instance that actually launched the GemFire Cache Server.%n");
-    }
-    else if (isPidInProcess() && launcher != null) {
+    } else if (isPidInProcess() && launcher != null) {
-    }
-    else if (getPid() != null) {
+    } else if (getPid() != null) {
-    debug("This ServerLauncher was not the instance used to launch the GemFire Cache Server, and neither PID "
-      .concat("nor working directory were specified; the Server's state is unknown.%n"));
+    debug(
+        "This ServerLauncher was not the instance used to launch the GemFire Cache Server, and neither PID "
+            .concat("nor working directory were specified; the Server's state is unknown.%n"));
-  
+
-      debug("Getting status from the ServerLauncher instance that actually launched the GemFire Cache Server.%n");
+      debug(
+          "Getting status from the ServerLauncher instance that actually launched the GemFire Cache Server.%n");
-  
+
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, getPid());
+      final ProcessController controller = new ProcessControllerFactory()
+          .createProcessController(this.controllerParameters, getPid());
-//    catch (NoClassDefFoundError error) {
-//      if (isAttachAPINotFound(error)) {
-//        throw new AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-//          .toLocalizedString(), error);
-//      }
-//
-//      throw error;
-//    }
+    // catch (NoClassDefFoundError error) {
+    // if (isAttachAPINotFound(error)) {
+    // throw new
+    // AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
+    // .toLocalizedString(), error);
+    // }
+    //
+    // throw error;
+    // }
-    } 
-    catch (IOException e) {
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-    } 
-//    catch (MalformedObjectNameException e) { // impossible
-//      // JMX object name is bad
-//      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-//    } 
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
+    }
+    // catch (MalformedObjectNameException e) { // impossible
+    // // JMX object name is bad
+    // return createNoResponseState(e, "Failed to communicate with server with process id " +
+    // getPid());
+    // }
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-    } 
-//    catch (PidUnavailableException e) {
-//      // couldn't determine pid from within server JVM
-//      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-//    } 
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
+    }
+    // catch (PidUnavailableException e) {
+    // // couldn't determine pid from within server JVM
+    // return createNoResponseState(e, "Failed to communicate with server with process id " +
+    // getPid());
+    // }
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-    } 
-    catch (InterruptedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
+    } catch (InterruptedException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-    } 
-    catch (TimeoutException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
+    } catch (TimeoutException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller = new ProcessControllerFactory().createProcessController(
+          this.controllerParameters, new File(getWorkingDirectory()),
+          ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      
+
-    }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException e) {
-    } 
-    catch (FileNotFoundException e) {
+    } catch (FileNotFoundException e) {
-      return createNoResponseState(e, "Failed to find process file " + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (IOException e) {
+      return createNoResponseState(e, "Failed to find process file "
+          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-    } 
-    catch (InterruptedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
+    } catch (InterruptedException e) {
-      return createNoResponseState(e, "Interrupted while trying to communicate with server with process id " + parsedPid);
-    } 
-    catch (MBeanInvocationFailedException e) {
+      return createNoResponseState(e,
+          "Interrupted while trying to communicate with server with process id " + parsedPid);
+    } catch (MBeanInvocationFailedException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-    } 
-    catch (PidUnavailableException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
+    } catch (PidUnavailableException e) {
-      return createNoResponseState(e, "Failed to find usable process id within file " + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (UnableToControlProcessException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-    } 
-    catch (TimeoutException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
+      return createNoResponseState(e, "Failed to find usable process id within file "
+          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (UnableToControlProcessException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
+    } catch (TimeoutException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
-   * Determines whether the Server can be stopped in-process, such as when a Server is embedded in an application
-   * and the ServerLauncher API is being used.
+   * Determines whether the Server can be stopped in-process, such as when a Server is embedded in
+   * an application and the ServerLauncher API is being used.
-   * @return a boolean indicating whether the Server can be stopped in-process (the application's process with
-   * an embedded Server).
+   * @return a boolean indicating whether the Server can be stopped in-process (the application's
+   *         process with an embedded Server).
-  
+
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, getPid());
+      final ProcessController controller = new ProcessControllerFactory()
+          .createProcessController(this.controllerParameters, getPid());
-//    catch (NoClassDefFoundError error) {
-//      if (isAttachAPINotFound(error)) {
-//        throw new AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-//          .toLocalizedString(), error);
-//      }
-//
-//      throw error;
-//    }
+    // catch (NoClassDefFoundError error) {
+    // if (isAttachAPINotFound(error)) {
+    // throw new
+    // AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
+    // .toLocalizedString(), error);
+    // }
+    //
+    // throw error;
+    // }
-    } 
-    catch (IOException e) {
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-    } 
-//    catch (MalformedObjectNameException e) { // impossible
-//      // JMX object name is bad
-//      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-//    } 
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
+    }
+    // catch (MalformedObjectNameException e) { // impossible
+    // // JMX object name is bad
+    // return createNoResponseState(e, "Failed to communicate with server with process id " +
+    // getPid());
+    // }
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-    } 
-//    catch (PidUnavailableException e) {
-//      // couldn't determine pid from within server JVM
-//      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
-//    } 
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
+    }
+    // catch (PidUnavailableException e) {
+    // // couldn't determine pid from within server JVM
+    // return createNoResponseState(e, "Failed to communicate with server with process id " +
+    // getPid());
+    // }
-      return createNoResponseState(e, "Failed to communicate with server with process id " + getPid());
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + getPid());
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller = new ProcessControllerFactory().createProcessController(
+          this.controllerParameters, new File(getWorkingDirectory()),
+          ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      
+
-      
+
-    }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException e) {
-    } 
-    catch (FileNotFoundException e) {
+    } catch (FileNotFoundException e) {
-      return createNoResponseState(e, "Failed to find process file " + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (IOException e) {
+      return createNoResponseState(e, "Failed to find process file "
+          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-    } 
-    catch (InterruptedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
+    } catch (InterruptedException e) {
-      return createNoResponseState(e, "Interrupted while trying to communicate with server with process id " + parsedPid);
-    } 
-    catch (MBeanInvocationFailedException e) {
+      return createNoResponseState(e,
+          "Interrupted while trying to communicate with server with process id " + parsedPid);
+    } catch (MBeanInvocationFailedException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-    } 
-    catch (PidUnavailableException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
+    } catch (PidUnavailableException e) {
-      return createNoResponseState(e, "Failed to find usable process id within file " + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (TimeoutException e) {
-      return createNoResponseState(e, "Timed out trying to find usable process id within file " + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (UnableToControlProcessException e) {
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
+      return createNoResponseState(e, "Failed to find usable process id within file "
+          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (TimeoutException e) {
+      return createNoResponseState(e, "Timed out trying to find usable process id within file "
+          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (UnableToControlProcessException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with server with process id " + parsedPid);
-    
-    overriddenDefaults.put(
-      ProcessLauncherContext.OVERRIDDEN_DEFAULTS_PREFIX.concat(LOG_FILE),
-      getLogFileName());
+
+    overriddenDefaults.put(ProcessLauncherContext.OVERRIDDEN_DEFAULTS_PREFIX.concat(LOG_FILE),
+        getLogFileName());
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    
+
-  
+
-  
+
-   * The Builder class, modeled after the Builder creational design pattern, is used to construct a properly configured
-   * and initialized instance of the ServerLauncher to control and run GemFire servers (in particular, cache servers).
+   * The Builder class, modeled after the Builder creational design pattern, is used to construct a
+   * properly configured and initialized instance of the ServerLauncher to control and run GemFire
+   * servers (in particular, cache servers).
-    
+
-    
+
-    
-    private String hostNameForClients; 
+
+    private String hostNameForClients;
-     * Default constructor used to create an instance of the Builder class for programmatical access.
+     * Default constructor used to create an instance of the Builder class for programmatical
+     * access.
-    public Builder() {
-    }
+    public Builder() {}
-     * Constructor used to create and configure an instance of the Builder class with the specified arguments, passed in
-     * from the command-line when launching an instance of this class from the command-line using the Java launcher.
+     * Constructor used to create and configure an instance of the Builder class with the specified
+     * arguments, passed in from the command-line when launching an instance of this class from the
+     * command-line using the Java launcher.
-     * Gets an instance of the JOptSimple OptionParser to parse the command-line arguments for Server.
+     * Gets an instance of the JOptSimple OptionParser to parse the command-line arguments for
+     * Server.
-     * @return an instance of the JOptSimple OptionParser configured with the command-line options used by the Server.
+     * @return an instance of the JOptSimple OptionParser configured with the command-line options
+     *         used by the Server.
-      parser.accepts(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE).withRequiredArg().ofType(Float.class);
-      parser.accepts(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE).withRequiredArg().ofType(Float.class);
-      parser.accepts(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE).withRequiredArg().ofType(Float.class);
-      parser.accepts(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE).withRequiredArg().ofType(Float.class);
-      parser.accepts(CliStrings.START_SERVER__MAX__CONNECTIONS).withRequiredArg().ofType(Integer.class);
-      parser.accepts(CliStrings.START_SERVER__MAX__MESSAGE__COUNT).withRequiredArg().ofType(Integer.class);
+      parser.accepts(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE).withRequiredArg()
+          .ofType(Float.class);
+      parser.accepts(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE).withRequiredArg()
+          .ofType(Float.class);
+      parser.accepts(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE).withRequiredArg()
+          .ofType(Float.class);
+      parser.accepts(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE).withRequiredArg()
+          .ofType(Float.class);
+      parser.accepts(CliStrings.START_SERVER__MAX__CONNECTIONS).withRequiredArg()
+          .ofType(Integer.class);
+      parser.accepts(CliStrings.START_SERVER__MAX__MESSAGE__COUNT).withRequiredArg()
+          .ofType(Integer.class);
-      parser.accepts(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE).withRequiredArg().ofType(Integer.class);
-      parser.accepts(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE).withRequiredArg().ofType(Integer.class);
-      parser.accepts(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS).withRequiredArg().ofType(String.class);
+      parser.accepts(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE).withRequiredArg()
+          .ofType(Integer.class);
+      parser.accepts(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE).withRequiredArg()
+          .ofType(Integer.class);
+      parser.accepts(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS).withRequiredArg()
+          .ofType(String.class);
-     * Parses the list of arguments to configure this Builder with the intent of constructing a Server launcher to
-     * invoke a Cache Server.  This method is called to parse the arguments specified by the user on the command-line.
+     * Parses the list of arguments to configure this Builder with the intent of constructing a
+     * Server launcher to invoke a Cache Server. This method is called to parse the arguments
+     * specified by the user on the command-line.
-     * @param args the array of arguments used to configure this Builder and create an instance of ServerLauncher.
+     * @param args the array of arguments used to configure this Builder and create an instance of
+     *        ServerLauncher.
-        
+
-          setCriticalHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE))));
+          setCriticalHeapPercentage(Float.parseFloat(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE))));
-        
+
-          setEvictionHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE))));
+          setEvictionHeapPercentage(Float.parseFloat(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE))));
-        
+
-          setCriticalOffHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE))));
+          setCriticalOffHeapPercentage(Float.parseFloat(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE))));
-        
+
-          setEvictionOffHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE))));
+          setEvictionOffHeapPercentage(Float.parseFloat(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE))));
-        
+
-          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__CONNECTIONS))));
+          setMaxConnections(Integer.parseInt(
+              ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__CONNECTIONS))));
-        
+
-          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__MESSAGE__COUNT))));
+          setMaxConnections(Integer.parseInt(
+              ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__MESSAGE__COUNT))));
-        
+
-          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE))));
+          setMaxConnections(Integer.parseInt(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE))));
-        
+
-          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE))));
-        } 
-        
-        if (options.hasArgument(CliStrings.START_SERVER__MAX__THREADS)) {
-          setMaxThreads(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__THREADS))));
+          setMaxConnections(Integer.parseInt(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE))));
-        
+
+        if (options.hasArgument(CliStrings.START_SERVER__MAX__THREADS)) {
+          setMaxThreads(Integer.parseInt(
+              ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__THREADS))));
+        }
+
-          setCriticalHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE))));
+          setCriticalHeapPercentage(Float.parseFloat(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE))));
-          setEvictionHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(
-            CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE))));
+          setEvictionHeapPercentage(Float.parseFloat(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE))));
-          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(
-            CliStrings.START_SERVER__MAX__CONNECTIONS))));
+          setMaxConnections(Integer.parseInt(
+              ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__CONNECTIONS))));
-          setMaxMessageCount(Integer.parseInt(ObjectUtils.toString(options.valueOf(
-            CliStrings.START_SERVER__MAX__MESSAGE__COUNT))));
+          setMaxMessageCount(Integer.parseInt(
+              ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__MESSAGE__COUNT))));
-          setMaxThreads(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__THREADS))));
+          setMaxThreads(Integer.parseInt(
+              ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__THREADS))));
-          setMessageTimeToLive(Integer.parseInt(ObjectUtils.toString(options.valueOf(
-            CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE))));
+          setMessageTimeToLive(Integer.parseInt(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE))));
-        
+
-          setSocketBufferSize(Integer.parseInt(ObjectUtils.toString(options.valueOf(
-            CliStrings.START_SERVER__SOCKET__BUFFER__SIZE))));
+          setSocketBufferSize(Integer.parseInt(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE))));
-          setHostNameForClients(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS)));
+          setHostNameForClients(ObjectUtils
+              .toString(options.valueOf(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS)));
-      }
-      catch (OptionException e) {
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_PARSE_COMMAND_LINE_ARGUMENT_ERROR_MESSAGE
-          .toLocalizedString("Server", e.getMessage()), e);
-      }
-      catch (Exception e) {
+      } catch (OptionException e) {
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_PARSE_COMMAND_LINE_ARGUMENT_ERROR_MESSAGE
+                .toLocalizedString("Server", e.getMessage()),
+            e);
+      } catch (Exception e) {
-     * Iterates the list of arguments in search of the Server's GemFire member name.  If the argument does not
-     * start with '-' or is not the name of a Server launcher command, then the value is presumed to be the member name
-     * for the Server in GemFire.
+     * Iterates the list of arguments in search of the Server's GemFire member name. If the argument
+     * does not start with '-' or is not the name of a Server launcher command, then the value is
+     * presumed to be the member name for the Server in GemFire.
-     * @param args the array of arguments from which to search for the Server's member name in GemFire.
+     * @param args the array of arguments from which to search for the Server's member name in
+     *        GemFire.
-     * @param command the targeted Server launcher command used during the invocation (run) of ServerLauncher.
+     * @param command the targeted Server launcher command used during the invocation (run) of
+     *        ServerLauncher.
-     * Determines whether buckets should be assigned to partitioned regions in the cache upon Server start.
+     * Determines whether buckets should be assigned to partitioned regions in the cache upon Server
+     * start.
-     * Sets whether buckets should be assigned to partitioned regions in the cache upon Server start.
+     * Sets whether buckets should be assigned to partitioned regions in the cache upon Server
+     * start.
-     * Sets a boolean value indicating whether to add a default cache when the GemFire Server comes online.
+     * Sets a boolean value indicating whether to add a default cache when the GemFire Server comes
+     * online.
-     * @return a Properties object containing configuration settings for the GemFire Distributed System (cluster).
+     * @return a Properties object containing configuration settings for the GemFire Distributed
+     *         System (cluster).
-     * Gets the boolean value used by the Server to determine if it should overwrite the PID file if it already exists.
+     * Gets the boolean value used by the Server to determine if it should overwrite the PID file if
+     * it already exists.
-     * @return the boolean value specifying whether or not to overwrite the PID file if it already exists.
+     * @return the boolean value specifying whether or not to overwrite the PID file if it already
+     *         exists.
-     * Sets the boolean value used by the Server to determine if it should overwrite the PID file if it already exists.
+     * Sets the boolean value used by the Server to determine if it should overwrite the PID file if
+     * it already exists.
-     * @param force a boolean value indicating whether to overwrite the PID file when it already exists.
+     * @param force a boolean value indicating whether to overwrite the PID file when it already
+     *        exists.
-     * Determines whether the new instance of the ServerLauncher will be used to output help information for either
-     * a specific command, or for using ServerLauncher in general.
+     * Determines whether the new instance of the ServerLauncher will be used to output help
+     * information for either a specific command, or for using ServerLauncher in general.
-     * @return a boolean value indicating whether help will be output during the invocation of the ServerLauncher.
+     * @return a boolean value indicating whether help will be output during the invocation of the
+     *         ServerLauncher.
-     * Sets whether the new instance of ServerLauncher will be used to output help information for either a specific
-     * command, or for using ServerLauncher in general.
+     * Sets whether the new instance of ServerLauncher will be used to output help information for
+     * either a specific command, or for using ServerLauncher in general.
-     * @param help a boolean indicating whether help information is to be displayed during invocation of ServerLauncher.
+     * @param help a boolean indicating whether help information is to be displayed during
+     *        invocation of ServerLauncher.
-     * Determines whether a rebalance operation on the cache will occur upon starting the GemFire server.
+     * Determines whether a rebalance operation on the cache will occur upon starting the GemFire
+     * server.
-     * Set a boolean value indicating whether a rebalance operation on the cache should occur upon starting
-     * the GemFire server.
+     * Set a boolean value indicating whether a rebalance operation on the cache should occur upon
+     * starting the GemFire server.
-     * @param rebalance a boolean indicating if the cache will be rebalanced when the GemFire server starts.
+     * @param rebalance a boolean indicating if the cache will be rebalanced when the GemFire server
+     *        starts.
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_MEMBER_NAME_ERROR_MESSAGE
-          .toLocalizedString("Server"));
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_MEMBER_NAME_ERROR_MESSAGE
+                .toLocalizedString("Server"));
-     * Gets the process ID (PID) of the running Server indicated by the user as an argument to the ServerLauncher.
-     * This PID is used by the Server launcher to determine the Server's status, or invoke shutdown on the Server.
+     * Gets the process ID (PID) of the running Server indicated by the user as an argument to the
+     * ServerLauncher. This PID is used by the Server launcher to determine the Server's status, or
+     * invoke shutdown on the Server.
-     * Sets the process ID (PID) of the running Server indicated by the user as an argument to the ServerLauncher.
-     * This PID will be used by the Server launcher to determine the Server's status, or invoke shutdown on the Server.
+     * Sets the process ID (PID) of the running Server indicated by the user as an argument to the
+     * ServerLauncher. This PID will be used by the Server launcher to determine the Server's
+     * status, or invoke shutdown on the Server.
-     * @throws IllegalArgumentException if the process ID (PID) is not valid (greater than zero if not null).
+     * @throws IllegalArgumentException if the process ID (PID) is not valid (greater than zero if
+     *         not null).
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_PID_ERROR_MESSAGE.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_PID_ERROR_MESSAGE.toLocalizedString());
-     * Determines whether the new instance of LocatorLauncher will redirect
-     * output to system logs when starting a Locator.
+     * Determines whether the new instance of LocatorLauncher will redirect output to system logs
+     * when starting a Locator.
-     * @return a boolean value indicating if output will be redirected to system 
-     * logs when starting a Locator
+     * @return a boolean value indicating if output will be redirected to system logs when starting
+     *         a Locator
-     * Sets whether the new instance of LocatorLauncher will redirect output to system logs when starting a Locator.
+     * Sets whether the new instance of LocatorLauncher will redirect output to system logs when
+     * starting a Locator.
-     * @param redirectOutput a boolean value indicating if output will be redirected to system logs when starting
-     * a Locator.
+     * @param redirectOutput a boolean value indicating if output will be redirected to system logs
+     *        when starting a Locator.
-     * Gets the IP address to which the Server will be bound listening for and accepting cache client connections in
-     * a client/server topology.
-     * 
-     * @return an InetAddress indicating the IP address that the Server is bound to listening for and accepting cache
+     * Gets the IP address to which the Server will be bound listening for and accepting cache
+     * 
+     * @return an InetAddress indicating the IP address that the Server is bound to listening for
+     *         and accepting cache client connections in a client/server topology.
-    
+
-     * Sets the IP address to which the Server will be bound listening for and accepting cache client connections in
-     * a client/server topology.
+     * Sets the IP address to which the Server will be bound listening for and accepting cache
+     * client connections in a client/server topology.
-     * @param serverBindAddress a String specifying the IP address or hostname that the Server will be bound to listen
-     * for and accept cache client connections in a client/server topology.
+     * @param serverBindAddress a String specifying the IP address or hostname that the Server will
+     *        be bound to listen for and accept cache client connections in a client/server
+     *        topology.
-     * @throws IllegalArgumentException wrapping the UnknownHostException if the IP address or hostname for the
-     * server bind address is unknown.
+     * @throws IllegalArgumentException wrapping the UnknownHostException if the IP address or
+     *         hostname for the server bind address is unknown.
+          } else {
+            throw new IllegalArgumentException(
+                serverBindAddress + " is not an address for this machine.");
-          else {
-            throw new IllegalArgumentException(serverBindAddress + " is not an address for this machine.");
-          }
-        }
-        catch (UnknownHostException e) {
-          throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE
-            .toLocalizedString("Server"), e);
+        } catch (UnknownHostException e) {
+          throw new IllegalArgumentException(
+              LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE
+                  .toLocalizedString("Server"),
+              e);
-     * Gets the port on which the Server will listen for and accept cache client connections in a client/server topology.
+     * Gets the port on which the Server will listen for and accept cache client connections in a
+     * client/server topology.
-     * @return an Integer value specifying the port the Server will listen on and accept cache client connections in
-     * a client/server topology.
+     * @return an Integer value specifying the port the Server will listen on and accept cache
+     *         client connections in a client/server topology.
-    
+
-     * Sets the port on which the Server will listen for and accept cache client connections in a client/server topology.
+     * Sets the port on which the Server will listen for and accept cache client connections in a
+     * client/server topology.
-     * @param serverPort an Integer value specifying the port the Server will listen on and accept cache client
-     * connections in a client/server topology.
+     * @param serverPort an Integer value specifying the port the Server will listen on and accept
+     *        cache client connections in a client/server topology.
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_INVALID_PORT_ERROR_MESSAGE
-          .toLocalizedString("Server"));
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_INVALID_PORT_ERROR_MESSAGE
+                .toLocalizedString("Server"));
-     * Gets the location of the Spring XML configuration meta-data file used to bootstrap, configure and initialize
-     * the GemFire Server on start.
+     * Gets the location of the Spring XML configuration meta-data file used to bootstrap, configure
+     * and initialize the GemFire Server on start.
+     * 
-     * Sets the location of the Spring XML configuration meta-data file used to bootstrap, configure and initialize
-     * the GemFire Server on start.
+     * Sets the location of the Spring XML configuration meta-data file used to bootstrap, configure
+     * and initialize the GemFire Server on start.
-     * @param springXmlLocation a String indicating the location of the Spring XML configuration file.
+     * 
+     * @param springXmlLocation a String indicating the location of the Spring XML configuration
+     *        file.
-     * Gets the working directory pathname in which the Server will be ran.  If the directory is unspecified,
-     * then working directory defaults to the current directory.
+     * Gets the working directory pathname in which the Server will be ran. If the directory is
+     * unspecified, then working directory defaults to the current directory.
-        new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
+          new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
-     * Sets the working directory in which the Server will be ran.  This also the directory in which all Server files
-     * (such as log and license files) will be written.  If the directory is unspecified, then the working directory
-     * defaults to the current directory.
+     * Sets the working directory in which the Server will be ran. This also the directory in which
+     * all Server files (such as log and license files) will be written. If the directory is
+     * unspecified, then the working directory defaults to the current directory.
-     * @param workingDirectory a String indicating the pathname of the directory in which the Server will be ran.
+     * @param workingDirectory a String indicating the pathname of the directory in which the Server
+     *        will be ran.
-     * @throws IllegalArgumentException wrapping a FileNotFoundException if the working directory pathname cannot be
-     * found.
+     * @throws IllegalArgumentException wrapping a FileNotFoundException if the working directory
+     *         pathname cannot be found.
-      if (!(new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY)).isDirectory())) {
+      if (!(new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY))
+          .isDirectory())) {
-          LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_NOT_FOUND_ERROR_MESSAGE.toLocalizedString("Server"),
+            LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_NOT_FOUND_ERROR_MESSAGE
+                .toLocalizedString("Server"),
-    
+
-          throw new IllegalArgumentException(String.format("Critical heap percentage (%1$s) must be between 0 and 100!",
-            criticalHeapPercentage));
+          throw new IllegalArgumentException(
+              String.format("Critical heap percentage (%1$s) must be between 0 and 100!",
+                  criticalHeapPercentage));
-    
+
-          throw new IllegalArgumentException(String.format("Critical off-heap percentage (%1$s) must be between 0 and 100!", criticalOffHeapPercentage));
+          throw new IllegalArgumentException(
+              String.format("Critical off-heap percentage (%1$s) must be between 0 and 100!",
+                  criticalOffHeapPercentage));
-     this.criticalOffHeapPercentage = criticalOffHeapPercentage;
-     return this;
+      this.criticalOffHeapPercentage = criticalOffHeapPercentage;
+      return this;
-    
+
-          throw new IllegalArgumentException(String.format("Eviction heap percentage (%1$s) must be between 0 and 100!",
-            evictionHeapPercentage));
+          throw new IllegalArgumentException(
+              String.format("Eviction heap percentage (%1$s) must be between 0 and 100!",
+                  evictionHeapPercentage));
-    
+
-    
+
-          throw new IllegalArgumentException(String.format("Eviction off-heap percentage (%1$s) must be between 0 and 100", evictionOffHeapPercentage));
+          throw new IllegalArgumentException(
+              String.format("Eviction off-heap percentage (%1$s) must be between 0 and 100",
+                  evictionOffHeapPercentage));
-    
+
-        throw new IllegalArgumentException(String.format("Max Connections (%1$s) must be greater than 0!",
-          maxConnections));
+        throw new IllegalArgumentException(
+            String.format("Max Connections (%1$s) must be greater than 0!", maxConnections));
-        throw new IllegalArgumentException(String.format("Max Message Count (%1$s) must be greater than 0!",
-          maxMessageCount));
+        throw new IllegalArgumentException(
+            String.format("Max Message Count (%1$s) must be greater than 0!", maxMessageCount));
-        throw new IllegalArgumentException(String.format("Max Threads (%1$s) must be greater than 0!", maxThreads));
+        throw new IllegalArgumentException(
+            String.format("Max Threads (%1$s) must be greater than 0!", maxThreads));
-        throw new IllegalArgumentException(String.format("Message Time To Live (%1$s) must be greater than 0!",
-          messageTimeToLive));
+        throw new IllegalArgumentException(String
+            .format("Message Time To Live (%1$s) must be greater than 0!", messageTimeToLive));
-        throw new IllegalArgumentException(String.format("The Server's Socket Buffer Size (%1$s) must be greater than 0!",
-          socketBufferSize));
+        throw new IllegalArgumentException(String.format(
+            "The Server's Socket Buffer Size (%1$s) must be greater than 0!", socketBufferSize));
-    
-    
+
+
-     * @param propertyName a String indicating the name of the GemFire Distributed System property as described in {@link ConfigurationProperties}
+     * @param propertyName a String indicating the name of the GemFire Distributed System property
+     *        as described in {@link ConfigurationProperties}
-     * @param persistent a boolean indicating whether PDX type meta-data should be persisted to disk.
+     * @param persistent a boolean indicating whether PDX type meta-data should be persisted to
+     *        disk.
-     * @param pdxDiskStore a String indicating the name of the GemFire Disk Store to use to store PDX type meta-data
+     * @param pdxDiskStore a String indicating the name of the GemFire Disk Store to use to store
+     *        PDX type meta-data
-     * @param ignore a boolean indicating whether unread fields in the PDX instance should be ignored.
+     * @param ignore a boolean indicating whether unread fields in the PDX instance should be
+     *        ignored.
-     * Sets whether PDX instances should be returned as is when Region.get(key:String):Object is called.
+     * Sets whether PDX instances should be returned as is when Region.get(key:String):Object is
+     * called.
-     * @param readSerialized a boolean indicating whether the PDX instance should be returned from a call to
-     * Region.get(key:String):Object
+     * @param readSerialized a boolean indicating whether the PDX instance should be returned from a
+     *        call to Region.get(key:String):Object
-     * Set the PdxSerializer to use to serialize POJOs to the GemFire Cache Region or when sent between peers,
-     * client/server, or during persistence to disk.
+     * Set the PdxSerializer to use to serialize POJOs to the GemFire Cache Region or when sent
+     * between peers, client/server, or during persistence to disk.
-     * @param pdxSerializer the PdxSerializer that is used to serialize application domain objects into PDX.
+     * @param pdxSerializer the PdxSerializer that is used to serialize application domain objects
+     *        into PDX.
-     * Validates the configuration settings and properties of this Builder, ensuring that all invariants have been met.
-     * Currently, the only invariant constraining the Builder is that the user must specify the member name for the
-     * Server in the GemFire distributed system as a command-line argument, or by setting the memberName property
-     * programmatically using the corresponding setter method.
+     * Validates the configuration settings and properties of this Builder, ensuring that all
+     * invariants have been met. Currently, the only invariant constraining the Builder is that the
+     * user must specify the member name for the Server in the GemFire distributed system as a
+     * command-line argument, or by setting the memberName property programmatically using the
+     * corresponding setter method.
-            && !isSet(loadGemFireProperties(DistributedSystem.getPropertyFileURL()), NAME))
-        {
-          throw new IllegalStateException(LocalizedStrings.Launcher_Builder_MEMBER_NAME_VALIDATION_ERROR_MESSAGE
-            .toLocalizedString("Server"));
+            && !isSet(loadGemFireProperties(DistributedSystem.getPropertyFileURL()), NAME)) {
+          throw new IllegalStateException(
+              LocalizedStrings.Launcher_Builder_MEMBER_NAME_VALIDATION_ERROR_MESSAGE
+                  .toLocalizedString("Server"));
-          throw new IllegalStateException(LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_OPTION_NOT_VALID_ERROR_MESSAGE
-            .toLocalizedString("Server"));
+          throw new IllegalStateException(
+              LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_OPTION_NOT_VALID_ERROR_MESSAGE
+                  .toLocalizedString("Server"));
-     * Validates the Builder configuration settings and then constructs an instance of the ServerLauncher class
-     * to invoke operations on a GemFire Server.
+     * Validates the Builder configuration settings and then constructs an instance of the
+     * ServerLauncher class to invoke operations on a GemFire Server.
-    START("start", "assign-buckets", "disable-default-server", "rebalance", SERVER_BIND_ADDRESS, "server-port", "force", "debug", "help"),
-    STATUS("status", "member", "pid", "dir", "debug", "help"),
-    STOP("stop", "member", "pid", "dir", "debug", "help"),
-    UNSPECIFIED("unspecified"),
-    VERSION("version");
+    START("start", "assign-buckets", "disable-default-server", "rebalance", SERVER_BIND_ADDRESS,
+        "server-port", "force", "debug",
+        "help"), STATUS("status", "member", "pid", "dir", "debug", "help"), STOP("stop", "member",
+            "pid", "dir", "debug", "help"), UNSPECIFIED("unspecified"), VERSION("version");
-        : Collections.<String>emptyList());
+          : Collections.<String>emptyList());
-     * Determines whether the specified name refers to a valid Server launcher command, as defined by this
-     * enumerated type.
+     * Determines whether the specified name refers to a valid Server launcher command, as defined
+     * by this enumerated type.
-     * @return a boolean indicating whether the specified name for a Server launcher command is valid.
+     * @return a boolean indicating whether the specified name for a Server launcher command is
+     *         valid.
-     * Determines whether the given Server launcher command has been properly specified.  The command is deemed
-     * unspecified if the reference is null or the Command is UNSPECIFIED.
+     * Determines whether the given Server launcher command has been properly specified. The command
+     * is deemed unspecified if the reference is null or the Command is UNSPECIFIED.
-     * Looks up a Server launcher command by name.  The equality comparison on name is case-insensitive.
+     * Looks up a Server launcher command by name. The equality comparison on name is
+     * case-insensitive.
-     * @return an enumerated type representing the command name or null if the no such command with the specified name
-     * exists.
+     * @return an enumerated type representing the command name or null if the no such command with
+     *         the specified name exists.
-     * Gets a set of valid options that can be used with the Locator launcher command when used from the command-line.
+     * Gets a set of valid options that can be used with the Locator launcher command when used from
+     * the command-line.
-     * @return a Set of Strings indicating the names of the options available to the Server launcher command.
+     * @return a Set of Strings indicating the names of the options available to the Server launcher
+     *         command.
-     * @return a boolean value indicating whether this command has the specified named command-line option.
+     * @return a boolean value indicating whether this command has the specified named command-line
+     *         option.
-   * The ServerState is an immutable type representing the state of the specified Locator at any given moment in time.
-   * The state of the Locator is assessed at the exact moment an instance of this class is constructed.
+   * The ServerState is an immutable type representing the state of the specified Locator at any
+   * given moment in time. The state of the Locator is assessed at the exact moment an instance of
+   * this class is constructed.
-        final List<String> jvmArguments = Arrays.asList(GfJsonArray.toStringArray(gfJsonObject.getJSONArray(
-          JSON_JVMARGUMENTS)));
+        final List<String> jvmArguments =
+            Arrays.asList(GfJsonArray.toStringArray(gfJsonObject.getJSONArray(JSON_JVMARGUMENTS)));
-        return new ServerState(status,
-          gfJsonObject.getString(JSON_STATUSMESSAGE),
-          gfJsonObject.getLong(JSON_TIMESTAMP),
-          gfJsonObject.getString(JSON_LOCATION),
-          gfJsonObject.getInt(JSON_PID),
-          gfJsonObject.getLong(JSON_UPTIME),
-          gfJsonObject.getString(JSON_WORKINGDIRECTORY),
-          jvmArguments,
-          gfJsonObject.getString(JSON_CLASSPATH),
-          gfJsonObject.getString(JSON_GEMFIREVERSION),
-          gfJsonObject.getString(JSON_JAVAVERSION),
-          gfJsonObject.getString(JSON_LOGFILE),
-          gfJsonObject.getString(JSON_HOST),
-          gfJsonObject.getString(JSON_PORT),
-          gfJsonObject.getString(JSON_MEMBERNAME));
-      }
-      catch (GfJsonException e) {
+        return new ServerState(status, gfJsonObject.getString(JSON_STATUSMESSAGE),
+            gfJsonObject.getLong(JSON_TIMESTAMP), gfJsonObject.getString(JSON_LOCATION),
+            gfJsonObject.getInt(JSON_PID), gfJsonObject.getLong(JSON_UPTIME),
+            gfJsonObject.getString(JSON_WORKINGDIRECTORY), jvmArguments,
+            gfJsonObject.getString(JSON_CLASSPATH), gfJsonObject.getString(JSON_GEMFIREVERSION),
+            gfJsonObject.getString(JSON_JAVAVERSION), gfJsonObject.getString(JSON_LOGFILE),
+            gfJsonObject.getString(JSON_HOST), gfJsonObject.getString(JSON_PORT),
+            gfJsonObject.getString(JSON_MEMBERNAME));
+      } catch (GfJsonException e) {
-      this(status,
-        launcher.statusMessage,
-        System.currentTimeMillis(),
-        launcher.getId(),
-        identifyPid(),
-        ManagementFactory.getRuntimeMXBean().getUptime(),
-        launcher.getWorkingDirectory(),
-        ManagementFactory.getRuntimeMXBean().getInputArguments(),
-        System.getProperty("java.class.path"),
-        GemFireVersion.getGemFireVersion(),
-        System.getProperty("java.version"),
-        getServerLogFileCanonicalPath(launcher),
-        getServerBindAddressAsString(launcher),
-        getServerPortAsString(launcher),
-        launcher.getMemberName());
+      this(status, launcher.statusMessage, System.currentTimeMillis(), launcher.getId(),
+          identifyPid(), ManagementFactory.getRuntimeMXBean().getUptime(),
+          launcher.getWorkingDirectory(), ManagementFactory.getRuntimeMXBean().getInputArguments(),
+          System.getProperty("java.class.path"), GemFireVersion.getGemFireVersion(),
+          System.getProperty("java.version"), getServerLogFileCanonicalPath(launcher),
+          getServerBindAddressAsString(launcher), getServerPortAsString(launcher),
+          launcher.getMemberName());
-    public ServerState(final ServerLauncher launcher, final Status status, final String errorMessage) {
+    public ServerState(final ServerLauncher launcher, final Status status,
+        final String errorMessage) {
-    
-    protected ServerState(final Status status,
-                          final String statusMessage,
-                          final long timestamp,
-                          final String serverLocation,
-                          final Integer pid,
-                          final Long uptime,
-                          final String workingDirectory,
-                          final List<String> jvmArguments,
-                          final String classpath,
-                          final String gemfireVersion,
-                          final String javaVersion,
-                          final String logFile,
-                          final String host,
-                          final String port,
-                          final String memberName)
-    {
-      super(status, statusMessage, timestamp, serverLocation, pid, uptime, workingDirectory, jvmArguments, classpath,
-        gemfireVersion, javaVersion, logFile, host, port, memberName);
+
+    protected ServerState(final Status status, final String statusMessage, final long timestamp,
+        final String serverLocation, final Integer pid, final Long uptime,
+        final String workingDirectory, final List<String> jvmArguments, final String classpath,
+        final String gemfireVersion, final String javaVersion, final String logFile,
+        final String host, final String port, final String memberName) {
+      super(status, statusMessage, timestamp, serverLocation, pid, uptime, workingDirectory,
+          jvmArguments, classpath, gemfireVersion, javaVersion, logFile, host, port, memberName);
-          final String logFileCanonicalPath = IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
-          if (!StringUtils.isBlank(logFileCanonicalPath)) { 
+          final String logFileCanonicalPath =
+              IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
+          if (!StringUtils.isBlank(logFileCanonicalPath)) {
-      
+
-      return (launcher.isDisableDefaultServer() ? StringUtils.EMPTY_STRING : launcher.getServerPortAsString());
+      return (launcher.isDisableDefaultServer() ? StringUtils.EMPTY_STRING
+          : launcher.getServerPortAsString());

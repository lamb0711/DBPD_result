GEODE-7083: Cleanup static analyzer warnings.

+
-import java.util.Iterator;
+import org.apache.geode.annotations.VisibleForTesting;
-  public static final int PLACE_HOLDER_FOR_TYPE_ID = 0xFFFFFF;
-  public static final int PLACE_HOLDER_FOR_DS_ID = 0xFF000000;
-  private int dsId;
+  @VisibleForTesting
+  public static final int PLACE_HOLDER_FOR_TYPE_ID = 0xFFFFFF;
+  private static final int PLACE_HOLDER_FOR_DS_ID = 0xFF000000;
+
+  private int distributedSystemId;
-  private Map<PdxType, Integer> typeToId =
-      Collections.synchronizedMap(new HashMap<PdxType, Integer>());
+  private Map<PdxType, Integer> typeToId = Collections.synchronizedMap(new HashMap<>());
-  private Map<EnumInfo, EnumId> enumToId =
-      Collections.synchronizedMap(new HashMap<EnumInfo, EnumId>());
+  private Map<EnumInfo, EnumId> enumToId = Collections.synchronizedMap(new HashMap<>());
-    this.dsId = distributedSystemId << 24;
-    this.maxTypeId = 0xFFFFFF;
+    this.distributedSystemId = distributedSystemId << 24;
+    maxTypeId = 0xFFFFFF;
-    if (this.idToType != null) {
-      return this.idToType;
+    if (idToType != null) {
+      return idToType;
-      if (this.cache.getPdxPersistent() && this.cache.getCacheConfig().pdxDiskStoreUserSet) {
+      if (cache.getPdxPersistent() && cache.getCacheConfig().pdxDiskStoreUserSet) {
-                + this.cache.getPdxDiskStore() + " was not created.");
+                + cache.getPdxDiskStore() + " was not created.");
-    AttributesFactory<Object, Object> factory = new AttributesFactory<Object, Object>();
+    @SuppressWarnings("deprecation")
+    AttributesFactory<Object, Object> factory = new AttributesFactory<>();
-      this.idToType = cache.createVMRegion(REGION_NAME, regionAttrs, internalArgs);
-    } catch (IOException ex) {
-      throw new PdxInitializationException("Could not create pdx registry", ex);
-    } catch (TimeoutException ex) {
-      throw new PdxInitializationException("Could not create pdx registry", ex);
-    } catch (RegionExistsException ex) {
-      throw new PdxInitializationException("Could not create pdx registry", ex);
-    } catch (ClassNotFoundException ex) {
+      idToType = cache.createVMRegion(REGION_NAME, regionAttrs, internalArgs);
+    } catch (IOException | TimeoutException | RegionExistsException | ClassNotFoundException ex) {
-    if (this.dls != null) {
-      return this.dls;
+    if (dls != null) {
+      return dls;
-    synchronized (this.dlsLock) {
-      if (this.dls == null) {
+    synchronized (dlsLock) {
+      if (dls == null) {
-          this.dls = DLockService.create(LOCK_SERVICE_NAME,
-              this.cache.getInternalDistributedSystem(), true /* distributed */,
+          dls = DLockService.create(LOCK_SERVICE_NAME,
+              cache.getInternalDistributedSystem(), true /* distributed */,
-          this.dls = DistributedLockService.getServiceNamed(LOCK_SERVICE_NAME);
-          if (this.dls == null) {
+          dls = DistributedLockService.getServiceNamed(LOCK_SERVICE_NAME);
+          if (dls == null) {
-      return this.dls;
+      return dls;
-    int newTypeId = id | this.dsId;
+    int newTypeId = id | distributedSystemId;
-        if (id > this.maxTypeId) {
+        if (id > maxTypeId) {
-        newTypeId = id | this.dsId;
+        newTypeId = id | distributedSystemId;
-    int newEnumId = id | this.dsId;
+    int newEnumId = id | distributedSystemId;
-      int maxTry = this.maxTypeId;
+      int maxTry = maxTypeId;
-                  + this.maxTypeId);
+                  + maxTypeId);
-        if (id > this.maxTypeId) {
+        if (id > maxTypeId) {
-        newEnumId = id | this.dsId;
+        newEnumId = id | distributedSystemId;
+  @SuppressWarnings("unchecked")
-    if (!typeRegistryInUse || this.idToType == null) {
+    if (!typeRegistryInUse || idToType == null) {
-    checkAllowed(true, this.cache.hasPersistentRegion());
+    checkAllowed(true, cache.hasPersistentRegion());
-  public boolean hasGatewaySender() {
+  private boolean hasGatewaySender() {
-    Iterator<GatewaySender> itr = sendersAndAsyncQueues.iterator();
-    while (itr.hasNext()) {
-      GatewaySender sender = itr.next();
-      if (AsyncEventQueueImpl.isAsyncEventQueue(sender.getId())) {
-        itr.remove();
-      }
-    }
+    sendersAndAsyncQueues.removeIf(sender -> AsyncEventQueueImpl.isAsyncEventQueue(sender.getId()));
-    if (typeRegistryInUse) {
-      return;
-    } else {
-      checkAllowed(hasGatewaySender(), this.cache.hasPersistentRegion());
+    if (!typeRegistryInUse) {
+      checkAllowed(hasGatewaySender(), cache.hasPersistentRegion());
-          if (tmpDsId == this.dsId) {
+          if (tmpDsId == distributedSystemId) {
-      if (totalPdxTypeIdInDS == this.maxTypeId) {
+      if (totalPdxTypeIdInDS == maxTypeId) {
-                + this.maxTypeId);
+                + maxTypeId);
-          if (tmpDsId == this.dsId) {
+          if (tmpDsId == distributedSystemId) {
-      if (totalEnumIdInDS == this.maxTypeId) {
+      if (totalEnumIdInDS == maxTypeId) {
-                + this.maxTypeId);
+                + maxTypeId);
-    Map<Integer, EnumInfo> enums = new HashMap<Integer, EnumInfo>();
+    Map<Integer, EnumInfo> enums = new HashMap<>();
-      synchronized (this.classToType) {
+      synchronized (classToType) {
-        CopyOnWriteHashSet<PdxType> pdxTypeSet = this.classToType.get(type.getClassName());
+        CopyOnWriteHashSet<PdxType> pdxTypeSet = classToType.get(type.getClassName());
-          pdxTypeSet = new CopyOnWriteHashSet<PdxType>();
+          pdxTypeSet = new CopyOnWriteHashSet<>();
+  @Deprecated
-    if (cache == null) {
-      return 0;
-    }
-

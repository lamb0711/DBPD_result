GEODE-2198: close and re-create the cache on a server when importing new cluster configuration

* When importing cluster config first check if there is any non-empty region
* close and re-create cache if no data exists when importing new cluster configuration
* put the acquire/release lock inside the ClusterConfigurationService instead of command execution strategy.

-import java.lang.reflect.Method;
-
-import org.springframework.shell.event.ParseResult;
-import org.springframework.util.Assert;
-import org.springframework.util.ReflectionUtils;
-
-import org.apache.geode.distributed.DistributedLockService;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.springframework.shell.event.ParseResult;
+import org.springframework.util.Assert;
+import org.springframework.util.ReflectionUtils;
+
+import java.lang.reflect.Method;
-        GemFireCacheImpl gfc = GemFireCacheImpl.getInstance();
-
-        // Do the locking and annotation check only if the shared configuration service is enabled
-        // Else go the usual route of command execution
-        // TODO: why do we need to care about this here?
-        if (gfc.getDistributionManager().isSharedConfigurationServiceEnabledForDS()
-            && (writesToSharedConfiguration(method) || readsFromSharedConfiguration(method))) {
-          DistributedLockService dls = ClusterConfigurationService
-              .getSharedConfigLockService(InternalDistributedSystem.getAnyInstance());
-          if (dls.lock(ClusterConfigurationService.SHARED_CONFIG_LOCK_NAME, 10000, -1)) {
-            try {
-              result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(),
-                  gfshParseResult.getInstance(), gfshParseResult.getArguments());
-            } finally {
-              dls.unlock(ClusterConfigurationService.SHARED_CONFIG_LOCK_NAME);
-            }
-          } else {
-            return ResultBuilder.createGemFireErrorResult(
-                "Unable to execute the command due to ongoing configuration change/member startup.");
-          }
-        } else {
-          result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(),
-              gfshParseResult.getInstance(), gfshParseResult.getArguments());
-        }
-
+        result = (Result) ReflectionUtils.invokeMethod(gfshParseResult.getMethod(),
+            gfshParseResult.getInstance(), gfshParseResult.getArguments());
-  private boolean writesToSharedConfiguration(Method method) {
-    CliMetaData cliMetadata = method.getAnnotation(CliMetaData.class);
-    return cliMetadata != null && cliMetadata.writesToSharedConfiguration();
-  }
-
-  private boolean readsFromSharedConfiguration(Method method) {
-    CliMetaData cliMetadata = method.getAnnotation(CliMetaData.class);
-    return cliMetadata != null && cliMetadata.readsSharedConfiguration();
-  }
-

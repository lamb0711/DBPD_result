GEODE-5420: Protect events in HAContainer from premature modification

- Updated putInProgress boolean in HAWrapper to a counter to prevent prematurely setting ClientUpdateMessage to null when events are temporarily queued during a GII or message dispatcher initialization
- decAndRemoveFromHAContainer only removes when putInProgress counter and ref count are 0
- Refactored putEventInHARegion/putConditionallyInHAContainer to prevent overwriting an existing entry in the HAContainer.  Also reduces simplifies the code and reduces duplicated logic.
- Wrote missing basic HARegionQueue unit/integration tests, and an integration test to capture setting the ClientUpdateMessage property on HAEventWrapper to null prematurely
- Added new event tracing messages at debug logging level to help track similar issues in the future

Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
Co-authored-by: Lynn Hughes-Godfrey <lhughesgodfrey@pivotal.io>

+        HAEventWrapper haContainerKey = null;
+
-          // bug #43609 - prevent loss of the message while in the queue
-          putEntryConditionallyIntoHAContainer((HAEventWrapper) object);
+          HAEventWrapper wrapper = (HAEventWrapper) object;
+          wrapper.incrementPutInProgressCounter();
+          if (logger.isDebugEnabled()) {
+            logger
+                .debug("Incremented PutInProgressCounter during GII queueing. Event ID hash code: "
+                    + wrapper.hashCode() + "; System ID hash code: "
+                    + System.identityHashCode(wrapper)
+                    + "; Wrapper details: " + wrapper);
+          }
+
-                // if there is no wrapped message look for it in the HA container map
-                ClientUpdateMessageImpl haContainerMessage =
-                    (ClientUpdateMessageImpl) haContainer.get(value);
-                if (haContainerMessage != null) {
-                  ((HAEventWrapper) value).setClientUpdateMessage(haContainerMessage);
-                } else {
-                  if (isDebugEnabled) {
-                    logger.debug(
-                        "{} ATTENTION: found gii queued event with null event message.  Please see bug #44852: {}",
-                        this.regionName, value);
-                  }
-                  continue;
+                if (isDebugEnabled) {
+                  logger.debug(
+                      "{} ATTENTION: found gii queued event with null event message.  Please see bug #44852: {}",
+                      this.regionName, value);
+                continue;
+
+
+            // The HAEventWrapper putInProgressCounter must be decremented because it was
+            // incremented when it was queued in giiQueue.
-              decAndRemoveFromHAContainer((HAEventWrapper) value);
+              ((HAEventWrapper) value).decrementPutInProgressCounter();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Adding position " + position + " to available IDs. Region: " + regionName);
+      }
+
-   *        where expiry is aborted if this function returns false
+   *        where
+   *        expiry is aborted if this function returns false
+    if (logger.isDebugEnabled()) {
+      logger.debug("Removing position " + position + " from available IDs. Region: " + regionName);
+    }
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("Removing position " + position + " from available IDs and region. Region: "
+          + this.regionName);
+    }
+
-    if (Thread.interrupted())
+    if (Thread.interrupted()) {
+    }
+
+
+
+      // It is possible for the object to be null if a queue removal
+      // occurred between getting the next available ID and getting the object
+      // from the region. If this happens, on the next iteration of this loop we will
+      // get a different available ID to process
-        // peeked a object, so add the correponding counter to thread-context
-        if (object != null) { // Is it possible for object to be null...when?
+        if (object != null) {
-            if ((HAEventWrapper) haContainer.getKey(entryHaEventWrapper) != null) {
+            if (entryHaEventWrapper == (HAEventWrapper) haContainer.getKey(entryHaEventWrapper)) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("GII Update of Event ID hash code: " + entryHaEventWrapper.hashCode()
+                    + "; System ID hash code: " + System.identityHashCode(entryHaEventWrapper)
+                    + "; Wrapper details: " + entryHaEventWrapper);
+              }
-            inputHaEventWrapper.setIsRefFromHAContainer(true);
+            if (logger.isDebugEnabled()) {
+              logger.debug("GII Add of Event ID hash code: " + inputHaEventWrapper.hashCode()
+                  + "; System ID hash code: " + System.identityHashCode(inputHaEventWrapper)
+                  + "; Wrapper details: " + entryHaEventWrapper);
+            }
+      Conflatable eventInHARegion = null;
+
+
-          owningQueue.putEventInHARegion(event, position);
+          eventInHARegion = owningQueue.putEventInHARegion(event, position);
-          if (owningQueue.shouldBeConflated(event)) {
+          if (owningQueue.shouldBeConflated(eventInHARegion)) {
-            oldPosition = owningQueue.addToConflationMap(event, position);
+            oldPosition = owningQueue.addToConflationMap(eventInHARegion, position);
-        owningQueue.entryEnqueued(event);
+        owningQueue.entryEnqueued(eventInHARegion);
-            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) conflatable);
+            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) conflatable,
+                "Remove Old Conflated Entry");
-              owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) event);
+
+              owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) event,
+                  "Queue Removal Message");
-            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) wrapper);
+            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) wrapper, "Message Dispatcher");
-  protected void putEventInHARegion(Conflatable event, Long position) {
+  protected Conflatable putEventInHARegion(Conflatable event, Long position) {
+      HAEventWrapper haContainerKey = null;
+
-        if (inputHaEventWrapper.getIsRefFromHAContainer()) {
-          putEntryConditionallyIntoHAContainer(inputHaEventWrapper);
-        } else {
-          // This means that the haEventWrapper reference we have is not
-          // authentic, i.e. it doesn't refer to the HAEventWrapper instance
-          // in the haContainer, but to the one outside it.
-          HAEventWrapper haContainerKey = null;
-          do {
-            ClientUpdateMessageImpl haContainerEntry =
-                (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer)
-                    .putIfAbsent(inputHaEventWrapper, inputHaEventWrapper.getClientUpdateMessage());
-            if (haContainerEntry != null) {
-              haContainerKey = (HAEventWrapper) ((HAContainerWrapper) this.haContainer)
-                  .getKey(inputHaEventWrapper);
-              if (haContainerKey == null) {
-                continue;
-              }
-              synchronized (haContainerKey) {
-                // assert the entry is still present
-                if (((HAContainerWrapper) this.haContainer).getKey(haContainerKey) != null) {
-                  haContainerKey.incAndGetReferenceCount();
-                  addClientCQsAndInterestList(haContainerEntry, inputHaEventWrapper,
-                      this.haContainer, this.regionName);
-                  inputHaEventWrapper = haContainerKey;
-                } else {
-                  haContainerKey = null;
-                }
-              }
-            } else {
-              synchronized (inputHaEventWrapper) {
-                inputHaEventWrapper.incAndGetReferenceCount();
-                inputHaEventWrapper.setHAContainer(this.haContainer);
-                if (!inputHaEventWrapper.getPutInProgress()) {
-                  // This means that this is a GII'ed event. Hence we must
-                  // explicitly set 'clientUpdateMessage' to null.
-                  inputHaEventWrapper.setClientUpdateMessage(null);
-                }
-                inputHaEventWrapper.setIsRefFromHAContainer(true);
-              }
-              break;
-            }
-          } while (haContainerKey == null);
-        }
+        haContainerKey = putEntryConditionallyIntoHAContainer(inputHaEventWrapper);
+      } else {
+        haContainerKey = inputHaEventWrapper;
-      // Put the reference to the HAEventWrapper instance into the
-      // HA queue.
+
-        logger.debug("adding inputHaEventWrapper to HARegion at " + position + ":"
-            + inputHaEventWrapper + " for " + this.regionName);
+        logger.debug("adding haContainerKey to HARegion at " + position + ":"
+            + haContainerKey + " for " + this.regionName);
-      this.region.put(position, inputHaEventWrapper);
+      this.region.put(position, haContainerKey);
+
+      return haContainerKey;
+
+      return event;
-    // if (haEventWrapper.getPutInProgress()) {
-    // ((HAEventWrapper)entry.getKey()).setPutInProgress(true);
-    // }
-    if (clientMsg.isClientInterestedInUpdates(proxyID)) {
-      msg.addClientInterestList(proxyID, true);
-    } else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
-      msg.addClientInterestList(proxyID, false);
+    if (clientMsg != null) {
+      if (clientMsg.isClientInterestedInUpdates(proxyID)) {
+        msg.addClientInterestList(proxyID, true);
+      } else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
+        msg.addClientInterestList(proxyID, false);
+      }
-   * @param haEventWrapper An instance of {@code HAEventWrapper}
+   * @param inputHaEventWrapper An instance of {@code HAEventWrapper}
-  protected void putEntryConditionallyIntoHAContainer(HAEventWrapper haEventWrapper) {
-    if (haEventWrapper.incAndGetReferenceCount() == 1) {
-      // if (logger.isDebugEnabled()) {
-      // logger.fine("Putting event in haContainer: " + haEventWrapper);
-      // }
-      haEventWrapper.setHAContainer(HARegionQueue.this.haContainer);
-      this.haContainer.put(haEventWrapper, haEventWrapper.getClientUpdateMessage());
+  protected HAEventWrapper putEntryConditionallyIntoHAContainer(
+      HAEventWrapper inputHaEventWrapper) {
+    HAEventWrapper haContainerKey = null;
+
+    while (haContainerKey == null) {
+      ClientUpdateMessageImpl haContainerEntry =
+          (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer)
+              .putIfAbsent(inputHaEventWrapper, inputHaEventWrapper.getClientUpdateMessage());
+
+      if (haContainerEntry != null) {
+        haContainerKey = (HAEventWrapper) ((HAContainerWrapper) this.haContainer)
+            .getKey(inputHaEventWrapper);
+
+        // Key was already removed from the container, so continue
+        if (haContainerKey == null) {
+          continue;
+        }
+
+        synchronized (haContainerKey) {
+          // assert the entry is still present and we still have the same reference
+          if (haContainerKey == ((HAContainerWrapper) this.haContainer).getKey(haContainerKey)) {
+            haContainerKey.incAndGetReferenceCount();
+
+            addClientCQsAndInterestList(haContainerEntry, inputHaEventWrapper,
+                this.haContainer, this.regionName);
+
+            if (logger.isDebugEnabled()) {
+              logger.debug("Putting updated event in haContainer with Event ID hash code: "
+                  + haContainerKey.hashCode() + "; System ID hash code: "
+                  + System.identityHashCode(haContainerKey)
+                  + "; Wrapper details: " + haContainerKey);
+            }
+          } else {
+            haContainerKey = null;
+          }
+        }
+      } else {
+        synchronized (inputHaEventWrapper) {
+          inputHaEventWrapper.incAndGetReferenceCount();
+          inputHaEventWrapper.setHAContainer(this.haContainer);
+
+          if (!inputHaEventWrapper.getPutInProgress()) {
+            // This means that this is a GII'ed event. Hence we must
+            // explicitly set 'clientUpdateMessage' to null.
+            inputHaEventWrapper.setClientUpdateMessage(null);
+          }
+
+          if (logger.isDebugEnabled()) {
+            logger.debug("Putting new event in haContainer with Event ID hash code: "
+                + inputHaEventWrapper.hashCode()
+                + "; System ID hash code: " + System.identityHashCode(inputHaEventWrapper)
+                + "; Wrapper details: " + inputHaEventWrapper);
+          }
+        }
+
+        haContainerKey = inputHaEventWrapper;
+      }
+
+    return haContainerKey;
+
-                  HARegionQueue.this.decAndRemoveFromHAContainer((HAEventWrapper) conflatable);
+                  HARegionQueue.this
+                      .decAndRemoveFromHAContainer((HAEventWrapper) conflatable, "Destroy");
-        });
+        }, "HA Region Cleanup for " + regionName);
-        decAndRemoveFromHAContainer(wrapper);
+        decAndRemoveFromHAContainer(wrapper, "GetAndRemoveFromHAContainer");
-   * IMPORTANT: <br>
-   * The wrapper passed here must be the authentic wrapper, i.e. it must be the one referred by the
-   * HARegion underlying this queue. <br>
-   * Decrements wrapper's reference count by one. If the decremented ref count is zero and put is
-   * not in progress, removes the entry from the haContainer.
+   * Decrements reference count for the wrapper in the container by one. If the decremented ref
+   * count is zero and put is not in progress, removes the entry from the haContainer.
-    if (wrapper.decAndGetReferenceCount() == 0L && !wrapper.getPutInProgress()) {
-      synchronized (wrapper) {
-        if (wrapper.getReferenceCount() == 0L) {
+    decAndRemoveFromHAContainer(wrapper, "");
+  }
+
+  public void decAndRemoveFromHAContainer(HAEventWrapper wrapper, String caller) {
+    boolean decAndRemovePerformed = false;
+
+    while (!decAndRemovePerformed) {
+      HAEventWrapper haContainerKey =
+          (HAEventWrapper) ((HAContainerWrapper) haContainer).getKey(wrapper);
+
+      if (haContainerKey == null) {
+        break;
+      }
+
+      synchronized (haContainerKey) {
+        if (haContainerKey == (HAEventWrapper) ((HAContainerWrapper) haContainer).getKey(wrapper)) {
-            logger.debug("Removing event from {}: {}", this.region.getFullPath(),
-                wrapper.getEventId());
+            logger.debug(caller + " decremented Event ID hash code: " + haContainerKey.hashCode()
+                + "; System ID hash code: " + System.identityHashCode(haContainerKey)
+                + "; Wrapper details: " + haContainerKey);
-          HARegionQueue.this.haContainer.remove(wrapper);
+          if (haContainerKey.decAndGetReferenceCount() == 0L) {
+            HARegionQueue.this.haContainer.remove(haContainerKey);
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  caller + " removed Event ID hash code: " + haContainerKey.hashCode()
+                      + "; System ID hash code: "
+                      + System.identityHashCode(haContainerKey)
+                      + "; Wrapper details: " + haContainerKey);
+            }
+          }
+          decAndRemovePerformed = true;

GEODE-4094: ClientHealthMonitor may cause an NPE in a ServerConnection (#1326)

* GEODE-4094: ClientHealthMonitor may cause an NPE in a ServerConnection

- minor refactoring of AcceptorImpl and Handshake to improve testability
- added a unit test to demonstrate race condition
- refactored connection map into a new object to prevent race

-import org.apache.commons.lang.StringUtils;
-   * The map of known client threads
-   */
-  private final Map _clientThreads;
-
-  /**
-   * An object used to lock the map of client threads
-   */
-  private final Object _clientThreadsLock = new Object();
-
-  /**
+   * Used to track the connections for a particular client
+   */
+  private final HashMap<ClientProxyMembershipID, ServerConnectionCollection> proxyIdConnections =
+      new HashMap<>();
+
+  /**
-  public void addConnection(ClientProxyMembershipID proxyID, ServerConnection connection) {
-    // logger.info("ClientHealthMonitor: Adding " + connection + " to
-    // client with member id " + proxyID);
-    synchronized (_clientThreadsLock) {
-      Set serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections == null) {
-        serverConnections = new HashSet();
-        this._clientThreads.put(proxyID, serverConnections);
-      }
-      serverConnections.add(connection);
-      // logger.info("ClientHealthMonitor: The client with member id " +
-      // proxyID + " contains " + serverConnections.size() + " threads");
+  public ServerConnectionCollection addConnection(ClientProxyMembershipID proxyID,
+      ServerConnection connection) {
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = getProxyIdCollection(proxyID);
+      collection.addConnection(connection);
+      return collection;
-    // logger.info("ClientHealthMonitor: Removing " + connection + " from
-    // client with member id " + proxyID);
-    synchronized (_clientThreadsLock) {
-      Set serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections != null) { // fix for bug 35343
-        serverConnections.remove(connection);
-        // logger.info("ClientHealthMonitor: The client with member id " +
-        // proxyID + " contains " + serverConnections.size() + " threads");
-        if (serverConnections.isEmpty()) {
-          // logger.info("ClientHealthMonitor: The client with member id "
-          // + proxyID + " is being removed since it contains 0 threads");
-          this._clientThreads.remove(proxyID);
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+      if (collection != null) {
+        collection.removeConnection(connection);
+        if (collection.getConnections().isEmpty()) {
+          proxyIdConnections.remove(proxyID);
-  public Map getConnectedClients(Set filterProxies) {
-    Map map = new HashMap(); // KEY=proxyID, VALUE=connectionCount (Integer)
-    synchronized (_clientThreadsLock) {
-      Iterator connectedClients = this._clientThreads.entrySet().iterator();
-      while (connectedClients.hasNext()) {
-        Map.Entry entry = (Map.Entry) connectedClients.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();// proxyID
-                                                                                   // includes FQDN
+  public Map<String, Object[]> getConnectedClients(Set filterProxies) {
+    Map<String, Object[]> map = new HashMap<>(); // KEY=proxyID, VALUE=connectionCount (Integer)
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, ServerConnectionCollection> entry : proxyIdConnections
+          .entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();// proxyID
+        // includes FQDN
-          Set connections = (Set) entry.getValue();
+          Set<ServerConnection> connections = entry.getValue().getConnections();
-          Iterator serverConnections = connections.iterator();
-          while (serverConnections.hasNext()) {
-            ServerConnection sc = (ServerConnection) serverConnections.next();
+          for (ServerConnection sc : connections) {
-          data = (Object[]) map.get(membershipID);
+          data = map.get(membershipID);
-  public Map getStatusForAllClients() {
-    Map result = new HashMap();
-    synchronized (_clientThreadsLock) {
-      Iterator connectedClients = this._clientThreads.entrySet().iterator();
-      while (connectedClients.hasNext()) {
-        Map.Entry entry = (Map.Entry) connectedClients.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();
+  public Map<ClientProxyMembershipID, CacheClientStatus> getStatusForAllClients() {
+    Map<ClientProxyMembershipID, CacheClientStatus> result = new HashMap<>();
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, ServerConnectionCollection> entry : proxyIdConnections
+          .entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();
-        Set connections = (Set) this._clientThreads.get(proxyID);
+        Set<ServerConnection> connections = entry.getValue().getConnections();
-          Iterator connectionsIterator = connections.iterator();
-          while (connectionsIterator.hasNext()) {
-            ServerConnection sc = (ServerConnection) connectionsIterator.next();
+          for (ServerConnection sc : connections) {
-  public void fillInClientInfo(Map allClients) {
+  public void fillInClientInfo(Map<ClientProxyMembershipID, CacheClientStatus> allClients) {
-    synchronized (_clientThreadsLock) {
-      Iterator allClientsIterator = allClients.entrySet().iterator();
-      while (allClientsIterator.hasNext()) {
-        Map.Entry entry = (Map.Entry) allClientsIterator.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();// proxyID
-                                                                                   // includes FQDN
-        CacheClientStatus cci = (CacheClientStatus) entry.getValue();
-        Set connections = (Set) this._clientThreads.get(proxyID);
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, CacheClientStatus> entry : allClients.entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();// proxyID
+        // includes FQDN
+        CacheClientStatus cci = entry.getValue();
+        ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+        Set<ServerConnection> connections = collection != null ? collection.getConnections() : null;
-          Iterator connectionsIterator = connections.iterator();
-          while (connectionsIterator.hasNext()) {
-            ServerConnection sc = (ServerConnection) connectionsIterator.next();
+          for (ServerConnection sc : connections) {
-                                             // same member id
+            // same member id
-  public Map getConnectedIncomingGateways() {
-    Map connectedIncomingGateways = new HashMap();
-    synchronized (_clientThreadsLock) {
-      Iterator connectedClients = this._clientThreads.entrySet().iterator();
-      while (connectedClients.hasNext()) {
-        Map.Entry entry = (Map.Entry) connectedClients.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();
-        Set connections = (Set) entry.getValue();
-        Iterator connectionsIterator = connections.iterator();
-        while (connectionsIterator.hasNext()) {
-          ServerConnection sc = (ServerConnection) connectionsIterator.next();
+  public Map<String, IncomingGatewayStatus> getConnectedIncomingGateways() {
+    Map<String, IncomingGatewayStatus> connectedIncomingGateways = new HashMap<>();
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, ServerConnectionCollection> entry : proxyIdConnections
+          .entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();
+        Set<ServerConnection> connections = entry.getValue().getConnections();
+        for (ServerConnection sc : connections) {
-    synchronized (this._clientThreadsLock) {
-      serverConnections = (Set) this._clientThreads.remove(proxyID);
-      // It is ok to modify the set after releasing the sync
-      // because it has been removed from the map while holding
-      // the sync.
-    } // end sync here to fix bug 37576 and 36740
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.remove(proxyID);
+      if (collection != null) {
+        serverConnections = collection.getConnections();
+      }
+    }
-        // logger.warn("Terminating " + serverConnections.size() + " connections");
-          // logger.warn("Terminating " + serverConnection);
-  protected boolean isAnyThreadProcessingMessage(ClientProxyMembershipID proxyID) {
-    boolean processingMessage = false;
-    synchronized (this._clientThreadsLock) {
-      Set serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections != null) {
-        for (Iterator it = serverConnections.iterator(); it.hasNext();) {
-          ServerConnection serverConnection = (ServerConnection) it.next();
-          if (serverConnection.isProcessingMessage()) {
-            processingMessage = true;
-            break;
-          }
-        }
+  // This will return true if the proxyID is truly idle (or if no connections are found), or false
+  // if there was a active connection.
+  private boolean prepareToTerminateIfNoConnectionIsProcessing(ClientProxyMembershipID proxyID) {
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+      if (collection == null) {
+        return true;
+      }
+      if (collection.connectionsProcessing.get() == 0) {
+        collection.isTerminating = true;
+        return true;
+      } else {
+        return false;
-    return processingMessage;
-    Set serverConnections = null;
-    synchronized (this._clientThreadsLock) {
-      serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections != null) {
-        serverConnections = new HashSet(serverConnections);
-      }
+    Set<ServerConnection> serverConnections;
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+      serverConnections =
+          collection != null ? new HashSet<>(collection.getConnections()) : Collections.emptySet();
-    if (serverConnections != null) {
-      for (Iterator it = serverConnections.iterator(); it.hasNext();) {
-        ServerConnection serverConnection = (ServerConnection) it.next();
-        if (serverConnection.hasBeenTimedOutOnClient()) {
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.ClientHealtMonitor_0_IS_BEING_TERMINATED_BECAUSE_ITS_CLIENT_TIMEOUT_OF_1_HAS_EXPIRED,
-              new Object[] {serverConnection,
-                  Integer.valueOf(serverConnection.getClientReadTimeout())}));
-          try {
-            serverConnection.handleTermination(true);
-            // Not all the code in a ServerConnection correctly
-            // handles interrupt. In particular it is possible to be doing
-            // p2p distribution and to have sent a message to one peer but
-            // to never send it to another due to interrupt.
-            // serverConnection.interruptOwner();
-          } finally {
-            // Just to be sure we clean it up.
-            // This call probably isn't needed.
-            removeConnection(proxyID, serverConnection);
-          }
+    for (ServerConnection serverConnection : serverConnections) {
+      if (serverConnection.hasBeenTimedOutOnClient()) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.ClientHealtMonitor_0_IS_BEING_TERMINATED_BECAUSE_ITS_CLIENT_TIMEOUT_OF_1_HAS_EXPIRED,
+            new Object[] {serverConnection,
+                Integer.valueOf(serverConnection.getClientReadTimeout())}));
+        try {
+          serverConnection.handleTermination(true);
+          // Not all the code in a ServerConnection correctly
+          // handles interrupt. In particular it is possible to be doing
+          // p2p distribution and to have sent a message to one peer but
+          // to never send it to another due to interrupt.
+          // serverConnection.interruptOwner();
+        } finally {
+          // Just to be sure we clean it up.
+          // This call probably isn't needed.
+          removeConnection(proxyID, serverConnection);
+
-    // Initialize the client threads map
-    this._clientThreads = new HashMap();
-
+  public ServerConnectionCollection getProxyIdCollection(ClientProxyMembershipID proxyID) {
+    return proxyIdConnections.computeIfAbsent(proxyID, key -> new ServerConnectionCollection());
+  }
+
-          // logger.warning("Monitoring " + getClientHeartbeats().size() +
-          // " client(s).");
-                if (isAnyThreadProcessingMessage(proxyID)) {
-                  if (logger.isDebugEnabled()) {
-                    logger.debug(
-                        "Monitoring client with member id {}. It has been {} ms since the latest heartbeat. This client would have been terminated but at least one of its threads is processing a message.",
-                        entry.getKey(), (currentTime - latestHeartbeat));
-                  }
-                } else {
+                if (prepareToTerminateIfNoConnectionIsProcessing(proxyID)) {
+                } else {
+                  if (logger.isDebugEnabled()) {
+                    logger.debug(
+                        "Monitoring client with member id {}. It has been {} ms since the latest heartbeat. This client would have been terminated but at least one of its threads is processing a message.",
+                        entry.getKey(), (currentTime - latestHeartbeat));
+                  }
-                // logger.warning("Monitoring client with member id " +
-                // entry.getKey() + ". It has been " + (currentTime -
-                // latestHeartbeat) + " ms since the latest heartbeat. This
-                // client is healthy.");

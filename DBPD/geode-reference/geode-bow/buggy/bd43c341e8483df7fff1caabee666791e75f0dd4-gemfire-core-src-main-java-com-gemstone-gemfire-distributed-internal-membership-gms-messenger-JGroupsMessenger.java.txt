new unit tests and code clean-up

New unit tests to increase code coverage.  I also tinkered with
trying to get EclEmma output from DUnit ChildVMs but it seems to
be run in a shutdownHook in parallel with the DUnitLauncher
shutdownHook.

+import org.jgroups.ReceiverAdapter;
+import com.gemstone.gemfire.GemFireIOException;
-   * The system property that specifies the name of a file from which to read
-   * Jgroups configuration information
-   */
-  public static final String JGROUPS_CONFIG = System
-      .getProperty("geode.jgroups_config_file");
-
-  /**
-  private volatile long pongsReceived;
+  protected volatile long pongsReceived;
-    if (JGROUPS_CONFIG != null) {
-      File file = new File(JGROUPS_CONFIG);
-      if (!file.exists()) {
-        throw new GemFireConfigException(LocalizedStrings.GroupMembershipService_JGROUPS_CONFIGURATION_FILE_0_DOES_NOT_EXIST.toLocalizedString(JGROUPS_CONFIG));
-      }
+    String r = null;
+    if (transport.isMcastEnabled()) {
+      r = DEFAULT_JGROUPS_MCAST_CONFIG;
+    } else {
+      r = DEFAULT_JGROUPS_TCP_CONFIG;
-    else {
-      String r = null;
-      if (transport.isMcastEnabled()) {
-        r = DEFAULT_JGROUPS_MCAST_CONFIG;
-      } else {
-        r = DEFAULT_JGROUPS_TCP_CONFIG;
-      }
-      is = ClassPathLoader.getLatest().getResourceAsStream(getClass(), r);
-      if (is == null) {
-        throw new GemFireConfigException(LocalizedStrings.GroupMembershipService_CANNOT_FIND_0.toLocalizedString(r));
-      }
+    is = ClassPathLoader.getLatest().getResourceAsStream(getClass(), r);
+    if (is == null) {
+      throw new GemFireConfigException(LocalizedStrings.GroupMembershipService_CANNOT_FIND_0.toLocalizedString(r));
-      if (JGROUPS_CONFIG != null) {
-        br = new BufferedReader(new InputStreamReader(is));
-      } else {
-        br = new BufferedReader(new InputStreamReader(is, "US-ASCII"));
-      }
+      br = new BufferedReader(new InputStreamReader(is, "US-ASCII"));
-        
+        // leave the channel open for reconnect attempts
-  public void handleJGroupsIOException(IOException e, Message msg, Address dest) {
+  public void handleJGroupsIOException(IOException e, Address dest) {
-    logger.info("processing JGroups IOException: " + e.getMessage());
-      if (this.jgAddress == null) {
-        String addr = udp.getLocalPhysicalAddress();
-        int cidx = addr.lastIndexOf(':');  // IPv6 literals might have colons
-        String host = addr.substring(0, cidx);
-        int jgport = Integer.parseInt(addr.substring(cidx+1, addr.length()));
-        try {
-          this.jgAddress = new JGAddress(logicalAddress, new IpAddress(InetAddress.getByName(host), jgport));
-        } catch (UnknownHostException e) {
-          myChannel.disconnect();
-          throw new SystemConnectException("unable to initialize jgroups address", e);
-        }
-      }
+//      if (this.jgAddress == null) {
+//        String addr = udp.getLocalPhysicalAddress();
+//        int cidx = addr.lastIndexOf(':');  // IPv6 literals might have colons
+//        String host = addr.substring(0, cidx);
+//        int jgport = Integer.parseInt(addr.substring(cidx+1, addr.length()));
+//        try {
+//          this.jgAddress = new JGAddress(logicalAddress, new IpAddress(InetAddress.getByName(host), jgport));
+//        } catch (UnknownHostException e) {
+//          myChannel.disconnect();
+//          throw new SystemConnectException("unable to initialize jgroups address", e);
+//        }
+//      }
-      useMcast = services.getManager().isMulticastAllowed()
-          && (msg.getMulticast() || allDestinations);
+      if (msg.getMulticast() || allDestinations) {
+        useMcast = services.getManager().isMulticastAllowed();
+      }
-      String recips = "multicast";
-      if (!useMcast) {
-        recips = Arrays.toString(msg.getRecipients());
-      }
+      String recips = useMcast? "multicast" : Arrays.toString(msg.getRecipients());
+      long startSer = theStats.startMsgSerialization();
+      Message jmsg = createJGMessage(msg, local, Version.CURRENT_ORDINAL);
+      theStats.endMsgSerialization(startSer);
+
-        long startSer = theStats.startMsgSerialization();
-        Message jmsg = createJGMessage(msg, local, Version.CURRENT_ORDINAL);
-        theStats.endMsgSerialization(startSer);
-      catch (IllegalArgumentException e) {
-        problem = e;
-      }
-      }
-      if (problem != null) {
-          Throwable cause = services.getShutdownCause();
+          Throwable shutdownCause = services.getShutdownCause();
-          if (cause instanceof ForcedDisconnectException) {
-            problem = (Exception) cause;
+          if (shutdownCause instanceof ForcedDisconnectException) {
+            problem = (Exception) shutdownCause;
-        List<GMSMember> calculatedMembers; // explicit list of members
-        int calculatedLen; // == calculatedMembers.len
-        if (len == 1 && destinations[0] == DistributionMessage.ALL_RECIPIENTS) { // send to all
-          // Grab a copy of the current membership
-          NetView v = services.getJoinLeave().getView();
-          
-          // Construct the list
-          calculatedLen = v.size();
-          calculatedMembers = new LinkedList<GMSMember>();
-          for (int i = 0; i < calculatedLen; i ++) {
-            InternalDistributedMember m = (InternalDistributedMember)v.get(i);
-            calculatedMembers.add((GMSMember)m.getNetMember());
-          }
-        } // send to all
-        else { // send to explicit list
-          calculatedLen = len;
-          calculatedMembers = new LinkedList<GMSMember>();
-          for (int i = 0; i < calculatedLen; i ++) {
-            calculatedMembers.add((GMSMember)destinations[i].getNetMember());
-          }
-        } // send to explicit list
-        Int2ObjectOpenHashMap<Message> messages = new Int2ObjectOpenHashMap<>();
-        long startSer = theStats.startMsgSerialization();
-        boolean firstMessage = true;
-        for (Iterator<GMSMember> it=calculatedMembers.iterator(); it.hasNext(); ) {
-          GMSMember mbr = it.next();
-          short version = mbr.getVersionOrdinal();
-          if ( !messages.containsKey(version) ) {
-            Message jmsg = createJGMessage(msg, local, version);
-            messages.put(version, jmsg);
-            if (firstMessage) {
-              theStats.incSentBytes(jmsg.getLength());
-              firstMessage = false;
-            }
+      List<GMSMember> calculatedMembers; // explicit list of members
+      int calculatedLen; // == calculatedMembers.len
+      if (len == 1 && destinations[0] == DistributionMessage.ALL_RECIPIENTS) { // send to all
+        // Grab a copy of the current membership
+        NetView v = services.getJoinLeave().getView();
+
+        // Construct the list
+        calculatedLen = v.size();
+        calculatedMembers = new LinkedList<GMSMember>();
+        for (int i = 0; i < calculatedLen; i ++) {
+          InternalDistributedMember m = (InternalDistributedMember)v.get(i);
+          calculatedMembers.add((GMSMember)m.getNetMember());
+        }
+      } // send to all
+      else { // send to explicit list
+        calculatedLen = len;
+        calculatedMembers = new LinkedList<GMSMember>();
+        for (int i = 0; i < calculatedLen; i ++) {
+          calculatedMembers.add((GMSMember)destinations[i].getNetMember());
+        }
+      } // send to explicit list
+      Int2ObjectOpenHashMap<Message> messages = new Int2ObjectOpenHashMap<>();
+      long startSer = theStats.startMsgSerialization();
+      boolean firstMessage = true;
+      for (Iterator<GMSMember> it=calculatedMembers.iterator(); it.hasNext(); ) {
+        GMSMember mbr = it.next();
+        short version = mbr.getVersionOrdinal();
+        if ( !messages.containsKey(version) ) {
+          Message jmsg = createJGMessage(msg, local, version);
+          messages.put(version, jmsg);
+          if (firstMessage) {
+            theStats.incSentBytes(jmsg.getLength());
+            firstMessage = false;
-        theStats.endMsgSerialization(startSer);
-        Collections.shuffle(calculatedMembers);
-        int i=0;
-        for (GMSMember mbr: calculatedMembers) {
-          JGAddress to = new JGAddress(mbr);
-          short version = mbr.getVersionOrdinal();
-          Message jmsg = (Message)messages.get(version);
-          Exception problem = null;
-          try {
-            Message tmp = (i < (calculatedLen-1)) ? jmsg.copy(true) : jmsg;
-            if (!reliably) {
-              jmsg.setFlag(Message.Flag.NO_RELIABILITY);
-            }
-            tmp.setDest(to);
-            tmp.setSrc(this.jgAddress);
-            logger.trace("Unicasting to {}", to);
-            myChannel.send(tmp);
+      }
+      theStats.endMsgSerialization(startSer);
+      Collections.shuffle(calculatedMembers);
+      int i=0;
+      for (GMSMember mbr: calculatedMembers) {
+        JGAddress to = new JGAddress(mbr);
+        short version = mbr.getVersionOrdinal();
+        Message jmsg = (Message)messages.get(version);
+        Exception problem = null;
+        try {
+          Message tmp = (i < (calculatedLen-1)) ? jmsg.copy(true) : jmsg;
+          if (!reliably) {
+            jmsg.setFlag(Message.Flag.NO_RELIABILITY);
-          catch (Exception e) {
-            problem = e;
-          }
-          if (problem != null) {
-            if (services.getManager().getShutdownCause() != null) {
-              Throwable cause = services.getManager().getShutdownCause();
-              // If ForcedDisconnectException occurred then report it as actual
-              // problem.
-              if (cause instanceof ForcedDisconnectException) {
-                problem = (Exception) cause;
-              } else {
-                Throwable ne = problem;
-                while (ne.getCause() != null) {
-                  ne = ne.getCause();
-                }
-                ne.initCause(services.getManager().getShutdownCause());
+          tmp.setDest(to);
+          tmp.setSrc(this.jgAddress);
+          logger.trace("Unicasting to {}", to);
+          myChannel.send(tmp);
+        }
+        catch (Exception e) {
+          problem = e;
+        }
+        if (problem != null) {
+          Throwable cause = services.getShutdownCause();
+          if (cause != null) {
+            // If ForcedDisconnectException occurred then report it as actual
+            // problem.
+            if (cause instanceof ForcedDisconnectException) {
+              problem = (Exception) cause;
+            } else {
+              Throwable ne = problem;
+              while (ne.getCause() != null) {
+                ne = ne.getCause();
+              ne.initCause(cause);
-          final String channelClosed = LocalizedStrings.GroupMembershipService_CHANNEL_CLOSED.toLocalizedString();
-//          services.getManager().membershipFailure(channelClosed, problem);
-          throw new DistributedSystemDisconnectedException(channelClosed, problem);
-        } // send individually
+          final String channelClosed = LocalizedStrings.GroupMembershipService_CHANNEL_CLOSED.toLocalizedString();
+          //          services.getManager().membershipFailure(channelClosed, problem);
+          throw new DistributedSystemDisconnectedException(channelClosed, problem);
+        }
+      } // send individually
-    catch(IOException ex) {
-        IllegalArgumentException ia = new
-          IllegalArgumentException("Error serializing message");
-        ia.initCause(ex);
-        throw ia;
-        //throw new IllegalArgumentException(ex.toString());
+    catch(IOException | GemFireIOException ex) {
+      logger.warn("Error serializing message", ex);
+      if (ex instanceof GemFireIOException) {
+        throw (GemFireIOException)ex;
+      } else {
+        GemFireIOException ioe = new
+          GemFireIOException("Error serializing message");
+        ioe.initCause(ex);
+        throw ioe;
+      }
-      if (result instanceof DistributionMessage) {
-        DistributionMessage dm = (DistributionMessage)result;
-        // JoinRequestMessages are sent with an ID that may have been
-        // reused from a previous life by way of auto-reconnect,
-        // so we don't want to find a canonical reference for the
-        // request's sender ID
-        if (dm.getDSFID() == JOIN_REQUEST) {
-          sender = ((JoinRequestMessage)dm).getMemberID();
-        } else {
-          sender = getMemberFromView(m, ordinal);
-        }
-        ((DistributionMessage)result).setSender(sender);
+
+      DistributionMessage dm = (DistributionMessage)result;
+      
+      // JoinRequestMessages are sent with an ID that may have been
+      // reused from a previous life by way of auto-reconnect,
+      // so we don't want to find a canonical reference for the
+      // request's sender ID
+      if (dm.getDSFID() == JOIN_REQUEST) {
+        sender = ((JoinRequestMessage)dm).getMemberID();
+      } else {
+        sender = getMemberFromView(m, ordinal);
+      ((DistributionMessage)result).setSender(sender);
-  private void filterOutgoingMessage(DistributionMessage m) {
+  void filterOutgoingMessage(DistributionMessage m) {
-      if (jrsp.getRejectionMessage() != null
+      if (jrsp.getRejectionMessage() == null
-        jrsp.setMessengerData(digest);
+        HeapDataOutputStream hdos = new HeapDataOutputStream(500, Version.CURRENT);
+        try {
+          digest.writeTo(hdos);
+        } catch (Exception e) {
+          logger.fatal("Unable to serialize JGroups messaging digest", e);
+        }
+        jrsp.setMessengerData(hdos.toByteArray());
-  private void filterIncomingMessage(DistributionMessage m) {
+  void filterIncomingMessage(DistributionMessage m) {
-      if (jrsp.getRejectionMessage() != null
+      if (jrsp.getRejectionMessage() == null
-        Digest digest = (Digest)jrsp.getMessengerData();
-        if (digest != null) {
-          logger.trace("installing JGroups message digest {}", digest);
-          this.myChannel.getProtocolStack()
-              .getTopProtocol().down(new Event(Event.SET_DIGEST, digest));
+        byte[] serializedDigest = jrsp.getMessengerData();
+        ByteArrayInputStream bis = new ByteArrayInputStream(serializedDigest);
+        DataInputStream dis = new DataInputStream(bis);
+        try {
+          Digest digest = new Digest();
+          digest.readFrom(dis);
+          if (digest != null) {
+            logger.trace("installing JGroups message digest {}", digest);
+            this.myChannel.getProtocolStack()
+                .getTopProtocol().down(new Event(Event.SET_DIGEST, digest));
+            jrsp.setMessengerData(null);
+          }
+        } catch (Exception e) {
+          logger.fatal("Unable to read JGroups messaging digest", e);
-   * returns the JGroups configuration string
+   * returns the JGroups configuration string, for testing
+   * returns the pinger, for testing
+   */
+  public GMSPingPonger getPingPonger() {
+    return this.pingPonger;
+  }
+  
+  /**
-   * Puller receives incoming JGroups messages and passes them to a handler
+   * JGroupsReceiver receives incoming JGroups messages and passes them to a handler.
+   * It may be accessed through JChannel.getReceiver().
-  class JGroupsReceiver implements Receiver  {
+  class JGroupsReceiver extends ReceiverAdapter  {
+      if (contents == null) {
+        return;
+      }
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.GroupMembershipService_MEMBERSHIP_GEMFIRE_RECEIVED_NULL_MESSAGE_FROM__0, String.valueOf(jgmsg)));
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.GroupMembershipService_MEMBERSHIP_MESSAGE_HEADERS__0, jgmsg.printObjectHeaders()));
-        return;
-      } else if ( !(o instanceof DistributionMessage) ) {
-        logger.warn("Received something other than a message from " + jgmsg.getSrc() + ": " + o);
+      assert msg.getSender() != null;
-        if (logger.isTraceEnabled())
-          logger.trace("Membership: admin VM discarding cache operation message {}", jgmsg.getObject());
-      if (msg.getSender() == null) {
-        Exception e = new Exception(LocalizedStrings.GroupMembershipService_NULL_SENDER.toLocalizedString());
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.GroupMembershipService_MEMBERSHIP_GEMFIRE_RECEIVED_A_MESSAGE_WITH_NO_SENDER_ADDRESS), e);
-      }
-      
-        if (logger.isTraceEnabled()) {
-          logger.trace("JGroupsMessenger dispatching {} from {}", msg, msg.getSender());
-        }
+        logger.trace("JGroupsMessenger dispatching {} from {}", msg, msg.getSender());
-        MessageHandler h = getMessageHandler(msg);
-        logger.trace("Handler for this message is {}", h);
-        h.processMessage(msg);
+        getMessageHandler(msg).processMessage(msg);
-    
-    
-    @Override
-    public void block() {
-    }
-    
-
-    @Override
-    public void viewAccepted(View new_view) {
-    }
-
-
-    @Override
-    public void getState(OutputStream output) throws Exception {
-    }
-
-    @Override
-    public void setState(InputStream input) throws Exception {
-    }
-
-    @Override
-    public void suspect(Address suspected_mbr) {
-    }
-
-    @Override
-    public void unblock() {
-    }
-    
-        
-  } // Puller class
+  }

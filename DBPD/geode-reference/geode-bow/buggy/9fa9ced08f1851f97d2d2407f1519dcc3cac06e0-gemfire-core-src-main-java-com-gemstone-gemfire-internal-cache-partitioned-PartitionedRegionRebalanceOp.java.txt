GEODE-74: Making the satisfy redundancy phase of rebalance parallel

Tasks submitted to background threads to trigger redundancy
satisfaction. After the satisfy redundancy phase is done we wait for the
tasks to finish.

The number of buckets that can be recovering in parallel is controlled
by the system property gemfire.MAX_PARALLEL_BUCKET_RECOVERIES, currently
set to 8.

If a redundancy recovery/rebalance is restarted due to a membership
change, wait for any in progress operations to complete before fetching
new information from all of the members.

+import com.gemstone.gemfire.internal.cache.partitioned.rebalance.ParallelBucketOperator;
+  private static final int MAX_PARALLEL_OPERATIONS = Integer.getInteger("gemfire.MAX_PARALLEL_BUCKET_RECOVERIES", 8);
+  
-      BucketOperatorWrapper operator = getBucketOperator(detailsMap);
-      model = buildModel(operator, detailsMap, resourceManager);
-      for(PartitionRebalanceDetailsImpl details : operator.getDetailSet()) {
+      BucketOperatorWrapper serialOperator = getBucketOperator(detailsMap);
+      ParallelBucketOperator parallelOperator = new ParallelBucketOperator(MAX_PARALLEL_OPERATIONS, cache.getDistributionManager().getWaitingThreadPool(), serialOperator);
+      model = buildModel(parallelOperator, detailsMap, resourceManager);
+      for(PartitionRebalanceDetailsImpl details : serialOperator.getDetailSet()) {
+          model.waitForOperations();
-          model = buildModel(operator, detailsMap, resourceManager);
+          model = buildModel(parallelOperator, detailsMap, resourceManager);
-      for(PartitionRebalanceDetailsImpl details : operator.getDetailSet()) {
+      for(PartitionRebalanceDetailsImpl details : serialOperator.getDetailSet()) {
-      return Collections.<PartitionRebalanceInfo>unmodifiableSet(operator.getDetailSet());
+      return Collections.<PartitionRebalanceInfo>unmodifiableSet(serialOperator.getDetailSet());
+    @Override
+    @Override
-    public boolean createRedundantBucket(
+    @Override
+    public void createRedundantBucket(
-        Map<String, Long> colocatedRegionBytes) {
-      return createRedundantBucketForRegion(targetMember, bucketId,
+        Map<String, Long> colocatedRegionBytes, Completion completion) {
+      boolean result = false;
+      try {
+        result = createRedundantBucketForRegion(targetMember, bucketId,
+      } finally {
+        if(result) {
+          completion.onSuccess();
+        } else {
+          completion.onFailure();
+        }
+      }
+    }
+    
+    @Override
+    public void waitForOperations() {
+      //do nothing, all operations are synchronous
+    @Override
-    
+    @Override
-    public boolean createRedundantBucket(
-        InternalDistributedMember targetMember, int i, 
-        Map<String, Long> colocatedRegionBytes) {
-      boolean result = false;
-      long elapsed = 0;
-      long totalBytes = 0;
-      
+    @Override
+    public void createRedundantBucket(
+        final InternalDistributedMember targetMember, final int i, 
+        final Map<String, Long> colocatedRegionBytes, final Completion completion) {
-      try {
-        long start = System.nanoTime();
-        result = delegate.createRedundantBucket(targetMember, i,  
-            colocatedRegionBytes);
-        elapsed= System.nanoTime() - start;
-        if (result) {
+      
+      final long start = System.nanoTime();
+      delegate.createRedundantBucket(targetMember, i,  
+          colocatedRegionBytes, new Completion() {
+
+        @Override
+        public void onSuccess() {
+          long totalBytes = 0;
+          long elapsed= System.nanoTime() - start;
-        } else {
+
+          if(stats != null) {
+            stats.endBucketCreate(regionCount, true, totalBytes, elapsed);
+          }
+
+        }
+
+        @Override
+        public void onFailure() {
+          long elapsed= System.nanoTime() - start;
+
+
+          if(stats != null) {
+            stats.endBucketCreate(regionCount, false, 0, elapsed);
+          }
-      } finally {
-        if(stats != null) {
-          stats.endBucketCreate(regionCount, result, totalBytes, elapsed);
-        }
-      }
-      
-      return result;
+      });
+    @Override
+    @Override
+    
+    @Override
+    public void waitForOperations() {
+      delegate.waitForOperations();
+    }

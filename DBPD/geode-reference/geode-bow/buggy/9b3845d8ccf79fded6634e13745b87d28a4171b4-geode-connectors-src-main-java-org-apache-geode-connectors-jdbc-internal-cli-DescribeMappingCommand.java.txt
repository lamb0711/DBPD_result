GEODE-6273: add group to jdbc-mapping create and describe (#3100)

gfsh create jdbc-mapping and describe jdbc-mapping now have a --group option.

Co-authored-by: Scott Jewell <sjewell@pivotal.io>
Co-authored-by: Jianxia Chen <jchen@pivotal.io>
Co-authored-by: Ben Ross <bross@pivotal.io>

+import static org.apache.geode.connectors.util.internal.MappingConstants.CATALOG_NAME;
+import static org.apache.geode.connectors.util.internal.MappingConstants.DATA_SOURCE_NAME;
+import static org.apache.geode.connectors.util.internal.MappingConstants.ID_NAME;
+import static org.apache.geode.connectors.util.internal.MappingConstants.PDX_NAME;
+import static org.apache.geode.connectors.util.internal.MappingConstants.SCHEMA_NAME;
+import static org.apache.geode.connectors.util.internal.MappingConstants.SYNCHRONOUS_NAME;
+import static org.apache.geode.connectors.util.internal.MappingConstants.TABLE_NAME;
-import java.util.Set;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.CacheElement;
+import org.apache.geode.cache.configuration.RegionConfig;
+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;
-import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.distributed.ConfigurationPersistenceService;
+import org.apache.geode.management.cli.ConverterHint;
-import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
+  private static final String CREATE_MAPPING__GROUPS_NAME__HELP =
+      "Server Group(s) of the JDBC mapping to be described.";
-      mandatory = true, help = DESCRIBE_MAPPING__REGION_NAME__HELP) String regionName) {
+      mandatory = true, help = DESCRIBE_MAPPING__REGION_NAME__HELP) String regionName,
+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
+          optionContext = ConverterHint.MEMBERGROUP,
+          help = CREATE_MAPPING__GROUPS_NAME__HELP) String[] groups) {
-    DescribeMappingResult describeMappingResult = null;
+    ArrayList<DescribeMappingResult> describeMappingResults = new ArrayList<>();
-    Set<DistributedMember> members = findMembers(null, null);
-    if (members.size() > 0) {
-      DistributedMember targetMember = members.iterator().next();
-      CliFunctionResult result = executeFunctionAndGetFunctionResult(
-          new DescribeMappingFunction(), regionName, targetMember);
-      if (result != null) {
-        describeMappingResult = (DescribeMappingResult) result.getResultObject();
+    try {
+      ConfigurationPersistenceService configService = checkForClusterConfiguration();
+      if (groups == null) {
+        groups = new String[] {ConfigurationPersistenceService.CLUSTER_CONFIG};
-    } else {
-      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+      for (String group : groups) {
+        CacheConfig cacheConfig = getCacheConfig(configService, group);
+        RegionConfig regionConfig = checkForRegion(regionName, cacheConfig, group);
+        describeMappingResults
+            .addAll(getMappingsFromRegionConfig(cacheConfig, regionConfig, group));
+      }
+    } catch (PreconditionException ex) {
+      return ResultModel.createError(ex.getMessage());
-    if (describeMappingResult == null) {
+    if (describeMappingResults.isEmpty()) {
-    ResultModel resultModel = new ResultModel();
-    fillResultData(describeMappingResult, resultModel);
+    ResultModel resultModel = buildResultModel(describeMappingResults);
-  private void fillResultData(DescribeMappingResult describeMappingResult,
-      ResultModel resultModel) {
-    DataResultModel sectionModel = resultModel.addData(RESULT_SECTION_NAME);
-    describeMappingResult.getAttributeMap().forEach(sectionModel::addData);
+  private CacheConfig getCacheConfig(ConfigurationPersistenceService configService, String group)
+      throws PreconditionException {
+    CacheConfig result = configService.getCacheConfig(group);
+    if (result == null) {
+      throw new PreconditionException(
+          "Cache Configuration not found"
+              + ((group.equals(ConfigurationPersistenceService.CLUSTER_CONFIG)) ? "."
+                  : " for group " + group + "."));
+    }
+    return result;
+  }
+
+  private ArrayList<DescribeMappingResult> getMappingsFromRegionConfig(CacheConfig cacheConfig,
+      RegionConfig regionConfig, String group) {
+    CacheConfig.AsyncEventQueue asyncEventQueue = findAsyncEventQueue(cacheConfig, regionConfig);
+    ArrayList<DescribeMappingResult> results = new ArrayList<>();
+    for (CacheElement element : regionConfig.getCustomRegionElements()) {
+      if (element instanceof RegionMapping) {
+        results.add(buildDescribeMappingResult((RegionMapping) element, regionConfig.getName(),
+            asyncEventQueue == null, group));
+      }
+    }
+    return results;
+  }
+
+  private CacheConfig.AsyncEventQueue findAsyncEventQueue(CacheConfig cacheConfig,
+      RegionConfig regionConfig) {
+    for (CacheConfig.AsyncEventQueue queue : cacheConfig.getAsyncEventQueues()) {
+      if (queue.getId()
+          .equals(CreateMappingCommand.createAsyncEventQueueName(regionConfig.getName()))) {
+        return queue;
+      }
+    }
+    return null;
+  }
+
+  private DescribeMappingResult buildDescribeMappingResult(RegionMapping regionMapping,
+      String regionName, boolean synchronous, String group) {
+    LinkedHashMap<String, String> attributes = new LinkedHashMap<>();
+    attributes.put(REGION_NAME, regionName);
+    attributes.put(PDX_NAME, regionMapping.getPdxName());
+    attributes.put(TABLE_NAME, regionMapping.getTableName());
+    attributes.put(DATA_SOURCE_NAME, regionMapping.getDataSourceName());
+    attributes.put(SYNCHRONOUS_NAME, Boolean.toString(synchronous));
+    attributes.put(ID_NAME, regionMapping.getIds());
+    if (regionMapping.getCatalog() != null) {
+      attributes.put(CATALOG_NAME, regionMapping.getCatalog());
+    }
+    if (regionMapping.getSchema() != null) {
+      attributes.put(SCHEMA_NAME, regionMapping.getSchema());
+    }
+    DescribeMappingResult result = new DescribeMappingResult(attributes);
+    result.setGroupName(group);
+    return result;
+  }
+
+  private ResultModel buildResultModel(ArrayList<DescribeMappingResult> describeMappingResult) {
+    ResultModel resultModel = new ResultModel();
+    for (int i = 0; i < describeMappingResult.size(); i++) {
+      DataResultModel sectionModel = resultModel.addData(RESULT_SECTION_NAME + String.valueOf(i));
+      DescribeMappingResult result = describeMappingResult.get(i);
+      if (!result.getGroupName().equals(ConfigurationPersistenceService.CLUSTER_CONFIG)) {
+        sectionModel.addData("Mapping for group", result.getGroupName());
+      }
+      result.getAttributeMap().forEach(sectionModel::addData);
+    }
+    return resultModel;
+  }
+
+  public ConfigurationPersistenceService checkForClusterConfiguration()
+      throws PreconditionException {
+    ConfigurationPersistenceService result = getConfigurationPersistenceService();
+    if (result == null) {
+      throw new PreconditionException("Cluster Configuration must be enabled.");
+    }
+    return result;
+  }
+
+  private RegionConfig checkForRegion(String regionName, CacheConfig cacheConfig, String groupName)
+      throws PreconditionException {
+    RegionConfig regionConfig = findRegionConfig(cacheConfig, regionName);
+    if (regionConfig == null) {
+      String groupClause = "A region named " + regionName + " must already exist"
+          + (!groupName.equals(ConfigurationPersistenceService.CLUSTER_CONFIG)
+              ? " for group " + groupName + "." : ".");
+      throw new PreconditionException(groupClause);
+    }
+    return regionConfig;
+  }
+
+  private RegionConfig findRegionConfig(CacheConfig cacheConfig, String regionName) {
+    return cacheConfig.getRegions().stream()
+        .filter(region -> region.getName().equals(regionName)).findFirst().orElse(null);

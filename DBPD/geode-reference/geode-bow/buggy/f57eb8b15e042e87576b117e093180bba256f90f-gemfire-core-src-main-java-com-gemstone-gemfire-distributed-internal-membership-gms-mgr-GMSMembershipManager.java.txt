GEODE-77: faster initiation of suspect processing on crashed member
TCPConduit's Connection.java was not initiating suspect processing when a member crashed.  This was due to not having the check in the normal (amt < 0) check for a socket error.

In testing this fix with ReconnectDUnitTest I found that the change exposed some problems in GMSJoinLeave that were keeping reconnect from happening as fast as it should:

1. The reconnecting member was processing a RemoveMember message intended for its old incarnation.  This caused it to invoke forceDisconnect() but the concurrent join() attempt did not notice this and continued to try to connect until it timed out.

2. ViewCreator was removing the new member from the view if its old ID was being declared crashed in the same view because of the way InternalDistributedMember.compareTo() works with viewless identifiers.

This change-set also gets rid of a bunch of references to JGroups scattered around in the code and removes references to JGroups classes from GMSMembershipManager, moving the code requiring these refs to the quorum checker.

-import org.jgroups.JChannel;
-   * thread-local used to force use of JGroups for communications, usually to
+   * thread-local used to force use of Messenger for communications, usually to
-  private ThreadLocal<Boolean> forceUseJGroups = new ThreadLocal<Boolean>();
+  private ThreadLocal<Boolean> forceUseUDPMessaging = new ThreadLocal<Boolean>();
-   * that has been returned from Jgroups
+   * that has been installed
-  /** has the jgroups channel been connected successfully? */
-  volatile boolean hasConnected;
+  /** have we joined successfully? */
+  volatile boolean hasJoined;
-   * suspect processing in JGroups that otherwise becomes pretty aggressive 
+   * suspect processing that otherwise becomes pretty aggressive 
-   * in a jgroups view.
+   * in a view.
-   * This is the latest viewId received from JGroups
+   * This is the latest viewId installed
-        // Once a member has been seen via JGroups, remove them from the
+        // Once a member has been seen via a view, remove them from the
-          continue; // member has not yet appeared in JGroups view
+          continue; // member has not yet appeared in a view
-              , "departed JGroups view");
+              , "departed membership view");
-            LocalizedStrings.GroupMembershipService_CONNECTED_TO_JGROUPS_CHANNEL_TOOK__0__MS, delta));
+            LocalizedStrings.GroupMembershipService_JOINED_TOOK__0__MS, delta));
-        throw new DistributionException(LocalizedStrings.GroupMembershipService_AN_EXCEPTION_WAS_THROWN_WHILE_CONNECTING_TO_JGROUPS.toLocalizedString(), ex);
+        throw new DistributionException(LocalizedStrings.GroupMembershipService_AN_EXCEPTION_WAS_THROWN_WHILE_JOINING.toLocalizedString(), ex);
-    this.hasConnected = true;
+    this.hasJoined = true;
-   * from a member not in the JGroups view).  Does not employ the
+   * from a member not in the view).  Does not employ the
-      // JGroups view comes in and he's still not visible.
+      // view comes in and he's still not visible.
-        // This will get corrected when he finally shows up in the JGroups
+        // This will get corrected when he finally shows up in the
-      // bug #44373 - queue all view messages while connecting the jgroups channel.
+      // bug #44373 - queue all view messages while joining.
-      // to avoid blocking the jgroups stack
+      // to avoid blocking a reader thread
-   * Ensure that the critical classes from JGroups and the TCP conduit
-   * implementation get loaded.
+   * Ensure that the critical classes from components
+   * get loaded.
-    if (mbr != null && !this.shutdownMembers.containsKey(mbr)) {
+    if (!this.shutdownInProgress && !this.shutdownMembers.containsKey(mbr)) {
-    return (this.hasConnected && !this.shutdownInProgress); 
+    return (this.hasJoined && !this.shutdownInProgress); 
-    if (this.hasConnected) {
-      // if the jgroups channel has been connected then we aren't in the
-      // middle of a reconnect attempt in this instance of the distributed system
+    if (this.hasJoined) {
-      JChannel channel = (JChannel)checker.getMembershipInfo();
-      if (channel != null  &&  !channel.isClosed()) {
-        channel.close();
-      }
+      checker.close();
-    boolean sendViaJGroups = isForceUDPCommunications(); // enable when bug #46438 is fixed: || msg.sendViaJGroups();
+    boolean sendViaMessenger = isForceUDPCommunications(); // enable when bug #46438 is fixed: || msg.sendViaUDP();
-    if (useMcast || tcpDisabled || sendViaJGroups) {
+    if (useMcast || tcpDisabled || sendViaMessenger) {
-    forceUseJGroups.set(null);
+    forceUseUDPMessaging.set(null);
-    Boolean forced = forceUseJGroups.get();
+    Boolean forced = forceUseUDPMessaging.get();

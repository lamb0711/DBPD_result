GEODE-420: Clean up of SocketCreator code in tests.
SocketCreatorFactory currently singleton, to amend at later stage

-import com.gemstone.gemfire.CancelCriterion;
-import com.gemstone.gemfire.CancelException;
-import com.gemstone.gemfire.SystemFailure;
-import com.gemstone.gemfire.distributed.DistributedMember;
-import com.gemstone.gemfire.distributed.DistributedSystemDisconnectedException;
-import com.gemstone.gemfire.distributed.internal.*;
-import com.gemstone.gemfire.distributed.internal.direct.DirectChannel;
-import com.gemstone.gemfire.distributed.internal.membership.InternalDistributedMember;
-import com.gemstone.gemfire.distributed.internal.membership.MembershipManager;
-import com.gemstone.gemfire.internal.SocketCreator;
-import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-import com.gemstone.gemfire.internal.logging.LogService;
-import com.gemstone.gemfire.internal.logging.LoggingThreadGroup;
-import com.gemstone.gemfire.internal.logging.log4j.AlertAppender;
-import com.gemstone.gemfire.internal.logging.log4j.LocalizedMessage;
-import com.gemstone.gemfire.internal.logging.log4j.LogMarker;
-import org.apache.logging.log4j.Logger;
-
-import javax.net.ssl.SSLException;
-import java.net.*;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
-import java.util.concurrent.*;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLException;
-/** <p>TCPConduit manages a server socket and a collection of connections to
-    other systems.  Connections are identified by DistributedMember IDs.
-    These types of messages are currently supported:</p><pre>
+import org.apache.logging.log4j.Logger;
-       DistributionMessage - message is delivered to the server's
-                             ServerDelegate
+import com.gemstone.gemfire.CancelCriterion;
+import com.gemstone.gemfire.CancelException;
+import com.gemstone.gemfire.SystemFailure;
+import com.gemstone.gemfire.distributed.DistributedMember;
+import com.gemstone.gemfire.distributed.DistributedSystemDisconnectedException;
+import com.gemstone.gemfire.distributed.internal.DM;
+import com.gemstone.gemfire.distributed.internal.DMStats;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import com.gemstone.gemfire.distributed.internal.DistributionMessage;
+import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.distributed.internal.LonerDistributionManager;
+import com.gemstone.gemfire.distributed.internal.direct.DirectChannel;
+import com.gemstone.gemfire.distributed.internal.membership.InternalDistributedMember;
+import com.gemstone.gemfire.distributed.internal.membership.MembershipManager;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
+import com.gemstone.gemfire.internal.logging.LogService;
+import com.gemstone.gemfire.internal.logging.LoggingThreadGroup;
+import com.gemstone.gemfire.internal.logging.log4j.AlertAppender;
+import com.gemstone.gemfire.internal.logging.log4j.LocalizedMessage;
+import com.gemstone.gemfire.internal.logging.log4j.LogMarker;
+import com.gemstone.gemfire.internal.net.SocketCreator;
+import com.gemstone.gemfire.internal.net.SocketCreatorFactory;
-    </pre>
-    <p>In the current implementation, ServerDelegate is the DirectChannel
-    used by the GemFire DistributionManager to send and receive messages.<p>
-    If the ServerDelegate is null, DistributionMessages are ignored by
-    the TCPConduit.</p>
-
-    @since GemFire 2.0
-   
-*/
+/**
+ * <p>TCPConduit manages a server socket and a collection of connections to
+ * other systems.  Connections are identified by DistributedMember IDs.
+ * These types of messages are currently supported:</p><pre>
+ * <p>
+ * DistributionMessage - message is delivered to the server's
+ * ServerDelegate
+ * <p>
+ * </pre>
+ * <p>In the current implementation, ServerDelegate is the DirectChannel
+ * used by the GemFire DistributionManager to send and receive messages.<p>
+ * If the ServerDelegate is null, DistributionMessages are ignored by
+ * the TCPConduit.</p>
+ * @since GemFire 2.0
+ */
+
-  /** max amount of time (ms) to wait for listener threads to stop */
+  /**
+   * max amount of time (ms) to wait for listener threads to stop
+   */
-  /** backlog is the "accept" backlog configuration parameter all
-      conduits server socket */
+  /**
+   * backlog is the "accept" backlog configuration parameter all
+   * conduits server socket
+   */
-  
-  /** use javax.net.ssl.SSLServerSocketFactory? */
+
+  /**
+   * use javax.net.ssl.SSLServerSocketFactory?
+   */
-//   public final static boolean USE_SYNC_WRITES = Boolean.getBoolean("p2p.useSyncWrites");
+  //   public final static boolean USE_SYNC_WRITES = Boolean.getBoolean("p2p.useSyncWrites");
-  /** use direct ByteBuffers instead of heap ByteBuffers for NIO operations */
+  /**
+   * use direct ByteBuffers instead of heap ByteBuffers for NIO operations
+   */
-  
+
-//  private transient DistributedMembershipListener messageReceiver;
-  
+  //  private transient DistributedMembershipListener messageReceiver;
+
-  
-  /** true if NIO can be used for the server socket */
+
+  /**
+   * true if NIO can be used for the server socket
+   */
-  
+
-  
+
-    BACKLOG = Integer.getInteger("p2p.backlog", HANDSHAKE_POOL_SIZE+1).intValue();
+    BACKLOG = Integer.getInteger("p2p.backlog", HANDSHAKE_POOL_SIZE + 1).intValue();
-  /** the size of OS TCP/IP buffers, not set by default */
+  /**
+   * the size of OS TCP/IP buffers, not set by default
+   */
-  /** port is the tcp/ip port that this conduit binds to. If it is zero, a port
-      from membership-port-range is selected to bind to. The actual port number this
-      conduit is listening on will be in the "id" instance variable */
+  /**
+   * port is the tcp/ip port that this conduit binds to. If it is zero, a port
+   * from membership-port-range is selected to bind to. The actual port number this
+   * conduit is listening on will be in the "id" instance variable
+   */
-  /** The java groups address that this conduit is associated with */
+  /**
+   * The java groups address that this conduit is associated with
+   */
-  
-  /** address is the InetAddress that this conduit uses for identity */
+
+  /**
+   * address is the InetAddress that this conduit uses for identity
+   */
-  
-  /** isBindAddress is true if we should bind to the address */
+
+  /**
+   * isBindAddress is true if we should bind to the address
+   */
-  /** the object that receives DistributionMessage messages
-      received by this conduit. */
+  /**
+   * the object that receives DistributionMessage messages
+   * received by this conduit.
+   */
-  
+
-  /** server socket address */
+  /**
+   * server socket address
+   */
-  /** the listener thread */
+  /**
+   * the listener thread
+   */
-  /** if using NIO, this is the object used for accepting connections */
+  /**
+   * if using NIO, this is the object used for accepting connections
+   */
-  /** the server socket */
+  /**
+   * the server socket
+   */
-  /** a table of Connections from this conduit to others
+  /**
+   * a table of Connections from this conduit to others
-  /** <p>creates a new TCPConduit bound to the given InetAddress and port.
-      The given ServerDelegate will receive any DistributionMessages
-      passed to the conduit.</p>
-      <p>This constructor forces the conduit to ignore the following
-      system properties and look for them only in the <i>props</i> argument:</p>
-      <pre>
-      p2p.tcpBufferSize
-      p2p.idleConnectionTimeout
-      </pre>
-  */
-  public TCPConduit(MembershipManager mgr, int port,
-      InetAddress address, boolean isBindAddress,
-      DirectChannel receiver, Properties props)
-    throws ConnectionException
-  {
+  /**
+   * <p>creates a new TCPConduit bound to the given InetAddress and port.
+   * The given ServerDelegate will receive any DistributionMessages
+   * passed to the conduit.</p>
+   * <p>This constructor forces the conduit to ignore the following
+   * system properties and look for them only in the <i>props</i> argument:</p>
+   * <pre>
+   * p2p.tcpBufferSize
+   * p2p.idleConnectionTimeout
+   * </pre>
+   */
+  public TCPConduit(MembershipManager mgr, int port, InetAddress address, boolean isBindAddress, DirectChannel receiver, Properties props)
+    throws ConnectionException {
-    }
-    catch (IOException io) {
+    } catch (IOException io) {
-        }
-        catch (java.net.UnknownHostException e) {
+        } catch (java.net.UnknownHostException e) {
-      
+
-  /** parse instance-level properties from the given object */
+  /**
+   * parse instance-level properties from the given object
+   */
-      s = p.getProperty("p2p.tcpBufferSize", ""+tcpBufferSize);
-      try { tcpBufferSize = Integer.parseInt(s); } catch (Exception e) { logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PTCPBUFFERSIZE), e); }
+      s = p.getProperty("p2p.tcpBufferSize", "" + tcpBufferSize);
+      try {
+        tcpBufferSize = Integer.parseInt(s);
+      } catch (Exception e) {
+        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PTCPBUFFERSIZE), e);
+      }
-      s = p.getProperty("p2p.idleConnectionTimeout", ""+idleConnectionTimeout);
-      try { idleConnectionTimeout = Integer.parseInt(s); } catch (Exception e) { logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PIDLECONNECTIONTIMEOUT), e); }
-      
+      s = p.getProperty("p2p.idleConnectionTimeout", "" + idleConnectionTimeout);
+      try {
+        idleConnectionTimeout = Integer.parseInt(s);
+      } catch (Exception e) {
+        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PIDLECONNECTIONTIMEOUT), e);
+      }
+
-      try { tcpPortRange[0] = Integer.parseInt(s); } catch (Exception e) { logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGESTART), e); }
-      
+      try {
+        tcpPortRange[0] = Integer.parseInt(s);
+      } catch (Exception e) {
+        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGESTART), e);
+      }
+
-      try { tcpPortRange[1] = Integer.parseInt(s); } catch (Exception e) { logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGEEND), e); }
-      
+      try {
+        tcpPortRange[1] = Integer.parseInt(s);
+      } catch (Exception e) {
+        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGEEND), e);
+      }
+
-  /** the reason for a shutdown, if abnormal */
+  /**
+   * the reason for a shutdown, if abnormal
+   */
-  /** added to fix bug 40436 */
+  /**
+   * added to fix bug 40436
+   */
-  /** binds the server socket and gets threads going
-   *
-   * */
+  /**
+   * binds the server socket and gets threads going
+   */
-    
+
-      final ThreadGroup socketThreadGroup
-        = LoggingThreadGroup.createThreadGroup(gName, logger);
-                                          
-      ThreadFactory socketThreadFactory = new ThreadFactory() {
-          int connNum = -1;
+      final ThreadGroup socketThreadGroup = LoggingThreadGroup.createThreadGroup(gName, logger);
-          public Thread newThread(Runnable command) {
-            int tnum;
-            synchronized (this) {
-              tnum = ++connNum;
-            }
-            String tName = socketThreadGroup.getName() + " Thread " + tnum;
-            return new Thread(socketThreadGroup, command, tName);
+      ThreadFactory socketThreadFactory = new ThreadFactory() {
+        int connNum = -1;
+
+        public Thread newThread(Runnable command) {
+          int tnum;
+          synchronized (this) {
+            tnum = ++connNum;
-        };
+          String tName = socketThreadGroup.getName() + " Thread " + tnum;
+          return new Thread(socketThreadGroup, command, tName);
+        }
+      };
-            public void rejectedExecution(Runnable r, ThreadPoolExecutor pool) {
-              try {
-                bq.put(r);
-              }
-              catch (InterruptedException ex) {
-                Thread.currentThread().interrupt(); // preserve the state
-                throw new RejectedExecutionException(LocalizedStrings.TCPConduit_INTERRUPTED.toLocalizedString(), ex);
-              }
+          public void rejectedExecution(Runnable r, ThreadPoolExecutor pool) {
+            try {
+              bq.put(r);
+            } catch (InterruptedException ex) {
+              Thread.currentThread().interrupt(); // preserve the state
+              throw new RejectedExecutionException(LocalizedStrings.TCPConduit_INTERRUPTED.toLocalizedString(), ex);
-          };
-        tmp_hsPool = new ThreadPoolExecutor(1,
-                                            HANDSHAKE_POOL_SIZE,
-                                            HANDSHAKE_POOL_KEEP_ALIVE_TIME,
-                                            TimeUnit.SECONDS,
-                                            bq,
-                                            socketThreadFactory,
-                                            reh);
-      }
-      catch (IllegalArgumentException poolInitException) {
+          }
+        };
+        tmp_hsPool = new ThreadPoolExecutor(1, HANDSHAKE_POOL_SIZE, HANDSHAKE_POOL_KEEP_ALIVE_TIME, TimeUnit.SECONDS, bq, socketThreadFactory, reh);
+      } catch (IllegalArgumentException poolInitException) {
-      ThreadGroup group =
-        LoggingThreadGroup.createThreadGroup("P2P Listener Threads", logger);
+      ThreadGroup group = LoggingThreadGroup.createThreadGroup("P2P Listener Threads", logger);
-      try { thread.setPriority(thread.getThreadGroup().getMaxPriority()); }
-      catch (Exception e) {
+      try {
+        thread.setPriority(thread.getThreadGroup().getMaxPriority());
+      } catch (Exception e) {
-      }
-      else {
+      } else {
-    }
-    catch (IOException io) {
+    } catch (IOException io) {
-  
-  /** creates the server sockets.  This can be used to recreate the
-   *  socket using this.port and this.bindAddress, which must be set
-   *  before invoking this method.
+
+  /**
+   * creates the server sockets.  This can be used to recreate the
+   * socket using this.port and this.bindAddress, which must be set
+   * before invoking this method.
-    
+
-          socket = SocketCreator.getDefaultInstance().createServerSocketUsingPortRange(ba, b, isBindAddress,
-                    this.useNIO, 0, tcpPortRange);
+
+          socket = SocketCreatorFactory.getClusterSSLSocketCreator().createServerSocketUsingPortRange(ba, b, isBindAddress, this.useNIO, 0, tcpPortRange);
-              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
-                  new Object[] {"Listener receiverBufferSize", Integer.valueOf(newSize), Integer.valueOf(tcpBufferSize)}));
+              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2, new Object[] {
+                "Listener receiverBufferSize",
+                Integer.valueOf(newSize),
+                Integer.valueOf(tcpBufferSize)
+              }));
-      }
-      else {
+      } else {
-            socket = SocketCreator.getDefaultInstance().createServerSocketUsingPortRange(ba, b, isBindAddress,
-                      this.useNIO, this.tcpBufferSize, tcpPortRange);
+            socket = SocketCreatorFactory.getClusterSSLSocketCreator()
+                                         .createServerSocketUsingPortRange(ba, b, isBindAddress, this.useNIO, this.tcpBufferSize, tcpPortRange);
-            socket = SocketCreator.getDefaultInstance().createServerSocket(p, b, isBindAddress? ba : null, this.tcpBufferSize);
+            socket = SocketCreatorFactory.getClusterSSLSocketCreator().createServerSocket(p, b, isBindAddress ? ba : null, this.tcpBufferSize);
-            logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
-                new Object[] {"Listener receiverBufferSize", Integer.valueOf(newSize), Integer.valueOf(this.tcpBufferSize)}));
+            logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2, new Object[] {
+              "Listener receiverBufferSize",
+              Integer.valueOf(newSize),
+              Integer.valueOf(this.tcpBufferSize)
+            }));
-          
+
-    }
-    catch (IOException io) {
-      throw new ConnectionException( LocalizedStrings.TCPConduit_EXCEPTION_CREATING_SERVERSOCKET.toLocalizedString(
-              new Object[] {Integer.valueOf(p), ba}), io);
+    } catch (IOException io) {
+      throw new ConnectionException(LocalizedStrings.TCPConduit_EXCEPTION_CREATING_SERVERSOCKET.toLocalizedString(new Object[] { Integer.valueOf(p), ba }), io);
-   * 
-  
+
-   * 
-//    stop(); // Causes grief
+    //    stop(); // Causes grief
-    
+
-//    System.err.println("DEBUG: TCPConduit emergencyClose");
+    //    System.err.println("DEBUG: TCPConduit emergencyClose");
-      }
-      else {
+      } else {
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-//  this.conTable.close(); not safe against deadlocks
+    //  this.conTable.close(); not safe against deadlocks
-    
+
-    
-//    System.err.println("DEBUG: end of TCPConduit emergencyClose");
+
+    //    System.err.println("DEBUG: end of TCPConduit emergencyClose");
-  
+
-        Thread t = this.thread;;
+        Thread t = this.thread;
+        ;
-        }
-        else {
+        } else {
-        
+
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.TCPConduit_UNABLE_TO_SHUT_DOWN_LISTENER_WITHIN_0_MS_UNABLE_TO_INTERRUPT_SOCKET_ACCEPT_DUE_TO_JDK_BUG_GIVING_UP,
-              Integer.valueOf(LISTENER_CLOSE_TIMEOUT)));
+          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_UNABLE_TO_SHUT_DOWN_LISTENER_WITHIN_0_MS_UNABLE_TO_INTERRUPT_SOCKET_ACCEPT_DUE_TO_JDK_BUG_GIVING_UP, Integer
+            .valueOf(LISTENER_CLOSE_TIMEOUT)));
-      }
-      finally {
+      } finally {
-   *
-  /** starts the conduit again after it's been stopped.  This will clear the
-      server map if the conduit's port is zero (wildcard bind) */
+  /**
+   * starts the conduit again after it's been stopped.  This will clear the
+   * server map if the conduit's port is zero (wildcard bind)
+   */
-    if (!stopped)
+    if (!stopped) {
+    }
-    }
-    catch (IOException io) {
+    } catch (IOException io) {
-  /** this is the server socket listener thread's run loop */
+  /**
+   * this is the server socket listener thread's run loop
+   */
-    for(;;) {
+    for (; ; ) {
-          SocketChannel otherChannel = channel.accept();          
+          SocketChannel otherChannel = channel.accept();
-        }
-        else {
+        } else {
-          }
-          catch (SSLException ex) {
+          } catch (SSLException ex) {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.TCPConduit_STOPPING_P2P_LISTENER_DUE_TO_SSL_CONFIGURATION_PROBLEM), ex);
+            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_STOPPING_P2P_LISTENER_DUE_TO_SSL_CONFIGURATION_PROBLEM), ex);
-          SocketCreator.getDefaultInstance().configureServerSSLSocket(
-              othersock);
+          SocketCreatorFactory.getClusterSSLSocketCreator().configureServerSSLSocket(othersock);
-          }
-          catch (Exception e) {
+          } catch (Exception e) {
-//          if (logger.isTraceEnabled(LogMarker.QA)) {
-            logger.info("Test hook: inhibiting acceptance of connection {}", othersock);
-//          }
+          //          if (logger.isTraceEnabled(LogMarker.QA)) {
+          logger.info("Test hook: inhibiting acceptance of connection {}", othersock);
+          //          }
-            try { 
-              Thread.sleep(2000); 
-            }
-            catch (InterruptedException e) {
+            try {
+              Thread.sleep(2000);
+            } catch (InterruptedException e) {
-            }
-            finally {
+            } finally {
-        }
-        else {
+        } else {
-      }
-      catch (ClosedByInterruptException cbie) {
+      } catch (ClosedByInterruptException cbie) {
-      }
-      catch (ClosedChannelException e) {
+      } catch (ClosedChannelException e) {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.TCPConduit_SERVERSOCKET_THREW_SOCKET_CLOSED_EXCEPTION_BUT_SAYS_IT_IS_NOT_CLOSED), e);
+              logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_SERVERSOCKET_THREW_SOCKET_CLOSED_EXCEPTION_BUT_SAYS_IT_IS_NOT_CLOSED), e);
-              }
-              catch (IOException ioe) {
+              } catch (IOException ioe) {
-                }
-                catch (InterruptedException ie) {
+                } catch (InterruptedException ie) {
-                  logger.info(LocalizedMessage.create(
-                      LocalizedStrings.TCPConduit_INTERRUPTED_AND_EXITING_WHILE_TRYING_TO_RECREATE_LISTENER_SOCKETS));
+                  logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_INTERRUPTED_AND_EXITING_WHILE_TRYING_TO_RECREATE_LISTENER_SOCKETS));
-        }
-        catch (ConnectionException ex) {
+        } catch (ConnectionException ex) {
-          public void run() {
-            basicAcceptConnection(othersock);
-          }
-        });
-    }
-    catch (RejectedExecutionException rejected) {
+        public void run() {
+          basicAcceptConnection(othersock);
+        }
+      });
+    } catch (RejectedExecutionException rejected) {
-      }
-      catch (IOException ignore) {
+      } catch (IOException ignore) {
+
+
-    }
-    catch (IOException io) {
+    } catch (IOException io) {
-    }
-    catch (ConnectionException ex) {
+    } catch (ConnectionException ex) {
-    }
-    catch (CancelException e) {
-    }
-    catch (Exception e) {
+    } catch (CancelException e) {
+    } catch (Exception e) {
-//        if (e instanceof SocketException
-//            && "Socket closed".equals(e.getMessage())) {
-//          // safe to ignore; see bug 31156
-//        } 
-//        else 
+        //        if (e instanceof SocketException
+        //            && "Socket closed".equals(e.getMessage())) {
+        //          // safe to ignore; see bug 31156
+        //        }
+        //        else
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_FAILED_TO_ACCEPT_CONNECTION_FROM_0_BECAUSE_1,
-            new Object[] {othersock.getInetAddress(), e}), e);
+          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_FAILED_TO_ACCEPT_CONNECTION_FROM_0_BECAUSE_1, new Object[] {
+            othersock.getInetAddress(),
+            e
+          }), e);
-  
+
-  public void getThreadOwnedOrderedConnectionState(
-    DistributedMember member,
-    Map result)
-  {
+  public void getThreadOwnedOrderedConnectionState(DistributedMember member, Map result) {
-  
+
-  public void waitForThreadOwnedOrderedConnectionState(DistributedMember member, Map channelState)
-    throws InterruptedException
-  {
+  public void waitForThreadOwnedOrderedConnectionState(DistributedMember member, Map channelState) throws InterruptedException {
-  */
-  protected void messageReceived(Connection receiver, DistributionMessage message,
-                                 int bytesRead) {
+   */
+  protected void messageReceived(Connection receiver, DistributionMessage message, int bytesRead) {
-  /** gets the address of this conduit's ServerSocket endpoint */
+  /**
+   * gets the address of this conduit's ServerSocket endpoint
+   */
-  /** gets the actual port to which this conduit's ServerSocket is bound */
+  /**
+   * gets the actual port to which this conduit's ServerSocket is bound
+   */
-  /** gets the requested port that this TCPConduit bound to.  This could
-      be zero if a wildcard bind was done */
+
+  /**
+   * gets the requested port that this TCPConduit bound to.  This could
+   * be zero if a wildcard bind was done
+   */
-  
-  /** gets the channel that is used to process non-DistributedMember messages */
+
+  /**
+   * gets the channel that is used to process non-DistributedMember messages
+   */
-  
+
-   * 
+   *
-  public Connection getConnection(InternalDistributedMember memberAddress, final boolean preserveOrder, boolean retry, long startTime,
-      long ackTimeout, long ackSATimeout)
-    throws java.io.IOException, DistributedSystemDisconnectedException
-  {
+  public Connection getConnection(InternalDistributedMember memberAddress,
+                                  final boolean preserveOrder,
+                                  boolean retry,
+                                  long startTime,
+                                  long ackTimeout,
+                                  long ackSATimeout) throws java.io.IOException, DistributedSystemDisconnectedException {
-    for (;;) {
+    for (; ; ) {
-      // If this is the second time through this loop, we had
-      // problems.  Tear down the connection so that it gets
-      // rebuilt.
-      if (retry || conn != null) { // not first time in loop
-        if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress) || membershipManager.shutdownInProgress()) {
-          throw new IOException(LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW.toLocalizedString());
-        }
-        // bug35953: Member is still in view; we MUST NOT give up!
-        
-        // Pause just a tiny bit...
+        // If this is the second time through this loop, we had
+        // problems.  Tear down the connection so that it gets
+        // rebuilt.
+        if (retry || conn != null) { // not first time in loop
+          if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress) || membershipManager.shutdownInProgress()) {
+            throw new IOException(LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW.toLocalizedString());
+          }
+          // bug35953: Member is still in view; we MUST NOT give up!
+
+          // Pause just a tiny bit...
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException e) {
+            interrupted = true;
+            stopper.checkCancelInProgress(e);
+          }
+
+          // try again after sleep
+          if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) {
+            // OK, the member left.  Just register an error.
+            throw new IOException(LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW.toLocalizedString());
+          }
+
+          // Print a warning (once)
+          if (memberInTrouble == null) {
+            memberInTrouble = memberAddress;
+            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_ATTEMPTING_TCPIP_RECONNECT_TO__0, memberInTrouble));
+          } else {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Attempting TCP/IP reconnect to {}", memberInTrouble);
+            }
+          }
+
+          // Close the connection (it will get rebuilt later).
+          this.stats.incReconnectAttempts();
+          if (conn != null) {
+            try {
+              if (logger.isDebugEnabled()) {
+                logger.debug("Closing old connection.  conn={} before retrying. memberInTrouble={}", conn, memberInTrouble);
+              }
+              conn.closeForReconnect("closing before retrying");
+            } catch (CancelException ex) {
+              throw ex;
+            } catch (Exception ex) {
+            }
+          }
+        } // not first time in loop
+
+        Exception problem = null;
-          Thread.sleep(100);
-        }
-        catch (InterruptedException e) {
-          interrupted = true;
-          stopper.checkCancelInProgress(e);
-        }
-        
-        // try again after sleep
-        if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) {
-          // OK, the member left.  Just register an error.
-          throw new IOException(LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW.toLocalizedString());
-        }
-        
-        // Print a warning (once)
-        if (memberInTrouble == null) {
-          memberInTrouble = memberAddress;
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_ATTEMPTING_TCPIP_RECONNECT_TO__0, memberInTrouble));
-        }
-        else {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Attempting TCP/IP reconnect to {}", memberInTrouble);
-          }
-        }
-        
-        // Close the connection (it will get rebuilt later).
-        this.stats.incReconnectAttempts();
-        if (conn != null) {
-          try { 
-            if (logger.isDebugEnabled()) {
-              logger.debug("Closing old connection.  conn={} before retrying. memberInTrouble={}",
-                  conn, memberInTrouble);
+          // Get (or regenerate) the connection
+          // bug36202: this could generate a ConnectionException, so it
+          // must be caught and retried
+          boolean retryForOldConnection;
+          boolean debugRetry = false;
+          do {
+            retryForOldConnection = false;
+            conn = getConTable().get(memberAddress, preserveOrder, startTime, ackTimeout, ackSATimeout);
+            if (conn == null) {
+              // conduit may be closed - otherwise an ioexception would be thrown
+              problem = new IOException(LocalizedStrings.TCPConduit_UNABLE_TO_RECONNECT_TO_SERVER_POSSIBLE_SHUTDOWN_0.toLocalizedString(memberAddress));
+            } else if (conn.isClosing() || !conn.getRemoteAddress().equals(memberAddress)) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("Got an old connection for {}: {}@{}", memberAddress, conn, conn.hashCode());
+              }
+              conn.closeOldConnection("closing old connection");
+              conn = null;
+              retryForOldConnection = true;
+              debugRetry = true;
-            conn.closeForReconnect("closing before retrying"); 
-          } 
-          catch (CancelException ex) {
-            throw ex;
+          } while (retryForOldConnection);
+          if (debugRetry && logger.isDebugEnabled()) {
+            logger.debug("Done removing old connections");
-          catch (Exception ex) {
-          }
-        }
-      } // not first time in loop
-      
-      Exception problem = null;
-      try {
-        // Get (or regenerate) the connection
-        // bug36202: this could generate a ConnectionException, so it
-        // must be caught and retried
-        boolean retryForOldConnection;
-        boolean debugRetry = false;
-        do {
-          retryForOldConnection = false;
-          conn = getConTable().get(memberAddress, preserveOrder, startTime, ackTimeout, ackSATimeout);
-          if (conn == null) {
-            // conduit may be closed - otherwise an ioexception would be thrown
-            problem = new IOException(LocalizedStrings.TCPConduit_UNABLE_TO_RECONNECT_TO_SERVER_POSSIBLE_SHUTDOWN_0.toLocalizedString(memberAddress));
-          } else if (conn.isClosing() || !conn.getRemoteAddress().equals(memberAddress)) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Got an old connection for {}: {}@{}", memberAddress, conn, conn.hashCode());
-            }
-            conn.closeOldConnection("closing old connection"); 
-            conn = null;
-            retryForOldConnection = true;
-            debugRetry = true;
-          }
-        } while (retryForOldConnection);
-        if (debugRetry && logger.isDebugEnabled()) {
-          logger.debug("Done removing old connections");
-        }
-        // we have a connection; fall through and return it
-      }
-      catch (ConnectionException e) {
-        // Race condition between acquiring the connection and attempting
-        // to use it: another thread closed it.
-        problem = e;
-        // [sumedh] No need to retry since Connection.createSender has already
-        // done retries and now member is really unreachable for some reason
-        // even though it may be in the view
-        breakLoop = true;
-      }
-      catch (IOException e) {
-        problem = e;
-        // bug #43962 don't keep trying to connect to an alert listener
-        if (AlertAppender.isThreadAlerting()) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Giving up connecting to alert listener {}", memberAddress);
-          }
+          // we have a connection; fall through and return it
+        } catch (ConnectionException e) {
+          // Race condition between acquiring the connection and attempting
+          // to use it: another thread closed it.
+          problem = e;
+          // [sumedh] No need to retry since Connection.createSender has already
+          // done retries and now member is really unreachable for some reason
+          // even though it may be in the view
-        }
-      }
-
-      if (problem != null) {
-        // Some problems are not recoverable; check and error out early.
-        if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) { // left the view
-          // Bracket our original warning
-          if (memberInTrouble != null) {
-            // make this msg info to bracket warning
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_BECAUSE_0_HAS_DISAPPEARED, memberInTrouble));
-          }
-          throw new IOException(LocalizedStrings.TCPConduit_PEER_HAS_DISAPPEARED_FROM_VIEW.toLocalizedString(memberAddress));
-        } // left the view
-
-        if (membershipManager.shutdownInProgress()) { // shutdown in progress
-          // Bracket our original warning
-          if (memberInTrouble != null) {
-            // make this msg info to bracket warning
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_TO_0_BECAUSE_SHUTDOWN_HAS_STARTED, memberInTrouble));
-          }
-          stopper.checkCancelInProgress(null);
-          throw new DistributedSystemDisconnectedException(LocalizedStrings.TCPConduit_ABANDONED_BECAUSE_SHUTDOWN_IS_IN_PROGRESS.toLocalizedString());
-        } // shutdown in progress
-        
-        // Log the warning.  We wait until now, because we want
-        // to have m defined for a nice message...
-        if (memberInTrouble == null) {
-          logger.warn(LocalizedMessage.create(
-          LocalizedStrings.TCPConduit_ERROR_SENDING_MESSAGE_TO_0_WILL_REATTEMPT_1,
-          new Object[] {memberAddress, problem}));
-          memberInTrouble = memberAddress;
-        }
-        else {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Error sending message to {}", memberAddress, problem);
+        } catch (IOException e) {
+          problem = e;
+          // bug #43962 don't keep trying to connect to an alert listener
+          if (AlertAppender.isThreadAlerting()) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Giving up connecting to alert listener {}", memberAddress);
+            }
+            breakLoop = true;
-        if (breakLoop) {
-          if (!problem.getMessage().startsWith("Cannot form connection to alert listener")) {
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.TCPConduit_THROWING_IOEXCEPTION_AFTER_FINDING_BREAKLOOP_TRUE),
-                  problem);
-          }
-          if (problem instanceof IOException) {
-            throw (IOException)problem;
-          }
-          else {
-            IOException ioe = new IOException( LocalizedStrings.TCPConduit_PROBLEM_CONNECTING_TO_0.toLocalizedString(memberAddress));
-            ioe.initCause(problem);
-            throw ioe;
-          }
-        }
-        // Retry the operation (indefinitely)
-        continue;
-      } // problem != null
-      // Success!
+        if (problem != null) {
+          // Some problems are not recoverable; check and error out early.
+          if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) { // left the view
+            // Bracket our original warning
+            if (memberInTrouble != null) {
+              // make this msg info to bracket warning
+              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_BECAUSE_0_HAS_DISAPPEARED, memberInTrouble));
+            }
+            throw new IOException(LocalizedStrings.TCPConduit_PEER_HAS_DISAPPEARED_FROM_VIEW.toLocalizedString(memberAddress));
+          } // left the view
-      // Make sure our logging is bracketed if there was a problem
-      if (memberInTrouble != null) {
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.TCPConduit_SUCCESSFULLY_RECONNECTED_TO_MEMBER_0,
-            memberInTrouble));
-        if (logger.isTraceEnabled()) {
-          logger.trace("new connection is {} memberAddress={}", conn, memberAddress);
+          if (membershipManager.shutdownInProgress()) { // shutdown in progress
+            // Bracket our original warning
+            if (memberInTrouble != null) {
+              // make this msg info to bracket warning
+              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_TO_0_BECAUSE_SHUTDOWN_HAS_STARTED, memberInTrouble));
+            }
+            stopper.checkCancelInProgress(null);
+            throw new DistributedSystemDisconnectedException(LocalizedStrings.TCPConduit_ABANDONED_BECAUSE_SHUTDOWN_IS_IN_PROGRESS.toLocalizedString());
+          } // shutdown in progress
+
+          // Log the warning.  We wait until now, because we want
+          // to have m defined for a nice message...
+          if (memberInTrouble == null) {
+            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_ERROR_SENDING_MESSAGE_TO_0_WILL_REATTEMPT_1, new Object[] {
+              memberAddress,
+              problem
+            }));
+            memberInTrouble = memberAddress;
+          } else {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Error sending message to {}", memberAddress, problem);
+            }
+          }
+
+          if (breakLoop) {
+            if (!problem.getMessage().startsWith("Cannot form connection to alert listener")) {
+              logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_THROWING_IOEXCEPTION_AFTER_FINDING_BREAKLOOP_TRUE), problem);
+            }
+            if (problem instanceof IOException) {
+              throw (IOException) problem;
+            } else {
+              IOException ioe = new IOException(LocalizedStrings.TCPConduit_PROBLEM_CONNECTING_TO_0.toLocalizedString(memberAddress));
+              ioe.initCause(problem);
+              throw ioe;
+            }
+          }
+          // Retry the operation (indefinitely)
+          continue;
+        } // problem != null
+        // Success!
+
+        // Make sure our logging is bracketed if there was a problem
+        if (memberInTrouble != null) {
+          logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_SUCCESSFULLY_RECONNECTED_TO_MEMBER_0, memberInTrouble));
+          if (logger.isTraceEnabled()) {
+            logger.trace("new connection is {} memberAddress={}", conn, memberAddress);
+          }
-      }
-      return conn;
-      }
-      finally {
+        return conn;
+      } finally {
+
+
-  
+
-  
-  /** check to see if there are still any receiver threads for the given end-point */
+
+  /**
+   * check to see if there are still any receiver threads for the given end-point
+   */
-  
+
-    
+
-  
+
-  
+
-  
-  
+
+
-  
+
-  
+
-//    this.inhibitNewConnections = true;
-//    this.conTable.closeReceivers(true);
+    //    this.inhibitNewConnections = true;
+    //    this.conTable.closeReceivers(true);
-  
+
-//    this.inhibitNewConnections = false;
+    //    this.inhibitNewConnections = false;

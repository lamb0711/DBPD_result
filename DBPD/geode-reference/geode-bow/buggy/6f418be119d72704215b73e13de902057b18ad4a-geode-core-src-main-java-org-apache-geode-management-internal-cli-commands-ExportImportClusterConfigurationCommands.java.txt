GEODE-2198: close and re-create the cache on a server when importing new cluster configuration

* When importing cluster config first check if there is any non-empty region
* close and re-create cache if no data exists when importing new cluster configuration
* put the acquire/release lock inside the ClusterConfigurationService instead of command execution strategy.

+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toSet;
+
-import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
+import org.apache.geode.management.internal.configuration.functions.RecreateCacheFunction;
+import org.apache.geode.management.internal.configuration.functions.RegionsWithDataOnServerFunction;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
- * Commands for the shared configuration
+ * Commands for the cluster configuration
-public class ExportImportSharedConfigurationCommands extends AbstractCommandsSupport {
+public class ExportImportClusterConfigurationCommands extends AbstractCommandsSupport {
-      interceptor = "org.apache.geode.management.internal.cli.commands.ExportImportSharedConfigurationCommands$ExportInterceptor",
-      readsSharedConfiguration = true, relatedTopic = {CliStrings.TOPIC_GEODE_CONFIG})
+      interceptor = "org.apache.geode.management.internal.cli.commands.ExportImportClusterConfigurationCommands$ExportInterceptor",
+      relatedTopic = {CliStrings.TOPIC_GEODE_CONFIG})
-        sc.writeConfig(config);
+        sc.writeConfigToFile(config);
-      interceptor = "org.apache.geode.management.internal.cli.commands.ExportImportSharedConfigurationCommands$ImportInterceptor",
-      writesToSharedConfiguration = true, relatedTopic = {CliStrings.TOPIC_GEODE_CONFIG})
+      interceptor = "org.apache.geode.management.internal.cli.commands.ExportImportClusterConfigurationCommands$ImportInterceptor",
+      relatedTopic = {CliStrings.TOPIC_GEODE_CONFIG})
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-
-    if (!CliUtil.getAllNormalMembers(cache).isEmpty()) {
-      return ResultBuilder
-          .createGemFireErrorResult(CliStrings.IMPORT_SHARED_CONFIG__CANNOT__IMPORT__MSG);
-    }
-
-    byte[][] shellBytesData = CommandExecutionContext.getBytesFromShell();
-    String zipFileName = CliUtil.bytesToNames(shellBytesData)[0];
-    byte[] zipBytes = CliUtil.bytesToData(shellBytesData)[0];
-
+    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+
+    Set<DistributedMember> servers = CliUtil.getAllNormalMembers(cache);
+
+    Set<String> regionsWithData = servers.stream().map(this::getNonEmptyRegionsOnServer)
+        .flatMap(Collection::stream).collect(toSet());
+
+    if (!regionsWithData.isEmpty()) {
+      return ResultBuilder.createGemFireErrorResult(
+          "Cannot import cluster configuration with existing data in regions: "
+              + regionsWithData.stream().collect(joining(",")));
+    }
+
+
+    byte[][] shellBytesData = CommandExecutionContext.getBytesFromShell();
+    String zipFileName = CliUtil.bytesToNames(shellBytesData)[0];
+    byte[] zipBytes = CliUtil.bytesToData(shellBytesData)[0];
+
+    InfoResultData infoData = ResultBuilder.createInfoResultData();
-        sc.writeConfig(config);
+        sc.writeConfigToFile(config);
-      sc.clearSharedConfiguration();
-
-      InfoResultData infoData = ResultBuilder.createInfoResultData();
-      result = ResultBuilder.buildResult(infoData);
+
+      // if import is unsuccessful, don't need to bounce the server.
+      return result;
+
+    // Bounce the cache of each member
+    Set<CliFunctionResult> functionResults =
+        servers.stream().map(this::reCreateCache).collect(toSet());
+
+    for (CliFunctionResult functionResult : functionResults) {
+      if (functionResult.isSuccessful()) {
+        infoData.addLine("Successfully applied the imported cluster configuration on "
+            + functionResult.getMemberIdOrName());
+      } else {
+        infoData.addLine("Failed to apply the imported cluster configuration on "
+            + functionResult.getMemberIdOrName() + " due to " + functionResult.getMessage());
+      }
+    }
+
+    result = ResultBuilder.buildResult(infoData);
+  private Set<String> getNonEmptyRegionsOnServer(DistributedMember server) {
+    ResultCollector rc =
+        CliUtil.executeFunction(new RegionsWithDataOnServerFunction(), null, server);
+    List<Set<String>> results = (List<Set<String>>) rc.getResult();
+
+    return results.get(0);
+  }
+
+  private CliFunctionResult reCreateCache(DistributedMember server) {
+    ResultCollector rc = CliUtil.executeFunction(new RecreateCacheFunction(), null, server);
+    List<CliFunctionResult> results = (List<CliFunctionResult>) rc.getResult();
+
+    return results.get(0);
+  }
+

GEODE-4131: Do not reference deployed jars as byte arrays anymore (#1212)

* GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.
- Whenever an upload happens (either deploying jars or importing cluster
  config) we stage the files initially and then proceed with the command.
+import java.io.File;
+import java.io.FileOutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.Collections;
+import java.util.HashMap;
-import java.util.stream.Stream;
-import org.apache.commons.lang.ArrayUtils;
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.configuration.functions.DownloadJarFunction;
-   * @param cache Cache of this member
-  public void deployJarsReceivedFromClusterConfiguration(Cache cache,
-      ConfigurationResponse response) throws IOException, ClassNotFoundException {
+  public void deployJarsReceivedFromClusterConfiguration(ConfigurationResponse response)
+      throws IOException, ClassNotFoundException {
-    String[] jarFileNames = response.getJarNames();
-    byte[][] jarBytes = response.getJars();
+    List<String> jarFileNames =
+        response.getJarNames().values().stream().flatMap(Set::stream).collect(Collectors.toList());
-    if (jarFileNames != null && jarBytes != null) {
-      logger.info("Got response with jars: {}", Stream.of(jarFileNames).collect(joining(",")));
+    if (jarFileNames != null && !jarFileNames.isEmpty()) {
+      logger.info("Got response with jars: {}", jarFileNames.stream().collect(joining(",")));
-                .filter(jarName -> !ArrayUtils.contains(jarFileNames, jarName)).collect(toList());
+                .filter(jarName -> !jarFileNames.contains(jarName)).collect(toList());
-        List<DeployedJar> deployedJars = jarDeployer.deploy(jarFileNames, jarBytes);
+        Map<String, File> stagedJarFiles =
+            getJarsFromLocator(response.getMember(), response.getJarNames());
+
+        List<DeployedJar> deployedJars = jarDeployer.deploy(stagedJarFiles);
+  private Map<String, File> getJarsFromLocator(DistributedMember locator,
+      Map<String, Set<String>> jarNames) throws IOException {
+    Map<String, File> results = new HashMap<>();
+
+    for (String group : jarNames.keySet()) {
+      for (String jar : jarNames.get(group)) {
+        results.put(jar, downloadJar(locator, group, jar));
+      }
+    }
+
+    return results;
+  }
+
+  public File downloadJar(DistributedMember locator, String groupName, String jarName)
+      throws IOException {
+    ResultCollector<RemoteInputStream, List<RemoteInputStream>> rc =
+        (ResultCollector<RemoteInputStream, List<RemoteInputStream>>) CliUtil.executeFunction(
+            new DownloadJarFunction(), new Object[] {groupName, jarName},
+            Collections.singleton(locator));
+
+    List<RemoteInputStream> result = rc.getResult();
+    RemoteInputStream jarStream = result.get(0);
+
+    Set<PosixFilePermission> perms = new HashSet<>();
+    perms.add(PosixFilePermission.OWNER_READ);
+    perms.add(PosixFilePermission.OWNER_WRITE);
+    perms.add(PosixFilePermission.OWNER_EXECUTE);
+    Path tempDir =
+        Files.createTempDirectory("deploy-", PosixFilePermissions.asFileAttribute(perms));
+    Path tempJar = Paths.get(tempDir.toString(), jarName);
+    FileOutputStream fos = new FileOutputStream(tempJar.toString());
+
+    int packetId = 0;
+    while (true) {
+      byte[] data = jarStream.readPacket(packetId);
+      if (data == null) {
+        break;
+      }
+      fos.write(data);
+      packetId++;
+    }
+    fos.close();
+    jarStream.close(true);
+
+    return tempJar.toFile();
+  }
+
+        response.setMember(locator);

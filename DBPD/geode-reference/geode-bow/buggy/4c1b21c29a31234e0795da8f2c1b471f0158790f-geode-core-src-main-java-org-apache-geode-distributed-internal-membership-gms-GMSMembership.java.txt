GEODE-7456: Moving GMSMembershipManager into gms package (#4313)

Adding a Distribution class that ClusterDistributionManager and the
rest of geode-core uses, which wraps GMSMembershipManager. Moving
GMSMembershipManager into the gms package and renaming to MembershipImpl.

Distribution now owns the DirectChannel, rather than MembershipImpl.

Removing the MembershipManager interface and replacing uses of it with the
Membership interface.

* Added an ArchUnitTest for geode-core to only use Distribution to access Membership.

-package org.apache.geode.distributed.internal.membership.adapter;
+package org.apache.geode.distributed.internal.membership.gms;
-import java.util.Arrays;
-import java.util.concurrent.TimeoutException;
-import java.util.function.Function;
+import java.util.function.Supplier;
-import org.apache.geode.ToDataException;
-import org.apache.geode.distributed.internal.AdminMessageType;
-import org.apache.geode.distributed.internal.OperationExecutors;
-import org.apache.geode.distributed.internal.OverflowQueueWithDMStats;
-import org.apache.geode.distributed.internal.ShutdownMessage;
-import org.apache.geode.distributed.internal.SizeableRunnable;
-import org.apache.geode.distributed.internal.direct.DirectChannel;
-import org.apache.geode.distributed.internal.direct.ShunnedMemberException;
-import org.apache.geode.distributed.internal.membership.MembershipManager;
-import org.apache.geode.distributed.internal.membership.gms.GMSMemberData;
-import org.apache.geode.distributed.internal.membership.gms.GMSMembershipView;
-import org.apache.geode.distributed.internal.membership.gms.Services;
-import org.apache.geode.distributed.internal.membership.gms.SuspectMember;
+import org.apache.geode.distributed.internal.membership.adapter.GMSLocatorAdapter;
+import org.apache.geode.distributed.internal.membership.adapter.GMSMessageAdapter;
+import org.apache.geode.distributed.internal.membership.adapter.GMSQuorumCheckerAdapter;
+import org.apache.geode.distributed.internal.membership.adapter.LocalViewMessage;
+import org.apache.geode.distributed.internal.membership.gms.api.LifecycleListener;
+import org.apache.geode.distributed.internal.membership.gms.api.Membership;
-import org.apache.geode.distributed.internal.membership.gms.api.MembershipStatistics;
-import org.apache.geode.distributed.internal.membership.gms.fd.GMSHealthMonitor;
-import org.apache.geode.distributed.internal.membership.gms.membership.GMSJoinLeave;
-import org.apache.geode.internal.tcp.ConnectExceptions;
+import org.apache.geode.internal.tcp.ConnectionException;
-import org.apache.geode.internal.util.Breadcrumbs;
+import org.apache.geode.security.GemFireSecurityException;
-public class GMSMembershipManager implements MembershipManager {
+public class GMSMembership implements Membership {
-  /**
-   * thread-local used to force use of Messenger for communications, usually to avoid deadlock when
-   * conserve-sockets=true. Use of this should be removed when connection pools are implemented in
-   * the direct-channel
-   */
-  private final ThreadLocal<Boolean> forceUseUDPMessaging =
-      ThreadLocal.withInitial(() -> Boolean.FALSE);
-
-
-  private long ackSevereAlertThreshold;
-  private long ackWaitThreshold;
+
+  private LifecycleListener lifecycleListener;
-   * @see GMSMembershipManager#startupLock
+   * @see GMSMembership#startupLock
-  private DirectChannel directChannel;
-
-  private MyDCReceiver dcReceiver;
-
-  /**
-   * Insert our own MessageReceiver between us and the direct channel, in order to correctly filter
-   * membership events.
-   *
-   *
-   */
-  class MyDCReceiver implements MessageListener {
-
-    final MessageListener upCall;
-
-    /**
-     * Don't provide events until the caller has told us we are ready.
-     *
-     * Synchronization provided via GroupMembershipService.class.
-     *
-     * Note that in practice we only need to delay accepting the first client; we don't need to put
-     * this check before every call...
-     *
-     */
-    MyDCReceiver(MessageListener up) {
-      upCall = up;
-    }
-
-    @Override
-    public void messageReceived(DistributionMessage msg) {
-      // bug 36851 - notify failure detection that we've had contact from a member
-      services.getHealthMonitor()
-          .contactedBy(msg.getSender());
-      handleOrDeferMessage(msg);
-    }
-
-  }
-  protected void processView(long newViewId, MembershipView newView) {
+  public void processView(long newViewId, MembershipView newView) {
-  public <V> V doWithViewLocked(Function<MembershipManager, V> function) {
+  public <V> V doWithViewLocked(Supplier<V> function) {
-      return (V) function.apply(this);
+      return function.get();
-  private boolean mcastEnabled;
-
-  private boolean tcpDisabled;
-  public GMSMembershipManager(MembershipListener listener, MessageListener messageListener,
-      ClusterDistributionManager dm) {
+  public GMSMembership(MembershipListener listener, MessageListener messageListener,
+      ClusterDistributionManager dm, LifecycleListener lifecycleListener) {
+    this.lifecycleListener = lifecycleListener;
-        if (directChannel != null) {
-          try {
-            directChannel.closeEndpoint(member, msg);
-          } catch (DistributedSystemDisconnectedException e) {
-            // ignore - happens during shutdown
-          }
-        }
-        destroyMember(member, msg); // for good luck
+
+        destroyMember(member, msg);
-      LocalViewMessage v = new LocalViewMessage(address, newId, viewArg, GMSMembershipManager.this);
+      LocalViewMessage v = new LocalViewMessage(address, newId, viewArg, GMSMembership.this);
-      directChannel.getCancelCriterion().checkCancelInProgress(null);
+      services.getCancelCriterion().checkCancelInProgress(null);
-          directChannel.getCancelCriterion().checkCancelInProgress(e);
+          services.getCancelCriterion().checkCancelInProgress(e);
-  private boolean isJoining() {
+  public boolean isJoining() {
+  @Override
-  public void postConnect() {}
-
-  /**
-   * @see SystemFailure#loadEmergencyClasses() /** break any potential circularity in
-   *      {@link #loadEmergencyClasses()}
-   */
-  @MakeNotStatic
-  private static volatile boolean emergencyClassesLoaded = false;
+  public void processMessage(final DistributionMessage msg) {
+    // notify failure detection that we've had contact from a member
+    services.getHealthMonitor().contactedBy(msg.getSender());
+    handleOrDeferMessage(msg);
+  }
-   * Ensure that the critical classes from components get loaded.
-   *
-   * @see SystemFailure#loadEmergencyClasses()
-   */
-  public static void loadEmergencyClasses() {
-    if (emergencyClassesLoaded)
-      return;
-    emergencyClassesLoaded = true;
-    DirectChannel.loadEmergencyClasses();
-    GMSJoinLeave.loadEmergencyClasses();
-    GMSHealthMonitor.loadEmergencyClasses();
-  }
-
-  /**
-
-    // Close the TCPConduit sockets...
-    if (directChannel != null) {
-      directChannel.emergencyClose();
-    }
-
-    if (this.directChannel != null) {
-      this.directChannel.disconnect(e);
-    }
+    lifecycleListener.disconnect(e);
-  /**
-   * Perform the grossness associated with sending a message over a DirectChannel
-   *
-   * @param destinations the list of destinations
-   * @param content the message
-   * @return all recipients who did not receive the message (null if all received it)
-   * @throws NotSerializableException if the message is not serializable
-   */
-  Set<InternalDistributedMember> directChannelSend(
-      InternalDistributedMember[] destinations, DistributionMessage content)
-      throws NotSerializableException {
-    MembershipStatistics theStats = services.getStatistics();
-    boolean allDestinations;
-    InternalDistributedMember[] keys;
-    if (content.forAll()) {
-      allDestinations = true;
-      latestViewReadLock.lock();
-      try {
-        List<InternalDistributedMember> keySet = latestView.getMembers();
-        keys = new InternalDistributedMember[keySet.size()];
-        keys = keySet.toArray(keys);
-      } finally {
-        latestViewReadLock.unlock();
-      }
-    } else {
-      allDestinations = false;
-      keys = destinations;
-    }
-
-    int sentBytes;
+  @Override
+  public InternalDistributedMember[] getAllMembers() {
+    latestViewReadLock.lock();
-      sentBytes =
-          directChannel.send(this, keys, content, ackWaitThreshold, ackSevereAlertThreshold);
-
-      if (theStats != null) {
-        theStats.incSentBytes(sentBytes);
-      }
-
-      if (sentBytes == 0) {
-        if (services.getCancelCriterion().isCancelInProgress()) {
-          throw new DistributedSystemDisconnectedException();
-        }
-      }
-    } catch (DistributedSystemDisconnectedException ex) {
-      if (services.getShutdownCause() != null) {
-        throw new DistributedSystemDisconnectedException("DistributedSystem is shutting down",
-            services.getShutdownCause());
-      } else {
-        throw ex; // see bug 41416
-      }
-    } catch (ConnectExceptions ex) {
-      // Check if the connect exception is due to system shutting down.
-      if (shutdownInProgress()) {
-        if (services.getShutdownCause() != null) {
-          throw new DistributedSystemDisconnectedException("DistributedSystem is shutting down",
-              services.getShutdownCause());
-        } else {
-          throw new DistributedSystemDisconnectedException();
-        }
-      }
-
-      if (allDestinations)
-        return null;
-
-      // We need to return this list of failures
-      List<InternalDistributedMember> members = ex.getMembers();
-
-      // SANITY CHECK: If we fail to send a message to an existing member
-      // of the view, we have a serious error (bug36202).
-
-      // grab a recent view, excluding shunned members
-      GMSMembershipView view = services.getJoinLeave().getView();
-
-      // Iterate through members and causes in tandem :-(
-      Iterator it_mem = members.iterator();
-      Iterator it_causes = ex.getCauses().iterator();
-      while (it_mem.hasNext()) {
-        InternalDistributedMember member = (InternalDistributedMember) it_mem.next();
-        Throwable th = (Throwable) it_causes.next();
-
-        if (!view.contains(member) || (th instanceof ShunnedMemberException)) {
-          continue;
-        }
-        logger.fatal(String.format("Failed to send message <%s> to member <%s> view, %s",
-            new Object[] {content, member, view}),
-            th);
-        // Assert.assertTrue(false, "messaging contract failure");
-      }
-      return new HashSet<>(members);
-    } // catch ConnectionExceptions
-    catch (ToDataException | CancelException e) {
-      throw e;
-    } catch (NotSerializableException | RuntimeException | Error e) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Membership: directChannelSend caught exception: {}", e.getMessage(), e);
-      }
-      throw e;
+      List<InternalDistributedMember> keySet = latestView.getMembers();
+      return keySet.toArray(new InternalDistributedMember[keySet.size()]);
+    } finally {
+      latestViewReadLock.unlock();
-    return null;
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.apache.geode.distributed.internal.membership.MembershipManager#isConnected()
+  @Override
+  public boolean hasMember(final InternalDistributedMember member) {
+    return services.getJoinLeave().getView().contains(member);
+  }
+
+  /**
+   * @see Membership#isConnected()
-  @Override
-  public Set<InternalDistributedMember> send(InternalDistributedMember[] destinations,
-      DistributionMessage msg) throws NotSerializableException {
-    Set<InternalDistributedMember> result;
-    boolean allDestinations = msg.forAll();
+
+  /**
+   * Check to see if the membership system is being shutdown
+   *
+   * @throws DistributedSystemDisconnectedException if the system is shutting down
+   */
+  public void checkCancelled() {
-          services.getCancelCriterion().generateCancelledException(null));
+          services.getCancelCriterion().generateCancelledException(services.getShutdownCause()));
+  }
+  /**
+   * Test hook to wait until we are no longer "Playing dead"
+   *
+   * TODO - remove this!
+   */
+  public void waitIfPlayingDead() {
+  }
-    if (isJoining()) {
-      // If we get here, we are starting up, so just report a failure.
-      if (allDestinations)
-        return null;
-      else {
-        result = new HashSet<>();
-        Collections.addAll(result, destinations);
-        return result;
-      }
+  @Override
+  public Set<InternalDistributedMember> send(final InternalDistributedMember[] destinations,
+      final DistributionMessage content)
+      throws NotSerializableException {
+    checkAddressesForUUIDs(destinations);
+    Set<MemberIdentifier> failures = services.getMessenger().send(new GMSMessageAdapter(content));
+    if (failures == null || failures.size() == 0) {
+      return Collections.emptySet();
-
-    if (msg instanceof AdminMessageType && this.shutdownInProgress) {
-      // no admin messages while shutting down - this can cause threads to hang
-      return new HashSet<>(Arrays.asList(msg.getRecipients()));
-    }
-
-    // Handle trivial cases
-    if (destinations == null) {
-      if (logger.isTraceEnabled())
-        logger.trace("Membership: Message send: returning early because null set passed in: '{}'",
-            msg);
-      return null; // trivially: all recipients received the message
-    }
-    if (destinations.length == 0) {
-      if (logger.isTraceEnabled())
-        logger.trace(
-            "Membership: Message send: returning early because empty destination list passed in: '{}'",
-            msg);
-      return null; // trivially: all recipients received the message
-    }
-
-    msg.setSender(address);
-
-    msg.setBreadcrumbsInSender();
-    Breadcrumbs.setProblem(null);
-
-    boolean useMcast = false;
-    if (mcastEnabled) {
-      useMcast = (msg.getMulticast() || allDestinations);
-    }
-
-    boolean sendViaMessenger = isForceUDPCommunications() || (msg instanceof ShutdownMessage);
-
-    if (useMcast || tcpDisabled || sendViaMessenger) {
-      checkAddressesForUUIDs(destinations);
-      Set<MemberIdentifier> failures = services.getMessenger().send(new GMSMessageAdapter(msg));
-      if (failures == null || failures.size() == 0) {
-        return Collections.emptySet();
-      }
-      return gmsMemberCollectionToInternalDistributedMemberSet(failures);
-    } else {
-      result = directChannelSend(destinations, msg);
-    }
-
-    // If the message was a broadcast, don't enumerate failures.
-    if (allDestinations)
-      return null;
-    else {
-      return result;
-    }
+    return gmsMemberCollectionToInternalDistributedMemberSet(failures);
-  // MembershipManager method
-  @Override
-  public void forceUDPMessagingForCurrentThread() {
-    forceUseUDPMessaging.set(Boolean.TRUE);
-  }
-
-  // MembershipManager method
-  @Override
-  public void releaseUDPMessagingForCurrentThread() {
-    forceUseUDPMessaging.set(Boolean.FALSE);
-  }
-
-  private boolean isForceUDPCommunications() {
-    return forceUseUDPMessaging.get();
-  }
-
-    final DirectChannel dc = directChannel;
-    if (dc != null) {
-      // Bug 37944: make sure this is always done in a separate thread,
-      // so that shutdown conditions don't wedge the view lock
-      // fix for bug 34010
-      new LoggingThread("disconnect thread for " + member, () -> {
-        try {
-          Thread.sleep(Integer.getInteger("p2p.disconnectDelay", 3000).intValue());
-        } catch (InterruptedException ie) {
-          Thread.currentThread().interrupt();
-          // Keep going, try to close the endpoint.
-        }
-        if (!dc.isOpen()) {
-          return;
-        }
-        if (logger.isDebugEnabled())
-          logger.debug("Membership: closing connections for departed member {}", member);
-        // close connections, but don't do membership notification since it's already been done
-        dc.closeEndpoint(member, reason, false);
-      }).start();
-    }
+    lifecycleListener.destroyMember(member, reason);
-
-  /**
-   * for testing verification purposes, this return the port for the direct channel, or zero if
-   * there is no direct channel
-   */
-  public int getDirectChannelPort() {
-    return directChannel == null ? 0 : directChannel.getPort();
-  }
-
-  /**
-   * for mock testing this allows insertion of a DirectChannel mock
-   */
-  void setDirectChannel(DirectChannel dc) {
-    this.directChannel = dc;
-    this.tcpDisabled = false;
-  }
-
-  public Map<String, Long> getMessageState(DistributedMember member, boolean includeMulticast) {
-    Map<String, Long> result = new HashMap<>();
-    DirectChannel dc = directChannel;
-    if (dc != null) {
-      dc.getChannelStates(member, result);
-    }
+  public Map<String, Long> getMessageState(DistributedMember member, boolean includeMulticast,
+      Map<String, Long> result) {
-    if (Thread.interrupted())
-      throw new InterruptedException();
-    DirectChannel dc = directChannel;
-    if (dc != null) {
-      dc.waitForChannelState(otherMember, state);
-    }
-
-    if (services.getConfig().isMulticastEnabled()
-        && !services.getConfig().getDisableTcp()) {
-      // GEODE-2865: wait for scheduled multicast messages to be applied to the cache
-      waitForSerialMessageProcessing((InternalDistributedMember) otherMember);
-    }
-  }
-
-  /*
-   * (non-Javadoc) MembershipManager method: wait for the given member to be gone. Throws
-   * TimeoutException if the wait goes too long
-   *
-   * @see
-   * org.apache.geode.distributed.internal.membership.MembershipManager#waitForDeparture(org.apache.
-   * geode.distributed.DistributedMember)
-   */
-  @Override
-  public boolean waitForDeparture(DistributedMember mbr)
-      throws TimeoutException, InterruptedException {
-    long memberTimeout = this.services.getConfig().getMemberTimeout();
-    return waitForDeparture(mbr, memberTimeout * 4);
-  }
-
-  /*
-   * (non-Javadoc) MembershipManager method: wait for the given member to be gone. Throws
-   * TimeoutException if the wait goes too long
-   *
-   * @see
-   * org.apache.geode.distributed.internal.membership.MembershipManager#waitForDeparture(org.apache.
-   * geode.distributed.DistributedMember)
-   */
-  @Override
-  public boolean waitForDeparture(DistributedMember mbr, long timeoutMs)
-      throws TimeoutException, InterruptedException {
-    if (Thread.interrupted())
-      throw new InterruptedException();
-    boolean result = false;
-    DirectChannel dc = directChannel;
-    InternalDistributedMember idm = (InternalDistributedMember) mbr;
-    long pauseTime = (timeoutMs < 4000) ? 100 : timeoutMs / 40;
-    boolean wait;
-    int numWaits = 0;
-    do {
-      wait = false;
-      if (dc != null) {
-        if (dc.hasReceiversFor(idm)) {
-          wait = true;
-        }
-        if (wait && logger.isDebugEnabled()) {
-          logger.info("waiting for receivers for {} to shut down", mbr);
-        }
-      }
-      if (!wait) {
-        latestViewReadLock.lock();
-        try {
-          wait = this.latestView.contains(idm);
-        } finally {
-          latestViewReadLock.unlock();
-        }
-        if (wait && logger.isDebugEnabled()) {
-          logger.debug("waiting for {} to leave the membership view", mbr);
-        }
-      }
-      if (!wait) {
-        if (waitForSerialMessageProcessing(idm)) {
-          result = true;
-        }
-      }
-      if (wait) {
-        numWaits++;
-        if (numWaits > 40) {
-          throw new TimeoutException("waited too long for " + idm + " to be removed");
-        }
-        Thread.sleep(pauseTime);
-      }
-    } while (wait && (dc != null && dc.isOpen())
-        && !services.getCancelCriterion().isCancelInProgress());
-    if (logger.isDebugEnabled()) {
-      logger.debug("operations for {} should all be in the cache at this point", mbr);
-    }
-    return result;
-  }
-
-  /**
-   * wait for serial executor messages from the given member to be processed
-   */
-  private boolean waitForSerialMessageProcessing(InternalDistributedMember idm)
-      throws InterruptedException {
-    // run a message through the member's serial execution queue to ensure that all of its
-    // current messages have been processed
-    boolean result = false;
-    OverflowQueueWithDMStats<Runnable> serialQueue = dm.getExecutors().getSerialQueue(idm);
-    if (serialQueue != null) {
-      final boolean done[] = new boolean[1];
-      final FlushingMessage msg = new FlushingMessage(done);
-      serialQueue.add(new SizeableRunnable(100) {
-        @Override
-        public void run() {
-          msg.invoke();
-        }
-
-        public String toString() {
-          return "Processing fake message";
-        }
-      });
-      synchronized (done) {
-        while (!done[0]) {
-          done.wait(10);
-        }
-        result = true;
-      }
-    }
-    return result;
-  /** this is a fake message class that is used to flush the serial execution queue */
-  static class FlushingMessage extends DistributionMessage {
-    final boolean[] done;
-
-    FlushingMessage(boolean[] done) {
-      this.done = done;
-    }
-
-    public void invoke() {
-      synchronized (done) {
-        done[0] = true;
-        done.notify();
-      }
-    }
-
-    @Override
-    protected void process(ClusterDistributionManager dm) {
-      // not used
-    }
-
-    @Override
-    public int getDSFID() {
-      return 0;
-    }
-
-    @Override
-    public int getProcessorType() {
-      return OperationExecutors.SERIAL_EXECUTOR;
-    }
-  }
-
+  @Override
+  public void start() {
+    try {
+      services.start();
+    } catch (ConnectionException e) {
+      throw new DistributionException(
+          "Unable to create membership manager",
+          e);
+    } catch (GemFireConfigException | SystemConnectException | GemFireSecurityException e) {
+      throw e;
+    } catch (RuntimeException e) {
+      Services.getLogger().error("Unexpected problem starting up membership services", e);
+      throw new SystemConnectException("Problem starting up membership services", e);
+    }
+  }
+
-      GMSMembershipManager.this.services = services;
+      GMSMembership.this.services = services;
-      // cache these settings for use in send()
-      mcastEnabled = config.isMcastEnabled();
-      tcpDisabled = config.isTcpDisabled();
-      ackSevereAlertThreshold = config.getAckSevereAlertThreshold();
-      ackWaitThreshold = config.getAckWaitThreshold();
-
-      if (!tcpDisabled) {
-        dcReceiver = new MyDCReceiver(messageListener);
-      }
-      int dcPort = 0;
-      if (!tcpDisabled) {
-        directChannel = new DirectChannel(GMSMembershipManager.this, dcReceiver, dm);
-        dcPort = directChannel.getPort();
-      }
-      services.getMessenger().getMemberID().setDirectChannelPort(dcPort);
+      lifecycleListener.start(services.getMessenger().getMemberID());
+
-      logger.debug("MembershipManager closing");
+      logger.debug("Membership closing");
-      if (directChannel != null) {
-        directChannel.disconnect(null);
+      if (lifecycleListener.disconnect(null)) {
-        logger.debug("MembershipManager: initial view is {}", latestView);
+        logger.debug("Membership: initial view is {}", latestView);
-        if (directChannel != null) {
-          directChannel.disconnect(e);
-        }
+        lifecycleListener.disconnect(e);
-      GMSMembershipManager.this.address =
+      GMSMembership.this.address =
-      if (directChannel != null) {
-        directChannel.setLocalAddr(address);
-      }
+      lifecycleListener.setLocalAddress(address);
-      GMSMembershipManager.this.hasJoined = true;
+      GMSMembership.this.hasJoined = true;
-      if (GMSMembershipManager.this.shutdownInProgress || isJoining()) {
+      if (GMSMembership.this.shutdownInProgress || isJoining()) {
-      // Attempt to replace these with full IDs from the MembershipManager's view.
+      // Attempt to replace these with full IDs from the Membership's view.

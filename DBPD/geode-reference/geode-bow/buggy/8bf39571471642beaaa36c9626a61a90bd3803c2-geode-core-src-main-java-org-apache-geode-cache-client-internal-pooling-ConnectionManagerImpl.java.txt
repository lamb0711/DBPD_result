Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Manages client to server connections for the connection pool. This class contains
- * all of the pooling logic to checkout/checkin connections.
+ * Manages client to server connections for the connection pool. This class contains all of the
+ * pooling logic to checkout/checkin connections.
-  static long AQUIRE_TIMEOUT = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "ConnectionManager.AQUIRE_TIMEOUT", 10 * 1000).longValue();
+  static long AQUIRE_TIMEOUT = Long
+      .getLong(DistributionConfig.GEMFIRE_PREFIX + "ConnectionManager.AQUIRE_TIMEOUT", 10 * 1000)
+      .longValue();
-//  private final long pingInterval; // ms // make this an int
-  private final LinkedList/*<PooledConnection>*/ availableConnections = new LinkedList/*<PooledConnection>*/();
+  // private final long pingInterval; // ms // make this an int
+  private final LinkedList/* <PooledConnection> */ availableConnections =
+      new LinkedList/* <PooledConnection> */();
-  
+
-  private boolean keepAlive=false;
+  private boolean keepAlive = false;
+   * 
-   * @param idleTimeout The amount of time to wait to expire idle connections. -1 means that
-   * idle connections are never expired.
+   * @param idleTimeout The amount of time to wait to expire idle connections. -1 means that idle
+   *        connections are never expired.
-   * @param securityLogger 
+   * @param securityLogger
-  public ConnectionManagerImpl(String poolName,
-                               ConnectionFactory factory,
-                               EndpointManager endpointManager,
-                               int maxConnections, int minConnections,
-                               long idleTimeout, int lifetimeTimeout,
-                               InternalLogWriter securityLogger, long pingInterval,
-                               CancelCriterion cancelCriterion, PoolStats poolStats) {
+  public ConnectionManagerImpl(String poolName, ConnectionFactory factory,
+      EndpointManager endpointManager, int maxConnections, int minConnections, long idleTimeout,
+      int lifetimeTimeout, InternalLogWriter securityLogger, long pingInterval,
+      CancelCriterion cancelCriterion, PoolStats poolStats) {
-    if(maxConnections < minConnections && maxConnections != -1) {
-      throw new IllegalArgumentException("Max connections " + maxConnections + " is less than minConnections " + minConnections);
+    if (maxConnections < minConnections && maxConnections != -1) {
+      throw new IllegalArgumentException(
+          "Max connections " + maxConnections + " is less than minConnections " + minConnections);
-    if(maxConnections <= 0 && maxConnections != -1) {
-      throw new IllegalArgumentException("Max connections " + maxConnections + " must be greater than 0");
+    if (maxConnections <= 0 && maxConnections != -1) {
+      throw new IllegalArgumentException(
+          "Max connections " + maxConnections + " must be greater than 0");
-    if(minConnections < 0) {
-      throw new IllegalArgumentException("Min connections " + minConnections + " must be greater than or equals to 0");
+    if (minConnections < 0) {
+      throw new IllegalArgumentException(
+          "Min connections " + minConnections + " must be greater than or equals to 0");
-    
+
-//    this.pingInterval = pingInterval;
+    // this.pingInterval = pingInterval;
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  public Connection borrowConnection(long acquireTimeout) throws AllConnectionsInUseException, NoAvailableServersException {
-    
+  public Connection borrowConnection(long acquireTimeout)
+      throws AllConnectionsInUseException, NoAvailableServersException {
+
-    
-    //wait for a connection to become free
+
+    // wait for a connection to become free
-      while(connectionCount >= maxConnections && availableConnections.isEmpty() &&remainingTime > 0 && !shuttingDown) {
+      while (connectionCount >= maxConnections && availableConnections.isEmpty()
+          && remainingTime > 0 && !shuttingDown) {
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
-      if(shuttingDown) {
+      if (shuttingDown) {
-        }
-        catch (ConnectionDestroyedException ex) {
+        } catch (ConnectionDestroyedException ex) {
-      }
-      else {
-        //We need to create a connection. Reserve space for it.
+      } else {
+        // We need to create a connection. Reserve space for it.
-//         logger.info("DEBUG: borrowConnection conCount(+1)->" + connectionCount);
-//         getPoolStats().incConCount(1);
+        // logger.info("DEBUG: borrowConnection conCount(+1)->" + connectionCount);
+        // getPoolStats().incConCount(1);
-      
-    }
-    finally {
+
+    } finally {
-    
+
-      Connection plainConnection = connectionFactory.createClientToServerConnection(Collections.EMPTY_SET);
-      
+      Connection plainConnection =
+          connectionFactory.createClientToServerConnection(Collections.EMPTY_SET);
+
-    }
-    catch(GemFireSecurityException e) {
+    } catch (GemFireSecurityException e) {
-    }
-    catch(GatewayConfigurationException e) {
+    } catch (GatewayConfigurationException e) {
-    }
-    catch(ServerRefusedConnectionException srce) {
+    } catch (ServerRefusedConnectionException srce) {
-    }
-    finally {
-      //if we failed, release the space we reserved for our connection
-      if(connection == null) {
+    } finally {
+      // if we failed, release the space we reserved for our connection
+      if (connection == null) {
-//           getPoolStats().incConCount(-1);
+          // getPoolStats().incConCount(-1);
-//           logger.info("DEBUG: borrowConnection conCount(-1)->" + connectionCount);
-          if(connectionCount < minConnections) {
+          // logger.info("DEBUG: borrowConnection conCount(-1)->" + connectionCount);
+          if (connectionCount < minConnections) {
-        }
-        finally {
+        } finally {
-    
-    if(connection == null) {
+
+    if (connection == null) {
-    
+
-  
-//   public Connection borrowConnection(ServerLocation server, long acquireTimeout)
-//       throws AllConnectionsInUseException, NoAvailableServersException {
-//     return borrowConnection(server, acquireTimeout, false);
-//   }
-//   /**
-//    * Used to tell a caller of borrowConnection that it did not find an existing connnection.
-//    */
-//   public static final Connection NO_EXISTING_CONNECTION = new ConnectionImpl(null, null);
-  
+  // public Connection borrowConnection(ServerLocation server, long acquireTimeout)
+  // throws AllConnectionsInUseException, NoAvailableServersException {
+  // return borrowConnection(server, acquireTimeout, false);
+  // }
+
+  // /**
+  // * Used to tell a caller of borrowConnection that it did not find an existing connnection.
+  // */
+  // public static final Connection NO_EXISTING_CONNECTION = new ConnectionImpl(null, null);
+
-   * Borrow a connection to a specific server. This task currently
-   * allows us to break the connection limit, because it is used by
-   * tasks from the background thread that shouldn't be constrained
-   * by the limit. They will only violate the limit by 1 connection, and 
-   * that connection will be destroyed when returned to the pool.
+   * Borrow a connection to a specific server. This task currently allows us to break the connection
+   * limit, because it is used by tasks from the background thread that shouldn't be constrained by
+   * the limit. They will only violate the limit by 1 connection, and that connection will be
+   * destroyed when returned to the pool.
-  public Connection borrowConnection(ServerLocation server, long acquireTimeout
-                                     , boolean onlyUseExistingCnx)
-    throws AllConnectionsInUseException, NoAvailableServersException {
+  public Connection borrowConnection(ServerLocation server, long acquireTimeout,
+      boolean onlyUseExistingCnx) throws AllConnectionsInUseException, NoAvailableServersException {
-      if(shuttingDown) {
+      if (shuttingDown) {
-      for(Iterator itr = availableConnections.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = availableConnections.iterator(); itr.hasNext();) {
-          if(nextConnection.getServer().equals(server)) {
+          if (nextConnection.getServer().equals(server)) {
-        //Fix for 41516. Before we let this method exceed the max connections
-        //by creating a new connection, we need to make sure that they're
-        //aren't bogus connections sitting in the available connection list
-        //otherwise, the length of that list might exceed max connections,
-        //but with some bad connections. That can cause members to 
-        //get a bad connection but have no permits to create a new connection.
-        if(nextConnection.shouldDestroy()) {
+        // Fix for 41516. Before we let this method exceed the max connections
+        // by creating a new connection, we need to make sure that they're
+        // aren't bogus connections sitting in the available connection list
+        // otherwise, the length of that list might exceed max connections,
+        // but with some bad connections. That can cause members to
+        // get a bad connection but have no permits to create a new connection.
+        if (nextConnection.shouldDestroy()) {
-//       logger.info("DEBUG: borrowConnection conCount(+1)->" + connectionCount);
-//       getPoolStats().incConCount(1);
+      // logger.info("DEBUG: borrowConnection conCount(+1)->" + connectionCount);
+      // getPoolStats().incConCount(1);
-    
+
-    } catch(GemFireSecurityException e) {
+    } catch (GemFireSecurityException e) {
-      //if we failed, release the space we reserved for our connection
-      if(connection == null) {
+      // if we failed, release the space we reserved for our connection
+      if (connection == null) {
-//           getPoolStats().incConCount(-1);
+          // getPoolStats().incConCount(-1);
-//           logger.info("DEBUG: borrowConnection conCount(-1)->" + connectionCount);
-          if(connectionCount < minConnections) {
+          // logger.info("DEBUG: borrowConnection conCount(-1)->" + connectionCount);
+          if (connectionCount < minConnections) {
-    if(connection == null) {
-      throw new ServerConnectivityException("Could not create a new connection to server " + server);
+    if (connection == null) {
+      throw new ServerConnectivityException(
+          "Could not create a new connection to server " + server);
-  
+
-      Set/* <ServerLocation> */excludedServers, long acquireTimeout)
+      Set/* <ServerLocation> */ excludedServers, long acquireTimeout)
-      if(shuttingDown) {
+      if (shuttingDown) {
-      for(Iterator itr = availableConnections.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = availableConnections.iterator(); itr.hasNext();) {
-        if(!excludedServers.contains(nextConnection.getServer())) {
+        if (!excludedServers.contains(nextConnection.getServer())) {
-//             logger.info("DEBUG: exchangeConnection removeCon(" + oldPC +")");
+            // logger.info("DEBUG: exchangeConnection removeCon(" + oldPC +")");
-//               getPoolStats().incConCount(-1);
+              // getPoolStats().incConCount(-1);
-//               logger.info("DEBUG: exchangeConnection conCount(-1)->" + connectionCount + " oldPC=" + oldPC);
-              if(connectionCount < minConnections) {
+              // logger.info("DEBUG: exchangeConnection conCount(-1)->" + connectionCount + "
+              // oldPC=" + oldPC);
+              if (connectionCount < minConnections) {
-          }
-          catch (ConnectionDestroyedException ex) {
+          } catch (ConnectionDestroyedException ex) {
-          //We need to create a connection. Reserve space for it.
+          // We need to create a connection. Reserve space for it.
-    }
-    finally {
+    } finally {
-    if(newConnection == null) {
+    if (newConnection == null) {
-        Connection plainConnection = connectionFactory.createClientToServerConnection(excludedServers);
+        Connection plainConnection =
+            connectionFactory.createClientToServerConnection(excludedServers);
-//         logger.info("DEBUG: exchangeConnection newConnection=" + newConnection);
-      }
-      catch(GemFireSecurityException e) {
+        // logger.info("DEBUG: exchangeConnection newConnection=" + newConnection);
+      } catch (GemFireSecurityException e) {
-      }
-      catch(ServerRefusedConnectionException srce) {
+      } catch (ServerRefusedConnectionException srce) {
-      }
-      finally {
+      } finally {
-//             getPoolStats().incConCount(-1);
+            // getPoolStats().incConCount(-1);
-//             logger.info("DEBUG: exchangeConnection conCount(-1)->" + connectionCount);
-            if(connectionCount < minConnections) {
+            // logger.info("DEBUG: exchangeConnection conCount(-1)->" + connectionCount);
+            if (connectionCount < minConnections) {
-          }
-          finally {
+          } finally {
-    
-    if(newConnection == null) {
+
+    if (newConnection == null) {
-//     logger.info("DEBUG: exchangeConnection internalDestroy(" + oldPC +")");
+    // logger.info("DEBUG: exchangeConnection internalDestroy(" + oldPC +")");
-    
+
-  protected/*GemStoneAddition*/ String getPoolName() {
+  protected/* GemStoneAddition */ String getPoolName() {
-  
+
-      
-    if(conn == null) {
+
+    if (conn == null) {
-    PooledConnection pooledConn= new PooledConnection(this, conn);
+    PooledConnection pooledConn = new PooledConnection(this, conn);
-    if(logger.isDebugEnabled()) {
-      logger.debug("Created a new connection. {} Connection count is now {}", pooledConn, connectionCount);
+    if (logger.isDebugEnabled()) {
+      logger.debug("Created a new connection. {} Connection count is now {}", pooledConn,
+          connectionCount);
-  
+
-        if(logger.isDebugEnabled()) {
-          logger.debug("Invalidating connection {} connection count is now {}", connection, connectionCount);
+        if (logger.isDebugEnabled()) {
+          logger.debug("Invalidating connection {} connection count is now {}", connection,
+              connectionCount);
-      
-//         getPoolStats().incConCount(-1);
-//         logger.info("DEBUG: destroyConnection conCount(-1)->" + connectionCount);
-        if(connectionCount < minConnections) {
+
+        // getPoolStats().incConCount(-1);
+        // logger.info("DEBUG: destroyConnection conCount(-1)->" + connectionCount);
+        if (connectionCount < minConnections) {
-    }
-    finally {
+    } finally {
-    
+
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.pooling.ConnectionManager#invalidateServer(org.apache.geode.distributed.internal.ServerLocation)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.pooling.ConnectionManager#invalidateServer(org.apache.
+   * geode.distributed.internal.ServerLocation)
-    if(badConnections == null) {
+    if (badConnections == null) {
-    
+
-      if(shuttingDown) {
+      if (shuttingDown) {
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-      //mark connections for destruction now, so if anyone tries
-      //to return a connection they'll get an exception
-      for(Iterator itr = badConnections.iterator(); itr.hasNext(); ) {
+      // mark connections for destruction now, so if anyone tries
+      // to return a connection they'll get an exception
+      for (Iterator itr = badConnections.iterator(); itr.hasNext();) {
-//           itr.remove(); // someone else is destroying it
+          // itr.remove(); // someone else is destroying it
-      
-      for(Iterator itr = availableConnections.iterator(); itr.hasNext(); ) {
+
+      for (Iterator itr = availableConnections.iterator(); itr.hasNext();) {
-        if(badConnections.contains(conn)) {
+        if (badConnections.contains(conn)) {
-      
-//       getPoolStats().incConCount(-badConnections.size());
+
+      // getPoolStats().incConCount(-badConnections.size());
-//       logger.info("DEBUG: invalidateServer conCount(" + (-badConnections.size()) + ")->" + connectionCount);
-      
-      if(connectionCount < minConnections) {
+      // logger.info("DEBUG: invalidateServer conCount(" + (-badConnections.size()) + ")->" +
+      // connectionCount);
+
+      if (connectionCount < minConnections) {
-      for(Iterator itr = badConnections.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = badConnections.iterator(); itr.hasNext();) {
-      if(connectionCount < maxConnections) {
+      if (connectionCount < maxConnections) {
-    }
-    finally {
+    } finally {
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.pooling.ConnectionManager#returnConnection(org.apache.geode.cache.client.internal.Connection)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.pooling.ConnectionManager#returnConnection(org.apache.
+   * geode.cache.client.internal.Connection)
-  
+
-    PooledConnection pooledConn = (PooledConnection)connection;
+    PooledConnection pooledConn = (PooledConnection) connection;
-          PoolImpl localpool=(PoolImpl)PoolManagerImpl.getPMI().find(poolName);
-          Boolean durable=false;
-          if(localpool!=null){
-            durable=localpool.isDurableClient();
-            }
-        pooledConn.internalClose(durable||this.keepAlive);
+        PoolImpl localpool = (PoolImpl) PoolManagerImpl.getPMI().find(poolName);
+        Boolean durable = false;
+        if (localpool != null) {
+          durable = localpool.isDurableClient();
+        }
+        pooledConn.internalClose(durable || this.keepAlive);
-            LocalizedStrings.ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_0,
-            pooledConn), e);
+            LocalizedStrings.ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_0, pooledConn), e);
-  }  
+  }
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
-    this.loadConditioningProcessor = new ScheduledThreadPoolExecutor(1/*why not 0?*/, new ThreadFactory() {
-        public Thread newThread(final Runnable r) {
-          Thread result = new Thread(r, "poolLoadConditioningMonitor-" + getPoolName());
-          result.setDaemon(true);
-          return result;
-        }
-      });
+    this.loadConditioningProcessor =
+        new ScheduledThreadPoolExecutor(1/* why not 0? */, new ThreadFactory() {
+          public Thread newThread(final Runnable r) {
+            Thread result = new Thread(r, "poolLoadConditioningMonitor-" + getPoolName());
+            result.setDaemon(true);
+            return result;
+          }
+        });
-    
+
-    
+
-    }
-    finally {
+    } finally {
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-    if(logger.isDebugEnabled()) {
+    if (logger.isDebugEnabled()) {
-    this.keepAlive=keepAlive;
+    this.keepAlive = keepAlive;
-    
+
-      if(shuttingDown) {
+      if (shuttingDown) {
-    }
-    finally {
+    } finally {
-//     closeReplacementConnection();
+    // closeReplacementConnection();
-        if(!this.loadConditioningProcessor.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.ConnectionManagerImpl_TIMEOUT_WAITING_FOR_LOAD_CONDITIONING_TASKS_TO_COMPLETE));
+        if (!this.loadConditioningProcessor.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT,
+            TimeUnit.MILLISECONDS)) {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.ConnectionManagerImpl_TIMEOUT_WAITING_FOR_LOAD_CONDITIONING_TASKS_TO_COMPLETE));
-    }
-    catch (RuntimeException e) {
-      logger.error(LocalizedMessage.create(LocalizedStrings.ConnectionManagerImpl_ERROR_STOPPING_LOADCONDITIONINGPROCESSOR), e);
-    }
-    catch (InterruptedException e) {
-      logger.error(LocalizedMessage.create(LocalizedStrings.ConnectionManagerImpl_INTERRUPTED_STOPPING_LOADCONDITIONINGPROCESSOR), e);
+    } catch (RuntimeException e) {
+      logger.error(LocalizedMessage.create(
+          LocalizedStrings.ConnectionManagerImpl_ERROR_STOPPING_LOADCONDITIONINGPROCESSOR), e);
+    } catch (InterruptedException e) {
+      logger.error(
+          LocalizedMessage.create(
+              LocalizedStrings.ConnectionManagerImpl_INTERRUPTED_STOPPING_LOADCONDITIONINGPROCESSOR),
+          e);
-//     closeReplacementConnection();
+    // closeReplacementConnection();
-  
+
-//     closeReplacementConnection();
+    // closeReplacementConnection();
-        if(!haveIdleExpireConnectionsTask) {
+        if (!haveIdleExpireConnectionsTask) {
-            backgroundProcessor.schedule(new IdleExpireConnectionsTask(), idleTimeout, TimeUnit.MILLISECONDS);
-          }
-          catch (RejectedExecutionException e) {
+            backgroundProcessor.schedule(new IdleExpireConnectionsTask(), idleTimeout,
+                TimeUnit.MILLISECONDS);
+          } catch (RejectedExecutionException e) {
-    if(!havePrefillTask) {
+    if (!havePrefillTask) {
-      }
-      catch (RejectedExecutionException e) {
+      } catch (RejectedExecutionException e) {
-  
+
-        boolean createdConnection= prefillConnection();
+        boolean createdConnection = prefillConnection();
-    }
-    catch(Throwable t) {
+    } catch (Throwable t) {
-      if(t.getCause()!=null) {
+      if (t.getCause() != null) {
-    
+
-  
+
-      return ((PooledConnection)conn).getConnection();
-    } else if (conn instanceof QueueConnectionImpl) { 
-      return ((QueueConnectionImpl)conn).getConnection();
+      return ((PooledConnection) conn).getConnection();
+    } else if (conn instanceof QueueConnectionImpl) {
+      return ((QueueConnectionImpl) conn).getConnection();
-      if (shuttingDown) { 
+      if (shuttingDown) {
-//         getPoolStats().incConCount(1);
+        // getPoolStats().incConCount(1);
-//         logger.info("DEBUG: prefillConnection conCount(+1)->" + connectionCount);
+        // logger.info("DEBUG: prefillConnection conCount(+1)->" + connectionCount);
-    }
-    finally {
+    } finally {
-    
+
-      PooledConnection connection= null;
+      PooledConnection connection = null;
-        Connection plainConnection = connectionFactory.createClientToServerConnection(Collections.EMPTY_SET);
-        if(plainConnection == null) {
+        Connection plainConnection =
+            connectionFactory.createClientToServerConnection(Collections.EMPTY_SET);
+        if (plainConnection == null) {
-      }
-      catch (ServerConnectivityException ex) {
-        logger.info(LocalizedStrings.ConnectionManagerImpl_UNABLE_TO_PREFILL_POOL_TO_MINIMUM_BECAUSE_0.toLocalizedString(ex.getMessage()));
+      } catch (ServerConnectivityException ex) {
+        logger
+            .info(LocalizedStrings.ConnectionManagerImpl_UNABLE_TO_PREFILL_POOL_TO_MINIMUM_BECAUSE_0
+                .toLocalizedString(ex.getMessage()));
-      }
-      finally {
+      } finally {
-          if(connection == null) {
-//             getPoolStats().incConCount(-1);
+          if (connection == null) {
+            // getPoolStats().incConCount(-1);
-//             logger.info("DEBUG: prefillConnection conCount(-1)->" + connectionCount);
-            if(logger.isDebugEnabled()) {
-              logger.debug("Unable to prefill pool to minimum, connection count is now {}", connectionCount);
+            // logger.info("DEBUG: prefillConnection conCount(-1)->" + connectionCount);
+            if (logger.isDebugEnabled()) {
+              logger.debug("Unable to prefill pool to minimum, connection count is now {}",
+                  connectionCount);
-          }
-          else {
+          } else {
-            if(logger.isDebugEnabled()) {
-              logger.debug("Prefilled connection {} connection count is now {}", connection, connectionCount);
+            if (logger.isDebugEnabled()) {
+              logger.debug("Prefilled connection {} connection count is now {}", connection,
+                  connectionCount);
-        }
-        finally {
+        } finally {
-    
+
-  
+
-  
+
-//         logger.info("DEBUG: lifetimeTask=" + this);
+        // logger.info("DEBUG: lifetimeTask=" + this);
-      }
-      catch (CancelException ignore) {
-      }
-      catch (VirtualMachineError e) {
+      } catch (CancelException ignore) {
+      } catch (VirtualMachineError e) {
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ConnectionManagerImpl_LOADCONDITIONINGTASK_0_ENCOUNTERED_EXCEPTION, this), t);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.ConnectionManagerImpl_LOADCONDITIONINGTASK_0_ENCOUNTERED_EXCEPTION,
+            this), t);
-  
+
-      }
-      catch (CancelException ignore) {
-      }
-      catch (VirtualMachineError e) {
+      } catch (CancelException ignore) {
+      } catch (VirtualMachineError e) {
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ConnectionManagerImpl_IDLEEXPIRECONNECTIONSTASK_0_ENCOUNTERED_EXCEPTION, this), t);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.ConnectionManagerImpl_IDLEEXPIRECONNECTIONSTASK_0_ENCOUNTERED_EXCEPTION,
+            this), t);
-  
+
-        if(connectionCount < minConnections && !cancelCriterion.isCancelInProgress()) {
+        if (connectionCount < minConnections && !cancelCriterion.isCancelInProgress()) {
-            backgroundProcessor.schedule(new PrefillConnectionsTask(), prefillRetry, TimeUnit.MILLISECONDS);
-          } catch(RejectedExecutionException e) {
-            //ignore, the timer has been cancelled, which means we're shutting down.
+            backgroundProcessor.schedule(new PrefillConnectionsTask(), prefillRetry,
+                TimeUnit.MILLISECONDS);
+          } catch (RejectedExecutionException e) {
+            // ignore, the timer has been cancelled, which means we're shutting down.
-        }
-        else {
+        } else {
-      }
-      finally {
+      } finally {
-//   private final AR/*<ReplacementConnection>*/ replacement = CFactory.createAR();
+  // private final AR/*<ReplacementConnection>*/ replacement = CFactory.createAR();
-//   private void closeReplacementConnection() {
-//     ReplacementConnection rc = (ReplacementConnection)this.replacement.getAndSet(null);
-//     if (rc != null) {
-//       rc.getConnection().destroy();
-//     }
-//   }
+  // private void closeReplacementConnection() {
+  // ReplacementConnection rc = (ReplacementConnection)this.replacement.getAndSet(null);
+  // if (rc != null) {
+  // rc.getConnection().destroy();
+  // }
+  // }
+   * 
-          }
-          else {
-//             // target was destroyed; we have already removed it from
-//             // allConnectionsMap but didn't dec the stat
-//             getPoolStats().incPoolConnections(-1);
-//             logger.info("DEBUG: offerReplacementConnection incPoolConnections(-1)->" + getPoolStats().getPoolConnections());
+          } else {
+            // // target was destroyed; we have already removed it from
+            // // allConnectionsMap but didn't dec the stat
+            // getPoolStats().incPoolConnections(-1);
+            // logger.info("DEBUG: offerReplacementConnection incPoolConnections(-1)->" +
+            // getPoolStats().getPoolConnections());
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
-   * An existing connections lifetime has expired.
-   * We only want to create one replacement connection at a time
-   * so this guy should block until this connection replaces an existing one.
-   * Note that if a connection is created here it must not count against
-   * the pool max and its idle time and lifetime must not begin until
-   * it actually replaces the existing one.
+   * An existing connections lifetime has expired. We only want to create one replacement connection
+   * at a time so this guy should block until this connection replaces an existing one. Note that if
+   * a connection is created here it must not count against the pool max and its idle time and
+   * lifetime must not begin until it actually replaces the existing one.
+   * 
-   * @return true if caller should recheck for expired lifetimes;
-   *         false if a background check was scheduled or no expirations are possible.
+   * @return true if caller should recheck for expired lifetimes; false if a background check was
+   *         scheduled or no expirations are possible.
-                                                      boolean idlePossible) {
+      boolean idlePossible) {
-//    boolean replacementConsumed = false;
+    // boolean replacementConsumed = false;
-      }
-      else {
+      } else {
-          //           logger.fine("DEBUG: creating replacement connection to " + sl);
+          // logger.fine("DEBUG: creating replacement connection to " + sl);
-          //           logger.fine("DEBUG: created replacement connection: " + con);
-        }
-        catch (GemFireSecurityException e) {
+          // logger.fine("DEBUG: created replacement connection: " + con);
+        } catch (GemFireSecurityException e) {
-        }
-        catch (ServerRefusedConnectionException srce) {
+        } catch (ServerRefusedConnectionException srce) {
-        } 
+        }
-        }
-        else {
+        } else {
-  
+
-    private final HashMap/*<Endpoint, HashSet<PooledConnection>*/ map = new HashMap();
-    private final LinkedList/*<PooledConnection>*/ allConnections = new LinkedList/*<PooledConnection>*/(); // in the order they were created
+    private final HashMap/* <Endpoint, HashSet<PooledConnection> */ map = new HashMap();
+    private final LinkedList/* <PooledConnection> */ allConnections =
+        new LinkedList/* <PooledConnection> */(); // in the order they were created
-        PooledConnection pc = (PooledConnection)it.next();
+        PooledConnection pc = (PooledConnection) it.next();
-        }
-        else if ( pc.hasIdleExpired(now, idleTimeoutNanos) ) {
+        } else if (pc.hasIdleExpired(now, idleTimeoutNanos)) {
-        }
-        else if ( pc.remainingLife(now, lifetimeTimeoutNanos) <= 0 ) {
+        } else if (pc.remainingLife(now, lifetimeTimeoutNanos) <= 0) {
-    
+
-//       logger.info("DEBUG: addConnection incPoolConnections(1)->" + getPoolStats().getPoolConnections() + " con="+connection,
-//                   new RuntimeException("STACK"));
+      // logger.info("DEBUG: addConnection incPoolConnections(1)->" +
+      // getPoolStats().getPoolConnections() + " con="+connection,
+      // new RuntimeException("STACK"));
-//           logger.info("DEBUG: rescheduling lifetime expire to be now");
+          // logger.info("DEBUG: rescheduling lifetime expire to be now");
-        }
-        else {
+        } else {
-    
+
-      if(endpointConnections != null) {
+      if (endpointConnections != null) {
-//           logger.info("DEBUG: removedEndpoint incPoolConnections(" + (-count) + ")->" + getPoolStats().getPoolConnections() + " cons.size=" + endpointConnections.size() + " cons=" + endpointConnections);
+          // logger.info("DEBUG: removedEndpoint incPoolConnections(" + (-count) + ")->" +
+          // getPoolStats().getPoolConnections() + " cons.size=" + endpointConnections.size() + "
+          // cons=" + endpointConnections);
-    
+
-//         logger.info("DEBUG: removedConnection incPoolConnections(-1)->" + getPoolStats().getPoolConnections() + " con="+connection);
+        // logger.info("DEBUG: removedConnection incPoolConnections(-1)->" +
+        // getPoolStats().getPoolConnections() + " con="+connection);
-      if(endpointConnections == null) {
+      if (endpointConnections == null) {
-    
+
-    
-    private synchronized void removeFromEndpointMap(Endpoint endpoint, PooledConnection connection) {
+
+    private synchronized void removeFromEndpointMap(Endpoint endpoint,
+        PooledConnection connection) {
-        if(endpointConnections.size() == 0) {
+        if (endpointConnections.size() == 0) {
-        PooledConnection pc = (PooledConnection)this.allConnections.removeFirst();
+        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
-          } catch(SocketException se) {
-              logger.info(LocalizedMessage.create(
-                      LocalizedStrings.ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_TO_SERVER_0,
-                      pc.getServer()), se);
-          } catch(Exception e) {
+          } catch (SocketException se) {
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_TO_SERVER_0,
+                pc.getServer()), se);
+          } catch (Exception e) {
-                LocalizedStrings.ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_TO_SERVER_0, 
+                LocalizedStrings.ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_TO_SERVER_0,
-//         logger.info("DEBUG: close incPoolConnections(" + (-count) + ")->" + getPoolStats().getPoolConnections());
+        // logger.info("DEBUG: close incPoolConnections(" + (-count) + ")->" +
+        // getPoolStats().getPoolConnections());
-        PooledConnection pc = (PooledConnection)this.allConnections.removeFirst();
+        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
-     * Returns a pooled connection that can have its underlying cnx
-     * to currentServer replaced by a new connection.
+     * Returns a pooled connection that can have its underlying cnx to currentServer replaced by a
+     * new connection.
+     * 
-        PooledConnection pc = (PooledConnection)it.next();
+        PooledConnection pc = (PooledConnection) it.next();
-          if (!pc.shouldDestroy()
-              && pc.remainingLife(now, lifetimeTimeoutNanos) <= 0) {
+          if (!pc.shouldDestroy() && pc.remainingLife(now, lifetimeTimeoutNanos) <= 0) {
-    
+
-     * Return true if we have a connection to the currentServer whose
-     * lifetime has expired.
+     * Return true if we have a connection to the currentServer whose lifetime has expired.
-        //boolean idlePossible = isIdleExpirePossible();
+        // boolean idlePossible = isIdleExpirePossible();
-          PooledConnection pc = (PooledConnection)it.next();
+          PooledConnection pc = (PooledConnection) it.next();
-          }
-          else if ( currentServer.equals(pc.getServer()) ) {
-            /*if (idlePossible && pc.hasIdleExpired(now, idleTimeoutNanos)) {
-              // this con has already idle expired so ignore it
-              continue;
-              } else*/ {
+          } else if (currentServer.equals(pc.getServer())) {
+            /*
+             * if (idlePossible && pc.hasIdleExpired(now, idleTimeoutNanos)) { // this con has
+             * already idle expired so ignore it continue; } else
+             */ {
+
-     * Returns true if caller should recheck for expired lifetimes
-     * Returns false if a background check was scheduled or no expirations are possible.
+     * Returns true if caller should recheck for expired lifetimes Returns false if a background
+     * check was scheduled or no expirations are possible.
-          PooledConnection pc = (PooledConnection)it.next();
+          PooledConnection pc = (PooledConnection) it.next();
-          }
-          else if ( pc.shouldDestroy() ) {
+          } else if (pc.shouldDestroy()) {
-          }
-          else {
+          } else {
-//                 logger.info("DEBUG: 2 rescheduling lifetime expire to be in: "
-//                             + life + " nanos");
+                // logger.info("DEBUG: 2 rescheduling lifetime expire to be in: "
+                // + life + " nanos");
-              }
-              else {
+              } else {
-            }
-            else {
+            } else {
-     * See if any of the expired connections (that have not idle expired)
-     * are already connected to this sl and have not idle expired.
-     * If so then just update them in-place to simulate a replace.
+     * See if any of the expired connections (that have not idle expired) are already connected to
+     * this sl and have not idle expired. If so then just update them in-place to simulate a
+     * replace.
+     * 
-     * @return true if we were able to extend an existing connection's lifetime
-     *         or if we have no connection's whose lifetime has expired.
-     *         false if we need to create a replacement connection.
+     * @return true if we were able to extend an existing connection's lifetime or if we have no
+     *         connection's whose lifetime has expired. false if we need to create a replacement
+     *         connection.
-          PooledConnection pc = (PooledConnection)it.next();
+          PooledConnection pc = (PooledConnection) it.next();
-//           } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
-//             // this con has already idle expired so ignore it
-          }
-          else if ( pc.shouldDestroy() ) {
+            // } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
+            // // this con has already idle expired so ignore it
+          } else if (pc.shouldDestroy()) {
-          }
-          else if ( sl.equals(pc.getEndpoint().getLocation()) ) {
+          } else if (sl.equals(pc.getEndpoint().getLocation())) {
-//             logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
+            // logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
-          }
-          else {
+          } else {
-//       if (result) {
-//         logger.fine("DEBUG: tryToExtendLifeTime found no one to extend");
-//       }
+      // if (result) {
+      // logger.fine("DEBUG: tryToExtendLifeTime found no one to extend");
+      // }
-        for (Iterator it = this.allConnections.iterator(); it.hasNext() ;) {
-          PooledConnection pc = (PooledConnection)it.next();
+        for (Iterator it = this.allConnections.iterator(); it.hasNext();) {
+          PooledConnection pc = (PooledConnection) it.next();
-//           } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
-//             // this con has already idle expired so ignore it
-          }
-          else if ( pc.shouldDestroy() ) {
+            // } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
+            // // this con has already idle expired so ignore it
+          } else if (pc.shouldDestroy()) {
-          }
-          else if ( sl.equals(pc.getEndpoint().getLocation()) ) {
+          } else if (sl.equals(pc.getEndpoint().getLocation())) {
-//             logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
+            // logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
-    
+
-      if(!this.haveLifetimeExpireConnectionsTask) {
+      if (!this.haveLifetimeExpireConnectionsTask) {
-//           logger.info("DEBUG: scheduling lifetime expire check in: " + delay + " ns");
+          // logger.info("DEBUG: scheduling lifetime expire check in: " + delay + " ns");
-//           logger.info("DEBUG: scheduling lifetimeTask=" + task);
+          // logger.info("DEBUG: scheduling lifetimeTask=" + task);
-        }
-        catch (RejectedExecutionException e) {
-          //ignore, the timer has been cancelled, which means we're shutting down.
+        } catch (RejectedExecutionException e) {
+          // ignore, the timer has been cancelled, which means we're shutting down.
-        if(shuttingDown) {
+        if (shuttingDown) {
-        //find connections which have idle expired
+        // find connections which have idle expired
-        toClose = new ArrayList<PooledConnection>(conCount-minConnections);
-        for (Iterator it = this.allConnections.iterator();
-             it.hasNext() && conCount > minConnections;) {
-          PooledConnection pc = (PooledConnection)it.next();
+        toClose = new ArrayList<PooledConnection>(conCount - minConnections);
+        for (Iterator it = this.allConnections.iterator(); it.hasNext()
+            && conCount > minConnections;) {
+          PooledConnection pc = (PooledConnection) it.next();
-          }
-          else {
+          } else {
-              }
-              else if ( remainingIdle < minRemainingIdle ) {
+              } else if (remainingIdle < minRemainingIdle) {
-            }
-            else /* (remainingIdle < 0) */{
+            } else /* (remainingIdle < 0) */ {
-            backgroundProcessor.schedule(new IdleExpireConnectionsTask(),
-                                         minRemainingIdle,
-                                         TimeUnit.NANOSECONDS);
-          }
-          catch (RejectedExecutionException e) {
-            //ignore, the timer has been cancelled, which means we're shutting down.
+            backgroundProcessor.schedule(new IdleExpireConnectionsTask(), minRemainingIdle,
+                TimeUnit.NANOSECONDS);
+          } catch (RejectedExecutionException e) {
+            // ignore, the timer has been cancelled, which means we're shutting down.
-//         logger.info("DEBUG: checkIdleExpiration incPoolConnections(" + (-expireCount) + ")->" + getPoolStats().getPoolConnections());
+        // logger.info("DEBUG: checkIdleExpiration incPoolConnections(" + (-expireCount) + ")->" +
+        // getPoolStats().getPoolConnections());
-//           getPoolStats().incConCount(-expireCount);
+          // getPoolStats().incConCount(-expireCount);
-//           logger.info("DEBUG: checkIdleExpiration conCount(" + (-expireCount) + ")->" + connectionCount);
+          // logger.info("DEBUG: checkIdleExpiration conCount(" + (-expireCount) + ")->" +
+          // connectionCount);
-          if(connectionCount < minConnections) {
+          if (connectionCount < minConnections) {
-        }
-        finally {
+        } finally {
-      //now destroy all of the connections, outside the sync
-//      if (toClose != null) (cannot be null) 
+      // now destroy all of the connections, outside the sync
+      // if (toClose != null) (cannot be null)
-        for (Iterator itr = toClose.iterator(); itr.hasNext(); ) {
+        for (Iterator itr = toClose.iterator(); itr.hasNext();) {
-          }
-          catch (Exception e) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.ConnectionManagerImpl_ERROR_EXPIRING_CONNECTION_0, 
-                connection));
+          } catch (Exception e) {
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.ConnectionManagerImpl_ERROR_EXPIRING_CONNECTION_0, connection));
-        //      logger.info("DEBUG: Looking for connections whose lifetime has expired");
+      // logger.info("DEBUG: Looking for connections whose lifetime has expired");
-        if(shuttingDown) {
+        if (shuttingDown) {
-        
+
-          if(shuttingDown) {
+          if (shuttingDown) {
-          for (Iterator it = this.allConnections.iterator();
-               it.hasNext() && life <= 0 && (candidate == null);) {
-            PooledConnection pc = (PooledConnection)it.next();
+          for (Iterator it = this.allConnections.iterator(); it.hasNext() && life <= 0
+              && (candidate == null);) {
+            PooledConnection pc = (PooledConnection) it.next();
-//             logger.fine("DEBUG: life remaining in " + pc + " is: " + life);
+            // logger.fine("DEBUG: life remaining in " + pc + " is: " + life);
-               boolean idleTimedOut = idlePossible
-                 ? pc.hasIdleExpired(now, idleTimeoutNanos)
-                 : false;
+              boolean idleTimedOut =
+                  idlePossible ? pc.hasIdleExpired(now, idleTimeoutNanos) : false;
-//               logger.fine("DEBUG: idleTimedOut=" + idleTimedOut
-//                           + " destroyed=" + destroyed);
+              // logger.fine("DEBUG: idleTimedOut=" + idleTimedOut
+              // + " destroyed=" + destroyed);
-            }
-            else if ( firstLife == -1 ) {
+            } else if (firstLife == -1) {
-//           logger.fine("DEBUG: calling createLifetimeReplacementConnection");
+          // logger.fine("DEBUG: calling createLifetimeReplacementConnection");
-//           logger.fine("DEBUG: createLifetimeReplacementConnection returned " + !done);
-        }
-        else {
-//           logger.fine("DEBUG: reschedule " + firstLife);
+          // logger.fine("DEBUG: createLifetimeReplacementConnection returned " + !done);
+        } else {
+          // logger.fine("DEBUG: reschedule " + firstLife);
-//             logger.info("DEBUG: rescheduling lifetime expire to be in: "
-//                         + firstLife + " nanos");
+            // logger.info("DEBUG: rescheduling lifetime expire to be in: "
+            // + firstLife + " nanos");
-    if(t instanceof GemFireSecurityException) {
-      securityLogWriter.info(LocalizedStrings.TWO_ARG_COLON, 
-            new Object[] {message.toLocalizedString(), t}, t);
+    if (t instanceof GemFireSecurityException) {
+      securityLogWriter.info(LocalizedStrings.TWO_ARG_COLON,
+          new Object[] {message.toLocalizedString(), t}, t);
-         new Object[] {message.toLocalizedString(), t}), t);
+          new Object[] {message.toLocalizedString(), t}), t);
-  
+
-    if(t instanceof GemFireSecurityException) {
+    if (t instanceof GemFireSecurityException) {
-    }
-    else { 
+    } else {
-  
+
-    ((PooledConnection)conn).activate();
+    ((PooledConnection) conn).activate();
+
-    ((PooledConnection)conn).passivate(accessed);
+    ((PooledConnection) conn).passivate(accessed);

GEODE-982: refactor off-heap

- removed unused MemoryChunk implementations
- collapsed OffHeapCacheDeserializable into StoredObject
- Added Slab, SlabFactory, SlabImpl, and AddressableMemoryManager.
- collapsed MemoryChunkWithRefCount into StoredObject
- methods that access and modify the data now have Data in their name
- collapsed AddressableStoredObject into StoredObject
- changed product code to use the StoredObject interface
  instead of internal class implementations of it
- renamed DataAsAddress to TinyStoredObject
- renamed ObjectChunk to OffHeapStoredObject
- renamed ObjectChunkWithHeapForm to OffHeapStoredObjectWithHeapForm
- renamed allocateChunk to allocateOffHeapStoredObject
- renamed FakeChunk to SearchMarker
- renamed ObjectChunkSlice to OffHeapStoredObjectSlice
- renamed SyncChunkStack to OffHeapStoredObjectAddressStack
- renamed ChunkValueWrapper to OffHeapValueWrapper

-        null, new AddressableMemoryChunkFactory() {
+        null, new SlabFactory() {
-      public AddressableMemoryChunk create(int size) {
-        return new UnsafeMemoryChunk(size);
+      public Slab create(int size) {
+        return new SlabImpl(size);
-      AddressableMemoryChunk[] slabs, AddressableMemoryChunkFactory memChunkFactory) {
+      Slab[] slabs, SlabFactory slabFactory) {
-        slabs = new UnsafeMemoryChunk[slabCount];
+        slabs = new SlabImpl[slabCount];
-              slabs[i] = memChunkFactory.create((int) maxSlabSize);
+              slabs[i] = slabFactory.create((int) maxSlabSize);
-              slabs[i] = memChunkFactory.create((int) uncreatedMemory);
+              slabs[i] = slabFactory.create((int) uncreatedMemory);
-                slabs[j].release();
+                slabs[j].free();
-      int slabCount, long offHeapMemorySize, long maxSlabSize, AddressableMemoryChunkFactory memChunkFactory) {
+      int slabCount, long offHeapMemorySize, long maxSlabSize, SlabFactory memChunkFactory) {
-  public static SimpleMemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, AddressableMemoryChunk[] slabs) {
+  public static SimpleMemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, Slab[] slabs) {
-  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize, AddressableMemoryChunk[] slabs) {
+  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize, Slab[] slabs) {
-  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final AddressableMemoryChunk[] slabs) {
+  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final Slab[] slabs) {
-  public List<ObjectChunk> getLostChunks() {
-    List<ObjectChunk> liveChunks = this.freeList.getLiveChunks();
-    List<ObjectChunk> regionChunks = getRegionLiveChunks();
-    Set<ObjectChunk> liveChunksSet = new HashSet<>(liveChunks);
-    Set<ObjectChunk> regionChunksSet = new HashSet<>(regionChunks);
+  public List<OffHeapStoredObject> getLostChunks() {
+    List<OffHeapStoredObject> liveChunks = this.freeList.getLiveChunks();
+    List<OffHeapStoredObject> regionChunks = getRegionLiveChunks();
+    Set<OffHeapStoredObject> liveChunksSet = new HashSet<>(liveChunks);
+    Set<OffHeapStoredObject> regionChunksSet = new HashSet<>(regionChunks);
-    return new ArrayList<ObjectChunk>(liveChunksSet);
+    return new ArrayList<OffHeapStoredObject>(liveChunksSet);
-  private List<ObjectChunk> getRegionLiveChunks() {
-    ArrayList<ObjectChunk> result = new ArrayList<ObjectChunk>();
+  private List<OffHeapStoredObject> getRegionLiveChunks() {
+    ArrayList<OffHeapStoredObject> result = new ArrayList<OffHeapStoredObject>();
-  private void getRegionLiveChunks(Region<?,?> r, List<ObjectChunk> result) {
+  private void getRegionLiveChunks(Region<?,?> r, List<OffHeapStoredObject> result) {
-  private void basicGetRegionLiveChunks(LocalRegion r, List<ObjectChunk> result) {
+  private void basicGetRegionLiveChunks(LocalRegion r, List<OffHeapStoredObject> result) {
-        if (value instanceof ObjectChunk) {
-          result.add((ObjectChunk) value);
+        if (value instanceof OffHeapStoredObject) {
+          result.add((OffHeapStoredObject) value);
-  private ObjectChunk allocateChunk(int size) {
-    ObjectChunk result = this.freeList.allocate(size);
+  private OffHeapStoredObject allocateOffHeapStoredObject(int size) {
+    OffHeapStoredObject result = this.freeList.allocate(size);
-      ReferenceCountHelper.refCountChanged(result.getMemoryAddress(), false, 1);
+      ReferenceCountHelper.refCountChanged(result.getAddress(), false, 1);
-  public MemoryChunk allocate(int size) {
+  public StoredObject allocate(int size) {
-    ObjectChunk result = allocateChunk(size);
+    OffHeapStoredObject result = allocateOffHeapStoredObject(size);
+    return allocateAndInitialize(v, isSerialized, isCompressed, null);
+  }
+  @Override
+  public StoredObject allocateAndInitialize(byte[] v, boolean isSerialized, boolean isCompressed, byte[] originalHeapData) {
-      return new DataAsAddress(addr);
+      return new TinyStoredObject(addr);
-    ObjectChunk result = allocateChunk(v.length);
+    OffHeapStoredObject result = allocateOffHeapStoredObject(v.length);
+    if (originalHeapData != null) {
+      result = new OffHeapStoredObjectWithHeapForm(result, originalHeapData);
+    }
-    List<ObjectChunk> liveChunks = this.freeList.getLiveChunks();
-    List<ObjectChunk> regionChunks = getRegionLiveChunks();
+    List<OffHeapStoredObject> liveChunks = this.freeList.getLiveChunks();
+    List<OffHeapStoredObject> regionChunks = getRegionLiveChunks();
-    for (ObjectChunk chunk: liveChunks) {
+    for (OffHeapStoredObject chunk: liveChunks) {
-            return Long.valueOf(o1.getMemoryAddress()).compareTo(o2.getMemoryAddress());
+            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());

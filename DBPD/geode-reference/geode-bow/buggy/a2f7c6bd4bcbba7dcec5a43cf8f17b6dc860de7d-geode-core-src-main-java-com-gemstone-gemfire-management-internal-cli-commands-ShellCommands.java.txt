GEODE-17: when connecting to a secure manager, prompt for username and password

* refactor the connect command for better readability and retry handling
* throw AuthenticationFailedException for consistency

+
-import java.net.ConnectException;
-import com.gemstone.gemfire.management.internal.cli.shell.JMXConnectionException;
-import com.gemstone.gemfire.management.internal.cli.util.CauseFinder;
+import com.gemstone.gemfire.security.AuthenticationFailedException;
- *
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_JMX, CliStrings.TOPIC_GEMFIRE_MANAGER})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_JMX, CliStrings.TOPIC_GEMFIRE_MANAGER })
-               unspecifiedDefaultValue = ConnectionEndpointConverter.DEFAULT_LOCATOR_ENDPOINTS,
-               optionContext = ConnectionEndpoint.LOCATOR_OPTION_CONTEXT,
-               help = CliStrings.CONNECT__LOCATOR__HELP) ConnectionEndpoint locatorTcpHostPort,
+      unspecifiedDefaultValue = ConnectionEndpointConverter.DEFAULT_LOCATOR_ENDPOINTS,
+      optionContext = ConnectionEndpoint.LOCATOR_OPTION_CONTEXT,
+      help = CliStrings.CONNECT__LOCATOR__HELP) ConnectionEndpoint locatorTcpHostPort,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               optionContext = ConnectionEndpoint.JMXMANAGER_OPTION_CONTEXT,
-               help = CliStrings.CONNECT__JMX_MANAGER__HELP) ConnectionEndpoint memberRmiHostPort,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      optionContext = ConnectionEndpoint.JMXMANAGER_OPTION_CONTEXT,
+      help = CliStrings.CONNECT__JMX_MANAGER__HELP) ConnectionEndpoint memberRmiHostPort,
-               mandatory = false,
-               specifiedDefaultValue = "true",
-               unspecifiedDefaultValue = "false",
-               help = CliStrings.CONNECT__USE_HTTP__HELP) boolean useHttp,
+      mandatory = false,
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = CliStrings.CONNECT__USE_HTTP__HELP) boolean useHttp,
-               mandatory = false,
-               unspecifiedDefaultValue = CliStrings.CONNECT__DEFAULT_BASE_URL,
-               help = CliStrings.CONNECT__URL__HELP) String url,
+      mandatory = false,
+      unspecifiedDefaultValue = CliStrings.CONNECT__DEFAULT_BASE_URL,
+      help = CliStrings.CONNECT__URL__HELP) String url,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__USERNAME__HELP) String userName,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__USERNAME__HELP) String userName,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__PASSWORD__HELP) String password,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__PASSWORD__HELP) String password,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__KEY_STORE__HELP) String keystore,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__KEY_STORE__HELP) String keystore,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__KEY_STORE_PASSWORD__HELP) String keystorePassword,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__KEY_STORE_PASSWORD__HELP) String keystorePassword,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__TRUST_STORE__HELP) String truststore,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__TRUST_STORE__HELP) String truststore,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__TRUST_STORE_PASSWORD__HELP) String truststorePassword,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__TRUST_STORE_PASSWORD__HELP) String truststorePassword,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__SSL_CIPHERS__HELP) String sslCiphers,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__SSL_CIPHERS__HELP) String sslCiphers,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__SSL_PROTOCOLS__HELP) String sslProtocols,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__SSL_PROTOCOLS__HELP) String sslProtocols,
-               optionContext = ConverterHint.FILE_PATHSTRING,
-               unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-               help = CliStrings.CONNECT__SECURITY_PROPERTIES__HELP) final String gfSecurityPropertiesPath,
+      optionContext = ConverterHint.FILE_PATHSTRING,
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      help = CliStrings.CONNECT__SECURITY_PROPERTIES__HELP) final String gfSecurityPropertiesPath,
-               specifiedDefaultValue = "true",
-               unspecifiedDefaultValue = "false",
-               help = CliStrings.CONNECT__USE_SSL__HELP) final boolean useSsl)
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = CliStrings.CONNECT__USE_SSL__HELP) final boolean useSsl)
-    
-    String passwordToUse           = decrypt(password);
-    String keystoreToUse           = keystore;
-    String keystorePasswordToUse   = keystorePassword;
-    String truststoreToUse         = truststore;
+    String passwordToUse = decrypt(password);
+    String keystoreToUse = keystore;
+    String keystorePasswordToUse = keystorePassword;
+    String truststoreToUse = truststore;
-    String sslCiphersToUse         = sslCiphers;
-    String sslProtocolsToUse       = sslProtocols;
+    String sslCiphersToUse = sslCiphers;
+    String sslProtocolsToUse = sslProtocols;
-    // TODO shouldn't the condition be (getGfsh() != null && getGfsh().isConnectedAndReady())?
-    // otherwise, we have potential NullPointerException on the line with getGfsh().getOperationInvoker()
-    //if (getGfsh() == null || getGfsh().isConnectedAndReady()) {
-    if (getGfsh() != null && getGfsh().isConnectedAndReady()) {
-      try {
-        result = ResultBuilder.createInfoResult("Already connected to: " + getGfsh().getOperationInvoker().toString());
-      } catch (Exception e) {
-        result = ResultBuilder.buildResult(ResultBuilder.createErrorResultData().setErrorCode(
-          ResultBuilder.ERRORCODE_DEFAULT).addLine(e.getMessage()));
-      }
-    } else if (useHttp) {      
-      Gfsh gemfireShell = getGfsh();
-      try{
+    Gfsh gfsh = getGfsh();
+    if (gfsh != null && gfsh.isConnectedAndReady()) {
+      return ResultBuilder.createInfoResult("Already connected to: " + getGfsh().getOperationInvoker().toString());
+    }
-        Map<String,String> securityProperties = new HashMap<String, String>();
-
-        if (userName != null && userName.length() > 0) {
-          if (passwordToUse == null || passwordToUse.length() == 0) {
-            passwordToUse = gemfireShell.readWithMask("password: ", '*');
-          }
-          if (passwordToUse == null || passwordToUse.length() == 0) {
-            throw new IllegalArgumentException(CliStrings.CONNECT__MSG__JMX_PASSWORD_MUST_BE_SPECIFIED);
-          }
-          securityProperties.put("security-username", userName);
-          securityProperties.put("security-password", passwordToUse);
+    Map<String, String> sslConfigProps = null;
+    try {
+      if (userName != null && userName.length() > 0) {
+        if (passwordToUse == null || passwordToUse.length() == 0) {
+          passwordToUse = this.readPassword(gfsh, "password: ");
-
-        final Map<String, String> sslConfigProps = this.readSSLConfiguration(useSsl, keystoreToUse,keystorePasswordToUse,
-            truststoreToUse, truststorePasswordToUse, sslCiphersToUse, sslProtocolsToUse, gfSecurityPropertiesPath);
-     
-        if (useSsl) {
-          configureHttpsURLConnection(sslConfigProps);
-          if (url.startsWith("http:")) {
-            url = url.replace("http:", "https:");
-          }
-        }
-
-        Iterator<String> it = sslConfigProps.keySet().iterator();
-        while(it.hasNext()){
-          String secKey = it.next();
-          securityProperties.put(secKey, sslConfigProps.get(secKey));
-        }
-
-        // This is so that SSL termination results in https URLs being returned
-        String query = (url.startsWith("https")) ? "?scheme=https" : "";
-
-        LogWrapper.getInstance().warning(String.format("Sending HTTP request for Link Index at (%1$s)...", url.concat("/index").concat(query)));
-
-        LinkIndex linkIndex = new SimpleHttpRequester(gemfireShell, CONNECT_LOCATOR_TIMEOUT_MS, securityProperties).exchange(url.concat("/index").concat(query), LinkIndex.class);
-
-        LogWrapper.getInstance().warning(String.format("Received Link Index (%1$s)", linkIndex.toString()));
-
-        HttpOperationInvoker operationInvoker = new RestHttpOperationInvoker(linkIndex, gemfireShell, url, securityProperties);
-
-        Initializer.init(operationInvoker);
-        gemfireShell.setOperationInvoker(operationInvoker);
-
-        LogWrapper.getInstance().info(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, operationInvoker.toString()));
-
-        Gfsh.redirectInternalJavaLoggers();
-        result = ResultBuilder.createInfoResult(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, operationInvoker.toString()));
-        
-      } catch (IOException ioe) {
-        String errorMessage = ioe.getMessage();
-        result = ResultBuilder.createConnectionErrorResult(errorMessage);
-        if (gemfireShell.getDebug()) {ioe.printStackTrace();}
-      } catch (Exception e) {
-        String errorMessage = e.getMessage();
-        result = ResultBuilder.createConnectionErrorResult(errorMessage);
-        if (gemfireShell.getDebug()) {e.printStackTrace();}
-      }
-    } else {
-
-      boolean isConnectingViaLocator = false;
-
-      InfoResultData infoResultData = ResultBuilder.createInfoResultData();
-      ConnectionEndpoint hostPortToConnect = null;
-      
-      try {
-        Gfsh gfshInstance = getGfsh();
-
-        // JMX Authentication Config
-        if (userName != null && userName.length() > 0) {
-          if (passwordToUse == null || passwordToUse.length() == 0) {
-            passwordToUse = gfshInstance.readWithMask("password: ", '*');
-          }
-          if (passwordToUse == null || passwordToUse.length() == 0) {
-              throw new IllegalArgumentException(CliStrings.CONNECT__MSG__JMX_PASSWORD_MUST_BE_SPECIFIED);
-          }
-        }
-
-        final Map<String, String> sslConfigProps = this.readSSLConfiguration(useSsl, keystoreToUse,keystorePasswordToUse, 
-            truststoreToUse, truststorePasswordToUse, sslCiphersToUse, sslProtocolsToUse, gfSecurityPropertiesPath);
-
-        if (memberRmiHostPort != null) {
-          hostPortToConnect = memberRmiHostPort;
-          Gfsh.println(CliStrings.format(CliStrings.CONNECT__MSG__CONNECTING_TO_MANAGER_AT_0, new Object[] {memberRmiHostPort.toString(false)}));
-        } else {
-          isConnectingViaLocator = true;
-          hostPortToConnect = locatorTcpHostPort;
-          Gfsh.println(CliStrings.format(CliStrings.CONNECT__MSG__CONNECTING_TO_LOCATOR_AT_0, new Object[] {locatorTcpHostPort.toString(false)}));
-
-          // Props required to configure a SocketCreator with SSL.
-          // Used for gfsh->locator connection & not needed for gfsh->manager connection
-          if (useSsl || !sslConfigProps.isEmpty()) {
-            //Fix for 51266 : Added an check for cluster-ssl-enabled proeprty
-            if(!sslConfigProps.containsKey(DistributionConfig.CLUSTER_SSL_ENABLED_NAME))
-              sslConfigProps.put(DistributionConfig.SSL_ENABLED_NAME, String.valueOf(true));
-            sslConfigProps.put(DistributionConfig.MCAST_PORT_NAME, String.valueOf(0));
-            sslConfigProps.put(DistributionConfig.LOCATORS_NAME, "");
-
-            String sslInfoLogMsg = "Connecting to Locator via SSL.";
-            if (useSsl) {
-              sslInfoLogMsg = CliStrings.CONNECT__USE_SSL + " is set to true. " + sslInfoLogMsg;
-            }
-            gfshInstance.logToFile(sslInfoLogMsg, null);
-          }
-
-          ConnectToLocatorResult connectToLocatorResult = connectToLocator(locatorTcpHostPort.getHost(), locatorTcpHostPort.getPort(), CONNECT_LOCATOR_TIMEOUT_MS, sslConfigProps);
-          memberRmiHostPort = connectToLocatorResult.getMemberEndpoint();
-          hostPortToConnect = memberRmiHostPort;
-          Gfsh.printlnErr(connectToLocatorResult.getResultMessage());
-
-          // when locator is configured to use SSL (ssl-enabled=true) but manager is not (jmx-manager-ssl=false)
-          if ((useSsl || !sslConfigProps.isEmpty()) && !connectToLocatorResult.isJmxManagerSslEnabled()) {
-            gfshInstance.logInfo(CliStrings.CONNECT__USE_SSL + " is set to true. But JMX Manager doesn't support SSL, connecting without SSL.", null);
-            sslConfigProps.clear();
-          }
-        }
-
-        if (!sslConfigProps.isEmpty()) {
-          gfshInstance.logToFile("Connecting to manager via SSL.", null);
-        }
-
-        JmxOperationInvoker operationInvoker = new JmxOperationInvoker(memberRmiHostPort.getHost(), memberRmiHostPort.getPort(), userName, passwordToUse, sslConfigProps, gfSecurityPropertiesPath);
-        gfshInstance.setOperationInvoker(operationInvoker);
-        infoResultData.addLine(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, memberRmiHostPort.toString(false)));
-        LogWrapper.getInstance().info(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, memberRmiHostPort.toString(false)));
-        result = ResultBuilder.buildResult(infoResultData);
-      } catch (Exception e) {
-        // TODO - Abhishek: Refactor to use catch blocks for instanceof checks
-        Gfsh gfshInstance = Gfsh.getCurrentInstance();
-        String errorMessage = e.getMessage();
-        boolean logAsFine = false;
-        if (CauseFinder.indexOfCause(e, javax.naming.ServiceUnavailableException.class, false) != -1) {
-          errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__SERVICE_UNAVAILABLE_ERROR, hostPortToConnect.toString(false));
-        } else if (e instanceof JMXConnectionException) {
-          JMXConnectionException jce = (JMXConnectionException)e;
-          if (jce.getExceptionType() == JMXConnectionException.MANAGER_NOT_FOUND_EXCEPTION) {
-            errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__SERVICE_UNAVAILABLE_ERROR, hostPortToConnect.toString(false));
-          }
-        } else if ((e instanceof ConnectException) && isConnectingViaLocator) {
-          errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_CONNECT_TO_LOCATOR_0, hostPortToConnect.toString(false));
-        } else if ( (e instanceof IllegalStateException) && isConnectingViaLocator) {
-          Throwable causeByType = CauseFinder.causeByType(e, ClassCastException.class, false);
-          if (causeByType != null) {
-            errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_CONNECT_TO_LOCATOR_0_POSSIBLY_SSL_CONFIG_ERROR,
-                                             new Object[] { hostPortToConnect.toString(false)});
-            if (gfshInstance.isLoggingEnabled()) {
-              errorMessage += " "+ getGfshLogsCheckMessage(gfshInstance.getLogFilePath());
-            }
-          } else if (errorMessage == null) {
-            errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_CONNECT_TO_LOCATOR_0, locatorTcpHostPort.toString(false));
-            if (gfshInstance.isLoggingEnabled()) {
-              errorMessage += " "+ getGfshLogsCheckMessage(gfshInstance.getLogFilePath());
-            }
-          }
-        } else if (e instanceof IOException) {
-          Throwable causeByType = CauseFinder.causeByType(e, java.rmi.ConnectIOException.class, false);
-          if (causeByType != null) {
-            // TODO - Abhishek : Is there a better way to know about a specific cause?
-            if (String.valueOf(causeByType.getMessage()).contains("non-JRMP server")) {
-              errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_CONNECT_TO_MANAGER_0_POSSIBLY_SSL_CONFIG_ERROR,
-                                               new Object[] { memberRmiHostPort.toString(false)});
-              logAsFine = true;
-            } else {
-              errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__ERROR, new Object[] {memberRmiHostPort.toString(false), ""});
-            }
-            if (gfshInstance.isLoggingEnabled()) {
-              errorMessage += " "+ getGfshLogsCheckMessage(gfshInstance.getLogFilePath());
-            }
-          }
-        } else if (e instanceof SecurityException) {
-          // the default exception message is clear enough
-          String msgPart = StringUtils.isBlank(userName) && StringUtils.isBlank(passwordToUse) ? "" : "appropriate ";
-          errorMessage += ". Please specify "+msgPart+"values for --"+CliStrings.CONNECT__USERNAME+" and --"+CliStrings.CONNECT__PASSWORD;
-        } else{
-          errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__ERROR, hostPortToConnect.toString(false), errorMessage);
-        }
-        result = ResultBuilder.createConnectionErrorResult(errorMessage);
-        if (logAsFine) {
-          LogWrapper.getInstance().fine(e.getMessage(), e);
-        } else {
-          LogWrapper.getInstance().severe(e.getMessage(), e);
+        if (passwordToUse == null || passwordToUse.length() == 0) {
+          return ResultBuilder.createConnectionErrorResult(CliStrings.CONNECT__MSG__JMX_PASSWORD_MUST_BE_SPECIFIED);
-      Gfsh.redirectInternalJavaLoggers();
+      sslConfigProps = this.readSSLConfiguration(useSsl, keystoreToUse, keystorePasswordToUse,
+        truststoreToUse, truststorePasswordToUse, sslCiphersToUse, sslProtocolsToUse, gfSecurityPropertiesPath);
+    }
+    catch (IOException e) {
+      return handleExcpetion(e, null);
+    }
+
+    if (useHttp) {
+      result = httpConnect(sslConfigProps, useSsl, url, userName, passwordToUse);
+    }
+    else {
+      result = jmxConnect(sslConfigProps, memberRmiHostPort, locatorTcpHostPort, useSsl, userName, passwordToUse, gfSecurityPropertiesPath, false);
+
+  private Result httpConnect(Map<String, String> sslConfigProps, boolean useSsl, String url, String userName, String passwordToUse)
+  {
+    Gfsh gfsh = getGfsh();
+    try {
+      Map<String, String> securityProperties = new HashMap<String, String>();
+
+      // at this point, if userName is not empty, password should not be empty either
+      if (userName != null && userName.length() > 0) {
+        securityProperties.put("security-username", userName);
+        securityProperties.put("security-password", passwordToUse);
+      }
+
+      if (useSsl) {
+        configureHttpsURLConnection(sslConfigProps);
+        if (url.startsWith("http:")) {
+          url = url.replace("http:", "https:");
+        }
+      }
+
+      Iterator<String> it = sslConfigProps.keySet().iterator();
+      while (it.hasNext()) {
+        String secKey = it.next();
+        securityProperties.put(secKey, sslConfigProps.get(secKey));
+      }
+
+      // This is so that SSL termination results in https URLs being returned
+      String query = (url.startsWith("https")) ? "?scheme=https" : "";
+
+      LogWrapper.getInstance().warning(String.format("Sending HTTP request for Link Index at (%1$s)...", url.concat("/index").concat(query)));
+
+      LinkIndex linkIndex = new SimpleHttpRequester(gfsh, CONNECT_LOCATOR_TIMEOUT_MS, securityProperties).exchange(url.concat("/index").concat(query),
+        LinkIndex.class);
+
+      LogWrapper.getInstance().warning(String.format("Received Link Index (%1$s)", linkIndex.toString()));
+
+      HttpOperationInvoker operationInvoker = new RestHttpOperationInvoker(linkIndex, gfsh, url, securityProperties);
+
+      Initializer.init(operationInvoker);
+      gfsh.setOperationInvoker(operationInvoker);
+
+      LogWrapper.getInstance().info(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, operationInvoker.toString()));
+      return ResultBuilder.createInfoResult(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, operationInvoker.toString()));
+
+    }
+    catch (Exception e) {
+      // all other exceptions, just logs it and returns a connection error
+      if (!(e instanceof SecurityException) && !(e instanceof AuthenticationFailedException)) {
+        return handleExcpetion(e, null);
+      }
+
+      // if it's security exception, and we already sent in username and password, still retuns the connection error
+      if (userName != null) {
+        return handleExcpetion(e, null);
+      }
+
+      // otherwise, prompt for username and password and retry the conenction
+      try {
+        userName = this.readText(gfsh, "username: ");
+        passwordToUse = this.readPassword(gfsh, "password: ");
+        return httpConnect(sslConfigProps, useSsl, url, userName, passwordToUse);
+      }
+      catch (IOException ioe) {
+        return handleExcpetion(ioe, null);
+      }
+    }
+    finally {
+      Gfsh.redirectInternalJavaLoggers();
+    }
+  }
+
+  private Result jmxConnect(Map<String, String> sslConfigProps,
+                            ConnectionEndpoint memberRmiHostPort,
+                            ConnectionEndpoint locatorTcpHostPort,
+                            boolean useSsl,
+                            String userName,
+                            String passwordToUse,
+                            String gfSecurityPropertiesPath,
+                            boolean retry)
+  {
+    ConnectionEndpoint hostPortToConnect = null;
+    Gfsh gfsh = getGfsh();
+
+    try {
+
+      // trying to find the hostPortToConnect, if rmi host port exists, use that, otherwise, use locator to find the rmi host port
+      if (memberRmiHostPort != null) {
+        hostPortToConnect = memberRmiHostPort;
+      }
+      else {
+        // Props required to configure a SocketCreator with SSL.
+        // Used for gfsh->locator connection & not needed for gfsh->manager connection
+        if (useSsl || !sslConfigProps.isEmpty()) {
+          //Fix for 51266 : Added an check for cluster-ssl-enabled proeprty
+          if (!sslConfigProps.containsKey(DistributionConfig.CLUSTER_SSL_ENABLED_NAME)) {
+            sslConfigProps.put(DistributionConfig.SSL_ENABLED_NAME, String.valueOf(true));
+          }
+          sslConfigProps.put(DistributionConfig.MCAST_PORT_NAME, String.valueOf(0));
+          sslConfigProps.put(DistributionConfig.LOCATORS_NAME, "");
+
+          String sslInfoLogMsg = "Connecting to Locator via SSL.";
+          if (useSsl) {
+            sslInfoLogMsg = CliStrings.CONNECT__USE_SSL + " is set to true. " + sslInfoLogMsg;
+          }
+          gfsh.logToFile(sslInfoLogMsg, null);
+        }
+
+        Gfsh.println(CliStrings.format(CliStrings.CONNECT__MSG__CONNECTING_TO_LOCATOR_AT_0, new Object[] { locatorTcpHostPort.toString(false) }));
+        ConnectToLocatorResult connectToLocatorResult = connectToLocator(locatorTcpHostPort.getHost(), locatorTcpHostPort.getPort(), CONNECT_LOCATOR_TIMEOUT_MS,
+          sslConfigProps);
+        hostPortToConnect = connectToLocatorResult.getMemberEndpoint();
+
+        // when locator is configured to use SSL (ssl-enabled=true) but manager is not (jmx-manager-ssl=false)
+        if ((useSsl || !sslConfigProps.isEmpty()) && !connectToLocatorResult.isJmxManagerSslEnabled()) {
+          gfsh.logInfo(CliStrings.CONNECT__USE_SSL + " is set to true. But JMX Manager doesn't support SSL, connecting without SSL.", null);
+          sslConfigProps.clear();
+        }
+      }
+
+      if (!sslConfigProps.isEmpty()) {
+        gfsh.logToFile("Connecting to manager via SSL.", null);
+      }
+
+      // print out the connecting endpoint
+      if (!retry) {
+        Gfsh.println(CliStrings.format(CliStrings.CONNECT__MSG__CONNECTING_TO_MANAGER_AT_0, new Object[] { hostPortToConnect.toString(false) }));
+      }
+
+      InfoResultData infoResultData = ResultBuilder.createInfoResultData();
+      JmxOperationInvoker operationInvoker = new JmxOperationInvoker(hostPortToConnect.getHost(), hostPortToConnect.getPort(), userName, passwordToUse,
+        sslConfigProps, gfSecurityPropertiesPath);
+
+      gfsh.setOperationInvoker(operationInvoker);
+      infoResultData.addLine(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, hostPortToConnect.toString(false)));
+      LogWrapper.getInstance().info(CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, hostPortToConnect.toString(false)));
+      return ResultBuilder.buildResult(infoResultData);
+    }
+    catch (Exception e) {
+      // all other exceptions, just logs it and returns a connection error
+      if (!(e instanceof SecurityException) && !(e instanceof AuthenticationFailedException)) {
+        return handleExcpetion(e, hostPortToConnect);
+      }
+
+      // if it's security exception, and we already sent in username and password, still retuns the connection error
+      if (userName != null) {
+        return handleExcpetion(e, hostPortToConnect);
+      }
+
+      // otherwise, prompt for username and password and retry the conenction
+      try {
+        userName = this.readText(gfsh, "username: ");
+        passwordToUse = this.readPassword(gfsh, "password: ");
+        return jmxConnect(sslConfigProps, hostPortToConnect, null, useSsl, userName, passwordToUse, gfSecurityPropertiesPath, true);
+      }
+      catch (IOException ioe) {
+        return handleExcpetion(ioe, hostPortToConnect);
+      }
+    }
+    finally {
+      Gfsh.redirectInternalJavaLoggers();
+    }
+  }
+
+  private Result handleExcpetion(Exception e, ConnectionEndpoint hostPortToConnect) {
+    String errorMessage = e.getMessage();
+    if (hostPortToConnect != null) {
+      errorMessage = CliStrings.format(CliStrings.CONNECT__MSG__ERROR, hostPortToConnect.toString(false), e.getMessage());
+    }
+    LogWrapper.getInstance().severe(errorMessage, e);
+    return ResultBuilder.createConnectionErrorResult(errorMessage);
+  }
+
+
-private void configureHttpsURLConnection(Map<String, String> sslConfigProps) throws Exception {
+  private void configureHttpsURLConnection(Map<String, String> sslConfigProps) throws Exception {
-    try{
-      
+    try {
+
-          trustManagerFactory != null ? trustManagerFactory.getTrustManagers() : null, new java.security.SecureRandom());
-   
+        trustManagerFactory != null ? trustManagerFactory.getTrustManagers() : null, new java.security.SecureRandom());
+
-    }finally{
-      if(keyStoreStream != null){
+    }
+    finally {
+      if (keyStoreStream != null) {
-      if(trustStoreStream != null ){
+      if (trustStoreStream != null) {
-      
+
-   
-    
+
+
-  
+
-      String truststoreToUse, String truststorePasswordToUse, String sslCiphersToUse, String sslProtocolsToUse,
-      String gfSecurityPropertiesPath) throws IOException {
+                                                   String truststoreToUse, String truststorePasswordToUse, String sslCiphersToUse, String sslProtocolsToUse,
+                                                   String gfSecurityPropertiesPath) throws IOException
+  {
-    Gfsh gfshInstance = getGfsh();    
+    Gfsh gfshInstance = getGfsh();
-    
+
-        } else {
+        }
+        else {
-      } else if (useSsl && gfSecurityPropertiesPath == null) {
+      }
+      else if (useSsl && gfSecurityPropertiesPath == null) {
-                + CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath()), null);
+          + CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath()), null);
-        }else{//For cases where password is already part of command option
+        }
+        else {//For cases where password is already part of command option
-        }else{//For cases where password is already part of command option
+        }
+        else {//For cases where password is already part of command option
-      if (sslCiphersToUse != null && sslCiphersToUse.length() > 0) {            
+      if (sslCiphersToUse != null && sslCiphersToUse.length() > 0) {
-    } while(useSsl && sslConfigProps.isEmpty() && (0 == numTimesPrompted++) && !gfshInstance.isQuietMode());    
+    }
+    while (useSsl && sslConfigProps.isEmpty() && (0 == numTimesPrompted++) && !gfshInstance.isQuietMode());
-    } else {
+    }
+    else {
-    } else {
+    }
+    else {
-  /* package-private */ static Map<String, String> loadPropertiesFromURL(URL gfSecurityPropertiesUrl) {
+  /* package-private */
+  static Map<String, String> loadPropertiesFromURL(URL gfSecurityPropertiesUrl) {
-            String key = (String)entry.getKey();
+            String key = (String) entry.getKey();
-              propsMap.put(key, (String)entry.getValue());
-            } else if (!jmxSpecificProps.contains(key)) {// Prefer properties ending with "-jmx" over default SSL props.
-              propsMap.put(key, (String)entry.getValue());
+              propsMap.put(key, (String) entry.getValue());
+            }
+            else if (!jmxSpecificProps.contains(key)) {// Prefer properties ending with "-jmx" over default SSL props.
+              propsMap.put(key, (String) entry.getValue());
-      } catch (IOException io) {
+      }
+      catch (IOException io) {
-            CliStrings.CONNECT__MSG__COULD_NOT_READ_CONFIG_FROM_0,
-                CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath())), io);
-      } finally {
+          CliStrings.CONNECT__MSG__COULD_NOT_READ_CONFIG_FROM_0,
+          CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath())), io);
+      }
+      finally {
-      } catch (MalformedURLException ignore) {
+      }
+      catch (MalformedURLException ignore) {
-      } catch (MalformedURLException ignore) {
+      }
+      catch (MalformedURLException ignore) {
-    
+
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_JMX, CliStrings.TOPIC_GEMFIRE_MANAGER})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_JMX, CliStrings.TOPIC_GEMFIRE_MANAGER })
-    } else {
+    }
+    else {
-        } else {
+        }
+        else {
-      } catch (Exception e) {
+      }
+      catch (Exception e) {
-  @CliCommand(value = {CliStrings.DESCRIBE_CONNECTION}, help = CliStrings.DESCRIBE_CONNECTION__HELP)
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_JMX})
+  @CliCommand(value = { CliStrings.DESCRIBE_CONNECTION }, help = CliStrings.DESCRIBE_CONNECTION__HELP)
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_JMX })
-//        tabularResultData.accumulate("Monitored GemFire DS", operationInvoker.toString());
+        //        tabularResultData.accumulate("Monitored GemFire DS", operationInvoker.toString());
-      } else {
+      }
+      else {
-    } catch (Exception e) {
+    }
+    catch (Exception e) {
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-      @CliOption(key = {CliStrings.ECHO__STR, ""},
-                 unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-                 specifiedDefaultValue = "",
-                 mandatory = true,
-                 help = CliStrings.ECHO__STR__HELP) String stringToEcho) {
+    @CliOption(key = { CliStrings.ECHO__STR, "" },
+      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      specifiedDefaultValue = "",
+      mandatory = true,
+      help = CliStrings.ECHO__STR__HELP) String stringToEcho)
+  {
-    if(stringToEcho.equals("$*")){
+    if (stringToEcho.equals("$*")) {
-      Set< Entry<String, String> > setEnvMap = envMap.entrySet();
-      TabularResultData  resultData = buildResultForEcho(setEnvMap);
+      Set<Entry<String, String>> setEnvMap = envMap.entrySet();
+      TabularResultData resultData = buildResultForEcho(setEnvMap);
-    } else {
+    }
+    else {
-  TabularResultData buildResultForEcho(Set< Entry<String, String> > propertyMap){
-    TabularResultData resultData = ResultBuilder.createTabularResultData();
-    Iterator <Entry<String, String>> it = propertyMap.iterator();
-    while(it.hasNext()){
+  TabularResultData buildResultForEcho(Set<Entry<String, String>> propertyMap) {
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
+    Iterator<Entry<String, String>> it = propertyMap.iterator();
+
+    while (it.hasNext()) {
-
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-      @CliOption(key = CliStrings.SET_VARIABLE__VAR,
-                 mandatory=true,
-                 help = CliStrings.SET_VARIABLE__VAR__HELP)
-                 String var,
-      @CliOption(key = CliStrings.SET_VARIABLE__VALUE,
-                 mandatory=true,
-                 help = CliStrings.SET_VARIABLE__VALUE__HELP)
-                 String value) {
+    @CliOption(key = CliStrings.SET_VARIABLE__VAR,
+      mandatory = true,
+      help = CliStrings.SET_VARIABLE__VAR__HELP)
+      String var,
+    @CliOption(key = CliStrings.SET_VARIABLE__VALUE,
+      mandatory = true,
+      help = CliStrings.SET_VARIABLE__VALUE__HELP)
+      String value)
+  {
-      result = ResultBuilder.createInfoResult("Value for variable "+var+" is now: "+value+".");
-    } catch (IllegalArgumentException e) {
+      result = ResultBuilder.createInfoResult("Value for variable " + var + " is now: " + value + ".");
+    }
+    catch (IllegalArgumentException e) {
-//Enable when "use region" command is required. See #46110
-//  @CliCommand(value = { CliStrings.USE_REGION }, help = CliStrings.USE_REGION__HELP)
-//  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_REGION})
-//  public Result useRegion(
-//      @CliArgument(name = CliStrings.USE_REGION__REGION,
-//                   unspecifiedDefaultValue = "/",
-//                   argumentContext = CliStrings.PARAM_CONTEXT_REGIONPATH,
-//                   help = CliStrings.USE_REGION__REGION__HELP)
-//                    String toRegion) {
-//    Gfsh gfsh = Gfsh.getCurrentInstance();
-//
-//    gfsh.setPromptPath(toRegion);
-//    return ResultBuilder.createInfoResult("");
-//  }
+  //Enable when "use region" command is required. See #46110
+  //  @CliCommand(value = { CliStrings.USE_REGION }, help = CliStrings.USE_REGION__HELP)
+  //  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GFSH, CliStrings.TOPIC_GEMFIRE_REGION})
+  //  public Result useRegion(
+  //      @CliArgument(name = CliStrings.USE_REGION__REGION,
+  //                   unspecifiedDefaultValue = "/",
+  //                   argumentContext = CliStrings.PARAM_CONTEXT_REGIONPATH,
+  //                   help = CliStrings.USE_REGION__REGION__HELP)
+  //                    String toRegion) {
+  //    Gfsh gfsh = Gfsh.getCurrentInstance();
+  //
+  //    gfsh.setPromptPath(toRegion);
+  //    return ResultBuilder.createInfoResult("");
+  //  }
-      @CliOption(key = CliStrings.DEBUG__STATE,
-                   unspecifiedDefaultValue = "OFF",
-                   mandatory = true,
-                   optionContext = "debug",
-                   help = CliStrings.DEBUG__STATE__HELP)
-                   String state) {
+    @CliOption(key = CliStrings.DEBUG__STATE,
+      unspecifiedDefaultValue = "OFF",
+      mandatory = true,
+      optionContext = "debug",
+      help = CliStrings.DEBUG__STATE__HELP)
+      String state)
+  {
-      } else if(state.equalsIgnoreCase("OFF")){
+      }
+      else if (state.equalsIgnoreCase("OFF")) {
-      }else{
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.DEBUG__MSG_0_INVALID_STATE_VALUE,state)) ;
+      }
+      else {
+        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.DEBUG__MSG_0_INVALID_STATE_VALUE, state));
-    } else {
+    }
+    else {
-          .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT).addLine(
-              CliStrings.ECHO__MSG__NO_GFSH_INSTANCE);
+        .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT).addLine(
+          CliStrings.ECHO__MSG__NO_GFSH_INSTANCE);
-    return ResultBuilder.createInfoResult(CliStrings.DEBUG__MSG_DEBUG_STATE_IS + state );
+    return ResultBuilder.createInfoResult(CliStrings.DEBUG__MSG_DEBUG_STATE_IS + state);
-      @CliOption(key = { CliStrings.HISTORY__FILE }, unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE, help = CliStrings.HISTORY__FILE__HELP)
+    @CliOption(key = { CliStrings.HISTORY__FILE }, unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE, help = CliStrings.HISTORY__FILE__HELP)
-      @CliOption(key = { CliStrings.HISTORY__CLEAR }, specifiedDefaultValue = "true",
-                      unspecifiedDefaultValue = "false", help = CliStrings.HISTORY__CLEAR__HELP) Boolean clearHistory) {
+    @CliOption(key = { CliStrings.HISTORY__CLEAR }, specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false", help = CliStrings.HISTORY__CLEAR__HELP) Boolean clearHistory)
+  {
-    if (clearHistory ) {
+    if (clearHistory) {
-    }else {
+    }
+    else {
-          .length() > 0) ? false : true;
+        .length() > 0) ? false : true;
-                lineNumber));
+              lineNumber));
-                .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
-                .addLine(CliStrings.HISTORY__MSG__FILE_DOES_NOT_EXISTS);
+              .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
+              .addLine(CliStrings.HISTORY__MSG__FILE_DOES_NOT_EXISTS);
-                .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
-                .addLine(CliStrings.HISTORY__MSG__FILE_SHOULD_NOT_BE_DIRECTORY);
+              .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
+              .addLine(CliStrings.HISTORY__MSG__FILE_SHOULD_NOT_BE_DIRECTORY);
-                .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
-                .addLine(CliStrings.HISTORY__MSG__FILE_CANNOT_BE_WRITTEN);
+              .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
+              .addLine(CliStrings.HISTORY__MSG__FILE_CANNOT_BE_WRITTEN);
-      } catch (IOException ex) {
+      }
+      catch (IOException ex) {
-            + " for file " + saveHistoryTo);
-      } finally {
+          + " for file " + saveHistoryTo);
+      }
+      finally {
-        } catch (IOException e) {
+        }
+        catch (IOException e) {
-              .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
-              .addLine("exception in closing file");
+            .setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
+            .addLine("exception in closing file");
-            + saveHistoryTo);
-      } else {
+          + saveHistoryTo);
+      }
+      else {
-  Result executeClearHistory(){
-    try{
+  Result executeClearHistory() {
+    try {
-    }catch(Exception e){
-      LogWrapper.getInstance().info(CliUtil.stackTraceAsString(e) );
+    }
+    catch (Exception e) {
+      LogWrapper.getInstance().info(CliUtil.stackTraceAsString(e));
-
-  @CliMetaData(shellOnly=true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-      @CliOption(key = CliStrings.RUN__FILE,
-                 optionContext = ConverterHint.FILE,
-                 mandatory = true,
-                 help = CliStrings.RUN__FILE__HELP)
-                 File file,
-      @CliOption(key = { CliStrings.RUN__QUIET },
-                 specifiedDefaultValue = "true",
-                 unspecifiedDefaultValue = "false",
-                 help = CliStrings.RUN__QUIET__HELP)
-                  boolean quiet,
-      @CliOption(key = { CliStrings.RUN__CONTINUEONERROR },
-                 specifiedDefaultValue = "true",
-                 unspecifiedDefaultValue = "false",
-                 help = CliStrings.RUN__CONTINUEONERROR__HELP)
-                  boolean continueOnError) {
+    @CliOption(key = CliStrings.RUN__FILE,
+      optionContext = ConverterHint.FILE,
+      mandatory = true,
+      help = CliStrings.RUN__FILE__HELP)
+      File file,
+    @CliOption(key = { CliStrings.RUN__QUIET },
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = CliStrings.RUN__QUIET__HELP)
+      boolean quiet,
+    @CliOption(key = { CliStrings.RUN__CONTINUEONERROR },
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = CliStrings.RUN__CONTINUEONERROR__HELP)
+      boolean continueOnError)
+  {
-    } catch (IllegalArgumentException e) {
+    }
+    catch (IllegalArgumentException e) {
-  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GEMFIRE_DEBUG_UTIL})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEMFIRE_DEBUG_UTIL })
-      @CliOption(key = CliStrings.ENCRYPT_STRING,
-                 help = CliStrings.ENCRYPT_STRING__HELP,
-                 mandatory = true)
-                 String stringToEncrypt) {
+    @CliOption(key = CliStrings.ENCRYPT_STRING,
+      help = CliStrings.ENCRYPT_STRING__HELP,
+      mandatory = true)
+      String stringToEncrypt)
+  {
-  @CliMetaData(shellOnly=true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-      @CliOption(key = { CliStrings.VERSION__FULL },
-                 specifiedDefaultValue = "true",
-                 unspecifiedDefaultValue = "false",
-                 help = CliStrings.VERSION__FULL__HELP)
-                  boolean full) {
+    @CliOption(key = { CliStrings.VERSION__FULL },
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = CliStrings.VERSION__FULL__HELP)
+      boolean full)
+  {
-  @CliMetaData(shellOnly=true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-      @CliOption(key = { CliStrings.SLEEP__TIME },
-                 unspecifiedDefaultValue = "3",
-                 help = CliStrings.SLEEP__TIME__HELP)
-                  double time) {
+    @CliOption(key = { CliStrings.SLEEP__TIME },
+      unspecifiedDefaultValue = "3",
+      help = CliStrings.SLEEP__TIME__HELP)
+      double time)
+  {
-      Thread.sleep( Math.round(time * 1000) );
-    } catch (InterruptedException ignorable) {}
+      Thread.sleep(Math.round(time * 1000));
+    }
+    catch (InterruptedException ignorable) {
+    }
-  @CliMetaData(shellOnly=true, relatedTopic = {CliStrings.TOPIC_GFSH})
+  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GFSH })
-      @CliArgument(name = CliStrings.SH__COMMAND,
-                   mandatory = true,
-                   help = CliStrings.SH__COMMAND__HELP)
-                    String command,
-      @CliOption(key = CliStrings.SH__USE_CONSOLE,
-                 specifiedDefaultValue = "true",
-                 unspecifiedDefaultValue = "false",
-                 help = CliStrings.SH__USE_CONSOLE__HELP)
-                  boolean useConsole) {
+    @CliArgument(name = CliStrings.SH__COMMAND,
+      mandatory = true,
+      help = CliStrings.SH__COMMAND__HELP)
+      String command,
+    @CliOption(key = CliStrings.SH__USE_CONSOLE,
+      specifiedDefaultValue = "true",
+      unspecifiedDefaultValue = "false",
+      help = CliStrings.SH__USE_CONSOLE__HELP)
+      boolean useConsole)
+  {
-    } catch (IllegalStateException e) {
+    }
+    catch (IllegalStateException e) {
-    } catch (IOException e) {
+    }
+    catch (IOException e) {
-    String cmdToExecute   = userCommand;
-    String cmdExecutor    = "/bin/sh";
+    String cmdToExecute = userCommand;
+    String cmdExecutor = "/bin/sh";
-      cmdExecutor    = "cmd";
+      cmdExecutor = "cmd";
-    } else if (useConsole) {
+    }
+    else if (useConsole) {
-    } catch (final InterruptedException e) {
+    }
+    catch (final InterruptedException e) {
-  @CliAvailabilityIndicator({CliStrings.CONNECT, CliStrings.DISCONNECT, CliStrings.DESCRIBE_CONNECTION})
+  @CliAvailabilityIndicator({ CliStrings.CONNECT, CliStrings.DISCONNECT, CliStrings.DESCRIBE_CONNECTION })

GEODE-5401: Check if transaction has been failed over before expiring client transactions. (#2197)

* Use ExpireDisconnectedClientTransactionsMessage instead of TXManagerImpl.TXRemovalMessage when expire client transactions.

* Only send new message to Geode 1.7.0 and later servers - assuming old version servers will be rolled soon.

* Handle differently when server receives this message based on sender version.


-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import org.apache.geode.DataSerializer;
+import org.apache.geode.annotations.TestingOnly;
-import org.apache.geode.distributed.internal.ClusterDistributionManager;
-import org.apache.geode.distributed.internal.HighPriorityDistributionMessage;
+  // Used for testing only.
+  private final Set<TXId> scheduledToBeRemovedTx =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "trackScheduledToBeRemovedTx")
+          ? new ConcurrentHashSet<TXId>() : null;
+
-
-
+      if (tx.isOnBehalfOfClient()) {
+        updateLastOperationTime(tx);
+      }
+  void updateLastOperationTime(TXStateProxy tx) {
+    ((TXStateProxyImpl) tx).setLastOperationTimeFromClient(System.currentTimeMillis());
+  }
+
-   * Cleanup the remote txState after commit and rollback
+   * Cleanup the txState
+  public void removeHostedTXState(Set<TXId> txIds) {
+    for (TXId txId : txIds) {
+      removeHostedTXState(txId);
+    }
+  }
+
-  /** remove the given TXStates */
-  public void removeTransactions(Set<TXId> txIds, boolean distribute) {
+  /**
+   * This method is only being invoked by pre geode 1.7.0 server during rolling upgrade now.
+   * The remote server has waited for transactionTimeToLive and require this server to
+   * remove the client transactions. Need to check if there is no activity of the client
+   * transaction.
+   */
+  public void removeExpiredClientTransactions(Set<TXId> txIds) {
+      for (TXId txId : txIds) {
+        // only expire client transaction if no activity for the given transactionTimeToLive
+        scheduleToRemoveExpiredClientTransaction(txId);
+      }
+    }
+  }
+
+  @TestingOnly
+  /** remove the given TXStates for test */
+  public void removeTransactions(Set<TXId> txIds, boolean distribute) {
+    synchronized (this.hostedTXStates) {
-    if (distribute) {
-      // tell other VMs to also remove the transactions
-      TXRemovalMessage.send(this.dm, this.dm.getOtherDistributionManagerIds(), txIds);
-    }
-  public static class TXRemovalMessage extends HighPriorityDistributionMessage {
-
-    Set<TXId> txIds;
-
-    /** for deserialization */
-    public TXRemovalMessage() {}
-
-    static void send(DistributionManager dm, Set recipients, Set<TXId> txIds) {
-      TXRemovalMessage msg = new TXRemovalMessage();
-      msg.txIds = txIds;
-      msg.setRecipients(recipients);
-      dm.putOutgoing(msg);
+  /** timer task for expiring the given TXStates */
+  public void expireDisconnectedClientTransactions(Set<TXId> txIds, boolean distribute) {
+    // increase the client transaction timeout setting to avoid a late in-flight client operation
+    // preventing the expiration of the client transaction.
+    long timeout = (long) (TimeUnit.SECONDS.toMillis(getTransactionTimeToLive()) * 1.1);
+    if (timeout <= 0) {
+      removeHostedTXState(txIds);
-
-    @Override
-    public void toData(DataOutput out) throws IOException {
-      DataSerializer.writeHashSet((HashSet<TXId>) this.txIds, out);
+    synchronized (this.hostedTXStates) {
+      Iterator<Map.Entry<TXId, TXStateProxy>> iterator = this.hostedTXStates.entrySet().iterator();
+      while (iterator.hasNext()) {
+        Map.Entry<TXId, TXStateProxy> entry = iterator.next();
+        if (txIds.contains(entry.getKey())) {
+          scheduleToRemoveClientTransaction(entry.getKey(), timeout);
+        }
+      }
-
-    @Override
-    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.txIds = DataSerializer.readHashSet(in);
+    if (distribute) {
+      expireClientTransactionsOnRemoteServer(txIds);
+  }
-    public int getDSFID() {
-      return TX_MANAGER_REMOVE_TRANSACTIONS;
+  void expireClientTransactionsOnRemoteServer(Set<TXId> txIds) {
+    // tell other VMs to also add tasks to expire the transactions
+    ExpireDisconnectedClientTransactionsMessage.send(this.dm,
+        this.dm.getOtherDistributionManagerIds(), txIds);
+  }
+
+  /**
+   * expire the transaction states for the given client.
+   * If the timeout is non-positive we expire the states immediately
+   */
+  void scheduleToRemoveClientTransaction(TXId txId, long timeout) {
+    if (timeout <= 0) {
+      removeHostedTXState(txId);
+    } else {
+      if (scheduledToBeRemovedTx != null) {
+        scheduledToBeRemovedTx.add(txId);
+      }
+      SystemTimerTask task = new SystemTimerTask() {
+        @Override
+        public void run2() {
+          scheduleToRemoveExpiredClientTransaction(txId);
+          if (scheduledToBeRemovedTx != null) {
+            scheduledToBeRemovedTx.remove(txId);
+          }
+        }
+      };
+      getCache().getCCPTimer().schedule(task, timeout);
+  }
-    @Override
-    protected void process(ClusterDistributionManager dm) {
-      InternalCache cache = dm.getCache();
-      if (cache != null) {
-        TXManagerImpl mgr = cache.getTXMgr();
-        mgr.removeTransactions(this.txIds, false);
+  void scheduleToRemoveExpiredClientTransaction(TXId txId) {
+    synchronized (this.hostedTXStates) {
+      TXStateProxy result = hostedTXStates.get(txId);
+      if (result != null) {
+        if (((TXStateProxyImpl) result).isOverTransactionTimeoutLimit()) {
+          result.close();
+          hostedTXStates.remove(txId);
+        }
-      logger.debug("expiring the following transactions: {}", txIds);
+      logger.debug("expiring the following transactions: {}", Arrays.toString(txIds.toArray()));
+  public Set<TXId> getScheduledToBeRemovedTx() {
+    return scheduledToBeRemovedTx;
+  }
+

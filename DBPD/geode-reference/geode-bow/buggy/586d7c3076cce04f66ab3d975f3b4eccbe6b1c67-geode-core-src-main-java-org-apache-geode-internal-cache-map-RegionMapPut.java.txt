GEODE-5195: add unit tests for RegionMapPut (#1964)


-import org.apache.geode.internal.cache.CachePerfStats;
-import org.apache.geode.internal.offheap.annotations.Retained;
-    boolean needToSetOldValue =
-        isCacheWrite() || isRequireOldValue() || event.getOperation().guaranteesOldValue();
-    if (needToSetOldValue) {
-      if (event.getOperation().guaranteesOldValue()) {
-        // In these cases we want to even get the old value from disk if it is not in memory
-        ReferenceCountHelper.skipRefCountTracking();
-        @Released
-        Object oldValueInVMOrDisk = re.getValueOffHeapOrDiskWithoutFaultIn(event.getRegion());
-        ReferenceCountHelper.unskipRefCountTracking();
-        try {
-          event.setOldValue(oldValueInVMOrDisk, true);
-        } finally {
-          OffHeapHelper.releaseWithNoTracking(oldValueInVMOrDisk);
-        }
-      } else {
-        // In these cases only need the old value if it is in memory
-        ReferenceCountHelper.skipRefCountTracking();
-
-        @Retained
-        @Released
-        Object oldValueInVM = re.getValueRetain(event.getRegion(), true); // OFFHEAP: re
-        // synced so can use
-        // its ref.
-        if (oldValueInVM == null) {
-          oldValueInVM = Token.NOT_AVAILABLE;
-        }
-        ReferenceCountHelper.unskipRefCountTracking();
-        try {
-          event.setOldValue(oldValueInVM);
-        } finally {
-          OffHeapHelper.releaseWithNoTracking(oldValueInVM);
-        }
-      }
+    if (event.getOperation().guaranteesOldValue()) {
+      setOldValueEvenIfFaultedOut();
+    } else if (isCacheWrite() || isRequireOldValue()) {
+      setOldValueIfNotFaultedOut();
-      // if the old value is in memory then if it is a GatewaySenderEventImpl then
-      // we want to set the old value.
-      Object ov = re.getValue(); // OFFHEAP _getValue is ok since re is synced and we only use it
-      // if its a GatewaySenderEventImpl.
-      // Since GatewaySenderEventImpl is never stored in an off-heap region nor a compressed region
-      // we don't need to worry about ov being compressed.
-      if (ov instanceof GatewaySenderEventImpl) {
-        event.setOldValue(ov, true);
+      Object existingValue = re.getValue();
+      if (existingValue instanceof GatewaySenderEventImpl) {
+        event.setOldValue(existingValue, true);
+  private void setOldValueIfNotFaultedOut() {
+    final EntryEventImpl event = getEvent();
+    ReferenceCountHelper.skipRefCountTracking();
+    @Released
+    Object oldValueInVM = getRegionEntry().getValueRetain(event.getRegion(), true);
+    if (oldValueInVM == null) {
+      oldValueInVM = Token.NOT_AVAILABLE;
+    }
+    ReferenceCountHelper.unskipRefCountTracking();
+    try {
+      event.setOldValue(oldValueInVM);
+    } finally {
+      OffHeapHelper.releaseWithNoTracking(oldValueInVM);
+    }
+  }
+
+  private void setOldValueEvenIfFaultedOut() {
+    final EntryEventImpl event = getEvent();
+    ReferenceCountHelper.skipRefCountTracking();
+    @Released
+    Object oldValueInVMOrDisk =
+        getRegionEntry().getValueOffHeapOrDiskWithoutFaultIn(event.getRegion());
+    ReferenceCountHelper.unskipRefCountTracking();
+    try {
+      event.setOldValue(oldValueInVMOrDisk, true);
+    } finally {
+      OffHeapHelper.releaseWithNoTracking(oldValueInVMOrDisk);
+    }
+  }
+
-        if (!isClearOccurred()) {
-          try {
-            getRegionMap().lruUpdateCallback();
-          } catch (DiskAccessException dae) {
-            getOwner().handleDiskAccessException(dae);
-            throw dae;
-          }
-        }
+        lruUpdateCallbackIfNotCleared();
+  private void lruUpdateCallbackIfNotCleared() {
+    if (!isClearOccurred()) {
+      try {
+        getRegionMap().lruUpdateCallback();
+      } catch (DiskAccessException dae) {
+        getOwner().handleDiskAccessException(dae);
+        throw dae;
+      }
+    }
+  }
+
-   * @return false if precondition indicates that
+   * @return false if preconditions indicate that
-    if (continueUpdate() && continueOverwriteDestroyed() && satisfiesExpectedOldValue()) {
-      return true;
+    if (!checkUpdatePreconditions()) {
+      return false;
-    return false;
+    if (!checkUninitializedRegionPreconditions()) {
+      return false;
+    }
+    if (!checkCreatePreconditions()) {
+      return false;
+    }
+    if (!checkExpectedOldValuePrecondition()) {
+      return false;
+    }
+    return true;
-  private boolean continueUpdate() {
+  private boolean checkUpdatePreconditions() {
-  private boolean continueOverwriteDestroyed() {
-    Token oldValueInVM = getRegionEntry().getValueAsToken();
-    // if region is under GII, check if token is destroyed
-    if (!isOverwriteDestroyed()) {
-      if (!getOwner().isInitialized()
-          && (oldValueInVM == Token.DESTROYED || oldValueInVM == Token.TOMBSTONE)) {
-        getEvent().setOldValueDestroyedToken();
-        return false;
+  private boolean checkUninitializedRegionPreconditions() {
+    if (!getOwner().isInitialized()) {
+      if (!isOverwriteDestroyed()) {
+        Token oldValueInVM = getRegionEntry().getValueAsToken();
+        if (oldValueInVM == Token.DESTROYED || oldValueInVM == Token.TOMBSTONE) {
+          getEvent().setOldValueDestroyedToken();
+          return false;
+        }
-    if (isIfNew() && !Token.isRemoved(oldValueInVM)) {
-      return false;
-    }
-  private boolean satisfiesExpectedOldValue() {
+  private boolean checkCreatePreconditions() {
+    if (isIfNew()) {
+      if (!getRegionEntry().isDestroyedOrRemoved()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private boolean checkExpectedOldValuePrecondition() {
-        CachePerfStats stats = getOwner().getCachePerfStats();
-        if (stats != null) {
-          stats.incEntryCount(1);
-        }
+        getOwner().getCachePerfStats().incEntryCount(1);

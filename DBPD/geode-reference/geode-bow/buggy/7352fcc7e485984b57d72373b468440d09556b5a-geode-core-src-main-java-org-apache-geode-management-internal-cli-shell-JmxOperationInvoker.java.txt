GEODE-3328: refactor ConnectCommand

* connect command will prompt for missing ssl configs if ssl is indicated by any options
* command ssl options will override the properties loaded in the file
* reworked connect with ssl so that the configuration won't get cached accidentally.
* have auto connect also prompt for missing ssl configs, not in the socket creator
* change the properties file type in the start server and start locator command to be File instead of String

-import org.apache.commons.lang.StringUtils;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.util.ArrayUtils;
-import org.apache.geode.internal.util.IOUtils;
-import org.apache.geode.management.DistributedSystemMXBean;
-import org.apache.geode.management.MemberMXBean;
-import org.apache.geode.management.internal.MBeanJMXAdapter;
-import org.apache.geode.management.internal.ManagementConstants;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.CommandRequest;
-import org.apache.geode.management.internal.cli.LogWrapper;
-import org.apache.geode.management.internal.cli.commands.ShellCommands;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-
-import java.io.File;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Iterator;
-import java.util.Map.Entry;
+
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.internal.admin.SSLConfig;
+import org.apache.geode.internal.net.SSLConfigurationFactory;
+import org.apache.geode.internal.security.SecurableCommunicationChannel;
+import org.apache.geode.internal.util.ArrayUtils;
+import org.apache.geode.management.DistributedSystemMXBean;
+import org.apache.geode.management.MemberMXBean;
+import org.apache.geode.management.internal.MBeanJMXAdapter;
+import org.apache.geode.management.internal.ManagementConstants;
+import org.apache.geode.management.internal.cli.CommandRequest;
+import org.apache.geode.management.internal.cli.LogWrapper;
+
-  public JmxOperationInvoker(final String host, final int port, final String userName,
-      final String password, final Map<String, String> sslConfigProps,
-      String gfSecurityPropertiesPath) throws Exception {
+  public JmxOperationInvoker(final String host, final int port, Properties gfProperties)
+      throws Exception {
+      env.put(JMXConnector.CREDENTIALS, gfProperties);
-      if (userName != null && userName.length() > 0) {
-        env.put(JMXConnector.CREDENTIALS, new String[] {userName, password});
-      }
-      Set<Entry<String, String>> entrySet = sslConfigProps.entrySet();
-      for (Iterator<Entry<String, String>> it = entrySet.iterator(); it.hasNext();) {
-        Entry<String, String> entry = it.next();
-        String key = entry.getKey();
-        String value = entry.getValue();
-        key = checkforSystemPropertyPrefix(key);
-        if ((key.equals(Gfsh.SSL_ENABLED_CIPHERS) || key.equals(Gfsh.SSL_ENABLED_PROTOCOLS))
-            && "any".equals(value)) {
-          continue;
+      SSLConfig sslConfig = SSLConfigurationFactory.getSSLConfigForComponent(gfProperties,
+          SecurableCommunicationChannel.JMX);
+
+      if (sslConfig.isEnabled()) {
+        if (sslConfig.getKeystore() != null) {
+          System.setProperty(SSLConfigurationFactory.JAVAX_KEYSTORE, sslConfig.getKeystore());
+          propsToClear.add(SSLConfigurationFactory.JAVAX_KEYSTORE);
-        System.setProperty(key, value);
-        propsToClear.add(key);
-      }
-
-      if (!sslConfigProps.isEmpty()) {
-        if (System.getProperty(Gfsh.SSL_KEYSTORE) != null
-            || System.getProperty(Gfsh.SSL_TRUSTSTORE) != null) {
-          // use ssl to connect
-          env.put("com.sun.jndi.rmi.factory.socket", new SslRMIClientSocketFactory());
+        if (sslConfig.getKeystorePassword() != null) {
+          System.setProperty(SSLConfigurationFactory.JAVAX_KEYSTORE_PASSWORD,
+              sslConfig.getKeystorePassword());
+          propsToClear.add(SSLConfigurationFactory.JAVAX_KEYSTORE_PASSWORD);
-      }
-
-      // Check for JMX Credentials if empty put properties instance directly so that
-      // jmx management interceptor can read it for custom security properties
-      if (!env.containsKey(JMXConnector.CREDENTIALS)) {
-        env.put(JMXConnector.CREDENTIALS, readProperties(gfSecurityPropertiesPath));
+        if (sslConfig.getKeystoreType() != null) {
+          System.setProperty(SSLConfigurationFactory.JAVAX_KEYSTORE_TYPE,
+              sslConfig.getKeystoreType());
+          propsToClear.add(SSLConfigurationFactory.JAVAX_KEYSTORE_TYPE);
+        }
+        if (sslConfig.getTruststore() != null) {
+          System.setProperty(SSLConfigurationFactory.JAVAX_TRUSTSTORE, sslConfig.getTruststore());
+          propsToClear.add(SSLConfigurationFactory.JAVAX_TRUSTSTORE);
+        }
+        if (sslConfig.getTruststorePassword() != null) {
+          System.setProperty(SSLConfigurationFactory.JAVAX_TRUSTSTORE_PASSWORD,
+              sslConfig.getTruststorePassword());
+          propsToClear.add(SSLConfigurationFactory.JAVAX_TRUSTSTORE_PASSWORD);
+        }
+        if (sslConfig.getTruststoreType() != null) {
+          System.setProperty(SSLConfigurationFactory.JAVAX_TRUSTSTORE_TYPE,
+              sslConfig.getTruststoreType());
+          propsToClear.add(SSLConfigurationFactory.JAVAX_TRUSTSTORE_TYPE);
+        }
+        env.put("com.sun.jndi.rmi.factory.socket", new SslRMIClientSocketFactory());
-  // Copied from ShellCommands.java
-  private Properties readProperties(String gfSecurityPropertiesPath) throws MalformedURLException {
-    Gfsh gfshInstance = Gfsh.getCurrentInstance();
-    // reference to hold resolved gfSecurityPropertiesPath
-    String gfSecurityPropertiesPathToUse = CliUtil.resolvePathname(gfSecurityPropertiesPath);
-    URL gfSecurityPropertiesUrl = null;
-
-    // Case 1: User has specified gfSecurity properties file
-    if (StringUtils.isNotBlank(gfSecurityPropertiesPathToUse)) {
-      // User specified gfSecurity properties doesn't exist
-      if (!IOUtils.isExistingPathname(gfSecurityPropertiesPathToUse)) {
-        gfshInstance
-            .printAsSevere(CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
-                "Security ", gfSecurityPropertiesPathToUse));
-      } else {
-        gfSecurityPropertiesUrl = new File(gfSecurityPropertiesPathToUse).toURI().toURL();
-      }
-    } else if (gfSecurityPropertiesPath == null) {
-      // Use default "gfsecurity.properties"
-      // in current dir, user's home or classpath
-      gfSecurityPropertiesUrl = ShellCommands.getFileUrl("gfsecurity.properties");
-    }
-    // if 'gfSecurityPropertiesPath' OR gfsecurity.properties has resolvable path
-    if (gfSecurityPropertiesUrl != null) {
-      gfshInstance.logToFile("Using security properties file : "
-          + CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath()), null);
-      return loadPropertiesFromURL(gfSecurityPropertiesUrl);
-    }
-    return null;
-  }
-
-  static Properties loadPropertiesFromURL(URL gfSecurityPropertiesUrl) {
-    Properties props = new Properties();
-    if (gfSecurityPropertiesUrl != null) {
-      InputStream inputStream = null;
-      try {
-
-        inputStream = gfSecurityPropertiesUrl.openStream();
-        props.load(inputStream);
-      } catch (IOException io) {
-        throw new RuntimeException(
-            CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_READ_CONFIG_FROM_0,
-                CliUtil.decodeWithDefaultCharSet(gfSecurityPropertiesUrl.getPath())),
-            io);
-      } finally {
-        IOUtils.close(inputStream);
-      }
-    }
-    return props;
-  }
-

GEODE-1372 added unit test and some more fixes.

-import com.gemstone.gemfire.*;
+import static com.gemstone.gemfire.distributed.internal.membership.gms.GMSUtil.replaceStrings;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.JOIN_REQUEST;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.JOIN_RESPONSE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.FIND_COORDINATOR_REQ;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.FIND_COORDINATOR_RESP;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.WeakHashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.logging.log4j.Logger;
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.JChannel;
+import org.jgroups.Message;
+import org.jgroups.Message.Flag;
+import org.jgroups.Message.TransientFlag;
+import org.jgroups.ReceiverAdapter;
+import org.jgroups.View;
+import org.jgroups.ViewId;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.UDP;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.stack.IpAddress;
+import org.jgroups.util.Digest;
+import org.jgroups.util.UUID;
+
+import com.gemstone.gemfire.DataSerializer;
+import com.gemstone.gemfire.ForcedDisconnectException;
+import com.gemstone.gemfire.GemFireConfigException;
+import com.gemstone.gemfire.GemFireIOException;
+import com.gemstone.gemfire.SystemConnectException;
+import com.gemstone.gemfire.distributed.internal.membership.gms.locator.FindCoordinatorRequest;
+import com.gemstone.gemfire.distributed.internal.membership.gms.locator.FindCoordinatorResponse;
-import com.gemstone.gemfire.internal.*;
+import com.gemstone.gemfire.internal.ClassPathLoader;
+import com.gemstone.gemfire.internal.HeapDataOutputStream;
+import com.gemstone.gemfire.internal.InternalDataSerializer;
+import com.gemstone.gemfire.internal.OSProcess;
+import com.gemstone.gemfire.internal.SocketCreator;
+import com.gemstone.gemfire.internal.VersionedDataInputStream;
+        logger.info("Initializing GMSEncrypt ");
-
-      try {
-        encrypt.installView(v);
-      } catch (Exception e) {
-        // TODO Auto-generated catch block
-        e.printStackTrace();
-      }
+      encrypt.installView(v);
-
-  @Override
-  public Set<InternalDistributedMember> send(DistributionMessage msg, NetView alternateView) {
-    if (this.encrypt != null) {
-      try {
-        this.encrypt.installView(alternateView);
-      } catch (Exception e) {
-        // TODO Auto-generated catch block
-        e.printStackTrace();
-      }
-    }
-    return send(msg, true);
-  }
-
+    
-      Message jmsg = createJGMessage(msg, local, null, Version.CURRENT_ORDINAL);
+      Message jmsg = createJGMessage(msg, local, Version.CURRENT_ORDINAL);
-      List<InternalDistributedMember> calculatedMembers; // explicit list of members
+      List<GMSMember> calculatedMembers; // explicit list of members
-        calculatedMembers = new LinkedList<InternalDistributedMember>();
+        calculatedMembers = new LinkedList<GMSMember>();
-          calculatedMembers.add(m);
+          calculatedMembers.add((GMSMember)m.getNetMember());
-        calculatedMembers = new LinkedList<>();
+        calculatedMembers = new LinkedList<GMSMember>();
-          calculatedMembers.add(destinations[i]);
+          calculatedMembers.add((GMSMember)destinations[i].getNetMember());
-
-      boolean encode = (encrypt != null);
-
+      for (Iterator<GMSMember> it=calculatedMembers.iterator(); it.hasNext(); ) {
+        GMSMember mbr = it.next();
+        short version = mbr.getVersionOrdinal();
+        if ( !messages.containsKey(version) ) {
+          Message jmsg = createJGMessage(msg, local, version);
+          messages.put(version, jmsg);
+          if (firstMessage) {
+            theStats.incSentBytes(jmsg.getLength());
+            firstMessage = false;
+          }
+        }
+      }
+      theStats.endMsgSerialization(startSer);
-      for (InternalDistributedMember mbr: calculatedMembers) {
-        short version = mbr.getNetMember().getVersionOrdinal();
+      for (GMSMember mbr: calculatedMembers) {
-        Message jmsg = createJGMessage(msg, local, mbr, version);
+        short version = mbr.getVersionOrdinal();
+        Message jmsg = (Message)messages.get(version);
+          Message tmp = (i < (calculatedLen-1)) ? jmsg.copy(true) : jmsg;
-          jmsg.setDest(to);
-          jmsg.setSrc(this.jgAddress);
+          tmp.setDest(to);
+          tmp.setSrc(this.jgAddress);
-          myChannel.send(jmsg);
+          myChannel.send(tmp);
-  Message createJGMessage(DistributionMessage gfmsg, JGAddress src, InternalDistributedMember recipient, short version) {
+  Message createJGMessage(DistributionMessage gfmsg, JGAddress src, short version) {
-      HeapDataOutputStream out_stream =
-        new HeapDataOutputStream(Version.fromOrdinalOrCurrent(version));
+      byte[] messageBytes = null;
+      HeapDataOutputStream out_stream = new HeapDataOutputStream(Version.fromOrdinalOrCurrent(version));
-      DataSerializer.writeObject(this.localAddress.getNetMember(), out_stream);
-      boolean encode = encrypt != null && recipient != null;
-      if (encode) {
-        // Coordinator doesn't know our publicKey for a JoinRequest
-        if (gfmsg.getDSFID() == JOIN_REQUEST || gfmsg.getDSFID() == JOIN_RESPONSE) {
-          encode = false;
-        }
-      }
-      if (encode) {
-        logger.info("encoding {}", gfmsg);
-        try {
-          out_stream.writeBoolean(true); // TODO we should have flag bits
-          HeapDataOutputStream out_stream2 =
-            new HeapDataOutputStream(Version.fromOrdinalOrCurrent(version));
-          DataSerializer.writeObject(gfmsg, out_stream2);
-          byte[] payload = out_stream2.toByteArray();
-          payload = encrypt.encryptData(payload, recipient);
-          DataSerializer.writeByteArray(payload, out_stream);
-        } catch (Exception e) {
-          throw new GemFireIOException("unable to send message", e);
-        }
+      if(encrypt != null) {
+        out_stream.writeBoolean(true);
+        writeEncryptedMessage(gfmsg, version, out_stream);                
-        logger.info("not encoding {}", gfmsg);
-        DataSerializer.writeObject(gfmsg, out_stream);
+        serializeMessage(gfmsg, out_stream);
+      
+    } catch(Exception ex){
+      logger.warn("Error serializing message", ex);
+      GemFireIOException ioe = new
+          GemFireIOException("Error serializing message");
+        ioe.initCause(ex.getCause());
+        throw ioe;
+  
+  void writeEncryptedMessage(DistributionMessage gfmsg, short version, HeapDataOutputStream out) throws Exception {
+    InternalDataSerializer.writeDSFIDHeader(gfmsg.getDSFID(), out);
+    byte[] pk = null;
+    int requestId = 0;
+    InternalDistributedMember pkMbr = null;
+    switch (gfmsg.getDSFID()) {
+    case FIND_COORDINATOR_REQ:
+    case JOIN_REQUEST:
+      //need to append mine PK
+      pk = encrypt.getPublicKey(localAddress);
+      
+      pkMbr = gfmsg.getRecipients()[0];      
+      requestId = getRequestId(gfmsg, true);
+      break;
+    case FIND_COORDINATOR_RESP:
+    case JOIN_RESPONSE:
+      pkMbr = gfmsg.getRecipients()[0];
+      requestId = getRequestId(gfmsg, false);
+    default:
+      break;
+    }
+    logger.debug("writeEncryptedMessage gfmsg.getDSFID() = {}  for {} with requestid  {}", gfmsg.getDSFID(), pkMbr, requestId);
+    out.writeInt(requestId);
+    if (pk != null) {      
+      InternalDataSerializer.writeByteArray(pk, out);
+    }
+
+    HeapDataOutputStream out_stream = new HeapDataOutputStream(Version.fromOrdinalOrCurrent(version));
+    byte[] messageBytes = serializeMessage(gfmsg, out_stream);
+    
+    if (pkMbr != null) {
+      // using members private key
+      messageBytes = encrypt.encryptData(messageBytes, pkMbr);
+    } else {
+      // using cluster secret key
+      messageBytes = encrypt.encryptData(messageBytes);
+    }
+    InternalDataSerializer.writeByteArray(messageBytes, out);
+  }
+  
+  int getRequestId(DistributionMessage gfmsg, boolean add) {
+    int requestId = 0;
+    if (gfmsg instanceof FindCoordinatorRequest) {
+      requestId = ((FindCoordinatorRequest) gfmsg).getRequestId();
+    } else if (gfmsg instanceof JoinRequestMessage) {
+      requestId = ((JoinRequestMessage) gfmsg).getRequestId();
+    } else if (gfmsg instanceof FindCoordinatorResponse) {
+      requestId = ((FindCoordinatorResponse) gfmsg).getRequestId();
+    } else if (gfmsg instanceof JoinResponseMessage) {
+      requestId = ((JoinResponseMessage) gfmsg).getRequestId();
+    }
+
+    if (add) {
+      addRequestId(requestId, gfmsg.getRecipients()[0]);
+    }
+
+    return requestId;
+  }
+  
+  byte[] serializeMessage(DistributionMessage gfmsg, HeapDataOutputStream out_stream) throws IOException {
+    
+    DataSerializer.writeObject(this.localAddress.getNetMember(), out_stream);
+    DataSerializer.writeObject(gfmsg, out_stream);
+    
+    return out_stream.toByteArray();
+  }
-    }
-
-    InternalDistributedMember sender;
+    }    
-
-      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(buf,
+      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(buf, 
-
-      GMSMember m = DataSerializer.readObject(dis);
-
-      sender = getMemberFromView(m, ordinal);
-
-      boolean encrypted = dis.readBoolean();
-
-      if (encrypted && encrypt != null) {
-        byte[] payload = DataSerializer.readByteArray(dis);
-        try {
-          payload = encrypt.decryptData(payload, sender);
-          dis = new DataInputStream(new ByteArrayInputStream(payload));
-          if (ordinal < Version.CURRENT_ORDINAL) {
-            dis = new VersionedDataInputStream(dis, Version.fromOrdinalNoThrow(
-              ordinal, true));
-          }
-        } catch (Exception e) {
-          throw new GemFireIOException("unable to receive message", e);
-        }
-      }
-
-      result = DataSerializer.readObject(dis);
-
-      DistributionMessage dm = (DistributionMessage)result;
+    
+      //read
+      boolean isEncrypted = dis.readBoolean();
-      // JoinRequestMessages are sent with an ID that may have been
-      // reused from a previous life by way of auto-reconnect,
-      // so we don't want to find a canonical reference for the
-      // request's sender ID
-      if (dm.getDSFID() == JOIN_REQUEST) {
-        sender = ((JoinRequestMessage)dm).getMemberID();
+      if(isEncrypted && encrypt == null) {
+        throw new GemFireConfigException("Got remote message as encrypted");
+      } 
+      
+      if(isEncrypted) {
+        result = readEncryptedMessage(dis, ordinal, encrypt);
+      } else {
+        GMSMember m = DataSerializer.readObject(dis);
+  
+        result = DataSerializer.readObject(dis);
+  
+        DistributionMessage dm = (DistributionMessage)result;
+        
+        setSender(dm, m, ordinal);
-      ((DistributionMessage)result).setSender(sender);
+      
+    } catch(Exception e) {
+      problem = e;
+  void setSender(DistributionMessage dm, GMSMember m, short ordinal) {
+    InternalDistributedMember sender = null;
+    // JoinRequestMessages are sent with an ID that may have been
+    // reused from a previous life by way of auto-reconnect,
+    // so we don't want to find a canonical reference for the
+    // request's sender ID
+    if (dm.getDSFID() == JOIN_REQUEST) {
+      sender = ((JoinRequestMessage)dm).getMemberID();
+    } else {
+      sender = getMemberFromView(m, ordinal);
+    }
+    dm.setSender(sender);
+  }
+
+  @SuppressWarnings("resource")
+  DistributionMessage readEncryptedMessage(DataInputStream dis, short ordinal, GMSEncrypt encryptLocal) throws Exception {
+    int dfsid = InternalDataSerializer.readDSFIDHeader(dis);
+    int requestId = dis.readInt();
+
+    try {
+      // TODO seems like we don't need this, just set bit that PK is appended
+
+      logger.debug("readEncryptedMessage Reading Request id " + dfsid + " and requestid is " + requestId + " myid " + this.localAddress);
+      InternalDistributedMember pkMbr = null;
+      boolean readPK = false;
+      switch (dfsid) {
+      case FIND_COORDINATOR_REQ:
+      case JOIN_REQUEST:
+        readPK = true;
+        break;
+      case FIND_COORDINATOR_RESP:
+      case JOIN_RESPONSE:
+        // this will have requestId to know the PK
+        pkMbr = getRequestedMember(requestId);
+        break;
+      }
+
+      byte[] data;
+
+      byte[] pk = null;
+
+      if (readPK) {
+        // need to read PK
+        pk = InternalDataSerializer.readByteArray(dis);
+        // encrypt.setPublicKey(publickey, mbr);
+        data = InternalDataSerializer.readByteArray(dis);
+        // using prefixed pk from sender
+        data = encryptLocal.decryptData(data, pk);
+      } else {
+        data = InternalDataSerializer.readByteArray(dis);
+        // from cluster key
+        if (pkMbr != null) {
+          // using member public key
+          data = encryptLocal.decryptData(data, pkMbr);
+        } else {
+          // from cluster key
+          data = encryptLocal.decryptData(data);
+        }
+      }
+
+      {
+        DataInputStream in = new DataInputStream(new ByteArrayInputStream(data));
+
+        if (ordinal < Version.CURRENT_ORDINAL) {
+          in = new VersionedDataInputStream(in, Version.fromOrdinalNoThrow(ordinal, true));
+        }
+
+        GMSMember m = DataSerializer.readObject(in);
+
+        DistributionMessage result = (DistributionMessage) DataSerializer.readObject(in);
+
+        setSender(result, m, ordinal);
+
+        if (pk != null) {
+          encryptLocal.setPublicKey(pk, result.getSender());
+        }
+
+        return result;
+      }
+    } catch (Exception e) {
+      throw new Exception("Message id is " + dfsid, e);
+    }
+
+  }
-      case JOIN_REQUEST:
-        if (encrypt == null) {
-          break;
-        }
-        JoinRequestMessage joinMsg = (JoinRequestMessage)m;
-        joinMsg.setPublicKey(encrypt.getPublicKeyBytes());
-        break;
-
-      case JOIN_RESPONSE:
-        JoinResponseMessage jrsp = (JoinResponseMessage)m;
-
-        if (jrsp.getRejectionMessage() == null
+    case JOIN_RESPONSE:
+      JoinResponseMessage jrsp = (JoinResponseMessage)m;
+      
+      if (jrsp.getRejectionMessage() == null
-          // get the multicast message digest and pass it with the join response
-          Digest digest = (Digest)this.myChannel.getProtocolStack()
+        // get the multicast message digest and pass it with the join response
+        Digest digest = (Digest)this.myChannel.getProtocolStack()
-          HeapDataOutputStream hdos = new HeapDataOutputStream(500, Version.CURRENT);
-          try {
-            digest.writeTo(hdos);
-          } catch (Exception e) {
-            logger.fatal("Unable to serialize JGroups messaging digest", e);
-          }
-          jrsp.setMessengerData(hdos.toByteArray());
+        HeapDataOutputStream hdos = new HeapDataOutputStream(500, Version.CURRENT);
+        try {
+          digest.writeTo(hdos);
+        } catch (Exception e) {
+          logger.fatal("Unable to serialize JGroups messaging digest", e);
-        break;
-      default:
-        break;
+        jrsp.setMessengerData(hdos.toByteArray());
+      }
+      break;
+    default:
+      break;
-            break;
+            break;              
+  @Override
+  public Set<InternalDistributedMember> send(DistributionMessage msg, NetView alternateView) {
+    if (this.encrypt != null) {
+      this.encrypt.installView(alternateView);      
+    }
+    return send(msg, true);
+  }
+
+  @Override
+  public byte[] getPublickey(InternalDistributedMember mbr) {
+    if (encrypt != null) {
+      return encrypt.getPublicKey(mbr);
+    }
+    return null;
+  }
+
+  @Override
+  public void setPublicKey(byte[] publickey, InternalDistributedMember mbr) {
+    if (encrypt != null) {
+      logger.debug("Setting pK for member " + mbr);
+      encrypt.setPublicKey(publickey, mbr);
+    }
+  }
+
+  @Override
+  public void setClusterSecretKey(byte[] clusterSecretKey) {
+    if (encrypt != null) {
+      logger.debug("Setting cluster key");
+      encrypt.addClusterKey(clusterSecretKey);
+    }
+  }
+
+  @Override
+  public byte[] getClusterSecretKey() {
+    if (encrypt != null) {
+      return encrypt.getClusterSecretKey();
+    }
+    return null;
+  }
+
+  private Random randomId = new Random();
+  private HashMap<Integer, InternalDistributedMember> requestIdVsRecipients = new HashMap<>();
+  InternalDistributedMember getRequestedMember(int requestId) {
+    //TODO: what if we don't get response, need to remove this otherwise it will be leak
+    return requestIdVsRecipients.remove(requestId);
+  }
+  void addRequestId(int requestId, InternalDistributedMember mbr) {
+    requestIdVsRecipients.put(requestId, mbr);
+  }
+  
+  @Override
+  public int getRequestId() {
+    return randomId.nextInt();
+  }
+
+  @Override
+  public void initClusterKey() {
+    if (encrypt != null) {
+      try {
+        logger.debug("Initializing cluster key");
+        encrypt.initClusterSecretKey();
+      } catch (Exception e) {
+        throw new RuntimeException("unable to create cluster key ", e);
+      }
+    }
+  }

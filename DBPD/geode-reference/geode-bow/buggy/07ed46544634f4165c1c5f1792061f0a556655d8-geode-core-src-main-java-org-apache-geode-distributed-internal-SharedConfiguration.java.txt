GEODE-2197: refactor cluster config

 * not to save the xml, properties in the file system.
 * the cc region's change listener is to download the jar from other locators

-import org.apache.geode.management.internal.cli.functions.ImportSharedConfigurationArtifactsFunction;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.configuration.functions.GetAllJarsFunction;
+import org.apache.geode.management.internal.configuration.functions.UploadJarFunction;
-import org.apache.geode.management.internal.configuration.utils.ZipUtils;
-import java.sql.Timestamp;
+import java.nio.file.Path;
+import java.util.Collection;
-import java.util.Map.Entry;
+import java.util.Objects;
-  private final String configDiskDirPath;;
+  private final String configDiskDirPath;
-  private static final GetAllJarsFunction getAllJarsFunction = new GetAllJarsFunction();
-   * 
-  public boolean addJars(String[] jarNames, byte[][] jarBytes, String[] groups) {
+  public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String[] groups) {
-        groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+        groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-          writeConfig(configuration);
+          createConfigDirIfNecessary(group);
-        configuration.addJarNames(jarNames);
-        configRegion.put(group, configuration);
+
+        // update the record after writing the jars to the file system, since the listener
+        // will need the jars on file to upload to other locators.
+        configuration.addJarNames(jarNames);
+        configRegion.put(group, configuration);
-      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-      writeConfig(configuration);
+//      writeConfig(configuration);
-   * 
-   *        directory
+   * directory
-        final DM dm = cache.getDistributedSystem().getDistributionManager();
-
-        if (dm.getNormalDistributionManagerIds().isEmpty()) {
-          Set<DistributedMember> locatorsWithSC = new HashSet<DistributedMember>(
-              dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-
-          // Send the config to other locators which host the shared configuration.
-          if (!locatorsWithSC.isEmpty()) {
-            final ImportSharedConfigurationArtifactsFunction fn =
-                new ImportSharedConfigurationArtifactsFunction();
-            final Date date = new Date();
-            String zipFileName = CliStrings.format(CliStrings.EXPORT_SHARED_CONFIG__FILE__NAME,
-                new Timestamp(date.getTime()).toString());
-            try {
-              ZipUtils.zip(getSharedConfigurationDirPath(), zipFileName);
-              File zipFile = new File(zipFileName);
-              byte[] zipBytes = FileUtils.readFileToByteArray(zipFile);
-              Object[] args = new Object[] {zipFileName, zipBytes};
-              // Make sure we wait for the result. The fn also does a clear on the config
-              // region so there is a race with the clear below.
-              CliUtil.executeFunction(fn, args, locatorsWithSC).getResult();
-            } catch (Exception e) {
-              logger.error(e.getMessage(), e);
-            }
-          }
-        }
+        // on region entry create/update, it will upload the jars to all other locators
-      putSecurityPropsIntoClusterConfig(configRegion);
-
-        Set<Entry<String, Configuration>> configEntries = configRegion.entrySet();
-
-        for (Entry<String, Configuration> configEntry : configEntries) {
-          Configuration configuration = configEntry.getValue();
-          try {
-            this.writeConfig(configuration);
-          } catch (Exception e) {
-            logger.info(e.getMessage(), e);
-          }
-        }
-        logger.info("Completed writing the shared configuration to 'cluster_config' directory");
-        this.getAllJarsFromOtherLocators();
+        // on region entry create/update, it should download missing jars from other locators
+        putSecurityPropsIntoClusterConfig(configRegion);
-          Object[] jars = getAllJars(groups);
-          if (jars != null) {
-            String[] jarNames = (String[]) jars[0];
-            byte[][] jarBytes = (byte[][]) jars[1];
-            configResponse.addJarsToBeDeployed(jarNames, jarBytes);
-          }
+          Map<String, byte[]> jarNamesToJarBytes = getAllJarsFromThisLocator(groups);
+          String[] jarNames = jarNamesToJarBytes.keySet().stream().toArray(String[]::new);
+          byte[][] jarBytes = jarNamesToJarBytes.values().toArray(new byte[jarNames.length][]);
+
+          configResponse.addJarsToBeDeployed(jarNames, jarBytes);
-
-   * 
-   * @return {@link SharedConfigurationStatusResponse} containing the
-   *         {@link SharedConfigurationStatus}
+   * @return {@link SharedConfigurationStatusResponse} containing the {@link
+   * SharedConfigurationStatus}
-          writeConfig(configuration);
+          //writeConfig(configuration);
-      writeConfig(configuration);
+      //writeConfig(configuration);
-  public Object[] getAllJars(Set<String> groups) throws Exception {
-    Set<String> jarsAdded = new HashSet<String>();
-    Object[] jars = new Object[2];
+  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws Exception {
+    Configuration configuration = getConfiguration(group);
-    for (String group : groups) {
-      Configuration configuration = getConfiguration(group);
-      if (configuration != null) {
-        jarsAdded.addAll(configuration.getJarNames());
-      }
+    //TODO: Should we check  like this, or just check jar.exists below()?
+    if (configuration == null || !configuration.getJarNames().contains(jarName)) {
+      return null;
-    int numJars = jarsAdded.size();
-    jarsAdded.clear();
-    if (numJars > 0) {
-      String[] jarNames = new String[numJars];
-      byte[][] jarBytes = new byte[numJars][];
-      int ctr = 0;
-
-      for (String group : groups) {
-        Configuration configuration = getConfiguration(group);
-        if (configuration != null) {
-          Set<String> jarNameSet = configuration.getJarNames();
-          for (String jarName : jarNameSet) {
-            String groupDirPath = FilenameUtils.concat(configDirPath, group);
-            if (!jarsAdded.contains(jarName)) {
-              String jarFilePath = FilenameUtils.concat(groupDirPath, jarName);
-              jarNames[ctr] = jarName;
-              jarBytes[ctr] = FileUtils.readFileToByteArray(new File(jarFilePath));
-              ctr++;
-            }
-          }
-        }
-      }
-
-      jars[0] = jarNames;
-      jars[1] = jarBytes;
-    }
-    return jars;
+    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
+    return FileUtils.readFileToByteArray(jar);
-  public Configuration getConfiguration(String groupName) throws Exception {
+  public Path getPathToJarOnThisLocator(String groupName, String jarName) {
+    return new File(configDirPath).toPath().resolve(groupName).resolve(jarName);
+  }
+
+  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws Exception {
+    Map<String, byte[]> jarNamesToJarBytes = new HashMap<>();
+
+    for (String group : groups) {
+      Configuration groupConfig = getConfiguration(group);
+      if (groupConfig == null) {
+        break;
+      }
+
+      Set<String> jars = groupConfig.getJarNames();
+      for (String jar : jars) {
+        byte[] jarBytes = getJarBytesFromThisLocator(group, jar);
+        jarNamesToJarBytes.put(jar, jarBytes);
+      }
+    }
+
+    return jarNamesToJarBytes;
+  }
+
+  public Configuration getConfiguration(String groupName) {
-   * 
-   * 
-   * 
-   * @throws Exception
-      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-      writeConfig(configuration);
+      //writeConfig(configuration);
-   * 
-        Set<String> groupSet = configRegion.keySet();
-        groups = groupSet.toArray(new String[groupSet.size()]);
+        groups = configRegion.keySet().stream().toArray(String[]::new);
-        Configuration configuration = (Configuration) configRegion.get(group);
-        if (configuration != null) {
-          String dirPath =
-              FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
-          removeJarFiles(dirPath, jarNames);
+        Configuration configuration = configRegion.get(group);
+        if (configuration == null) {
+          break;
-      }
-      for (String group : groups) {
-        Configuration configuration = (Configuration) configRegion.get(group);
-        if (configuration != null) {
-          if (!configuration.getJarNames().isEmpty()) {
-            configuration.removeJarNames(jarNames);
-            configRegion.put(group, configuration);
-          }
-        }
+        configuration.removeJarNames(jarNames);
+        configRegion.put(group, configuration);
-   * Writes the contents of the {@link Configuration} to the file system
+   * Creates a directory for this configuration if it doesn't already exist.
-  public void writeConfig(final Configuration configuration) throws Exception {
-    File configDir = new File(getSharedConfigurationDirPath());
-    if (!configDir.exists()) {
-      if (!configDir.mkdirs()) {
+  private File createConfigDirIfNecessary(final String configName) throws Exception {
+    File clusterConfigDir = new File(getSharedConfigurationDirPath());
+    if (!clusterConfigDir.exists()) {
+      if (!clusterConfigDir.mkdirs()) {
-    String dirPath =
-        FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
-    File file = new File(dirPath);
-    if (!file.exists()) {
-      if (!file.mkdir()) {
-        throw new IOException("Cannot create directory : " + dirPath);
+    Path configDirPath = clusterConfigDir.toPath().resolve(configName);
+
+    File configDir = configDirPath.toFile();
+    if (!configDir.exists()) {
+      if (!configDir.mkdir()) {
+        throw new IOException("Cannot create directory : " + configDirPath);
-    writeProperties(dirPath, configuration);
-    writeCacheXml(dirPath, configuration);
+    return configDir;
+  }
+
+  public void writeConfig(final Configuration configuration) throws Exception {
+    File configDir = createConfigDirIfNecessary(configuration.getConfigName());
+
+    File propsFile = new File(configDir, configuration.getPropertiesFileName());
+    BufferedWriter bw = new BufferedWriter(new FileWriter(propsFile));
+    configuration.getGemfireProperties().store(bw, null);
+    bw.close();
+
+    File xmlFile = new File(configDir, configuration.getCacheXmlFileName());
+    FileUtils.writeStringToFile(xmlFile, configuration.getCacheXmlContent(), "UTF-8");
-  /**
-   * Gets the Jar from existing locators in the system
-   */
-  private void getAllJarsFromOtherLocators() throws Exception {
+  public void addJarFromOtherLocators(String groupName, String jarName) throws Exception {
-        new HashSet<DistributedMember>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
+        new HashSet<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-    String[] jarNames = null;
-    byte[][] jarBytes = null;
-    if (locators.isEmpty()) {
-      logger.info("No other locators present");
-      return;
-    }
-    ResultCollector<?, List<Object>> rc = (ResultCollector<?, List<Object>>) CliUtil
-        .executeFunction(getAllJarsFunction, null, locators);
+    createConfigDirIfNecessary(groupName);
-    List<Object> results = rc.getResult();
-    for (Object result : results) {
-      if (result != null) {
-        if (!(result instanceof Exception)) {
-          Object[] jars = (Object[]) result;
-          jarNames = (String[]) jars[0];
-          jarBytes = (byte[][]) jars[1];
-          break;
-        }
-      }
-    }
+    byte[] jarBytes = locators.stream()
+        .map((DistributedMember locator) -> downloadJarFromLocator(locator, groupName, jarName))
+        .filter(Objects::nonNull)
+        .findFirst()
+        .orElseThrow(() -> new IllegalStateException(
+            "No locators have a deployed jar named " + jarName + " in " + groupName));
-    if (jarNames != null && jarBytes != null) {
-      Map<String, Integer> jarIndex = new HashMap<String, Integer>();
+    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
+    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
+  }
-      for (int i = 0; i < jarNames.length; i++) {
-        String jarName = jarNames[i];
-        jarIndex.put(jarName, i);
-      }
+  private byte[] downloadJarFromLocator(DistributedMember locator, String groupName,
+                                        String jarName) {
+    ResultCollector<byte[], List<byte[]>> rc = (ResultCollector<byte[], List<byte[]>>) CliUtil
+        .executeFunction(new UploadJarFunction(), new Object[]{groupName, jarName}, locator);
-      Map<String, Configuration> entireConfiguration = getEntireConfiguration();
-      Set<String> groups = entireConfiguration.keySet();
+    List<byte[]> result = rc.getResult();
-      for (String group : groups) {
-        Configuration config = entireConfiguration.get(group);
-        Set<String> groupJarNames = config.getJarNames();
-        String groupDirPath = FilenameUtils.concat(configDirPath, group);
-
-        for (String groupJarName : groupJarNames) {
-          Integer index = jarIndex.get(groupJarName);
-
-          if (index != null) {
-            String jarFilePath = FilenameUtils.concat(groupDirPath, groupJarName);
-            byte[] jarData = jarBytes[index.intValue()];
-
-            try {
-              FileUtils.writeByteArrayToFile(new File(jarFilePath), jarData);
-            } catch (IOException e) {
-              logger.info(e.getMessage(), e);
-            }
-          } else {
-            // This should NEVER happen
-            logger.error("JarFile {} not delivered.", groupJarName);
-          }
-        }
-      }
-    } else {
-      logger.info("No deployed jars found on other locators.");
-    }
+    // we should only get one byte[] back in the list
+    return result.stream()
+        .filter(Objects::nonNull)
+        .findFirst()
+        .orElse(null);
-   * 
-  private Region<String, Configuration> getConfigurationRegion() throws Exception {
+  private Region<String, Configuration> getConfigurationRegion() {
-      throw new Exception("Error occurred while initializing cluster configuration", e);
+      throw new RuntimeException("Error occurred while initializing cluster configuration", e);
-   * 
-   * @param configName
-   * @param configDirectory
-   * @throws TransformerException
-   * @throws TransformerFactoryConfigurationError
-   * @throws ParserConfigurationException
-   * @throws SAXException
-   * 
-   * @param propertiesFilePath
-   * @throws IOException
-   * 
-   * @throws TransformerException
-   * @throws TransformerFactoryConfigurationError
-   * @throws ParserConfigurationException
-   * @throws SAXException
-   * Removes the jar files from the given directory
-   * 
-   * @param dirPath Path of the configuration directory
-   * @param jarNames Names of the jar files
-   * @throws IOException
-   */
-  private void removeJarFiles(final String dirPath, final String[] jarNames) throws IOException {
-    if (jarNames != null) {
-      for (int i = 0; i < jarNames.length; i++) {
-        File jarFile = new File(FilenameUtils.concat(dirPath, jarNames[i]));
-        if (jarFile.exists()) {
-          FileUtils.forceDelete(jarFile);
-        }
-      }
-    } else {
-      File dir = new File(dirPath);
-      String[] jarFileNames = dir.list(jarFileFilter);
-      if (jarFileNames.length != 0) {
-        File jarFileToBeDeleted;
-        for (String jarFileName : jarFileNames) {
-          String fullPath = FilenameUtils.concat(dirPath, jarFileName);
-          jarFileToBeDeleted = new File(fullPath);
-          FileUtils.forceDelete(jarFileToBeDeleted);
-        }
-      }
-    }
-  }
-
-  /**
-   * Writes the cache.xml to the file , based on Configuration
-   */
-  private void writeCacheXml(final String dirPath, final Configuration configuration)
-      throws IOException {
-    String fullPath = FilenameUtils.concat(dirPath, configuration.getCacheXmlFileName());
-    FileUtils.writeStringToFile(new File(fullPath), configuration.getCacheXmlContent(), "UTF-8");
-  }
-
-  /**
-   * 
-      final byte[][] jarBytes) {
+                             final byte[][] jarBytes) {
-   * Writes the properties to the file based on the {@link Configuration}
-   */
-  private void writeProperties(final String dirPath, final Configuration configuration)
-      throws IOException {
-    String fullPath = FilenameUtils.concat(dirPath, configuration.getPropertiesFileName());
-    BufferedWriter bw = new BufferedWriter(new FileWriter(fullPath));
-    configuration.getGemfireProperties().store(bw, "");
-    bw.close();
-  }
-
-  /**
-   *
-   * 
-   *         the path is incorrect
+   * the path is incorrect

GEODE-1053: Adding "filter" on Function Rest Invoction
Refactoring of RestAPIOnRegionFunctionExecutionDUnitTest.java RestAPIsOnGroupsFunctionExecutionDUnitTest.java RestAPIsOnMembersFunctionExecutionDUnitTest.java.
Updating dependency-versions.properties http-core and http-client

-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
+import com.gemstone.gemfire.cache.LowMemoryException;
+import com.gemstone.gemfire.cache.execute.*;
+import com.gemstone.gemfire.internal.logging.LogService;
+import com.gemstone.gemfire.rest.internal.web.exception.GemfireRestException;
+import com.gemstone.gemfire.rest.internal.web.util.ArrayUtils;
+import com.gemstone.gemfire.rest.internal.web.util.JSONUtils;
+import com.wordnik.swagger.annotations.Api;
+import com.wordnik.swagger.annotations.ApiOperation;
+import com.wordnik.swagger.annotations.ApiResponse;
+import com.wordnik.swagger.annotations.ApiResponses;
+import org.json.JSONException;
-import org.springframework.web.bind.annotation.PathVariable;
-import org.springframework.web.bind.annotation.RequestBody;
-import org.springframework.web.bind.annotation.RequestMapping;
-import org.springframework.web.bind.annotation.RequestMethod;
-import org.springframework.web.bind.annotation.RequestParam;
-import org.springframework.web.bind.annotation.ResponseBody;
-import org.springframework.web.bind.annotation.ResponseStatus;
+import org.springframework.web.bind.annotation.*;
-import com.gemstone.gemfire.cache.LowMemoryException;
-import com.gemstone.gemfire.cache.execute.Execution;
-import com.gemstone.gemfire.cache.execute.Function;
-import com.gemstone.gemfire.cache.execute.FunctionException;
-import com.gemstone.gemfire.cache.execute.FunctionService;
-import com.gemstone.gemfire.cache.execute.ResultCollector;
-import com.gemstone.gemfire.internal.logging.LogService;
-import com.gemstone.gemfire.rest.internal.web.exception.GemfireRestException;
-import com.gemstone.gemfire.rest.internal.web.util.ArrayUtils;
-import com.gemstone.gemfire.rest.internal.web.util.JSONUtils;
-import org.json.JSONException;
-import com.wordnik.swagger.annotations.Api;
-import com.wordnik.swagger.annotations.ApiOperation;
-import com.wordnik.swagger.annotations.ApiResponse;
-import com.wordnik.swagger.annotations.ApiResponses;
+import java.util.*;
- * <p/>
+ * <p>
+ *
-   * <p/>
+   * <p>
+   *
-  
+
+   *
-  @RequestMapping(method = RequestMethod.GET,  produces = { MediaType.APPLICATION_JSON_VALUE })
+  @RequestMapping(method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
-    value = "list all functions",
-    notes = "list all functions available in the GemFire cluster",
-    response  = void.class
+      value = "list all functions",
+      notes = "list all functions available in the GemFire cluster",
+      response = void.class
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK." ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception." )   
-  } )
+  @ApiResponses({
+      @ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")
+  })
-    
-    if(logger.isDebugEnabled()){
+
+    if (logger.isDebugEnabled()) {
-    
+
-    String listFunctionsAsJson =  JSONUtils.formulateJsonForListFunctionsCall(registeredFunctions.keySet());
-    final HttpHeaders headers = new HttpHeaders();  
+    String listFunctionsAsJson = JSONUtils.formulateJsonForListFunctionsCall(registeredFunctions.keySet());
+    final HttpHeaders headers = new HttpHeaders();
-  } 
-  
+  }
+
-   * Arguments to the function are passed as JSON string in the request body. 
+   * Arguments to the function are passed as JSON string in the request body.
+   *
-   * @param region list of regions on which function to be executed.
-   * @param members list of nodes on which function to be executed.
-   * @param groups list of groups on which function to be executed. 
+   * @param region     list of regions on which function to be executed.
+   * @param members    list of nodes on which function to be executed.
+   * @param groups     list of groups on which function to be executed.
+   * @param filter     list of keys which the function will use to determine on which node to execute the function.
-    value = "execute function",
-    notes = "Execute function with arguments on regions, members, or group(s). By default function will be executed on all nodes if none of (onRegion, onMembers, onGroups) specified",
-    response  = void.class
+      value = "execute function",
+      notes = "Execute function with arguments on regions, members, or group(s). By default function will be executed on all nodes if none of (onRegion, onMembers, onGroups) specified",
+      response = void.class
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK." ),
-    @ApiResponse( code = 500, message = "if GemFire throws an error or exception" ),
-    @ApiResponse( code = 400, message = "if Function arguments specified as JSON document in the request body is invalid" )
-  } )
+  @ApiResponses({
+      @ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 500, message = "if GemFire throws an error or exception"),
+      @ApiResponse(code = 400, message = "if Function arguments specified as JSON document in the request body is invalid")
+  })
-                          @RequestParam(value = "onRegion", required = false ) String region,
-                          @RequestParam(value = "onMembers", required = false ) final String[] members,
-                          @RequestParam(value = "onGroups", required = false) final String[] groups,
-                          @RequestBody(required = false) final String argsInBody
-                          )
-  {
+      @RequestParam(value = "onRegion", required = false) String region,
+      @RequestParam(value = "onMembers", required = false) final String[] members,
+      @RequestParam(value = "onGroups", required = false) final String[] groups,
+      @RequestParam(value = "filter", required = false) final String[] filter,
+      @RequestBody(required = false) final String argsInBody
+  ) {
-    
+
-      if(logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-      
+
-      } catch(FunctionException fe){
+      } catch (FunctionException fe) {
-    }
-    else if (ArrayUtils.isNotEmpty(members)) {
-      if(logger.isDebugEnabled()){
+    } else if (ArrayUtils.isNotEmpty(members)) {
+      if (logger.isDebugEnabled()) {
-      try {            
+      try {
-      } catch(FunctionException fe){
-        throw new GemfireRestException("Could not found the specified members in disributed system!", fe);
+      } catch (FunctionException fe) {
+        throw new GemfireRestException("Could not found the specified members in distributed system!", fe);
-    }
-    else if (ArrayUtils.isNotEmpty(groups)) {
-      if(logger.isDebugEnabled()){
+    } else if (ArrayUtils.isNotEmpty(groups)) {
+      if (logger.isDebugEnabled()) {
-      } catch(FunctionException fe){
+      } catch (FunctionException fe) {
-    }
-    else {
+    } else {
-      if(logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-        
+
-      } catch(FunctionException fe) {
-        throw new GemfireRestException("Disributed system does not contain any valid data node to run the specified  function!", fe);
+      } catch (FunctionException fe) {
+        throw new GemfireRestException("Distributed system does not contain any valid data node to run the specified  function!", fe);
+    if (!ArrayUtils.isEmpty(filter)) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Executing Function ({}) with filter ({})", functionId,
+            ArrayUtils.toString(filter));
+      }
+      Set filter1 = ArrayUtils.asSet(filter);
+      function = function.withFilter(filter1);
+    }
+
-    
+
-      if(argsInBody != null) 
-      {
+      if (argsInBody != null) {
-        
+
-        if(args.length == 1){
+        if (args.length == 1) {
-      }else { 
+      } else {
-    } catch(ClassCastException cce){
+    } catch (ClassCastException cce) {
-    } catch(NullPointerException npe){
+    } catch (NullPointerException npe) {
-    } catch(LowMemoryException lme){
+    } catch (LowMemoryException lme) {
-    }catch (FunctionException fe){
+    } catch (FunctionException fe) {
-    
+
-    
-      if(functionResult instanceof List<?>) {
+
+      if (functionResult instanceof List<?>) {
-      
+
-          String functionResultAsJson = JSONUtils.convertCollectionToJson((ArrayList<Object>)functionResult);
-          return new ResponseEntity<String>(functionResultAsJson, headers, HttpStatus.OK);  
+          String functionResultAsJson = JSONUtils.convertCollectionToJson((ArrayList<Object>) functionResult);
+          return new ResponseEntity<String>(functionResultAsJson, headers, HttpStatus.OK);
-      }else {
+      } else {
-    }catch (FunctionException fe) {
+    } catch (FunctionException fe) {

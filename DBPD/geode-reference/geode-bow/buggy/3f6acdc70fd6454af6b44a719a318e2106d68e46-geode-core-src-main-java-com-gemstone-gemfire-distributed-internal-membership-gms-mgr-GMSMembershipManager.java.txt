Performance enhancements ported from GemFire 8.2.0.x

This increases throughput in GMSMembershipManager by avoiding write-locks
on the view in some places.

I also found GMSHealthMonitor was mistakenly referencing a CORBA class's "debug"
static variable and found an out-of-date comment in AnalyzeSerializablesJUnitTest.

-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.*;
-  
+  private final Lock latestViewReadLock = latestViewLock.readLock();
+  private final Lock latestViewWriteLock = latestViewLock.writeLock();
+
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-            latestViewLock.writeLock().lock();
+            latestViewWriteLock.lock();
-              latestViewLock.writeLock().unlock();
+              latestViewWriteLock.unlock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    // First grab the lock: check the sender against our stabilized view.
-    latestViewLock.writeLock().lock();
-    try {
-      if (isShunned(m)) {
-        if (msg instanceof StartupMessage) {
-          endShun(m);
+    // If this member is shunned or new, grab the latestViewWriteLock: update the appropriate data structure.
+    //    synchronized (latestViewLock) {
+    if (isShunnedOrNew(m)) {
+      latestViewWriteLock.lock();
+      try {
+        if (isShunned(m)) {
+          if (msg instanceof StartupMessage) {
+            endShun(m);
+          } else {
+            // fix for bug 41538 - sick alert listener causes deadlock
+            // due to view latestViewReadWriteLock being held during messaging
+            shunned = true;
+          }
-        else {
-          // fix for bug 41538 - sick alert listener causes deadlock
-          // due to view lock being held during messaging
-          shunned = true;
+
+        if (!shunned) {
+          // If it's a new sender, wait our turn, generate the event
+          if (isNew(m)) {
+            shunned = !addSurpriseMember(m);
+          }
-      } // isShunned
-
-      if (!shunned) {
-        isNew = !latestView.contains(m) && !surpriseMembers.containsKey(m);
-
-        // If it's a new sender, wait our turn, generate the event
-        if (isNew) {
-          shunned = !addSurpriseMember(m);
-        } // isNew
+      } finally {
+        latestViewWriteLock.unlock();
-
-      // Latch the view before we unlock
-    } finally {
-      latestViewLock.writeLock().unlock();
-    
+
-      logger.info("Membership: Ignoring message from shunned member <{}>:{}", m, msg);
+      if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_VIEWS)) {
+        logger.trace(LogMarker.DISTRIBUTION_VIEWS, "Membership: Ignoring message from shunned member <{}>:{}", m, msg);
+      }
-    
+
-  /**
-   * Process a new view object, or place on the startup queue
-   * @param viewArg the new view
-   */
+
+    /**
+     * Process a new view object, or place on the startup queue
+     * @param viewArg the new view
+     */
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-    latestViewLock.readLock().unlock();
+    latestViewReadLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-      latestViewLock.readLock().unlock();
+      latestViewReadLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-      latestViewLock.readLock().unlock();
+      latestViewReadLock.unlock();
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-    latestViewLock.readLock().unlock();
+    latestViewReadLock.unlock();
-        latestViewLock.writeLock().lock();
+        latestViewWriteLock.lock();
-          latestViewLock.writeLock().unlock();
+          latestViewWriteLock.unlock();
-      latestViewLock.writeLock().lock();
+      latestViewReadLock.lock();
-        latestViewLock.writeLock().unlock();
+        latestViewReadLock.unlock();
-          latestViewLock.readLock().lock();
+          latestViewReadLock.lock();
-            latestViewLock.readLock().unlock();
+            latestViewReadLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-    latestViewLock.writeLock().unlock();
+    latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-   * 
+   *
+   * @guarded.By latestViewLock
-    latestViewLock.writeLock().lock();
+    if (!shunnedMembers.containsKey(m)) {
+      return false;
+    }
+
+    latestViewWriteLock.lock();
-      if (!shunnedMembers.containsKey(m))
-        return false;
-      
-      if (shunTime + SHUNNED_SUNSET * 1000 > now)
+      if (shunTime + SHUNNED_SUNSET * 1000 > now) {
+      }
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
+  private final boolean isShunnedOrNew(final InternalDistributedMember m) {
+    latestViewReadLock.lock();
+    try {
+      return shunnedMembers.containsKey(m) || isNew(m);
+    } finally { // synchronized
+      latestViewReadLock.unlock();
+    }
+  }
+
+  // must be invoked under view read or write lock
+  private final boolean isNew(final InternalDistributedMember m) {
+    return !latestView.contains(m) && !surpriseMembers.containsKey(m);
+  }
+
-    latestViewLock.readLock().lock();
+    latestViewReadLock.lock();
-      latestViewLock.readLock().unlock();
+      latestViewReadLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-        latestViewLock.readLock().lock();
+        latestViewReadLock.lock();
-          latestViewLock.readLock().unlock();
+          latestViewReadLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();
-    latestViewLock.writeLock().lock();
+    latestViewWriteLock.lock();
-      latestViewLock.writeLock().unlock();
+      latestViewWriteLock.unlock();

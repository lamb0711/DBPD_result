Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Abstract implementation of both Serial and Parallel GatewaySender. It handles
- * common functionality like initializing proxy.
+ * Abstract implementation of both Serial and Parallel GatewaySender. It handles common
+ * functionality like initializing proxy.
-public abstract class AbstractGatewaySender implements GatewaySender,
-    DistributionAdvisee {
+public abstract class AbstractGatewaySender implements GatewaySender, DistributionAdvisee {
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  private org.apache.geode.internal.cache.GatewayEventFilter filter = DefaultGatewayEventFilter.getInstance();
-  
+
+  private org.apache.geode.internal.cache.GatewayEventFilter filter =
+      DefaultGatewayEventFilter.getInstance();
+
-  
+
-  
-  protected volatile boolean enqueuedAllTempQueueEvents = false; 
-  
-  protected volatile ConcurrentLinkedQueue<TmpQueueEvent> tmpQueuedEvents = new ConcurrentLinkedQueue<>();
+
+  protected volatile boolean enqueuedAllTempQueueEvents = false;
+
+  protected volatile ConcurrentLinkedQueue<TmpQueueEvent> tmpQueuedEvents =
+      new ConcurrentLinkedQueue<>();
-   * The number of seconds to wait before stopping the GatewaySender.
-   * Default is 0 seconds.
+   * The number of seconds to wait before stopping the GatewaySender. Default is 0 seconds.
-  public static int MAXIMUM_SHUTDOWN_WAIT_TIME = Integer.getInteger(
-		  "GatewaySender.MAXIMUM_SHUTDOWN_WAIT_TIME", 0).intValue();
+  public static int MAXIMUM_SHUTDOWN_WAIT_TIME =
+      Integer.getInteger("GatewaySender.MAXIMUM_SHUTDOWN_WAIT_TIME", 0).intValue();
-  protected static final int MAXIMUM_SHUTDOWN_PEEKS = Integer.getInteger(
-      "GatewaySender.MAXIMUM_SHUTDOWN_PEEKS", 20).intValue();
-  
-  public static final int QUEUE_SIZE_THRESHOLD = Integer.getInteger(
-      "GatewaySender.QUEUE_SIZE_THRESHOLD", 5000).intValue();
+  protected static final int MAXIMUM_SHUTDOWN_PEEKS =
+      Integer.getInteger("GatewaySender.MAXIMUM_SHUTDOWN_PEEKS", 20).intValue();
-  public static int TOKEN_TIMEOUT = Integer.getInteger(
-      "GatewaySender.TOKEN_TIMEOUT", 15000).intValue();
+  public static final int QUEUE_SIZE_THRESHOLD =
+      Integer.getInteger("GatewaySender.QUEUE_SIZE_THRESHOLD", 5000).intValue();
+
+  public static int TOKEN_TIMEOUT =
+      Integer.getInteger("GatewaySender.TOKEN_TIMEOUT", 15000).intValue();
-   * The name of the DistributedLockService used when accessing the GatewaySender's
-   * meta data region.
+   * The name of the DistributedLockService used when accessing the GatewaySender's meta data
+   * region.
-  
+
-  
+
-  
+
-  
+
-   * A unique (per <code>GatewaySender</code> id) index used when modifying
-   * <code>EventIDs</code>. Unlike the serialNumber, the eventIdIndex matches
-   * for the same <code>GatewaySender</code> across all members of the
-   * <code>DistributedSystem</code>.
+   * A unique (per <code>GatewaySender</code> id) index used when modifying <code>EventIDs</code>.
+   * Unlike the serialNumber, the eventIdIndex matches for the same <code>GatewaySender</code>
+   * across all members of the <code>DistributedSystem</code>.
-   
-  /** 
-   * A <code>Region</code> used for storing <code>GatewaySender</code> event id
-   * indexes. This <code>Region</code> along with a <code>DistributedLock</code>
-   * facilitates creation of unique indexes across members.
+
+  /**
+   * A <code>Region</code> used for storing <code>GatewaySender</code> event id indexes. This
+   * <code>Region</code> along with a <code>DistributedLock</code> facilitates creation of unique
+   * indexes across members.
-  private Region<String,Integer> eventIdIndexMetaDataRegion;
-  
+  private Region<String, Integer> eventIdIndexMetaDataRegion;
+
-  protected AbstractGatewaySender() {
-  }
+  protected AbstractGatewaySender() {}
-  public AbstractGatewaySender(Cache cache, GatewaySenderAttributes attrs){
+  public AbstractGatewaySender(Cache cache, GatewaySenderAttributes attrs) {
-    //divide the maximumQueueMemory of sender equally using number of dispatcher threads.
-    //if dispatcherThreads is 1 then maxMemoryPerDispatcherQueue will be same as maximumQueueMemory of sender
+    // divide the maximumQueueMemory of sender equally using number of dispatcher threads.
+    // if dispatcherThreads is 1 then maxMemoryPerDispatcherQueue will be same as maximumQueueMemory
+    // of sender
-    this.myDSId = InternalDistributedSystem.getAnyInstance().getDistributionManager().getDistributedSystemId();
+    this.myDSId = InternalDistributedSystem.getAnyInstance().getDistributionManager()
+        .getDistributedSystemId();
-        this.statistics = new GatewaySenderStats(cache.getDistributedSystem(),
-            id);
+        this.statistics = new GatewaySenderStats(cache.getDistributedSystem(), id);
-  
+
-    //no op
+    // no op
-  
-  public void setIsPrimary(boolean isPrimary){
+
+  public void setIsPrimary(boolean isPrimary) {
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  }  
-    
+  }
+
-  
+
-  
+
-  
+
-  
+
-    return (InternalDistributedSystem)this.cache.getDistributedSystem();
+    return (InternalDistributedSystem) this.cache.getDistributedSystem();
-  
+
-  
+
-    AbstractGatewaySender sender = (AbstractGatewaySender)obj;
+    AbstractGatewaySender sender = (AbstractGatewaySender) obj;
-  
+
-  
+
+
-  
+
-   * Destroys the GatewaySender. Before destroying the sender, caller needs to to ensure 
-   * that the sender is stopped so that all the resources (threads, connection pool etc.) 
-   * will be released properly. Stopping the sender is not handled in the destroy.
-   * Destroy is carried out in following steps:
-   * 1. Take the lifeCycleLock. 
-   * 2. If the sender is attached to any application region, throw an exception.
-   * 3. Close the GatewaySenderAdvisor.
-   * 4. Remove the sender from the cache.
-   * 5. Destroy the region underlying the GatewaySender.
+   * Destroys the GatewaySender. Before destroying the sender, caller needs to to ensure that the
+   * sender is stopped so that all the resources (threads, connection pool etc.) will be released
+   * properly. Stopping the sender is not handled in the destroy. Destroy is carried out in
+   * following steps: 1. Take the lifeCycleLock. 2. If the sender is attached to any application
+   * region, throw an exception. 3. Close the GatewaySenderAdvisor. 4. Remove the sender from the
+   * cache. 5. Destroy the region underlying the GatewaySender.
-   * In case of ParallelGatewaySender, the destroy operation does distributed destroy of the 
-   * QPR. In case of SerialGatewaySender, the queue region is destroyed locally.
+   * In case of ParallelGatewaySender, the destroy operation does distributed destroy of the QPR. In
+   * case of SerialGatewaySender, the queue region is destroyed locally.
-      Set<LocalRegion> regions = ((GemFireCacheImpl)this.cache)
-          .getApplicationRegions();
+      Set<LocalRegion> regions = ((GemFireCacheImpl) this.cache).getApplicationRegions();
-        LocalRegion region = (LocalRegion)regionItr.next();
+        LocalRegion region = (LocalRegion) regionItr.next();
-      ((GemFireCacheImpl)this.cache).removeGatewaySender(this);
+      ((GemFireCacheImpl) this.cache).removeGatewaySender(this);
-              Set<PartitionedRegion> queueRegions = ((ConcurrentParallelGatewaySenderQueue)regionQueue)
-                  .getRegions();
+              Set<PartitionedRegion> queueRegions =
+                  ((ConcurrentParallelGatewaySenderQueue) regionQueue).getRegions();
-            }
-            else {// For SerialGatewaySenderQueue, do local destroy
+            } else {// For SerialGatewaySenderQueue, do local destroy
-            this
-                .logger.info(LocalizedMessage.create(LocalizedStrings.AbstractGatewaySender_REGION_0_UNDERLYING_GATEWAYSENDER_1_IS_ALREADY_DESTROYED,
-                    new Object[] { e.getRegionFullPath(), this }));
+            this.logger.info(LocalizedMessage.create(
+                LocalizedStrings.AbstractGatewaySender_REGION_0_UNDERLYING_GATEWAYSENDER_1_IS_ALREADY_DESTROYED,
+                new Object[] {e.getRegionFullPath(), this}));
-      }//END if (regionQueues != null)
-    }
-    finally {
+      } // END if (regionQueues != null)
+    } finally {
-  
+
-    logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_GATEWAY_0_HAS_BEEN_REBALANCED, this));
+    logger.info(
+        LocalizedMessage.create(LocalizedStrings.GatewayImpl_GATEWAY_0_HAS_BEEN_REBALANCED, this));
-  
+
-    logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_GATEWAY_0_IS_NOT_CLOSING_CLEANLY_FORCING_CANCELLATION, this));
+    logger.warn(LocalizedMessage.create(
+        LocalizedStrings.GatewayImpl_GATEWAY_0_IS_NOT_CLOSING_CLEANLY_FORCING_CANCELLATION, this));
-  
+
-  
+
-  
+
-  
+
-      }
-      else {
-        throw new IllegalArgumentException(
-            "getQueue() for concurrent serial gateway sender");
+      } else {
+        throw new IllegalArgumentException("getQueue() for concurrent serial gateway sender");
-      return ((ConcurrentSerialGatewaySenderEventProcessor)this.eventProcessor)
-          .getQueues();
+      return ((ConcurrentSerialGatewaySenderEventProcessor) this.eventProcessor).getQueues();
-  
+
-      return ((ConcurrentSerialGatewaySenderEventProcessor)this.eventProcessor)
-          .getQueues();
+      return ((ConcurrentSerialGatewaySenderEventProcessor) this.eventProcessor).getQueues();
-  
+
-      while (this.eventProcessor.getException() == null
-          && this.eventProcessor.isStopped()) {
+      while (this.eventProcessor.getException() == null && this.eventProcessor.isStopped()) {
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-                .toLocalizedString(new Object[] { this.getId(), ex.getMessage() }),
+                .toLocalizedString(new Object[] {this.getId(), ex.getMessage()}),
-  
+
-        InternalDistributedSystem system = (InternalDistributedSystem) this.cache
-            .getDistributedSystem();
+        InternalDistributedSystem system =
+            (InternalDistributedSystem) this.cache.getDistributedSystem();
-        
+
-        
-        InternalDistributedSystem system = (InternalDistributedSystem) this.cache
-            .getDistributedSystem();
+
+        InternalDistributedSystem system =
+            (InternalDistributedSystem) this.cache.getDistributedSystem();
-        
+
-        
+
-  
+
+   * 
-    if (event.getRegion().getDataPolicy().equals(DataPolicy.NORMAL))
-    {
+    if (event.getRegion().getDataPolicy().equals(DataPolicy.NORMAL)) {
-      if (event.getOperation().isExpiration() && this.isAsyncEventQueue() && this.isForwardExpirationDestroy()) {
+      if (event.getOperation().isExpiration() && this.isAsyncEventQueue()
+          && this.isForwardExpirationDestroy()) {
-    @Released EntryEventImpl clonedEvent = new EntryEventImpl(event, false);
+    @Released
+    EntryEventImpl clonedEvent = new EntryEventImpl(event, false);
-    Region region = event.getRegion();
+      Region region = event.getRegion();
-    setModifiedEventId(clonedEvent);
-    Object callbackArg = clonedEvent.getRawCallbackArgument();
+      setModifiedEventId(clonedEvent);
+      Object callbackArg = clonedEvent.getRawCallbackArgument();
-    if (isDebugEnabled) {
-      // We can't deserialize here for logging purposes so don't
-      // call getNewValue.
-      // event.getNewValue(); // to deserialize the value if necessary
-      logger.debug("{} : About to notify {} to perform operation {} for {} callback arg {}",
-          this.isPrimary(), getId(), operation, clonedEvent, callbackArg);
-    }
-
-    if (callbackArg instanceof GatewaySenderEventCallbackArgument) {
-      GatewaySenderEventCallbackArgument seca = (GatewaySenderEventCallbackArgument)callbackArg;
-        logger.debug("{}: Event originated in {}. My DS id is {}. The remote DS id is {}. The recipients are: {}",
-            this, seca.getOriginatingDSId(), this.getMyDSId(), this.getRemoteDSId(), seca.getRecipientDSIds());
+        // We can't deserialize here for logging purposes so don't
+        // call getNewValue.
+        // event.getNewValue(); // to deserialize the value if necessary
+        logger.debug("{} : About to notify {} to perform operation {} for {} callback arg {}",
+            this.isPrimary(), getId(), operation, clonedEvent, callbackArg);
-      if (seca.getOriginatingDSId() == DEFAULT_DISTRIBUTED_SYSTEM_ID) {
-        if (isDebugEnabled) {
-          logger.debug("{}: Event originated in {}. My DS id is {}. The remote DS id is {}. The recipients are: {}",
-              this, seca.getOriginatingDSId(), this.getMyDSId(), this.getRemoteDSId(), seca.getRecipientDSIds());
-        }
-        seca.setOriginatingDSId(this.getMyDSId());
-        seca.initializeReceipientDSIds(allRemoteDSIds);
+      if (callbackArg instanceof GatewaySenderEventCallbackArgument) {
+        GatewaySenderEventCallbackArgument seca = (GatewaySenderEventCallbackArgument) callbackArg;
+        if (isDebugEnabled) {
+          logger.debug(
+              "{}: Event originated in {}. My DS id is {}. The remote DS id is {}. The recipients are: {}",
+              this, seca.getOriginatingDSId(), this.getMyDSId(), this.getRemoteDSId(),
+              seca.getRecipientDSIds());
+        }
+        if (seca.getOriginatingDSId() == DEFAULT_DISTRIBUTED_SYSTEM_ID) {
+          if (isDebugEnabled) {
+            logger.debug(
+                "{}: Event originated in {}. My DS id is {}. The remote DS id is {}. The recipients are: {}",
+                this, seca.getOriginatingDSId(), this.getMyDSId(), this.getRemoteDSId(),
+                seca.getRecipientDSIds());
+          }
+
+          seca.setOriginatingDSId(this.getMyDSId());
+          seca.initializeReceipientDSIds(allRemoteDSIds);
-          //if the dispatcher is GatewaySenderEventCallbackDispatcher (which is the case of WBCL), skip the below check of remoteDSId.
-          //Fix for #46517
+          // if the dispatcher is GatewaySenderEventCallbackDispatcher (which is the case of WBCL),
+          // skip the below check of remoteDSId.
+          // Fix for #46517
-        if (ep != null && !(ep.getDispatcher() instanceof GatewaySenderEventCallbackDispatcher)) {
-          if (seca.getOriginatingDSId() == this.getRemoteDSId()) {
-            if (isDebugEnabled) {
-              logger.debug("{}: Event originated in {}. My DS id is {}. It is being dropped as remote is originator.",
-                  this, seca.getOriginatingDSId(), getMyDSId());
+          if (ep != null && !(ep.getDispatcher() instanceof GatewaySenderEventCallbackDispatcher)) {
+            if (seca.getOriginatingDSId() == this.getRemoteDSId()) {
+              if (isDebugEnabled) {
+                logger.debug(
+                    "{}: Event originated in {}. My DS id is {}. It is being dropped as remote is originator.",
+                    this, seca.getOriginatingDSId(), getMyDSId());
+              }
+              return;
+            } else if (seca.getRecipientDSIds().contains(this.getRemoteDSId())) {
+              if (isDebugEnabled) {
+                logger.debug(
+                    "{}: Event originated in {}. My DS id is {}. The remote DS id is {}.. It is being dropped as remote ds is already a recipient. Recipients are: {}",
+                    this, seca.getOriginatingDSId(), getMyDSId(), this.getRemoteDSId(),
+                    seca.getRecipientDSIds());
+              }
+              return;
-            return;
-          } else if (seca.getRecipientDSIds().contains(this.getRemoteDSId())) {
-            if (isDebugEnabled) {
-              logger.debug("{}: Event originated in {}. My DS id is {}. The remote DS id is {}.. It is being dropped as remote ds is already a recipient. Recipients are: {}",
-                  this, seca.getOriginatingDSId(), getMyDSId(), this.getRemoteDSId(), seca.getRecipientDSIds());
-            }
-            return;
+          seca.getRecipientDSIds().addAll(allRemoteDSIds);
-        seca.getRecipientDSIds().addAll(allRemoteDSIds);
-      }
-    } else {
-      GatewaySenderEventCallbackArgument geCallbackArg = new GatewaySenderEventCallbackArgument(
-          callbackArg, this.getMyDSId(), allRemoteDSIds);
-      clonedEvent.setCallbackArgument(geCallbackArg);
-    }
-
-    if (!this.getLifeCycleLock().readLock().tryLock()) {
-      synchronized (this.queuedEventsSync) {
-        if (!this.enqueuedAllTempQueueEvents) {
-          if (!this.getLifeCycleLock().readLock().tryLock()) {
-            Object substituteValue = getSubstituteValue(clonedEvent, operation);
-            this.tmpQueuedEvents.add(new TmpQueueEvent(operation, clonedEvent, substituteValue));
-            freeClonedEvent = false;
-            stats.incTempQueueSize();
-            if (isDebugEnabled) {
-              logger.debug("Event : {} is added to TempQueue", clonedEvent);
-            }
-            return;
-          }
-        }
-      }
-      if(this.enqueuedAllTempQueueEvents) {
-        this.getLifeCycleLock().readLock().lock();
-      }
-    }
-    try {
-      // If this gateway is not running, return
-      // The sender may have stopped, after we have checked the status in the beginning. 
-      if (!isRunning()) {
-        if (isDebugEnabled) {
-          logger.debug("Returning back without putting into the gateway sender queue");
-        }
-        return;
+      } else {
+        GatewaySenderEventCallbackArgument geCallbackArg =
+            new GatewaySenderEventCallbackArgument(callbackArg, this.getMyDSId(), allRemoteDSIds);
+        clonedEvent.setCallbackArgument(geCallbackArg);
+      if (!this.getLifeCycleLock().readLock().tryLock()) {
+        synchronized (this.queuedEventsSync) {
+          if (!this.enqueuedAllTempQueueEvents) {
+            if (!this.getLifeCycleLock().readLock().tryLock()) {
+              Object substituteValue = getSubstituteValue(clonedEvent, operation);
+              this.tmpQueuedEvents.add(new TmpQueueEvent(operation, clonedEvent, substituteValue));
+              freeClonedEvent = false;
+              stats.incTempQueueSize();
+              if (isDebugEnabled) {
+                logger.debug("Event : {} is added to TempQueue", clonedEvent);
+              }
+              return;
+            }
+          }
+        }
+        if (this.enqueuedAllTempQueueEvents) {
+          this.getLifeCycleLock().readLock().lock();
+        }
+      }
-        AbstractGatewaySenderEventProcessor ev = this.eventProcessor;
-        if (ev == null) {
-          getStopper().checkCancelInProgress(null);
-          this.getCache().getDistributedSystem().getCancelCriterion()
-              .checkCancelInProgress(null);
-          // event processor will be null if there was an authorization
-          // problem
-          // connecting to the other site (bug #40681)
-          if (ev == null) {
-            throw new GatewayCancelledException(
-                "Event processor thread is gone");
+        // If this gateway is not running, return
+        // The sender may have stopped, after we have checked the status in the beginning.
+        if (!isRunning()) {
+          if (isDebugEnabled) {
+            logger.debug("Returning back without putting into the gateway sender queue");
+          return;
-        
-        // Get substitution value to enqueue if necessary
-        Object substituteValue = getSubstituteValue(clonedEvent, operation);
-        
-        ev.enqueueEvent(operation, clonedEvent, substituteValue);
-      } catch (CancelException e) {
-        logger.debug("caught cancel exception", e);
-      } catch (RegionDestroyedException e) {
-        logger.warn(LocalizedMessage.create(
-        LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
-        new Object[] { this, getId(), operation, clonedEvent }), e);
-      } catch (Exception e) {
-        logger.fatal(LocalizedMessage.create(
-                LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
-                new Object[] { this, getId(), operation, clonedEvent }), e);
+
+        try {
+          AbstractGatewaySenderEventProcessor ev = this.eventProcessor;
+          if (ev == null) {
+            getStopper().checkCancelInProgress(null);
+            this.getCache().getDistributedSystem().getCancelCriterion().checkCancelInProgress(null);
+            // event processor will be null if there was an authorization
+            // problem
+            // connecting to the other site (bug #40681)
+            if (ev == null) {
+              throw new GatewayCancelledException("Event processor thread is gone");
+            }
+          }
+
+          // Get substitution value to enqueue if necessary
+          Object substituteValue = getSubstituteValue(clonedEvent, operation);
+
+          ev.enqueueEvent(operation, clonedEvent, substituteValue);
+        } catch (CancelException e) {
+          logger.debug("caught cancel exception", e);
+        } catch (RegionDestroyedException e) {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
+              new Object[] {this, getId(), operation, clonedEvent}), e);
+        } catch (Exception e) {
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
+              new Object[] {this, getId(), operation, clonedEvent}), e);
+        }
+      } finally {
+        this.getLifeCycleLock().readLock().unlock();
-      this.getLifeCycleLock().readLock().unlock();
-    }
-    } finally {
-  
+
-   * During sender is getting started, if there are any cache operation on queue then that event will be stored in temp queue. 
-   * Once sender is started, these event from tmp queue will be added to sender queue.
+   * During sender is getting started, if there are any cache operation on queue then that event
+   * will be stored in temp queue. Once sender is started, these event from tmp queue will be added
+   * to sender queue.
-   * Apart from sender's start() method, this method also gets called from ParallelGatewaySenderQueue.addPartitionedRegionForRegion(). 
-   * This is done to support the postCreateRegion scenario i.e. the sender is already running and region is created later.
-   * The eventProcessor can be null when the method gets invoked through this flow: 
-   * ParallelGatewaySenderImpl.start() -> ParallelGatewaySenderQueue.<init> -> ParallelGatewaySenderQueue.addPartitionedRegionForRegion 
+   * Apart from sender's start() method, this method also gets called from
+   * ParallelGatewaySenderQueue.addPartitionedRegionForRegion(). This is done to support the
+   * postCreateRegion scenario i.e. the sender is already running and region is created later. The
+   * eventProcessor can be null when the method gets invoked through this flow:
+   * ParallelGatewaySenderImpl.start() -> ParallelGatewaySenderQueue.<init> ->
+   * ParallelGatewaySenderQueue.addPartitionedRegionForRegion
-    if (this.eventProcessor != null) {//Fix for defect #47308
+    if (this.eventProcessor != null) {// Fix for defect #47308
-          try {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Event :{} is enqueued to GatewaySenderQueue from TempQueue", nextEvent);
+            try {
+              if (logger.isDebugEnabled()) {
+                logger.debug("Event :{} is enqueued to GatewaySenderQueue from TempQueue",
+                    nextEvent);
+              }
+              stats.decTempQueueSize();
+              this.eventProcessor.enqueueEvent(nextEvent.getOperation(), nextEvent.getEvent(),
+                  nextEvent.getSubstituteValue());
+            } finally {
+              nextEvent.release();
-            stats.decTempQueueSize();
-            this.eventProcessor.enqueueEvent(nextEvent.getOperation(),
-                nextEvent.getEvent(), nextEvent.getSubstituteValue());
-          } finally {
-            nextEvent.release();
-          }
-      }
-      catch (CacheException e) {
+      } catch (CacheException e) {
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-                new Object[] { this, getId(), nextEvent.getOperation(), nextEvent }), e);
+            new Object[] {this, getId(), nextEvent.getOperation(), nextEvent}), e);
-  
+
-   * Removes the EntryEventImpl, whose tailKey matches with the provided tailKey, 
-   * from tmpQueueEvents. 
+   * Removes the EntryEventImpl, whose tailKey matches with the provided tailKey, from
+   * tmpQueueEvents.
+   * 
-            logger.debug("shadowKey {} is found in tmpQueueEvents at AbstractGatewaySender level. Removing from there..", tailKey);
+            logger.debug(
+                "shadowKey {} is found in tmpQueueEvents at AbstractGatewaySender level. Removing from there..",
+                tailKey);
-  
+
-   * During sender is getting stopped, if there are any cache operation on queue then that event will be stored in temp queue. 
-   * Once sender is started, these event from tmp queue will be cleared.
+   * During sender is getting stopped, if there are any cache operation on queue then that event
+   * will be stored in temp queue. Once sender is started, these event from tmp queue will be
+   * cleared.
-    
+
-  
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
-                new Object[] { this, getId(), operation, clonedEvent }), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
+            new Object[] {this, getId(), operation, clonedEvent}), e);
-  
+
-    
+
-      gotLock = ((GemFireCacheImpl) getCache()).getGatewaySenderLockService().lock(META_DATA_REGION_NAME, -1, -1);
+      gotLock = ((GemFireCacheImpl) getCache()).getGatewaySenderLockService()
+          .lock(META_DATA_REGION_NAME, -1, -1);
-      } else { 
+      } else {
-        Region<String,Integer> region = getEventIdIndexMetaDataRegion();
-        
+        Region<String, Integer> region = getEventIdIndexMetaDataRegion();
+
-        
+
-  private Region<String,Integer> getEventIdIndexMetaDataRegion() {
+  private Region<String, Integer> getEventIdIndexMetaDataRegion() {
-  @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" })
+  @SuppressWarnings({"rawtypes", "unchecked", "deprecation"})
-    Region<String,Integer> region = cache.getRegion(META_DATA_REGION_NAME);
+    Region<String, Integer> region = cache.getRegion(META_DATA_REGION_NAME);
-          return new CachePerfStats(cache.getDistributedSystem(),
-              META_DATA_REGION_NAME);
+          return new CachePerfStats(cache.getDistributedSystem(), META_DATA_REGION_NAME);
-      
+
-      InternalRegionArguments ira = new InternalRegionArguments()
-          .setIsUsedForMetaRegion(true).setCachePerfStatsHolder(statsHolder);
+      InternalRegionArguments ira = new InternalRegionArguments().setIsUsedForMetaRegion(true)
+          .setCachePerfStatsHolder(statsHolder);
-  
-  public static class DefaultGatewayEventFilter implements org.apache.geode.internal.cache.GatewayEventFilter {
+
+  public static class DefaultGatewayEventFilter
+      implements org.apache.geode.internal.cache.GatewayEventFilter {
-    private DefaultGatewayEventFilter() {
-    }
+    private DefaultGatewayEventFilter() {}
-  
+
-  
-  public int getEventQueueSize() { 
+
+  public int getEventQueueSize() {
-  
+
-  
+
+
-  public static class EventWrapper  {
+  public static class EventWrapper {
-    static private final int EVENT_TIMEOUT
-      = Integer.getInteger("Gateway.EVENT_TIMEOUT", 5 * 60 * 1000).intValue();
+    static private final int EVENT_TIMEOUT =
+        Integer.getInteger("Gateway.EVENT_TIMEOUT", 5 * 60 * 1000).intValue();
+
-  
+
-   * Instances of this class allow us to delay queuing an incoming event.
-   * What used to happen was that the tmpQ would have a GatewaySenderEventImpl
-   * added to it. But then when we took it out we had to ask it for its EntryEventImpl.
-   * Then we created another GatewaySenderEventImpl.
-   * As part of the off-heap work, the GatewaySenderEventImpl no longer has a EntryEventImpl.
-   * So this class allows us to defer creation of the GatewaySenderEventImpl until we
-   * are ready to actually enqueue it.
-   * The caller is responsible for giving us an EntryEventImpl that we own and that
-   * we will release. This is done by making a copy/clone of the original event.
-   * This fixes bug 52029.
+   * Instances of this class allow us to delay queuing an incoming event. What used to happen was
+   * that the tmpQ would have a GatewaySenderEventImpl added to it. But then when we took it out we
+   * had to ask it for its EntryEventImpl. Then we created another GatewaySenderEventImpl. As part
+   * of the off-heap work, the GatewaySenderEventImpl no longer has a EntryEventImpl. So this class
+   * allows us to defer creation of the GatewaySenderEventImpl until we are ready to actually
+   * enqueue it. The caller is responsible for giving us an EntryEventImpl that we own and that we
+   * will release. This is done by making a copy/clone of the original event. This fixes bug 52029.
+
-    
+
-    
+
-    
+

GEODE-6626: Cleanup AcceptorImpl warnings

Co-authored-by: Mark Hanson <mhanson@pivotal.io>

+import java.nio.channels.AsynchronousCloseException;
-  public static final int CLIENT_QUEUE_INITIALIZATION_POOL_SIZE = 16;
+  private static final int CLIENT_QUEUE_INITIALIZATION_POOL_SIZE = 16;
-  protected final CacheServerStats stats;
+  private final CacheServerStats stats;
-  private ServerSocket serverSock = null;
+  private ServerSocket serverSock;
-  protected final InternalCache cache;
+  private final InternalCache cache;
-  private final LinkedBlockingQueue commBufferQueue;
+  private final LinkedBlockingQueue<ByteBuffer> commBufferQueue;
-  private final LinkedBlockingQueue selectorQueue;
+  private final LinkedBlockingQueue<ServerConnection> selectorQueue;
-  private final HashSet selectorRegistrations;
+  private final Set<ServerConnection> selectorRegistrations;
-  public static final String HANDSHAKE_TIMEOUT_PROPERTY_NAME = "BridgeServer.handShakeTimeout";
+  private static final String HANDSHAKE_TIMEOUT_PROPERTY_NAME = "BridgeServer.handShakeTimeout";
-  public static final int DEFAULT_HANDSHAKE_TIMEOUT_MS = 59000;
+  private static final int DEFAULT_HANDSHAKE_TIMEOUT_MS = 59000;
-  protected static final int handshakeTimeout =
-      Integer.getInteger(HANDSHAKE_TIMEOUT_PROPERTY_NAME, DEFAULT_HANDSHAKE_TIMEOUT_MS).intValue();
+  private static final int handshakeTimeout =
+      Integer.getInteger(HANDSHAKE_TIMEOUT_PROPERTY_NAME, DEFAULT_HANDSHAKE_TIMEOUT_MS);
-  public static final int DEFAULT_ACCEPT_TIMEOUT_MS = 9900;
+  private static final int DEFAULT_ACCEPT_TIMEOUT_MS = 9900;
-      Integer.getInteger(ACCEPT_TIMEOUT_PROPERTY_NAME, DEFAULT_ACCEPT_TIMEOUT_MS).intValue();
+      Integer.getInteger(ACCEPT_TIMEOUT_PROPERTY_NAME, DEFAULT_ACCEPT_TIMEOUT_MS);
-  public static final int MINIMUM_MAX_CONNECTIONS = 16;
+  static final int MINIMUM_MAX_CONNECTIONS = 16;
-  private CacheClientNotifier clientNotifier;
+  private final CacheClientNotifier clientNotifier;
-  public static final String BACKLOG_PROPERTY_NAME = "BridgeServer.backlog";
+  private static final String BACKLOG_PROPERTY_NAME = "BridgeServer.backlog";
-  public static final String CHECK_REGISTERED_KEYS_INTERVAL_NAME =
+  private static final String CHECK_REGISTERED_KEYS_INTERVAL_NAME =
-  public static final int DEFAULT_CHECK_REGISTERED_KEYS_INTERVAL_NS = 0;
+  private static final int DEFAULT_CHECK_REGISTERED_KEYS_INTERVAL_NS = 0;
-      .getLong(CHECK_REGISTERED_KEYS_INTERVAL_NAME, DEFAULT_CHECK_REGISTERED_KEYS_INTERVAL_NS)
-      .longValue();
+      .getLong(CHECK_REGISTERED_KEYS_INTERVAL_NAME, DEFAULT_CHECK_REGISTERED_KEYS_INTERVAL_NS);
-  public final AtomicInteger clientServerCnxCount = new AtomicInteger();
+  private final AtomicInteger clientServerCnxCount = new AtomicInteger();
-  private volatile boolean shutdownStarted = false;
+  private volatile boolean shutdownStarted;
-  private Thread thread = null;
+  private Thread thread;
-  private Thread selectorThread = null;
+  private Thread selectorThread;
-  private final HashSet allSCs = new HashSet();
+  private final Set<ServerConnection> allSCs = new HashSet<>();
-  private volatile ServerConnection allSCList[] = new ServerConnection[0];
+  private volatile ServerConnection[] allSCList = new ServerConnection[0];
-   * The ip address or host name this acceptor is to bind to; <code>null</code> or "" indicates it
+   * The ip address or host name this acceptor is to bind to; {@code null} or "" indicates it
-  private boolean isGatewayReceiver;
-  private List<GatewayTransportFilter> gatewayTransportFilters;
+  private final boolean isGatewayReceiver;
+  private final List<GatewayTransportFilter> gatewayTransportFilters;
-   * @param port The port on which this acceptor listens for connections. If <code>0</code>, a
+   * @param port The port on which this acceptor listens for connections. If {@code 0}, a
-   *        <code>null</code> or "" then all local addresses are used
+   *        {@code null} or "" then all local addresses are used
-   *        <code>ClientHealthMonitor</code> to monitor the health of this server's clients.
+   *        {@code ClientHealthMonitor} to monitor the health of this server's clients.
-    this.securityService = internalCache.getSecurityService();
+    securityService = internalCache.getSecurityService();
-    this.connectionListener = listener == null ? new ConnectionListenerAdapter() : listener;
+    connectionListener = listener == null ? new ConnectionListenerAdapter() : listener;
-    this.gatewayTransportFilters = transportFilter;
+    gatewayTransportFilters = transportFilter;
-        if (os.indexOf("Windows") != -1) {
+        if (os.contains("Windows")) {
-      // Selector tmp2_s = null;
-      LinkedBlockingQueue tmp_q = null;
-      LinkedBlockingQueue tmp_commQ = null;
-      HashSet tmp_hs = null;
+      LinkedBlockingQueue<ServerConnection> tmp_q = null;
+      LinkedBlockingQueue<ByteBuffer> tmp_commQ = null;
+      Set<ServerConnection> tmp_hs = null;
-        // tmp2_s = Selector.open(); // workaround for bug 39624
-        tmp_q = new LinkedBlockingQueue();
-        tmp_commQ = new LinkedBlockingQueue();
-        tmp_hs = new HashSet(512);
+        tmp_q = new LinkedBlockingQueue<>();
+        tmp_commQ = new LinkedBlockingQueue<>();
+        tmp_hs = new HashSet<>(512);
-      this.selector = tmp_s;
-      // this.tmpSel = tmp2_s;
-      this.selectorQueue = tmp_q;
-      this.commBufferQueue = tmp_commQ;
-      this.selectorRegistrations = tmp_hs;
-      this.hsTimer = tmp_timer;
+      selector = tmp_s;
+      selectorQueue = tmp_q;
+      commBufferQueue = tmp_commQ;
+      selectorRegistrations = tmp_hs;
+      hsTimer = tmp_timer;
-        this.socketCreator =
+        socketCreator =
-        this.socketCreator = SocketCreatorFactory
+        socketCreator = SocketCreatorFactory
-      final int backLog = Integer.getInteger(BACKLOG_PROPERTY_NAME, DEFAULT_BACKLOG).intValue();
+      final int backLog = Integer.getInteger(BACKLOG_PROPERTY_NAME, DEFAULT_BACKLOG);
-        if (this.socketCreator.useSSL()) {
+        if (socketCreator.useSSL()) {
-        this.serverSock = channel.socket();
-        this.serverSock.setReuseAddress(true);
+        serverSock = channel.socket();
+        serverSock.setReuseAddress(true);
-        this.serverSock.setReceiveBufferSize(socketBufferSize);
+        serverSock.setReceiveBufferSize(socketBufferSize);
-            this.serverSock.bind(new InetSocketAddress(getBindAddress(), port), backLog);
+            serverSock.bind(new InetSocketAddress(getBindAddress(), port), backLog);
-            this.serverSock = this.socketCreator.createServerSocket(port, backLog, getBindAddress(),
-                this.gatewayTransportFilters, socketBufferSize);
+            serverSock = socketCreator.createServerSocket(port, backLog, getBindAddress(),
+                gatewayTransportFilters, socketBufferSize);
-        port = this.serverSock.getLocalPort();
+        port = serverSock.getLocalPort();
-              && (dm instanceof LonerDistributionManager)) {
+              && dm instanceof LonerDistributionManager) {
-      this.localPort = port;
+      localPort = port;
-          new Object[] {sockName, Integer.valueOf(backLog)});
+          new Object[] {sockName, backLog});
-        this.stats = GatewayReceiverStats.createGatewayReceiverStats(sockName);
+        stats = GatewayReceiverStats.createGatewayReceiverStats(sockName);
-        this.stats = new CacheServerStats(sockName);
+        stats = new CacheServerStats(sockName);
-    this.cache = internalCache;
-    this.crHelper = new CachedRegionHelper(cache);
+    cache = internalCache;
+    crHelper = new CachedRegionHelper(cache);
-    this.clientNotifier = CacheClientNotifier.getInstance(cache, this.stats, maximumMessageCount,
+    clientNotifier = CacheClientNotifier.getInstance(cache, stats, maximumMessageCount,
-    this.healthMonitor = ClientHealthMonitor.getInstance(internalCache, maximumTimeBetweenPings,
-        this.clientNotifier.getStats());
+    healthMonitor = ClientHealthMonitor.getInstance(internalCache, maximumTimeBetweenPings,
+        clientNotifier.getStats());
-    isAuthenticationRequired = this.securityService.isClientSecurityRequired();
+    isAuthenticationRequired = securityService.isClientSecurityRequired();
-        this.cache.getDistributedSystem().getProperties().getProperty(SECURITY_CLIENT_ACCESSOR_PP);
+        cache.getDistributedSystem().getProperties().getProperty(SECURITY_CLIENT_ACCESSOR_PP);
-        (postAuthzFactoryName != null && postAuthzFactoryName.length() > 0) ? true : false;
+        postAuthzFactoryName != null && !postAuthzFactoryName.isEmpty();
-        "Handshaker " + serverSock.getInetAddress() + ":" + this.localPort + " Thread ";
+        "Handshaker " + serverSock.getInetAddress() + ":" + localPort + " Thread ";
-      this.stats.close();
-      this.serverSock.close();
-      this.pool.shutdown();
+      stats.close();
+      serverSock.close();
+      pool.shutdown();
-  private ExecutorService initializeClientQueueInitializerThreadPool() throws IOException {
+  private ExecutorService initializeClientQueueInitializerThreadPool() {
-    String threadName = "ServerConnection on port " + this.localPort + " Thread ";
+      String threadName = "ServerConnection on port " + localPort + " Thread ";
-            commandWrapper, this.maxThreads,
+            commandWrapper, maxThreads,
-      } else {
-        return LoggingExecutors.newThreadPoolWithSynchronousFeed(threadName, threadInitializer,
-            commandWrapper,
-            MINIMUM_MAX_CONNECTIONS, this.maxConnections, 0L);
+      return LoggingExecutors.newThreadPoolWithSynchronousFeed(threadName, threadInitializer,
+          commandWrapper,
+          MINIMUM_MAX_CONNECTIONS, maxConnections, 0L);
-      this.stats.close();
-      this.serverSock.close();
+      stats.close();
+      serverSock.close();
-    DistributionManager distributionManager = this.cache.getDistributionManager();
+    DistributionManager distributionManager = cache.getDistributionManager();
-    } else {
-      return null;
+    return null;
-    return this.acceptorId;
+    return acceptorId;
-    return this.stats;
+    return stats;
-    return this.maxThreads > 0;
+    return maxThreads > 0;
-      Integer.getInteger("BridgeServer.SELECTOR_POOL_SIZE", 16).intValue();
+      Integer.getInteger("BridgeServer.SELECTOR_POOL_SIZE", 16);
-      .getInteger("BridgeServer.HANDSHAKE_POOL_SIZE", HANDSHAKER_DEFAULT_POOL_SIZE).intValue();
+      .getInteger("BridgeServer.HANDSHAKE_POOL_SIZE", HANDSHAKER_DEFAULT_POOL_SIZE);
-  public void start() throws IOException {
+  public void start() {
-        new LoggingThread("Cache Server Acceptor " + this.serverSock.getInetAddress() + ":"
-            + this.localPort + " local port: " + this.serverSock.getLocalPort(), false, this);
-    this.acceptorId = thread.getId();
+        new LoggingThread("Cache Server Acceptor " + serverSock.getInetAddress() + ":"
+            + localPort + " local port: " + serverSock.getLocalPort(), false, this);
+    acceptorId = thread.getId();
-      this.selectorThread =
-          new LoggingThread("Cache Server Selector " + this.serverSock.getInetAddress() + ":"
-              + this.localPort + " local port: " + this.serverSock.getLocalPort(),
+      selectorThread =
+          new LoggingThread("Cache Server Selector " + serverSock.getInetAddress() + ":"
+              + localPort + " local port: " + serverSock.getLocalPort(),
-      this.selectorThread.start();
+      selectorThread.start();
-    Set<PartitionedRegion> prs = this.cache.getPartitionedRegions();
+    Set<PartitionedRegion> prs = cache.getPartitionedRegions();
-          new HashMap<Integer, BucketAdvisor.BucketProfile>();
+          new HashMap<>();
-      Set receipients = new HashSet();
-      receipients = pr.getRegionAdvisor().adviseAllPRNodes();
-      // send it to all in one messgae
-      ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(receipients,
+      Set recipients = pr.getRegionAdvisor().adviseAllPRNodes();
+      // send it to all in one message
+      ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(recipients,
-  public void registerSC(ServerConnection sc) {
-    synchronized (this.syncLock) {
+  void registerSC(ServerConnection sc) {
+    synchronized (syncLock) {
-      this.selector.wakeup();
+      selector.wakeup();
-  public void unregisterSC(ServerConnection sc) {
+  void unregisterSC(ServerConnection sc) {
-    synchronized (this.allSCsLock) {
-      this.allSCs.remove(sc);
-      Iterator it = this.allSCs.iterator();
-      ServerConnection again[] = new ServerConnection[this.allSCs.size()];
+    synchronized (allSCsLock) {
+      allSCs.remove(sc);
+      Iterator it = allSCs.iterator();
+      ServerConnection[] again = new ServerConnection[allSCs.size()];
-      this.allSCList = again;
+      allSCList = again;
-    ServerConnection sc = (ServerConnection) this.selectorQueue.poll();
+    ServerConnection sc = selectorQueue.poll();
-      sc = (ServerConnection) this.selectorQueue.poll();
+      sc = selectorQueue.poll();
-    Iterator it = selectorRegistrations.iterator();
-    while (it.hasNext()) {
+    for (ServerConnection selectorRegistration : selectorRegistrations) {
-        finishCon((ServerConnection) it.next());
+        finishCon(selectorRegistration);
-  private static volatile boolean emergencyClassesLoaded = false;
+  private static volatile boolean emergencyClassesLoaded;
-    ServerSocket ss = this.serverSock;
+    ServerSocket ss = serverSock;
-    this.crHelper.setShutdown(true);
+    crHelper.setShutdown(true);
-      ServerConnection snap[] = this.allSCList;
-      for (int i = 0; i < snap.length; i++) {
-        snap[i].emergencyClose(); // part of cleanup()
+      ServerConnection[] snap = allSCList;
+      for (ServerConnection serverConnection : snap) {
+        serverConnection.emergencyClose(); // part of cleanup()
-      Iterator it = this.selectorRegistrations.iterator();
+      Iterator it = selectorRegistrations.iterator();
-    Iterator it = (new ArrayList(this.selector.keys())).iterator();
-    while (it.hasNext()) {
-      SelectionKey sk = (SelectionKey) it.next();
+    for (SelectionKey sk : new ArrayList<>(selector.keys())) {
-        this.selector.selectNow(); // clear the cancelled key
-        SelectionKey tmpsk = sc.getSelectableChannel().register(this.tmpSel,
+        selector.selectNow(); // clear the cancelled key
+        SelectionKey tmpsk = sc.getSelectableChannel().register(tmpSel,
-          int events = this.tmpSel.selectNow();
+          int events = tmpSel.selectNow();
-            sc.registerWithSelector2(this.selector);
+            sc.registerWithSelector2(selector);
-              // logger.info("DEBUG detected read event on " + sc);
-                this.tmpSel.selectNow(); // clear canceled key
-                this.selectorRegistrations.remove(sc);
+                tmpSel.selectNow(); // clear canceled key
+                selectorRegistrations.remove(sc);
-                AcceptorImpl.this.stats.incThreadQueueSize();
-                AcceptorImpl.this.pool.execute(sc);
+                stats.incThreadQueueSize();
+                pool.execute(sc);
-                AcceptorImpl.this.stats.decThreadQueueSize();
+                stats.decThreadQueueSize();
-              this.tmpSel.selectNow(); // clear canceled key
-              sc.registerWithSelector2(this.selector);
+              tmpSel.selectNow(); // clear canceled key
+              sc.registerWithSelector2(selector);
-              this.tmpSel.selectNow(); // clear canceled key
-              sc.registerWithSelector2(this.selector);
+              tmpSel.selectNow(); // clear canceled key
+              sc.registerWithSelector2(selector);
-          if (isRunning() && this.selector.isOpen() && this.tmpSel.isOpen()) {
+          if (isRunning() && selector.isOpen() && tmpSel.isOpen()) {
-              if (isRunning() && this.selector.isOpen() && this.tmpSel.isOpen()) {
+              if (isRunning() && selector.isOpen() && tmpSel.isOpen()) {
-        continue;
-      } catch (IOException ex) {
-        if (isRunning() && this.selector.isOpen() && this.tmpSel.isOpen()) {
+      } catch (IOException | NullPointerException ex) {
+        if (isRunning() && selector.isOpen() && tmpSel.isOpen()) {
-      } catch (NullPointerException npe) { // fix bug 39644
-        if (isRunning() && this.selector.isOpen() && this.tmpSel.isOpen()) {
-          logger.warn("Unexpected Exception:", npe);
-        }
-      }
+      } // fix bug 39644
+
-  private int registeredKeys = 0;
+  private int registeredKeys;
-  public void runSelectorLoop() {
+  private void runSelectorLoop() {
-      while (this.selector.isOpen() && !Thread.currentThread().isInterrupted()) {
+      while (selector.isOpen() && !Thread.currentThread().isInterrupted()) {
-          if (this.cache.isClosed()) { // bug 38834
+          if (cache.isClosed()) { // bug 38834
-          if (this.cache.getCancelCriterion().isCancelInProgress()) {
+          if (cache.getCancelCriterion().isCancelInProgress()) {
-          ServerConnection sc;
+          ServerConnection sc;
-            sc = (ServerConnection) this.selectorQueue.take();
+            sc = selectorQueue.take();
-            sc = (ServerConnection) this.selectorQueue.poll();
+            sc = selectorQueue.poll();
-              sc.registerWithSelector2(this.selector);
+              sc.registerWithSelector2(selector);
-              this.selectorRegistrations.add(sc);
+              selectorRegistrations.add(sc);
-            } catch (IOException ex) {
+            } catch (IOException | RuntimeException ex) {
-            } catch (RuntimeException ex) {
-              finishCon(sc);
-              logger.warn("ignoring", ex);
-            sc = (ServerConnection) this.selectorQueue.poll();
+            sc = selectorQueue.poll();
-        int events = this.selector.select();
+        int events = selector.select();
-        if (this.cache.getCancelCriterion().isCancelInProgress()) {
+        if (cache.getCancelCriterion().isCancelInProgress()) {
-          int cancelCount = 0;
-          Set sk = this.selector.selectedKeys();
+          Set sk = selector.selectedKeys();
+          int cancelCount = 0;
-                  this.selectorRegistrations.remove(sc);
+                  selectorRegistrations.remove(sc);
-                  AcceptorImpl.this.stats.incThreadQueueSize();
-                  AcceptorImpl.this.pool.execute(sc);
+                  stats.incThreadQueueSize();
+                  pool.execute(sc);
-                  AcceptorImpl.this.stats.decThreadQueueSize();
+                  stats.decThreadQueueSize();
-          if (cancelCount > 0 && this.selector.isOpen()) {
+          if (cancelCount > 0 && selector.isOpen()) {
-            events = this.selector.selectNow();
+            events = selector.selectNow();
-    String name = this.serverSock.getLocalSocketAddress().toString();
+    String name = serverSock.getLocalSocketAddress().toString();
-  public InetAddress getServerInetAddr() {
-    return this.serverSock.getInetAddress();
+  InetAddress getServerInetAddr() {
+    return serverSock.getInetAddress();
-        if (this.serverSock != null) {
-          this.serverSock.close();
+        if (serverSock != null) {
+          serverSock.close();
-      if (this.stats != null) {
-        this.stats.close();
+      if (stats != null) {
+        stats.close();
-  public Selector getSelector() {
-    return this.selector;
+  private Selector getSelector() {
+    return selector;
-  public BlockingQueue getSelectorQueue() {
-    return this.selectorQueue;
+  private BlockingQueue<ServerConnection> getSelectorQueue() {
+    return selectorQueue;
-  protected boolean loggedAcceptError = false;
+  private boolean loggedAcceptError;
-  protected static void closeSocket(Socket s) {
+  private static void closeSocket(Socket s) {
-        synchronized (this.syncLock) {
+        synchronized (syncLock) {
-        this.loggedAcceptError = false;
+        loggedAcceptError = false;
-          if (!this.loggedAcceptError) {
-            this.loggedAcceptError = true;
+          if (!loggedAcceptError) {
+            loggedAcceptError = true;
-      this.stats.incAcceptsInProgress();
-      this.hsPool.execute(new Runnable() {
-        @Override
-        public void run() {
-          boolean finished = false;
-          try {
-            handleNewClientConnection(socket, serverConnectionFactory);
-            finished = true;
-          } catch (RegionDestroyedException rde) {
-            // aborted due to disconnect - bug 42273
-            if (rde.getMessage().indexOf("HARegion") == -1) {
-              throw rde;
-            }
-          } catch (CancelException e) {
-            // aborted due to shutdown - bug 37318
-          } catch (java.nio.channels.AsynchronousCloseException expected) {
-            // this is expected when our TimerTask times out an accepted socket
-          } catch (IOException | ToDataException ex) { // added ToDataException to fix bug 44659
-            if (isRunning()) {
-              if (!AcceptorImpl.this.loggedAcceptError) {
-                AcceptorImpl.this.loggedAcceptError = true;
-                if (ex instanceof SocketTimeoutException) {
-                  logger.warn(
-                      "Cache server: failed accepting client connection due to socket timeout.");
-                } else {
-                  logger.warn("Cache server: failed accepting client connection " +
-                      ex,
-                      ex);
-                }
+      stats.incAcceptsInProgress();
+      hsPool.execute(() -> {
+        boolean finished = false;
+        try {
+          handleNewClientConnection(socket, serverConnectionFactory);
+          finished = true;
+        } catch (RegionDestroyedException rde) {
+          // aborted due to disconnect - bug 42273
+          if (!rde.getMessage().contains("HARegion")) {
+            throw rde;
+          }
+        } catch (CancelException e) {
+          // aborted due to shutdown - bug 37318
+        } catch (AsynchronousCloseException expected) {
+          // this is expected when our TimerTask times out an accepted socket
+        } catch (IOException | ToDataException ex) { // added ToDataException to fix bug 44659
+          if (isRunning()) {
+            if (!loggedAcceptError) {
+              loggedAcceptError = true;
+              if (ex instanceof SocketTimeoutException) {
+                logger.warn(
+                    "Cache server: failed accepting client connection due to socket timeout.");
+              } else {
+                logger.warn("Cache server: failed accepting client connection " +
+                    ex,
+                    ex);
-          } finally {
-            if (!finished) {
-              closeSocket(socket);
-            }
-            if (isRunning()) {
-              AcceptorImpl.this.stats.decAcceptsInProgress();
-            }
+          }
+        } finally {
+          if (!finished) {
+            closeSocket(socket);
+          }
+          if (isRunning()) {
+            stats.decAcceptsInProgress();
-        this.stats.decAcceptsInProgress();
+        stats.decAcceptsInProgress();
-    ByteBuffer result = (ByteBuffer) this.commBufferQueue.poll();
+    ByteBuffer result = commBufferQueue.poll();
-      result = ByteBuffer.allocateDirect(this.socketBufferSize);
+      result = ByteBuffer.allocateDirect(socketBufferSize);
-      this.commBufferQueue.offer(bb);
+      commBufferQueue.offer(bb);
-  public void incClientServerCnxCount() {
-    this.clientServerCnxCount.incrementAndGet();
+  private void incClientServerCnxCount() {
+    clientServerCnxCount.incrementAndGet();
-  public void decClientServerCnxCount() {
-    this.clientServerCnxCount.decrementAndGet();
+  void decClientServerCnxCount() {
+    clientServerCnxCount.decrementAndGet();
-    return this.clientServerCnxCount.get();
+    return clientServerCnxCount.get();
-  public boolean isNotifyBySubscription() {
+  private boolean isNotifyBySubscription() {
-  protected void handleNewClientConnection(final Socket socket,
+  private void handleNewClientConnection(final Socket socket,
-      socket.setTcpNoDelay(this.tcpNoDelay);
+      socket.setTcpNoDelay(tcpNoDelay);
-    boolean notForQueue = (communicationMode != ClientToServerForQueue);
+    boolean notForQueue = communicationMode != ClientToServerForQueue;
-      int curCnt = this.getClientServerCnxCount();
-      if (curCnt >= this.maxConnections) {
+      int curCnt = getClientServerCnxCount();
+      if (curCnt >= maxConnections) {
-            new Object[] {socket.getInetAddress(), Integer.valueOf(curCnt),
-                Integer.valueOf(this.maxConnections)});
+            new Object[] {socket.getInetAddress(), curCnt,
+                maxConnections});
-                    Integer.valueOf(this.maxConnections)),
+                    maxConnections),
-        serverConnectionFactory.makeServerConnection(socket, this.cache, this.crHelper, this.stats,
-            AcceptorImpl.handshakeTimeout, this.socketBufferSize, communicationMode.toString(),
-            communicationMode.getModeNumber(), this, this.securityService);
+        serverConnectionFactory.makeServerConnection(socket, cache, crHelper, stats,
+            handshakeTimeout, socketBufferSize, communicationMode.toString(),
+            communicationMode.getModeNumber(), this, securityService);
-    synchronized (this.allSCsLock) {
-      this.allSCs.add(serverConn);
-      ServerConnection snap[] = this.allSCList; // avoid volatile read
-      this.allSCList = (ServerConnection[]) ArrayUtils.insert(snap, snap.length, serverConn);
+    synchronized (allSCsLock) {
+      allSCs.add(serverConn);
+      ServerConnection[] snap = allSCList; // avoid volatile read
+      allSCList = (ServerConnection[]) ArrayUtils.insert(snap, snap.length, serverConn);
-                  Integer.valueOf(this.maxConnections)),
+                  maxConnections),
-    this.socketCreator.handshakeIfSocketIsSSL(socket, this.acceptTimeout);
+    socketCreator.handshakeIfSocketIsSSL(socket, acceptTimeout);
-    } else if (res == 0) {
+    }
+    if (res == 0) {
-      this.hsTimer.schedule(timerTask, this.acceptTimeout);
+      hsTimer.schedule(timerTask, acceptTimeout);
-      if ((!timerTask.cancel()) || res <= 0) {
+      if (!timerTask.cancel() || res <= 0) {
-    return !this.shutdownStarted;
+    return !shutdownStarted;
-        this.shutdownStarted = true;
-        logger.info("Cache server on port {} is shutting down.", this.localPort);
-        if (this.thread != null) {
-          this.thread.interrupt();
+        shutdownStarted = true;
+        logger.info("Cache server on port {} is shutting down.", localPort);
+        if (thread != null) {
+          thread.interrupt();
-          this.serverSock.close();
+          serverSock.close();
-        this.clientNotifier.shutdown(this.acceptorId);
+        clientNotifier.shutdown(acceptorId);
-        this.stats.close();
+        stats.close();
-    for (PartitionedRegion pr : this.cache.getPartitionedRegions()) {
+    for (PartitionedRegion pr : cache.getPartitionedRegions()) {
-      this.hsTimer.cancel();
-      if (this.tmpSel != null) {
+      hsTimer.cancel();
+      if (tmpSel != null) {
-          this.tmpSel.close();
+          tmpSel.close();
-        this.selector.close();
+        selector.close();
-      if (this.selectorThread != null) {
-        this.selectorThread.interrupt();
+      if (selectorThread != null) {
+        selectorThread.interrupt();
-      this.commBufferQueue.clear();
+      commBufferQueue.clear();
-    this.pool.shutdown();
+    pool.shutdown();
-      if (!this.pool.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
+      if (!pool.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
-        this.pool.shutdownNow();
+        pool.shutdownNow();
-      this.pool.shutdownNow();
+      pool.shutdownNow();
-    this.clientQueueInitPool.shutdown();
-    this.hsPool.shutdown();
+    clientQueueInitPool.shutdown();
+    hsPool.shutdown();
-    synchronized (this.allSCsLock) {
-      ServerConnection snap[] = this.allSCList;
-      for (int i = 0; i < snap.length; i++) {
-        snap[i].cleanup();
+    synchronized (allSCsLock) {
+      ServerConnection[] snap = allSCList;
+      for (ServerConnection serverConnection : snap) {
+        serverConnection.cleanup();
-  public boolean isShutdownProperly() {
+  boolean isShutdownProperly() {
-    if (bindName != null && !bindName.equals("")) {
+    if (bindName != null && !bindName.isEmpty()) {
-    if (serverBindAddress != null && serverBindAddress.length() > 0) {
+    if (serverBindAddress != null && !serverBindAddress.isEmpty()) {
-      if (bindAddress != null && bindAddress.length() > 0) {
+      if (bindAddress != null && !bindAddress.isEmpty()) {
-    if (this.bindHostName == null || "".equals(this.bindHostName)) {
+    if (bindHostName == null || bindHostName.isEmpty()) {
-    } else {
-      return InetAddress.getByName(this.bindHostName);
+    return InetAddress.getByName(bindHostName);
-    String result = this.bindHostName;
+    String result = bindHostName;
-    if (result == null || "".equals(result)) {
+    if (result == null || result.isEmpty()) {
-      ServerSocket ss = this.serverSock;
+      ServerSocket ss = serverSock;
-    return this.clientNotifier;
+    return clientNotifier;
-    return this.crHelper;
+    return crHelper;
-  public ClientHealthMonitor getClientHealthMonitor() {
+  ClientHealthMonitor getClientHealthMonitor() {
-  public ConnectionListener getConnectionListener() {
+  ConnectionListener getConnectionListener() {
-    return this.isGatewayReceiver;
+    return isGatewayReceiver;
-    return this.gatewayTransportFilters;
+    return gatewayTransportFilters;
-  public static boolean treatAsBindException(SocketException se) {
+  private static boolean treatAsBindException(SocketException se) {
-    return (msg != null && msg.contains("Invalid argument: listen failed"));
+    return msg != null && msg.contains("Invalid argument: listen failed");
-  public static boolean isAuthenticationRequired() {
+  static boolean isAuthenticationRequired() {
-  public static boolean isPostAuthzCallbackPresent() {
+  static boolean isPostAuthzCallbackPresent() {
-    return this.allSCList;
+    return allSCList;
-    public ClientQueueInitializerTask(Socket socket, boolean isPrimaryServerToClient,
+    ClientQueueInitializerTask(Socket socket, boolean isPrimaryServerToClient,

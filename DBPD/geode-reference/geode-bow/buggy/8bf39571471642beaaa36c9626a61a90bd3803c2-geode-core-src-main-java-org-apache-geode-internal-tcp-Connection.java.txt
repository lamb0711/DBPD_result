Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** <p>Connection is a socket holder that sends and receives serialized
-    message objects.  A Connection may be closed to preserve system
-    resources and will automatically be reopened when it's needed.</p>
-
-    @since GemFire 2.0
-
-*/
+/**
+ * <p>
+ * Connection is a socket holder that sends and receives serialized message objects. A Connection
+ * may be closed to preserve system resources and will automatically be reopened when it's needed.
+ * </p>
+ * 
+ * @since GemFire 2.0
+ * 
+ */
-  private static final int INITIAL_CAPACITY = Integer.getInteger("p2p.readerBufferSize", 32768).intValue();
+  private static final int INITIAL_CAPACITY =
+      Integer.getInteger("p2p.readerBufferSize", 32768).intValue();
-  private static boolean IS_P2P_CONNECT_TIMEOUT_INITIALIZED = false; 
-  
+  private static boolean IS_P2P_CONNECT_TIMEOUT_INITIALIZED = false;
+
-  //We no longer support early ack
-  //public final static int EARLY_ACK_BIT = 0x10;
+  // We no longer support early ack
+  // public final static int EARLY_ACK_BIT = 0x10;
-   * Small buffer used for send socket buffer on receiver connections
-   * and receive buffer on sender connections.
+   * Small buffer used for send socket buffer on receiver connections and receive buffer on sender
+   * connections.
-  public final static int SMALL_BUFFER_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "SMALL_BUFFER_SIZE", 4096).intValue();
+  public final static int SMALL_BUFFER_SIZE =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "SMALL_BUFFER_SIZE", 4096).intValue();
-  public static final String INITIATING_SUSPECT_PROCESSING = "member unexpectedly shut down shared, unordered connection";
+  public static final String INITIATING_SUSPECT_PROCESSING =
+      "member unexpectedly shut down shared, unordered connection";
-  
-  /** Set to false once run() is terminating. Using this instead of Thread.isAlive  
-    * as the reader thread may be a pooled thread.
-    */ 
-  private volatile boolean isRunning = false; 
+
+  /**
+   * Set to false once run() is terminating. Using this instead of Thread.isAlive as the reader
+   * thread may be a pooled thread.
+   */
+  private volatile boolean isRunning = false;
-  
+
-  
+
-   * Returns the depth of unshared reader threads from this thread to
-   * the original non-reader-thread.
-   * E.g., ServerConnection -> reader(domino=1) -> reader(domino=2) -> reader(domino=3)
+   * Returns the depth of unshared reader threads from this thread to the original
+   * non-reader-thread. E.g., ServerConnection -> reader(domino=1) -> reader(domino=2) ->
+   * reader(domino=3)
+
+
+
-      return ((Boolean)o).booleanValue();
+      return ((Boolean) o).booleanValue();
-    if(IS_P2P_CONNECT_TIMEOUT_INITIALIZED)
+    if (IS_P2P_CONNECT_TIMEOUT_INITIALIZED)
-    if(connectTimeoutStr != null) {
-      P2P_CONNECT_TIMEOUT =  Integer.parseInt(connectTimeoutStr);
-    }
-    else {      
-      P2P_CONNECT_TIMEOUT = 6*this.owner.owner.getDM().getConfig().getMemberTimeout();
+    if (connectTimeoutStr != null) {
+      P2P_CONNECT_TIMEOUT = Integer.parseInt(connectTimeoutStr);
+    } else {
+      P2P_CONNECT_TIMEOUT = 6 * this.owner.owner.getDM().getConfig().getMemberTimeout();
-    return P2P_CONNECT_TIMEOUT;     
+    return P2P_CONNECT_TIMEOUT;
+
-  private static final boolean DOMINO_THREAD_OWNED_SOCKETS = Boolean.getBoolean("p2p.ENABLE_DOMINO_THREAD_OWNED_SOCKETS");
+  private static final boolean DOMINO_THREAD_OWNED_SOCKETS =
+      Boolean.getBoolean("p2p.ENABLE_DOMINO_THREAD_OWNED_SOCKETS");
+
+
-      return ((Boolean)o).booleanValue();
+      return ((Boolean) o).booleanValue();
-   * True if this connection was accepted by a listening socket.
-   * This makes it a receiver.
-   * False if this connection was explicitly created by a connect call.
-   * This makes it a sender.
+   * True if this connection was accepted by a listening socket. This makes it a receiver. False if
+   * this connection was explicitly created by a connect call. This makes it a sender.
-  
+
-   * count of how many unshared p2p-readers removed from the original action this
-   * thread is.  For instance, server-connection -> owned p2p reader (count 0)
-   * -> owned p2p reader (count 1) -> owned p2p reader (count 2).  This shows
-   * up in thread names as "DOM #x" (domino #x)
+   * count of how many unshared p2p-readers removed from the original action this thread is. For
+   * instance, server-connection -> owned p2p reader (count 0) -> owned p2p reader (count 1) ->
+   * owned p2p reader (count 2). This shows up in thread names as "DOM #x" (domino #x)
-    }};
+    }
+  };
-//  /**
-//   * name of sender thread thread.  Useful in finding out why a reader
-//   * thread was created.  Add sending of the name in handshakes and
-//   * add it to the name of the reader thread (the code is there but commented out)
-//   */
-//  private String senderName = null;
-  
+  // /**
+  // * name of sender thread thread. Useful in finding out why a reader
+  // * thread was created. Add sending of the name in handshakes and
+  // * add it to the name of the reader thread (the code is there but commented out)
+  // */
+  // private String senderName = null;
+
-   * How long to wait if receiver will not accept a message before we
-   * go into queue mode.
+   * How long to wait if receiver will not accept a message before we go into queue mode.
+   * 
-   * How long to wait,
-   * with the receiver not accepting any messages,
-   * before kicking the receiver out of the distributed system.
-   * Ignored if asyncDistributionTimeout is zero.
+   * How long to wait, with the receiver not accepting any messages, before kicking the receiver out
+   * of the distributed system. Ignored if asyncDistributionTimeout is zero.
+   * 
-   * How much queued data we can have,
-   * with the receiver not accepting any messages,
-   * before kicking the receiver out of the distributed system.
-   * Ignored if asyncDistributionTimeout is zero.
+   * How much queued data we can have, with the receiver not accepting any messages, before kicking
+   * the receiver out of the distributed system. Ignored if asyncDistributionTimeout is zero.
+   * 
-   * Maps ConflatedKey instances to ConflatedKey instance.
-   * Note that even though the key and value for an entry is the map
-   * will always be "equal" they will not always be "==".
+   * Maps ConflatedKey instances to ConflatedKey instance. Note that even though the key and value
+   * for an entry is the map will always be "equal" they will not always be "==".
-  //private final Queue outgoingQueue = new LinkedBlockingQueue();
+  // private final Queue outgoingQueue = new LinkedBlockingQueue();
-   * Number of bytes in the outgoingQueue.
-   * Used to control capacity.
+   * Number of bytes in the outgoingQueue. Used to control capacity.
-  private final static int MAX_SENDERS = Integer.getInteger("p2p.maxConnectionSenders", DirectChannel.DEFAULT_CONCURRENCY_LEVEL).intValue();
+  private final static int MAX_SENDERS = Integer
+      .getInteger("p2p.maxConnectionSenders", DirectChannel.DEFAULT_CONCURRENCY_LEVEL).intValue();
-   * This semaphore is used to throttle how many threads will try to do sends on
-   * this connection concurrently. A thread must acquire this semaphore before it
-   * is allowed to start serializing its message.
+   * This semaphore is used to throttle how many threads will try to do sends on this connection
+   * concurrently. A thread must acquire this semaphore before it is allowed to start serializing
+   * its message.
-  private static final byte REPLY_CODE_OK = (byte)69;
-  private static final byte REPLY_CODE_OK_WITH_ASYNC_INFO = (byte)70;
+  private static final byte REPLY_CODE_OK = (byte) 69;
+  private static final byte REPLY_CODE_OK_WITH_ASYNC_INFO = (byte) 70;
-//  /**
-//   * When a thread owns the outLock and is writing to the socket, it must
-//   * be placed in this variable so that it can be interrupted should the
-//   * socket need to be closed.
-//   */
-//  private volatile Thread writerThread;
+  // /**
+  // * When a thread owns the outLock and is writing to the socket, it must
+  // * be placed in this variable so that it can be interrupted should the
+  // * socket need to be closed.
+  // */
+  // private volatile Thread writerThread;
-  
+
-  // State for ackTimeoutTask: transmissionStartTime, ackWaitTimeout, ackSATimeout, ackConnectionGroup, ackThreadName
-  
-  /** millisecond clock at the time message transmission started, if doing
-   *  forced-disconnect processing */
+  // State for ackTimeoutTask: transmissionStartTime, ackWaitTimeout, ackSATimeout,
+  // ackConnectionGroup, ackThreadName
+
+  /**
+   * millisecond clock at the time message transmission started, if doing forced-disconnect
+   * processing
+   */
-  
+
-  
+
-   * other connections participating in the current transmission.  we notify
-   * them if ackSATimeout expires to keep all members from generating alerts
-   * when only one is slow 
+   * other connections participating in the current transmission. we notify them if ackSATimeout
+   * expires to keep all members from generating alerts when only one is slow
-  
+
-  
+
-//  int nioMessageStart;
+  // int nioMessageStart;
-//  byte nioMessageVersion;
+  // byte nioMessageVersion;
-  /** used to map a msgId to a MsgDestreamer which are
-    * used for destreaming chunked messages using nio */
+  /**
+   * used to map a msgId to a MsgDestreamer which are used for destreaming chunked messages using
+   * nio
+   */
-  
+
+
+
+
+
+
-  private void setSocketBufferSize(Socket sock, boolean send, int requestedSize, boolean alreadySetInSocket) {
+
+  private void setSocketBufferSize(Socket sock, boolean send, int requestedSize,
+      boolean alreadySetInSocket) {
-        int currentSize = send
-          ? sock.getSendBufferSize()
-          : sock.getReceiveBufferSize();
+        int currentSize = send ? sock.getSendBufferSize() : sock.getReceiveBufferSize();
-        int actualSize = send
-          ? sock.getSendBufferSize()
-          : sock.getReceiveBufferSize();
+        int actualSize = send ? sock.getSendBufferSize() : sock.getReceiveBufferSize();
-          logger.info(LocalizedMessage.create(LocalizedStrings.Connection_SOCKET_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
-              new Object[] {(send ? "send buffer size" : "receive buffer size"), Integer.valueOf(actualSize), Integer.valueOf(requestedSize)}));
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.Connection_SOCKET_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
+              new Object[] {(send ? "send buffer size" : "receive buffer size"),
+                  Integer.valueOf(actualSize), Integer.valueOf(requestedSize)}));
+
-  /** creates a connection that we accepted (it was initiated by
-   * an explicit connect being done on the other side).
-   * We will only receive data on this socket; never send.
+  /**
+   * creates a connection that we accepted (it was initiated by an explicit connect being done on
+   * the other side). We will only receive data on this socket; never send.
-    throws IOException, ConnectionException
-  {
+      throws IOException, ConnectionException {
-        c.closeForReconnect(LocalizedStrings.Connection_COULD_NOT_START_READER_THREAD.toLocalizedString());
+        c.closeForReconnect(
+            LocalizedStrings.Connection_COULD_NOT_START_READER_THREAD.toLocalizedString());
-    //sendHandshakeReplyOK();
+    // sendHandshakeReplyOK();
-  
-  /** creates a connection that we accepted (it was initiated by
-   * an explicit connect being done on the other side).
+
+  /**
+   * creates a connection that we accepted (it was initiated by an explicit connect being done on
+   * the other side).
-  protected Connection(ConnectionTable t, Socket socket)
-    throws IOException, ConnectionException
-  {
+  protected Connection(ConnectionTable t, Socket socket) throws IOException, ConnectionException {
-      throw new IllegalArgumentException(LocalizedStrings.Connection_NULL_CONNECTIONTABLE.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.Connection_NULL_CONNECTIONTABLE.toLocalizedString());
-//      socket.setSoLinger(true, (Integer.valueOf(System.getProperty("p2p.lingerTime", "5000"))).intValue());
+      // socket.setSoLinger(true, (Integer.valueOf(System.getProperty("p2p.lingerTime",
+      // "5000"))).intValue());
-    }
-    catch (SocketException e) {
-      // unable to get the settings we want.  Don't log an error because it will
+    } catch (SocketException e) {
+      // unable to get the settings we want. Don't log an error because it will
-        //this.output = new BufferedOutputStream(socket.getOutputStream(), SMALL_BUFFER_SIZE);
+        // this.output = new BufferedOutputStream(socket.getOutputStream(), SMALL_BUFFER_SIZE);
-      }
-      catch (IOException io) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNABLE_TO_GET_P2P_CONNECTION_STREAMS), io);
+      } catch (IOException io) {
+        logger.fatal(LocalizedMessage
+            .create(LocalizedStrings.Connection_UNABLE_TO_GET_P2P_CONNECTION_STREAMS), io);
-  
+
-    if (isSocketInUse()
-        || (this.sharedResource && !this.preserveOrder)) { // shared/unordered connections are used for failure-detection
-                                                           // and are not subject to idle-timeout
+    if (isSocketInUse() || (this.sharedResource && !this.preserveOrder)) { // shared/unordered
+                                                                           // connections are used
+                                                                           // for failure-detection
+                                                                           // and are not subject to
+                                                                           // idle-timeout
-        logger.debug("Closing idle connection {} shared={} ordered={}", this, this.sharedResource, this.preserveOrder);
+        logger.debug("Closing idle connection {} shared={} ordered={}", this, this.sharedResource,
+            this.preserveOrder);
-        closeForReconnect(LocalizedStrings.Connection_IDLE_CONNECTION_TIMED_OUT.toLocalizedString());
-      } catch (Exception ignore) {}
+        closeForReconnect(
+            LocalizedStrings.Connection_IDLE_CONNECTION_TIMED_OUT.toLocalizedString());
+      } catch (Exception ignore) {
+      }
-    bytes[MSG_HEADER_SIZE_OFFSET] = (byte)((msglen/0x1000000) & 0xff);
-    bytes[MSG_HEADER_SIZE_OFFSET+1] = (byte)((msglen/0x10000) & 0xff);
-    bytes[MSG_HEADER_SIZE_OFFSET+2] = (byte)((msglen/0x100) & 0xff);
-    bytes[MSG_HEADER_SIZE_OFFSET+3] = (byte)(msglen & 0xff);
-    bytes[MSG_HEADER_TYPE_OFFSET] = (byte)NORMAL_MSG_TYPE; // message type
-    bytes[MSG_HEADER_ID_OFFSET] = (byte)((MsgIdGenerator.NO_MSG_ID/0x100) & 0xff);
-    bytes[MSG_HEADER_ID_OFFSET+1] = (byte)(MsgIdGenerator.NO_MSG_ID & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET] = (byte) ((msglen / 0x1000000) & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET + 1] = (byte) ((msglen / 0x10000) & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET + 2] = (byte) ((msglen / 0x100) & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET + 3] = (byte) (msglen & 0xff);
+    bytes[MSG_HEADER_TYPE_OFFSET] = (byte) NORMAL_MSG_TYPE; // message type
+    bytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID / 0x100) & 0xff);
+    bytes[MSG_HEADER_ID_OFFSET + 1] = (byte) (MsgIdGenerator.NO_MSG_ID & 0xff);
+
-      throw new IllegalStateException(LocalizedStrings.Connection_TCP_MESSAGE_EXCEEDED_MAX_SIZE_OF_0.toLocalizedString(Integer.valueOf(MAX_MSG_SIZE)));
+      throw new IllegalStateException(LocalizedStrings.Connection_TCP_MESSAGE_EXCEEDED_MAX_SIZE_OF_0
+          .toLocalizedString(Integer.valueOf(MAX_MSG_SIZE)));
+
+
-    byte ver = (byte)(hdrSize >> 24);
+    byte ver = (byte) (hdrSize >> 24);
-      throw new IOException(LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1.toLocalizedString(new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(ver)}));
+      throw new IOException(
+          LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
+              .toLocalizedString(new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(ver)}));
+
-      bb.put((byte)NORMAL_MSG_TYPE);
+      bb.put((byte) NORMAL_MSG_TYPE);
-      bb.putInt(0, calcHdrSize(bb.position()-MSG_HEADER_BYTES));
+      bb.putInt(0, calcHdrSize(bb.position() - MSG_HEADER_BYTES));
-      synchronized(outLock) {
+      synchronized (outLock) {
-//          this.writerThread = Thread.currentThread();
+          // this.writerThread = Thread.currentThread();
-        }
-        finally {
-//          this.writerThread = null;
+        } finally {
+          // this.writerThread = null;
-  private static final int HANDSHAKE_TIMEOUT_MS = Integer.getInteger("p2p.handshakeTimeoutMs", 59000).intValue();
-  //private static final byte HANDSHAKE_VERSION = 1; // 501
-  //public static final byte HANDSHAKE_VERSION = 2; // cbb5x_PerfScale
-  //public static final byte HANDSHAKE_VERSION = 3; // durable_client
-  //public static final byte HANDSHAKE_VERSION = 4; // dataSerialMay19
-//  public static final byte HANDSHAKE_VERSION = 5; // split-brain bits
-  //public static final byte HANDSHAKE_VERSION = 6; // direct ack changes
-  // NOTICE: handshake_version should not be changed anymore.  Use the gemfire
-  //         version transmitted with the handshake bits and handle old handshakes
-  //         based on that
+  private static final int HANDSHAKE_TIMEOUT_MS =
+      Integer.getInteger("p2p.handshakeTimeoutMs", 59000).intValue();
+  // private static final byte HANDSHAKE_VERSION = 1; // 501
+  // public static final byte HANDSHAKE_VERSION = 2; // cbb5x_PerfScale
+  // public static final byte HANDSHAKE_VERSION = 3; // durable_client
+  // public static final byte HANDSHAKE_VERSION = 4; // dataSerialMay19
+  // public static final byte HANDSHAKE_VERSION = 5; // split-brain bits
+  // public static final byte HANDSHAKE_VERSION = 6; // direct ack changes
+  // NOTICE: handshake_version should not be changed anymore. Use the gemfire
+  // version transmitted with the handshake bits and handle old handshakes
+  // based on that
-    synchronized (this.handshakeSync) {
-      if (!this.handshakeRead && !this.handshakeCancelled) {
-        boolean success = false;
-        reason = LocalizedStrings.Connection_UNKNOWN.toLocalizedString();
-        boolean interrupted = Thread.interrupted();
-        try {
-          final long endTime = System.currentTimeMillis() + HANDSHAKE_TIMEOUT_MS;
-          long msToWait = HANDSHAKE_TIMEOUT_MS;
-          while (!this.handshakeRead && !this.handshakeCancelled && msToWait > 0) {
-            this.handshakeSync.wait(msToWait); // spurious wakeup ok
-            if (!this.handshakeRead && !this.handshakeCancelled) {
-              msToWait = endTime - System.currentTimeMillis();
-            }
-          }
-          if (!this.handshakeRead && !this.handshakeCancelled) {
-            reason = LocalizedStrings.Connection_HANDSHAKE_TIMED_OUT.toLocalizedString();
-            String peerName;
-            if (this.remoteAddr != null) {
-              peerName = this.remoteAddr.toString();
-              // late in the life of jdk 1.7 we started seeing connections accepted
-              // when accept() was not even being called.  This started causing timeouts
-              // to occur in the handshake threads instead of causing failures in
-              // connection-formation.  So, we need to initiate suspect processing here
-              owner.getDM().getMembershipManager().suspectMember(this.remoteAddr,
-                  LocalizedStrings.Connection_CONNECTION_HANDSHAKE_WITH_0_TIMED_OUT_AFTER_WAITING_1_MILLISECONDS.toLocalizedString(
-                      new Object[] {peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)}));
-            }
-            else {
-              peerName = "socket " + this.socket.getRemoteSocketAddress().toString()
-                  + ":" + this.socket.getPort();
-            }
-            throw new ConnectionException(LocalizedStrings.Connection_CONNECTION_HANDSHAKE_WITH_0_TIMED_OUT_AFTER_WAITING_1_MILLISECONDS.toLocalizedString(
-                  new Object[] {peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)}));
-          } else {
-            success = this.handshakeRead;
-          }
-        } catch (InterruptedException ex) {
-          interrupted = true;
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-          reason = LocalizedStrings.Connection_INTERRUPTED.toLocalizedString();
-        } finally {
-          if (interrupted) {
-            Thread.currentThread().interrupt();
-          }
-          if (success) {
-            if (this.isReceiver) {
-              needToClose = !owner.getConduit().getMembershipManager().addSurpriseMember(this.remoteAddr);
-              if (needToClose) {
-                reason = "this member is shunned";
+      synchronized (this.handshakeSync) {
+        if (!this.handshakeRead && !this.handshakeCancelled) {
+          boolean success = false;
+          reason = LocalizedStrings.Connection_UNKNOWN.toLocalizedString();
+          boolean interrupted = Thread.interrupted();
+          try {
+            final long endTime = System.currentTimeMillis() + HANDSHAKE_TIMEOUT_MS;
+            long msToWait = HANDSHAKE_TIMEOUT_MS;
+            while (!this.handshakeRead && !this.handshakeCancelled && msToWait > 0) {
+              this.handshakeSync.wait(msToWait); // spurious wakeup ok
+              if (!this.handshakeRead && !this.handshakeCancelled) {
+                msToWait = endTime - System.currentTimeMillis();
+            if (!this.handshakeRead && !this.handshakeCancelled) {
+              reason = LocalizedStrings.Connection_HANDSHAKE_TIMED_OUT.toLocalizedString();
+              String peerName;
+              if (this.remoteAddr != null) {
+                peerName = this.remoteAddr.toString();
+                // late in the life of jdk 1.7 we started seeing connections accepted
+                // when accept() was not even being called. This started causing timeouts
+                // to occur in the handshake threads instead of causing failures in
+                // connection-formation. So, we need to initiate suspect processing here
+                owner.getDM().getMembershipManager().suspectMember(this.remoteAddr,
+                    LocalizedStrings.Connection_CONNECTION_HANDSHAKE_WITH_0_TIMED_OUT_AFTER_WAITING_1_MILLISECONDS
+                        .toLocalizedString(
+                            new Object[] {peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)}));
+              } else {
+                peerName = "socket " + this.socket.getRemoteSocketAddress().toString() + ":"
+                    + this.socket.getPort();
+              }
+              throw new ConnectionException(
+                  LocalizedStrings.Connection_CONNECTION_HANDSHAKE_WITH_0_TIMED_OUT_AFTER_WAITING_1_MILLISECONDS
+                      .toLocalizedString(
+                          new Object[] {peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)}));
+            } else {
+              success = this.handshakeRead;
+            }
+          } catch (InterruptedException ex) {
+            interrupted = true;
+            this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+            reason = LocalizedStrings.Connection_INTERRUPTED.toLocalizedString();
+          } finally {
+            if (interrupted) {
+              Thread.currentThread().interrupt();
+            }
+            if (success) {
+              if (this.isReceiver) {
+                needToClose =
+                    !owner.getConduit().getMembershipManager().addSurpriseMember(this.remoteAddr);
+                if (needToClose) {
+                  reason = "this member is shunned";
+                }
+              }
+            } else {
+              needToClose = true; // for bug 42159
+            }
-          else {
-            needToClose = true; // for bug 42159
-          }
-        }
-      } // !handshakeRead
-    } // synchronized
+        } // !handshakeRead
+      } // synchronized
-        } 
-        catch (Exception ignore) {
+        } catch (Exception ignore) {
-  
+
-  
+
-    
-    // we do the close in a background thread because the operation may hang if 
-    // there is a problem with the network.  See bug #46659
+
+    // we do the close in a background thread because the operation may hang if
+    // there is a problem with the network. See bug #46659
-    }
-    else {
+    } else {
-  
+
-    synchronized(stateLock) {
+    synchronized (stateLock) {
-   * waits until we've joined the distributed system
-   * before returning
+   * waits until we've joined the distributed system before returning
-        }
-        catch (InterruptedException ie) {
+        } catch (InterruptedException ie) {
-    
+
-    final MsgOutputStream connectHandshake
-      = new MsgOutputStream(CONNECT_HANDSHAKE_SIZE);
-    //connectHandshake.reset();
+    final MsgOutputStream connectHandshake = new MsgOutputStream(CONNECT_HANDSHAKE_SIZE);
+    // connectHandshake.reset();
-     * Note a byte of zero is always written because old products
-     * serialized a member id with always sends an ip address.
-     * My reading of the ip-address specs indicated that the first byte
-     * of a valid address would never be 0.
+     * Note a byte of zero is always written because old products serialized a member id with always
+     * sends an ip address. My reading of the ip-address specs indicated that the first byte of a
+     * valid address would never be 0.
-    connectHandshake.writeInt(dominoCount.get()+1);
-// this writes the sending member + thread name that is stored in senderName
-// on the receiver to show the cause of reader thread creation
-//    if (dominoCount.get() > 0) {
-//      connectHandshake.writeUTF(Thread.currentThread().getName());
-//    } else {
-//      String name = owner.getDM().getConfig().getName();
-//      if (name == null) {
-//        name = "pid="+OSProcess.getId();
-//      }
-//      connectHandshake.writeUTF("["+name+"] "+Thread.currentThread().getName());
-//    }
-    connectHandshake.setMessageHeader(NORMAL_MSG_TYPE, DistributionManager.STANDARD_EXECUTOR, MsgIdGenerator.NO_MSG_ID);
+    connectHandshake.writeInt(dominoCount.get() + 1);
+    // this writes the sending member + thread name that is stored in senderName
+    // on the receiver to show the cause of reader thread creation
+    // if (dominoCount.get() > 0) {
+    // connectHandshake.writeUTF(Thread.currentThread().getName());
+    // } else {
+    // String name = owner.getDM().getConfig().getName();
+    // if (name == null) {
+    // name = "pid="+OSProcess.getId();
+    // }
+    // connectHandshake.writeUTF("["+name+"] "+Thread.currentThread().getName());
+    // }
+    connectHandshake.setMessageHeader(NORMAL_MSG_TYPE, DistributionManager.STANDARD_EXECUTOR,
+        MsgIdGenerator.NO_MSG_ID);
-    //this.output = new BufferedOutputStream(getSocket().getOutputStream(), owner.getConduit().bufferSize);
+    // this.output = new BufferedOutputStream(getSocket().getOutputStream(),
+    // owner.getConduit().bufferSize);
-    os.writeInt(dominoCount.get()+1);
- // this writes the sending member + thread name that is stored in senderName
- // on the receiver to show the cause of reader thread creation
-//    if (dominoCount.get() > 0) {
-//      os.writeUTF(Thread.currentThread().getName());
-//    } else {
-//      String name = owner.getDM().getConfig().getName();
-//      if (name == null) {
-//        name = "pid="+OSProcess.getId();
-//      }
-//      os.writeUTF("["+name+"] "+Thread.currentThread().getName());
-//    }
+    os.writeInt(dominoCount.get() + 1);
+    // this writes the sending member + thread name that is stored in senderName
+    // on the receiver to show the cause of reader thread creation
+    // if (dominoCount.get() > 0) {
+    // os.writeUTF(Thread.currentThread().getName());
+    // } else {
+    // String name = owner.getDM().getConfig().getName();
+    // if (name == null) {
+    // name = "pid="+OSProcess.getId();
+    // }
+    // os.writeUTF("["+name+"] "+Thread.currentThread().getName());
+    // }
-    lenbytes[MSG_HEADER_SIZE_OFFSET] = (byte)((len/0x1000000) & 0xff);
-    lenbytes[MSG_HEADER_SIZE_OFFSET+1] = (byte)((len/0x10000) & 0xff);
-    lenbytes[MSG_HEADER_SIZE_OFFSET+2] = (byte)((len/0x100) & 0xff);
-    lenbytes[MSG_HEADER_SIZE_OFFSET+3] = (byte)(len & 0xff);
-    lenbytes[MSG_HEADER_TYPE_OFFSET] = (byte)NORMAL_MSG_TYPE;
-    lenbytes[MSG_HEADER_ID_OFFSET] = (byte)((MsgIdGenerator.NO_MSG_ID/0x100) & 0xff);
-    lenbytes[MSG_HEADER_ID_OFFSET+1] = (byte)(MsgIdGenerator.NO_MSG_ID & 0xff);
-    synchronized(outLock) {
+    lenbytes[MSG_HEADER_SIZE_OFFSET] = (byte) ((len / 0x1000000) & 0xff);
+    lenbytes[MSG_HEADER_SIZE_OFFSET + 1] = (byte) ((len / 0x10000) & 0xff);
+    lenbytes[MSG_HEADER_SIZE_OFFSET + 2] = (byte) ((len / 0x100) & 0xff);
+    lenbytes[MSG_HEADER_SIZE_OFFSET + 3] = (byte) (len & 0xff);
+    lenbytes[MSG_HEADER_TYPE_OFFSET] = (byte) NORMAL_MSG_TYPE;
+    lenbytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID / 0x100) & 0xff);
+    lenbytes[MSG_HEADER_ID_OFFSET + 1] = (byte) (MsgIdGenerator.NO_MSG_ID & 0xff);
+    synchronized (outLock) {
-//        this.writerThread = Thread.currentThread();
+        // this.writerThread = Thread.currentThread();
-      }
-      finally {
-//        this.writerThread = null;
+      } finally {
+        // this.writerThread = null;
-    // send this server's port.  It's expected on the other side
+    // send this server's port. It's expected on the other side
-    }
-    else {
+    } else {
-  /** time between connection attempts*/
-  private static final int RECONNECT_WAIT_TIME
-      = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "RECONNECT_WAIT_TIME", 2000).intValue();
+  /** time between connection attempts */
+  private static final int RECONNECT_WAIT_TIME = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "RECONNECT_WAIT_TIME", 2000).intValue();
-  /** creates a new connection to a remote server.
-   *  We are initiating this connection; the other side must accept us
-   *  We will almost always send messages; small acks are received.
+  /**
+   * creates a new connection to a remote server. We are initiating this connection; the other side
+   * must accept us We will almost always send messages; small acks are received.
-  protected static Connection createSender(final MembershipManager mgr,
-                                           final ConnectionTable t,
-                                           final boolean preserveOrder,
-                                           final DistributedMember remoteAddr,
-                                           final boolean sharedResource,
-                                           final long startTime,
-                                           final long ackTimeout,
-                                           final long ackSATimeout)
-    throws IOException, DistributedSystemDisconnectedException
-  {
+  protected static Connection createSender(final MembershipManager mgr, final ConnectionTable t,
+      final boolean preserveOrder, final DistributedMember remoteAddr, final boolean sharedResource,
+      final long startTime, final long ackTimeout, final long ackSATimeout)
+      throws IOException, DistributedSystemDisconnectedException {
-    // keep trying.  Note that this may be executing during the shutdown window
+    // keep trying. Note that this may be executing during the shutdown window
-    // interrupted.  In this case we must allow the connection to succeed even
+    // interrupted. In this case we must allow the connection to succeed even
-        if (!severeAlertIssued && ackSATimeout > 0  &&  startTime + ackTimeout < now) {
+        if (!severeAlertIssued && ackSATimeout > 0 && startTime + ackTimeout < now) {
-                  LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_TO_0_IN_OVER_1_SECONDS, new Object[] { remoteAddr,
-                  (ackSATimeout + ackTimeout) / 1000 }));
+                  LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_TO_0_IN_OVER_1_SECONDS,
+                  new Object[] {remoteAddr, (ackSATimeout + ackTimeout) / 1000}));
-          }
-          else if (!suspected) {
+          } else if (!suspected) {
-                  new Object[] { remoteAddr, (ackTimeout)/1000 }));
+                  new Object[] {remoteAddr, (ackTimeout) / 1000}));
-            mgr.suspectMember(remoteAddr, LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME.toLocalizedString());
+            mgr.suspectMember(remoteAddr,
+                LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME
+                    .toLocalizedString());
-          reconnectWaitTime = Math.min(RECONNECT_WAIT_TIME,
-              ackSATimeout - (now - startTime - ackTimeout));
+          reconnectWaitTime =
+              Math.min(RECONNECT_WAIT_TIME, ackSATimeout - (now - startTime - ackTimeout));
-          mgr.suspectMember(remoteAddr, LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME.toLocalizedString());
+          mgr.suspectMember(remoteAddr,
+              LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME
+                  .toLocalizedString());
-          if (!mgr.memberExists(remoteAddr) || mgr.isShunned(remoteAddr) || mgr.shutdownInProgress()) {
+          if (!mgr.memberExists(remoteAddr) || mgr.isShunned(remoteAddr)
+              || mgr.shutdownInProgress()) {
-        }
-        else {
-          // if we're sending an alert and can't connect, bail out.  A sick
+        } else {
+          // if we're sending an alert and can't connect, bail out. A sick
-            
+
-          }
-          catch (InterruptedException ie) {
+          } catch (InterruptedException ie) {
-            throw new IOException(LocalizedStrings.Connection_MEMBER_LEFT_THE_GROUP.toLocalizedString(remoteAddr));
+            throw new IOException(
+                LocalizedStrings.Connection_MEMBER_LEFT_THE_GROUP.toLocalizedString(remoteAddr));
-            logger.warn(LocalizedMessage.create(LocalizedStrings.Connection_CONNECTION_ATTEMPTING_RECONNECT_TO_PEER__0, remoteAddr));
-          }          
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.Connection_CONNECTION_ATTEMPTING_RECONNECT_TO_PEER__0,
+                remoteAddr));
+          }
-        //create connection
+        // create connection
-        }
-        catch (javax.net.ssl.SSLHandshakeException se) {
+        } catch (javax.net.ssl.SSLHandshakeException se) {
-        }
-        catch (IOException ioe) {
+        } catch (IOException ioe) {
-          }
-          else if (!connectionErrorLogged) {
-            connectionErrorLogged = true; // otherwise change to use 100ms intervals causes a lot of these
+          } else if (!connectionErrorLogged) {
+            connectionErrorLogged = true; // otherwise change to use 100ms intervals causes a lot of
+                                          // these
-                throw new IOException(LocalizedStrings.Connection_MEMBER_LEFT_THE_GROUP.toLocalizedString(remoteAddr));
+                throw new IOException(LocalizedStrings.Connection_MEMBER_LEFT_THE_GROUP
+                    .toLocalizedString(remoteAddr));
-            }
-            else {
+            } else {
-          }
-          catch (DistributedSystemDisconnectedException e) {
+          } catch (DistributedSystemDisconnectedException e) {
-          }
-          catch (ConnectionException e) {
+          } catch (ConnectionException e) {
-              IOException ioe = new IOException(LocalizedStrings.Connection_HANDSHAKE_FAILED.toLocalizedString());
+              IOException ioe =
+                  new IOException(LocalizedStrings.Connection_HANDSHAKE_FAILED.toLocalizedString());
-                new Object[] {sharedResource, preserveOrder, remoteAddr ,e}));
-          }
-          catch (IOException e) {
+                new Object[] {sharedResource, preserveOrder, remoteAddr, e}));
+          } catch (IOException e) {
-                new Object[] {sharedResource, preserveOrder, remoteAddr ,e}));
+                new Object[] {sharedResource, preserveOrder, remoteAddr, e}));
-          }
-          finally {
+          } finally {
-                conn.requestClose(LocalizedStrings.Connection_FAILED_HANDSHAKE.toLocalizedString()); 
-              } catch (Exception ignore) {}
+                conn.requestClose(LocalizedStrings.Connection_FAILED_HANDSHAKE.toLocalizedString());
+              } catch (Exception ignore) {
+              }
-    }
-    finally {
+    } finally {
-      }
-      finally {
+      } finally {
-    //Assert.assertTrue(conn != null);
+    // Assert.assertTrue(conn != null);
-        LocalizedStrings.Connection_CONNECTION_FAILED_CONSTRUCTION_FOR_PEER_0
-          .toLocalizedString(remoteAddr));
+          LocalizedStrings.Connection_CONNECTION_FAILED_CONSTRUCTION_FOR_PEER_0
+              .toLocalizedString(remoteAddr));
-  
+
-  
-  /** creates a new connection to a remote server.
-   *  We are initiating this connection; the other side must accept us
-   *  We will almost always send messages; small acks are received.
-   */
-  private Connection(MembershipManager mgr,
-                     ConnectionTable t,
-                     boolean preserveOrder,
-                     DistributedMember remoteID,
-                     boolean sharedResource)
-    throws IOException, DistributedSystemDisconnectedException
-  {
-    //initialize a socket upfront. So that the
-    InternalDistributedMember remoteAddr = (InternalDistributedMember)remoteID;
+  /**
+   * creates a new connection to a remote server. We are initiating this connection; the other side
+   * must accept us We will almost always send messages; small acks are received.
+   */
+  private Connection(MembershipManager mgr, ConnectionTable t, boolean preserveOrder,
+      DistributedMember remoteID, boolean sharedResource)
+      throws IOException, DistributedSystemDisconnectedException {
+
+    // initialize a socket upfront. So that the
+    InternalDistributedMember remoteAddr = (InternalDistributedMember) remoteID;
-      throw new IllegalArgumentException(LocalizedStrings.Connection_CONNECTIONTABLE_IS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.Connection_CONNECTIONTABLE_IS_NULL.toLocalizedString());
-    InetSocketAddress addr = new InetSocketAddress(remoteAddr.getInetAddress(), remoteAddr.getDirectChannelPort());
+    InetSocketAddress addr =
+        new InetSocketAddress(remoteAddr.getInetAddress(), remoteAddr.getDirectChannelPort());
-  
-        /** If conserve-sockets is false, the socket can be used for receiving responses,
-         * so set the receive buffer accordingly.
+
+        /**
+         * If conserve-sockets is false, the socket can be used for receiving responses, so set the
+         * receive buffer accordingly.
-        if(!sharedResource) {
+        if (!sharedResource) {
-        } 
-        else {
-          setReceiveBufferSize(channel.socket(), SMALL_BUFFER_SIZE); // make small since only receive ack messages
+        } else {
+          setReceiveBufferSize(channel.socket(), SMALL_BUFFER_SIZE); // make small since only
+                                                                     // receive ack messages
-        int connectTime = getP2PConnectTimeout();; 
+        int connectTime = getP2PConnectTimeout();;
-          //             instead of an IOException on timeouts
-          ConnectException c = new ConnectException(LocalizedStrings.Connection_ATTEMPT_TO_CONNECT_TIMED_OUT_AFTER_0_MILLISECONDS
-              .toLocalizedString(new Object[]{connectTime}));
+          // instead of an IOException on timeouts
+          ConnectException c = new ConnectException(
+              LocalizedStrings.Connection_ATTEMPT_TO_CONNECT_TIMED_OUT_AFTER_0_MILLISECONDS
+                  .toLocalizedString(new Object[] {connectTime}));
-          //             instead of an IOException on timeouts
-          ConnectException c = new ConnectException(LocalizedStrings.Connection_ATTEMPT_TO_CONNECT_TIMED_OUT_AFTER_0_MILLISECONDS
-              .toLocalizedString(new Object[]{connectTime}));
+          // instead of an IOException on timeouts
+          ConnectException c = new ConnectException(
+              LocalizedStrings.Connection_ATTEMPT_TO_CONNECT_TIMED_OUT_AFTER_0_MILLISECONDS
+                  .toLocalizedString(new Object[] {connectTime}));
-      }
-      finally {
+      } finally {
-    }
-    else {
+    } else {
-        //  .createSocket(remoteAddr.getInetAddress(), remoteAddr.getPort());
-        int socketBufferSize = sharedResource ? SMALL_BUFFER_SIZE : this.owner.getConduit().tcpBufferSize;
-        this.socket = owner.getConduit().getSocketCreator()
-                           .connectForServer( remoteAddr.getInetAddress(), remoteAddr.getDirectChannelPort(), socketBufferSize );
+        // .createSocket(remoteAddr.getInetAddress(), remoteAddr.getPort());
+        int socketBufferSize =
+            sharedResource ? SMALL_BUFFER_SIZE : this.owner.getConduit().tcpBufferSize;
+        this.socket = owner.getConduit().getSocketCreator().connectForServer(
+            remoteAddr.getInetAddress(), remoteAddr.getDirectChannelPort(), socketBufferSize);
-      }
-      else {
-        //socket = new Socket(remoteAddr.getInetAddress(), remoteAddr.getPort());
+      } else {
+        // socket = new Socket(remoteAddr.getInetAddress(), remoteAddr.getPort());
-    try { getSocket().setTcpNoDelay(true); } catch (SocketException e) {  }
+    try {
+      getSocket().setTcpNoDelay(true);
+    } catch (SocketException e) {
+    }
-   * Batch sends currently should not be turned on because:
-   *  1. They will be used for all sends (instead of just no-ack)
-   *     and thus will break messages that wait for a response (or kill perf).
-   *  2. The buffer is not properly flushed and closed on shutdown.
-   *     The code attempts to do this but must not be doing it  correctly.
+   * Batch sends currently should not be turned on because: 1. They will be used for all sends
+   * (instead of just no-ack) and thus will break messages that wait for a response (or kill perf).
+   * 2. The buffer is not properly flushed and closed on shutdown. The code attempts to do this but
+   * must not be doing it correctly.
-  protected static final int BATCH_BUFFER_SIZE = Integer.getInteger("p2p.batchBufferSize", 1024*1024).intValue();
-  protected static final int BATCH_FLUSH_MS = Integer.getInteger("p2p.batchFlushTime", 50).intValue();
+  protected static final int BATCH_BUFFER_SIZE =
+      Integer.getInteger("p2p.batchBufferSize", 1024 * 1024).intValue();
+  protected static final int BATCH_FLUSH_MS =
+      Integer.getInteger("p2p.batchFlushTime", 50).intValue();
-  private class BatchBufferFlusher extends Thread  {
+  private class BatchBufferFlusher extends Thread {
+
-              batchLock.wait();  // spurious wakeup ok
-            } 
-            catch (InterruptedException ex) {
+              batchLock.wait(); // spurious wakeup ok
+            } catch (InterruptedException ex) {
-            }
-            finally {
+            } finally {
-            if (!this.flushNeeded && fillBatchBuffer.position() <= (BATCH_BUFFER_SIZE/2)) {
+            if (!this.flushNeeded && fillBatchBuffer.position() <= (BATCH_BUFFER_SIZE / 2)) {
-            if (this.flushNeeded || fillBatchBuffer.position() > (BATCH_BUFFER_SIZE/2)) {
+            if (this.flushNeeded || fillBatchBuffer.position() > (BATCH_BUFFER_SIZE / 2)) {
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0,ex));
+                  logger.fatal(LocalizedMessage.create(
+                      LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0, ex));
-                  requestClose(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0.toLocalizedString(ex));
+                  requestClose(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0
+                      .toLocalizedString(ex));
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0,ex));
+                  logger.fatal(LocalizedMessage.create(
+                      LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0, ex));
-                  requestClose(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0.toLocalizedString(ex));
+                  requestClose(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0
+                      .toLocalizedString(ex));
-//        Thread.currentThread().interrupt();
+        // Thread.currentThread().interrupt();
-  /** use to test message prep overhead (no socket write).
-   * WARNING: turning this on completely disables distribution of batched sends
+  /**
+   * use to test message prep overhead (no socket write). WARNING: turning this on completely
+   * disables distribution of batched sends
-      Assert.assertTrue(src.remaining() <= BATCH_BUFFER_SIZE , "Message size(" + src.remaining() + ") exceeded BATCH_BUFFER_SIZE(" + BATCH_BUFFER_SIZE + ")");
+      Assert.assertTrue(src.remaining() <= BATCH_BUFFER_SIZE, "Message size(" + src.remaining()
+          + ") exceeded BATCH_BUFFER_SIZE(" + BATCH_BUFFER_SIZE + ")");
-   * Request that the manager close this connection, or close it
-   * forcibly if there is no manager.  Invoking this method ensures
-   * that the proper synchronization is done.
+   * Request that the manager close this connection, or close it forcibly if there is no manager.
+   * Invoking this method ensures that the proper synchronization is done.
-   * Used to close a connection that has not yet been registered
-   * with the distribution manager.
+   * Used to close a connection that has not yet been registered with the distribution manager.
-  
+
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="TLW_TWO_LOCK_WAIT")
-  private void close(String reason, boolean cleanupEndpoint, 
-      boolean p_removeEndpoint, boolean beingSick, boolean forceRemoval) {
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "TLW_TWO_LOCK_WAIT")
+  private void close(String reason, boolean cleanupEndpoint, boolean p_removeEndpoint,
+      boolean beingSick, boolean forceRemoval) {
-    synchronized (this) {
-      this.stopped = true;
-      if (this.connected) {
-        if (this.asyncQueuingInProgress
-            && this.pusherThread != Thread.currentThread()) {
-          // We don't need to do this if we are the pusher thread
-          // and we have determined that we need to close the connection.
-          // See bug 37601.
-          synchronized (this.outgoingQueue) {
-            // wait for the flusher to complete (it may timeout)
-            while (this.asyncQueuingInProgress) {
-              // Don't do this: causes closes to not get done in the event
-              // of an orderly shutdown:
-  //            this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-              boolean interrupted = Thread.interrupted();
-              try {
-                this.outgoingQueue.wait(); // spurious wakeup ok
-              } catch (InterruptedException ie) {
-                interrupted = true;
-  //                this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
+      synchronized (this) {
+        this.stopped = true;
+        if (this.connected) {
+          if (this.asyncQueuingInProgress && this.pusherThread != Thread.currentThread()) {
+            // We don't need to do this if we are the pusher thread
+            // and we have determined that we need to close the connection.
+            // See bug 37601.
+            synchronized (this.outgoingQueue) {
+              // wait for the flusher to complete (it may timeout)
+              while (this.asyncQueuingInProgress) {
+                // Don't do this: causes closes to not get done in the event
+                // of an orderly shutdown:
+                // this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+                boolean interrupted = Thread.interrupted();
+                try {
+                  this.outgoingQueue.wait(); // spurious wakeup ok
+                } catch (InterruptedException ie) {
+                  interrupted = true;
+                  // this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
+                } finally {
+                  if (interrupted)
+                    Thread.currentThread().interrupt();
+                }
+              } // while
+            } // synchronized
+          }
+          this.connected = false;
+          closeSenderSem();
+          {
+            final DMStats stats = this.owner.getConduit().stats;
+            if (this.finishedConnecting) {
+              if (this.isReceiver) {
+                stats.decReceivers();
+              } else {
+                stats.decSenders(this.sharedResource, this.preserveOrder);
-              finally {
-                if (interrupted) Thread.currentThread().interrupt();
-              }
-            } // while
-          } // synchronized
-        }
-        this.connected = false;
-        closeSenderSem();
-        {
-          final DMStats stats = this.owner.getConduit().stats;
-          if (this.finishedConnecting) {
-            if (this.isReceiver) {
-              stats.decReceivers();
-            } else {
-              stats.decSenders(this.sharedResource, this.preserveOrder);
+          if (logger.isDebugEnabled()) {
+            logger.debug("Closing socket for {}", this);
+          }
+        } else if (!forceRemoval) {
+          removeEndpoint = false;
-        if (logger.isDebugEnabled()) {
-          logger.debug("Closing socket for {}", this);
-        }
-      }
-        else if (!forceRemoval) {
-        removeEndpoint = false;
-      }
-      // make sure our socket is closed
-      asyncClose(false);
-      nioLengthSet = false;
-    } // synchronized
-    
+        // make sure our socket is closed
+        asyncClose(false);
+        nioLengthSet = false;
+      } // synchronized
+
-    // wait a bit for the our reader thread to exit
-    // don't wait if we are the reader thread
-    boolean isIBM = false;
-    // if network partition detection is enabled or this is an admin vm
-    // we can't wait for the reader thread when running in an IBM JRE.  See
-    // bug 41889
-    if (this.owner.owner.config.getEnableNetworkPartitionDetection() ||
-        this.owner.owner.getLocalAddr().getVmKind() == DistributionManager.ADMIN_ONLY_DM_TYPE ||
-        this.owner.owner.getLocalAddr().getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
-      isIBM = "IBM Corporation".equals(System.getProperty("java.vm.vendor"));
-    }
-    {
-      // Now that readerThread is returned to a pool after we close
-      // we need to be more careful not to join on a thread that belongs
-      // to someone else.
-      Thread readerThreadSnapshot = this.readerThread;
-      if (!beingSick && readerThreadSnapshot != null && !isIBM
-          && this.isRunning && !this.readerShuttingDown
-          && readerThreadSnapshot != Thread.currentThread()) {
-        try {
-          readerThreadSnapshot.join(500);
-          readerThreadSnapshot = this.readerThread;
-          if (this.isRunning && !this.readerShuttingDown
-              && readerThreadSnapshot != null
-              && owner.getDM().getRootCause() == null) { // don't wait twice if there's a system failure
-            readerThreadSnapshot.join(1500);
-            if (this.isRunning) {
-              logger.info(LocalizedMessage.create(LocalizedStrings.Connection_TIMED_OUT_WAITING_FOR_READERTHREAD_ON_0_TO_FINISH, this));
+      // wait a bit for the our reader thread to exit
+      // don't wait if we are the reader thread
+      boolean isIBM = false;
+      // if network partition detection is enabled or this is an admin vm
+      // we can't wait for the reader thread when running in an IBM JRE. See
+      // bug 41889
+      if (this.owner.owner.config.getEnableNetworkPartitionDetection()
+          || this.owner.owner.getLocalAddr().getVmKind() == DistributionManager.ADMIN_ONLY_DM_TYPE
+          || this.owner.owner.getLocalAddr().getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
+        isIBM = "IBM Corporation".equals(System.getProperty("java.vm.vendor"));
+      }
+      {
+        // Now that readerThread is returned to a pool after we close
+        // we need to be more careful not to join on a thread that belongs
+        // to someone else.
+        Thread readerThreadSnapshot = this.readerThread;
+        if (!beingSick && readerThreadSnapshot != null && !isIBM && this.isRunning
+            && !this.readerShuttingDown && readerThreadSnapshot != Thread.currentThread()) {
+          try {
+            readerThreadSnapshot.join(500);
+            readerThreadSnapshot = this.readerThread;
+            if (this.isRunning && !this.readerShuttingDown && readerThreadSnapshot != null
+                && owner.getDM().getRootCause() == null) { // don't wait twice if there's a system
+                                                           // failure
+              readerThreadSnapshot.join(1500);
+              if (this.isRunning) {
+                logger.info(LocalizedMessage.create(
+                    LocalizedStrings.Connection_TIMED_OUT_WAITING_FOR_READERTHREAD_ON_0_TO_FINISH,
+                    this));
+              }
+          } catch (IllegalThreadStateException ignore) {
+            // ignored - thread already stopped
+          } catch (InterruptedException ignore) {
+            Thread.currentThread().interrupt();
+            // but keep going, we're trying to close.
-        catch (IllegalThreadStateException ignore) {
-          // ignored - thread already stopped
-        }
-        catch (InterruptedException ignore) {
-          Thread.currentThread().interrupt();
-          // but keep going, we're trying to close.
-        }
-    }
-    closeBatchBuffer();
-    closeAllMsgDestreamers();
+      closeBatchBuffer();
+      closeAllMsgDestreamers();
-          }
-          else {
+          } else {
-        }
-        else if (!this.isReceiver) {
+        } else if (!this.isReceiver) {
-      }
-      else {
+      } else {
-        }
-        else if (!this.isReceiver) {
+        } else if (!this.isReceiver) {
-    
-    //This cancels the idle timer task, but it also removes the tasks
-    //reference to this connection, freeing up the connection (and it's buffers
-    //for GC sooner.
-    if(idleTask != null) {
+
+    // This cancels the idle timer task, but it also removes the tasks
+    // reference to this connection, freeing up the connection (and it's buffers
+    // for GC sooner.
+    if (idleTask != null) {
-    
-    if(ackTimeoutTask!=null){
-        ackTimeoutTask.cancel();
+
+    if (ackTimeoutTask != null) {
+      ackTimeoutTask.cancel();
-  private void startReader(ConnectionTable connTable) { 
-    Assert.assertTrue(!this.isRunning); 
-    stopped = false; 
-    this.isRunning = true; 
-    connTable.executeCommand(this);  
-  } 
+  private void startReader(ConnectionTable connTable) {
+    Assert.assertTrue(!this.isRunning);
+    stopped = false;
+    this.isRunning = true;
+    connTable.executeCommand(this);
+  }
-  /** in order to read non-NIO socket-based messages we need to have a thread
-      actively trying to grab bytes out of the sockets input queue.
-      This is that thread. */
+  /**
+   * in order to read non-NIO socket-based messages we need to have a thread actively trying to grab
+   * bytes out of the sockets input queue. This is that thread.
+   */
-      if(tmp != null) {
+      if (tmp != null) {
-      sb.append('-')
-        .append(getUniqueId());
+      sb.append('-').append(getUniqueId());
-      // bug 37693: the channel was asynchronously closed.  Our work
+      // bug 37693: the channel was asynchronously closed. Our work
-      try { 
-        requestClose(LocalizedStrings.Connection_RUNNIOREADER_CAUGHT_CLOSED_CHANNEL.toLocalizedString()); 
-      } catch (Exception ignore) {}      
+      try {
+        requestClose(
+            LocalizedStrings.Connection_RUNNIOREADER_CAUGHT_CLOSED_CHANNEL.toLocalizedString());
+      } catch (Exception ignore) {
+      }
-        try { 
-          requestClose(LocalizedStrings.Connection_RUNNIOREADER_CAUGHT_SHUTDOWN.toLocalizedString());
-        } catch (Exception ignore) {}
+        try {
+          requestClose(
+              LocalizedStrings.Connection_RUNNIOREADER_CAUGHT_SHUTDOWN.toLocalizedString());
+        } catch (Exception ignore) {
+        }
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_FAILED_SETTING_CHANNEL_TO_BLOCKING_MODE_0, ex));
+      logger.fatal(LocalizedMessage
+          .create(LocalizedStrings.Connection_FAILED_SETTING_CHANNEL_TO_BLOCKING_MODE_0, ex));
-      try { requestClose(LocalizedStrings.Connection_FAILED_SETTING_CHANNEL_TO_BLOCKING_MODE_0.toLocalizedString(ex)); } catch (Exception ignore) {}
+      try {
+        requestClose(LocalizedStrings.Connection_FAILED_SETTING_CHANNEL_TO_BLOCKING_MODE_0
+            .toLocalizedString(ex));
+      } catch (Exception ignore) {
+      }
-//      Assert.assertTrue(owner != null, "How did owner become null");
+      // Assert.assertTrue(owner != null, "How did owner become null");
-            }
-            catch (IOException e) {
+            } catch (IOException e) {
-          synchronized(stateLock) {
+          synchronized (stateLock) {
-          synchronized(stateLock) {
+          synchronized (stateLock) {
-              requestClose(LocalizedStrings.Connection_SOCKETCHANNEL_READ_RETURNED_EOF.toLocalizedString());
+              requestClose(
+                  LocalizedStrings.Connection_SOCKETCHANNEL_READ_RETURNED_EOF.toLocalizedString());
-          if (!this.isReceiver
-              && (this.handshakeRead || this.handshakeCancelled)) {
+          if (!this.isReceiver && (this.handshakeRead || this.handshakeCancelled)) {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-          try { 
-            requestClose(LocalizedStrings.Connection_CACHECLOSED_IN_CHANNEL_READ_0.toLocalizedString(e));
-          } catch (Exception ex) {}
+          try {
+            requestClose(
+                LocalizedStrings.Connection_CACHECLOSED_IN_CHANNEL_READ_0.toLocalizedString(e));
+          } catch (Exception ex) {
+          }
-        }
-        catch (ClosedChannelException e) {
+        } catch (ClosedChannelException e) {
-          try { 
-            requestClose(LocalizedStrings.Connection_CLOSEDCHANNELEXCEPTION_IN_CHANNEL_READ_0.toLocalizedString(e));
-          } catch (Exception ex) {}
+          try {
+            requestClose(LocalizedStrings.Connection_CLOSEDCHANNELEXCEPTION_IN_CHANNEL_READ_0
+                .toLocalizedString(e));
+          } catch (Exception ex) {
+          }
-        }
-        catch (IOException e) {
-          if (! isSocketClosed()
-                && !"Socket closed".equalsIgnoreCase(e.getMessage()) // needed for Solaris jdk 1.4.2_08
-                ) {
+        } catch (IOException e) {
+          if (!isSocketClosed() && !"Socket closed".equalsIgnoreCase(e.getMessage()) // needed for
+                                                                                     // Solaris jdk
+                                                                                     // 1.4.2_08
+          ) {
-            if(e.getMessage().contains("interrupted by a call to WSACancelBlockingCall")) {
+            if (e.getMessage().contains("interrupted by a call to WSACancelBlockingCall")) {
-                logger.debug("{} received unexpected WSACancelBlockingCall exception, which may result in a hang", p2pReaderName()); 
+                logger.debug(
+                    "{} received unexpected WSACancelBlockingCall exception, which may result in a hang",
+                    p2pReaderName());
-          try { 
-            requestClose(LocalizedStrings.Connection_IOEXCEPTION_IN_CHANNEL_READ_0.toLocalizedString(e));
-          } catch (Exception ex) {}
+          try {
+            requestClose(
+                LocalizedStrings.Connection_IOEXCEPTION_IN_CHANNEL_READ_0.toLocalizedString(e));
+          } catch (Exception ex) {
+          }
-          if (!stopped && ! isSocketClosed() ) {
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_0_EXCEPTION_IN_CHANNEL_READ, p2pReaderName()), e);
+          if (!stopped && !isSocketClosed()) {
+            logger.fatal(LocalizedMessage.create(
+                LocalizedStrings.Connection_0_EXCEPTION_IN_CHANNEL_READ, p2pReaderName()), e);
-          try { 
-            requestClose(LocalizedStrings.Connection_0_EXCEPTION_IN_CHANNEL_READ.toLocalizedString(e)); 
-          } catch (Exception ex) {}
+          try {
+            requestClose(
+                LocalizedStrings.Connection_0_EXCEPTION_IN_CHANNEL_READ.toLocalizedString(e));
+          } catch (Exception ex) {
+          }
-    }
-    finally {
+    } finally {
-        synchronized(stateLock) {
+        synchronized (stateLock) {
-        logger.debug("{} runNioReader terminated id={} from {}", p2pReaderName(), conduitIdStr, remoteAddr);
+        logger.debug("{} runNioReader terminated id={} from {}", p2pReaderName(), conduitIdStr,
+            remoteAddr);
-  /** initiate suspect processing if a shared/ordered connection is lost and we're not shutting down */
+  /**
+   * initiate suspect processing if a shared/ordered connection is lost and we're not shutting down
+   */
-   * checks to see if an exception should not be logged: i.e., "forcibly closed",
-   * "reset by peer", or "connection reset"
-   * */
+   * checks to see if an exception should not be logged: i.e., "forcibly closed", "reset by peer",
+   * or "connection reset"
+   */
-    return (msg.indexOf("forcibly closed") >= 0)
-      ||   (msg.indexOf("reset by peer")   >= 0)
-      ||   (msg.indexOf("connection reset")   >= 0);
+    return (msg.indexOf("forcibly closed") >= 0) || (msg.indexOf("reset by peer") >= 0)
+        || (msg.indexOf("connection reset") >= 0);
-    return msgType == NORMAL_MSG_TYPE
-      || msgType == CHUNKED_MSG_TYPE
-      || msgType == END_CHUNKED_MSG_TYPE;
+    return msgType == NORMAL_MSG_TYPE || msgType == CHUNKED_MSG_TYPE
+        || msgType == END_CHUNKED_MSG_TYPE;
-          MsgDestreamer md = (MsgDestreamer)it.next();
+          MsgDestreamer md = (MsgDestreamer) it.next();
-      MsgDestreamer result = (MsgDestreamer)this.destreamerMap.get(key);
+      MsgDestreamer result = (MsgDestreamer) this.destreamerMap.get(key);
-          result = new MsgDestreamer(this.owner.getConduit().stats, 
+          result = new MsgDestreamer(this.owner.getConduit().stats,
+
-    if(directAck) {
+    if (directAck) {
-    } else if(rpId != 0) {
+    } else if (rpId != 0) {
+
-        logger.debug("Socket is of type: {}", getSocket().getClass() );
+        logger.debug("Socket is of type: {}", getSocket().getClass());
-    }
-    catch (IOException io) {
+    } catch (IOException io) {
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNABLE_TO_GET_INPUT_STREAM), io);
+      logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNABLE_TO_GET_INPUT_STREAM),
+          io);
-      Assert.assertTrue(owner != null, LocalizedStrings.Connection_OWNER_SHOULD_NOT_BE_NULL.toLocalizedString());
+      Assert.assertTrue(owner != null,
+          LocalizedStrings.Connection_OWNER_SHOULD_NOT_BE_NULL.toLocalizedString());
-            }
-            catch (IOException e) {
+            } catch (IOException e) {
-//        long recvNanos = DistributionStats.getStatTime();
-        len = ((lenbytes[MSG_HEADER_SIZE_OFFSET]&0xff) * 0x1000000) +
-          ((lenbytes[MSG_HEADER_SIZE_OFFSET+1]&0xff) * 0x10000) +
-          ((lenbytes[MSG_HEADER_SIZE_OFFSET+2]&0xff) * 0x100) +
-          (lenbytes[MSG_HEADER_SIZE_OFFSET+3]&0xff);
-        /*byte msgHdrVersion =*/ calcHdrVersion(len);
+        // long recvNanos = DistributionStats.getStatTime();
+        len = ((lenbytes[MSG_HEADER_SIZE_OFFSET] & 0xff) * 0x1000000)
+            + ((lenbytes[MSG_HEADER_SIZE_OFFSET + 1] & 0xff) * 0x10000)
+            + ((lenbytes[MSG_HEADER_SIZE_OFFSET + 2] & 0xff) * 0x100)
+            + (lenbytes[MSG_HEADER_SIZE_OFFSET + 3] & 0xff);
+        /* byte msgHdrVersion = */ calcHdrVersion(len);
-        short msgId = (short)((lenbytes[MSG_HEADER_ID_OFFSET]&0xff * 0x100)
-                              + (lenbytes[MSG_HEADER_ID_OFFSET+1]&0xff));
+        short msgId = (short) ((lenbytes[MSG_HEADER_ID_OFFSET] & 0xff * 0x100)
+            + (lenbytes[MSG_HEADER_ID_OFFSET + 1] & 0xff));
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0, Integer.valueOf(msgType)));
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0, Integer.valueOf(msgType)));
-          requestClose(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0.toLocalizedString(Integer.valueOf(msgType)));
+          requestClose(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0
+              .toLocalizedString(Integer.valueOf(msgType)));
-              //DMStats stats = this.owner.getConduit().stats;
-              //long start = DistributionStats.getStatTime();
+              // DMStats stats = this.owner.getConduit().stats;
+              // long start = DistributionStats.getStatTime();
-                msg = (DistributionMessage)InternalDataSerializer.readDSFID(dis);
+                msg = (DistributionMessage) InternalDataSerializer.readDSFID(dis);
-                      new Object[] { msg, Integer.valueOf(dis.available())}));
+                      new Object[] {msg, Integer.valueOf(dis.available())}));
-                //stats.incBatchCopyTime(start);
+                // stats.incBatchCopyTime(start);
-                  //start = DistributionStats.getStatTime();
+                  // start = DistributionStats.getStatTime();
-                  //stats.incBatchSendTime(start);
-                }
-                catch (MemberShunnedException e) {
+                  // stats.incBatchSendTime(start);
+                } catch (MemberShunnedException e) {
+                } catch (Exception de) {
+                  this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de); // bug
+                                                                                          // 37101
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
-                catch (Exception de) {
-                  this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de); // bug 37101
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
-                }
-              }
-              catch (VirtualMachineError err) {
+              } catch (VirtualMachineError err) {
-                // If this ever returns, rethrow the error.  We're poisoned
+                // If this ever returns, rethrow the error. We're poisoned
-              }
-              catch (Throwable e) {
+              } catch (Throwable e) {
-                // catch VirtualMachineError (see above).  However, there is
+                // catch VirtualMachineError (see above). However, there is
-                  String reason = LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE.toLocalizedString();
+                  String reason =
+                      LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE.toLocalizedString();
-                if(e instanceof CancelException) {
+                if (e instanceof CancelException) {
-                    // Just log a message if we had trouble deserializing due to CacheClosedException; see bug 43543
+                    // Just log a message if we had trouble deserializing due to
+                    // CacheClosedException; see bug 43543
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE), e);
-                //requestClose();
-                //return;
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE), e);
+                // requestClose();
+                // return;
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_FAILED_HANDLING_CHUNK_MESSAGE), ex);
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_FAILED_HANDLING_CHUNK_MESSAGE), ex);
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_FAILED_HANDLING_END_CHUNK_MESSAGE), ex);
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_FAILED_HANDLING_END_CHUNK_MESSAGE), ex);
-                logger.warn(LocalizedMessage.create(LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE_0, ex));
+                logger.warn(LocalizedMessage
+                    .create(LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE_0, ex));
-                failureMsg = LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE.toLocalizedString();
+                failureMsg = LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE
+                    .toLocalizedString();
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE), failureEx);
+                logger.fatal(LocalizedMessage.create(
+                    LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE), failureEx);
-              } 
-              catch (VirtualMachineError err) {
+              } catch (VirtualMachineError err) {
-                // If this ever returns, rethrow the error.  We're poisoned
+                // If this ever returns, rethrow the error. We're poisoned
-              }
-              catch (Throwable ex) {
+              } catch (Throwable ex) {
-                // catch VirtualMachineError (see above).  However, there is
+                // catch VirtualMachineError (see above). However, there is
-                failureMsg = LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE.toLocalizedString();
+                failureMsg = LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE
+                    .toLocalizedString();
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE), failureEx);
+                logger.fatal(
+                    LocalizedMessage.create(
+                        LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE),
+                    failureEx);
-                }
-                catch (MemberShunnedException e) {
+                } catch (MemberShunnedException e) {
-                }
-                catch (Exception de) {
+                } catch (Exception de) {
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
-                }
-                catch (ThreadDeath td) {
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                } catch (ThreadDeath td) {
-                } 
-                catch (VirtualMachineError err) {
+                } catch (VirtualMachineError err) {
-                  // If this ever returns, rethrow the error.  We're poisoned
+                  // If this ever returns, rethrow the error. We're poisoned
-                }
-                catch (Throwable t) {
+                } catch (Throwable t) {
-                  // catch VirtualMachineError (see above).  However, there is
+                  // catch VirtualMachineError (see above). However, there is
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
-              if (this.replyCode != REPLY_CODE_OK && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
+              if (this.replyCode != REPLY_CODE_OK
+                  && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
-                String err = LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0.toLocalizedString(replyCodeInteger);
-                
+                String err = LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0
+                    .toLocalizedString(replyCodeInteger);
+
-                }
-                else {
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0, replyCodeInteger));
+                } else {
+                  logger.fatal(LocalizedMessage.create(
+                      LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0,
+                      replyCodeInteger));
-                  break;
+                break;
-                this.asyncMaxQueueSize = (long)dis.readInt() * (1024*1024);
+                this.asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
-                  logger.info(LocalizedMessage.create(LocalizedStrings.
-                    Connection_0_ASYNC_CONFIGURATION_RECEIVED_1,
-                    new Object[] {p2pReaderName(),
-                      " asyncDistributionTimeout=" 
-                      + this.asyncDistributionTimeout
-                      + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                      + " asyncMaxQueueSize=" 
-                      + (this.asyncMaxQueueSize / (1024*1024))}));
+                  logger.info(LocalizedMessage.create(
+                      LocalizedStrings.Connection_0_ASYNC_CONFIGURATION_RECEIVED_1,
+                      new Object[] {p2pReaderName(),
+                          " asyncDistributionTimeout=" + this.asyncDistributionTimeout
+                              + " asyncQueueTimeout=" + this.asyncQueueTimeout
+                              + " asyncMaxQueueSize=" + (this.asyncMaxQueueSize / (1024 * 1024))}));
-                throw new IllegalStateException(LocalizedStrings.Connection_DETECTED_OLD_VERSION_PRE_5_0_1_OF_GEMFIRE_OR_NONGEMFIRE_DURING_HANDSHAKE_DUE_TO_INITIAL_BYTE_BEING_0.toLocalizedString(new Byte(b)));
+                throw new IllegalStateException(
+                    LocalizedStrings.Connection_DETECTED_OLD_VERSION_PRE_5_0_1_OF_GEMFIRE_OR_NONGEMFIRE_DURING_HANDSHAKE_DUE_TO_INITIAL_BYTE_BEING_0
+                        .toLocalizedString(new Byte(b)));
-                throw new IllegalStateException(LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
-                    .toLocalizedString(new Object[]{new Byte(HANDSHAKE_VERSION), new Byte(handShakeByte)}));
+                throw new IllegalStateException(
+                    LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
+                        .toLocalizedString(
+                            new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handShakeByte)}));
-              Thread.currentThread().setName(LocalizedStrings.Connection_P2P_MESSAGE_READER_FOR_0.toLocalizedString(this.remoteAddr, this.socket.getPort()));
+              Thread.currentThread().setName(LocalizedStrings.Connection_P2P_MESSAGE_READER_FOR_0
+                  .toLocalizedString(this.remoteAddr, this.socket.getPort()));
-              if (this.remoteVersion == null ||
-                  (this.remoteVersion.compareTo(Version.GFE_80) >= 0) ) {
+              if (this.remoteVersion == null
+                  || (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
-//                this.senderName = dis.readUTF();
+                // this.senderName = dis.readUTF();
-                    LocalizedStrings.Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS));
-// bug #49565 - if domino count is >= 2 use shared resources.
-// Also see DistributedCacheOperation#supportsDirectAck
+                      LocalizedStrings.Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS));
+                  // bug #49565 - if domino count is >= 2 use shared resources.
+                  // Also see DistributedCacheOperation#supportsDirectAck
-                    logger.debug("thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets", dominoNumber);
+                    logger.debug(
+                        "thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets",
+                        dominoNumber);
-//                } else {
-//                  ConnectionTable.threadWantsSharedResources();
-//                  logger.fine("thread-owned receiver with domino count of " + dominoNumber + " will prefer shared sockets");
+                  // } else {
+                  // ConnectionTable.threadWantsSharedResources();
+                  // logger.fine("thread-owned receiver with domino count of " + dominoNumber + "
+                  // will prefer shared sockets");
-              
+
-              String authInit = System
-                  .getProperty(DistributionConfigImpl.SECURITY_SYSTEM_PREFIX
-                      + SECURITY_PEER_AUTH_INIT);
+              String authInit = System.getProperty(
+                  DistributionConfigImpl.SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
-                }
-                else {
+                } else {
-                    LocalizedStrings.Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK, p2pReaderName()));
+                      LocalizedStrings.Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK,
+                      p2pReaderName()));
-              }
-              else {
+              } else {
-            if (!this.isReceiver
-                && (this.handshakeRead || this.handshakeCancelled)) {
+            if (!this.isReceiver && (this.handshakeRead || this.handshakeCancelled)) {
-                 if (this.handshakeRead) {
+                if (this.handshakeRead) {
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_0_STRAY_INTERRUPT_READING_MESSAGE, p2pReaderName()), e);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.Connection_0_STRAY_INTERRUPT_READING_MESSAGE, p2pReaderName()), e);
-        }
-        catch (Exception ioe) {
+        } catch (Exception ioe) {
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_0_ERROR_READING_MESSAGE, p2pReaderName()), ioe);
+            logger.fatal(LocalizedMessage
+                .create(LocalizedStrings.Connection_0_ERROR_READING_MESSAGE, p2pReaderName()), ioe);
-        }
-        finally {
+        } finally {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-        try { 
-          requestClose(LocalizedStrings.Connection_CACHECLOSED_IN_CHANNEL_READ_0.toLocalizedString(e));
-        } catch (Exception ex) {}
+        try {
+          requestClose(
+              LocalizedStrings.Connection_CACHECLOSED_IN_CHANNEL_READ_0.toLocalizedString(e));
+        } catch (Exception ex) {
+        }
-      }
-      catch (IOException io) {
-        boolean closed = isSocketClosed()
-                || "Socket closed".equalsIgnoreCase(io.getMessage()); // needed for Solaris jdk 1.4.2_08
+      } catch (IOException io) {
+        boolean closed = isSocketClosed() || "Socket closed".equalsIgnoreCase(io.getMessage()); // needed
+                                                                                                // for
+                                                                                                // Solaris
+                                                                                                // jdk
+                                                                                                // 1.4.2_08
-        try { 
+        try {
-        } catch (Exception ex) {}
+        } catch (Exception ex) {
+        }
-        }
-        else {
+        } else {
-          try { Thread.sleep(1000); } catch (InterruptedException ie) {
+          try {
+            Thread.sleep(1000);
+          } catch (InterruptedException ie) {
-        if (!stopped && !(e instanceof InterruptedException) ) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_0_EXCEPTION_RECEIVED, p2pReaderName()), e);
+        if (!stopped && !(e instanceof InterruptedException)) {
+          logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_0_EXCEPTION_RECEIVED,
+              p2pReaderName()), e);
-        }
-        else {
+        } else {
-          try { requestClose(LocalizedStrings.Connection_0_EXCEPTION_RECEIVED.toLocalizedString(e)); } catch (Exception ex) {}
+          try {
+            requestClose(LocalizedStrings.Connection_0_EXCEPTION_RECEIVED.toLocalizedString(e));
+          } catch (Exception ex) {
+          }
-          try { Thread.sleep(1000); } catch (InterruptedException ie) {
+          try {
+            Thread.sleep(1000);
+          } catch (InterruptedException ie) {
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="DE_MIGHT_IGNORE")
+
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "DE_MIGHT_IGNORE")
-        synchronized(stateLock) {
+        synchronized (stateLock) {
-        int bytesThisTime = input.read(buffer, bytesSoFar, len-bytesSoFar);
+        int bytesThisTime = input.read(buffer, bytesSoFar, len - bytesSoFar);
-          try {  
-            requestClose(LocalizedStrings.Connection_STREAM_READ_RETURNED_NONPOSITIVE_LENGTH.toLocalizedString());
-          } catch (Exception ex) {  }
+          try {
+            requestClose(LocalizedStrings.Connection_STREAM_READ_RETURNED_NONPOSITIVE_LENGTH
+                .toLocalizedString());
+          } catch (Exception ex) {
+          }
-      }
-      catch (InterruptedIOException io) {
-//      try { Thread.sleep(10); }
-//      catch (InterruptedException ie) {
-//        Thread.currentThread().interrupt();
-//      }
+      } catch (InterruptedIOException io) {
+        // try { Thread.sleep(10); }
+        // catch (InterruptedException ie) {
+        // Thread.currentThread().interrupt();
+        // }
-        // Current thread has been interrupted.  Regard it similar to an EOF
+        // Current thread has been interrupted. Regard it similar to an EOF
-        } catch (Exception ex) { }
+        } catch (Exception ex) {
+        }
-      }
-      finally {
-        synchronized(stateLock) {
+      } finally {
+        synchronized (stateLock) {
-   * sends a serialized message to the other end of this connection.  This
-      is used by the DirectChannel in GemFire when the message is going to
-      be sent to multiple recipients.
+   * sends a serialized message to the other end of this connection. This is used by the
+   * DirectChannel in GemFire when the message is going to be sent to multiple recipients.
+   * 
-  public void sendPreserialized(ByteBuffer buffer,
-      boolean cacheContentChanges, DistributionMessage msg)
-    throws IOException, ConnectionException
-  {
+  public void sendPreserialized(ByteBuffer buffer, boolean cacheContentChanges,
+      DistributionMessage msg) throws IOException, ConnectionException {
-      throw new ConnectionException(LocalizedStrings.Connection_NOT_CONNECTED_TO_0.toLocalizedString(this.remoteAddr));
+      throw new ConnectionException(
+          LocalizedStrings.Connection_NOT_CONNECTED_TO_0.toLocalizedString(this.remoteAddr));
-                            buffer.limit() - buffer.position());
+              buffer.limit() - buffer.position());
-          synchronized(outLock) {
+          synchronized (outLock) {
-//              this.writerThread = Thread.currentThread();
+              // this.writerThread = Thread.currentThread();
-            }
-            finally {
-//              this.writerThread = null;
+            } finally {
+              // this.writerThread = null;
+
-   * If <code>use</code> is true then "claim" the connection for our use.
-   * If <code>use</code> is false then "release" the connection.
-   * Fixes bug 37657.
-   * @return true if connection was already in use at time of call;
-   *         false if not.
+   * If <code>use</code> is true then "claim" the connection for our use. If <code>use</code> is
+   * false then "release" the connection. Fixes bug 37657.
+   * 
+   * @return true if connection was already in use at time of call; false if not.
-  public boolean setInUse(boolean use, long startTime, long ackWaitThreshold, long ackSAThreshold, List connectionGroup) {
+  public boolean setInUse(boolean use, long startTime, long ackWaitThreshold, long ackSAThreshold,
+      List connectionGroup) {
-    synchronized(this) {
+    synchronized (this) {
-      }
-      else {
+      } else {
-  
+
-   * For testing we want to configure the connection without having
-   * to read a handshake
+   * For testing we want to configure the connection without having to read a handshake
-  
+
-          synchronized(Connection.this) {
+          synchronized (Connection.this) {
-            // want to complain about all receivers out just because one was slow.  We therefore reset
+            // want to complain about all receivers out just because one was slow. We therefore
+            // reset
-            for (Iterator it=group.iterator(); it.hasNext(); ) {
-              Connection con = (Connection)it.next();
+            for (Iterator it = group.iterator(); it.hasNext();) {
+              Connection con = (Connection) it.next();
-      
-      synchronized(owner) {
+
+      synchronized (owner) {
-          }
-          else {
+          } else {
-    if (ackSATimeout > 0
-        && (transmissionStartTime + ackWaitTimeout + ackSATimeout) <= now) {
+    if (ackSATimeout > 0 && (transmissionStartTime + ackWaitTimeout + ackSATimeout) <= now) {
-          new Object[] {Long.valueOf((ackWaitTimeout+ackSATimeout)/1000), getRemoteAddress(), ackThreadName}));
+          new Object[] {Long.valueOf((ackWaitTimeout + ackSATimeout) / 1000), getRemoteAddress(),
+              ackThreadName}));
-    }
-    else if (!ackTimedOut
-        && (0 < ackWaitTimeout) 
+    } else if (!ackTimedOut && (0 < ackWaitTimeout)
-          new Object[] {Long.valueOf(ackWaitTimeout/1000), getRemoteAddress(), ackThreadName}));
+          new Object[] {Long.valueOf(ackWaitTimeout / 1000), getRemoteAddress(), ackThreadName}));
-      
-      final StringId state = (connectionState == Connection.STATE_SENDING)?
-          LocalizedStrings.Connection_TRANSMIT_ACKWAITTHRESHOLD : LocalizedStrings.Connection_RECEIVE_ACKWAITTHRESHOLD;
+
+      final StringId state = (connectionState == Connection.STATE_SENDING)
+          ? LocalizedStrings.Connection_TRANSMIT_ACKWAITTHRESHOLD
+          : LocalizedStrings.Connection_RECEIVE_ACKWAITTHRESHOLD;
-        .suspectMembers(Collections.singleton(getRemoteAddress()), state.toLocalizedString());
+            .suspectMembers(Collections.singleton(getRemoteAddress()), state.toLocalizedString());
-//  private String socketInfo() {
-//    return (" socket: " + getSocket().getLocalAddress() + ":" + getSocket().getLocalPort() + " -> " +
-//            getSocket().getInetAddress() + ":" + getSocket().getPort() + " connection = " + System.identityHashCode(this));
-//
-//  }
+  // private String socketInfo() {
+  // return (" socket: " + getSocket().getLocalAddress() + ":" + getSocket().getLocalPort() + " -> "
+  // +
+  // getSocket().getInetAddress() + ":" + getSocket().getPort() + " connection = " +
+  // System.identityHashCode(this));
+  //
+  // }
-  private final boolean addToQueue(ByteBuffer buffer, DistributionMessage msg,
-                                   boolean force) throws ConnectionException {
+  private final boolean addToQueue(ByteBuffer buffer, DistributionMessage msg, boolean force)
+      throws ConnectionException {
-          throw new ConnectionException(LocalizedStrings.Connection_FORCED_DISCONNECT_SENT_TO_0.toLocalizedString(this.remoteAddr));
+          throw new ConnectionException(LocalizedStrings.Connection_FORCED_DISCONNECT_SENT_TO_0
+              .toLocalizedString(this.remoteAddr));
-              ConflationKey oldck = (ConflationKey)oldValue;
+              ConflationKey oldck = (ConflationKey) oldValue;
-            /*Object removedVal =*/ this.conflatedKeys.remove(ck);
+            /* Object removedVal = */ this.conflatedKeys.remove(ck);
-                new Object[] {newQueueSize, this.asyncMaxQueueSize, this.remoteAddr }));
+                new Object[] {newQueueSize, this.asyncMaxQueueSize, this.remoteAddr}));
+
-   * Return true if it was able to handle a block write of the given buffer.
-   * Return false if it is still the caller is still responsible for writing it.
+   * Return true if it was able to handle a block write of the given buffer. Return false if it is
+   * still the caller is still responsible for writing it.
+   * 
-  private final boolean handleBlockedWrite(ByteBuffer buffer,
-      DistributionMessage msg) throws ConnectionException
-  {
+  private final boolean handleBlockedWrite(ByteBuffer buffer, DistributionMessage msg)
+      throws ConnectionException {
-      synchronized (this.nioPusherSync) {
-        while (this.pusherThread != null) {
-          // wait for previous pusher thread to exit
-          boolean interrupted = Thread.interrupted();
-          try {
-            this.nioPusherSync.wait(); // spurious wakeup ok
-          } catch (InterruptedException ex) {
-            interrupted = true;
-            this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-          }
-          finally {
-            if (interrupted) {
-              Thread.currentThread().interrupt();
-            }
+    synchronized (this.nioPusherSync) {
+      while (this.pusherThread != null) {
+        // wait for previous pusher thread to exit
+        boolean interrupted = Thread.interrupted();
+        try {
+          this.nioPusherSync.wait(); // spurious wakeup ok
+        } catch (InterruptedException ex) {
+          interrupted = true;
+          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+        } finally {
+          if (interrupted) {
+            Thread.currentThread().interrupt();
-        this.asyncQueuingInProgress = true;
-        ThreadGroup group =
-          LoggingThreadGroup.createThreadGroup("P2P Writer Threads", logger);
-        this.pusherThread = new Thread(group, new Runnable() {
-            public void run() {
-              Connection.this.runNioPusher();
-            }
-          }, "P2P async pusher to " + this.remoteAddr);
-        this.pusherThread.setDaemon(true);
-      } // synchronized
-      this.pusherThread.start();
+      }
+      this.asyncQueuingInProgress = true;
+      ThreadGroup group = LoggingThreadGroup.createThreadGroup("P2P Writer Threads", logger);
+      this.pusherThread = new Thread(group, new Runnable() {
+        public void run() {
+          Connection.this.runNioPusher();
+        }
+      }, "P2P async pusher to " + this.remoteAddr);
+      this.pusherThread.setDaemon(true);
+    } // synchronized
+    this.pusherThread.start();
-        //Object o = this.outgoingQueue.poll();
+        // Object o = this.outgoingQueue.poll();
-            result = ((ConflationKey)o).getBuffer();
+            result = ((ConflationKey) o).getBuffer();
-            result = (ByteBuffer)o;
+            result = (ByteBuffer) o;
-      this.owner.removeEndpoint(this.remoteAddr, LocalizedStrings.Connection_NO_DISTRIBUTION_MANAGER.toLocalizedString());
+      this.owner.removeEndpoint(this.remoteAddr,
+          LocalizedStrings.Connection_NO_DISTRIBUTION_MANAGER.toLocalizedString());
-    dm.getMembershipManager().requestMemberRemoval(this.remoteAddr, 
-                                                   LocalizedStrings.Connection_DISCONNECTED_AS_A_SLOWRECEIVER.toLocalizedString());
+    dm.getMembershipManager().requestMemberRemoval(this.remoteAddr,
+        LocalizedStrings.Connection_DISCONNECTED_AS_A_SLOWRECEIVER.toLocalizedString());
-      }
-      catch (InterruptedException ie) {
+      } catch (InterruptedException ie) {
-    this.owner.removeEndpoint(this.remoteAddr, 
-                              LocalizedStrings.Connection_FORCE_DISCONNECT_TIMED_OUT.toLocalizedString());
+    this.owner.removeEndpoint(this.remoteAddr,
+        LocalizedStrings.Connection_FORCE_DISCONNECT_TIMED_OUT.toLocalizedString());
-        logger.debug("Force disconnect timed out after waiting {} seconds", (FORCE_TIMEOUT/1000));
+        logger.debug("Force disconnect timed out after waiting {} seconds", (FORCE_TIMEOUT / 1000));
-   * have the pusher thread check for queue overflow
-   * and for idle time exceeded
+   * have the pusher thread check for queue overflow and for idle time exceeded
-    final DMStats stats = this.owner.getConduit().stats;
-    final long threadStart = stats.startAsyncThread();
-    try {
-      stats.incAsyncQueues(1);
-      stats.incAsyncThreads(1);
-
+      final DMStats stats = this.owner.getConduit().stats;
+      final long threadStart = stats.startAsyncThread();
-        int flushId = 0;
-        while (this.asyncQueuingInProgress && this.connected) {
-          if (SystemFailure.getFailure() != null) {
-            // Allocate no objects here!
-            Socket s = this.socket;
-            if (s != null) {
-              try {
-                s.close();
+        stats.incAsyncQueues(1);
+        stats.incAsyncThreads(1);
+
+        try {
+          int flushId = 0;
+          while (this.asyncQueuingInProgress && this.connected) {
+            if (SystemFailure.getFailure() != null) {
+              // Allocate no objects here!
+              Socket s = this.socket;
+              if (s != null) {
+                try {
+                  s.close();
+                } catch (IOException e) {
+                  // don't care
+                }
-              catch (IOException e) {
-                // don't care
+              SystemFailure.checkFailure(); // throws
+            }
+            if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
+              break;
+            }
+            flushId++;
+            long flushStart = stats.startAsyncQueueFlush();
+            try {
+              long curQueuedBytes = this.queuedBytes;
+              if (curQueuedBytes > this.asyncMaxQueueSize) {
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.Connection_QUEUED_BYTES_0_EXCEEDS_MAX_OF_1_ASKING_SLOW_RECEIVER_2_TO_DISCONNECT,
+                    new Object[] {curQueuedBytes, this.asyncMaxQueueSize, this.remoteAddr}));
+                stats.incAsyncQueueSizeExceeded(1);
+                disconnectSlowReceiver();
+                return;
-            }
-            SystemFailure.checkFailure(); // throws
-          }
-          if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-            break;
-          }
-          flushId++;
-          long flushStart = stats.startAsyncQueueFlush();
-          try {
-            long curQueuedBytes = this.queuedBytes;
-            if (curQueuedBytes > this.asyncMaxQueueSize) {
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.Connection_QUEUED_BYTES_0_EXCEEDS_MAX_OF_1_ASKING_SLOW_RECEIVER_2_TO_DISCONNECT,
-                  new Object[]{ curQueuedBytes, this.asyncMaxQueueSize, this.remoteAddr}));
-              stats.incAsyncQueueSizeExceeded(1);
-              disconnectSlowReceiver();
-              return;
-            }
-            SocketChannel channel = getSocket().getChannel();
-            ByteBuffer bb = takeFromOutgoingQueue();
-            if (bb == null) {
-              if (logger.isDebugEnabled() && flushId == 1) {
-                logger.debug("P2P pusher found empty queue");
+              SocketChannel channel = getSocket().getChannel();
+              ByteBuffer bb = takeFromOutgoingQueue();
+              if (bb == null) {
+                if (logger.isDebugEnabled() && flushId == 1) {
+                  logger.debug("P2P pusher found empty queue");
+                }
+                return;
-              return;
+              nioWriteFully(channel, bb, true, null);
+              // We should not add messagesSent here according to Bruce.
+              // The counts are increased elsewhere.
+              // messagesSent++;
+              accessed();
+            } finally {
+              stats.endAsyncQueueFlush(flushStart);
-            nioWriteFully(channel, bb, true, null);
-            // We should not add messagesSent here according to Bruce.
-            // The counts are increased elsewhere.
-            // messagesSent++;
-            accessed();
-          } finally {
-            stats.endAsyncQueueFlush(flushStart);
+          } // while
+        } finally {
+          // need to force this to false before doing the requestClose calls
+          synchronized (this.outgoingQueue) {
+            this.asyncQueuingInProgress = false;
+            this.outgoingQueue.notifyAll();
-        } // while
+        }
+      } catch (InterruptedException ex) {
+        // someone wants us to stop.
+        // No need to set interrupt bit, we're quitting.
+        // No need to throw an error, we're quitting.
+      } catch (IOException ex) {
+        final String err =
+            LocalizedStrings.Connection_P2P_PUSHER_IO_EXCEPTION_FOR_0.toLocalizedString(this);
+        if (!isSocketClosed()) {
+          if (logger.isDebugEnabled() && !isIgnorableIOException(ex)) {
+            logger.debug(err, ex);
+          }
+        }
+        try {
+          requestClose(err + ": " + ex);
+        } catch (Exception ignore) {
+        }
+      } catch (CancelException ex) { // bug 37367
+        final String err = LocalizedStrings.Connection_P2P_PUSHER_0_CAUGHT_CACHECLOSEDEXCEPTION_1
+            .toLocalizedString(new Object[] {this, ex});
+        logger.debug(err);
+        try {
+          requestClose(err);
+        } catch (Exception ignore) {
+        }
+        return;
+      } catch (Exception ex) {
+        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex); // bug 37101
+        if (!isSocketClosed()) {
+          logger.fatal(
+              LocalizedMessage.create(LocalizedStrings.Connection_P2P_PUSHER_EXCEPTION_0, ex), ex);
+        }
+        try {
+          requestClose(LocalizedStrings.Connection_P2P_PUSHER_EXCEPTION_0.toLocalizedString(ex));
+        } catch (Exception ignore) {
+        }
-        // need to force this to false before doing the requestClose calls
-        synchronized (this.outgoingQueue) {
-          this.asyncQueuingInProgress = false;
-          this.outgoingQueue.notifyAll();
+        stats.incAsyncQueueSize(-this.queuedBytes);
+        this.queuedBytes = 0;
+        stats.endAsyncThread(threadStart);
+        stats.incAsyncThreads(-1);
+        stats.incAsyncQueues(-1);
+        if (logger.isDebugEnabled()) {
+          logger.debug("runNioPusher terminated id={} from {}/{}", conduitIdStr, remoteAddr,
+              remoteAddr);
-    } catch (InterruptedException ex) {
-      // someone wants us to stop.
-      // No need to set interrupt bit, we're quitting.
-      // No need to throw an error, we're quitting.
-    } catch (IOException ex) {
-      final String err = LocalizedStrings.Connection_P2P_PUSHER_IO_EXCEPTION_FOR_0.toLocalizedString(this);
-      if (! isSocketClosed() ) {
-        if (logger.isDebugEnabled() && !isIgnorableIOException(ex)) {
-          logger.debug(err, ex);
-        }
-      }
-      try { requestClose(err + ": " + ex); } catch (Exception ignore) {}
-    } 
-    catch (CancelException ex) { // bug 37367
-      final String err = LocalizedStrings.Connection_P2P_PUSHER_0_CAUGHT_CACHECLOSEDEXCEPTION_1.toLocalizedString(new Object[] {this, ex});
-      logger.debug(err);
-      try { requestClose(err); } catch (Exception ignore) {}
-      return;
-    } 
-    catch (Exception ex) {
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex); // bug 37101
-      if (! isSocketClosed() ) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_P2P_PUSHER_EXCEPTION_0, ex), ex);
-      }
-      try { requestClose(LocalizedStrings.Connection_P2P_PUSHER_EXCEPTION_0.toLocalizedString(ex)); } catch (Exception ignore) {}
-    } finally {
-      stats.incAsyncQueueSize(-this.queuedBytes);
-      this.queuedBytes = 0;
-      stats.endAsyncThread(threadStart);
-      stats.incAsyncThreads(-1);
-      stats.incAsyncQueues(-1);
-      if (logger.isDebugEnabled()) {
-        logger.debug("runNioPusher terminated id={} from {}/{}", conduitIdStr, remoteAddr, remoteAddr);
-      }
-    }
-   * Return false if socket writes to be done async/nonblocking
-   * Return true if socket writes to be done sync/blocking
+   * Return false if socket writes to be done async/nonblocking Return true if socket writes to be
+   * done sync/blocking
-  static private final int MAX_WAIT_TIME = (1<<5); // ms (must be a power of 2)
+  static private final int MAX_WAIT_TIME = (1 << 5); // ms (must be a power of 2)
-  private final void writeAsync(SocketChannel channel,
-      ByteBuffer buffer, boolean forceAsync, DistributionMessage p_msg,
-      final DMStats stats) throws IOException {
+  private final void writeAsync(SocketChannel channel, ByteBuffer buffer, boolean forceAsync,
+      DistributionMessage p_msg, final DMStats stats) throws IOException {
-//  async/non-blocking
+    // async/non-blocking
-                      logger.debug("Starting async pusher to handle async queue because distribution-timeout is 1 and the last socket write would have blocked.");
+                      logger.debug(
+                          "Starting async pusher to handle async queue because distribution-timeout is 1 and the last socket write would have blocked.");
-                      logger.debug("Blocked for {}ms which is longer than the max of {}ms so starting async pusher to handle async queue.",
+                      logger.debug(
+                          "Blocked for {}ms which is longer than the max of {}ms so starting async pusher to handle async queue.",
-                      new Object[]{ Long.valueOf(curQueuedBytes), Long.valueOf(this.asyncMaxQueueSize), this.remoteAddr})); 
+                      new Object[] {Long.valueOf(curQueuedBytes),
+                          Long.valueOf(this.asyncMaxQueueSize), this.remoteAddr}));
-                      new Object[] {Long.valueOf(blockedMs), Integer.valueOf(this.asyncQueueTimeout), this.remoteAddr}));
+                      new Object[] {Long.valueOf(blockedMs),
+                          Integer.valueOf(this.asyncQueueTimeout), this.remoteAddr}));
-                  }
-                  finally {
+                  } finally {
-  /** nioWriteFully implements a blocking write on a channel that is in
-   *  non-blocking mode.
+  /**
+   * nioWriteFully implements a blocking write on a channel that is in non-blocking mode.
+   * 
-  protected final void nioWriteFully(SocketChannel channel,
-                                     ByteBuffer buffer,
-                                     boolean forceAsync,
-                                     DistributionMessage msg)
-    throws IOException, ConnectionException
-  {
+  protected final void nioWriteFully(SocketChannel channel, ByteBuffer buffer, boolean forceAsync,
+      DistributionMessage msg) throws IOException, ConnectionException {
-//            this.writerThread = Thread.currentThread();
+            // this.writerThread = Thread.currentThread();
-          }
-          finally {
+          } finally {
-//            this.writerThread = null;
+            // this.writerThread = null;
-    }
-    else {
+    } else {
-  
+
-  
-  /*~~~~~~~~~~~~~ connection states ~~~~~~~~~~~~~~~*/
+
+  /* ~~~~~~~~~~~~~ connection states ~~~~~~~~~~~~~~~ */
-  
-  protected static final String[] STATE_NAMES = new String[] {
-    "idle", "sending", "post_sending", "reading_ack", "received_ack", "reading" };
-  /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
-  
+
+  protected static final String[] STATE_NAMES =
+      new String[] {"idle", "sending", "post_sending", "reading_ack", "received_ack", "reading"};
+  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+
-   * @param msToWait number of milliseconds to wait for an ack.
-   *                 If 0 then wait forever.
+   * @param msToWait number of milliseconds to wait for an ack. If 0 then wait forever.
-  public void readAck(final int msToWait, final long msInterval, final DirectReplyProcessor processor) throws SocketTimeoutException,
-      ConnectionException {
+  public void readAck(final int msToWait, final long msInterval,
+      final DirectReplyProcessor processor) throws SocketTimeoutException, ConnectionException {
-      throw new ConnectionException(LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+      throw new ConnectionException(
+          LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
-    
-    
+
+
-      if(useNIO()) {
+      if (useNIO()) {
-      
+
-      if(header.getNioMessageType() == NORMAL_MSG_TYPE) {
+      if (header.getNioMessageType() == NORMAL_MSG_TYPE) {
-        MsgDestreamer destreamer = obtainMsgDestreamer(
-            header.getNioMessageId(), version);
+        MsgDestreamer destreamer = obtainMsgDestreamer(header.getNioMessageId(), version);
-      //I'd really just like to call dispatchMessage here. However,
-      //that call goes through a bunch of checks that knock about
-      //10% of the performance. Since this direct-ack stuff is all
-      //about performance, we'll skip those checks. Skipping them
-      //should be legit, because we just sent a message so we know
-      //the member is already in our view, etc.
+      // I'd really just like to call dispatchMessage here. However,
+      // that call goes through a bunch of checks that knock about
+      // 10% of the performance. Since this direct-ack stuff is all
+      // about performance, we'll skip those checks. Skipping them
+      // should be legit, because we just sent a message so we know
+      // the member is already in our view, etc.
-//      dispatchMessage(msg, len, false);
-    }
-    catch (MemberShunnedException e) {
-      //do nothing
-    }
-    catch (SocketTimeoutException timeout) {
+      // dispatchMessage(msg, len, false);
+    } catch (MemberShunnedException e) {
+      // do nothing
+    } catch (SocketTimeoutException timeout) {
-    }
-    catch (IOException e) {
-      final String err = LocalizedStrings.Connection_ACK_READ_IO_EXCEPTION_FOR_0.toLocalizedString(this);
-      if (! isSocketClosed() ) {
+    } catch (IOException e) {
+      final String err =
+          LocalizedStrings.Connection_ACK_READ_IO_EXCEPTION_FOR_0.toLocalizedString(this);
+      if (!isSocketClosed()) {
-      try { requestClose(err + ": " + e); } catch (Exception ex) {}
-      throw new ConnectionException(LocalizedStrings.Connection_UNABLE_TO_READ_DIRECT_ACK_BECAUSE_0.toLocalizedString(e));
-    }
-    catch(ConnectionException e) {
+      try {
+        requestClose(err + ": " + e);
+      } catch (Exception ex) {
+      }
+      throw new ConnectionException(
+          LocalizedStrings.Connection_UNABLE_TO_READ_DIRECT_ACK_BECAUSE_0.toLocalizedString(e));
+    } catch (ConnectionException e) {
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-      if (! isSocketClosed() ) {
+      if (!isSocketClosed()) {
-      try { requestClose(LocalizedStrings.Connection_ACK_READ_EXCEPTION_0.toLocalizedString(e)); } catch (Exception ex) {}
-      throw new ConnectionException(LocalizedStrings.Connection_UNABLE_TO_READ_DIRECT_ACK_BECAUSE_0.toLocalizedString(e));
-    }
-    finally {
+      try {
+        requestClose(LocalizedStrings.Connection_ACK_READ_EXCEPTION_0.toLocalizedString(e));
+      } catch (Exception ex) {
+      }
+      throw new ConnectionException(
+          LocalizedStrings.Connection_UNABLE_TO_READ_DIRECT_ACK_BECAUSE_0.toLocalizedString(e));
+    } finally {
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.Connection_FINISHED_WAITING_FOR_REPLY_FROM_0,
-            new Object[] {getRemoteAddress()}));
+        logger.info(
+            LocalizedMessage.create(LocalizedStrings.Connection_FINISHED_WAITING_FOR_REPLY_FROM_0,
+                new Object[] {getRemoteAddress()}));
-      if(msgReader != null) {
+      if (msgReader != null) {
-  /** processes the current NIO buffer.  If there are complete messages
-      in the buffer, they are deserialized and passed to TCPConduit for
-      further processing */
+  /**
+   * processes the current NIO buffer. If there are complete messages in the buffer, they are
+   * deserialized and passed to TCPConduit for further processing
+   */
-//      long startTime = DistributionStats.getStatTime();
+      // long startTime = DistributionStats.getStatTime();
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0, nioMessageTypeInteger));
+            logger.fatal(LocalizedMessage.create(
+                LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0, nioMessageTypeInteger));
-            requestClose(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0.toLocalizedString(nioMessageTypeInteger));
+            requestClose(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0
+                .toLocalizedString(nioMessageTypeInteger));
-        if (remaining >= nioMessageLength+MSG_HEADER_BYTES) {
+        if (remaining >= nioMessageLength + MSG_HEADER_BYTES) {
-          nioInputBuffer.position(nioInputBuffer.position()+MSG_HEADER_BYTES);
+          nioInputBuffer.position(nioInputBuffer.position() + MSG_HEADER_BYTES);
-          // the correct spot.  Some of the serialization uses buffered
+          // the correct spot. Some of the serialization uses buffered
-          nioInputBuffer.limit(startPos+nioMessageLength);
+          nioInputBuffer.limit(startPos + nioMessageLength);
-              ByteBufferInputStream bbis = remoteVersion == null
-                  ? new ByteBufferInputStream(nioInputBuffer)
-                  : new VersionedByteBufferInputStream(nioInputBuffer,
-                      remoteVersion);
+              ByteBufferInputStream bbis =
+                  remoteVersion == null ? new ByteBufferInputStream(nioInputBuffer)
+                      : new VersionedByteBufferInputStream(nioInputBuffer, remoteVersion);
-                msg = (DistributionMessage)InternalDataSerializer.readDSFID(bbis);
+                msg = (DistributionMessage) InternalDataSerializer.readDSFID(bbis);
-                      new Object[] { msg, Integer.valueOf(bbis.available())}));
+                      new Object[] {msg, Integer.valueOf(bbis.available())}));
-                }
-                catch (MemberShunnedException e) {
+                } catch (MemberShunnedException e) {
-                }
-                catch (Exception de) {
+                } catch (Exception de) {
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
-                }
-                catch (ThreadDeath td) {
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                } catch (ThreadDeath td) {
-                }
-                catch (VirtualMachineError err) {
+                } catch (VirtualMachineError err) {
-                  // If this ever returns, rethrow the error.  We're poisoned
+                  // If this ever returns, rethrow the error. We're poisoned
-                }
-                catch (Throwable t) {
+                } catch (Throwable t) {
-                  // catch VirtualMachineError (see above).  However, there is
+                  // catch VirtualMachineError (see above). However, there is
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
-              }
-              catch (VirtualMachineError err) {
+              } catch (VirtualMachineError err) {
-                // If this ever returns, rethrow the error.  We're poisoned
+                // If this ever returns, rethrow the error. We're poisoned
-              }
-              catch (Throwable t) {
+              } catch (Throwable t) {
-                // catch VirtualMachineError (see above).  However, there is
+                // catch VirtualMachineError (see above). However, there is
-                  sendFailureReply(ReplyProcessor21.getMessageRPId(), LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE.toLocalizedString(), t, directAck);
+                sendFailureReply(ReplyProcessor21.getMessageRPId(),
+                    LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE.toLocalizedString(), t,
+                    directAck);
-                  throw (ThreadDeath)t;
+                  throw (ThreadDeath) t;
-                if(t instanceof CancelException) {
+                if (t instanceof CancelException) {
-                    // Just log a message if we had trouble deserializing due to CacheClosedException; see bug 43543
+                    // Just log a message if we had trouble deserializing due to
+                    // CacheClosedException; see bug 43543
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE), t);
-              }
-              finally {
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE), t);
+              } finally {
-            }
-            else if (nioMessageType == CHUNKED_MSG_TYPE) {
+            } else if (nioMessageType == CHUNKED_MSG_TYPE) {
-              this.owner.getConduit().stats.incMessagesBeingReceived(md.size() == 0, nioMessageLength);
+              this.owner.getConduit().stats.incMessagesBeingReceived(md.size() == 0,
+                  nioMessageLength);
+              } catch (IOException ex) {
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_FAILED_HANDLING_CHUNK_MESSAGE), ex);
-              catch (IOException ex) {
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_FAILED_HANDLING_CHUNK_MESSAGE), ex);
-              }
-            }
-            else /* (nioMessageType == END_CHUNKED_MSG_TYPE) */ {
-              //logger.info("END_CHUNK msgId="+nioMsgId);
+            } else /* (nioMessageType == END_CHUNKED_MSG_TYPE) */ {
+              // logger.info("END_CHUNK msgId="+nioMsgId);
-              this.owner.getConduit().stats.incMessagesBeingReceived(md.size() == 0, nioMessageLength);
+              this.owner.getConduit().stats.incMessagesBeingReceived(md.size() == 0,
+                  nioMessageLength);
-              }
-              catch (IOException ex) {
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_FAILED_HANDLING_END_CHUNK_MESSAGE), ex);
+              } catch (IOException ex) {
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_FAILED_HANDLING_END_CHUNK_MESSAGE), ex);
-              }
-              catch (ClassNotFoundException ex) {
+              } catch (ClassNotFoundException ex) {
-                failureMsg = LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE.toLocalizedString();
+                failureMsg = LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE
+                    .toLocalizedString();
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE_0, ex));
-              }
-              catch (IOException ex) {
+                logger.fatal(LocalizedMessage
+                    .create(LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE_0, ex));
+              } catch (IOException ex) {
-                failureMsg = LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE.toLocalizedString();
+                failureMsg = LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE
+                    .toLocalizedString();
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE), failureEx);
-              }
-              catch (InterruptedException ex) {
+                logger.fatal(LocalizedMessage.create(
+                    LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE), failureEx);
+              } catch (InterruptedException ex) {
-              } 
-              catch (VirtualMachineError err) {
+              } catch (VirtualMachineError err) {
-                // If this ever returns, rethrow the error.  We're poisoned
+                // If this ever returns, rethrow the error. We're poisoned
-              }
-              catch (Throwable ex) {
+              } catch (Throwable ex) {
-                // catch VirtualMachineError (see above).  However, there is
+                // catch VirtualMachineError (see above). However, there is
-                failureMsg = LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE.toLocalizedString();
+                failureMsg = LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE
+                    .toLocalizedString();
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE), failureEx);
-              }
-              finally {
+                logger.fatal(
+                    LocalizedMessage.create(
+                        LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE),
+                    failureEx);
+              } finally {
-                }
-                catch (MemberShunnedException e) {
+                } catch (MemberShunnedException e) {
-                }
-                catch (Exception de) {
+                } catch (Exception de) {
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
-                }
-                catch (ThreadDeath td) {
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                } catch (ThreadDeath td) {
-                } 
-                catch (VirtualMachineError err) {
+                } catch (VirtualMachineError err) {
-                  // If this ever returns, rethrow the error.  We're poisoned
+                  // If this ever returns, rethrow the error. We're poisoned
-                }
-                catch (Throwable t) {
+                } catch (Throwable t) {
-                  // catch VirtualMachineError (see above).  However, there is
+                  // catch VirtualMachineError (see above). However, there is
-                  logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
+                  logger.fatal(LocalizedMessage
+                      .create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
-              }
-              else if (failureEx != null) {
+              } else if (failureEx != null) {
-          }
-          else {
+          } else {
-            ByteBufferInputStream bbis =
-              new ByteBufferInputStream(nioInputBuffer);
+            ByteBufferInputStream bbis = new ByteBufferInputStream(nioInputBuffer);
-                  this.asyncMaxQueueSize = (long)dis.readInt() * (1024*1024);
+                  this.asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
-                          " asyncDistributionTimeout="
-                          + this.asyncDistributionTimeout
-                          + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                          + " asyncMaxQueueSize="  
-                          + (this.asyncMaxQueueSize / (1024*1024))}));  
+                            " asyncDistributionTimeout=" + this.asyncDistributionTimeout
+                                + " asyncQueueTimeout=" + this.asyncQueueTimeout
+                                + " asyncMaxQueueSize="
+                                + (this.asyncMaxQueueSize / (1024 * 1024))}));
-              }
-              catch (Exception e) {
+              } catch (Exception e) {
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_REPLY), e);
+                logger.fatal(LocalizedMessage.create(
+                    LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_REPLY), e);
-                requestClose(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_REPLY.toLocalizedString());
+                requestClose(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_REPLY
+                    .toLocalizedString());
-              }
-              catch (ThreadDeath td) {
+              } catch (ThreadDeath td) {
-              } 
-              catch (VirtualMachineError err) {
+              } catch (VirtualMachineError err) {
-                // If this ever returns, rethrow the error.  We're poisoned
+                // If this ever returns, rethrow the error. We're poisoned
-              }
-              catch (Throwable t) {
+              } catch (Throwable t) {
-                // catch VirtualMachineError (see above).  However, there is
+                // catch VirtualMachineError (see above). However, there is
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_THROWABLE_DESERIALIZING_P2P_HANDSHAKE_REPLY), t);
+                logger.fatal(
+                    LocalizedMessage.create(
+                        LocalizedStrings.Connection_THROWABLE_DESERIALIZING_P2P_HANDSHAKE_REPLY),
+                    t);
-                requestClose(LocalizedStrings.Connection_THROWABLE_DESERIALIZING_P2P_HANDSHAKE_REPLY.toLocalizedString());
+                requestClose(LocalizedStrings.Connection_THROWABLE_DESERIALIZING_P2P_HANDSHAKE_REPLY
+                    .toLocalizedString());
-              if (this.replyCode != REPLY_CODE_OK && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
-                 StringId err = LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0_NIOMESSAGELENGTH_1_PROCESSORTYPE_2;
-                 Object[] errArgs = new Object[] {Integer.valueOf(this.replyCode), Integer.valueOf(nioMessageLength)}; 
+              if (this.replyCode != REPLY_CODE_OK
+                  && this.replyCode != REPLY_CODE_OK_WITH_ASYNC_INFO) {
+                StringId err =
+                    LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0_NIOMESSAGELENGTH_1_PROCESSORTYPE_2;
+                Object[] errArgs = new Object[] {Integer.valueOf(this.replyCode),
+                    Integer.valueOf(nioMessageLength)};
-                  logger.debug(err.toLocalizedString(errArgs) + " (peer probably departed ungracefully)");
-                }
-                else {
+                  logger.debug(
+                      err.toLocalizedString(errArgs) + " (peer probably departed ungracefully)");
+                } else {
-            }
-            else {
+            } else {
-                  throw new IllegalStateException(LocalizedStrings.Connection_DETECTED_OLD_VERSION_PRE_501_OF_GEMFIRE_OR_NONGEMFIRE_DURING_HANDSHAKE_DUE_TO_INITIAL_BYTE_BEING_0.toLocalizedString(new Byte(b)));
+                  throw new IllegalStateException(
+                      LocalizedStrings.Connection_DETECTED_OLD_VERSION_PRE_501_OF_GEMFIRE_OR_NONGEMFIRE_DURING_HANDSHAKE_DUE_TO_INITIAL_BYTE_BEING_0
+                          .toLocalizedString(new Byte(b)));
-                  throw new IllegalStateException(LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1.toLocalizedString(new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handShakeByte)}));
+                  throw new IllegalStateException(
+                      LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
+                          .toLocalizedString(
+                              new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handShakeByte)}));
-                if (this.remoteVersion == null || 
-                    (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
+                if (this.remoteVersion == null
+                    || (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
-//                  this.senderName = dis.readUTF();
+                  // this.senderName = dis.readUTF();
-                      LocalizedStrings.Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS));
-// bug #49565 - if domino count is >= 2 use shared resources.
-// Also see DistributedCacheOperation#supportsDirectAck
-                  } else { //if (dominoNumber < 2) {
+                        LocalizedStrings.Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS));
+                    // bug #49565 - if domino count is >= 2 use shared resources.
+                    // Also see DistributedCacheOperation#supportsDirectAck
+                  } else { // if (dominoNumber < 2) {
-                      logger.debug("thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets", dominoNumber);
+                      logger.debug(
+                          "thread-owned receiver with domino count of {} will prefer sending on thread-owned sockets",
+                          dominoNumber);
-//                  } else {
-//                    ConnectionTable.threadWantsSharedResources();
+                    // } else {
+                    // ConnectionTable.threadWantsSharedResources();
-                  //Because this thread is not shared resource, it will be used for direct
-                  //ack. Direct ack messages can be large. This call will resize the send
-                  //buffer.
+                  // Because this thread is not shared resource, it will be used for direct
+                  // ack. Direct ack messages can be large. This call will resize the send
+                  // buffer.
-//                String name = owner.getDM().getConfig().getName();
-//                if (name == null) {
-//                  name = "pid="+OSProcess.getId();
-//                }
+                // String name = owner.getDM().getConfig().getName();
+                // if (name == null) {
+                // name = "pid="+OSProcess.getId();
+                // }
-//                    (!this.sharedResource && this.senderName != null? ("<"+this.senderName+"> -> ") : "") +
-//                     "[" + name + "] "+
-                                     "P2P message reader for " + this.remoteAddr
-                                               + " " + (this.sharedResource?"":"un") + "shared"
-                                               + " " + (this.preserveOrder?"":"un") + "ordered"
-                                               + " uid=" + this.uniqueId
-                                               + (dominoNumber>0? (" dom #" + dominoNumber) : "")
-                                               + " port=" + this.socket.getPort());
-              }
-              catch (Exception e) {
+                    // (!this.sharedResource && this.senderName != null? ("<"+this.senderName+"> ->
+                    // ") : "") +
+                    // "[" + name + "] "+
+                    "P2P message reader for " + this.remoteAddr + " "
+                        + (this.sharedResource ? "" : "un") + "shared" + " "
+                        + (this.preserveOrder ? "" : "un") + "ordered" + " uid=" + this.uniqueId
+                        + (dominoNumber > 0 ? (" dom #" + dominoNumber) : "") + " port="
+                        + this.socket.getPort());
+              } catch (Exception e) {
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_MESSAGE), e);
+                logger.fatal(LocalizedMessage.create(
+                    LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_MESSAGE), e);
-                requestClose(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_MESSAGE.toLocalizedString());
+                requestClose(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_MESSAGE
+                    .toLocalizedString());
-                String authInit = System
-                    .getProperty(DistributionConfigImpl.SECURITY_SYSTEM_PREFIX
-                        + SECURITY_PEER_AUTH_INIT);
-                boolean isSecure = authInit!= null && authInit.length() != 0 ;
+                String authInit = System.getProperty(
+                    DistributionConfigImpl.SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
+                boolean isSecure = authInit != null && authInit.length() != 0;
-                  if (owner.getConduit()
-                      .waitForMembershipCheck(this.remoteAddr)) {
+                  if (owner.getConduit().waitForMembershipCheck(this.remoteAddr)) {
-                  }
-                  else {
+                  } else {
-                      LocalizedStrings.Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK, p2pReaderName()));
+                        LocalizedStrings.Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK,
+                        p2pReaderName()));
-                }
-                else {
+                } else {
-                  }
-                  catch (Exception e) {
-                    logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNCAUGHT_EXCEPTION_FROM_LISTENER), e);
+                  } catch (Exception e) {
+                    logger.fatal(LocalizedMessage
+                        .create(LocalizedStrings.Connection_UNCAUGHT_EXCEPTION_FROM_LISTENER), e);
-              }
-              catch (IOException ex) {
-                final String err = LocalizedStrings.Connection_FAILED_SENDING_HANDSHAKE_REPLY.toLocalizedString();
+              } catch (IOException ex) {
+                final String err =
+                    LocalizedStrings.Connection_FAILED_SENDING_HANDSHAKE_REPLY.toLocalizedString();
-        }
-        else {
+        } else {
-      }
-      else {
+      } else {
-        }
-        else {
+        } else {
+
-    int allocSize = messageLength+MSG_HEADER_BYTES;
+    int allocSize = messageLength + MSG_HEADER_BYTES;
-        LocalizedStrings.Connection_ALLOCATING_LARGER_NETWORK_READ_BUFFER_NEW_SIZE_IS_0_OLD_SIZE_WAS_1,
-        new Object[] { Integer.valueOf(allocSize), Integer.valueOf(oldBufferSize)}));
+          LocalizedStrings.Connection_ALLOCATING_LARGER_NETWORK_READ_BUFFER_NEW_SIZE_IS_0_OLD_SIZE_WAS_1,
+          new Object[] {Integer.valueOf(allocSize), Integer.valueOf(oldBufferSize)}));
-      nioInputBuffer = Buffers.acquireReceiveBuffer(allocSize,  stats);
+      nioInputBuffer = Buffers.acquireReceiveBuffer(allocSize, stats);
-      if(oldBuffer != null) {
+      if (oldBuffer != null) {
-      Buffers.releaseReceiveBuffer(oldBuffer,  stats);
+        Buffers.releaseReceiveBuffer(oldBuffer, stats);
-    }
-    else {
+    } else {
-      }
-      else {
+      } else {
+
-      if(directAck) {
-        Assert.assertTrue(!isSharedResource(), "We were asked to send a direct reply on a shared socket");
+      if (directAck) {
+        Assert.assertTrue(!isSharedResource(),
+            "We were asked to send a direct reply on a shared socket");
-      throw new SocketException(LocalizedStrings.Connection_SOCKET_HAS_BEEN_CLOSED.toLocalizedString());
+      throw new SocketException(
+          LocalizedStrings.Connection_SOCKET_HAS_BEEN_CLOSED.toLocalizedString());
+
+
-  /** return the DM id of the guy on the other side of this connection.
+  /**
+   * return the DM id of the guy on the other side of this connection.
-        + (this.remoteVersion != null ? ('(' + this.remoteVersion.toString()
-            + ')') : "") /*DEBUG + " accepted=" + this.isReceiver + " connected=" + this.connected + " hash=" + System.identityHashCode(this) + " preserveOrder=" + this.preserveOrder +
-    " closing=" + isClosing() + ">"*/;
+        + (this.remoteVersion != null ? ('(' + this.remoteVersion.toString() + ')')
+            : "") /*
+                   * DEBUG + " accepted=" + this.isReceiver + " connected=" + this.connected +
+                   * " hash=" + System.identityHashCode(this) + " preserveOrder=" +
+                   * this.preserveOrder + " closing=" + isClosing() + ">"
+                   */;
+   * 
+
-      throw new ConnectionException(LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+      throw new ConnectionException(
+          LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
-    }
-    finally {
+    } finally {
-      throw new ConnectionException(LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+      throw new ConnectionException(
+          LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+
+
-  
+
-  
+

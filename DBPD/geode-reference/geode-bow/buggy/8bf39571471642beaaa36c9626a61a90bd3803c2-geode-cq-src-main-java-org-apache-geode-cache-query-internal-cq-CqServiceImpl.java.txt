Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implements the CqService functionality.
+ *        Implements the CqService functionality.
-public final class CqServiceImpl implements CqService  {
+public final class CqServiceImpl implements CqService {
-  
-  private static final Integer MESSAGE_TYPE_LOCAL_CREATE = Integer.valueOf(MessageType.LOCAL_CREATE); 
-  private static final Integer MESSAGE_TYPE_LOCAL_UPDATE = Integer.valueOf(MessageType.LOCAL_UPDATE); 
-  private static final Integer MESSAGE_TYPE_LOCAL_DESTROY = Integer.valueOf(MessageType.LOCAL_DESTROY); 
+
+  private static final Integer MESSAGE_TYPE_LOCAL_CREATE =
+      Integer.valueOf(MessageType.LOCAL_CREATE);
+  private static final Integer MESSAGE_TYPE_LOCAL_UPDATE =
+      Integer.valueOf(MessageType.LOCAL_UPDATE);
+  private static final Integer MESSAGE_TYPE_LOCAL_DESTROY =
+      Integer.valueOf(MessageType.LOCAL_DESTROY);
-  
-  /** 
-   * System property to evaluate the query even though the initial results are not required
-   * when cq is executed using the execute() method. 
+
+  /**
+   * System property to evaluate the query even though the initial results are not required when cq
+   * is executed using the execute() method.
-  public static boolean EXECUTE_QUERY_DURING_INIT =
-      Boolean.valueOf(System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "cq.EXECUTE_QUERY_DURING_INIT", "true")).booleanValue();
+  public static boolean EXECUTE_QUERY_DURING_INIT = Boolean
+      .valueOf(System
+          .getProperty(DistributionConfig.GEMFIRE_PREFIX + "cq.EXECUTE_QUERY_DURING_INIT", "true"))
+      .booleanValue();
-  
+
-  
+
-  
-  /** Manages CQ objects. uses serverCqName as key and CqQueryImpl as value 
+
+  /**
+   * Manages CQ objects. uses serverCqName as key and CqQueryImpl as value
+   * 
-  
+
-  private final HashMap<String, UserAttributes> cqNameToUserAttributesMap = new HashMap<String, UserAttributes>();
-  
+  private final HashMap<String, UserAttributes> cqNameToUserAttributesMap =
+      new HashMap<String, UserAttributes>();
+
-  
+
-  // Map to manage CQ to satisfied CQ events (keys) for optimizing updates. 
-  private final HashMap cqToCqEventKeysMap = 
-      CqService.MAINTAIN_KEYS ? new HashMap() : null;
-  */
-  
+   * // Map to manage CQ to satisfied CQ events (keys) for optimizing updates. private final HashMap
+   * cqToCqEventKeysMap = CqService.MAINTAIN_KEYS ? new HashMap() : null;
+   */
+
-  
+
-  
+
-    
+
-  private HashMap<String, ArrayList<String>> baseRegionToCqNameMap = new HashMap<String, ArrayList<String>>();
-  
-  
+  private HashMap<String, ArrayList<String>> baseRegionToCqNameMap =
+      new HashMap<String, ArrayList<String>>();
+
+
-   * Constructor. 
+   * Constructor.
+   * 
-    
+
-    
+
-    this.cqServiceStats  = new CqServiceStatisticsImpl(this);
+    this.cqServiceStats = new CqServiceStatisticsImpl(this);
-//    final LoggingThreadGroup group =
-//      LoggingThreadGroup.createThreadGroup("CqExecutor Threads", logger);
-    
-    //if (this.cache.getCacheServers().isEmpty()) {
-    //  isServer = false;
-    //}    
+    // final LoggingThreadGroup group =
+    // LoggingThreadGroup.createThreadGroup("CqExecutor Threads", logger);
+
+    // if (this.cache.getCacheServers().isEmpty()) {
+    // isServer = false;
+    // }
-  
+
-    
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#newCq(java.lang.String, java.lang.String, org.apache.geode.cache.query.CqAttributes, org.apache.geode.cache.client.internal.ServerCQProxy, boolean)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.query.internal.InternalCqService#newCq(java.lang.String,
+   * java.lang.String, org.apache.geode.cache.query.CqAttributes,
+   * org.apache.geode.cache.client.internal.ServerCQProxy, boolean)
-  public synchronized ClientCQ newCq(String cqName, String queryString, CqAttributes cqAttributes, InternalPool pool, boolean isDurable)
-  throws QueryInvalidException, CqExistsException, CqException {
+  public synchronized ClientCQ newCq(String cqName, String queryString, CqAttributes cqAttributes,
+      InternalPool pool, boolean isDurable)
+      throws QueryInvalidException, CqExistsException, CqException {
-      throw new IllegalArgumentException(LocalizedStrings.CqService_NULL_ARGUMENT_0.toLocalizedString("queryString"));
+      throw new IllegalArgumentException(
+          LocalizedStrings.CqService_NULL_ARGUMENT_0.toLocalizedString("queryString"));
-    } else if (cqAttributes == null ) {
-      throw new IllegalArgumentException(LocalizedStrings.CqService_NULL_ARGUMENT_0.toLocalizedString("cqAttribute"));
+    } else if (cqAttributes == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.CqService_NULL_ARGUMENT_0.toLocalizedString("cqAttribute"));
-    
+
-        LocalizedStrings.CqService_CLIENT_SIDE_NEWCQ_METHOD_INVOCATION_ON_SERVER.toLocalizedString());
+          LocalizedStrings.CqService_CLIENT_SIDE_NEWCQ_METHOD_INVOCATION_ON_SERVER
+              .toLocalizedString());
-    
+
-        LocalizedStrings.
-          CqService_CQ_WITH_THE_GIVEN_NAME_ALREADY_EXISTS_CQNAME_0
-        .toLocalizedString(cqName));
+          LocalizedStrings.CqService_CQ_WITH_THE_GIVEN_NAME_ALREADY_EXISTS_CQNAME_0
+              .toLocalizedString(cqName));
-    
-    
-    ServerCQProxyImpl serverProxy= pool == null ? null : new ServerCQProxyImpl(pool);
-    ClientCQImpl cQuery = new ClientCQImpl(this, cqName, queryString, cqAttributes, serverProxy, isDurable);
+
+
+    ServerCQProxyImpl serverProxy = pool == null ? null : new ServerCQProxyImpl(pool);
+    ClientCQImpl cQuery =
+        new ClientCQImpl(this, cqName, queryString, cqAttributes, serverProxy, isDurable);
-    //cQuery.initCq();
-    
-    // Check if query is valid.  
+    // cQuery.initCq();
+
+    // Check if query is valid.
-    
-    // Add cq into meta region.    
+
+    // Add cq into meta region.
-      while(true) {
+      while (true) {
-            logger.debug("Got CqExistsException while intializing cq : {} Error : {}", cQuery.getName(), ex.getMessage());
+            logger.debug("Got CqExistsException while intializing cq : {} Error : {}",
+                cQuery.getName(), ex.getMessage());
-      } 
+      }
-    
+
-  
+
-   * Executes the given CqQuery, if the CqQuery for that name is not there
-   * it registers the one and executes. This is called on the Server. 
+   * Executes the given CqQuery, if the CqQuery for that name is not there it registers the one and
+   * executes. This is called on the Server.
+   * 
-   * @param regionDataPolicy the data policy of the region associated with the
-   *        query.  This is only needed if manageEmptyRegions is true.
-   * @param emptyRegionsMap map of empty regions.    
+   * @param regionDataPolicy the data policy of the region associated with the query. This is only
+   *        needed if manageEmptyRegions is true.
+   * @param emptyRegionsMap map of empty regions.
-  public synchronized ServerCQ executeCq(String cqName, String queryString,
-      int cqState, ClientProxyMembershipID clientProxyId, 
-      CacheClientNotifier ccn, boolean isDurable, boolean manageEmptyRegions,
-      int regionDataPolicy, Map emptyRegionsMap) 
-    throws CqException, RegionNotFoundException, CqClosedException {
+  public synchronized ServerCQ executeCq(String cqName, String queryString, int cqState,
+      ClientProxyMembershipID clientProxyId, CacheClientNotifier ccn, boolean isDurable,
+      boolean manageEmptyRegions, int regionDataPolicy, Map emptyRegionsMap)
+      throws CqException, RegionNotFoundException, CqClosedException {
-    
+
-    
+
-      cQuery = new ServerCQImpl(this, cqName, queryString, isDurable, constructServerCqName(cqName, clientProxyId));
-      
+      cQuery = new ServerCQImpl(this, cqName, queryString, isDurable,
+          constructServerCqName(cqName, clientProxyId));
+
-          if (emptyRegionsMap != null && emptyRegionsMap.containsKey(cQuery.getBaseRegionName())){
+          if (emptyRegionsMap != null && emptyRegionsMap.containsKey(cQuery.getBaseRegionName())) {
-          ccn.updateMapOfEmptyRegions(ccn.getClientProxy(clientProxyId, true).getRegionsWithEmptyDataPolicy(), 
+          ccn.updateMapOfEmptyRegions(
+              ccn.getClientProxy(clientProxyId, true).getRegionsWithEmptyDataPolicy(),
-        logger.info(LocalizedMessage.create(LocalizedStrings.CqService_EXCEPTION_WHILE_REGISTERING_CQ_ON_SERVER_CQNAME___0, cQuery.getName()));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.CqService_EXCEPTION_WHILE_REGISTERING_CQ_ON_SERVER_CQNAME___0,
+            cQuery.getName()));
-      
+
-      cQuery = (ServerCQImpl)getCq(serverCqName);
+      cQuery = (ServerCQImpl) getCq(serverCqName);
-   }
-    
-    
-    if (logger.isDebugEnabled() ) {
+    }
+
+
+    if (logger.isDebugEnabled()) {
-    if(((CqStateImpl)cQuery.getState()).getState() != cqState) {
+    if (((CqStateImpl) cQuery.getState()).getState() != cqState) {
-    //If we are going to set the state to running, we need to check to see if it matches any other cq
+    // If we are going to set the state to running, we need to check to see if it matches any other
+    // cq
-        addToMatchingCqMap((CqQueryImpl) cQuery);    
+      addToMatchingCqMap((CqQueryImpl) cQuery);
-  
-  /*
-  public void addToCqEventKeysMap(CqQuery cq){
-    if (cqToCqEventKeysMap != null) {
-      synchronized (cqToCqEventKeysMap){
-        String serverCqName = ((CqQueryImpl)cq).getServerCqName();
-        if (!cqToCqEventKeysMap.containsKey(serverCqName)){
-          cqToCqEventKeysMap.put(serverCqName, new HashSet());
-          if (_logger.isDebugEnabled()) {
-            _logger.debug("CQ Event key maintenance for CQ, CqName: " + 
-              serverCqName + " is Enabled." + " key maintenance map size is: " +
-              cqToCqEventKeysMap.size());
-          }
-        }
-      } // synchronized
-    }    
-  }
-  */
-  public boolean hasCq(){
+  /*
+   * public void addToCqEventKeysMap(CqQuery cq){ if (cqToCqEventKeysMap != null) { synchronized
+   * (cqToCqEventKeysMap){ String serverCqName = ((CqQueryImpl)cq).getServerCqName(); if
+   * (!cqToCqEventKeysMap.containsKey(serverCqName)){ cqToCqEventKeysMap.put(serverCqName, new
+   * HashSet()); if (_logger.isDebugEnabled()) {
+   * _logger.debug("CQ Event key maintenance for CQ, CqName: " + serverCqName + " is Enabled." +
+   * " key maintenance map size is: " + cqToCqEventKeysMap.size()); } } } // synchronized } }
+   */
+
+  public boolean hasCq() {
-  
-  
+
+
-      if (cqMap.containsKey(sCqName)) {
-        throw new CqExistsException(
-          LocalizedStrings.CqService_A_CQ_WITH_THE_GIVEN_NAME_0_ALREADY_EXISTS.toLocalizedString(sCqName));
+    if (cqMap.containsKey(sCqName)) {
+      throw new CqExistsException(
+          LocalizedStrings.CqService_A_CQ_WITH_THE_GIVEN_NAME_0_ALREADY_EXISTS
+              .toLocalizedString(sCqName));
+    }
+    synchronized (cqQueryMapLock) {
+      HashMap<String, CqQueryImpl> tmpCqQueryMap = new HashMap<String, CqQueryImpl>(cqQueryMap);
+      try {
+        tmpCqQueryMap.put(sCqName, cq);
+      } catch (Exception ex) {
+        StringId errMsg =
+            LocalizedStrings.CqQueryImpl_FAILED_TO_STORE_CONTINUOUS_QUERY_IN_THE_REPOSITORY_CQNAME_0_1;
+        Object[] errMsgArgs = new Object[] {sCqName, ex.getLocalizedMessage()};
+        String s = errMsg.toLocalizedString(errMsgArgs);
+        logger.error(s);
+        throw new CqException(s, ex);
-      synchronized (cqQueryMapLock) {
-        HashMap<String, CqQueryImpl> tmpCqQueryMap = new HashMap<String, CqQueryImpl>(cqQueryMap);
-        try {
-          tmpCqQueryMap.put(sCqName, cq);
-        }catch (Exception ex){
-          StringId errMsg = LocalizedStrings.CqQueryImpl_FAILED_TO_STORE_CONTINUOUS_QUERY_IN_THE_REPOSITORY_CQNAME_0_1;
-          Object[] errMsgArgs = new Object[] {sCqName, ex.getLocalizedMessage()};
-          String s = errMsg.toLocalizedString(errMsgArgs);
-          logger.error(s);
-          throw new CqException(s, ex);
-        }    
-        UserAttributes attributes = UserAttributes.userAttributes.get();
-        if (attributes != null) {
-          this.cqNameToUserAttributesMap.put(cq.getName(), attributes);
-        }
-        cqQueryMap = tmpCqQueryMap;
+      UserAttributes attributes = UserAttributes.userAttributes.get();
+      if (attributes != null) {
+        this.cqNameToUserAttributesMap.put(cq.getName(), attributes);
+      cqQueryMap = tmpCqQueryMap;
+    }
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#getClientCqFromServer(org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID, java.lang.String)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#getClientCqFromServer(org.apache.geode.
+   * internal.cache.tier.sockets.ClientProxyMembershipID, java.lang.String)
-    return (CqQuery)cqMap.get(this.constructServerCqName(clientCqName, clientProxyId));
+    return (CqQuery) cqMap.get(this.constructServerCqName(clientCqName, clientProxyId));
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    return (InternalCqQuery)cqQueryMap.get(cqName);
+    return (InternalCqQuery) cqQueryMap.get(cqName);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  public Collection<? extends InternalCqQuery> getAllCqs(){
+  public Collection<? extends InternalCqQuery> getAllCqs() {
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  public Collection<? extends InternalCqQuery> getAllCqs(final String regionName)throws CqException{
-    if (regionName == null){
-      throw new IllegalArgumentException(LocalizedStrings.CqService_NULL_ARGUMENT_0.toLocalizedString("regionName"));
+  public Collection<? extends InternalCqQuery> getAllCqs(final String regionName)
+      throws CqException {
+    if (regionName == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.CqService_NULL_ARGUMENT_0.toLocalizedString("regionName"));
-    
+
-    
-    synchronized(this.baseRegionToCqNameMap){
+
+    synchronized (this.baseRegionToCqNameMap) {
-      if(cqs == null) {
+      if (cqs == null) {
-    
+
-    for(int cqCnt=0; cqCnt < cqNames.length; cqCnt++){
+    for (int cqCnt = 0; cqCnt < cqNames.length; cqCnt++) {
-      if (cq != null){
+      if (cq != null) {
-    
+
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  public synchronized void executeAllClientCqs()throws CqException{
+  public synchronized void executeAllClientCqs() throws CqException {
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#executeAllRegionCqs(java.lang.String)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#executeAllRegionCqs(java.lang.String)
-  public synchronized void executeAllRegionCqs(final String regionName)throws CqException{
-     executeCqs(getAllCqs(regionName));
+  public synchronized void executeAllRegionCqs(final String regionName) throws CqException {
+    executeCqs(getAllCqs(regionName));
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#executeCqs(org.apache.geode.cache.query.CqQuery[])
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#executeCqs(org.apache.geode.cache.query
+   * .CqQuery[])
-  public synchronized void executeCqs(Collection<? extends InternalCqQuery> cqs)throws CqException{
-    if(cqs == null) {
+  public synchronized void executeCqs(Collection<? extends InternalCqQuery> cqs)
+      throws CqException {
+    if (cqs == null) {
-            logger.debug("Failed to execute the CQ, CqName : {} Error : {}", cqName, qe.getMessage());
+            logger.debug("Failed to execute the CQ, CqName : {} Error : {}", cqName,
+                qe.getMessage());
-        } catch (CqClosedException cce){
+        } catch (CqClosedException cce) {
-            logger.debug("Failed to execute the CQ, CqName : {} Error : {}", cqName, cce.getMessage());
+            logger.debug("Failed to execute the CQ, CqName : {} Error : {}", cqName,
+                cce.getMessage());
-    }    
+    }
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  public synchronized void stopAllClientCqs()throws CqException{
+  public synchronized void stopAllClientCqs() throws CqException {
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  public synchronized void stopAllRegionCqs(final String regionName)throws CqException{
+  public synchronized void stopAllRegionCqs(final String regionName) throws CqException {
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#stopCqs(org.apache.geode.cache.query.CqQuery[])
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#stopCqs(org.apache.geode.cache.query.
+   * CqQuery[])
-  public synchronized void stopCqs(Collection<? extends InternalCqQuery> cqs)throws CqException{
+  public synchronized void stopCqs(Collection<? extends InternalCqQuery> cqs) throws CqException {
-    if(cqs == null) {
+    if (cqs == null) {
-    
+
-          if (isDebugEnabled){
+          if (isDebugEnabled) {
-        } catch (CqClosedException cce){
-          if (isDebugEnabled){
+        } catch (CqClosedException cce) {
+          if (isDebugEnabled) {
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  public void closeCqs(final String regionName)throws CqException{
+  public void closeCqs(final String regionName) throws CqException {
-    if(cqs != null) {
+    if (cqs != null) {
-      for (InternalCqQuery cq: cqs) {
+      for (InternalCqQuery cq : cqs) {
-          
-          if(isServer()) {
+
+          if (isServer()) {
-            cq.close(false);  
-          } else { 
+            cq.close(false);
+          } else {
-            boolean keepAlive = ((GemFireCacheImpl)this.cache).keepDurableSubscriptionsAlive();
-            if(cq.isDurable() && keepAlive){
-              logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_NOT_SENDING_CQ_CLOSE_TO_THE_SERVER_AS_IT_IS_A_DURABLE_CQ));
-              cq.close(false);  
-            } 
-            else {
+            boolean keepAlive = ((GemFireCacheImpl) this.cache).keepDurableSubscriptionsAlive();
+            if (cq.isDurable() && keepAlive) {
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.CqService_NOT_SENDING_CQ_CLOSE_TO_THE_SERVER_AS_IT_IS_A_DURABLE_CQ));
+              cq.close(false);
+            } else {
-            logger.debug("Failed to close the CQ, CqName : {} Error : {}", cqName, cce.getMessage());
+            logger.debug("Failed to close the CQ, CqName : {} Error : {}", cqName,
+                cce.getMessage());
+   * 
-  public void stopCq(String cqName, ClientProxyMembershipID clientId)
-  throws CqException {
+  public void stopCq(String cqName, ClientProxyMembershipID clientId) throws CqException {
-      serverCqName = this.constructServerCqName(cqName, clientId); 
+      serverCqName = this.constructServerCqName(cqName, clientId);
-  
+
-    
+
-//        throw new CqException(LocalizedStrings.CqService_CQ_NOT_FOUND_FAILED_TO_STOP_THE_SPECIFIED_CQ_0.toLocalizedString(serverCqName));
-        /* gregp 052808: We should silently fail here instead of throwing error. This is to deal with races in recovery */
+        // throw new
+        // CqException(LocalizedStrings.CqService_CQ_NOT_FOUND_FAILED_TO_STOP_THE_SPECIFIED_CQ_0.toLocalizedString(serverCqName));
+        /*
+         * gregp 052808: We should silently fail here instead of throwing error. This is to deal
+         * with races in recovery
+         */
-      cQuery = (ServerCQImpl)getCq(serverCqName);
-      
+      cQuery = (ServerCQImpl) getCq(serverCqName);
+
-      if (ex != null){
+      if (ex != null) {
-    
+
-      if(!cQuery.isStopped()) {
+      if (!cQuery.isStopped()) {
-    } catch (CqClosedException cce){
+    } catch (CqClosedException cce) {
-      //this.removeCQFromCaching(cQuery.getServerCqName());
+      // this.removeCQFromCaching(cQuery.getServerCqName());
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#closeCq(java.lang.String, org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.query.internal.InternalCqService#closeCq(java.lang.String,
+   * org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID)
-  public void closeCq(String cqName, ClientProxyMembershipID clientProxyId)
-  throws CqException {
+  public void closeCq(String cqName, ClientProxyMembershipID clientProxyId) throws CqException {
-      serverCqName = this.constructServerCqName(cqName, clientProxyId); 
+      serverCqName = this.constructServerCqName(cqName, clientProxyId);
-    
+
-    
+
-//        throw new CqException(LocalizedStrings.CqService_CQ_NOT_FOUND_FAILED_TO_CLOSE_THE_SPECIFIED_CQ_0
-//            .toLocalizedString(serverCqName));
-        /* gregp 052808: We should silently fail here instead of throwing error. This is to deal with races in recovery */
+        // throw new
+        // CqException(LocalizedStrings.CqService_CQ_NOT_FOUND_FAILED_TO_CLOSE_THE_SPECIFIED_CQ_0
+        // .toLocalizedString(serverCqName));
+        /*
+         * gregp 052808: We should silently fail here instead of throwing error. This is to deal
+         * with races in recovery
+         */
-      cQuery = (ServerCQImpl)cqMap.get(serverCqName);
-      
+      cQuery = (ServerCQImpl) cqMap.get(serverCqName);
+
-      if (ex != null){
+      if (ex != null) {
-    
+
-      
-      // CqBaseRegion 
+
+      // CqBaseRegion
-          if (isServer()){
+          if (isServer()) {
-            CacheClientProxy clientProxy = cQuery.getCacheClientNotifier().getClientProxy(clientProxyId);
+            CacheClientProxy clientProxy =
+                cQuery.getCacheClientNotifier().getClientProxy(clientProxyId);
-        } 
-      }catch (Exception e){
+        }
+      } catch (Exception e) {
-    
-      if (isServer()){
-        removeFromBaseRegionToCqNameMap(cQuery.getRegionName(), serverCqName);      
+
+      if (isServer()) {
+        removeFromBaseRegionToCqNameMap(cQuery.getRegionName(), serverCqName);
-      if(baseRegion.getFilterProfile().getCqCount() <= 0){
+      if (baseRegion.getFilterProfile().getCqCount() <= 0) {
-          logger.debug("Should update the profile for this partitioned region {} for not requiring old value", baseRegion);
+          logger.debug(
+              "Should update the profile for this partitioned region {} for not requiring old value",
+              baseRegion);
-    } catch (CqClosedException cce){
+    } catch (CqClosedException cce) {
-  
-  
-  /* (non-Javadoc)
+
+
+  /*
+   * (non-Javadoc)
+   * 
-  /** 
-   * Close all CQs executing in this VM, and release resources
-   * associated with executing CQs.
+  /**
+   * Close all CQs executing in this VM, and release resources associated with executing CQs.
-    closeAllCqs(clientInitiated, cqs, ((GemFireCacheImpl)this.cache)
-        .keepDurableSubscriptionsAlive());
+    closeAllCqs(clientInitiated, cqs,
+        ((GemFireCacheImpl) this.cache).keepDurableSubscriptionsAlive());
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#closeAllCqs(boolean, org.apache.geode.cache.query.CqQuery[], boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.query.internal.InternalCqService#closeAllCqs(boolean,
+   * org.apache.geode.cache.query.CqQuery[], boolean)
-    
-    //CqQuery[] cqs = getAllCqs();
+
+    // CqQuery[] cqs = getAllCqs();
-      if (logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-      for (InternalCqQuery cQuery: cqs){
+      for (InternalCqQuery cQuery : cqs) {
-//          boolean keepAlive = ((GemFireCache)this.cache).keepDurableSubscriptionsAlive();
-         
-          if(isServer()) {
-            cQuery.close(false);  
+          // boolean keepAlive = ((GemFireCache)this.cache).keepDurableSubscriptionsAlive();
+
+          if (isServer()) {
+            cQuery.close(false);
-            } 
-            else {
-              if(!isServer() && cQuery.isDurable() && keepAlive){
-                logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_NOT_SENDING_CQ_CLOSE_TO_THE_SERVER_AS_IT_IS_A_DURABLE_CQ));
+            } else {
+              if (!isServer() && cQuery.isDurable() && keepAlive) {
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.CqService_NOT_SENDING_CQ_CLOSE_TO_THE_SERVER_AS_IT_IS_A_DURABLE_CQ));
-              }
-              else {
+              } else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_FAILED_TO_CLOSE_CQ__0___1, new Object[] {cqName, cqe.getMessage()}));
+            logger
+                .warn(LocalizedMessage.create(LocalizedStrings.CqService_FAILED_TO_CLOSE_CQ__0___1,
+                    new Object[] {cqName, cqe.getMessage()}));
-        } catch (CqClosedException cqe){
+        } catch (CqClosedException cqe) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_FAILED_TO_CLOSE_CQ__0___1, new Object[] {cqName, cqe.getMessage()}));
+            logger
+                .warn(LocalizedMessage.create(LocalizedStrings.CqService_FAILED_TO_CLOSE_CQ__0___1,
+                    new Object[] {cqName, cqe.getMessage()}));
-          } 
+          }
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#closeClientCqs(org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.query.internal.InternalCqService#closeClientCqs(org.apache.geode.
+   * internal.cache.tier.sockets.ClientProxyMembershipID)
-  public void closeClientCqs(ClientProxyMembershipID clientProxyId)
-  throws CqException {
+  public void closeClientCqs(ClientProxyMembershipID clientProxyId) throws CqException {
-    for (ServerCQ cq: cqs) {
-      CqQueryImpl cQuery = (CqQueryImpl)cq;
+    for (ServerCQ cq : cqs) {
+      CqQueryImpl cQuery = (CqQueryImpl) cq;
-          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(), qe.getMessage());
+          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(),
+              qe.getMessage());
-          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(), cce.getMessage());
+          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(),
+              cce.getMessage());
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#getAllClientCqs(org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.query.internal.InternalCqService#getAllClientCqs(org.apache.geode.
+   * internal.cache.tier.sockets.ClientProxyMembershipID)
-  public List<ServerCQ> getAllClientCqs(ClientProxyMembershipID clientProxyId){
+  public List<ServerCQ> getAllClientCqs(ClientProxyMembershipID clientProxyId) {
-    
-    for (InternalCqQuery cq: cqs) {
-      ServerCQImpl cQuery = (ServerCQImpl)cq;
-      ClientProxyMembershipID id = cQuery.getClientProxyId(); 
+
+    for (InternalCqQuery cq : cqs) {
+      ServerCQImpl cQuery = (ServerCQImpl) cq;
+      ClientProxyMembershipID id = cQuery.getClientProxyId();
-          clientCqs.add(cQuery);
+        clientCqs.add(cQuery);
-    return clientCqs;   
+    return clientCqs;
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#getAllDurableClientCqs(org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#getAllDurableClientCqs(org.apache.geode
+   * .internal.cache.tier.sockets.ClientProxyMembershipID)
-  public List<String> getAllDurableClientCqs(ClientProxyMembershipID clientProxyId) throws CqException {
+  public List<String> getAllDurableClientCqs(ClientProxyMembershipID clientProxyId)
+      throws CqException {
-      throw new CqException (LocalizedStrings.CqService_UNABLE_TO_RETRIEVE_DURABLE_CQS_FOR_CLIENT_PROXY_ID.toLocalizedString(clientProxyId));
+      throw new CqException(
+          LocalizedStrings.CqService_UNABLE_TO_RETRIEVE_DURABLE_CQS_FOR_CLIENT_PROXY_ID
+              .toLocalizedString(clientProxyId));
-    
-    for (ServerCQ cq: cqs) {
-      ServerCQImpl cQuery = (ServerCQImpl)cq;
+
+    for (ServerCQ cq : cqs) {
+      ServerCQImpl cQuery = (ServerCQImpl) cq;
-        ClientProxyMembershipID id = cQuery.getClientProxyId(); 
+        ClientProxyMembershipID id = cQuery.getClientProxyId();
-            durableClientCqs.add(cQuery.getName());
+          durableClientCqs.add(cQuery.getName());
-    return durableClientCqs;   
+    return durableClientCqs;
-  
+
-   * Server side method.
-   * Closes non-durable CQs for the given client proxy id.
+   * Server side method. Closes non-durable CQs for the given client proxy id.
+   * 
-  public void closeNonDurableClientCqs(ClientProxyMembershipID clientProxyId)
-  throws CqException {
+  public void closeNonDurableClientCqs(ClientProxyMembershipID clientProxyId) throws CqException {
-    for (ServerCQ cq: cqs) {
-      ServerCQImpl cQuery = (ServerCQImpl)cq;
+    for (ServerCQ cq : cqs) {
+      ServerCQImpl cQuery = (ServerCQImpl) cq;
-          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(), qe.getMessage());
+          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(),
+              qe.getMessage());
-          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(), cce.getMessage());
+          logger.debug("Failed to close the CQ, CqName : {} Error : {}", cQuery.getName(),
+              cce.getMessage());
-  
+
+   * 
-    }    
+    }
-  
+
-    if (logger.isDebugEnabled()){
+    if (logger.isDebugEnabled()) {
-  
+
-  
+
-  
-  private static final ConcurrentHashMap<String, ConcurrentHashMap<ClientProxyMembershipID, String>> serverCqNameCache = new ConcurrentHashMap<>();
+
+  private static final ConcurrentHashMap<String, ConcurrentHashMap<ClientProxyMembershipID, String>> serverCqNameCache =
+      new ConcurrentHashMap<>();
-      final ConcurrentHashMap<ClientProxyMembershipID, String> old = serverCqNameCache.putIfAbsent(cqName,
-          cache = new ConcurrentHashMap<ClientProxyMembershipID, String>());
+      final ConcurrentHashMap<ClientProxyMembershipID, String> old = serverCqNameCache
+          .putIfAbsent(cqName, cache = new ConcurrentHashMap<ClientProxyMembershipID, String>());
-  
+
+   * 
+   * 
-    HashMap<String, CqQueryImpl> cqMap =cqQueryMap;
+    HashMap<String, CqQueryImpl> cqMap = cqQueryMap;
-   * Generates a name for CQ.
-   * Checks if CQ with that name already exists if so generates a new cqName.
+   * Generates a name for CQ. Checks if CQ with that name already exists if so generates a new
+   * cqName.
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#dispatchCqListeners(java.util.HashMap, int, java.lang.Object, java.lang.Object, byte[], org.apache.geode.cache.client.internal.QueueManager, org.apache.geode.internal.cache.EventID)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#dispatchCqListeners(java.util.HashMap,
+   * int, java.lang.Object, java.lang.Object, byte[],
+   * org.apache.geode.cache.client.internal.QueueManager, org.apache.geode.internal.cache.EventID)
-      Map.Entry<String, Integer> entry = iter.next();
-      cqName = entry.getKey();
-      cQuery = (ClientCQImpl) this.getCq(cqName);
-      
-      if (cQuery == null || (!cQuery.isRunning() && cQuery.getQueuedEvents() == null)) {
-        if (isDebugEnabled) {
-          logger.debug("Unable to invoke CqListener, {}, CqName : {}", ((cQuery == null)? "CQ not found":" CQ is Not running"), cqName);
-        }
-        continue;
-      }
-      
-      Integer cqOp = (Integer)entry.getValue();
-      
-      // If Region destroy event, close the cq.
-      if (cqOp.intValue() == MessageType.DESTROY_REGION) {
-        // The close will also invoke the listeners close().
-        try {
-          cQuery.close(false);
-        } catch (Exception ex) {
-          // handle?
-        }
-        continue;
-      }
-      
-      // Construct CqEvent.
-      CqEventImpl cqEvent = null;
-      cqEvent = new CqEventImpl(cQuery, getOperation(messageType),
-          getOperation(cqOp.intValue()), key, value, delta, qManager, eventId);
-      
-      // Update statistics
-      cQuery.updateStats(cqEvent);
+        Map.Entry<String, Integer> entry = iter.next();
+        cqName = entry.getKey();
+        cQuery = (ClientCQImpl) this.getCq(cqName);
-      // Check if CQ Event needs to be queued.
-      if (cQuery.getQueuedEvents() != null) {
-        synchronized(cQuery.queuedEventsSynchObject) {
-          // Get latest value.
-          ConcurrentLinkedQueue<CqEventImpl> queuedEvents = cQuery.getQueuedEvents();
-          // Check to see, if its not set to null while waiting to get 
-          // Synchronization lock.
-          if (queuedEvents != null) {
-            if (isDebugEnabled) {
-              logger.debug("Queueing event for key: {}", key);
+        if (cQuery == null || (!cQuery.isRunning() && cQuery.getQueuedEvents() == null)) {
+          if (isDebugEnabled) {
+            logger.debug("Unable to invoke CqListener, {}, CqName : {}",
+                ((cQuery == null) ? "CQ not found" : " CQ is Not running"), cqName);
+          }
+          continue;
+        }
+
+        Integer cqOp = (Integer) entry.getValue();
+
+        // If Region destroy event, close the cq.
+        if (cqOp.intValue() == MessageType.DESTROY_REGION) {
+          // The close will also invoke the listeners close().
+          try {
+            cQuery.close(false);
+          } catch (Exception ex) {
+            // handle?
+          }
+          continue;
+        }
+
+        // Construct CqEvent.
+        CqEventImpl cqEvent = null;
+        cqEvent = new CqEventImpl(cQuery, getOperation(messageType), getOperation(cqOp.intValue()),
+            key, value, delta, qManager, eventId);
+
+        // Update statistics
+        cQuery.updateStats(cqEvent);
+
+        // Check if CQ Event needs to be queued.
+        if (cQuery.getQueuedEvents() != null) {
+          synchronized (cQuery.queuedEventsSynchObject) {
+            // Get latest value.
+            ConcurrentLinkedQueue<CqEventImpl> queuedEvents = cQuery.getQueuedEvents();
+            // Check to see, if its not set to null while waiting to get
+            // Synchronization lock.
+            if (queuedEvents != null) {
+              if (isDebugEnabled) {
+                logger.debug("Queueing event for key: {}", key);
+              }
+              cQuery.getVsdStats().incQueuedCqListenerEvents();
+              queuedEvents.add(cqEvent);
+              continue;
-            cQuery.getVsdStats().incQueuedCqListenerEvents();
-            queuedEvents.add(cqEvent);
-            continue;
-      }
-      this.invokeListeners(cqName, cQuery, cqEvent, fullValue);
-      if (value == null) {
-        value = fullValue[0];
-      }
+        this.invokeListeners(cqName, cQuery, cqEvent, fullValue);
+        if (value == null) {
+          value = fullValue[0];
+        }
-      catch(Throwable t) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_ERROR_PROCESSING_CQLISTENER_FOR_CQ_0, cqName), t);
-        
+      catch (Throwable t) {
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.CqService_ERROR_PROCESSING_CQLISTENER_FOR_CQ_0, cqName), t);
+
-          logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_VIRTUALMACHINEERROR_PROCESSING_CQLISTENER_FOR_CQ_0, cqName), t);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.CqService_VIRTUALMACHINEERROR_PROCESSING_CQLISTENER_FOR_CQ_0,
+              cqName), t);
-  public void invokeListeners(String cqName, ClientCQImpl cQuery,
-      CqEventImpl cqEvent) {
+  public void invokeListeners(String cqName, ClientCQImpl cQuery, CqEventImpl cqEvent) {
-  public void invokeListeners(String cqName, ClientCQImpl cQuery,
-      CqEventImpl cqEvent, Object[] fullValue) {
+  public void invokeListeners(String cqName, ClientCQImpl cQuery, CqEventImpl cqEvent,
+      Object[] fullValue) {
-    
+
-      logger.debug("Invoking CQ listeners for {}, number of listeners : {} cqEvent : {}", cqName, cqListeners.length, cqEvent);
+      logger.debug("Invoking CQ listeners for {}, number of listeners : {} cqEvent : {}", cqName,
+          cqListeners.length, cqEvent);
-    
-    for (int lCnt=0; lCnt < cqListeners.length; lCnt++) {
+
+    for (int lCnt = 0; lCnt < cqListeners.length; lCnt++) {
-        if (cqListeners[lCnt] != null){
+        if (cqListeners[lCnt] != null) {
-          if (cqEvent.getThrowable() != null) {
-            cqListeners[lCnt].onError(cqEvent);
-          } else {
-            cqListeners[lCnt].onEvent(cqEvent);
-          }
+            if (cqEvent.getThrowable() != null) {
+              cqListeners[lCnt].onError(cqEvent);
+            } else {
+              cqListeners[lCnt].onEvent(cqEvent);
+            }
-            Part result = (Part)GetEventValueOp.executeOnPrimary(cqEvent
-                .getQueueManager().getPool(), cqEvent.getEventID(), null);
+            Part result = (Part) GetEventValueOp
+                .executeOnPrimary(cqEvent.getQueueManager().getPool(), cqEvent.getEventID(), null);
-                Exception ex = new Exception(
-                    "Failed to retrieve full value from server for eventID "
-                    + cqEvent.getEventID());
+                Exception ex =
+                    new Exception("Failed to retrieve full value from server for eventID "
+                        + cqEvent.getEventID());
-                    new Object[] { cqName, ex.getMessage() }));
+                    new Object[] {cqName, ex.getMessage()}));
-            }
-            else {
-              ((GemFireCacheImpl)this.cache).getCachePerfStats().incDeltaFullValuesRequested();
+            } else {
+              ((GemFireCacheImpl) this.cache).getCachePerfStats().incDeltaFullValuesRequested();
-                    cqEvent.getQueryOperation(), cqEvent.getKey(), newVal,
-                    cqEvent.getDeltaValue(), cqEvent.getQueueManager(), cqEvent.getEventID());
+                  cqEvent.getQueryOperation(), cqEvent.getKey(), newVal, cqEvent.getDeltaValue(),
+                  cqEvent.getQueueManager(), cqEvent.getEventID());
-              new Object[] { cqName, ex.getMessage()}));
+              new Object[] {cqName, ex.getMessage()}));
-      } 
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_RUNTIME_EXCEPTION_IN_THE_CQLISTENER_OF_THE_CQ_CQNAME_0_ERROR__1, new Object[] {cqName, t.getLocalizedMessage()}));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CqService_RUNTIME_EXCEPTION_IN_THE_CQLISTENER_OF_THE_CQ_CQNAME_0_ERROR__1,
+            new Object[] {cqName, t.getLocalizedMessage()}));
-      }      
-    }    
+      }
+    }
-  
+
-    
-    if (logger.isDebugEnabled()){
-      logger.debug("Invoking CQ status listeners for {}, number of listeners : {}", cqName, cqListeners.length);
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("Invoking CQ status listeners for {}, number of listeners : {}", cqName,
+          cqListeners.length);
-    
-    for (int lCnt=0; lCnt < cqListeners.length; lCnt++) {
+
+    for (int lCnt = 0; lCnt < cqListeners.length; lCnt++) {
-            }
-            else {
+            } else {
-              new Object[] { cqName, ex.getMessage()}));
+              new Object[] {cqName, ex.getMessage()}));
-      } 
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_RUNTIME_EXCEPTION_IN_THE_CQLISTENER_OF_THE_CQ_CQNAME_0_ERROR__1, new Object[] {cqName, t.getLocalizedMessage()}));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CqService_RUNTIME_EXCEPTION_IN_THE_CQLISTENER_OF_THE_CQ_CQNAME_0_ERROR__1,
+            new Object[] {cqName, t.getLocalizedMessage()}));
-      }      
-    }    
+      }
+    }
-  
-  
+
+
+   * 
-  private Operation getOperation(int eventType) {  
+  private Operation getOperation(int eventType) {
-      case MessageType.LOCAL_CREATE :
+      case MessageType.LOCAL_CREATE:
-        
-      case MessageType.LOCAL_UPDATE :
+
+      case MessageType.LOCAL_UPDATE:
-        
-      case MessageType.LOCAL_DESTROY :
+
+      case MessageType.LOCAL_DESTROY:
-        break;        
-        
-      case MessageType.LOCAL_INVALIDATE :
+        break;
+
+      case MessageType.LOCAL_INVALIDATE:
-        break;        
-        
-      case MessageType.CLEAR_REGION :
+        break;
+
+      case MessageType.CLEAR_REGION:
-        break;        
-        
-      case MessageType.INVALIDATE_REGION :
+        break;
+
+      case MessageType.INVALIDATE_REGION:
-        break;        
+        break;
-    return op;    
+    return op;
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqService#processEvents(org.apache.geode.cache.CacheEvent, org.apache.geode.distributed.internal.DistributionAdvisor.Profile, org.apache.geode.distributed.internal.DistributionAdvisor.Profile[], org.apache.geode.internal.cache.FilterRoutingInfo)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqService#processEvents(org.apache.geode.cache.
+   * CacheEvent, org.apache.geode.distributed.internal.DistributionAdvisor.Profile,
+   * org.apache.geode.distributed.internal.DistributionAdvisor.Profile[],
+   * org.apache.geode.internal.cache.FilterRoutingInfo)
-  public void processEvents (CacheEvent event, Profile localProfile, Profile[] profiles, FilterRoutingInfo frInfo) 
-    throws CqException {
-    //Is this a region event or an entry event
-    if (event instanceof RegionEvent){
+  public void processEvents(CacheEvent event, Profile localProfile, Profile[] profiles,
+      FilterRoutingInfo frInfo) throws CqException {
+    // Is this a region event or an entry event
+    if (event instanceof RegionEvent) {
-        processEntryEvent (event, localProfile, profiles, frInfo);
+        processEntryEvent(event, localProfile, profiles, frInfo);
-  private void processRegionEvent(CacheEvent event, Profile localProfile, Profile[] profiles, FilterRoutingInfo frInfo)  
-    throws CqException {
+  private void processRegionEvent(CacheEvent event, Profile localProfile, Profile[] profiles,
+      FilterRoutingInfo frInfo) throws CqException {
-      logger.debug("CQ service processing region event {}", event); 
+      logger.debug("CQ service processing region event {}", event);
-    
-    for (int i=-1; i < profiles.length; i++) {
+
+    for (int i = -1; i < profiles.length; i++) {
-      if (i<0) {
-        cf = (CacheProfile)localProfile;
-        if (cf == null) continue;
+      if (i < 0) {
+        cf = (CacheProfile) localProfile;
+        if (cf == null)
+          continue;
-        cf = (CacheProfile)profiles[i];
+        cf = (CacheProfile) profiles[i];
-      while (cqIter.hasNext()){
-        Map.Entry cqEntry = (Map.Entry)cqIter.next();
-        ServerCQImpl cQuery = (ServerCQImpl)cqEntry.getValue();
-        if (!event.isOriginRemote() && event.getOperation().isRegionDestroy() &&
-            !((LocalRegion)event.getRegion()).isUsedForPartitionedRegionBucket()) {
+      while (cqIter.hasNext()) {
+        Map.Entry cqEntry = (Map.Entry) cqIter.next();
+        ServerCQImpl cQuery = (ServerCQImpl) cqEntry.getValue();
+        if (!event.isOriginRemote() && event.getOperation().isRegionDestroy()
+            && !((LocalRegion) event.getRegion()).isUsedForPartitionedRegionBucket()) {
-            if (isDebugEnabled){
+            if (isDebugEnabled) {
-          } 
-          catch (Exception ex) {
+          } catch (Exception ex) {
-              logger.debug("Failed to Close CQ on region destroy. CqName : {}", cQuery.getName(), ex);
+              logger.debug("Failed to Close CQ on region destroy. CqName : {}", cQuery.getName(),
+                  ex);
-          }      
+          }
-      if(pf.isLocalProfile()){
+      if (pf.isLocalProfile()) {
-  private void processEntryEvent(CacheEvent event, Profile localProfile, Profile[] profiles, FilterRoutingInfo frInfo)
-  throws CqException {
+  private void processEntryEvent(CacheEvent event, Profile localProfile, Profile[] profiles,
+      FilterRoutingInfo frInfo) throws CqException {
-    EntryEvent entryEvent = (EntryEvent)event;
+    EntryEvent entryEvent = (EntryEvent) event;
-   
-    boolean isDupEvent = ((EntryEventImpl)event).isPossibleDuplicate();
+
+    boolean isDupEvent = ((EntryEventImpl) event).isPossibleDuplicate();
-    // invalidate and in case when op is create and its an duplicate 
+    // invalidate and in case when op is create and its an duplicate
-    boolean opRequiringQueryOnOldValue = (event.getOperation().isUpdate() || 
-        event.getOperation().isDestroy() ||
-        event.getOperation().isInvalidate() || 
-        (event.getOperation().isCreate() && isDupEvent));
+    boolean opRequiringQueryOnOldValue = (event.getOperation().isUpdate()
+        || event.getOperation().isDestroy() || event.getOperation().isInvalidate()
+        || (event.getOperation().isCreate() && isDupEvent));
-    for (int i=-1; i < profiles.length; i++) {
+    for (int i = -1; i < profiles.length; i++) {
-      if (i<0) {
-        cf = (CacheProfile)localProfile;
-        if (cf == null) continue;
+      if (i < 0) {
+        cf = (CacheProfile) localProfile;
+        if (cf == null)
+          continue;
-        cf = (CacheProfile)profiles[i];
+        cf = (CacheProfile) profiles[i];
-      
+
-      
-      
+
+
-      if (cqUnfilteredEventsSet_newValue.isEmpty() && (event.getOperation().isCreate() ||  event.getOperation().isUpdate())) {
+      if (cqUnfilteredEventsSet_newValue.isEmpty()
+          && (event.getOperation().isCreate() || event.getOperation().isUpdate())) {
-          //We have a new value to run the query on
+          // We have a new value to run the query on
-      
+
-      
-      while (cqIter.hasNext()){
-        Map.Entry cqEntry = (Map.Entry)cqIter.next();
-        ServerCQImpl cQuery = (ServerCQImpl)cqEntry.getValue();
+
+      while (cqIter.hasNext()) {
+        Map.Entry cqEntry = (Map.Entry) cqIter.next();
+        ServerCQImpl cQuery = (ServerCQImpl) cqEntry.getValue();
-        if (cQuery == null){
+        if (cQuery == null) {
-        }        
+        }
-          if (cqEvent.intValue() == MessageType.LOCAL_CREATE ||
-              cqEvent.intValue() == MessageType.LOCAL_UPDATE) {
-              cQuery.addToCqResultKeys(eventKey);
+          if (cqEvent.intValue() == MessageType.LOCAL_CREATE
+              || cqEvent.intValue() == MessageType.LOCAL_UPDATE) {
+            cQuery.addToCqResultKeys(eventKey);
-              cQuery.markAsDestroyedInCqResultKeys(eventKey);
+            cQuery.markAsDestroyedInCqResultKeys(eventKey);
-          //synchronized (cQuery) 
+          // synchronized (cQuery)
-                  b_cqResults_newValue = evaluateQuery(cQuery, new Object[] { cqUnfilteredEventsSet_newValue });
+                  b_cqResults_newValue =
+                      evaluateQuery(cQuery, new Object[] {cqUnfilteredEventsSet_newValue});
-                // Check if CQ Result is cached, if not apply query on old 
-                // value. Currently the CQ Results are not cached for the 
-                // Partitioned Regions. Once this is added remove the check 
+                // Check if CQ Result is cached, if not apply query on old
+                // value. Currently the CQ Results are not cached for the
+                // Partitioned Regions. Once this is added remove the check
-                  // Also apply if the query was not executed during cq execute 
-                  if ((cQuery.isPR || !CqServiceImpl.EXECUTE_QUERY_DURING_INIT) && b_cqResults_oldValue == false) {
+                  // Also apply if the query was not executed during cq execute
+                  if ((cQuery.isPR || !CqServiceImpl.EXECUTE_QUERY_DURING_INIT)
+                      && b_cqResults_oldValue == false) {
-                  } 
+                  }
-                    logger.debug("Event Key not found in the CQ Result Queue. EventKey : {} CQ Name : {}", eventKey, cqName );
+                    logger.debug(
+                        "Event Key not found in the CQ Result Queue. EventKey : {} CQ Name : {}",
+                        eventKey, cqName);
-                  
+
-                      b_cqResults_oldValue = evaluateQuery(cQuery, new Object[] { cqUnfilteredEventsSet_oldValue });
+                      b_cqResults_oldValue =
+                          evaluateQuery(cQuery, new Object[] {cqUnfilteredEventsSet_oldValue});
-                        logger.debug("old value for event with key {} is null - query execution not performed", eventKey);
+                        logger.debug(
+                            "old value for event with key {} is null - query execution not performed",
+                            eventKey);
-                
-              } 
+
+              }
-              // Any exception in running the query should be caught here and 
-              // buried because this code is running in-line with the message 
+              // Any exception in running the query should be caught here and
+              // buried because this code is running in-line with the message
-                 LocalizedStrings.CqService_ERROR_WHILE_PROCESSING_CQ_ON_THE_EVENT_KEY_0_CQNAME_1_ERROR_2,
-                  new Object[] { ((EntryEvent)event).getKey(), cQuery.getName(), ex.getLocalizedMessage()}));
+                  LocalizedStrings.CqService_ERROR_WHILE_PROCESSING_CQ_ON_THE_EVENT_KEY_0_CQNAME_1_ERROR_2,
+                  new Object[] {((EntryEvent) event).getKey(), cQuery.getName(),
+                      ex.getLocalizedMessage()}));
-              cqEvent = MESSAGE_TYPE_EXCEPTION; 
-            } 
-            else { 
+              cqEvent = MESSAGE_TYPE_EXCEPTION;
+            } else {
-                // If its create and caching is enabled, cache the key 
+                // If its create and caching is enabled, cache the key
-                // When the invalidate comes through, the entry will no longer 
+                // When the invalidate comes through, the entry will no longer
-                // If caching is enabled, mark this event's key as removed 
+                // If caching is enabled, mark this event's key as removed
-          } //end synchronized(cQuery)
+          } // end synchronized(cQuery)
-          //synchronized (this.matchingCqMap){
-            String query = cQuery.getQueryString();
-            Set matchingCqs = (Set)matchingCqMap.get(query);
-            if (matchingCqs != null) {
-              Iterator iter = matchingCqs.iterator();
-              while (iter.hasNext()) {
-                String matchingCqName = (String)iter.next();
-                if (!matchingCqName.equals(cqName)){
-                  matchedCqs.put(matchingCqName, cqEvent);
-                  if (isDebugEnabled) {
-                    logger.debug("Adding CQ into Matching CQ Map: {} Event is: {}", matchingCqName, cqEvent);
-                  }
+          // synchronized (this.matchingCqMap){
+          String query = cQuery.getQueryString();
+          Set matchingCqs = (Set) matchingCqMap.get(query);
+          if (matchingCqs != null) {
+            Iterator iter = matchingCqs.iterator();
+            while (iter.hasNext()) {
+              String matchingCqName = (String) iter.next();
+              if (!matchingCqName.equals(cqName)) {
+                matchedCqs.put(matchingCqName, cqEvent);
+                if (isDebugEnabled) {
+                  logger.debug("Adding CQ into Matching CQ Map: {} Event is: {}", matchingCqName,
+                      cqEvent);
-          //}
+          }
+          // }
-        if (cqEvent != null && cQuery.isRunning()){
+        if (cqEvent != null && cQuery.isRunning()) {
-            logger.debug("Added event to CQ with client-side name: {} key: {} operation : {}", cQuery.cqName, eventKey, cqEvent);
-          }         
+            logger.debug("Added event to CQ with client-side name: {} key: {} operation : {}",
+                cQuery.cqName, eventKey, cqEvent);
+          }
-      } 
+      }
-        if(pf.isLocalProfile()){
+        if (pf.isLocalProfile()) {
-/*  public void processEvents (EnumListenerEvent operation, CacheEvent event,
-                             ClientUpdateMessage clientMessage, 
-                             CM<ClientProxyMembershipID, CM<CqQuery, Boolean>> clientIds) 
-  throws CqException {
-  
-    //Is this a region event or an entry event
-    if (event instanceof RegionEvent){
-      processRegionEvent(operation, event, clientMessage, clientIds);
-    } else {
-      processEntryEvent (operation, event, clientMessage, clientIds);
-    }
+  /*
+   * public void processEvents (EnumListenerEvent operation, CacheEvent event, ClientUpdateMessage
+   * clientMessage, CM<ClientProxyMembershipID, CM<CqQuery, Boolean>> clientIds) throws CqException
+   * {
+   * 
+   * //Is this a region event or an entry event if (event instanceof RegionEvent){
+   * processRegionEvent(operation, event, clientMessage, clientIds); } else { processEntryEvent
+   * (operation, event, clientMessage, clientIds); }
+   * 
+   * }
+   * 
+   * private void processRegionEvent(EnumListenerEvent operation, CacheEvent event,
+   * ClientUpdateMessage clientMessage, CM<ClientProxyMembershipID, CM<CqQuery, Boolean>> clientIds)
+   * throws CqException {
+   * 
+   * if (logger.isDebugEnabled()) { logger.debug("Processing region event for region " +
+   * ((LocalRegion)(event.getRegion())).getName()); } HashMap filteredCqs = new HashMap(); Integer
+   * cqRegionEvent = generateCqRegionEvent(operation); Iterator it =
+   * clientIds.entrySet().iterator(); while (it.hasNext()) { Map.Entry me = (Map.Entry)it.next();
+   * ClientProxyMembershipID clientId = (ClientProxyMembershipID)me.getKey(); CM cqsToBooleans =
+   * (CM)me.getValue(); if (cqsToBooleans == null) { continue; } Set<CqQuery> cqs =
+   * cqsToBooleans.keySet(); if (cqs.isEmpty()) { continue; } filteredCqs.clear(); Iterator cqIt =
+   * cqs.iterator(); while (cqIt.hasNext()) { CqQueryImpl cQuery = (CqQueryImpl)cqIt.next(); if
+   * (operation == EnumListenerEvent.AFTER_REGION_DESTROY) { try { if (logger.isDebugEnabled()){
+   * logger.debug("Closing CQ on region destroy event. CqName :" + cQuery.getName()); }
+   * cQuery.close(false); } catch (Exception ex) {
+   * logger.debug("Failed to Close CQ on region destroy. CqName :" + cQuery.getName(), ex); }
+   * 
+   * } filteredCqs.put(cQuery.cqName, cqRegionEvent);
+   * cQuery.getVsdStats().updateStats(cqRegionEvent);
+   * 
+   * } if (!filteredCqs.isEmpty()){ ((ClientUpdateMessageImpl)clientMessage).addClientCqs( clientId,
+   * filteredCqs); }
+   * 
+   * }
+   * 
+   * }
+   * 
+   * private void processEntryEvent(EnumListenerEvent operation, CacheEvent event,
+   * ClientUpdateMessage clientMessage, CM<ClientProxyMembershipID, CM<CqQuery, Boolean>> clientIds)
+   * throws CqException { HashSet cqUnfilteredEventsSet_newValue = new HashSet(); HashSet
+   * cqUnfilteredEventsSet_oldValue = new HashSet(); boolean b_cqResults_newValue = false; boolean
+   * b_cqResults_oldValue = false; EntryEvent entryEvent = (EntryEvent)event; Object eventKey =
+   * entryEvent.getKey(); if (operation == EnumListenerEvent.AFTER_CREATE || operation ==
+   * EnumListenerEvent.AFTER_UPDATE) { if (entryEvent.getNewValue() != null) { //We have a new value
+   * to run the query on cqUnfilteredEventsSet_newValue.clear();
+   * cqUnfilteredEventsSet_newValue.add(entryEvent.getNewValue()); } }
+   * 
+   * HashMap matchedCqs = new HashMap(); long executionStartTime = 0; Iterator it =
+   * clientIds.entrySet().iterator(); while (it.hasNext()) { Map.Entry me = (Map.Entry)it.next();
+   * ClientProxyMembershipID clientId = (ClientProxyMembershipID)me.getKey(); if
+   * (logger.isDebugEnabled()) { logger.debug("Processing event for CQ filter, ClientId : " +
+   * clientId); } CM cqsToBooleans = (CM)me.getValue(); if (cqsToBooleans == null) { continue; }
+   * Set<CqQuery> cqs = cqsToBooleans.keySet(); if (cqs.isEmpty()) { continue; } HashMap filteredCqs
+   * = new HashMap(); Iterator cqIt = cqs.iterator(); while (cqIt.hasNext()) { CqQueryImpl cQuery =
+   * (CqQueryImpl)cqIt.next(); b_cqResults_newValue = false; b_cqResults_oldValue = false; if
+   * (cQuery == null || !(cQuery.isRunning())){ continue; } String cqName =
+   * cQuery.getServerCqName(); Integer cqEvent = null; if (matchedCqs.containsKey(cqName)) { if
+   * (logger.isDebugEnabled()){ logger.
+   * debug("Similar cq/query is already processed, getting the cq event-type from the matched cq.");
+   * } cqEvent = (Integer)matchedCqs.get(cqName); } else { boolean error = false; boolean
+   * hasSeenEvent = false; HashSet cqEventKeys = null; synchronized (cQuery) { try { // Apply query
+   * on new value. if (!cqUnfilteredEventsSet_newValue.isEmpty()) { executionStartTime =
+   * this.stats.startCqQueryExecution(); b_cqResults_newValue = evaluateQuery(cQuery, new Object[]
+   * {cqUnfilteredEventsSet_newValue}); this.stats.endCqQueryExecution(executionStartTime); } //
+   * Check if old value is cached, if not apply query on old value. if (cqToCqEventKeysMap != null)
+   * { synchronized (cqToCqEventKeysMap) { if ((cqEventKeys =
+   * (HashSet)cqToCqEventKeysMap.get(cqName)) != null) { hasSeenEvent =
+   * cqEventKeys.contains(eventKey); } } } if (!hasSeenEvent) { // get the oldValue. // In case of
+   * Update, destroy and invalidate. if (operation == EnumListenerEvent.AFTER_UPDATE || operation ==
+   * EnumListenerEvent.AFTER_DESTROY || operation == EnumListenerEvent.AFTER_INVALIDATE) { if
+   * (entryEvent.getOldValue() != null) { cqUnfilteredEventsSet_oldValue.clear();
+   * cqUnfilteredEventsSet_oldValue.add(entryEvent.getOldValue()); // Apply query on old value.
+   * executionStartTime = this.stats.startCqQueryExecution(); b_cqResults_oldValue =
+   * evaluateQuery(cQuery, new Object[] {cqUnfilteredEventsSet_oldValue});
+   * this.stats.endCqQueryExecution(executionStartTime); } } } } catch (Exception ex) { //Any
+   * exception in running the query // should be caught here and buried //because this code is
+   * running inline with the //message processing code and we don't want to //kill that thread error
+   * = true; logger.info( LocalizedStrings.
+   * CqService_ERROR_WHILE_PROCESSING_CQ_ON_THE_EVENT_KEY_0_CQNAME_1_CLIENTID_2_ERROR_3, new
+   * Object[] { ((EntryEvent)event).getKey(), cQuery.getName(), clientId,
+   * ex.getLocalizedMessage()}); }
+   * 
+   * if (error) { cqEvent = Integer.valueOf(MessageType.EXCEPTION); } else { if
+   * (b_cqResults_newValue) { if (hasSeenEvent || b_cqResults_oldValue) { cqEvent =
+   * Integer.valueOf(MessageType.LOCAL_UPDATE); } else { cqEvent =
+   * Integer.valueOf(MessageType.LOCAL_CREATE); } // If its create and caching is enabled, cache the
+   * key for this CQ. if (!hasSeenEvent && cqEventKeys != null) { cqEventKeys.add(eventKey); } }
+   * else if (hasSeenEvent || (b_cqResults_oldValue)) { // Base invalidate operation is treated as
+   * destroy. // When the invalidate comes through, the entry will no longer satisfy // the query
+   * and will need to be deleted. cqEvent = Integer.valueOf(MessageType.LOCAL_DESTROY); // If
+   * caching is enabled, remove this event's key from the cache. if (hasSeenEvent && cqEventKeys !=
+   * null) { cqEventKeys.remove(eventKey); } } }
+   * 
+   * } //end synchronized(cQuery)
+   * 
+   * // Get the matching CQs if any. synchronized (this.matchingCqMap){ String query =
+   * cQuery.getQueryString(); ArrayList matchingCqs = (ArrayList)matchingCqMap.get(query); if
+   * (matchingCqs != null) { Iterator iter = matchingCqs.iterator(); while (iter.hasNext()) { String
+   * matchingCqName = (String)iter.next(); if (!matchingCqName.equals(cqName)){
+   * matchedCqs.put(matchingCqName, cqEvent); } } } }
+   * 
+   * }
+   * 
+   * if (cqEvent != null){ if (logger.isDebugEnabled()) {
+   * logger.debug("Event is added for the CQ, CqName (clientside): " + cQuery.cqName +
+   * " With CQ Op : " + cqEvent + " for Client : " + clientId); } filteredCqs.put(cQuery.cqName,
+   * cqEvent); cQuery.getVsdStats().updateStats(cqEvent); }
+   * 
+   * } // iteration over cqsToBooleans.keySet() if (!filteredCqs.isEmpty()){
+   * logger.debug("Adding event map for client : "+clientId +
+   * " with event map size : "+filteredCqs.size());
+   * ((ClientUpdateMessageImpl)clientMessage).addClientCqs(clientId, filteredCqs); } } // iteration
+   * over clientIds.entrySet() }
+   */
-  }
-  
-  private void processRegionEvent(EnumListenerEvent operation, CacheEvent event,
-                                  ClientUpdateMessage clientMessage, 
-                                  CM<ClientProxyMembershipID, CM<CqQuery, Boolean>> clientIds) 
-  throws CqException {
-    
-    if (logger.isDebugEnabled()) {
-      logger.debug("Processing region event for region " + 
-                  ((LocalRegion)(event.getRegion())).getName());
-    }
-    HashMap filteredCqs = new HashMap(); 
-    Integer cqRegionEvent = generateCqRegionEvent(operation);
-    Iterator it = clientIds.entrySet().iterator();
-    while (it.hasNext()) {
-      Map.Entry me = (Map.Entry)it.next();
-      ClientProxyMembershipID clientId = (ClientProxyMembershipID)me.getKey();
-      CM cqsToBooleans = (CM)me.getValue();
-      if (cqsToBooleans == null) {
-        continue;
-      }
-      Set<CqQuery> cqs = cqsToBooleans.keySet();
-      if (cqs.isEmpty()) {
-        continue;
-      }
-      filteredCqs.clear();
-      Iterator cqIt = cqs.iterator();
-      while (cqIt.hasNext()) {
-        CqQueryImpl cQuery = (CqQueryImpl)cqIt.next();
-        if (operation == EnumListenerEvent.AFTER_REGION_DESTROY) {
-          try {
-            if (logger.isDebugEnabled()){
-              logger.debug("Closing CQ on region destroy event. CqName :" 
-                            + cQuery.getName());
-            }
-            cQuery.close(false);
-          } 
-          catch (Exception ex) {
-            logger.debug("Failed to Close CQ on region destroy. CqName :" + 
-                         cQuery.getName(), ex);
-          }      
-
-        }
-        filteredCqs.put(cQuery.cqName, cqRegionEvent);
-        cQuery.getVsdStats().updateStats(cqRegionEvent);
-        
-      }
-      if (!filteredCqs.isEmpty()){
-        ((ClientUpdateMessageImpl)clientMessage).addClientCqs(
-            clientId, filteredCqs);
-      }
-      
-    }
-  
-  }
-  
-  private void processEntryEvent(EnumListenerEvent operation, CacheEvent event,
-                                 ClientUpdateMessage clientMessage, 
-                                 CM<ClientProxyMembershipID, CM<CqQuery, Boolean>> clientIds)
-  throws CqException {
-    HashSet cqUnfilteredEventsSet_newValue = new HashSet();
-    HashSet cqUnfilteredEventsSet_oldValue = new HashSet();
-    boolean b_cqResults_newValue = false;
-    boolean b_cqResults_oldValue = false;
-    EntryEvent entryEvent = (EntryEvent)event;
-    Object eventKey = entryEvent.getKey();
-    if (operation == EnumListenerEvent.AFTER_CREATE || 
-        operation == EnumListenerEvent.AFTER_UPDATE) {
-      if (entryEvent.getNewValue() != null) {
-        //We have a new value to run the query on
-        cqUnfilteredEventsSet_newValue.clear();
-        cqUnfilteredEventsSet_newValue.add(entryEvent.getNewValue());
-      }
-    }
-     
-    HashMap matchedCqs = new HashMap();
-    long executionStartTime = 0;
-    Iterator it = clientIds.entrySet().iterator();
-    while (it.hasNext()) {
-      Map.Entry me = (Map.Entry)it.next();
-      ClientProxyMembershipID clientId = (ClientProxyMembershipID)me.getKey();
-      if (logger.isDebugEnabled()) {
-        logger.debug("Processing event for CQ filter, ClientId : " + clientId);
-      }
-      CM cqsToBooleans = (CM)me.getValue();
-      if (cqsToBooleans == null) {
-        continue;
-      }
-      Set<CqQuery> cqs = cqsToBooleans.keySet();
-      if (cqs.isEmpty()) {
-        continue;
-      }
-      HashMap filteredCqs = new HashMap();
-      Iterator cqIt = cqs.iterator();
-      while (cqIt.hasNext()) {
-        CqQueryImpl cQuery = (CqQueryImpl)cqIt.next();
-        b_cqResults_newValue = false;
-        b_cqResults_oldValue = false;       
-        if (cQuery == null || !(cQuery.isRunning())){
-          continue;
-        }        
-        String cqName = cQuery.getServerCqName();
-        Integer cqEvent = null;
-        if (matchedCqs.containsKey(cqName)) {
-          if (logger.isDebugEnabled()){
-            logger.debug("Similar cq/query is already processed, getting the cq event-type from the matched cq.");
-          }
-          cqEvent = (Integer)matchedCqs.get(cqName);
-        } else {
-          boolean error = false;
-          boolean hasSeenEvent = false;
-          HashSet cqEventKeys = null;
-          synchronized (cQuery) {
-            try {
-              // Apply query on new value.
-              if (!cqUnfilteredEventsSet_newValue.isEmpty()) {
-                executionStartTime = this.stats.startCqQueryExecution();
-                b_cqResults_newValue = evaluateQuery(cQuery, 
-                                                     new Object[] {cqUnfilteredEventsSet_newValue});
-                this.stats.endCqQueryExecution(executionStartTime);
-              }
-              // Check if old value is cached, if not apply query on old value.
-              if (cqToCqEventKeysMap != null) {
-                synchronized (cqToCqEventKeysMap) {
-                  if ((cqEventKeys = (HashSet)cqToCqEventKeysMap.get(cqName)) != null) {
-                    hasSeenEvent = cqEventKeys.contains(eventKey);
-                  }
-                }
-              }  
-              if (!hasSeenEvent) {
-                // get the oldValue.
-                // In case of Update, destroy and invalidate.
-                if (operation == EnumListenerEvent.AFTER_UPDATE || 
-                    operation == EnumListenerEvent.AFTER_DESTROY ||
-                    operation == EnumListenerEvent.AFTER_INVALIDATE) {
-                  if (entryEvent.getOldValue() != null) {
-                    cqUnfilteredEventsSet_oldValue.clear();
-                    cqUnfilteredEventsSet_oldValue.add(entryEvent.getOldValue());
-                    // Apply query on old value.
-                    executionStartTime = this.stats.startCqQueryExecution();
-                    b_cqResults_oldValue = evaluateQuery(cQuery, 
-                                                         new Object[] {cqUnfilteredEventsSet_oldValue});
-                    this.stats.endCqQueryExecution(executionStartTime);
-                  }
-                }
-              }
-            }
-            catch (Exception ex) {
-              //Any exception in running the query
-              // should be caught here and buried
-              //because this code is running inline with the 
-              //message processing code and we don't want to 
-              //kill that thread
-              error = true;
-              logger.info(
-                LocalizedStrings.CqService_ERROR_WHILE_PROCESSING_CQ_ON_THE_EVENT_KEY_0_CQNAME_1_CLIENTID_2_ERROR_3,
-                new Object[] { ((EntryEvent)event).getKey(), cQuery.getName(), clientId, ex.getLocalizedMessage()});
-            }
-            
-            if (error) {
-              cqEvent = Integer.valueOf(MessageType.EXCEPTION);  
-            } 
-            else {
-              if (b_cqResults_newValue) {
-                if (hasSeenEvent || b_cqResults_oldValue) {
-                  cqEvent = Integer.valueOf(MessageType.LOCAL_UPDATE);
-                } else {
-                  cqEvent = Integer.valueOf(MessageType.LOCAL_CREATE);
-                }
-                // If its create and caching is enabled, cache the key for this CQ.
-                if (!hasSeenEvent && cqEventKeys != null) {
-                  cqEventKeys.add(eventKey);
-                } 
-              } 
-              else if (hasSeenEvent || (b_cqResults_oldValue)) {
-                // Base invalidate operation is treated as destroy.
-                // When the invalidate comes through, the entry will no longer satisfy 
-                // the query and will need to be deleted.
-                cqEvent = Integer.valueOf(MessageType.LOCAL_DESTROY);
-                // If caching is enabled, remove this event's key from the cache.
-                if (hasSeenEvent && cqEventKeys != null) {
-                  cqEventKeys.remove(eventKey);
-                }
-              }
-            }
-            
-          } //end synchronized(cQuery)
-
-          // Get the matching CQs if any.
-          synchronized (this.matchingCqMap){
-            String query = cQuery.getQueryString();
-            ArrayList matchingCqs = (ArrayList)matchingCqMap.get(query);
-            if (matchingCqs != null) {
-              Iterator iter = matchingCqs.iterator();
-              while (iter.hasNext()) {
-                String matchingCqName = (String)iter.next();
-                if (!matchingCqName.equals(cqName)){
-                  matchedCqs.put(matchingCqName, cqEvent);
-                }
-              }
-            }
-          }
-          
-        }
- 
-        if (cqEvent != null){
-          if (logger.isDebugEnabled()) {
-            logger.debug("Event is added for the CQ, CqName (clientside): " + cQuery.cqName + 
-            " With CQ Op : " + cqEvent + " for Client : " + clientId);
-          }
-          filteredCqs.put(cQuery.cqName, cqEvent);
-          cQuery.getVsdStats().updateStats(cqEvent);
-        }
- 
-      } // iteration over cqsToBooleans.keySet()
-      if (!filteredCqs.isEmpty()){
-        logger.debug("Adding event map for client : "+clientId + " with event map size : "+filteredCqs.size());
-        ((ClientUpdateMessageImpl)clientMessage).addClientCqs(clientId, filteredCqs);
-      }
-    } // iteration over clientIds.entrySet()
-  }
-*/ 
- 
-    }
-    else if (event.getOperation().isRegionInvalidate()) {
+    } else if (event.getOperation().isRegionInvalidate()) {
-    }
-    else if (event.getOperation().isClear()){
+    } else if (event.getOperation().isClear()) {
-    } 
+    }
-  
+
-   * Manages the CQs created for the base region.
-   * This is managed here, instead of on the base region; since the cq could be
-   * created on the base region, before base region is created (using newCq()).
+   * Manages the CQs created for the base region. This is managed here, instead of on the base
+   * region; since the cq could be created on the base region, before base region is created (using
+   * newCq()).
-  public void addToBaseRegionToCqNameMap(String regionName, String cqName){
-    synchronized(this.baseRegionToCqNameMap){
+  public void addToBaseRegionToCqNameMap(String regionName, String cqName) {
+    synchronized (this.baseRegionToCqNameMap) {
-      if (cqs == null){
+      if (cqs == null) {
-  
-  public void removeFromBaseRegionToCqNameMap(String regionName, String cqName){
-    synchronized(this.baseRegionToCqNameMap){
+
+  public void removeFromBaseRegionToCqNameMap(String regionName, String cqName) {
+    synchronized (this.baseRegionToCqNameMap) {
-      if (cqs != null){
+      if (cqs != null) {
-        if (cqs.isEmpty()){
+        if (cqs.isEmpty()) {
-  
+
+   * 
-   * Removes this CQ from CQ event Cache map. 
-   * This disables the caching events for this CQ. 
+   * Removes this CQ from CQ event Cache map. This disables the caching events for this CQ.
+   * 
-  synchronized public void removeCQFromCaching(String cqName){
-    if (cqToCqEventKeysMap != null) {
-      // Take a lock on CqQuery object. In processEvents the maps are
-      // handled under CqQuery object.
-      if (cqToCqEventKeysMap != null){
-        synchronized (cqToCqEventKeysMap) {        
-          cqToCqEventKeysMap.remove(cqName);
-        }
-      }
-    } 
-  }
-  */
-  
+   * synchronized public void removeCQFromCaching(String cqName){ if (cqToCqEventKeysMap != null) {
+   * // Take a lock on CqQuery object. In processEvents the maps are // handled under CqQuery
+   * object. if (cqToCqEventKeysMap != null){ synchronized (cqToCqEventKeysMap) {
+   * cqToCqEventKeysMap.remove(cqName); } } } }
+   */
+
+   * 
-   * Caller must synchronize on the returned value in order
-   * to inspect.
+   *         Caller must synchronize on the returned value in order to inspect.
-  public HashMap getCqToCqEventKeysMap(){
-    return cqToCqEventKeysMap; 
-  }
-  */
-  
+   * public HashMap getCqToCqEventKeysMap(){ return cqToCqEventKeysMap; }
+   */
+
+   * 
-    synchronized(this.matchingCqMap){
+    synchronized (this.matchingCqMap) {
-      if (!matchingCqMap.containsKey(cqQuery)){
+      if (!matchingCqMap.containsKey(cqQuery)) {
-        matchingCQs = (Set)matchingCqMap.get(cqQuery);
+        matchingCQs = (Set) matchingCqMap.get(cqQuery);
-        logger.debug("Adding CQ into MatchingCQ map, CQName: {} Number of matched querys are: {}" , cq.getServerCqName(), matchingCQs.size());
+        logger.debug("Adding CQ into MatchingCQ map, CQName: {} Number of matched querys are: {}",
+            cq.getServerCqName(), matchingCQs.size());
+   * 
-    synchronized(this.matchingCqMap){
+    synchronized (this.matchingCqMap) {
-      if (matchingCqMap.containsKey(cqQuery)){
-    	  Set matchingCQs = (Set)matchingCqMap.get(cqQuery);
+      if (matchingCqMap.containsKey(cqQuery)) {
+        Set matchingCQs = (Set) matchingCqMap.get(cqQuery);
-          logger.debug("Removing CQ from MatchingCQ map, CQName: {} Number of matched querys are: {}", cq.getServerCqName(), matchingCQs.size());
+          logger.debug(
+              "Removing CQ from MatchingCQ map, CQName: {} Number of matched querys are: {}",
+              cq.getServerCqName(), matchingCQs.size());
-        if (matchingCQs.isEmpty()){
+        if (matchingCQs.isEmpty()) {
-      } 
+      }
+   * 
-  public Map<String, HashSet<String>> getMatchingCqMap(){
-    return matchingCqMap; 
+  public Map<String, HashSet<String>> getMatchingCqMap() {
+    return matchingCqMap;
-   * Applies the query on the event.
-   * This method takes care of the performance related changed done to improve 
-   * the CQ-query performance. When CQ-query is executed first time, it saves the 
-   * query related information in the execution context and uses that info in later 
-   * executions. 
+   * Applies the query on the event. This method takes care of the performance related changed done
+   * to improve the CQ-query performance. When CQ-query is executed first time, it saves the query
+   * related information in the execution context and uses that info in later executions.
+   * 
-    
+
-      SelectResults results = (SelectResults)((DefaultQuery)cQuery.getQuery()).executeUsingContext(execContext);
+      SelectResults results =
+          (SelectResults) ((DefaultQuery) cQuery.getQuery()).executeUsingContext(execContext);
-      } 
+      }
-      CompiledSelect cs = ((DefaultQuery)(cQuery.getQuery())).getSelect();
+      CompiledSelect cs = ((DefaultQuery) (cQuery.getQuery())).getSelect();
-  
-//  public static void memberLeft(String poolName) {
-//    if (cqServiceSingleton != null  && !cqServiceSingleton.isServer()) {
-//      cqServiceSingleton.sendMemberDisconnectedMessageToCqs(poolName);
-//    }
-//  }
-//  
-//  public static void memberCrashed(String poolName) {
-//    if (cqServiceSingleton != null && !cqServiceSingleton.isServer()) {
-//      cqServiceSingleton.sendMemberDisconnectedMessageToCqs(poolName);
-//    }
-//  }
-//  
-  
+
+  // public static void memberLeft(String poolName) {
+  // if (cqServiceSingleton != null && !cqServiceSingleton.isServer()) {
+  // cqServiceSingleton.sendMemberDisconnectedMessageToCqs(poolName);
+  // }
+  // }
+  //
+  // public static void memberCrashed(String poolName) {
+  // if (cqServiceSingleton != null && !cqServiceSingleton.isServer()) {
+  // cqServiceSingleton.sendMemberDisconnectedMessageToCqs(poolName);
+  // }
+  // }
+  //
+
-  
+
-  
+
-    //Check to see if we are already connected/disconnected.
-    //If state has not changed, do not invoke another connected/disconnected 
-    synchronized(cqPoolsConnected) {
-      //don't repeatily send same connect/disconnect message to cq's on repeated fails of RedundancySatisfier
-      if (cqPoolsConnected.containsKey(poolName) && connected == cqPoolsConnected.get(poolName)){
+    // Check to see if we are already connected/disconnected.
+    // If state has not changed, do not invoke another connected/disconnected
+    synchronized (cqPoolsConnected) {
+      // don't repeatily send same connect/disconnect message to cq's on repeated fails of
+      // RedundancySatisfier
+      if (cqPoolsConnected.containsKey(poolName) && connected == cqPoolsConnected.get(poolName)) {
-    
+
-      for (InternalCqQuery query: cqs) {
+      for (InternalCqQuery query : cqs) {
-          
+
-  
-          //Check cq pool to determine if the pool matches, if not continue.
-          //Also if the connected state is already the same, we do not have to send status again.
-	  if (cQuery == null || cQuery.getCQProxy() == null) {
+
+          // Check cq pool to determine if the pool matches, if not continue.
+          // Also if the connected state is already the same, we do not have to send status again.
+          if (cQuery == null || cQuery.getCQProxy() == null) {
-          
+
-              logger.debug("Unable to invoke CqListener, {}, CqName : {}", ((cQuery == null) ? "CQ not found" : " CQ is Not running"), cqName);
+              logger.debug("Unable to invoke CqListener, {}, CqName : {}",
+                  ((cQuery == null) ? "CQ not found" : " CQ is Not running"), cqName);
-        
+
-          logger.warn(LocalizedMessage.create(LocalizedStrings.CqService_ERROR_SENDING_CQ_CONNECTION_STATUS, cqName), t);
-  
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.CqService_ERROR_SENDING_CQ_CONNECTION_STATUS, cqName), t);
+
-                    LocalizedStrings.CqService_VIRTUALMACHINEERROR_PROCESSING_CQLISTENER_FOR_CQ_0,
-                    cqName), t);
+                LocalizedStrings.CqService_VIRTUALMACHINEERROR_PROCESSING_CQLISTENER_FOR_CQ_0,
+                cqName), t);
-  
-  
+
+

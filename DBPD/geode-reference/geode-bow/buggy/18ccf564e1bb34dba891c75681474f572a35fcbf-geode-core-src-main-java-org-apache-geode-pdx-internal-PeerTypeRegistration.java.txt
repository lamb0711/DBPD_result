GEODE-6973: Use cachelistener to synchronize typeToId with IdToType

    Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>
    Co-authored-by: Donal Evans <doevans@pivotal.io>

-  /**
-   * This map serves two purposes. It lets us look up an id based on a type, if we previously found
-   * that type in the region. And, if a type is present in this map, that means we read the type
-   * while holding the dlock, which means the type was distributed to all members.
-   */
-  private final Map<PdxType, Integer> typeToId = Collections.synchronizedMap(new HashMap<>());
-
-  private final Map<EnumInfo, EnumId> enumToId = Collections.synchronizedMap(new HashMap<>());
+  private LocalReverseMap localReverseMap = new LocalReverseMap();
-        if (value instanceof PdxType) {
-          updateClassToTypeMap((PdxType) value);
+        Object key = event.getKey();
+        if (value != null) {
+          updateLocalMaps(key, value);
+
+    buildTypeToIdFromIdToType();
-    Integer existingId = typeToId.get(newType);
+    Integer existingId = localReverseMap.checkIfExistsInLocal(newType);
-      int id = getExistingIdForType(newType);
-      if (id != -1) {
-        return id;
+      if (localReverseMap.shouldReloadFromRegion()) {
+        buildTypeToIdFromIdToType();
+      }
+      localReverseMap.flushLocalMap();
+      // double check if my type is in region in case the typeToId map has been updated while
+      // waiting to obtain a lock
+      existingId = localReverseMap.checkIfExistsInLocal(newType);
+      if (existingId != null) {
+        return existingId;
-      id = allocateTypeId(newType);
+      int id = allocateTypeId(newType);
-
-      typeToId.put(newType, id);
-
+      localReverseMap.flushLocalMap();
-  /** Should be called holding the dlock */
-  private int getExistingIdForType(PdxType newType) {
+  private void buildTypeToIdFromIdToType() {
-      int result = -1;
-        if (k instanceof EnumId) {
-          EnumId id = (EnumId) k;
-          EnumInfo info = (EnumInfo) v;
-          enumToId.put(info, id);
-        } else {
+        if (v instanceof PdxType) {
-          }
-
-          typeToId.put(foundType, id);
-          if (foundType.equals(newType)) {
-            result = foundType.getTypeId();
+            if (totalPdxTypeIdInDS >= MAX_TYPE_ID) {
+              throw new InternalGemFireError(
+                  "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
+                      + MAX_TYPE_ID);
+            }
+        localReverseMap.save(k, v, false);
-      if (totalPdxTypeIdInDS == MAX_TYPE_ID) {
-        throw new InternalGemFireError(
-            "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
-                + MAX_TYPE_ID);
-      }
-      return result;
-          enumToId.put(info, id);
-        } else {
-          typeToId.put((PdxType) v, (Integer) k);
+        localReverseMap.save(k, v, false);
-    final EnumId existingId = enumToId.get(newInfo);
+    final EnumId existingId = localReverseMap.checkIfExistsInLocal(newInfo);
+      localReverseMap.flushLocalMap();
-      enumToId.put(newInfo, id);
+      localReverseMap.save(id, newInfo, false);
+      localReverseMap.flushLocalMap();
-  private void updateClassToTypeMap(PdxType type) {
-    if (type != null) {
+  private void updateLocalMaps(Object key, Object value) {
+    localReverseMap.save(key, value, true);
+    if (value instanceof PdxType) {
+      PdxType type = (PdxType) value;
+
+  @VisibleForTesting
+  public int getTypeToIdSize() {
+    return localReverseMap.typeToIdSize();
+  }
+
+  @VisibleForTesting
+  public int getEnumToIdSize() {
+    return localReverseMap.enumToIdSize();
+  }
+
+  class LocalReverseMap {
+    /**
+     * When a new pdxType or a new enumInfo is added to idToType region, its
+     * listener will add the new type to the pendingTypeToId first, to make sure
+     * the distribution finished.
+     * Then any member who wants to use this new pdxType has to get the dlock to
+     * flush the pendingTypeToId map into typeToId. This design to guarantee that
+     * when using the new pdxType, it should have been distributed to all members.
+     */
+    private final Map<PdxType, Integer> pendingTypeToId =
+        Collections.synchronizedMap(new HashMap<>());
+    private final Map<EnumInfo, EnumId> pendingEnumToId =
+        Collections.synchronizedMap(new HashMap<>());
+
+    /**
+     * This map serves two purposes. It lets us look up an id based on a type, if we previously
+     * found
+     * that type in the region. And, if a type is present in this map, that means we read the type
+     * while holding the dlock, which means the type was distributed to all members.
+     */
+    private final Map<PdxType, Integer> typeToId = Collections.synchronizedMap(new HashMap<>());
+
+    private final Map<EnumInfo, EnumId> enumToId = Collections.synchronizedMap(new HashMap<>());
+
+    void save(Object key, Object value, boolean isPending) {
+      if (value instanceof PdxType) {
+        PdxType type = (PdxType) value;
+        if (isPending) {
+          pendingTypeToId.put(type, (Integer) key);
+        } else {
+          typeToId.put(type, (Integer) key);
+        }
+      } else if (value instanceof EnumInfo) {
+        EnumInfo info = (EnumInfo) value;
+        if (isPending) {
+          pendingEnumToId.put(info, (EnumId) key);
+        } else {
+          enumToId.put(info, (EnumId) key);
+        }
+      }
+    }
+
+    int typeToIdSize() {
+      return typeToId.size();
+    }
+
+    int enumToIdSize() {
+      return enumToId.size();
+    }
+
+    Integer checkIfExistsInLocal(PdxType newType) {
+      return typeToId.get(newType);
+    }
+
+    EnumId checkIfExistsInLocal(EnumInfo newInfo) {
+      return enumToId.get(newInfo);
+    }
+
+    // The local maps should be loaded from the region if there is a mismatch in size between the
+    // region and all local maps
+    boolean shouldReloadFromRegion() {
+      return ((typeToId.size() + pendingTypeToId.size() + enumToId.size()
+          + pendingEnumToId.size()) != getIdToType().size());
+    }
+
+    void flushLocalMap() {
+      if (!pendingTypeToId.isEmpty()) {
+        typeToId.putAll(pendingTypeToId);
+        pendingTypeToId.clear();
+      }
+      if (!pendingEnumToId.isEmpty()) {
+        enumToId.putAll(pendingEnumToId);
+        pendingEnumToId.clear();
+      }
+    }
+  }

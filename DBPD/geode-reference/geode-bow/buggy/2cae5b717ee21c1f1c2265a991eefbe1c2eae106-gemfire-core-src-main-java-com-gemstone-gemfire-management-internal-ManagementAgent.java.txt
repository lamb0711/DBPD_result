[GEODE-20] Allow REST API to be launched

-import java.io.File;
- * Agent implementation that controls the JMX server end points for JMX 
- * clients to connect, such as an RMI server.
+ * Agent implementation that controls the JMX server end points for JMX clients
+ * to connect, such as an RMI server.
- * MBeans hosted within it. 
+ * MBeans hosted within it.
-public class ManagementAgent  {
+public class ManagementAgent {
-  
+
-   * synchronize while configuring, starting, and eventually stopping the
-   * RMI server, the hidden management regions (in FederatingManager), etc
+   * synchronize while configuring, starting, and eventually stopping the RMI
+   * server, the hidden management regions (in FederatingManager), etc
-   * This system property is set to true when the embedded HTTP server is started so that the embedded pulse webapp
-   * can use a local MBeanServer instead of a remote JMX connection.
+   * This system property is set to true when the embedded HTTP server is
+   * started so that the embedded pulse webapp can use a local MBeanServer
+   * instead of a remote JMX connection.
-  
+
-  
+
-  
-  private boolean isAPIRestServiceRunning(GemFireCacheImpl cache){
+
+  private boolean isAPIRestServiceRunning(GemFireCacheImpl cache) {
-  
-  private boolean isServerNode(GemFireCacheImpl cache){
+
+  private boolean isServerNode(GemFireCacheImpl cache) {
-         && cache.getDistributedSystem().getDistributedMember().getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE
-         && !cache.isClient());
+        && cache.getDistributedSystem().getDistributedMember().getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE && !cache
+          .isClient());
-  
-  public synchronized void startAgent(GemFireCacheImpl cache){
-    //Do not start Management REST service if developer REST service is already started.
-    
-    if(!isAPIRestServiceRunning(cache)) {
+
+  public synchronized void startAgent(GemFireCacheImpl cache) {
+    // Do not start Management REST service if developer REST service is already
+    // started.
+
+    if (!isAPIRestServiceRunning(cache)) {
-    }else {
+    } else {
-        logger.debug("Developer REST APIs webapp is already running, Not Starting M&M REST and pulse!");
+        logger
+            .debug("Developer REST APIs webapp is already running, Not Starting M&M REST and pulse!");
-    
+
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-  
-  public synchronized void stopAgent(){
+
+  public synchronized void stopAgent() {
-    
-    if (!this.running) return;
-    
+
+    if (!this.running)
+      return;
+
-    
+
-  
+
-  
+  private AgentUtil agentUtil = new AgentUtil(GEMFIRE_VERSION);
+
-    final SystemManagementService managementService = (SystemManagementService) ManagementService.getManagementService(
-      CacheFactory.getAnyInstance());
+    final SystemManagementService managementService = (SystemManagementService) ManagementService
+        .getManagementService(CacheFactory.getAnyInstance());
-    
+
-      // GEMFIRE environment variable
-      final String gemfireHome = System.getenv("GEMFIRE");
-
-      // Check for empty variable. if empty, then log message and exit HTTP server startup
-      if (StringUtils.isBlank(gemfireHome)) {
+      // Check for empty variable. if empty, then log message and exit HTTP
+      // server startup
+      if (!agentUtil.isGemfireHomeDefined()) {
-      final String gemfireWar = getGemFireWarLocation(gemfireHome);
-
+      final String gemfireWar = agentUtil.getGemFireWebWarLocation();
-          logger.debug("Unable to find GemFire REST API WAR file; the REST API to GemFire will not be exported and accessible.");
+          logger
+              .debug("Unable to find GemFire REST API WAR file; the REST API to GemFire will not be exported and accessible.");
-      final String pulseWar = getPulseWarLocation(gemfireHome);
+      final String pulseWar = agentUtil.getPulseWarLocation();
-      
-      //Find developer REST WAR file
-      final String gemfireAPIWar =  getGemFireAPIWarLocation(gemfireHome);
+
+      // Find developer REST WAR file
+      final String gemfireAPIWar = agentUtil.getGemFireWebApiWarLocation();
-      
+
-        if (isWebApplicationAvailable(gemfireWar, pulseWar, gemfireAPIWar)) {
-          
+        if (agentUtil.isWebApplicationAvailable(gemfireWar, pulseWar, gemfireAPIWar)) {
+
-          
-          this.httpServer = JettyHelper.initJetty(bindAddress, port, 
+
+          this.httpServer = JettyHelper.initJetty(bindAddress, port,
-              this.config.getHttpServiceSSLRequireAuthentication(), 
-              this.config.getHttpServiceSSLProtocols(),
-              this.config.getHttpServiceSSLCiphers(), 
+              this.config.getHttpServiceSSLRequireAuthentication(),
+              this.config.getHttpServiceSSLProtocols(), this.config.getHttpServiceSSLCiphers(),
-          if (isWebApplicationAvailable(gemfireWar)) {
-            this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire", gemfireWar);
+          if (agentUtil.isWebApplicationAvailable(gemfireWar)) {
+            this.httpServer = JettyHelper
+                .addWebApplication(this.httpServer, "/gemfire", gemfireWar);
-          if (isWebApplicationAvailable(pulseWar)) {
+          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
-         
-          if(isServer && this.config.getStartDevRestApi()) {
-            if (isWebApplicationAvailable(gemfireAPIWar) ) {
-              this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire-api", gemfireAPIWar);
+
+          if (isServer && this.config.getStartDevRestApi()) {
+            if (agentUtil.isWebApplicationAvailable(gemfireAPIWar)) {
+              this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire-api",
+                  gemfireAPIWar);
-          }else {
+          } else {
-          
+
-                ((ServerConnector)this.httpServer.getConnectors()[0]).getPort(), bindAddress);
+                ((ServerConnector) this.httpServer.getConnectors()[0]).getPort(), bindAddress);
-          // now, that Tomcat has been started, we can set the URL used by web clients to connect to Pulse
-          if (isWebApplicationAvailable(pulseWar)) {
-            managerBean.setPulseURL("http://".concat(getHost(bindAddress)).concat(":").concat(String.valueOf(port))
-              .concat("/pulse/"));
+          // now, that Tomcat has been started, we can set the URL used by web
+          // clients to connect to Pulse
+          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
+            managerBean.setPulseURL("http://".concat(getHost(bindAddress)).concat(":")
+                .concat(String.valueOf(port)).concat("/pulse/"));
-          
-          //set cache property for developer REST service running
-          if(isRestWebAppAdded) {
-            GemFireCacheImpl cache = (GemFireCacheImpl)CacheFactory.getAnyInstance();
+
+          // set cache property for developer REST service running
+          if (isRestWebAppAdded) {
+            GemFireCacheImpl cache = (GemFireCacheImpl) CacheFactory.getAnyInstance();
-            
-            //create region to hold query information (queryId, queryString). Added for the developer REST APIs
+
+            // create region to hold query information (queryId, queryString).
+            // Added for the developer REST APIs
-          
-          //set true for HTTP service running
+
+          // set true for HTTP service running
-      }
-      catch (Exception e) {
-        stopHttpService();//Jetty needs to be stopped even if it has failed to start. Some of the threads are left behind even if server.start() fails due to an exception
-        setStatusMessage(managerBean, "HTTP service failed to start with " + e.getClass().getSimpleName() + " '" + e.getMessage() + "'");
+      } catch (Exception e) {
+        stopHttpService();// Jetty needs to be stopped even if it has failed to
+                          // start. Some of the threads are left behind even if
+                          // server.start() fails due to an exception
+        setStatusMessage(managerBean, "HTTP service failed to start with "
+            + e.getClass().getSimpleName() + " '" + e.getMessage() + "'");
-    }
-    else {
-      setStatusMessage(managerBean, "Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)");
+    } else {
+      setStatusMessage(managerBean,
+          "Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)");
-  
+
-    }
-    else if (!StringUtils.isBlank(bindAddress)) {
+    } else if (!StringUtils.isBlank(bindAddress)) {
-    }
-    else {
+    } else {
-  // Use the GEMFIRE environment variable to find the GemFire product tree.
-  // First, look in the $GEMFIRE/tools/Management directory
-  // Second, look in the $GEMFIRE/lib directory
-  // Finally, if we cannot find Management WAR file then return null...
-  private String getGemFireWarLocation(final String gemfireHome) {
-    assert !StringUtils.isBlank(gemfireHome) : "The GEMFIRE environment variable must be set!";
-
-    if (new File(gemfireHome + "/tools/Extensions/gemfire-web-" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/tools/Extensions/gemfire-web-" + GEMFIRE_VERSION + ".war";
-    }
-    else if (new File(gemfireHome + "/lib/gemfire-web-" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/lib/gemfire-web-" + GEMFIRE_VERSION + ".war";
-    }
-    else {
-      return null;
-    }
-  }
-
-  // Use the GEMFIRE environment variable to find the GemFire product tree.
-  // First, look in the $GEMFIRE/tools/Pulse directory
-  // Second, look in the $GEMFIRE/lib directory
-  // Finally, if we cannot find the Management WAR file then return null...
-  private String getPulseWarLocation(final String gemfireHome) {
-    assert !StringUtils.isBlank(gemfireHome) : "The GEMFIRE environment variable must be set!";
-
-    if (new File(gemfireHome + "/tools/Pulse/pulse.war").isFile()) {
-      return gemfireHome + "/tools/Pulse/pulse.war";
-    }
-    else if (new File(gemfireHome + "/lib/pulse.war").isFile()) {
-      return gemfireHome + "/lib/pulse.war";
-    }
-    else {
-      return null;
-    }
-  }
-
-  private String getGemFireAPIWarLocation(final String gemfireHome) {
-    assert !StringUtils.isBlank(gemfireHome) : "The GEMFIRE environment variable must be set!";
-    if (new File(gemfireHome + "/tools/Extensions/gemfire-api" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/tools/Extensions/gemfire-api" + GEMFIRE_VERSION + ".war";
-    }
-    else if (new File(gemfireHome + "/lib/gemfire-api" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/lib/gemfire-api" + GEMFIRE_VERSION + ".war";
-    }
-    else {
-      return null;
-    }
-  }
-
-  private boolean isWebApplicationAvailable(final String warFileLocation) {
-    return !StringUtils.isBlank(warFileLocation);
-  }
-
-  private boolean isWebApplicationAvailable(final String... warFileLocations) {
-    for (String warFileLocation : warFileLocations) {
-      if (isWebApplicationAvailable(warFileLocation)) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-          logger.error("Failed to properly release resources held by the HTTP service: {}", ignore.getMessage(), ignore);
+          logger.error("Failed to properly release resources held by the HTTP service: {}",
+              ignore.getMessage(), ignore);
-   * http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html#gdfvq
-   * https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
-   * https://blogs.oracle.com/jmxetc/entry/building_a_remotely_stoppable_connector
-   * https://blogs.oracle.com/jmxetc/entry/jmx_connecting_through_firewalls_using
+   * http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html
+   * #gdfvq https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
+   * https
+   * ://blogs.oracle.com/jmxetc/entry/building_a_remotely_stoppable_connector
+   * https
+   * ://blogs.oracle.com/jmxetc/entry/jmx_connecting_through_firewalls_using
-    // KIRK: I copied this from https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
-    //       we'll need to change this significantly but it's a starting point
-    
+    // KIRK: I copied this from
+    // https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
+    // we'll need to change this significantly but it's a starting point
+
-    
+
-      logger.debug("Starting jmx manager agent on port {}{}", port, (bindAddr != null ? (" bound to " + bindAddr) : "") + (ssl ? " using SSL" : ""));
+      logger.debug("Starting jmx manager agent on port {}{}", port,
+          (bindAddr != null ? (" bound to " + bindAddr) : "") + (ssl ? " using SSL" : ""));
-        this.config.getJmxManagerSSLProtocols(),
-        this.config.getJmxManagerSSLCiphers(),
+        this.config.getJmxManagerSSLProtocols(), this.config.getJmxManagerSSLCiphers(),
-    RMIClientSocketFactory csf = ssl ? new SslRMIClientSocketFactory() : null;//RMISocketFactory.getDefaultSocketFactory();
-      //new GemFireRMIClientSocketFactory(sc, getLogger());
+    RMIClientSocketFactory csf = ssl ? new SslRMIClientSocketFactory() : null;// RMISocketFactory.getDefaultSocketFactory();
+    // new GemFireRMIClientSocketFactory(sc, getLogger());
-    System.setProperty("sun.rmi.dgc.server.gcInterval", Long.toString(Long.MAX_VALUE-1));
-    
+    System.setProperty("sun.rmi.dgc.server.gcInterval", Long.toString(Long.MAX_VALUE - 1));
+
-    // In order to use a single port, we must use these factories 
+    // In order to use a single port, we must use these factories
-    
+
-    
-    
-    final HashMap<String,Object> env = new HashMap<String,Object>();
-    
+    final HashMap<String, Object> env = new HashMap<String, Object>();
+
-    
-    
-    
-    // Manually creates and binds a JMX RMI Connector Server stub with the 
-    // registry created above: the port we pass here is the port that can  
+
+    // Manually creates and binds a JMX RMI Connector Server stub with the
+    // registry created above: the port we pass here is the port that can
-    // Here we choose to use the same port as was specified for the   
+    // Here we choose to use the same port as was specified for the
-    
+
-    // Here we use the same port as that we choose for the RMI registry. 
+    // Here we use the same port as that we choose for the RMI registry.
-    final JMXServiceURL url = new JMXServiceURL(
-        "service:jmx:rmi://"+hostname+":"+port+"/jndi/rmi://"+hostname+":"+port+"/jmxrmi");
-    
+    final JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://" + hostname + ":" + port
+        + "/jndi/rmi://" + hostname + ":" + port + "/jmxrmi");
+
-    //    
-    // KIRK: JDK 1.5 cannot use JMXConnectorServerFactory because of 
+    //
+    // KIRK: JDK 1.5 cannot use JMXConnectorServerFactory because of
-    cs = new RMIConnectorServer(new JMXServiceURL("rmi",hostname,port),
-          env,stub,mbs) {
+    cs = new RMIConnectorServer(new JMXServiceURL("rmi", hostname, port), env, stub, mbs) {
-      public JMXServiceURL getAddress() { return url;}
+      public JMXServiceURL getAddress() {
+        return url;
+      }
-    // This may be the 1.6 way of doing it but the problem is it does not use our "stub".
-    //cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
-       
+    // This may be the 1.6 way of doing it but the problem is it does not use
+    // our "stub".
+    // cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
+
-    }  
-    
+    }
+
-    //System.out.println("Server started at: "+cs.getAddress());
+    // System.out.println("Server started at: "+cs.getAddress());
-    //final Thread clean = new CleanThread(cs);
-    //clean.start();
+    // final Thread clean = new CleanThread(cs);
+    // clean.start();
-  
-  private static class GemFireRMIClientSocketFactory implements RMIClientSocketFactory, Serializable {
+
+  private static class GemFireRMIClientSocketFactory implements RMIClientSocketFactory,
+      Serializable {
-    
-    private /*final hack to prevent serialization*/ transient SocketCreator sc;
-    
+
+    private/* final hack to prevent serialization */transient SocketCreator sc;
+
-      return this.sc.connectForClient(host, port, 0/*no timeout*/);
+      return this.sc.connectForClient(host, port, 0/* no timeout */);
-  private static class GemFireRMIServerSocketFactory implements RMIServerSocketFactory, Serializable {
+
+  private static class GemFireRMIServerSocketFactory implements RMIServerSocketFactory,
+      Serializable {
-    private /*final hack to prevent serialization*/ transient SocketCreator sc;
+    private/* final hack to prevent serialization */transient SocketCreator sc;
-    
+
-}
+}

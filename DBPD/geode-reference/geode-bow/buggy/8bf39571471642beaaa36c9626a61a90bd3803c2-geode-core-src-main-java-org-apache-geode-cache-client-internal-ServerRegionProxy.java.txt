Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-  
+
-  
+
+   * 
-    this.region = (LocalRegion)r;
+    this.region = (LocalRegion) r;
+
-   * Used by tests to create proxies for "fake" regions.
-   * Also, used by ClientStatsManager for admin region.
+   * Used by tests to create proxies for "fake" regions. Also, used by ClientStatsManager for admin
+   * region.
-  
+
-      throw new IllegalStateException("The region " + r.getFullPath()
-          + " did not have a client pool configured.");
+      throw new IllegalStateException(
+          "The region " + r.getFullPath() + " did not have a client pool configured.");
-      InternalPool pool = (InternalPool)PoolManager.find(poolName);
+      InternalPool pool = (InternalPool) PoolManager.find(poolName);
-        throw new IllegalStateException("The pool " + poolName
-                                        + " does not exist.");
+        throw new IllegalStateException("The pool " + poolName + " does not exist.");
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#get(java.lang.Object, java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#get(java.lang.Object,
+   * java.lang.Object)
-    return GetOp.execute(this.pool, this.region, key, callbackArg, this.pool.getPRSingleHopEnabled(), clientEvent);
+    return GetOp.execute(this.pool, this.region, key, callbackArg,
+        this.pool.getPRSingleHopEnabled(), clientEvent);
-  
-  
+
+
-  
+
-   * <code>Operation.CREATE</code> to the <code>PutOp.execute()</code>
-   * method as the caller of this method does not put Delta instances as value.
+   * <code>Operation.CREATE</code> to the <code>PutOp.execute()</code> method as the caller of this
+   * method does not put Delta instances as value.
-  public Object putForMetaRegion(Object key,
-                  Object value,
-                  byte[] deltaBytes,
-                  EntryEventImpl event,
-                  Object callbackArg,
-                  boolean isMetaRegionPutOp)
-  {
+  public Object putForMetaRegion(Object key, Object value, byte[] deltaBytes, EntryEventImpl event,
+      Object callbackArg, boolean isMetaRegionPutOp) {
-          Operation.CREATE,
-          false, null,
-          callbackArg, this.pool.getPRSingleHopEnabled(),
+          Operation.CREATE, false, null, callbackArg, this.pool.getPRSingleHopEnabled(),
-      return PutOp.execute(this.pool, this.region, key, value, deltaBytes,
-          event, Operation.CREATE, false, null, callbackArg, this.pool
-              .getPRSingleHopEnabled());
+      return PutOp.execute(this.pool, this.region, key, value, deltaBytes, event, Operation.CREATE,
+          false, null, callbackArg, this.pool.getPRSingleHopEnabled());
-  public Object put(Object key,
-                  Object value,
-                  byte[] deltaBytes,
-                  EntryEventImpl event,
-                  Operation op,
-                  boolean requireOldValue, Object expectedOldValue,
-                  Object callbackArg,
-                  boolean isCreate)
-  {
-    recordTXOperation(ServerRegionOperation.PUT, key, value, deltaBytes,
-        event.getEventId(), op, Boolean.valueOf(requireOldValue), expectedOldValue,
-        callbackArg, Boolean.valueOf(isCreate));
+  public Object put(Object key, Object value, byte[] deltaBytes, EntryEventImpl event, Operation op,
+      boolean requireOldValue, Object expectedOldValue, Object callbackArg, boolean isCreate) {
+    recordTXOperation(ServerRegionOperation.PUT, key, value, deltaBytes, event.getEventId(), op,
+        Boolean.valueOf(requireOldValue), expectedOldValue, callbackArg, Boolean.valueOf(isCreate));
-    if (!isCreate && this.region.getDataPolicy() == DataPolicy.EMPTY
-        && op.isCreate() && op != Operation.PUT_IF_ABSENT) {
+    if (!isCreate && this.region.getDataPolicy() == DataPolicy.EMPTY && op.isCreate()
+        && op != Operation.PUT_IF_ABSENT) {
-      return PutOp.execute(this.pool, this.regionName, key, value, deltaBytes,
-          event, operation, requireOldValue, expectedOldValue, callbackArg,
-          this.pool.getPRSingleHopEnabled(), false);
-    }
-    else {
-      return PutOp.execute(this.pool, this.region, key, value, deltaBytes,
-          event, operation, requireOldValue, expectedOldValue, callbackArg,
-          this.pool.getPRSingleHopEnabled());
+      return PutOp.execute(this.pool, this.regionName, key, value, deltaBytes, event, operation,
+          requireOldValue, expectedOldValue, callbackArg, this.pool.getPRSingleHopEnabled(), false);
+    } else {
+      return PutOp.execute(this.pool, this.region, key, value, deltaBytes, event, operation,
+          requireOldValue, expectedOldValue, callbackArg, this.pool.getPRSingleHopEnabled());
-  
-  
+
+
+   * 
-  public void putOnForTestsOnly(Connection con,
-                    Object key,
-                    Object value,
-                    EventID eventId,
-                    Object callbackArg)
-  {
+  public void putOnForTestsOnly(Connection con, Object key, Object value, EventID eventId,
+      Object callbackArg) {
-    PutOp.execute(con, this.pool, this.regionName, key, value, event, callbackArg, this.pool.getPRSingleHopEnabled());
+    PutOp.execute(con, this.pool, this.regionName, key, value, event, callbackArg,
+        this.pool.getPRSingleHopEnabled());
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#destroy(java.lang.Object, java.lang.Object, org.apache.geode.cache.Operation, org.apache.geode.internal.cache.EventID, java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#destroy(java.lang.Object,
+   * java.lang.Object, org.apache.geode.cache.Operation, org.apache.geode.internal.cache.EventID,
+   * java.lang.Object)
-  public Object destroy(Object key,
-                      Object expectedOldValue,
-                      Operation operation,
-                      EntryEventImpl event,
-                      Object callbackArg)
-  {
+  public Object destroy(Object key, Object expectedOldValue, Operation operation,
+      EntryEventImpl event, Object callbackArg) {
-    recordTXOperation(ServerRegionOperation.DESTROY, key, expectedOldValue, operation, event.getEventId(), callbackArg);
-    return DestroyOp.execute(this.pool, this.region, key, expectedOldValue,
-        operation, event, callbackArg, this.pool.getPRSingleHopEnabled());
-    }
-  
-  
+    recordTXOperation(ServerRegionOperation.DESTROY, key, expectedOldValue, operation,
+        event.getEventId(), callbackArg);
+    return DestroyOp.execute(this.pool, this.region, key, expectedOldValue, operation, event,
+        callbackArg, this.pool.getPRSingleHopEnabled());
+  }
+
+
-    InvalidateOp.execute(this.pool, this.region.getFullPath(),
-        event);
+    InvalidateOp.execute(this.pool, this.region.getFullPath(), event);
-  
-  
+
+
+   * 
-  public void destroyOnForTestsOnly(Connection con,
-                        Object key,
-                        Object expectedOldValue,
-                        Operation operation,
-                        EntryEventImpl event,
-                        Object callbackArg)
-  {
-    DestroyOp.execute(con, this.pool, this.regionName, key, 
-        expectedOldValue, operation, event, callbackArg);
+  public void destroyOnForTestsOnly(Connection con, Object key, Object expectedOldValue,
+      Operation operation, EntryEventImpl event, Object callbackArg) {
+    DestroyOp.execute(con, this.pool, this.regionName, key, expectedOldValue, operation, event,
+        callbackArg);
+
+   * 
-  public void destroyRegion(EventID eventId,
-                            Object callbackArg)
-  {
+  public void destroyRegion(EventID eventId, Object callbackArg) {
+
+   * 
-  public void destroyRegionOnForTestsOnly(Connection con,
-                              EventID eventId,
-                              Object callbackArg)
-  {
+  public void destroyRegionOnForTestsOnly(Connection con, EventID eventId, Object callbackArg) {
-  
+
-    TXCommitMessage tx = CommitOp.execute(this.pool,txId);
+    TXCommitMessage tx = CommitOp.execute(this.pool, txId);
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#clear(org.apache.geode.internal.cache.EventID, java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.ServerRegionDataAccess#clear(org.apache.geode.internal.
+   * cache.EventID, java.lang.Object)
-  public void clear(EventID eventId,
-                    Object callbackArg)
-  {
+  public void clear(EventID eventId, Object callbackArg) {
-  
+
+   * 
-  public void clearOnForTestsOnly(Connection con,
-                      EventID eventId,
-                      Object callbackArg)
-  {
+  public void clearOnForTestsOnly(Connection con, EventID eventId, Object callbackArg) {
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#containsKey(java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.ServerRegionDataAccess#containsKey(java.lang.Object)
-    return ContainsKeyOp.execute(this.pool, this.regionName, key,MODE.KEY);
+    return ContainsKeyOp.execute(this.pool, this.regionName, key, MODE.KEY);
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#containsKey(java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.ServerRegionDataAccess#containsKey(java.lang.Object)
-    return ContainsKeyOp.execute(this.pool, this.regionName, key,MODE.VALUE_FOR_KEY);
+    return ContainsKeyOp.execute(this.pool, this.regionName, key, MODE.VALUE_FOR_KEY);
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.ServerRegionDataAccess#containsKey(java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.ServerRegionDataAccess#containsKey(java.lang.Object)
-    return ContainsKeyOp.execute(this.pool, this.regionName, value,MODE.VALUE);
+    return ContainsKeyOp.execute(this.pool, this.regionName, value, MODE.VALUE);
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  
+
+   * 
-  public List registerInterest(final Object key,
-                               final int interestType,
-                               final InterestResultPolicy policy,
-                               final boolean isDurable,
-                               final byte regionDataPolicy)
-  {
+  public List registerInterest(final Object key, final int interestType,
+      final InterestResultPolicy policy, final boolean isDurable, final byte regionDataPolicy) {
-  
+
+   * 
-  public List registerInterest(final Object key,
-                               final int interestType,
-                               final InterestResultPolicy policy,
-                               final boolean isDurable,
-                               final boolean receiveUpdatesAsInvalidates,
-                               final byte regionDataPolicy)
-  {
-    if (interestType == InterestType.KEY
-        && key instanceof List) {
-      return registerInterestList((List)key, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+  public List registerInterest(final Object key, final int interestType,
+      final InterestResultPolicy policy, final boolean isDurable,
+      final boolean receiveUpdatesAsInvalidates, final byte regionDataPolicy) {
+    if (interestType == InterestType.KEY && key instanceof List) {
+      return registerInterestList((List) key, policy, isDurable, receiveUpdatesAsInvalidates,
+          regionDataPolicy);
-      
+
-        rit.addSingleInterest(this.region, key, interestType, policy, isDurable, receiveUpdatesAsInvalidates);
-        result = RegisterInterestOp.execute(this.pool, this.regionName, key,
-            interestType, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+        rit.addSingleInterest(this.region, key, interestType, policy, isDurable,
+            receiveUpdatesAsInvalidates);
+        result = RegisterInterestOp.execute(this.pool, this.regionName, key, interestType, policy,
+            isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-      }
-      finally {
+      } finally {
-          rit.removeSingleInterest(this.region, key, interestType,
-              isDurable, receiveUpdatesAsInvalidates);
+          rit.removeSingleInterest(this.region, key, interestType, isDurable,
+              receiveUpdatesAsInvalidates);
-  /**
-   * Support for server-side interest registration
-   */
-  public void addSingleInterest(Object key, int interestType,
-      InterestResultPolicy pol, boolean isDurable, boolean receiveUpdatesAsInvalidates) {
-    RegisterInterestTracker rit = this.pool.getRITracker();
-    boolean finished = false;
-    try {
-      rit.addSingleInterest(this.region, key, interestType, pol,
-          isDurable, receiveUpdatesAsInvalidates);
-      finished = true;
-    }
-    finally {
-      if (!finished) {
-        rit.removeSingleInterest(this.region, key, interestType,
-            isDurable, receiveUpdatesAsInvalidates);
-      }
-    }
-  }
-  
-  public void addListInterest(List keys, InterestResultPolicy pol,
-      boolean isDurable, boolean receiveUpdatesAsInvalidates) {
-    RegisterInterestTracker rit = this.pool.getRITracker();
-    boolean finished = false;
-    try {
-      rit.addInterestList(this.region, keys, pol, isDurable,
-          receiveUpdatesAsInvalidates);
-      finished = true;
-    }
-    finally {
-      if (!finished) {
-        rit.removeInterestList(this.region, keys, isDurable,
-            receiveUpdatesAsInvalidates);
-      }
-    }
-  }
-  public void removeSingleInterest(Object key, int interestType,
+  public void addSingleInterest(Object key, int interestType, InterestResultPolicy pol,
-    this.pool.getRITracker()
-      .removeSingleInterest(this.region, key, interestType,
-          isDurable, receiveUpdatesAsInvalidates);
+    RegisterInterestTracker rit = this.pool.getRITracker();
+    boolean finished = false;
+    try {
+      rit.addSingleInterest(this.region, key, interestType, pol, isDurable,
+          receiveUpdatesAsInvalidates);
+      finished = true;
+    } finally {
+      if (!finished) {
+        rit.removeSingleInterest(this.region, key, interestType, isDurable,
+            receiveUpdatesAsInvalidates);
+      }
+    }
-  
+
+  public void addListInterest(List keys, InterestResultPolicy pol, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates) {
+    RegisterInterestTracker rit = this.pool.getRITracker();
+    boolean finished = false;
+    try {
+      rit.addInterestList(this.region, keys, pol, isDurable, receiveUpdatesAsInvalidates);
+      finished = true;
+    } finally {
+      if (!finished) {
+        rit.removeInterestList(this.region, keys, isDurable, receiveUpdatesAsInvalidates);
+      }
+    }
+  }
+
+  /**
+   * Support for server-side interest registration
+   */
+  public void removeSingleInterest(Object key, int interestType, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates) {
+    this.pool.getRITracker().removeSingleInterest(this.region, key, interestType, isDurable,
+        receiveUpdatesAsInvalidates);
+  }
+
-  
+
-   * <p>Note that this call by-passes the RegisterInterestTracker.
+   * <p>
+   * Note that this call by-passes the RegisterInterestTracker.
+   * 
-  public List registerInterestOn(ServerLocation sl,
-                                 final Object key,
-                                 final int interestType,
-                                 final InterestResultPolicy policy,
-                                 final boolean isDurable,
-                                 final byte regionDataPolicy)
-  {
+  public List registerInterestOn(ServerLocation sl, final Object key, final int interestType,
+      final InterestResultPolicy policy, final boolean isDurable, final byte regionDataPolicy) {
+
-   * <p>Note that this call by-passes the RegisterInterestTracker.
+   * <p>
+   * Note that this call by-passes the RegisterInterestTracker.
+   * 
-  public List registerInterestOn(ServerLocation sl,
-                                 final Object key,
-                                 final int interestType,
-                                 final InterestResultPolicy policy,
-                                 final boolean isDurable,
-                                 final boolean receiveUpdatesAsInvalidates,
-                                 final byte regionDataPolicy)
-  {
-    if (interestType == InterestType.KEY
-        && key instanceof List) {
-      return RegisterInterestListOp.executeOn(sl, this.pool, this.regionName,
-          (List)key, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+  public List registerInterestOn(ServerLocation sl, final Object key, final int interestType,
+      final InterestResultPolicy policy, final boolean isDurable,
+      final boolean receiveUpdatesAsInvalidates, final byte regionDataPolicy) {
+    if (interestType == InterestType.KEY && key instanceof List) {
+      return RegisterInterestListOp.executeOn(sl, this.pool, this.regionName, (List) key, policy,
+          isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-      return RegisterInterestOp.executeOn(sl, this.pool, this.regionName, key,
-          interestType, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+      return RegisterInterestOp.executeOn(sl, this.pool, this.regionName, key, interestType, policy,
+          isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-  
+
-   * <p>Note that this call by-passes the RegisterInterestTracker.
+   * <p>
+   * Note that this call by-passes the RegisterInterestTracker.
+   * 
-  public List registerInterestOn(Connection conn,
-                                 final Object key,
-                                 final int interestType,
-                                 final InterestResultPolicy policy,
-                                 final boolean isDurable,
-                                 final byte regionDataPolicy)
-  {
-    return registerInterestOn(conn, key, interestType, policy, isDurable, false, regionDataPolicy); 
+  public List registerInterestOn(Connection conn, final Object key, final int interestType,
+      final InterestResultPolicy policy, final boolean isDurable, final byte regionDataPolicy) {
+    return registerInterestOn(conn, key, interestType, policy, isDurable, false, regionDataPolicy);
+
-   * <p>Note that this call by-passes the RegisterInterestTracker.
+   * <p>
+   * Note that this call by-passes the RegisterInterestTracker.
+   * 
-  public List registerInterestOn(Connection conn,
-                                 final Object key,
-                                 final int interestType,
-                                 final InterestResultPolicy policy,
-                                 final boolean isDurable,
-                                 final boolean receiveUpdatesAsInvalidates,
-                                 final byte regionDataPolicy)
-  {
-    if (interestType == InterestType.KEY
-        && key instanceof List) {
-      return RegisterInterestListOp.executeOn(conn, this.pool, this.regionName,
-          (List)key, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+  public List registerInterestOn(Connection conn, final Object key, final int interestType,
+      final InterestResultPolicy policy, final boolean isDurable,
+      final boolean receiveUpdatesAsInvalidates, final byte regionDataPolicy) {
+    if (interestType == InterestType.KEY && key instanceof List) {
+      return RegisterInterestListOp.executeOn(conn, this.pool, this.regionName, (List) key, policy,
+          isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-      return RegisterInterestOp.executeOn(conn, this.pool, this.regionName,
-          key, interestType, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+      return RegisterInterestOp.executeOn(conn, this.pool, this.regionName, key, interestType,
+          policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-    
-  
-  
+
+
+
+   * 
-  public List registerInterestList(List keys,
-                                   InterestResultPolicy policy,
-                                   boolean isDurable,
-                                   boolean receiveUpdatesAsInvalidates,
-                                   final byte regionDataPolicy)
-  {
+  public List registerInterestList(List keys, InterestResultPolicy policy, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates, final byte regionDataPolicy) {
-      result = RegisterInterestListOp.execute(this.pool, this.regionName, keys, policy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+      result = RegisterInterestListOp.execute(this.pool, this.regionName, keys, policy, isDurable,
+          receiveUpdatesAsInvalidates, regionDataPolicy);
-    }
-    finally {
+    } finally {
+
+   * 
-  public void unregisterInterest(Object key,
-                                 int interestType,
-                                 boolean isClosing,
-                                 boolean keepAlive)
-  {
-    if (interestType == InterestType.KEY
-        && key instanceof List) {
-      unregisterInterestList((List)key, isClosing, keepAlive);
+  public void unregisterInterest(Object key, int interestType, boolean isClosing,
+      boolean keepAlive) {
+    if (interestType == InterestType.KEY && key instanceof List) {
+      unregisterInterestList((List) key, isClosing, keepAlive);
-      boolean removed =
-        rit.removeSingleInterest(this.region, key, interestType, false, false) ||
-        rit.removeSingleInterest(this.region, key, interestType, true, false) ||
-        rit.removeSingleInterest(this.region, key, interestType, false, true) ||
-        rit.removeSingleInterest(this.region, key, interestType, true, true);
+      boolean removed = rit.removeSingleInterest(this.region, key, interestType, false, false)
+          || rit.removeSingleInterest(this.region, key, interestType, true, false)
+          || rit.removeSingleInterest(this.region, key, interestType, false, true)
+          || rit.removeSingleInterest(this.region, key, interestType, true, true);
-        UnregisterInterestOp.execute(this.pool, this.regionName, key, interestType, isClosing, keepAlive);
+        UnregisterInterestOp.execute(this.pool, this.regionName, key, interestType, isClosing,
+            keepAlive);
+
+   * 
-  public void unregisterInterestList(List keys,
-                                     boolean isClosing,
-                                     boolean keepAlive)
-  {
+  public void unregisterInterestList(List keys, boolean isClosing, boolean keepAlive) {
-    boolean removed =
-      rit.removeInterestList(this.region, keys, false, true) ||
-      rit.removeInterestList(this.region, keys, false, false) ||
-      rit.removeInterestList(this.region, keys, true, true) ||
-      rit.removeInterestList(this.region, keys, true, false);
+    boolean removed = rit.removeInterestList(this.region, keys, false, true)
+        || rit.removeInterestList(this.region, keys, false, false)
+        || rit.removeInterestList(this.region, keys, true, true)
+        || rit.removeInterestList(this.region, keys, true, false);
+
-    return this.pool.getRITracker().getInterestList(this.regionName,
-                                                    interestType);
+    return this.pool.getRITracker().getInterestList(this.regionName, interestType);
-  public VersionedObjectList putAll(Map map, EventID eventId, boolean skipCallbacks, Object callbackArg) {
+  public VersionedObjectList putAll(Map map, EventID eventId, boolean skipCallbacks,
+      Object callbackArg) {
-      return PutAllOp.execute(this.pool, this.region, map, eventId, skipCallbacks, this.pool.getRetryAttempts(), callbackArg);
-    }
-    else {
-      return PutAllOp.execute(this.pool, this.region, map, eventId, skipCallbacks, false, callbackArg);
+      return PutAllOp.execute(this.pool, this.region, map, eventId, skipCallbacks,
+          this.pool.getRetryAttempts(), callbackArg);
+    } else {
+      return PutAllOp.execute(this.pool, this.region, map, eventId, skipCallbacks, false,
+          callbackArg);
-  
+
-  public VersionedObjectList removeAll(Collection<Object> keys, EventID eventId, Object callbackArg) {
+  public VersionedObjectList removeAll(Collection<Object> keys, EventID eventId,
+      Object callbackArg) {
-      return RemoveAllOp.execute(this.pool, this.region, keys, eventId, this.pool.getRetryAttempts(), callbackArg);
-    }
-    else {
+      return RemoveAllOp.execute(this.pool, this.region, keys, eventId,
+          this.pool.getRetryAttempts(), callbackArg);
+    } else {
-  
-  
+
+
-      result = GetAllOp.execute(this.pool, this.region, keys,this.pool.getRetryAttempts(), callback);
-    }
-    else {
+      result =
+          GetAllOp.execute(this.pool, this.region, keys, this.pool.getRetryAttempts(), callback);
+    } else {
-      for (Iterator it=result.iterator(); it.hasNext(); ) {
+      for (Iterator it = result.iterator(); it.hasNext();) {
-                    LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
-                    new Object[]{value, key}), (Throwable)value);
-          } 
+                LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
+                new Object[] {value, key}), (Throwable) value);
+          }
-    
+
+
-  
+
-    
+
-      ServerRegionFunctionExecutor serverRegionExecutor,
-      ResultCollector resultCollector, byte hasResult, boolean replaying) {
-    
-    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(1),
-          function, serverRegionExecutor, resultCollector,
-          Byte.valueOf(hasResult));
+      ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector resultCollector,
+      byte hasResult, boolean replaying) {
+
+    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(1), function,
+        serverRegionExecutor, resultCollector, Byte.valueOf(hasResult));
-          HashMap<ServerLocation, HashSet<Integer>> serverToBuckets = cms
-              .groupByServerToAllBuckets(this.region,
-                  function.optimizeForWrite());
+          HashMap<ServerLocation, HashSet<Integer>> serverToBuckets =
+              cms.groupByServerToAllBuckets(this.region, function.optimizeForWrite());
-            ExecuteRegionFunctionOp
-                .execute(this.pool, rgnName, function, serverRegionExecutor,
-                    resultCollector, hasResult, retryAttempts);
+            ExecuteRegionFunctionOp.execute(this.pool, rgnName, function, serverRegionExecutor,
+                resultCollector, hasResult, retryAttempts);
-            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region,
-                function, serverRegionExecutor, resultCollector, hasResult,
-                serverToBuckets, retryAttempts, true);
+            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region, function,
+                serverRegionExecutor, resultCollector, hasResult, serverToBuckets, retryAttempts,
+                true);
-          Map<ServerLocation, HashSet> serverToFilterMap = cms
-              .getServerToFilterMap(serverRegionExecutor.getFilter(), region,
+          Map<ServerLocation, HashSet> serverToFilterMap =
+              cms.getServerToFilterMap(serverRegionExecutor.getFilter(), region,
-            ExecuteRegionFunctionOp
-                .execute(this.pool, rgnName, function, serverRegionExecutor,
-                    resultCollector, hasResult, retryAttempts);
+            ExecuteRegionFunctionOp.execute(this.pool, rgnName, function, serverRegionExecutor,
+                resultCollector, hasResult, retryAttempts);
-            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region,
-                function, serverRegionExecutor, resultCollector, hasResult,
-                serverToFilterMap, retryAttempts, isBucketFilter);
+            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region, function,
+                serverRegionExecutor, resultCollector, hasResult, serverToFilterMap, retryAttempts,
+                isBucketFilter);
-        ExecuteRegionFunctionOp.execute(this.pool, rgnName, function,
-            serverRegionExecutor, resultCollector, hasResult, retryAttempts);
+        ExecuteRegionFunctionOp.execute(this.pool, rgnName, function, serverRegionExecutor,
+            resultCollector, hasResult, retryAttempts);
-    }
-    else {
-      ExecuteRegionFunctionOp.execute(this.pool, rgnName, function,
-          serverRegionExecutor, resultCollector, hasResult, retryAttempts);
+    } else {
+      ExecuteRegionFunctionOp.execute(this.pool, rgnName, function, serverRegionExecutor,
+          resultCollector, hasResult, retryAttempts);
-      ServerRegionFunctionExecutor serverRegionExecutor,
-      ResultCollector resultCollector, byte hasResult, boolean isHA, boolean optimizeForWrite,
-      boolean replaying) {
+      ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector resultCollector,
+      byte hasResult, boolean isHA, boolean optimizeForWrite, boolean replaying) {
-    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(2), 
-          functionId, serverRegionExecutor, resultCollector, Byte.valueOf(hasResult),
-          Boolean.valueOf(isHA), Boolean.valueOf(optimizeForWrite));
-    
+    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(2), functionId,
+        serverRegionExecutor, resultCollector, Byte.valueOf(hasResult), Boolean.valueOf(isHA),
+        Boolean.valueOf(optimizeForWrite));
+
-      ClientMetadataService cms = this.region.getCache()
-          .getClientMetadataService();
+      ClientMetadataService cms = this.region.getCache().getClientMetadataService();
-          HashMap<ServerLocation, HashSet<Integer>> serverToBuckets = cms
-              .groupByServerToAllBuckets(this.region, optimizeForWrite);
+          HashMap<ServerLocation, HashSet<Integer>> serverToBuckets =
+              cms.groupByServerToAllBuckets(this.region, optimizeForWrite);
-            ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId,
-                serverRegionExecutor, resultCollector, hasResult,
-                retryAttempts, isHA, optimizeForWrite);
+            ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId, serverRegionExecutor,
+                resultCollector, hasResult, retryAttempts, isHA, optimizeForWrite);
-            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region,
-                functionId, serverRegionExecutor, resultCollector, hasResult,
-                serverToBuckets, retryAttempts, true, isHA, optimizeForWrite);
+            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region, functionId,
+                serverRegionExecutor, resultCollector, hasResult, serverToBuckets, retryAttempts,
+                true, isHA, optimizeForWrite);
-          Map<ServerLocation, HashSet> serverToFilterMap = cms
-              .getServerToFilterMap(serverRegionExecutor.getFilter(), region,
-                  optimizeForWrite, isBucketsAsFilter);
+          Map<ServerLocation, HashSet> serverToFilterMap = cms.getServerToFilterMap(
+              serverRegionExecutor.getFilter(), region, optimizeForWrite, isBucketsAsFilter);
-            ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId,
-                serverRegionExecutor, resultCollector, hasResult,
-                retryAttempts, isHA, optimizeForWrite);
+            ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId, serverRegionExecutor,
+                resultCollector, hasResult, retryAttempts, isHA, optimizeForWrite);
-            ExecuteRegionFunctionSingleHopOp
-                .execute(this.pool, this.region, functionId,
-                    serverRegionExecutor, resultCollector, hasResult,
-                    serverToFilterMap, retryAttempts, false, isHA,
-                    optimizeForWrite);
+            ExecuteRegionFunctionSingleHopOp.execute(this.pool, this.region, functionId,
+                serverRegionExecutor, resultCollector, hasResult, serverToFilterMap, retryAttempts,
+                false, isHA, optimizeForWrite);
-        ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId,
-            serverRegionExecutor, resultCollector, hasResult, retryAttempts,
-            isHA, optimizeForWrite);
+        ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId, serverRegionExecutor,
+            resultCollector, hasResult, retryAttempts, isHA, optimizeForWrite);
-    }
-    else {
-      ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId,
-          serverRegionExecutor, resultCollector, hasResult, retryAttempts, isHA, optimizeForWrite);
+    } else {
+      ExecuteRegionFunctionOp.execute(this.pool, rgnName, functionId, serverRegionExecutor,
+          resultCollector, hasResult, retryAttempts, isHA, optimizeForWrite);
-  
+
-    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(3),
-          function, serverRegionExecutor, Byte.valueOf(hasResult));
-    ExecuteRegionFunctionNoAckOp.execute(this.pool, rgnName, function,
-        serverRegionExecutor, hasResult);
-  }    
-  
+    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(3), function,
+        serverRegionExecutor, Byte.valueOf(hasResult));
+    ExecuteRegionFunctionNoAckOp.execute(this.pool, rgnName, function, serverRegionExecutor,
+        hasResult);
+  }
+
-      ServerRegionFunctionExecutor serverRegionExecutor, byte hasResult,
-      boolean isHA, boolean optimizeForWrite, boolean replaying) {
-    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(4),
-          functionId, serverRegionExecutor, Byte.valueOf(hasResult));
-    ExecuteRegionFunctionNoAckOp.execute(this.pool, rgnName, functionId,
-        serverRegionExecutor, hasResult, isHA,  optimizeForWrite);
-  } 
+      ServerRegionFunctionExecutor serverRegionExecutor, byte hasResult, boolean isHA,
+      boolean optimizeForWrite, boolean replaying) {
+    recordTXOperation(ServerRegionOperation.EXECUTE_FUNCTION, null, Integer.valueOf(4), functionId,
+        serverRegionExecutor, Byte.valueOf(hasResult));
+    ExecuteRegionFunctionNoAckOp.execute(this.pool, rgnName, functionId, serverRegionExecutor,
+        hasResult, isHA, optimizeForWrite);
+  }
-  
+
+   * 
-    TXSynchronizationOp.execute(pool, 0, txId, TXSynchronizationOp.CompletionType.BEFORE_COMPLETION);
+    TXSynchronizationOp.execute(pool, 0, txId,
+        TXSynchronizationOp.CompletionType.BEFORE_COMPLETION);
-  
+
+   * 
-    return TXSynchronizationOp.execute(pool, status, txId, TXSynchronizationOp.CompletionType.AFTER_COMPLETION);
+    return TXSynchronizationOp.execute(pool, status, txId,
+        TXSynchronizationOp.CompletionType.AFTER_COMPLETION);
-  public byte[] getFunctionAttributes(String functionId){
-    return (byte[])GetFunctionAttributeOp.execute(this.pool, functionId);
+  public byte[] getFunctionAttributes(String functionId) {
+    return (byte[]) GetFunctionAttributeOp.execute(this.pool, functionId);
-  
+
-  
+

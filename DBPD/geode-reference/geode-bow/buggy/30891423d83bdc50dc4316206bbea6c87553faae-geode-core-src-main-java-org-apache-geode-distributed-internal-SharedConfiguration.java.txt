GEODE-2197: refactor cluster config and fix the test failures

+import java.io.FileFilter;
-import java.io.FilenameFilter;
-import java.util.Collection;
+import java.util.Arrays;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
-  private final String configDiskDirName;
-  private final Set<PersistentMemberPattern> newerSharedConfigurationLocatorInfo =
-      new HashSet<PersistentMemberPattern>();
-  private final AtomicReference<SharedConfigurationStatus> status =
-      new AtomicReference<SharedConfigurationStatus>();
-  private static final JarFileFilter jarFileFilter = new JarFileFilter();
+  private final Set<PersistentMemberPattern> newerSharedConfigurationLocatorInfo = new HashSet<>();
+  private final AtomicReference<SharedConfigurationStatus> status = new AtomicReference<>();
-    this.configDiskDirName =
-        CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
-    String clusterConfigDir =
+    // resolve the cluster config dir
+    String clusterConfigRootDir =
-    if (StringUtils.isBlank(clusterConfigDir)) {
-      clusterConfigDir = System.getProperty("user.dir");
+    if (StringUtils.isBlank(clusterConfigRootDir)) {
+      clusterConfigRootDir = System.getProperty("user.dir");
-      File diskDir = new File(clusterConfigDir);
+      File diskDir = new File(clusterConfigRootDir);
-        throw new IOException("Cannot create directory : " + clusterConfigDir);
+        throw new IOException("Cannot create directory : " + clusterConfigRootDir);
-      clusterConfigDir = diskDir.getCanonicalPath();
+      clusterConfigRootDir = diskDir.getCanonicalPath();
-    this.configDiskDirPath = FilenameUtils.concat(clusterConfigDir, this.configDiskDirName);
-    configDirPath = FilenameUtils.concat(clusterConfigDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+
+    // resolve the file paths
+    String configDiskDirName =
+        CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
+
+    configDirPath = FilenameUtils.concat(clusterConfigRootDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+    configDiskDirPath = FilenameUtils.concat(clusterConfigRootDir, configDiskDirName);
-  /**
-   * Add jar information into the shared configuration and save the jars in the file system
-   * @return true on success
-   */
-  public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String[] groups) {
-    boolean success = true;
-    try {
-      if (groups == null) {
-        groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-      }
-      Region<String, Configuration> configRegion = getConfigurationRegion();
-      for (String group : groups) {
-        Configuration configuration = configRegion.get(group);
-
-        if (configuration == null) {
-          configuration = new Configuration(group);
-          createConfigDirIfNecessary(group);
-        }
-        String groupDir = FilenameUtils.concat(configDirPath, group);
-        writeJarFiles(groupDir, jarNames, jarBytes);
-
-        // update the record after writing the jars to the file system, since the listener
-        // will need the jars on file to upload to other locators.
-        configuration.addJarNames(jarNames);
-        configRegion.put(group, configuration);
-      }
-    } catch (Exception e) {
-      success = false;
-      logger.info(e.getMessage(), e);
-    }
-    return success;
-  }
-   * Adds/replaces the xml entity in the shared configuration
+   * Adds/replaces the xml entity in the shared configuration we don't need to trigger the change
+   * listener for this modification, so it's ok to operate on the original configuration object
-      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
+      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
-//      writeConfig(configuration);
-    }
-  }
-
-  public void clearSharedConfiguration() throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    if (configRegion != null) {
-      configRegion.clear();
+   * Deletes the xml entity from the shared configuration.
+   */
+  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) throws Exception {
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    // No group is specified, so delete in every single group if it exists.
+    if (groups == null) {
+      Set<String> groupSet = configRegion.keySet();
+      groups = groupSet.toArray(new String[groupSet.size()]);
+    }
+    for (String group : groups) {
+      Configuration configuration = (Configuration) configRegion.get(group);
+      if (configuration != null) {
+        String xmlContent = configuration.getCacheXmlContent();
+        if (xmlContent != null && !xmlContent.isEmpty()) {
+          Document doc = createAndUpgradeDocumentFromXml(xmlContent);
+          XmlUtils.deleteNode(doc, xmlEntity);
+          configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+          configRegion.put(group, configuration);
+        }
+      }
+    }
+  }
+
+  // we don't need to trigger the change listener for this modification, so it's ok to
+  // operate on the original configuration object
+  public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, String[] groups)
+      throws Exception {
+    if (groups == null) {
+      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+    }
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    for (String group : groups) {
+      Configuration configuration = configRegion.get(group);
+      if (configuration == null) {
+        configuration = new Configuration(group);
+      }
+
+      if (xmlEntity != null) {
+        String xmlContent = configuration.getCacheXmlContent();
+        if (xmlContent == null || xmlContent.isEmpty()) {
+          StringWriter sw = new StringWriter();
+          PrintWriter pw = new PrintWriter(sw);
+          CacheXmlGenerator.generateDefault(pw);
+          xmlContent = sw.toString();
+        }
+
+        Document doc = createAndUpgradeDocumentFromXml(xmlContent);
+
+        // Modify the cache attributes
+        XmlUtils.modifyRootAttributes(doc, xmlEntity);
+
+        // Change the xml content of the configuration and put it the config region
+        configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+      }
+
+      if (properties != null) {
+        configuration.getGemfireProperties().putAll(properties);
+      }
+      configRegion.put(group, configuration);
+    }
+  }
+
+
+  /**
+   * Add jar information into the shared configuration and save the jars in the file system used
+   * when deploying jars
+   * 
+   * @return true on success
+   */
+  public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String[] groups) {
+    boolean success = true;
+    try {
+      if (groups == null) {
+        groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+      }
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      for (String group : groups) {
+        Configuration configuration = configRegion.get(group);
+
+        if (configuration == null) {
+          configuration = new Configuration(group);
+          createConfigDirIfNecessary(group);
+        }
+
+        String groupDir = FilenameUtils.concat(configDirPath, group);
+        for (int i = 0; i < jarNames.length; i++) {
+          String filePath = FilenameUtils.concat(groupDir, jarNames[i]);
+          File jarFile = new File(filePath);
+          try {
+            FileUtils.writeByteArrayToFile(jarFile, jarBytes[i]);
+          } catch (IOException e) {
+            logger.info(e);
+          }
+        }
+
+        // update the record after writing the jars to the file system, since the listener
+        // will need the jars on file to upload to other locators.
+        Configuration configurationCopy = new Configuration(configuration);
+        configurationCopy.addJarNames(jarNames);
+        configRegion.put(group, configurationCopy);
+      }
+    } catch (Exception e) {
+      success = false;
+      logger.info(e.getMessage(), e);
+    }
+    return success;
+  }
+
+  /**
+   * read the jar bytes in the file system
+   * 
+   * @return
+   * @throws Exception
+   */
+  // used when creating cluster config response
+  // and used when uploading the jars to another locator
+  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws Exception {
+    Configuration configuration = getConfiguration(group);
+
+    // TODO: Should we check like this, or just check jar.exists below()?
+    if (configuration == null || !configuration.getJarNames().contains(jarName)) {
+      return null;
+    }
+
+    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
+    return FileUtils.readFileToByteArray(jar);
+  }
+
+  /**
+   * Removes the jar files from the shared configuration. used when undeploy jars
+   *
+   * @param jarNames Names of the jar files.
+   * @param groups Names of the groups which had the jar file deployed.
+   * @return true on success.
+   */
+  public boolean removeJars(final String[] jarNames, String[] groups) {
+    boolean success = true;
+    try {
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      if (groups == null) {
+        groups = configRegion.keySet().stream().toArray(String[]::new);
+      }
+      for (String group : groups) {
+        Configuration configuration = configRegion.get(group);
+        if (configuration == null) {
+          break;
+        }
+        Configuration configurationCopy = new Configuration(configuration);
+        configurationCopy.removeJarNames(jarNames);
+        configRegion.put(group, configurationCopy);
+      }
+    } catch (Exception e) {
+      logger.info("Exception occurred while deleting the jar files", e);
+      success = false;
+    }
+    return success;
+  }
+
+  // used in the cluster config change listener when jarnames are changed in the internal region
+  public void downloadJarFromOtherLocators(String groupName, String jarName) throws Exception {
+    logger.info("Getting Jar files from other locators");
+    DM dm = cache.getDistributionManager();
+    DistributedMember me = cache.getMyId();
+    Set<DistributedMember> locators =
+        new HashSet<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
+    locators.remove(me);
+
+    createConfigDirIfNecessary(groupName);
+
+    byte[] jarBytes = locators.stream()
+        .map((DistributedMember locator) -> downloadJarFromLocator(locator, groupName, jarName))
+        .filter(Objects::nonNull).findFirst().orElseThrow(() -> new IllegalStateException(
+            "No locators have a deployed jar named " + jarName + " in " + groupName));
+
+    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
+    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
+  }
+
+
+  // used when creating cluster config response
+  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws Exception {
+    Map<String, byte[]> jarNamesToJarBytes = new HashMap<>();
+
+    for (String group : groups) {
+      Configuration groupConfig = getConfiguration(group);
+      if (groupConfig == null) {
+        break;
+      }
+
+      Set<String> jars = groupConfig.getJarNames();
+      for (String jar : jars) {
+        byte[] jarBytes = getJarBytesFromThisLocator(group, jar);
+        jarNamesToJarBytes.put(jar, jarBytes);
+      }
+    }
+
+    return jarNamesToJarBytes;
+  }
+
+  public void clearSharedConfiguration() throws Exception {
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    configRegion.clear();
+  }
+
+  /**
+   * 
-   * directory
+   *        directory
+    lockSharedConfiguration();
-    if (loadSharedConfigFromDir) {
-      lockSharedConfiguration();
-      try {
+    try {
+      if (loadSharedConfigFromDir) {
-
-        Map<String, Configuration> sharedConfigMap = this.readSharedConfigurationFromDisk();
-        // Clear the configuration region and load the configuration read from the 'shared_config'
-        // directory
-        // on region entry create/update, it will upload the jars to all other locators
-        configRegion.clear();
-        configRegion.putAll(sharedConfigMap);
-      } finally {
-        unlockSharedConfiguration();
-      }
-    } else {
-      // Write out the existing configuration into the 'shared_config' directory
-      // And get deployed jars from other locators.
-      lockSharedConfiguration();
-      try {
-        // on region entry create/update, it should download missing jars from other locators
+        this.loadSharedConfigurationFromDisk();
+      } else {
-      } finally {
-        unlockSharedConfiguration();
+        Set<String> groups = configRegion.keySet();
+        for (String group : groups) {
+          Configuration config = configRegion.get(group);
+          // for those groups that have jar files, need to download the jars from other locators
+          // if it doesn't exist yet
+          for (String jar : config.getJarNames()) {
+            if (!(getPathToJarOnThisLocator(group, jar).toFile()).exists()) {
+              downloadJarFromOtherLocators(group, jar);
+            }
+          }
+        }
+    } finally {
+      unlockSharedConfiguration();
-   * @return {@link SharedConfigurationStatusResponse} containing the {@link
-   * SharedConfigurationStatus}
+   * 
+   * @return {@link SharedConfigurationStatusResponse} containing the
+   *         {@link SharedConfigurationStatus}
-   * Deletes the xml entity from the shared configuration.
-   */
-  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    // No group is specified, so delete in every single group if it exists.
-    if (groups == null) {
-      Set<String> groupSet = configRegion.keySet();
-      groups = groupSet.toArray(new String[groupSet.size()]);
-    }
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-      if (configuration != null) {
-        String xmlContent = configuration.getCacheXmlContent();
-        if (xmlContent != null && !xmlContent.isEmpty()) {
-          Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-          XmlUtils.deleteNode(doc, xmlEntity);
-          configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-          configRegion.put(group, configuration);
-          //writeConfig(configuration);
-        }
-      }
-    }
-  }
-
-  public void modifyCacheAttributes(final XmlEntity xmlEntity, String[] groups) throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    // No group is specified, so modify the cache attributes for a in every single group if it
-    // exists.
-    if (groups == null) {
-      Set<String> groupSet = configRegion.keySet();
-      groups = groupSet.toArray(new String[groupSet.size()]);
-    }
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-
-      if (configuration == null) {
-        configuration = new Configuration(group);
-      }
-      String xmlContent = configuration.getCacheXmlContent();
-      if (xmlContent == null || xmlContent.isEmpty()) {
-        StringWriter sw = new StringWriter();
-        PrintWriter pw = new PrintWriter(sw);
-        CacheXmlGenerator.generateDefault(pw);
-        xmlContent = sw.toString();
-      }
-
-      Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-
-      // Modify the cache attributes
-      XmlUtils.modifyRootAttributes(doc, xmlEntity);
-
-      // Change the xml content of the configuration and put it the config region
-      configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-      configRegion.put(group, configuration);
-      //writeConfig(configuration);
-    }
-  }
-
-  /**
-  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws Exception {
-    Configuration configuration = getConfiguration(group);
-
-    //TODO: Should we check  like this, or just check jar.exists below()?
-    if (configuration == null || !configuration.getJarNames().contains(jarName)) {
-      return null;
-    }
-
-    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
-    return FileUtils.readFileToByteArray(jar);
-  }
-
-  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws Exception {
-    Map<String, byte[]> jarNamesToJarBytes = new HashMap<>();
-
-    for (String group : groups) {
-      Configuration groupConfig = getConfiguration(group);
-      if (groupConfig == null) {
-        break;
-      }
-
-      Set<String> jars = groupConfig.getJarNames();
-      for (String jar : jars) {
-        byte[] jarBytes = getJarBytesFromThisLocator(group, jar);
-        jarNamesToJarBytes.put(jar, jarBytes);
-      }
-    }
-
-    return jarNamesToJarBytes;
-  }
-
+   * 
+   * 
-   * Loads the
+   * Loads the internal region with the configuration in the configDirPath
-    Map<String, Configuration> sharedConfigurationMap = readSharedConfigurationFromDisk();
+    File[] groupNames =
+        new File(configDirPath).listFiles((FileFilter) DirectoryFileFilter.INSTANCE);
+    Map<String, Configuration> sharedConfiguration = new HashMap<String, Configuration>();
+
+    for (File groupName : groupNames) {
+      Configuration configuration = readConfiguration(groupName);
+      sharedConfiguration.put(groupName.getName(), configuration);
+    }
+
-    getConfigurationRegion().putAll(sharedConfigurationMap);
+    getConfigurationRegion().putAll(sharedConfiguration);
-  public void modifyProperties(final Properties properties, String[] groups) throws Exception {
-    if (groups == null) {
-      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-    }
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    for (String group : groups) {
-      Configuration configuration = configRegion.get(group);
-      if (configuration == null) {
-        configuration = new Configuration(group);
-      }
-      configuration.getGemfireProperties().putAll(properties);
-      configRegion.put(group, configuration);
-      //writeConfig(configuration);
-    }
-  }
-  /**
-   * Removes the jar files from the shared configuration.
-   * @param jarNames Names of the jar files.
-   * @param groups Names of the groups which had the jar file deployed.
-   * @return true on success.
-   */
-  public boolean removeJars(final String[] jarNames, String[] groups) {
-    boolean success = true;
-    try {
-      Region<String, Configuration> configRegion = getConfigurationRegion();
-      if (groups == null) {
-        groups = configRegion.keySet().stream().toArray(String[]::new);
-      }
-      for (String group : groups) {
-        Configuration configuration = configRegion.get(group);
-        if (configuration == null) {
-          break;
-        }
-        configuration.removeJarNames(jarNames);
-        configRegion.put(group, configuration);
-      }
-    } catch (Exception e) {
-      logger.info("Exception occurred while deleting the jar files", e);
-      success = false;
-    }
-    return success;
-  }
-  /**
-   * Creates a directory for this configuration if it doesn't already exist.
-   */
-  private File createConfigDirIfNecessary(final String configName) throws Exception {
-    File clusterConfigDir = new File(getSharedConfigurationDirPath());
-    if (!clusterConfigDir.exists()) {
-      if (!clusterConfigDir.mkdirs()) {
-        throw new IOException("Cannot create directory : " + getSharedConfigurationDirPath());
-      }
-    }
-    Path configDirPath = clusterConfigDir.toPath().resolve(configName);
-    File configDir = configDirPath.toFile();
-    if (!configDir.exists()) {
-      if (!configDir.mkdir()) {
-        throw new IOException("Cannot create directory : " + configDirPath);
-      }
-    }
-
-    return configDir;
-  }
-
+  // Write the content of xml and properties into the file system for exporting purpose
-  public void addJarFromOtherLocators(String groupName, String jarName) throws Exception {
-    logger.info("Getting Jar files from other locators");
-    DM dm = cache.getDistributionManager();
-    DistributedMember me = cache.getMyId();
-    Set<DistributedMember> locators =
-        new HashSet<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-    locators.remove(me);
-
-    createConfigDirIfNecessary(groupName);
-
-    byte[] jarBytes = locators.stream()
-        .map((DistributedMember locator) -> downloadJarFromLocator(locator, groupName, jarName))
-        .filter(Objects::nonNull)
-        .findFirst()
-        .orElseThrow(() -> new IllegalStateException(
-            "No locators have a deployed jar named " + jarName + " in " + groupName));
-
-    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
-    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
-  }
-                                        String jarName) {
+      String jarName) {
-        .executeFunction(new UploadJarFunction(), new Object[]{groupName, jarName}, locator);
+        .executeFunction(new UploadJarFunction(), new Object[] {groupName, jarName}, locator);
-    return result.stream()
-        .filter(Objects::nonNull)
-        .findFirst()
-        .orElse(null);
+    return result.stream().filter(Objects::nonNull).findFirst().orElse(null);
-   * @return {@link Region} ConfigurationRegion
+   * 
+   * @return {@link Region} ConfigurationRegion, this should never be null
+   * 
-  private Configuration readConfiguration(final String configName, final String configDirectory)
+  private Configuration readConfiguration(File groupConfigDir)
-      TransformerException {
-    Configuration configuration = new Configuration(configName);
-    String cacheXmlFullPath =
-        FilenameUtils.concat(configDirectory, configuration.getCacheXmlFileName());
-    String propertiesFullPath =
-        FilenameUtils.concat(configDirectory, configuration.getPropertiesFileName());
+      TransformerException, IOException {
+    Configuration configuration = new Configuration(groupConfigDir.getName());
+    File cacheXmlFull = new File(groupConfigDir, configuration.getCacheXmlFileName());
+    File propertiesFull = new File(groupConfigDir, configuration.getPropertiesFileName());
-    File file = new File(configDirectory);
-    String[] jarFileNames = file.list(jarFileFilter);
+    configuration.setCacheXmlFile(cacheXmlFull);
+    configuration.setPropertiesFile(propertiesFull);
-    if (jarFileNames != null && jarFileNames.length != 0) {
-      configuration.addJarNames(jarFileNames);
-    }
-
-    try {
-      configuration.setCacheXmlContent(XmlUtils.readXmlAsStringFromFile(cacheXmlFullPath));
-      configuration.setGemfireProperties(readProperties(propertiesFullPath));
-    } catch (IOException e) {
-      logger.info(e);
-    }
+    Set<String> jarFileNames = Arrays.stream(groupConfigDir.list())
+        .filter((String filename) -> filename.endsWith(".jar")).collect(Collectors.toSet());
+    configuration.addJarNames(jarFileNames);
-   * Reads the properties from the properties file.
-   * @return {@link Properties}
+   * Creates a directory for this configuration if it doesn't already exist.
-  private Properties readProperties(final String propertiesFilePath) throws IOException {
-    Properties properties = new Properties();
-    File propsFile = new File(propertiesFilePath);
-    FileInputStream fis = null;
-    if (propsFile.exists()) {
-      try {
-        fis = new FileInputStream(propsFile);
-        properties.load(fis);
-      } finally {
-        if (fis != null) {
-          fis.close();
-        }
+  private File createConfigDirIfNecessary(final String configName) throws Exception {
+    File clusterConfigDir = new File(getSharedConfigurationDirPath());
+    if (!clusterConfigDir.exists()) {
+      if (!clusterConfigDir.mkdirs()) {
+        throw new IOException("Cannot create directory : " + getSharedConfigurationDirPath());
-    return properties;
-  }
+    Path configDirPath = clusterConfigDir.toPath().resolve(configName);
-  /**
-   * Reads the "shared_config" directory and loads all the cache.xml, gemfire.properties and
-   * deployed jars information
-   * @return {@link Map}
-   */
-  private Map<String, Configuration> readSharedConfigurationFromDisk() throws SAXException,
-      ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
-    String[] subdirectoryNames = getSubdirectories(configDirPath);
-    Map<String, Configuration> sharedConfiguration = new HashMap<String, Configuration>();
-
-    if (subdirectoryNames != null) {
-      for (String subdirectoryName : subdirectoryNames) {
-        String fullpath = FilenameUtils.concat(configDirPath, subdirectoryName);
-        Configuration configuration = readConfiguration(subdirectoryName, fullpath);
-        sharedConfiguration.put(subdirectoryName, configuration);
+    File configDir = configDirPath.toFile();
+    if (!configDir.exists()) {
+      if (!configDir.mkdir()) {
+        throw new IOException("Cannot create directory : " + configDirPath);
-    return sharedConfiguration;
-  }
-  /**
-   * Writes the
-   * @param dirPath target directory , where the jar files are to be written
-   * @param jarNames Array containing the name of the jar files.
-   * @param jarBytes Array of byte arrays for the jar files.
-   */
-  private void writeJarFiles(final String dirPath, final String[] jarNames,
-                             final byte[][] jarBytes) {
-    for (int i = 0; i < jarNames.length; i++) {
-      String filePath = FilenameUtils.concat(dirPath, jarNames[i]);
-      File jarFile = new File(filePath);
-      try {
-        FileUtils.writeByteArrayToFile(jarFile, jarBytes[i]);
-      } catch (IOException e) {
-        logger.info(e);
-      }
-    }
+    return configDir;
+   * 
-  // UnitTest SharedConfigurationJUnitTest.testCreateAndUpgradeDocumentFromXml
-
-  /**
-   * Returns an array containing the names of the subdirectories in a given directory
-   * @param path Path of the directory whose subdirectories are listed
-   * @return String[] names of first level subdirectories, null if no subdirectories are found or if
-   * the path is incorrect
-   */
-  private static String[] getSubdirectories(String path) {
-    File directory = new File(path);
-    return directory.list(DirectoryFileFilter.INSTANCE);
-  }
-
-  private static class JarFileFilter implements FilenameFilter {
-    @Override
-    public boolean accept(File dir, String name) {
-      return name.endsWith(".jar");
-    }
-  }

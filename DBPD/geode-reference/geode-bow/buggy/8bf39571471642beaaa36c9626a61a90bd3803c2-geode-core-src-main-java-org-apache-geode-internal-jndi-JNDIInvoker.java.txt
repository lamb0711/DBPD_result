Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Utility class for binding DataSources and Transactional resources to JNDI
- * Tree. If there is a pre-existing JNDI tree in the system, the GemFire
- * JNDI tree is not not generated.
- * </p><p>
- * Datasources are bound to jndi tree after getting initialised. The
- * initialisation parameters are read from cache.xml.
- * </p><p>
- * If there is a pre-existing TransactionManager/UserTransaction (possible
- * in presence of application server scenerio), the GemFire TransactionManager
- * and UserTransaction will not be initialised. In that case, application server
- * TransactionManager/UserTransaction will handle the transactional activity. But
- * even in this case the datasource element will be bound to the available JNDI
- * tree. The transactional datasource (XADataSource) will make use of available
+ * Utility class for binding DataSources and Transactional resources to JNDI Tree. If there is a
+ * pre-existing JNDI tree in the system, the GemFire JNDI tree is not not generated.
+ * </p>
+ * <p>
+ * Datasources are bound to jndi tree after getting initialised. The initialisation parameters are
+ * read from cache.xml.
+ * </p>
+ * <p>
+ * If there is a pre-existing TransactionManager/UserTransaction (possible in presence of
+ * application server scenerio), the GemFire TransactionManager and UserTransaction will not be
+ * initialised. In that case, application server TransactionManager/UserTransaction will handle the
+ * transactional activity. But even in this case the datasource element will be bound to the
+ * available JNDI tree. The transactional datasource (XADataSource) will make use of available
-public class JNDIInvoker  {
+public class JNDIInvoker {
-//  private static boolean DEBUG = false;
+  // private static boolean DEBUG = false;
-   * JNDI Context, this may refer to GemFire JNDI Context or external Context,
-   * in case the external JNDI tree exists.
+   * JNDI Context, this may refer to GemFire JNDI Context or external Context, in case the external
+   * JNDI tree exists.
-   * transactionManager TransactionManager, this refers to GemFire
-   * TransactionManager only.
+   * transactionManager TransactionManager, this refers to GemFire TransactionManager only.
-  private static String[][] knownJNDIManagers = {
-      {"java:/TransactionManager", "JBoss"},
-      {"java:comp/TransactionManager","Cosminexus"}, // and many others
-      {"java:appserver/TransactionManager","GlassFish"},
-      {"java:pm/TransactionManager","SunONE"},
-      {"java:comp/UserTransaction","Orion, JTOM, BEA WebLogic"},
+  private static String[][] knownJNDIManagers = {{"java:/TransactionManager", "JBoss"},
+      {"java:comp/TransactionManager", "Cosminexus"}, // and many others
+      {"java:appserver/TransactionManager", "GlassFish"}, {"java:pm/TransactionManager", "SunONE"},
+      {"java:comp/UserTransaction", "Orion, JTOM, BEA WebLogic"},
-      {"javax.transaction.TransactionManager", "BEA WebLogic"}
-   };
+      {"javax.transaction.TransactionManager", "BEA WebLogic"}};
-  private static final String WS_FACTORY_CLASS_5_1 = "com.ibm.ws.Transaction.TransactionManagerFactory";
+  private static final String WS_FACTORY_CLASS_5_1 =
+      "com.ibm.ws.Transaction.TransactionManagerFactory";
-  private static final String WS_FACTORY_CLASS_5_0 = "com.ibm.ejs.jts.jta.TransactionManagerFactory";
+  private static final String WS_FACTORY_CLASS_5_0 =
+      "com.ibm.ejs.jts.jta.TransactionManagerFactory";
-   * List of DataSource bound to the context, used for cleaning gracefully
-   * closing datasource and associated threads.
+   * List of DataSource bound to the context, used for cleaning gracefully closing datasource and
+   * associated threads.
-   * If this system property is set to true, GemFire will not try to lookup for an
-   * existing JTA transaction manager bound to JNDI context or try to bind itself
-   * as a JTA transaction manager. Also region operations will <b>not</b> participate in
-   * an ongoing JTA transaction. 
+   * If this system property is set to true, GemFire will not try to lookup for an existing JTA
+   * transaction manager bound to JNDI context or try to bind itself as a JTA transaction manager.
+   * Also region operations will <b>not</b> participate in an ongoing JTA transaction.
-  private static Boolean IGNORE_JTA = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreJTA");
+  private static Boolean IGNORE_JTA =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreJTA");
-   * Bind the transaction resources. Bind UserTransaction and
-   * TransactionManager. 
+   * Bind the transaction resources. Bind UserTransaction and TransactionManager.
-   * If there is pre-existing JNDI tree in the system
-   * and TransactionManager / UserTransaction is already bound, GemFire will
-   * make use of these resources, but if TransactionManager / UserTransaction is
-   * not available, the GemFire TransactionManager / UserTransaction will be
+   * If there is pre-existing JNDI tree in the system and TransactionManager / UserTransaction is
+   * already bound, GemFire will make use of these resources, but if TransactionManager /
+   * UserTransaction is not available, the GemFire TransactionManager / UserTransaction will be
-   *  
+   * 
-    }
-    catch (NamingException ne) {
+    } catch (NamingException ne) {
-        String exception = "JNDIInvoker::mapTransactions:: No application server context found, Starting GemFire JNDI Context Context ";
-        if (writer.finerEnabled()) writer.finer(exception);
+        String exception =
+            "JNDIInvoker::mapTransactions:: No application server context found, Starting GemFire JNDI Context Context ";
+        if (writer.finerEnabled())
+          writer.finer(exception);
-              writer
-                  .fine("JNDIInvoker::mapTransactions::Bound TransactionManager to Context GemFire JNDI Tree");
+            writer.fine(
+                "JNDIInvoker::mapTransactions::Bound TransactionManager to Context GemFire JNDI Tree");
-              writer
-                  .fine("JNDIInvoker::mapTransactions::Bound Transaction to Context GemFire JNDI Tree");
-        }
-        catch (NamingException ne1) {
+            writer.fine(
+                "JNDIInvoker::mapTransactions::Bound Transaction to Context GemFire JNDI Tree");
+        } catch (NamingException ne1) {
-              writer
-                  .info(LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSNAMINGEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_GEMFIRE_JNDI_TREE);
-        }
-        catch (SystemException se1) {
+            writer.info(
+                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSNAMINGEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_GEMFIRE_JNDI_TREE);
+        } catch (SystemException se1) {
-              writer
-                  .info(LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSSYSTEMEXCEPTION_WHILE_BINDING_USERTRANSACTION_TO_GEMFIRE_JNDI_TREE);
+            writer.info(
+                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSSYSTEMEXCEPTION_WHILE_BINDING_USERTRANSACTION_TO_GEMFIRE_JNDI_TREE);
-      }
-      else if (ne instanceof NameNotFoundException) {
-        String exception = "JNDIInvoker::mapTransactions:: No TransactionManager associated to Application server context, trying to bind GemFire TransactionManager";
-        if (writer.finerEnabled()) writer.finer(exception);
+      } else if (ne instanceof NameNotFoundException) {
+        String exception =
+            "JNDIInvoker::mapTransactions:: No TransactionManager associated to Application server context, trying to bind GemFire TransactionManager";
+        if (writer.finerEnabled())
+          writer.finer(exception);
-              writer
-                  .fine("JNDIInvoker::mapTransactions::Bound TransactionManager to Application Server Context");
+            writer.fine(
+                "JNDIInvoker::mapTransactions::Bound TransactionManager to Application Server Context");
-              writer
-                  .fine("JNDIInvoker::mapTransactions::Bound UserTransaction to Application Server Context");
-        }
-        catch (NamingException ne1) {
+            writer.fine(
+                "JNDIInvoker::mapTransactions::Bound UserTransaction to Application Server Context");
+        } catch (NamingException ne1) {
-              writer
-                  .info(LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSNAMINGEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_APPLICATION_SERVER_JNDI_TREE);
-        }
-        catch (SystemException se1) {
+            writer.info(
+                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSNAMINGEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_APPLICATION_SERVER_JNDI_TREE);
+        } catch (SystemException se1) {
-              writer
-                  .info(LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSSYSTEMEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_APPLICATION_SERVER_JNDI_TREE);
+            writer.info(
+                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSSYSTEMEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_APPLICATION_SERVER_JNDI_TREE);
-   * Cleans all the DataSource ans its associated threads gracefully, before
-   * start of the GemFire system. Also kills all of the threads associated with
-   * the TransactionManager before making it null.
+   * Cleans all the DataSource ans its associated threads gracefully, before start of the GemFire
+   * system. Also kills all of the threads associated with the TransactionManager before making it
+   * null.
-   * Helps in locating TransactionManager in presence of application server
-   * scenario. Stores the value of TransactionManager for reference in GemFire
-   * system.
+   * Helps in locating TransactionManager in presence of application server scenario. Stores the
+   * value of TransactionManager for reference in GemFire system.
-      }
-      catch (NamingException e) {
+      } catch (NamingException e) {
-        if (writer.finerEnabled()) writer.finer(exception);
+        if (writer.finerEnabled())
+          writer.finer(exception);
-        if (writer.fineEnabled()) writer.fine(exception);
+        if (writer.fineEnabled())
+          writer.fine(exception);
-          + (jndiObject == null?"null":jndiObject.getClass()) + " but is not of type javax.transaction.TransactionManager" ;
-        if (writer.fineEnabled()) writer.fine(exception);
+            + (jndiObject == null ? "null" : jndiObject.getClass())
+            + " but is not of type javax.transaction.TransactionManager";
+        if (writer.fineEnabled())
+          writer.fine(exception);
-          writer
-              .finer("JNDIInvoker::doTransactionLookup::Trying WebSphere 5.1: "
-                  + WS_FACTORY_CLASS_5_1);
+        writer.finer(
+            "JNDIInvoker::doTransactionLookup::Trying WebSphere 5.1: " + WS_FACTORY_CLASS_5_1);
-          writer.fine("JNDIInvoker::doTransactionLookup::Found WebSphere 5.1: "
-              + WS_FACTORY_CLASS_5_1);
-    }
-    catch (ClassNotFoundException ex) {
+        writer
+            .fine("JNDIInvoker::doTransactionLookup::Found WebSphere 5.1: " + WS_FACTORY_CLASS_5_1);
+    } catch (ClassNotFoundException ex) {
-            writer
-                .finer("JNDIInvoker::doTransactionLookup::Trying WebSphere 5.0: "
-                    + WS_FACTORY_CLASS_5_0);
+          writer.finer(
+              "JNDIInvoker::doTransactionLookup::Trying WebSphere 5.0: " + WS_FACTORY_CLASS_5_0);
-            writer
-                .fine("JNDIInvoker::doTransactionLookup::Found WebSphere 5.0: "
-                    + WS_FACTORY_CLASS_5_0);
-      }
-      catch (ClassNotFoundException ex2) {
+          writer.fine(
+              "JNDIInvoker::doTransactionLookup::Found WebSphere 5.0: " + WS_FACTORY_CLASS_5_0);
+      } catch (ClassNotFoundException ex2) {
-          String exception = "JNDIInvoker::doTransactionLookup::Found WebSphere 4: "
-              + WS_FACTORY_CLASS_4;
-          if (writer.fineEnabled()) writer.fine(exception, ex);
-        }
-        catch (ClassNotFoundException ex3) {
+          String exception =
+              "JNDIInvoker::doTransactionLookup::Found WebSphere 4: " + WS_FACTORY_CLASS_4;
+          if (writer.fineEnabled())
+            writer.fine(exception, ex);
+        } catch (ClassNotFoundException ex3) {
-              writer
-                  .finer("JNDIInvoker::doTransactionLookup::Couldn't find any WebSphere TransactionManager factory class, neither for WebSphere version 5.1 nor 5.0 nor 4");
+            writer.finer(
+                "JNDIInvoker::doTransactionLookup::Couldn't find any WebSphere TransactionManager factory class, neither for WebSphere version 5.1 nor 5.0 nor 4");
-      Method method = clazz.getMethod("getTransactionManager", (Class[])null);
-      transactionManager = (TransactionManager) method.invoke(null, (Object[])null);
-    }
-    catch (Exception ex) {
-      writer.warning(LocalizedStrings.JNDIInvoker_JNDIINVOKER_DOTRANSACTIONLOOKUP_FOUND_WEBSPHERE_TRANSACTIONMANAGER_FACTORY_CLASS_0_BUT_COULDNT_INVOKE_ITS_STATIC_GETTRANSACTIONMANAGER_METHOD, clazz.getName(), ex);
-      throw new NameNotFoundException(LocalizedStrings.JNDIInvoker_JNDIINVOKER_DOTRANSACTIONLOOKUP_FOUND_WEBSPHERE_TRANSACTIONMANAGER_FACTORY_CLASS_0_BUT_COULDNT_INVOKE_ITS_STATIC_GETTRANSACTIONMANAGER_METHOD.toLocalizedString(new Object[] {clazz.getName()}));
+      Method method = clazz.getMethod("getTransactionManager", (Class[]) null);
+      transactionManager = (TransactionManager) method.invoke(null, (Object[]) null);
+    } catch (Exception ex) {
+      writer.warning(
+          LocalizedStrings.JNDIInvoker_JNDIINVOKER_DOTRANSACTIONLOOKUP_FOUND_WEBSPHERE_TRANSACTIONMANAGER_FACTORY_CLASS_0_BUT_COULDNT_INVOKE_ITS_STATIC_GETTRANSACTIONMANAGER_METHOD,
+          clazz.getName(), ex);
+      throw new NameNotFoundException(
+          LocalizedStrings.JNDIInvoker_JNDIINVOKER_DOTRANSACTIONLOOKUP_FOUND_WEBSPHERE_TRANSACTIONMANAGER_FACTORY_CLASS_0_BUT_COULDNT_INVOKE_ITS_STATIC_GETTRANSACTIONMANAGER_METHOD
+              .toLocalizedString(new Object[] {clazz.getName()}));
-   * Initialises the GemFire context. This is called when no external JNDI
-   * Context is found. 
+   * Initialises the GemFire context. This is called when no external JNDI Context is found.
-   * Binds a single Datasource to the existing JNDI tree. The JNDI tree may be
-   * The Datasource properties are contained in the map. The Datasource
-   * implementation class is populated based on properties in the map.
+   * Binds a single Datasource to the existing JNDI tree. The JNDI tree may be The Datasource
+   * properties are contained in the map. The Datasource implementation class is populated based on
+   * properties in the map.
-            writer.fine("Bound java:/" + jndiName + " to Context");
-      }
-      else if (value.equals("XAPooledDataSource")) {
+          writer.fine("Bound java:/" + jndiName + " to Context");
+      } else if (value.equals("XAPooledDataSource")) {
-            writer.fine("Bound java:/" + jndiName + " to Context");
-      }
-      else if (value.equals("SimpleDataSource")) {
+          writer.fine("Bound java:/" + jndiName + " to Context");
+      } else if (value.equals("SimpleDataSource")) {
-            writer.fine("Bound java:/" + jndiName + " to Context");
-      }
-      else if (value.equals("ManagedDataSource")) {
-        ClientConnectionFactoryWrapper ds1 = DataSourceFactory
-            .getManagedDataSource(map, props);
+          writer.fine("Bound java:/" + jndiName + " to Context");
+      } else if (value.equals("ManagedDataSource")) {
+        ClientConnectionFactoryWrapper ds1 = DataSourceFactory.getManagedDataSource(map, props);
-            writer.fine("Bound java:/" + jndiName + " to Context");
-      }
-      else {
+          writer.fine("Bound java:/" + jndiName + " to Context");
+      } else {
-        if (writer.fineEnabled()) writer.fine(exception);
+        if (writer.fineEnabled())
+          writer.fine(exception);
-    }
-    catch (NamingException ne) {
-      if (writer.infoEnabled()) writer.info(
-          LocalizedStrings.JNDIInvoker_JNDIINVOKER_MAPDATASOURCE_0_WHILE_BINDING_1_TO_JNDI_CONTEXT,
-          new Object[] {"NamingException", jndiName});
-    }
-    catch (DataSourceCreateException dsce) {
-      if (writer.infoEnabled()) writer.info(
-          LocalizedStrings.JNDIInvoker_JNDIINVOKER_MAPDATASOURCE_0_WHILE_BINDING_1_TO_JNDI_CONTEXT,
-          new Object[] {"DataSourceCreateException", jndiName});
+    } catch (NamingException ne) {
+      if (writer.infoEnabled())
+        writer.info(
+            LocalizedStrings.JNDIInvoker_JNDIINVOKER_MAPDATASOURCE_0_WHILE_BINDING_1_TO_JNDI_CONTEXT,
+            new Object[] {"NamingException", jndiName});
+    } catch (DataSourceCreateException dsce) {
+      if (writer.infoEnabled())
+        writer.info(
+            LocalizedStrings.JNDIInvoker_JNDIINVOKER_MAPDATASOURCE_0_WHILE_BINDING_1_TO_JNDI_CONTEXT,
+            new Object[] {"DataSourceCreateException", jndiName});
-   * @return Context the existing JNDI Context. If there is no pre-esisting JNDI
-   *         Context, the GemFire JNDI Context is returned.
+   * @return Context the existing JNDI Context. If there is no pre-esisting JNDI Context, the
+   *         GemFire JNDI Context is returned.
-  //try to find websphere lookups since we came here
+  // try to find websphere lookups since we came here
-   * private static void print(String str) { if (DEBUG) {
-   * System.err.println(str); } }
+   * private static void print(String str) { if (DEBUG) { System.err.println(str); } }

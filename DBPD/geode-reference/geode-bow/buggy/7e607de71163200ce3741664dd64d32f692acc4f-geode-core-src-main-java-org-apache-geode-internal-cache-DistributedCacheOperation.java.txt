GEODE-2787: When distribution happened, it calls startOperation() to increase a count, then call an endOperation() to decrease the count.

state flush will wait for this count to become 0.

But notifyGateway() is called after distribute(). So there's race that stateflush finished but notifyGateway has not done yet.

The fix is to move the endOperation() after callbacks.

+import org.apache.geode.InvalidVersionException;
+import org.apache.geode.internal.util.DelayedAction;
+  public static volatile DelayedAction test_InvalidVersionAction;
+
+  /**
+   * region's distribution advisor marked that a distribution is about to start, then distribute. It
+   * returns a token, which is view version. Return -1 means the method did not succeed. This method
+   * must be invoked before toDistribute(). This method should pair with endOperation() in
+   * try/finally block.
+   */
+  public long startOperation() {
+    DistributedRegion region = getRegion();
+    long viewVersion = -1;
+    if (this.containsRegionContentChange()) {
+      viewVersion = region.getDistributionAdvisor().startOperation();
+    }
+    if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP)) {
+      logger.trace(LogMarker.STATE_FLUSH_OP, "dispatching operation in view version {}",
+          viewVersion);
+    }
+    try {
+      _distribute();
+    } catch (InvalidVersionException e) {
+      if (logger.isDebugEnabled()) {
+        logger.trace(LogMarker.DM, "PutAll failed since versions were missing; retrying again", e);
+      }
+
+      if (test_InvalidVersionAction != null) {
+        test_InvalidVersionAction.run();
+      }
+      _distribute();
+    }
+    return viewVersion;
+  }
+
+  /**
+   * region's distribution advisor marked that a distribution is ended. This method should pair with
+   * startOperation in try/finally block.
+   */
+  public void endOperation(long viewVersion) {
+    DistributedRegion region = getRegion();
+    if (viewVersion != -1) {
+      region.getDistributionAdvisor().endOperation(viewVersion);
+      if (logger.isDebugEnabled()) {
+        logger.trace(LogMarker.STATE_FLUSH_OP, "done dispatching operation in view version {}",
+            viewVersion);
+      }
+    }
+  }
+
+    long token = -1;
+    try {
+      token = startOperation();
+    } finally {
+      endOperation(token);
+    }
+  }
+
+  /**
+   * About to distribute a cache operation to other members of the distributed system. This method
+   * determines who the recipients are and handles careful delivery of the operation to those
+   * members. This method should wrapped by startOperation() and endOperation() in try/finally
+   * block.
+   */
+  private void _distribute() {
-    long viewVersion = -1;
-    if (this.containsRegionContentChange()) {
-      viewVersion = region.getDistributionAdvisor().startOperation();
-    }
-    if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP)) {
-      logger.trace(LogMarker.STATE_FLUSH_OP, "dispatching operation in view version {}",
-          viewVersion);
-    }
-
-        if (viewVersion > 0) {
-          region.getDistributionAdvisor().endOperation(viewVersion);
-          viewVersion = -1;
-        }
-
-      if (viewVersion != -1) {
-        if (logger.isDebugEnabled()) {
-          logger.trace(LogMarker.STATE_FLUSH_OP, "done dispatching operation in view version {}",
-              viewVersion);
-        }
-        region.getDistributionAdvisor().endOperation(viewVersion);
-      }

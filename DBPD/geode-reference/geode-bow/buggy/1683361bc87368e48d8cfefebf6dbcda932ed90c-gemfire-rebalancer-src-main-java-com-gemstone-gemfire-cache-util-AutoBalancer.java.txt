GEODE-124: Add min size check and optimize calls

* Member stats are needed for computing member load skew and total data size.
  The gathering step is common and need not be executed twice
* If the total transfer size during rebalance is low, then avoid rebalance. This
  could happen when a new cluster is created is data is being loaded

+import java.util.HashMap;
+import java.util.Map;
-   * Use this configuration to manage re-balance threshold. Rebalance operation
+   * Use this configuration to manage re-balance invocation. Rebalance operation
-   * is more than this threshold, percentage of the total data size.
+   * is more than this threshold, in percentage of the total data size.
+   * In the initial data load phases,
+   * {@link AutoBalancer#SIZE_THRESHOLD_PERCENT} based rebalance invocation may
+   * be unnecessary. Rebalance should not be triggered if the total data size
+   * managed by cluster is too small. Rebalance operation will be triggered if
+   * the total number of bytes rebalance operation may move is more than this
+   * number of bytes.
+   * <P>
+   * Default {@value AutoBalancer#DEFAULT_SIZE_MINIMUM}
+   */
+  public static final String SIZE_MINIMUM = "size-minimum";
+
+  /**
+   * Default value of {@link AutoBalancer#SIZE_MINIMUM}. In the initial data
+   * load phases, {@link AutoBalancer#SIZE_THRESHOLD_PERCENT} based rebalance
+   * invocation may be unnecessary. Do not rebalance if the data to be moved is
+   * less than 100MB
+   */
+  public static final int DEFAULT_SIZE_MINIMUM = 100 * 1024 * 1024;
+
+  /**
+    private int sizeMinimum = DEFAULT_SIZE_MINIMUM;
+        if (props.getProperty(SIZE_MINIMUM) != null) {
+          sizeMinimum = Integer.valueOf(props.getProperty(SIZE_MINIMUM));
+          if (sizeMinimum <= 0) {
+            throw new GemFireConfigException(SIZE_MINIMUM + " should be greater than 0");
+          }
+        }
-      long totalSize = cacheFacade.getTotalDataSize();
+      if (transferSize <= sizeMinimum) {
+        return false;
+      }
+
+      Map<PartitionedRegion, InternalPRInfo> details = cacheFacade.getRegionMemberDetails();
+      long totalSize = cacheFacade.getTotalDataSize(details);
-    public int getSizeThreshold() {
+    int getSizeThreshold() {
+
+    public long getSizeMinimum() {
+      return sizeMinimum;
+    }
-    public long getTotalDataSize() {
-      long totalSize = 0;
+    public Map<PartitionedRegion, InternalPRInfo> getRegionMemberDetails() {
+      Map<PartitionedRegion, InternalPRInfo> detailsMap = new HashMap<>();
-        Set<PartitionMemberInfo> membersInfo = info.getPartitionMemberInfo();
-        for (PartitionMemberInfo member : membersInfo) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Region:{}, Member: {}, Size: {}", region.getFullPath(), member, member.getSize());
+        detailsMap.put(region, info);
+      }
+      return detailsMap;
+    }
+
+    @Override
+    public long getTotalDataSize(Map<PartitionedRegion, InternalPRInfo> details) {
+      long totalSize = 0;
+      if (details != null) {
+        for (PartitionedRegion region : details.keySet()) {
+          InternalPRInfo info = details.get(region);
+          Set<PartitionMemberInfo> membersInfo = info.getPartitionMemberInfo();
+          for (PartitionMemberInfo member : membersInfo) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Region:{}, Member: {}, Size: {}", region.getFullPath(), member, member.getSize());
+            }
+            totalSize += member.getSize();
-          totalSize += member.getSize();
-    long getTotalDataSize();
+    Map<PartitionedRegion, InternalPRInfo> getRegionMemberDetails();
+
+    long getTotalDataSize(Map<PartitionedRegion, InternalPRInfo> details);
+
+  public CacheOperationFacade getCacheOperationFacade() {
+    return this.cacheFacade;
+  }

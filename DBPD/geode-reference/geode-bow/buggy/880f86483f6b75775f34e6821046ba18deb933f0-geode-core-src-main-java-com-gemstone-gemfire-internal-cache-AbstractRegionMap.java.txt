GEODE-1464: remove sqlf code

-import com.gemstone.gemfire.cache.query.internal.IndexUpdater;
-import com.gemstone.gemfire.internal.cache.delta.Delta;
-//Asif: In case of sqlFabric System, we are creating a different set of RegionEntry 
-// which are derived from the concrete  GFE RegionEntry classes.
-// In future if any new concrete  RegionEntry class is defined, the new  SqlFabric
-// RegionEntry Classes need to be created. There is a junit test in sqlfabric
-// which checks for RegionEntry classes of GFE and validates the same with its 
-// own classes.
-
-  /** An internal Listener for index maintenance for SQLFabric. */
-  private final IndexUpdater indexUpdater;
-    if (internalRegionArgs != null) {
-      this.indexUpdater = internalRegionArgs.getIndexUpdater();
-    }
-    else {
-      this.indexUpdater = null;
-    }
-  }
-
-  public final IndexUpdater getIndexUpdater() {
-    return this.indexUpdater;
-      EntryEventImpl event, final LocalRegion owner,
-      final IndexUpdater indexUpdater) {
+      EntryEventImpl event, final LocalRegion owner) {
-    try {
-      if (indexUpdater != null) {
-        indexUpdater.onEvent(owner, event, re);
-      }
-
-      if (_getMap().remove(key, re)) {
-        re.removePhase2();
-        success = true;
-        if (updateStat) {
-          incEntryCount(-1);
-        }
-      }
-    } finally {
-      if (indexUpdater != null) {
-        indexUpdater.postEvent(owner, event, re, success);
+    if (_getMap().remove(key, re)) {
+      re.removePhase2();
+      success = true;
+      if (updateStat) {
+        incEntryCount(-1);
-    assert indexUpdater == null : "indexUpdater should only exist if sqlfire";
-                          removeEntry(event.getKey(), re, true, event, owner,
-                              indexUpdater);
+                          removeEntry(event.getKey(), re, true, event, owner);
-                          removeEntry(event.getKey(), re, true, event, owner,
-                              indexUpdater);
+                          removeEntry(event.getKey(), re, true, event, owner);
-                        removeEntry(event.getKey(), re, true, event, owner,
-                            indexUpdater);
+                        removeEntry(event.getKey(), re, true, event, owner);
-              EntryEventImpl sqlfEvent = null;
-              if (/* owner.isUsedForPartitionedRegionBucket() && */ 
-                  indexUpdater != null) {
-                 sqlfEvent = cbEvent;
-              } else {
-              }
-                    if (sqlfEvent != null) {
-                      re.removePhase1(owner, false); // fix for bug 43063
-                      re.removePhase2();
-                      removeEntry(key, re, true, sqlfEvent, owner, indexUpdater);
-                    } else {
+                    {
-  protected static final MapCallbackAdapter<Object, Object, Object, Object>
-      listOfDeltasCreator = new MapCallbackAdapter<Object, Object,
-          Object, Object>() {
-    @Override
-    public Object newValue(Object key, Object context, Object createParams,
-        final MapResult result) {
-      return new ListOfDeltas(4);
-    }
-  };
-  
-  /**
-   * Neeraj: The below if block is to handle the special
-   * scenario witnessed in Sqlfabric for now. (Though its
-   * a general scenario). The scenario is that the updates start coming 
-   * before the base value reaches through GII. In that scenario the updates
-   * essentially the deltas are added to a list and kept as oldValue in the
-   * map and this method returns. When through GII the actual base value arrives
-   * these updates or deltas are applied on it and the new value thus got is put
-   * in the map.
-   * @param event 
-   * @param ifOld 
-   * @return true if delta was enqued
-   */
-  private boolean enqueDelta(EntryEventImpl event, boolean ifOld) {
-    final IndexUpdater indexManager = getIndexUpdater();
-    LocalRegion owner = _getOwner();
-    if (indexManager != null && !owner.isInitialized() && event.hasDelta()) {
-      boolean isOldValueDelta = true;
-      try {
-        if (ifOld) {
-          final Delta delta = event.getDeltaNewValue();
-		  RegionEntry re = getOrCreateRegionEntry(owner, event, null,
-          	  listOfDeltasCreator, false, false);
-          assert re != null;
-          synchronized (re) {
-            @Retained @Released Object oVal = re.getValueOffHeapOrDiskWithoutFaultIn(owner);
-            if (oVal != null) {
-              try {
-              if (oVal instanceof ListOfDeltas) {
-                if (logger.isDebugEnabled()) {
-                  logger.debug("basicPut: adding delta to list of deltas: {}", delta);
-                }
-                ((ListOfDeltas)oVal).merge(delta);
-                @Retained Object newVal = ((AbstractRegionEntry)re).prepareValueForCache(owner, oVal, true);              
-                re.setValue(owner, newVal); // TODO:KIRK:48068 prevent orphan
-              }
-              else {
-                isOldValueDelta = false;
-              }
-              }finally {
-                OffHeapHelper.release(oVal);
-              }
-            }
-            else {
-              if (logger.isDebugEnabled()) {
-                logger.debug("basicPut: new list of deltas with delta: {}", delta);
-              }
-              @Retained Object newVal = new ListOfDeltas(delta);
-              // TODO no need to call AbstractRegionMap.prepareValueForCache here?
-              newVal = ((AbstractRegionEntry)re).prepareValueForCache(owner, newVal, true);
-              re.setValue(owner, newVal); // TODO:KIRK:48068 prevent orphan
-            }
-          }
-        }
-      } catch (RegionClearedException ex) {
-        // Neeraj: We can just ignore this exception because we are returning after this block
-      }
-      if (isOldValueDelta) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-    // SqlFabric Changes - BEGIN
-    if (enqueDelta(event, ifOld)) {
-      return null;
-    }
-
-    final IndexUpdater indexManager = getIndexUpdater();
-
-    boolean sqlfIndexLocked = false;
-    // SqlFabric Changes - END
-
-      // take read lock for SQLF index initializations if required; the index
-      // GII lock is for any updates that may come in while index is being
-      // loaded during replay see bug #41377; this will go away once we allow
-      // for indexes to be loaded completely in parallel (#40899); need to
-      // take this lock before the RegionEntry lock else a deadlock can happen
-      // between this thread and index loading thread that will first take the
-      // corresponding write lock on the IndexUpdater
-      if (indexManager != null) {
-        sqlfIndexLocked = indexManager.lockForIndexGII();
-      }
-                    owner.cleanUpOnIncompleteOp(event, re, eventRecorded,
-                        false/* updateStats */, replaceOnClient);
+                    owner.cleanUpOnIncompleteOp(event, re);
-        if (sqlfIndexLocked) {
-          indexManager.unlockForIndexGII();
-        }
-          } catch (EntryExistsException eee) {
-            // SQLFabric changes BEGIN
-            // ignore EntryExistsException in distribution from a non-empty
-            // region since actual check will be done in this put itself
-            // and it can happen in distribution if put comes in from
-            // GII as well as distribution channel
-            if (indexManager != null) {
-              if (logger.isTraceEnabled()) {
-                logger.trace("basicPut: ignoring EntryExistsException in distribution {}", eee);
-              }
-            }
-            else {
-              // can this happen for non-SQLFabric case?
-              throw eee;
-            }
-            // SQLFabric changes END
-  // Asif: If the new value is an instance of SerializableDelta, then
-  // the old value requirement is a must & it needs to be faulted in
-  // if overflown to disk without affecting LRU? This is needed for
-  // Sql Fabric.
-  // [sumedh] store both the value in VM and the value in VM or disk;
-  // the former is used for updating the VM size calculations, while
-  // the latter is used in other places like passing to
-  // SqlfIndexManager or setting the old value in the event; this is
-  // required since using the latter for updating the size
-  // calculations will be incorrect in case the value was read from
-  // disk but not brought into the VM like what getValueInVMOrDisk
-  // method does when value is not found in VM
-    boolean needToSetOldValue = getIndexUpdater() != null || cacheWrite || requireOldValue || event.getOperation().guaranteesOldValue();
+    boolean needToSetOldValue = cacheWrite || requireOldValue || event.getOperation().guaranteesOldValue();
-      if (event.hasDelta() || event.getOperation().guaranteesOldValue()) {
+      if (event.getOperation().guaranteesOldValue()) {
-    @Released EntryEventImpl sqlfEvent = null;
-    if (/*owner.isUsedForPartitionedRegionBucket() && */ 
-       (getIndexUpdater() != null ||
-       (newValue instanceof com.gemstone.gemfire.internal.cache.delta.Delta))) {
-      sqlfEvent = createCBEvent(owner, putOp, key, newValue, txId, 
-          txEvent, eventId, aCallbackArgument,filterRoutingInfo,bridgeContext, txEntryState, versionTag, tailKey);
-    }
-                  if (sqlfEvent != null) {
-                    sqlfEvent.setOldValue(re.getValueInVM(owner)); // OFFHEAP eei
-                  }
-                      // Rahul: applies the delta and sets the new value in 
-                      // region entry (required for sqlfabric delta).
-                      if (newValue instanceof com.gemstone.gemfire.internal.cache.delta.Delta 
-                          && sqlfEvent != null) {
-                        //cbEvent.putExistingEntry(owner, re);
-                        sqlfEvent.putExistingEntry(owner, re);
-                      } else {
+                      {
-                        if (sqlfEvent != null) {
-                          owner.updateSizeOnPut(key, oldSize, sqlfEvent.getNewValueBucketSize());
-                        } else {
+                        {
-                  if (sqlfEvent != null) {
-                    sqlfEvent.setOldValue(oldRe.getValueInVM(owner)); // OFFHEAP eei
-                  }
-                      if (newValue instanceof com.gemstone.gemfire.internal.cache.delta.Delta 
-                          && sqlfEvent != null ) {
-                        //cbEvent.putExistingEntry(owner, oldRe);
-                        sqlfEvent.putExistingEntry(owner, oldRe);
-                      } else {
+                      {
-                        if (sqlfEvent != null) {
-                          owner.updateSizeOnPut(key, oldSize, sqlfEvent.getNewValueBucketSize());
-                        } else {
+                        {
-                  if (sqlfEvent != null ) {
-                    sqlfEvent.putNewEntry(owner,newRe);
-                  } else {
+                  {
-      if (sqlfEvent != null) sqlfEvent.release();

GEODE-1994: Overhaul of internal.lang.StringUtils to extend and heavily use commons.lang.StringUtils

*   geode.internal.lang.StringUtils has been deprecated.  In the interim, it has been heavily refactored and extends commons.lang.StringUtils.
*
*   Renamed:
*   --  EMPTY_STRING -> EMPTY (inherited)
*   --  toUpperCase  -> upperCase (inherited)
*   --  toLowerCase  -> lowerCase (inherited)
*   --  padEnding    -> rightPad (inherited)
*
*   Removed:
*   --  EMPTY_STRING_ARRAY; usage replaced with commons.lang.ArrayUtils.EMPTY_STRING_ARRAY
*   --  SPACES
*   --  UTF_8; rare usage replaced with raw string
*   --  concat; usage replaced with commons.lang.join, refactoring as necessary.
*   --  getLettersOnly
*   --  getSpaces
*   --  truncate
*   --  valueOf; usage refactored to use defaultString
*
*   Refactored
*   --  defaultIfBlank: previously relied on varargs and could return null.  Usage refactored to allow inheritance from commons.
*   --  defaultString(s, EMPTY) refactored to use standard signature defaultString(s) for consistency throughout codebase.
*   --  isBlank: usage refactored to resolve discrepancies with commons.lang.isBlank, which is now inherited.
*   --  isEmpty: usage refactored to resolve discrepancies with commons.lang.isEmpty, which is now inherited.
*
*   Code Cleanup:
*   --  Many uses of !isBlank -> isNotBlank
*   --  Changes suggested by Inspections on most touched files.
*   --     Explicit <T> -> <> when type is inferable
*   --     while loops operating on iterators converted to for each loops
*   --     for loops operating on array indices converted to for each loops
*   --  Various string typos corrected.
*   --  isEmpty(s.trim()) -> isBlank(s)
*   --  s.trim().isEmpty() -> isEmpty(s)
*   --  Removed some instances of 'dead' code
*   --  Optimized imports in every touched file
*
*   Qualitative Changes:
*   --  The following functions now throw an error when called with a null string input:
*   --  *  LocatorLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setHostnameForClients
*   --  (Unit tests added to capture these changes)
*
*   Notes:
*   --  StringUtils.wraps may be inherited from Apache Commons when the dependency is updated.
*   --  AbstractLauncher.getMember has the documented behavior of returning null when both MemberName and ID are blank.  Is this the best behavior for this method?

* this closes #521

-import java.io.File;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.TreeSet;
-import java.util.UUID;
-import java.util.concurrent.ConcurrentHashMap;
-
-import javax.management.InstanceNotFoundException;
-import javax.management.ListenerNotFoundException;
-import javax.management.MBeanServer;
-import javax.management.Notification;
-import javax.management.NotificationBroadcasterSupport;
-import javax.management.NotificationListener;
-import javax.management.ObjectName;
-
-import org.apache.logging.log4j.Logger;
-
+import org.apache.commons.lang.StringUtils;
+import org.apache.logging.log4j.Logger;
+
+import java.io.File;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.management.InstanceNotFoundException;
+import javax.management.ListenerNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationBroadcasterSupport;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
-   * Gatway Sender Proxy set size
+   * Gateway Sender Proxy set size
-   * Gatway Receiver Proxy set size
+   * Gateway Receiver Proxy set size
-    this.distrLockServiceMap = new ConcurrentHashMap<ObjectName, DistributedLockServiceBridge>();
-    this.distrRegionMap = new ConcurrentHashMap<ObjectName, DistributedRegionBridge>();
-    this.mapOfMembers = new ConcurrentHashMap<ObjectName, MemberMXBean>();
-    this.mapOfServers = new ConcurrentHashMap<ObjectName, CacheServerMXBean>();
-    this.mapOfGatewayReceivers = new ConcurrentHashMap<ObjectName, GatewayReceiverMXBean>();
-    this.mapOfGatewaySenders = new ConcurrentHashMap<ObjectName, GatewaySenderMXBean>();
+    this.distrLockServiceMap = new ConcurrentHashMap<>();
+    this.distrRegionMap = new ConcurrentHashMap<>();
+    this.mapOfMembers = new ConcurrentHashMap<>();
+    this.mapOfServers = new ConcurrentHashMap<>();
+    this.mapOfGatewayReceivers = new ConcurrentHashMap<>();
+    this.mapOfGatewaySenders = new ConcurrentHashMap<>();
-        Map<String, String[]> backedUpDiskStores = new HashMap<String, String[]>();
+        Map<String, String[]> backedUpDiskStores = new HashMap<>();
-      List<String> listOfReceivers = new ArrayList<String>();
+      List<String> listOfReceivers = new ArrayList<>();
-      List<String> listOfServer = new ArrayList<String>();
+      List<String> listOfServer = new ArrayList<>();
-      List<String> listOfServer = new ArrayList<String>();
+      List<String> listOfServer = new ArrayList<>();
-  public String[] listGatwaySenders() {
+  public String[] listGatewaySenders() {
-      List<String> listOfSenders = new ArrayList<String>();
+      List<String> listOfSenders = new ArrayList<>();
-      Set<String> set = new HashSet<String>();
+      Set<String> set = new HashSet<>();
-        for (String locator : hostedLocators) {
-          set.add(locator);
-        }
+        set.addAll(hostedLocators);
-      String[] locators = set.toArray(new String[set.size()]);
-      return locators;
+      return set.toArray(new String[set.size()]);
-      Map<String, String[]> mapOfDisks = new HashMap<String, String[]>();
+      Map<String, String[]> mapOfDisks = new HashMap<>();
-        Set<String> locatorMemberSet = new TreeSet<String>();
+        Set<String> locatorMemberSet = new TreeSet<>();
-    Set<DistributedMember> members = new HashSet<DistributedMember>();
+    Set<DistributedMember> members = new HashSet<>();
-      Set<String> locatorMemberSet = new TreeSet<String>();
+      Set<String> locatorMemberSet = new TreeSet<>();
-          name = name != null && !name.trim().isEmpty() ? name : member.getId();
+          name = StringUtils.isNotBlank(name) ? name : member.getId();
-      Set<String> groupSet = new TreeSet<String>();
+      Set<String> groupSet = new TreeSet<>();
-   * @return basic Opertaing metrics for a given member.
+   * @return basic Operating metrics for a given member.
-    SortedSet<String> regionPathsSet = new TreeSet<String>();
+    SortedSet<String> regionPathsSet = new TreeSet<>();
-      Iterator<InternalDistributedMember> it = members.iterator();
-      while (it.hasNext()) {
-        shutDownMembers[j] = it.next().getId();
+      for (InternalDistributedMember member : members) {
+        shutDownMembers[j] = member.getId();
-   * @return Array of PeristentMemberDetails (which contains host, directory and disk store id)
+   * @return Array of PersistentMemberDetails (which contains host, directory and disk store id)
-    Set<PersistentID> persitentMemberSet = MissingPersistentIDsRequest.send(dm);
-    if (persitentMemberSet != null && persitentMemberSet.size() > 0) {
-      missingDiskStores = new PersistentMemberDetails[persitentMemberSet.size()];
+    Set<PersistentID> persistentMemberSet = MissingPersistentIDsRequest.send(dm);
+    if (persistentMemberSet != null && persistentMemberSet.size() > 0) {
+      missingDiskStores = new PersistentMemberDetails[persistentMemberSet.size()];
-      for (PersistentID id : persitentMemberSet) {
+      for (PersistentID id : persistentMemberSet) {
-  public boolean revokeMissingDiskStores(final String diskStoreId) throws Exception {
+  public boolean revokeMissingDiskStores(final String diskStoreId) {
-    ObjectName memberName = MBeanJMXAdapter.getMemberMBeanName(member);
-    return memberName;
+    return MBeanJMXAdapter.getMemberMBeanName(member);
-    List<ObjectName> list = new ArrayList<ObjectName>();
+    List<ObjectName> list = new ArrayList<>();
-    List<ObjectName> list = new ArrayList<ObjectName>();
-    Iterator<ObjectName> it = distrRegionMap.keySet().iterator();
-    while (it.hasNext()) {
-      list.add(it.next());
-    }
+    List<ObjectName> list = new ArrayList<>();
+    list.addAll(distrRegionMap.keySet());
-      ObjectName lockSerName = service.getDistributedLockServiceMBeanName(lockServiceName);
-      return lockSerName;
+      return service.getDistributedLockServiceMBeanName(lockServiceName);
-      listName = new ArrayList<ObjectName>();
+      listName = new ArrayList<>();
-      ObjectName[] arry = new ObjectName[listName.size()];
-      return listName.toArray(arry);
+      ObjectName[] array = new ObjectName[listName.size()];
+      return listName.toArray(array);
-      Set<String> uniqueClientSet = new HashSet<String>();
-      Iterator<CacheServerMXBean> it = mapOfServers.values().iterator();
-      while (it.hasNext()) {
-        String[] clients = null;
+      Set<String> uniqueClientSet = new HashSet<>();
+      for (CacheServerMXBean cacheServerMXBean : mapOfServers.values()) {
+        String[] clients;
-          clients = it.next().getClientIds();
+          clients = cacheServerMXBean.getClientIds();
-          for (String client : clients) {
-            uniqueClientSet.add(client);
-          }
+          Collections.addAll(uniqueClientSet, clients);
-      Map<String, Boolean> senderMap = new HashMap<String, Boolean>();
-      Iterator<GatewaySenderMXBean> it = mapOfGatewaySenders.values().iterator();
-      while (it.hasNext()) {
-        GatewaySenderMXBean bean = it.next();
+      Map<String, Boolean> senderMap = new HashMap<>();
+      for (GatewaySenderMXBean bean : mapOfGatewaySenders.values()) {
-        FederationComponent newObj = (FederationComponent) (fedComp);
+        FederationComponent newObj = fedComp;
-        FederationComponent newObj = (FederationComponent) (fedComp);
+        FederationComponent newObj = fedComp;
-      FederationComponent newProxy = (FederationComponent) (newValue);
+      FederationComponent newProxy = newValue;
-        oldProxy = (FederationComponent) oldValue;
+        oldProxy = oldValue;
-    // neeeded.
+    // needed.

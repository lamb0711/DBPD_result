GEODE-1801: Updated the ClientTypeRegistration.java to handle Snapshot reading on the client side.

-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.pdx.PdxInitializationException;
+import org.apache.logging.log4j.Logger;
+
-  
+
-  
-  private volatile boolean typeRegistryInUse = false;
-  
+
-    verifyConfiguration(); 
-    
+
-    for(Pool pool: pools) {
+    int newTypeId = -1;
+    for (Pool pool : pools) {
-        int result = GetPDXIdForTypeOp.execute((ExecutablePool) pool, newType);
-        newType.setTypeId(result);
-        sendTypeToAllPools(newType, result, pools, pool);
-        return result;
-      } catch(ServerConnectivityException e) {
+        newTypeId = GetPDXIdForTypeOp.execute((ExecutablePool) pool, newType);
+        newType.setTypeId(newTypeId);
+        sendTypeToAllPools(newType, newTypeId, pool);
+        return newTypeId;
+      } catch (ServerConnectivityException e) {
-    if(lastException != null) {
-      throw lastException;
-    } else {
-      if (this.cache.isClosed()) {
-        throw new CacheClosedException("PDX detected cache was closed");
-      }
-      throw new CacheClosedException("Client pools have been closed so the PDX type registry can not define a type.");
-    }
+    throw returnCorrectExceptionForFailure(pools, newTypeId, lastException);
-  
-  private void sendTypeToAllPools(PdxType type, int id,
-      Collection<Pool> pools, Pool definingPool) {
-    
-    for(Pool pool: pools) {
-      if(pool.equals(definingPool)) {
-        continue;
-      }
-      
-      try {
-        AddPDXTypeOp.execute((ExecutablePool) pool, id, type);
-      } catch(ServerConnectivityException ignore) {
-        logger.debug("Received an exception sending pdx type to pool {}, {}", pool, ignore.getMessage(), ignore);
-        //TODO DAN - is it really safe to ignore this? What if this is the pool
-        //we're about to do a put on? I think maybe we really should pass the context
-        //down to this point, if it is available. Maybe just an optional thread local?
-        //Then we could go straight to that pool to register the type and bail otherwise.
-      }
+
+  private void sendTypeToAllPools(PdxType type, int id, Pool pool) {
+
+    try {
+      AddPDXTypeOp.execute((ExecutablePool) pool, id, type);
+    } catch (ServerConnectivityException ignore) {
+      logger.debug("Received an exception sending pdx type to pool {}, {}", pool, ignore.getMessage(), ignore);
+      //TODO DAN - is it really safe to ignore this? What if this is the pool
+      //we're about to do a put on? I think maybe we really should pass the context
+      //down to this point, if it is available. Maybe just an optional thread local?
+      //Then we could go straight to that pool to register the type and bail otherwise.
-    
-    verifyConfiguration();
-    
+
-    for(Pool pool: pools) {
+    for (Pool pool : pools) {
-        if(type != null) {
+        if (type != null) {
-      } catch(ServerConnectivityException e) {
+      } catch (ServerConnectivityException e) {
-    
-    if(lastException != null) {
+
+    if (lastException != null) {
-      if(pools.isEmpty()) {
+      if (pools.isEmpty()) {
+        } else {
+          throw new CacheClosedException("Client pools have been closed so the PDX type registry can not lookup a type.");
-        throw new CacheClosedException("Client pools have been closed so the PDX type registry can not lookup a type.");
-  
-  private Collection<Pool> getAllPools() {
-    return getAllPools(cache);
-  }
-  
-  private static Collection<Pool> getAllPools(GemFireCacheImpl cache) {
+
+  private static Collection<Pool> getAllPools() {
-    for(Iterator<Pool> itr= pools.iterator(); itr.hasNext(); ) {
+    for (Iterator<Pool> itr = pools.iterator(); itr.hasNext(); ) {
-      if(pool.isUsedByGateway()) {
+      if (pool.isUsedByGateway()) {
-    checkAllowed();
+    //do nothing
-  
+
-    EnumInfo ei = new EnumInfo(v);
-    Collection<Pool> pools = getAllPools();
+    EnumInfo enumInfo = new EnumInfo(v);
+    return processEnumInfoForEnumId(enumInfo);
+  }
+  private int processEnumInfoForEnumId(EnumInfo enumInfo) {
+    Collection<Pool> pools = getAllPools();
-    for(Pool pool: pools) {
+    for (Pool pool : pools) {
-        int result = GetPDXIdForEnumOp.execute((ExecutablePool) pool, ei);
-        sendEnumIdToAllPools(ei, result, pools, pool);
+        int result = GetPDXIdForEnumOp.execute((ExecutablePool) pool, enumInfo);
+        sendEnumIdToAllPools(enumInfo, result, pool);
-      } catch(ServerConnectivityException e) {
+      } catch (ServerConnectivityException e) {
-    if (lastException != null) {
-      throw lastException;
-    } else {
-      if (this.cache.isClosed()) {
-        throw new CacheClosedException("PDX detected cache was closed");
-      }
-      throw new CacheClosedException("Client pools have been closed so the PDX type registry can not define a type.");
-    }
+    throw returnCorrectExceptionForFailure(pools, -1, lastException);
-  
-  private void sendEnumIdToAllPools(EnumInfo enumInfo, int id,
-      Collection<Pool> pools, Pool definingPool) {
-    for (Pool pool: pools) {
-      if (pool.equals(definingPool)) {
-        continue;
-      }
-
-      try {
-        AddPDXEnumOp.execute((ExecutablePool) pool, id, enumInfo);
-      } catch(ServerConnectivityException ignore) {
-        logger.debug("Received an exception sending pdx type to pool {}, {}", pool, ignore.getMessage(), ignore);
-        //TODO DAN - is it really safe to ignore this? What if this is the pool
-        //we're about to do a put on? I think maybe we really should pass the context
-        //down to this point, if it is available. Maybe just an optional thread local?
-        //Then we could go straight to that pool to register the type and bail otherwise.
-      }
+  private void sendEnumIdToAllPools(EnumInfo enumInfo, int id, Pool pool) {
+    try {
+      AddPDXEnumOp.execute((ExecutablePool) pool, id, enumInfo);
+    } catch (ServerConnectivityException ignore) {
+      logger.debug("Received an exception sending pdx type to pool {}, {}", pool, ignore.getMessage(), ignore);
+      //TODO DAN - is it really safe to ignore this? What if this is the pool
+      //we're about to do a put on? I think maybe we really should pass the context
+      //down to this point, if it is available. Maybe just an optional thread local?
+      //Then we could go straight to that pool to register the type and bail otherwise.
-    Collection<Pool> pools = getAllPools();
-    
-    ServerConnectivityException lastException = null;
-    for(Pool pool: pools) {
-      try {
-        int result = GetPDXIdForEnumOp.execute((ExecutablePool) pool, newInfo);
-        sendEnumIdToAllPools(newInfo, result, pools, pool);
-        return result;
-      } catch(ServerConnectivityException e) {
-        //ignore, try the next pool.
-        lastException = e;
-      }
-    }
-    
-    
-    if(lastException != null) {
-      throw lastException;
-    } else {
-      if (this.cache.isClosed()) {
-        throw new CacheClosedException("PDX detected cache was closed");
-      }
-      throw new CacheClosedException("Client pools have been closed so the PDX type registry can not define a type.");
-    }
-   }
+    return processEnumInfoForEnumId(newInfo);
+  }
-    
+
-    for(Pool pool: pools) {
+    for (Pool pool : pools) {
-        if(result != null) {
+        if (result != null) {
-      } catch(ServerConnectivityException e) {
+      } catch (ServerConnectivityException e) {
-    
-    if(lastException != null) {
-      throw lastException;
-    } else {
-      if(pools.isEmpty()) {
-        if (this.cache.isClosed()) {
-          throw this.cache.getCacheClosedException("PDX detected cache was closed", null);
-        }
-        throw new CacheClosedException("Client pools have been closed so the PDX type registry can not lookup an enum.");
-      } else {
-        throw new InternalGemFireError("getEnum: Unable to determine pdx enum for id " + enumId + " from existing client to server pools " + pools);
-      }
-    }
-  }
-  
-  private void verifyConfiguration() {
-    if(typeRegistryInUse) {
-      return;
-    } else {
-      typeRegistryInUse = true;
-      checkAllowed();
-    }
-  }
-  
-  private void checkAllowed() {
-    //Anything is allowed until the registry is in use.
-    if(!typeRegistryInUse) {
-      return;
-    }
+
+    throw returnCorrectExceptionForFailure(pools, enumId, lastException);
-    
-    Map<Integer, PdxType> types = new HashMap<Integer, PdxType>();
+
+    Map<Integer, PdxType> types = new HashMap<>();
-    
-    Map<Integer, EnumInfo> enums = new HashMap<Integer, EnumInfo>();
+
+    Map<Integer, EnumInfo> enums = new HashMap<>();
-  
+
-      if (value instanceof PdxType){
+      if (value instanceof PdxType) {
-        if(pdxType.getClassName().equals(className) && pdxType.getPdxField(fieldName) != null){
+        if (pdxType.getClassName().equals(className) && pdxType.getPdxField(fieldName) != null) {
+
-    
+
-    for(Pool pool: pools) {
+    for (Pool pool : pools) {
-        sendTypeToAllPools(importedType, typeId, pools, pool);
-      } catch(ServerConnectivityException e) {
+        sendTypeToAllPools(importedType, typeId, pool);
+        return;
+      } catch (ServerConnectivityException e) {
-    if(lastException != null) {
-      throw lastException;
-    } else {
-      if (this.cache.isClosed()) {
-        throw new CacheClosedException("PDX detected cache was closed");
-      }
-      throw new CacheClosedException("Client pools have been closed so the PDX type registry can not define a type.");
-    }
+    throw returnCorrectExceptionForFailure(pools, typeId, lastException);
-    
+
-    for(Pool pool: pools) {
+    for (Pool pool : pools) {
-        sendEnumIdToAllPools(importedInfo, enumId, pools, pool);
-      } catch(ServerConnectivityException e) {
+        sendEnumIdToAllPools(importedInfo, enumId, pool);
+      } catch (ServerConnectivityException e) {
-    
-    if(lastException != null) {
+
+    throw returnCorrectExceptionForFailure(pools, enumId, lastException);
+  }
+
+  private RuntimeException returnCorrectExceptionForFailure(final Collection<Pool> pools, final int typeId, final ServerConnectivityException lastException) {
+    if (lastException != null) {
-      if (this.cache.isClosed()) {
-        throw new CacheClosedException("PDX detected cache was closed");
+      if (pools.isEmpty()) {
+        if (this.cache.isClosed()) {
+          throw this.cache.getCacheClosedException("PDX detected cache was closed", null);
+        } else {
+          throw new CacheClosedException("Client pools have been closed so the PDX type registry can not lookup a type.");
+        }
+      } else {
+        throw new InternalGemFireError("Unable to determine PDXType for id " + typeId);
-      throw new CacheClosedException("Client pools have been closed so the PDX type registry can not define a type.");
-  
+

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This is the fundamental representation of a member of a GemFire distributed
- * system.
+ * This is the fundamental representation of a member of a GemFire distributed system.
-public class InternalDistributedMember
- implements DistributedMember,
-    Externalizable, DataSerializableFixedID, ProfileId,
-    VersionSource<DistributedMember>
-{
+public class InternalDistributedMember implements DistributedMember, Externalizable,
+    DataSerializableFixedID, ProfileId, VersionSource<DistributedMember> {
-  
+
-  private final boolean SHOW_NETMEMBER = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "show_netmembers");
-  
+  private final boolean SHOW_NETMEMBER =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "show_netmembers");
+
-   * This is the direct channel port. The underlying NetMember must be able to
-   * serialize and deliver this value.
+   * This is the direct channel port. The underlying NetMember must be able to serialize and deliver
+   * this value.
-   * This is the process id of this member on its machine. The underlying
-   * NetMember must be able to serialize and deliver this value.
+   * This is the process id of this member on its machine. The underlying NetMember must be able to
+   * serialize and deliver this value.
-   * This is a representation of the type of VM. The underlying NetMember must
-   * be able to serialize and deliver this value.
+   * This is a representation of the type of VM. The underlying NetMember must be able to serialize
+   * and deliver this value.
-  
+
-   * This is the view identifier where this ID was born, or zero if this is
-   * a loner member
+   * This is the view identifier where this ID was born, or zero if this is a loner member
-  
+
-   * whether this is a partial member ID (without roles, durable attributes).
-   * We use partial IDs in EventID objects to reduce their size.  It would be
-   * better to use canonical IDs but there is currently no central mechanism
-   * that would allow that for both server and client identifiers
+   * whether this is a partial member ID (without roles, durable attributes). We use partial IDs in
+   * EventID objects to reduce their size. It would be better to use canonical IDs but there is
+   * currently no central mechanism that would allow that for both server and client identifiers
-   * The roles, if any, of this member. Lazily created first time getRoles()
-   * is called.
+   * The roles, if any, of this member. Lazily created first time getRoles() is called.
+   * 
-   * Unique tag (such as randomly generated bytes) to help enforce uniqueness.
-   * Note: this should be displayable.
+   * Unique tag (such as randomly generated bytes) to help enforce uniqueness. Note: this should be
+   * displayable.
-  private static final Version[] dsfidVersions = new Version[] {
-        Version.GFE_71, Version.GFE_90 };
+  private static final Version[] dsfidVersions = new Version[] {Version.GFE_71, Version.GFE_90};
-      }
-      else {
+      } else {
-    }
-    catch(UnknownHostException ee){
+    } catch (UnknownHostException ee) {
-   * Construct a InternalDistributedMember.  All fields are specified.<p>
+   * Construct a InternalDistributedMember. All fields are specified.
+   * <p>
-   * This, and the following constructor are the only valid ways to create an ID
-   * for a distributed member for use
-   * in the P2P cache.  Use of other constructors can break network-partition-detection.
+   * This, and the following constructor are the only valid ways to create an ID for a distributed
+   * member for use in the P2P cache. Use of other constructors can break
+   * network-partition-detection.
-   * @param p
-   *        the membership port
+   * @param p the membership port
-   * @param attr
-   *        the member's attributes
+   * @param attr the member's attributes
-  public InternalDistributedMember(InetAddress i, int p, 
-      boolean splitBrainEnabled, boolean canBeCoordinator, MemberAttributes attr) {
+  public InternalDistributedMember(InetAddress i, int p, boolean splitBrainEnabled,
+      boolean canBeCoordinator, MemberAttributes attr) {
-    this.netMbr = MemberFactory.newNetMember(i, p, splitBrainEnabled, canBeCoordinator, Version.CURRENT_ORDINAL, attr);
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getHostName(i) : i.getHostAddress();
+    this.netMbr = MemberFactory.newNetMember(i, p, splitBrainEnabled, canBeCoordinator,
+        Version.CURRENT_ORDINAL, attr);
+    this.hostName = SocketCreator.resolve_dns ? SocketCreator.getHostName(i) : i.getHostAddress();
-//    checkHostName();
+    // checkHostName();
-  
+
-   * Construct a InternalDistributedMember based on the given NetMember.<p>
-   * This is not the preferred way of creating an instance since the NetMember
-   * may not have all required information (e.g., a JGroups address without
-   * direct-port and other information).
+   * Construct a InternalDistributedMember based on the given NetMember.
+   * <p>
+   * This is not the preferred way of creating an instance since the NetMember may not have all
+   * required information (e.g., a JGroups address without direct-port and other information).
+   * 
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getHostName(m.getInetAddress()) :
-      m.getInetAddress().getHostAddress();
-//    checkHostName();
+    this.hostName = SocketCreator.resolve_dns ? SocketCreator.getHostName(m.getInetAddress())
+        : m.getInetAddress().getHostAddress();
+    // checkHostName();
-    }
-    else {
+    } else {
-  //  private void checkHostName() {
-//    // bug #44858: debug method to find who is putting a host name instead of addr into an ID
-//    if (!SocketCreator.resolve_dns
-//        && this.hostName != null && this.hostName.length() > 0
-//        && !Character.isDigit(this.hostName.charAt(0))) {
-//      throw new RuntimeException("found hostname that doesn't start with a digit: " + this.hostName);
-//    }
-//  }
+  // private void checkHostName() {
+  // // bug #44858: debug method to find who is putting a host name instead of addr into an ID
+  // if (!SocketCreator.resolve_dns
+  // && this.hostName != null && this.hostName.length() > 0
+  // && !Character.isDigit(this.hostName.charAt(0))) {
+  // throw new RuntimeException("found hostname that doesn't start with a digit: " + this.hostName);
+  // }
+  // }
-   * string).<p>
+   * string).
+   * <p>
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param i
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
+   * @param i the hostname, must be for the current host
+   * @param p the membership listening port
-  
+
-   * string).<p>
+   * string).
+   * <p>
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param i
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
-   * @param version
-   *          the version of this member
+   * @param i the hostname, must be for the current host
+   * @param p the membership listening port
+   * @param version the version of this member
-    this (i, p, version, MemberFactory.newNetMember(i, p));
+    this(i, p, version, MemberFactory.newNetMember(i, p));
-  
+
-   * string).<p>
+   * string).
+   * <p>
-   * <b>
-   * THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT. IT
+   * DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-  public InternalDistributedMember(String i, int p, Version version, NetMember netMember) throws UnknownHostException {
+  public InternalDistributedMember(String i, int p, Version version, NetMember netMember)
+      throws UnknownHostException {
-   * Create a InternalDistributedMember referring to the current host
-   * (as defined by the given string) with additional info including optional
-   * connection name and an optional unique string. Currently these two
-   * optional fields (and this constructor) are only used by the
-   * LonerDistributionManager.<p>
+   * Create a InternalDistributedMember referring to the current host (as defined by the given
+   * string) with additional info including optional connection name and an optional unique string.
+   * Currently these two optional fields (and this constructor) are only used by the
+   * LonerDistributionManager.
+   * <p>
-   * < b>
-   * [bruce]DO NOT USE THIS METHOD TO CREATE ANYTHING OTHER THAN A LONER ID
-   * WITHOUT TALKING TO ME FIRST.  IT DOES NOT PROPERLY INITIALIZE THE ID.
-   * </b>
+   * < b> [bruce]DO NOT USE THIS METHOD TO CREATE ANYTHING OTHER THAN A LONER ID WITHOUT TALKING TO
+   * ME FIRST. IT DOES NOT PROPERLY INITIALIZE THE ID. </b>
-   * @param host
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
-   * @param n
-   *          gemfire properties connection name
-   * @param u
-   *          unique string used make the member more unique
+   * @param host the hostname, must be for the current host
+   * @param p the membership listening port
+   * @param n gemfire properties connection name
+   * @param u unique string used make the member more unique
-  public InternalDistributedMember(String host, int p, String n, String u,
-      int vmKind, String[] groups, DurableClientAttributes attr) throws UnknownHostException {
-    MemberAttributes mattr = new MemberAttributes(p,
-        org.apache.geode.internal.OSProcess.getId(),
-        vmKind, -1,
-        n,
-        groups, attr);
+  public InternalDistributedMember(String host, int p, String n, String u, int vmKind,
+      String[] groups, DurableClientAttributes attr) throws UnknownHostException {
+    MemberAttributes mattr = new MemberAttributes(p, org.apache.geode.internal.OSProcess.getId(),
+        vmKind, -1, n, groups, attr);
-   * Create a InternalDistributedMember  referring to the current host (as defined by the given
-   * address).<p>
+   * Create a InternalDistributedMember referring to the current host (as defined by the given
+   * address).
+   * <p>
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param i
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
+   * @param i the hostname, must be for the current host
+   * @param p the membership listening port
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param addr 
-   *        address of the server
-   * @param p
-   *        the listening port of the server
-   * @param isCurrentHost
-   *        true if the given host refers to the current host (bridge and
-   *        gateway use false to create a temporary id for the OTHER side of a
-   *        connection)
+   * @param addr address of the server
+   * @param p the listening port of the server
+   * @param isCurrentHost true if the given host refers to the current host (bridge and gateway use
+   *        false to create a temporary id for the OTHER side of a connection)
-  public InternalDistributedMember(InetAddress addr,
-                                   int p,
-                                   boolean isCurrentHost) {
+  public InternalDistributedMember(InetAddress addr, int p, boolean isCurrentHost) {
-  public InetAddress getInetAddress()
-  {
+  public InetAddress getInetAddress() {
+   * 
-  public int getPort()
-  {
+  public int getPort() {
-  public int getDirectChannelPort()
-  {
+  public int getDirectChannelPort() {
-   * [GemStone] Returns the kind of VM that hosts the distribution manager with
-   * this address.
+   * [GemStone] Returns the kind of VM that hosts the distribution manager with this address.
-  public int getVmKind()
-  {
+  public int getVmKind() {
-  
+
-   * Returns the membership view ID that this member was born in. For
-   * backward compatibility reasons this is limited to 16 bits.
+   * Returns the membership view ID that this member was born in. For backward compatibility reasons
+   * this is limited to 16 bits.
-        if (tmpRoles == null  ||  tmpRoles.length == 0) {
+        if (tmpRoles == null || tmpRoles.length == 0) {
-        }
-        else {
+        } else {
+
-    netMbr.setAttributes(new MemberAttributes(dcPort, vmPid, vmKind, 
-        vmViewId, name, groups, durableClientAttributes));
+    netMbr.setAttributes(new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups,
+        durableClientAttributes));
-  public void setVmKind(int p)
-  {
+  public void setVmKind(int p) {
-  
+
-   * [GemStone] Returns the process id of the VM that hosts the distribution
-   * manager with this address.
+   * [GemStone] Returns the process id of the VM that hosts the distribution manager with this
+   * address.
-  public int getVmPid()
-  {
+  public int getVmPid() {
-   * [GemStone] Sets the process id of the VM that hosts the distribution
-   * manager with this address.
+   * [GemStone] Sets the process id of the VM that hosts the distribution manager with this address.
-  public void setVmPid(int p)
-  {
+  public void setVmPid(int p) {
-   * Returns the name of this member's distributed system connection or null
-   * if no name was specified.
+   * Returns the name of this member's distributed system connection or null if no name was
+   * specified.
+   * 
-   * Returns this member's unique tag (such as randomly generated bytes) or
-   * null if no unique tag was created.
+   * Returns this member's unique tag (such as randomly generated bytes) or null if no unique tag
+   * was created.
-   * Returns this client member's durable attributes or null if no durable
-   * attributes were created.
+   * Returns this client member's durable attributes or null if no durable attributes were created.
-   * @param o -
-   *          the Object to be compared
-   * @return a negative integer, zero, or a positive integer as this object is
-   *         less than, equal to, or greater than the specified object.
-   * @exception java.lang.ClassCastException -
-   *              if the specified object's type prevents it from being compared
-   *              to this Object.
+   * @param o - the Object to be compared
+   * @return a negative integer, zero, or a positive integer as this object is less than, equal to,
+   *         or greater than the specified object.
+   * @exception java.lang.ClassCastException - if the specified object's type prevents it from being
+   *            compared to this Object.
-  
+
-  
+
-      throw new ClassCastException(LocalizedStrings.InternalDistributedMember_INTERNALDISTRIBUTEDMEMBERCOMPARETO_COMPARISON_BETWEEN_DIFFERENT_CLASSES.toLocalizedString());
-    InternalDistributedMember other = (InternalDistributedMember)o;
+      throw new ClassCastException(
+          LocalizedStrings.InternalDistributedMember_INTERNALDISTRIBUTEDMEMBERCOMPARETO_COMPARISON_BETWEEN_DIFFERENT_CLASSES
+              .toLocalizedString());
+    InternalDistributedMember other = (InternalDistributedMember) o;
-    }
-    else if (myAddr == null) {
+    } else if (myAddr == null) {
-    }
-    else if (otherAddr == null)
+    } else if (otherAddr == null)
-    }
-    else if (other.name == null) {
+    } else if (other.name == null) {
-    }
-    else {
+    } else {
-    }
-    else if (other.uniqueTag == null) {
+    } else if (other.uniqueTag == null) {
-    }
-    else {
+    } else {
-    
-    if (checkNetMembersIfEqual
-        && this.netMbr != null && other.netMbr != null) {
+
+    if (checkNetMembersIfEqual && this.netMbr != null && other.netMbr != null) {
-    
+
-  public boolean equals(Object obj)
-  {
+  public boolean equals(Object obj) {
-    return compareTo((InternalDistributedMember)obj) == 0;
+    return compareTo((InternalDistributedMember) obj) == 0;
-  public int hashCode()
-  {
+  public int hashCode() {
-     result = result + netMbr.getInetAddress().hashCode();
+    result = result + netMbr.getInetAddress().hashCode();
-  private String shortName(String hostname)
-  {
+  private String shortName(String hostname) {
-  public String toString()
-  {
+  public String toString() {
-        if (add.isMulticastAddress())
-          host = add.getHostAddress();
-        else {
-         // host = shortName(add.getHostName());
-          host = SocketCreator.resolve_dns? shortName(this.hostName) : this.hostName;
-        }
+      if (add.isMulticastAddress())
+        host = add.getHostAddress();
+      else {
+        // host = shortName(add.getHostName());
+        host = SocketCreator.resolve_dns ? shortName(this.hostName) : this.hostName;
+      }
-        case DistributionManager.NORMAL_DM_TYPE:
-  //        vmStr = ":local"; // let this be silent
-          break;
-        case DistributionManager.LOCATOR_DM_TYPE:
-          vmStr = ":locator";
-          break;
-        case DistributionManager.ADMIN_ONLY_DM_TYPE:
-          vmStr = ":admin";
-          break;
-        case DistributionManager.LONER_DM_TYPE:
-          vmStr = ":loner";
-          break;
-        default:
-          vmStr = ":<unknown:" + vmKind + ">";
-          break;
+          case DistributionManager.NORMAL_DM_TYPE:
+            // vmStr = ":local"; // let this be silent
+            break;
+          case DistributionManager.LOCATOR_DM_TYPE:
+            vmStr = ":locator";
+            break;
+          case DistributionManager.ADMIN_ONLY_DM_TYPE:
+            vmStr = ":admin";
+            break;
+          case DistributionManager.LONER_DM_TYPE:
+            vmStr = ":loner";
+            break;
+          default:
+            vmStr = ":<unknown:" + vmKind + ">";
+            break;
-//      if (dcPort > 0 && vmKind != DistributionManager.LONER_DM_TYPE) {
-//        sb.append("/");
-//        sb.append(Integer.toString(dcPort));
-//      }
+      // if (dcPort > 0 && vmKind != DistributionManager.LONER_DM_TYPE) {
+      // sb.append("/");
+      // sb.append(Integer.toString(dcPort));
+      // }
-        sb.append("(version:").append(Version.toString(this.version))
-            .append(')');
+        sb.append("(version:").append(Version.toString(this.version)).append(')');
-      
-//      if (netMbr instanceof GMSMember) {
-//        sb.append("(UUID=").append(((GMSMember)netMbr).getUUID()).append(")");
-//      }
+
+      // if (netMbr instanceof GMSMember) {
+      // sb.append("(UUID=").append(((GMSMember)netMbr).getUUID()).append(")");
+      // }
-    
+
-    if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-    if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-    if (this.isPartial) flags |= PARTIAL_ID_BIT;
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    if (this.isPartial)
+      flags |= PARTIAL_ID_BIT;
-    out.writeByte((byte)(flags & 0xff));
+    out.writeByte((byte) (flags & 0xff));
-    DataSerializer.writeString(this.durableClientAttributes==null ? "" : this.durableClientAttributes.getId(), out);
-    DataSerializer.writeInteger(Integer.valueOf(this.durableClientAttributes==null ? 300 : this.durableClientAttributes.getTimeout()), out);
+    DataSerializer.writeString(
+        this.durableClientAttributes == null ? "" : this.durableClientAttributes.getId(), out);
+    DataSerializer.writeInteger(
+        Integer.valueOf(
+            this.durableClientAttributes == null ? 300 : this.durableClientAttributes.getTimeout()),
+        out);
-    * For Externalizable
-    *
-    * @see Externalizable
-    */
-   public void readExternal(ObjectInput in)
-   throws IOException, ClassNotFoundException {
-     int len = in.readInt(); // IPv6 compatible
-     byte addr[] = new byte[len];
-     in.readFully(addr);
-     InetAddress inetAddr = InetAddress.getByAddress(addr);
-     int port = in.readInt();
-     
-     this.hostName = DataSerializer.readString(in);
+   * For Externalizable
+   *
+   * @see Externalizable
+   */
+  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    int len = in.readInt(); // IPv6 compatible
+    byte addr[] = new byte[len];
+    in.readFully(addr);
+    InetAddress inetAddr = InetAddress.getByAddress(addr);
+    int port = in.readInt();
-     int flags = in.readUnsignedByte();
-     boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
-     boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
-     this.isPartial = (flags & PARTIAL_ID_BIT) != 0;
-     
-     this.dcPort = in.readInt();
-     this.vmPid = in.readInt();
-     this.vmKind = in.readInt();
-     this.vmViewId = in.readInt();
-     this.groups = DataSerializer.readStringArray(in);
+    this.hostName = DataSerializer.readString(in);
-     this.name = DataSerializer.readString(in);
-     this.uniqueTag = DataSerializer.readString(in);
-     String durableId = DataSerializer.readString(in);
-     int durableTimeout = DataSerializer.readInteger(in).intValue();
-     this.durableClientAttributes = new DurableClientAttributes(durableId, durableTimeout);
+    int flags = in.readUnsignedByte();
+    boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
+    boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
+    this.isPartial = (flags & PARTIAL_ID_BIT) != 0;
-     readVersion(flags, in);
+    this.dcPort = in.readInt();
+    this.vmPid = in.readInt();
+    this.vmKind = in.readInt();
+    this.vmViewId = in.readInt();
+    this.groups = DataSerializer.readStringArray(in);
-     netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, version,
-         new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups, durableClientAttributes));
-     if (this.version >= Version.GFE_90.ordinal()) {
-       try {
-         netMbr.readAdditionalData(in);
-       } catch (java.io.EOFException e) {
-         // old version quand-meme
-       }
-     }
+    this.name = DataSerializer.readString(in);
+    this.uniqueTag = DataSerializer.readString(in);
+    String durableId = DataSerializer.readString(in);
+    int durableTimeout = DataSerializer.readInteger(in).intValue();
+    this.durableClientAttributes = new DurableClientAttributes(durableId, durableTimeout);
-     Assert.assertTrue(this.vmKind > 0);
-   }
+    readVersion(flags, in);
+
+    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, version,
+        new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups,
+            durableClientAttributes));
+    if (this.version >= Version.GFE_90.ordinal()) {
+      try {
+        netMbr.readAdditionalData(in);
+      } catch (java.io.EOFException e) {
+        // old version quand-meme
+      }
+    }
+
+    Assert.assertTrue(this.vmKind > 0);
+  }
-  
-  
+
+
-    //Assert.assertTrue(vmKind > 0);
+    // Assert.assertTrue(vmKind > 0);
-    //       then bump Connection.HANDSHAKE_VERSION since an
-    //       instance of this class is sent during Connection handshake.
+    // then bump Connection.HANDSHAKE_VERSION since an
+    // instance of this class is sent during Connection handshake.
-    if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-    if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-    if (this.isPartial) flags |= PARTIAL_ID_BIT;
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    if (this.isPartial)
+      flags |= PARTIAL_ID_BIT;
-    out.writeByte((byte)(flags & 0xff));
-    
+    out.writeByte((byte) (flags & 0xff));
+
-    } else {  // added in 6.5 for unique identifiers in P2P
+    } else { // added in 6.5 for unique identifiers in P2P
-    DataSerializer.writeString(this.durableClientAttributes==null ? "" : this.durableClientAttributes.getId(), out);
-    DataSerializer.writeInteger(Integer.valueOf(this.durableClientAttributes==null ? 300 : this.durableClientAttributes.getTimeout()), out);
+    DataSerializer.writeString(
+        this.durableClientAttributes == null ? "" : this.durableClientAttributes.getId(), out);
+    DataSerializer.writeInteger(
+        Integer.valueOf(
+            this.durableClientAttributes == null ? 300 : this.durableClientAttributes.getTimeout()),
+        out);
-      Assert.assertTrue(vmKind > 0);
+    Assert.assertTrue(vmKind > 0);
-//    Assert.assertTrue(getPort() > 0);
-//    if (this.getPort() == 0) {
-//      InternalDistributedSystem.getLoggerI18n().warning(LocalizedStrings.DEBUG,
-//          "Serializing ID with zero port", new Exception("Stack trace"));
-//    }
+    // Assert.assertTrue(getPort() > 0);
+    // if (this.getPort() == 0) {
+    // InternalDistributedSystem.getLoggerI18n().warning(LocalizedStrings.DEBUG,
+    // "Serializing ID with zero port", new Exception("Stack trace"));
+    // }
-    //       then bump Connection.HANDSHAKE_VERSION since an
-    //       instance of this class is sent during Connection handshake.
+    // then bump Connection.HANDSHAKE_VERSION since an
+    // instance of this class is sent during Connection handshake.
-    if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-    if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-    if (this.isPartial) flags |= PARTIAL_ID_BIT;
-    out.writeByte((byte)(flags & 0xff));
-    
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    if (this.isPartial)
+      flags |= PARTIAL_ID_BIT;
+    out.writeByte((byte) (flags & 0xff));
+
-    } else {  // added in 6.5 for unique identifiers in P2P
+    } else { // added in 6.5 for unique identifiers in P2P
-    DataSerializer.writeString(this.durableClientAttributes==null ? "" : this.durableClientAttributes.getId(), out);
-    DataSerializer.writeInteger(Integer.valueOf(this.durableClientAttributes==null ? 300 : this.durableClientAttributes.getTimeout()), out);
- 
+    DataSerializer.writeString(
+        this.durableClientAttributes == null ? "" : this.durableClientAttributes.getId(), out);
+    DataSerializer.writeInteger(
+        Integer.valueOf(
+            this.durableClientAttributes == null ? 300 : this.durableClientAttributes.getTimeout()),
+        out);
+
-  
-  public void fromData(DataInput in)
-  throws IOException, ClassNotFoundException {
+
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  
-  public void fromDataPre_GFE_9_0_0_0(DataInput in)
-  throws IOException, ClassNotFoundException {
+
+  public void fromDataPre_GFE_9_0_0_0(DataInput in) throws IOException, ClassNotFoundException {
-    
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
+
+    this.hostName = SocketCreator.resolve_dns
+        ? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
-    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid,
-        this.vmKind, this.vmViewId, this.name, this.groups, this.durableClientAttributes);
+    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid, this.vmKind,
+        this.vmViewId, this.name, this.groups, this.durableClientAttributes);
-//    Assert.assertTrue(getPort() > 0);
+    // Assert.assertTrue(getPort() > 0);
-  public void fromDataPre_GFE_7_1_0_0(DataInput in)  throws IOException, ClassNotFoundException {
+  public void fromDataPre_GFE_7_1_0_0(DataInput in) throws IOException, ClassNotFoundException {
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
+    this.hostName = SocketCreator.resolve_dns
+        ? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
-    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid,
-        this.vmKind, this.vmViewId, this.name, this.groups, this.durableClientAttributes);
-    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, 
+    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid, this.vmKind,
+        this.vmViewId, this.name, this.groups, this.durableClientAttributes);
+    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord,
-   public static InternalDistributedMember readEssentialData(DataInput in)
-     throws IOException, ClassNotFoundException {
-     final InternalDistributedMember mbr = new InternalDistributedMember();
-     mbr._readEssentialData(in);
-     return mbr;
-   }
-   
-   private void _readEssentialData(DataInput in)
-     throws IOException, ClassNotFoundException {
-     this.isPartial = true;
-     InetAddress inetAddr = DataSerializer.readInetAddress(in);
-     int port = in.readInt();
+  public static InternalDistributedMember readEssentialData(DataInput in)
+      throws IOException, ClassNotFoundException {
+    final InternalDistributedMember mbr = new InternalDistributedMember();
+    mbr._readEssentialData(in);
+    return mbr;
+  }
-     this.hostName = SocketCreator.resolve_dns? SocketCreator.getHostName(inetAddr) : inetAddr.getHostAddress();
+  private void _readEssentialData(DataInput in) throws IOException, ClassNotFoundException {
+    this.isPartial = true;
+    InetAddress inetAddr = DataSerializer.readInetAddress(in);
+    int port = in.readInt();
-     int flags = in.readUnsignedByte();
-     boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
-     boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
+    this.hostName =
+        SocketCreator.resolve_dns ? SocketCreator.getHostName(inetAddr) : inetAddr.getHostAddress();
-     this.vmKind = in.readUnsignedByte();
-     
+    int flags = in.readUnsignedByte();
+    boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
+    boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
-     if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
-       this.uniqueTag = DataSerializer.readString(in);
-     } else {
-       String str = DataSerializer.readString(in);
-       if (str != null) { // backward compatibility from earlier than 6.5
-         this.vmViewId = Integer.parseInt(str);
-       }
-     }
-
-     this.name = DataSerializer.readString(in);
-
-     MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid,
-         this.vmKind, this.vmViewId, this.name, this.groups, this.durableClientAttributes);
-     netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, 
-         InternalDataSerializer.getVersionForDataStream(in).ordinal(), attr);
-
-     synchPayload();
-
-     if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GFE_90)>=0) {
-       netMbr.readAdditionalData(in);
-     }
-   }
+    this.vmKind = in.readUnsignedByte();
-   public void writeEssentialData(DataOutput out) throws IOException {
-     Assert.assertTrue(vmKind > 0);
-     DataSerializer.writeInetAddress(getInetAddress(), out);
-     out.writeInt(getPort());
+    if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
+      this.uniqueTag = DataSerializer.readString(in);
+    } else {
+      String str = DataSerializer.readString(in);
+      if (str != null) { // backward compatibility from earlier than 6.5
+        this.vmViewId = Integer.parseInt(str);
+      }
+    }
-     int flags = 0;
-     if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-     if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-     flags |= PARTIAL_ID_BIT;
-     out.writeByte((byte)(flags & 0xff));
-     
-//     out.writeInt(dcPort);
-     out.writeByte(vmKind);
+    this.name = DataSerializer.readString(in);
-     if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
-       DataSerializer.writeString(this.uniqueTag, out);
-     } else {  // added in 6.5 for unique identifiers in P2P
-       DataSerializer.writeString(String.valueOf(this.vmViewId), out);
-     }
-     // write name last to fix bug 45160
-     DataSerializer.writeString(this.name, out);
+    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid, this.vmKind,
+        this.vmViewId, this.name, this.groups, this.durableClientAttributes);
+    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord,
+        InternalDataSerializer.getVersionForDataStream(in).ordinal(), attr);
-     if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GFE_90)>=0) {
-       netMbr.writeAdditionalData(out);
-     }
-   }
+    synchPayload();
+
+    if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GFE_90) >= 0) {
+      netMbr.readAdditionalData(in);
+    }
+  }
+
+
+  public void writeEssentialData(DataOutput out) throws IOException {
+    Assert.assertTrue(vmKind > 0);
+    DataSerializer.writeInetAddress(getInetAddress(), out);
+    out.writeInt(getPort());
+
+    int flags = 0;
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    flags |= PARTIAL_ID_BIT;
+    out.writeByte((byte) (flags & 0xff));
+
+    // out.writeInt(dcPort);
+    out.writeByte(vmKind);
+
+    if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
+      DataSerializer.writeString(this.uniqueTag, out);
+    } else { // added in 6.5 for unique identifiers in P2P
+      DataSerializer.writeString(String.valueOf(this.vmViewId), out);
+    }
+    // write name last to fix bug 45160
+    DataSerializer.writeString(this.name, out);
+
+    if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GFE_90) >= 0) {
+      netMbr.writeAdditionalData(out);
+    }
+  }
-  public void setDirectChannelPort(int p)
-  {
+  public void setDirectChannelPort(int p) {
-  
+
-   * Set the membership port.  This is done in loner systems using
-   * client/server connection information to help form a unique ID
+   * Set the membership port. This is done in loner systems using client/server connection
+   * information to help form a unique ID
-  
+
-  
+
-    /*if (this.ipAddr == null) {
-      return "<null>";
-    }
-    else {
-      StringBuffer sb = new StringBuffer();
-      InetAddress addr = this.ipAddr.getIpAddress();
-      if(addr.isMulticastAddress()) {
-        sb.append(addr.getHostAddress());
-      } else {
-        appendShortName(addr.getHostName(), sb);
-      }
-      if (this.vmPid != 0) {
-        sb.append("(");
-        sb.append(this.vmPid);
-        sb.append(")");
-      }
-      sb.append(":");
-      sb.append(this.ipAddr.getPort());
-      return sb.toString();
-    }
-  }
+  /*
+   * if (this.ipAddr == null) { return "<null>"; } else { StringBuffer sb = new StringBuffer();
+   * InetAddress addr = this.ipAddr.getIpAddress(); if(addr.isMulticastAddress()) {
+   * sb.append(addr.getHostAddress()); } else { appendShortName(addr.getHostName(), sb); } if
+   * (this.vmPid != 0) { sb.append("("); sb.append(this.vmPid); sb.append(")"); } sb.append(":");
+   * sb.append(this.ipAddr.getPort()); return sb.toString(); } }
+   * 
+   * // Helper method for getId()... copied from IpAddress. private void appendShortName(String
+   * hostname, StringBuffer sb) { if (hostname == null) return; int index = hostname.indexOf('.');
+   * if(index > 0 && !Character.isDigit(hostname.charAt(0))) { sb.append(hostname.substring(0,
+   * index)); } else { sb.append(hostname); } }
+   */
-  // Helper method for getId()... copied from IpAddress.
-  private void appendShortName(String hostname, StringBuffer sb) {
-    if (hostname == null) return;
-    int index = hostname.indexOf('.');
-    if(index > 0 && !Character.isDigit(hostname.charAt(0))) {
-      sb.append(hostname.substring(0, index));
-    } else {
-      sb.append(hostname);
-    }
-  }*/
-  
-  
+
-  
+
-  
-    // ipaddr:  1 byte length + 4 bytes (IPv4) or 16 bytes (IPv6)
-    if (netMbr.getInetAddress() instanceof Inet4Address){
+
+    // ipaddr: 1 byte length + 4 bytes (IPv4) or 16 bytes (IPv6)
+    if (netMbr.getInetAddress() instanceof Inet4Address) {
-    
-    // port:  4 bytes
+
+    // port: 4 bytes
-    //vmKind: 1 byte
+    // vmKind: 1 byte
-    
-    // viewID:  String(1+1+numchars)
-    size += (2+ String.valueOf(this.vmViewId).length());
-    
+
+    // viewID: String(1+1+numchars)
+    size += (2 + String.valueOf(this.vmViewId).length());
+
-    
+
-  
+
-    
+
-      InternalDistributedMember other = ((InternalDistributedMemberWrapper)obj).mbr;
+      InternalDistributedMember other = ((InternalDistributedMemberWrapper) obj).mbr;
-    }        
+    }

GEODE-3436: revert recent refactoring of GFSH commands

Revert "GEODE-3264: Refactoring MemberCommands"
This reverts commit d27f8b956de7d9c5d95ebdc68dfc67ee8b2d7b51.

Revert "GEODE-3259: Refactoring DurableClientCommands"
This reverts commit 440c87f81fab96f9ce38a2d53ded75e5fe8390d7.

Revert "GEODE-3254: Refactoring ConfigCommands"
This reverts commit 97c4e9a59f17c7bc914e39dd048b0a4cd96293c4.

Revert "GEODE-3262: Refactoring IndexCommands"
This reverts commit ed293e817e547fb5ecd399bf4ba10d694af51e0a.

Revert "GEODE-3260: Refactoring FunctionCommands"
This reverts commit 90f5440de8ec747f301a309a0a34101e8defcd29.

Revert "GEODE-3258: Refactoring DiskStoreCommands"
This reverts commit 5d6cad7755ec3c4fe931e3d0f8e89fb181038543.

Revert "GEODE-3337: Refactoring LauncherLifecycleCommandsDUnitTest"
This reverts commit 210ff9f15460c993f2bf7fd682d50ee65462cd23.

Revert "GEODE-3265: Refactoring MiscellaneousCommands"
This reverts commit 63169699e933f6e0fdd90b95ed039e4e3c92c32c.

Revert "GEODE-3261: Refactoring GfshHelpCommands"
This reverts commit cf91426692349d0c81ce77394935576d9cc336e8.

Revert "GEODE-3267: Refactoring QueueCommands"
This reverts commit fd47ed660168864a6f81b2a4cd7dbceebc99a282.

Revert "GEODE-3270: Refactoring (renaming) StatusCommands"
This reverts commit 359e3fff6482ecfb375939d387f4dad3a636246b.

Revert "GEODE-3267: Refactoring QueueCommands - updated based on feedback"
This reverts commit 957d583e54dc34c029885f32a54f0b25a3ac1094.

Revert "GEODE-3268: Refactoring RegionCommands"
This reverts commit 64de3b69c2aecb4930bcfd0a1161569b1d5fda89.

Revert "GEODE-3266: Refactoring PDXCommands"
This reverts commit 67185abcdd68b908dea6888cb94286b8aa9ea49f.

Revert "GEODE-3257: Refactoring DeployCommands"
This reverts commit 9d967446a44a78b612f605b6a8f8eedcfc625b3a.

Revert "GEODE-3255: Refactor CreateAlterDestroyRegionCommands and tests"
This reverts commit 756efe77c86bb03ac9984655e7bd040659e85890.

Revert "GEODE-3230: Cleaning up unused (Cli)Strings"
This reverts commit a7f29525df2981c1c99abac96ea83cb965295970.

This closes #711

-
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.TreeSet;
+import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.management.internal.cli.domain.RegionInformation;
+import org.apache.geode.management.internal.cli.functions.GetRegionsFunction;
+import org.apache.geode.management.internal.cli.result.CompositeResultData.SectionResultData;
-import org.apache.geode.security.ResourcePermission;
+import org.apache.geode.security.ResourcePermission.Operation;
+import org.apache.geode.security.ResourcePermission.Resource;
-public class DescribeRegionCommand implements GfshCommand {
+/**
+ * Class containing implementation of commands based on region:
+ * <ul>
+ * <li>list region
+ * <li>describe region
+ * </ul>
+ * 
+ * @since GemFire 7.0
+ */
+public class RegionCommands implements GfshCommand {
+  private static final GetRegionsFunction getRegionsFunction = new GetRegionsFunction();
+  @CliCommand(value = {CliStrings.LIST_REGION}, help = CliStrings.LIST_REGION__HELP)
+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_REGION)
+  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.READ)
+  public Result listRegion(
+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
+          optionContext = ConverterHint.MEMBERGROUP,
+          help = CliStrings.LIST_REGION__GROUP__HELP) String[] group,
+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},
+          optionContext = ConverterHint.MEMBERIDNAME,
+          help = CliStrings.LIST_REGION__MEMBER__HELP) String[] memberNameOrId) {
+    Result result = null;
+    try {
+      Set<RegionInformation> regionInfoSet = new LinkedHashSet<>();
+      ResultCollector<?, ?> rc;
+
+      Set<DistributedMember> targetMembers = CliUtil.findMembers(group, memberNameOrId);
+
+      if (targetMembers.isEmpty()) {
+        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+      }
+
+      TabularResultData resultData = ResultBuilder.createTabularResultData();
+      rc = CliUtil.executeFunction(getRegionsFunction, null, targetMembers);
+
+      ArrayList<?> resultList = (ArrayList<?>) rc.getResult();
+
+      if (resultList != null) {
+
+        for (Object resultObj : resultList) {
+          if (resultObj != null) {
+            if (resultObj instanceof Object[]) {
+              Object[] resultObjectArray = (Object[]) resultObj;
+              for (Object regionInfo : resultObjectArray) {
+                if (regionInfo instanceof RegionInformation) {
+                  regionInfoSet.add((RegionInformation) regionInfo);
+                }
+              }
+            }
+          }
+        }
+
+        Set<String> regionNames = new TreeSet<>();
+
+        for (RegionInformation regionInfo : regionInfoSet) {
+          regionNames.add(regionInfo.getName());
+          Set<String> subRegionNames = regionInfo.getSubRegionNames();
+
+          regionNames.addAll(subRegionNames);
+        }
+
+        for (String regionName : regionNames) {
+          resultData.accumulate("List of regions", regionName);
+        }
+
+        if (!regionNames.isEmpty()) {
+          result = ResultBuilder.buildResult(resultData);
+
+        } else {
+          result = ResultBuilder.createInfoResult(CliStrings.LIST_REGION__MSG__NOT_FOUND);
+        }
+      }
+    } catch (FunctionInvocationTargetException e) {
+      result = ResultBuilder.createGemFireErrorResult(CliStrings
+          .format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.LIST_REGION));
+    } catch (Exception e) {
+      result = ResultBuilder
+          .createGemFireErrorResult(CliStrings.LIST_REGION__MSG__ERROR + " : " + e.getMessage());
+    }
+    return result;
+  }
+
-  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,
-      operation = ResourcePermission.Operation.READ)
+  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.READ)
-        CompositeResultData.SectionResultData regionSection = crd.addSection();
+        SectionResultData regionSection = crd.addSection();
-            writeFixedPartitionAttributesToTable(table, fpaList, member, memberNameAdded);
+            writeFixedPartitionAttributesToTable(table, "", fpaList, member, memberNameAdded);
-        String type;
+        String type, memName;
-  private void writeFixedPartitionAttributesToTable(TabularResultData table,
-      List<FixedPartitionAttributesInfo> fpaList, String member, boolean isMemberNameAdded) {
-    if (fpaList == null) {
-      return;
+  private boolean writeFixedPartitionAttributesToTable(TabularResultData table,
+      String attributeType, List<FixedPartitionAttributesInfo> fpaList, String member,
+      boolean isMemberNameAdded) {
+
+    if (fpaList != null) {
+      boolean isTypeAdded = false;
+      final String blank = "";
+
+      Iterator<FixedPartitionAttributesInfo> fpaIter = fpaList.iterator();
+      String type, memName;
+
+      while (fpaIter.hasNext()) {
+        FixedPartitionAttributesInfo fpa = fpaIter.next();
+        StringBuilder fpaBuilder = new StringBuilder();
+        fpaBuilder.append(fpa.getPartitionName());
+        fpaBuilder.append(',');
+
+        if (fpa.isPrimary()) {
+          fpaBuilder.append("Primary");
+        } else {
+          fpaBuilder.append("Secondary");
+        }
+        fpaBuilder.append(',');
+        fpaBuilder.append(fpa.getNumBuckets());
+
+        if (!isTypeAdded) {
+          type = attributeType;
+          isTypeAdded = true;
+        } else {
+          type = blank;
+        }
+
+        if (!isMemberNameAdded) {
+          memName = member;
+          isMemberNameAdded = true;
+        } else {
+          memName = blank;
+        }
+
+        writeAttributeToTable(table, memName, type, "Fixed Partition", fpaBuilder.toString());
+      }
-    boolean isTypeAdded = false;
-    final String blank = "";
-    String memName;
-
-    for (FixedPartitionAttributesInfo fpa : fpaList) {
-      StringBuilder fpaBuilder = new StringBuilder();
-      fpaBuilder.append(fpa.getPartitionName());
-      fpaBuilder.append(',');
-
-      if (fpa.isPrimary()) {
-        fpaBuilder.append("Primary");
-      } else {
-        fpaBuilder.append("Secondary");
-      }
-      fpaBuilder.append(',');
-      fpaBuilder.append(fpa.getNumBuckets());
-
-      if (!isTypeAdded) {
-        isTypeAdded = true;
-      }
-
-      if (!isMemberNameAdded) {
-        memName = member;
-        isMemberNameAdded = true;
-      } else {
-        memName = blank;
-      }
-      writeAttributeToTable(table, memName, "", "Fixed Partition", fpaBuilder.toString());
-    }
+    return isMemberNameAdded;
-  private void writeAttributeToTable(TabularResultData table, String member, String attributeType,
+  public void writeAttributeToTable(TabularResultData table, String member, String attributeType,
+
+
+
+  public void addChildSection(SectionResultData parentSection, Map<String, String> map,
+      String header) {
+    if (!map.isEmpty()) {
+      Set<String> attributes = map.keySet();
+      SectionResultData section = parentSection.addSection();
+      section.setHeader(header);
+      for (String attribute : attributes) {
+        section.addData(attribute, map.get(attribute));
+      }
+    }
+  }

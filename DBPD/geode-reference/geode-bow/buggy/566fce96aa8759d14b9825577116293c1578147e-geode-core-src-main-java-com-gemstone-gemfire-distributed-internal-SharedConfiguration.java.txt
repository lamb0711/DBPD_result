GEODE-1255: Add test coverage for using a custom log4j2.xml with Geode

* refactor launcher integration tests (rename files, use TemporaryFolder)
* refactor cluster config tests (use TemporaryFolder)
* change several additional tests to use TemporaryFolder
* add better support for TemporaryFolder usage to HeadlessGfsh
* alter HeadlessGfsh tests to use TemporaryFolder
* rescope variables and methods to private where possible
* fixup file formatting
* prevent eating of exceptions
* remove incomplete or useless javadocs
* rename LocatorJUnitTest test methods from TRAC #s to meaningful names

-/*********
- * 
- *
- */
-@SuppressWarnings("deprecation")
+@SuppressWarnings({ "deprecation", "unchecked" })
-  static class JarFileFilter implements FilenameFilter {
-    @Override
-    public boolean accept(File dir, String name) {
-      return name.endsWith(".jar");
-    }
-  }
-  /****
+  /**
-  public static final String CLUSTER_CONFIG_DISK_STORE_NAME = "cluster_config";
-  public static String CONFIG_DIR_PATH;//FilenameUtils.concat(System.getProperty("user.dir"), CONFIG_ARTIFACTS_DIR_NAME);
+  private static final String CLUSTER_CONFIG_DISK_STORE_NAME = "cluster_config";
-
-  /***
+  /**
-  public static final String SHARED_CONFIG_LOCK_SERVICE_NAME = "__CLUSTER_CONFIG_LS";
+  private static final String SHARED_CONFIG_LOCK_SERVICE_NAME = "__CLUSTER_CONFIG_LS";
-  /***
+  /**
-  /***
+  /**
-  public static final String CONFIG_REGION_NAME = "_ConfigurationRegion";
+  private static final String CONFIG_REGION_NAME = "_ConfigurationRegion";
-
-  public String CONFIG_DISK_DIR_NAME;
-  public String CONFIG_DISK_DIR_PATH;;
+  private final String configDirPath;
+  private final String configDiskDirName;
+  private final String configDiskDirPath;;
-
-  /****
+  /**
-   * @return DistributedLockService 
-
-  /**
-   * Returns an array containing the names of the subdirectories in a given directory
-   * @param path Path of the directory whose subdirectories are listed
-   * @return String[] names of first level subdirectories, null if no subdirectories are found or if the path is incorrect
-   */
-  private static String[] getSubdirectories(String path) {
-    File directory = new File(path);
-    return directory.list(DirectoryFileFilter.INSTANCE);
-  }
-
-    CONFIG_DISK_DIR_NAME = CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
+    this.configDiskDirName = CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
-    CONFIG_DISK_DIR_PATH = FilenameUtils.concat(clusterConfigDir, CONFIG_DISK_DIR_NAME);
-    CONFIG_DIR_PATH = FilenameUtils.concat(clusterConfigDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+    this.configDiskDirPath = FilenameUtils.concat(clusterConfigDir, this.configDiskDirName);
+    configDirPath = FilenameUtils.concat(clusterConfigDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
-  /*****
+  /**
-   * @param jarNames
-   * @param jarBytes
-   * @param groups
-        Configuration configuration = (Configuration) configRegion.get(group);
+        Configuration configuration = configRegion.get(group);
-        String groupDir = FilenameUtils.concat(CONFIG_DIR_PATH, group);
+        String groupDir = FilenameUtils.concat(configDirPath, group);
-
-  /***
+  /**
-   * @param xmlEntity
-   * @param groups
-   * @throws Exception
-  /**
-   * Create a {@link Document} using
-   * {@link XmlUtils#createDocumentFromXml(String)} and if the version attribute
-   * is not equal to the current version then update the XML to the current
-   * schema and return the document.
-   * 
-   * @param xmlContent
-   *          XML content to load and upgrade.
-   * @return {@link Document} from xmlContent.
-   * @throws IOException 
-   * @throws ParserConfigurationException 
-   * @throws SAXException 
-   * @throws XPathExpressionException 
-   * @since 8.1
-   */
-  // UnitTest SharedConfigurationJUnitTest.testCreateAndUpgradeDocumentFromXml
-  static Document createAndUpgradeDocumentFromXml(final String xmlContent) throws SAXException, ParserConfigurationException, IOException, XPathExpressionException {
-    Document doc = XmlUtils.createDocumentFromXml(xmlContent);
-    if (!CacheXml.VERSION_LATEST.equals(XmlUtils.getAttribute(doc.getDocumentElement(), CacheXml.VERSION, CacheXml.GEODE_NAMESPACE))) {
-      doc = XmlUtils.upgradeSchema(doc, CacheXml.GEODE_NAMESPACE, CacheXml.LATEST_SCHEMA_LOCATION, CacheXml.VERSION_LATEST);
-    }
-    return doc;
-  }
-
-
-  /*****
+  /**
-   * @throws Exception 
-
-  public boolean lockSharedConfiguration() {
-    return sharedConfigLockingService.lock(SHARED_CONFIG_LOCK_NAME, -1, -1);
-  }
-
-  public void unlockSharedConfiguration() {
-    sharedConfigLockingService.unlock(SHARED_CONFIG_LOCK_NAME);
-  }
-
-  /****
+  /**
-   * @param configRequest
-   * @return ConfigurationResponse
-   * @throws Exception 
-  public ConfigurationResponse createConfigurationReponse(ConfigurationRequest configRequest) throws Exception {
+  public ConfigurationResponse createConfigurationReponse(final ConfigurationRequest configRequest) throws Exception {
-  /***
+  /**
-  /*****
+  /**
-   * @param xmlEntity 
-   * @param groups
-   * @throws Exception
-  public void deleteXmlEntity (XmlEntity xmlEntity, String[] groups) throws Exception {
+  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) throws Exception {
-  public void modifyCacheAttributes(XmlEntity xmlEntity, String [] groups) throws Exception {
+  public void modifyCacheAttributes(final XmlEntity xmlEntity, String [] groups) throws Exception {
-  /***
-   * Only to be used for clean up in DUnits. 
+  /**
+   * For tests only. TODO: clean this up and remove from production code
+   * <p/>
+   * Throws {@code AssertionError} wrapping any exception thrown by operation.
-  public void destroySharedConfiguration() {
-    Region<String, Configuration> configRegion;
+  public void destroySharedConfiguration_forTestsOnly() {
-      configRegion = getConfigurationRegion();
+      Region<String, Configuration> configRegion = getConfigurationRegion();
-        File file = new File(CONFIG_DISK_DIR_PATH);
+        File file = new File(configDiskDirPath);
-      FileUtils.deleteDirectory(new File(CONFIG_DIR_PATH));
-    } catch (IOException e) {
-      e.printStackTrace();
-    } catch (Exception e1) {
-      e1.printStackTrace();
+      FileUtils.deleteDirectory(new File(configDirPath));
+    } catch (Exception exception) {
+      throw new AssertionError(exception);
-            String groupDirPath = FilenameUtils.concat(CONFIG_DIR_PATH, group);
+            String groupDirPath = FilenameUtils.concat(configDirPath, group);
+
+  public Configuration getConfiguration(String groupName) throws Exception {
+    Configuration configuration = getConfigurationRegion().get(groupName);
+    return configuration;
+  }
-  /***
-   * Gets the Jar from existing locators in the system
-   * @throws Exception 
+  public Map<String, Configuration> getEntireConfiguration() throws Exception {
+    Set<String> keys = getConfigurationRegion().keySet();
+    return getConfigurationRegion().getAll(keys);
+  }
+
+  /**
+   * Returns the path of Shared configuration directory
+   * @return {@link String}  path of the shared configuration directory
-  public void getAllJarsFromOtherLocators() throws Exception {
+  public String getSharedConfigurationDirPath() {
+    return configDirPath;
+  }
+
+  /**
+   * Gets the current status of the SharedConfiguration
+   * If the status is started , it determines if the shared configuration is waiting for new configuration on
+   * other locators
+   * @return {@link SharedConfigurationStatus}
+   */
+  public SharedConfigurationStatus getStatus() {
+    SharedConfigurationStatus scStatus = this.status.get();
+    if (scStatus == SharedConfigurationStatus.STARTED) {
+      PersistentMemberManager pmm = cache.getPersistentMemberManager();
+      Map<String, Set<PersistentMemberID>> waitingRegions = pmm.getWaitingRegions();
+      if (!waitingRegions.isEmpty()) {
+        this.status.compareAndSet(SharedConfigurationStatus.STARTED, SharedConfigurationStatus.WAITING);
+        Set<PersistentMemberID> persMemIds =  waitingRegions.get(Region.SEPARATOR_CHAR + CONFIG_REGION_NAME);
+        for (PersistentMemberID persMemId : persMemIds) {
+          newerSharedConfigurationLocatorInfo.add(new PersistentMemberPattern(persMemId));
+        }
+      }
+    }
+    return this.status.get();
+  }
+
+  /**
+   * Loads the
+   * @throws Exception
+   */
+  public void loadSharedConfigurationFromDisk() throws Exception {
+    Map<String, Configuration> sharedConfigurationMap = readSharedConfigurationFromDisk();
+    getConfigurationRegion().clear();
+    getConfigurationRegion().putAll(sharedConfigurationMap);
+  }
+
+  public void modifyProperties(final Properties properties, String[] groups) throws Exception {
+    if (groups == null) {
+      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+    }
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    for (String group : groups) {
+      Configuration configuration = configRegion.get(group);
+      if (configuration == null) {
+        configuration = new Configuration(group);
+      }
+      configuration.getGemfireProperties().putAll(properties);
+      configRegion.put(group, configuration);
+      writeConfig(configuration);
+    }
+  }
+
+  /**
+   * Removes the jar files from the shared configuration.
+   * @param jarNames Names of the jar files.
+   * @param groups Names of the groups which had the jar file deployed.
+   * @return true on success.
+   */
+  public boolean removeJars(final String[] jarNames, String[] groups){
+    boolean success = true;
+    try {
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      if (groups == null) {
+        Set<String> groupSet = configRegion.keySet();
+        groups = groupSet.toArray(new String[groupSet.size()]);
+      }
+      for (String group : groups) {
+        Configuration configuration = (Configuration) configRegion.get(group);
+        if (configuration != null) {
+          String dirPath = FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
+          removeJarFiles(dirPath, jarNames);
+        }
+      }
+      for (String group : groups) {
+        Configuration configuration = (Configuration) configRegion.get(group);
+        if (configuration != null) {
+          if (!configuration.getJarNames().isEmpty()) {
+            configuration.removeJarNames(jarNames);
+            configRegion.put(group, configuration);
+          }
+        }
+      }
+    } catch (Exception e) {
+      logger.info("Exception occurred while deleting the jar files", e);
+      success = false;
+    }
+    return success;
+  }
+
+  public void renameExistingSharedConfigDirectory() {
+    File configDirFile = new File(configDirPath);
+    if (configDirFile.exists()) {
+      String configDirFileName2 = CLUSTER_CONFIG_ARTIFACTS_DIR_NAME + new SimpleDateFormat("yyyyMMddhhmm").format(new Date()) + "." + System.nanoTime();
+      File configDirFile2 = new File(FilenameUtils.concat(configDirFileName2, configDirFileName2));
+      try {
+        FileUtils.moveDirectoryToDirectory(configDirFile, configDirFile2, true);
+      } catch (IOException e) {
+        logger.info(e);
+      }
+    }
+  }
+
+  /**
+   * Writes the contents of the {@link Configuration} to the file system
+   */
+  public void writeConfig(final Configuration configuration) throws Exception {
+    File configDir = new File(getSharedConfigurationDirPath());
+    if (!configDir.exists()) {
+      if (!configDir.mkdirs()) {
+        throw new IOException("Cannot create directory : " + getSharedConfigurationDirPath());
+      }
+    }
+    String dirPath = FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
+    File file = new File(dirPath);
+    if (!file.exists()) {
+      if (!file.mkdir()) {
+        throw new IOException("Cannot create directory : " + dirPath);
+      }
+    }
+
+    writeProperties(dirPath, configuration);
+    writeCacheXml(dirPath, configuration);
+  }
+
+  private boolean lockSharedConfiguration() {
+    return sharedConfigLockingService.lock(SHARED_CONFIG_LOCK_NAME, -1, -1);
+  }
+
+  private void unlockSharedConfiguration() {
+    sharedConfigLockingService.unlock(SHARED_CONFIG_LOCK_NAME);
+  }
+
+  /**
+   * Gets the Jar from existing locators in the system
+   */
+  private void getAllJarsFromOtherLocators() throws Exception {
-    @SuppressWarnings("unchecked")
-        String groupDirPath = FilenameUtils.concat(CONFIG_DIR_PATH, group);
+        String groupDirPath = FilenameUtils.concat(configDirPath, group);
-  public Configuration getConfiguration(String groupName) throws Exception {
-    Configuration configuration = (Configuration)getConfigurationRegion().get(groupName);
-    return configuration;
-  }
-
-  /*****
+  /**
-   * @return  {@link Region} ConfigurationRegion
-   * @throws Exception 
+   * @return {@link Region} ConfigurationRegion
-    @SuppressWarnings("unchecked")
-        File diskDir = new File(CONFIG_DISK_DIR_PATH);
+        File diskDir = new File(configDiskDirPath);
-            throw new IOException("Cannot create directory at " + CONFIG_DISK_DIR_PATH);
+            throw new IOException("Cannot create directory at " + configDiskDirPath);
+
+
+
-  public Map<String, Configuration> getEntireConfiguration() throws Exception {
-    Set<String> keys = getConfigurationRegion().keySet();
-    return getConfigurationRegion().getAll(keys);
-  }
-
-
-  /****
-   * Returns the path of Shared configuration directory
-   * @return {@link String}  path of the shared configuration directory
-   */
-  public String getSharedConfigurationDirPath() {
-    return CONFIG_DIR_PATH;
-  }
-
-
-  /*****
-   * Gets the current status of the SharedConfiguration
-   * If the status is started , it determines if the shared configuration is waiting for new configuration on 
-   * other locators
-   * @return {@link SharedConfigurationStatus}
-   */
-  public SharedConfigurationStatus getStatus() {
-    SharedConfigurationStatus scStatus = this.status.get();
-    if (scStatus == SharedConfigurationStatus.STARTED) {
-      PersistentMemberManager pmm = cache.getPersistentMemberManager();
-      Map<String, Set<PersistentMemberID>> waitingRegions = pmm.getWaitingRegions();
-      if (!waitingRegions.isEmpty()) {
-        this.status.compareAndSet(SharedConfigurationStatus.STARTED, SharedConfigurationStatus.WAITING);
-        Set<PersistentMemberID> persMemIds =  waitingRegions.get(Region.SEPARATOR_CHAR + CONFIG_REGION_NAME);
-        for (PersistentMemberID persMemId : persMemIds) {
-          newerSharedConfigurationLocatorInfo.add(new PersistentMemberPattern(persMemId));
-        }
-      }
-    }
-    return this.status.get();
-  }
-  /****
-   * Loads the 
-   * @throws Exception 
-   */
-  public void loadSharedConfigurationFromDisk() throws Exception {
-    Map<String, Configuration> sharedConfigurationMap = readSharedConfigurationFromDisk();
-    getConfigurationRegion().clear();
-    getConfigurationRegion().putAll(sharedConfigurationMap);
-  }
-
-  public void modifyProperties(Properties properties, String[] groups) throws Exception {
-    if (groups == null) {
-      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
-    }
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-      if (configuration == null) {
-        configuration = new Configuration(group);
-      } 
-      configuration.getGemfireProperties().putAll(properties);
-      configRegion.put(group, configuration);
-      writeConfig(configuration);
-    }
-  }
-
-  /*****
+  /**
-  private Configuration readConfiguration(String configName, String configDirectory) throws SAXException, ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
+  private Configuration readConfiguration(final String configName, final String configDirectory) throws SAXException, ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
-  /*****
+  /**
-  public Properties readProperties(String propertiesFilePath) throws IOException{
-
+  private Properties readProperties(final String propertiesFilePath) throws IOException {
-
-  /****
-   * Reads the "shared_config" directory and loads all the cache.xml , gemfire.properties and deployd jars information
+  /**
+   * Reads the "shared_config" directory and loads all the cache.xml, gemfire.properties and deployed jars information
-    String []subdirectoryNames = getSubdirectories(CONFIG_DIR_PATH);
+    String[] subdirectoryNames = getSubdirectories(configDirPath);
-        String fullpath = FilenameUtils.concat(CONFIG_DIR_PATH, subdirectoryName);
+        String fullpath = FilenameUtils.concat(configDirPath, subdirectoryName);
-
-
-  /****
+  /**
-
-  public void removeJarFiles (String dirPath, String[] jarNames) throws IOException {
+  private void removeJarFiles(final String dirPath, final String[] jarNames) throws IOException {
-  /****
-   * Removes the jar files from the shared configuration. 
-   * @param jarNames Names of the jar files.
-   * @param groups Names of the groups which had the jar file deployed.
-   * @return true on success.
-   */
-  public boolean removeJars(String []jarNames, String[] groups){
-    boolean success = true;
-    try {
-      Region<String, Configuration> configRegion = getConfigurationRegion();
-      if (groups == null) {
-        Set<String> groupSet = configRegion.keySet();
-        groups = groupSet.toArray(new String[groupSet.size()]);
-      }
-      for (String group : groups) {
-        Configuration configuration = (Configuration) configRegion.get(group);
-        if (configuration != null) {
-          String dirPath = FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
-          removeJarFiles(dirPath, jarNames);
-        }
-      }
-      for (String group : groups) {
-        Configuration configuration = (Configuration) configRegion.get(group);
-        if (configuration != null) {
-          if (!configuration.getJarNames().isEmpty()) {
-            configuration.removeJarNames(jarNames);
-            configRegion.put(group, configuration);
-          }
-        } 
-      }
-    } catch (Exception e) {
-      logger.info("Exception occurred while deleting the jar files", e);
-      success = false;
-    }
-    return success;
-  }
-
-  public void renameExistingSharedConfigDirectory() {
-    File configDirFile = new File(CONFIG_DIR_PATH);
-    if (configDirFile.exists()) {
-      String configDirFileName2 = CLUSTER_CONFIG_ARTIFACTS_DIR_NAME + new SimpleDateFormat("yyyyMMddhhmm").format(new Date()) + "." + System.nanoTime(); 
-      File configDirFile2 = new File(FilenameUtils.concat(configDirFileName2, configDirFileName2));
-      try {
-        FileUtils.moveDirectoryToDirectory(configDirFile, configDirFile2, true);
-      } catch (IOException e) {
-        logger.info(e);
-      }
-    } 
-  }
-  /***
+  /**
-   * @param dirPath Path of the directory in which the configuration is written
-   * @param configuration 
-   * @throws IOException 
-  private void writeCacheXml(String dirPath, Configuration configuration) throws IOException {
+  private void writeCacheXml(final String dirPath, final Configuration configuration) throws IOException {
-  /***
-   * Writes the contents of the {@link Configuration} to the file system
-   * @param configuration
-   * @throws Exception
-   */
-  public void writeConfig(Configuration configuration) throws Exception {
-    File configDir = new File(getSharedConfigurationDirPath());
-    if (!configDir.exists()) {
-      if (!configDir.mkdirs()) {
-        throw new IOException("Cannot create directory : " + getSharedConfigurationDirPath());
-      }
-    }
-    String dirPath = FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
-    File file = new File(dirPath);
-    if (!file.exists()) {
-      if (!file.mkdir()) {
-        throw new IOException("Cannot create directory : " + dirPath);
-      }
-    }
-    writeProperties(dirPath, configuration);
-    writeCacheXml(dirPath, configuration);
-  }
-
-  /*****
+  /**
-  private void writeJarFiles(String dirPath , String[] jarNames, byte[][] jarBytes) {
+  private void writeJarFiles(final String dirPath, final String[] jarNames, final byte[][] jarBytes) {
-  /****
+  /**
-   * @param dirPath
-   * @param configuration
-   * @throws IOException
-  private void writeProperties(String dirPath, Configuration configuration) throws IOException {
+  private void writeProperties(final String dirPath, final Configuration configuration) throws IOException {
+  /**
+   * Create a {@link Document} using
+   * {@link XmlUtils#createDocumentFromXml(String)} and if the version attribute
+   * is not equal to the current version then update the XML to the current
+   * schema and return the document.
+   *
+   * @param xmlContent XML content to load and upgrade.
+   * @return {@link Document} from xmlContent.
+   * @since 8.1
+   */
+  // UnitTest SharedConfigurationJUnitTest.testCreateAndUpgradeDocumentFromXml
+  static Document createAndUpgradeDocumentFromXml(final String xmlContent) throws SAXException, ParserConfigurationException, IOException, XPathExpressionException {
+    Document doc = XmlUtils.createDocumentFromXml(xmlContent);
+    if (!CacheXml.VERSION_LATEST.equals(XmlUtils.getAttribute(doc.getDocumentElement(), CacheXml.VERSION, CacheXml.GEODE_NAMESPACE))) {
+      doc = XmlUtils.upgradeSchema(doc, CacheXml.GEODE_NAMESPACE, CacheXml.LATEST_SCHEMA_LOCATION, CacheXml.VERSION_LATEST);
+    }
+    return doc;
+  }
+
+  /**
+   * Returns an array containing the names of the subdirectories in a given directory
+   * @param path Path of the directory whose subdirectories are listed
+   * @return String[] names of first level subdirectories, null if no subdirectories are found or if the path is incorrect
+   */
+  private static String[] getSubdirectories(String path) {
+    File directory = new File(path);
+    return directory.list(DirectoryFileFilter.INSTANCE);
+  }
+
+  private static class JarFileFilter implements FilenameFilter {
+    @Override
+    public boolean accept(File dir, String name) {
+      return name.endsWith(".jar");
+    }
+  }

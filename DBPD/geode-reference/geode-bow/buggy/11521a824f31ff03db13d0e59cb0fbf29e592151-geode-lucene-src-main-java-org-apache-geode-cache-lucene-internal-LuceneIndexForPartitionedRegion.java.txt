GEODE-2404: Added support for destroying lucene indexes

+import org.apache.geode.CancelException;
+import org.apache.geode.cache.asyncqueue.internal.AsyncEventQueueImpl;
+import org.apache.geode.distributed.internal.ReplyException;
+import org.apache.geode.distributed.internal.ReplyProcessor21;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import java.util.Set;
+
+  public static final String FILES_REGION_SUFFIX = ".files";
+  public static final String CHUNKS_REGION_SUFFIX = ".chunks";
+
-    return LuceneServiceImpl.getUniqueIndexName(indexName, regionPath) + ".files";
+    return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);
-    return LuceneServiceImpl.getUniqueIndexName(indexName, regionPath) + ".chunks";
+    return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, CHUNKS_REGION_SUFFIX);
+
+  @Override
+  public void destroy(boolean initiator) {
+    if (logger.isDebugEnabled()) {
+      logger.debug("Destroying index regionPath=" + regionPath + "; indexName=" + indexName
+          + "; initiator=" + initiator);
+    }
+
+    // Invoke super destroy to remove the extension
+    super.destroy(initiator);
+
+    // Destroy the AsyncEventQueue
+    PartitionedRegion pr = (PartitionedRegion) getDataRegion();
+    destroyAsyncEventQueue(pr);
+
+    // Destroy the chunk region (colocated with the file region)
+    // localDestroyRegion can't be used because locally destroying regions is not supported on
+    // colocated regions
+    if (!chunkRegion.isDestroyed()) {
+      chunkRegion.destroyRegion();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Destroyed chunkRegion=" + chunkRegion.getName());
+      }
+    }
+
+    // Destroy the file region (colocated with the application region)
+    // localDestroyRegion can't be used because locally destroying regions is not supported on
+    // colocated regions
+    if (!fileRegion.isDestroyed()) {
+      fileRegion.destroyRegion();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Destroyed fileRegion=" + fileRegion.getName());
+      }
+    }
+
+    // Destroy index on remote members if necessary
+    if (initiator) {
+      destroyOnRemoteMembers(pr);
+    }
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("Destroyed index regionPath=" + regionPath + "; indexName=" + indexName
+          + "; initiator=" + initiator);
+    }
+  }
+
+  private void destroyAsyncEventQueue(PartitionedRegion pr) {
+    String aeqId = LuceneServiceImpl.getUniqueIndexName(indexName, regionPath);
+
+    // Get the AsyncEventQueue
+    AsyncEventQueueImpl aeq = (AsyncEventQueueImpl) cache.getAsyncEventQueue(aeqId);
+
+    // Stop the AsyncEventQueue (this stops the AsyncEventQueue's underlying GatewaySender)
+    aeq.stop();
+
+    // Remove the id from the dataRegion's AsyncEventQueue ids
+    // Note: The region may already have been destroyed by a remote member
+    if (!pr.isDestroyed()) {
+      pr.getAttributesMutator().removeAsyncEventQueueId(aeqId);
+    }
+
+    // Destroy the aeq (this also removes it from the GemFireCacheImpl)
+    aeq.destroy();
+    if (logger.isDebugEnabled()) {
+      logger.debug("Destroyed aeqId=" + aeqId);
+    }
+  }
+
+  private void destroyOnRemoteMembers(PartitionedRegion pr) {
+    DM dm = pr.getDistributionManager();
+    Set<InternalDistributedMember> recipients = pr.getRegionAdvisor().adviseDataStore();
+    if (!recipients.isEmpty()) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("LuceneIndexForPartitionedRegion: About to send destroy message recipients="
+            + recipients);
+      }
+      ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);
+      DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients,
+          processor.getProcessorId(), regionPath, indexName);
+      dm.putOutgoing(message);
+      if (logger.isDebugEnabled()) {
+        logger.debug("LuceneIndexForPartitionedRegion: Sent message recipients=" + recipients);
+      }
+      try {
+        processor.waitForReplies();
+      } catch (ReplyException e) {
+        if (!(e.getCause() instanceof CancelException)) {
+          throw e;
+        }
+      } catch (InterruptedException e) {
+        dm.getCancelCriterion().checkCancelInProgress(e);
+        Thread.currentThread().interrupt();
+      }
+    }
+  }

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Common support for MBeans and {@link ManagedResource}s.  Static loading of
- * this class creates the MBeanServer and Modeler Registry.
+ * Common support for MBeans and {@link ManagedResource}s. Static loading of this class creates the
+ * MBeanServer and Modeler Registry.
- * @since GemFire     3.5
+ * @since GemFire 3.5
-  
+
-  
+
-  
+
-  
+
-    
+
-  
+
-  
-  /** 
+
+  /**
-   * map: key=ObjectName, 
-   *      value=map: key=RefreshNotificationType,
-   *                 value=timerNotificationId
+   * map: key=ObjectName, value=map: key=RefreshNotificationType, value=timerNotificationId
-  private static Map<NotificationListener, Map<RefreshNotificationType, Integer>> refreshClients = new HashMap<NotificationListener, Map<RefreshNotificationType, Integer>>();
-  
+  private static Map<NotificationListener, Map<RefreshNotificationType, Integer>> refreshClients =
+      new HashMap<NotificationListener, Map<RefreshNotificationType, Integer>>();
+
-  private final static Map<ObjectName, ManagedResource> managedResources = new HashMap<ObjectName, ManagedResource>();
+  private final static Map<ObjectName, ManagedResource> managedResources =
+      new HashMap<ObjectName, ManagedResource>();
-  
+
-   * Initializes Mbean Server, Registry, Refresh Timer & registers Server 
-   * Notification Listener.
+   * Initializes Mbean Server, Registry, Refresh Timer & registers Server Notification Listener.
-      registry    = createRegistry();
-      
+      registry = createRegistry();
+
-  
+
-      
+
-      releaseMBeanServer();//makes mbeanServer null
+      releaseMBeanServer();// makes mbeanServer null
-   * Create and configure (if necessary) and return the <code>MBeanServer</code> 
-   * with which we will be registering our <code>ModelMBean</code> 
-   * implementations.
+   * Create and configure (if necessary) and return the <code>MBeanServer</code> with which we will
+   * be registering our <code>ModelMBean</code> implementations.
-   * Create and configure (if necessary) and return the Commons-Modeler registry 
-   * of managed object descriptions.
+   * Create and configure (if necessary) and return the Commons-Modeler registry of managed object
+   * descriptions.
-          throw new IllegalStateException(LocalizedStrings.MBeanUtil_MBEAN_SERVER_NOT_INITIALIZED_YET.toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.MBeanUtil_MBEAN_SERVER_NOT_INITIALIZED_YET.toLocalizedString());
-  
+
-        //System.out.println(LocalizedStrings.MBeanUtil_LOADING_RESOURCE_0.toLocalizedString(mbeansResource));
-        
+        // System.out.println(LocalizedStrings.MBeanUtil_LOADING_RESOURCE_0.toLocalizedString(mbeansResource));
+
-        raiseOnFailure(url != null, 
-            LocalizedStrings.MBeanUtil_FAILED_TO_FIND_0.toLocalizedString(new Object[] {mbeansResource}));
+        raiseOnFailure(url != null, LocalizedStrings.MBeanUtil_FAILED_TO_FIND_0
+            .toLocalizedString(new Object[] {mbeansResource}));
-        
+
-        raiseOnFailure(test != null && test.length > 0,
-            LocalizedStrings.MBeanUtil_FAILED_TO_LOAD_0.toLocalizedString(new Object[] {mbeansResource}));
+        raiseOnFailure(test != null && test.length > 0, LocalizedStrings.MBeanUtil_FAILED_TO_LOAD_0
+            .toLocalizedString(new Object[] {mbeansResource}));
-        throw new RuntimeAdminException(LocalizedStrings.MBeanUtil_FAILED_TO_GET_MBEAN_REGISTRY.toLocalizedString(), e);
+        throw new RuntimeAdminException(
+            LocalizedStrings.MBeanUtil_FAILED_TO_GET_MBEAN_REGISTRY.toLocalizedString(), e);
-   * Creates and registers a <code>ModelMBean</code> for the specified
-   * <code>ManagedResource</code>. State changing callbacks into the 
-   * <code>ManagedResource</code> will also be made.
+   * Creates and registers a <code>ModelMBean</code> for the specified <code>ManagedResource</code>.
+   * State changing callbacks into the <code>ManagedResource</code> will also be made.
-   * @param resource
-   *        the ManagedResource to create a managing MBean for
+   * @param resource the ManagedResource to create a managing MBean for
-  
+
-   * Creates and registers a <code>ModelMBean</code> for the specified
-   * <code>ManagedResource</code>. State changing callbacks into the 
-   * <code>ManagedResource</code> will also be made.
+   * Creates and registers a <code>ModelMBean</code> for the specified <code>ManagedResource</code>.
+   * State changing callbacks into the <code>ManagedResource</code> will also be made.
-   * @param managed  the ManagedBean definition to create the MBean with
+   * @param managed the ManagedBean definition to create the MBean with
-      
+
-        throw new MalformedObjectNameException(LocalizedStrings.MBeanUtil_0_IN_1.toLocalizedString(new Object[] { e.getMessage(), resource.getMBeanName()} ) );
+        throw new MalformedObjectNameException(LocalizedStrings.MBeanUtil_0_IN_1
+            .toLocalizedString(new Object[] {e.getMessage(), resource.getMBeanName()}));
-        // Only register a bean once.  Otherwise, you risk race
+        // Only register a bean once. Otherwise, you risk race
-      throw new RuntimeAdminException(LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_MBEAN_FOR_0.toLocalizedString(new Object[]{resource.getMBeanName()}), e);
+      throw new RuntimeAdminException(LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_MBEAN_FOR_0
+          .toLocalizedString(new Object[] {resource.getMBeanName()}), e);
-  
+
-   * Ensures that an MBean is registered for the specified 
-   * <code>ManagedResource</code>.  If an MBean cannot be found in the
-   * <code>MBeanServer</code>, then this creates and registers a 
-   * <code>ModelMBean</code>. State changing callbacks into the 
-   * <code>ManagedResource</code> will also be made.
+   * Ensures that an MBean is registered for the specified <code>ManagedResource</code>. If an MBean
+   * cannot be found in the <code>MBeanServer</code>, then this creates and registers a
+   * <code>ModelMBean</code>. State changing callbacks into the <code>ManagedResource</code> will
+   * also be made.
-   * @param resource
-   *        the ManagedResource to create a managing MBean for
+   * @param resource the ManagedResource to create a managing MBean for
-      raiseOnFailure(mbeanServer.isRegistered(objName), 
-          LocalizedStrings.MBeanUtil_COULDNT_FIND_MBEAN_REGISTERED_WITH_OBJECTNAME_0.toLocalizedString(new Object[] {objName.toString()}));
+      raiseOnFailure(mbeanServer.isRegistered(objName),
+          LocalizedStrings.MBeanUtil_COULDNT_FIND_MBEAN_REGISTERED_WITH_OBJECTNAME_0
+              .toLocalizedString(new Object[] {objName.toString()}));
-    } 
-    catch (java.lang.Exception e) {
+    } catch (java.lang.Exception e) {
-  
+
-   * Retrieves the <code>ManagedBean</code> configuration from the Registry for 
-   * the specified <code>ManagedResource</code>
+   * Retrieves the <code>ManagedBean</code> configuration from the Registry for the specified
+   * <code>ManagedResource</code>
-      managed = registry.findManagedBean(
-          resource.getManagedResourceType().getClassTypeName());
+      managed = registry.findManagedBean(resource.getManagedResourceType().getClassTypeName());
-      throw new IllegalArgumentException(LocalizedStrings.MBeanUtil_MANAGEDBEAN_IS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.MBeanUtil_MANAGEDBEAN_IS_NULL.toLocalizedString());
-    
+
-      throw new IllegalArgumentException(LocalizedStrings.MBeanUtil_MANAGEDBEAN_IS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.MBeanUtil_MANAGEDBEAN_IS_NULL.toLocalizedString());
-    
+
-    managed.setClassName(
-        "org.apache.geode.admin.jmx.internal.MX4JModelMBean");
+    managed.setClassName("org.apache.geode.admin.jmx.internal.MX4JModelMBean");
-   * Registers a refresh notification for the specified client MBean.  
-   * Specifying zero for the refreshInterval disables notification for the 
-   * refresh client. Note: this does not currently support remote connections.
+   * Registers a refresh notification for the specified client MBean. Specifying zero for the
+   * refreshInterval disables notification for the refresh client. Note: this does not currently
+   * support remote connections.
-   * @param client          client to listen for refresh notifications
-   * @param userData        userData to register with the Notification 
-   * @param type            refresh notification type the client will use
+   * @param client client to listen for refresh notifications
+   * @param userData userData to register with the Notification
+   * @param type refresh notification type the client will use
-  static void registerRefreshNotification(NotificationListener client, 
-                                          Object userData, 
-                                          RefreshNotificationType type,
-                                          int refreshInterval) {
+  static void registerRefreshNotification(NotificationListener client, Object userData,
+      RefreshNotificationType type, int refreshInterval) {
-      throw new IllegalArgumentException(LocalizedStrings.MBeanUtil_NOTIFICATIONLISTENER_IS_REQUIRED.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.MBeanUtil_NOTIFICATIONLISTENER_IS_REQUIRED.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.MBeanUtil_REFRESHNOTIFICATIONTYPE_IS_REQUIRED.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.MBeanUtil_REFRESHNOTIFICATIONTYPE_IS_REQUIRED.toLocalizedString());
-      throw new IllegalStateException(LocalizedStrings.MBeanUtil_REFRESHTIMER_HAS_NOT_BEEN_PROPERLY_INITIALIZED.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.MBeanUtil_REFRESHTIMER_HAS_NOT_BEEN_PROPERLY_INITIALIZED
+              .toLocalizedString());
-    
+
-        notifications = (Map<RefreshNotificationType, Integer>) refreshClients.get(client);        
+        notifications = (Map<RefreshNotificationType, Integer>) refreshClients.get(client);
-      
+
-        
+
-          mbeanServer.addNotificationListener(
-              refreshTimerObjectName, // timer to listen to
-              client,       // the NotificationListener object
-              null,         // optional NotificationFilter TODO: convert to using
-              new Object()  // not used but null throws IllegalArgumentException
-              );
+          mbeanServer.addNotificationListener(refreshTimerObjectName, // timer to listen to
+              client, // the NotificationListener object
+              null, // optional NotificationFilter TODO: convert to using
+              new Object() // not used but null throws IllegalArgumentException
+          );
-          logStackTrace(Level.WARN, e, LocalizedStrings.MBeanUtil_COULD_NOT_FIND_REGISTERED_REFRESHTIMER_INSTANCE.toLocalizedString());
+          logStackTrace(Level.WARN, e,
+              LocalizedStrings.MBeanUtil_COULD_NOT_FIND_REGISTERED_REFRESHTIMER_INSTANCE
+                  .toLocalizedString());
-      
+
-      
+
-        timerNotificationId = refreshTimer.addNotification(
-            type.getType(),                   // type
-            type.getMessage(),                // message = "refresh"
-            userData,                         // userData
-            new Date(System.currentTimeMillis() + 
-                     refreshInterval * 1000), // first occurence
-            refreshInterval * 1000);          // period to repeat  
-        
+        timerNotificationId = refreshTimer.addNotification(type.getType(), // type
+            type.getMessage(), // message = "refresh"
+            userData, // userData
+            new Date(System.currentTimeMillis() + refreshInterval * 1000), // first occurence
+            refreshInterval * 1000); // period to repeat
+
-        // do nothing!  refreshInterval must be over 0 to do anything...
+        // do nothing! refreshInterval must be over 0 to do anything...
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-   * Verifies a refresh notification for the specified client MBean.
-   * If notification is not registered, then returns a false
+   * Verifies a refresh notification for the specified client MBean. If notification is not
+   * registered, then returns a false
-   * @param client          client to listen for refresh notifications
-   * @param type            refresh notification type the client will use
+   * @param client client to listen for refresh notifications
+   * @param type refresh notification type the client will use
-   * @return isRegistered   boolean indicating if a notification is registered
+   * @return isRegistered boolean indicating if a notification is registered
-                                          RefreshNotificationType type) {
+      RefreshNotificationType type) {
-    synchronized(refreshClients) {
+    synchronized (refreshClients) {
-    // never registered before if  null ...
+    // never registered before if null ...
-  
-  /** 
-   * Validates refreshTimer has been registered without problems and attempts 
-   * to re-register if there is a problem. 
+
+  /**
+   * Validates refreshTimer has been registered without problems and attempts to re-register if
+   * there is a problem.
-      //if (refreshTimerObjectName == null) System.out.println("refreshTimerObjectName is null");
-      //if (refreshTimer == null) System.out.println("refreshTimer is null");
-      //System.out.println("[validateRefreshTimer] createRefreshTimer");
+      // if (refreshTimerObjectName == null) System.out.println("refreshTimerObjectName is null");
+      // if (refreshTimer == null) System.out.println("refreshTimer is null");
+      // System.out.println("[validateRefreshTimer] createRefreshTimer");
-    
-    raiseOnFailure(refreshTimer != null, 
-                      "Failed to validate Refresh Timer");
+
+    raiseOnFailure(refreshTimer != null, "Failed to validate Refresh Timer");
-      //System.out.println("[validateRefreshTimer] registerMBean");
+      // System.out.println("[validateRefreshTimer] registerMBean");
-      } catch (JMException e) { 
-        logStackTrace(Level.WARN, e); 
-  	  } catch (JMRuntimeException e) { 
-        logStackTrace(Level.WARN, e); 
-  	  }
-    }                       
+      } catch (JMException e) {
+        logStackTrace(Level.WARN, e);
+      } catch (JMRuntimeException e) {
+        logStackTrace(Level.WARN, e);
+      }
+    }
-  
+
-  static void createRefreshTimer() {        
+  static void createRefreshTimer() {
-            
+
-      logStackTrace(Level.WARN, e, LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER.toLocalizedString());
+      logStackTrace(Level.WARN, e,
+          LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER.toLocalizedString());
-      logStackTrace(Level.WARN, e, LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER.toLocalizedString());
+      logStackTrace(Level.WARN, e,
+          LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER.toLocalizedString());
-      logStackTrace(Level.WARN, e, LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER.toLocalizedString());
+      logStackTrace(Level.WARN, e,
+          LocalizedStrings.MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER.toLocalizedString());
-  
+
-  static void stopRefreshTimer() {        
+  static void stopRefreshTimer() {
-              
+
-      logStackTrace(Level.DEBUG,e, "Failed to stop refresh timer for MBeanUtil");
+      logStackTrace(Level.DEBUG, e, "Failed to stop refresh timer for MBeanUtil");
-  
+
-   * Return a String that been modified to be compliant as a property of an 
-   * ObjectName.
+   * Return a String that been modified to be compliant as a property of an ObjectName.
-   * The property name of an ObjectName may not contain any of the following
-   * characters:  <b><i>:  ,  =  *  ?</i></b>
+   * The property name of an ObjectName may not contain any of the following characters: <b><i>: , =
+   * * ?</i></b>
-   * This method will replace the above non-compliant characters with a
-   * dash:  <b><i>-</i></b>
+   * This method will replace the above non-compliant characters with a dash: <b><i>-</i></b>
-   * Note: this is <code>public</code> because certain tests call this from
-   * outside of the package. TODO: clean this up
+   * Note: this is <code>public</code> because certain tests call this from outside of the package.
+   * TODO: clean this up
-   * @param value  the potentially non-compliant ObjectName property
+   * @param value the potentially non-compliant ObjectName property
-  
+
-   * Unregisters all GemFire MBeans and then releases the MBeanServer for
-   * garbage collection.
+   * Unregisters all GemFire MBeans and then releases the MBeanServer for garbage collection.
-        ObjectName name = (ObjectName)iter.next();
+        ObjectName name = (ObjectName) iter.next();
-      
+
-    } catch (JMRuntimeException e) { 
-      logStackTrace(Level.WARN, e); 
-   	} 
-	  /* See #42391. Cleaning up the static maps which might be still holding  
-	   * references to ManagedResources */ 
-	   synchronized (MBeanUtil.managedResources) { 
-	     MBeanUtil.managedResources.clear(); 
-	   } 
-	   synchronized (refreshClients) { 
-	     refreshClients.clear();
-	   }
-    /* See #42391. Cleaning up the static maps which might be still holding 
-     * references to ManagedResources */
+    } catch (JMRuntimeException e) {
+      logStackTrace(Level.WARN, e);
+    }
+    /*
+     * See #42391. Cleaning up the static maps which might be still holding references to
+     * ManagedResources
+     */
+    synchronized (MBeanUtil.managedResources) {
+      MBeanUtil.managedResources.clear();
+    }
+    synchronized (refreshClients) {
+      refreshClients.clear();
+    }
+    /*
+     * See #42391. Cleaning up the static maps which might be still holding references to
+     * ManagedResources
+     */
-  
+
-   * @param objectName
-   *          ObjectName to use for checking if MBean is registered
-   * @return true if MBeanServer is not null & MBean with given ObjectName is
-   *         registered with the MBeanServer        
+   * @param objectName ObjectName to use for checking if MBean is registered
+   * @return true if MBeanServer is not null & MBean with given ObjectName is registered with the
+   *         MBeanServer
-  
+
-      logStackTrace(Level.WARN, null, LocalizedStrings.MBeanUtil_FAILED_WHILE_UNREGISTERING_MBEAN_WITH_OBJECTNAME_0.toLocalizedString(new Object[] {objectName}));
+      logStackTrace(Level.WARN, null,
+          LocalizedStrings.MBeanUtil_FAILED_WHILE_UNREGISTERING_MBEAN_WITH_OBJECTNAME_0
+              .toLocalizedString(new Object[] {objectName}));
-      logStackTrace(Level.WARN, null, LocalizedStrings.MBeanUtil_WHILE_UNREGISTERING_COULDNT_FIND_MBEAN_WITH_OBJECTNAME_0.toLocalizedString(new Object[] {objectName}));
-    } catch (JMRuntimeException e) { 
-      logStackTrace(Level.WARN, null, LocalizedStrings.MBeanUtil_COULD_NOT_UNREGISTER_MBEAN_WITH_OBJECTNAME_0.toLocalizedString(new Object[] {objectName}));
+      logStackTrace(Level.WARN, null,
+          LocalizedStrings.MBeanUtil_WHILE_UNREGISTERING_COULDNT_FIND_MBEAN_WITH_OBJECTNAME_0
+              .toLocalizedString(new Object[] {objectName}));
+    } catch (JMRuntimeException e) {
+      logStackTrace(Level.WARN, null,
+          LocalizedStrings.MBeanUtil_COULD_NOT_UNREGISTER_MBEAN_WITH_OBJECTNAME_0
+              .toLocalizedString(new Object[] {objectName}));
+
-  
+
-      // all notifications of un-registration. If resource is 
+      // all notifications of un-registration. If resource is
-  
+
-    // never registered before if  null ...
-    // Also as of current, there is ever only 1 Notification type per 
+    // never registered before if null ...
+    // Also as of current, there is ever only 1 Notification type per
-      
-      for(Map.Entry<RefreshNotificationType, Integer> e : entries) {
+
+      for (Map.Entry<RefreshNotificationType, Integer> e : entries) {
-        if(null != timerNotificationId) {
+        if (null != timerNotificationId) {
-      
+
-          mbeanServer.removeNotificationListener(
-              refreshTimerObjectName, // timer to listen to
-              (NotificationListener)resource       // the NotificationListener object
+          mbeanServer.removeNotificationListener(refreshTimerObjectName, // timer to listen to
+              (NotificationListener) resource // the NotificationListener object
-        logStackTrace(Level.WARN, null, LocalizedStrings.MBeanUtil_WHILE_UNREGISTERING_COULDNT_FIND_MBEAN_WITH_OBJECTNAME_0.toLocalizedString(new Object[] {refreshTimerObjectName}));
+        logStackTrace(Level.WARN, null,
+            LocalizedStrings.MBeanUtil_WHILE_UNREGISTERING_COULDNT_FIND_MBEAN_WITH_OBJECTNAME_0
+                .toLocalizedString(new Object[] {refreshTimerObjectName}));
-  
+
-      return (Character.isLetter(path.charAt(0)) && path.charAt(1) == ':') ||
-        (path.startsWith("//") || path.startsWith("\\\\"));
+      return (Character.isLetter(path.charAt(0)) && path.charAt(1) == ':')
+          || (path.startsWith("//") || path.startsWith("\\\\"));
-      mbeanServer.addNotificationListener(
-        delegate,
-        new NotificationListener() {
-          public void handleNotification(Notification notification, Object handback) {
-            MBeanServerNotification serverNotification = (MBeanServerNotification) notification;
-            if (MBeanServerNotification.UNREGISTRATION_NOTIFICATION.equals(serverNotification.getType())) {
-              ObjectName objectName = serverNotification.getMBeanName();
-              synchronized (MBeanUtil.managedResources) {
-                Object entry = MBeanUtil.managedResources.get(objectName);
-                if (entry == null) return;
-                if (!(entry instanceof ManagedResource)) {
-                  throw new ClassCastException(LocalizedStrings.MBeanUtil_0_IS_NOT_A_MANAGEDRESOURCE.toLocalizedString(new Object[] {entry.getClass().getName()}));
-                }
-                ManagedResource resource = (ManagedResource) entry;
-                {
-                  // call cleanup on managedResource
-                  cleanupResource(resource);
-                }
+      mbeanServer.addNotificationListener(delegate, new NotificationListener() {
+        public void handleNotification(Notification notification, Object handback) {
+          MBeanServerNotification serverNotification = (MBeanServerNotification) notification;
+          if (MBeanServerNotification.UNREGISTRATION_NOTIFICATION
+              .equals(serverNotification.getType())) {
+            ObjectName objectName = serverNotification.getMBeanName();
+            synchronized (MBeanUtil.managedResources) {
+              Object entry = MBeanUtil.managedResources.get(objectName);
+              if (entry == null)
+                return;
+              if (!(entry instanceof ManagedResource)) {
+                throw new ClassCastException(LocalizedStrings.MBeanUtil_0_IS_NOT_A_MANAGEDRESOURCE
+                    .toLocalizedString(new Object[] {entry.getClass().getName()}));
+              }
+              ManagedResource resource = (ManagedResource) entry;
+              {
+                // call cleanup on managedResource
+                cleanupResource(resource);
-        }, 
-        null, null);
+        }
+      }, null, null);
-      logStackTrace(Level.WARN, e, 
-          LocalizedStrings.MBeanUtil_FAILED_TO_REGISTER_SERVERNOTIFICATIONLISTENER.toLocalizedString());
+      logStackTrace(Level.WARN, e,
+          LocalizedStrings.MBeanUtil_FAILED_TO_REGISTER_SERVERNOTIFICATIONLISTENER
+              .toLocalizedString());
-      logStackTrace(Level.WARN, e, 
-          LocalizedStrings.MBeanUtil_FAILED_TO_REGISTER_SERVERNOTIFICATIONLISTENER.toLocalizedString());
+      logStackTrace(Level.WARN, e,
+          LocalizedStrings.MBeanUtil_FAILED_TO_REGISTER_SERVERNOTIFICATIONLISTENER
+              .toLocalizedString());
-   * Logs the stack trace for the given Throwable if logger is initialized else
-   * prints the stack trace using System.out.
+   * Logs the stack trace for the given Throwable if logger is initialized else prints the stack
+   * trace using System.out.
-   * @param level
-   *          severity level to log at
-   * @param throwable
-   *          Throwable to log stack trace for
+   * @param level severity level to log at
+   * @param throwable Throwable to log stack trace for
-   * Logs the stack trace for the given Throwable if logger is initialized else
-   * prints the stack trace using System.out.
+   * Logs the stack trace for the given Throwable if logger is initialized else prints the stack
+   * trace using System.out.
-   * @param level
-   *          severity level to log at
-   * @param throwable
-   *          Throwable to log stack trace for
-   * @param message
-   *          user friendly error message to show
+   * @param level severity level to log at
+   * @param throwable Throwable to log stack trace for
+   * @param message user friendly error message to show
-  public static void logStackTrace(Level level, Throwable throwable, 
-                                   String message) {
+  public static void logStackTrace(Level level, Throwable throwable, String message) {
-   * Raises RuntimeAdminException with given 'message' if given 'condition' is
-   * false.
+   * Raises RuntimeAdminException with given 'message' if given 'condition' is false.
-   * @param condition
-   *          condition to evaluate
-   * @param message
-   *          failure message
+   * @param condition condition to evaluate
+   * @param message failure message

GEODE-420: Added SSLConfigurationFactory to have a single location that determines the SSLConfiguration. Amended all affected classes

+import org.springframework.util.StringUtils;
+import com.gemstone.gemfire.internal.admin.SSLConfig;
-  /**
-   * True if configured to use SSL
-   */
-  private boolean useSSL;
-
-  /**
-   * True if configured to require client authentication
-   */
-  private boolean needClientAuth;
-
-  /**
-   * Space-delimited list of SSL protocols to use, 'any' allows any
-   */
-  private String[] protocols;
-
-  /**
-   * Space-delimited list of SSL ciphers to use, 'any' allows any
-   */
-  private String[] ciphers;
+  //  /**
+  //   * True if configured to use SSL
+  //   */
+  //  private boolean useSSL;
+  //
+  //  /**
+  //   * True if configured to require client authentication
+  //   */
+  //  private boolean needClientAuth;
+  //
+  //  /**
+  //   * Space-delimited list of SSL protocols to use, 'any' allows any
+  //   */
+  //  private String[] protocols;
+  //
+  //  /**
+  //   * Space-delimited list of SSL ciphers to use, 'any' allows any
+  //   */
+  //  private String[] ciphers;
+  private SSLConfig sslConfig;
+
-
-  SocketCreator() {
-    this(false, false, null, null, null, null);
+  SocketCreator(final SSLConfig sslConfig) {
+    this.sslConfig = sslConfig;
+    initialize();
-  /**
-   * Constructs new SocketCreator instance.
-   */
-  SocketCreator(final boolean useSSL,
-                final boolean needClientAuth,
-                final String[] protocols,
-                final String[] ciphers,
-                final Properties props,
-                final String alias) {
-    initialize(useSSL, needClientAuth, protocols, ciphers, props, alias);
-  }
-   * @param useSSL true if ssl is to be enabled
-   * @param needClientAuth true if client authentication is required
-   * @param protocols array of ssl protocols to use
-   * @param ciphers array of ssl ciphers to use
-   * @param props vendor properties passed in through gfsecurity.properties
-  private void initialize(final boolean useSSL,
-                          final boolean needClientAuth,
-                          final String[] protocols,
-                          final String[] ciphers,
-                          final Properties props,
-                          final String alias) {
+  private void initialize() {
-      this.useSSL = useSSL;
-      this.needClientAuth = needClientAuth;
-
-      this.protocols = protocols;
-      this.ciphers = ciphers;
-
-      if (this.useSSL) {
+      if (this.sslConfig.isEnabled()) {
-            sslContext = createAndConfigureSSLContext(protocols, props, alias);
+            sslContext = createAndConfigureSSLContext();
-   * @param protocolNames valid SSL protocols for this connection
-   * @param props vendor properties passed in through gfsecurity.properties
-   *
-  private SSLContext createAndConfigureSSLContext(final String[] protocolNames, final Properties props, final String alias)
-    throws GeneralSecurityException, IOException {
+  private SSLContext createAndConfigureSSLContext() throws GeneralSecurityException, IOException {
-    SSLContext newSSLContext = getSSLContextInstance(protocolNames);
-    KeyManager[] keyManagers = getKeyManagers(props, alias);
-    TrustManager[] trustManagers = getTrustManagers(props);
+    SSLContext newSSLContext = getSSLContextInstance();
+    KeyManager[] keyManagers = getKeyManagers();
+    TrustManager[] trustManagers = getTrustManagers();
-  private SSLContext getSSLContextInstance(String[] protocols) {
+  private SSLContext getSSLContextInstance() {
+    String[] protocols = sslConfig.getProtocolsAsStringArray();
-  private TrustManager[] getTrustManagers(Properties sysProps) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
+  private TrustManager[] getTrustManagers() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
-    String trustStoreType = sysProps.getProperty("javax.net.ssl.trustStoreType");
-    if (trustStoreType == null) {
-      trustStoreType = System.getProperty("javax.net.ssl.trustStoreType", KeyStore.getDefaultType());
-    } else if (trustStoreType.trim().equals("")) {
+    String trustStoreType = sslConfig.getTruststoreType();
+    if (StringUtils.isEmpty(trustStoreType)) {
-      }
-      if (isEmpty(trustStoreType)) {
+      } else {
+
-    String trustStorePath = System.getProperty("javax.net.ssl.trustStore");
-    if (trustStorePath == null) {
-      trustStorePath = sysProps.getProperty("javax.net.ssl.trustStore");
+    String trustStorePath = sslConfig.getTruststore();
+    if (StringUtils.isEmpty(trustStorePath)) {
+      if (consoleReader.isSupported()) {
+        trustStorePath = consoleReader.readLine("Please enter the trustStore location (javax.net.ssl.trustStore) : ");
+      }
-    if (trustStorePath != null) {
-      if (trustStorePath.trim().equals("")) {
-        trustStorePath = System.getenv("javax.net.ssl.trustStore");
-        //read from console
-        if (isEmpty(trustStorePath) && consoleReader.isSupported()) {
-          trustStorePath = consoleReader.readLine("Please enter the trustStore location (javax.net.ssl.trustStore) : ");
-        }
-      }
-      FileInputStream fis = new FileInputStream(trustStorePath);
-      String passwordString = System.getProperty("javax.net.ssl.trustStorePassword");
-      if (passwordString == null) {
-        passwordString = sysProps.getProperty("javax.net.ssl.trustStorePassword");
-      }
-      char[] password = null;
-      if (passwordString != null) {
-        if (passwordString.trim().equals("")) {
-          String encryptedPass = System.getenv("javax.net.ssl.trustStorePassword");
-          if (!isEmpty(encryptedPass)) {
-            String toDecrypt = "encrypted(" + encryptedPass + ")";
-            passwordString = PasswordUtil.decrypt(toDecrypt);
-            password = passwordString.toCharArray();
-          }
-          //read from the console
-          if (isEmpty(passwordString) && consoleReader.isSupported()) {
-            password = consoleReader.readPassword("Please enter password for trustStore (javax.net.ssl.trustStorePassword) : ");
-          }
-        } else {
+    FileInputStream fis = new FileInputStream(trustStorePath);
+    String passwordString = sslConfig.getTruststorePassword();
+    char[] password = null;
+    if (passwordString != null) {
+      if (passwordString.trim().equals("")) {
+        if (!StringUtils.isEmpty(passwordString)) {
+          String toDecrypt = "encrypted(" + passwordString + ")";
+          passwordString = PasswordUtil.decrypt(toDecrypt);
-      }
-      ts.load(fis, password);
-
-      // default algorithm can be changed by setting property "ssl.TrustManagerFactory.algorithm" in security properties
-      TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-      tmf.init(ts);
-      trustManagers = tmf.getTrustManagers();
-      // follow the security tip in java doc
-      if (password != null) {
-        java.util.Arrays.fill(password, ' ');
+        //read from the console
+        if (StringUtils.isEmpty(passwordString) && consoleReader.isSupported()) {
+          password = consoleReader.readPassword("Please enter password for trustStore (javax.net.ssl.trustStorePassword) : ");
+        }
+      } else {
+        password = passwordString.toCharArray();
+    ts.load(fis, password);
+
+    // default algorithm can be changed by setting property "ssl.TrustManagerFactory.algorithm" in security properties
+    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+    tmf.init(ts);
+    trustManagers = tmf.getTrustManagers();
+    // follow the security tip in java doc
+    if (password != null) {
+      java.util.Arrays.fill(password, ' ');
+    }
+
-  private KeyManager[] getKeyManagers(final Properties sysProps, final String alias)
-    throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException {
-    String keyStoreType = sysProps.getProperty("javax.net.ssl.keyStoreType");
+  private KeyManager[] getKeyManagers() throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException {
-
-    if (keyStoreType == null) {
-      keyStoreType = System.getProperty("javax.net.ssl.keyStoreType", KeyStore.getDefaultType());
-    } else if (keyStoreType.trim().equals("")) {
+    String keyStoreType = sslConfig.getKeystoreType();
+    if (StringUtils.isEmpty(keyStoreType)) {
-      }
-      if (isEmpty(keyStoreType)) {
+      } else {
-    String keyStoreFilePath = sysProps.getProperty("javax.net.ssl.keyStore");
-    if (keyStoreFilePath == null) {
-      keyStoreFilePath = System.getProperty("javax.net.ssl.keyStore");
+    String keyStoreFilePath = sslConfig.getKeystore();
+    if (StringUtils.isEmpty(keyStoreFilePath)) {
+      if (consoleReader.isSupported()) {
+        keyStoreFilePath = consoleReader.readLine("Please enter the keyStore location (javax.net.ssl.keyStore) : ");
+      } else {
+        keyStoreFilePath = System.getProperty("user.home") + System.getProperty("file.separator") + ".keystore";
+      }
-    if (keyStoreFilePath != null) {
-      if (keyStoreFilePath.trim().equals("")) {
-        keyStoreFilePath = System.getenv("javax.net.ssl.keyStore");
-        //read from console
-        if (isEmpty(keyStoreFilePath) && consoleReader.isSupported()) {
-          keyStoreFilePath = consoleReader.readLine("Please enter the keyStore location (javax.net.ssl.keyStore) : ");
-        }
-        if (isEmpty(keyStoreFilePath)) {
-          keyStoreFilePath = System.getProperty("user.home") + System.getProperty("file.separator") + ".keystore";
-        }
-      }
-      FileInputStream fileInputStream = new FileInputStream(keyStoreFilePath);
-      String passwordString = sysProps.getProperty("javax.net.ssl.keyStorePassword");
-      if (passwordString == null) {
-        passwordString = System.getProperty("javax.net.ssl.keyStorePassword");
-      }
-      char[] password = null;
-      if (passwordString != null) {
-        if (passwordString.trim().equals("")) {
-          String encryptedPass = System.getenv("javax.net.ssl.keyStorePassword");
-          if (!isEmpty(encryptedPass)) {
-            String toDecrypt = "encrypted(" + encryptedPass + ")";
-            passwordString = PasswordUtil.decrypt(toDecrypt);
-            password = passwordString.toCharArray();
-          }
-          //read from the console
-          if (isEmpty(passwordString) && consoleReader != null) {
-            password = consoleReader.readPassword("Please enter password for keyStore (javax.net.ssl.keyStorePassword) : ");
-          }
-        } else {
+
+    FileInputStream fileInputStream = new FileInputStream(keyStoreFilePath);
+    String passwordString = sslConfig.getKeystorePassword();
+    char[] password = null;
+    if (passwordString != null) {
+      if (passwordString.trim().equals("")) {
+        String encryptedPass = System.getenv("javax.net.ssl.keyStorePassword");
+        if (!StringUtils.isEmpty(encryptedPass)) {
+          String toDecrypt = "encrypted(" + encryptedPass + ")";
+          passwordString = PasswordUtil.decrypt(toDecrypt);
-      }
-      keyStore.load(fileInputStream, password);
-      // default algorithm can be changed by setting property "ssl.KeyManagerFactory.algorithm" in security properties
-      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-      keyManagerFactory.init(keyStore, password);
-      keyManagers = keyManagerFactory.getKeyManagers();
-      // follow the security tip in java doc
-      if (password != null) {
-        java.util.Arrays.fill(password, ' ');
+        //read from the console
+        if (StringUtils.isEmpty(passwordString) && consoleReader != null) {
+          password = consoleReader.readPassword("Please enter password for keyStore (javax.net.ssl.keyStorePassword) : ");
+        }
+      } else {
+        password = passwordString.toCharArray();
+    keyStore.load(fileInputStream, password);
+    // default algorithm can be changed by setting property "ssl.KeyManagerFactory.algorithm" in security properties
+    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keyStore, password);
+    keyManagers = keyManagerFactory.getKeyManagers();
+    // follow the security tip in java doc
+    if (password != null) {
+      java.util.Arrays.fill(password, ' ');
+    }
+
-    for (int i = 0; i < keyManagers.length; i++) {
-      extendedKeyManagers[i] = new ExtendedAliasKeyManager(keyManagers[i], alias);
+    for (int i = 0; i < keyManagers.length; i++)
+
+    {
+      extendedKeyManagers[i] = new ExtendedAliasKeyManager(keyManagers[i], sslConfig.getAlias());
+
-  private boolean isEmpty(String string) {
-    return (string == null || string.trim().equals(""));
-  }
-
-    return this.useSSL;
+    return this.sslConfig.isEnabled();
-    return createServerSocket(nport, backlog, bindAddr, -1, useSSL);
+    return createServerSocket(nport, backlog, bindAddr, -1, sslConfig.isEnabled());
-    return createServerSocket(nport, backlog, bindAddr, socketBufferSize, useSSL);
+    return createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConfig.isEnabled());
-    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize, tcpPortRange, this.useSSL);
+    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize, tcpPortRange, sslConfig.isEnabled());
-    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize, this.useSSL);
+    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize, sslConfig.isEnabled());
-        if (this.needClientAuth) {
+        if (this.sslConfig.isRequireAuth()) {
-    if (this.needClientAuth) {
+    if (this.sslConfig.isRequireAuth()) {
-    if (!"any".equalsIgnoreCase(this.protocols[0])) {
-      serverSocket.setEnabledProtocols(this.protocols);
+    String[] protocols = this.sslConfig.getProtocolsAsStringArray();
+    if (!"any".equalsIgnoreCase(protocols[0])) {
+      serverSocket.setEnabledProtocols(protocols);
-    if (!"any".equalsIgnoreCase(this.ciphers[0])) {
-      serverSocket.setEnabledCipherSuites(this.ciphers);
+    String[] ciphers = this.sslConfig.getCiphersAsStringArray();
+    if (!"any".equalsIgnoreCase(ciphers[0])) {
+      serverSocket.setEnabledCipherSuites(ciphers);
+      String[] protocols = this.sslConfig.getProtocolsAsStringArray();
+
-      if (this.protocols != null && !"any".equalsIgnoreCase(this.protocols[0])) {
-        sslSocket.setEnabledProtocols(this.protocols);
+      if (protocols != null && !"any".equalsIgnoreCase(protocols[0])) {
+        sslSocket.setEnabledProtocols(protocols);
-      if (this.ciphers != null && !"any".equalsIgnoreCase(this.ciphers[0])) {
-        sslSocket.setEnabledCipherSuites(this.ciphers);
+      String[] ciphers = this.sslConfig.getCiphersAsStringArray();
+      if (ciphers != null && !"any".equalsIgnoreCase(ciphers[0])) {
+        sslSocket.setEnabledCipherSuites(ciphers);
-        if (this.needClientAuth) {
+        if (this.sslConfig.isRequireAuth()) {
-      sb.append("  ssl-enabled = " + this.useSSL).append("\n");
+      sb.append("  ssl-enabled = " + this.sslConfig.isEnabled()).append("\n");

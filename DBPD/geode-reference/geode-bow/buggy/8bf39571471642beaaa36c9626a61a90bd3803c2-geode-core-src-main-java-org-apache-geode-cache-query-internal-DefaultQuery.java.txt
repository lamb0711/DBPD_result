Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-//  private Pool pool;
+  // private Pool pool;
-  //TODO : Toggle the flag appropriately when implementing the  compile() functionality
+  // TODO : Toggle the flag appropriately when implementing the compile() functionality
-   * System property to cleanup the compiled query. The compiled query
-   * will be removed if it is not used for more than the set value.
-   * By default its set to 10 minutes, the time is set in MilliSecs.
+   * System property to cleanup the compiled query. The compiled query will be removed if it is not
+   * used for more than the set value. By default its set to 10 minutes, the time is set in
+   * MilliSecs.
-  public static final int COMPILED_QUERY_CLEAR_TIME = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "Query.COMPILED_QUERY_CLEAR_TIME", 10 * 60 * 1000).intValue();
+  public static final int COMPILED_QUERY_CLEAR_TIME =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Query.COMPILED_QUERY_CLEAR_TIME",
+          10 * 60 * 1000).intValue();
-  
+
-  private final boolean[] queryCompletedForMonitoring = new boolean[]{false};
+  private final boolean[] queryCompletedForMonitoring = new boolean[] {false};
-  
+
-    @Override 
+    @Override
-  
+
-  
+
-   * Caches the fields not found in any Pdx version.
-   * This threadlocal will be
-   * cleaned up after query execution completes in
-   * {@linkplain #executeUsingContext(ExecutionContext)}
+   * Caches the fields not found in any Pdx version. This threadlocal will be cleaned up after query
+   * execution completes in {@linkplain #executeUsingContext(ExecutionContext)}
-  private static final ThreadLocal<Map<String, Set<String>>> pdxClassToFieldsMap = new ThreadLocal() {
-    @Override 
-    protected Map<String, Set<String>> initialValue() {
-      return new HashMap<String, Set<String>>();
-    }
-  };
-  
+  private static final ThreadLocal<Map<String, Set<String>>> pdxClassToFieldsMap =
+      new ThreadLocal() {
+        @Override
+        protected Map<String, Set<String>> initialValue() {
+          return new HashMap<String, Set<String>>();
+        }
+      };
+
- 
+
-  
-    
+
+
-   * Caches the methods not found in any Pdx version.
-   * This threadlocal will be
-   * cleaned up after query execution completes in
-   * {@linkplain #executeUsingContext(ExecutionContext)}
+   * Caches the methods not found in any Pdx version. This threadlocal will be cleaned up after
+   * query execution completes in {@linkplain #executeUsingContext(ExecutionContext)}
-  private static final ThreadLocal<Map<String, Set<String>>> pdxClassToMethodsMap = new ThreadLocal() {
-    @Override 
-    protected Map<String, Set<String>> initialValue() {
-      return new HashMap<String, Set<String>>();
-    }
-  };
-  
+  private static final ThreadLocal<Map<String, Set<String>>> pdxClassToMethodsMap =
+      new ThreadLocal() {
+        @Override
+        protected Map<String, Set<String>> initialValue() {
+          return new HashMap<String, Set<String>>();
+        }
+      };
+
- 
+
-  /** Should be constructed from DefaultQueryService
+  /**
+   * Should be constructed from DefaultQueryService
+   * 
-    if(cs != null && !isForRemote && (cs.isGroupBy() || cs.isOrderBy())) {
+    if (cs != null && !isForRemote && (cs.isGroupBy() || cs.isOrderBy())) {
-        cs.computeDependencies(ctx);       
-      }catch(QueryException qe) {
-        throw new QueryInvalidException("",qe);
+        cs.computeDependencies(ctx);
+      } catch (QueryException qe) {
+        throw new QueryInvalidException("", qe);
+
-    if (cache != null &&  !cache.getPdxReadSerialized()) {
+    if (cache != null && !cache.getPdxReadSerialized()) {
-  public Object execute()
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-          QueryInvocationTargetException {
+  public Object execute() throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-  public Object execute(Object[] parameters)
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+  public Object execute(Object[] parameters) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-        throw new IllegalArgumentException(LocalizedStrings.DefaultQuery_PARAMETERS_CANNOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DefaultQuery_PARAMETERS_CANNOT_BE_NULL.toLocalizedString());
-    
+
-      //Setting the readserialized flag for local queries
+      // Setting the readserialized flag for local queries
-        // For local queries returning pdx objects wrap the resultset with ResultsCollectionPdxDeserializerWrapper
+        // For local queries returning pdx objects wrap the resultset with
+        // ResultsCollectionPdxDeserializerWrapper
-        if(needsPDXDeserializationWrapper(true /* is query on PR*/) 
-            && result instanceof SelectResults ) {
-          //we use copy on read false here because the copying has already taken effect earlier in the PartitionedRegionQueryEvaluator
+        if (needsPDXDeserializationWrapper(true /* is query on PR */)
+            && result instanceof SelectResults) {
+          // we use copy on read false here because the copying has already taken effect earlier in
+          // the PartitionedRegionQueryEvaluator
-        } 
+        }
-      if (GemFireCacheImpl.getInstance() != null){
+      if (GemFireCacheImpl.getInstance() != null) {
-      //Only wrap/copy results when copy on read is set and an index is used
-      //This is because when an index is used, the results are actual references to values in the cache
-      //Currently as 7.0.1 when indexes are not used, iteration uses non tx entries to retrieve the value.
-      //The non tx entry already checks copy on read and returns a copy.
-      //We only wrap actual results and not UNDEFINED.
+      // Only wrap/copy results when copy on read is set and an index is used
+      // This is because when an index is used, the results are actual references to values in the
+      // cache
+      // Currently as 7.0.1 when indexes are not used, iteration uses non tx entries to retrieve the
+      // value.
+      // The non tx entry already checks copy on read and returns a copy.
+      // We only wrap actual results and not UNDEFINED.
-      //Takes into consideration that isRemoteQuery is already being checked with the if checks
-      //this flag is true if copy on read is set to true and we are copying at the entry level for queries is set to false (default) 
-      //OR copy on read is true and we used an index where copy on entry level for queries is set to true.  
-      //Due to bug#46970  index usage does not actually copy at the entry level so that is why we have the OR condition
-      boolean needsCopyOnReadWrapper = this.cache.getCopyOnRead() && !DefaultQueryService.COPY_ON_READ_AT_ENTRY_LEVEL || (((QueryExecutionContext)context).isIndexUsed() && DefaultQueryService.COPY_ON_READ_AT_ENTRY_LEVEL);
-      // For local queries returning pdx objects wrap the resultset with ResultsCollectionPdxDeserializerWrapper
+      // Takes into consideration that isRemoteQuery is already being checked with the if checks
+      // this flag is true if copy on read is set to true and we are copying at the entry level for
+      // queries is set to false (default)
+      // OR copy on read is true and we used an index where copy on entry level for queries is set
+      // to true.
+      // Due to bug#46970 index usage does not actually copy at the entry level so that is why we
+      // have the OR condition
+      boolean needsCopyOnReadWrapper =
+          this.cache.getCopyOnRead() && !DefaultQueryService.COPY_ON_READ_AT_ENTRY_LEVEL
+              || (((QueryExecutionContext) context).isIndexUsed()
+                  && DefaultQueryService.COPY_ON_READ_AT_ENTRY_LEVEL);
+      // For local queries returning pdx objects wrap the resultset with
+      // ResultsCollectionPdxDeserializerWrapper
-      if(needsPDXDeserializationWrapper(false /* is query on PR*/) && result instanceof SelectResults) {
-        result = new ResultsCollectionPdxDeserializerWrapper((SelectResults) result, needsCopyOnReadWrapper);
-      } 
-      else if (!isRemoteQuery() && this.cache.getCopyOnRead() && result instanceof SelectResults) {
+      if (needsPDXDeserializationWrapper(false /* is query on PR */)
+          && result instanceof SelectResults) {
+        result = new ResultsCollectionPdxDeserializerWrapper((SelectResults) result,
+            needsCopyOnReadWrapper);
+      } else if (!isRemoteQuery() && this.cache.getCopyOnRead()
+          && result instanceof SelectResults) {
-    }
-    catch (QueryExecutionCanceledException e) {
-      //query execution canceled exception will be thrown from the QueryMonitor
-      //canceled exception should not be null at this point as it should be set
-      //when query is canceled.
+    } catch (QueryExecutionCanceledException e) {
+      // query execution canceled exception will be thrown from the QueryMonitor
+      // canceled exception should not be null at this point as it should be set
+      // when query is canceled.
+      } else {
+        throw new QueryExecutionCanceledException(
+            "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-      else {
-        throw new QueryExecutionCanceledException("Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-      }
-    }
-    finally {
+    } finally {
-         queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
-  //For Order by queries ,since they are already ordered by the comparator 
-  //&& it takes care of conversion, we do not have to wrap it in a wrapper
+  // For Order by queries ,since they are already ordered by the comparator
+  // && it takes care of conversion, we do not have to wrap it in a wrapper
-      if( !isRemoteQuery() && !this.cache.getPdxReadSerialized() ) {
-        return true;
-        /*if(isQueryOnPR) {
-          // if the query is on PR we need a top level pdx deserialization wrapper only in case of 
-          //order by query or non distinct query
-          CompiledSelect cs = this.getSimpleSelect();
-          if(cs != null) {
-            return cs.getOrderByAttrs() != null ;
-          }else {
-           return true; 
-          }
-        }else {
-          return true;
-        }*/
-      }else {
-        return false;
-      }
+    if (!isRemoteQuery() && !this.cache.getPdxReadSerialized()) {
+      return true;
+      /*
+       * if(isQueryOnPR) { // if the query is on PR we need a top level pdx deserialization wrapper
+       * only in case of //order by query or non distinct query CompiledSelect cs =
+       * this.getSimpleSelect(); if(cs != null) { return cs.getOrderByAttrs() != null ; }else {
+       * return true; } }else { return true; }
+       */
+    } else {
+      return false;
+    }
- 
+
-      result =  this.serverProxy.query(this.queryString, parameters);
-//    } catch (QueryExecutionCanceledException e) {
-//      throw canceledException;
+      result = this.serverProxy.query(this.queryString, parameters);
+      // } catch (QueryExecutionCanceledException e) {
+      // throw canceledException;
-  /** Execute a PR Query on the specified bucket. Assumes query already meets restrictions
-    * for PR Query, and the first iterator in the FROM clause can be replaced with the
-    * BucketRegion.
-    */
+  /**
+   * Execute a PR Query on the specified bucket. Assumes query already meets restrictions for PR
+   * Query, and the first iterator in the FROM clause can be replaced with the BucketRegion.
+   */
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-        indexObserver = (IndexTrackingQueryObserver)qo;
-      }
-      else if (!QueryObserverHolder.hasObserver()) {
+        indexObserver = (IndexTrackingQueryObserver) qo;
+      } else if (!QueryObserverHolder.hasObserver()) {
-      }
-      else {
+      } else {
-    if (GemFireCacheImpl.getInstance() != null){
+    if (GemFireCacheImpl.getInstance() != null) {
-    if (queryMonitor != null && PRQueryProcessor.NUM_THREADS > 1){
+    if (queryMonitor != null && PRQueryProcessor.NUM_THREADS > 1) {
-            resultSize = ((Collection)result).size();
+          resultSize = ((Collection) result).size();
-      String queryVerboseMsg = DefaultQuery.getLogMessage(indexObserver, startTime,
-          otherObserver, resultSize, this.queryString, bukRgn);
+      String queryVerboseMsg = DefaultQuery.getLogMessage(indexObserver, startTime, otherObserver,
+          resultSize, this.queryString, bukRgn);
-        if(this.cache.getLogger().fineEnabled()){
-        this.cache.getLogger().fine(queryVerboseMsg);
+        if (this.cache.getLogger().fineEnabled()) {
+          this.cache.getLogger().fine(queryVerboseMsg);
-  public Object executeUsingContext(ExecutionContext context)
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+  public Object executeUsingContext(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    if (!((GemFireCacheImpl)this.cache).isClient()) { // fixes bug 42294
+    if (!((GemFireCacheImpl) this.cache).isClient()) { // fixes bug 42294
-      
+
-      }
-      catch (QueryExecutionCanceledException e) {
-        //query execution canceled exception will be thrown from the QueryMonitor
-        //canceled exception should not be null at this point as it should be set
-        //when query is canceled.
+      } catch (QueryExecutionCanceledException e) {
+        // query execution canceled exception will be thrown from the QueryMonitor
+        // canceled exception should not be null at this point as it should be set
+        // when query is canceled.
+        } else {
+          throw new QueryExecutionCanceledException(
+              "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-        else {
-          throw new QueryExecutionCanceledException("Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-        }
-      }
-      finally {
+      } finally {
-//    } catch (QueryExecutionCanceledException e) {
-//      throw canceledException;
+      // } catch (QueryExecutionCanceledException e) {
+      // throw canceledException;
-  private QueryExecutor checkQueryOnPR(Object[] parameters) throws RegionNotFoundException, PartitionOfflineException {
+  private QueryExecutor checkQueryOnPR(Object[] parameters)
+      throws RegionNotFoundException, PartitionOfflineException {
-    //    1) the query must be just a SELECT expression; (preceded by zero or more IMPORT statements)
-    //    2) the first FROM clause iterator cannot contain a subquery;
-    //    3) PR reference can only be in the first FROM clause
+    // 1) the query must be just a SELECT expression; (preceded by zero or more IMPORT statements)
+    // 2) the first FROM clause iterator cannot contain a subquery;
+    // 3) PR reference can only be in the first FROM clause
-    //QueryExecutor foundPR = null;
-    //Region otherRgn = null;
+    // QueryExecutor foundPR = null;
+    // Region otherRgn = null;
-    List <QueryExecutor>prs = new ArrayList<QueryExecutor>();
-    for (Iterator itr = getRegionsInQuery(parameters).iterator(); itr.hasNext(); ) {
-      String regionPath = (String)itr.next();
+    List<QueryExecutor> prs = new ArrayList<QueryExecutor>();
+    for (Iterator itr = getRegionsInQuery(parameters).iterator(); itr.hasNext();) {
+      String regionPath = (String) itr.next();
-        throw new RegionNotFoundException(LocalizedStrings.DefaultQuery_REGION_NOT_FOUND_0.toLocalizedString(regionPath));
+        throw new RegionNotFoundException(
+            LocalizedStrings.DefaultQuery_REGION_NOT_FOUND_0.toLocalizedString(regionPath));
-        ((PartitionedRegion)rgn).checkPROffline();
-        prs.add((QueryExecutor)rgn);
+        ((PartitionedRegion) rgn).checkPROffline();
+        prs.add((QueryExecutor) rgn);
-    } else if (prs.size() > 1) { //colocation checks; valid for more the one PRs
+    } else if (prs.size() > 1) { // colocation checks; valid for more the one PRs
-            .toLocalizedString(new Object[] { prs.get(0).getName(),
-                prs.get(1).getName() }));
+                .toLocalizedString(new Object[] {prs.get(0).getName(), prs.get(1).getName()}));
-      // If there are more than one  PRs they have to be co-located.
+      // If there are more than one PRs they have to be co-located.
-        
+
-          if ((((PartitionedRegion) eachPR).colocatedByList.contains(allPRs) || 
-              ((PartitionedRegion) allPRs).colocatedByList.contains(eachPR)))  {
+          if ((((PartitionedRegion) eachPR).colocatedByList.contains(allPRs)
+              || ((PartitionedRegion) allPRs).colocatedByList.contains(eachPR))) {
-          } 
+          }
-        if (!colocated) { 
+        if (!colocated) {
-              .toLocalizedString(new Object[] { eachPR.getName(),
-                  other.getName() }));
+                  .toLocalizedString(new Object[] {eachPR.getName(), other.getName()}));
-        
+
-        throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_QUERY_MUST_BE_A_SIMPLE_SELECT_WHEN_REFERENCING_A_PARTITIONED_REGION.toLocalizedString());
+        throw new UnsupportedOperationException(
+            LocalizedStrings.DefaultQuery_QUERY_MUST_BE_A_SIMPLE_SELECT_WHEN_REFERENCING_A_PARTITIONED_REGION
+                .toLocalizedString());
-          throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_THE_WHERE_CLAUSE_CANNOT_REFER_TO_A_REGION_WHEN_QUERYING_ON_A_PARTITIONED_REGION.toLocalizedString());
+          throw new UnsupportedOperationException(
+              LocalizedStrings.DefaultQuery_THE_WHERE_CLAUSE_CANNOT_REFER_TO_A_REGION_WHEN_QUERYING_ON_A_PARTITIONED_REGION
+                  .toLocalizedString());
-      CompiledIteratorDef itrDef = (CompiledIteratorDef)fromClauseIterator.next();
+      CompiledIteratorDef itrDef = (CompiledIteratorDef) fromClauseIterator.next();
-            throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONEDREGION_THE_FIRST_FROM_CLAUSE_ITERATOR_MUST_NOT_CONTAIN_A_SUBQUERY.toLocalizedString());
+            throw new UnsupportedOperationException(
+                LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONEDREGION_THE_FIRST_FROM_CLAUSE_ITERATOR_MUST_NOT_CONTAIN_A_SUBQUERY
+                    .toLocalizedString());
-          itrDef = (CompiledIteratorDef)fromClauseIterator.next();
+          itrDef = (CompiledIteratorDef) fromClauseIterator.next();
-            throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_FROM_CLAUSE_ITERATORS_OTHER_THAN_THE_FIRST_ONE_MUST_NOT_REFERENCE_ANY_REGIONS.toLocalizedString());
+            throw new UnsupportedOperationException(
+                LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_FROM_CLAUSE_ITERATORS_OTHER_THAN_THE_FIRST_ONE_MUST_NOT_REFERENCE_ANY_REGIONS
+                    .toLocalizedString());
-          for (Iterator itr = projs.iterator(); itr.hasNext(); ) {
-            Object[] rawProj = (Object[])itr.next();
-            CompiledValue proj = (CompiledValue)rawProj[1];
+          for (Iterator itr = projs.iterator(); itr.hasNext();) {
+            Object[] rawProj = (Object[]) itr.next();
+            CompiledValue proj = (CompiledValue) rawProj[1];
-              throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_PROJECTIONS_MUST_NOT_REFERENCE_ANY_REGIONS.toLocalizedString());
+              throw new UnsupportedOperationException(
+                  LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_PROJECTIONS_MUST_NOT_REFERENCE_ANY_REGIONS
+                      .toLocalizedString());
-          for (Iterator itr = orderBys.iterator(); itr.hasNext(); ) {
-            CompiledValue orderBy = (CompiledValue)itr.next();
+          for (Iterator itr = orderBys.iterator(); itr.hasNext();) {
+            CompiledValue orderBy = (CompiledValue) itr.next();
-              throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_ORDERBY_ATTRIBUTES_MUST_NOT_REFERENCE_ANY_REGIONS.toLocalizedString());
+              throw new UnsupportedOperationException(
+                  LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_ORDERBY_ATTRIBUTES_MUST_NOT_REFERENCE_ANY_REGIONS
+                      .toLocalizedString());
-  private void updateStatistics(long executionTime){
+  private void updateStatistics(long executionTime) {
-    ((GemFireCacheImpl)this.cache).getCachePerfStats().endQueryExecution(executionTime);
+    ((GemFireCacheImpl) this.cache).getCachePerfStats().endQueryExecution(executionTime);
-  //TODO: Implement the function. Toggle the isCompiled flag accordingly
+  // TODO: Implement the function. Toggle the isCompiled flag accordingly
-    throw new UnsupportedOperationException(LocalizedStrings.DefaultQuery_NOT_YET_IMPLEMENTED.toLocalizedString());
+    throw new UnsupportedOperationException(
+        LocalizedStrings.DefaultQuery_NOT_YET_IMPLEMENTED.toLocalizedString());
-     * Returns the total amount of time (in nanoseconds) spent executing
-     * the query.
+     * Returns the total amount of time (in nanoseconds) spent executing the query.
-   * Returns an unmodifiable Set containing the Region names  which are present in the Query.
-   * A region which is assosciated with the  query as a bind parameter
-   * will not be included in the list.
-   * The Region names returned by the query do not indicate anything about the state of the region or whether
-   * the region actually exists in the GemfireCache etc.
+   * Returns an unmodifiable Set containing the Region names which are present in the Query. A
+   * region which is assosciated with the query as a bind parameter will not be included in the
+   * list. The Region names returned by the query do not indicate anything about the state of the
+   * region or whether the region actually exists in the GemfireCache etc.
-   * Returns the CompiledSelect if this query consists of only a SELECT
-   * expression (possibly with IMPORTS as well).
-   * Otherwise, returns null
+   * Returns the CompiledSelect if this query consists of only a SELECT expression (possibly with
+   * IMPORTS as well). Otherwise, returns null
-      return (CompiledSelect)this.compiledQuery;
+      return (CompiledSelect) this.compiledQuery;
-     return (CompiledSelect)this.compiledQuery;
+    return (CompiledSelect) this.compiledQuery;
-   * @return int idenitifying the limit. A value of -1 indicates that no
-   * limit is imposed or the query is not a select query
-   * @throws QueryInvocationTargetException 
-   * @throws NameResolutionException 
-   * @throws TypeMismatchException 
-   * @throws FunctionDomainException 
+   * @return int idenitifying the limit. A value of -1 indicates that no limit is imposed or the
+   *         query is not a select query
+   * @throws QueryInvocationTargetException
+   * @throws NameResolutionException
+   * @throws TypeMismatchException
+   * @throws FunctionDomainException
-  public int getLimit(Object[] bindArguments) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    return this.compiledQuery instanceof CompiledSelect ?  ((CompiledSelect)this.compiledQuery).getLimitValue(bindArguments): -1;
+  public int getLimit(Object[] bindArguments) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+    return this.compiledQuery instanceof CompiledSelect
+        ? ((CompiledSelect) this.compiledQuery).getLimitValue(bindArguments) : -1;
-  public void setServerProxy(ServerProxy serverProxy){
+  public void setServerProxy(ServerProxy serverProxy) {
-   * Check to see if the query execution got canceled.
-   * The query gets canceled by the QueryMonitor if it takes more than the max
-   * query execution time or low memory situations
+   * Check to see if the query execution got canceled. The query gets canceled by the QueryMonitor
+   * if it takes more than the max query execution time or low memory situations
-  
+
-  
+
-  public void setIsCqQuery(boolean isCqQuery){
+  public void setIsCqQuery(boolean isCqQuery) {
-  public boolean isCqQuery(){
+  public boolean isCqQuery() {
-  public void setCqQuery(InternalCqQuery cqQuery){
+  public void setCqQuery(InternalCqQuery cqQuery) {
-  public InternalCqQuery getCqQuery(){
+  public InternalCqQuery getCqQuery() {
-    tempBuff.append("; Total Executions = " );
+    tempBuff.append("; Total Executions = ");
-    tempBuff.append("; Total Execution Time = " );
+    tempBuff.append("; Total Execution Time = ");
-  void setProxyCache(ProxyCache proxyCache){
+  void setProxyCache(ProxyCache proxyCache) {
-  public static String getLogMessage(QueryObserver observer,
-      long startTime, int resultSize, String query) {
+  public static String getLogMessage(QueryObserver observer, long startTime, int resultSize,
+      String query) {
-      IndexTrackingQueryObserver indexObserver = (IndexTrackingQueryObserver)observer;
+      IndexTrackingQueryObserver indexObserver = (IndexTrackingQueryObserver) observer;
-    if (resultSize != -1){
+    if (resultSize != -1) {
-    return "Query Executed in " + time + " ms;" +
-    (rowCountString != null ? rowCountString : "") +
-    (usedIndexesString != null ? usedIndexesString : "") +
-    " \"" + query + "\"";
+    return "Query Executed in " + time + " ms;" + (rowCountString != null ? rowCountString : "")
+        + (usedIndexesString != null ? usedIndexesString : "") + " \"" + query + "\"";
-  public static String getLogMessage(IndexTrackingQueryObserver indexObserver,
-      long startTime, String otherObserver, int resultSize, String query, BucketRegion bucket) {
+  public static String getLogMessage(IndexTrackingQueryObserver indexObserver, long startTime,
+      String otherObserver, int resultSize, String query, BucketRegion bucket) {
-          buf.append(entry.getKey().toString() + "(Results: " + entry.getValue() + ", Bucket: " + bucket.getId()+")");
+          buf.append(entry.getKey().toString() + "(Results: " + entry.getValue() + ", Bucket: "
+              + bucket.getId() + ")");
-      usedIndexesString = " indexesUsed(NA due to other observer in the way: "
-          + otherObserver + ")";
+      usedIndexesString =
+          " indexesUsed(NA due to other observer in the way: " + otherObserver + ")";
-    return "Query Executed" +
-    (startTime > 0L ? " in " + time + " ms;": ";") +
-    (rowCountString != null ? rowCountString : "") +
-    (usedIndexesString != null ? usedIndexesString : "") +
-    " \"" + query + "\"";
+    return "Query Executed" + (startTime > 0L ? " in " + time + " ms;" : ";")
+        + (rowCountString != null ? rowCountString : "")
+        + (usedIndexesString != null ? usedIndexesString : "") + " \"" + query + "\"";
-  public Object execute(RegionFunctionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public Object execute(RegionFunctionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-          LocalizedStrings.DefaultQuery_FUNCTIONCONTEXT_CANNOT_BE_NULL
-              .toLocalizedString());
+          LocalizedStrings.DefaultQuery_FUNCTIONCONTEXT_CANNOT_BE_NULL.toLocalizedString());
-    
+
-          LocalizedStrings.DefaultQuery_PARAMETERS_CANNOT_BE_NULL
-              .toLocalizedString());
+          LocalizedStrings.DefaultQuery_PARAMETERS_CANNOT_BE_NULL.toLocalizedString());
-        LocalDataSet localDataSet = (LocalDataSet) PartitionRegionHelper
-            .getLocalDataForContext(context);
+        LocalDataSet localDataSet =
+            (LocalDataSet) PartitionRegionHelper.getLocalDataForContext(context);
-//    } catch (QueryExecutionCanceledException e) {
-//      throw canceledException;
+      // } catch (QueryExecutionCanceledException e) {
+      // throw canceledException;
+   * 
-        resultSize = ((Collection)result).size();
+        resultSize = ((Collection) result).size();
-      String queryVerboseMsg = DefaultQuery.getLogMessage(indexObserver,
-          startTime, resultSize, queryString);
+      String queryVerboseMsg =
+          DefaultQuery.getLogMessage(indexObserver, startTime, resultSize, queryString);
-  
+
-    if (this.cache != null && this.cache.getLogger().infoEnabled() && this.traceOn ) {
+    if (this.cache != null && this.cache.getLogger().infoEnabled() && this.traceOn) {
-      }      
+      }
-      String queryVerboseMsg = DefaultQuery.getLogMessage(indexObserver,
-          startTime, resultSize, queryString);
+      String queryVerboseMsg =
+          DefaultQuery.getLogMessage(indexObserver, startTime, resultSize, queryString);
-  
- /**
-  * set keepSerialized flag for remote queries of type
-  * 'select *' having independent operators
-  * @param cs
-  * @param context
-  */
-  public void keepResultsSerialized(CompiledSelect cs,
-      ExecutionContext context) {
+
+  /**
+   * set keepSerialized flag for remote queries of type 'select *' having independent operators
+   * 
+   * @param cs
+   * @param context
+   */
+  public void keepResultsSerialized(CompiledSelect cs, ExecutionContext context) {
-      //for dependent iterators, deserialization is required
+      // for dependent iterators, deserialization is required
-          && cs.getWhereClause() == null
-          && cs.getProjectionAttributes() == null && !cs.isDistinct()
-          && cs.getOrderByAttrs() == null
-          ) {
+          && cs.getWhereClause() == null && cs.getProjectionAttributes() == null && !cs.isDistinct()
+          && cs.getOrderByAttrs() == null) {
-  
-  
+
+
+

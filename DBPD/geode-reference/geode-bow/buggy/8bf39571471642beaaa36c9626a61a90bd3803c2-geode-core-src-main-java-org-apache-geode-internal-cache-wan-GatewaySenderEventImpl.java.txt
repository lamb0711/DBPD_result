Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class GatewaySenderEventImpl implements 
-    AsyncEvent, DataSerializableFixedID, Conflatable, Sizeable, Releasable {
+public class GatewaySenderEventImpl
+    implements AsyncEvent, DataSerializableFixedID, Conflatable, Sizeable, Releasable {
-  
+
-  
+
-  
+
-   * The serialized new value for this event's key.
-   * May not be computed at construction time.
+   * The serialized new value for this event's key. May not be computed at construction time.
-  
+
-   * The "object" form of the value.
-   * Will be null after this object is deserialized.
+   * The "object" form of the value. Will be null after this object is deserialized.
-  
+
-   * Whether this event is acknowledged after the ack received by
-   * AckReaderThread. As of now this is getting used for PDX related
-   * GatewaySenderEvent. But can be extended for for other GatewaySenderEvent.
+   * Whether this event is acknowledged after the ack received by AckReaderThread. As of now this is
+   * getting used for PDX related GatewaySenderEvent. But can be extended for for other
+   * GatewaySenderEvent.
-  
+
-   * Whether this event is dispatched by dispatcher. As of now this is getting
-   * used for PDX related GatewaySenderEvent. But can be extended for for other
-   * GatewaySenderEvent.
+   * Whether this event is dispatched by dispatcher. As of now this is getting used for PDX related
+   * GatewaySenderEvent. But can be extended for for other GatewaySenderEvent.
-   * For ParalledGatewaySender we need bucketId of the PartitionRegion on which
-   * the update operation was applied.
+   * For ParalledGatewaySender we need bucketId of the PartitionRegion on which the update operation
+   * was applied.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-//  /**
-//   * Is this thread in the process of deserializing this event?
-//   */
-//  public static final ThreadLocal isDeserializingValue = new ThreadLocal() {
-//    @Override
-//    protected Object initialValue() {
-//      return Boolean.FALSE;
-//    }
-//  };
+  // /**
+  // * Is this thread in the process of deserializing this event?
+  // */
+  // public static final ThreadLocal isDeserializingValue = new ThreadLocal() {
+  // @Override
+  // protected Object initialValue() {
+  // return Boolean.FALSE;
+  // }
+  // };
-  public GatewaySenderEventImpl() {
-  }
+  public GatewaySenderEventImpl() {}
-   * @param operation
-   *          The operation for this event (e.g. AFTER_CREATE)
-   * @param event
-   *          The <code>CacheEvent</code> on which this
-   *          <code>GatewayEventImpl</code> is based
-   * @param substituteValue
-   *          The value to be enqueued instead of the value in the event.
+   * @param operation The operation for this event (e.g. AFTER_CREATE)
+   * @param event The <code>CacheEvent</code> on which this <code>GatewayEventImpl</code> is based
+   * @param substituteValue The value to be enqueued instead of the value in the event.
-      Object substituteValue, boolean initialize, int bucketId)
-      throws IOException {
+      Object substituteValue, boolean initialize, int bucketId) throws IOException {
-   * @param operation
-   *          The operation for this event (e.g. AFTER_CREATE)
-   * @param ce
-   *          The <code>CacheEvent</code> on which this
-   *          <code>GatewayEventImpl</code> is based
-   * @param substituteValue
-   *          The value to be enqueued instead of the value in the event.
-   * @param initialize
-   *          Whether to initialize this instance
+   * @param operation The operation for this event (e.g. AFTER_CREATE)
+   * @param ce The <code>CacheEvent</code> on which this <code>GatewayEventImpl</code> is based
+   * @param substituteValue The value to be enqueued instead of the value in the event.
+   * @param initialize Whether to initialize this instance
-  public GatewaySenderEventImpl(EnumListenerEvent operation, CacheEvent ce,
-      Object substituteValue, boolean initialize) throws IOException {
+  public GatewaySenderEventImpl(EnumListenerEvent operation, CacheEvent ce, Object substituteValue,
+      boolean initialize) throws IOException {
-    final EntryEventImpl event = (EntryEventImpl)ce;
+    final EntryEventImpl event = (EntryEventImpl) ce;
-    this.region = (LocalRegion)event.getRegion();
+    this.region = (LocalRegion) event.getRegion();
-    this.possibleDuplicate = event.isPossibleDuplicate(); 
-    
-    //Initialize ack and dispatch status of events
+    this.possibleDuplicate = event.isPossibleDuplicate();
+
+    // Initialize ack and dispatch status of events
-    
+
-    this.callbackArgument = (GatewaySenderEventCallbackArgument)
-        event.getRawCallbackArgument();
+    this.callbackArgument = (GatewaySenderEventCallbackArgument) event.getRawCallbackArgument();
-    
-    //initialize the operation detail 
+
+    // initialize the operation detail
-    
+
-   * Used to create a heap copy of an offHeap event.
-   * Note that this constructor produces an instance that does not need to be released.
+   * Used to create a heap copy of an offHeap event. Note that this constructor produces an instance
+   * that does not need to be released.
-  
+
-    case CREATE_ACTION:
-      switch (this.operationDetail) {
-      case OP_DETAIL_LOCAL_LOAD:
-        op = Operation.LOCAL_LOAD_CREATE;
+      case CREATE_ACTION:
+        switch (this.operationDetail) {
+          case OP_DETAIL_LOCAL_LOAD:
+            op = Operation.LOCAL_LOAD_CREATE;
+            break;
+          case OP_DETAIL_NET_LOAD:
+            op = Operation.NET_LOAD_CREATE;
+            break;
+          case OP_DETAIL_PUTALL:
+            op = Operation.PUTALL_CREATE;
+            break;
+          case OP_DETAIL_NONE:
+            op = Operation.CREATE;
+            break;
+          // if operationDetail is none of the above, then default should be NONE
+          default:
+            op = Operation.CREATE;
+            break;
+        }
-      case OP_DETAIL_NET_LOAD:
-    	op = Operation.NET_LOAD_CREATE;
-    	break;
-      case OP_DETAIL_PUTALL:
-        op = Operation.PUTALL_CREATE;
-    	break;
-      case OP_DETAIL_NONE:
-    	op = Operation.CREATE;
-    	break;
-      //if operationDetail is none of the above, then default should be NONE 
-      default:
-    	op = Operation.CREATE;
-    	break;
-      }
-      break;
-    case UPDATE_ACTION:
-      switch (this.operationDetail) {
-      case OP_DETAIL_LOCAL_LOAD:
-    	op = Operation.LOCAL_LOAD_UPDATE;
-    	break;
-      case OP_DETAIL_NET_LOAD:
-    	op = Operation.NET_LOAD_UPDATE;
-    	break;
-      case OP_DETAIL_PUTALL:
-    	op = Operation.PUTALL_UPDATE;
-    	break;
-      case OP_DETAIL_NONE:
-    	op = Operation.UPDATE;
-    	break;
-      //if operationDetail is none of the above, then default should be NONE 
-      default:
-    	op = Operation.UPDATE;
-    	break;
-      }
-      break;
-    case DESTROY_ACTION:
-      if (this.operationDetail == OP_DETAIL_REMOVEALL) {
-        op = Operation.REMOVEALL_DESTROY;
-      } else {
-        op = Operation.DESTROY;
-      }
-      break;
-    case VERSION_ACTION:
-      op = Operation.UPDATE_VERSION_STAMP;
-      break;
-    case INVALIDATE_ACTION:
-      op = Operation.INVALIDATE;
-      break;
+      case UPDATE_ACTION:
+        switch (this.operationDetail) {
+          case OP_DETAIL_LOCAL_LOAD:
+            op = Operation.LOCAL_LOAD_UPDATE;
+            break;
+          case OP_DETAIL_NET_LOAD:
+            op = Operation.NET_LOAD_UPDATE;
+            break;
+          case OP_DETAIL_PUTALL:
+            op = Operation.PUTALL_UPDATE;
+            break;
+          case OP_DETAIL_NONE:
+            op = Operation.UPDATE;
+            break;
+          // if operationDetail is none of the above, then default should be NONE
+          default:
+            op = Operation.UPDATE;
+            break;
+        }
+        break;
+      case DESTROY_ACTION:
+        if (this.operationDetail == OP_DETAIL_REMOVEALL) {
+          op = Operation.REMOVEALL_DESTROY;
+        } else {
+          op = Operation.DESTROY;
+        }
+        break;
+      case VERSION_ACTION:
+        op = Operation.UPDATE_VERSION_STAMP;
+        break;
+      case INVALIDATE_ACTION:
+        op = Operation.INVALIDATE;
+        break;
-  
-  public EnumListenerEvent getEnumListenerEvent(){
+
+  public EnumListenerEvent getEnumListenerEvent() {
+
+
-      WrappedCallbackArgument wca = (WrappedCallbackArgument)result;
+      WrappedCallbackArgument wca = (WrappedCallbackArgument) result;
-  
+
-   * Return the value as a byte[] array, if it is plain byte array,
-   * otherwise return a cache deserializable or plain object, depending
-   * on if the currently held form of the object is serialized or not.
+   * Return the value as a byte[] array, if it is plain byte array, otherwise return a cache
+   * deserializable or plain object, depending on if the currently held form of the object is
+   * serialized or not.
-   *  //OFFHEAP TODO: Optimize callers by returning a reference to the off heap value
+   * //OFFHEAP TODO: Optimize callers by returning a reference to the off heap value
-      //if the value is a byte array, just return it
+      // if the value is a byte array, just return it
-  
+
-   * Return the currently held form of the object.
-   * May return a retained OFF_HEAP_REFERENCE.
+   * Return the currently held form of the object. May return a retained OFF_HEAP_REFERENCE.
-      result = this.valueObj;
-      if (result instanceof StoredObject && ((StoredObject) result).hasRefCount()) {
-        if (this.valueObjReleased) {
-          result = null;
-        } else {
-          StoredObject ohref = (StoredObject) result;
-          if (!ohref.retain()) {
+        result = this.valueObj;
+        if (result instanceof StoredObject && ((StoredObject) result).hasRefCount()) {
+          if (this.valueObjReleased) {
-          } else if (this.valueObjReleased) {
-            ohref.release();
-            result = null;
+          } else {
+            StoredObject ohref = (StoredObject) result;
+            if (!ohref.retain()) {
+              result = null;
+            } else if (this.valueObjReleased) {
+              ohref.release();
+              result = null;
+            }
-      }
-          throw new IllegalStateException("Value is no longer available. getDeserializedValue must be called before processEvents returns.");
+          throw new IllegalStateException(
+              "Value is no longer available. getDeserializedValue must be called before processEvents returns.");
-          return ((StoredObject)so).getValueAsDeserializedHeapObject();
+          return ((StoredObject) so).getValueAsDeserializedHeapObject();
-          throw new IllegalStateException("expected valueObj field to be an instance of StoredObject but it was " + so);
+          throw new IllegalStateException(
+              "expected valueObj field to be an instance of StoredObject but it was " + so);
-    }
-    else {
+    } else {
-          StoredObject so = (StoredObject)vo;
+          StoredObject so = (StoredObject) vo;
-            throw new IllegalStateException("Value is no longer available. getDeserializedValue must be called before processEvents returns.");
+            throw new IllegalStateException(
+                "Value is no longer available. getDeserializedValue must be called before processEvents returns.");
-  
+
-   * Returns the value in the form of a String.
-   * This should be used by code that wants to log
-   * the value. This is a debugging exception.
+   * Returns the value in the form of a String. This should be used by code that wants to log the
+   * value. This is a debugging exception.
-   * If the value owned of this event is just bytes return that byte array;
-   * otherwise serialize the value object and return the serialized bytes.
-   * Use {@link #getValueIsObject()} to determine if the result is raw or serialized bytes.
+   * If the value owned of this event is just bytes return that byte array; otherwise serialize the
+   * value object and return the serialized bytes. Use {@link #getValueIsObject()} to determine if
+   * the result is raw or serialized bytes.
-              throw new IllegalStateException("Value is no longer available. getSerializedValue must be called before processEvents returns.");
+              throw new IllegalStateException(
+                  "Value is no longer available. getSerializedValue must be called before processEvents returns.");
-    out.writeLong(getVersionTimeStamp());    
+    out.writeLong(getVersionTimeStamp());
-    if (version < 0x11 &&
-        (in instanceof InputStream) &&
-        InternalDataSerializer.getVersionForDataStream(in) == Version.CURRENT) {
-      in = new VersionedDataInputStream((InputStream)in, Version.GFE_701);
+    if (version < 0x11 && (in instanceof InputStream)
+        && InternalDataSerializer.getVersionForDataStream(in) == Version.CURRENT) {
+      in = new VersionedDataInputStream((InputStream) in, Version.GFE_701);
-    this.id = (EventID)DataSerializer.readObject(in);   
+    this.id = (EventID) DataSerializer.readObject(in);
-    this.callbackArgument = (GatewaySenderEventCallbackArgument)DataSerializer
-        .readObject(in);
+    this.callbackArgument = (GatewaySenderEventCallbackArgument) DataSerializer.readObject(in);
-  protected void deserializeKey(DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void deserializeKey(DataInput in) throws IOException, ClassNotFoundException {
-    buffer.append("SenderEventImpl[").append("id=").append(this.id)
-        .append(";action=").append(this.action).append(";operation=")
-        .append(getOperation()).append(";region=").append(this.regionPath)
-        .append(";key=").append(this.key).append(";value=")
-        .append(getValueAsString(true)).append(";valueIsObject=")
-        .append(this.valueIsObject).append(";numberOfParts=")
-        .append(this.numberOfParts).append(";callbackArgument=")
-        .append(this.callbackArgument).append(";possibleDuplicate=")
-        .append(this.possibleDuplicate).append(";creationTime=")
-        .append(this.creationTime).append(";shadowKey= ")
-        .append(this.shadowKey)
-        .append(";timeStamp=").append(this.versionTimeStamp)
-        .append(";acked=").append(this.isAcked)
-        .append(";dispatched=").append(this.isDispatched)
+    buffer.append("SenderEventImpl[").append("id=").append(this.id).append(";action=")
+        .append(this.action).append(";operation=").append(getOperation()).append(";region=")
+        .append(this.regionPath).append(";key=").append(this.key).append(";value=")
+        .append(getValueAsString(true)).append(";valueIsObject=").append(this.valueIsObject)
+        .append(";numberOfParts=").append(this.numberOfParts).append(";callbackArgument=")
+        .append(this.callbackArgument).append(";possibleDuplicate=").append(this.possibleDuplicate)
+        .append(";creationTime=").append(this.creationTime).append(";shadowKey= ")
+        .append(this.shadowKey).append(";timeStamp=").append(this.versionTimeStamp)
+        .append(";acked=").append(this.isAcked).append(";dispatched=").append(this.isDispatched)
-    return ((Boolean)isSerializingValue.get()).booleanValue();
+    return ((Boolean) isSerializingValue.get()).booleanValue();
-//   public static boolean isDeserializingValue() {
-//     return ((Boolean)isDeserializingValue.get()).booleanValue();
-//   }
+  // public static boolean isDeserializingValue() {
+  // return ((Boolean)isDeserializingValue.get()).booleanValue();
+  // }
-   * Determines whether or not to conflate this message. This method will answer
-   * true IFF the message's operation is AFTER_UPDATE and its region has enabled
-   * are conflation. Otherwise, this method will answer false. Messages whose
-   * operation is AFTER_CREATE, AFTER_DESTROY, AFTER_INVALIDATE or
-   * AFTER_REGION_DESTROY are not conflated.
+   * Determines whether or not to conflate this message. This method will answer true IFF the
+   * message's operation is AFTER_UPDATE and its region has enabled are conflation. Otherwise, this
+   * method will answer false. Messages whose operation is AFTER_CREATE, AFTER_DESTROY,
+   * AFTER_INVALIDATE or AFTER_REGION_DESTROY are not conflated.
-   * Initialize the unique identifier for this event. This id is used by the
-   * receiving <code>Gateway</code> to keep track of which events have been
-   * processed. Duplicates can be dropped.
+   * Initialize the unique identifier for this event. This id is used by the receiving
+   * <code>Gateway</code> to keep track of which events have been processed. Duplicates can be
+   * dropped.
-   * Initialize this instance. Get the useful parts of the input operation and
-   * event.
+   * Initialize this instance. Get the useful parts of the input operation and event.
-  // Initializes the value object. This function need a relook because the 
+  // Initializes the value object. This function need a relook because the
-    // If the value is already serialized, use it.
-    this.valueIsObject = 0x01;
-    /**
-     * so ends up being stored in this.valueObj
-     */
-    @Retained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
-    StoredObject so = null;
-    {
-      ReferenceCountHelper.setReferenceCountOwner(this);
-      so = event.getOffHeapNewValue();
-      ReferenceCountHelper.setReferenceCountOwner(null);      
-    }
-    
-    if (so != null) {
-//    if (so != null  && !event.hasDelta()) {
-      // Since GatewaySenderEventImpl instances can live for a long time in the gateway region queue
-      // we do not want the StoredObject to be one that keeps the heap form cached.
-      so = so.getStoredObjectWithoutHeapForm(); // fixes 51999
-      this.valueObj = so;
-      if (!so.isSerialized()) {
-        this.valueIsObject = 0x00;
+      // If the value is already serialized, use it.
+      this.valueIsObject = 0x01;
+      /**
+       * so ends up being stored in this.valueObj
+       */
+      @Retained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+      StoredObject so = null;
+      {
+        ReferenceCountHelper.setReferenceCountOwner(this);
+        so = event.getOffHeapNewValue();
+        ReferenceCountHelper.setReferenceCountOwner(null);
-    } else if (event.getCachedSerializedNewValue() != null) {
-      // We want this to have lower precedence than StoredObject so that the gateway
-      // can share a reference to the off-heap value.
-      this.value = event.getCachedSerializedNewValue();
-    } else {
-      final Object newValue = event.getRawNewValue();
-      assert !(newValue instanceof StoredObject); // since we already called getOffHeapNewValue() and it returned null
-      if (newValue instanceof CachedDeserializable) {
-        this.value = ((CachedDeserializable) newValue).getSerializedValue();
-      } else if (newValue instanceof byte[]) {
-        // The value is byte[]. Set _valueIsObject flag to 0x00 (not an object)
-        this.value = (byte[])newValue;
-        this.valueIsObject = 0x00;
+
+      if (so != null) {
+        // if (so != null && !event.hasDelta()) {
+        // Since GatewaySenderEventImpl instances can live for a long time in the gateway region
+        // queue
+        // we do not want the StoredObject to be one that keeps the heap form cached.
+        so = so.getStoredObjectWithoutHeapForm(); // fixes 51999
+        this.valueObj = so;
+        if (!so.isSerialized()) {
+          this.valueIsObject = 0x00;
+        }
+      } else if (event.getCachedSerializedNewValue() != null) {
+        // We want this to have lower precedence than StoredObject so that the gateway
+        // can share a reference to the off-heap value.
+        this.value = event.getCachedSerializedNewValue();
-        // The value is an object. It will be serialized later when getSerializedValue is called.
-        this.valueObj = newValue;
-        // to prevent bug 48281 we need to serialize it now
-        this.getSerializedValue();
-        this.valueObj = null;
+        final Object newValue = event.getRawNewValue();
+        assert !(newValue instanceof StoredObject); // since we already called getOffHeapNewValue()
+                                                    // and it returned null
+        if (newValue instanceof CachedDeserializable) {
+          this.value = ((CachedDeserializable) newValue).getSerializedValue();
+        } else if (newValue instanceof byte[]) {
+          // The value is byte[]. Set _valueIsObject flag to 0x00 (not an object)
+          this.value = (byte[]) newValue;
+          this.valueIsObject = 0x00;
+        } else {
+          // The value is an object. It will be serialized later when getSerializedValue is called.
+          this.valueObj = newValue;
+          // to prevent bug 48281 we need to serialize it now
+          this.getSerializedValue();
+          this.valueObj = null;
+        }
-    }
-   * @param operation
-   *          The operation from which to initialize this event's action and
-   *          number of parts
+   * @param operation The operation from which to initialize this event's action and number of parts
-  
+
-   * @return    EventSequenceID
+   * 
+   * @return EventSequenceID
-    return new EventSequenceID(id.getMembershipID(), id.getThreadID(), id
-        .getSequenceID());
+    return new EventSequenceID(id.getMembershipID(), id.getThreadID(), id.getSequenceID());
-  
+
-  
+
-    
+
-      size = CachedDeserializableFactory.calcMemSize(obj)
-          - Sizeable.PER_OBJECT_OVERHEAD;
+      size = CachedDeserializableFactory.calcMemSize(obj) - Sizeable.PER_OBJECT_OVERHEAD;
-    return this.region != null ? this.region : CacheFactory.getAnyInstance()
-        .getRegion(this.regionPath);
+    return this.region != null ? this.region
+        : CacheFactory.getAnyInstance().getRegion(this.regionPath);
-   * @param tailKey
-   *          the tailKey to set
+   * @param tailKey the tailKey to set
-  
+
-  
-  public static void release(@Released(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE) Object o) {
+
+  public static void release(
+      @Released(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE) Object o) {
-   * Make a heap copy of this off-heap event and return it.
-   * A copy only needs to be made if the event's value is stored off-heap.
-   * If it is already on the java heap then just return "this".
-   * If it was stored off-heap and is no longer available (because it was released) then return null.
+   * Make a heap copy of this off-heap event and return it. A copy only needs to be made if the
+   * event's value is stored off-heap. If it is already on the java heap then just return "this". If
+   * it was stored off-heap and is no longer available (because it was released) then return null.
-  
+

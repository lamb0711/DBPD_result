GEODE-2804 Caching the InetAddress for configured ip string

1. We keep configure host string in HostAddress class
2. We reuse InetsocketAddress if it is ipString.
3. Client has logic to retry thus we keep InetsocketAddress even if
   it is not ip string.

GEODE-3017 IPv6 issue on windows. Above changes fixed this issue.

GEODE-2940 Now we don't validate configure host string on start. As
there is possibility that host may not available.

1. Earlier wan config were failing because of that. Now we just keep
   those configure host string. And try this later.

Added unit tests for it.

+import org.apache.geode.distributed.internal.membership.gms.membership.HostAddress;
-  private static final Comparator<InetSocketAddress> SOCKET_ADDRESS_COMPARATOR =
-      new Comparator<InetSocketAddress>() {
-        public int compare(InetSocketAddress o1, InetSocketAddress o2) {
+  private static final Comparator<HostAddress> SOCKET_ADDRESS_COMPARATOR =
+      new Comparator<HostAddress>() {
+        public int compare(HostAddress address, HostAddress otherAddress) {
+          InetSocketAddress inetSocketAddress = address.getSocketInetAddress();
+          InetSocketAddress otherInetSocketAddress = otherAddress.getSocketInetAddress();
-          if (o1.getAddress() == null || o2.getAddress() == null) {
+          if (inetSocketAddress.getAddress() == null
+              || otherInetSocketAddress.getAddress() == null) {
-          int result = o1.getAddress().getCanonicalHostName()
-              .compareTo(o2.getAddress().getCanonicalHostName());
+          int result = inetSocketAddress.getAddress().getCanonicalHostName()
+              .compareTo(otherInetSocketAddress.getAddress().getCanonicalHostName());
+          } else {
+            return inetSocketAddress.getPort() - otherInetSocketAddress.getPort();
-
-      else
-            return o1.getPort() - o2.getPort();
-  protected final List<InetSocketAddress> initialLocators;
+  protected final List<HostAddress> initialLocators;
-  /**
-   * @param contacts
-   * @param serverGroup
-   * @param handshakeTimeout
-   */
-  public AutoConnectionSourceImpl(List<InetSocketAddress> contacts, String serverGroup,
-      int handshakeTimeout) {
-    ArrayList<InetSocketAddress> tmpContacts = new ArrayList<InetSocketAddress>(contacts);
+  public AutoConnectionSourceImpl(List<InetSocketAddress> locators, List<HostAddress> contacts,
+      String serverGroup, int handshakeTimeout) {
+    ArrayList<HostAddress> tmpContacts =
+        new ArrayList<HostAddress>(Collections.unmodifiableList(contacts));
-    this.initialLocators = Collections.unmodifiableList(tmpContacts);
+    this.initialLocators = Collections.unmodifiableList(this.locators.get().getLocatorAddresses());
-  private ServerLocationResponse queryOneLocator(InetSocketAddress locator,
+  private ServerLocationResponse queryOneLocator(HostAddress locator,
-    InetAddress addr = locator.getAddress();
-    int port = locator.getPort();
-      returnObj = tcpClient.requestToServer(addr, port, request, connectionTimeout);
+      returnObj = tcpClient.requestToServer(locator.getSocketInetAddressNoLookup(), request,
+          connectionTimeout, true);
-        reportLiveLocator(locator);
+        reportLiveLocator(locator.getSocketInetAddressNoLookup());
-      reportDeadLocator(locator, ioe);
+      reportDeadLocator(locator.getSocketInetAddressNoLookup(), ioe);
+      updateLocatorInLocatorList(locator);
-      reportDeadLocator(locator, e);
+      reportDeadLocator(locator.getSocketInetAddressNoLookup(), e);
+  /**
+   * If connecting to the locator fails with an IOException, this may be because the locator's IP
+   * has changed. Add the locator back to the list of locators using host address rather than IP.
+   * This will cause another DNS lookup, hopefully finding the locator.
+   * 
+   * @param locator
+   */
+  protected void updateLocatorInLocatorList(HostAddress locator) {
+    if (locator.getSocketInetAddressNoLookup().getHostName() != null && !locator.isIpString()) {
+      LocatorList locatorList = locators.get();
+      List<HostAddress> newLocatorsList = new ArrayList<>();
+
+      for (HostAddress tloc : locatorList.getLocatorAddresses()) {
+        if (tloc.equals(locator)) {
+          /**
+           * This call doesn't throw UnknownHostException;
+           */
+          InetSocketAddress changeLoc = new InetSocketAddress(locator.getHostName(),
+              locator.getSocketInetAddressNoLookup().getPort());
+          HostAddress hostAddress = new HostAddress(changeLoc, locator.getHostName());
+          newLocatorsList.add(hostAddress);
+          logger.info("updateLocatorInLocatorList changing locator list: loc form: " + locator
+              + " ,loc to: " + changeLoc);
+        } else {
+          newLocatorsList.add(tloc);
+        }
+      }
+
+      logger.info("updateLocatorInLocatorList locator list from:" + locatorList.getLocators()
+          + " to: " + newLocatorsList);
+
+      LocatorList newLocatorList = new LocatorList(newLocatorsList);
+      locators.set(newLocatorList);
+    }
+  }
+
+  protected List<InetSocketAddress> getCurrentLocators() {
+    return locators.get().getLocators();
+  }
+
-      InetSocketAddress locator = (InetSocketAddress) controllerItr.next();
+      HostAddress hostAddress = (HostAddress) controllerItr.next();
-        logger.debug("Sending query to locator {}: {}", locator, request);
+        logger.debug("Sending query to locator {}: {}", hostAddress, request);
-      response = queryOneLocator(locator, request);
+      response = queryOneLocator(hostAddress, request);
-        logger.debug("Received query response from locator {}: {}", locator, response);
+        logger.debug("Received query response from locator {}: {}", hostAddress, response);
-    List<InetSocketAddress> newLocators = new ArrayList<InetSocketAddress>(locatorResponse.size());
-    List<InetSocketAddress> newOnlineLocators =
-        new ArrayList<InetSocketAddress>(locatorResponse.size());
+    List<HostAddress> newLocatorAddresses = new ArrayList<HostAddress>(locatorResponse.size());
+    List<HostAddress> newOnlineLocators = new ArrayList<>(locatorResponse.size());
-    Set<InetSocketAddress> badLocators = new HashSet<InetSocketAddress>(initialLocators);
+    Set<HostAddress> badLocators = new HashSet<>(initialLocators);
-      newLocators.add(address);
-      newOnlineLocators.add(address);
-      badLocators.remove(address);
+      HostAddress hostAddress = new HostAddress(address, locator.getHostName());
+      newLocatorAddresses.add(hostAddress);
+      newOnlineLocators.add(hostAddress);
+      badLocators.remove(hostAddress);
-    newLocators.addAll(badLocators);
+    addbadLocators(newLocatorAddresses, badLocators);
+
+    LocatorList newLocatorList = new LocatorList(newLocatorAddresses);
+      List<InetSocketAddress> newLocators = newLocatorList.getLocators();
-      ArrayList<InetSocketAddress> addedLocators = new ArrayList<InetSocketAddress>(newLocators);
+      ArrayList<InetSocketAddress> addedLocators = new ArrayList<>(newLocators);
-    LocatorList newLocatorList = new LocatorList(newLocators);
+
+
+
-    pool.getStats().setLocatorCount(newLocators.size());
+    pool.getStats().setLocatorCount(newLocatorAddresses.size());
+  }
+
+  /**
+   * This method will add bad locator only when locator with hostname and port is not already in
+   * list.
+   */
+  protected void addbadLocators(List<HostAddress> newLocators, Set<HostAddress> badLocators) {
+    for (HostAddress badloc : badLocators) {
+      boolean addIt = true;
+      for (HostAddress goodloc : newLocators) {
+        boolean isSameHost = badloc.getHostName().equals(goodloc.getHostName());
+        if (isSameHost && badloc.getPort() == goodloc.getPort()) {
+          // ip has been changed so don't add this in current
+          // list
+          addIt = false;
+          break;
+
+        }
+      }
+      if (addIt) {
+        newLocators.add(badloc);
+      }
+    }
-    protected final List<InetSocketAddress> locators;
+    protected final List<HostAddress> locators;
-    public LocatorList(List<InetSocketAddress> locators) {
+    public LocatorList(List<HostAddress> locators) {
-    public Collection<InetSocketAddress> getLocators() {
+    public List<InetSocketAddress> getLocators() {
+      List<InetSocketAddress> locs = new ArrayList<>();
+      for (HostAddress la : locators) {
+        locs.add(la.getSocketInetAddress());
+      }
+      return locs;
+    }
+
+    public List<HostAddress> getLocatorAddresses() {
-    public Iterator<InetSocketAddress> iterator() {
+    public Iterator<HostAddress> iterator() {
-    protected class LocatorIterator implements Iterator<InetSocketAddress> {
+    protected class LocatorIterator implements Iterator<HostAddress> {
-      public InetSocketAddress next() {
+      public HostAddress next() {
-          InetSocketAddress nextLocator = locators.get(index);
+          HostAddress nextLocator = locators.get(index);

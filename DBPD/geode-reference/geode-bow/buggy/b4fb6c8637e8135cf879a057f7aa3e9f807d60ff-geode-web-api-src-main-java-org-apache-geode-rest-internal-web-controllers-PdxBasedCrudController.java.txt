Revert "GEODE-7938: added keys query param to GET, PUT, and DELETE /{region} endpoints (#4901)"

This reverts commit 6263f1f9a4782433d013c6b759bda8c84216b595.

-import java.net.URI;
-import org.apache.geode.rest.internal.web.controllers.support.UpdateOp;
-  @ApiOperation(value = "create entry", notes = "Create (put-if-absent) data in region."
-      + " The key is not decoded so if the key contains special characters use PUT /{region}?keys=EncodedKey&op=CREATE.")
+  @ApiOperation(value = "create entry", notes = "Create (put-if-absent) data in region")
+
+    logger.debug(
+        "Posting (creating/putIfAbsent) JSON document ({}) to Region ({}) with Key ({})...", json,
+        region, key);
+
-    return create(region, key, json, false);
-  }
-
-  private ResponseEntity<?> create(String region, String key, String json,
-      boolean keyInQueryParam) {
-    logger.debug("Create JSON document ({}) in Region ({}) with Key ({})...", json, region, key);
-
-    if (keyInQueryParam) {
-      headers.setLocation(toUriWithKeys(new String[] {encode(key)}, region));
-    } else {
-      headers.setLocation(toUri(region, key));
-    }
+    headers.setLocation(toUri(region, key));
-   * For the given region either gets all the region's data (with an optional limit),
-   * or gets the region's data for the given keys (optionally ignoring missing keys).
+   * Read all or fixed number of data in a given Region
-   * @param encodedKeys an optional comma separated list of encoded keys to read
-   * @param ignoreMissingKey if true and reading more than one key then if a key is missing ignore
-   *        it
-  @ApiOperation(value = "read all data for region or the specified keys",
-      notes = "If reading all data for region then the limit parameter can be used to give the maximum number of values to return."
-          + " If reading specific keys then the ignoreMissingKey parameter can be used to not fail if a key is missing.")
+  @ApiOperation(value = "read all data for region",
+      notes = "Read all data for region. Use limit param to get fixed or limited number of entries.")
+  @PreAuthorize("@securityService.authorize('DATA', 'READ', #region)")
-          defaultValue = DEFAULT_GETALL_RESULT_LIMIT) final String limit,
-      @RequestParam(value = "keys", required = false) final String[] encodedKeys,
-      @RequestParam(value = "ignoreMissingKey", required = false) final String ignoreMissingKey) {
-    region = decode(region);
-    if (encodedKeys == null || encodedKeys.length == 0) {
-      return getAllRegionData(region, limit);
-    } else {
-      String[] decodedKeys = decode(encodedKeys);
-      return getRegionKeys(region, ignoreMissingKey, decodedKeys, true);
-    }
-  }
-
-  private ResponseEntity<?> getAllRegionData(String region, String limit) {
-    securityService.authorize("DATA", "READ", region);
+          defaultValue = DEFAULT_GETALL_RESULT_LIMIT) final String limit) {
+
+    region = decode(region);
+
-      keyList = StringUtils.collectionToCommaDelimitedString(keys);
+      keyList = StringUtils.collectionToDelimitedString(keys, ",");
-        keyList = StringUtils.collectionToCommaDelimitedString(keys.subList(0, maxLimit));
+        keyList = StringUtils.collectionToDelimitedString(keys.subList(0, maxLimit), ",");
-    headers.set(HttpHeaders.CONTENT_LOCATION, toUri(region, keyList).toASCIIString());
+    headers.set("Content-Location", toUri(region, keyList).toASCIIString());
-  @RequestMapping(method = RequestMethod.GET, value = "/{region}/{keys}",
+  @RequestMapping(method = RequestMethod.GET, value = "/{region}/**",
-      notes = "Read data for specific set of keys in a region. Deprecated in favor of /{region}?keys=.")
+      notes = "Read data for specific set of keys in a region. The keys, ** in the endpoint, are a comma separated list.")
-  public ResponseEntity<?> readKeys(@PathVariable("region") String region,
-      @PathVariable("keys") final String[] keys,
-      @RequestParam(value = "ignoreMissingKey", required = false) final String ignoreMissingKey) {
-    region = decode(region);
-    return getRegionKeys(region, ignoreMissingKey, keys, false);
-  }
-
-  private ResponseEntity<?> getRegionKeys(String region, String ignoreMissingKey, String[] keys,
-      boolean keysInQueryParam) {
-    logger.debug("Reading data for keys ({}) in Region ({})", ArrayUtils.toString(keys), region);
+  public ResponseEntity<?> read(@PathVariable("region") String region,
+      @RequestParam(value = "ignoreMissingKey", required = false) final String ignoreMissingKey,
+      HttpServletRequest request) {
+    String[] keys = parseKeys(request, region);
+    logger.debug("Reading data for keys ({}) in Region ({})", ArrayUtils.toString(keys), region);
+
+    region = decode(region);
+
-      URI uri;
-      if (keysInQueryParam) {
-        String[] encodedKeys = encode(keys);
-        String encodedRegion = encode(region);
-        uri = this.toUriWithKeys(encodedKeys, encodedRegion);
-      } else {
-        uri = toUri(region, keys[0]);
-      }
-      headers.set(HttpHeaders.CONTENT_LOCATION, uri.toASCIIString());
+      headers.set("Content-Location", toUri(region, keys[0]).toASCIIString());
-      final Map<Object, Object> valueObjs = getValues(region, keys);
-      // valueObjs will have as its keys all of "keys".
-      // valueObjs will have a null value if the key did not exist.
-      // So if ignoreMissingKey is false we can use "null" values to detect the missing keys.
-        List<String> unknownKeys = new ArrayList<>();
-        // use "keys" to iterate so that we get the original key ordering from user.
-        for (String key : keys) {
-          if (valueObjs.get(key) == null) {
-            unknownKeys.add(key);
-          }
-        }
-        if (!unknownKeys.isEmpty()) {
-          String unknownKeysAsStr = StringUtils.collectionToCommaDelimitedString(unknownKeys);
-          String errorString = String.format("Requested keys (%1$s) not exist in region (%2$s)",
-              unknownKeysAsStr, region);
-          return new ResponseEntity<>(convertErrorAsJson(errorString), headers,
+        List<String> unknownKeys = checkForMultipleKeysExist(region, keys);
+        if (unknownKeys.size() > 0) {
+          String unknownKeysAsStr = StringUtils.collectionToDelimitedString(unknownKeys, ",");
+          String erroString = String.format("Requested keys (%1$s) not exist in region (%2$s)",
+              StringUtils.collectionToDelimitedString(unknownKeys, ","), region);
+          return new ResponseEntity<>(convertErrorAsJson(erroString), headers,
-      // The dev rest api was already released with null values being returned
-      // for non-existent keys.
-      // Order the keys in the result after the array of keys given to this method.
-      // Previous code returned them in random order which made the result harder to test and use.
+      final Map<Object, Object> valueObjs = getValues(region, keys);
-      URI uri;
-      if (keysInQueryParam) {
-        String[] encodedKeys = encode(keys);
-        String encodedRegion = encode(region);
-        uri = this.toUriWithKeys(encodedKeys, encodedRegion);
-      } else {
-        String keyList = StringUtils.arrayToCommaDelimitedString(keys);
-        uri = toUri(region, keyList);
-      }
+      // Do we need to remove null values from Map..?
+      // To Remove null value entries from map.
+      // valueObjs.values().removeAll(Collections.singleton(null));
-      headers.set(HttpHeaders.CONTENT_LOCATION, uri.toASCIIString());
+      // currently we are not removing keys having value null from the result.
+      String keyList = StringUtils.collectionToDelimitedString(valueObjs.keySet(), ",");
+      headers.set("Content-Location", toUri(region, keyList).toASCIIString());
-      // add the values in the same order as the original keys
-      // the code used to use valueObj.values() which used "hash" ordering.
-      for (String key : keys) {
-        data.add(valueObjs.get(key));
-      }
+      data.add(valueObjs.values());
-   * @param keys comma separated list of keys
-  @RequestMapping(method = RequestMethod.PUT, value = "/{region}/{keys}",
+  @RequestMapping(method = RequestMethod.PUT, value = "/{region}/**",
-          + " Deprecated in favor of /{region}?keys=."
+          + " The keys, ** in the endpoint, are a comma separated list."
-  @PreAuthorize("@securityService.authorize('WRITE', #region, #keys)")
-      @PathVariable("keys") String[] keys,
+    String[] keys = parseKeys(request, region);
+    securityService.authorize("WRITE", region, keys);
-    if (!validOp(opValue)) {
-      String errorMessage = String.format(
-          "The op parameter (%1$s) is not valid. Valid values are PUT, REPLACE, or CAS.",
-          opValue);
-      return new ResponseEntity<>(convertErrorAsJson(errorMessage), HttpStatus.BAD_REQUEST);
-    }
-      updateMultipleKeys(region, keys, json);
-      HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUri(region, StringUtils.arrayToCommaDelimitedString(keys)));
-      return new ResponseEntity<>(headers, HttpStatus.OK);
+      return updateMultipleKeys(region, keys, json);
-      Object existingValue = updateSingleKey(region, keys[0], json, opValue);
-      final HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUri(region, keys[0]));
-      return new ResponseEntity<>(existingValue, headers,
-          (existingValue == null ? HttpStatus.OK : HttpStatus.CONFLICT));
-    }
-  }
-
-  private boolean validOp(String opValue) {
-    try {
-      UpdateOp.valueOf(opValue.toUpperCase());
-      return true;
-    } catch (IllegalArgumentException ex) {
-      return false;
-    }
-  }
-
-  /**
-   * Update data for a key or set of keys
-   *
-   * @param encodedRegion gemfire data region
-   * @param encodedKeys comma separated list of keys
-   * @param opValue type of update (put, replace, cas etc)
-   * @param json new data for the key(s)
-   * @return JSON document
-   */
-  @RequestMapping(method = RequestMethod.PUT, value = "/{region}",
-      consumes = {APPLICATION_JSON_UTF8_VALUE}, produces = {
-          APPLICATION_JSON_UTF8_VALUE})
-  @ApiOperation(value = "update data for key(s)",
-      notes = "Update or insert (put) data for keys in a region."
-          + " The keys are a comma separated list."
-          + " If multiple keys are given then put (create or update) the data for each key."
-          + " The op parameter is ignored if more than one key is given."
-          + " If op=PUT, the default, create or update data for the given key."
-          + " If op=CREATE, create data for the given key if and only if the key does not exit in the region."
-          + " If op=REPLACE, update (replace) data for the given key if and only if the key exists in the region."
-          + " If op=CAS, update (compare-and-set) value having key with a new value if and only if the \"@old\" value sent matches the current value for the key in the region.")
-  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
-      @ApiResponse(code = 201, message = "For op=CREATE on success."),
-      @ApiResponse(code = 400, message = "Bad Request."),
-      @ApiResponse(code = 401, message = "Invalid Username or Password."),
-      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
-      @ApiResponse(code = 404,
-          message = "Region does not exist or if key is not mapped to some value for REPLACE or CAS."),
-      @ApiResponse(code = 409,
-          message = "For op=CREATE, key already exist in region. For op=CAS, @old value does not match to the current value in region."),
-      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")})
-  public ResponseEntity<?> updateKeys(@PathVariable("region") final String encodedRegion,
-      @RequestParam(value = "keys") final String[] encodedKeys,
-      @RequestParam(value = "op", defaultValue = "PUT") final String opValue,
-      @RequestBody final String json) {
-
-    String decodedRegion = decode(encodedRegion);
-    String[] decodedKeys = decode(encodedKeys);
-    if (!validOp(opValue) && !opValue.equalsIgnoreCase("CREATE")) {
-      String errorMessage = String.format(
-          "The op parameter (%1$s) is not valid. Valid values are PUT, CREATE, REPLACE, or CAS.",
-          opValue);
-      return new ResponseEntity<>(convertErrorAsJson(errorMessage), HttpStatus.BAD_REQUEST);
-    }
-
-    if (decodedKeys.length > 1) {
-      // putAll case
-      logger.debug("updating keys ({}) for region ({}) op={}", decodedKeys, decodedRegion, opValue);
-      securityService.authorize("WRITE", decodedRegion, decodedKeys);
-      updateMultipleKeys(decodedRegion, decodedKeys, json);
-      HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUriWithKeys(encodedKeys, encodedRegion));
-      return new ResponseEntity<>(headers, HttpStatus.OK);
-    } else if (opValue.equalsIgnoreCase("CREATE")) {
-      securityService.authorize("DATA", "WRITE", decodedRegion);
-      return create(decodedRegion, decodedKeys[0], json, true);
-    } else {
-      // put case
-      logger.debug("updating keys ({}) for region ({}) op={}", decodedKeys, decodedRegion, opValue);
-      securityService.authorize("WRITE", decodedRegion, decodedKeys);
-      Object existingValue = updateSingleKey(decodedRegion, decodedKeys[0], json, opValue);
-      final HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUriWithKeys(encodedKeys, encodedRegion));
-      return new ResponseEntity<>(existingValue, headers,
-          (existingValue == null ? HttpStatus.OK : HttpStatus.CONFLICT));
+      return updateSingleKey(region, keys[0], json, opValue);

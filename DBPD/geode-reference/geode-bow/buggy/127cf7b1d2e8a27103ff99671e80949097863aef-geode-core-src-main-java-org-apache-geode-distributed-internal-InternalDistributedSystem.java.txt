GEODE-6355: Fix Synchronization of Function stats in IDS. (#3158)

* Don't use double-checked locking.
* Use computeIfAbsent instead of locking on the object.

Cleanup:
* Rename listeners to disconnectListeners.
* Remove dead code
* generify collections
* Change some loops to foreach
* Make a ThreadLocal use withInitial
* Make methods and fields private
-  public static final String DISABLE_MANAGEMENT_PROPERTY =
+  private static final String DISABLE_MANAGEMENT_PROPERTY =
-      new AtomicReference<CreationStackGenerator>(DEFAULT_CREATION_STACK_GENERATOR);
+      new AtomicReference<>(DEFAULT_CREATION_STACK_GENERATOR);
-  protected final Object isConnectedMutex = new Object();
+  private final Object isConnectedMutex = new Object();
-  private final Set listeners = new LinkedHashSet(); // needs to be ordered
+  private final Set<DisconnectListener> disconnectListeners = new LinkedHashSet<>(); // needs to be
+                                                                                     // ordered
-  private static final Set connectListeners = new LinkedHashSet(); // needs to be ordered
+  // needs to be ordered
+  private static final Set<ConnectListener> connectListeners = new LinkedHashSet();
-  public static InternalLogWriter getStaticSecurityInternalLogWriter() {
-    InternalDistributedSystem sys = getAnyInstance();
-    if (sys != null) {
-      return sys.securityLogWriter;
-    }
-    return null;
-  }
-
-      this.isReconnectingDS = ((Boolean) o).booleanValue();
+      this.isReconnectingDS = (Boolean) o;
-   * @param reason the reason that the system is disconnecting
-   *
-  private HashSet doDisconnects(boolean doReconnect, String reason) {
+  private HashSet<ShutdownListener> doDisconnects(boolean doReconnect) {
-    HashSet shutdownListeners = new HashSet();
+    HashSet<ShutdownListener> shutdownListeners = new HashSet<>();
-      DisconnectListener listener = null;
-      synchronized (this.listeners) {
-        Iterator itr = listeners.iterator();
+      DisconnectListener listener;
+      synchronized (this.disconnectListeners) {
+        Iterator<DisconnectListener> itr = disconnectListeners.iterator();
-          break;
+          return shutdownListeners;
-        listener = (DisconnectListener) itr.next();
+        listener = itr.next();
-          shutdownListeners.add(listener);
+          shutdownListeners.add((ShutdownListener) listener);
-    return shutdownListeners;
-  private void doShutdownListeners(HashSet shutdownListeners) {
+  private void doShutdownListeners(HashSet<ShutdownListener> shutdownListeners) {
-    Iterator it = shutdownListeners.iterator();
-    while (it.hasNext()) {
-      ShutdownListener s = (ShutdownListener) it.next();
+    for (ShutdownListener shutdownListener : shutdownListeners) {
-        s.onShutdown(this);
+        shutdownListener.onShutdown(this);
-        logger.fatal(String.format("ShutdownListener < %s > threw...", s), t);
+        logger.fatal(String.format("ShutdownListener < %s > threw...", shutdownListener), t);
-      synchronized (this.listeners) {
-        Iterator itr = listeners.iterator();
+      synchronized (this.disconnectListeners) {
+        Iterator<DisconnectListener> itr = disconnectListeners.iterator();
-        dcListener = (DisconnectListener) itr.next();
+        dcListener = itr.next();
-    this.listeners.clear();
+    this.disconnectListeners.clear();
-      HashSet shutdownListeners = null;
+      HashSet<ShutdownListener> shutdownListeners = null;
-          shutdownListeners = doDisconnects(attemptingToReconnect, reason);
+          shutdownListeners = doDisconnects(attemptingToReconnect);
-      new ConcurrentHashMap<String, FunctionStats>();
+      new ConcurrentHashMap<>();
-    FunctionStats stats = functionExecutionStatsMap.get(textId);
-    if (stats == null) {
-      stats = new FunctionStats(this, textId);
-      FunctionStats oldStats = functionExecutionStatsMap.putIfAbsent(textId, stats);
-      if (oldStats != null) {
-        stats.close();
-        stats = oldStats;
-      }
-    }
-    return stats;
+    return functionExecutionStatsMap.computeIfAbsent(textId,
+        key -> new FunctionStats(this, key));
-  public FunctionServiceStats getFunctionServiceStats() {
+  public synchronized FunctionServiceStats getFunctionServiceStats() {
-      synchronized (this) {
-        if (functionServiceStats == null) {
-          functionServiceStats = new FunctionServiceStats(this, "FunctionExecution");
-        }
-      }
+      functionServiceStats = new FunctionServiceStats(this, "FunctionExecution");
-  public Set<String> getAllFunctionExecutionIds() {
-    return functionExecutionStatsMap.keySet();
-  }
-
-    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("registering reconnect
-    // listener: " + listener);
-   * Removes a <code>ConnectListener</code> from the list of listeners that will be notified when a
-   * connection is created to a distributed system.
-   *
-   * @return true if listener was in the list
-   */
-  public static boolean removeConnectListener(ConnectListener listener) {
-    synchronized (connectListeners) {
-      return connectListeners.remove(listener);
-    }
-  }
-
-  /**
-      for (Iterator iter = connectListeners.iterator(); iter.hasNext();) {
+      for (ConnectListener listener : connectListeners) {
-          ConnectListener listener = (ConnectListener) iter.next();
-   * Removes a <code>ReconnectListener</code> from the list of listeners that will be notified when
-   * a connection is recreated to a distributed system.
-   */
-  public static void removeReconnectListener(ReconnectListener listener) {
-    synchronized (reconnectListeners) {
-      reconnectListeners.remove(listener);
-    }
-  }
-
-  /**
-      listeners = new ArrayList<ReconnectListener>(reconnectListeners);
+      listeners = new ArrayList<>(reconnectListeners);
-    synchronized (this.listeners) {
-      this.listeners.add(listener);
+    synchronized (this.disconnectListeners) {
+      this.disconnectListeners.add(listener);
-          this.listeners.remove(listener); // don't leave in the list!
+          this.disconnectListeners.remove(listener); // don't leave in the list!
-   *
-   * @return true if listener was in the list
-  public boolean removeDisconnectListener(DisconnectListener listener) {
-    synchronized (this.listeners) {
-      return this.listeners.remove(listener);
+  public void removeDisconnectListener(DisconnectListener listener) {
+    synchronized (this.disconnectListeners) {
+      this.disconnectListeners.remove(listener);
-   * Fires an "informational" <code>SystemMembershipEvent</code> in admin VMs.
-   *
-   * @since GemFire 4.0
-   */
-  public void fireInfoEvent(Object callback) {
-    throw new UnsupportedOperationException(
-        "Not implemented yet");
-  }
-
-  /**
-          DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
+          InternalDistributedSystem ds = InternalDistributedSystem.getAnyInstance();
-            DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
+            DurableClientAttributes dca = ds.getDistributedMember()
-            ((InternalDistributedSystem) ds).disconnect(false,
+            ds.disconnect(false,
-   * The time at which reconnect attempts last began
-   */
-  private static long reconnectAttemptTime;
-
-  /**
-  public void cancelReconnect() {
-    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("cancelReconnect invoked",
-    // new Exception("stack trace");
+  private void cancelReconnect() {
-        if (reconnectAttemptCounter == 0) {
-          reconnectAttemptTime = System.currentTimeMillis();
-        }
-      return;
-
-      for (int i = 0; i < validAttributeNames.length; i++) {
-        String attName = validAttributeNames[i];
+      for (String attName : validAttributeNames) {
-  public String forceStop() {
-    if (this.dm == null) {
-      return "no distribution manager";
-    }
-    String reason = dm.getCancelCriterion().cancelInProgress();
-    return reason;
-  }
-
-  public boolean isServerLocator() {
-    return this.startedLocator.isServerLocator();
-  }
-
-  /**
-   * Provides synchronized time for this process based on other processes in this GemFire
-   * distributed system. GemFire distributed system coordinator adjusts each member's time by an
-   * offset. This offset for each member is calculated based on Berkeley Time Synchronization
-   * algorithm.
-   *
-   * @return time in milliseconds.
-   */
-  public long systemTimeMillis() {
-    return dm.cacheTimeMillis();
-  }
-
-      InternalDistributedSystem recon = this.reconnectDS;
-
-      recon = this.reconnectDS;
+      InternalDistributedSystem recon = this.reconnectDS;
-    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("stopReconnecting invoked",
-    // new Exception("stack trace");

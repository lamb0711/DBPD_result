GEODE-7800: Add Redis PSUBSCRIBE and PUNSUBSCRIBE commands (#4705)

* GEODE-7800: Add Redis PSUBSCRIBE and PUNSUBSCRIBE commands

Similar to `SUBSCRIBE` and `UNSUBSCRIBE`, `PSUBSCRIBE` allows a client
to subscribe to a pattern. For example: `PSUBSCRIBE sal*s`

The subscription pattern is in the form of a glob supporting `*`, `?`
and ranges. https://redis.io/commands/psubscribe

Pattern subscriptions must be unsubscribed verbatim. i.e., the above
subscription would not be unsubscribed using the pattern `s*`, but must
be unsubscribed using the complete subscribed pattern, namely `sal*s`.

When clients subscribe to overlapping patterns (or channels) they will
receive a message for every matched subscription. Matches for a single
client are not conflated.

    Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
    Co-authored-by: John Hutchison <jhutchison@pivotal.io>
    Co-authored-by: Jens Deppe <jdeppe@pivotal.io>

* Fixes class names in sanctioned-geode-redis-serializables.txt

* Fixes flaky test

* Adds license to PublishResult

* Clean code using spA and make test reliable

stop propagating exceptions that get thrown when disconnecting Jedis

* Cleans up subscribers and publishers after each test or after the whole class as needed

* re-add ignoreExceptions to waitfor test helper method

Co-authored-by: Jens Deppe <jdeppe@pivotal.io>
Co-authored-by: Venkateswara Prasath Durairaj <xtreme-prasath@users.noreply.github.com>

-class Subscriber {
+public abstract class AbstractSubscription implements Subscription {
-  public final Client client;
-  public final String channel;
-  private ExecutionHandlerContext context;
+  private final Client client;
+  private final ExecutionHandlerContext context;
-  public Subscriber(Client client, String channel, ExecutionHandlerContext context) {
+  AbstractSubscription(Client client, ExecutionHandlerContext context) {
+    if (client == null) {
+      throw new IllegalArgumentException("client cannot be null");
+    }
+    if (context == null) {
+      throw new IllegalArgumentException("context cannot be null");
+    }
-    this.channel = channel;
-  public boolean isEqualTo(String channel, Client client) {
-    if (channel == null || client == null) {
-      return false;
-    }
-    return channel.equals(this.channel) && client.equals(this.client);
-  }
-
-  public boolean publishMessage(String channel, String message) {
+  @Override
+  public PublishResult publishMessage(String channel, String message) {
-      return false;
+      return new PublishResult(client, false);
-    return writeToChannelSynchronously(messageByteBuffer);
+    return new PublishResult(client, writeToChannelSynchronously(messageByteBuffer));
+  }
+
+  Client getClient() {
+    return client;
+  }
+
+  @Override
+  public boolean matchesClient(Client client) {
+    return this.client.equals(client);
-   * This method turns the response into a synchronous call. We want to
-   * determine if the response, to the client, resulted in an error - for example if the client has
-   * disconnected and the write fails. In such cases we need to be able to notify the caller.
+   * This method turns the response into a synchronous call. We want to determine if the response,
+   * to the client, resulted in an error - for example if the client has disconnected and the write
+   * fails. In such cases we need to be able to notify the caller.
+

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * @version     $Revision: 1.1 $
+ * @version $Revision: 1.1 $
-  
-  
-  
+
+
+
-  
-  
-  
+
+
+
-  
-  public Object read(Object target)
-  throws NameNotFoundException, QueryInvocationTargetException {
-    if (target == null  || target == QueryService.UNDEFINED){
+
+  public Object read(Object target) throws NameNotFoundException, QueryInvocationTargetException {
+    if (target == null || target == QueryService.UNDEFINED) {
-    if (target instanceof PdxInstance){
+    if (target instanceof PdxInstance) {
-    //for non pdx objects
+    // for non pdx objects
-  
+
-  throws NameNotFoundException, QueryInvocationTargetException {
+      throws NameNotFoundException, QueryInvocationTargetException {
-          } else {            
-            return ((Method)m).invoke(target, (Object[])null);
+          } else {
+            return ((Method) m).invoke(target, (Object[]) null);
-          //eat the Exception
+          // eat the Exception
-          throw new NameNotFoundException(LocalizedStrings.AttributeDescriptor_METHOD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR.toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}), e);
+          throw new NameNotFoundException(
+              LocalizedStrings.AttributeDescriptor_METHOD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR
+                  .toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}),
+              e);
-             //eat the exception
-             return QueryService.UNDEFINED;
+            // eat the exception
+            return QueryService.UNDEFINED;
-            return ((Field)m).get(target);
-          }  
+            return ((Field) m).get(target);
+          }
-          throw new NameNotFoundException(LocalizedStrings.AttributeDescriptor_FIELD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR.toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}), e);
+          throw new NameNotFoundException(
+              LocalizedStrings.AttributeDescriptor_FIELD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR
+                  .toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}),
+              e);
-  
-  
+
+
-        /*
-    public Object write(Object target, Object newValue)
-        throws PathEvaluationException
-    {
-        if (target == null)
-            return QueryService.UNDEFINED;
-         
-         
-        Class targetType = target.getClass();
-        Class argType = newValue == null ? null : newValue.getClass();
-        Member m = getWriteMember(targetType, argType);
-        if (m == null)
-            throw new PathEvaluationException(LocalizedStrings.AttributeDescriptor_NO_UPDATE_PATH_MAPPING_FOUND_FOR_0.toLocalizedString(_name));
-        try
-        {
-            if (m instanceof Method)
-            {
-                try
-                {
-                    ((Method)m).invoke(target, new Object[] { newValue });
-                    return null;
-                }
-                catch (InvocationTargetException e)
-                {
-                    throw new PathEvaluationException(e.getTargetException());
-                }
-            }
-            else
-            {
-                ((Field)m).set(target, newValue);
-                return null;
-            }
-        }
-        catch (IllegalAccessException e)
-        {
-            throw new PathEvaluationException(e));
-        }
-         
-    }
-         */
-  
-  
-  Member getReadMember(ObjectType targetType)
-  throws NameNotFoundException {
+  /*
+   * public Object write(Object target, Object newValue) throws PathEvaluationException { if (target
+   * == null) return QueryService.UNDEFINED;
+   * 
+   * 
+   * Class targetType = target.getClass(); Class argType = newValue == null ? null :
+   * newValue.getClass(); Member m = getWriteMember(targetType, argType); if (m == null) throw new
+   * PathEvaluationException(LocalizedStrings.AttributeDescriptor_NO_UPDATE_PATH_MAPPING_FOUND_FOR_0
+   * .toLocalizedString(_name)); try { if (m instanceof Method) { try { ((Method)m).invoke(target,
+   * new Object[] { newValue }); return null; } catch (InvocationTargetException e) { throw new
+   * PathEvaluationException(e.getTargetException()); } } else { ((Field)m).set(target, newValue);
+   * return null; } } catch (IllegalAccessException e) { throw new PathEvaluationException(e)); }
+   * 
+   * }
+   */
+
+
+  Member getReadMember(ObjectType targetType) throws NameNotFoundException {
-  
-  Member getReadMember(Class targetClass)
-  throws NameNotFoundException {
+
+  Member getReadMember(Class targetClass) throws NameNotFoundException {
-    // method (attribute())    
+    // method (attribute())
-    
-    Member m = (Member)_cache.get(key);
+
+    Member m = (Member) _cache.get(key);
-    
+
-      throw new NameNotFoundException(LocalizedStrings.AttributeDescriptor_NO_PUBLIC_ATTRIBUTE_NAMED_0_WAS_FOUND_IN_CLASS_1.toLocalizedString(new Object[] {_name, targetClass.getName()}));
+      throw new NameNotFoundException(
+          LocalizedStrings.AttributeDescriptor_NO_PUBLIC_ATTRIBUTE_NAMED_0_WAS_FOUND_IN_CLASS_1
+              .toLocalizedString(new Object[] {_name, targetClass.getName()}));
-    ((AccessibleObject)m).setAccessible(true);
+    ((AccessibleObject) m).setAccessible(true);
-  
-  
-        /* Not yet used, Here to support Update statements
-    private Member getWriteMember(Class targetType, Class argType)
-    {
-            // mapping: public field (same name), method (setAttribute(val)),
-            // method attribute(val)
-        Member m;
-        m = getWriteField(targetType, argType);
-        if (m != null)
-            return m;
-        return getWriteMethod(targetType, argType);
-    }
-         */
-  
-  
-  
+
+
+  /*
+   * Not yet used, Here to support Update statements private Member getWriteMember(Class targetType,
+   * Class argType) { // mapping: public field (same name), method (setAttribute(val)), // method
+   * attribute(val) Member m; m = getWriteField(targetType, argType); if (m != null) return m;
+   * return getWriteMethod(targetType, argType); }
+   */
+
+
+
-  
-        /* not yet used
-    private Field getWriteField(Class targetType, Class argType)
-    {
-        try
-        {
-            return targetType.getField(_name);
-        }
-        catch (NoSuchFieldException e)
-        {
-            return null;
-        }
-    }
-         */
-  
-  
-  
+
+  /*
+   * not yet used private Field getWriteField(Class targetType, Class argType) { try { return
+   * targetType.getField(_name); } catch (NoSuchFieldException e) { return null; } }
+   */
+
+
+
-    String beanMethod = "get" + _name.substring(0,1).toUpperCase() + _name.substring(1);
+    String beanMethod = "get" + _name.substring(0, 1).toUpperCase() + _name.substring(1);
-  
-        /* not yet used
-    private Method getWriteMethod(Class targetType, Class argType)
-    {
-        Method m;
-        String beanMethod = "set" + _name.substring(0,1).toUpperCase() + _name.substring(1);
-        m = getWriteMethod(targetType, argType, beanMethod);
-        if (m != null)
-            return m;
-        return getWriteMethod(targetType, argType, _name);
-    }
-         */
-  
-  
+
+  /*
+   * not yet used private Method getWriteMethod(Class targetType, Class argType) { Method m; String
+   * beanMethod = "set" + _name.substring(0,1).toUpperCase() + _name.substring(1); m =
+   * getWriteMethod(targetType, argType, beanMethod); if (m != null) return m; return
+   * getWriteMethod(targetType, argType, _name); }
+   */
+
+
-      return targetType.getMethod(methodName, (Class[])null);
+      return targetType.getMethod(methodName, (Class[]) null);
-  
-        /* not yet used
-    private Method getWriteMethod(Class targetType, Class argType, String methodName)
-    {
-        try
-        {
-                // @todo look up maximally specific method based on argType
-            return targetType.getMethod(methodName, new Class[] { argType });
-        }
-        catch (NoSuchMethodException e)
-        {
-            return null;
-        }
-    }
-         */
+
+  /*
+   * not yet used private Method getWriteMethod(Class targetType, Class argType, String methodName)
+   * { try { // @todo look up maximally specific method based on argType return
+   * targetType.getMethod(methodName, new Class[] { argType }); } catch (NoSuchMethodException e) {
+   * return null; } }
+   */
+   * 
-  private Object readPdx(PdxInstance target) throws NameNotFoundException,
-      QueryInvocationTargetException {
+  private Object readPdx(PdxInstance target)
+      throws NameNotFoundException, QueryInvocationTargetException {
-      if (pdxInstance.hasField(_name)) { 
+      if (pdxInstance.hasField(_name)) {
-      }
-      else {
+      } else {
-        
-        //don't look further for field or method or reflect on GemFire JSON data
-        if(className.equals(JSONFormatter.JSON_CLASSNAME)){
-            return QueryService.UNDEFINED;
+
+        // don't look further for field or method or reflect on GemFire JSON data
+        if (className.equals(JSONFormatter.JSON_CLASSNAME)) {
+          return QueryService.UNDEFINED;
-        
+
-            return pdxInstance.getDefaultValueIfFieldExistsInAnyPdxVersions(
-                _name, className);
+            return pdxInstance.getDefaultValueIfFieldExistsInAnyPdxVersions(_name, className);
-        }  
+        }
-        if(!this.isMethodAlreadySearchedAndNotFound(className, _name)){
-        	try{
-        		return readFieldFromDeserializedObject(pdxInstance, target);
-        	}catch (NameNotFoundException ex){
-				updateClassToMethodsMap(pdxInstance.getClassName(),_name);
-				throw ex;
-        	}
-        }else return QueryService.UNDEFINED;
+        if (!this.isMethodAlreadySearchedAndNotFound(className, _name)) {
+          try {
+            return readFieldFromDeserializedObject(pdxInstance, target);
+          } catch (NameNotFoundException ex) {
+            updateClassToMethodsMap(pdxInstance.getClassName(), _name);
+            throw ex;
+          }
+        } else
+          return QueryService.UNDEFINED;
-    }
-    else {
+    } else {
-              .toLocalizedString(new Object[] { _name,
-                  target.getClass().getName() }));
+              .toLocalizedString(new Object[] {_name, target.getClass().getName()}));
-  
-  private Object readFieldFromDeserializedObject(PdxInstanceImpl pdxInstance,
-      Object target) throws NameNotFoundException,
-      QueryInvocationTargetException {
+
+  private Object readFieldFromDeserializedObject(PdxInstanceImpl pdxInstance, Object target)
+      throws NameNotFoundException, QueryInvocationTargetException {
-              .toLocalizedString(new Object[] { _name,
-                  target.getClass().getName() }));
+              .toLocalizedString(new Object[] {_name, target.getClass().getName()}));
-  
+
-  
-  
+
+

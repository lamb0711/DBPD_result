Revert "GEODE-577: rewrite QueryMonitorDUnitTest (#2179)"

This reverts commit 38e1714

+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import org.apache.geode.cache.query.Query;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+  private boolean testingQueryMonitor = false;
-  private static final ThreadLocal<AtomicBoolean> queryCancelled =
+  private static final ThreadLocal<AtomicBoolean> queryExecutionStatus =
+  /** For DUnit test purpose TODO: delete this ConcurrentMap */
+  private ConcurrentMap queryMonitorTasks = null;
+
-  public void monitorQueryThread(Thread queryThread, DefaultQuery query) {
-    // cq query is not monitored
-    if (query.isCqQuery()) {
-      return;
-    }
-
+  public void monitorQueryThread(Thread queryThread, Query query) {
-      query.setCanceled(new QueryExecutionLowMemoryException(reason));
+      ((DefaultQuery) query).setCanceled(true, new QueryExecutionLowMemoryException(reason));
-    QueryThreadTask queryTask = new QueryThreadTask(queryThread, query, queryCancelled.get());
+    QueryThreadTask queryTask = new QueryThreadTask(queryThread, query, queryExecutionStatus.get());
+    // For dunit test purpose
+    if (cache != null && testingQueryMonitor) {
+      if (this.queryMonitorTasks == null) {
+        this.queryMonitorTasks = new ConcurrentHashMap();
+      }
+      this.queryMonitorTasks.put(queryThread, queryTask);
+    }
-  public void stopMonitoringQueryThread(Thread queryThread, DefaultQuery query) {
+  public void stopMonitoringQueryThread(Thread queryThread, Query query) {
-    boolean[] queryCompleted = query.getQueryCompletedForMonitoring();
+    DefaultQuery defaultQuery = (DefaultQuery) query;
+    boolean[] queryCompleted = defaultQuery.getQueryCompletedForMonitoring();
-      queryCancelled.get().getAndSet(Boolean.FALSE);
-      query.setQueryCompletedForMonitoring(true);
+      queryExecutionStatus.get().getAndSet(Boolean.FALSE);
+
+      defaultQuery.setQueryCompletedForMonitoring(true);
-    if (queryCancelled.get() != null && queryCancelled.get().get()) {
+    if (queryExecutionStatus.get() != null && queryExecutionStatus.get().get()) {
+      // TODO: while-block cannot complete without throwing
+          // Empty queue.
-        long executionTime = System.currentTimeMillis() - queryTask.StartTime;
+        long currentTime = System.currentTimeMillis();
+
-        if (executionTime < this.maxQueryExecutionTime) {
-          sleepTime = this.maxQueryExecutionTime - executionTime;
+        if (currentTime - queryTask.StartTime < this.maxQueryExecutionTime) {
+          sleepTime = this.maxQueryExecutionTime - (currentTime - queryTask.StartTime);
-        // Query execution has taken more than the max time, Set queryCancelled flag
-        // to true.
-        boolean[] queryCompleted = queryTask.query.getQueryCompletedForMonitoring();
+
+        // Query execution has taken more than the max time, Set queryExecutionStatus flag
+        // to canceled (TRUE).
+        boolean[] queryCompleted =
+            ((DefaultQuery) queryTask.query).getQueryCompletedForMonitoring();
-          // check if query is already completed
-          if (!queryCompleted[0]) {
-            queryTask.query.setCanceled(new QueryExecutionTimeoutException(String
-                .format("Query execution cancelled after exceeding max execution time %sms.",
-                    this.maxQueryExecutionTime)));
-            queryTask.queryCancelled.set(Boolean.TRUE);
-            // remove the query threads from monitoring queue
+          if (!queryCompleted[0] && !((DefaultQuery) queryTask.query).isCqQuery()) { // Check if the
+                                                                                     // query is
+                                                                                     // already
+                                                                                     // completed.
+            ((DefaultQuery) queryTask.query).setCanceled(true,
+                new QueryExecutionTimeoutException(
+                    LocalizedStrings.QueryMonitor_LONG_RUNNING_QUERY_CANCELED
+                        .toLocalizedString(GemFireCacheImpl.MAX_QUERY_EXECUTION_TIME)));
+            queryTask.queryExecutionStatus.set(Boolean.TRUE);
+            // Remove the task from queue.
-            logger.info(String.format(
-                "%s is set as canceled after %s milliseconds", queryTask.toString(),
-                executionTime));
+
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.GemFireCache_LONG_RUNNING_QUERY_EXECUTION_CANCELED,
+            new Object[] {queryTask.query.getQueryString(), queryTask.queryThread.getId()}));
+
+        if (logger.isDebugEnabled()) {
+          logger.debug("Query Execution for the thread {} got canceled.", queryTask.queryThread);
+        }
-    boolean[] queryCompleted = queryTask.query.getQueryCompletedForMonitoring();
+    boolean[] queryCompleted = ((DefaultQuery) queryTask.query).getQueryCompletedForMonitoring();
-        queryTask.query.setCanceled(
+        ((DefaultQuery) queryTask.query).setCanceled(true,
-        queryTask.queryCancelled.set(Boolean.TRUE);
+        queryTask.queryExecutionStatus.set(Boolean.TRUE);
-    final DefaultQuery query;
+    final Query query;
-    final AtomicBoolean queryCancelled;
+    final AtomicBoolean queryExecutionStatus;
-    QueryThreadTask(Thread queryThread, DefaultQuery query, AtomicBoolean queryCancelled) {
+    QueryThreadTask(Thread queryThread, Query query, AtomicBoolean queryExecutionStatus) {
-      this.queryCancelled = queryCancelled;
+      this.queryExecutionStatus = queryExecutionStatus;
-          .append(", queryCancelled:").append(this.queryCancelled).append(']')
+          .append(", queryExecutionStatus:").append(this.queryExecutionStatus).append(']')

GEODE-5407: fix JMXMBeanReconnectDUnitTest timing

This test class had several timing isses for the remote MBean tests.
This PR fixes all known timing issues, which were MBean inconsistencies
in the before() and trouble reconnecting stopped members, as well as
insufficiently strict assertions (comparing lists with
.containsExactlyElementsOf() is not commutative). This commit also
changes MemberVM's forceDisconnect to use a blackboard mailbox instead
of a fixed amount of time to decid when to start reconnecting. It also
adds functionality to the ConcurrencyRule to act as an awaitility.

* In waitForLocatorsToAgreeOnMembership, called from the before, the
MBeans that each locator has were only compared by list size. Now they
are compared element by element, and the sizes are checked to be
correct.

* In waitForLocatorToAgreeOnMembership, the wait was returning
prematurely after the first pass due to Awaitlity.untilAsserted not
working correctly. For this method, a simple implementation using
assertions and Awaitility caused memory issues, so the current
implementation uses do/while loops, compares the lists element by
element, and starts a single thread that is allowed to run for 300
seconds.

* In the tests, the timing was not strictly enforced. The disconnect and
starting the reconnect now happen in different threads. The thread that
starts the reconnect checks that the disconnect has happened, gathers
relevant information, then signals that reconnect can start, which the
reconnect thread now checks for. This ensures that we don't gather
MBeans before the member has fully stopped, and that reconnect does not
start until we've gathered the MBeans.

* Assertions have been made more strict by checking that lists against
each other twice, since Assertions.containsExactlyElementsOf() is not
commutative.

* Use a blackboard entry to check if the stopped member should start
reconnecting in the reconnect listener attached from MemberVM when
forcing a member to disconnect.

* Add functionality to ConcurrencyRule to act as an awaitility,
expecting a value to eventually be true. This was added during the
process of trying to solve this bug but is not used in the final
implementation.

+import static org.apache.geode.test.dunit.internal.JUnit4DistributedTestCase.getBlackboard;
-import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.geode.distributed.DistributedSystem;
+import org.apache.geode.test.dunit.DUnitBlackboard;
-   * This disconnects the distributed system of the member. The reconnect thread will wait for at
-   * least the given delay before completing the attempt.
+   * This disconnects the distributed system of the member. The reconnect thread will wait until the
+   * given mailbox is set to true from within the vm that this method is invoked on.
-   * @param delayReconnecting minimum delay in milliseconds before reconnect can complete.
+   * For example, if forceDisconnect is called like this:
+   * member1.forceDisconnect(300, "reconnectReady");
+   * Then the reconnect should be triggered like this:
+   * member1.invoke(() -> getBlackboard().setMailbox("reconnectReady", true));
+   *
+   * Setting this mailbox from within the test JVM will not cause the member to begin reconnecting.
+   *
+   * @param timeoutSeconds maximum time that the reconnect can take
+   * @param reconnectBBKey String key to the blackboard mailbox containing a boolean that shall
+   *        be set to true when the member should start reconnecting.
-  public void forceDisconnect(final long delayReconnecting) {
+  public void forceDisconnect(int timeoutSeconds, String reconnectBBKey) {
-      // The reconnect thread can yield the CPU before allowing the listeners to be invoked. The
-      // latch ensures that the listener is guaranteed to be called before this method returns thus
-      // ensuring that reconnection has started but not yet completed.
-      CountDownLatch latch = new CountDownLatch(1);
+      DUnitBlackboard server1BB = getBlackboard();
+      server1BB.initBlackboard();
+      server1BB.setMailbox(reconnectBBKey, false);
+
-              try {
-                Thread.sleep(delayReconnecting);
-                latch.countDown();
-              } catch (InterruptedException e) {
-                e.printStackTrace();
-              }
+              await().atMost(timeoutSeconds, TimeUnit.SECONDS)
+                  .until(() -> (boolean) server1BB.getMailbox(reconnectBBKey));
+
-      latch.await();
-        // provide more information when condition is not satisfied after one minute
+        // provide more information when condition is not satisfied after awaitility timeout
-        logger.info("locator is not null: " + (intLocator != null));
-        logger.info("cache is not null: " + (cache != null));
-        logger.info("ds is connected: " + (intLocator.getDistributedSystem().isConnected()));
+        DistributedSystem ds = intLocator.getDistributedSystem();
+        logger.info("locator is: " + (intLocator != null ? "not null" : "null"));
+        logger.info("cache is: " + (cache != null ? "not null" : "null"));
+        if (ds != null) {
+          logger
+              .info("distributed system is: " + (ds.isConnected() ? "connected" : "not connected"));
+        } else {
+          logger.info("distributed system is: null");
+        }
-        // provide more information when condition is not satisfied after one minute
-        InternalDistributedSystem internalDistributedSystem =
-            InternalDistributedSystem.getConnectedInstance();
-        logger.info("ds is not null: " + (internalDistributedSystem != null));
-        logger.info("cache is not null: " + (internalDistributedSystem.getCache() != null));
+        // provide more information when condition is not satisfied after awaitility timeout
+        InternalDistributedSystem ids = InternalDistributedSystem.getConnectedInstance();
+        logger.info("ds is: " + (ids != null ? "not null" : "null"));
+        logger.info("cache is: " + (ids.getCache() != null ? "not null" : "null"));
-            + (!internalDistributedSystem.getCache().getCacheServers().isEmpty()));
+            + (!ids.getCache().getCacheServers().isEmpty()));

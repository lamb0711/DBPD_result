Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+
- * StreamingOperation is an abstraction for sending messages to multiple (or single)
- * recipient requesting a potentially large amount of data and receiving the reply
- * with data chunked into several messages.
+ * StreamingOperation is an abstraction for sending messages to multiple (or single) recipient
+ * requesting a potentially large amount of data and receiving the reply with data chunked into
+ * several messages.
-  
+
-   * This is the number of bytes that need to be allowed in addition to
-   * data chunk to prevent overflowing the socket buffer size in one message.
-   * For now, this is just an estimate
+   * This is the number of bytes that need to be allowed in addition to data chunk to prevent
+   * overflowing the socket buffer size in one message. For now, this is just an estimate
-  
-  public final InternalDistributedSystem sys;    
+
+  public final InternalDistributedSystem sys;
-  }  
-  
+  }
+
-  throws org.apache.geode.cache.TimeoutException, InterruptedException
-  {    
-    if (Thread.interrupted()) throw new InterruptedException();
+      throws org.apache.geode.cache.TimeoutException, InterruptedException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
-      try {
-        // should we allow this to timeout?
-        processor.waitForRepliesUninterruptibly();
+    try {
+      // should we allow this to timeout?
+      processor.waitForRepliesUninterruptibly();
+    } catch (InternalGemFireException ex) {
+      Throwable cause = ex.getCause();
+      if (cause instanceof org.apache.geode.cache.TimeoutException) {
+        throw (org.apache.geode.cache.TimeoutException) cause;
-      catch (InternalGemFireException ex) {
-        Throwable cause = ex.getCause();
-        if (cause instanceof org.apache.geode.cache.TimeoutException) {
-          throw (org.apache.geode.cache.TimeoutException)cause;
-        }
-        throw ex;
-      }
-      catch (ReplyException e) {
-        e.handleAsUnexpected();
-        // throws exception
-      }
+      throw ex;
+    } catch (ReplyException e) {
+      e.handleAsUnexpected();
+      // throws exception
+    }
-  
+
-  protected abstract DistributionMessage createRequestMessage(Set recipients, ReplyProcessor21 processor);
-  
-  /** Called from separate thread when reply is processed.
+  protected abstract DistributionMessage createRequestMessage(Set recipients,
+      ReplyProcessor21 processor);
+
+  /**
+   * Called from separate thread when reply is processed.
+   * 
-  public boolean processChunk(List objects, InternalDistributedMember sender,
-                               int sequenceNum, boolean lastInSequence)  {
+  public boolean processChunk(List objects, InternalDistributedMember sender, int sequenceNum,
+      boolean lastInSequence) {
-  /** Override in subclass to do something useful with the data.
-    * @param sequenceNum the sequence of this data (0-based), in case ordering matters
-    * @param lastInSequence true if this is the last chunk in the sequence
-    * @return false to abort  
-    */
-  
-  protected abstract boolean processData(List objects, InternalDistributedMember sender, int sequenceNum, boolean lastInSequence);
-  
+  /**
+   * Override in subclass to do something useful with the data.
+   * 
+   * @param sequenceNum the sequence of this data (0-based), in case ordering matters
+   * @param lastInSequence true if this is the last chunk in the sequence
+   * @return false to abort
+   */
+
+  protected abstract boolean processData(List objects, InternalDistributedMember sender,
+      int sequenceNum, boolean lastInSequence);
+
-    
+
-      
+
-          logger.debug("Streaming Message Tracking Status: Processor id: {}; Sender: {}; Messages Processed: {}; NumMsgs: {}",
+          logger.debug(
+              "Streaming Message Tracking Status: Processor id: {}; Sender: {}; Messages Processed: {}; NumMsgs: {}",
-    
-    
+
+
-                              InternalDistributedMember member) {
+        InternalDistributedMember member) {
-    public StreamingProcessor(InternalDistributedSystem system,
-                          Set members) {
-      super(system, members); 
+    public StreamingProcessor(InternalDistributedSystem system, Set members) {
+      super(system, members);
-    
+
-        StreamingReplyMessage m = (StreamingReplyMessage)msg;
+        StreamingReplyMessage m = (StreamingReplyMessage) msg;
-          if (objects != null) {  // CONSTRAINT: objects should only be null if there's no data at all
+        if (objects != null) { // CONSTRAINT: objects should only be null if there's no data at all
-        }
-        else {
+        } else {
-      }
-      finally {
+      } finally {
-        checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signalling to proceed
-      }          
-    }  
-    
+        checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signalling to
+                       // proceed
+      }
+    }
+
-     * Contract of {@link ReplyProcessor21#stillWaiting()} is to never return true
-     * after returning false.
+     * Contract of {@link ReplyProcessor21#stillWaiting()} is to never return true after returning
+     * false.
-    
-    /** Overridden to wait for messages being currently processed:
-     *  This situation can come about if a member departs while we
-     *  are still processing data from that member
+
+    /**
+     * Overridden to wait for messages being currently processed: This situation can come about if a
+     * member departs while we are still processing data from that member
-      finishedWaiting = finishedWaiting ||
-          this.abort || !super.stillWaiting();
+      finishedWaiting = finishedWaiting || this.abort || !super.stillWaiting();
-    
-        
+
+
-      return "<" + this.getClass().getName() + " " + this.getProcessorId() +
-        " waiting for " + numMembers() + " replies" + 
-        (exception == null ? "" : (" exception: " + exception)) +
-        " from " + membersToString() + "; waiting for " +
-        this.msgsBeingProcessed.get() +
-        " messages in the process of being processed" + ">";
-    }    
-    
+      return "<" + this.getClass().getName() + " " + this.getProcessorId() + " waiting for "
+          + numMembers() + " replies" + (exception == null ? "" : (" exception: " + exception))
+          + " from " + membersToString() + "; waiting for " + this.msgsBeingProcessed.get()
+          + " messages in the process of being processed" + ">";
+    }
+
-        status = (Status)this.statusMap.get(m.getSender());
+        status = (Status) this.statusMap.get(m.getSender());
-        
+
-  
-  public static abstract class RequestStreamingMessage 
-    extends PooledDistributionMessage implements MessageWithReply {
+
+  public static abstract class RequestStreamingMessage extends PooledDistributionMessage
+      implements MessageWithReply {
-    
+
-    
+
-      HeapDataOutputStream outStream = new HeapDataOutputStream(chunkSize, getSender().getVersionObject());
+      HeapDataOutputStream outStream =
+          new HeapDataOutputStream(chunkSize, getSender().getVersionObject());
-//          boolean firstObject = true;
-          
+          // boolean firstObject = true;
+
-          
+
-          
+
-              outStream.disallowExpansion(CHUNK_FULL); // sets the mark where rollback occurs on CHUNK_FULL
-              
+              outStream.disallowExpansion(CHUNK_FULL); // sets the mark where rollback occurs on
+                                                       // CHUNK_FULL
+
-              
+
-                } 
+                }
-          
+
-            replyWithData(dm, outStream, numObjectsInChunk, msgNum++, nextObject == Token.END_OF_STREAM);
+            replyWithData(dm, outStream, numObjectsInChunk, msgNum++,
+                nextObject == Token.END_OF_STREAM);
-//      } catch (CancelException e) {
-//        // if cache is closed, we cannot send a reply (correct?)
-      } 
-      catch (VirtualMachineError err) {
+        // } catch (CancelException e) {
+        // // if cache is closed, we cannot send a reply (correct?)
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-      } else if (!sentFinalMessage && !receiverCacheClosed) {         
-        throw new InternalGemFireError(LocalizedStrings.StreamingOperation_THIS_SHOULDNT_HAPPEN.toLocalizedString());
-//        replyNoData(dm);
+      } else if (!sentFinalMessage && !receiverCacheClosed) {
+        throw new InternalGemFireError(
+            LocalizedStrings.StreamingOperation_THIS_SHOULDNT_HAPPEN.toLocalizedString());
+        // replyNoData(dm);
-    
-    /** override in subclass to provide reply data.
-      *  terminate by returning Token.END_OF_STREAM
-      */
+
+    /**
+     * override in subclass to provide reply data. terminate by returning Token.END_OF_STREAM
+     */
-    
-//    private void replyNoData(DistributionManager dm) {
-//      StreamingReplyMessage.send(getSender(), this.processorId, null, dm, null, 0, 0, true);
-//    }
+
+    // private void replyNoData(DistributionManager dm) {
+    // StreamingReplyMessage.send(getSender(), this.processorId, null, dm, null, 0, 0, true);
+    // }
-                                int numObjects, int msgNum, boolean lastMsg) {
+        int numObjects, int msgNum, boolean lastMsg) {
-                             msgNum, lastMsg);
-    }  
+          msgNum, lastMsg);
+    }
-    
+
-    
+
-    }    
+    }
-  
-  public static final class StreamingReplyMessage extends ReplyMessage {    
-    
+
+  public static final class StreamingReplyMessage extends ReplyMessage {
+
-    
+
-    
-    private transient HeapDataOutputStream chunkStream; // used only on sending side, null means abort
-    private transient int numObjects; // used only on sending side
-    private transient List objectList = null;  // used only on receiving side
-    
-    private boolean pdxReadSerialized = false; // used to read PDX types in serialized form.
-    private transient boolean isCanceled = false; //used only on receiving side and if messageProcessor is of type PartitionedRegionQueryEvaluator.StreamingQueryPartitionResponse
-    
+    private transient HeapDataOutputStream chunkStream; // used only on sending side, null means
+                                                        // abort
+    private transient int numObjects; // used only on sending side
+    private transient List objectList = null; // used only on receiving side
+
+    private boolean pdxReadSerialized = false; // used to read PDX types in serialized form.
+    private transient boolean isCanceled = false; // used only on receiving side and if
+                                                  // messageProcessor is of type
+                                                  // PartitionedRegionQueryEvaluator.StreamingQueryPartitionResponse
+
+
-     * @param chunkStream the data to send back, if null then all the following
-     * parameters are ignored and any future replies from this member will
-     * be ignored, and the streaming of chunks is considered aborted by the
-     * receiver.
+     * @param chunkStream the data to send back, if null then all the following parameters are
+     *        ignored and any future replies from this member will be ignored, and the streaming of
+     *        chunks is considered aborted by the receiver.
-    public static void send(InternalDistributedMember recipient, int processorId, ReplyException exception,
-                            DM dm, HeapDataOutputStream chunkStream,
-                            int numObjects, int msgNum, boolean lastMsg) {
+    public static void send(InternalDistributedMember recipient, int processorId,
+        ReplyException exception, DM dm, HeapDataOutputStream chunkStream, int numObjects,
+        int msgNum, boolean lastMsg) {
-    }        
+    }
-    public static void send(InternalDistributedMember recipient, int processorId, ReplyException exception,
-                            DM dm, HeapDataOutputStream chunkStream,
-                            int numObjects, int msgNum, boolean lastMsg, boolean pdxReadSerialized) {
+    public static void send(InternalDistributedMember recipient, int processorId,
+        ReplyException exception, DM dm, HeapDataOutputStream chunkStream, int numObjects,
+        int msgNum, boolean lastMsg, boolean pdxReadSerialized) {
-      
+
-      
+
-    }        
+    }
-    
+
-    
+
-    
+
-    
+
-    
+
-      }
-      else {
+      } else {
-        // This will make readObject() to return PdxInstance form.       
+        // This will make readObject() to return PdxInstance form.
-          ReplyProcessor21 messageProcessor = ReplyProcessor21.getProcessor(processorId); 
-          boolean isQueryMessageProcessor = messageProcessor instanceof PartitionedRegionQueryEvaluator.StreamingQueryPartitionResponse;
+          ReplyProcessor21 messageProcessor = ReplyProcessor21.getProcessor(processorId);
+          boolean isQueryMessageProcessor =
+              messageProcessor instanceof PartitionedRegionQueryEvaluator.StreamingQueryPartitionResponse;
-          if(isQueryMessageProcessor) {
-            elementType = ((PartitionedRegionQueryEvaluator.
-                StreamingQueryPartitionResponse)messageProcessor).getResultType();            
+          if (isQueryMessageProcessor) {
+            elementType =
+                ((PartitionedRegionQueryEvaluator.StreamingQueryPartitionResponse) messageProcessor)
+                    .getResultType();
-          
+
-            //TestHook used in ResourceManagerWithQueryMonitorDUnitTest.
-            //will simulate an critical memory event after a certain number of calls to doTestHook(3)
+            // TestHook used in ResourceManagerWithQueryMonitorDUnitTest.
+            // will simulate an critical memory event after a certain number of calls to
+            // doTestHook(3)
-            if(isQueryMessageProcessor && elementType != null && elementType.isStructType()) {
-              boolean convertToStruct = isSenderAbove_8_1 ;
-              if(convertToStruct && i == 0) {
+            if (isQueryMessageProcessor && elementType != null && elementType.isStructType()) {
+              boolean convertToStruct = isSenderAbove_8_1;
+              if (convertToStruct && i == 0) {
-              if(convertToStruct) {
-                o = new StructImpl( (StructTypeImpl)elementType, (Object[])o);
+              if (convertToStruct) {
+                o = new StructImpl((StructTypeImpl) elementType, (Object[]) o);
-            //TestHook to help verify that objects have been rejected.
+            // TestHook to help verify that objects have been rejected.
-    
+
-      }
-      else {
+      } else {
-      out.writeBoolean(this.lastMsg); 
+      out.writeBoolean(this.lastMsg);
-      }
-      else {
+      } else {
-    
+
+

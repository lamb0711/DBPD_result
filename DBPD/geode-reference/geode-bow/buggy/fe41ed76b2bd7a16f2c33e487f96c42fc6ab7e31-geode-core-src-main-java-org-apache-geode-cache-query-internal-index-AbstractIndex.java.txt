GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

+import java.util.Map.Entry;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import org.apache.commons.lang.StringUtils;
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.query.internal.Bag;
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.cache.query.internal.types.TypeUtils;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.partitioned.Bucket;
- * 
-  private static final AtomicIntegerFieldUpdater<RegionEntryToValuesMap> atomicUpdater =
+  // package-private to avoid synthetic accessor
+  static final AtomicIntegerFieldUpdater<RegionEntryToValuesMap> atomicUpdater =
-  final String originalProjectionAttributes;
+  private final String originalProjectionAttributes;
-  // Statistics
-  protected InternalIndexStatistics internalIndexStats;
-  // For PartitionedIndex for now
+  InternalIndexStatistics internalIndexStats;
+
+  /** For PartitionedIndex for now */
-  // Flag to indicate if index map has keys as PdxString
-  // All the keys in the index map should be either Strings or PdxStrings
-  protected Boolean isIndexedPdxKeys = false;
-  // Flag to indicate if the flag isIndexedPdxKeys is set
-  protected Boolean isIndexedPdxKeysFlagSet = false;
+  /**
+   * Flag to indicate if index map has keys as PdxString All the keys in the index map should be
+   * either Strings or PdxStrings
+   */
+  private Boolean isIndexedPdxKeys = false;
-  protected boolean indexOnRegionKeys = false;
+  /** Flag to indicate if the flag isIndexedPdxKeys is set */
+  Boolean isIndexedPdxKeysFlagSet = false;
-  protected boolean indexOnValues = false;
+  boolean indexOnRegionKeys = false;
+
+  boolean indexOnValues = false;
-  // Flag to indicate if the index is populated with data
-  protected volatile boolean isPopulated = false;
+  /** Flag to indicate if the index is populated with data */
+  volatile boolean isPopulated = false;
-      String projectionAttributes, String origFromClause, String origIndxExpr, String[] defintions,
-      IndexStatistics stats) {
+      String projectionAttributes, String originalFromClause, String originalIndexedExpression,
+      String[] defintions, IndexStatistics stats) {
+
-    this.originalIndexedExpression = origIndxExpr;
-    this.originalFromClause = origFromClause;
+    this.originalIndexedExpression = originalIndexedExpression;
+    this.originalFromClause = originalFromClause;
-    if (projectionAttributes == null || projectionAttributes.length() == 0) {
+    if (StringUtils.isEmpty(projectionAttributes)) {
+  @Override
+  @Override
-    return evaluator;
+    return this.evaluator;
+  @Override
+  @Override
-  // ////////// Index default implementation
+  @Override
+
-    if (context.getBucketList() != null && (this.region instanceof BucketRegion)) {
-      PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+    if (context.getBucketList() != null && this.region instanceof BucketRegion) {
+      PartitionedRegion pr = ((Bucket) this.region).getPartitionedRegion();
-        for (Object b : context.getBucketList()) {
-          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-          if (i == null) {
+        for (Object bucketId : context.getBucketList()) {
+          AbstractIndex bucketIndex =
+              PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) bucketId);
+          if (bucketIndex == null) {
-          i.lockedQuery(key, operator, results, null/* No Keys to be removed */, context);
+          bucketIndex.lockedQuery(key, operator, results, null/* No Keys to be removed */, context);
-        return;
+  @Override
-      RuntimeIterator indpndntIr, ExecutionContext context, List projAttrib,
+      RuntimeIterator indpndntItr, ExecutionContext context, List projAttrib,
+
-    if (context.getBucketList() != null && (this.region instanceof BucketRegion)) {
-      PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+    if (context.getBucketList() != null && this.region instanceof BucketRegion) {
+      PartitionedRegion pr = ((Bucket) region).getPartitionedRegion();
-        for (Object b : context.getBucketList()) {
-          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-          if (i == null) {
+        for (Object bucketId : context.getBucketList()) {
+          AbstractIndex bucketIndex =
+              PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) bucketId);
+          if (bucketIndex == null) {
-          i.lockedQuery(key, operator, results, iterOp, indpndntIr, context, projAttrib,
+          bucketIndex.lockedQuery(key, operator, results, iterOp, indpndntItr, context, projAttrib,
-        lockedQuery(key, operator, results, iterOp, indpndntIr, context, projAttrib,
+        lockedQuery(key, operator, results, iterOp, indpndntItr, context, projAttrib,
-    return;
+  @Override
+
-    if (context.getBucketList() != null && (this.region instanceof BucketRegion)) {
-      PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+    if (context.getBucketList() != null && this.region instanceof BucketRegion) {
+      PartitionedRegion pr = ((Bucket) region).getPartitionedRegion();
-        for (Object b : context.getBucketList()) {
-          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-          if (i == null) {
+        for (Object bucketId : context.getBucketList()) {
+          AbstractIndex bucketIndex =
+              PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) bucketId);
+          if (bucketIndex == null) {
-          i.lockedQuery(key, operator, results, keysToRemove, context);
+          bucketIndex.lockedQuery(key, operator, results, keysToRemove, context);
-    return;
+  @Override
-    Iterator itr = keysToRemove.iterator();
-    Object temp = itr.next();
-    itr.remove();
-    if (context.getBucketList() != null && (this.region instanceof BucketRegion)) {
+
+    Iterator iterator = keysToRemove.iterator();
+    Object temp = iterator.next();
+    iterator.remove();
+    if (context.getBucketList() != null && this.region instanceof BucketRegion) {
-        PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
-        for (Object b : context.getBucketList()) {
-          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-          if (i == null) {
+        PartitionedRegion partitionedRegion = ((Bucket) this.region).getPartitionedRegion();
+        for (Object bucketId : context.getBucketList()) {
+          AbstractIndex bucketIndex = PartitionedIndex.getBucketIndex(partitionedRegion,
+              this.indexName, (Integer) bucketId);
+          if (bucketIndex == null) {
-          i.lockedQuery(temp, OQLLexerTokenTypes.TOK_NE, results,
-              itr.hasNext() ? keysToRemove : null, context);
+          bucketIndex.lockedQuery(temp, OQLLexerTokenTypes.TOK_NE, results,
+              iterator.hasNext() ? keysToRemove : null, context);
-        lockedQuery(temp, OQLLexerTokenTypes.TOK_NE, results, itr.hasNext() ? keysToRemove : null,
-            context);
+        lockedQuery(temp, OQLLexerTokenTypes.TOK_NE, results,
+            iterator.hasNext() ? keysToRemove : null, context);
-    return;
+  @Override
+
-        PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+        PartitionedRegion partitionedRegion = ((Bucket) this.region).getPartitionedRegion();
-          for (Object b : context.getBucketList()) {
-            AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-            if (i == null) {
+          for (Object bucketId : context.getBucketList()) {
+            AbstractIndex bucketIndex = PartitionedIndex.getBucketIndex(partitionedRegion,
+                this.indexName, (Integer) bucketId);
+            if (bucketIndex == null) {
-            i.lockedQuery(lowerBoundKey, lowerBoundOperator, upperBoundKey, upperBoundOperator,
-                results, keysToRemove, context);
+            bucketIndex.lockedQuery(lowerBoundKey, lowerBoundOperator, upperBoundKey,
+                upperBoundOperator, results, keysToRemove, context);
-    return;
-
+  @Override
+
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-  // ////////// IndexProtocol default implementation
+  @Override
-    this.addMapping(entry);
-    return true; // if no exception, then success
+    addMapping(entry);
+    // if no exception, then success
+    return true;
-  public boolean addAllIndexMappings(Collection c) throws IMQException {
-    Iterator iterator = c.iterator();
-    while (iterator.hasNext()) {
-      this.addMapping((RegionEntry) iterator.next());
+  @Override
+  public boolean addAllIndexMappings(Collection<RegionEntry> c) throws IMQException {
+    for (RegionEntry regionEntry : c) {
+      addMapping(regionEntry);
-    return true; // if no exception, then success
+    // if no exception, then success
+    return true;
+  @Override
-    return true; // if no exception, then success
+    // if no exception, then success
+    return true;
-  public boolean removeAllIndexMappings(Collection c) throws IMQException {
-    Iterator iterator = c.iterator();
-    while (iterator.hasNext()) {
-      removeMapping((RegionEntry) iterator.next(), OTHER_OP);
+  @Override
+  public boolean removeAllIndexMappings(Collection<RegionEntry> c) throws IMQException {
+    for (RegionEntry regionEntry : c) {
+      removeMapping(regionEntry, OTHER_OP);
-    return true; // if no exception, then success
+    // if no exception, then success
+    return true;
+  @Override
-    return isValid;
+    return this.isValid;
+  @Override
-    isValid = b;
+    this.isValid = b;
-  public boolean isMatchingWithIndexExpression(CompiledValue indexExpr, String conditionExprStr,
+  @Override
+  public boolean isMatchingWithIndexExpression(CompiledValue condnExpr, String condnExprStr,
-    return this.indexedExpression.equals(conditionExprStr);
+    return this.indexedExpression.equals(condnExprStr);
-  private Object verifyAndGetPdxDomainObject(Object value) {
+  // package-private to avoid synthetic accessor
+  Object verifyAndGetPdxDomainObject(Object value) {
-      if (((StructImpl) value).isHasPdx() && !((GemFireCacheImpl) this.region.getCache())
-          .getPdxReadSerializedByAnyGemFireServices()) {
+      if (((StructImpl) value).isHasPdx()
+          && !((InternalCache) this.region.getCache()).getPdxReadSerializedByAnyGemFireServices()) {
-    } else if (value instanceof PdxInstance && !((GemFireCacheImpl) this.region.getCache())
-        .getPdxReadSerializedByAnyGemFireServices()) {
+    } else if (value instanceof PdxInstance
+        && !((InternalCache) this.region.getCache()).getPdxReadSerializedByAnyGemFireServices()) {
+
-        // intermediateResults.add(value);
+
-        // LinkedStructSet lss = (LinkedStructSet)results;
-        SelectResults sr = (SelectResults) results;
-        StructImpl structImpl =
-            new StructImpl((StructTypeImpl) sr.getCollectionType().getElementType(), values);
-        // lss.add(structImpl);
-        sr.add(structImpl);
+        SelectResults selectResults = (SelectResults) results;
+        StructImpl structImpl = new StructImpl(
+            (StructTypeImpl) selectResults.getCollectionType().getElementType(), values);
+        selectResults.add(structImpl);
+
-          int numOcc = intermediateResults.occurrences(values);
-          if (numOcc > 0) {
+          int occurrences = intermediateResults.occurrences(values);
+          if (occurrences > 0) {
+
-          // LinkedStructSet lss = (LinkedStructSet)results;
-          SelectResults sr = (SelectResults) results;
-          StructImpl structImpl =
-              new StructImpl((StructTypeImpl) sr.getCollectionType().getElementType(), values);
+          SelectResults selectResults = (SelectResults) results;
+          StructImpl structImpl = new StructImpl(
+              (StructTypeImpl) selectResults.getCollectionType().getElementType(), values);
-            sr.add(structImpl);
+            selectResults.add(structImpl);
+
-          SelectResults sr = (SelectResults) results;
-          // LinkedStructSet lss = (LinkedStructSet)results;
-          StructImpl structImpl =
-              new StructImpl((StructTypeImpl) sr.getCollectionType().getElementType(), values);
-          if (((SelectResults) intermediateResults).remove(structImpl)) {
-            sr.add(structImpl);
+          SelectResults selectResults = (SelectResults) results;
+          StructImpl structImpl = new StructImpl(
+              (StructTypeImpl) selectResults.getCollectionType().getElementType(), values);
+          if (intermediateResults.remove(structImpl)) {
+            selectResults.add(structImpl);
+
+
-      // TODO : Asif : Optimize this . This condition looks ugly.
-      /*
-       * if (result instanceof StructBag || result instanceof LinkedStructSet || result instanceof
-       * LinkedStructBag) {
-       */
+
-          Object projDef[] = (Object[]) projIter.next();
+          Object[] projDef = (Object[]) projIter.next();
-  // For local queries with distinct, deserialize all PdxInstances
-  // as we do not have a way to compare Pdx and non Pdx objects in case
-  // the cache has a mix of pdx and non pdx objects.
-  // We still have to honor the cache level readserialized flag in
-  // case of all Pdx objects in cache.
-  // Also always convert PdxString to String before adding to resultset
-  // for remote queries
-  private Object deserializePdxForLocalDistinctQuery(ExecutionContext context, Object val)
+  /**
+   * For local queries with distinct, deserialize all PdxInstances as we do not have a way to
+   * compare Pdx and non Pdx objects in case the cache has a mix of pdx and non pdx objects. We
+   * still have to honor the cache level readSerialized flag in case of all Pdx objects in cache.
+   * Also always convert PdxString to String before adding to resultSet for remote queries
+   */
+  private Object deserializePdxForLocalDistinctQuery(ExecutionContext context, Object value)
+
-      if (context.isDistinct() && val instanceof PdxInstance
+      if (context.isDistinct() && value instanceof PdxInstance
-          val = ((PdxInstance) val).getObject();
+          value = ((PdxInstance) value).getObject();
-      } else if (val instanceof PdxString) {
-        val = ((PdxString) val).toString();
+      } else if (value instanceof PdxString) {
+        value = value.toString();
-    return val;
+    return value;
+
-      SelectResults intermediateResults, boolean isIntersection, Object values[],
-      ExecutionContext context) {
+      SelectResults intermediateResults, boolean isIntersection, Object[] values) {
+
-  void removeProjection(List projAttrib, ExecutionContext context, Collection result,
+  private void removeProjection(List projAttrib, ExecutionContext context, Collection result,
+
-            values, context);
+            values);
-  /*
-   * This function returns the canonicalized defintions of the from clauses used in Index creation
-   * TODO:Asif :How to make it final so that it is immutable
+  /**
+   * This function returns the canonicalized definitions of the from clauses used in Index creation
+  @Override
-  // Asif : This implementation is for PrimaryKeyIndex. RangeIndex has its
-  // own implementation. For PrimaryKeyIndex , this method should not be used
-  // TODO: Asif : Check if an Exception should be thrown if the function
-  // implementation of this class gets invoked
+  /**
+   * This implementation is for PrimaryKeyIndex. RangeIndex has its own implementation. For
+   * PrimaryKeyIndex , this method should not be used
+   * <p>
+   * TODO: check if an Exception should be thrown if the function implementation of this class gets
+   * invoked
+   */
+  @Override
-  void instantiateEvaluator(IndexCreationHelper ich) {}
+  abstract void instantiateEvaluator(IndexCreationHelper indexCreationHelper);
-  public void initializeIndex(boolean loadEntries) throws IMQException {}
-
+  @Override
+  public void initializeIndex(boolean loadEntries) throws IMQException {
+    // implement me
+  }
-    StringBuffer sb = new StringBuffer();
+    StringBuilder sb = new StringBuilder();
-    sb.append("]");
+    sb.append(']');
+  @Override
-   * Shobhit: This is used to buffer the index entries evaluated from a RegionEntry which is getting
-   * updated at present. These buffered index entries are replaced into the index later all together
-   * to avoid remove-add sequence.
-   * 
-   * @param key
-   * @param value
-   * @param entry
-   * @throws IMQException
+   * This is used to buffer the index entries evaluated from a RegionEntry which is getting updated
+   * at present. These buffered index entries are replaced into the index later all together to
+   * avoid remove-add sequence.
-    return prIndex;
+    return this.prIndex;
-  public void setPRIndex(Index parIndex) {
+  void setPRIndex(Index parIndex) {
-
-  protected static abstract class InternalIndexStatistics implements IndexStatistics {
+  protected abstract static class InternalIndexStatistics implements IndexStatistics {
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
-    public long getUpdateTime() {
-      return 0L;
-    }
-
-    public long getUseTime() {
-      return 0L;
-    }
-
+    @Override
+    @Override
+    @Override
-  /**
-   * 
-   */
-    private Cache cache;
+    private final InternalCache cache;
-    final private String[] canonicalIterNames;
+    private final String[] canonicalIterNames;
-    /*
-     * Asif : The boolean if true indicates that the 0th iterator is on entries . If the 0th
-     * iterator is on collection of Region.Entry objects, then the RegionEntry object used in Index
-     * data objects is obtained directly from its corresponding Region.Entry object. However if the
-     * 0th iterator is not on entries then the boolean is false. In this case the additional
-     * projection attribute gives us the original value of the iterator while the Region.Entry
-     * object is obtained from 0th iterator. It is possible to have index being created on a Region
-     * Entry itself , instead of a Region. A Map operator( Compiled Index Operator) used with Region
-     * enables, us to create such indexes. In such case the 0th iterator, even if it represents a
-     * collection of Objects which are not Region.Entry objects, still the boolean remains true, as
-     * the Entry object can be easily obtained from the 0th iterator. In this case, the additional
-     * projection attribute s not null as it is used to evaluate the Entry object from the 0th
-     * iterator.
+    /**
+     * The boolean if true indicates that the 0th iterator is on entries . If the 0th iterator is on
+     * collection of Region.Entry objects, then the RegionEntry object used in Index data objects is
+     * obtained directly from its corresponding Region.Entry object. However if the 0th iterator is
+     * not on entries then the boolean is false. In this case the additional projection attribute
+     * gives us the original value of the iterator while the Region.Entry object is obtained from
+     * 0th iterator. It is possible to have index being created on a Region Entry itself , instead
+     * of a Region. A Map operator( Compiled Index Operator) used with Region enables, us to create
+     * such indexes. In such case the 0th iterator, even if it represents a collection of Objects
+     * which are not Region.Entry objects, still the boolean remains true, as the Entry object can
+     * be easily obtained from the 0th iterator. In this case, the additional projection attribute s
+     * not null as it is used to evaluate the Entry object from the 0th iterator.
-    // Shobhit: The boolean if true indicates that the 0th iterator is on keys.
+    /** The boolean if true indicates that the 0th iterator is on keys. */
-    // Asif: List of modified iterators, not null only when the booelan
-    // isFirstItrOnEntry is false.
+    /**
+     * List of modified iterators, not null only when the boolean isFirstItrOnEntry is false.
+     */
-    // Asif : The additional Projection attribute representing the value of the
-    // original 0th iterator.
-    // If the isFirstItrOnEntry is false, then it is not null. However if the
-    // isFirstItrOnEntry is
-    // true but & still this attribute is not null, this indicates that the 0th
-    // iterator
-    // is derived using an individual entry thru Map operator on the Region.
+    /**
+     * The additional Projection attribute representing the value of the original 0th iterator. If
+     * the isFirstItrOnEntry is false, then it is not null. However if the isFirstItrOnEntry is true
+     * but & still this attribute is not null, this indicates that the 0th iterator is derived using
+     * an individual entry thru Map operator on the Region.
+     */
-    // Asif : This is not null iff the boolean isFirstItrOnEntry is false.
+    /** This is not null iff the boolean isFirstItrOnEntry is false. */
-      // Asif : The modified iterators for optmizing Index cxreation
-      isFirstItrOnEntry = ((FunctionalIndexCreationHelper) helper).isFirstIteratorRegionEntry;
-      isFirstItrOnKey = ((FunctionalIndexCreationHelper) helper).isFirstIteratorRegionKey;
-      additionalProj = ((FunctionalIndexCreationHelper) helper).additionalProj;
-      Object params1[] = {new QRegion(rgn, false)};
-      initContext = new ExecutionContext(params1, cache);
+      // The modified iterators for optimizing Index creation
+      this.isFirstItrOnEntry = ((FunctionalIndexCreationHelper) helper).isFirstIteratorRegionEntry;
+      this.isFirstItrOnKey = ((FunctionalIndexCreationHelper) helper).isFirstIteratorRegionKey;
+      this.additionalProj = ((FunctionalIndexCreationHelper) helper).additionalProj;
+      Object[] params1 = {new QRegion(this.rgn, false)};
+      this.initContext = new ExecutionContext(params1, this.cache);
-      if (isFirstItrOnEntry) {
+      if (this.isFirstItrOnEntry) {
-        modifiedIndexExpr = ((FunctionalIndexCreationHelper) helper).modifiedIndexExpr;
-        addnlProjType = ((FunctionalIndexCreationHelper) helper).addnlProjType;
+        this.modifiedIndexExpr = ((FunctionalIndexCreationHelper) helper).modifiedIndexExpr;
+        this.addnlProjType = ((FunctionalIndexCreationHelper) helper).addnlProjType;
-
+    @Override
+    @Override
+    @Override
+    @Override
+    @Override
-      DummyQRegion dQRegion = new DummyQRegion(rgn);
+      DummyQRegion dQRegion = new DummyQRegion(this.rgn);
-      Object params[] = {dQRegion};
+      Object[] params = {dQRegion};
+
-        if (dependencyGraph != null) {
-          context.setDependencyGraph(dependencyGraph);
+        if (this.dependencyGraph != null) {
+          context.setDependencyGraph(this.dependencyGraph);
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators.get(i);
-          // Asif: Compute the dependency only once. The call to methods of this
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) this.fromIterators.get(i);
+          // Compute the dependency only once. The call to methods of this
+
-        if (dependencyGraph == null) {
-          dependencyGraph = context.getDependencyGraph();
+        if (this.dependencyGraph == null) {
+          this.dependencyGraph = context.getDependencyGraph();
-     * Asif : This function is used for creating Index data at the start
-     * 
+     * This function is used for creating Index data at the start
+    @Override
-        // Asif: Since an index initialization can happen multiple times
-        // for a given region, due to clear operation, we are using harcoded
-        // scope ID of 1 , as otherwise if obtained from ExecutionContext
-        // object,
-        // it will get incremented on very index initialization
+        // Since an index initialization can happen multiple times for a given region, due to clear
+        // operation, we are using hardcoded scope ID of 1 , as otherwise if obtained from
+        // ExecutionContext object, it will get incremented on very index initialization
-        // System.out.println("Level = "+level+" Iter = "+rIter.getDef());
-        Collection c = rIter.evaluateCollection(this.initContext);
-        if (c == null)
+        Collection collection = rIter.evaluateCollection(this.initContext);
+        if (collection == null) {
-        Iterator cIter = c.iterator();
-        while (cIter.hasNext()) {
-          rIter.setCurrent(cIter.next());
+        }
+        for (Object aCollection : collection) {
+          rIter.setCurrent(aCollection);
-    /*
-     * Asif : This function is used to obtain Indxe data at the time of index creation. Each element
-     * of the List is an Object Array of size 3. The 0th element of Object Array stores the value of
-     * Index Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the
-     * booelan isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry
-     * object which can be used to obtain the underlying RegionEntry object. If the boolean is true
-     * & additional projection attribute is not null, then the Region.Entry object can be obtained
-     * by evaluating the additional projection attribute. If the boolean isFirstItrOnEntry is tru e&
-     * additional projection attribute is null, then teh 0th iterator itself will evaluate to
-     * Region.Entry Object.
-     * 
+    /**
+     * This function is used to obtain Index data at the time of index creation. Each element of the
+     * List is an Object Array of size 3. The 0th element of Object Array stores the value of Index
+     * Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the boolean
+     * isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry object which
+     * can be used to obtain the underlying RegionEntry object. If the boolean is true & additional
+     * projection attribute is not null, then the Region.Entry object can be obtained by evaluating
+     * the additional projection attribute. If the boolean isFirstItrOnEntry is true & additional
+     * projection attribute is null, then the 0th iterator itself will evaluate to Region.Entry
+     * Object.
+     * <p>
+
-      LocalRegion.NonTXEntry temp = null;
+      LocalRegion.NonTXEntry temp;
-        temp = (LocalRegion.NonTXEntry) additionalProj.evaluate(this.initContext);
+        temp = (LocalRegion.NonTXEntry) this.additionalProj.evaluate(this.initContext);
-        temp = (LocalRegion.NonTXEntry) (((RuntimeIterator) currrentRuntimeIters.get(0))
-            .evaluate(this.initContext));
+        temp = (LocalRegion.NonTXEntry) ((RuntimeIterator) currrentRuntimeIters.get(0))
+            .evaluate(this.initContext);
-      Object indxResultSet = null;
+      Object indxResultSet;
-      // Object tuple[] ;
-            ? ((this.additionalProj == null) ? temp
-                : ((RuntimeIterator) currrentRuntimeIters.get(0)).evaluate(this.initContext))
-            : additionalProj.evaluate(this.initContext);
+            ? this.additionalProj == null ? temp
+                : ((RuntimeIterator) currrentRuntimeIters.get(0)).evaluate(this.initContext)
+            : this.additionalProj.evaluate(this.initContext);
-        int i = (this.isFirstItrOnEntry) ? 0 : 1;
+        int i = this.isFirstItrOnEntry ? 0 : 1;
-        if (!this.isFirstItrOnEntry)
-          tuple[0] = additionalProj.evaluate(this.initContext);
+        if (!this.isFirstItrOnEntry) {
+          tuple[0] = this.additionalProj.evaluate(this.initContext);
+        }
-      // destroyed
-      // and so if value is UNDEFINED, key will definitely will be UNDEFINED.
+      // destroyed and so if value is UNDEFINED, key will definitely will be UNDEFINED.
-          : modifiedIndexExpr.evaluate(this.initContext);
+          : this.modifiedIndexExpr.evaluate(this.initContext);
-      if (!isIndexedPdxKeysFlagSet) {
+      if (!AbstractIndex.this.isIndexedPdxKeysFlagSet) {
-    // TODO:Asif : This appears to be incorrect.
+
-        // System.out.println("Level = "+level+" Iter = "+rIter.getDef());
-        Collection c = rIter.evaluateCollection(context);
-        if (c == null)
+        Collection collection = rIter.evaluateCollection(context);
+        if (collection == null) {
-        Iterator cIter = c.iterator();
-        while (cIter.hasNext()) {
-          rIter.setCurrent(cIter.next());
+        }
+        for (Object aCollection : collection) {
+          rIter.setCurrent(aCollection);
+
-      Object indxResultSet = null;
-      // int size = currrentRuntimeIters.size();
-      Object indexKey = indexedExpr.evaluate(context);
+      Object indexKey = this.indexedExpr.evaluate(context);
-      if (!isIndexedPdxKeysFlagSet) {
+      if (!AbstractIndex.this.isIndexedPdxKeysFlagSet) {
+      Object indxResultSet;
+
-      // Keep Entry value in fly untill all keys are evaluated
+      // Keep Entry value in fly until all keys are evaluated
-    // TODO :Asif: Test this function .
-    // The struct type calculation is modified if the
-    // 0th iterator is modified to make it dependent on Entry
+    /**
+     * The struct type calculation is modified if the 0th iterator is modified to make it dependent
+     * on Entry
+     */
-      ObjectType type = null;
-      // String fieldNames[] = new String[len];
-      ObjectType fieldTypes[] = new ObjectType[len];
+      ObjectType[] fieldTypes = new ObjectType[len];
-        // fieldNames[start] = iter.getInternalId();
-        // fieldNames[0] = "iter1";
-        fieldTypes[0] = addnlProjType;
+        fieldTypes[0] = this.addnlProjType;
-      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(this.canonicalIterNames, fieldTypes);
-      return type;
+      return len == 1 ? fieldTypes[0] : new StructTypeImpl(this.canonicalIterNames, fieldTypes);
-    private void printList(List list) {
-      System.out.println("results.size = " + list.size());
-      for (int i = 0; i < list.size(); i++) {
-        Object arr[] = (Object[]) list.get(i);
-        System.out.println("Key = " + arr[0]);
-        System.out.println("Value =" + arr[1]);
-      }
-    }
-
-    int getTotalEntriesUpdated() {
-      return this.initEntriesUpdated;
-    }
-
+    @Override
-    public boolean isFirstItrOnEntry() {
-      return isFirstItrOnEntry;
+    boolean isFirstItrOnEntry() {
+      return this.isFirstItrOnEntry;
-    public boolean isFirstItrOnKey() {
-      return isFirstItrOnKey;
+    boolean isFirstItrOnKey() {
+      return this.isFirstItrOnKey;
-      return fromIterators;
+      return this.fromIterators;
-   * @param result
-   * @param limit
-   * @param context
-  protected boolean verifyLimit(Collection result, int limit, ExecutionContext context) {
-    if (limit > 0) {
-      /*
-       * if (!context.isDistinct()) { return ((Bag)result).size() == limit; } else if (result.size()
-       * == limit) { return true; }
-       */
-      return result.size() == limit;
-    }
-    return false;
+  boolean verifyLimit(Collection result, int limit) {
+    return limit > 0 && result.size() == limit;
-   * @param re
-   * @param value
-   * @param context
-  protected boolean verifyEntryAndIndexVaue(RegionEntry re, Object value,
-      ExecutionContext context) {
+  // package-private to avoid synthetic accessor
+  boolean verifyEntryAndIndexValue(RegionEntry re, Object value, ExecutionContext context) {
-      // In a RegionEntry key and Entry itself can not be modified else
-      // RegionEntry itself will change. So no need to verify anything just return
-      // true.
+      // In a RegionEntry key and Entry itself can not be modified else RegionEntry itself will
+      // change. So no need to verify anything just return true.
-      // TODO: Create a new LocalizedString for this.
-   * @param valueInRegion
-   * @param valueInIndex
-    } else if (valueInRegion instanceof Struct && !(valueInIndex instanceof Struct)) {
+
+    } else if (valueInRegion instanceof Struct) {
-    } else if (!(valueInRegion instanceof Struct) && valueInIndex instanceof Struct) {
+
+    } else if (valueInIndex instanceof Struct) {
-   * @throws QueryInvocationTargetException
-   * @throws NameResolutionException
-   * @throws TypeMismatchException
-   * @throws FunctionDomainException
-  protected List evaluateIndexIteratorsFromRE(Object value, ExecutionContext context)
+  private List evaluateIndexIteratorsFromRE(Object value, ExecutionContext context)
+
-    List values = evaluateLastColl(value, context, itrs, 0);
-    return values;
+    return evaluateLastColl(value, context, itrs, 0);
-    // A tuple is a value generated from RegionEntry value which could be
-    // a StructType (Multiple Dependent Iterators) or ObjectType (Single
-    // Iterator) value.
+
+    // A tuple is a value generated from RegionEntry value which could be a StructType (Multiple
+    // Dependent Iterators) or ObjectType (Single Iterator) value.
+
-    if ((itrs.size() - 1) == level) {
+    if (itrs.size() - 1 == level) {
-        Object tuple[] = new Object[itrs.size()];
+        Object[] tuple = new Object[itrs.size()];
-      // If value is null or INVALID then the evaluated collection would be
-      // Null.
+      // If value is null or INVALID then the evaluated collection would be Null.
-   * @param context
-  public RuntimeIterator getRuntimeIteratorForThisIndex(ExecutionContext context) {
+  RuntimeIterator getRuntimeIteratorForThisIndex(ExecutionContext context) {
-      rgn = ((BucketRegion) rgn).getPartitionedRegion();
+      rgn = ((Bucket) rgn).getPartitionedRegion();
-      // GemFireCacheImpl.getInstance().getLogger().fine("Shobhit: "+ itr.getDefinition() + " "+
-      // this.getRegion().getFullPath());
-   * @param context
-   * @param info
-  public RuntimeIterator getRuntimeIteratorForThisIndex(ExecutionContext context, IndexInfo info) {
+  RuntimeIterator getRuntimeIteratorForThisIndex(ExecutionContext context, IndexInfo info) {
-      rgn = ((BucketRegion) rgn).getPartitionedRegion();
+      rgn = ((Bucket) rgn).getPartitionedRegion();
-      if ((itr.getDefinition().equals(regionPath) || itr.getDefinition().equals(definition))) {
+      if (itr.getDefinition().equals(regionPath) || itr.getDefinition().equals(definition)) {
-      return getReceiverNameFromPath(((CompiledIndexOperation) path).getReceiver());
+      return getReceiverNameFromPath(path.getReceiver());
-  public List getAllDependentRuntimeIterators(ExecutionContext context) {
+  private List getAllDependentRuntimeIterators(ExecutionContext context) {
-    ArrayList itrs = new ArrayList();
+    List itrs = new ArrayList();
-   * 
-   *
-    private boolean useList;
+    private final boolean useList;
-     * 
-     * @param entry
-     * @param value
-      // Values must NOT be null and ConcurrentHashMap does not
-      // support null values.
+      // Values must NOT be null and ConcurrentHashMap does not support null values.
-      Object object = map.get(entry);
+      Object object = this.map.get(entry);
-        map.put(entry, value);
+        this.map.put(entry, value);
-        if (useList) {
+        if (this.useList) {
-        Collection coll = useList ? new ArrayList(2) : new IndexConcurrentHashSet(2, 0.75f, 1);
+        Collection coll = this.useList ? new ArrayList(2) : new IndexConcurrentHashSet(2, 0.75f, 1);
-        map.put(entry, coll);
+        this.map.put(entry, coll);
-      Object object = map.get(entry);
+      Object object = this.map.get(entry);
-        Collection coll = useList ? new ArrayList(values.size())
+        Collection coll = this.useList ? new ArrayList(values.size())
-        map.put(entry, coll);
+        this.map.put(entry, coll);
-        if (useList) {
+        if (this.useList) {
-        Collection coll = useList ? new ArrayList(values.size() + 1)
+        Collection coll = this.useList ? new ArrayList(values.size() + 1)
-        map.put(entry, coll);
+        this.map.put(entry, coll);
-      return map.get(entry);
+      return this.map.get(entry);
-     *
-     * @param entry
-     * @param value
-      Object object = map.get(entry);
+      Object object = this.map.get(entry);
-        boolean removed = false;
+        boolean removed;
-        if (useList) {
+        if (this.useList) {
-            map.remove(entry);
+            this.map.remove(entry);
-          map.remove(entry);
+          this.map.remove(entry);
-      Object retVal = map.remove(entry);
+      Object retVal = this.map.remove(entry);
-            (retVal instanceof Collection) ? -((Collection) retVal).size() : -1);
+            retVal instanceof Collection ? -((Collection) retVal).size() : -1);
-    public int getNumValues(RegionEntry entry) {
-      Object object = map.get(entry);
+    int getNumValues(RegionEntry entry) {
+      Object object = this.map.get(entry);
-      return map.keySet().size();
+      return this.map.keySet().size();
-    public void addValuesToCollection(Collection result, int limit, ExecutionContext context) {
-
-      Iterator entriesIter = map.entrySet().iterator();
-      while (entriesIter.hasNext()) {
+    void addValuesToCollection(Collection result, int limit, ExecutionContext context) {
+      for (final Object o : this.map.entrySet()) {
-        if (this.verifylimit(result, limit, context)) {
+        if (this.verifyLimit(result, limit, context)) {
-        Map.Entry e = (Map.Entry) entriesIter.next();
+        Entry e = (Entry) o;
-              Iterator itr = ((Collection) value).iterator();
-              while (itr.hasNext()) {
-                Object val = itr.next();
-                // Shobhit: Compare the value in index with in RegionEntry.
-                if (!reUpdateInProgress || verifyEntryAndIndexVaue(re, val, context)) {
+              for (Object val : (Iterable) value) {
+                // Compare the value in index with in RegionEntry.
+                if (!reUpdateInProgress || verifyEntryAndIndexValue(re, val, context)) {
-            Iterator itr = ((Collection) value).iterator();
-            while (itr.hasNext()) {
-              Object val = itr.next();
-              // Shobhit: Compare the value in index with in RegionEntry.
-              if (!reUpdateInProgress || verifyEntryAndIndexVaue(re, val, context)) {
+            for (Object val : (Iterable) value) {
+              // Compare the value in index with in RegionEntry.
+              if (!reUpdateInProgress || verifyEntryAndIndexValue(re, val, context)) {
-                if (this.verifylimit(result, limit, context)) {
+                if (this.verifyLimit(result, limit, context)) {
-          if (!reUpdateInProgress || verifyEntryAndIndexVaue(re, value, context)) {
+          if (!reUpdateInProgress || verifyEntryAndIndexValue(re, value, context)) {
-    public void addValuesToCollection(Collection result, CompiledValue iterOp,
-        RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
-        SelectResults intermediateResults, boolean isIntersection, int limit)
-        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-        QueryInvocationTargetException {
-      if (this.verifylimit(result, limit, context)) {
+    void addValuesToCollection(Collection result, CompiledValue iterOp, RuntimeIterator runtimeItr,
+        ExecutionContext context, List projAttrib, SelectResults intermediateResults,
+        boolean isIntersection, int limit) throws FunctionDomainException, TypeMismatchException,
+        NameResolutionException, QueryInvocationTargetException {
+
+      if (this.verifyLimit(result, limit, context)) {
-      // Iterator valuesIter = map.values().iterator();
-      Iterator entries = map.entrySet().iterator();
-      while (entries.hasNext()) {
+
+      for (Object o : this.map.entrySet()) {
-        Map.Entry e = (Map.Entry) entries.next();
+        Entry e = (Entry) o;
-        boolean reUpdateInProgress = false;
+          boolean reUpdateInProgress = false;
-                Iterator itr = ((Collection) value).iterator();
-                while (itr.hasNext()) {
+                for (Object o1 : ((Iterable) value)) {
-                  Object val = itr.next();
-                    // Shobhit: Compare the value in index with value in RegionEntry.
-                    ok = verifyEntryAndIndexVaue(entry, val, context);
+                    // Compare the value in index with value in RegionEntry.
+                    ok = verifyEntryAndIndexValue(entry, o1, context);
-                    runtimeItr.setCurrent(val);
+                    runtimeItr.setCurrent(o1);
-                    applyProjection(projAttrib, context, result, val, intermediateResults,
+                    applyProjection(projAttrib, context, result, o1, intermediateResults,
-                    // return pResultSet;
-              Iterator itr = ((Collection) value).iterator();
-              while (itr.hasNext()) {
+              for (Object o1 : ((Iterable) value)) {
-                Object val = itr.next();
-                  // Shobhit: Compare the value in index with value in RegionEntry.
-                  ok = verifyEntryAndIndexVaue(entry, val, context);
+                  // Compare the value in index with value in RegionEntry.
+                  ok = verifyEntryAndIndexValue(entry, o1, context);
-                  runtimeItr.setCurrent(val);
+                  runtimeItr.setCurrent(o1);
-                  applyProjection(projAttrib, context, result, val, intermediateResults,
+                  applyProjection(projAttrib, context, result, o1, intermediateResults,
-                  if (this.verifylimit(result, limit, context)) {
+                  if (this.verifyLimit(result, limit, context)) {
-                  // return pResultSet;
-              // Shobhit: Compare the value in index with in RegionEntry.
-              ok = verifyEntryAndIndexVaue(entry, value, context);
+              // Compare the value in index with in RegionEntry.
+              ok = verifyEntryAndIndexValue(entry, value, context);
-    public void removeValuesFromCollection(Collection result, CompiledValue iterOps,
-        RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
-        SelectResults intermediateResults, boolean isIntersection) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      // Iterator valuesIter = map.values().iterator();
-      Iterator entries = map.entrySet().iterator();
-      while (entries.hasNext()) {
-        Map.Entry e = (Map.Entry) entries.next();
-        Object value = e.getValue();
-        if (value instanceof Collection) {
-          Iterator itr = ((Collection) value).iterator();
-          while (itr.hasNext()) {
-            boolean ok = true;
-            Object val = itr.next();
-            if (runtimeItr != null) {
-              runtimeItr.setCurrent(val);
-              ok = QueryUtils.applyCondition(iterOps, context);
-
-            }
-            if (ok) {
-              removeProjection(projAttrib, context, result, val, intermediateResults,
-                  isIntersection);
-            }
-          }
-        } else {
-          boolean ok = true;
-          if (runtimeItr != null) {
-            // Attempt to remove only if it was apossibly added
-            runtimeItr.setCurrent(value);
-            ok = QueryUtils.applyCondition(iterOps, context);
-          }
-          if (ok) {
-            if (context.isCqQueryContext()) {
-              result.remove(new CqEntry(((RegionEntry) e.getKey()).getKey(), value));
-            } else {
-              removeProjection(projAttrib, context, result, value, intermediateResults,
-                  isIntersection);
-            }
-          }
-
-        }
-      }
-    }
-
-    public void removeValuesFromCollection(Collection result) {
-      Iterator valuesIter = map.values().iterator();
-      while (valuesIter.hasNext()) {
-        Object value = valuesIter.next();
-        if (value instanceof Collection)
-          result.removeAll((Collection) value);
-        else
-          result.remove(value);
-      }
-    }
-
-    private boolean verifylimit(Collection result, int limit, ExecutionContext context) {
+    private boolean verifyLimit(Collection result, int limit, ExecutionContext context) {
-          return ((Bag) result).size() == limit;
+          return result.size() == limit;
-      return map.containsKey(entry);
+      return this.map.containsKey(entry);
-      map.clear();
+      this.map.clear();
-      return map.entrySet();
+      return this.map.entrySet();
-     * 
-     * @param entry
-     * @param values
-          ((values instanceof Collection) ? ((Collection) values).size() : 1) - numOldValues);
+          (values instanceof Collection ? ((Collection) values).size() : 1) - numOldValues);
-   * This will populate resultset from both type of indexes, {@link CompactRangeIndex} and
+   * This will populate resultSet from both type of indexes, {@link CompactRangeIndex} and
-   * 
-   * @param list
-   * @param outerEntries
-   * @param innerEntries
-   * @param context
-   * @param key
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-  protected void populateListForEquiJoin(List list, Object outerEntries, Object innerEntries,
+  void populateListForEquiJoin(List list, Object outerEntries, Object innerEntries,
-    Assert.assertTrue((outerEntries != null && innerEntries != null),
+    Assert.assertTrue(outerEntries != null && innerEntries != null,
-    Object values[][] = new Object[2][];
+    Object[][] values = new Object[2][];
-      // TODO :Asif Identify appropriate size of the List
-            entryVal = ((Collection) val).iterator().next();
+            entryVal = ((Iterable) val).iterator().next();
+
-            ok = ((RangeIndex) indInfo._getIndex()).verifyEntryAndIndexVaue(re, entryVal, context);
+            ok = ((RangeIndex) indInfo._getIndex()).verifyEntryAndIndexValue(re, entryVal, context);
-   * 
-   * @param key
-  public synchronized void setPdxStringFlag(Object key) {
+  synchronized void setPdxStringFlag(Object key) {
-    if (!isIndexedPdxKeys) {
+    if (!this.isIndexedPdxKeys) {
-        isIndexedPdxKeys = true;
+        this.isIndexedPdxKeys = true;
-    isIndexedPdxKeysFlagSet = true;
+    this.isIndexedPdxKeysFlagSet = true;
-   * @param key
-  public Object getPdxStringForIndexedPdxKeys(Object key) {
-    if (isIndexedPdxKeys) {
+  Object getPdxStringForIndexedPdxKeys(Object key) {
+    if (this.isIndexedPdxKeys) {
-      return ((PdxString) key).toString();
+      return key.toString();
-  public boolean removeFromKeysToRemove(Collection keysToRemove, Object key) {
-    Iterator iterator = keysToRemove.iterator();
-    while (iterator.hasNext()) {
-      try {
-        if (TypeUtils.compare(key, iterator.next(), OQLLexerTokenTypes.TOK_EQ)
-            .equals(Boolean.TRUE)) {
-          iterator.remove();
-          return true;
-        }
-      } catch (TypeMismatchException e) {
-        // they are not equals, so we just continue iterating
-      }
-    }
-    return false;
-  }
-
-  public boolean acquireIndexReadLockForRemove() {
+  boolean acquireIndexReadLockForRemove() {
-    if (logger.isDebugEnabled()) {
+    if (isDebugEnabled) {
-    removeIndexLock.writeLock().lock();
-    if (logger.isDebugEnabled()) {
+    this.removeIndexLock.writeLock().lock();
+    if (isDebugEnabled) {
-    removeIndexLock.writeLock().unlock();
+    this.removeIndexLock.writeLock().unlock();
-    return isPopulated;
+    return this.isPopulated;
-
-

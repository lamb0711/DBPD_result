Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
+
-  
+
-  
-  private final ThreadGroup threadGroup = 
-    LoggingThreadGroup.createThreadGroup("GatewaySenderAdvisor Threads");
-  
+
+  private final ThreadGroup threadGroup =
+      LoggingThreadGroup.createThreadGroup("GatewaySenderAdvisor Threads");
+
-  
+
-    this.sender = (AbstractGatewaySender)sender;
+    this.sender = (AbstractGatewaySender) sender;
-  
+
-  public String getDLockServiceName(){
+  public String getDLockServiceName() {
-  
+
+
-  protected Profile instantiateProfile(InternalDistributedMember memberId,
-      int version) {
+  protected Profile instantiateProfile(InternalDistributedMember memberId, int version) {
-   * The profile will be created when the sender is added to the cache. here we
-   * are not starting the sender. so we should not release or acquire any lock
-   * for the sender to become primary based on creation only.
+   * The profile will be created when the sender is added to the cache. here we are not starting the
+   * sender. so we should not release or acquire any lock for the sender to become primary based on
+   * creation only.
-      GatewaySenderProfile sp = (GatewaySenderProfile)profile;
+      GatewaySenderProfile sp = (GatewaySenderProfile) profile;
-              .toString(new Object[] { sp.Id, sp.remoteDSId, sender.remoteDSId }));
+              .toString(new Object[] {sp.Id, sp.remoteDSId, sender.remoteDSId}));
-              .toString(new Object[] { sp.Id }));
+              .toString(new Object[] {sp.Id}));
-              .toString(new Object[] { sp.Id }));
+              .toString(new Object[] {sp.Id}));
-              .toString(new Object[] { sp.Id, sp.isBatchConflationEnabled,
-                  sender.isBatchConflationEnabled() }));
+              .toString(new Object[] {sp.Id, sp.isBatchConflationEnabled,
+                  sender.isBatchConflationEnabled()}));
-              .toString(new Object[] { sp.Id, sp.isPersistenceEnabled,
-                  sender.isPersistenceEnabled() }));
+              .toString(
+                  new Object[] {sp.Id, sp.isPersistenceEnabled, sender.isPersistenceEnabled()}));
-              .toString(new Object[] { sp.Id, sp.alertThreshold,
-                  sender.getAlertThreshold() }));
+              .toString(new Object[] {sp.Id, sp.alertThreshold, sender.getAlertThreshold()}));
-                .toString(new Object[] { sp.Id, sp.manualStart,
-                    sender.isManualStart() }));
+                .toString(new Object[] {sp.Id, sp.manualStart, sender.isManualStart()}));
-    /*if(sp.dispatcherThreads != sender.getDispatcherThreads()) {
-      throw new IllegalStateException(
-          LocalizedStrings.GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_DISPATCHER_THREAD_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_DISPATCHER_THREAD_2
-              .toString(new Object[] { sp.Id, sp.dispatcherThreads,
-                  sender.getDispatcherThreads() }));
-    }*/
-    
-    if(!sp.isParallel) {
-      if(sp.orderPolicy != sender.getOrderPolicy()) {
+    /*
+     * if(sp.dispatcherThreads != sender.getDispatcherThreads()) { throw new IllegalStateException(
+     * LocalizedStrings.
+     * GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_DISPATCHER_THREAD_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_DISPATCHER_THREAD_2
+     * .toString(new Object[] { sp.Id, sp.dispatcherThreads, sender.getDispatcherThreads() })); }
+     */
+
+    if (!sp.isParallel) {
+      if (sp.orderPolicy != sender.getOrderPolicy()) {
-                .toString(new Object[] { sp.Id, sp.orderPolicy,
-                    sender.getOrderPolicy() }));
+                .toString(new Object[] {sp.Id, sp.orderPolicy, sender.getOrderPolicy()}));
-    for (org.apache.geode.cache.wan.GatewayEventFilter filter : sender
-        .getGatewayEventFilters()) {
+    for (org.apache.geode.cache.wan.GatewayEventFilter filter : sender.getGatewayEventFilters()) {
-          LocalizedStrings.GatewaySenderAdvisor_GATEWAY_EVENT_FILTERS_MISMATCH
-              .toString(new Object[] { sp.Id, sp.eventFiltersClassNames,
-                  senderEventFilterClassNames }));
-    }
-    else {
-      for(String filterName : senderEventFilterClassNames){
-        if(!sp.eventFiltersClassNames.contains(filterName)){
+          LocalizedStrings.GatewaySenderAdvisor_GATEWAY_EVENT_FILTERS_MISMATCH.toString(
+              new Object[] {sp.Id, sp.eventFiltersClassNames, senderEventFilterClassNames}));
+    } else {
+      for (String filterName : senderEventFilterClassNames) {
+        if (!sp.eventFiltersClassNames.contains(filterName)) {
-              LocalizedStrings.GatewaySenderAdvisor_GATEWAY_EVENT_FILTERS_MISMATCH
-                  .toString(new Object[] { sp.Id, sp.eventFiltersClassNames,
-                      senderEventFilterClassNames }));
+              LocalizedStrings.GatewaySenderAdvisor_GATEWAY_EVENT_FILTERS_MISMATCH.toString(
+                  new Object[] {sp.Id, sp.eventFiltersClassNames, senderEventFilterClassNames}));
-    
+
-    for (GatewayTransportFilter filter : sender
-        .getGatewayTransportFilters()) {
+    for (GatewayTransportFilter filter : sender.getGatewayTransportFilters()) {
-          LocalizedStrings.GatewaySenderAdvisor_GATEWAY_TRANSPORT_FILTERS_MISMATCH
-              .toString(new Object[] { sp.Id, sp.transFiltersClassNames,
-                  senderTransportFilterClassNames }));
-    }
-    else {
+          LocalizedStrings.GatewaySenderAdvisor_GATEWAY_TRANSPORT_FILTERS_MISMATCH.toString(
+              new Object[] {sp.Id, sp.transFiltersClassNames, senderTransportFilterClassNames}));
+    } else {
-      while(i1.hasNext() && i2.hasNext()){
-        if(!i1.next().equals(i2.next())){
+      while (i1.hasNext() && i2.hasNext()) {
+        if (!i1.next().equals(i2.next())) {
-                  .toString(new Object[] { sp.Id, sp.transFiltersClassNames,
-                      senderTransportFilterClassNames }));    
+                  .toString(new Object[] {sp.Id, sp.transFiltersClassNames,
+                      senderTransportFilterClassNames}));
-    for (AsyncEventListener listener : sender
-        .getAsyncEventListeners()) {
+    for (AsyncEventListener listener : sender.getAsyncEventListeners()) {
-              .toString(new Object[] { sp.Id, sp.senderEventListenerClassNames,
-                  senderEventListenerClassNames }));
-    }
-    else {
-      for(String listenerName : senderEventListenerClassNames){
-        if(!sp.senderEventListenerClassNames.contains(listenerName)){
+              .toString(new Object[] {sp.Id, sp.senderEventListenerClassNames,
+                  senderEventListenerClassNames}));
+    } else {
+      for (String listenerName : senderEventListenerClassNames) {
+        if (!sp.senderEventListenerClassNames.contains(listenerName)) {
-                  .toString(new Object[] { sp.Id, sp.senderEventListenerClassNames,
-                      senderEventListenerClassNames }));
+                  .toString(new Object[] {sp.Id, sp.senderEventListenerClassNames,
+                      senderEventListenerClassNames}));
-              .toString(new Object[] { sp.Id, sp.isDiskSynchronous,
-                  sender.isDiskSynchronous() }));
+              .toString(new Object[] {sp.Id, sp.isDiskSynchronous, sender.isDiskSynchronous()}));
-   * If there is change in sender which having policy as primary.
-   * 1. If that sender is stopped then if there are no other primary senders then this sender should volunteer for primary.
-   * 2. If this sender is primary and its policy is secondary then this sender should release the lock so that other primary sender which s waiting on lock will get the lock.
+   * If there is change in sender which having policy as primary. 1. If that sender is stopped then
+   * if there are no other primary senders then this sender should volunteer for primary. 2. If this
+   * sender is primary and its policy is secondary then this sender should release the lock so that
+   * other primary sender which s waiting on lock will get the lock.
-      GatewaySenderProfile sp = (GatewaySenderProfile)profile;
+      GatewaySenderProfile sp = (GatewaySenderProfile) profile;
-                logger.debug("Sender {} is not the eldest in the system. Giving preference to eldest sender to become primary...", this.sender);
+                logger.debug(
+                    "Sender {} is not the eldest in the system. Giving preference to eldest sender to become primary...",
+                    this.sender);
-   * When the sender profile is removed, 
-   * then check for the primary members if they are not available then this secondary sender should volunteer for primary
+   * When the sender profile is removed, then check for the primary members if they are not
+   * available then this secondary sender should volunteer for primary
-      GatewaySenderProfile sp = (GatewaySenderProfile)profile;
+      GatewaySenderProfile sp = (GatewaySenderProfile) profile;
-    	//if there is a primary sender, then don't volunteer for primary 
+        // if there is a primary sender, then don't volunteer for primary
-        if (!this.sender.isPrimary()) {//IF this sender is not primary
-          if (!adviseEldestGatewaySender()) {//AND this is not the eldest sender 
-        	if (logger.isDebugEnabled()) {
-        	  logger.debug("Sender {} is not the eldest in the system. Giving preference to eldest sender to become primary...", this.sender);
-        	}
-        	return;
+        if (!this.sender.isPrimary()) {// IF this sender is not primary
+          if (!adviseEldestGatewaySender()) {// AND this is not the eldest sender
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  "Sender {} is not the eldest in the system. Giving preference to eldest sender to become primary...",
+                  this.sender);
+            }
+            return;
-  
+
-    InternalDistributedSystem ds = ((GemFireCacheImpl)this.sender.getCache())
-        .getDistributedSystem();
+    InternalDistributedSystem ds =
+        ((GemFireCacheImpl) this.sender.getCache()).getDistributedSystem();
-  
+
-        if (!adviseEldestGatewaySender()) {
-           	if (logger.isDebugEnabled()) {
-           	  logger.debug("Sender {} is not the eldest in the system. Giving preference to eldest sender to become primary...", this.sender);
-           	}
-           	return false;
+      if (!adviseEldestGatewaySender()) {
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "Sender {} is not the eldest in the system. Giving preference to eldest sender to become primary...",
+              this.sender);
+        return false;
+      }
-        logger.debug("Sender : {} no Primary available. So going to acquire distributed lock", this.sender);
+        logger.debug("Sender : {} no Primary available. So going to acquire distributed lock",
+            this.sender);
-   * Find out if this sender is the eldest in the DS. Returns true if: 1. No
-   * other sender is running 2. At least one sender is running in the system
-   * apart from this sender AND this sender's start time is lesser of all (i.e.
-   * this sender is oldest)
+   * Find out if this sender is the eldest in the DS. Returns true if: 1. No other sender is running
+   * 2. At least one sender is running in the system apart from this sender AND this sender's start
+   * time is lesser of all (i.e. this sender is oldest)
-      GatewaySenderProfile sp = (GatewaySenderProfile)profile;
+      GatewaySenderProfile sp = (GatewaySenderProfile) profile;
-        || (this.sender.isRunning() && (this.sender.startTime <= senderStartTimes
-            .first()));
+        || (this.sender.isRunning() && (this.sender.startTime <= senderStartTimes.first()));
-  
+
-      GatewaySenderProfile sp = (GatewaySenderProfile)profile;
+      GatewaySenderProfile sp = (GatewaySenderProfile) profile;
-  
+
-    logger.info(LocalizedMessage.create(LocalizedStrings.SerialGatewaySenderImpl_0__STARTING_AS_PRIMARY, this.sender));
+    logger.info(LocalizedMessage
+        .create(LocalizedStrings.SerialGatewaySenderImpl_0__STARTING_AS_PRIMARY, this.sender));
-    
+
-      logger.info(LocalizedMessage.create(LocalizedStrings.SerialGatewaySenderImpl_0__BECOMING_PRIMARY_GATEWAYSENDER, this.sender));
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.SerialGatewaySenderImpl_0__BECOMING_PRIMARY_GATEWAYSENDER, this.sender));
-  
+
-      logger.debug("{}: Did not obtain the lock on {}. Starting as secondary gateway sender.", this.sender, this.lockToken);
+      logger.debug("{}: Did not obtain the lock on {}. Starting as secondary gateway sender.",
+          this.sender, this.lockToken);
-  
+
-        GatewaySenderAdvisor.this.sender.getLifeCycleLock()
-                    .readLock().lock(); 
-          try {
-            // Attempt to obtain the lock
-            if (!(GatewaySenderAdvisor.this.sender
-                .isRunning())) {
-              return;
-            }
+        GatewaySenderAdvisor.this.sender.getLifeCycleLock().readLock().lock();
+        try {
+          // Attempt to obtain the lock
+          if (!(GatewaySenderAdvisor.this.sender.isRunning())) {
+            return;
+          }
+          if (logger.isDebugEnabled()) {
+            logger.debug("{}: Obtaining the lock on {}", this, GatewaySenderAdvisor.this.lockToken);
+          }
+
+          if (volunteerForPrimary()) {
-              logger.debug("{}: Obtaining the lock on {}", this, GatewaySenderAdvisor.this.lockToken);
+              logger.debug("{}: Obtained the lock on {}", this,
+                  GatewaySenderAdvisor.this.lockToken);
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.GatewaySender_0_IS_BECOMING_PRIMARY_GATEWAY_Sender,
+                GatewaySenderAdvisor.this));
-            if (volunteerForPrimary()) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("{}: Obtained the lock on {}", this, GatewaySenderAdvisor.this.lockToken);
-              }
-              logger.info(LocalizedMessage.create(LocalizedStrings.GatewaySender_0_IS_BECOMING_PRIMARY_GATEWAY_Sender,
-                  GatewaySenderAdvisor.this));
-
-              // As soon as the lock is obtained, set primary
-              GatewaySenderAdvisor.this.makePrimary();
-            }
+            // As soon as the lock is obtained, set primary
+            GatewaySenderAdvisor.this.makePrimary();
-          catch (CancelException e) {
-            // no action necessary
+        } catch (CancelException e) {
+          // no action necessary
+        } catch (Exception e) {
+          if (!sender.getStopper().isCancelInProgress()) {
+            logger.fatal(LocalizedMessage.create(
+                LocalizedStrings.GatewaySenderAdvisor_0_THE_THREAD_TO_OBTAIN_THE_FAILOVER_LOCK_WAS_INTERRUPTED__THIS_GATEWAY_SENDER_WILL_NEVER_BECOME_THE_PRIMARY,
+                GatewaySenderAdvisor.this), e);
-          catch (Exception e) {
-            if (!sender.getStopper().isCancelInProgress()) {
-              logger.fatal(LocalizedMessage.create(
-                  LocalizedStrings.GatewaySenderAdvisor_0_THE_THREAD_TO_OBTAIN_THE_FAILOVER_LOCK_WAS_INTERRUPTED__THIS_GATEWAY_SENDER_WILL_NEVER_BECOME_THE_PRIMARY,
-                  GatewaySenderAdvisor.this), e);
-            }
-          }
-          finally{
-            GatewaySenderAdvisor.this.sender.getLifeCycleLock()
-                          .readLock().unlock();
+        } finally {
+          GatewaySenderAdvisor.this.sender.getLifeCycleLock().readLock().unlock();
-  public void waitToBecomePrimary() throws InterruptedException
-  {
+  public void waitToBecomePrimary() throws InterruptedException {
-        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0__WAITING_TO_BECOME_PRIMARY_GATEWAY, this.sender.getId()));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.GatewayImpl_0__WAITING_TO_BECOME_PRIMARY_GATEWAY,
+            this.sender.getId()));
+
-    
+
-    
+
-     * I need this boolean to make sure the sender which is volunteer for primary is running. not running sender should not become primary. 
+     * I need this boolean to make sure the sender which is volunteer for primary is running. not
+     * running sender should not become primary.
-    
+
-    
+
-    
+
-    
-    public boolean isDiskSynchronous; 
-    
+
+    public boolean isDiskSynchronous;
+
-    
+
-    
+
-    
+
-    public GatewaySenderProfile() {
-    }
+    public GatewaySenderProfile() {}
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      if (InternalDataSerializer.getVersionForDataStream(in).compareTo(
-          Version.CURRENT) < 0) {
-        org.apache.geode.cache.util.Gateway.OrderPolicy oldOrderPolicy = DataSerializer
-            .readObject(in);
+      if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.CURRENT) < 0) {
+        org.apache.geode.cache.util.Gateway.OrderPolicy oldOrderPolicy =
+            DataSerializer.readObject(in);
-          }
-          else if (oldOrderPolicy.name().equals(OrderPolicy.THREAD.name())) {
+          } else if (oldOrderPolicy.name().equals(OrderPolicy.THREAD.name())) {
-          }
-          else {
+          } else {
-          }}
-        else {
+          }
+        } else {
-      }
-      else {
+      } else {
-          this.serverLocation = new ServerLocation();
-          InternalDataSerializer.invokeFromData(this.serverLocation, in);
+        this.serverLocation = new ServerLocation();
+        InternalDataSerializer.invokeFromData(this.serverLocation, in);
-      if (InternalDataSerializer.getVersionForDataStream(out).compareTo(
-          Version.CURRENT) < 0 && this.orderPolicy != null) {
+      if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.CURRENT) < 0
+          && this.orderPolicy != null) {
-          DataSerializer.writeObject(
-              org.apache.geode.cache.util.Gateway.OrderPolicy.KEY, out);
+          DataSerializer.writeObject(org.apache.geode.cache.util.Gateway.OrderPolicy.KEY, out);
+        } else if (orderPolicyName
+            .equals(org.apache.geode.cache.util.Gateway.OrderPolicy.THREAD.name())) {
+          DataSerializer.writeObject(org.apache.geode.cache.util.Gateway.OrderPolicy.THREAD, out);
+        } else {
+          DataSerializer.writeObject(org.apache.geode.cache.util.Gateway.OrderPolicy.PARTITION,
+              out);
-        else if(orderPolicyName.equals(org.apache.geode.cache.util.Gateway.OrderPolicy.THREAD.name())) {
-          DataSerializer.writeObject(
-              org.apache.geode.cache.util.Gateway.OrderPolicy.THREAD, out);
-        }else{
-          DataSerializer.writeObject(
-              org.apache.geode.cache.util.Gateway.OrderPolicy.PARTITION, out);
-        }
-      }
-      else {
+      } else {
-      if(serverLocationFound) {
+      if (serverLocationFound) {
-    public void fromDataPre_GFE_8_0_0_0(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromDataPre_GFE_8_0_0_0(DataInput in) throws IOException, ClassNotFoundException {
-          this.serverLocation = new ServerLocation();
-          InternalDataSerializer.invokeFromData(this.serverLocation, in);
+        this.serverLocation = new ServerLocation();
+        InternalDataSerializer.invokeFromData(this.serverLocation, in);
-      //out.writeInt(dispatcherThreads);
-      if(isParallel)
-        out.writeInt(1);//it was 1 on previous version of gemfire
+      // out.writeInt(dispatcherThreads);
+      if (isParallel)
+        out.writeInt(1);// it was 1 on previous version of gemfire
-        out.writeInt(1);//it was 1 on previous version of gemfire
+        out.writeInt(1);// it was 1 on previous version of gemfire
-      if(isParallel)
+      if (isParallel)
-      
+
-      if(serverLocationFound) {
+      if (serverLocationFound) {
-    
-    private final static Version[] serializationVersions = new Version[] {Version.GFE_80}; 
-    
+
+    private final static Version[] serializationVersions = new Version[] {Version.GFE_80};
+
-    
+
-    public void processIncoming(DistributionManager dm, String adviseePath,
-        boolean removeProfile, boolean exchangeProfiles,
-        final List<Profile> replyProfiles) {
+    public void processIncoming(DistributionManager dm, String adviseePath, boolean removeProfile,
+        boolean exchangeProfiles, final List<Profile> replyProfiles) {
-        AbstractGatewaySender sender = (AbstractGatewaySender)((GemFireCacheImpl)cache)
-            .getGatewaySender(adviseePath);
-        handleDistributionAdvisee(sender, removeProfile, exchangeProfiles,
-            replyProfiles);
+        AbstractGatewaySender sender =
+            (AbstractGatewaySender) ((GemFireCacheImpl) cache).getGatewaySender(adviseePath);
+        handleDistributionAdvisee(sender, removeProfile, exchangeProfiles, replyProfiles);
-    
+
-      
+
-      GatewaySenderProfile sp = (GatewaySenderProfile)profile;
+      GatewaySenderProfile sp = (GatewaySenderProfile) profile;
-  
+
-  
+

GEODE-6580: Cleanup static analyzer warnings. (#3432)


+
-import java.io.EOFException;
-import java.net.ConnectException;
-  private final ThreadLocal<Boolean> serverAffinity = new ThreadLocal<Boolean>() {
-    @Override
-    protected Boolean initialValue() {
-      return Boolean.FALSE;
-    };
-  };
+  private final ThreadLocal<Boolean> serverAffinity = ThreadLocal.withInitial(() -> Boolean.FALSE);
-  private final ThreadLocal<ServerLocation> affinityServerLocation =
-      new ThreadLocal<ServerLocation>();
+  private final ThreadLocal<ServerLocation> affinityServerLocation = new ThreadLocal<>();
-  private final ThreadLocal<Integer> affinityRetryCount = new ThreadLocal<Integer>() {
-    @Override
-    protected Integer initialValue() {
-      return 0;
-    };
-  };
+  private final ThreadLocal<Integer> affinityRetryCount = ThreadLocal.withInitial(() -> 0);
-  public OpExecutorImpl(ConnectionManager manager, QueueManager queueManager,
+  public OpExecutorImpl(ConnectionManager connectionManager, QueueManager queueManager,
-    this.connectionManager = manager;
+    this.connectionManager = connectionManager;
-    if (this.serverAffinity.get()) {
-      ServerLocation loc = this.affinityServerLocation.get();
+    if (serverAffinity.get()) {
+      ServerLocation loc = affinityServerLocation.get();
-        this.affinityServerLocation.set(loc);
+        affinityServerLocation.set(loc);
-          logger.debug("setting server affinity to {}", this.affinityServerLocation.get());
+          logger.debug("setting server affinity to {}", affinityServerLocation.get());
-    boolean success = false;
-          Object result = executeWithPossibleReAuthentication(conn, op);
-          success = true;
-          return result;
+          return executeWithPossibleReAuthentication(conn, op);
-        if (!this.serverAffinityFailover || e instanceof ServerOperationException) {
+        if (!serverAffinityFailover || e instanceof ServerOperationException) {
-      this.affinityServerLocation.set(null);
+      affinityServerLocation.set(null);
-      TXFailoverOp.execute(this.pool, transactionId);
+      TXFailoverOp.execute(pool, transactionId);
-        op = new ExecuteRegionFunctionOpImpl((ExecuteRegionFunctionOpImpl) op,
-            (byte) 1/* isReExecute */, new HashSet<String>());
+        op = new ExecuteRegionFunctionOpImpl((ExecuteRegionFunctionOpImpl) op, (byte) 1,
+            new HashSet<>());
-      return this.pool.execute(op);
+      return pool.execute(op);
-    this.serverAffinityFailover = allowFailover;
-    this.serverAffinity.set(Boolean.TRUE);
+    serverAffinityFailover = allowFailover;
+    serverAffinity.set(Boolean.TRUE);
-    this.serverAffinity.set(Boolean.FALSE);
-    this.affinityServerLocation.set(null);
+    serverAffinity.set(Boolean.FALSE);
+    affinityServerLocation.set(null);
-    return this.affinityServerLocation.get();
+    return affinityServerLocation.get();
-    assert this.affinityServerLocation.get() == null;
-    this.affinityServerLocation.set(serverLocation);
+    assert affinityServerLocation.get() == null;
+    affinityServerLocation.set(serverLocation);
-      this.connectionManager.returnConnection(conn);
+      connectionManager.returnConnection(conn);
-    if (this.serverAffinity.get()) {
-      ServerLocation affinityserver = this.affinityServerLocation.get();
+    if (serverAffinity.get()) {
+      ServerLocation affinityserver = affinityServerLocation.get();
-        this.affinityServerLocation.set(server);
+        affinityServerLocation.set(server);
-    ServerLocation server = p_server;
-      if (this.queueManager != null) {
+      if (queueManager != null) {
-        Endpoint ep = (Endpoint) this.endpointManager.getEndpointMap().get(server);
+        Endpoint ep = endpointManager.getEndpointMap().get(p_server);
-          QueueConnections qcs = this.queueManager.getAllConnectionsNoWait();
+          QueueConnections qcs = queueManager.getAllConnectionsNoWait();
-      conn = connectionManager.borrowConnection(server, serverTimeout, onlyUseExistingCnx);
+      conn = connectionManager.borrowConnection(p_server, serverTimeout, onlyUseExistingCnx);
-    boolean success = true;
-      success = false;
-      if (this.serverAffinity.get() && this.affinityServerLocation.get() == null) {
+      if (serverAffinity.get() && affinityServerLocation.get() == null) {
-        this.affinityServerLocation.set(conn.getServer());
+        affinityServerLocation.set(conn.getServer());
-    HashSet attemptedPrimaries = new HashSet();
+    HashSet<ServerLocation> attemptedPrimaries = new HashSet<>();
-    List backups = connections.getBackups();
-    for (int i = 0; i < backups.size(); i++) {
-      Connection conn = (Connection) backups.get(i);
+    List<Connection> backups = connections.getBackups();
+    for (Connection conn : backups) {
-    HashSet attemptedPrimaries = new HashSet();
+    HashSet<ServerLocation> attemptedPrimaries = new HashSet<>();
-      if ((t instanceof ConnectException) || (t instanceof SocketException)
-          || (t instanceof SocketTimeoutException) || (t instanceof IOException)
+      if ((t instanceof IOException)
-        final StringBuffer sb = getExceptionMessage(title, retryCount, finalAttempt, conn, e);
+        final StringBuffer sb = getExceptionMessage(title, retryCount, finalAttempt, conn);
-      boolean finalAttempt, Connection connection, Throwable ex) {
+      boolean finalAttempt, Connection connection) {
-    if (this.pool == null) {
+    if (pool == null) {
-          (PoolImpl) PoolManagerImpl.getPMI().find(this.endpointManager.getPoolName());
+          (PoolImpl) PoolManagerImpl.getPMI().find(endpointManager.getPoolName());
-      this.pool = poolImpl;
+      pool = poolImpl;
-    if (this.pool.getMultiuserAuthentication()) {
+    if (pool.getMultiuserAuthentication()) {
-            authenticateMultiuser(this.pool, conn, ua);
+            authenticateMultiuser(pool, conn, ua);
-        } else {
-          // This should never be reached.
-        conn.getServer().setUserId((Long) AuthenticateUserOp.executeOn(connImpl, this.pool));
+        conn.getServer().setUserId((Long) AuthenticateUserOp.executeOn(connImpl, pool));
-      if (cause instanceof SocketException || cause instanceof EOFException
-          || cause instanceof IOException || cause instanceof BufferUnderflowException
+      if (cause instanceof IOException || cause instanceof BufferUnderflowException
-              && (sce.getMessage().indexOf("Could not create a new connection to server") != -1
-                  || sce.getMessage().indexOf("socket timed out on client") != -1
-                  || sce.getMessage().indexOf("connection was asynchronously destroyed") != -1))) {
+              && (sce.getMessage().contains("Could not create a new connection to server")
+                  || sce.getMessage().contains("socket timed out on client")
+                  || sce.getMessage().contains("connection was asynchronously destroyed")))) {
-            (PoolImpl) PoolManagerImpl.getPMI().find(this.endpointManager.getPoolName());
+            (PoolImpl) PoolManagerImpl.getPMI().find(endpointManager.getPoolName());

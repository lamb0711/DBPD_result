enabling multicast communications and fixing a locator auto-restart problem.
This disables the use of multicast for discovery and all tests that were
doing that have been changed to use locators.

+import static com.gemstone.gemfire.internal.DataSerializableFixedID.JOIN_RESPONSE;
+import org.jgroups.util.Digest;
-      // TODO multicast-specific settings
+      properties = replaceStrings(properties, "MCAST_PORT", String.valueOf(transport.getMcastId().getPort()));
+      properties = replaceStrings(properties, "MCAST_ADDRESS", transport.getMcastId().getHost().getHostAddress());
+      properties = replaceStrings(properties, "MCAST_TTL", String.valueOf(dc.getMcastTtl()));
+      properties = replaceStrings(properties, "MCAST_SEND_BUFFER_SIZE", String.valueOf(dc.getMcastSendBufferSize()));
+      properties = replaceStrings(properties, "MCAST_RECV_BUFFER_SIZE", String.valueOf(dc.getMcastRecvBufferSize()));
+      properties = replaceStrings(properties, "MCAST_RETRANSMIT_INTERVAL", ""+Integer.getInteger("gemfire.mcast-retransmit-interval", 500));
+      properties = replaceStrings(properties, "RETRANSMIT_LIMIT", String.valueOf(dc.getUdpFragmentSize()-256));
+    
+    properties = replaceStrings(properties, "FC_MAX_CREDITS", ""+dc.getMcastFlowControl().getByteAllowance());
+    properties = replaceStrings(properties, "FC_THRESHOLD", ""+dc.getMcastFlowControl().getRechargeThreshold());
+    properties = replaceStrings(properties, "FC_MAX_BLOCK", ""+dc.getMcastFlowControl().getRechargeBlockMs());
+    logger.debug("JGroups configuration: {}", properties);
+    
+    long start = System.currentTimeMillis();
+    
-      throw new SystemConnectException("unable to create jgroups channel", e);
+      throw new GemFireConfigException("unable to create jgroups channel", e);
-    try {
-      logger.info("Messenger established the local identity as {} localHost is {}", localAddress, SocketCreator.getLocalHost());
-    } catch (UnknownHostException e) {
-      
-    }
+    logger.info("JGroups channel created (took {}ms)", System.currentTimeMillis()-start);
+    
-    filterMessage(msg);
+    filterOutgoingMessage(msg);
-    logger.debug("Membership: sending message via JGroups: {} recipients: {}", msg, msg.getRecipientsDescription());
+    if (logger.isDebugEnabled()) {
+      logger.debug("JGroupsMessenger sending [{}] recipients: {}", msg, msg.getRecipientsDescription());
+    }
-        logger.trace("Membership: sending message via multicast");
+        logger.trace("This message is being multicast");
-        Int2ObjectOpenHashMap messages = new Int2ObjectOpenHashMap();
+        Int2ObjectOpenHashMap<Message> messages = new Int2ObjectOpenHashMap<>();
-        for (Iterator it=calculatedMembers.iterator(); it.hasNext(); ) {
-          GMSMember mbr = (GMSMember)it.next();
+        for (Iterator<GMSMember> it=calculatedMembers.iterator(); it.hasNext(); ) {
+          GMSMember mbr = it.next();
-        for (Iterator<GMSMember> it=calculatedMembers.iterator();
-          it.hasNext(); i++) { // send individually
-          GMSMember mbr = it.next();
+        for (GMSMember mbr: calculatedMembers) {
-            if (logger.isDebugEnabled())
-              logger.debug("Membership: Sending {} to '{}' via udp unicast", tmp, mbr);
+            if (logger.isTraceEnabled())
+              logger.trace("Unicasting to {}", to);
+    if (gfmsg instanceof DistributedCacheOperation.CacheOperationMessage) {
+      // we don't want to see our own cache operation messages
+      msg.setTransientFlag(Message.TransientFlag.DONT_LOOPBACK);
+    }
-    if (logger.isDebugEnabled()) {
-      logger.debug("deserializing a message of length "+messageLength);
+    if (logger.isTraceEnabled()) {
+      logger.trace("deserializing a message of length "+messageLength);
-      logger.debug("Message length is zero - ignoring");
+      logger.trace("message length is zero - ignoring");
-  private void filterMessage(DistributionMessage m) {
-    if (m instanceof JoinResponseMessage) {
-      // TODO: for mcast does the new JGroups need to have the NAKACK digest transmitted
-      // to new members at join-time?  The old JGroups needs this and it would require us to
-      // install an uphandler for JChannel to handle GET_DIGEST_OK events.
-      // I (bruce) am postponing looking into this until we move to the new version of jgroups.
+  private void filterOutgoingMessage(DistributionMessage m) {
+    switch (m.getDSFID()) {
+    case JOIN_RESPONSE:
+      JoinResponseMessage jrsp = (JoinResponseMessage)m;
+      
+      if (jrsp.getRejectionMessage() != null
+          &&  services.getConfig().getTransport().isMcastEnabled()) {
+        // get the multicast message digest and pass it with the join response
+        Digest digest = (Digest)this.myChannel.getProtocolStack()
+            .getTopProtocol().down(Event.GET_DIGEST_EVT);
+        jrsp.setMessengerData(digest);
+      }
+      break;
+    default:
+      break;
+    }
+  }
+  
+  private void filterIncomingMessage(DistributionMessage m) {
+    switch (m.getDSFID()) {
+    case JOIN_RESPONSE:
+      JoinResponseMessage jrsp = (JoinResponseMessage)m;
+      
+      if (jrsp.getRejectionMessage() != null
+          &&  services.getConfig().getTransport().isMcastEnabled()) {
+        Digest digest = (Digest)jrsp.getMessengerData();
+        if (digest != null) {
+          this.myChannel.getProtocolStack()
+              .getTopProtocol().down(new Event(Event.SET_DIGEST, digest));
+        }
+      }
+      break;
+    default:
+      break;
-      logger.debug("JGroupsReceiver received {} headers: {}", jgmsg, jgmsg.getHeaders());
+      if (logger.isDebugEnabled()) {
+        logger.debug("JGroupsMessenger received {} headers: {}", jgmsg, jgmsg.getHeaders());
+      }
+        filterIncomingMessage(msg);
-        logger.debug("Handler for this message is {}", h);
+        logger.trace("Handler for this message is {}", h);

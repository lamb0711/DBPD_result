GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.cache.*;
+import org.apache.geode.cache.CacheClosedException;
+import org.apache.geode.cache.CacheEvent;
+import org.apache.geode.cache.CacheListener;
+import org.apache.geode.cache.CacheLoader;
+import org.apache.geode.cache.CacheLoaderException;
+import org.apache.geode.cache.CacheWriter;
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.DiskAccessException;
+import org.apache.geode.cache.EntryNotFoundException;
+import org.apache.geode.cache.LossAction;
+import org.apache.geode.cache.MembershipAttributes;
+import org.apache.geode.cache.Operation;
+import org.apache.geode.cache.RegionAccessException;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.RegionDestroyedException;
+import org.apache.geode.cache.RegionDistributionException;
+import org.apache.geode.cache.RegionMembershipListener;
+import org.apache.geode.cache.ResumptionAction;
+import org.apache.geode.cache.RoleException;
+import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.distributed.internal.*;
+import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionAdvisee;
+import org.apache.geode.distributed.internal.DistributionAdvisor;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.MembershipListener;
+import org.apache.geode.distributed.internal.ReplyProcessor21;
-import org.apache.geode.internal.cache.execute.*;
+import org.apache.geode.internal.cache.execute.DistributedRegionFunctionExecutor;
+import org.apache.geode.internal.cache.execute.DistributedRegionFunctionResultSender;
+import org.apache.geode.internal.cache.execute.DistributedRegionFunctionResultWaiter;
+import org.apache.geode.internal.cache.execute.FunctionStats;
+import org.apache.geode.internal.cache.execute.LocalResultCollector;
+import org.apache.geode.internal.cache.execute.RegionFunctionContextImpl;
+import org.apache.geode.internal.cache.execute.ServerToClientFunctionResultSender;
-import org.apache.geode.internal.cache.persistence.*;
+import org.apache.geode.internal.cache.partitioned.Bucket;
+import org.apache.geode.internal.cache.persistence.CreatePersistentRegionProcessor;
+import org.apache.geode.internal.cache.persistence.PersistenceAdvisor;
+import org.apache.geode.internal.cache.persistence.PersistenceAdvisorImpl;
+import org.apache.geode.internal.cache.persistence.PersistentMemberID;
+import org.apache.geode.internal.cache.persistence.PersistentMemberManager;
+import org.apache.geode.internal.cache.persistence.PersistentMemberView;
-import org.apache.logging.log4j.Logger;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.*;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-
-/**
- * 
- */
-   * @guarded.By {@link #dlockMonitor}
+   * GuardedBy {@link #dlockMonitor}
-  protected final AdvisorListener advisorListener = new AdvisorListener();
+  final AdvisorListener advisorListener = new AdvisorListener();
-  protected final HashSet missingRequiredRoles = new HashSet();
+  final HashSet missingRequiredRoles = new HashSet(); // package-private to avoid synthetic accessor
-  protected volatile boolean isMissingRequiredRoles = false;
+  private volatile boolean isMissingRequiredRoles = false;
-  protected final StoppableCountDownLatch initializationLatchAfterMemberTimeout;
+  private final StoppableCountDownLatch initializationLatchAfterMemberTimeout;
-  private static AtomicBoolean loggedNetworkPartitionWarning = new AtomicBoolean(false);
+  private static final AtomicBoolean loggedNetworkPartitionWarning = new AtomicBoolean(false);
-      GemFireCacheImpl cache, InternalRegionArguments internalRegionArgs) {
+      InternalCache cache, InternalRegionArguments internalRegionArgs) {
-    } else if (this.allowsPersistence()) {
-      // TODO prpersist - using this lock service is a hack. Maybe? Or maybe
+    } else if (allowsPersistence()) {
+      // TODO: prpersist - using this lock service is a hack. Maybe? Or maybe
-        // TODO prpersist - this is just a quick and dirty storage mechanism so that
+        // TODO: prpersist - this is just a quick and dirty storage mechanism so that
-        this.persistenceAdvisor = new PersistenceAdvisorImpl(distAdvisor, dl, storage,
+        this.persistenceAdvisor = new PersistenceAdvisorImpl(this.distAdvisor, dl, storage,
-      } catch (Exception e) {
+      } catch (Exception ignore) {
-      this.persistentId = persistenceAdvisor.generatePersistentID();
+      this.persistentId = this.persistenceAdvisor.generatePersistentID();
-
-    return CacheDistributionAdvisor.createCacheDistributionAdvisor(this); // Warning: potential
-                                                                          // early escape of object
-                                                                          // before full
-                                                                          // construction
+    // Warning: potential early escape of object before full construction
+    return CacheDistributionAdvisor.createCacheDistributionAdvisor(this);
-    return this.concurrencyChecksEnabled && (this.srp == null) && !isTX()
+    return this.concurrencyChecksEnabled && (this.serverRegionProxy == null) && !isTX()
-  /**
-   * @see LocalRegion#virtualPut(EntryEventImpl, boolean, boolean, Object, boolean, long, boolean)
-   */
-        !event.isLocalLoad() && !event.isSingleHopPutOp()) { // Single Hop Op means dlock is already
-                                                             // taken at origin node.
+        !event.isLocalLoad() && !event.isSingleHopPutOp()) {
+      // Single Hop Op means dlock is already taken at origin node.
-        // Gester, Fix 39014: when hasSeenEvent, put will still distribute
+        // Fix 39014: when hasSeenEvent, put will still distribute
-        // LR.basicPutPart3 in purpose. Reviewed by Bruce.
+        // LR.basicPutPart3 in purpose.
-      // getSharedDataView().destroyExistingEntry(event, true, null);
-  protected void setGeneratedVersionTag(boolean generateVersionTag) {
+  void setGeneratedVersionTag(boolean generateVersionTag) {
-    if (this.srp != null) { // client
+    if (this.serverRegionProxy != null) { // client
-                  .toLocalizedString(
-                      new Object[] {getMembershipAttributes().getLossAction(), roles}),
+                  .toLocalizedString(getMembershipAttributes().getLossAction(), roles),
-                  .toLocalizedString(
-                      new Object[] {getMembershipAttributes().getLossAction(), roles}),
+                  .toLocalizedString(getMembershipAttributes().getLossAction(), roles),
-    handleReliableDistribution(successfulRecipients, Collections.EMPTY_SET, Collections.EMPTY_SET);
+    handleReliableDistribution(successfulRecipients, Collections.emptySet(),
+        Collections.emptySet());
-  protected void handleReliableDistribution(Set successfulRecipients, Set otherRecipients1,
+  private void handleReliableDistribution(Set successfulRecipients, Set otherRecipients1,
-      Set recipients = successfulRecipients;
-      for (Iterator iter = recipients.iterator(); iter.hasNext();) {
-        InternalDistributedMember mbr = (InternalDistributedMember) iter.next();
+      for (Object successfulRecipient : successfulRecipients) {
+        InternalDistributedMember mbr = (InternalDistributedMember) successfulRecipient;
-      for (Iterator iter = otherRecipients1.iterator(); iter.hasNext();) {
-        InternalDistributedMember mbr = (InternalDistributedMember) iter.next();
+      for (Object anOtherRecipients1 : otherRecipients1) {
+        InternalDistributedMember mbr = (InternalDistributedMember) anOtherRecipients1;
-      for (Iterator iter = otherRecipients2.iterator(); iter.hasNext();) {
-        InternalDistributedMember mbr = (InternalDistributedMember) iter.next();
+      for (Object anOtherRecipients2 : otherRecipients2) {
+        InternalDistributedMember mbr = (InternalDistributedMember) anOtherRecipients2;
-      if (failedRoles.isEmpty())
+      if (failedRoles.isEmpty()) {
-      // if (rp.isAllAccessWithQueuing()) {
-      // this.rmq.add(data, failedRoles);
-      // } else {
+      }
-      // }
-   * 
-  protected boolean isNoDistributionOk() {
+  boolean isNoDistributionOk() {
-      // if (ra.getLossAction().isAllAccessWithQueuing()) {
-      // return !ra.hasRequiredRoles();
-      // } else {
-      Set failedRoles = ra.getRequiredRoles();
+      Set<Role> failedRoles = ra.getRequiredRoles();
-      // }
-
-
-  /**
-   * Adjust the specified set of recipients by removing any of them that are currently having their
-   * data queued.
-   * 
-   * @param recipients the set of recipients that a message is to be distributed too. Recipients
-   *        that are currently having their data queued will be removed from this set.
-   * @return the set, possibly null, of recipients that are currently having their data queued.
-   * @since GemFire 5.0
-   */
-  protected Set adjustForQueuing(Set recipients) {
-    Set result = null;
-    // if (this.requiresReliabilityCheck) {
-    // MembershipAttributes ra = getMembershipAttributes();
-    // if (ra.getLossAction().isAllAccessWithQueuing()) {
-    // Set currentQueuedRoles = this.rmq.getQueuingRoles();
-    // if (currentQueuedRoles != null) {
-    // // foreach recipient see if any of his roles are queued and if
-    // // they are remove him from recipients and add him to result
-    // Iterator it = recipients.iterator();
-    // while (it.hasNext()) {
-    // DistributedMember dm = (DistributedMember)it.next();
-    // Set dmRoles = dm.getRoles();
-    // if (!dmRoles.isEmpty()) {
-    // if (intersects(dmRoles, currentQueuedRoles)) {
-    // it.remove(); // fix for bug 34447
-    // if (result == null) {
-    // result = new HashSet();
-    // }
-    // result.add(dm);
-    // }
-    // }
-    // }
-    // }
-    // }
-    // }
-    return result;
-  }
-
-  /**
-   * Returns true if the two sets intersect
-   * 
-   * @param a a non-null non-empty set
-   * @param b a non-null non-empty set
-   * @return true if sets a and b intersect; false if not
-   * @since GemFire 5.0
-   */
-  public static boolean intersects(Set a, Set b) {
-    Iterator it;
-    Set target;
-    if (a.size() <= b.size()) {
-      it = a.iterator();
-      target = b;
-    } else {
-      it = b.iterator();
-      target = a;
-    }
-    while (it.hasNext()) {
-      if (target.contains(it.next()))
-        return true;
-    }
-    return false;
-  }
-
-  protected boolean resumeReliability(InternalDistributedMember id, Set newlyAcquiredRoles) {
+  private boolean resumeReliability(InternalDistributedMember id, Set newlyAcquiredRoles) {
+      @Override
-  protected boolean lostReliability(final InternalDistributedMember id,
-      final Set newlyMissingRoles) {
+  private boolean lostReliability(final InternalDistributedMember id, final Set newlyMissingRoles) {
-        if (isInitializingThread) {
+        if (this.isInitializingThread) {
-        /*
-         * moved to a new method called doLostReliablity. Thread t = new
-         * Thread("Reconnect Distributed System") { public void run() { try { // TODO: may need to
-         * check isReconnecting and checkReadiness... initializationLatchAfterMemberTimeout.await();
-         * // TODO: call reconnect here getSystem().tryReconnect((GemFireCache)getCache()); // added
-         * for reconnect. synchronized (missingRequiredRoles) { // any number of threads may be
-         * waiting on missingRequiredRoles missingRequiredRoles.notifyAll(); // need to fire an
-         * event if id is not null if (hasListener() && id != null) { RoleEventImpl relEvent = new
-         * RoleEventImpl( DistributedRegion.this, Operation.CACHE_RECONNECT, null, true, id,
-         * newlyMissingRoles); dispatchListenerEvent( EnumListenerEvent.AFTER_ROLE_LOSS, relEvent);
-         * } } } catch (Exception e) { } } }; t.setDaemon(true); t.start();
-         */
-        Thread t = new Thread(
+        Thread thread = new Thread(
-        t.setDaemon(true);
-        t.start();
+        thread.setDaemon(true);
+        thread.start();
-        synchronized (missingRequiredRoles) {
+        synchronized (this.missingRequiredRoles) {
-          missingRequiredRoles.notifyAll();
+          this.missingRequiredRoles.notifyAll();
-        // } catch (CancelException cce){
-
-        // }
-
-
-  protected void lockCheckReadiness() {
+  void lockCheckReadiness() { // package-private to avoid synthetic accessor
-    cache.getCancelCriterion().checkCancelInProgress(null);
+    this.cache.getCancelCriterion().checkCancelInProgress(null);
-  /**
-   * @see LocalRegion#localDestroyNoCallbacks(Object)
-   */
-  /**
-   * @see LocalRegion#localDestroy(Object, Object)
-   */
-  /**
-   * @see LocalRegion#invalidate(Object, Object)
-   */
-      super.validatedInvalidate(key, aCallbackArgument);
+      validatedInvalidate(key, aCallbackArgument);
-   * 
-   * @see LocalRegion#initialize(InputStream, InternalDistributedMember, InternalRegionArguments)
-        PersistentMemberID persistentId = null;
+        PersistentMemberID persistentMemberId = null;
-          persistentId = dskRgn.getMyPersistentID();
+          persistentMemberId = dskRgn.getMyPersistentID();
-              recoverFromDisk, persistentId);
+              recoverFromDisk, persistentMemberId);
-      isInitializingThread = false;
-      super.initialize(null, null, null); // makes sure all latches are released if they haven't
-                                          // been already
+      this.isInitializingThread = false;
+      // makes sure all latches are released if they haven't been already
+      super.initialize(null, null, null);
-  private final Set<DistributedMember> memoryThresholdReachedMembers =
-      new CopyOnWriteArraySet<DistributedMember>();
+  private final Set<DistributedMember> memoryThresholdReachedMembers = new CopyOnWriteArraySet<>();
-  /** Sets and returns giiMissingRequiredRoles */
-  private boolean checkInitialImageForReliability(InternalDistributedMember imageTarget,
-      CacheDistributionAdvisor.InitialImageAdvice advice) {
-    // assumption: required roles are interesting to GII only if Reinitialize...
-    // if (true)
-    return false;
-    // if (getMembershipAttributes().hasRequiredRoles()
-    // && getMembershipAttributes().getResumptionAction().isReinitialize()) {
-    // // are any required roles missing for GII with Reinitialize?
-    // Set missingRR = new HashSet(getMembershipAttributes().getRequiredRoles());
-    // missingRR.removeAll(getSystem().getDistributedMember().getRoles());
-    // for (Iterator iter = advice.replicates.iterator(); iter.hasNext();) {
-    // DistributedMember member = (DistributedMember)iter.next();
-    // missingRR.removeAll(member.getRoles());
-    // }
-    // for (Iterator iter = advice.others.iterator(); iter.hasNext();) {
-    // DistributedMember member = (DistributedMember)iter.next();
-    // missingRR.removeAll(member.getRoles());
-    // }
-    // for (Iterator iter = advice.preloaded.iterator(); iter.hasNext();) {
-    // DistributedMember member = (DistributedMember)iter.next();
-    // missingRR.removeAll(member.getRoles());
-    // }
-    // if (!missingRR.isEmpty()) {
-    // // entering immediate loss condition, which will cause reinit on resume
-    // this.giiMissingRequiredRoles = true;
-    // }
-    // }
-    // return this.giiMissingRequiredRoles;
-  }
-
+  // TODO: cleanup getInitialImageAndRecovery
-    boolean isForConversion = isCBool != null ? isCBool.booleanValue() : false;
+    boolean isForConversion = isCBool != null ? isCBool : false;
-              .toLocalizedString(
-                  new Object[] {Boolean.valueOf(recoverFromDisk), snapshotInputStream}));
+              .toLocalizedString(new Object[] {true, snapshotInputStream}));
-    if (dataPolicy.withPersistence()) {
+    if (this.dataPolicy.withPersistence()) {
-    if (dataPolicy.withPersistence()) {
-      recovered_rvv = (this.getVersionVector() == null ? null
-          : this.getVersionVector().getCloneForTransmission());
+    if (this.dataPolicy.withPersistence()) {
+      recovered_rvv = this.getVersionVector() == null ? null
+          : this.getVersionVector().getCloneForTransmission();
-    if (persistenceAdvisor != null) {
-      persistenceAdvisor.initialize();
+    if (this.persistenceAdvisor != null) {
+      this.persistenceAdvisor.initialize();
-        cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
+        this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
-        throw new RuntimeException(e); // @todo change this exception?
+        throw new RuntimeException(e); // TODO: change this exception?
-        throw new RuntimeException(e); // @todo change this exception?
+        throw new RuntimeException(e); // TODO: change this exception?
-    // [defunct] Special case GII for PR admin regions (which are always
-    // replicates and always writers
-    // bruce: this was commented out after adding the GIIAckRequest logic to
-    // force
-    // consistency before the gii operation begins
-    // if (isUsedForPartitionedRegionAdmin() ||
-    // isUsedForPartitionedRegionBucket()) {
-    // releaseBeforeGetInitialImageLatch();
-    // iiop.getFromAll(this.distAdvisor.adviseGeneric(), false);
-    // cleanUpDestroyedTokens();
-    // return;
-    // }
-
-      checkInitialImageForReliability(imageSrc, advice);
-          /*
-           * no more union GII // do union getInitialImage Set rest = new HashSet();
-           * rest.addAll(advice.others); rest.addAll(advice.preloaded); // push profile w/ recovery
-           * flag turned off at same time that we // do a union getInitialImage boolean pushProfile
-           * = recoverFromDisk; iiop.getFromAll(rest, pushProfile);
-           */
-
-    return;
-  }
-
-  private void synchronizeWith(InternalDistributedMember target, VersionSource idToRecover) {
-    InitialImageOperation op = new InitialImageOperation(this, this.entries);
-    op.synchronizeWith(target, idToRecover, null);
-    if (this.concurrencyChecksEnabled == false) {
+    if (!this.concurrencyChecksEnabled) {
-  /**
-   * invoked just before an initial image is requested from another member
-   */
-  protected void cleanUpAfterFailedGII(boolean recoverFromDisk) {
+  void cleanUpAfterFailedGII(boolean recoverFromDisk) {
-          for (Iterator iter = others.iterator(); iter.hasNext();) {
-            DistributedMember other = (DistributedMember) iter.next();
+          for (Object other1 : others) {
+            DistributedMember other = (DistributedMember) other1;
-          isInitializingThread = true;
+          this.isInitializingThread = true;
-              isInitializingThread = true;
+              this.isInitializingThread = true;
-                  advisorListener.destroyed = true;
+                  this.advisorListener.destroyed = true;
-                isInitializingThread = true;
+                this.isInitializingThread = true;
-      } catch (CancelException ignore) {
+      } catch (CancelException e) {
-        if (isInitializingThread) {
-          throw ignore;
+        if (this.isInitializingThread) {
+          throw e;
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "UL_UNRELEASED_LOCK")
+  @SuppressWarnings("UL_UNRELEASED_LOCK")
-      if (persistenceAdvisor != null) {
-        persistenceAdvisor.setOnline(GIIStatus.didGII(giiStatus), false, getPersistentID());
+      if (this.persistenceAdvisor != null) {
+        this.persistenceAdvisor.setOnline(GIIStatus.didGII(giiStatus), false, getPersistentID());
-  /**
-   * @see LocalRegion#basicDestroy(EntryEventImpl, boolean, Object)
-   */
-    boolean invokeWriter = cacheWrite;
+      boolean invokeWriter = cacheWrite;
-          if (this.srp == null) {
+          if (this.serverRegionProxy == null) {
-      return;
-
-  /**
-   * @see LocalRegion#basicInvalidateRegion(RegionEventImpl)
-   */
-   * @param event
-  /**
-   * @see LocalRegion#basicDestroyRegion(RegionEventImpl, boolean, boolean, boolean)
-   */
-      cache.beginDestroy(path, this);
+      this.cache.beginDestroy(path, this);
-        cache.endDestroy(path, this);
+        this.cache.endDestroy(path, this);
-
-    if (persistenceAdvisor != null) {
-      persistenceAdvisor.releaseTieLock();
+    if (this.persistenceAdvisor != null) {
+      this.persistenceAdvisor.releaseTieLock();
-   * 
-   * @see LocalRegion#basicInvalidate(EntryEventImpl)
-
+
-          if (this.srp == null) {
+          if (this.serverRegionProxy == null) {
-      return;
-    LocalRegion lr = event.getLocalRegion();
-    AbstractRegionMap arm = ((AbstractRegionMap) lr.getRegionMap());
+    LocalRegion localRegion = event.getLocalRegion();
+    AbstractRegionMap regionMap = (AbstractRegionMap) localRegion.getRegionMap();
-      arm.lockForCacheModification(lr, event);
+      regionMap.lockForCacheModification(localRegion, event);
-        return;
-      arm.releaseCacheModificationLock(lr, event);
+      regionMap.releaseCacheModificationLock(localRegion, event);
-  protected void distributeUpdateEntryVersion(EntryEventImpl event) {
+  void distributeUpdateEntryVersion(EntryEventImpl event) {
-  protected void basicClear(RegionEventImpl ev) {
+  protected void basicClear(RegionEventImpl regionEvent) {
-      super.basicClear(ev);
+      super.basicClear(regionEvent);
-        if (repls.size() > 0) {
+        if (!repls.isEmpty()) {
-    synchronized (clearLock) {
+    synchronized (this.clearLock) {
-   * 
-   * @param participants
-   **/
+   */
-  public void lockLocallyForClear(DM dm, InternalDistributedMember locker, CacheEvent event) {
+  void lockLocallyForClear(DM dm, InternalDistributedMember locker, CacheEvent event) {
-    ARMLockTestHook alth = getRegionMap().getARMLockTestHook();
-    if (alth != null)
-      alth.beforeLock(this, event);
+    ARMLockTestHook armLockTestHook = getRegionMap().getARMLockTestHook();
+    if (armLockTestHook != null) {
+      armLockTestHook.beforeLock(this, event);
+    }
-        Set<InternalDistributedMember> mbrs = getDistributionAdvisor().adviseCacheOp();
-        StateFlushOperation.flushTo(mbrs, this);
+        Set<InternalDistributedMember> members = getDistributionAdvisor().adviseCacheOp();
+        StateFlushOperation.flushTo(members, this);
-    if (alth != null)
-      alth.afterLock(this, null);
-
+    if (armLockTestHook != null) {
+      armLockTestHook.afterLock(this, null);
+    }
-   * 
-   * @param participants
-    ARMLockTestHook alth = getRegionMap().getARMLockTestHook();
-    if (alth != null)
-      alth.beforeRelease(this, regionEvent);
+    ARMLockTestHook armLockTestHook = getRegionMap().getARMLockTestHook();
+    if (armLockTestHook != null) {
+      armLockTestHook.beforeRelease(this, regionEvent);
+    }
-    if (alth != null)
-      alth.afterRelease(this, regionEvent);
-
+    if (armLockTestHook != null) {
+      armLockTestHook.afterRelease(this, regionEvent);
+    }
-
-      synchronized (clearLock) {
+      synchronized (this.clearLock) {
-        // DAN - I'm a little scared that the compiler might optimize
+        // I'm a little scared that the compiler might optimize
-  // test hook for DistributedAckRegionCCEDUnitTest
-  public static boolean LOCALCLEAR_TESTHOOK;
-
-    if (getScope().isDistributed() && getDataPolicy().withReplication() && !LOCALCLEAR_TESTHOOK) {
+    if (getScope().isDistributed() && getDataPolicy().withReplication()) {
-  /*
-   * @see SearchLoadAndWriteProcessor#initialize(LocalRegion, Object, Object)
-   */
-  public final CacheDistributionAdvisor getDistributionAdvisor() {
+  @Override
+  public CacheDistributionAdvisor getDistributionAdvisor() {
+  @Override
-  public final PersistenceAdvisor getPersistenceAdvisor() {
+  public PersistenceAdvisor getPersistenceAdvisor() {
-  public final PersistentMemberID getPersistentID() {
+  public PersistentMemberID getPersistentID() {
+  @Override
-  public void fillInProfile(Profile p) {
-    assert p instanceof CacheProfile;
-    CacheProfile profile = (CacheProfile) p;
-    profile.dataPolicy = getDataPolicy();
-    profile.hasCacheLoader = basicGetLoader() != null;
-    profile.hasCacheWriter = basicGetWriter() != null;
-    profile.hasCacheListener = hasListener();
+  @Override
+  public void fillInProfile(Profile profile) {
+    assert profile instanceof CacheProfile;
+    CacheProfile cacheProfile = (CacheProfile) profile;
+    cacheProfile.dataPolicy = getDataPolicy();
+    cacheProfile.hasCacheLoader = basicGetLoader() != null;
+    cacheProfile.hasCacheWriter = basicGetWriter() != null;
+    cacheProfile.hasCacheListener = hasListener();
-    profile.scope = this.scope;
-    profile.inRecovery = getImageState().getInRecovery();
-    profile.isPersistent = getDataPolicy().withPersistence();
-    profile.setSubscriptionAttributes(getSubscriptionAttributes());
-    // Kishor : Below PDX check is added for rolling upgrade support. We are
+    cacheProfile.scope = this.scope;
+    cacheProfile.inRecovery = getImageState().getInRecovery();
+    cacheProfile.isPersistent = getDataPolicy().withPersistence();
+    cacheProfile.setSubscriptionAttributes(getSubscriptionAttributes());
+
+    // Below PDX check is added for rolling upgrade support. We are
-    if (this.isPdxTypesRegion()) {
-      profile.isGatewayEnabled = true;
-    } else {
-      profile.isGatewayEnabled = false;
-    }
-    profile.serialNumber = getSerialNumber();
-    profile.regionInitialized = this.isInitialized();
-    profile.persistentID = getPersistentID();
+
+    cacheProfile.isGatewayEnabled = isPdxTypesRegion();
+    cacheProfile.serialNumber = getSerialNumber();
+    cacheProfile.regionInitialized = isInitialized();
+    cacheProfile.persistentID = getPersistentID();
-      profile.persistenceInitialized = getPersistenceAdvisor().isOnline();
+      cacheProfile.persistenceInitialized = getPersistenceAdvisor().isOnline();
-    profile.hasCacheServer = ((this.cache.getCacheServers().size() > 0) ? true : false);
-    profile.requiresOldValueInEvents = this.dataPolicy.withReplication()
+    cacheProfile.hasCacheServer = this.cache.getCacheServers().size() > 0 ? true : false;
+    cacheProfile.requiresOldValueInEvents = this.dataPolicy.withReplication()
-    profile.gatewaySenderIds = getGatewaySenderIds();
-    profile.asyncEventQueueIds = getVisibleAsyncEventQueueIds();
-    profile.isOffHeap = getOffHeap();
+    cacheProfile.gatewaySenderIds = getGatewaySenderIds();
+    cacheProfile.asyncEventQueueIds = getVisibleAsyncEventQueueIds();
+    cacheProfile.isOffHeap = getOffHeap();
-      // Assert.assertTrue(this.scope.isGlobal()); since 7.0 this is used for distributing clear()
-      // ops
-
-      String svcName = getFullPath();
+      String dlsName = getFullPath();
-        this.dlockService = DistributedLockService.getServiceNamed(svcName);
+        this.dlockService = DistributedLockService.getServiceNamed(dlsName);
-          this.dlockService = DLockService.create(getFullPath(), getSystem(),
-              true /* distributed */, false /* destroyOnDisconnect */, // region destroy will
-                                                                       // destroy dls
-              false /* automateFreeResources */); // manual freeResources only
+          // region destroy will destroy dls and manual freeResources only
+          this.dlockService = DLockService.create(getFullPath(), getSystem(), true, false, false);
-          logger.debug("LockService for {} is using LockLease={}, LockTimeout=", svcName,
+          logger.debug("LockService for {} is using LockLease={}, LockTimeout={}", dlsName,
-  /**
-   * @see LocalRegion#isCurrentlyLockGrantor()
-   */
-    if (!this.scope.isGlobal())
-      return false;
-    return getLockService().isLockGrantor();
+    return this.scope.isGlobal() && getLockService().isLockGrantor();
-    if (!this.scope.isGlobal())
-      return false;
-    return this.isLockGrantor;
+    return this.scope.isGlobal() && this.isLockGrantor;
+
+
-    if (this.srp == null) {
+    if (this.serverRegionProxy == null) {
-    Object value = this.srp.get(keyInfo.getKey(), aCallbackArgument, holder);
+    Object value = this.serverRegionProxy.get(keyInfo.getKey(), aCallbackArgument, holder);
-   * hook for subclasses to note that a cache load was performed
-   * 
-   * @see BucketRegion#performedLoad
-   */
-  // void performedLoad(EntryEventImpl event, long lastModifiedTime, TXState txState)
-  // throws CacheWriterException {
-  // // no action in DistributedRegion
-  // }
-
-  /**
-   * @see LocalRegion#cacheWriteBeforeDestroy(EntryEventImpl, Object)
-  /**
-   * @see LocalRegion#cacheWriteBeforeRegionDestroy(RegionEventImpl)
-   */
-      if (localWriter != null || (netWriteRecipients != null && !netWriteRecipients.isEmpty())) {
+      if (localWriter != null || netWriteRecipients != null && !netWriteRecipients.isEmpty()) {
-    if (persistenceAdvisor != null) {
+    if (this.persistenceAdvisor != null) {
-    DLockService dls = null;
+    DLockService dls = null;
-        for (int i = 0; i < listeners.length; i++) {
-          if (listeners[i] instanceof RegionMembershipListener) {
-            RegionMembershipListener rml = (RegionMembershipListener) listeners[i];
+        for (CacheListener listener : listeners) {
+          if (listener instanceof RegionMembershipListener) {
+            RegionMembershipListener regionMembershipListener = (RegionMembershipListener) listener;
-              rml.initialMembers(this, otherDms);
+              regionMembershipListener.initialMembers(this, otherDms);
-        for (GatewaySender sender : cache.getAllGatewaySenders()) {
+        for (GatewaySender sender : this.cache.getAllGatewaySenders()) {
-
-            // if (sender.isRunning()) {
-            // ConcurrentParallelGatewaySenderQueue parallelQueue =
-            // (ConcurrentParallelGatewaySenderQueue)((ParallelGatewaySenderImpl)sender)
-            // .getQueues().toArray(new RegionQueue[1])[0];
-            // parallelQueue.addShadowPartitionedRegionForUserRR(this);
-            // }
-   * 
-   * @see LocalRegion#postDestroyRegion(boolean, RegionEventImpl)
-
-    } catch (RegionDestroyedException e) {
+    } catch (RegionDestroyedException ignore) {
-    } catch (CancelException e) {
+    } catch (CancelException ignore) {
-  /**
-   * @see LocalRegion#handleCacheClose(Operation)
-   */
-  void handleCacheClose(Operation op) {
+  void handleCacheClose(Operation operation) {
-      super.handleCacheClose(op);
+      super.handleCacheClose(operation);
-   * 
-   * @see LocalRegion#cacheWriteBeforePut(EntryEventImpl, Set, CacheWriter, boolean, Object)
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-    List senderIds =
+    List<Set<String>> senderIds =
-    List asycnQueueIds = this.getCacheDistributionAdvisor()
+    List<Set<String>> asycnQueueIds = this.getCacheDistributionAdvisor()
-            msgArgs =
-                new Object[] {key, Long.valueOf((System.currentTimeMillis() - start) / 1000L)};
+            msgArgs = new Object[] {key, (System.currentTimeMillis() - start) / 1000L};
-          // FIXME Why is it OK to keep going?
+          // TODO: Why is it OK to keep going?
-            timeLeft = getCache().getLockTimeout() - ((System.currentTimeMillis() - start) / 1000L);
+            timeLeft = getCache().getLockTimeout() - (System.currentTimeMillis() - start) / 1000L;
-        msgArgs = new Object[] {Integer.valueOf(getCache().getLockTimeout()), key};
+        msgArgs = new Object[] {getCache().getLockTimeout(), key};
-   * 
-    return (mapEntry == null || (mapEntry.isRemoved() && !mapEntry.isTombstone()));
+    return mapEntry == null || mapEntry.isRemoved() && !mapEntry.isTombstone();
+  @Override
-        return new DiskSavyIterator();
+        return new DiskSavvyIterator();
-  // /**
-  // * The maximum number of entries that can be put into the diskMap before
-  // * some of them are read from disk and returned by this iterator.
-  // * The larger this number the more memory this iterator is allowed to consume
-  // * and the better it will do in optimally reading the pending entries.
-  // */
-  // static final long MAX_PENDING_ENTRIES = Long.getLong("gemfire.MAX_PENDING_ENTRIES",
-  // 1000000).longValue();
-  private class DiskSavyIterator implements Iterator<RegionEntry> {
+  private class DiskSavvyIterator implements Iterator<RegionEntry> {
+
+
-    // private final ArrayList<DiskPosition> diskList = new ArrayList<DiskPosition>(/*@todo presize
-    // based on number of entries only on disk*/);
-    // value will be either RegionEntry or an ArrayList<RegionEntry>
-    // private long pendingCount = 0;
-    private final java.util.TreeMap<DiskPage, Object> diskMap =
-        new java.util.TreeMap<DiskPage, Object>();
-    // /**
-    // * used to iterate over the fullest pages at the time we have
-    // * added MAX_PENDING_ENTRIES to diskMap;
-    // */
-    // private Iterator<Map.Entry<DiskPage, Object>> sortedDiskIt;
+    private final TreeMap<DiskPage, Object> diskMap = new TreeMap<>();
-    public DiskSavyIterator() {}
+    DiskSavvyIterator() {}
+    @Override
-      // if (this.sortedDiskIt != null) {
-      // result = this.sortedDiskIt.hasNext();
-      // if (!result) {
-      // this.sortedDiskIt = null;
-      // } else {
-      // return result;
-      // }
-      // }
+
-        // long start = System.currentTimeMillis();
-        // Collections.sort(this.diskList);
-        // long end = System.currentTimeMillis();
+    @Override
-          // } else if (this.sortedDiskIt != null) {
-          // Map.Entry<DiskPage, Object> me = this.sortedDiskIt.next();
-          // // remove the page from the diskMap.
-          // this.diskMap.remove(me.getKey());
-          // Object v = me.getValue();
-          // int size = 1;
-          // if (v instanceof ArrayList) {
-          // ArrayList al = (ArrayList)v;
-          // size = al.size();
-          // // set up the iterator to start returning the entries on that page
-          // this.subIt = al.iterator();
-          // v = this.subIt.next();
-          // }
-
-          // // decrement pendingCount by the number of entries on the page
-          // this.pendingCount -= size;
-          // // return the first region entry on this page
-          // return v;
-          RegionEntry re = (RegionEntry) this.it.next();
-          DiskPosition dp = new DiskPosition();
-          if (re.isOverflowedToDisk(DistributedRegion.this, dp)) {
-            // add dp to sorted list
-            DiskPage dPage = new DiskPage(dp);
-            Object v = this.diskMap.get(dPage);
-            if (v == null) {
-              this.diskMap.put(dPage, re);
-            } else if (v instanceof ArrayList) {
-              ArrayList al = (ArrayList) v;
-              al.add(re);
+          RegionEntry regionEntry = (RegionEntry) this.it.next();
+          DiskPosition diskPosition = new DiskPosition();
+          if (regionEntry.isOverflowedToDisk(DistributedRegion.this, diskPosition)) {
+            // add diskPosition to sorted list
+            DiskPage dPage = new DiskPage(diskPosition);
+            Object value = this.diskMap.get(dPage);
+            if (value == null) {
+              this.diskMap.put(dPage, regionEntry);
+            } else if (value instanceof ArrayList) {
+              List list = (List) value;
+              list.add(regionEntry);
-              ArrayList al = new ArrayList();
-              al.add(v);
-              al.add(re);
-              this.diskMap.put(dPage, al);
+              List list = new ArrayList();
+              list.add(value);
+              list.add(regionEntry);
+              this.diskMap.put(dPage, list);
-            // this.pendingCount++;
-            // if (this.usingIt && this.pendingCount >= MAX_PENDING_ENTRIES) {
-            // // find the pages that have the most entries
-            // int largestPage = 1;
-            // ArrayList<Map.Entry<DiskPage, Object>> largestPages
-            // = new ArrayList<Map.Entry<DiskPage, Object>>();
-            // for (Map.Entry<DiskPage, Object> me: this.diskMap.entrySet()) {
-            // int meSize = 1;
-            // if (me.getValue() instanceof ArrayList) {
-            // meSize = ((ArrayList)me.getValue()).size();
-            // }
-            // if (meSize > largestPage) {
-            // largestPage = meSize;
-            // largestPages.clear(); // throw away smaller pages
-            // largestPages.add(me);
-            // } else if (meSize == largestPage) {
-            // largestPages.add(me);
-            // } else {
-            // // ignore this page
-            // }
-            // }
-            // Collections.sort(largestPages, new Comparator
-            // <Map.Entry<DiskPage, Object>>() {
-            // /**
-            // * Note: this comparator imposes orderings that are inconsistent
-            // * with equals.
-            // */
-            // public int compare(Map.Entry<DiskPage, Object> o1, Map.Entry<DiskPage, Object> o2) {
-            // return o1.getKey().compareTo(o2.getKey());
-            // }
-            // });
-            // this.sortedDiskIt = largestPages.iterator();
-            // // loop around and fetch first value from sortedDiskIt
-            // }
-            return re;
+            return regionEntry;
-          Object v = this.it.next();
-          if (v instanceof ArrayList) {
-            ArrayList al = (ArrayList) v;
-            this.subIt = al.iterator();
+          Object value = this.it.next();
+          if (value instanceof ArrayList) {
+            List list = (List) value;
+            this.subIt = list.iterator();
-            return (RegionEntry) v;
+            return (RegionEntry) value;
+    @Override
-    private long oplogId;
-    private long offset;
+    long oplogId; // package-private to avoid synthetic accessor
+    long offset; // package-private to avoid synthetic accessor
+      // TODO: Object instantiation inside 'hashCode()' is bad
-    public boolean equals(Object o) {
-      if (o instanceof DiskPosition) {
-        DiskPosition other = (DiskPosition) o;
+    public boolean equals(Object obj) {
+      if (obj instanceof DiskPosition) {
+        DiskPosition other = (DiskPosition) obj;
+    @Override
-      StringBuffer sb = new StringBuffer();
-      sb.append("<").append(this.oplogId).append(":").append(this.offset).append(">");
+      StringBuilder sb = new StringBuilder();
+      sb.append('<').append(this.oplogId).append(':').append(this.offset).append('>');
+
-        Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "DISK_PAGE_SIZE", 8 * 1024L).longValue();
+        Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "DISK_PAGE_SIZE", 8 << 10);
-    DiskPage(DiskPosition dp) {
-      this.setPosition(dp.oplogId, dp.offset / DISK_PAGE_SIZE);
+    DiskPage(DiskPosition diskPosition) {
+      this.setPosition(diskPosition.oplogId, diskPosition.offset / DISK_PAGE_SIZE);
-  protected long getLockLeaseForLock() {
+  long getLockLeaseForLock() { // package-private to avoid synthetic accessor
-  protected long getLockTimeoutForLock(long time, TimeUnit unit) {
+  long getLockTimeoutForLock(long time, TimeUnit unit) { // package-private to avoid synthetic
+                                                         // accessor
-
-
-  /** ******************* DistributedLock ************************************* */
-
-    public DistributedLock(Object key) {
+    DistributedLock(Object key) {
+    @Override
+    @Override
+    @Override
+    @Override
-
+    // TODO: basicTryLock method is too complex for IDE to analyze
-      boolean suspected = false;
-      boolean severeAlertIssued = false;
-      DistributedMember lockHolder = null;
+      boolean suspected = false;
+      boolean severeAlertIssued = false;
+      DistributedMember lockHolder = null;
-                        new Object[] {Long.valueOf(ackWaitThreshold + ackSAThreshold),
-                            lockHolder}));
+                        new Object[] {ackWaitThreshold + ackSAThreshold, lockHolder}));
+    @Override
-        if (!DistributedRegion.this.entries.containsKey(key)) {
-          getLockService().freeResources(key);
+        if (!DistributedRegion.this.entries.containsKey(this.key)) {
+          getLockService().freeResources(this.key);
+    @Override
-  /////////////////// RegionDistributedLock //////////////////
-
-    public RegionDistributedLock() {}
+    RegionDistributedLock() {}
+    @Override
+    @Override
-      // if (Thread.interrupted()) throw new InterruptedException(); not necessary
-      // suspendLockingInterruptibly does this
+      // suspendLockingInterruptibly checks Thread.interrupted() to throw InterruptedException
+    @Override
+    @Override
-      // if (Thread.interrupted()) throw new InterruptedException(); not necessary
-      // suspendLockingINterruptibly does this
+      // suspendLockingInterruptibly checks Thread.interrupted() to throw InterruptedException
+    @Override
+    @Override
-  // - add in region locking for destroy and invalidate...
-
-  Lock getRegionDistributedLockIfGlobal() throws TimeoutException {
+  private Lock getRegionDistributedLockIfGlobal() throws TimeoutException {
-      dlock.lock();
+      dlock.lock(); // caller is expected to use a try-finally to unlock
-  /*
-   * void localDestroyRegion(Object aCallbackArgument) { try { Lock dlock =
-   * this.getRegionDistributedLockIfGlobal(); try { super.localDestroyRegion(aCallbackArgument); }
-   * finally { if (dlock != null) { dlock.unlock(); } } } catch (TimeoutException e) { throw new
-   * GemFireCacheException("localDestroyRegion timed out", e); } }
-   * 
-   * void destroyRegion(Object aCallbackArgument) throws CacheWriterException, TimeoutException {
-   * Lock dlock = this.getRegionDistributedLockIfGlobal(); try {
-   * super.destroyRegion(aCallbackArgument); } finally { if (dlock != null) { dlock.unlock(); } } }
-   * 
-   * void invalidateRegion(Object aCallbackArgument) throws TimeoutException { Lock dlock =
-   * this.getRegionDistributedLockIfGlobal(); try { super.invalidateRegion(aCallbackArgument); }
-   * finally { if (dlock != null) { dlock.unlock(); } } }
-   */
-
-
-      final DistributedRemoveAllOperation removeAllOp, final ArrayList<VersionTag> retryVersions) {
+      final DistributedRemoveAllOperation removeAllOp, final List<VersionTag> retryVersions) {
-
-  /** Returns true if any required roles are currently missing */
-  boolean isMissingRequiredRoles() {
-    return this.isMissingRequiredRoles;
-  }
-
-   * @throws InterruptedException TODO-javadocs
-    if (Thread.interrupted())
+    if (Thread.interrupted()) {
+    }
+
-      return Collections.EMPTY_SET; // early-out: no missing required roles
+      return Collections.emptySet(); // early-out: no missing required roles
-          this.cache.getCancelCriterion().checkCancelInProgress(null); // bail if distribution has
-                                                                       // stopped
+          // bail if distribution has stopped
+          this.cache.getCancelCriterion().checkCancelInProgress(null);
-          this.cache.getCancelCriterion().checkCancelInProgress(null); // bail if distribution has
-                                                                       // stopped
+          // bail if distribution has stopped
+          this.cache.getCancelCriterion().checkCancelInProgress(null);
-        return Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
+        return Collections.unmodifiableSet(new HashSet<>(this.missingRequiredRoles));
-      return Collections.EMPTY_SET;
+      return Collections.emptySet();
-  protected boolean basicIsRoleInRegionMembership(Role role) {
+  private boolean basicIsRoleInRegionMembership(Role role) {
-    Set members = this.distAdvisor.adviseGeneric();
-    for (Iterator iter = members.iterator(); iter.hasNext();) {
-      DistributedMember member = (DistributedMember) iter.next();
-      Set roles = member.getRoles();
+    for (DistributedMember member : this.distAdvisor.adviseGeneric()) {
+      Set<Role> roles = member.getRoles();
+  @Override
-    private Set members = new HashSet();
+    Set members = new HashSet(); // package-private to avoid synthetic accessor
-    protected synchronized void addMembers(Set newMembers) {
+    synchronized void addMembers(Set newMembers) {
+    @Override
-        List<InternalDistributedMember> remaining) {}
+        List<InternalDistributedMember> remaining) {
+      // do nothing
+    }
+    @Override
-        String reason) {}
+        String reason) {
+      // do nothing
+    }
-    protected synchronized void initRMLWrappers() {
-      Set membersWithThisRegion = DistributedRegion.this.distAdvisor.adviseGeneric();
+    synchronized void initRMLWrappers() {
+      Set<InternalDistributedMember> membersWithThisRegion =
+          DistributedRegion.this.distAdvisor.adviseGeneric();
+    @Override
-      // if (this.members == null && hasListener()) {
-      // RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
-      // Operation.REGION_CREATE, null, true, id);
-      // dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CREATE,
-      // event);
-      // }
-        Set newlyAcquiredRoles = Collections.EMPTY_SET;
+        Set newlyAcquiredRoles = Collections.emptySet();
-        Set newlyMissingRoles = Collections.EMPTY_SET;
+        Set newlyMissingRoles = Collections.emptySet();
-              if (newlyMissingRoles == Collections.EMPTY_SET) {
+              if (newlyMissingRoles == Collections.emptySet()) {
-   * @param key
-   * @param function
-   * @param args
-        this.randIndex = PartitionedRegion.rand.nextInt(numProfiles);
+        this.randIndex = PartitionedRegion.RANDOM.nextInt(numProfiles);
-      Set<InternalDistributedMember> critialMembers) {
+      Set<InternalDistributedMember> criticalMembers) {
-    for (InternalDistributedMember idm : critialMembers) {
+    for (InternalDistributedMember idm : criticalMembers) {
-   * @param key

GEODE-5013 Replace org.json with Jackson in GfJsonObject

This removes org.json as a dependency in geode-core and associated test
modules.  GfJsonObject and GfJsonArray are ported to use the same basic
Jackson ObjectMapper setup as QueryResultFormatter so that we now have a
uniform mechanism for managing JSON documents for querying/gfsh and
folks can use Jackson annotations like @JsonIgnore on their classes.

The geode-web-api and geode-pulse modules still use the geode-json
module in tests.  When/if they are ported to use GfJsonObject/Array we can delete
the geode-json module.

-import java.util.Collection;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.JsonToken;
-import com.fasterxml.jackson.core.type.WritableTypeId;
-import com.fasterxml.jackson.databind.BeanDescription;
-import com.fasterxml.jackson.databind.JsonSerializer;
-import com.fasterxml.jackson.databind.MapperFeature;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.SerializationConfig;
-import com.fasterxml.jackson.databind.SerializationFeature;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
-import com.fasterxml.jackson.databind.module.SimpleModule;
-import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
-
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.query.internal.StructImpl;
-import org.apache.geode.pdx.PdxInstance;
-
-public class QueryResultFormatter {
-
-  private final ObjectMapper mapper;
+public class QueryResultFormatter extends AbstractJSONFormatter {
-   * serializedObjects is used to prevent recursive serialization in cases where
-   * there are cyclical references
-   */
-  private final Map<Object, Object> serializedObjects;
-
-  /**
-  private QueryResultFormatter(int maxCollectionElements, int serializationDepth) {
+  public QueryResultFormatter(int maxCollectionElements, int serializationDepth) {
+    super(maxCollectionElements, serializationDepth, true);
-
-    this.serializedObjects = new IdentityHashMap<>();
-    this.mapper = new ObjectMapper();
-
-    SimpleModule mapperModule =
-        new PreventReserializationModule(serializedObjects, serializationDepth);
-
-    // insert a collection serializer that limits the number of elements generated
-    mapperModule.addSerializer(Collection.class, new CollectionSerializer(maxCollectionElements));
-    // insert a PdxInstance serializer that knows about PDX fields/values
-    mapperModule.addSerializer(PdxInstance.class, new PdxInstanceSerializer());
-    // insert a Struct serializer that knows about its format
-    mapperModule.addSerializer(StructImpl.class, new StructSerializer());
-    // insert a RegionEntry serializer because they're too messy looking
-    mapperModule.addSerializer(Region.Entry.class, new RegionEntrySerializer());
-
-    mapper.registerModule(mapperModule);
-
-    // allow objects with no content
-    mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
-    // use toString on Enums
-    mapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
-    // sort fields alphabetically
-    mapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);
-    // add type information (Jackson has no way to force it to do this for all values)
-    mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
-
-  private static class PreventReserializationSerializer extends JsonSerializer {
-
-    private JsonSerializer defaultSerializer;
-    Map<Object, Object> serializedObjects;
-    private final int serializationDepth;
-    int depth;
-
-    PreventReserializationSerializer(JsonSerializer serializer, Map serializedObjects,
-        int serializationDepth) {
-      defaultSerializer = serializer;
-      this.serializedObjects = serializedObjects;
-      this.serializationDepth = serializationDepth;
-    }
-
-    boolean isPrimitiveOrWrapper(Class<?> klass) {
-      return klass.isAssignableFrom(Byte.class) || klass.isAssignableFrom(byte.class)
-          || klass.isAssignableFrom(Short.class) || klass.isAssignableFrom(short.class)
-          || klass.isAssignableFrom(Integer.class) || klass.isAssignableFrom(int.class)
-          || klass.isAssignableFrom(Long.class) || klass.isAssignableFrom(long.class)
-          || klass.isAssignableFrom(Float.class) || klass.isAssignableFrom(float.class)
-          || klass.isAssignableFrom(Double.class) || klass.isAssignableFrom(double.class)
-          || klass.isAssignableFrom(Boolean.class) || klass.isAssignableFrom(boolean.class)
-          || klass.isAssignableFrom(String.class) || klass.isAssignableFrom(char.class)
-          || klass.isAssignableFrom(Character.class) || klass.isAssignableFrom(java.sql.Date.class)
-          || klass.isAssignableFrom(java.util.Date.class)
-          || klass.isAssignableFrom(java.math.BigDecimal.class);
-    }
-
-    @Override
-    public void serializeWithType(Object value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      if (value == null || isPrimitiveOrWrapper(value.getClass())) {
-        defaultSerializer.serializeWithType(value, gen, serializers, typeSer);
-        return;
-      }
-      depth += 1;
-      try {
-        if (depth > serializationDepth) {
-          gen.writeString("{}");
-        } else if (serializedObjects.containsKey(value)) {
-          gen.writeString("duplicate " + value.getClass().getName());
-        } else {
-          serializedObjects.put(value, value);
-          defaultSerializer.serializeWithType(value, gen, serializers, typeSer);
-        }
-      } finally {
-        depth--;
-      }
-    }
-
-    @Override
-    public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      if (value == null || isPrimitiveOrWrapper(value.getClass())) {
-        defaultSerializer.serialize(value, gen, serializers);
-        return;
-      }
-      if (serializedObjects.containsKey(value)) {
-        gen.writeStartObject(value);
-        gen.writeFieldName("duplicate");
-        gen.writeString("reference@" + Integer.toHexString(System.identityHashCode(value)));
-        gen.writeEndObject();
-      } else {
-        serializedObjects.put(value, value);
-        defaultSerializer.serialize(value, gen, serializers);
-      }
-    }
-  }
-
-
-  private static class CollectionSerializer extends JsonSerializer<Collection> {
-    private final int maxCollectionElements;
-
-    public CollectionSerializer(int maxCollectionElements) {
-      this.maxCollectionElements = maxCollectionElements;
-    }
-
-    @Override
-    public void serializeWithType(Collection value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      gen.setCurrentValue(value);
-      WritableTypeId typeIdDef = typeSer.writeTypePrefix(gen,
-          typeSer.typeId(value, JsonToken.START_OBJECT));
-      _serialize(value, gen);
-      typeSer.writeTypeSuffix(gen, typeIdDef);
-    }
-
-    @Override
-    public void serialize(Collection value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      _serialize(value, gen);
-      gen.writeEndObject();
-    }
-
-    void _serialize(Collection value, JsonGenerator gen) throws IOException {
-      Iterator<Object> objects = value.iterator();
-      for (int i = 0; i < maxCollectionElements && objects.hasNext(); i++) {
-        Object nextObject = objects.next();
-        gen.writeObjectField("" + i, nextObject);
-      }
-    }
-
-    @Override
-    public Class<Collection> handledType() {
-      return Collection.class;
-    }
-  }
-
-
-  private static class PdxInstanceSerializer extends JsonSerializer<PdxInstance> {
-    @Override
-    public void serializeWithType(PdxInstance value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      WritableTypeId writableTypeId = typeSer.typeId(value, JsonToken.START_OBJECT);
-      typeSer.writeTypePrefix(gen, writableTypeId);
-      _serialize(value, gen);
-      typeSer.writeTypeSuffix(gen, writableTypeId);
-    }
-
-    @Override
-    public void serialize(PdxInstance value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      _serialize(value, gen);
-      gen.writeEndObject();
-    }
-
-    void _serialize(PdxInstance value, JsonGenerator gen) throws IOException {
-      for (String field : value.getFieldNames()) {
-        gen.writeObjectField(field, value.getField(field));
-      }
-    }
-
-    @Override
-    public Class<PdxInstance> handledType() {
-      return PdxInstance.class;
-    }
-  }
-
-  private static class StructSerializer extends JsonSerializer<StructImpl> {
-    @Override
-    public void serializeWithType(StructImpl value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      typeSer.writeTypePrefix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
-      _serialize(value, gen);
-      typeSer.writeTypeSuffix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
-    }
-
-    @Override
-    public void serialize(StructImpl value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      _serialize(value, gen);
-      gen.writeEndObject();
-    }
-
-    void _serialize(StructImpl value, JsonGenerator gen) throws IOException {
-      String[] fields = value.getFieldNames();
-      Object[] values = value.getFieldValues();
-      for (int i = 0; i < fields.length; i++) {
-        gen.writeObjectField(fields[i], values[i]);
-      }
-    }
-
-    @Override
-    public Class<StructImpl> handledType() {
-      return StructImpl.class;
-    }
-  }
-
-  private static class RegionEntrySerializer extends JsonSerializer<Region.Entry> {
-    @Override
-    public void serializeWithType(Region.Entry value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      typeSer.writeTypePrefix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
-      gen.writeObjectField(value.getKey().toString(), value.getValue());
-      typeSer.writeTypeSuffix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
-    }
-
-    @Override
-    public void serialize(Region.Entry value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      gen.writeObjectField(value.getKey().toString(), value.getValue());
-      gen.writeEndObject();
-    }
-
-    @Override
-    public Class<Region.Entry> handledType() {
-      return Region.Entry.class;
-    }
-  }
-
-  /**
-   * A Jackson module that installs a serializer-modifier to detect and prevent
-   * reserialization of objects that have already been serialized. W/o this
-   * Jackson would throw infinite-recursion exceptions.
-   */
-  private static class PreventReserializationModule extends SimpleModule {
-    private final Map<Object, Object> serializedObjects;
-    private final int serializationDepth;
-
-    PreventReserializationModule(Map<Object, Object> serializedObjects, int serializationDepth) {
-      this.serializedObjects = serializedObjects;
-      this.serializationDepth = serializationDepth;
-    }
-
-    @Override
-    public void setupModule(SetupContext context) {
-      // install a modifier that prevents recursive serialization in cases where
-      // there are cyclical references
-      super.setupModule(context);
-      context.addBeanSerializerModifier(new BeanSerializerModifier() {
-        @Override
-        public JsonSerializer<?> modifySerializer(
-            SerializationConfig config, BeanDescription desc, JsonSerializer<?> serializer) {
-          return new PreventReserializationSerializer(serializer, serializedObjects,
-              serializationDepth);
-        }
-      });
-    }
-
-  }

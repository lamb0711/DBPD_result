Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class HandShake implements ClientHandShake
-{
+public class HandShake implements ClientHandShake {
-  
-  protected static final byte REPLY_OK = (byte)59;
-  protected static final byte REPLY_REFUSED = (byte)60;
+  protected static final byte REPLY_OK = (byte) 59;
-  protected static final byte REPLY_INVALID = (byte)61;
+  protected static final byte REPLY_REFUSED = (byte) 60;
-  protected static final byte REPLY_EXCEPTION_AUTHENTICATION_REQUIRED = (byte)62;
+  protected static final byte REPLY_INVALID = (byte) 61;
-  protected static final byte REPLY_EXCEPTION_AUTHENTICATION_FAILED = (byte)63;
-  
-  protected static final byte REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT = (byte)64;
-  
-  protected static final byte REPLY_WAN_CREDENTIALS = (byte)65;
-  
-  protected static final byte REPLY_AUTH_NOT_REQUIRED = (byte)66;
-  
+  protected static final byte REPLY_EXCEPTION_AUTHENTICATION_REQUIRED = (byte) 62;
+
+  protected static final byte REPLY_EXCEPTION_AUTHENTICATION_FAILED = (byte) 63;
+
+  protected static final byte REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT = (byte) 64;
+
+  protected static final byte REPLY_WAN_CREDENTIALS = (byte) 65;
+
+  protected static final byte REPLY_AUTH_NOT_REQUIRED = (byte) 66;
+
-  
+
- 
+
-   * Used at client side, indicates whether the 'delta-propagation' property is
-   * enabled on the DS this client is connected to. This variable is used to
-   * decide whether to send delta bytes or full value to the server for a
-   * delta-update operation.
+   * Used at client side, indicates whether the 'delta-propagation' property is enabled on the DS
+   * this client is connected to. This variable is used to decide whether to send delta bytes or
+   * full value to the server for a delta-update operation.
-  public static final byte CREDENTIALS_NONE = (byte)0;
+  public static final byte CREDENTIALS_NONE = (byte) 0;
-  public static final byte CREDENTIALS_NORMAL = (byte)1;
+  public static final byte CREDENTIALS_NORMAL = (byte) 1;
-  public static final byte CREDENTIALS_DHENCRYPT = (byte)2;
-  
-  public static final byte SECURITY_MULTIUSER_NOTIFICATIONCHANNEL = (byte)3;
+  public static final byte CREDENTIALS_DHENCRYPT = (byte) 2;
-  private byte appSecureMode = (byte)0;
+  public static final byte SECURITY_MULTIUSER_NOTIFICATIONCHANNEL = (byte) 3;
+
+  private byte appSecureMode = (byte) 0;
-  private String clientSKAlgo = null; 
+  private String clientSKAlgo = null;
-  private static final BigInteger dhP = new BigInteger(
-      "13528702063991073999718992897071702177131142188276542919088770094024269"
-       +  "73079899070080419278066109785292538223079165925365098181867673946"
-       +  "34756714063947534092593553024224277712367371302394452615862654308"
-       +  "11180902979719649450105660478776364198726078338308557022096810447"
-       +  "3500348898008043285865193451061481841186553");
+  private static final BigInteger dhP =
+      new BigInteger("13528702063991073999718992897071702177131142188276542919088770094024269"
+          + "73079899070080419278066109785292538223079165925365098181867673946"
+          + "34756714063947534092593553024224277712367371302394452615862654308"
+          + "11180902979719649450105660478776364198726078338308557022096810447"
+          + "3500348898008043285865193451061481841186553");
-  private static final BigInteger dhG = new BigInteger(
-      "13058345680719715096166513407513969537624553636623932169016704425008150"
-      +  "56576152779768716554354314319087014857769741104157332735258102835"
-      +  "93126577393912282416840649805564834470583437473176415335737232689"
-      +  "81480201869671811010996732593655666464627559582258861254878896534"
-      +  "1273697569202082715873518528062345259949959");
+  private static final BigInteger dhG =
+      new BigInteger("13058345680719715096166513407513969537624553636623932169016704425008150"
+          + "56576152779768716554354314319087014857769741104157332735258102835"
+          + "93126577393912282416840649805564834470583437473176415335737232689"
+          + "81480201869671811010996732593655666464627559582258861254878896534"
+          + "1273697569202082715873518528062345259949959");
-  
+
-  /** @since GemFire 6.0.3
-   *  List of per client property override bits.
+  /**
+   * @since GemFire 6.0.3 List of per client property override bits.
-  
+
+   * 
+   * 
-  
+
-  public HandShake(Socket sock, int timeout, DistributedSystem sys,
-      Version clientVersion, byte communicationMode) throws IOException,
-      AuthenticationRequiredException {
+  public HandShake(Socket sock, int timeout, DistributedSystem sys, Version clientVersion,
+      byte communicationMode) throws IOException, AuthenticationRequiredException {
-    //SocketChannel sc = sock.getChannel();
-    /*if (sc != null) {
-      } else*/ {
+    // SocketChannel sc = sock.getChannel();
+    /*
+     * if (sc != null) { } else
+     */ {
-        int valRead =  is.read();
-        //this.code =  (byte)is.read();
+        int valRead = is.read();
+        // this.code = (byte)is.read();
-          throw new EOFException(LocalizedStrings.HandShake_HANDSHAKE_EOF_REACHED_BEFORE_CLIENT_CODE_COULD_BE_READ.toLocalizedString()); 
+          throw new EOFException(
+              LocalizedStrings.HandShake_HANDSHAKE_EOF_REACHED_BEFORE_CLIENT_CODE_COULD_BE_READ
+                  .toLocalizedString());
-        this.code =  (byte)valRead;
+        this.code = (byte) valRead;
-          throw new IOException(LocalizedStrings.HandShake_HANDSHAKE_REPLY_CODE_IS_NOT_OK.toLocalizedString());
+          throw new IOException(
+              LocalizedStrings.HandShake_HANDSHAKE_REPLY_CODE_IS_NOT_OK.toLocalizedString());
-            setOverrides(new byte[] { dis.readByte() });
+            setOverrides(new byte[] {dis.readByte()});
-          //Hitesh
+          // Hitesh
-        } catch(IOException ioe) {
+        } catch (IOException ioe) {
-          throw  ioe;
-        } catch(ClassNotFoundException cnfe) {
+          throw ioe;
+        } catch (ClassNotFoundException cnfe) {
-          throw new IOException(LocalizedStrings.HandShake_CLIENTPROXYMEMBERSHIPID_CLASS_COULD_NOT_BE_FOUND_WHILE_DESERIALIZING_THE_OBJECT.toLocalizedString());
+          throw new IOException(
+              LocalizedStrings.HandShake_CLIENTPROXYMEMBERSHIPID_CLASS_COULD_NOT_BE_FOUND_WHILE_DESERIALIZING_THE_OBJECT
+                  .toLocalizedString());
-          }
-          catch (IOException ignore) {
+          } catch (IOException ignore) {
-  //private void initSingleton(DistributedSystem sys) {
-  //  id = ClientProxyMembershipID.getNewProxyMembership();    
-  //  this.system = sys;
-  //  this.code = REPLY_OK;
-  //}
+  // private void initSingleton(DistributedSystem sys) {
+  // id = ClientProxyMembershipID.getNewProxyMembership();
+  // this.system = sys;
+  // this.code = REPLY_OK;
+  // }
-   public HandShake(ClientProxyMembershipID id, DistributedSystem sys) {
-     this.id = id;
-     this.code = REPLY_OK;
-     this.system = sys;
-     setOverrides();
-     this.credentials = null;
-   }  
-   
-   public void updateProxyID(InternalDistributedMember idm) {
-     this.id.updateID(idm);
-   }
+  public HandShake(ClientProxyMembershipID id, DistributedSystem sys) {
+    this.id = id;
+    this.code = REPLY_OK;
+    this.system = sys;
+    setOverrides();
+    this.credentials = null;
+  }
-   public HandShake(HandShake handShake) {
-     this.appSecureMode = handShake.appSecureMode;
-     this.clientConflation = handShake.clientConflation;
-     this.clientPublicKey = null;
-     this.clientReadTimeout = handShake.clientReadTimeout;
-     this.clientSKAlgo = null;
-     this.clientVersion = handShake.clientVersion;
-     this.code = handShake.code;
-     this.credentials = handShake.credentials;
-     this.isRead = handShake.isRead;
-     this.multiuserSecureMode = handShake.multiuserSecureMode;
-     this.overrides = handShake.overrides;
-     this.system = handShake.system;
-     this.id = handShake.id;
-     //create new one
-     this._decrypt = null;
-     this._encrypt = null;
-   }  
+  public void updateProxyID(InternalDistributedMember idm) {
+    this.id.updateID(idm);
+  }
-  /*private void read(DataInputStream dis,byte[] toFill)  throws IOException {
-     /* this.code = (byte) in.read();
-      if (this.code == -1) {
-        throw new IOException(LocalizedStrings.HandShake_HANDSHAKE_READ_AT_END_OF_STREAM.toLocalizedString());
-      }
-      if (this.code != REPLY_OK) {
-        throw new IOException(LocalizedStrings.HandShake_HANDSHAKE_REPLY_CODE_IS_NOT_OK.toLocalizedString());
-      }
-      try {
-        ObjectInput in = new ObjectInputStream(is);
-        this.id = ClientProxyMembershipID.readCanonicalized(in);
-      } catch(IOException ioe) {
-        this.code = -2;
-        throw  ioe;
-      } catch(ClassNotFoundException cnfe) {
-        this.code = -3;
-        IOException e = new IOException(LocalizedStrings.HandShake_ERROR_DESERIALIZING_HANDSHAKE.toLocalizedString());
-        e.initCause(cnfe);
-        throw e;
-      }
+  public HandShake(HandShake handShake) {
+    this.appSecureMode = handShake.appSecureMode;
+    this.clientConflation = handShake.clientConflation;
+    this.clientPublicKey = null;
+    this.clientReadTimeout = handShake.clientReadTimeout;
+    this.clientSKAlgo = null;
+    this.clientVersion = handShake.clientVersion;
+    this.code = handShake.code;
+    this.credentials = handShake.credentials;
+    this.isRead = handShake.isRead;
+    this.multiuserSecureMode = handShake.multiuserSecureMode;
+    this.overrides = handShake.overrides;
+    this.system = handShake.system;
+    this.id = handShake.id;
+    // create new one
+    this._decrypt = null;
+    this._encrypt = null;
+  }
+
+  /*
+   * private void read(DataInputStream dis,byte[] toFill) throws IOException { /* this.code = (byte)
+   * in.read(); if (this.code == -1) { throw new
+   * IOException(LocalizedStrings.HandShake_HANDSHAKE_READ_AT_END_OF_STREAM.toLocalizedString()); }
+   * if (this.code != REPLY_OK) { throw new
+   * IOException(LocalizedStrings.HandShake_HANDSHAKE_REPLY_CODE_IS_NOT_OK.toLocalizedString()); }
+   * try { ObjectInput in = new ObjectInputStream(is); this.id =
+   * ClientProxyMembershipID.readCanonicalized(in); } catch(IOException ioe) { this.code = -2; throw
+   * ioe; } catch(ClassNotFoundException cnfe) { this.code = -3; IOException e = new
+   * IOException(LocalizedStrings.HandShake_ERROR_DESERIALIZING_HANDSHAKE.toLocalizedString());
+   * e.initCause(cnfe); throw e; } } finally { synchronized (this) { this.isRead = true; } } }
+   */
+
+  // used by the client side
+  private byte setClientConflation() {
+    byte result = CONFLATION_DEFAULT;
+
+    String clientConflationValue = this.system.getProperties().getProperty(CONFLATE_EVENTS);
+    if (DistributionConfig.CLIENT_CONFLATION_PROP_VALUE_ON
+        .equalsIgnoreCase(clientConflationValue)) {
+      result = CONFLATION_ON;
+    } else if (DistributionConfig.CLIENT_CONFLATION_PROP_VALUE_OFF
+        .equalsIgnoreCase(clientConflationValue)) {
+      result = CONFLATION_OFF;
-    finally {
-      synchronized (this) {
-        this.isRead = true;
-      }
-    }
-  }*/
-
-   //used by the client side
-   private byte setClientConflation() {
-     byte result = CONFLATION_DEFAULT;
-     
-     String clientConflationValue = this.system.getProperties().getProperty(CONFLATE_EVENTS);
-     if (DistributionConfig.CLIENT_CONFLATION_PROP_VALUE_ON
-         .equalsIgnoreCase(clientConflationValue)) {
-       result = CONFLATION_ON;
-     }
-     else 
-     if (DistributionConfig.CLIENT_CONFLATION_PROP_VALUE_OFF
-         .equalsIgnoreCase(clientConflationValue)) {
-       result = CONFLATION_OFF;
-     }
-     return result;
-   }
+    return result;
+  }
-    case CONFLATION_DEFAULT:
-    case CONFLATION_OFF:
-    case CONFLATION_ON:
-      break;
-    default:
-      throw new IllegalArgumentException("Illegal clientConflation");
+      case CONFLATION_DEFAULT:
+      case CONFLATION_OFF:
+      case CONFLATION_ON:
+        break;
+      default:
+        throw new IllegalArgumentException("Illegal clientConflation");
-      override = this.notifyBySubscriptionOverride;
-      override = (byte)((override << 2) | this.removeUnresponsiveClientOverride);
-      override = (byte)((override << 2) | this.clientConflation);
-      */
+       * override = this.notifyBySubscriptionOverride; override = (byte)((override << 2) |
+       * this.removeUnresponsiveClientOverride); override = (byte)((override << 2) |
+       * this.clientConflation);
+       */
-      this.overrides = new byte[] { override };
+      this.overrides = new byte[] {override};
-    setClientConflation(((byte)(override & 0x03)));
+    setClientConflation(((byte) (override & 0x03)));
-    override = (byte)(override >>> 2);
-    setRemoveUnresponsiveClientOverride(((byte)(override & 0x03)));
-    override = (byte)(override >>> 2);
-    setNotifyBySubscriptionOverride(((byte)(override & 0x03)));
-    */
+     * override = (byte)(override >>> 2); setRemoveUnresponsiveClientOverride(((byte)(override &
+     * 0x03))); override = (byte)(override >>> 2); setNotifyBySubscriptionOverride(((byte)(override
+     * & 0x03)));
+     */
-      overrides[item] = (byte)(override & 0x03);
-      override = (byte)(override >>> 2);
+      overrides[item] = (byte) (override & 0x03);
+      override = (byte) (override >>> 2);
-  
-  public byte write(DataOutputStream dos, DataInputStream dis, byte communicationMode, int replyCode,
-      int readTimeout, List ports, Properties p_credentials, DistributedMember member, boolean isCallbackConnection)
-      throws IOException {
+
+  public byte write(DataOutputStream dos, DataInputStream dis, byte communicationMode,
+      int replyCode, int readTimeout, List ports, Properties p_credentials,
+      DistributedMember member, boolean isCallbackConnection) throws IOException {
-        
+
-          hdos.writeInt(Integer.parseInt((String)ports.get(i)));
+          hdos.writeInt(Integer.parseInt((String) ports.get(i)));
-      }
-      else {
+      } else {
-  
+
-        }
-        else {
+        } else {
-        }        
+        }
-      if (isCallbackConnection
-          || communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
+      if (isCallbackConnection || communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
-        acceptanceCode = writeCredential(dos, dis, authInitMethod,
-            ports != null, member, hdos);
+        acceptanceCode = writeCredential(dos, dis, authInitMethod, ports != null, member, hdos);
-    }
-    finally {
+    } finally {
-  public void writeCredentials(DataOutputStream dos, DataInputStream dis,
-      Properties p_credentials, boolean isNotification, DistributedMember member)
+  public void writeCredentials(DataOutputStream dos, DataInputStream dis, Properties p_credentials,
+      boolean isNotification, DistributedMember member)
-    }
-    finally {
+    } finally {
-  public void writeCredentials(DataOutputStream dos, DataInputStream dis,
-      Properties p_credentials, boolean isNotification, DistributedMember member, 
-      HeapDataOutputStream heapdos)
+  public void writeCredentials(DataOutputStream dos, DataInputStream dis, Properties p_credentials,
+      boolean isNotification, DistributedMember member, HeapDataOutputStream heapdos)
-    
+
-    
+
-      InternalLogWriter securityLogWriter = (InternalLogWriter)this.system.getSecurityLogWriter();
+      InternalLogWriter securityLogWriter = (InternalLogWriter) this.system.getSecurityLogWriter();
-      boolean requireAuthentication = (certificateFilePath != null && certificateFilePath
-          .length() > 0);
+      boolean requireAuthentication =
+          (certificateFilePath != null && certificateFilePath.length() > 0);
-            .fine("HandShake: server authentication using digital "
-                + "signature required");
+            .fine("HandShake: server authentication using digital " + "signature required");
-      
+
-      if (acceptanceCode != REPLY_OK
-          && acceptanceCode != REPLY_AUTH_NOT_REQUIRED) {
+      if (acceptanceCode != REPLY_OK && acceptanceCode != REPLY_AUTH_NOT_REQUIRED) {
-      }
-      else 
-      if (acceptanceCode == REPLY_OK) {
+      } else if (acceptanceCode == REPLY_OK) {
-              LocalizedStrings.HandShake_HANDSHAKE_FAILED_TO_FIND_PUBLIC_KEY_FOR_SERVER_WITH_SUBJECT_0.toLocalizedString(subject));
+                LocalizedStrings.HandShake_HANDSHAKE_FAILED_TO_FIND_PUBLIC_KEY_FOR_SERVER_WITH_SUBJECT_0
+                    .toLocalizedString(subject));
-          
+
-          X509Certificate cert = (X509Certificate)certificateMap
-              .get(subject);
+          X509Certificate cert = (X509Certificate) certificateMap.get(subject);
-            throw new AuthenticationFailedException("Mismatch in client "
-                + "challenge bytes. Malicious server?");
+            throw new AuthenticationFailedException(
+                "Mismatch in client " + "challenge bytes. Malicious server?");
-          securityLogWriter.fine("HandShake: Successfully verified the "
-              + "digital signature from server");
+          securityLogWriter
+              .fine("HandShake: Successfully verified the " + "digital signature from server");
-        
+
-        //PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
+        // PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
-        
+
-          
-        //  byte[] encBytes = encrypt.doFinal(hdos.toByteArray());
-          byte[] encBytes = encryptBytes(hdos.toByteArray(), getEncryptCipher(dhSKAlgo, this.clientPublicKey));
+
+          // byte[] encBytes = encrypt.doFinal(hdos.toByteArray());
+          byte[] encBytes =
+              encryptBytes(hdos.toByteArray(), getEncryptCipher(dhSKAlgo, this.clientPublicKey));
-        }
-        finally {
+        } finally {
-    }
-    catch (IOException ex) {
+    } catch (IOException ex) {
-    }
-    catch (GemFireSecurityException ex) {
+    } catch (GemFireSecurityException ex) {
-    }
-    catch (Exception ex) {
-      throw new AuthenticationFailedException(
-          "HandShake failed in Diffie-Hellman key exchange", ex);
+    } catch (Exception ex) {
+      throw new AuthenticationFailedException("HandShake failed in Diffie-Hellman key exchange",
+          ex);
-   * This method writes what readCredential() method expects to read. (Note the
-   * use of singular credential). It is similar to writeCredentials(), except
-   * that it doesn't write credential-properties.
+   * This method writes what readCredential() method expects to read. (Note the use of singular
+   * credential). It is similar to writeCredentials(), except that it doesn't write
+   * credential-properties.
-  public byte writeCredential(DataOutputStream dos, DataInputStream dis,
-      String authInit, boolean isNotification, DistributedMember member, 
-      HeapDataOutputStream heapdos)
+  public byte writeCredential(DataOutputStream dos, DataInputStream dis, String authInit,
+      boolean isNotification, DistributedMember member, HeapDataOutputStream heapdos)
-    
+
-//      DataSerializer.writeProperties(p_credentials, heapdos);
+      // DataSerializer.writeProperties(p_credentials, heapdos);
-      InternalLogWriter securityLogWriter = (InternalLogWriter)this.system.getSecurityLogWriter();
+      InternalLogWriter securityLogWriter = (InternalLogWriter) this.system.getSecurityLogWriter();
-      boolean requireAuthentication = (certificateFilePath != null && certificateFilePath
-          .length() > 0);
+      boolean requireAuthentication =
+          (certificateFilePath != null && certificateFilePath.length() > 0);
-            .fine("HandShake: server authentication using digital "
-                + "signature required");
+            .fine("HandShake: server authentication using digital " + "signature required");
-      
+
-      if (acceptanceCode != REPLY_OK
-          && acceptanceCode != REPLY_AUTH_NOT_REQUIRED) {
+      if (acceptanceCode != REPLY_OK && acceptanceCode != REPLY_AUTH_NOT_REQUIRED) {
-      }
-      else 
-      if (acceptanceCode == REPLY_OK) {
+      } else if (acceptanceCode == REPLY_OK) {
-              LocalizedStrings.HandShake_HANDSHAKE_FAILED_TO_FIND_PUBLIC_KEY_FOR_SERVER_WITH_SUBJECT_0.toLocalizedString(subject));
+                LocalizedStrings.HandShake_HANDSHAKE_FAILED_TO_FIND_PUBLIC_KEY_FOR_SERVER_WITH_SUBJECT_0
+                    .toLocalizedString(subject));
-          
+
-          X509Certificate cert = (X509Certificate)certificateMap
-              .get(subject);
+          X509Certificate cert = (X509Certificate) certificateMap.get(subject);
-            throw new AuthenticationFailedException("Mismatch in client "
-                + "challenge bytes. Malicious server?");
+            throw new AuthenticationFailedException(
+                "Mismatch in client " + "challenge bytes. Malicious server?");
-          securityLogWriter.fine("HandShake: Successfully verified the "
-              + "digital signature from server");
+          securityLogWriter
+              .fine("HandShake: Successfully verified the " + "digital signature from server");
-        
+
-//        PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
+        // PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
-//          byte[] encBytes = encrypt.doFinal(hdos.toByteArray());
-          byte[] encBytes = encryptBytes(hdos.toByteArray(), getEncryptCipher(dhSKAlgo, this.clientPublicKey));
+          // byte[] encBytes = encrypt.doFinal(hdos.toByteArray());
+          byte[] encBytes =
+              encryptBytes(hdos.toByteArray(), getEncryptCipher(dhSKAlgo, this.clientPublicKey));
-        }
-        finally {
+        } finally {
-    }
-    catch (IOException ex) {
+    } catch (IOException ex) {
-    }
-    catch (GemFireSecurityException ex) {
+    } catch (GemFireSecurityException ex) {
-    }
-    catch (Exception ex) {
-      throw new AuthenticationFailedException(
-          "HandShake failed in Diffie-Hellman key exchange", ex);
+    } catch (Exception ex) {
+      throw new AuthenticationFailedException("HandShake failed in Diffie-Hellman key exchange",
+          ex);
-  public byte [] encryptBytes(byte[] data) throws Exception
-  {
-    if( this.appSecureMode == CREDENTIALS_DHENCRYPT) {
+  public byte[] encryptBytes(byte[] data) throws Exception {
+    if (this.appSecureMode == CREDENTIALS_DHENCRYPT) {
-  static public byte[] encryptBytes(byte[] data, Cipher encrypt)
-  throws Exception{
-    
-    
-    try{
-        byte[] encBytes = encrypt.doFinal(data);
-        return encBytes;
+  static public byte[] encryptBytes(byte[] data, Cipher encrypt) throws Exception {
+
+
+    try {
+      byte[] encBytes = encrypt.doFinal(data);
+      return encBytes;
-  private Cipher getEncryptCipher(String dhSKAlgo, PublicKey publicKey) 
-      throws Exception{
+  private Cipher getEncryptCipher(String dhSKAlgo, PublicKey publicKey) throws Exception {
-      if(_encrypt == null) {
+      if (_encrypt == null) {
-        
+
-        
+
-    
+
-        }
-        else {
+        } else {
-          
+
-          
+
-    }catch(Exception ex) {
+    } catch (Exception ex) {
-  
-//This assumes that authentication is the last piece of info in handshake
-  public Properties readCredential(DataInputStream dis, DataOutputStream dos, DistributedSystem system)
-      throws GemFireSecurityException, IOException {
+
+  // This assumes that authentication is the last piece of info in handshake
+  public Properties readCredential(DataInputStream dis, DataOutputStream dos,
+      DistributedSystem system) throws GemFireSecurityException, IOException {
-            LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-              .toLocalizedString());
+              LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED.toLocalizedString());
-      }
-      else if (secureMode == CREDENTIALS_NORMAL) {
+      } else if (secureMode == CREDENTIALS_NORMAL) {
-        /*if (requireAuthentication) {
-          credentials = DataSerializer.readProperties(dis);
-        }
-        else {
-          DataSerializer.readProperties(dis); // ignore the credentials
-        }*/
-      }
-      else if (secureMode == CREDENTIALS_DHENCRYPT) {
+        /*
+         * if (requireAuthentication) { credentials = DataSerializer.readProperties(dis); } else {
+         * DataSerializer.readProperties(dis); // ignore the credentials }
+         */
+      } else if (secureMode == CREDENTIALS_DHENCRYPT) {
-        InternalLogWriter securityLogWriter = (InternalLogWriter)system.getSecurityLogWriter();
+        InternalLogWriter securityLogWriter = (InternalLogWriter) system.getSecurityLogWriter();
-        //String skAlgo = DataSerializer.readString(dis);
+        // String skAlgo = DataSerializer.readString(dis);
-       // PublicKey pubKey = null;
+        // PublicKey pubKey = null;
-                LocalizedStrings.HandShake_SERVER_PRIVATE_KEY_NOT_AVAILABLE_FOR_CREATING_SIGNATURE.toLocalizedString());
+                  LocalizedStrings.HandShake_SERVER_PRIVATE_KEY_NOT_AVAILABLE_FOR_CREATING_SIGNATURE
+                      .toLocalizedString());
-            //DataSerializer.writeString(privateKeyAlias, dos);
+            // DataSerializer.writeString(privateKeyAlias, dos);
-          }
-          else {
+          } else {
-          Cipher c= getDecryptCipher(this.clientSKAlgo, this.clientPublicKey);
+          Cipher c = getDecryptCipher(this.clientSKAlgo, this.clientPublicKey);
-          //credentials = DataSerializer.readProperties(dinp);//Hitesh: we don't send in handshake now
+          // credentials = DataSerializer.readProperties(dinp);//Hitesh: we don't send in handshake
+          // now
-              LocalizedStrings.HandShake_MISMATCH_IN_CHALLENGE_BYTES_MALICIOUS_CLIENT
-                .toLocalizedString());
+                LocalizedStrings.HandShake_MISMATCH_IN_CHALLENGE_BYTES_MALICIOUS_CLIENT
+                    .toLocalizedString());
-        }
-        else {
+        } else {
-    }
-    catch (IOException ex) {
+    } catch (IOException ex) {
-    }
-    catch (GemFireSecurityException ex) {
+    } catch (GemFireSecurityException ex) {
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-        LocalizedStrings.HandShake_FAILURE_IN_READING_CREDENTIALS
-          .toLocalizedString(),
-        ex);
+          LocalizedStrings.HandShake_FAILURE_IN_READING_CREDENTIALS.toLocalizedString(), ex);
-  
-  public byte[] decryptBytes(byte[] data) throws Exception
-  {  
-    if( this.appSecureMode == CREDENTIALS_DHENCRYPT) {
+
+  public byte[] decryptBytes(byte[] data) throws Exception {
+    if (this.appSecureMode == CREDENTIALS_DHENCRYPT) {
-      Cipher c= getDecryptCipher(algo, this.clientPublicKey);
+      Cipher c = getDecryptCipher(algo, this.clientPublicKey);
-  
-  
-  
-  static public byte[] decryptBytes(byte[] data, Cipher decrypt)
-  throws Exception{
+
+
+
+  static public byte[] decryptBytes(byte[] data, Cipher decrypt) throws Exception {
-    }catch(Exception ex) {
+    } catch (Exception ex) {
-    }    
+    }
-  
+
-  
-  private Cipher getDecryptCipher( String dhSKAlgo, PublicKey publicKey)
-      throws Exception{
-      if(_decrypt == null) {
-        try {
-          KeyAgreement ka = KeyAgreement.getInstance("DH");
-          ka.init(dhPrivateKey);
-          ka.doPhase(publicKey, true);
-      
-          Cipher decrypt;
-          
-          int keysize = getKeySize(dhSKAlgo);
-          int blocksize = getBlockSize(dhSKAlgo);
-      
-          if (keysize == -1 || blocksize == -1) {
-            SecretKey sKey = ka.generateSecret(dhSKAlgo);
-            decrypt = Cipher.getInstance(dhSKAlgo);
-            decrypt.init(Cipher.DECRYPT_MODE, sKey);
-          }
-          else {
-            String algoStr = getDhAlgoStr(dhSKAlgo);
-            
-            byte[] sKeyBytes = ka.generateSecret();
-            SecretKeySpec sks = new SecretKeySpec(sKeyBytes, 0, keysize, algoStr);
-            IvParameterSpec ivps = new IvParameterSpec(sKeyBytes, keysize, blocksize);
-            
-            decrypt = Cipher.getInstance(algoStr + "/CBC/PKCS5Padding");
-            decrypt.init(Cipher.DECRYPT_MODE, sks, ivps);
-          }
-          
-          _decrypt = decrypt;
-          }catch(Exception ex) {
-            throw ex;
-          }            
+
+  private Cipher getDecryptCipher(String dhSKAlgo, PublicKey publicKey) throws Exception {
+    if (_decrypt == null) {
+      try {
+        KeyAgreement ka = KeyAgreement.getInstance("DH");
+        ka.init(dhPrivateKey);
+        ka.doPhase(publicKey, true);
+
+        Cipher decrypt;
+
+        int keysize = getKeySize(dhSKAlgo);
+        int blocksize = getBlockSize(dhSKAlgo);
+
+        if (keysize == -1 || blocksize == -1) {
+          SecretKey sKey = ka.generateSecret(dhSKAlgo);
+          decrypt = Cipher.getInstance(dhSKAlgo);
+          decrypt.init(Cipher.DECRYPT_MODE, sKey);
+        } else {
+          String algoStr = getDhAlgoStr(dhSKAlgo);
+
+          byte[] sKeyBytes = ka.generateSecret();
+          SecretKeySpec sks = new SecretKeySpec(sKeyBytes, 0, keysize, algoStr);
+          IvParameterSpec ivps = new IvParameterSpec(sKeyBytes, keysize, blocksize);
+
+          decrypt = Cipher.getInstance(algoStr + "/CBC/PKCS5Padding");
+          decrypt.init(Cipher.DECRYPT_MODE, sks, ivps);
+        }
+
+        _decrypt = decrypt;
+      } catch (Exception ex) {
+        throw ex;
-      return _decrypt;
+    }
+    return _decrypt;
+
-   * Populate the available server public keys into a local static HashMap. This
-   * method is not thread safe.
+   * Populate the available server public keys into a local static HashMap. This method is not
+   * thread safe.
-      char[] passPhrase = (keyStorePass != null ? keyStorePass.toCharArray()
-          : null);
+      char[] passPhrase = (keyStorePass != null ? keyStorePass.toCharArray() : null);
-      }
-      finally {
+      } finally {
-        String alias = (String)aliases.nextElement();
+        String alias = (String) aliases.nextElement();
-          String subject = ((X509Certificate)cert).getSubjectDN().getName();
+          String subject = ((X509Certificate) cert).getSubjectDN().getName();
-      char[] passPhrase = (keyStorePass != null ? keyStorePass.toCharArray()
-          : null);
+      char[] passPhrase = (keyStorePass != null ? keyStorePass.toCharArray() : null);
-      }
-      finally {
+      } finally {
-        privateKeyEncrypt = (PrivateKey)key;
-        privateKeySignAlgo = ((X509Certificate)keyCert).getSigAlgName();
-        privateKeySubject = ((X509Certificate)keyCert).getSubjectDN().getName();
+        privateKeyEncrypt = (PrivateKey) key;
+        privateKeySignAlgo = ((X509Certificate) keyCert).getSigAlgName();
+        privateKeySubject = ((X509Certificate) keyCert).getSubjectDN().getName();
-    if ((dhSKAlgo != null && dhSKAlgo.length() > 0)
-        || securityService.isClientSecurityRequired()) {
+    if ((dhSKAlgo != null && dhSKAlgo.length() > 0) || securityService.isClientSecurityRequired()) {
-  
+
-    }
-    else {
-      dos.writeByte(REPLY_OK);//byte 59
+    } else {
+      dos.writeByte(REPLY_OK);// byte 59
-    
-  //additional byte of wan site needs to send for Gateway BC
+
+    // additional byte of wan site needs to send for Gateway BC
-      Version.writeOrdinal(dos, ServerHandShakeProcessor.currentServerVersion.ordinal(),
-          true);
+      Version.writeOrdinal(dos, ServerHandShakeProcessor.currentServerVersion.ordinal(), true);
-    
+
-      dos.writeBoolean(((InternalDistributedSystem)this.system).getConfig()
-          .getDeltaPropagation());
+      dos.writeBoolean(((InternalDistributedSystem) this.system).getConfig().getDeltaPropagation());
-          
+
-    //on the remote side of the gateway
+    // on the remote side of the gateway
-      dos.writeByte(((InternalDistributedSystem)this.system)
-          .getDistributionManager().getDistributedSystemId());
+      dos.writeByte(((InternalDistributedSystem) this.system).getDistributionManager()
+          .getDistributedSystemId());
-    
-    if((communicationMode == Acceptor.GATEWAY_TO_GATEWAY) 
+
+    if ((communicationMode == Acceptor.GATEWAY_TO_GATEWAY)
-   * Return fake, temporary DistributedMember to represent the other vm this 
-   * vm is connecting to
+   * Return fake, temporary DistributedMember to represent the other vm this vm is connecting to
-    return new InternalDistributedMember(
-        sock.getInetAddress(), sock.getPort(), false);
+    return new InternalDistributedMember(sock.getInetAddress(), sock.getPort(), false);
-  public ServerQueueStatus greet(Connection conn, ServerLocation location, byte communicationMode) throws IOException,
-      AuthenticationRequiredException, AuthenticationFailedException,
+  public ServerQueueStatus greet(Connection conn, ServerLocation location, byte communicationMode)
+      throws IOException, AuthenticationRequiredException, AuthenticationFailedException,
-      // if running in a loner system, use the new port number in the ID to 
+      // if running in a loner system, use the new port number in the ID to
-      DM dm = ((InternalDistributedSystem)this.system).getDistributionManager();
+      DM dm = ((InternalDistributedSystem) this.system).getDistributionManager();
-      synchronized(idm) {
+      synchronized (idm) {
-          ((LonerDistributionManager)dm).updateLonerPort(port);
+          ((LonerDistributionManager) dm).updateLonerPort(port);
-      if(communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
+      if (communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
-      byte intermediateAcceptanceCode = write(dos, dis, communicationMode,
-          REPLY_OK, this.clientReadTimeout, null, this.credentials, member,
-          false);
-      
+      byte intermediateAcceptanceCode = write(dos, dis, communicationMode, REPLY_OK,
+          this.clientReadTimeout, null, this.credentials, member, false);
+
-      if (acceptanceCode == (byte)21 && !(sock instanceof SSLSocket)) {
+      if (acceptanceCode == (byte) 21 && !(sock instanceof SSLSocket)) {
-          LocalizedStrings.HandShake_SERVER_EXPECTING_SSL_CONNECTION
-          .toLocalizedString());
+            LocalizedStrings.HandShake_SERVER_EXPECTING_SSL_CONNECTION.toLocalizedString());
-      
-      //Successful handshake for GATEWAY_TO_GATEWAY mode sets the peer version in connection
-      if(communicationMode == Acceptor.GATEWAY_TO_GATEWAY  && !
-          (acceptanceCode == REPLY_EXCEPTION_AUTHENTICATION_REQUIRED ||
-          acceptanceCode ==  REPLY_EXCEPTION_AUTHENTICATION_FAILED)) {
+
+      // Successful handshake for GATEWAY_TO_GATEWAY mode sets the peer version in connection
+      if (communicationMode == Acceptor.GATEWAY_TO_GATEWAY
+          && !(acceptanceCode == REPLY_EXCEPTION_AUTHENTICATION_REQUIRED
+              || acceptanceCode == REPLY_EXCEPTION_AUTHENTICATION_FAILED)) {
-        // establish a versioned stream for the other site, if necessary         
+        // establish a versioned stream for the other site, if necessary
-      } 
+      }
-      serverQStatus = new ServerQueueStatus(epType, qSize,member);
+      serverQStatus = new ServerQueueStatus(epType, qSize, member);
-      //validate that the remote side has a different distributed system id.
+      // validate that the remote side has a different distributed system id.
-        int localDistributedSystemId = ((InternalDistributedSystem) system).getDistributionManager().getDistributedSystemId();
-        if(localDistributedSystemId >= 0 && localDistributedSystemId == remoteDistributedSystemId) {
+        int localDistributedSystemId =
+            ((InternalDistributedSystem) system).getDistributionManager().getDistributedSystemId();
+        if (localDistributedSystemId >= 0
+            && localDistributedSystemId == remoteDistributedSystemId) {
-              "Remote WAN site's distributed system id "
-                  + remoteDistributedSystemId
-                  + " matches this sites distributed system id "
-                  + localDistributedSystemId);
+              "Remote WAN site's distributed system id " + remoteDistributedSystemId
+                  + " matches this sites distributed system id " + localDistributedSystemId);
-      //Read the PDX registry size from the remote size
-      if(communicationMode == Acceptor.GATEWAY_TO_GATEWAY 
-          && Version.GFE_80.compareTo(conn.getWanSiteVersion()) <= 0 
+      // Read the PDX registry size from the remote size
+      if (communicationMode == Acceptor.GATEWAY_TO_GATEWAY
+          && Version.GFE_80.compareTo(conn.getWanSiteVersion()) <= 0
-    }
-    catch (IOException ex) {
+    } catch (IOException ex) {
-  public ServerQueueStatus greetNotifier(Socket sock, boolean isPrimary, ServerLocation location) throws IOException, AuthenticationRequiredException,
-      AuthenticationFailedException, ServerRefusedConnectionException, ClassNotFoundException {
+  public ServerQueueStatus greetNotifier(Socket sock, boolean isPrimary, ServerLocation location)
+      throws IOException, AuthenticationRequiredException, AuthenticationFailedException,
+      ServerRefusedConnectionException, ClassNotFoundException {
-      byte mode = isPrimary ? Acceptor.PRIMARY_SERVER_TO_CLIENT 
-              : Acceptor.SECONDARY_SERVER_TO_CLIENT;
-      write(dos, dis, mode, REPLY_OK, 0, new ArrayList(), this.credentials, 
-          member, true); 
-      
+      byte mode =
+          isPrimary ? Acceptor.PRIMARY_SERVER_TO_CLIENT : Acceptor.SECONDARY_SERVER_TO_CLIENT;
+      write(dos, dis, mode, REPLY_OK, 0, new ArrayList(), this.credentials, member, true);
+
-      if (acceptanceCode == (byte)21 && !(sock instanceof SSLSocket)) {
+      if (acceptanceCode == (byte) 21 && !(sock instanceof SSLSocket)) {
-            
+
-        Map.Entry instantiator = (Map.Entry)itr.next();
-        Integer id = (Integer)instantiator.getKey();
-        ArrayList instantiatorArguments = (ArrayList)instantiator.getValue();
-        InternalInstantiator.register((String)instantiatorArguments
-            .get(0), (String)instantiatorArguments.get(1), id, false);
+        Map.Entry instantiator = (Map.Entry) itr.next();
+        Integer id = (Integer) instantiator.getKey();
+        ArrayList instantiatorArguments = (ArrayList) instantiator.getValue();
+        InternalInstantiator.register((String) instantiatorArguments.get(0),
+            (String) instantiatorArguments.get(1), id, false);
-        Map.Entry dataSerializer = (Map.Entry)itr.next();
-        Integer id = (Integer)dataSerializer.getKey();
-        InternalDataSerializer.register((String)dataSerializer.getValue(),
-            false, null, null, id);
+        Map.Entry dataSerializer = (Map.Entry) itr.next();
+        Integer id = (Integer) dataSerializer.getKey();
+        InternalDataSerializer.register((String) dataSerializer.getValue(), false, null, null, id);
-      InternalDataSerializer.updateSupportedClassesMap(dsToSupportedClassNames);      
-   }
-    catch (IOException ex) {
+      InternalDataSerializer.updateSupportedClassesMap(dsToSupportedClassNames);
+    } catch (IOException ex) {
-    }
-    catch (ClassNotFoundException ex) {
+    } catch (ClassNotFoundException ex) {
-  public static DistributedMember readServerMember(DataInputStream p_dis, ServerLocation serverLocation) throws IOException {
+  public static DistributedMember readServerMember(DataInputStream p_dis,
+      ServerLocation serverLocation) throws IOException {
-      InternalDistributedMember ids = (InternalDistributedMember)DataSerializer.readObject(dis);
+      InternalDistributedMember ids = (InternalDistributedMember) DataSerializer.readObject(dis);
-    }
-    catch (EOFException e) {
+    } catch (EOFException e) {
-    }
-    catch (Exception e) {
-      throw new InternalGemFireException(LocalizedStrings.HandShake_UNABLE_TO_DESERIALIZE_MEMBER.toLocalizedString(), e);
+    } catch (Exception e) {
+      throw new InternalGemFireException(
+          LocalizedStrings.HandShake_UNABLE_TO_DESERIALIZE_MEMBER.toLocalizedString(), e);
-  protected void readMessage(DataInputStream dis, DataOutputStream dos, byte acceptanceCode, DistributedMember member)
-      throws IOException, AuthenticationRequiredException,
+  protected void readMessage(DataInputStream dis, DataOutputStream dos, byte acceptanceCode,
+      DistributedMember member) throws IOException, AuthenticationRequiredException,
-        throw new ServerRefusedConnectionException(member,
-            message);
+        throw new ServerRefusedConnectionException(member, message);
-        throw new ServerRefusedConnectionException(member,
-            message);
+        throw new ServerRefusedConnectionException(member, message);
-  public byte getCode()
-  {
+  public byte getCode() {
-  public boolean isRead()
-  {
+  public boolean isRead() {
-  public boolean isOK()
-  {
+  public boolean isOK() {
-  
+
-   * @param  other  the reference object with which to compare.
-   * @return true if this object is the same as the obj argument;
-   *         false otherwise.
+   * @param other the reference object with which to compare.
+   * @return true if this object is the same as the obj argument; false otherwise.
-    if (other == this) return true;
-//    if (other == null) return false;
-    if (!(other instanceof HandShake)) return  false;
-    final HandShake that = (HandShake) other;
-    
-    /*if (identity != null && identity.length > 0) {
-     for (int i = 0; i < identity.length; i++) {
-     if (this.identity[i] != that.identity[i]) return false;
-     }
-     }
-     if (this.code != that.code) return false;
-     return true;*/
-    
-    if(this.id.isSameDSMember(that.id) && this.code ==that.code) {
+    if (other == this)
-    }
-    else {
+    // if (other == null) return false;
+    if (!(other instanceof HandShake))
+      return false;
+    final HandShake that = (HandShake) other;
+
+    /*
+     * if (identity != null && identity.length > 0) { for (int i = 0; i < identity.length; i++) { if
+     * (this.identity[i] != that.identity[i]) return false; } } if (this.code != that.code) return
+     * false; return true;
+     */
+
+    if (this.id.isSameDSMember(that.id) && this.code == that.code) {
+      return true;
+    } else {
-  
-  
+
+
-   * Returns a hash code for the object. This method is supported for the
-   * benefit of hashtables such as those provided by java.util.Hashtable.
+   * Returns a hash code for the object. This method is supported for the benefit of hashtables such
+   * as those provided by java.util.Hashtable.
-    
-    /*if (this.identity != null && this.identity.length > 0) {
-     for (int i = 0; i < this.identity.length; i++) {
-     result = mult * result + (int) this.identity[i];
-     }
-     }*/
+
+    /*
+     * if (this.identity != null && this.identity.length > 0) { for (int i = 0; i <
+     * this.identity.length; i++) { result = mult * result + (int) this.identity[i]; } }
+     */
-    
+
-  
+
-    StringBuffer buf = new StringBuffer()
-      .append("HandShake@")
-      .append(System.identityHashCode(this))
-      .append(" code: ")
-      .append(this.code);
+    StringBuffer buf = new StringBuffer().append("HandShake@").append(System.identityHashCode(this))
+        .append(" code: ").append(this.code);
-      /*for(int i=0; i<this.identity.length; ++i) {
-        buf.append(this.identity[i]);
-      }*/
-      buf.append(this.id.toString());     
+      /*
+       * for(int i=0; i<this.identity.length; ++i) { buf.append(this.identity[i]); }
+       */
+      buf.append(this.id.toString());
-  
+
-  public static Properties getCredentials(String authInitMethod,
-      Properties securityProperties, DistributedMember server, boolean isPeer,
-      InternalLogWriter logWriter, InternalLogWriter securityLogWriter)
-      throws AuthenticationRequiredException {
+  public static Properties getCredentials(String authInitMethod, Properties securityProperties,
+      DistributedMember server, boolean isPeer, InternalLogWriter logWriter,
+      InternalLogWriter securityLogWriter) throws AuthenticationRequiredException {
-    if (StringUtils.isBlank(authInitMethod)){
+    if (StringUtils.isBlank(authInitMethod)) {
-      }
-      finally {
+      } finally {
-    }
-    catch (GemFireSecurityException ex) {
+    } catch (GemFireSecurityException ex) {
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-          LocalizedStrings.HandShake_FAILED_TO_ACQUIRE_AUTHINITIALIZE_METHOD_0.toLocalizedString(authInitMethod), ex);
+          LocalizedStrings.HandShake_FAILED_TO_ACQUIRE_AUTHINITIALIZE_METHOD_0
+              .toLocalizedString(authInitMethod),
+          ex);
-    return getCredentials(authInitMethod, this.system.getSecurityProperties(),
-        member, false, (InternalLogWriter)this.system.getLogWriter(), 
-        (InternalLogWriter)this.system.getSecurityLogWriter());
+    return getCredentials(authInitMethod, this.system.getSecurityProperties(), member, false,
+        (InternalLogWriter) this.system.getLogWriter(),
+        (InternalLogWriter) this.system.getSecurityLogWriter());
-  public static Properties readCredentials(DataInputStream dis,
-      DataOutputStream dos, DistributedSystem system)
-      throws GemFireSecurityException, IOException {
+  public static Properties readCredentials(DataInputStream dis, DataOutputStream dos,
+      DistributedSystem system) throws GemFireSecurityException, IOException {
-            LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-              .toLocalizedString());
+              LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED.toLocalizedString());
-      }
-      else if (secureMode == CREDENTIALS_NORMAL) {
+      } else if (secureMode == CREDENTIALS_NORMAL) {
-        }
-        else {
+        } else {
-      }
-      else if (secureMode == CREDENTIALS_DHENCRYPT) {
+      } else if (secureMode == CREDENTIALS_DHENCRYPT) {
-        InternalLogWriter securityLogWriter = (InternalLogWriter)system.getSecurityLogWriter();
+        InternalLogWriter securityLogWriter = (InternalLogWriter) system.getSecurityLogWriter();
-                LocalizedStrings.HandShake_SERVER_PRIVATE_KEY_NOT_AVAILABLE_FOR_CREATING_SIGNATURE.toLocalizedString());
+                  LocalizedStrings.HandShake_SERVER_PRIVATE_KEY_NOT_AVAILABLE_FOR_CREATING_SIGNATURE
+                      .toLocalizedString());
-            //DataSerializer.writeString(privateKeyAlias, dos);
+            // DataSerializer.writeString(privateKeyAlias, dos);
-          }
-          else {
+          } else {
-          
+
-          }
-          else {
+          } else {
-            
+
-            
+
-          
+
-              LocalizedStrings.HandShake_MISMATCH_IN_CHALLENGE_BYTES_MALICIOUS_CLIENT
-                .toLocalizedString());
+                LocalizedStrings.HandShake_MISMATCH_IN_CHALLENGE_BYTES_MALICIOUS_CLIENT
+                    .toLocalizedString());
-        }
-        else {
+        } else {
-      }else if (secureMode == SECURITY_MULTIUSER_NOTIFICATIONCHANNEL)
-      {
-        // hitesh there will be no credential CCP will get credential(Principal) using ServerConnection..
+      } else if (secureMode == SECURITY_MULTIUSER_NOTIFICATIONCHANNEL) {
+        // hitesh there will be no credential CCP will get credential(Principal) using
+        // ServerConnection..
-    }
-    catch (IOException ex) {
+    } catch (IOException ex) {
-    }
-    catch (GemFireSecurityException ex) {
+    } catch (GemFireSecurityException ex) {
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-        LocalizedStrings.HandShake_FAILURE_IN_READING_CREDENTIALS
-          .toLocalizedString(),
-        ex);
+          LocalizedStrings.HandShake_FAILURE_IN_READING_CREDENTIALS.toLocalizedString(), ex);
-   * this could return either a Subject or a Principal depending on if it's integrated security or not
+   * this could return either a Subject or a Principal depending on if it's integrated security or
+   * not
-  public static Object verifyCredentials(String authenticatorMethod,
-      Properties credentials, Properties securityProperties, InternalLogWriter logWriter,
+  public static Object verifyCredentials(String authenticatorMethod, Properties credentials,
+      Properties securityProperties, InternalLogWriter logWriter,
-      if(AcceptorImpl.isIntegratedSecurity()){
+      if (AcceptorImpl.isIntegratedSecurity()) {
-      }
-      else {
+      } else {
-    }
-    catch(AuthenticationFailedException ex){
+    } catch (AuthenticationFailedException ex) {
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-    }
-    finally {
-      if(auth!=null) auth.close();
+    } finally {
+      if (auth != null)
+        auth.close();
-  public Object verifyCredentials() throws AuthenticationRequiredException,
-      AuthenticationFailedException {
+  public Object verifyCredentials()
+      throws AuthenticationRequiredException, AuthenticationFailedException {
-    String methodName = this.system.getProperties().getProperty(
-        SECURITY_CLIENT_AUTHENTICATOR);
-    return verifyCredentials(methodName, this.credentials, this.system
-        .getSecurityProperties(), (InternalLogWriter)this.system.getLogWriter(), (InternalLogWriter)this.system
-        .getSecurityLogWriter(), this.id.getDistributedMember());
+    String methodName = this.system.getProperties().getProperty(SECURITY_CLIENT_AUTHENTICATOR);
+    return verifyCredentials(methodName, this.credentials, this.system.getSecurityProperties(),
+        (InternalLogWriter) this.system.getLogWriter(),
+        (InternalLogWriter) this.system.getSecurityLogWriter(), this.id.getDistributedMember());
-  private void checkIfAuthenticWanSite(DataInputStream dis,
-      DataOutputStream dos, DistributedMember member)
-      throws GemFireSecurityException, IOException {
+  private void checkIfAuthenticWanSite(DataInputStream dis, DataOutputStream dos,
+      DistributedMember member) throws GemFireSecurityException, IOException {
-    String authenticator = this.system.getProperties().getProperty(
-        SECURITY_CLIENT_AUTHENTICATOR);
+    String authenticator = this.system.getProperties().getProperty(SECURITY_CLIENT_AUTHENTICATOR);
-    verifyCredentials(authenticator, peerWanProps, this.system
-        .getSecurityProperties(), (InternalLogWriter)this.system.getLogWriter(), (InternalLogWriter)this.system
-        .getSecurityLogWriter(), member);
+    verifyCredentials(authenticator, peerWanProps, this.system.getSecurityProperties(),
+        (InternalLogWriter) this.system.getLogWriter(),
+        (InternalLogWriter) this.system.getSecurityLogWriter(), member);
-    }
-    else {
+    } else {
-    }
-    else if (algoStr.equalsIgnoreCase("Blowfish")) {
+    } else if (algoStr.equalsIgnoreCase("Blowfish")) {
-    }
-    else if (algoStr.equalsIgnoreCase("AES")) {
-      keysize = (algoKeySize != 192 && algoKeySize != 256) ? 16
-          : algoKeySize / 8;
+    } else if (algoStr.equalsIgnoreCase("AES")) {
+      keysize = (algoKeySize != 192 && algoKeySize != 256) ? 16 : algoKeySize / 8;
-  
+
-    }
-    else {
+    } else {
-  
+
-    }
-    else if (algoStr.equalsIgnoreCase("Blowfish")) {
+    } else if (algoStr.equalsIgnoreCase("Blowfish")) {
-    }
-    else if (algoStr.equalsIgnoreCase("AES")) {
+    } else if (algoStr.equalsIgnoreCase("AES")) {
-  
+

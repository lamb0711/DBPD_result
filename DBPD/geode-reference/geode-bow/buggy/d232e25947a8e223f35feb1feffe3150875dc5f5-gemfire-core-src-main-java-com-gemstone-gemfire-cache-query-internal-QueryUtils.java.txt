GEODE-730: Optimize single filter join queries

When executing a join query with additional filters on a single region, we now detect this scenario and
instead of creating a CompositeGroupJunction, we create a regular GroupJunction.  When we being cutdown
and expansion, we then create new compiled comparisons so that we can do an index lookup.

For example "select * from /region1 a, /region2 b where a.name = "joe" and a.id = b.id"
We will now execute the a.name first assuming an index is present on a.name

During cutdown and expand, we determine that the comparison a.id = b.id can create a new compiled comparison
because the alias a from a.id matches our original filter a.name.  We can evaluate a.id at this point, say id
evaluated to 8.  So we create a compiled comparison of b.id = 8.  We can now do a lookup using the index on b.id.
We retrieve these results and place them into a map.  This map will be used to continue to derive additional joins
if they exist.  Such as b.id = c.id, etc...

We can continue with the iteration but instead of iterating the entire b region, we can now go over derived results.

This also includes a fix to not unlock an index lock when reevaluating an inner query.

+import java.util.Map;
+import com.gemstone.gemfire.cache.query.internal.index.IndexManager;
-import com.gemstone.gemfire.internal.logging.log4j.LocalizedMessage;
-              finalItrs, expansionListIterator, context, iterOps, limit);
+              finalItrs, expansionListIterator, context, iterOps, limit, null);
-      List checkList, CompiledValue iterOps) throws FunctionDomainException,
+      List checkList, CompiledValue iterOps, IndexInfo theFilteringIndex) throws FunctionDomainException,
-        expansionList, finalItrs, context, checkList, iterOps);
+        expansionList, finalItrs, context, checkList, iterOps, theFilteringIndex);
-      List checkList, CompiledValue iterOps) throws FunctionDomainException,
+      List checkList, CompiledValue iterOps, IndexInfo theFilteringIndex) throws FunctionDomainException,
+      DerivedInfo derivedInfo = null;
+      if (IndexManager.JOIN_OPTIMIZATION) {
+        derivedInfo = new DerivedInfo();
+        derivedInfo.setExpansionList(expansionList);
+      }
-       
+        if (IndexManager.JOIN_OPTIMIZATION) {
+          derivedInfo.computeDerivedJoinResults(theFilteringIndex, context, iterOps);
+        }  
-            finalItrs, expansionListIterator, context, iterOps, limit);
+            finalItrs, expansionListIterator, context, iterOps, limit, derivedInfo.derivedResults);
+  
+  public static CompiledID getCompiledIdFromPath(CompiledValue path) {
+    int type = path.getType();
+    if (type == OQLLexerTokenTypes.Identifier) {
+      return (CompiledID) path;
+    } 
+    return getCompiledIdFromPath(path.getReceiver());
+  }
-      ExecutionContext context, CompiledValue iterOps, int limit)
+      ExecutionContext context, CompiledValue iterOps, int limit, Map<String, SelectResults> derivedResults)
-      SelectResults c = currentLevel.evaluateCollection(context);
+      SelectResults c = null;
+      // Calculate the key to find the derived join results. If we are a non nested lookup it will be a Compiled Region otherwise it will be a CompiledPath that
+      // we can extract the id from. In the end the result will be the alias which is used as a prefix
+      CompiledValue collectionExpression = currentLevel.getCmpIteratorDefn().getCollectionExpr();
+      String key = null;
+      boolean useDerivedResults = true;
+      if (currentLevel.getCmpIteratorDefn().getCollectionExpr().getType() == OQLLexerTokenTypes.RegionPath) {
+        key = currentLevel.getCmpIteratorDefn().getName() + ":" + currentLevel.getDefinition();
+      } else if (currentLevel.getCmpIteratorDefn().getCollectionExpr().getType() == OQLLexerTokenTypes.LITERAL_select) {
+        useDerivedResults = false;
+      } else {
+        key = getCompiledIdFromPath(currentLevel.getCmpIteratorDefn().getCollectionExpr()).getId() + ":" + currentLevel.getDefinition();
+      }
+      if (useDerivedResults && derivedResults != null && derivedResults.containsKey(key)) {
+        c = derivedResults.get(key);
+      } else {
+        c = currentLevel.evaluateCollection(context);
+      }
-            finalItrs, expansionItrs, context, iterOps, limit);
+            finalItrs, expansionItrs, context, iterOps, limit, derivedResults);
-            context, ich.checkList, iterOperands);
+            context, ich.checkList, iterOperands, indexInfo);
-              context, ich.checkList, iterOperands);
+              context, ich.checkList, iterOperands, indexInfo);
-              context, singleUsableICH.checkList, iterOperands);
+              context, singleUsableICH.checkList, iterOperands, singleUsableICH.indxInfo);
-        (List) dataList.get(5), null);
+        (List) dataList.get(5), null, null);

GEODE-2253 Locator may fail to respond to a valid request

This introduces a retry loop in the locator when a handler for an
incoming message can't be found.  It waits for an amount of time
for the handler to be installed, which I've set to the locator-
wait-time or 5 seconds if that property hasn't been set.

I've also changed InternalLocator to always install the handler
for cluster configuration status so that you can query any locator
to see if it has a cluster configuration service and, if so, what
state it's in.

-      slocator.handler.willHaveServerLocator = true;
+  public PrimaryHandler getPrimaryHandler() {
+    return this.handler;
+  }
+
-  private static class PrimaryHandler implements TcpHandler {
+  public static class PrimaryHandler implements TcpHandler {
-    boolean willHaveServerLocator; // flag to avoid warning about missing handlers during startup
+    // GEODE-2253 test condition
+    private boolean hasWaitedForHandlerInitialization = false;
-      TcpHandler handler = null;
-      if (request instanceof PeerLocatorRequest) {
-        handler = (TcpHandler) handlerMapping.get(PeerLocatorRequest.class);
-      } else {
-        handler = (TcpHandler) handlerMapping.get(request.getClass());
-      }
-
-      if (handler != null) {
-        Object result;
-        result = handler.processRequest(request);
-        return result;
-      } else {
-        Object response;
-        if (locatorListener != null) {
-          response = locatorListener.handleRequest(request);
+      long giveup = 0;
+      while (giveup == 0 || System.currentTimeMillis() < giveup) {
+        TcpHandler handler = null;
+        if (request instanceof PeerLocatorRequest) {
+          handler = (TcpHandler) handlerMapping.get(PeerLocatorRequest.class);
-          if (!(willHaveServerLocator && (request instanceof ServerLocationRequest))) {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.InternalLocator_EXPECTED_ONE_OF_THESE_0_BUT_RECEIVED_1,
-                new Object[] {handlerMapping.keySet(), request}));
-          }
-          return null;
+          handler = (TcpHandler) handlerMapping.get(request.getClass());
-        return response;
-      }
+
+        if (handler != null) {
+          return handler.processRequest(request);
+        } else {
+          if (locatorListener != null) {
+            return locatorListener.handleRequest(request);
+          } else {
+            // either there is a configuration problem or the locator is still starting up
+            if (giveup == 0) {
+              int locatorWaitTime = internalLocator.getConfig().getLocatorWaitTime();
+              if (locatorWaitTime <= 0) {
+                locatorWaitTime = 30; // always retry some number of times
+              }
+              hasWaitedForHandlerInitialization = true;
+              giveup = System.currentTimeMillis() + (locatorWaitTime * 1000);
+              try {
+                Thread.sleep(1000);
+              } catch (InterruptedException e) {
+                // running in an executor - no need to set the interrupted flag on the thread
+                return null;
+              }
+            }
+          }
+        }
+      } // while
+      logger.info(
+          "Received a location request of class {} but the handler for this is "
+              + "either not enabled or is not ready to process requests",
+          request.getClass().getSimpleName());
+      return null;
+    }
+
+    /**
+     * GEODE-2253 test condition - has this handler waited for a subordinate handler to be
+     * installed?
+     */
+    public boolean hasWaitedForHandlerInitialization() {
+      return hasWaitedForHandlerInitialization;
+    installSharedConfigHandler();
-        logger.info("Cluster configuration service is only supported in dedicated locators");
+        logger.info("Cluster configuration service not enabled as it is only supported "
+            + "in dedicated locators");
-      this.isSharedConfigurationStarted = true;
-      installSharedConfigStatus();
-  public void installSharedConfigStatus() {
+  public void installSharedConfigHandler() {
+  public boolean hasHandlerForClass(Class messageClass) {
+    return (handler.isHandled(messageClass));
+  }
+

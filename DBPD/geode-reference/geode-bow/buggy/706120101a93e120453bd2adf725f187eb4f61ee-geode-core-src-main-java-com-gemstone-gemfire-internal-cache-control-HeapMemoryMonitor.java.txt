GEODE-1377: Initial move of system properties from private to public

-import java.lang.management.ManagementFactory;
-import java.lang.management.MemoryMXBean;
-import java.lang.management.MemoryPoolMXBean;
-import java.lang.management.MemoryType;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-
-import javax.management.ListenerNotFoundException;
-import javax.management.Notification;
-import javax.management.NotificationEmitter;
-import javax.management.NotificationListener;
-
-import org.apache.logging.log4j.Logger;
-
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import org.apache.logging.log4j.Logger;
+
+import javax.management.ListenerNotFoundException;
+import javax.management.Notification;
+import javax.management.NotificationEmitter;
+import javax.management.NotificationListener;
+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryMXBean;
+import java.lang.management.MemoryPoolMXBean;
+import java.lang.management.MemoryType;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.*;
-  private static final String HEAP_POOL = System.getProperty("gemfire.ResourceManager.HEAP_POOL");
+  private static final String HEAP_POOL = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "ResourceManager.HEAP_POOL");
-  public static final String POLLER_INTERVAL_PROP = "gemfire.heapPollerInterval";
+  public static final String POLLER_INTERVAL_PROP = DistributionConfig.GEMFIRE_PREFIX + "heapPollerInterval";
-  
-  private volatile MemoryThresholds thresholds = new MemoryThresholds(tenuredPoolMaxMemory);
-  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED,
-      MemoryState.DISABLED, null, 0L, true, this.thresholds);
-  private volatile MemoryState currentState = MemoryState.DISABLED;
-
-  //Set when startMonitoring() and stopMonitoring() are called
-  private Boolean started = false;
-  
-  // Set to true when setEvictionThreshold(...) is called.
-  private boolean hasEvictionThreshold = false;
-  
-   // Only change state when these counters exceed {@link HeapMemoryMonitor#memoryStateChangeTolerance}
-  private int criticalToleranceCounter;
-  private int evictionToleranceCounter;
-  
-  private final InternalResourceManager resourceManager;
-  private final ResourceAdvisor resourceAdvisor;
-  private final GemFireCacheImpl cache;
-  private final ResourceManagerStats stats;
-  
-  private static boolean testDisableMemoryUpdates = false;
-  private static long testBytesUsedForThresholdSet = -1;
-      memoryStateChangeTolerance = Integer.getInteger("gemfire.memoryEventTolerance",1);
+      memoryStateChangeTolerance = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 1);
-      memoryStateChangeTolerance = Integer.getInteger("gemfire.memoryEventTolerance",5);
+      memoryStateChangeTolerance = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 5);
-    
+
-  
- // Calculated value for the amount of JVM tenured heap memory available.
- private static final long tenuredPoolMaxMemory;
+  // Calculated value for the amount of JVM tenured heap memory available.
+  private static final long tenuredPoolMaxMemory;
- static {
-   if (tenuredMemoryPoolMXBean != null && tenuredMemoryPoolMXBean.getUsage().getMax() != -1) {
-     tenuredPoolMaxMemory = tenuredMemoryPoolMXBean.getUsage().getMax();
-   } else {
-     long calculatedMaxMemory = Runtime.getRuntime().maxMemory();
-     List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
-     for (MemoryPoolMXBean p : pools) {
-       if (p.getType() == MemoryType.HEAP && p.getUsage().getMax() != -1) {
-         calculatedMaxMemory -= p.getUsage().getMax();
-       }
-     }
-     tenuredPoolMaxMemory = calculatedMaxMemory;
-   }
- }
+  static {
+    if (tenuredMemoryPoolMXBean != null && tenuredMemoryPoolMXBean.getUsage().getMax() != -1) {
+      tenuredPoolMaxMemory = tenuredMemoryPoolMXBean.getUsage().getMax();
+    } else {
+      long calculatedMaxMemory = Runtime.getRuntime().maxMemory();
+      List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
+      for (MemoryPoolMXBean p : pools) {
+        if (p.getType() == MemoryType.HEAP && p.getUsage().getMax() != -1) {
+          calculatedMaxMemory -= p.getUsage().getMax();
+        }
+      }
+      tenuredPoolMaxMemory = calculatedMaxMemory;
+    }
+  }
+
+  private volatile MemoryThresholds thresholds = new MemoryThresholds(tenuredPoolMaxMemory);
+  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED,
+      MemoryState.DISABLED, null, 0L, true, this.thresholds);
+  private volatile MemoryState currentState = MemoryState.DISABLED;
+
+  //Set when startMonitoring() and stopMonitoring() are called
+  private Boolean started = false;
+
+  // Set to true when setEvictionThreshold(...) is called.
+  private boolean hasEvictionThreshold = false;
+
+  // Only change state when these counters exceed {@link HeapMemoryMonitor#memoryStateChangeTolerance}
+  private int criticalToleranceCounter;
+  private int evictionToleranceCounter;
+
+  private final InternalResourceManager resourceManager;
+  private final ResourceAdvisor resourceAdvisor;
+  private final GemFireCacheImpl cache;
+  private final ResourceManagerStats stats;
+
+  private static boolean testDisableMemoryUpdates = false;
+  private static long testBytesUsedForThresholdSet = -1;
+
+
+
+
+

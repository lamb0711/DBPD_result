Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The execute  method of this class is synchronized to
- * prevent two ops from using the client to server connection
- *  at the same time.
+ * The execute method of this class is synchronized to prevent two ops from using the client to
+ * server connection at the same time.
+ * 
-  
+
-  
-  /**Test hook to simulate a client crashing. If true, we will
-   * not notify the server when we close the connection.
+
+  /**
+   * Test hook to simulate a client crashing. If true, we will not notify the server when we close
+   * the connection.
-  
+
-//  private int handShakeTimeout = AcceptorImpl.DEFAULT_HANDSHAKE_TIMEOUT_MS;
+  // private int handShakeTimeout = AcceptorImpl.DEFAULT_HANDSHAKE_TIMEOUT_MS;
-  private short wanSiteVersion = -1;//In Gateway communication version of connected wan site
-                                   //will be stored after successful handshake
-//  private final CancelCriterion cancelCriterion;
+  private short wanSiteVersion = -1;// In Gateway communication version of connected wan site
+                                    // will be stored after successful handshake
+  // private final CancelCriterion cancelCriterion;
-//    this.cancelCriterion = cancelCriterion;
+    // this.cancelCriterion = cancelCriterion;
-  
-  public ServerQueueStatus connect(EndpointManager endpointManager,
-      ServerLocation location, HandShake handShake, int socketBufferSize,
-      int handShakeTimeout, int readTimeout, byte communicationMode, GatewaySender sender, SocketCreator sc)
-      throws IOException {
-    theSocket = sc.connectForClient(
-        location.getHostName(), location.getPort(), handShakeTimeout, socketBufferSize);
+
+  public ServerQueueStatus connect(EndpointManager endpointManager, ServerLocation location,
+      HandShake handShake, int socketBufferSize, int handShakeTimeout, int readTimeout,
+      byte communicationMode, GatewaySender sender, SocketCreator sc) throws IOException {
+    theSocket = sc.connectForClient(location.getHostName(), location.getPort(), handShakeTimeout,
+        socketBufferSize);
-    //System.out.println("ConnectionImpl setting buffer sizes: " +
+    // System.out.println("ConnectionImpl setting buffer sizes: " +
-    
+
-      commBufferForAsyncRead = ServerConnection
-          .allocateCommBuffer(socketBufferSize, theSocket);
+      commBufferForAsyncRead = ServerConnection.allocateCommBuffer(socketBufferSize, theSocket);
-    //logger.warning("ESTABLISHING ENDPOINT:"+location+" MEMBERID:"+endpoint.getMemberId(),new Exception());
+    // logger.warning("ESTABLISHING ENDPOINT:"+location+" MEMBERID:"+endpoint.getMemberId(),new
+    // Exception());
-  
+
-    
+
-          ((InternalDistributedSystem)ds).getDistributionManager();
-        }
-        catch (CancelException e) { // distribution has stopped
+          ((InternalDistributedSystem) ds).getDistributionManager();
+        } catch (CancelException e) { // distribution has stopped
-      
+
-    }
-    finally {
+    } finally {
-  
+
-      //ignore
+      // ignore
-      //ignore
+      // ignore
-  
+
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-  
+
-  
+
-  
+
-  
+
-  
+
-    // as the same connection is being used 
-    if ((op instanceof AbstractOp) && ((AbstractOp)op).isGatewaySenderOp()) {
+    // as the same connection is being used
+    if ((op instanceof AbstractOp) && ((AbstractOp) op).isGatewaySenderOp()) {
-      if (op instanceof ExecuteFunctionOpImpl
-          || op instanceof ExecuteRegionFunctionOpImpl
+      if (op instanceof ExecuteFunctionOpImpl || op instanceof ExecuteRegionFunctionOpImpl
-  
-  
+
+
-    //do nothing
+    // do nothing
-  public short getWanSiteVersion(){
+
+  public short getWanSiteVersion() {
-  
-  public void setWanSiteVersion(short wanSiteVersion){
+
+  public void setWanSiteVersion(short wanSiteVersion) {
-  
+
-    return ((InternalDistributedSystem)this.ds).getDistributionManager().getDistributedSystemId();
+    return ((InternalDistributedSystem) this.ds).getDistributionManager().getDistributedSystemId();
-  
+
-  
+
-      logger.info(LocalizedMessage.create(LocalizedStrings.Connection_SOCKET_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
-          new Object[] { new StringBuilder(type).append(" buffer size").toString(), actualBufferSize, requestedBufferSize }));
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.Connection_SOCKET_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
+          new Object[] {new StringBuilder(type).append(" buffer size").toString(), actualBufferSize,
+              requestedBufferSize}));

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Pattern;
+
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
+
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.CacheFactory;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
-import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.regex.Pattern;
-import javax.management.MBeanServer;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectName;
+
+  /**
+   * TODO: method createRegion is too complex to analyze
+   */
-      Cache cache = CacheFactory.getAnyInstance();
+      InternalCache cache = getCache();
-            cacheWriter != null ? cacheWriter : regionAttributesResult.getCacheWriterClass();;
+            cacheWriter != null ? cacheWriter : regionAttributesResult.getCacheWriterClass();
-
-
-  public boolean verifyDistributedRegionMbean(Cache cache, String regionName) {
-    GemFireCacheImpl gemfireCache = (GemFireCacheImpl) cache;
+  public boolean verifyDistributedRegionMbean(InternalCache cache, String regionName) {
-        gemfireCache.getInternalDistributedSystem().getConfig().getJmxManagerUpdateRate();
+        cache.getInternalDistributedSystem().getConfig().getJmxManagerUpdateRate();
-      Cache cache = CacheFactory.getAnyInstance();
+      InternalCache cache = getCache();
-  private static boolean regionExists(Cache cache, String regionPath) {
+  private static boolean regionExists(InternalCache cache, String regionPath) {
-  private void validateRegionPathAndParent(Cache cache, String regionPath) {
+  private void validateRegionPathAndParent(InternalCache cache, String regionPath) {
-
-  private void validateGroups(Cache cache, String[] groups) {
+  private void validateGroups(InternalCache cache, String[] groups) {
-  private void validateRegionFunctionArgs(Cache cache, RegionFunctionArgs regionFunctionArgs) {
+  private void validateRegionFunctionArgs(InternalCache cache,
+      RegionFunctionArgs regionFunctionArgs) {
-      // Validation for the following is not known yet
-      // if (partitionArgs.isSetPRTotalNumBuckets()) {
-      // int prTotalNumBuckets = partitionArgs.getPrTotalNumBuckets();
-      // }
-      // if (partitionArgs.isSetPRStartupRecoveryDelay()) {
-      // long prStartupRecoveryDelay = partitionArgs.getPrStartupRecoveryDelay();
-      // }
-      // if (partitionArgs.isSetPRRecoveryDelay()) {
-      // long prRecoveryDelay = partitionArgs.getPrRecoveryDelay();
-      // }
-  private boolean diskStoreExists(Cache cache, String diskStoreName) {
+  private boolean diskStoreExists(InternalCache cache, String diskStoreName) {
-  private static <K, V> FetchRegionAttributesFunctionResult<K, V> getRegionAttributes(Cache cache,
-      String regionPath) {
-    if (!isClusterwideSameConfig(cache, regionPath)) {
+  private static <K, V> FetchRegionAttributesFunctionResult<K, V> getRegionAttributes(
+      InternalCache cache, String regionPath) {
+    if (!isClusterWideSameConfig(cache, regionPath)) {
-  private static boolean isClusterwideSameConfig(Cache cache, String regionPath) {
+  private static boolean isClusterWideSameConfig(InternalCache cache, String regionPath) {
-      Cache cache = CacheFactory.getAnyInstance();
+      InternalCache cache = getCache();
-          new Object[] {regionPath, /* subRegionMessage */""});
+          new Object[] {regionPath, ""});
-  private Set<DistributedMember> findMembersForRegion(Cache cache,
+  private Set<DistributedMember> findMembersForRegion(InternalCache cache,
-  private Set<DistributedMember> getMembersByIds(Cache cache, Set<String> memberIds) {
+  private Set<DistributedMember> getMembersByIds(InternalCache cache, Set<String> memberIds) {
-    if (CliUtil.isGfshVM()) { // in gfsh check if connected //TODO - Abhishek: make this better
+    if (CliUtil.isGfshVM()) { // in gfsh check if connected //TODO: make this better

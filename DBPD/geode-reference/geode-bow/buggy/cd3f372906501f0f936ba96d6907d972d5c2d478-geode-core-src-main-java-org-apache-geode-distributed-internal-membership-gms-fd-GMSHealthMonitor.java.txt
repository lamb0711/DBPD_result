GEODE-3780 suspected member is never watched again after passing final check

Consolidated "unsuspect" processing into a memberUnsuspected() method.
Modified "final check" method to not unsuspect a member that fails the check.

+import org.apache.geode.distributed.internal.membership.gms.ServiceConfig;
-  private final ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView =
+  private final ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberIds =
-  private final Map<NetView, Set<SuspectRequest>> viewVsSuspectedMembers = new HashMap<>();
+  private final Map<NetView, Set<SuspectRequest>> suspectRequestsInView = new HashMap<>();
-    if (suspectedMemberInView.remove(sender) != null) {
-      logger.info("No longer suspecting {}", sender);
+    if (suspectedMemberIds.containsKey(sender)) {
+      memberUnsuspected(sender);
-        suspectedMemberInView.put(mbr, currentView);
+        suspectedMemberIds.put(mbr, currentView);
-        GMSHealthMonitor.this.initiateSuspicion(mbr, reason);
+        initiateSuspicion(mbr, reason);
-        suspectedMemberInView.remove(mbr);
+        memberUnsuspected(mbr);
-        setNextNeighbor(GMSHealthMonitor.this.currentView, null);
+        setNextNeighbor(currentView, null);
-            serverSocketExecutor.execute(new ClientSocketHandler(socket)); // start(); [bruce] I'm
-            // seeing a lot of
-            // failures due to this
-            // thread not being
-            // created fast enough,
-            // sometimes as long as
-            // 30 seconds
-
+            serverSocketExecutor.execute(new ClientSocketHandler(socket));
-    synchronized (viewVsSuspectedMembers) {
-      viewVsSuspectedMembers.clear();
+    synchronized (suspectRequestsInView) {
+      suspectRequestsInView.clear();
-    for (Iterator<InternalDistributedMember> it = suspectedMemberInView.keySet().iterator(); it
+    for (Iterator<InternalDistributedMember> it = suspectedMemberIds.keySet().iterator(); it
-    //
-    // Set<InternalDistributedMember> checkAllSuspected = new HashSet<>(allMembers);
-    // checkAllSuspected.removeAll(suspectedMemberInView.keySet());
-    // checkAllSuspected.remove(localAddress);
-    // if (checkAllSuspected.isEmpty() && allMembers.size() > 1) {
-    // logger.info("All other members are suspect at this point");
-    // nextNeighbor = null;
-    // return;
-    // }
-    if (allMembers.size() > 1 && suspectedMemberInView.size() >= allMembers.size() - 1) {
+    if (allMembers.size() > 1 && suspectedMemberIds.size() >= allMembers.size() - 1) {
-        if (!suspectedMemberInView.containsKey(member)) {
+        if (!suspectedMemberIds.containsKey(member)) {
-      if (suspectedMemberInView.containsKey(newNeighbor)) {
+      if (suspectedMemberIds.containsKey(newNeighbor)) {
-        logger.debug("Failure detection is now watching {}", newNeighbor);
+        logger.info("Failure detection is now watching {}", newNeighbor);
-    return this.suspectedMemberInView.containsKey(m);
+    return this.suspectedMemberIds.containsKey(m);
-    suspectedMemberInView.putIfAbsent(suspect, currentView);
+    synchronized (suspectRequestsInView) {
+      suspectedMemberIds.putIfAbsent(suspect, currentView);
+      Collection<SuspectRequest> requests = suspectRequestsInView.get(currentView);
+      boolean found = false;
+      if (requests == null) {
+        requests = new HashSet<>();
+        requests.add(new SuspectRequest(suspect, reason));
+      }
+      for (SuspectRequest request : requests) {
+        if (suspect.equals(request.getSuspectMember())) {
+          found = true;
+          break;
+        }
+      }
+      if (!found) {
+        requests.add(new SuspectRequest(suspect, reason));
+      }
+    }
+  }
+
+  private void memberUnsuspected(InternalDistributedMember mbr) {
+    synchronized (suspectRequestsInView) {
+      if (suspectedMemberIds.remove(mbr) != null) {
+        logger.info("No longer suspecting {}", mbr);
+      }
+      Collection<SuspectRequest> suspectRequests = suspectRequestsInView.get(currentView);
+      if (suspectRequests != null) {
+        Collection<SuspectRequest> removals = new ArrayList<>(suspectRequests.size());
+        for (SuspectRequest suspectRequest : suspectRequests) {
+          if (mbr.equals(suspectRequest.getSuspectMember())) {
+            removals.add(suspectRequest);
+          }
+        }
+        suspectRequests.removeAll(removals);
+      }
+    }
-    List<SuspectRequest> sMembers = incomingRequest.getMembers();
+    List<SuspectRequest> suspectRequests = incomingRequest.getMembers();
-      checkIfAvailable(sender, sMembers, cv);
+      checkIfAvailable(sender, suspectRequests, cv);
-      ArrayList<SuspectRequest> smbr = new ArrayList<>();
-      synchronized (viewVsSuspectedMembers) {
-        recordSuspectRequests(sMembers, cv);
-        Set<SuspectRequest> viewVsMembers = viewVsSuspectedMembers.get(cv);
-        for (final SuspectRequest sr : viewVsMembers) {
+      ArrayList<SuspectRequest> membersToCheck = new ArrayList<>();
+      synchronized (suspectRequestsInView) {
+        recordSuspectRequests(suspectRequests, cv);
+        Set<SuspectRequest> suspectsInView = suspectRequestsInView.get(cv);
+        for (final SuspectRequest sr : suspectsInView) {
-          smbr.add(sr);
+          membersToCheck.add(sr);
-        checkIfAvailable(sender, smbr, cv);
-      } else {
-        recordSuspectRequests(sMembers, cv);
+        checkIfAvailable(sender, membersToCheck, cv);
-  private void recordSuspectRequests(List<SuspectRequest> sMembers, NetView cv) {
+  private void recordSuspectRequests(List<SuspectRequest> suspectRequests, NetView cv) {
-    Set<SuspectRequest> viewVsMembers;
-    synchronized (viewVsSuspectedMembers) {
-      viewVsMembers = viewVsSuspectedMembers.get(cv);
-      if (viewVsMembers == null) {
-        viewVsMembers = new HashSet<>();
-        viewVsSuspectedMembers.put(cv, viewVsMembers);
+    Set<SuspectRequest> suspectedMembers;
+    synchronized (suspectRequestsInView) {
+      suspectedMembers = suspectRequestsInView.get(cv);
+      if (suspectedMembers == null) {
+        suspectedMembers = new HashSet<>();
+        suspectRequestsInView.put(cv, suspectedMembers);
-      for (SuspectRequest sr : sMembers) {
-        viewVsMembers.add(sr);
-      }
+      suspectedMembers.addAll(suspectRequests);
-      // suspectMemberInView is now set by the heartbeat monitoring code
-      // to allow us to move on from watching members we've already
-      // suspected. Since that code is updating this collection we
-      // cannot use it here as an indication that a member is currently
-      // undergoing a final check.
-      // NetView view;
-      // view = suspectedMemberInView.putIfAbsent(mbr, cv);
-
-      // if (view == null || !view.equals(cv)) {
-        } finally {
-          GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
-      // }// scheduling for final check and removing it..
+    logger.info("Performing final check for suspect member {} reason={}", mbr, reason);
-      logger.info("Performing final check for suspect member {} reason={}", mbr, reason);
-      // whether it's alive or not, at this point we allow it to
-      // be watched again
-      suspectedMemberInView.remove(mbr);
-      setNextNeighbor(currentView, null);
+      if (!failed) {
+        memberUnsuspected(mbr);
+        setNextNeighbor(currentView, null);
+      }
-    // the background suspect-collector thread is currently disabled
-    // synchronized (suspectRequests) {
-    // if (suspectRequests.size() > 0) {
-    // for (SuspectRequest sr: suspectRequests) {
-    // if (!requests.contains(sr)) {
-    // requests.add(sr);
-    // }
-    // }
-    // suspectRequests.clear();
-    // }
-    // }
-    if (currentView.size() > 4) {
+    if (currentView.size() > ServiceConfig.SMALL_CLUSTER_SIZE) {
-      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e
+      for (Enumeration<InternalDistributedMember> e = suspectedMemberIds.keys(); e
-          currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
+          currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(),
+              ServiceConfig.SMALL_CLUSTER_SIZE + 1);

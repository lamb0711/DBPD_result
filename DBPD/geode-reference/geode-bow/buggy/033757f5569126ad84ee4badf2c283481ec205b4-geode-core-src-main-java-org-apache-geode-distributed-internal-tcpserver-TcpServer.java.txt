GEODE-3751: a single place for client protocol loading, logic.

* Load a single service, `ClientProtocolService`.
  - (well, authenticators are still separate).
* Move several interfaces to `geode-protobuf` from core.
* Client protocol state and statistics are now stored on the new
  `ClientProtocolPipeline` interface. This will allow us to keep
  connection logic for core separated from protocol logic.
* implement pipelines for Cache and Locator.
* some other small fixes and changes.

Signed-off-by: Galen O'Sullivan <gosullivan@pivotal.io>

This closes #873

Signed-off-by: Brian Rowe <browe@pivotal.io>

+import org.apache.geode.cache.IncompatibleVersionException;
-import org.apache.geode.internal.cache.tier.sockets.ClientProtocolMessageHandler;
+import org.apache.geode.internal.cache.tier.sockets.ClientProtocolProcessor;
+import org.apache.geode.internal.cache.tier.sockets.ClientProtocolService;
-import org.apache.geode.internal.cache.tier.sockets.MessageExecutionContext;
-  private ClientProtocolMessageHandler clientProtocolMessageHandler;
+  private final ClientProtocolService clientProtocolService;
-  public ClientProtocolMessageHandler getClientProtocolMessageHandler() {
-    return clientProtocolMessageHandler;
+  public ClientProtocolService getClientProtocolService() {
+    return clientProtocolService;
-      ClientProtocolMessageHandler clientProtocolMessageHandler) {
+      ClientProtocolService clientProtocolService) {
-    this.clientProtocolMessageHandler = clientProtocolMessageHandler;
+    this.clientProtocolService = clientProtocolService;
-            clientProtocolMessageHandler.getStatistics().clientConnected();
-            clientProtocolMessageHandler.receiveMessage(input, socket.getOutputStream(),
-                new MessageExecutionContext(internalLocator));
-            clientProtocolMessageHandler.getStatistics().clientDisconnected();
+            if (clientProtocolService == null) {
+              // this shouldn't happen.
+              log.error("Client protocol service not initialized but a request was received");
+              socket.close();
+              throw new IOException(
+                  "Client protocol service not initialized but a request was received");
+            } else {
+              try (ClientProtocolProcessor pipeline =
+                  clientProtocolService.createProcessorForLocator(internalLocator)) {
+                pipeline.processMessage(input, socket.getOutputStream());
+              } catch (IncompatibleVersionException e) {
+                // should not happen on the locator as there is no handshake.
+                log.error("Unexpected exception in client message processing", e);
+              }
+            }

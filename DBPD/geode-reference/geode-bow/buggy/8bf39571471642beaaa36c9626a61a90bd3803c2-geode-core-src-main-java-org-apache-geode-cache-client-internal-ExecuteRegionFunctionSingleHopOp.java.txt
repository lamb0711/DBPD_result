Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  private ExecuteRegionFunctionSingleHopOp() {
-  }
-  public static void execute(ExecutablePool pool, Region region,
-      Function function, ServerRegionFunctionExecutor serverRegionExecutor,
-      ResultCollector resultCollector, byte hasResult,
-      Map<ServerLocation, ? extends HashSet> serverToFilterMap, int mRetryAttempts, boolean allBuckets) {
+  private ExecuteRegionFunctionSingleHopOp() {}
+
+  public static void execute(ExecutablePool pool, Region region, Function function,
+      ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector resultCollector,
+      byte hasResult, Map<ServerLocation, ? extends HashSet> serverToFilterMap, int mRetryAttempts,
+      boolean allBuckets) {
-    ClientMetadataService cms = ((GemFireCacheImpl)region.getCache())
-        .getClientMetadataService();
+    ClientMetadataService cms = ((GemFireCacheImpl) region.getCache()).getClientMetadataService();
-      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The serverToFilterMap is : {}", serverToFilterMap);
+      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The serverToFilterMap is : {}",
+          serverToFilterMap);
-    List<SingleHopOperationCallable> callableTasks = constructAndGetExecuteFunctionTasks(region.getFullPath(),
-        serverRegionExecutor, serverToFilterMap, (PoolImpl)pool, function,
+    List<SingleHopOperationCallable> callableTasks = constructAndGetExecuteFunctionTasks(
+        region.getFullPath(), serverRegionExecutor, serverToFilterMap, (PoolImpl) pool, function,
-    reexecute = SingleHopClientExecutor.submitAllHA(callableTasks,
-        (LocalRegion)region, function.isHA(), resultCollector, failedNodes);
+    reexecute = SingleHopClientExecutor.submitAllHA(callableTasks, (LocalRegion) region,
+        function.isHA(), resultCollector, failedNodes);
-      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The size of callableTask is : {}", callableTasks.size());
+      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The size of callableTask is : {}",
+          callableTasks.size());
-    if (reexecute ) {
+    if (reexecute) {
-      if(function.isHA()) {
-      ExecuteRegionFunctionOp.reexecute(pool, region.getFullPath(), function,
-          serverRegionExecutor, resultCollector, hasResult, failedNodes,
-          maxRetryAttempts - 1);
+      if (function.isHA()) {
+        ExecuteRegionFunctionOp.reexecute(pool, region.getFullPath(), function,
+            serverRegionExecutor, resultCollector, hasResult, failedNodes, maxRetryAttempts - 1);
-//      else {
-//        ExecuteRegionFunctionOp.execute(pool, region.getFullPath(), function,
-//            serverRegionExecutor, resultCollector, hasResult,
-//            maxRetryAttempts - 1);
-//      }
+      // else {
+      // ExecuteRegionFunctionOp.execute(pool, region.getFullPath(), function,
+      // serverRegionExecutor, resultCollector, hasResult,
+      // maxRetryAttempts - 1);
+      // }
-  public static void execute(ExecutablePool pool, Region region,
-      String functionId, ServerRegionFunctionExecutor serverRegionExecutor,
-      ResultCollector resultCollector, byte hasResult,
-      Map<ServerLocation, ? extends HashSet> serverToFilterMap,
-      int mRetryAttempts, boolean allBuckets, boolean isHA,
-      boolean optimizeForWrite) {
+  public static void execute(ExecutablePool pool, Region region, String functionId,
+      ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector resultCollector,
+      byte hasResult, Map<ServerLocation, ? extends HashSet> serverToFilterMap, int mRetryAttempts,
+      boolean allBuckets, boolean isHA, boolean optimizeForWrite) {
-    ClientMetadataService cms = ((GemFireCacheImpl)region.getCache())
-        .getClientMetadataService();
+    ClientMetadataService cms = ((GemFireCacheImpl) region.getCache()).getClientMetadataService();
-      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The serverToFilterMap is : {}", serverToFilterMap);
+      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The serverToFilterMap is : {}",
+          serverToFilterMap);
-    List<SingleHopOperationCallable> callableTasks = constructAndGetExecuteFunctionTasks(region.getFullPath(),
-        serverRegionExecutor, serverToFilterMap, (PoolImpl)pool, functionId,
-        hasResult, resultCollector, cms, allBuckets, isHA,optimizeForWrite);
+    List<SingleHopOperationCallable> callableTasks = constructAndGetExecuteFunctionTasks(
+        region.getFullPath(), serverRegionExecutor, serverToFilterMap, (PoolImpl) pool, functionId,
+        hasResult, resultCollector, cms, allBuckets, isHA, optimizeForWrite);
-    reexecute = SingleHopClientExecutor.submitAllHA(callableTasks,
-        (LocalRegion)region, isHA, resultCollector, failedNodes);
+    reexecute = SingleHopClientExecutor.submitAllHA(callableTasks, (LocalRegion) region, isHA,
+        resultCollector, failedNodes);
-      logger.debug("ExecuteRegionFunctionSingleHopOp#execute : The size of callableTask is: {}, reexecute={}", callableTasks.size(), reexecute);
+      logger.debug(
+          "ExecuteRegionFunctionSingleHopOp#execute : The size of callableTask is: {}, reexecute={}",
+          callableTasks.size(), reexecute);
-        ExecuteRegionFunctionOp.reexecute(pool, region.getFullPath(),
-            functionId, serverRegionExecutor, resultCollector, hasResult,
-            failedNodes, maxRetryAttempts - 1, isHA, optimizeForWrite);
+        ExecuteRegionFunctionOp.reexecute(pool, region.getFullPath(), functionId,
+            serverRegionExecutor, resultCollector, hasResult, failedNodes, maxRetryAttempts - 1,
+            isHA, optimizeForWrite);
-//      else {
-//        ExecuteRegionFunctionOp.execute(pool, region.getFullPath(), functionId,
-//            serverRegionExecutor, resultCollector, hasResult,
-//            maxRetryAttempts - 1, isHA, optimizeForWrite);
-//      }
+      // else {
+      // ExecuteRegionFunctionOp.execute(pool, region.getFullPath(), functionId,
+      // serverRegionExecutor, resultCollector, hasResult,
+      // maxRetryAttempts - 1, isHA, optimizeForWrite);
+      // }
-  
+
-      final Map<ServerLocation, ? extends HashSet> serverToFilterMap,
-      final PoolImpl pool, final Function function, byte hasResult,
-      ResultCollector rc, ClientMetadataService cms, boolean allBucket) {
+      final Map<ServerLocation, ? extends HashSet> serverToFilterMap, final PoolImpl pool,
+      final Function function, byte hasResult, ResultCollector rc, ClientMetadataService cms,
+      boolean allBucket) {
-    ArrayList<ServerLocation> servers = new ArrayList<ServerLocation>(
-        serverToFilterMap.keySet());
+    ArrayList<ServerLocation> servers = new ArrayList<ServerLocation>(serverToFilterMap.keySet());
-      ServerRegionFunctionExecutor executor = (ServerRegionFunctionExecutor)serverRegionExecutor
+      ServerRegionFunctionExecutor executor = (ServerRegionFunctionExecutor) serverRegionExecutor
-      AbstractOp op = new ExecuteRegionFunctionSingleHopOpImpl(region, function, executor, rc, hasResult, new HashSet<String>(),
-          allBucket);
-      SingleHopOperationCallable task = new SingleHopOperationCallable(
-          new ServerLocation(server.getHostName(), server.getPort()), pool, op, UserAttributes.userAttributes.get());
+      AbstractOp op = new ExecuteRegionFunctionSingleHopOpImpl(region, function, executor, rc,
+          hasResult, new HashSet<String>(), allBucket);
+      SingleHopOperationCallable task =
+          new SingleHopOperationCallable(new ServerLocation(server.getHostName(), server.getPort()),
+              pool, op, UserAttributes.userAttributes.get());
-      final Map<ServerLocation, ? extends HashSet> serverToFilterMap,
-      final PoolImpl pool, final String functionId, byte hasResult,
-      ResultCollector rc, ClientMetadataService cms, boolean allBucket, boolean isHA, boolean optimizeForWrite) {
+      final Map<ServerLocation, ? extends HashSet> serverToFilterMap, final PoolImpl pool,
+      final String functionId, byte hasResult, ResultCollector rc, ClientMetadataService cms,
+      boolean allBucket, boolean isHA, boolean optimizeForWrite) {
-    ArrayList<ServerLocation> servers = new ArrayList<ServerLocation>(
-        serverToFilterMap.keySet());
+    ArrayList<ServerLocation> servers = new ArrayList<ServerLocation>(serverToFilterMap.keySet());
-      ServerRegionFunctionExecutor executor = (ServerRegionFunctionExecutor)serverRegionExecutor
+      ServerRegionFunctionExecutor executor = (ServerRegionFunctionExecutor) serverRegionExecutor
-      AbstractOp op = new ExecuteRegionFunctionSingleHopOpImpl(region, functionId, executor, rc, hasResult, new HashSet<String>(),
-          allBucket, isHA, optimizeForWrite);
-      SingleHopOperationCallable task = new SingleHopOperationCallable(
-          new ServerLocation(server.getHostName(), server.getPort()), pool, op, UserAttributes.userAttributes.get());
+      AbstractOp op = new ExecuteRegionFunctionSingleHopOpImpl(region, functionId, executor, rc,
+          hasResult, new HashSet<String>(), allBucket, isHA, optimizeForWrite);
+      SingleHopOperationCallable task =
+          new SingleHopOperationCallable(new ServerLocation(server.getHostName(), server.getPort()),
+              pool, op, UserAttributes.userAttributes.get());
-  
+
-    private boolean isHA; 
-    
+    private boolean isHA;
+
-    public ExecuteRegionFunctionSingleHopOpImpl(String region,
-        Function function, ServerRegionFunctionExecutor serverRegionExecutor,
-        ResultCollector rc, byte hasResult,
+    public ExecuteRegionFunctionSingleHopOpImpl(String region, Function function,
+        ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector rc, byte hasResult,
-      super(MessageType.EXECUTE_REGION_FUNCTION_SINGLE_HOP, 8
-          + serverRegionExecutor.getFilter().size() + removedNodes.size());
+      super(MessageType.EXECUTE_REGION_FUNCTION_SINGLE_HOP,
+          8 + serverRegionExecutor.getFilter().size() + removedNodes.size());
-      byte functionState = AbstractExecution.getFunctionState(function.isHA(),
-          function.hasResult() , function.optimizeForWrite());
+      byte functionState = AbstractExecution.getFunctionState(function.isHA(), function.hasResult(),
+          function.optimizeForWrite());
-      MemberMappedArgument memberMappedArg = serverRegionExecutor
-          .getMemberMappedArgument();
+      MemberMappedArgument memberMappedArg = serverRegionExecutor.getMemberMappedArgument();
-      }
-      else {
+      } else {
-      getMessage().addBytesPart(new byte[] { allBuckets ? (byte)1 : (byte)0 });
+      getMessage().addBytesPart(new byte[] {allBuckets ? (byte) 1 : (byte) 0});
-        if(allBuckets){
-          getMessage().addIntPart((Integer)key);
-        }
-        else {
+        if (allBuckets) {
+          getMessage().addIntPart((Integer) key);
+        } else {
-    public ExecuteRegionFunctionSingleHopOpImpl(String region,
-        String functionId, ServerRegionFunctionExecutor serverRegionExecutor,
-        ResultCollector rc, byte hasResult,
+    public ExecuteRegionFunctionSingleHopOpImpl(String region, String functionId,
+        ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector rc, byte hasResult,
-      super(MessageType.EXECUTE_REGION_FUNCTION_SINGLE_HOP, 8
-          + serverRegionExecutor.getFilter().size() + removedNodes.size());
+      super(MessageType.EXECUTE_REGION_FUNCTION_SINGLE_HOP,
+          8 + serverRegionExecutor.getFilter().size() + removedNodes.size());
-          hasResult == (byte)1 ? true : false, optimizeForWrite);
-      MemberMappedArgument memberMappedArg = serverRegionExecutor
-          .getMemberMappedArgument();
+          hasResult == (byte) 1 ? true : false, optimizeForWrite);
+      MemberMappedArgument memberMappedArg = serverRegionExecutor.getMemberMappedArgument();
-      getMessage().addBytesPart(new byte[] { allBuckets ? (byte)1 : (byte)0 });
+      getMessage().addBytesPart(new byte[] {allBuckets ? (byte) 1 : (byte) 0});
-        if(allBuckets){
-          getMessage().addIntPart((Integer)key);
-        }
-        else {
+        if (allBuckets) {
+          getMessage().addIntPart((Integer) key);
+        } else {
-      if (GemFireCacheImpl.getClientFunctionTimeout() == GemFireCacheImpl.DEFAULT_CLIENT_FUNCTION_TIMEOUT) {
-        getMessage().addBytesPart(new byte[] { functionState });
+      if (GemFireCacheImpl
+          .getClientFunctionTimeout() == GemFireCacheImpl.DEFAULT_CLIENT_FUNCTION_TIMEOUT) {
+        getMessage().addBytesPart(new byte[] {functionState});
-      ChunkedMessage executeFunctionResponseMsg = (ChunkedMessage)msg;
+      ChunkedMessage executeFunctionResponseMsg = (ChunkedMessage) msg;
-              logger.debug("ExecuteRegionFunctionSingleHopOpImpl#processResponse: received message of type EXECUTE_REGION_FUNCTION_RESULT.");
+              logger.debug(
+                  "ExecuteRegionFunctionSingleHopOpImpl#processResponse: received message of type EXECUTE_REGION_FUNCTION_RESULT.");
-              Object resultResponse = executeFunctionResponseMsg.getPart(0)
-                  .getObject();
+              Object resultResponse = executeFunctionResponseMsg.getPart(0).getObject();
-                result = ((ArrayList)resultResponse).get(0);
-              }
-              else {
+                result = ((ArrayList) resultResponse).get(0);
+              } else {
-                FunctionException ex = ((FunctionException)result);
+                FunctionException ex = ((FunctionException) result);
-                  logger.debug("ExecuteRegionFunctionSingleHopOpImpl#processResponse: received Exception. {}", ex.getCause());
+                  logger.debug(
+                      "ExecuteRegionFunctionSingleHopOpImpl#processResponse: received Exception. {}",
+                      ex.getCause());
-                  DistributedMember memberID = (DistributedMember)((ArrayList)resultResponse)
-                      .get(1);
-                  this.resultCollector
-                      .addResult(memberID, cause);
-                  FunctionStats.getFunctionStats(this.functionId,
-                      this.executor.getRegion().getSystem())
+                  DistributedMember memberID =
+                      (DistributedMember) ((ArrayList) resultResponse).get(1);
+                  this.resultCollector.addResult(memberID, cause);
+                  FunctionStats
+                      .getFunctionStats(this.functionId, this.executor.getRegion().getSystem())
-                }
-                else if (((FunctionException)result).getCause() instanceof InternalFunctionInvocationTargetException) {
-                  InternalFunctionInvocationTargetException ifite = (InternalFunctionInvocationTargetException)ex
-                      .getCause();
+                } else if (((FunctionException) result)
+                    .getCause() instanceof InternalFunctionInvocationTargetException) {
+                  InternalFunctionInvocationTargetException ifite =
+                      (InternalFunctionInvocationTargetException) ex.getCause();
-              }
-              else if(result instanceof BucketMovedException) {
-                FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-                    ((BucketMovedException)result).getMessage());
+              } else if (result instanceof BucketMovedException) {
+                FunctionInvocationTargetException fite =
+                    new InternalFunctionInvocationTargetException(
+                        ((BucketMovedException) result).getMessage());
-              }
-              else if(result instanceof CacheClosedException) {
-                FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-                    ((CacheClosedException)result).getMessage());
+              } else if (result instanceof CacheClosedException) {
+                FunctionInvocationTargetException fite =
+                    new InternalFunctionInvocationTargetException(
+                        ((CacheClosedException) result).getMessage());
-                  DistributedMember memberID = (DistributedMember) ((ArrayList) resultResponse)
-                      .get(1);
+                  DistributedMember memberID =
+                      (DistributedMember) ((ArrayList) resultResponse).get(1);
-                }                
+                }
-              }
-              else if (result instanceof Throwable) {
+              } else if (result instanceof Throwable) {
-                exception = new ServerOperationException(s, (Throwable)result);
-              }
-              else {
-                DistributedMember memberID = (DistributedMember)((ArrayList)resultResponse)
-                    .get(1);
-                  this.resultCollector
-                      .addResult(memberID, result);
-                FunctionStats.getFunctionStats(this.functionId,
-                    this.executor.getRegion().getSystem()).incResultsReceived();
+                exception = new ServerOperationException(s, (Throwable) result);
+              } else {
+                DistributedMember memberID =
+                    (DistributedMember) ((ArrayList) resultResponse).get(1);
+                this.resultCollector.addResult(memberID, result);
+                FunctionStats
+                    .getFunctionStats(this.functionId, this.executor.getRegion().getSystem())
+                    .incResultsReceived();
-              logger.debug("ExecuteRegionFunctionSingleHopOpImpl#processResponse: received all the results from server successfully.");
+              logger.debug(
+                  "ExecuteRegionFunctionSingleHopOpImpl#processResponse: received all the results from server successfully.");
-            
+
-              logger.debug("ExecuteRegionFunctionSingleHopOpImpl#processResponse: received message of type EXCEPTION");
+              logger.debug(
+                  "ExecuteRegionFunctionSingleHopOpImpl#processResponse: received message of type EXCEPTION");
-              FunctionException ex = ((FunctionException)obj);
-              if (((FunctionException)obj).getCause() instanceof InternalFunctionInvocationTargetException) {
-                InternalFunctionInvocationTargetException ifite = (InternalFunctionInvocationTargetException)ex
-                    .getCause();
+              FunctionException ex = ((FunctionException) obj);
+              if (((FunctionException) obj)
+                  .getCause() instanceof InternalFunctionInvocationTargetException) {
+                InternalFunctionInvocationTargetException ifite =
+                    (InternalFunctionInvocationTargetException) ex.getCause();
-            }
-            else if (obj instanceof Throwable) {
+            } else if (obj instanceof Throwable) {
-              throw new ServerOperationException(s, (Throwable)obj);
+              throw new ServerOperationException(s, (Throwable) obj);
-              logger.debug("ExecuteRegionFunctionSingleHopOpImpl#processResponse: received message of type EXECUTE_REGION_FUNCTION_ERROR");
+              logger.debug(
+                  "ExecuteRegionFunctionSingleHopOpImpl#processResponse: received message of type EXECUTE_REGION_FUNCTION_ERROR");
-            String errorMessage = executeFunctionResponseMsg.getPart(0)
-                .getString();
+            String errorMessage = executeFunctionResponseMsg.getPart(0).getString();
-            
+
-            throw new InternalGemFireError("Unknown message type "
-                + executeFunctionResponseMsg.getMessageType());
+            throw new InternalGemFireError(
+                "Unknown message type " + executeFunctionResponseMsg.getMessageType());
-      }
-      finally {
+      } finally {
-     boolean optimizeForWrite() {
+    boolean optimizeForWrite() {
-    
+

GEODE-577: rewrite QueryMonitorDUnitTest (#2179)

* code cleanup.
* add QueryMonitor unit test
* do not add cq query to the monitor queue

-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import org.apache.geode.cache.query.Query;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-  private boolean testingQueryMonitor = false;
-  private static final ThreadLocal<AtomicBoolean> queryExecutionStatus =
+  private static final ThreadLocal<AtomicBoolean> queryCancelled =
-  /** For DUnit test purpose TODO: delete this ConcurrentMap */
-  private ConcurrentMap queryMonitorTasks = null;
-
-  public void monitorQueryThread(Thread queryThread, Query query) {
+  public void monitorQueryThread(Thread queryThread, DefaultQuery query) {
+    // cq query is not monitored
+    if (query.isCqQuery()) {
+      return;
+    }
+
-      ((DefaultQuery) query).setCanceled(true, new QueryExecutionLowMemoryException(reason));
+      query.setCanceled(new QueryExecutionLowMemoryException(reason));
-    QueryThreadTask queryTask = new QueryThreadTask(queryThread, query, queryExecutionStatus.get());
+    QueryThreadTask queryTask = new QueryThreadTask(queryThread, query, queryCancelled.get());
-    // For dunit test purpose
-    if (cache != null && testingQueryMonitor) {
-      if (this.queryMonitorTasks == null) {
-        this.queryMonitorTasks = new ConcurrentHashMap();
-      }
-      this.queryMonitorTasks.put(queryThread, queryTask);
-    }
-  public void stopMonitoringQueryThread(Thread queryThread, Query query) {
+  public void stopMonitoringQueryThread(Thread queryThread, DefaultQuery query) {
-    DefaultQuery defaultQuery = (DefaultQuery) query;
-    boolean[] queryCompleted = defaultQuery.getQueryCompletedForMonitoring();
+    boolean[] queryCompleted = query.getQueryCompletedForMonitoring();
-      queryExecutionStatus.get().getAndSet(Boolean.FALSE);
-
-      defaultQuery.setQueryCompletedForMonitoring(true);
+      queryCancelled.get().getAndSet(Boolean.FALSE);
+      query.setQueryCompletedForMonitoring(true);
-    if (queryExecutionStatus.get() != null && queryExecutionStatus.get().get()) {
+    if (queryCancelled.get() != null && queryCancelled.get().get()) {
-      // TODO: while-block cannot complete without throwing
-          // Empty queue.
-        long currentTime = System.currentTimeMillis();
-
+        long executionTime = System.currentTimeMillis() - queryTask.StartTime;
-        if (currentTime - queryTask.StartTime < this.maxQueryExecutionTime) {
-          sleepTime = this.maxQueryExecutionTime - (currentTime - queryTask.StartTime);
+        if (executionTime < this.maxQueryExecutionTime) {
+          sleepTime = this.maxQueryExecutionTime - executionTime;
-
-        // Query execution has taken more than the max time, Set queryExecutionStatus flag
-        // to canceled (TRUE).
-        boolean[] queryCompleted =
-            ((DefaultQuery) queryTask.query).getQueryCompletedForMonitoring();
+        // Query execution has taken more than the max time, Set queryCancelled flag
+        // to true.
+        boolean[] queryCompleted = queryTask.query.getQueryCompletedForMonitoring();
-          if (!queryCompleted[0] && !((DefaultQuery) queryTask.query).isCqQuery()) { // Check if the
-                                                                                     // query is
-                                                                                     // already
-                                                                                     // completed.
-            ((DefaultQuery) queryTask.query).setCanceled(true,
-                new QueryExecutionTimeoutException(
-                    LocalizedStrings.QueryMonitor_LONG_RUNNING_QUERY_CANCELED
-                        .toLocalizedString(GemFireCacheImpl.MAX_QUERY_EXECUTION_TIME)));
-            queryTask.queryExecutionStatus.set(Boolean.TRUE);
-            // Remove the task from queue.
+          // check if query is already completed
+          if (!queryCompleted[0]) {
+            queryTask.query.setCanceled(new QueryExecutionTimeoutException(String
+                .format("Query execution cancelled after exceeding max execution time %sms.",
+                    this.maxQueryExecutionTime)));
+            queryTask.queryCancelled.set(Boolean.TRUE);
+            // remove the query threads from monitoring queue
+            logger.info(String.format(
+                "%s is set as canceled after %s milliseconds", queryTask.toString(),
+                executionTime));
-
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.GemFireCache_LONG_RUNNING_QUERY_EXECUTION_CANCELED,
-            new Object[] {queryTask.query.getQueryString(), queryTask.queryThread.getId()}));
-
-        if (logger.isDebugEnabled()) {
-          logger.debug("Query Execution for the thread {} got canceled.", queryTask.queryThread);
-        }
-    boolean[] queryCompleted = ((DefaultQuery) queryTask.query).getQueryCompletedForMonitoring();
+    boolean[] queryCompleted = queryTask.query.getQueryCompletedForMonitoring();
-        ((DefaultQuery) queryTask.query).setCanceled(true,
+        queryTask.query.setCanceled(
-        queryTask.queryExecutionStatus.set(Boolean.TRUE);
+        queryTask.queryCancelled.set(Boolean.TRUE);
-    final Query query;
+    final DefaultQuery query;
-    final AtomicBoolean queryExecutionStatus;
+    final AtomicBoolean queryCancelled;
-    QueryThreadTask(Thread queryThread, Query query, AtomicBoolean queryExecutionStatus) {
+    QueryThreadTask(Thread queryThread, DefaultQuery query, AtomicBoolean queryCancelled) {
-      this.queryExecutionStatus = queryExecutionStatus;
+      this.queryCancelled = queryCancelled;
-          .append(", queryExecutionStatus:").append(this.queryExecutionStatus).append(']')
+          .append(", queryCancelled:").append(this.queryCancelled).append(']')

Feature/geode 5624 Use a single thread to ensure beforeCompletion and afterCompletion are executed by the same thread. (#2388)





+import java.util.concurrent.Executor;
+import org.apache.geode.CancelCriterion;
+  /**
+   * for client/server JTA transactions we need to have a single thread handle both beforeCompletion
+   * and afterCompletion so that beforeCompletion can obtain locks for the afterCompletion step.
+   * This is that thread
+   */
+  private final SingleThreadJTAExecutor singleThreadJTAExecutor;
+
+    this(proxy, onBehalfOfRemoteStub, new SingleThreadJTAExecutor());
+  }
+
+  public TXState(TXStateProxy proxy, boolean onBehalfOfRemoteStub,
+      SingleThreadJTAExecutor singleThreadJTAExecutor) {
-
+    this.singleThreadJTAExecutor = singleThreadJTAExecutor;
-       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort
+       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to cleanup
+    if (singleThreadJTAExecutor.shouldDoCleanup()) {
+      singleThreadJTAExecutor.cleanup(getCancelCriterion());
+    } else {
+      doCleanup();
+    }
+  }
+
+  void doCleanup() {
+
+    proxy.getTxMgr().setTXState(null);
+
-    doBeforeCompletion();
+    singleThreadJTAExecutor.executeBeforeCompletion(this,
+        getExecutor(), getCancelCriterion());
-  private void doBeforeCompletion() {
+  private Executor getExecutor() {
+    return getCache().getDistributionManager().getWaitingThreadPool();
+  }
+
+  private CancelCriterion getCancelCriterion() {
+    return getCache().getCancelCriterion();
+  }
+
+  void doBeforeCompletion() {
+
-       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort
+       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to cleanup
-    this.proxy.getTxMgr().setTXState(null);
-    // For commit, beforeCompletion should be called. Otherwise
+    proxy.getTxMgr().setTXState(null);
+    // if there was a beforeCompletion call then there will be a thread
+    // sitting in the waiting pool to execute afterCompletion. Otherwise
-    if (wasBeforeCompletionCalled()) {
-      doAfterCompletion(status);
+    if (beforeCompletionCalled) {
+      singleThreadJTAExecutor.executeAfterCompletion(getCancelCriterion(), status);
-  private void doAfterCompletion(int status) {
+  void doAfterCompletion(int status) {

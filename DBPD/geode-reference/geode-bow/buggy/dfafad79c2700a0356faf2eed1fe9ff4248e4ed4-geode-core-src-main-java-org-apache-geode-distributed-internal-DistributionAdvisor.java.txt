GEODE-5349 State-flush operation may exit early allowing for cache inconsistency

Removed the ability for this method to exit without the operation count
falling to zero.  Instead it issues a fatal-level log message, which
translates into a severe-level alert for operators.  This can help tech
support know which server a customer should terminate in order to break
a distributed deadlock.

I also added an info-level message that is issued if a warning/fatal message
has been issued noting that the wait has completed.  This parallels what
we do in ReplyProcessor21 if we've issued a warning that a cache-op response
hasn't been received within the ack-wait-threshold period.

This closes #2083

-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-  public void waitForCurrentOperations() {
-    long timeout =
-        1000L * this.getDistributionManager().getSystem().getConfig().getAckWaitThreshold();
-    waitForCurrentOperations(timeout);
-  }
-
-  public void waitForCurrentOperations(long timeout) {
-    // CacheProfile profile = (CacheProfile)getProfile(member);
-    // long targetVersion = profile.initialMembershipVersion - 1;
+  public void waitForCurrentOperations() {
+    long timeout =
+        1000L * this.getDistributionManager().getSystem().getConfig().getAckWaitThreshold();
+    waitForCurrentOperations(logger, timeout, timeout * 2L);
+  }
+  public void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
-    long startTime = System.currentTimeMillis();
-    long warnTime = startTime + timeout;
-    long quitTime = warnTime + timeout - 1000L;
+    final long startTime = System.currentTimeMillis();
+    final long warnTime = startTime + warnMS;
+    final long severeAlertTime = startTime + severeAlertMS;
+    boolean severeAlertIssued = false;
-        logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE);
+        DistributionAdvisor.logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE);
+        if (warned) {
+          alertLogger.info("Wait for current operations completed");
+        }
-        logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
+        DistributionAdvisor.logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.DistributionAdvisor_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_CURRENT_OPERATIONS_TO_DISTRIBUTE,
-            Long.toString((warnTime - startTime) / 1000L)));
-      } else if (warned && (now >= quitTime)) {
+        alertLogger.warn("This operation has been stalled for {} milliseconds waiting for "
+            + "current operations to complete.", warnMS);
+      } else if (warned && !severeAlertIssued && (now >= severeAlertTime)) {
-        throw new GemFireIOException(
-            "Current operations did not distribute within " + (now - startTime) + " milliseconds");
+        alertLogger.fatal("This operation has been stalled for {} milliseconds "
+            + "waiting for current operations to complete.  Something may be blocking operations.",
+            severeAlertMS);
+        severeAlertIssued = true;
-        logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
+        DistributionAdvisor.logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,

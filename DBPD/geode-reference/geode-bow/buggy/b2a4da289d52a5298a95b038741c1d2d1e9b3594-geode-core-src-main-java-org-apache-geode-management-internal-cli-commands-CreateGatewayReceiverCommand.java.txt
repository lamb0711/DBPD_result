GEODE-5185: Correct backwards-compatibility violation in 'create gateway-receiver'.  (#1920)

* This commit also refactors the 'create gateway-receiver' command and function in accordance with GEODE-4858 and GEODE-5011, concerning persistence service and ResultModel respectively.
+import java.util.Arrays;
+import java.util.stream.Collectors;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.DeclarableType;
-import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.cli.Result.Status;
+import org.apache.geode.management.cli.SingleGfshCommand;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
-import org.apache.geode.management.internal.configuration.domain.XmlEntity;
+import org.apache.geode.management.internal.cli.result.model.ResultModel;
-public class CreateGatewayReceiverCommand extends InternalGfshCommand {
+public class CreateGatewayReceiverCommand extends SingleGfshCommand {
-  public Result createGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
+  public ResultModel createGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
-      @CliOption(key = {CliStrings.IFNOTEXISTS}, help = CliStrings.PUT__PUTIFNOTEXISTS__HELP,
+      @CliOption(key = CliStrings.IFNOTEXISTS, help = CliStrings.IFNOTEXISTS_HELP,
-    GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs = new GatewayReceiverFunctionArgs(
-        manualStart, startPort, endPort, bindAddress, socketBufferSize, maximumTimeBetweenPings,
-        gatewayTransportFilters, hostnameForSenders, ifNotExists);
+    CacheConfig.GatewayReceiver configuration =
+        buildConfiguration(manualStart, startPort, endPort, bindAddress, maximumTimeBetweenPings,
+            socketBufferSize, gatewayTransportFilters, hostnameForSenders);
+
+    GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs =
+        new GatewayReceiverFunctionArgs(configuration, ifNotExists);
-    CommandResult result = ResultBuilder.buildResult(gatewayReceiverCreateResults);
-
-    XmlEntity xmlEntity = findXmlEntity(gatewayReceiverCreateResults);
-    // no xml needs to be updated, simply return
-    if (xmlEntity == null) {
-      return result;
-    }
-
-    boolean allSuccessful = gatewayReceiverCreateResults.stream()
-        .map(CliFunctionResult::isSuccessful).reduce(true, (x, y) -> x && y);
-    if (!allSuccessful) {
-      result.setStatus(Status.ERROR);
-      return result;
-    }
-
-    // has xml but unable to persist to cluster config, need to print warning message and return
-    if (onMember != null || getConfigurationPersistenceService() == null) {
-      result.setCommandPersisted(false);
-      return result;
-    }
-
-    // update cluster config
-    ((InternalConfigurationPersistenceService) getConfigurationPersistenceService())
-        .addXmlEntity(xmlEntity, onGroups);
+    ResultModel result = ResultModel.createMemberStatusResult(gatewayReceiverCreateResults);
+    result.setConfigObject(configuration);
+  @Override
+  public void updateClusterConfig(String group, CacheConfig config, Object configObject) {
+    config.setGatewayReceiver((CacheConfig.GatewayReceiver) configObject);
+  }
+
+  private CacheConfig.GatewayReceiver buildConfiguration(Boolean manualStart, Integer startPort,
+      Integer endPort, String bindAddress, Integer maximumTimeBetweenPings,
+      Integer socketBufferSize, String[] gatewayTransportFilters, String hostnameForSenders) {
+    CacheConfig.GatewayReceiver configuration = new CacheConfig.GatewayReceiver();
+
+    if (gatewayTransportFilters != null) {
+      List<DeclarableType> filters =
+          Arrays.stream(gatewayTransportFilters).map(fullyQualifiedClassName -> {
+            DeclarableType thisFilter = new DeclarableType();
+            thisFilter.setClassName(fullyQualifiedClassName);
+            return thisFilter;
+          }).collect(Collectors.toList());
+      configuration.getGatewayTransportFilter().addAll(filters);
+    }
+    if (startPort != null) {
+      configuration.setStartPort(String.valueOf(startPort));
+    }
+    if (endPort != null) {
+      configuration.setEndPort(String.valueOf(endPort));
+    }
+    configuration.setBindAddress(bindAddress);
+    if (maximumTimeBetweenPings != null) {
+      configuration.setMaximumTimeBetweenPings(String.valueOf(maximumTimeBetweenPings));
+    }
+    if (socketBufferSize != null) {
+      configuration.setSocketBufferSize(String.valueOf(socketBufferSize));
+    }
+    configuration.setHostnameForSenders(hostnameForSenders);
+    configuration.setManualStart(manualStart);
+    return configuration;
+  }
+
-    public Result preExecution(GfshParseResult parseResult) {
+    public ResultModel preExecution(GfshParseResult parseResult) {
-        return ResultBuilder.createUserErrorResult("start-port must be smaller than end-port.");
+        return ResultModel.createError("start-port must be smaller than end-port.");
-      return ResultBuilder.createInfoResult("");
+      return ResultModel.createInfo("");

GEODE-7035 - Updated Enums in PeerTypeRegistration, refactored LocalReverseMap

Brought Enum behaviour in line with PdxType behaviour in
PeerTypeRegistration
Refactored ReverseMap to not be an internal class of
PeerTypeRegistration
Added unit tests for PeerTypeRegistration and
PeerTypeRegistrationReverseMap

Authored-by: Donal Evans <doevans@pivotal.io>

+  private static final String LOCK_NAME = "PDX_LOCK";
-  private LocalReverseMap localReverseMap = new LocalReverseMap();
+  private PeerTypeRegistrationReverseMap reverseMap = new PeerTypeRegistrationReverseMap();
-    AttributesFactory<Object, Object> factory = new AttributesFactory<>();
+    AttributesFactory<Object, Object> factory = getAttributesFactory();
+
-        // update a local map with the pdxtypes registered
+        // update the local map and reverse map with the pdxtypes registered
-          updateLocalMaps(key, value);
+          updateLocalAndReverseMaps(key, value);
-    buildTypeToIdFromIdToType();
+    buildReverseMapsFromRegion();
-  private static final String LOCK_NAME = "PDX_LOCK";
-
-    Integer existingId = localReverseMap.checkIfExistsInLocal(newType);
+    Integer existingId = reverseMap.getIdFromReverseMap(newType);
-      if (localReverseMap.shouldReloadFromRegion()) {
-        buildTypeToIdFromIdToType();
+      if (reverseMap.shouldReloadFromRegion(getIdToType())) {
+        buildReverseMapsFromRegion();
-      localReverseMap.flushLocalMap();
-      // double check if my type is in region in case the typeToId map has been updated while
-      // waiting to obtain a lock
-      existingId = localReverseMap.checkIfExistsInLocal(newType);
+      reverseMap.flushPendingReverseMap();
+
+      // double check if my PdxType is in the reverse map in case it was just flushed into it
+      existingId = reverseMap.getIdFromReverseMap(newType);
-
+
-      localReverseMap.flushLocalMap();
+      // flush the reverse map for the member that introduced this new PdxType
+      reverseMap.flushPendingReverseMap();
-  private void buildTypeToIdFromIdToType() {
+  /**
+   * Should only be called holding the dlock
+   * This method iterates through the entire PdxTypes region and syncs the reverse map with the pdx
+   * region This is an expensive operation and should only be called during initialization. A cache
+   * listener is used to keep the reverse maps up to date.
+   */
+  void buildReverseMapsFromRegion() {
+    int totalEnumIdInDS = 0;
+      reverseMap.clear();
-        Object v = entry.getValue();
-        if (v instanceof PdxType) {
-          PdxType foundType = (PdxType) v;
+        Object v = entry.getValue();
+        if (k instanceof EnumId) {
+          EnumId id = (EnumId) k;
+          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
+          if (tmpDsId == typeIdPrefix) {
+            totalEnumIdInDS++;
+            if (totalEnumIdInDS >= MAX_TYPE_ID) {
+              throw new InternalGemFireError(
+                  "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
+                      + MAX_TYPE_ID);
+            }
+          }
+        } else {
-        localReverseMap.save(k, v, false);
+        reverseMap.save(k, v);
-  /** Should be called holding the dlock */
-  private EnumId getExistingIdForEnum(EnumInfo ei) {
-    TXStateProxy currentState = suspendTX();
-    int totalEnumIdInDS = 0;
-    try {
-      EnumId result = null;
-      for (Map.Entry<Object, Object> entry : getIdToType().entrySet()) {
-        Object v = entry.getValue();
-        Object k = entry.getKey();
-        if (k instanceof EnumId) {
-          EnumId id = (EnumId) k;
-          EnumInfo info = (EnumInfo) v;
-          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
-          if (tmpDsId == typeIdPrefix) {
-            totalEnumIdInDS++;
-          }
-          if (ei.equals(info)) {
-            result = id;
-          }
-        }
-        localReverseMap.save(k, v, false);
-      }
-
-      if (totalEnumIdInDS == MAX_TYPE_ID) {
-        throw new InternalGemFireError(
-            "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
-                + MAX_TYPE_ID);
-      }
-      return result;
-    } finally {
-      resumeTX(currentState);
-    }
-  }
-
-    final EnumId existingId = localReverseMap.checkIfExistsInLocal(newInfo);
+    EnumId existingId = reverseMap.getIdFromReverseMap(newInfo);
-      localReverseMap.flushLocalMap();
-      EnumId id = getExistingIdForEnum(newInfo);
-      if (id != null) {
-        return id.intValue();
+      if (reverseMap.shouldReloadFromRegion(getIdToType())) {
+        buildReverseMapsFromRegion();
+      }
+      reverseMap.flushPendingReverseMap();
+
+      // double check if my Enum is in the reverse map in case it was just flushed into it
+      existingId = reverseMap.getIdFromReverseMap(newInfo);
+      if (existingId != null) {
+        return existingId.intValue();
-      id = allocateEnumId(newInfo);
-
+      EnumId id = allocateEnumId(newInfo);
-      localReverseMap.save(id, newInfo, false);
-
-      localReverseMap.flushLocalMap();
+      // flush the reverse map for the member that introduced this new enumInfo
+      reverseMap.flushPendingReverseMap();
-  private void updateLocalMaps(Object key, Object value) {
-    localReverseMap.save(key, value, true);
+  private void updateLocalAndReverseMaps(Object key, Object value) {
+    reverseMap.saveToPending(key, value);
+  @SuppressWarnings("deprecation")
+  protected AttributesFactory<Object, Object> getAttributesFactory() {
+    return new AttributesFactory<>();
+  }
+
+  @VisibleForTesting
-    return localReverseMap.typeToIdSize();
+    return reverseMap.typeToIdSize();
-    return localReverseMap.enumToIdSize();
-  }
-
-  class LocalReverseMap {
-    /**
-     * When a new pdxType or a new enumInfo is added to idToType region, its
-     * listener will add the new type to the pendingTypeToId first, to make sure
-     * the distribution finished.
-     * Then any member who wants to use this new pdxType has to get the dlock to
-     * flush the pendingTypeToId map into typeToId. This design to guarantee that
-     * when using the new pdxType, it should have been distributed to all members.
-     */
-    private final Map<PdxType, Integer> pendingTypeToId =
-        Collections.synchronizedMap(new HashMap<>());
-    private final Map<EnumInfo, EnumId> pendingEnumToId =
-        Collections.synchronizedMap(new HashMap<>());
-
-    /**
-     * This map serves two purposes. It lets us look up an id based on a type, if we previously
-     * found
-     * that type in the region. And, if a type is present in this map, that means we read the type
-     * while holding the dlock, which means the type was distributed to all members.
-     */
-    private final Map<PdxType, Integer> typeToId = Collections.synchronizedMap(new HashMap<>());
-
-    private final Map<EnumInfo, EnumId> enumToId = Collections.synchronizedMap(new HashMap<>());
-
-    void save(Object key, Object value, boolean isPending) {
-      if (value instanceof PdxType) {
-        PdxType type = (PdxType) value;
-        if (isPending) {
-          pendingTypeToId.put(type, (Integer) key);
-        } else {
-          typeToId.put(type, (Integer) key);
-        }
-      } else if (value instanceof EnumInfo) {
-        EnumInfo info = (EnumInfo) value;
-        if (isPending) {
-          pendingEnumToId.put(info, (EnumId) key);
-        } else {
-          enumToId.put(info, (EnumId) key);
-        }
-      }
-    }
-
-    int typeToIdSize() {
-      return typeToId.size();
-    }
-
-    int enumToIdSize() {
-      return enumToId.size();
-    }
-
-    Integer checkIfExistsInLocal(PdxType newType) {
-      return typeToId.get(newType);
-    }
-
-    EnumId checkIfExistsInLocal(EnumInfo newInfo) {
-      return enumToId.get(newInfo);
-    }
-
-    // The local maps should be loaded from the region if there is a mismatch in size between the
-    // region and all local maps
-    boolean shouldReloadFromRegion() {
-      return ((typeToId.size() + pendingTypeToId.size() + enumToId.size()
-          + pendingEnumToId.size()) != getIdToType().size());
-    }
-
-    void flushLocalMap() {
-      if (!pendingTypeToId.isEmpty()) {
-        typeToId.putAll(pendingTypeToId);
-        pendingTypeToId.clear();
-      }
-      if (!pendingEnumToId.isEmpty()) {
-        enumToId.putAll(pendingEnumToId);
-        pendingEnumToId.clear();
-      }
-    }
+    return reverseMap.enumToIdSize();

GEODE-6786: Provide ability to delete a region using V2 REST API (#3610)


+import java.util.HashSet;
+import org.apache.geode.management.internal.CacheElementOperation;
-    String group = config.getConfigGroup();
+    // validate that user used the correct config object type
+    ConfigurationManager configurationManager = getConfigurationManager(config);
-    validators.get(CacheElement.class).validate(config);
+    validators.get(CacheElement.class).validate(CacheElementOperation.CREATE, config);
+    String group = config.getConfigGroup();
-      validator.validate(config);
+      validator.validate(CacheElementOperation.CREATE, config);
-      if (validator.exists(config, currentPersistedConfig)) {
-        throw new EntityExistsException("cache element " + config.getId() + " already exists.");
+      if (validator.exists(config.getId(), currentPersistedConfig)) {
+        throw new EntityExistsException("Cache element '" + config.getId() + "' already exists");
-    // validate that user used the correct config object type
-    ConfigurationManager configurationManager = managers.get(config.getClass());
-    if (configurationManager == null) {
-      throw new IllegalArgumentException(String.format("Configuration type %s is not supported.",
-          config.getClass().getSimpleName()));
-    }
-
-          "no members found in " + group + " to create cache element");
+          "No members found in group '" + group + "' to create cache element");
-        Arrays.asList(config, UpdateCacheFunction.CacheElementOperation.ADD),
+        Arrays.asList(config, CacheElementOperation.CREATE),
-      result.setStatus(false, "Failed to apply the update on all members.");
+      result.setStatus(false, "Failed to apply the update on all members");
-            "successfully persisted config for " + finalGroup);
+            "Successfully updated config for " + finalGroup);
-        String message = "failed to update cluster config for " + finalGroup;
+        String message = "Failed to update cluster config for " + finalGroup;
-    throw new NotImplementedException("Not implemented");
+    // validate that user used the correct config object type
+    ConfigurationManager configurationManager = getConfigurationManager(config);
+
+    if (persistenceService == null) {
+      return new ClusterManagementResult(false,
+          "Cluster configuration service needs to be enabled");
+    }
+
+    // first validate common attributes of all configuration object
+    validators.get(CacheElement.class).validate(CacheElementOperation.DELETE, config);
+
+    ConfigurationValidator validator = validators.get(config.getClass());
+    validator.validate(CacheElementOperation.DELETE, config);
+
+    List<String> relevantGroups = persistenceService.getGroups().stream().filter(g -> {
+      CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(g);
+      if (currentPersistedConfig != null && validator != null) {
+        return validator.exists(config.getId(), currentPersistedConfig);
+      } else {
+        return false;
+      }
+    }).collect(Collectors.toList());
+
+    if (relevantGroups.isEmpty()) {
+      throw new EntityNotFoundException("Cache element '" + config.getId() + "' does not exist");
+    }
+
+    // execute function on all members
+    Set<DistributedMember> targetedMembers = new HashSet<>();
+    relevantGroups.forEach(g -> targetedMembers.addAll(findMembers(g)));
+
+    if (targetedMembers.size() == 0) {
+      return new ClusterManagementResult(false,
+          "No members found to delete cache element");
+    }
+
+    ClusterManagementResult result = new ClusterManagementResult();
+
+    List<CliFunctionResult> functionResults = executeAndGetFunctionResult(
+        new UpdateCacheFunction(),
+        Arrays.asList(config, CacheElementOperation.DELETE),
+        targetedMembers);
+    functionResults
+        .forEach(functionResult -> result.addMemberStatus(functionResult.getMemberIdOrName(),
+            functionResult.isSuccessful(),
+            functionResult.getStatusMessage()));
+
+    // if any false result is added to the member list
+    if (result.getStatusCode() != ClusterManagementResult.StatusCode.OK) {
+      result.setStatus(false, "Failed to apply the update on all members");
+      return result;
+    }
+
+    // persist configuration in cache config
+    List<String> updatedGroups = new ArrayList<>();
+    List<String> failedGroups = new ArrayList<>();
+    for (String finalGroup : relevantGroups) {
+      persistenceService.updateCacheConfig(finalGroup, cacheConfigForGroup -> {
+        try {
+          configurationManager.delete(config, cacheConfigForGroup);
+          updatedGroups.add(finalGroup);
+        } catch (Exception e) {
+          logger.error("Failed to update cluster config for " + finalGroup, e);
+          failedGroups.add(finalGroup);
+          return null;
+        }
+        return cacheConfigForGroup;
+      });
+    }
+
+    if (failedGroups.isEmpty()) {
+      result.setStatus(true, "Successfully removed config for " + updatedGroups);
+    } else {
+      String message = "Failed to update cluster config for " + failedGroups;
+      result.setStatus(ClusterManagementResult.StatusCode.FAIL_TO_PERSIST, message);
+    }
+
+    return result;
-    Stream<DistributedMember> stream =
+    Stream<DistributedMember> memberStream =
-      stream = stream.filter(m -> m.getGroups().contains(group));
+      memberStream = memberStream.filter(m -> m.getGroups().contains(group));
-    return stream.collect(Collectors.toSet());
+    return memberStream.collect(Collectors.toSet());
+
+  private ConfigurationManager getConfigurationManager(CacheElement config) {
+    ConfigurationManager configurationManager = managers.get(config.getClass());
+    if (configurationManager == null) {
+      throw new IllegalArgumentException(String.format("Configuration type %s is not supported",
+          config.getClass().getSimpleName()));
+    }
+
+    return configurationManager;
+  }

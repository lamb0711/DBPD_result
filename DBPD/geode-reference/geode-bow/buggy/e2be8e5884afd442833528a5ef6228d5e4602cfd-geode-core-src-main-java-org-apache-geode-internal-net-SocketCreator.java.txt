GEODE-6580: Cleanup static analyzer warnings.

-import java.security.SecureRandom;
-import java.util.Iterator;
-import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
-import org.apache.geode.admin.internal.InetAddressUtil;
+import org.apache.geode.management.internal.SSLUtil;
-  public static final String USE_LINK_LOCAL_ADDRESSES_PROPERTY =
+  private static final String USE_LINK_LOCAL_ADDRESSES_PROPERTY =
-        Set myInterfaces = getMyAddresses();
+        Set<InetAddress> myInterfaces = getMyAddresses();
-        String lhName = null;
-        for (Iterator<InetAddress> it = myInterfaces.iterator(); lhName == null && it.hasNext();) {
-          InetAddress addr = it.next();
+        for (InetAddress addr : myInterfaces) {
-              lhName = addrName;
+              break;
-              lhName = addrName;
+              break;
-        if (inetAddress == null) {
-          inetAddress = InetAddress.getLocalHost();
-        }
-    } catch (UnknownHostException e) {
+    } catch (UnknownHostException ignored) {
-    SSLContext newSSLContext = getSSLContextInstance();
+    SSLContext newSSLContext = SSLUtil.getSSLContextInstance(sslConfig);
-    for (Object entry : props.entrySet()) {
-      Map.Entry<String, String> ent = (Map.Entry<String, String>) entry;
+    for (Map.Entry<Object, Object> ent : props.entrySet()) {
+      String key = (String) ent.getKey();
-      if (ent.getKey().startsWith(DistributionConfig.SSL_SYSTEM_PROPS_NAME)
-          || ent.getKey().startsWith(DistributionConfig.SYS_PROP_NAME)) {
-        String key = ent.getKey();
+      if (key.startsWith(DistributionConfig.SSL_SYSTEM_PROPS_NAME)
+          || key.startsWith(DistributionConfig.SYS_PROP_NAME)) {
-        if (ent.getValue() == null || ent.getValue().trim().equals("")) {
+        final String value = (String) ent.getValue();
+        if (value == null || value.trim().equals("")) {
-  private SSLContext getSSLContextInstance() {
-    String[] protocols = sslConfig.getProtocolsAsStringArray();
-    SSLContext sslContext = null;
-    if (protocols != null && protocols.length > 0) {
-      for (String protocol : protocols) {
-        if (!protocol.equals("any")) {
-          try {
-            sslContext = SSLContext.getInstance(protocol);
-            break;
-          } catch (NoSuchAlgorithmException e) {
-            // continue
-          }
-        }
-      }
-    }
-    if (sslContext != null) {
-      return sslContext;
-    }
-    // lookup known algorithms
-    String[] knownAlgorithms = {"SSL", "SSLv2", "SSLv3", "TLS", "TLSv1", "TLSv1.1", "TLSv1.2"};
-    for (String algo : knownAlgorithms) {
-      try {
-        sslContext = SSLContext.getInstance(algo);
-        break;
-      } catch (NoSuchAlgorithmException e) {
-        // continue
-      }
-    }
-    return sslContext;
-  }
-
-    TrustManager[] trustManagers = null;
+    TrustManager[] trustManagers;
-    KeyManager[] keyManagers = null;
+    KeyManager[] keyManagers;
-        BindException throwMe =
-            new BindException(String.format("Failed to create server socket on %s[%s]",
-                bindAddr, Integer.valueOf(nport)));
+        BindException throwMe = new BindException(
+            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
-    ServerSocket socket = null;
-    int localPort = 0;
-    int startingPort = 0;
-    Random rand = new SecureRandom();
+    int startingPort = tcpPortRange[0]
+        + ThreadLocalRandom.current().nextInt(tcpPortRange[1] - tcpPortRange[0] + 1);
+    int localPort = startingPort;
-    int randPort = tcpPortRange[0] + rand.nextInt(tcpPortRange[1] - tcpPortRange[0] + 1);
-
-    startingPort = randPort;
-    localPort = startingPort;
+        ServerSocket socket;
-          ServerSocketChannel channl = ServerSocketChannel.open();
-          socket = channl.socket();
+          ServerSocketChannel channel = ServerSocketChannel.open();
+          socket = channel.socket();
-          InetSocketAddress addr = new InetSocketAddress(isBindAddress ? ba : null, localPort);
-          socket.bind(addr, backlog);
+          InetSocketAddress address = new InetSocketAddress(isBindAddress ? ba : null, localPort);
+          socket.bind(address, backlog);
-        break;
+        return socket;
-    return socket;
-  public static boolean treatAsBindException(SocketException se) {
+  private static boolean treatAsBindException(SocketException se) {
-          logger.fatal(
-              String.format("SSL Error in authenticating peer %s[%s].",
-                  new Object[] {socket.getInetAddress(), Integer.valueOf(socket.getPort())}),
-              ex);
+          logger.fatal(String.format("SSL Error in authenticating peer %s[%s].",
+              socket.getInetAddress(), socket.getPort()), ex);
-        }
-        // ignore
-        catch (SocketException e) {
+        } catch (SocketException ignored) {
-  private void finishServerSocket(SSLServerSocket serverSocket) throws IOException {
+  private void finishServerSocket(SSLServerSocket serverSocket) {
-        logger
-            .fatal(String.format("Problem forming SSL connection to %s[%s].",
-                socket.getInetAddress(), Integer.valueOf(socket.getPort())),
-                ex);
+        logger.fatal(String.format("Problem forming SSL connection to %s[%s].",
+            socket.getInetAddress(), socket.getPort()), ex);
-    Set<InetAddress> result = new HashSet<InetAddress>();
-    Set<InetAddress> locals = new HashSet<InetAddress>();
+    Set<InetAddress> result = new HashSet<>();
+    Set<InetAddress> locals = new HashSet<>();
-  public static String reverseDNS(InetAddress addr) {
+  private static String reverseDNS(InetAddress addr) {
-    String lookup = "";
+    StringBuilder lookup = new StringBuilder();
-      lookup = lookup + (addrBytes[index] & 0xff) + '.';
+      lookup.append(addrBytes[index] & 0xff).append('.');
-    lookup += "in-addr.arpa";
-    // System.out.println("Looking up: " + lookup);
+    lookup.append("in-addr.arpa");
-      Hashtable env = new Hashtable();
+      Hashtable<String, String> env = new Hashtable<>();
-      Attributes attrs = ctx.getAttributes(lookup, new String[] {"PTR"});
+      Attributes attrs = ctx.getAttributes(lookup.toString(), new String[] {"PTR"});
-      if (InetAddressUtil.LOCALHOST.equals(host)) {
+      InetAddress inetAddress = (InetAddress) host;
+      if (isLocalHost(inetAddress)) {
-      } else if (((InetAddress) host).isLoopbackAddress()) {
+      } else if (inetAddress.isLoopbackAddress()) {
-              if (host.equals(addr)) {
+              if (inetAddress.equals(addr)) {
-          throw new IllegalArgumentException(
-              "Unable to query network interface",
-              e);
+          throw new IllegalArgumentException("Unable to query network interface", e);
-      return isLocalHost(toInetAddress(host.toString()));
+      return isLocalHost((Object) toInetAddress(host.toString()));
+    }
+  }
+
+  private static boolean isLocalHost(InetAddress host) {
+    try {
+      return SocketCreator.getLocalHost().equals(host);
+    } catch (UnknownHostException ignored) {
+      return false;
-      if (host.indexOf("/") > -1) {
-        return InetAddress.getByName(host.substring(host.indexOf("/") + 1));
+      final int index = host.indexOf("/");
+      if (index > -1) {
+        return InetAddress.getByName(host.substring(index + 1));

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  public GatewayReceiverImpl(Cache cache, int startPort,
-      int endPort, int timeBetPings, int buffSize, String bindAdd,
-      List<GatewayTransportFilter> filters, String hostnameForSenders, boolean manualStart) {
-    this.cache = (GemFireCacheImpl)cache;
-    
+
+  public GatewayReceiverImpl(Cache cache, int startPort, int endPort, int timeBetPings,
+      int buffSize, String bindAdd, List<GatewayTransportFilter> filters, String hostnameForSenders,
+      boolean manualStart) {
+    this.cache = (GemFireCacheImpl) cache;
+
-     * If user has set hostNameForSenders then it should take precedence over
-     * bindAddress. If user hasn't set either hostNameForSenders or bindAddress
-     * then getLocalHost().getHostName() should be used.
+     * If user has set hostNameForSenders then it should take precedence over bindAddress. If user
+     * hasn't set either hostNameForSenders or bindAddress then getLocalHost().getHostName() should
+     * be used.
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayReceiverImpl_USING_LOCAL_HOST));
+          logger
+              .warn(LocalizedMessage.create(LocalizedStrings.GatewayReceiverImpl_USING_LOCAL_HOST));
-              LocalizedStrings.GatewayReceiverImpl_COULD_NOT_GET_HOST_NAME
-                  .toLocalizedString(),
-              e);
+              LocalizedStrings.GatewayReceiverImpl_COULD_NOT_GET_HOST_NAME.toLocalizedString(), e);
-  
+
-  
+
-  
+
-  
+
-      receiver.setGroups(new String[] { GatewayReceiverImpl.RECEIVER_GROUP });
-      ((CacheServerImpl)receiver).setGatewayTransportFilter(this.filters);
+      receiver.setGroups(new String[] {GatewayReceiverImpl.RECEIVER_GROUP});
+      ((CacheServerImpl) receiver).setGatewayTransportFilter(this.filters);
-        ((CacheServerImpl)receiver).start();
+        ((CacheServerImpl) receiver).start();
-            && be.getCause().getMessage()
-                .contains("assign requested address")) {
+            && be.getCause().getMessage().contains("assign requested address")) {
-                  .toLocalizedString(new Object[] { bindAdd,
-                      Integer.valueOf(this.port) }));
+                  .toLocalizedString(new Object[] {bindAdd, Integer.valueOf(this.port)}));
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayReceiver_Address_Already_In_Use, this.port));
+        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayReceiver_Address_Already_In_Use,
+            this.port));
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayReceiver_Address_Already_In_Use, this.port));
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.GatewayReceiver_Address_Already_In_Use, this.port));
-      
+
-      throw new IllegalStateException(
-          "No available free port found in the given range.");
+      throw new IllegalStateException("No available free port found in the given range.");
-    logger.info(LocalizedMessage.create(LocalizedStrings.GatewayReceiver_STARTED_ON_PORT, this.port));
+    logger
+        .info(LocalizedMessage.create(LocalizedStrings.GatewayReceiver_STARTED_ON_PORT, this.port));
-  
-  private int getPortToStart(){
+
+  private int getPortToStart() {
-      rPort = AvailablePort.getRandomAvailablePortInRange(this.startPort,
-          this.endPort, AvailablePort.SOCKET);
+      rPort = AvailablePort.getRandomAvailablePortInRange(this.startPort, this.endPort,
+          AvailablePort.SOCKET);
-  
+
-    if(!isRunning()){
-      throw new GatewayReceiverException(LocalizedStrings.GatewayReceiver_IS_NOT_RUNNING.toLocalizedString());
+    if (!isRunning()) {
+      throw new GatewayReceiverException(
+          LocalizedStrings.GatewayReceiver_IS_NOT_RUNNING.toLocalizedString());
-//    InternalDistributedSystem system = ((GemFireCacheImpl) this.cache)
-//        .getDistributedSystem();
-//    system.handleResourceEvent(ResourceEvent.GATEWAYRECEIVER_STOP, this);
+    // InternalDistributedSystem system = ((GemFireCacheImpl) this.cache)
+    // .getDistributedSystem();
+    // system.handleResourceEvent(ResourceEvent.GATEWAYRECEIVER_STOP, this);
-  
+
-    return new StringBuffer()
-      .append("Gateway Receiver")
-      .append("@").append(Integer.toHexString(hashCode()))
-      .append(" [")
-      .append("host='").append(getHost())
-      .append("'; port=").append(getPort())
-      .append("; bindAddress=").append(getBindAddress())
-      .append("; maximumTimeBetweenPings=").append(getMaximumTimeBetweenPings())
-      .append("; socketBufferSize=").append(getSocketBufferSize())
-      .append("; isManualStart=").append(isManualStart())
-      .append("; group=").append(Arrays.toString(new String[]{GatewayReceiverImpl.RECEIVER_GROUP}))
-      .append("]")
-      .toString();
+    return new StringBuffer().append("Gateway Receiver").append("@")
+        .append(Integer.toHexString(hashCode())).append(" [").append("host='").append(getHost())
+        .append("'; port=").append(getPort()).append("; bindAddress=").append(getBindAddress())
+        .append("; maximumTimeBetweenPings=").append(getMaximumTimeBetweenPings())
+        .append("; socketBufferSize=").append(getSocketBufferSize()).append("; isManualStart=")
+        .append(isManualStart()).append("; group=")
+        .append(Arrays.toString(new String[] {GatewayReceiverImpl.RECEIVER_GROUP})).append("]")
+        .toString();
-   
+

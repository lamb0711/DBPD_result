Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-
- * This class is the proxy handler for all the proxies created for federated
- * MBeans. Its designed with Java proxy mechanism. All data calls are 
- * delegated to the federation components.
- * All method calls are routed to specified members via Function service
+ * This class is the proxy handler for all the proxies created for federated MBeans. Its designed
+ * with Java proxy mechanism. All data calls are delegated to the federation components. All method
+ * calls are routed to specified members via Function service
-  
+
- 
+
-  
+
-  
-  
+
+
-   * @param member
-   *          member to which this MBean belongs
-   * @param monitoringRegion
-   *          corresponding MonitoringRegion
-   * @param objectName
-   *          ObjectName of the MBean
-   * @param interfaceClass
-   *          on which interface the proxy to be exposed
+   * @param member member to which this MBean belongs
+   * @param monitoringRegion corresponding MonitoringRegion
+   * @param objectName ObjectName of the MBean
+   * @param interfaceClass on which interface the proxy to be exposed
-      Region<String, Object> monitoringRegion, ObjectName objectName,
-      Class interfaceClass) throws ClassNotFoundException,
-      IntrospectionException {
+      Region<String, Object> monitoringRegion, ObjectName objectName, Class interfaceClass)
+      throws ClassNotFoundException, IntrospectionException {
-    boolean notificationBroadcaster = ((FederationComponent) monitoringRegion
-        .get(objectName.toString())).isNotificationEmitter();
+    boolean notificationBroadcaster =
+        ((FederationComponent) monitoringRegion.get(objectName.toString())).isNotificationEmitter();
-    InvocationHandler handler = new MBeanProxyInvocationHandler(member,
-        objectName, monitoringRegion, isMXBean);
+    InvocationHandler handler =
+        new MBeanProxyInvocationHandler(member, objectName, monitoringRegion, isMXBean);
-      interfaces = new Class[] { interfaceClass, ProxyInterface.class,
-          NotificationBroadCasterProxy.class };
+      interfaces =
+          new Class[] {interfaceClass, ProxyInterface.class, NotificationBroadCasterProxy.class};
-      interfaces = new Class[] { interfaceClass, ProxyInterface.class };
+      interfaces = new Class[] {interfaceClass, ProxyInterface.class};
-    Object proxy = Proxy.newProxyInstance(MBeanProxyInvocationHandler.class
-        .getClassLoader(), interfaces, handler);
+    Object proxy = Proxy.newProxyInstance(MBeanProxyInvocationHandler.class.getClassLoader(),
+        interfaces, handler);
-   * @param member
-   *          member to which this MBean belongs
-   * @param objectName
-   *          ObjectName of the MBean
-   * @param monitoringRegion
-   *          corresponding MonitoringRegion
+   * @param member member to which this MBean belongs
+   * @param objectName ObjectName of the MBean
+   * @param monitoringRegion corresponding MonitoringRegion
-  private MBeanProxyInvocationHandler(DistributedMember member,
-      ObjectName objectName, Region<String, Object> monitoringRegion, boolean isMXBean)
+  private MBeanProxyInvocationHandler(DistributedMember member, ObjectName objectName,
+      Region<String, Object> monitoringRegion, boolean isMXBean)
-    
+
-   * Inherited method from Invocation handler All object state requests are
-   * delegated to the federated component.
+   * Inherited method from Invocation handler All object state requests are delegated to the
+   * federated component.
-  public Object invoke(Object proxy, Method method, Object[] args)
-      throws Throwable {
+  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-   
-    
+
+
-  
-    
+
+
-    
+
-    if (shouldDoLocally(proxy, method)){
+    if (shouldDoLocally(proxy, method)) {
-      
+
-      return p.invoke( proxy, method, args);
+      return p.invoke(proxy, method, args);
-    if (methodName.startsWith("is")
-        && methodName.length() > 2
-        && nargs == 0
+    if (methodName.startsWith("is") && methodName.length() > 2 && nargs == 0
-  
-   
+
-   * As this proxy may behave as an notification emitter it delegates to the
-   * member NotificationBroadcasterSupport object
+   * As this proxy may behave as an notification emitter it delegates to the member
+   * NotificationBroadcasterSupport object
-   * This will get the data from Object state which is replicated across the
-   * hidden region FederataionComponent being the carrier.
+   * This will get the data from Object state which is replicated across the hidden region
+   * FederataionComponent being the carrier.
-    
+
-      FederationComponent fedComp = (FederationComponent) monitoringRegion
-          .get(objectName.toString());
+      FederationComponent fedComp =
+          (FederationComponent) monitoringRegion.get(objectName.toString());
-   * @param objectName
-   *          ObjectName of the MBean
-   * @param methodName
-   *          method name
-   * @param args
-   *          arguments to the methods
-   * @param signature
-   *          signature of the method
+   * @param objectName ObjectName of the MBean
+   * @param methodName method name
+   * @param args arguments to the methods
+   * @param signature signature of the method
-  protected Object delegateToFucntionService(ObjectName objectName,
-      String methodName, Object[] args, String[] signature) throws Throwable {
+  protected Object delegateToFucntionService(ObjectName objectName, String methodName,
+      Object[] args, String[] signature) throws Throwable {
-      ResultCollector rc = FunctionService.onMember(member).withArgs(
-          functionArgs).execute(ManagementConstants.MGMT_FUNCTION_ID);
+      ResultCollector rc = FunctionService.onMember(member).withArgs(functionArgs)
+          .execute(ManagementConstants.MGMT_FUNCTION_ID);
-     
+
-      } 
-      //Only in case of Exception caused for Function framework.
+      }
+      // Only in case of Exception caused for Function framework.
-      }    
+      }
-  
+
-   
-    
+
+
-   * The call will delegate to Managed Node for NotificationHub to register a
-   * local listener to listen for notification from the MBean
+   * The call will delegate to Managed Node for NotificationHub to register a local listener to
+   * listen for notification from the MBean
-   * Moreover it will also add the client to local listener list by adding to
-   * the contained emitter.
+   * Moreover it will also add the client to local listener list by adding to the contained emitter.
-   * @param proxy
-   *          the proxy object
-   * @param method
-   *          method to be invoked
-   * @param args
-   *          method arguments
+   * @param proxy the proxy object
+   * @param method method to be invoked
+   * @param args method arguments
-  private Object invokeBroadcasterMethod(Object proxy, Method method,
-      Object[] args) throws Throwable {
+  private Object invokeBroadcasterMethod(Object proxy, Method method, Object[] args)
+      throws Throwable {
-       * The various throws of IllegalArgumentException here should not happen,
-       * since we know what the methods in NotificationBroadcaster and
-       * NotificationEmitter are.
+       * The various throws of IllegalArgumentException here should not happen, since we know what
+       * the methods in NotificationBroadcaster and NotificationEmitter are.
-       * NullPointerException if method with no args, but that shouldn't happen
-       * because removeNL does have args.
+       * NullPointerException if method with no args, but that shouldn't happen because removeNL
+       * does have args.
-      case 1:
-        emitter.removeNotificationListener(listener);
-        /**
-         * No need to send listener and filter details to other members.
-         * We only need to send a message saying remove the listner registered for this object on your side.
-         * Fixes Bug[ #47075 ] 
-         */
-        delegateToFucntionService(objectName, methodName, null, signature);
-        return null;
+        case 1:
+          emitter.removeNotificationListener(listener);
+          /**
+           * No need to send listener and filter details to other members. We only need to send a
+           * message saying remove the listner registered for this object on your side. Fixes Bug[
+           * #47075 ]
+           */
+          delegateToFucntionService(objectName, methodName, null, signature);
+          return null;
-      case 3:
-        NotificationFilter filter = (NotificationFilter) args[1];
-        Object handback = args[2];
-        emitter.removeNotificationListener(listener, filter, handback);
+        case 3:
+          NotificationFilter filter = (NotificationFilter) args[1];
+          Object handback = args[2];
+          emitter.removeNotificationListener(listener, filter, handback);
-        delegateToFucntionService(objectName, methodName, null, signature);
-        return null;
+          delegateToFucntionService(objectName, methodName, null, signature);
+          return null;
-      default:
-        final String msg = "Bad arg count to removeNotificationListener: "
-            + nargs;
-        throw new IllegalArgumentException(msg);
+        default:
+          final String msg = "Bad arg count to removeNotificationListener: " + nargs;
+          throw new IllegalArgumentException(msg);
-       
-      if(!MBeanJMXAdapter.mbeanServer.isRegistered(objectName)){
+
+      if (!MBeanJMXAdapter.mbeanServer.isRegistered(objectName)) {
-      
+
-       * MBean info is delegated to function service as intention is to get the
-       * info of the actual mbean rather than the proxy
+       * MBean info is delegated to function service as intention is to get the info of the actual
+       * mbean rather than the proxy
-      
-      
-      Object obj = delegateToFucntionService(objectName,
-          methodName, args, signature);
-      if(obj instanceof String){
-          return new MBeanNotificationInfo[0];
+
+
+      Object obj = delegateToFucntionService(objectName, methodName, args, signature);
+      if (obj instanceof String) {
+        return new MBeanNotificationInfo[0];
-  
- 
+
+
-        && Arrays.equals(method.getParameterTypes(),
-            new Class[] { Object.class }))
+        && Arrays.equals(method.getParameterTypes(), new Class[] {Object.class}))
-    FederationComponent fedComp = (FederationComponent) monitoringRegion
-        .get(objectName.toString());
+    FederationComponent fedComp = (FederationComponent) monitoringRegion.get(objectName.toString());
-      Class<?> mxbeanInterface, MBeanProxyInvocationHandler handler)
-      throws Throwable {
+      Class<?> mxbeanInterface, MBeanProxyInvocationHandler handler) throws Throwable {
-          mxbeanInvocationRef = new MXBeanProxyInvocationHandler(objectName,
-              mxbeanInterface, handler);
+          mxbeanInvocationRef =
+              new MXBeanProxyInvocationHandler(objectName, mxbeanInterface, handler);
-          String msg = "Cannot make MXBean proxy for "
-              + mxbeanInterface.getName() + ": " + e.getMessage();
+          String msg =
+              "Cannot make MXBean proxy for " + mxbeanInterface.getName() + ": " + e.getMessage();
- 
+

GEODE-6708: Ensuring single drainer and preventing NPE

+import java.util.concurrent.locks.ReentrantLock;
-    // As an optimization, we drain as many events from the queue as we can
-    // before taking out a lock to drain the remaining events
-    if (logger.isDebugEnabled()) {
-      logger.debug("Draining events from registration queue for client proxy "
-          + clientProxyMembershipID
-          + " without synchronization");
-    }
-
-    drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID, cacheClientNotifier);
-
-    registrationEventQueue.lockForDraining();
-    try {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Draining remaining events from registration queue for client proxy "
-            + clientProxyMembershipID + " with synchronization");
+    if (registrationEventQueue != null) {
+      // It is possible that several client registration threads are active for the same
+      // ClientProxyMembershipID, in which case we only want a single drainer to drain
+      // and remove the queue.
+      registrationEventQueue.lockForSingleDrainer();
+      try {
+        // See if the queue is still available after acquiring the lock as it may have
+        // been removed from registeringProxyEventQueues by the previous thread
+        if (registeringProxyEventQueues.containsKey(clientProxyMembershipID)) {
+          // As an optimization, we drain as many events from the queue as we can
+          // before taking out a lock to drain the remaining events. When we lock for draining,
+          // it prevents additional events from being added to the queue while the queue is drained
+          // and removed.
+          if (logger.isDebugEnabled()) {
+            logger.debug("Draining events from registration queue for client proxy "
+                + clientProxyMembershipID
+                + " without synchronization");
+          }
+
+          drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID, registrationEventQueue,
+              cacheClientNotifier);
+
+          // Prevents additional events from being added to the queue while we process and remove it
+          registrationEventQueue.lockForDraining();
+          try {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Draining remaining events from registration queue for client proxy "
+                  + clientProxyMembershipID + " with synchronization");
+            }
+
+            drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID,
+                registrationEventQueue,
+                cacheClientNotifier);
+
+            registeringProxyEventQueues.remove(clientProxyMembershipID);
+          } finally {
+            registrationEventQueue.unlockForDraining();
+          }
+        }
+      } finally {
+        registrationEventQueue.unlockForSingleDrainer();
-
-      drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID, cacheClientNotifier);
-
-      registeringProxyEventQueues.remove(clientProxyMembershipID);
-    } finally {
-      registrationEventQueue.unlockForDraining();
+      final ClientRegistrationEventQueue registrationEventQueue,
-    ClientRegistrationEventQueue registrationEventQueue = registeringProxyEventQueues.get(proxyID);
-
-      final ReadWriteLock putDrainLock) {
+      final ReadWriteLock eventAddDrainLock,
+      final ReentrantLock singleDrainerLock) {
-            putDrainLock);
-    registeringProxyEventQueues.put(clientProxyMembershipID,
+            eventAddDrainLock, singleDrainerLock);
+    registeringProxyEventQueues.putIfAbsent(clientProxyMembershipID,
-    Queue<ClientRegistrationEvent> eventQueue;
-    ReadWriteLock readWriteLock;
+    private final Queue<ClientRegistrationEvent> eventQueue;
+    private final ReadWriteLock eventAddDrainLock;
+    private final ReentrantLock singleDrainerLock;
-        final Queue<ClientRegistrationEvent> eventQueue, final ReadWriteLock readWriteLock) {
+        final Queue<ClientRegistrationEvent> eventQueue,
+        final ReadWriteLock eventAddDrainLock,
+        final ReentrantLock singleDrainerLock) {
-      this.readWriteLock = readWriteLock;
+      this.eventAddDrainLock = eventAddDrainLock;
+      this.singleDrainerLock = singleDrainerLock;
-      readWriteLock.writeLock().lock();
+      eventAddDrainLock.writeLock().lock();
-      readWriteLock.writeLock().unlock();
+      eventAddDrainLock.writeLock().unlock();
-      readWriteLock.readLock().lock();
+      eventAddDrainLock.readLock().lock();
-      readWriteLock.readLock().unlock();
+      eventAddDrainLock.readLock().unlock();
+    }
+
+    private void lockForSingleDrainer() {
+      singleDrainerLock.lock();
+    }
+
+    private void unlockForSingleDrainer() {
+      singleDrainerLock.unlock();

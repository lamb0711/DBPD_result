Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.cache.RegionDestroyedException;
-  private static final Logger logger = LogService.getLogger();
+  protected static final Logger logger = LogService.getLogger();
+      GatewaySenderEventImpl event = (GatewaySenderEventImpl)conflatableObject;
-        String regionPath = ColocationHelper.getLeaderRegion(
-            (PartitionedRegion)((GatewaySenderEventImpl)conflatableObject)
-                .getRegion()).getFullPath();
+        String regionPath = ColocationHelper.getLeaderRegion((PartitionedRegion)event.getRegion()).getFullPath();
-            this, deserialize(conflatableObject.getValueToConflate()), conflatableObject.getKeyToConflate(), prQ.getName());
+            this, conflatableObject.getValueToConflate(), conflatableObject.getKeyToConflate(), prQ.getName());
-      if(userPR.getDataPolicy().withPersistence() && !sender.isPersistenceEnabled()){
+      if(!isUsedForHDFS() && userPR.getDataPolicy().withPersistence() && !sender.isPersistenceEnabled()){
-            prQName, ra, null, cache, sender);
+            prQName, ra, null, cache, sender, isUsedForHDFS());
+          // at this point we should be able to assert prQ == meta; 
+  protected boolean isUsedForHDFS()
+  {
+    return false;
+  }
+//      value.freeOffHeapValue();
+      value.release();
+        value.release();
-            //value.freeOffHeapValue();
+            value.release();
-              //value.freeOffHeapValue();
+              value.release();
-          //value.freeOffHeapValue();
+          value.release();
+    boolean addedValueToQueue = false;
-        brq.addToQueue(key, value);
+        addedValueToQueue = brq.addToQueue(key, value);
+    } finally {
+      if (!addedValueToQueue) {
+        value.release();
+      }
+      try {
+      } finally {
+        event.release();
+      }
-    return object;
+    return object; // OFFHEAP: ok since only callers uses it to check for empty queue
-    Object object = null;
-    int bId = -1;
+    int bId = -1;
-        object = peekAhead(prQ, bId);
+        GatewaySenderEventImpl object = (GatewaySenderEventImpl) peekAhead(prQ, bId);
+        if (object != null) {
+          GatewaySenderEventImpl copy = object.makeHeapCopyIfOffHeap();
+          if (copy == null) {
+            continue;
+          }
+          object = copy;
+        }
-          peekedEvents.add((GatewaySenderEventImpl)object);
+          peekedEvents.add(object);
-    return object;
+    return object; // OFFHEAP: ok since callers are careful to do destroys on region queue after finished with peeked object.
+  @Override
+  public void close() {
+    // Because of bug 49060 do not close the regions of a parallel queue
+//    for (Region r: getRegions()) {
+//      if (r != null && !r.isDestroyed()) {
+//        try {
+//          r.close();
+//        } catch (RegionDestroyedException e) {
+//        }
+//      }
+//    }
+  }
+
+      this( regionName, attrs, parentRegion, cache, pgSender, false);
+    }
+    public ParallelGatewaySenderQueueMetaRegion(String regionName,
+        RegionAttributes attrs, LocalRegion parentRegion,
+        GemFireCacheImpl cache, AbstractGatewaySender pgSender, boolean isUsedForHDFS) {
-              .setParallelGatewaySender((AbstractGatewaySender)pgSender));
+              .setParallelGatewaySender((AbstractGatewaySender)pgSender)
+              .setIsUsedForHDFSParallelGatewaySenderQueue(isUsedForHDFS));

GEODE-6897: implement CMS rebalance operation (#3820)


+import java.util.Date;
+import java.util.List;
-import java.util.function.Function;
+import java.util.function.BiFunction;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.management.api.JsonSerializable;
+import org.apache.geode.management.operation.RebalanceOperation;
+import org.apache.geode.management.runtime.OperationResult;
-  private final Map<Class<? extends ClusterManagementOperation>, Function> performers;
+  private final Map<Class<? extends ClusterManagementOperation>, BiFunction> performers;
+  private final InternalCache cache;
-  public OperationManager(OperationHistoryManager historyManager) {
+  public OperationManager(InternalCache cache, OperationHistoryManager historyManager) {
+    this.cache = cache;
+    registerOperation(RebalanceOperation.class, RebalanceOperationPerformer::perform);
-  public <A extends ClusterManagementOperation<V>, V extends JsonSerializable> void registerOperation(
-      Class<A> operationClass, Function<A, V> operationPerformer) {
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> void registerOperation(
+      Class<A> operationClass, BiFunction<Cache, A, V> operationPerformer) {
-  public <A extends ClusterManagementOperation<V>, V extends JsonSerializable> OperationInstance<A, V> submit(
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationInstance<A, V> submit(
-    Function<A, V> performer = getPerformer(op);
+    BiFunction<Cache, A, V> performer = getPerformer(op);
-        CompletableFuture.supplyAsync(() -> performer.apply(op), executor);
+        CompletableFuture.supplyAsync(() -> performer.apply(cache, op), executor);
-    OperationInstance<A, V> inst = new OperationInstance<>(future, opId, op);
+    OperationInstance<A, V> inst = new OperationInstance<>(future, opId, op, new Date());
-  private <A extends ClusterManagementOperation<V>, V extends JsonSerializable> Function<A, V> getPerformer(
+  private <C extends Cache, A extends ClusterManagementOperation<V>, V extends OperationResult> BiFunction<C, A, V> getPerformer(
-    return performers.get(op.getClass());
+    Class<? extends ClusterManagementOperation> aClass = op.getClass();
+
+    if (op instanceof TaggedWithOperator
+        && ClusterManagementOperation.class.isAssignableFrom(aClass.getSuperclass())) {
+      aClass = (Class<? extends ClusterManagementOperation>) aClass.getSuperclass();
+    }
+
+    return performers.get(aClass);
-  @SuppressWarnings("unchecked")
-  public <V extends JsonSerializable> CompletableFuture<V> getStatus(String opId) {
-    return historyManager.getStatus(opId);
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> OperationInstance<A, V> getOperationInstance(
+      String opId) {
+    return historyManager.getOperationInstance(opId);
+  }
+
+  public <A extends ClusterManagementOperation<V>, V extends OperationResult> List<OperationInstance<A, V>> listOperationInstances(
+      A opType) {
+    return historyManager.listOperationInstances(opType);

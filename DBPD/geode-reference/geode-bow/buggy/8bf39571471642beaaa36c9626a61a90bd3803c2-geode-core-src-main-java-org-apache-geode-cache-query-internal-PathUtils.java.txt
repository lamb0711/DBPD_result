Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.query.QueryService; 
+import org.apache.geode.cache.query.QueryService;
- * @version     $Revision: 1.1 $
+ * @version $Revision: 1.1 $
-  
+
-    return (String[])alist.toArray(new String[alist.size()]);
+    return (String[]) alist.toArray(new String[alist.size()]);
-  
+
-    for (int i = 1 ; i < path.length; i++) {
+    for (int i = 1; i < path.length; i++) {
-  
+
-  throws NameNotFoundException, QueryInvocationTargetException {
-    if(target instanceof Struct){
-      Struct struct = (Struct)target;
-      try{
+      throws NameNotFoundException, QueryInvocationTargetException {
+    if (target instanceof Struct) {
+      Struct struct = (Struct) target;
+      try {
-      }catch(Exception e){
+      } catch (Exception e) {
-      if (DefaultQueryService.QUERY_HETEROGENEOUS_OBJECTS ||
-          DefaultQueryService.TEST_QUERY_HETEROGENEOUS_OBJECTS) {
+      if (DefaultQueryService.QUERY_HETEROGENEOUS_OBJECTS
+          || DefaultQueryService.TEST_QUERY_HETEROGENEOUS_OBJECTS) {
-   * This was added as part of CQ performance changes.
-   * The change is done to re-use the AttributeDescriptor object instead of creating
-   * it each time. 
+   * This was added as part of CQ performance changes. The change is done to re-use the
+   * AttributeDescriptor object instead of creating it each time.
-  public static Object evaluateAttribute(Object target, String attribute, AttributeDescriptor attributeDescriptor)
-  throws NameNotFoundException, QueryInvocationTargetException {
-    if(target instanceof Struct){
-      Struct struct = (Struct)target;
-      try{
-        return struct.get(attribute);
-      }catch(Exception e){
-        throw new NameNotFoundException(attribute);
-      }
-    }
-    return attributeDescriptor.read(target);
-  }
-  */
-  
+   * public static Object evaluateAttribute(Object target, String attribute, AttributeDescriptor
+   * attributeDescriptor) throws NameNotFoundException, QueryInvocationTargetException { if(target
+   * instanceof Struct){ Struct struct = (Struct)target; try{ return struct.get(attribute);
+   * }catch(Exception e){ throw new NameNotFoundException(attribute); } } return
+   * attributeDescriptor.read(target); }
+   */
+
-   * @param pathArray the path starting with an attribute on
-   * the initial type.
-   * @return array of types starting with the initialType and
-   * ending with the type of the last attribute in the path.
+   * @param pathArray the path starting with an attribute on the initial type.
+   * @return array of types starting with the initialType and ending with the type of the last
+   *         attribute in the path.
-  public static ObjectType[] calculateTypesAlongPath(ObjectType initialType,
-          String[] pathArray)
-          throws NameNotFoundException {
+  public static ObjectType[] calculateTypesAlongPath(ObjectType initialType, String[] pathArray)
+      throws NameNotFoundException {
-    
+
-      Member member = new AttributeDescriptor(pathArray[i-1]).getReadMember(currentType);
+      Member member = new AttributeDescriptor(pathArray[i - 1]).getReadMember(currentType);
-        types[i] = TypeUtils.getObjectType(((Field)member).getType());
+        types[i] = TypeUtils.getObjectType(((Field) member).getType());
-        types[i] = TypeUtils.getObjectType(((Method)member).getReturnType());
+        types[i] = TypeUtils.getObjectType(((Method) member).getReturnType());
-  
-  
-  public static ObjectType computeElementTypeOfExpression(
-      ExecutionContext context, CompiledValue expr)
-      throws AmbiguousNameException
-  {
+
+
+  public static ObjectType computeElementTypeOfExpression(ExecutionContext context,
+      CompiledValue expr) throws AmbiguousNameException {
-          CompiledPath path = (CompiledPath)expr;
+          CompiledPath path = (CompiledPath) expr;
-        }
-        else if (expr instanceof CompiledOperation) {
-          CompiledOperation operation = (CompiledOperation)expr;
+        } else if (expr instanceof CompiledOperation) {
+          CompiledOperation operation = (CompiledOperation) expr;
-            expr = context.resolveImplicitOperationName(operation
-                .getMethodName(), operation.getArguments().size(), true);
+            expr = context.resolveImplicitOperationName(operation.getMethodName(),
+                operation.getArguments().size(), true);
-        }
-        else if (expr instanceof CompiledID) {
-          expr = context.resolve(((CompiledID)expr).getId());
-        }
-        else if (expr instanceof CompiledRegion) {
-          QRegion qrgn = (QRegion)((CompiledRegion)expr).evaluate(context);
+        } else if (expr instanceof CompiledID) {
+          expr = context.resolve(((CompiledID) expr).getId());
+        } else if (expr instanceof CompiledRegion) {
+          QRegion qrgn = (QRegion) ((CompiledRegion) expr).evaluate(context);
-        }
-        else if (expr instanceof RuntimeIterator) {
-          type = ((RuntimeIterator)expr).getElementType();
+        } else if (expr instanceof RuntimeIterator) {
+          type = ((RuntimeIterator) expr).getElementType();
-        }
-        else {
+        } else {
-          String stepStr = (String)exprSteps.get(i);
+          String stepStr = (String) exprSteps.get(i);
-            member = clazz.getMethod(stepStr, (Class[])null);
-          }
-          else {
+            member = clazz.getMethod(stepStr, (Class[]) null);
+          } else {
-            clazz = ((Field)member).getType();
-          }
-          else if (member instanceof Method) {
-            clazz = ((Method)member).getReturnType();
+            clazz = ((Field) member).getType();
+          } else if (member instanceof Method) {
+            clazz = ((Method) member).getReturnType();
-    }
-    catch (NoSuchMethodException e) {
-    }
-    catch (NameResolutionException e) {
-    }
-    catch (TypeMismatchException e) {
+    } catch (NoSuchMethodException e) {
+    } catch (NameResolutionException e) {
+    } catch (TypeMismatchException e) {
-  
+
-   * Collects all the compiled values in the path , starting from the self at
-   * position 0 in the returned List
+   * Collects all the compiled values in the path , starting from the self at position 0 in the
+   * returned List
-  public static List<CompiledValue> collectCompiledValuesInThePath(
-      CompiledValue expr, ExecutionContext context)
-      throws AmbiguousNameException, TypeMismatchException {
+  public static List<CompiledValue> collectCompiledValuesInThePath(CompiledValue expr,
+      ExecutionContext context) throws AmbiguousNameException, TypeMismatchException {
-      case OQLLexerTokenTypes.RegionPath:
-        retList.add(expr);
-        toContinue = false;
-        break;
-      case OQLLexerTokenTypes.METHOD_INV:
-        retList.add(expr);
-        CompiledOperation operation = (CompiledOperation) expr;
-        expr = operation.getReceiver(null/*
-                                          * pass the ExecutionContext as null,
-                                          * thus never implicitly resolving to
-                                          * RuntimeIterator
-                                          */);
-        if (expr == null) {
-          expr = operation;
+        case OQLLexerTokenTypes.RegionPath:
+          retList.add(expr);
-        }
-        break;
-      case CompiledValue.PATH:
-        retList.add(expr);
-        expr = ((CompiledPath) expr).getReceiver();
-        break;
-      case OQLLexerTokenTypes.ITERATOR_DEF:
-        retList.add(expr);
-        toContinue = false;
-        break;
-      case OQLLexerTokenTypes.TOK_LBRACK:
-        retList.add(expr);
-        expr = ((CompiledIndexOperation) expr).getReceiver();
-        break;
-      case OQLLexerTokenTypes.Identifier:
-        CompiledID cid = (CompiledID) expr;
-        expr = context.resolve(cid.getId());
-        break;
-      default:
-        toContinue = false;
-        break;
+          break;
+        case OQLLexerTokenTypes.METHOD_INV:
+          retList.add(expr);
+          CompiledOperation operation = (CompiledOperation) expr;
+          expr = operation.getReceiver(null/*
+                                            * pass the ExecutionContext as null, thus never
+                                            * implicitly resolving to RuntimeIterator
+                                            */);
+          if (expr == null) {
+            expr = operation;
+            toContinue = false;
+          }
+          break;
+        case CompiledValue.PATH:
+          retList.add(expr);
+          expr = ((CompiledPath) expr).getReceiver();
+          break;
+        case OQLLexerTokenTypes.ITERATOR_DEF:
+          retList.add(expr);
+          toContinue = false;
+          break;
+        case OQLLexerTokenTypes.TOK_LBRACK:
+          retList.add(expr);
+          expr = ((CompiledIndexOperation) expr).getReceiver();
+          break;
+        case OQLLexerTokenTypes.Identifier:
+          CompiledID cid = (CompiledID) expr;
+          expr = context.resolve(cid.getId());
+          break;
+        default:
+          toContinue = false;
+          break;

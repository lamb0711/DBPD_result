GEODE-6626: Separate CacheServer and GatewayReceiver

Introduce new interfaces and then have GatewayReceiverServer extend
CacheServerImpl to override behavior.

+import java.util.function.Supplier;
+import org.apache.geode.StatisticsFactory;
-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.tier.OverflowAttributes;
+import org.apache.geode.internal.cache.tier.sockets.CacheClientNotifier.CacheClientNotifierProvider;
+import org.apache.geode.internal.cache.tier.sockets.ClientHealthMonitor.ClientHealthMonitorProvider;
-import org.apache.geode.internal.net.SocketCreatorFactory;
-import org.apache.geode.internal.security.SecurableCommunicationChannel;
-public class AcceptorImpl implements Acceptor, Runnable, CommBufferPool {
+public class AcceptorImpl implements Acceptor, Runnable {
-  // private final Selector tmpSel;
+
-   * The mininum value of max-connections
+   * The minimum value of max-connections
+
+
+   * Constructs an AcceptorImpl for use within a CacheServer.
+   *
+   * <p>
+   * @param securityService the SecurityService to use for authentication and authorization
+   *
+   *
-  public AcceptorImpl(int port, String bindHostName, boolean notifyBySubscription,
-      int socketBufferSize, int maximumTimeBetweenPings,
-      InternalCache internalCache,
-      int maxConnections, int maxThreads, int maximumMessageCount,
-      int messageTimeToLive,
-      ConnectionListener listener, List overflowAttributesList,
-      boolean isGatewayReceiver,
-      List<GatewayTransportFilter> transportFilter, boolean tcpNoDelay,
-      ServerConnectionFactory serverConnectionFactory, long timeLimitMillis) throws IOException {
-    securityService = internalCache.getSecurityService();
-    this.bindHostName = calcBindHostName(internalCache, bindHostName);
-    connectionListener = listener == null ? new ConnectionListenerAdapter() : listener;
-    this.notifyBySubscription = notifyBySubscription;
+  AcceptorImpl(final int port, final String bindHostName, final boolean notifyBySubscription,
+      final int socketBufferSize, final int maximumTimeBetweenPings,
+      final InternalCache internalCache, final int maxConnections, final int maxThreads,
+      final int maximumMessageCount, final int messageTimeToLive,
+      final ConnectionListener connectionListener, final OverflowAttributes overflowAttributes,
+      final boolean tcpNoDelay, final ServerConnectionFactory serverConnectionFactory,
+      final long timeLimitMillis, final SecurityService securityService,
+      final Supplier<SocketCreator> socketCreatorSupplier,
+      final CacheClientNotifierProvider cacheClientNotifierProvider,
+      final ClientHealthMonitorProvider clientHealthMonitorProvider) throws IOException {
+    this(port, bindHostName, notifyBySubscription, socketBufferSize, maximumTimeBetweenPings,
+        internalCache, maxConnections, maxThreads, maximumMessageCount, messageTimeToLive,
+        connectionListener, overflowAttributes, tcpNoDelay, serverConnectionFactory,
+        timeLimitMillis, securityService, socketCreatorSupplier, cacheClientNotifierProvider,
+        clientHealthMonitorProvider, false, Collections.emptyList());
+  }
+
+  /**
+   * Constructs an AcceptorImpl for use within a GatewayReceiver.
+   *
+   * <p>
+   * Initializes this acceptor thread to listen for connections on the given port.
+   *
+   * @param port The port on which this acceptor listens for connections. If {@code 0}, a
+   *        random port will be chosen.
+   * @param bindHostName The ip address or host name this acceptor listens on for connections. If
+   *        {@code null} or "" then all local addresses are used
+   * @param socketBufferSize The buffer size for server-side sockets
+   * @param maximumTimeBetweenPings The maximum time between client pings. This value is used by the
+   *        {@code ClientHealthMonitor} to monitor the health of this server's clients.
+   * @param internalCache The GemFire cache whose contents is served to clients
+   * @param maxConnections the maximum number of connections allowed in the server pool
+   * @param maxThreads the maximum number of threads allowed in the server pool
+   * @param securityService the SecurityService to use for authentication and authorization
+   * @param gatewayReceiver the GatewayReceiver that will use this AcceptorImpl instance
+   * @param gatewayReceiverMetrics the GatewayReceiverMetrics to use for exposing metrics
+   * @param gatewayTransportFilters List of GatewayTransportFilters
+   */
+  AcceptorImpl(final int port, final String bindHostName, final boolean notifyBySubscription,
+      final int socketBufferSize, final int maximumTimeBetweenPings,
+      final InternalCache internalCache, final int maxConnections, final int maxThreads,
+      final int maximumMessageCount, final int messageTimeToLive,
+      final ConnectionListener connectionListener, final OverflowAttributes overflowAttributes,
+      final boolean tcpNoDelay, final ServerConnectionFactory serverConnectionFactory,
+      final long timeLimitMillis, final SecurityService securityService,
+      final Supplier<SocketCreator> socketCreatorSupplier,
+      final CacheClientNotifierProvider cacheClientNotifierProvider,
+      final ClientHealthMonitorProvider clientHealthMonitorProvider,
+      final boolean isGatewayReceiver,
+      final List<GatewayTransportFilter> gatewayTransportFilters) throws IOException {
+    this.securityService = securityService;
+
-    gatewayTransportFilters = transportFilter;
+    this.gatewayTransportFilters = gatewayTransportFilters;
+
+    this.bindHostName = calcBindHostName(internalCache, bindHostName);
+    this.connectionListener =
+        connectionListener == null ? new ConnectionListenerAdapter() : connectionListener;
+    this.notifyBySubscription = notifyBySubscription;
+
-      if (!isGatewayReceiver) {
-        // If configured use SSL properties for cache-server
-        socketCreator =
-            SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.SERVER);
-      } else {
-        socketCreator = SocketCreatorFactory
-            .getSocketCreatorForComponent(SecurableCommunicationChannel.GATEWAY);
-      }
+      socketCreator = socketCreatorSupplier.get();
-                gatewayTransportFilters, socketBufferSize);
+                this.gatewayTransportFilters, socketBufferSize);
-        port = serverSock.getLocalPort();
+        localPort = serverSock.getLocalPort();
+      } else {
+        localPort = port;
-        InternalDistributedSystem ds = InternalDistributedSystem.getConnectedInstance();
+        InternalDistributedSystem ds = internalCache.getInternalDistributedSystem();
-            ((LonerDistributionManager) dm).updateLonerPort(port);
+            ((LonerDistributionManager) dm).updateLonerPort(localPort);
-      localPort = port;
-          new Object[] {sockName, backLog});
-      if (isGatewayReceiver) {
-        stats = GatewayReceiverStats.createGatewayReceiverStats(sockName);
+          sockName, backLog);
+      StatisticsFactory statisticsFactory =
+          internalCache.getInternalDistributedSystem().getStatisticsManager();
+      if (isGatewayReceiver()) {
+        stats = GatewayReceiverStats.createGatewayReceiverStats(statisticsFactory, sockName);
-        stats = new CacheServerStats(sockName);
+        stats = new CacheServerStats(statisticsFactory, sockName);
-
-    clientNotifier = CacheClientNotifier.getInstance(cache, stats, maximumMessageCount,
-        messageTimeToLive, connectionListener, overflowAttributesList, isGatewayReceiver);
+    clientNotifier = cacheClientNotifierProvider.get(internalCache, stats, maximumMessageCount,
+        messageTimeToLive, this.connectionListener, overflowAttributes, isGatewayReceiver());
+
-    healthMonitor = ClientHealthMonitor.getInstance(internalCache, maximumTimeBetweenPings,
+    healthMonitor = clientHealthMonitorProvider.get(internalCache, maximumTimeBetweenPings,
+  @Override
+  @Override
+  @Override
-  void registerSC(ServerConnection sc) {
+  @Override
+  public void registerServerConnection(ServerConnection serverConnection) {
-        finishCon(sc);
+        finishCon(serverConnection);
-    getSelectorQueue().offer(sc);
+    getSelectorQueue().offer(serverConnection);
-  void unregisterSC(ServerConnection sc) {
+  @Override
+  public void unregisterServerConnection(ServerConnection serverConnection) {
-      allSCs.remove(sc);
+      allSCs.remove(serverConnection);
+  @Override
-
-  InetAddress getServerInetAddr() {
+  @Override
+  public InetAddress getServerInetAddress() {
-  void decClientServerCnxCount() {
+  @Override
+  public void decClientServerConnectionCount() {
-  public int getClientServerCnxCount() {
+  @Override
+  public int getClientServerConnectionCount() {
-      int curCnt = getClientServerCnxCount();
+      int curCnt = getClientServerConnectionCount();
-  void refuseHandshake(OutputStream out, String message, byte exception) throws IOException {
-
+  @Override
+  public void refuseHandshake(OutputStream out, String message, byte exception) throws IOException {
-  void notifyCacheMembersOfClose() {
+  @Override
+  public void notifyCacheMembersOfClose() {
-  private static String calcBindHostName(Cache cache, String bindName) {
+  private static String calcBindHostName(InternalCache cache, String bindName) {
-    InternalDistributedSystem system = (InternalDistributedSystem) cache.getDistributedSystem();
+    InternalDistributedSystem system = cache.getInternalDistributedSystem();
+  @Override
+  @Override
-  ClientHealthMonitor getClientHealthMonitor() {
+  @Override
+  public ClientHealthMonitor getClientHealthMonitor() {
-  ConnectionListener getConnectionListener() {
+  @Override
+  public ConnectionListener getConnectionListener() {
+  @Override
-  // see bug #40589
+  @Override
+  @Override

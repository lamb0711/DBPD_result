GEODE-3609 Small AcceptorImpl refactor (#772)

Use one CommunicationMode variable, not 3.

Also, refactor the selector and not-selector cases into separate
methods.

I'm not changing the `ServerConnectionFactory` because it more or less
passes straight through to `ServerConnection`, and there's too much
legacy code there to change easily.
-  private ClientHealthMonitor healthMonitor;
+  private final ClientHealthMonitor healthMonitor;
-    byte communicationMode;
-    if (isSelector()) {
-      ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1);
-      final SocketChannel socketChannel = socket.getChannel();
-      socketChannel.configureBlocking(false);
-      // try to read the byte first in non-blocking mode
-      int res = socketChannel.read(byteBuffer);
-      socketChannel.configureBlocking(true);
-      if (res < 0) {
-        throw new EOFException();
-      } else if (res == 0) {
-        // now do a blocking read so setup a timer to close the socket if the
-        // the read takes too long
-        SystemTimer.SystemTimerTask timerTask = new SystemTimer.SystemTimerTask() {
-          @Override
-          public void run2() {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0,
-                socket.getRemoteSocketAddress()));
-            closeSocket(socket);
-          }
-        };
-        this.hsTimer.schedule(timerTask, this.acceptTimeout);
-        res = socketChannel.read(byteBuffer);
-        if ((!timerTask.cancel()) || res <= 0) {
-          throw new EOFException();
-        }
-      }
-      communicationMode = byteBuffer.get(0);
-    } else {
-      socket.setSoTimeout(this.acceptTimeout);
-      this.socketCreator.configureServerSSLSocket(socket);
-      communicationMode = (byte) socket.getInputStream().read();
-      if (communicationMode == -1) {
-        throw new EOFException();
-      }
-      socket.setSoTimeout(0);
-    }
-
-    socket.setTcpNoDelay(this.tcpNoDelay);
-
-    final CommunicationMode mode;
+    final CommunicationMode communicationMode;
-      mode = CommunicationMode.fromModeNumber(communicationMode);
+      if (isSelector()) {
+        communicationMode = getCommunicationModeForSelector(socket);
+      } else {
+        communicationMode = getCommunicationModeForNonSelector(socket);
+      }
+      socket.setTcpNoDelay(this.tcpNoDelay);
+
-      // possible if a client uses SSL & the server isn't configured to use SSL
+      // possible if a client uses SSL & the server isn't configured to use SSL,
+      // or if an invalid communication communication mode byte is sent.
-    String communicationModeStr;
-    if (mode.isSubscriptionFeed()) {
-      boolean primary = mode == CommunicationMode.PrimaryServerToClient;
+    if (communicationMode.isSubscriptionFeed()) {
+      boolean primary = communicationMode == CommunicationMode.PrimaryServerToClient;
-    communicationModeStr = mode.toString();
-    logger.debug("Bridge server: Initializing {} communication socket: {}", communicationModeStr,
+    logger.debug("Bridge server: Initializing {} communication socket: {}", communicationMode,
-    boolean notForQueue = (mode != ClientToServerForQueue);
+    boolean notForQueue = (communicationMode != ClientToServerForQueue);
-        if (mode.expectsConnectionRefusalMessage()) {
+        if (communicationMode.expectsConnectionRefusalMessage()) {
-    ServerConnection serverConn = serverConnectionFactory.makeServerConnection(socket, this.cache,
-        this.crHelper, this.stats, AcceptorImpl.handShakeTimeout, this.socketBufferSize,
-        communicationModeStr, communicationMode, this, this.securityService, this.getBindAddress());
+    ServerConnection serverConn =
+        serverConnectionFactory.makeServerConnection(socket, this.cache, this.crHelper, this.stats,
+            AcceptorImpl.handShakeTimeout, this.socketBufferSize, communicationMode.toString(),
+            communicationMode.getModeNumber(), this, this.securityService, this.getBindAddress());
+  private CommunicationMode getCommunicationModeForNonSelector(Socket socket) throws IOException {
+    socket.setSoTimeout(this.acceptTimeout);
+    this.socketCreator.configureServerSSLSocket(socket);
+    byte communicationModeByte = (byte) socket.getInputStream().read();
+    if (communicationModeByte == -1) {
+      throw new EOFException();
+    }
+    socket.setSoTimeout(0);
+    return CommunicationMode.fromModeNumber(communicationModeByte);
+  }
+
+  private CommunicationMode getCommunicationModeForSelector(Socket socket) throws IOException {
+    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1);
+    final SocketChannel socketChannel = socket.getChannel();
+    socketChannel.configureBlocking(false);
+    // try to read the byte first in non-blocking mode
+    int res = socketChannel.read(byteBuffer);
+    socketChannel.configureBlocking(true);
+    if (res < 0) {
+      throw new EOFException();
+    } else if (res == 0) {
+      // now do a blocking read so setup a timer to close the socket if the
+      // the read takes too long
+      SystemTimer.SystemTimerTask timerTask = new SystemTimer.SystemTimerTask() {
+        @Override
+        public void run2() {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0,
+              socket.getRemoteSocketAddress()));
+          closeSocket(socket);
+        }
+      };
+      this.hsTimer.schedule(timerTask, this.acceptTimeout);
+      res = socketChannel.read(byteBuffer);
+      if ((!timerTask.cancel()) || res <= 0) {
+        throw new EOFException();
+      }
+    }
+    return CommunicationMode.fromModeNumber(byteBuffer.get(0));
+  }
+

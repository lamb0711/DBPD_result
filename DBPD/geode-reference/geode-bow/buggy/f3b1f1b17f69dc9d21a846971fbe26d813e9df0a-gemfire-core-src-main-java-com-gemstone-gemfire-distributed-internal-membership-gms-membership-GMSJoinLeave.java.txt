GEODE-77: deadlock in GMSJoinLeave

This removes the stateLock read-write lock in favor of using a
sync on viewInstallationLock, eliminating the possibility of
inversion between the two.

-  /** a lock governing GMS state */
-  private ReadWriteLock stateLock = new ReentrantReadWriteLock();
-  
-  /** guarded by stateLock */
+  /** guarded by viewInstallationLock */
-  /** the currently installed view */
+  /** the currently installed view.  Guarded by viewInstallationLock */
-        becomeCoordinator();
+        synchronized(viewInstallationLock) {
+          becomeCoordinator();
+        }
-              becomeCoordinator();
+              synchronized(viewInstallationLock) {
+                becomeCoordinator();
+              }
-          this.currentView = response.getCurrentView();
-          becomeCoordinator(null);
+          synchronized(viewInstallationLock) {
+            this.currentView = response.getCurrentView();
+            becomeCoordinator(null);
+          }
-        becomeCoordinator(incomingRequest.getMemberID());
+        synchronized(viewInstallationLock) {
+          becomeCoordinator(incomingRequest.getMemberID());
+        }
-        becomeCoordinator(mbr);
+        synchronized(viewInstallationLock) {
+          becomeCoordinator(mbr);
+        }
+  
+  public void becomeCoordinatorForTest() {
+    synchronized(viewInstallationLock) {
+      becomeCoordinator();
+    }
+  }
+  
+   * Transitions this member into the coordinator role.  This must
+   * be invoked under a synch on viewInstallationLock that was held
+   * at the time the decision was made to become coordinator so that
+   * the decision is atomic with actually becoming coordinator.
-    stateLock.writeLock().lock();
-    try {
-      if (isCoordinator) {
-        return;
-      }
-      logger.info("This member is becoming the membership coordinator with address {}", localAddress);
-      isCoordinator = true;
-      if (currentView == null) {
-        // create the initial membership view
-        NetView newView = new NetView(this.localAddress);
-        this.localAddress.setVmViewId(0);
-        installView(newView);
-        isJoined = true;
-        if (viewCreator == null || viewCreator.isShutdown()) {
-          viewCreator = new ViewCreator("GemFire Membership View Creator", Services.getThreadGroup());
-          viewCreator.setDaemon(true);
-          viewCreator.start();
-        }
-      } else {
-        // create and send out a new view
-        NetView newView;
-        Set<InternalDistributedMember> leaving = new HashSet<>();
-        Set<InternalDistributedMember> removals;
-        synchronized(viewInstallationLock) {
-          int rand = testing? 0 : NetView.RANDOM.nextInt(10);
-          int viewNumber = currentView.getViewId() + 5 + rand;
-          if (this.localAddress.getVmViewId() < 0) {
-            this.localAddress.setVmViewId(viewNumber);
-          }
-          List<InternalDistributedMember> mbrs = new ArrayList<>(currentView.getMembers());
-          if (!mbrs.contains(localAddress)) {
-            mbrs.add(localAddress);
-          }
-          synchronized(this.removedMembers) {
-            removals = new HashSet<>(this.removedMembers);
-          }
-          if (oldCoordinator != null && !removals.contains(oldCoordinator)) {
-            leaving.add(oldCoordinator);
-          }
-          mbrs.removeAll(removals);
-          mbrs.removeAll(leaving);
-          newView = new NetView(this.localAddress, viewNumber, mbrs, leaving,
-              removals);
-        }
-        if (viewCreator == null || viewCreator.isShutdown()) {
-          viewCreator = new ViewCreator("GemFire Membership View Creator", Services.getThreadGroup());
-          viewCreator.setInitialView(newView, leaving, removals);
-          viewCreator.setDaemon(true);
-          viewCreator.start();
-        }
+    assert Thread.holdsLock(viewInstallationLock);
+    
+    if (isCoordinator) {
+      return;
+    }
+    
+    logger.info("This member is becoming the membership coordinator with address {}", localAddress);
+    isCoordinator = true;
+    if (currentView == null) {
+      // create the initial membership view
+      NetView newView = new NetView(this.localAddress);
+      this.localAddress.setVmViewId(0);
+      installView(newView);
+      isJoined = true;
+      if (viewCreator == null || viewCreator.isShutdown()) {
+        viewCreator = new ViewCreator("GemFire Membership View Creator", Services.getThreadGroup());
+        viewCreator.setDaemon(true);
+        viewCreator.start();
-    } finally {
-      stateLock.writeLock().unlock();
+    } else {
+      // create and send out a new view
+      NetView newView;
+      Set<InternalDistributedMember> leaving = new HashSet<>();
+      Set<InternalDistributedMember> removals;
+      synchronized(viewInstallationLock) {
+        int rand = testing? 0 : NetView.RANDOM.nextInt(10);
+        int viewNumber = currentView.getViewId() + 5 + rand;
+        if (this.localAddress.getVmViewId() < 0) {
+          this.localAddress.setVmViewId(viewNumber);
+        }
+
+        List<InternalDistributedMember> mbrs = new ArrayList<>(currentView.getMembers());
+        if (!mbrs.contains(localAddress)) {
+          mbrs.add(localAddress);
+        }
+        synchronized(this.removedMembers) {
+          removals = new HashSet<>(this.removedMembers);
+        }
+        if (oldCoordinator != null && !removals.contains(oldCoordinator)) {
+          leaving.add(oldCoordinator);
+        }
+        mbrs.removeAll(removals);
+        mbrs.removeAll(leaving);
+        newView = new NetView(this.localAddress, viewNumber, mbrs, leaving,
+            removals);
+      }
+      if (viewCreator == null || viewCreator.isShutdown()) {
+        viewCreator = new ViewCreator("GemFire Membership View Creator", Services.getThreadGroup());
+        viewCreator.setInitialView(newView, leaving, removals);
+        viewCreator.setDaemon(true);
+        viewCreator.start();
+      }
-          stateLock.writeLock().lock();
-          try {
-            stopCoordinatorServices();
-            this.isCoordinator = false;
-          } finally {
-            stateLock.writeLock().unlock();
-          }
+          stopCoordinatorServices();
+          this.isCoordinator = false;
-
+        long giveUpTime = System.currentTimeMillis() + viewAckTimeout;
+          long now = System.currentTimeMillis();
-            InternalDistributedMember mbr = future.get(viewAckTimeout, TimeUnit.MILLISECONDS);
+            InternalDistributedMember mbr = null;
+            long timeToWait = giveUpTime - now;
+            if (timeToWait <= 0) {
+              // TODO if timeToWait==0 is future.get() guaranteed to return immediately?
+              // It looks like some code paths invoke Object.wait(0), which waits forever.
+              timeToWait = 1;
+            }
+            mbr = future.get(timeToWait, TimeUnit.MILLISECONDS);
-            // TODO should the member be removed if we can't verify it in time?
+            // timeout - member didn't pass the final check and will not be removed
+            // from the collection of members

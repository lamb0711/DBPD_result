Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * StructSetOrResultsSet.java
- * Utlity Class : Can be used to compare the results (StructSet OR ResultsSet) under the scenario without/with Index Usage.
- * Created on June 13, 2005, 11:16 AM
+ * StructSetOrResultsSet.java Utlity Class : Can be used to compare the results (StructSet OR
+ * ResultsSet) under the scenario without/with Index Usage. Created on June 13, 2005, 11:16 AM
-  public void CompareQueryResultsWithoutAndWithIndexes(Object[][] r, int len, boolean checkOrder, String queries[]) {
+  public void CompareQueryResultsWithoutAndWithIndexes(Object[][] r, int len, boolean checkOrder,
+      String queries[]) {
-      checkSelectResultTypes((SelectResults)r[j][0], (SelectResults)r[j][1], queries[j]);
-      checkResultSizes((SelectResults)r[j][0], (SelectResults)r[j][1], queries[j]);
-      
+      checkSelectResultTypes((SelectResults) r[j][0], (SelectResults) r[j][1], queries[j]);
+      checkResultSizes((SelectResults) r[j][0], (SelectResults) r[j][1], queries[j]);
+
-  public void compareExternallySortedQueriesWithOrderBy(String[] queries, Object[][] baseResults) throws Exception {
+  public void compareExternallySortedQueriesWithOrderBy(String[] queries, Object[][] baseResults)
+      throws Exception {
-        int unorderedResultsSize =  ((SelectResults) baseResults[i][1]).size(); 
-        if(unorderedResultsSize == 0) {
-          fail("The test results size is 0 , it possibly is not validating anything. rewrite the test");
+        int unorderedResultsSize = ((SelectResults) baseResults[i][1]).size();
+        if (unorderedResultsSize == 0) {
+          fail(
+              "The test results size is 0 , it possibly is not validating anything. rewrite the test");
-        Wrapper wrapper = getOrderByComparatorAndLimitForQuery(queries[i],unorderedResultsSize );
+        Wrapper wrapper = getOrderByComparatorAndLimitForQuery(queries[i], unorderedResultsSize);
-          Object[] externallySorted = ((SelectResults) baseResults[i][1])
-              .toArray();
+          Object[] externallySorted = ((SelectResults) baseResults[i][1]).toArray();
-              System.arraycopy(externallySorted, 0, newExternallySorted, 0,
-                  wrapper.limit);
+              System.arraycopy(externallySorted, 0, newExternallySorted, 0, wrapper.limit);
-          ssOrrs1.compareQueryResultsWithExternallySortedResults(
-              (SelectResults) baseResults[i][0], externallySorted, queries[i],
-              wrapper);
+          ssOrrs1.compareQueryResultsWithExternallySortedResults((SelectResults) baseResults[i][0],
+              externallySorted, queries[i], wrapper);
-        throw new AssertionError("query with index=" + i + " has failed. failed query=" + queries[i], e);
+        throw new AssertionError(
+            "query with index=" + i + " has failed. failed query=" + queries[i], e);
-  private void compareQueryResultsWithExternallySortedResults(SelectResults sr, Object[] externallySorted, String query, Wrapper wrapper) {
+  private void compareQueryResultsWithExternallySortedResults(SelectResults sr,
+      Object[] externallySorted, String query, Wrapper wrapper) {
-      CacheUtils.log("Both SelectResults are of Same Size i.e.  Size= "
-          + sr.size());
+      CacheUtils.log("Both SelectResults are of Same Size i.e.  Size= " + sr.size());
-      fail("FAILED:SelectResults size is different in both the cases. Size1="
-          + sr.size() + " Size2 = " + externallySorted.length
-          + "; failed query=" + query);
+      fail("FAILED:SelectResults size is different in both the cases. Size1=" + sr.size()
+          + " Size2 = " + externallySorted.length + "; failed query=" + query);
-         
+
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
-    DefaultQuery q = (DefaultQuery) CacheUtils.getQueryService().newQuery(
-        orderByQuery);
-    CompiledSelect cs = q.getSimpleSelect();    
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException, NoSuchFieldException, SecurityException,
+      IllegalArgumentException, IllegalAccessException, NoSuchMethodException,
+      InvocationTargetException {
+    DefaultQuery q = (DefaultQuery) CacheUtils.getQueryService().newQuery(orderByQuery);
+    CompiledSelect cs = q.getSimpleSelect();
-    if(cs.getType() == CompiledValue.GROUP_BY_SELECT) {
-      Field originalOrderByMethod = CompiledGroupBySelect.class.getDeclaredField("originalOrderByClause");
+    if (cs.getType() == CompiledValue.GROUP_BY_SELECT) {
+      Field originalOrderByMethod =
+          CompiledGroupBySelect.class.getDeclaredField("originalOrderByClause");
-      orderByAttribs = ( List<CompiledSortCriterion>)originalOrderByMethod.get(cs);
-    }else {
+      orderByAttribs = (List<CompiledSortCriterion>) originalOrderByMethod.get(cs);
+    } else {
-    final OrderByComparator obc = new OrderByComparator(orderByAttribs,
-        resultType, context);
+    final OrderByComparator obc = new OrderByComparator(orderByAttribs, resultType, context);
-        final boolean[] orderByColsEqual = new boolean[] { false };
+        final boolean[] orderByColsEqual = new boolean[] {false};
-    Field hasUnmappedOrderByColsField = CompiledSelect.class
-        .getDeclaredField("hasUnmappedOrderByCols");
+    Field hasUnmappedOrderByColsField =
+        CompiledSelect.class.getDeclaredField("hasUnmappedOrderByCols");
-    boolean skip = ((Boolean) hasUnmappedOrderByColsField.get(cs))
-        .booleanValue();
+    boolean skip = ((Boolean) hasUnmappedOrderByColsField.get(cs)).booleanValue();
-    
-    int limit ;
-    
-    if(cs.getType() == CompiledValue.GROUP_BY_SELECT) {
+
+    int limit;
+
+    if (cs.getType() == CompiledValue.GROUP_BY_SELECT) {
-      CompiledValue limitCV = ( CompiledValue)limitCVField.get(cs);
+      CompiledValue limitCV = (CompiledValue) limitCVField.get(cs);
-          ExecutionContext.class, CompiledValue.class );
+          ExecutionContext.class, CompiledValue.class);
-      limit = ((Integer)evaluateLimitMethod.invoke(null, context, limitCV)).intValue();
-    }else {
+      limit = ((Integer) evaluateLimitMethod.invoke(null, context, limitCV)).intValue();
+    } else {
-   
+
-  public void CompareCountStarQueryResultsWithoutAndWithIndexes(Object[][] r, int len, boolean checkOrder, String queries[]) {
+  public void CompareCountStarQueryResultsWithoutAndWithIndexes(Object[][] r, int len,
+      boolean checkOrder, String queries[]) {
-  public void CompareQueryResultsAsListWithoutAndWithIndexes(Object[][] r, int len, boolean checkOrder, String queries[]) {
-    CompareQueryResultsAsListWithoutAndWithIndexes(r, len, checkOrder, true,
-        queries);
+  public void CompareQueryResultsAsListWithoutAndWithIndexes(Object[][] r, int len,
+      boolean checkOrder, String queries[]) {
+    CompareQueryResultsAsListWithoutAndWithIndexes(r, len, checkOrder, true, queries);
-  public void CompareQueryResultsAsListWithoutAndWithIndexes(Object[][] r, int len, boolean checkOrder, boolean checkClass, String queries[]) {
+  public void CompareQueryResultsAsListWithoutAndWithIndexes(Object[][] r, int len,
+      boolean checkOrder, boolean checkClass, String queries[]) {
-    
+
-  
-  public void compareQueryResultLists(List r1, List r2, int len, boolean checkOrder, boolean checkClass, String query) {
+
+  public void compareQueryResultLists(List r1, List r2, int len, boolean checkOrder,
+      boolean checkClass, String query) {
-      if ((r1.get(0).getClass().getName()).equals(r2.get(0)
-          .getClass().getName())) {
-        CacheUtils.log("Both SelectResults are of the same Type i.e.--> "
-            + r1.get(0).getClass().getName());
+      if ((r1.get(0).getClass().getName()).equals(r2.get(0).getClass().getName())) {
+        CacheUtils.log(
+            "Both SelectResults are of the same Type i.e.--> " + r1.get(0).getClass().getName());
-            + r1.get(0).getClass().getName() + "and"
-            + r1.get(0).getClass().getName() + "; failed query="
-            + query);
+            + r1.get(0).getClass().getName() + "and" + r1.get(0).getClass().getName()
+            + "; failed query=" + query);
-  
+
-      CacheUtils.log("Classes are : " + type1.getClass().getName() + " " + type2.getClass().getName());
+      CacheUtils
+          .log("Classes are : " + type1.getClass().getName() + " " + type2.getClass().getName());
-  
+
-      fail("FAILED:SelectResults size is different in both the cases. Size1="
-          + r1.size() + " Size2 = "
-          + r2.size() + "; failed query=" + query);
+      fail("FAILED:SelectResults size is different in both the cases. Size1=" + r1.size()
+          + " Size2 = " + r2.size() + "; failed query=" + query);
-  private void compareResults(Collection result1, Collection result2, String query, boolean checkOrder) {
+  private void compareResults(Collection result1, Collection result2, String query,
+      boolean checkOrder) {
-              + "supposedly identical, is not equal " + "Match not found for :"
-              + p1 + " compared with:" + p2 + "; failed query=" + query + "; element unmatched ="
-              + p1 + ";p1 class=" + p1.getClass() + " ; other set has ="
-              + result2);
+              + "supposedly identical, is not equal " + "Match not found for :" + p1
+              + " compared with:" + p2 + "; failed query=" + query + "; element unmatched =" + p1
+              + ";p1 class=" + p1.getClass() + " ; other set has =" + result2);
-      }
-      else {
+      } else {
-            fail("Order of results was not the same, match not found for :"
-                + p1 + " compared with:" + p2 + "; failed query=" + query + "; element unmatched ="
-                + p1 + ";p1 class=" + p1.getClass() + " compared with " + p2 + ";p2 class=" + p2.getClass()
-                + "currentIndex:" + currentIndex 
-                + "\nr1:" + result1 + "\n\nr2:" + result2);
+            fail("Order of results was not the same, match not found for :" + p1 + " compared with:"
+                + p2 + "; failed query=" + query + "; element unmatched =" + p1 + ";p1 class="
+                + p1.getClass() + " compared with " + p2 + ";p2 class=" + p2.getClass()
+                + "currentIndex:" + currentIndex + "\nr1:" + result1 + "\n\nr2:" + result2);
-      currentIndex ++;
+      currentIndex++;
-  
+
-  
+
-    //Assumed that o1 and o2 are the same object type as both are from collections created by executing the same query
+    // Assumed that o1 and o2 are the same object type as both are from collections created by
+    // executing the same query
-      //if o2 is null, an NPE will be thrown.
+      // if o2 is null, an NPE will be thrown.
-        elementEqual = elementEqual
-            && ((values1[i] == values2[i]) || values1[i]
-                .equals(values2[i]));
+        elementEqual =
+            elementEqual && ((values1[i] == values2[i]) || values1[i].equals(values2[i]));
-    } 
-    else {
-      //if o1 is null and o2 is not, an NPE will be thrown
+    } else {
+      // if o1 is null and o2 is not, an NPE will be thrown

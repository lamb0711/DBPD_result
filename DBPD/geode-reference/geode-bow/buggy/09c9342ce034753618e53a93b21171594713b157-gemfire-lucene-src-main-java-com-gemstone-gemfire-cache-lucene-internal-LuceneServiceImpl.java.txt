Requiring lucene index to be created before the region

At the moment, adding an AsyncEventQueue after a region is created has
issues - See GEODE-404.

Therefore, in order to create a lucene index programmatically, the
lucene index needs to be created before the region exists so that we can
create the AEQ ahead of time.

With this change, when an LuceneIndex is created, the actual creation is
deferred in a RegionListener callback. When the region is created, we
add the AEQ to the region attributes and create the colocated regions.

+import com.gemstone.gemfire.cache.AttributesFactory;
+import com.gemstone.gemfire.cache.RegionAttributes;
+import com.gemstone.gemfire.internal.cache.InternalRegionArguments;
+import com.gemstone.gemfire.internal.cache.RegionListener;
-  private final Cache cache;
-
-  private final HashMap<String, LuceneIndex> indexMap;
-  
+  
+  private final GemFireCacheImpl cache;
+  private final HashMap<String, LuceneIndex> indexMap = new HashMap<String, LuceneIndex>();;
+  
-
-    // Initialize the Map which maintains indexes
-    this.indexMap = new HashMap<String, LuceneIndex>();
-  public LuceneIndex createIndex(String indexName, String regionPath, String... fields) {
-    LuceneIndexImpl index = createIndexRegions(indexName, regionPath);
-    if (index == null) {
-      return null;
+  public void createIndex(String indexName, String regionPath, String... fields) {
+    StandardAnalyzer analyzer = new StandardAnalyzer();
+    
+    createIndex(indexName, regionPath, analyzer, fields);
+  }
+  
+  @Override
+  public void createIndex(String indexName, String regionPath, Map<String, Analyzer> analyzerPerField) {
+    Analyzer analyzer = new PerFieldAnalyzerWrapper(new StandardAnalyzer(), analyzerPerField);
+    String[] fields = (String[])analyzerPerField.keySet().toArray(new String[analyzerPerField.keySet().size()]);
+
+    createIndex(indexName, regionPath, analyzer, fields);
+  }
+
+  private void createIndex(final String indexName, String regionPath,
+      final Analyzer analyzer, final String... fields) {
+
+    if(!regionPath.startsWith("/")) {
+      regionPath = "/" + regionPath;
+    Region region = cache.getRegion(regionPath);
+    if(region != null) {
+      throw new IllegalStateException("The lucene index must be created before region");
+    }
+    
+    final String dataRegionPath = regionPath;
+    cache.addRegionListener(new RegionListener() {
+      @Override
+      public RegionAttributes beforeCreate(Region parent, String regionName,
+          RegionAttributes attrs, InternalRegionArguments internalRegionArgs) {
+        String path = parent == null ? "/" + regionName : parent.getFullPath() + "/" + regionName;
+        if(path.equals(dataRegionPath)) {
+          String aeqId = LuceneServiceImpl.getUniqueIndexName(indexName, dataRegionPath);
+          AttributesFactory af = new AttributesFactory(attrs);
+          af.addAsyncEventQueueId(aeqId);
+          return af.create();
+        } else {
+          return attrs;
+        }
+      }
+      
+      @Override
+      public void afterCreate(Region region) {
+        if(region.getFullPath().equals(dataRegionPath)) {
+          afterDataRegionCreated(indexName, analyzer, dataRegionPath, fields);
+          cache.removeRegionListener(this);
+        }
+      }
+    });
+    
+  }
+  
+  /**
+   * Finish creating the lucene index after the data region is created .
+   * 
+   * Public because this is called by the Xml parsing code
+   */
+  public void afterDataRegionCreated(final String indexName,
+      final Analyzer analyzer, final String dataRegionPath,
+      final String... fields) {
+    LuceneIndexImpl index = createIndexRegions(indexName, dataRegionPath);
-    index.setAnalyzer(null);
+    index.setAnalyzer(analyzer);
-    return index;
-  public LuceneIndex createIndex(String indexName, String regionPath, Map<String, Analyzer> analyzerPerField) {
-    LuceneIndexImpl index = createIndexRegions(indexName, regionPath);
-    if (index == null) {
-      return null;
-    }
-    
-    Analyzer analyzer = new PerFieldAnalyzerWrapper(new StandardAnalyzer(), analyzerPerField);
-    String[] fields = (String[])analyzerPerField.keySet().toArray(new String[analyzerPerField.keySet().size()]);
-    index.setSearchableFields(fields);
-    index.setAnalyzer(analyzer);
-    index.initialize();
-    registerIndex(index);
-    return index;
-  }
-
-  @Override

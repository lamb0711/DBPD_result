GEODE-1761 Clients don't fail back when servers are bounced

Servers will send a refresh hint to clients if they detect that a request
had to be send to a different server who owned the primary bucket
affected by the operation.  Clients should always refresh when this
happens unless they have connection-pool size constraints that force
them to use non-optimal servers.

Client-side operation classes have been modified to initiate the refresh.
I've added code in the meta-data service class to avoid performing
multiple concurrent refreshes on the same region.

On the server-side I've cleaned up some of the network-hop detection
code to stop using hard-coded integers and to consolidate some of
the code that resets the ThreadLocals being used to record network-
hops detected.

-import com.gemstone.gemfire.internal.cache.BucketServerLocation66;
-import com.gemstone.gemfire.internal.cache.EntryOperationImpl;
-import com.gemstone.gemfire.internal.cache.LocalRegion;
-import com.gemstone.gemfire.internal.cache.PartitionedRegionHelper;
+import com.gemstone.gemfire.internal.cache.*;
-  private int fetchTaskCount = 0;
+  private int refreshTaskCount = 0;
+  
+  private Set<String> regionsBeingRefreshed = new HashSet<>();
-        fetchTaskCount++;
+        refreshTaskCount++;
-              fetchTaskCount--;
+              refreshTaskCount--;
-        logger.debug("Scheduling metadata refresh : {}", nwHopType);
+        logger.debug("Scheduling metadata refresh: {} region: {}", nwHopType, region.getName());
-      if(nwHopType == (byte)2){
+      if( nwHopType == PartitionedRegion.NETWORK_HOP_TO_DIFFERENT_GROUP){
-    region.getCachePerfStats().incNonSingleHopsCount();
+    synchronized (fetchTaskCountLock) {
+      if (regionsBeingRefreshed.contains(region.getFullPath())) {
+        return;
+      }
+    }
+      region.getCachePerfStats().incNonSingleHopsCount();
-      synchronized (fetchTaskCountLock){
-        fetchTaskCount++;
+      synchronized (fetchTaskCountLock) {
+        if (regionsBeingRefreshed.contains(region.getFullPath())) {
+          return;
+        }
+        region.getCachePerfStats().incNonSingleHopsCount();
+        regionsBeingRefreshed.add(region.getFullPath());
+        refreshTaskCount++;
-              fetchTaskCount--;
+              regionsBeingRefreshed.remove(region.getFullPath());
+              refreshTaskCount--;
-  public int getFetchTaskCount() {
+  public int getRefreshTaskCount() {
-      return fetchTaskCount;
+      return refreshTaskCount;

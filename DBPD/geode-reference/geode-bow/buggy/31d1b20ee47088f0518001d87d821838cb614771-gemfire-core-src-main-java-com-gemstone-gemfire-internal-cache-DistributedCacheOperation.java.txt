Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.internal.cache.DistributedPutAllOperation.PutAllMessage;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl.OldValueImporter;
+import com.gemstone.gemfire.internal.offheap.OffHeapReference;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+  
+  /**
+   * @param deserializationPolicy must be one of the following: DESERIALIZATION_POLICY_NONE, DESERIALIZATION_POLICY_EAGER, DESERIALIZATION_POLICY_LAZY.
+   */
+  public static void writeValue(final byte deserializationPolicy, final Object vObj, final byte[] vBytes, final DataOutput out) throws IOException {
+    if (vObj != null) {
+      if (deserializationPolicy == DESERIALIZATION_POLICY_EAGER) {
+        // for DESERIALIZATION_POLICY_EAGER avoid extra byte array serialization
+        DataSerializer.writeObject(vObj, out);
+      } else if (deserializationPolicy == DESERIALIZATION_POLICY_NONE) {
+        // We only have NONE with a vObj when vObj is off-heap and not serialized.
+        OffHeapReference ohref = (OffHeapReference) vObj;
+        assert !ohref.isSerialized();
+        DataSerializer.writeByteArray(ohref.getValueAsHeapByteArray(), out);
+      } else { // LAZY
+        // TODO OFFHEAP MERGE: cache the oldValue that is serialized here
+        // into the event
+        DataSerializer.writeObjectAsByteArray(vObj, out);
+      }
+    } else {
+      if (deserializationPolicy == DESERIALIZATION_POLICY_EAGER) {
+        // object is already in serialized form in the byte array.
+        // So just write the bytes to the stream.
+        // fromData will call readObject which will deserialize to object form.
+        out.write(vBytes);
+      } else {
+        DataSerializer.writeByteArray(vBytes, out);
+      }
+    }    
+  }
+  // static values for oldValueIsObject
+  public static final byte VALUE_IS_BYTES = 0;
+  public static final byte VALUE_IS_SERIALIZED_OBJECT = 1;
+  public static final byte VALUE_IS_OBJECT = 2;
+
+  /**
+   * Given a VALUE_IS_* constant convert and return the corresponding DESERIALIZATION_POLICY_*.
+   */
+  public static byte valueIsToDeserializationPolicy(boolean oldValueIsSerialized) {
+    if (!oldValueIsSerialized) return DESERIALIZATION_POLICY_NONE;
+    if (CachedDeserializableFactory.preferObject()) return DESERIALIZATION_POLICY_EAGER;
+    return DESERIALIZATION_POLICY_LAZY;
+  }
+
-      DirectReplyMessage, ReliableDistributionData {
+      DirectReplyMessage, ReliableDistributionData, OldValueImporter {
+	protected final static short FETCH_FROM_HDFS = 0x200;
+    
+    protected final static short IS_PUT_DML = 0x100;
+
-      Object val = event.getRawOldValue();
-      if (val == Token.NOT_AVAILABLE ||
-          val == Token.REMOVED_PHASE1 ||
-          val == Token.REMOVED_PHASE2 ||
-          val == Token.DESTROYED ||
-          val == Token.TOMBSTONE) {
-        return;
+      {
+        @Unretained Object val = event.getRawOldValue();
+        if (val == null ||
+            val == Token.NOT_AVAILABLE ||
+            val == Token.REMOVED_PHASE1 ||
+            val == Token.REMOVED_PHASE2 ||
+            val == Token.DESTROYED ||
+            val == Token.TOMBSTONE) {
+          return;
+        }
-      if (val instanceof CachedDeserializable) {
-        val = ((CachedDeserializable)val).getValue();
-      }
-      this.oldValue = val;
-      this.hasOldValue = true;
-      this.oldValueIsSerialized = (val instanceof byte[]);
+      event.exportOldValue(this);
+    
+    protected LocalRegion getLocalRegionForProcessing(DistributionManager dm) {
+      Assert.assertTrue(this.regionPath != null, "regionPath was null");
+      GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
+      return gfc.getRegionByPathForProcessing(this.regionPath);
+    }
-        Assert.assertTrue(this.regionPath != null, "regionPath was null");
-
-        GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm
-            .getSystem());
-        final LocalRegion lclRgn = gfc
-            .getRegionByPathForProcessing(this.regionPath);
+        final LocalRegion lclRgn = getLocalRegionForProcessing(dm);
+        try {
+        } finally {
+          if (event instanceof EntryEventImpl) {
+            ((EntryEventImpl) event).release();
+          }
+        }
-        // below boolean is not strictly required, but this is for compatibility
-        // with SQLFire code which writes as byte here to indicate whether
-        // oldValue is an object, serialized object or byte[]
-        in.readByte();
+        byte b = in.readByte();
+        if (b == 0) {
+          this.oldValueIsSerialized = false;
+        } else if (b == 1) {
+          this.oldValueIsSerialized = true;
+        } else {
+          throw new IllegalStateException("expected 0 or 1");
+        }
-        this.oldValueIsSerialized = true;
+	  if (this instanceof PutAllMessage) {
+        ((PutAllMessage) this).setFetchFromHDFS((extBits & FETCH_FROM_HDFS) != 0);
+        ((PutAllMessage) this).setPutDML((extBits & IS_PUT_DML) != 0);
+      }
-        // below boolean is not strictly required, but this is for compatibility
-        // with SQLFire code which writes as byte here to indicate whether
-        // oldValue is an object, serialized object or byte[]
-        if (this.oldValueIsSerialized) {
-          DataSerializer.writeByteArray((byte[])this.oldValue, out);
+        final byte policy = valueIsToDeserializationPolicy(this.oldValueIsSerialized);
+        final Object vObj;
+        final byte[] vBytes;
+        if (!this.oldValueIsSerialized && this.oldValue instanceof byte[]) {
+          vObj = null;
+          vBytes = (byte[])this.oldValue;
+        } else {
+          vObj = this.oldValue;
+          vBytes = null;
-        else {
-          DataSerializer.writeObjectAsByteArray(this.oldValue, out);
-        }
+        writeValue(policy, vObj, vBytes, out);
+
+    @Override
+    public boolean prefersOldSerialized() {
+      return true;
+    }
+
+    @Override
+    public boolean isUnretainedOldReferenceOk() {
+      return true;
+    }
+
+    @Override
+    public boolean isCachedDeserializableValueOk() {
+      return false;
+    }
+
+    @Override
+    public void importOldObject(Object ov, boolean isSerialized) {
+      this.oldValueIsSerialized = isSerialized;
+      this.oldValue = ov;
+      this.hasOldValue = true;
+    }
+
+    @Override
+    public void importOldBytes(byte[] ov, boolean isSerialized) {
+      this.oldValueIsSerialized = isSerialized;
+      this.oldValue = ov;
+      this.hasOldValue = true;
+    }
+
+    protected final boolean _mayAddToMultipleSerialGateways(DistributionManager dm) {
+      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT); 
+      try {
+        LocalRegion lr = getLocalRegionForProcessing(dm);
+        if (lr == null) {
+          return false;
+        }
+        return lr.notifiesMultipleSerialGateways();
+      } catch (CancelException ignore) {
+        return false;
+      } finally {
+        LocalRegion.setThreadInitLevelRequirement(oldLevel);
+      }
+    }

GEODE-4858: Refactor 'list async-event-queue' command and function (#1975)

* Command refactored for cleaner presentation
* Command refactored to return ResultModel
* Function refactored to extend CliFunction

+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
-import java.util.Map;
+import com.fasterxml.jackson.databind.ObjectMapper;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
-import org.apache.geode.management.internal.cli.result.TabularResultData;
+import org.apache.geode.management.internal.cli.result.model.ResultModel;
+import org.apache.geode.management.internal.cli.result.model.TabularResultModel;
+  private static final String[] DETAILS_OUTPUT_COLUMNS =
+      {"Member", "ID", "Batch Size", "Persistent", "Disk Store", "Max Memory", "Listener"};
+  private static final String ASYNC_EVENT_QUEUES_TABLE_SECTION = "Async Event Queues";
+  private static final String MEMBER_ERRORS_TABLE_SECTION = "Member Errors";
+
-  public Result listAsyncEventQueues() {
-    try {
-      TabularResultData tabularData = ResultBuilder.createTabularResultData();
-      boolean accumulatedData = false;
-
-      Set<DistributedMember> targetMembers = getAllNormalMembers();
-
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
-
-      ResultCollector<?, ?> rc = CliUtil.executeFunction(new ListAsyncEventQueuesFunction(),
-          new Object[] {}, targetMembers);
-      List<CliFunctionResult> results = CliFunctionResult.cleanResults((List<?>) rc.getResult());
-
-      for (CliFunctionResult result : results) {
-        if (result.getThrowable() != null) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", "ERROR: " + result.getThrowable().getClass().getName()
-              + ": " + result.getThrowable().getMessage());
-          accumulatedData = true;
-          tabularData.setStatus(Result.Status.ERROR);
-        } else {
-          AsyncEventQueueDetails[] details = (AsyncEventQueueDetails[]) result.getSerializables();
-          for (AsyncEventQueueDetails detail : details) {
-            tabularData.accumulate("Member", result.getMemberIdOrName());
-            tabularData.accumulate("ID", detail.getId());
-            tabularData.accumulate("Batch Size", detail.getBatchSize());
-            tabularData.accumulate("Persistent", detail.isPersistent());
-            tabularData.accumulate("Disk Store", detail.getDiskStoreName());
-            tabularData.accumulate("Max Memory", detail.getMaxQueueMemory());
-
-            Properties listenerProperties = detail.getListenerProperties();
-            if (listenerProperties == null || listenerProperties.size() == 0) {
-              tabularData.accumulate("Listener", detail.getListener());
-            } else {
-              StringBuilder propsStringBuilder = new StringBuilder();
-              propsStringBuilder.append('(');
-              boolean firstProperty = true;
-              for (Map.Entry<Object, Object> property : listenerProperties.entrySet()) {
-                if (!firstProperty) {
-                  propsStringBuilder.append(',');
-                } else {
-                  firstProperty = false;
-                }
-                propsStringBuilder.append(property.getKey()).append('=')
-                    .append(property.getValue());
-              }
-              propsStringBuilder.append(')');
-
-              tabularData.accumulate("Listener",
-                  detail.getListener() + propsStringBuilder.toString());
-            }
-            accumulatedData = true;
-          }
-        }
-      }
-
-      if (!accumulatedData) {
-        return ResultBuilder
-            .createInfoResult(CliStrings.LIST_ASYNC_EVENT_QUEUES__NO_QUEUES_FOUND_MESSAGE);
-      }
-
-      return ResultBuilder.buildResult(tabularData);
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable th) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.LIST_ASYNC_EVENT_QUEUES__ERROR_WHILE_LISTING_REASON_0,
-              new Object[] {th.getMessage()}));
+  public ResultModel listAsyncEventQueues() {
+    Set<DistributedMember> targetMembers = getAllNormalMembers();
+    if (targetMembers.isEmpty()) {
+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+
+    // Each (successful) member returns a list of AsyncEventQueueDetails.
+    List<CliFunctionResult> results = executeAndGetFunctionResult(
+        new ListAsyncEventQueuesFunction(), new Object[] {}, targetMembers);
+
+    ResultModel result = buildAsyncEventQueueInfo(results);
+
+    // Report any explicit errors as well.
+    if (results.stream().anyMatch(r -> !r.isSuccessful())) {
+      TabularResultModel errors = result.addTable(MEMBER_ERRORS_TABLE_SECTION);
+      errors.setColumnHeader("Member", "Error");
+      results.stream().filter(r -> !r.isSuccessful()).forEach(errorResult -> errors
+          .addRow(errorResult.getMemberIdOrName(), errorResult.getStatusMessage()));
+    }
+
+    return result;
+  }
+
+  /**
+   * @return An info result containing the table of AsyncEventQueueDetails.
+   *         If no details are found, returns an info result message indicating so.
+   */
+  private ResultModel buildAsyncEventQueueInfo(List<CliFunctionResult> results) {
+    if (results.stream().filter(CliFunctionResult::isSuccessful)
+        .noneMatch(r -> ((List<AsyncEventQueueDetails>) r.getResultObject()).size() > 0)) {
+      return ResultModel.createInfo(CliStrings.LIST_ASYNC_EVENT_QUEUES__NO_QUEUES_FOUND_MESSAGE);
+    }
+
+    ResultModel result = new ResultModel();
+    TabularResultModel detailsTable = result.addTable(ASYNC_EVENT_QUEUES_TABLE_SECTION);
+    detailsTable.setColumnHeader(DETAILS_OUTPUT_COLUMNS);
+
+    results.stream().filter(CliFunctionResult::isSuccessful).forEach(successfulResult -> {
+      String memberName = successfulResult.getMemberIdOrName();
+      ((List<AsyncEventQueueDetails>) successfulResult.getResultObject())
+          .forEach(entry -> detailsTable.addRow(memberName, entry.getId(),
+              String.valueOf(entry.getBatchSize()), String.valueOf(entry.isPersistent()),
+              String.valueOf(entry.getDiskStoreName()), String.valueOf(entry.getMaxQueueMemory()),
+              getListenerEntry(entry)));
+    });
+    return result;
+  }
+
+  /**
+   * @return The class of the entry's listener. If the listener is parameterized, these parameters
+   *         are appended in a json format.
+   */
+  private String getListenerEntry(AsyncEventQueueDetails entry) {
+    return entry.getListener() + propertiesToString(entry.getListenerProperties());
+  }
+
+  /**
+   * @return A json format of the properties, or the empty string if the properties are empty.
+   */
+  static String propertiesToString(Properties props) {
+    if (props == null || props.isEmpty()) {
+      return "";
+    }
+    ObjectMapper mapper = new ObjectMapper();
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    try {
+      mapper.writeValue(baos, props);
+    } catch (IOException e) {
+      return e.getMessage();
+    }
+    return baos.toString();

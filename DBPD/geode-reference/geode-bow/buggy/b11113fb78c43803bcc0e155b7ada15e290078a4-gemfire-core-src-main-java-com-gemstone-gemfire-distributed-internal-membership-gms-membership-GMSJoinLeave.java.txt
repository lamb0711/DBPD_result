ViewCreator thread sends another message when any member doesn't ack back to
prepared view. And then it waits on future as this can happen for multiple members.
In this case, If those members are not responsive and other thread already determined that,
then we don't need to wait for those members. Thus now viewCreator thread checks
RemoveMember message for those members while waiting for response.
Another minor fix in same area.
And added unit test for that

-        viewCreator = new ViewCreator("Geode Membership View Creator", Services.getThreadGroup());
+        createViewCreator();
-        viewCreator = new ViewCreator("Geode Membership View Creator", Services.getThreadGroup());
+        createViewCreator();
+  protected void createViewCreator() {
+    viewCreator = new ViewCreator("Geode Membership View Creator", Services.getThreadGroup());
+  }
+
+    volatile boolean testFlagForRemovalRequest = false;
-    private void removeHealthyMembers(Collection<InternalDistributedMember> mbrs) throws InterruptedException {
+    private void removeHealthyMembers(final Collection<InternalDistributedMember> mbrs) throws InterruptedException {
-      synchronized (viewRequests) {
-        for (DistributionMessage msg : viewRequests) {
-          switch (msg.getDSFID()) {
-          case LEAVE_REQUEST_MESSAGE:
-            newLeaves.add(((LeaveRequestMessage) msg).getMemberID());
-            break;
-          case REMOVE_MEMBER_REQUEST:
-            newRemovals.add(((RemoveMemberMessage) msg).getMemberID());
-            break;
-          default:
-            break;
-          }
-        }
-      }
-
+      filterMembers(mbrs, newRemovals, REMOVE_MEMBER_REQUEST);
+      filterMembers(mbrs, newLeaves, LEAVE_REQUEST_MESSAGE);   
+      
-        if (newRemovals.contains(mbr)) {
-          // no need to do a health check on a member who is already leaving
-          logger.info("member {} is already scheduled for removal", mbr);
-          continue;
-        }
-        if (newLeaves.contains(mbr)) {
-          // no need to do a health check on a member that is declared crashed
-          logger.info("member {} has already sent a leave-request", mbr);
-          continue;
-        }
-            logger.info("checking state of member " + fmbr);
-            if (services.getHealthMonitor().checkIfAvailable(fmbr, "Member failed to acknowledge a membership view", false)) {
-              logger.info("member " + fmbr + " passed availability check");
-              return fmbr;
+            InternalDistributedMember mbr = GMSJoinLeave.this.checkIfAvailable(fmbr);
+            
+            synchronized (viewRequests) {
+              if(mbr != null)
+                mbrs.remove(mbr);
+              viewRequests.notifyAll();
-            logger.info("member " + fmbr + " failed availability check");
-            return null;
+            return mbr;
-
+      
-        List<Future<InternalDistributedMember>> futures;
-        futures = svc.invokeAll(checkers);
-        for (Future<InternalDistributedMember> future: futures) {
-          long now = System.currentTimeMillis();
-          try {
-            InternalDistributedMember mbr = null;
-            long timeToWait = giveUpTime - now;
-            if (timeToWait <= 0) {
-              // TODO if timeToWait==0 is future.get() guaranteed to return immediately?
-              // It looks like some code paths invoke Object.wait(0), which waits forever.
-              timeToWait = 1;
+        List<Future<InternalDistributedMember>> futures;
+        futures = submitAll(svc, checkers);
+        long waitTime = giveUpTime - System.currentTimeMillis();
+        synchronized (viewRequests) {
+          while(waitTime>0 ) {
+            logger.debug("removeHealthyMembers: mbrs" + mbrs.size());
+            
+            filterMembers(mbrs, newRemovals, REMOVE_MEMBER_REQUEST);
+            filterMembers(mbrs, newLeaves, LEAVE_REQUEST_MESSAGE);   
+            
+            if(mbrs.isEmpty()) {
+              break;
-            mbr = future.get(timeToWait, TimeUnit.MILLISECONDS);
-            if (mbr != null) {
-              mbrs.remove(mbr);
-            }
-          } catch (java.util.concurrent.TimeoutException e) {
-            // timeout - member didn't pass the final check and will not be removed
-            // from the collection of members
-          } catch (ExecutionException e) {
-            logger.info("unexpected exception caught during member verification", e);
+            
+            viewRequests.wait(waitTime);
+            waitTime = giveUpTime - System.currentTimeMillis();
+        
+        //we have waited for all members, now check if we considered any removeRequest;
+        //add them back to create new view
+        if(!newRemovals.isEmpty()) {
+          newRemovals.removeAll(newLeaves);
+          mbrs.addAll(newRemovals);
+        }
+        
+
+    protected void filterMembers(Collection<InternalDistributedMember> mbrs, Set<InternalDistributedMember> removalRequestForMembers, short requestType) {
+      Set<InternalDistributedMember> gotRemovalRequests = getPendingRequestIDs(requestType);
+      
+      if(!gotRemovalRequests.isEmpty()) {
+        logger.debug("removeHealthyMembers: gotRemovalRequests " + gotRemovalRequests.size());
+        Iterator<InternalDistributedMember> itr = gotRemovalRequests.iterator();
+        while(itr.hasNext()) {
+          InternalDistributedMember removeMember = itr.next();
+          if(mbrs.contains(removeMember)) {
+            testFlagForRemovalRequest = true;
+            removalRequestForMembers.add(removeMember);
+            mbrs.remove(removeMember);
+          }
+        }
+      }
+    }
+    
+    private <T> List<Future<T>> submitAll ( ExecutorService executor, Collection<? extends Callable<T> > tasks ) {
+      List<Future<T>> result = new ArrayList<Future<T>>( tasks.size() );
+
+      for ( Callable<T> task : tasks ) {
+        result.add(executor.submit(task));
+      }
+
+      return result;
+    }
+    
+    boolean getTestFlageForRemovalRequest() {
+      return testFlagForRemovalRequest;
+    }
-  
+  InternalDistributedMember checkIfAvailable(InternalDistributedMember fmbr) {
+ // return the member id if it fails health checks
+    logger.info("checking state of member " + fmbr);
+    if (services.getHealthMonitor().checkIfAvailable(fmbr, "Member failed to acknowledge a membership view", false)) {
+      logger.info("member " + fmbr + " passed availability check");
+      return fmbr;
+    }
+    logger.info("member " + fmbr + " failed availability check");
+    return null;
+  }

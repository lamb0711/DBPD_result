Enabling creation of stand-alone GMSLocator & adding 2-phase view casting

The locator work will let us unit-test this component while the
view-casting work is in preparation for the health-monitor impl that is
coming soon & will allow us to start testing HA features.

+import java.util.Collection;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import com.gemstone.gemfire.distributed.internal.membership.gms.Services;
-import com.gemstone.gemfire.distributed.internal.membership.gms.GMSMemberServices;
+import com.gemstone.gemfire.internal.logging.LoggingThreadGroup;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-  private static final int JOIN_ATTEMPTS = Integer.getInteger("geode.join-attempts", 6);
+  private static final int JOIN_ATTEMPTS = Integer.getInteger("gemfire.join-attempts", 4);
-  private static final int JOIN_RETRY_SLEEP = Integer.getInteger("geode.join-retry-sleep", 3000);
+  private static final int JOIN_RETRY_SLEEP = Integer.getInteger("gemfire.join-retry-sleep", 3000);
-  private static final int VIEW_INSTALLATION_TIMEOUT = Integer.getInteger("geode.view-ack-timeout", 12500);
+  private static final int VIEW_INSTALLATION_TIMEOUT = Integer.getInteger("gemfire.view-ack-timeout", 12500);
-  private static final long MEMBER_REQUEST_COLLECTION_INTERVAL = Long.getLong("geode.member-request-collection-interval", 2000);
+  private static final long MEMBER_REQUEST_COLLECTION_INTERVAL = Long.getLong("gemfire.member-request-collection-interval", 2000);
-  private static final long LEAVE_MESSAGE_SLEEP_TIME = Long.getLong("geode.leave-message-sleep-time", 2000);
+  private static final long LEAVE_MESSAGE_SLEEP_TIME = Long.getLong("gemfire.leave-message-sleep-time", 2000);
-  private static final Logger logger = GMSMemberServices.getLogger();
+  private static final Logger logger = Services.getLogger();
-  private GMSMemberServices services;
+  private Services services;
-  private List<InetSocketAddress> locators;
+  /** the last view that conflicted with view preparation */
+  private NetView lastConflictingView;
-  private InternalDistributedMember leader;
+  private List<InetSocketAddress> locators;
-  private ViewReplyProcessor viewResponses = new ViewReplyProcessor();
+  private ViewReplyProcessor viewResponses = new ViewReplyProcessor(false);
+  
+  private ViewReplyProcessor prepareResponses = new ViewReplyProcessor(true);
-  private boolean disableForcedDisconnect = false;
+  private boolean quorumRequired = false;
+  
+  private int viewAckTimeout;
-        me.setShouldNotBeCoordinator(o.isShouldNotBeCoordinator());
+        me.setPreferredForCoordinator(o.preferredForCoordinator());
+    if (incomingRequest.getMemberID().getVersionObject().compareTo(Version.CURRENT) < 0) {
+      logger.warn("detected an attempt to start a peer using an older version of the product {}",
+          incomingRequest.getMemberID());
+      JoinResponseMessage m = new JoinResponseMessage("Rejecting the attempt of a member using an older version");
+      m.setRecipient(incomingRequest.getMemberID());
+      try {
+        services.getMessenger().send(m);
+      } catch (IOException e) {
+        //ignore - the attempt has been logged and the member can't join
+      }
+      return;
+    }
-      } catch (AuthenticationFailedException e) {
+      } catch (Exception e) {
+  
+  boolean prepareView(NetView view) {
+    return sendView(view, true, this.prepareResponses);
+  }
+  
-    // TODO two-phase view installation and network partition detection
-    // send a prepared view, check for conflicting prepared view
-    // examine members that don't respond & recreate view and start over
+    sendView(view, false, this.viewResponses);
+  }
+  
+  
+  boolean sendView(NetView view, boolean preparing, ViewReplyProcessor rp) {
-    InstallViewMessage msg = new InstallViewMessage(view, services.getAuthenticator().getCredentials());
+    InstallViewMessage msg = new InstallViewMessage(view, services.getAuthenticator().getCredentials(), preparing);
-    this.viewResponses.initialize(id, recips);
-    logger.info("View Creator sending new view " + view);
+    rp.initialize(id, recips);
+    logger.info("View Creator " + (preparing? "preparing" : "sending") + " new view " + view);
+      return false;
-    
-    Set<InternalDistributedMember> failedToRespond = this.viewResponses.waitForResponses();
-    
-    logger.info("View Creator is finished waiting for responses to view change");
-    if (!failedToRespond.isEmpty()  &&  (services.getCancelCriterion().cancelInProgress() == null)) {
-      logger.warn("these members failed to respond to the view change: " + failedToRespond);
+    // only wait for responses during preparation
+    if (preparing) {
+      Set<InternalDistributedMember> failedToRespond = rp.waitForResponses();
+
+      logger.info("View Creator is finished waiting for responses to view preparation");
+      
+      InternalDistributedMember conflictingViewSender = rp.getConflictingViewSender();
+      NetView conflictingView = rp.getConflictingView();
+      if (conflictingView != null) {
+        logger.warn("View Creator received a conflicting membership view from " + conflictingViewSender
+            + " during preparation: " + conflictingView);
+        return false;
+      }
+      
+      if (!failedToRespond.isEmpty()  &&  (services.getCancelCriterion().cancelInProgress() == null)) {
+        logger.warn("these members failed to respond to the view change: " + failedToRespond);
+        return false;
+      }
+    
+    return true;
+    
-    if (currentView != null  &&  !m.isPreparing() && !view.contains(this.localAddress)) {
-      services.getManager().forceDisconnect("I am no longer in the membership view");
-      return;
-    }
+      else {
+        this.preparedView = view;
+        ackView(m);
+      }
-
-    if (view.contains(view.getCreator())) {
-      ackView(m);
+    else { // !preparing
+      if (currentView != null  &&  !view.contains(this.localAddress)) {
+        if (quorumRequired) {
+          services.getManager().forceDisconnect("This node is no longer in the membership view");
+        }
+      }
+      else {
+        ackView(m);
+        installView(view);
+      }
-    
-    // process the view
-    installView(view);
-    // send an acknowledgement
-    try {
-      services.getMessenger().send(new ViewAckMessage(m.getSender(), m.getView().getViewId()));
-    } catch (IOException e) {
-      logger.info("unable to send view response to " + m.getSender(), e);
+    if (m.getView().contains(m.getView().getCreator())) {
+      try {
+        services.getMessenger().send(new ViewAckMessage(m.getSender(), m.getView().getViewId(), m.isPreparing()));
+      } catch (IOException e) {
+        logger.info("unable to send view response to " + m.getSender(), e);
+      }
-    this.viewResponses.processViewResponse(m.getViewId(), m.getSender());
+    if (m.isPrepareAck()) {
+      this.prepareResponses.processViewResponse(m.getViewId(), m.getSender(), m.getAlternateView());
+    } else {
+      this.viewResponses.processViewResponse(m.getViewId(), m.getSender(), m.getAlternateView());
+    }
+  
+
+    
-    for (InetSocketAddress addr: locators) { 
-      try {
-        Object o = TcpClient.requestToServer(
-            addr.getAddress(), addr.getPort(), request, services.getConfig().getJoinTimeout(), 
-            true);
-        FindCoordinatorResponse response = (o instanceof FindCoordinatorResponse) ? (FindCoordinatorResponse)o : null;
-        if (response != null && response.getCoordinator() != null) {
-          coordinators.add(response.getCoordinator());
-          GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
-          services.getConfig().setNetworkPartitionDetectionEnabled(response.isNetworkPartitionDetectionEnabled());
-          if (response.isUsePreferredCoordinators()
-              && localAddress.getVmKind() != DistributionManager.LOCATOR_DM_TYPE) {
-            mbr.setShouldNotBeCoordinator(true);
+    long giveUpTime = System.currentTimeMillis() + (services.getConfig().getLocatorWaitTime() * 1000L);
+    boolean anyResponses = false;
+    
+    do {
+      for (InetSocketAddress addr: locators) { 
+        try {
+          Object o = TcpClient.requestToServer(
+              addr.getAddress(), addr.getPort(), request, services.getConfig().getJoinTimeout(), 
+              true);
+          FindCoordinatorResponse response = (o instanceof FindCoordinatorResponse) ? (FindCoordinatorResponse)o : null;
+          if (response != null && response.getCoordinator() != null) {
+            anyResponses = false;
+            coordinators.add(response.getCoordinator());
+            GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
+            services.getConfig().setNetworkPartitionDetectionEnabled(response.isNetworkPartitionDetectionEnabled());
+            if (response.isUsePreferredCoordinators()
+                && localAddress.getVmKind() != DistributionManager.LOCATOR_DM_TYPE) {
+              mbr.setPreferredForCoordinator(false);
+            }
+        } catch (IOException | ClassNotFoundException problem) {
-      } catch (IOException problem) {
-      } catch (ClassNotFoundException problem) {
-    }
-    if (coordinators.isEmpty()) {
-      return null;
-    }
+      if (coordinators.isEmpty()) {
+        return null;
+      }
+      if (!anyResponses) {
+        try { Thread.sleep(2000); } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          return null;
+        }
+      }
+    } while (!anyResponses && System.currentTimeMillis() < giveUpTime);
+    
-      checkForPartition(newView);
+      
+      if (checkForPartition(newView)) {
+        if (quorumRequired) {
+          List<InternalDistributedMember> crashes = newView.getActualCrashedMembers(currentView);
+          services.getManager().forceDisconnect(
+              LocalizedStrings.Network_partition_detected.toLocalizedString(crashes.size(), crashes));
+        }
+        return;
+      }
+      
-      leader = newView.getLeadMember();
+      lastConflictingView = null;
-  private void checkForPartition(NetView newView) {
-    // compare currentView to newView to see if there's been a network
-    // partition event
-    
+  /**
+   * check to see if the new view shows a drop of 51% or more
+   */
+  private boolean checkForPartition(NetView newView) {
+    if (currentView == null) {
+      return false;
+    }
+    int oldWeight = currentView.memberWeight();
+    int failedWeight = newView.getCrashedMemberWeight(currentView);
+    if (failedWeight > 0) {
+      if (logger.isInfoEnabled()) {
+        newView.logCrashedMemberWeights(currentView, logger);
+      }
+      int failurePoint = (int)(Math.round(51 * oldWeight) / 100.0);
+      if (failedWeight > failurePoint) {
+        services.getManager().quorumLost(newView.getActualCrashedMembers(currentView), currentView);
+        return true;
+      }
+    }
+    return false;
-      viewCreator = new ViewCreator(Version.CURRENT.getProductName()
-          +" Membership View Creator", GMSMemberServices.getThreadGroup());
+      viewCreator = new ViewCreator("GemFire Membership View Creator", Services.getThreadGroup());
-    this.disableForcedDisconnect = true;
+    this.quorumRequired = false;
-  public void init(GMSMemberServices s) {
+  public void init(Services s) {
-
+    this.viewAckTimeout = ackCollectionTimeout;
+    
+    this.quorumRequired = services.getConfig().getDistributionConfig().getEnableNetworkPartitionDetection();
+    
+    volatile NetView conflictingView;
+    volatile InternalDistributedMember conflictingViewSender;
+    volatile boolean waiting;
+    final boolean isPrepareViewProcessor;
+    
+    ViewReplyProcessor(boolean forPreparation) {
+      this.isPrepareViewProcessor = forPreparation;
+    }
+      this.waiting = true;
-    void processViewResponse(int viewId, InternalDistributedMember sender) {
+    void processViewResponse(int viewId, InternalDistributedMember sender, NetView conflictingView) {
+      if (!this.waiting) {
+        return;
+      }
+      
+        if (conflictingView != null) {
+          this.conflictingViewSender = sender;
+          this.conflictingView = conflictingView;
+        }
+      
-      long endOfWait = System.currentTimeMillis() + VIEW_INSTALLATION_TIMEOUT;
-      while (System.currentTimeMillis() < endOfWait
-          &&  (services.getCancelCriterion().cancelInProgress() == null)) {
-        try {
-          synchronized(result) {
-            result.wait(1000);
+      long endOfWait = System.currentTimeMillis() + viewAckTimeout;
+      try {
+        while (System.currentTimeMillis() < endOfWait
+            &&  (services.getCancelCriterion().cancelInProgress() == null)) {
+          try {
+            synchronized(result) {
+              result.wait(1000);
+            }
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            return result;
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt();
-          return result;
+      } finally {
+        this.waiting = false;
+    
+    NetView getConflictingView() {
+      return this.conflictingView;
+    }
+    
+    InternalDistributedMember getConflictingViewSender() {
+      return this.conflictingViewSender;
+    }
+    
+    Set<InternalDistributedMember> getUnresponsiveMembers() {
+      return this.recipients;
+    }
-            createAndSendView(requests);
+            /*boolean success = */createAndSendView(requests);
-    void createAndSendView(List<DistributionMessage> requests) {
+    /**
+     * Create a new membership view and send it to members (including crashed members).
+     * Returns false if the view cannot be prepared successfully, true otherwise
+     */
+    boolean createAndSendView(List<DistributionMessage> requests) {
+      
-      // getting messages from them
+      // getting messages from members that have been kicked out
-      sendJoinResponses(joinReqs, newView);
+      
+      // we want to always check for quorum loss but don't act on it
+      // unless network-partition-detection is enabled
+      if ( !(checkForPartition(newView) && quorumRequired) ) {
+        sendJoinResponses(joinReqs, newView);
+      }
+
+      if (quorumRequired) {
+        boolean prepared = false;
+        do {
+          if (this.shutdown || Thread.currentThread().isInterrupted()) {
+            return false;
+          }
+          prepared = prepareView(newView);
+          if (!prepared && quorumRequired) {
+            Set<InternalDistributedMember> unresponsive = prepareResponses.getUnresponsiveMembers();
+            try {
+              removeHealthyMembers(unresponsive);
+            } catch (InterruptedException e) {
+              // abort the view if interrupted
+              shutdown = true;
+              return false;
+            }
+  
+            List<InternalDistributedMember> failures = new ArrayList<InternalDistributedMember>(currentView.getCrashedMembers().size() + unresponsive.size());
+            failures.addAll(unresponsive);
+            
+            NetView conflictingView = prepareResponses.getConflictingView();
+            if (conflictingView != null
+                && !conflictingView.getCreator().equals(localAddress)
+                && conflictingView.getViewId() > newView.getViewId()
+                && (lastConflictingView == null || conflictingView.getViewId() > lastConflictingView.getViewId())) {
+              lastConflictingView = conflictingView;
+              failures.addAll(conflictingView.getCrashedMembers());
+            }
+  
+            failures.removeAll(removalReqs);
+            if (failures.size() > 0) {
+              // abort the current view and try again
+              removalReqs.addAll(failures);
+              newView = new NetView(localAddress, newView.getViewId()+1, newView.getMembers(), leaveReqs,
+                  removalReqs);
+            }
+          }
+        } while (!prepared);
+      } // quorumRequired
+      
+      lastConflictingView = null;
+      
+      return true;
+    }
+    
+    /**
+     * performs health checks on the collection of members, removing any that
+     * are found to be healthy
+     * @param mbrs
+     */
+    private void removeHealthyMembers(Collection<InternalDistributedMember> mbrs) throws InterruptedException {
+      List<Callable<InternalDistributedMember>> checkers = new ArrayList<Callable<InternalDistributedMember>>(mbrs.size()); 
+      
+      for (InternalDistributedMember mbr: mbrs) {
+        final InternalDistributedMember fmbr = mbr;
+        checkers.add(new Callable<InternalDistributedMember>() {
+          @Override
+          public InternalDistributedMember call() throws Exception {
+            // return the member id if it fails health checks
+            logger.info("checking state of member " + fmbr);
+            if (services.getHealthMonitor().checkIfAvailable(fmbr, "Member failed to acknowledge a membership view", false)) {
+              logger.info("member " + fmbr + " passed availability check");
+              return null;
+            }
+            logger.info("member " + fmbr + " failed availability check");
+            return fmbr;
+          }
+        });
+      }
+      
+      ExecutorService svc = Executors.newFixedThreadPool(mbrs.size(), new ThreadFactory() {
+        AtomicInteger i = new AtomicInteger();
+        @Override
+        public Thread newThread(Runnable r) {
+          return new Thread(Services.getThreadGroup(), r,
+              "Member verification thread " + i.incrementAndGet());
+        }
+      });
+
+      try {
+        List<Future<InternalDistributedMember>> futures;
+        futures = svc.invokeAll(checkers);
+
+        for (Future<InternalDistributedMember> future: futures) {
+          try {
+            InternalDistributedMember mbr = future.get(viewAckTimeout, TimeUnit.MILLISECONDS);
+            if (mbr != null) {
+              logger.debug("disregarding lack of acknowledgement from {}", mbr);
+              mbrs.remove(mbr);
+            }
+          } catch (java.util.concurrent.TimeoutException e) {
+            // TODO should the member be removed if we can't verify it in time?
+          } catch (ExecutionException e) {
+            logger.info("unexpected exception caught during member verification", e);
+          }
+        }
+      } finally {
+        svc.shutdownNow();
+      }

Converting FilterProfile to use CopyOnWrite collections

There was a lot of overly-complicated code in FilterProfile to implement its own
copy-on-write but we now have CopyOnWriteHashSet and CopyOnWriteHashMap.  This
change-set converts FilterProfile to use those classes.

This change-set also includes refactoring of unregisterClientInterest performed in a
group refactoring session last week.  It adds unit tests for unregisterClientInterest
that give 96% code coverage for that algorithm and substantially increased coverage
for registerClientInterest as well.

+import com.gemstone.gemfire.internal.CopyOnWriteHashSet;
+import com.gemstone.gemfire.internal.util.concurrent.CopyOnWriteHashMap;
-   * this variable is used to ensure that the state of all of the interest
-   * variables is consistent with other threads.  See
-   * http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile
-   */
-  @SuppressWarnings("unused")
-  private volatile Object volatileBarrier = null;
-  
-  /**
-   * 
-   * This map is never modified in place. Updaters must synchronize via
-   * {@link #interestListLock}.
-  private  Map<Object, Set> keysOfInterest;
+  private final Map<Object, Set> keysOfInterest = new CopyOnWriteHashMap<>();
-  private  Map<Object, Set> keysOfInterestInv;
+  private final Map<Object, Set> keysOfInterestInv = new CopyOnWriteHashMap<>();
-   *
-   * This map is never modified in place. Updaters must synchronize via
-   * {@link #interestListLock}.
-  private  Map<Object, Map<Object, Pattern>> patternsOfInterest;
+  private final Map<Object, Map<Object, Pattern>> patternsOfInterest = new CopyOnWriteHashMap<>();
-  private  Map<Object, Map<Object, Pattern>> patternsOfInterestInv;
+  private final Map<Object, Map<Object, Pattern>> patternsOfInterestInv = new CopyOnWriteHashMap<>();
-   *
-   * This map is never modified in place. Updaters must synchronize via
-   * {@link #interestListLock}.
-  private  Map<Object, Map> filtersOfInterest;
+  private final Map<Object, Map> filtersOfInterest = new CopyOnWriteHashMap<>();
-  private  Map<Object, Map> filtersOfInterestInv;
+  private final Map<Object, Map> filtersOfInterestInv = new CopyOnWriteHashMap<>();
-  private Set<Long> allKeyClients = null;
+  private final Set<Long> allKeyClients = new CopyOnWriteHashSet<>();
-  private  Set<Long> allKeyClientsInv = null;
-  
-  /**
-   * An object used for synchronizing the interest lists
-   */
-  private transient final Object interestListLock = new Object();
+  private final Set<Long> allKeyClientsInv = new CopyOnWriteHashSet<>();
-  private volatile Map cqs = Collections.EMPTY_MAP;
+  private final Map cqs = new CopyOnWriteHashMap();
+  private final Object interestListLock = new Object();
+  
-  private volatile Map<InternalDistributedMember, LinkedList<OperationMessage>> filterProfileMsgQueue = new HashMap();
+  private volatile Map<InternalDistributedMember, LinkedList<OperationMessage>> filterProfileMsgQueue = new HashMap<>();
-    Set keysRegistered = null;
+    Set keysRegistered = new HashSet();
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
+    Long clientID = getClientIDForMaps(inputClientID);
-      case InterestType.KEY: {
+      case InterestType.KEY:
-        Set oldInterestList;
-            this.getKeysOfInterestInv() : this.getKeysOfInterest();
-        oldInterestList = koi.get(clientID);
-        Set newInterestList = (oldInterestList == null)?
-          new HashSet() : new HashSet(oldInterestList);
-        newInterestList.add(interest);
-        Map<Object,Set> newMap = new HashMap(koi);
-        newMap.put(clientID, newInterestList);
-        if (updatesAsInvalidates) {
-          this.setKeysOfInterestInv(newMap);
-        } else {
-          this.setKeysOfInterest(newMap);
-        }
-        // Create a set of keys to pass to any listeners. 
-        // There currently is no check to see if the key already exists. 
-        keysRegistered = new HashSet(); 
-        keysRegistered.add(interest);
+            getKeysOfInterestInv() : getKeysOfInterest();
+        registerKeyInMap(interest, keysRegistered, clientID, koi);
-      }
-
-      case InterestType.REGULAR_EXPRESSION: {
-        keysRegistered = new HashSet(); 
+      case InterestType.REGULAR_EXPRESSION:
-          // ALL_KEYS
-          Set akc = updatesAsInvalidates? this.getAllKeyClientsInv() : this.getAllKeyClients();
-          akc = new HashSet(akc);
+          Set akc = updatesAsInvalidates? getAllKeyClientsInv() : getAllKeyClients();
-            if (updatesAsInvalidates) {
-              this.setAllKeyClientsInv(akc);
-            } else {
-              this.setAllKeyClients(akc);
-            }
-          Pattern pattern = Pattern.compile((String) interest);
-              this.getPatternsOfInterestInv() : this.getPatternsOfInterest();
-          Map<Object, Pattern> oldInterestMap = pats.get(clientID);
-          Map<Object, Pattern> newInterestMap =(oldInterestMap == null)?
-            new HashMap() : new HashMap(oldInterestMap);
-          Pattern oldPattern = newInterestMap.put(interest, pattern);
-          if (oldPattern == null) {
-            // If the pattern didn't exist, add it to the set of keys to pass to any listeners. 
-            keysRegistered.add(interest);
-          }
-          Map<Object, Map<Object, Pattern>> newMap = new HashMap(pats);
-          newMap.put(clientID, newInterestMap);
-          if(updatesAsInvalidates) {
-            this.setPatternsOfInterestInv(newMap);
-          } else {
-            this.setPatternsOfInterest(newMap);
-          }
+              getPatternsOfInterestInv() : getPatternsOfInterest();
+          registerPatternInMap(interest, keysRegistered, clientID, pats);
+      case InterestType.FILTER_CLASS: {
+        opType = operationType.REGISTER_FILTER;
+        Map<Object, Map>filts = updatesAsInvalidates?
+            getFiltersOfInterestInv() : getFiltersOfInterest();
+        registerFilterClassInMap(interest, clientID, filts);
+        break;
-      case InterestType.FILTER_CLASS: {
-        // get instance of the filter
-        Class filterClass;
-        InterestFilter filter;
-        try {
-          filterClass = ClassLoadUtil.classFromName((String)interest);
-          filter = (InterestFilter)filterClass.newInstance();
-        }
-        catch (ClassNotFoundException cnfe) {
-          throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_NOT_FOUND_IN_CLASSPATH.toLocalizedString(interest), cnfe);
-        }
-        catch (Exception e) {
-          throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_COULD_NOT_BE_INSTANTIATED.toLocalizedString(interest), e);
-        }
-        opType = operationType.REGISTER_FILTER;
-        Map<Object, Map>filts = updatesAsInvalidates?
-            this.getFiltersOfInterestInv() : this.getFiltersOfInterest();
-        Map oldInterestMap = filts.get(clientID);
-        Map newInterestMap = (oldInterestMap == null)?
-          new HashMap() : new HashMap(oldInterestMap);
-        newInterestMap.put(interest, filter);
-        HashMap newMap = new HashMap(filts);
-        newMap.put(clientID, newInterestMap);
-        if (updatesAsInvalidates) {
-          this.setFiltersOfInterestInv(newMap);
-        } else {
-          this.setFiltersOfInterest(newMap);
-        }
-        break;
-      }
+  private void registerFilterClassInMap(Object interest, Long clientID,
+      Map<Object, Map> filts) {
+    // get instance of the filter
+    Class filterClass;
+    InterestFilter filter;
+    try {
+      filterClass = ClassLoadUtil.classFromName((String)interest);
+      filter = (InterestFilter)filterClass.newInstance();
+    }
+    catch (ClassNotFoundException cnfe) {
+      throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_NOT_FOUND_IN_CLASSPATH.toLocalizedString(interest), cnfe);
+    }
+    catch (Exception e) {
+      throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_COULD_NOT_BE_INSTANTIATED.toLocalizedString(interest), e);
+    }
+    Map interestMap = filts.get(clientID);
+    if (interestMap == null) {
+      interestMap = new CopyOnWriteHashMap();
+      filts.put(clientID, interestMap);
+    }
+    interestMap.put(interest, filter);
+  }
+
+  private void registerPatternInMap(Object interest, Set keysRegistered,
+      Long clientID, Map<Object, Map<Object, Pattern>> pats) {
+    Pattern pattern = Pattern.compile((String) interest);
+    Map<Object, Pattern> interestMap = pats.get(clientID);
+    if (interestMap == null) {
+      interestMap = new CopyOnWriteHashMap<Object, Pattern>();
+      pats.put(clientID, interestMap);
+    }
+    Pattern oldPattern = interestMap.put(interest, pattern);
+    if (oldPattern == null) {
+      // If the pattern didn't exist, add it to the set of keys to pass to any listeners. 
+      keysRegistered.add(interest);
+    }
+  }
+
+  private void registerKeyInMap(Object interest, Set keysRegistered,
+      Long clientID, Map<Object, Set> koi) {
+    Set interestList = koi.get(clientID);
+    if (interestList == null) {
+      interestList = new CopyOnWriteHashSet();
+      koi.put(clientID, interestList);
+    }
+    interestList.add(interest);
+    keysRegistered.add(interest);
+  }
+
-    Set keysUnregistered = null;
+    Set keysUnregistered = new HashSet();
-        if (interest == UnregisterAllInterest.singleton()) {
-          clearInterestFor(inputClientID);
-          // Bruce: this code removed since clearInterestFor() is more comprehensive
-//          if (this.keysOfInterest.get(clientID) != null) {
-//            Map newMap = new HashMap(this.keysOfInterest);
-//            Set removed = (Set)newMap.remove(clientID);
-//            // If something is removed, create a set of keys to pass
-//            // to any listeners
-//            if (removed != null) {
-//              keysUnregistered = new HashSet();
-//              keysUnregistered.addAll(removed);
-//            } 
-//            this.keysOfInterest = newMap;
-//          }
-//          if (this.keysOfInterestInv.get(clientID) != null) {
-//            Map newMap = new HashMap(this.keysOfInterestInv);
-//            Set removed = (Set)newMap.remove(clientID);
-//            // If something is removed, create a set of keys to pass
-//            // to any listeners
-//            if (removed != null) {
-//              if (keysUnregistered == null) keysUnregistered = new HashSet();
-//              keysUnregistered.addAll(removed);
-//            } 
-//            this.keysOfInterestInv = newMap;
-//          }
-          break;
-        }
-        Set oldInterestList = this.getKeysOfInterest().get(clientID);
-        if (oldInterestList != null) {
-          Set newInterestList = new HashSet(oldInterestList);
-          boolean removed = newInterestList.remove(interest);
-          if (removed) {
-            keysUnregistered = new HashSet();
-            keysUnregistered.add(interest);
-          } 
-          Map newMap = new HashMap(this.getKeysOfInterest());
-          if (newInterestList.size() > 0) {
-            newMap.put(clientID, newInterestList);
-          } else {
-            newMap.remove(clientID);
-          }
-          this.setKeysOfInterest(newMap);
-        }
-        oldInterestList = this.getKeysOfInterestInv().get(clientID);
-        if (oldInterestList != null) {
-          Set newInterestList = new HashSet(oldInterestList);
-          boolean removed = newInterestList.remove(interest);
-          if (removed) {
-            keysUnregistered = new HashSet();
-            keysUnregistered.add(interest);
-          } 
-          Map newMap = new HashMap(this.getKeysOfInterestInv());
-          if (newInterestList.size() > 0) {
-            newMap.put(clientID, newInterestList);
-          } else {
-            newMap.remove(clientID);
-          }
-          this.setKeysOfInterestInv(newMap);
-        }
+        unregisterClientKeys(inputClientID, interest,
+            clientID, keysUnregistered);
-        if (interest == UnregisterAllInterest.singleton()) {
-          if (this.getPatternsOfInterest().get(clientID) != null) {
-            HashMap newMap = new HashMap(this.getPatternsOfInterest());
-            Map removed = (Map)newMap.remove(clientID);
-            if (removed != null) {
-              keysUnregistered = new HashSet();
-              keysUnregistered.addAll(removed.keySet());
-            } 
-            this.setPatternsOfInterest(newMap);
-          }
-          if (this.getPatternsOfInterestInv().get(clientID) != null) {
-            HashMap newMap = new HashMap(this.getPatternsOfInterestInv());
-            Map removed = (Map)newMap.remove(clientID);
-            if (removed != null) {
-              if (keysUnregistered == null) keysUnregistered = new HashSet();
-              keysUnregistered.addAll(removed.keySet());
-            } 
-            this.setPatternsOfInterestInv(newMap);
-          }
-          Set oldSet = this.getAllKeyClients();
-          if (!oldSet.isEmpty()) {
-            Set newSet;
-            newSet = new HashSet(oldSet);
-            if (newSet.remove(clientID)) {
-              if (newSet.isEmpty()) {
-                newSet = null;
-              }
-              this.setAllKeyClients(newSet);
-              if (keysUnregistered == null) {
-                // keysUnregistered won't be null if somebody has registered
-                // interest in a specific key, then in '.*'.
-                keysUnregistered = new HashSet();
-              }
-              keysUnregistered.add(".*"); 
-            }
-          }
-          oldSet = this.getAllKeyClientsInv();
-          if (oldSet != null) {
-            Set newSet;
-            newSet = new HashSet(oldSet);
-            if (newSet.remove(clientID)) {
-              if (newSet.isEmpty()) {
-                newSet = null;
-              }
-              this.setAllKeyClientsInv(newSet);
-              if (keysUnregistered == null) {
-                // keysUnregistered won't be null if somebody has registered
-                // interest in a specific key, then in '.*'.
-                keysUnregistered = new HashSet();
-              }
-              keysUnregistered.add(".*"); 
-            }
-          }
-        }
-        else if (((String)interest).equals(".*")) { // ALL_KEYS
-          Set oldSet = this.getAllKeyClients();
-          if (oldSet != null) {
-            Set newSet;
-            newSet = new HashSet(oldSet);
-            if (newSet.remove(clientID)) {
-              if (newSet.isEmpty()) {
-                newSet = null;
-              }
-              this.setAllKeyClients(newSet);
-              // Since something was removed, create a set of keys to pass to any
-              // listeners
-              keysUnregistered = new HashSet();
-              keysUnregistered.add(interest); 
-            }
-          }
-          oldSet = this.getAllKeyClientsInv();
-          if (oldSet != null) {
-            Set newSet;
-            newSet = new HashSet(oldSet);
-            if (newSet.remove(clientID)) {
-              if (newSet.isEmpty()) {
-                newSet = null;
-              }
-              this.setAllKeyClientsInv(newSet);
-              // Since something was removed, create a set of keys to pass to any
-              // listeners
-              keysUnregistered = new HashSet();
-              keysUnregistered.add(interest); 
-            }
-          }
-        }
-        else {
-          Map oldInterestMap = this.getPatternsOfInterest().get(clientID);
-          if (oldInterestMap != null) {
-            Map newInterestMap = new HashMap(oldInterestMap);
-            Object obj = newInterestMap.remove(interest);
-            if (obj != null) {
-              // Since something was removed, create a set of keys to pass to any
-              // listeners
-              keysUnregistered = new HashSet();
-              keysUnregistered.add(interest); 
-            }
-            Map newMap = new HashMap(this.getPatternsOfInterest());
-            if (newInterestMap.size() > 0)
-              newMap.put(clientID, newInterestMap);
-            else
-              newMap.remove(clientID);
-            this.setPatternsOfInterest(newMap);
-          }
-          oldInterestMap = this.getPatternsOfInterestInv().get(clientID);
-          if (oldInterestMap != null) {
-            Map newInterestMap = new HashMap(oldInterestMap);
-            Object obj = newInterestMap.remove(interest);
-            if (obj != null) {
-              // Since something was removed, create a set of keys to pass to any
-              // listeners
-              keysUnregistered = new HashSet();
-              keysUnregistered.add(interest); 
-            }
-            Map newMap = new HashMap(this.getPatternsOfInterestInv());
-            if (newInterestMap.size() > 0)
-              newMap.put(clientID, newInterestMap);
-            else
-              newMap.remove(clientID);
-            this.setPatternsOfInterestInv(newMap);
-          }
-        }
+        unregisterClientPattern(interest, clientID,
+            keysUnregistered);
-        if (interest == UnregisterAllInterest.singleton()) {
-          if (this.getFiltersOfInterest().get(clientID) != null) {
-            Map newMap = new HashMap(this.getFiltersOfInterest());
-            newMap.remove(clientID);
-            this.setFiltersOfInterest(newMap);
-          }
-          if (this.getFiltersOfInterestInv().get(clientID) != null) {
-            Map newMap = new HashMap(this.getFiltersOfInterestInv());
-            newMap.remove(clientID);
-            this.setFiltersOfInterestInv(newMap);
-          }
-          break;
-        }
-        Map oldInterestMap = this.getFiltersOfInterest().get(clientID);
-        if (oldInterestMap != null) {
-          Map newInterestMap = new HashMap(oldInterestMap);
-          newInterestMap.remove(interest);
-          Map newMap = new HashMap(this.getFiltersOfInterest());
-          if (newInterestMap.size() > 0) {
-            newMap.put(clientID, newInterestMap);
-          } else {
-            newMap.remove(clientID);
-          }
-          this.setFiltersOfInterest(newMap);
-        }
-        oldInterestMap = this.getFiltersOfInterestInv().get(clientID);
-        if (oldInterestMap != null) {
-          Map newInterestMap = new HashMap(oldInterestMap);
-          newInterestMap.remove(interest);
-          Map newMap = new HashMap(this.getFiltersOfInterestInv());
-          if (newInterestMap.size() > 0) {
-            newMap.put(clientID, newInterestMap);
-          } else {
-            newMap.remove(clientID);
-          }
-          this.setFiltersOfInterestInv(newMap);
-        }
+        unregisterClientFilterClass(interest, clientID);
+  private void unregisterClientFilterClass(Object interest, Long clientID) {
+    if (interest == UnregisterAllInterest.singleton()) {
+      if (getFiltersOfInterest().get(clientID) != null) {
+        getFiltersOfInterest().remove(clientID);
+      }
+      if (getFiltersOfInterestInv().get(clientID) != null) {
+        getFiltersOfInterestInv().remove(clientID);
+      }
+      return;
+    }
+    Map interestMap = getFiltersOfInterest().get(clientID);
+    if (interestMap != null) {
+      interestMap.remove(interest);
+      if (interestMap.isEmpty()) {
+        getFiltersOfInterest().remove(clientID);
+      }
+    }
+    interestMap = getFiltersOfInterestInv().get(clientID);
+    if (interestMap != null) {
+      interestMap.remove(interest);
+      if (interestMap.isEmpty()) {
+        this.getFiltersOfInterestInv().remove(clientID);
+      }
+    }
+  }
+
+  private void unregisterClientPattern(Object interest, Long clientID,
+      Set keysUnregistered) {
+    if (interest instanceof String && ((String)interest).equals(".*")) { // ALL_KEYS
+      unregisterAllKeys(interest, clientID, keysUnregistered);
+      return;
+    }
+    if (interest == UnregisterAllInterest.singleton()) {
+      unregisterClientIDFromMap(clientID, getPatternsOfInterest(), keysUnregistered);
+      unregisterClientIDFromMap(clientID, getPatternsOfInterestInv(), keysUnregistered);
+      if (getAllKeyClients().remove(clientID)) {
+        keysUnregistered.add(".*"); 
+      }
+      if (getAllKeyClientsInv().remove(clientID)) {
+        keysUnregistered.add(".*"); 
+      }
+    }
+    else {
+      unregisterPatternFromMap(getPatternsOfInterest(), interest, clientID, keysUnregistered);
+      unregisterPatternFromMap(getPatternsOfInterestInv(), interest, clientID, keysUnregistered);
+    }
+  }
+
+  private void unregisterPatternFromMap(Map<Object, Map<Object, Pattern>> map,
+      Object interest, Long clientID, Set keysUnregistered) {
+    Map interestMap = map.get(clientID);
+    if (interestMap != null) {
+      Object obj = interestMap.remove(interest);
+      if (obj != null) {
+        keysUnregistered.add(interest); 
+      }
+      if (interestMap.isEmpty()) {
+        map.remove(clientID);
+      }
+    }
+  }
+
+  private void unregisterClientIDFromMap(Long clientID, Map interestMap, Set keysUnregistered) {
+    if (interestMap.get(clientID) != null) {
+      Map removed = (Map)interestMap.remove(clientID);
+      if (removed != null) {
+        keysUnregistered.addAll(removed.keySet());
+      } 
+    }
+  }
+
+  private void unregisterAllKeys(Object interest, Long clientID,
+      Set keysUnregistered) {
+    if (getAllKeyClients().remove(clientID)) {
+      keysUnregistered.add(interest); 
+    }
+    if (getAllKeyClientsInv().remove(clientID)) {
+      keysUnregistered.add(interest); 
+    }
+  }
+
+  private void unregisterClientKeys(Object inputClientID, Object interest,
+      Long clientID, Set keysUnregistered) {
+    if (interest == UnregisterAllInterest.singleton()) {
+      clearInterestFor(inputClientID);
+      return;
+    }
+    unregisterKeyFromMap(getKeysOfInterest(), interest, clientID, keysUnregistered);
+    unregisterKeyFromMap(getKeysOfInterestInv(), interest, clientID, keysUnregistered);
+    return;
+  }
+
+  private void unregisterKeyFromMap(Map<Object, Set> map, Object interest, Long clientID,
+      Set keysUnregistered) {
+    Set interestList = map.get(clientID);
+    if (interestList != null) {
+      boolean removed = interestList.remove(interest);
+      if (removed) {
+        keysUnregistered.add(interest);
+      } 
+      if (interestList.isEmpty()) {
+        map.remove(clientID);
+      }
+    }
+  }
+
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
+    Long clientID = getClientIDForMaps(inputClientID);
-          this.getKeysOfInterestInv() : this.getKeysOfInterest();
-      Set oldInterestList = koi.get(clientID);
-      Set newInterestList = (oldInterestList == null)?
-        new HashSet() : new HashSet(oldInterestList);
+          getKeysOfInterestInv() : getKeysOfInterest();
+      Set interestList = koi.get(clientID);
+      if (interestList == null) {
+        interestList = new CopyOnWriteHashSet();
+        koi.put(clientID, interestList);
+      }
-        if (newInterestList.add(key)) { 
+        if (interestList.add(key)) { 
-      Map newMap = new HashMap(koi);
-      newMap.put(clientID, newInterestList);
-      if (updatesAsInvalidates) {
-        this.setKeysOfInterestInv(newMap);
-      } else {
-        this.setKeysOfInterest(newMap);
-      }
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
+    Long clientID = getClientIDForMaps(inputClientID);
-      Set oldInterestList = this.getKeysOfInterest().get(clientID);
-      if (oldInterestList != null) {
-        Set newInterestList = new HashSet(oldInterestList);
+      Set interestList = getKeysOfInterest().get(clientID);
+      if (interestList != null) {
-          if (newInterestList.remove(keyOfInterest)) { 
+          if (interestList.remove(keyOfInterest)) { 
-        Map newMap = new HashMap(this.getKeysOfInterest());
-        if (newInterestList.size() > 0)
-          newMap.put(clientID, newInterestList);
-        else
-          newMap.remove(clientID);
-        this.setKeysOfInterest(newMap);
+        if (interestList.isEmpty()) {
+          getKeysOfInterest().remove(clientID);
+        }
-      oldInterestList = this.getKeysOfInterestInv().get(clientID);
-      if (oldInterestList != null) {
-        Set newInterestList = new HashSet(oldInterestList);
+      interestList = getKeysOfInterestInv().get(clientID);
+      if (interestList != null) {
-          if (newInterestList.remove(keyOfInterest)) { 
+          if (interestList.remove(keyOfInterest)) { 
-        Map newMap = new HashMap(this.getKeysOfInterestInv());
-        if (newInterestList.size() > 0)
-          newMap.put(clientID, newInterestList);
-        else
-          newMap.remove(clientID);
-        this.setKeysOfInterestInv(newMap);
+        if (interestList.isEmpty()) {
+          getKeysOfInterestInv().remove(clientID);
+        }
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
-    volatileBarrier();
+    Long clientID = getClientIDForMaps(inputClientID);
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
-    volatileBarrier();
+    Long clientID = getClientIDForMaps(inputClientID);
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
-    volatileBarrier();
+    Long clientID = getClientIDForMaps(inputClientID);
-    return this.getKeysOfInterestInv().containsKey(clientID);
+    return this.getKeysOfInterest().containsKey(clientID);
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
-    volatileBarrier();
+    Long clientID = getClientIDForMaps(inputClientID);
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
+    Long clientID = getClientIDForMaps(inputClientID);
-      volatileBarrier();
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
-    volatileBarrier();
+    Long clientID = getClientIDForMaps(inputClientID);
-    Long clientID;
-    if (inputClientID instanceof Long) {
-      clientID = (Long)inputClientID;
-    } else {
-      clientID = clientMap.getWireID(inputClientID);
-    }
-    volatileBarrier();
+    Long clientID = getClientIDForMaps(inputClientID);
-    return this.getFiltersOfInterestInv().containsKey(clientID);
+    return this.getFiltersOfInterest().containsKey(clientID);
-          akc = new HashSet(akc);
-          this.setAllKeyClients(akc);
-          akci = new HashSet(akci);
-          this.setAllKeyClientsInv(akci);
-          Map newkeys = new HashMap(keys);
-          newkeys.remove(clientID);
-          this.setKeysOfInterest(newkeys);
+          keys.remove(clientID);
-          Map newkeys = new HashMap(keys);
-          newkeys.remove(clientID);
-          this.setKeysOfInterestInv(newkeys);
+          keys.remove(clientID);
-          Map newpats = new HashMap(pats);
-          newpats.remove(clientID);
-          this.setPatternsOfInterest(newpats);
+          pats.remove(clientID);
-          Map newpats = new HashMap(pats);
-          newpats.remove(clientID);
-          this.setPatternsOfInterestInv(newpats);
+          pats.remove(clientID);
-          Map newfilts = new HashMap(filters);
-          newfilts.remove(clientID);
-          this.setFiltersOfInterest(newfilts);
+          filters.remove(clientID);
-          Map newfilts = new HashMap(filters);
-          newfilts.remove(clientID);
-          this.setFiltersOfInterestInv(newfilts);
+          filters.remove(clientID);
-    Map newCqs = new HashMap(this.cqs);
-    newCqs.put(cq.getServerCqName(), cq);
-    this.cqs = newCqs;
+    this.cqs.put(cq.getServerCqName(), cq);
-      Map newCqs = new HashMap(this.cqs);
-      newCqs.put(serverCqName, cq);
-      this.cqs = newCqs;
+      this.cqs.put(serverCqName, cq);
-      Map newCqs = new HashMap(cqs);
-      newCqs.remove(serverCqName);
-      this.cqs = newCqs;
+      this.cqs.remove(serverCqName);
-    Map newCqs = new HashMap(this.cqs);
-    newCqs.remove(serverCqName);
-    this.cqs = newCqs;
+    this.cqs.remove(serverCqName);
-    volatileBarrier();
-    
-    volatileBarrier();
-      volatileBarrier();
-     volatileBarrier();
-  
-  
-  /* DataSerializableFixedID methods ---------------------------------------- */
-
-    this.allKeyClients = InternalDataSerializer.readSetOfLongs(in);
-    this.keysOfInterest = DataSerializer.readHashMap(in);
-    this.patternsOfInterest = DataSerializer.readHashMap(in);
-    this.filtersOfInterest = DataSerializer.readHashMap(in);
+    this.allKeyClients.addAll(InternalDataSerializer.readSetOfLongs(in));
+    this.keysOfInterest.putAll(DataSerializer.readHashMap(in));
+    this.patternsOfInterest.putAll(DataSerializer.readHashMap(in));
+    this.filtersOfInterest.putAll(DataSerializer.readHashMap(in));
-    this.allKeyClientsInv = InternalDataSerializer.readSetOfLongs(in);
-    this.keysOfInterestInv = DataSerializer.readHashMap(in);
-    this.patternsOfInterestInv = DataSerializer.readHashMap(in);
-    this.filtersOfInterestInv = DataSerializer.readHashMap(in);
+    this.allKeyClientsInv.addAll(InternalDataSerializer.readSetOfLongs(in));
+    this.keysOfInterestInv.putAll(DataSerializer.readHashMap(in));
+    this.patternsOfInterestInv.putAll(DataSerializer.readHashMap(in));
+    this.filtersOfInterestInv.putAll(DataSerializer.readHashMap(in));
-      Map theCQs = new HashMap(numCQs);
-          theCQs.put(serverCqName, cq);
+          this.cqs.put(serverCqName, cq);
-        this.cqs = theCQs;
-    DataSerializer.writeHashMap((HashMap)this.keysOfInterest, out);
-    DataSerializer.writeHashMap((HashMap)this.patternsOfInterest, out);
-    DataSerializer.writeHashMap((HashMap)this.filtersOfInterest, out);
+    DataSerializer.writeHashMap(this.keysOfInterest, out);
+    DataSerializer.writeHashMap(this.patternsOfInterest, out);
+    DataSerializer.writeHashMap(this.filtersOfInterest, out);
-    DataSerializer.writeHashMap((HashMap)this.keysOfInterestInv, out);
-    DataSerializer.writeHashMap((HashMap)this.patternsOfInterestInv, out);
-    DataSerializer.writeHashMap((HashMap)this.filtersOfInterestInv, out);
+    DataSerializer.writeHashMap(this.keysOfInterestInv, out);
+    DataSerializer.writeHashMap(this.patternsOfInterestInv, out);
+    DataSerializer.writeHashMap(this.filtersOfInterestInv, out);
-    Map<Object,Set> keysOfInterestRef = this.keysOfInterest;
-    return keysOfInterestRef == null? Collections.EMPTY_MAP : keysOfInterestRef;
-  }
-
-  /**
-   * @param keysOfInterest the keysOfInterest to set
-   */
-  private void setKeysOfInterest(Map keysOfInterest) {
-    this.keysOfInterest = keysOfInterest;
+    return this.keysOfInterest;
-    Map<Object, Set> keysOfInterestInvRef = this.keysOfInterestInv;
-    return keysOfInterestInvRef == null? Collections.EMPTY_MAP : keysOfInterestInvRef;
-  }
-
-  /**
-   * @param keysOfInterestInv the keysOfInterestInv to set
-   */
-  private void setKeysOfInterestInv(Map keysOfInterestInv) {
-    this.keysOfInterestInv = keysOfInterestInv;
+    return this.keysOfInterestInv;
-    Map<Object, Map<Object, Pattern>> patternsOfInterestRef = this.patternsOfInterest;
-    return patternsOfInterestRef == null? Collections.EMPTY_MAP : patternsOfInterestRef;
-  }
-
-  /**
-   * @param patternsOfInterest the patternsOfInterest to set
-   */
-  private void setPatternsOfInterest(Map patternsOfInterest) {
-    this.patternsOfInterest = patternsOfInterest;
+    return this.patternsOfInterest;
-    Map<Object, Map<Object, Pattern>> patternsOfInterestInvRef = this.patternsOfInterestInv;
-    return patternsOfInterestInvRef == null? Collections.EMPTY_MAP : patternsOfInterestInvRef;
-  }
-
-  /**
-   * @param patternsOfInterestInv the patternsOfInterestInv to set
-   */
-  private void setPatternsOfInterestInv(Map patternsOfInterestInv) {
-    this.patternsOfInterestInv = patternsOfInterestInv;
+    return this.patternsOfInterestInv;
-    Map<Object, Map> filtersOfInterestInvRef = filtersOfInterestInv;
-    return filtersOfInterestInvRef == null? Collections.EMPTY_MAP : filtersOfInterestInvRef;
+    return this.filtersOfInterestInv;
-   * @param filtersOfInterestInv the filtersOfInterestInv to set
-   */
-  void setFiltersOfInterestInv(Map filtersOfInterestInv) {
-    this.filtersOfInterestInv = filtersOfInterestInv;
-  }
-
-
-
-  /**
-    Map<Object, Map> filtersOfInterestRef = this.filtersOfInterest;
-    return  filtersOfInterestRef == null? Collections.EMPTY_MAP : filtersOfInterestRef;
+    return this.filtersOfInterest;
-  /**
-   * @param filtersOfInterest the filtersOfInterest to set
-   */
-  private void setFiltersOfInterest(Map filtersOfInterest) {
-    this.filtersOfInterest = filtersOfInterest;
-  }
-
-  /**
-   * So far all calls to setAllKeyClients has occurred under synchronized blocks, locking on interestListLock
-   * @param akc the allKeyClients to set
-   */
-  private void setAllKeyClients(Set akc) {
-    this.allKeyClients = akc;
-    if (logger.isDebugEnabled()) {
-      logger.debug("{}: updated allKeyClients to {}", this, akc);
-    }
-  }
-  
-  /**
-   * perform a volatile read to ensure that all state is consistent
-   */
-  private void volatileBarrier() {
-    volatileBarrier = this.cqCount; // volatile write
-  }
-
-  /**
-   * It is possible to do a get outside of a synch block, so it can change if another thread
-   * calls setAllKeyClients.  So instead we store a ref to allKeyClients and if it changes
-   * we at least have the one we expected to return.
-   * @return the allKeyClients
-   */
-    return allKeysRef == null? Collections.EMPTY_SET : allKeysRef;
+    return allKeysRef;
-  /**
-   * @param akc the allKeyClientsInv to set
-   */
-  private void setAllKeyClientsInv(Set akc) {
-    this.allKeyClientsInv = akc;
-  }
-
-  /**
-   * It is possible to do a get outside of a synch block, so it can change if another thread
-   * calls setAllKeyClients.  So instead we store a ref to allKeyClientsInv and if it changes
-   * we at least have the one we expected to return.
-   * @return the allKeyClientsInv
-   */
-  private Set<Object> getAllKeyClientsInv() {
-    Set allKeysInvRef = this.allKeyClientsInv;
-    return allKeysInvRef == null? Collections.EMPTY_SET : allKeysInvRef;
+  private Set<Long> getAllKeyClientsInv() {
+    return this.allKeyClientsInv;
+  
+  /**
+   * When clients are registered they are assigned a Long identifier.
+   * This method maps between the real client ID and its Long identifier.
+   */
+  private Long getClientIDForMaps(Object inputClientID) {
+    Long clientID;
+    if (inputClientID instanceof Long) {
+      clientID = (Long)inputClientID;
+    } else {
+      clientID = clientMap.getWireID(inputClientID);
+    }
+    return clientID;
+  }

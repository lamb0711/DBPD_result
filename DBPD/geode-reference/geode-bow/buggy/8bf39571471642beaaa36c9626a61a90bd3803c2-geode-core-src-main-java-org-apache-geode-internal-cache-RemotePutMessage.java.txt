Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Replicate Region update message.  Meant to be sent only to
- * the peer who hosts transactional data.
+ * A Replicate Region update message. Meant to be sent only to the peer who hosts transactional
+ * data.
-  implements NewValueImporter, OldValueImporter {
+    implements NewValueImporter, OldValueImporter {
-  
+
-  
+
-  /** Used on sender side only to defer serialization until toData is called.
+  /**
+   * Used on sender side only to defer serialization until toData is called.
-  @Unretained(ENTRY_EVENT_NEW_VALUE) 
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
-  @Unretained(ENTRY_EVENT_OLD_VALUE) 
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-   * for relayed messages, this is the sender of the original message.  It should be used in constructing events
-   * for listener notification.
+   * for relayed messages, this is the sender of the original message. It should be used in
+   * constructing events for listener notification.
-  
+
-   * Indicates if and when the new value should be deserialized on the
-   * the receiver. Distinguishes between a non-byte[] value that was
-   * serialized (DESERIALIZATION_POLICY_LAZY) and a
-   * byte[] array value that didn't need to be serialized
-   * (DESERIALIZATION_POLICY_NONE). While this seems like an extra data, it
-   * isn't, because serializing a byte[] causes the type (a byte)
-   * to be written in the stream, AND what's better is
-   * that handling this distinction at this level reduces processing for values
-   * that are byte[].
+   * Indicates if and when the new value should be deserialized on the the receiver. Distinguishes
+   * between a non-byte[] value that was serialized (DESERIALIZATION_POLICY_LAZY) and a byte[] array
+   * value that didn't need to be serialized (DESERIALIZATION_POLICY_NONE). While this seems like an
+   * extra data, it isn't, because serializing a byte[] causes the type (a byte) to be written in
+   * the stream, AND what's better is that handling this distinction at this level reduces
+   * processing for values that are byte[].
-  protected byte deserializationPolicy =
-    DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
+  protected byte deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
-   * For put to happen, the old value must be equal to this
-   * expectedOldValue.
+   * For put to happen, the old value must be equal to this expectedOldValue.
+   * 
-  
+
-   * state from operateOnRegion that must be preserved for transmission
-   * from the waiting pool
+   * state from operateOnRegion that must be preserved for transmission from the waiting pool
- /** whether new value is formed by applying delta **/
+  /** whether new value is formed by applying delta **/
-  
-  /** delta bytes read in fromData that will be used in operate()*/
+
+  /** delta bytes read in fromData that will be used in operate() */
-  protected static final int HAS_ORIGINAL_SENDER =
-      getNextByteMask(HAS_BRIDGE_CONTEXT);
-  protected static final int HAS_VERSION_TAG =
-      getNextByteMask(HAS_ORIGINAL_SENDER);
+  protected static final int HAS_ORIGINAL_SENDER = getNextByteMask(HAS_BRIDGE_CONTEXT);
+  protected static final int HAS_VERSION_TAG = getNextByteMask(HAS_ORIGINAL_SENDER);
-  public RemotePutMessage() {
-  }
+  public RemotePutMessage() {}
-  private RemotePutMessage(Set recipients,
-                     String regionPath,
-                     DirectReplyProcessor processor,
-                     EntryEventImpl event,
-                     final long lastModified,
-                     boolean ifNew,
-                     boolean ifOld,
-                     Object expectedOldValue,
-                     boolean requireOldValue,
-                     boolean useOriginRemote,
-                     int processorType, boolean possibleDuplicate) {
+  private RemotePutMessage(Set recipients, String regionPath, DirectReplyProcessor processor,
+      EntryEventImpl event, final long lastModified, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue, boolean useOriginRemote, int processorType,
+      boolean possibleDuplicate) {
-    }
-    else {
+    } else {
-      assert this.deserializationPolicy ==
-        DistributedCacheOperation.DESERIALIZATION_POLICY_NONE :
-        this.deserializationPolicy;
+      assert this.deserializationPolicy == DistributedCacheOperation.DESERIALIZATION_POLICY_NONE : this.deserializationPolicy;
-  
+
-   * this is similar to send() but it selects an initialized replicate
-   * that is used to proxy the message
+   * this is similar to send() but it selects an initialized replicate that is used to proxy the
+   * message
-  public static boolean distribute(EntryEventImpl event, long lastModified,
-      boolean ifNew, boolean ifOld, Object expectedOldValue,
-      boolean requireOldValue, boolean onlyPersistent) {
+  public static boolean distribute(EntryEventImpl event, long lastModified, boolean ifNew,
+      boolean ifOld, Object expectedOldValue, boolean requireOldValue, boolean onlyPersistent) {
-    DistributedRegion r = (DistributedRegion)event.getRegion();
-    Collection replicates = onlyPersistent ? r.getCacheDistributionAdvisor()
-        .adviseInitializedPersistentMembers().keySet() : r
-        .getCacheDistributionAdvisor().adviseInitializedReplicates();
+    DistributedRegion r = (DistributedRegion) event.getRegion();
+    Collection replicates = onlyPersistent
+        ? r.getCacheDistributionAdvisor().adviseInitializedPersistentMembers().keySet()
+        : r.getCacheDistributionAdvisor().adviseInitializedReplicates();
-    for (Iterator<InternalDistributedMember> it=replicates.iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-        RemotePutResponse response = send(replicate,
-            event.getRegion(),
-            event, lastModified, ifNew, ifOld, expectedOldValue, requireOldValue,
-            false, DistributionManager.SERIAL_EXECUTOR, posDup);
+        RemotePutResponse response =
+            send(replicate, event.getRegion(), event, lastModified, ifNew, ifOld, expectedOldValue,
+                requireOldValue, false, DistributionManager.SERIAL_EXECUTOR, posDup);
-        event.setOldValue(result.oldValue, true/*force*/);
+        event.setOldValue(result.oldValue, true/* force */);
-            event.getRegion().getVersionVector().recordVersion(result.versionTag.getMemberID(), result.versionTag);
+            event.getRegion().getVersionVector().recordVersion(result.versionTag.getMemberID(),
+                result.versionTag);
-      
+
-      
+
-      } catch(RemoteOperationException e) {
+      } catch (RemoteOperationException e) {
-          logger.trace(LogMarker.DM, "RemotePutMessage caught an unexpected exception during distribution", e);
+          logger.trace(LogMarker.DM,
+              "RemotePutMessage caught an unexpected exception during distribution", e);
-  
+
-   * Sends a ReplicateRegion
-   * {@link org.apache.geode.cache.Region#put(Object, Object)} message to
+   * Sends a ReplicateRegion {@link org.apache.geode.cache.Region#put(Object, Object)} message to
+   * 
-   * @param r  the PartitionedRegion for which the put was performed
+   * @param r the PartitionedRegion for which the put was performed
-   * @return the processor used to await acknowledgement that the update was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * @return the processor used to await acknowledgement that the update was sent, or null to
+   *         indicate that no acknowledgement will be sent
-  public static RemotePutResponse txSend(DistributedMember recipient,
-                                       LocalRegion r,
-                                       EntryEventImpl event,
-                                       final long lastModified,
-                                       boolean ifNew,
-                                       boolean ifOld,
-                                       Object expectedOldValue,
-                                       boolean requireOldValue)
-  throws RemoteOperationException {
-    return send(recipient, r, event, lastModified, ifNew,
-        ifOld, expectedOldValue, requireOldValue, true, DistributionManager.PARTITIONED_REGION_EXECUTOR, false);
+  public static RemotePutResponse txSend(DistributedMember recipient, LocalRegion r,
+      EntryEventImpl event, final long lastModified, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue) throws RemoteOperationException {
+    return send(recipient, r, event, lastModified, ifNew, ifOld, expectedOldValue, requireOldValue,
+        true, DistributionManager.PARTITIONED_REGION_EXECUTOR, false);
-   * Sends a ReplicateRegion
-   * {@link org.apache.geode.cache.Region#put(Object, Object)} message to
+   * Sends a ReplicateRegion {@link org.apache.geode.cache.Region#put(Object, Object)} message to
+   * 
-   * @param r  the PartitionedRegion for which the put was performed
+   * @param r the PartitionedRegion for which the put was performed
-   * @param processorType the type of executor to use (e.g., DistributionManager.PARTITIONED_REGION_EXECUTOR)
+   * @param processorType the type of executor to use (e.g.,
+   *        DistributionManager.PARTITIONED_REGION_EXECUTOR)
-   * @return the processor used to await acknowledgement that the update was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * @return the processor used to await acknowledgement that the update was sent, or null to
+   *         indicate that no acknowledgement will be sent
-  public static RemotePutResponse send(DistributedMember recipient,
-                                       LocalRegion r,
-                                       EntryEventImpl event,
-                                       final long lastModified,
-                                       boolean ifNew,
-                                       boolean ifOld,
-                                       Object expectedOldValue,
-                                       boolean requireOldValue,
-                                       boolean useOriginRemote, int processorType, boolean possibleDuplicate)
-  throws RemoteOperationException {
-    //Assert.assertTrue(recipient != null, "RemotePutMessage NULL recipient");  recipient can be null for event notifications
+  public static RemotePutResponse send(DistributedMember recipient, LocalRegion r,
+      EntryEventImpl event, final long lastModified, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue, boolean useOriginRemote, int processorType,
+      boolean possibleDuplicate) throws RemoteOperationException {
+    // Assert.assertTrue(recipient != null, "RemotePutMessage NULL recipient"); recipient can be
+    // null for event notifications
-    RemotePutResponse processor = new RemotePutResponse(r.getSystem(), recipients, event.getKey(), false);
+    RemotePutResponse processor =
+        new RemotePutResponse(r.getSystem(), recipients, event.getKey(), false);
-    RemotePutMessage m = new RemotePutMessage(recipients,
-                                  r.getFullPath(),
-                                  processor,
-                                  event,
-                                  lastModified,
-                                  ifNew,
-                                  ifOld,
-                                  expectedOldValue,
-                                  requireOldValue,
-                                  useOriginRemote,
-                                  processorType, possibleDuplicate);
+    RemotePutMessage m = new RemotePutMessage(recipients, r.getFullPath(), processor, event,
+        lastModified, ifNew, ifOld, expectedOldValue, requireOldValue, useOriginRemote,
+        processorType, possibleDuplicate);
-    
+
-    Set failures =r.getDistributionManager().putOutgoing(m);
+    Set failures = r.getDistributionManager().putOutgoing(m);
-      throw new RemoteOperationException(LocalizedStrings.RemotePutMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new RemoteOperationException(
+          LocalizedStrings.RemotePutMessage_FAILED_SENDING_0.toLocalizedString(m));
-  //  public final boolean needsDirectAck()
-  //  {
-  //    return this.directAck;
-  //  }
+  // public final boolean needsDirectAck()
+  // {
+  // return this.directAck;
+  // }
-//  final public int getProcessorType() {
-//    return DistributionManager.PARTITIONED_REGION_EXECUTOR;
-//  }
+  // final public int getProcessorType() {
+  // return DistributionManager.PARTITIONED_REGION_EXECUTOR;
+  // }
-  public final Object getKey()
-  {
+  public final Object getKey() {
-  public final void setKey(Object key)
-  {
+  public final void setKey(Object key) {
-  public final byte[] getValBytes()
-  {
+  public final byte[] getValBytes() {
-  public final byte[] getOldValueBytes(){
+  public final byte[] getOldValueBytes() {
-  private void setValBytes(byte[] valBytes)
-  {
+  private void setValBytes(byte[] valBytes) {
-  private void setOldValBytes(byte[] valBytes){
+  private void setOldValBytes(byte[] valBytes) {
-  private Object getOldValObj(){
+  private Object getOldValObj() {
-  private void setOldValObj(@Unretained(ENTRY_EVENT_OLD_VALUE) Object o){
+  private void setOldValObj(@Unretained(ENTRY_EVENT_OLD_VALUE) Object o) {
-  protected final Operation getOperation()
-  {
+  protected final Operation getOperation() {
-        }
+  }
+
-  public void setHasOldValue(final boolean value){
+  public void setHasOldValue(final boolean value) {
-  public final void fromData(DataInput in) throws IOException,
-      ClassNotFoundException
-  {
+  public final void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.deserializationPolicy = (byte)(extraFlags
-        & DistributedCacheOperation.DESERIALIZATION_POLICY_MASK);
+    this.deserializationPolicy =
+        (byte) (extraFlags & DistributedCacheOperation.DESERIALIZATION_POLICY_MASK);
-  protected void setFlags(short flags, DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void setFlags(short flags, DataInput in) throws IOException, ClassNotFoundException {
-  public final void toData(DataOutput out) throws IOException
-  {
+  public final void toData(DataOutput out) throws IOException {
-    if (this.bridgeContext != null) extraFlags |= HAS_BRIDGE_CONTEXT;
-    if (this.originalSender != null) extraFlags |= HAS_ORIGINAL_SENDER;
-    if (this.versionTag != null) extraFlags |= HAS_VERSION_TAG;
+    if (this.bridgeContext != null)
+      extraFlags |= HAS_BRIDGE_CONTEXT;
+    if (this.originalSender != null)
+      extraFlags |= HAS_ORIGINAL_SENDER;
+    if (this.versionTag != null)
+      extraFlags |= HAS_VERSION_TAG;
-    DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(), out);
+    DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(),
+        out);
-    if (this.ifNew) s |= IF_NEW;
-    if (this.ifOld) s |= IF_OLD;
-    if (this.requireOldValue) s |= REQUIRED_OLD_VAL;
-    if (this.hasOldValue) s |= HAS_OLD_VAL;
-    if (this.event.getDeltaBytes() != null) s |= HAS_DELTA_BYTES;
-    if (this.expectedOldValue != null) s |= HAS_EXPECTED_OLD_VAL;
-    if (this.useOriginRemote) s |= USE_ORIGIN_REMOTE;
-    if (this.possibleDuplicate) s |= POS_DUP;
+    if (this.ifNew)
+      s |= IF_NEW;
+    if (this.ifOld)
+      s |= IF_OLD;
+    if (this.requireOldValue)
+      s |= REQUIRED_OLD_VAL;
+    if (this.hasOldValue)
+      s |= HAS_OLD_VAL;
+    if (this.event.getDeltaBytes() != null)
+      s |= HAS_DELTA_BYTES;
+    if (this.expectedOldValue != null)
+      s |= HAS_EXPECTED_OLD_VAL;
+    if (this.useOriginRemote)
+      s |= USE_ORIGIN_REMOTE;
+    if (this.possibleDuplicate)
+      s |= POS_DUP;
-   * This method is called upon receipt and make the desired changes to the
-   * Replicate Region. Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the Replicate Region. Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected final boolean operateOnRegion(DistributionManager dm,
-                                                     LocalRegion r,
-                                                     long startTime)
-  throws EntryExistsException, RemoteOperationException {
+  protected final boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws EntryExistsException, RemoteOperationException {
-       eventSender = getSender();
+      eventSender = getSender();
-    @Released EntryEventImpl eei = EntryEventImpl.create(
-        r,
-        getOperation(),
-        getKey(),
-        null, /*newValue*/
+    @Released
+    EntryEventImpl eei = EntryEventImpl.create(r, getOperation(), getKey(), null, /* newValue */
-        useOriginRemote, /*originRemote - false to force distribution in buckets*/
-        eventSender,
-        true/*generateCallbacks*/,
-        false/*initializeId*/);
+        useOriginRemote, /* originRemote - false to force distribution in buckets */
+        eventSender, true/* generateCallbacks */, false/* initializeId */);
-    if (this.versionTag != null) {
-      this.versionTag.replaceNullIDs(getSender());
-      event.setVersionTag(this.versionTag);
-    }
-    this.event.setCausedByMessage(this);
-    
-    event.setPossibleDuplicate(this.possibleDuplicate);
-    if (this.bridgeContext != null) {
-      event.setContext(this.bridgeContext);
-    }
-    
-    Assert.assertTrue(eventId != null);
-    event.setEventId(eventId);
+      if (this.versionTag != null) {
+        this.versionTag.replaceNullIDs(getSender());
+        event.setVersionTag(this.versionTag);
+      }
+      this.event.setCausedByMessage(this);
-    //added for cq procesing
-    if (this.hasOldValue){
-      if (this.oldValueIsSerialized){
-        event.setSerializedOldValue(getOldValueBytes());
+      event.setPossibleDuplicate(this.possibleDuplicate);
+      if (this.bridgeContext != null) {
+        event.setContext(this.bridgeContext);
-      else{
-        event.setOldValue(getOldValueBytes());
-      }
-    }
-    if (this.applyDeltaBytes) {
-      event.setNewValue(this.valObj);
-      event.setDeltaBytes(this.deltaBytes);
-    }
-    else {
-      switch (this.deserializationPolicy) {
-        case DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY:
-          event.setSerializedNewValue(getValBytes());
-          break;
-        case DistributedCacheOperation.DESERIALIZATION_POLICY_NONE:
-          event.setNewValue(getValBytes());
-          break;
-        default:
-          throw new AssertionError("unknown deserialization policy: "
-              + deserializationPolicy);
+      Assert.assertTrue(eventId != null);
+      event.setEventId(eventId);
+
+      // added for cq procesing
+      if (this.hasOldValue) {
+        if (this.oldValueIsSerialized) {
+          event.setSerializedOldValue(getOldValueBytes());
+        } else {
+          event.setOldValue(getOldValueBytes());
+        }
-    }
+
+      if (this.applyDeltaBytes) {
+        event.setNewValue(this.valObj);
+        event.setDeltaBytes(this.deltaBytes);
+      } else {
+        switch (this.deserializationPolicy) {
+          case DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY:
+            event.setSerializedNewValue(getValBytes());
+            break;
+          case DistributedCacheOperation.DESERIALIZATION_POLICY_NONE:
+            event.setNewValue(getValBytes());
+            break;
+          default:
+            throw new AssertionError("unknown deserialization policy: " + deserializationPolicy);
+        }
+      }
-//        event.setOriginRemote(true);
-//        this.op = r.doCacheWriteBeforePut(event, ifNew);  // TODO fix this for bug 37072
-        result = r.getDataView().putEntry(event, this.ifNew, this.ifOld, this.expectedOldValue,this.requireOldValue,this.lastModified, true);
+        // event.setOriginRemote(true);
+        // this.op = r.doCacheWriteBeforePut(event, ifNew); // TODO fix this for bug 37072
+        result = r.getDataView().putEntry(event, this.ifNew, this.ifOld, this.expectedOldValue,
+            this.requireOldValue, this.lastModified, true);
-                LocalizedStrings.RemotePutMessage_UNABLE_TO_PERFORM_PUT_BUT_OPERATION_SHOULD_NOT_FAIL_0.toLocalizedString());
+                LocalizedStrings.RemotePutMessage_UNABLE_TO_PERFORM_PUT_BUT_OPERATION_SHOULD_NOT_FAIL_0
+                    .toLocalizedString());
-            sendReply(getSender(), getProcessorId(), dm,
-                new ReplyException(fre), r, startTime);
+            sendReply(getSender(), getProcessorId(), dm, new ReplyException(fre), r, startTime);
-      }
-      catch (CacheWriterException cwe) {
+      } catch (CacheWriterException cwe) {
-      }
-      catch (PrimaryBucketException pbe) {
+      } catch (PrimaryBucketException pbe) {
-    setOperation(event.getOperation()); // set operation for reply message
+      setOperation(event.getOperation()); // set operation for reply message
-    if (sendReply) {
-      sendReply(getSender(),
-                getProcessorId(),
-                dm,
-                null,
-                r,
-                startTime,
-                event);
-    }
-    return false;
+      if (sendReply) {
+        sendReply(getSender(), getProcessorId(), dm, null, r, startTime, event);
+      }
+      return false;
-  protected void sendReply(InternalDistributedMember member,
-                           int procId,
-                           DM dm,
-                           ReplyException ex,
-                           LocalRegion pr,
-                           long startTime,
-                           EntryEventImpl event) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      LocalRegion pr, long startTime, EntryEventImpl event) {
-    PutReplyMessage.send(member, procId, getReplySender(dm), result,
-        getOperation(), ex, this, event);
+    PutReplyMessage.send(member, procId, getReplySender(dm), result, getOperation(), ex, this,
+        event);
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm,
-      ReplyException ex, LocalRegion pr, long startTime) {
-    PutReplyMessage.send(member, procId, getReplySender(dm), result,
-        getOperation(), ex, this, null);
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      LocalRegion pr, long startTime) {
+    PutReplyMessage.send(member, procId, getReplySender(dm), result, getOperation(), ex, this,
+        null);
-  protected final void appendFields(StringBuffer buff)
-  {
+  protected final void appendFields(StringBuffer buff) {
-    buff.append("; key=").append(getKey())
-        .append("; value=");
-//    buff.append(getValBytes());
+    buff.append("; key=").append(getKey()).append("; value=");
+    // buff.append(getValBytes());
-    buff.append("; callback=").append(this.cbArg)
-        .append("; op=").append(this.op);
+    buff.append("; callback=").append(this.cbArg).append("; op=").append(this.op);
-    buff.append("; ifOld=")
-        .append(this.ifOld)
-        .append("; ifNew=")
-        .append(this.ifNew)
-        .append("; op=")
+    buff.append("; ifOld=").append(this.ifOld).append("; ifNew=").append(this.ifNew).append("; op=")
-    if(this.hasOldValue){
+    if (this.hasOldValue) {
-    buff.append(DistributedCacheOperation.deserializationPolicyToString(this.deserializationPolicy));
+    buff.append(
+        DistributedCacheOperation.deserializationPolicyToString(this.deserializationPolicy));
-  public final InternalDistributedSystem getInternalDs()
-  {
+  public final InternalDistributedSystem getInternalDs() {
-  public final void setInternalDs(InternalDistributedSystem internalDs)
-  {
+  public final void setInternalDs(InternalDistributedSystem internalDs) {
-    
+
-     * Set to true by the import methods if the oldValue
-     * is already serialized. In that case toData
-     * should just copy the bytes to the stream.
-     * In either case fromData just calls readObject.
+     * Set to true by the import methods if the oldValue is already serialized. In that case toData
+     * should just copy the bytes to the stream. In either case fromData just calls readObject.
-    
+
-     * Old value in serialized form: either a byte[] or CachedDeserializable,
-     * or null if not set.
+     * Old value in serialized form: either a byte[] or CachedDeserializable, or null if not set.
-    
+
-    public PutReplyMessage() {
-    }
+    public PutReplyMessage() {}
-    PutReplyMessage(int processorId,
-                            boolean result,
-                            Operation op,
-                            ReplyException ex,
-                            Object oldValue,
-                            VersionTag versionTag)  {
+    PutReplyMessage(int processorId, boolean result, Operation op, ReplyException ex,
+        Object oldValue, VersionTag versionTag) {
-    public static void send(InternalDistributedMember recipient,
-                            int processorId,
-                            ReplySender dm,
-                            boolean result,
-                            Operation op,
-                            ReplyException ex,
-                            RemotePutMessage sourceMessage,
-                            EntryEventImpl event) {
+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,
+        boolean result, Operation op, ReplyException ex, RemotePutMessage sourceMessage,
+        EntryEventImpl event) {
-      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, null, event != null ? event.getVersionTag() : null);
-      
+      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, null,
+          event != null ? event.getVersionTag() : null);
+
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        RemotePutResponse processor = (RemotePutResponse)rp;
+        RemotePutResponse processor = (RemotePutResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    /** Return oldValue as a byte[] or as a CachedDeserializable.
-     * This method used to deserialize a CachedDeserializable but that is too soon.
-     * This method is called during message processing. The deserialization needs
-     * to be deferred until we get back to the application thread which happens
-     * for this oldValue when they call EntryEventImpl.getOldValue.
+    /**
+     * Return oldValue as a byte[] or as a CachedDeserializable. This method used to deserialize a
+     * CachedDeserializable but that is too soon. This method is called during message processing.
+     * The deserialization needs to be deferred until we get back to the application thread which
+     * happens for this oldValue when they call EntryEventImpl.getOldValue.
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      byte flags = (byte)(in.readByte() & 0xff);
+      byte flags = (byte) (in.readByte() & 0xff);
-    public static void oldValueToData(DataOutput out, Object ov, boolean ovIsSerialized) throws IOException {
+    public static void oldValueToData(DataOutput out, Object ov, boolean ovIsSerialized)
+        throws IOException {
-      
+
-    
-     @Override
+
+    @Override
-      if (this.result) flags |= FLAG_RESULT;
-      if (this.versionTag != null) flags |= FLAG_HASVERSION;
-      if (this.versionTag instanceof DiskVersionTag) flags |= FLAG_PERSISTENT;
+      if (this.result)
+        flags |= FLAG_RESULT;
+      if (this.versionTag != null)
+        flags |= FLAG_HASVERSION;
+      if (this.versionTag instanceof DiskVersionTag)
+        flags |= FLAG_PERSISTENT;
-      sb.append("PutReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" returning ").append(this.result)
-      .append(" op=").append(op)
-      .append(" exception=").append(getException());
+      sb.append("PutReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" returning ").append(this.result).append(" op=").append(op).append(" exception=")
+          .append(getException());
-    
+
-    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov,
+        boolean isSerialized) {
+   * 
-  public static class RemotePutResponse extends RemoteOperationResponse  {
+  public static class RemotePutResponse extends RemoteOperationResponse {
-    public RemotePutResponse(InternalDistributedSystem ds, Collection recipients,
-        Object key, boolean register) {
+    public RemotePutResponse(InternalDistributedSystem ds, Collection recipients, Object key,
+        boolean register) {
-    
+
-    public PutResult waitForResult() throws CacheException,
-        RemoteOperationException {
+    public PutResult waitForResult() throws CacheException, RemoteOperationException {
-      }
-      catch (RemoteOperationException e) {
+      } catch (RemoteOperationException e) {
-        throw new RemoteOperationException(LocalizedStrings.RemotePutMessage_DID_NOT_RECEIVE_A_VALID_REPLY.toLocalizedString());
+        throw new RemoteOperationException(
+            LocalizedStrings.RemotePutMessage_DID_NOT_RECEIVE_A_VALID_REPLY.toLocalizedString());
-          return new PutResult(this.returnValue,
-                               this.op,
-                               this.oldValue, this.versionTag);
+      return new PutResult(this.returnValue, this.op, this.oldValue, this.versionTag);
-  public static class PutResult  {
+  public static class PutResult {
-    
+
-    public PutResult(boolean flag, Operation actualOperation, Object oldValue, VersionTag versionTag) {
+    public PutResult(boolean flag, Operation actualOperation, Object oldValue,
+        VersionTag versionTag) {
-  
+
-      this.oldValueIsSerialized = true; //VALUE_IS_SERIALIZED_OBJECT;
+      this.oldValueIsSerialized = true; // VALUE_IS_SERIALIZED_OBJECT;
-      this.oldValueIsSerialized = false; //VALUE_IS_BYTES;
+      this.oldValueIsSerialized = false; // VALUE_IS_BYTES;
-  
+

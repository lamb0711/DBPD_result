GEODE-5568: Rewrite QueryMonitor to use ScheduledThreadPoolExecutor (#2744)

* GEODE-5568: Rewrite QueryMonitor to use ScheduledThreadPoolExecutor

Eliminate notify/wait bugs and improve hot-path performance.

Co-authored-by: Bill Burcham <bburcham@pivotal.io>
Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
+import java.util.Optional;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+  private Optional<ScheduledFuture> expirationTask;
+
-  private volatile boolean isCanceled = false;
-
-  private CacheRuntimeException canceledException;
-
-  /**
-   * This is declared as array so that it can be synchronized between two threads to validate the
-   * state.
-   */
-  private final boolean[] queryCompletedForMonitoring = new boolean[] {false};
+  private volatile CacheRuntimeException queryCancelledException;
+  static final ThreadLocal<AtomicBoolean> queryCanceled =
+      ThreadLocal.withInitial(AtomicBoolean::new);
+
+  public Optional<ScheduledFuture> getCancelationTask() {
+    return expirationTask;
+  }
+
+  public void setCancelationTask(final ScheduledFuture expirationTask) {
+    this.expirationTask = Optional.of(expirationTask);
+  }
+    this.expirationTask = Optional.empty();
-        queryMonitor.monitorQueryThread(Thread.currentThread(), this);
+        queryMonitor.monitorQueryThread(this);
-      // query execution canceled exception will be thrown from the QueryMonitor
-      // canceled exception should not be null at this point as it should be set
-      // when query is canceled.
-      if (this.canceledException != null) {
-        throw this.canceledException;
-      } else {
-        throw new QueryExecutionCanceledException(
-            "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-      }
+      return reinterpretQueryExecutionCanceledException();
-        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(this);
+   * This method attempts to reintrepret a {@link QueryExecutionCanceledException} using the
+   * the value returned by {@link #getQueryCanceledException} (set by the {@link QueryMonitor}).
+   *
+   * @throws if {@link #getQueryCanceledException} doesn't return {@code null} then throw that
+   *         {@link CacheRuntimeException}, otherwise throw {@link QueryExecutionCanceledException}
+   */
+  private Object reinterpretQueryExecutionCanceledException() {
+    final CacheRuntimeException queryCanceledException = getQueryCanceledException();
+    if (queryCanceledException != null) {
+      throw queryCanceledException;
+    } else {
+      throw new QueryExecutionCanceledException(
+          "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
+    }
+  }
+
+  /**
-      queryMonitor.monitorQueryThread(Thread.currentThread(), this);
+      queryMonitor.monitorQueryThread(this);
-        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(this);
-        // query execution canceled exception will be thrown from the QueryMonitor
-        // canceled exception should not be null at this point as it should be set
-        // when query is canceled.
-        if (this.canceledException != null) {
-          throw this.canceledException;
-        } else {
-          throw new QueryExecutionCanceledException(
-              "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-        }
+        reinterpretQueryExecutionCanceledException();
+      queryCanceled.remove();
-    return this.isCanceled;
+    return getQueryCanceledException() != null;
-    return this.canceledException;
-  }
-
-  boolean[] getQueryCompletedForMonitoring() {
-    return this.queryCompletedForMonitoring;
-  }
-
-  // TODO: parameter value is always true
-  void setQueryCompletedForMonitoring(boolean value) {
-    this.queryCompletedForMonitoring[0] = value;
+    return queryCancelledException;
-  public void setCanceled(CacheRuntimeException canceledException) {
-    this.isCanceled = true;
-    this.canceledException = canceledException;
+  public void setQueryCanceledException(final CacheRuntimeException queryCanceledException) {
+    this.queryCancelledException = queryCanceledException;
-    sb.append(this.isCanceled);
+    sb.append(this.isCanceled());

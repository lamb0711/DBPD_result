GEODE-4131: Do not reference deployed jars as byte arrays anymore (#1212)

* GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.
- Whenever an upload happens (either deploying jars or importing cluster
  config) we stage the files initially and then proceed with the command.
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.OutputStream;
+import java.nio.file.Files;
+import org.apache.geode.annotations.TestingOnly;
-  public DeployedJar deployWithoutRegistering(final String jarName, final byte[] jarBytes)
+  public DeployedJar deployWithoutRegistering(final String jarName, final File stagedJar)
-      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, jarBytes);
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, stagedJar);
-      writeJarBytesToFile(newVersionedJarFile, jarBytes);
+      Files.copy(stagedJar.toPath(), newVersionedJarFile.toPath());
-      return new DeployedJar(newVersionedJarFile, jarName, jarBytes);
+      return new DeployedJar(newVersionedJarFile, jarName);
-   * Attempt to write the given bytes to the given file. If this VM is able to successfully write
-   * the contents to the file, or another VM writes the exact same contents, then the write is
-   * considered to be successful.
-   *
-   * @param file File of the JAR file to deploy.
-   * @param jarBytes Contents of the JAR file to deploy.
-   * @return True if the file was successfully written, false otherwise
-   */
-  private boolean writeJarBytesToFile(final File file, final byte[] jarBytes) throws IOException {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    if (file.createNewFile()) {
-      if (isDebugEnabled) {
-        logger.debug("Successfully created new JAR file: {}", file.getAbsolutePath());
-      }
-      final OutputStream outStream = new FileOutputStream(file);
-      outStream.write(jarBytes);
-      outStream.close();
-      return true;
-    }
-    return doesFileMatchBytes(file, jarBytes);
-  }
-
-  /**
-   * Determine if the contents of the file referenced is an exact match for the bytes provided. The
-   * method first checks to see if the file is actively being written by checking the length over
-   * time. If it appears that the file is actively being written, then it loops waiting for that to
-   * complete before doing the comparison.
-   *
-   * @param file File to compare
-   * @param bytes Bytes to compare
-   * @return True if there's an exact match, false otherwise
-   * @throws IOException If there's a problem reading the file
-   */
-  private boolean doesFileMatchBytes(final File file, final byte[] bytes) throws IOException {
-    // First check to see if the file is actively being written (if it's not big enough)
-    final String absolutePath = file.getAbsolutePath();
-    boolean keepTrying = true;
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    while (file.length() < bytes.length && keepTrying) {
-      if (isDebugEnabled) {
-        logger.debug("Loop waiting for another to write file: {}", absolutePath);
-      }
-      long startingFileLength = file.length();
-      try {
-        Thread.sleep(500);
-      } catch (InterruptedException iex) {
-        // Just keep looping
-      }
-      if (startingFileLength == file.length()) {
-        if (isDebugEnabled) {
-          logger.debug("Done waiting for another to write file: {}", absolutePath);
-        }
-        // Assume the other process has finished writing
-        keepTrying = false;
-      }
-    }
-
-    // If they don't have the same number of bytes then nothing to do
-    if (file.length() != bytes.length) {
-      if (isDebugEnabled) {
-        logger.debug("Unmatching file length when waiting for another to write file: {}",
-            absolutePath);
-      }
-      return false;
-    }
-
-    // Open the file then loop comparing each byte
-    BufferedInputStream inStream = new BufferedInputStream(new FileInputStream(file));
-    int index = 0;
-    try {
-      for (; index < bytes.length; index++) {
-        if (((byte) inStream.read()) != bytes[index]) {
-          if (isDebugEnabled) {
-            logger.debug("Did not find a match when waiting for another to write file: {}",
-                absolutePath);
-          }
-          return false;
-        }
-      }
-    } finally {
-      inStream.close();
-    }
-
-    return true;
-  }
-
-  /**
-    Optional<File> latestValidDeployedJarOptional =
-        Arrays.stream(jarFiles).filter(Objects::nonNull).filter(jarFile -> {
-          try {
-            return DeployedJar.hasValidJarContent(FileUtils.readFileToByteArray(jarFile));
-          } catch (IOException e) {
-            return false;
-          }
-        }).findFirst();
+    Optional<File> latestValidDeployedJarOptional = Arrays.stream(jarFiles).filter(Objects::nonNull)
+        .filter(jarFile -> DeployedJar.hasValidJarContent(jarFile)).findFirst();
-   * @param jarNames Array of names of the JAR files to deploy.
-   * @param jarBytes Array of contents of the JAR files to deploy.
+   * @param stagedJarFiles A map of Files which have been staged in another location and are ready
+   *        to be deployed as a unit.
-  public List<DeployedJar> deploy(final String jarNames[], final byte[][] jarBytes)
+  public List<DeployedJar> deploy(final Map<String, File> stagedJarFiles)
-    DeployedJar[] deployedJars = new DeployedJar[jarNames.length];
+    List<DeployedJar> deployedJars = new ArrayList<>(stagedJarFiles.size());
-    for (int i = 0; i < jarNames.length; i++) {
-      if (!DeployedJar.hasValidJarContent(jarBytes[i])) {
+    for (File jar : stagedJarFiles.values()) {
+      if (!DeployedJar.hasValidJarContent(jar)) {
-            "File does not contain valid JAR content: " + jarNames[i]);
+            "File does not contain valid JAR content: " + jar.getName());
-      for (int i = 0; i < jarNames.length; i++) {
-        String jarName = jarNames[i];
-        byte[] newJarBytes = jarBytes[i];
-
-        deployedJars[i] = deployWithoutRegistering(jarName, newJarBytes);
+      for (String fileName : stagedJarFiles.keySet()) {
+        deployedJars.add(deployWithoutRegistering(fileName, stagedJarFiles.get(fileName)));
-      return registerNewVersions(Arrays.asList(deployedJars));
+      return registerNewVersions(deployedJars);
-  private boolean shouldDeployNewVersion(String jarName, byte[] newJarBytes) throws IOException {
+  private boolean shouldDeployNewVersion(String jarName, File stagedJar) throws IOException {
-    if (oldDeployedJar.hasSameContentAs(newJarBytes)) {
+    if (oldDeployedJar.hasSameContentAs(stagedJar)) {
-  public DeployedJar findDeployedJar(String jarName) {
+  public DeployedJar getDeployedJar(String jarName) {
-  public DeployedJar deploy(final String jarName, final byte[] jarBytes)
+  @TestingOnly
+  public DeployedJar deploy(final String jarName, final File stagedJarFile)
+    Map<String, File> jarFiles = new HashMap<>();
+    jarFiles.put(jarName, stagedJarFile);
+
-      List<DeployedJar> deployedJars = deploy(new String[] {jarName}, new byte[][] {jarBytes});
+      List<DeployedJar> deployedJars = deploy(jarFiles);

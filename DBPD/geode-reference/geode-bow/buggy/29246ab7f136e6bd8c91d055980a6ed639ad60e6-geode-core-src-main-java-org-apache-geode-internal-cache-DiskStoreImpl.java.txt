GEODE-2457: Replace org.apache.geode.internal.FileUtil with org.apache.commons.io.FileUtils

+import static org.apache.geode.distributed.ConfigurationProperties.CACHE_XML_FILE;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import org.apache.commons.io.FileUtils;
-import org.apache.geode.cache.*;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheClosedException;
+import org.apache.geode.cache.DiskAccessException;
+import org.apache.geode.cache.DiskStore;
+import org.apache.geode.cache.DiskStoreFactory;
+import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.internal.FileUtil;
-import org.apache.geode.internal.cache.persistence.*;
+import org.apache.geode.internal.cache.persistence.BackupInspector;
+import org.apache.geode.internal.cache.persistence.BackupManager;
+import org.apache.geode.internal.cache.persistence.BytesAndBits;
+import org.apache.geode.internal.cache.persistence.DiskRecoveryStore;
+import org.apache.geode.internal.cache.persistence.DiskRegionView;
+import org.apache.geode.internal.cache.persistence.DiskStoreFilter;
+import org.apache.geode.internal.cache.persistence.DiskStoreID;
+import org.apache.geode.internal.cache.persistence.OplogType;
+import org.apache.geode.internal.cache.persistence.PRPersistentConfig;
+import org.apache.geode.internal.cache.persistence.PersistentMemberID;
+import org.apache.geode.internal.cache.persistence.PersistentMemberPattern;
+import org.apache.geode.internal.cache.persistence.RestoreScript;
-import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import java.io.*;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.io.PrintStream;
-import java.util.*;
-import java.util.concurrent.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
-import static org.apache.geode.distributed.ConfigurationProperties.*;
-
-  public static final int MAX_OPEN_INACTIVE_OPLOGS = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_OPEN_INACTIVE_OPLOGS", 7).intValue();
+  public static final int MAX_OPEN_INACTIVE_OPLOGS =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_OPEN_INACTIVE_OPLOGS", 7);
-  public static final int MIN_DISK_SPACE_FOR_LOGS = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MIN_DISK_SPACE_FOR_LOGS", 20).intValue();
+  public static final int MIN_DISK_SPACE_FOR_LOGS =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "MIN_DISK_SPACE_FOR_LOGS", 20);
-  private final int MAX_OPLOGS_PER_COMPACTION = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_OPLOGS_PER_COMPACTION", Integer
-          .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_OPLOGS_PER_ROLL", 1).intValue())
-      .intValue();
+  private final int MAX_OPLOGS_PER_COMPACTION = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "MAX_OPLOGS_PER_COMPACTION",
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_OPLOGS_PER_ROLL", 1).intValue());
-  public static final int MAX_CONCURRENT_COMPACTIONS = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_CONCURRENT_COMPACTIONS", Integer
-          .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_CONCURRENT_ROLLS", 1).intValue())
-      .intValue();
+  public static final int MAX_CONCURRENT_COMPACTIONS = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "MAX_CONCURRENT_COMPACTIONS",
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAX_CONCURRENT_ROLLS", 1).intValue());
-    final String thName = LocalizedStrings.DiskRegion_ASYNCHRONOUS_DISK_WRITER_0
-        .toLocalizedString(new Object[] {getName()});
+    final String thName =
+        LocalizedStrings.DiskRegion_ASYNCHRONOUS_DISK_WRITER_0.toLocalizedString(getName());
-      } catch (IOException ex) {
+      } catch (IOException | IllegalStateException ex) {
-      } catch (IllegalStateException ex2) {
-        // OverlappingFileLockExtension needs to be caught here see bug 41290
-        if (fs != null) {
-          try {
-            fs.close();
-          } catch (IOException ignore) {
-          }
-        }
-        dae = new DiskAccessException(
-            LocalizedStrings.Oplog_COULD_NOT_LOCK_0.toLocalizedString(f.getPath()), ex2, this);
-        for (DirectoryHolder dh : this.directories) {
-          File dir = dh.getDir();
-          // delete all overflow files
-          File[] files = FileUtil.listFiles(dir, overflowFileFilter);
-          for (File file : files) {
-            boolean deleted = file.delete();
-            if (!deleted && file.exists() && logger.isDebugEnabled()) {
-              logger.debug("Could not delete file {}", file);
-            }
-          }
-        }
+        deleteFiles(overflowFileFilter);
-      for (int i = 0; i < this.directories.length; i++) {
-        this.directories[i].close();
+      for (final DirectoryHolder directory : this.directories) {
+        directory.close();
-      Iterator<Object> it = this.asyncQueue.iterator();
-      while (it.hasNext()) {
-        Object o = it.next();
+      for (final Object o : this.asyncQueue) {
-    int v = this.backgroundTasks.incrementAndGet();
-    return v;
+    return this.backgroundTasks.incrementAndGet();
-    for (int i = 0; i < this.directories.length; i++) {
-      File dir = this.directories[i].getDir();
-      File[] files = FileUtil.listFiles(dir, overflowFileFilter);
-      for (File file : files) {
-        boolean deleted = file.delete();
-        if (!deleted && file.exists() && logger.isDebugEnabled()) {
-          logger.debug("Could not delete file {}", file);
+    for (final DirectoryHolder directory : this.directories) {
+      File[] files = directory.getDir().listFiles(overflowFileFilter);
+      if (files != null) {
+        for (File file : files) {
+          boolean deleted = file.delete();
+          if (!deleted && file.exists() && logger.isDebugEnabled()) {
+            logger.debug("Could not delete file {}", file);
+          }
-    List<File> baselineOplogFiles = FileUtil.findAll(baselineDir, ".*\\.[kdc]rf$");
-
+    Collection<File> baselineOplogFiles =
+        FileUtils.listFiles(baselineDir, new String[] {"krf", "drf", "crf"}, true);
-      if (!this.scheduled) {
-        return schedule(opLogs);
-      } else {
-        return false;
-      }
+      return !this.scheduled && schedule(opLogs);
-        for (int i = 0; i < opLogs.length; i++) {
-          opLogs[i].prepareForCompact();
+        for (final CompactableOplog opLog : opLogs) {
+          opLog.prepareForCompact();
-      if (stopper.isCancelInProgress()) {
-        return true;
-      }
-      return false;
+      return stopper.isCancelInProgress();
-          StringBuffer buffer = new StringBuffer();
+          StringBuilder buffer = new StringBuilder();
-    PersistentMemberID id = new PersistentMemberID(getDiskStoreID(), memberId.getInetAddress(),
+    return new PersistentMemberID(getDiskStoreID(), memberId.getInetAddress(),
-    return id;
-      sb.append(" versionOnly=" + this.versionOnly);
+      sb.append(" versionOnly=").append(this.versionOnly);
-        sb.append(" versionTag=" + this.tag);
+        sb.append(" versionTag=").append(this.tag);
-        sb.append(" key=" + de.getKey());
+        sb.append(" key=").append(de.getKey());
-      Collections.sort(types, new Comparator<PdxType>() {
-        @Override
-        public int compare(PdxType o1, PdxType o2) {
-          return o1.getClassName().compareTo(o2.getClassName());
-        }
-      });
-      Collections.sort(enums, new Comparator<EnumInfo>() {
-        @Override
-        public int compare(EnumInfo o1, EnumInfo o2) {
-          return o1.compareTo(o2);
-        }
-      });
+      types.sort(Comparator.comparing(PdxType::getClassName));
+      enums.sort(EnumInfo::compareTo);
-        Object childLock = childOplog == null ? new Object() : childOplog.lock;;
+        Object childLock = childOplog.lock;;
-            if (!FileUtil.mkdirs(dir)) {
+            if (!dir.mkdirs()) {
-      if (listPdxTypes != null && listPdxTypes.booleanValue()) {
+      if (listPdxTypes != null && listPdxTypes) {
-      result = tmp.booleanValue();
+      result = tmp;

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class PrimaryKeyIndex extends AbstractIndex  {
+public class PrimaryKeyIndex extends AbstractIndex {
- 
-  public PrimaryKeyIndex(String indexName, Region region,String fromClause,
-      String indexedExpression,  String projectionAttributes,
-      String origFromClause, String origIndxExpr, String[] defintions, IndexStatistics indexStatistics) {
-    super(indexName, region, fromClause, indexedExpression,
-        projectionAttributes, origFromClause, origIndxExpr, defintions, indexStatistics);
-    //TODO : Asif Check if the below is correct
+
+  public PrimaryKeyIndex(String indexName, Region region, String fromClause,
+      String indexedExpression, String projectionAttributes, String origFromClause,
+      String origIndxExpr, String[] defintions, IndexStatistics indexStatistics) {
+    super(indexName, region, fromClause, indexedExpression, projectionAttributes, origFromClause,
+        origIndxExpr, defintions, indexStatistics);
+    // TODO : Asif Check if the below is correct
-    if (constr == null) constr = Object.class;
+    if (constr == null)
+      constr = Object.class;
-  
+
-  
-  public ObjectType getResultSetType()  {
+
+  public ObjectType getResultSetType() {
-  void removeMapping(RegionEntry entry, int opCode) {
-  }
+  void removeMapping(RegionEntry entry, int opCode) {}
-  void addMapping(RegionEntry entry) throws IMQException {
-  }
-  
+  void addMapping(RegionEntry entry) throws IMQException {}
+
-  void instantiateEvaluator(IndexCreationHelper ich) {    
-  }
- 
+  void instantiateEvaluator(IndexCreationHelper ich) {}
+
-  void lockedQuery(Object key, int operator, Collection results, Set keysToRemove, ExecutionContext context)
-      throws TypeMismatchException {
+  void lockedQuery(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException {
-    //System.out.println("PrimaryKeyIndex.lockedQuery");
-    //System.out.println(" key="+key);
-    //System.out.println(" key.class="+(key != null ? key.getClass().getName()
+    // System.out.println("PrimaryKeyIndex.lockedQuery");
+    // System.out.println(" key="+key);
+    // System.out.println(" key.class="+(key != null ? key.getClass().getName()
-    //    if(key == null){
-    //      numUses++;
-    //      return;
-    //    }
-    //key = TypeUtils.indexKeyFor(key);
+    // if(key == null){
+    // numUses++;
+    // return;
+    // }
+    // key = TypeUtils.indexKeyFor(key);
-    
-    //Key cannot be PdxString in a region
-    if(key instanceof PdxString){
+
+    // Key cannot be PdxString in a region
+    if (key instanceof PdxString) {
-    Boolean applyLimit = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX); 
-    if(applyLimit != null && applyLimit.booleanValue()) {
-      limit = ((Integer)context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    Boolean applyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+    if (applyLimit != null && applyLimit.booleanValue()) {
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
-    if (limit != -1 &&  results.size() == limit) {
-      observer.limitAppliedAtIndexLevel(this, limit,results);
+    if (limit != -1 && results.size() == limit) {
+      observer.limitAppliedAtIndexLevel(this, limit, results);
-          Region.Entry entry = ((LocalRegion)getRegion()).accessEntry(key, false);
+          Region.Entry entry = ((LocalRegion) getRegion()).accessEntry(key, false);
-        //Add data one more than the limit
-        if(limit != -1) {
+        // Add data one more than the limit
+        if (limit != -1) {
-          if (limit != -1 &&  results.size() == limit) {
-            observer.limitAppliedAtIndexLevel(this, limit,results);
+          if (limit != -1 && results.size() == limit) {
+            observer.limitAppliedAtIndexLevel(this, limit, results);
-          Region.Entry entry = ((LocalRegion)getRegion()).accessEntry(key, false);
+          Region.Entry entry = ((LocalRegion) getRegion()).accessEntry(key, false);
-        if(removeOneRow) {
+        if (removeOneRow) {
-          if(itr.hasNext()) {
+          if (itr.hasNext()) {
-        throw new IllegalArgumentException(LocalizedStrings.PrimaryKeyIndex_INVALID_OPERATOR.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.PrimaryKeyIndex_INVALID_OPERATOR.toLocalizedString());
-  void lockedQuery(Object key,
-                   int operator,
-                   Collection results,
-                   CompiledValue iterOps,
-                   RuntimeIterator runtimeItr,
-                   ExecutionContext context,
-                   List  projAttrib, SelectResults intermediateResults, boolean isIntersection)
-  throws TypeMismatchException,
-         FunctionDomainException,
-         NameResolutionException,
-         QueryInvocationTargetException
-  {
-   
+  void lockedQuery(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+
-    int limit = -1;    
-    
-   Boolean applyLimit = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
-    
-    if(applyLimit != null && applyLimit.booleanValue()) {
-      limit = ((Integer)context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    int limit = -1;
+
+    Boolean applyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+
+    if (applyLimit != null && applyLimit.booleanValue()) {
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
-    if(limit != -1 && results.size()== limit) {
-      observer.limitAppliedAtIndexLevel(this, limit,results);
+    if (limit != -1 && results.size() == limit) {
+      observer.limitAppliedAtIndexLevel(this, limit, results);
-    //Key cannot be PdxString in a region
-    if(key instanceof PdxString){
+    // Key cannot be PdxString in a region
+    if (key instanceof PdxString) {
-    case OQLLexerTokenTypes.TOK_EQ: {
-      if (key != null && key != QueryService.UNDEFINED) {
-        Region.Entry entry = ((LocalRegion)getRegion()).accessEntry(key, false);
-        if (entry != null) {
-          Object value = entry.getValue();
-          if (value != null) {
+      case OQLLexerTokenTypes.TOK_EQ: {
+        if (key != null && key != QueryService.UNDEFINED) {
+          Region.Entry entry = ((LocalRegion) getRegion()).accessEntry(key, false);
+          if (entry != null) {
+            Object value = entry.getValue();
+            if (value != null) {
+              boolean ok = true;
+              if (runtimeItr != null) {
+                runtimeItr.setCurrent(value);
+                ok = QueryUtils.applyCondition(iterOps, context);
+              }
+              if (ok) {
+                applyProjection(projAttrib, context, results, value, intermediateResults,
+                    isIntersection);
+              }
+            }
+          }
+        }
+        break;
+      }
+
+      case OQLLexerTokenTypes.TOK_NE_ALT:
+      case OQLLexerTokenTypes.TOK_NE: { // add all btree values
+        Set entries = (Set) getRegion().entrySet();
+        Iterator itr = entries.iterator();
+        while (itr.hasNext()) {
+          Map.Entry entry = (Map.Entry) itr.next();
+
+          if (key != null && key != QueryService.UNDEFINED && key.equals(entry.getKey())) {
+            continue;
+          }
+          Object val = entry.getValue();
+          // TODO:Asif: is this correct. What should be the behaviour of null
+          // values?
+          if (val != null) {
-              runtimeItr.setCurrent(value);
+              runtimeItr.setCurrent(val);
-              applyProjection(projAttrib, context, results,value,intermediateResults,isIntersection);
+              applyProjection(projAttrib, context, results, val, intermediateResults,
+                  isIntersection);
+            }
+            if (limit != -1 && results.size() == limit) {
+              observer.limitAppliedAtIndexLevel(this, limit, results);
+              break;
+        // if (key != null && key != QueryService.UNDEFINED) {
+        // Region.Entry entry = getRegion().getEntry(key);
+        // if (entry != null) {
+        // Object val = entry.getValue();
+        // if (val != null) {
+        // boolean ok = true;
+        // if (runtimeItr != null) {
+        // runtimeItr.setCurrent(val);
+        // ok = QueryUtils.applyCondition(iterOps, context);
+        // }
+        // if (ok) {
+        // applyProjection(projAttrib, context, results,val,intermediateResults,isIntersection);
+        // }
+        // }
+        // }
+        // }
+        break;
-      break;
-    }
-   
-    case OQLLexerTokenTypes.TOK_NE_ALT:
-    case OQLLexerTokenTypes.TOK_NE: { // add all btree values
-      Set entries = (Set)getRegion().entrySet();
-      Iterator itr = entries.iterator();
-      while (itr.hasNext()) {       
-        Map.Entry entry = (Map.Entry)itr.next();
-            
-        if(key != null && key != QueryService.UNDEFINED && key.equals(entry.getKey())) {
-          continue;
-        }
-        Object val = entry.getValue();
-        // TODO:Asif: is this correct. What should be the behaviour of null
-        // values?
-        if (val != null) {
-          boolean ok = true;
-          if (runtimeItr != null) {
-            runtimeItr.setCurrent(val);
-            ok = QueryUtils.applyCondition(iterOps, context);
-          }
-          if (ok) {
-            applyProjection(projAttrib, context, results,val,intermediateResults,isIntersection);
-          }
-          if (limit != -1 && results.size() == limit){            
-             observer.limitAppliedAtIndexLevel(this, limit,results);            
-            break;
-          }
-        }
+      default: {
+        throw new IllegalArgumentException("Invalid Operator");
-//      if (key != null && key != QueryService.UNDEFINED) {
-//        Region.Entry entry = getRegion().getEntry(key);
-//        if (entry != null) {
-//          Object val = entry.getValue();
-//          if (val != null) {
-//            boolean ok = true;
-//            if (runtimeItr != null) {
-//              runtimeItr.setCurrent(val);
-//              ok = QueryUtils.applyCondition(iterOps, context);
-//            }
-//            if (ok) {
-//              applyProjection(projAttrib, context, results,val,intermediateResults,isIntersection);
-//            }
-//          }
-//        }
-//      }
-      break;
-    }
-    default: {
-      throw new IllegalArgumentException("Invalid Operator");
-    }
-    Support
-        .Assert(
-            false,
-            "PrimaryKeyIndex::recreateIndexData: This method should not have got invoked at all");
+    Support.Assert(false,
+        "PrimaryKeyIndex::recreateIndexData: This method should not have got invoked at all");
-  
+
-     * Returns the total number of times this index has been accessed by a
-     * query.
+     * Returns the total number of times this index has been accessed by a query.
-      if (getRegion().containsValueForKey(key)) return 1;
+      if (getRegion().containsValueForKey(key))
+        return 1;
-      sb.append("Total Update time = ").append(getTotalUpdateTime()).append(
-          "\n");
+      sb.append("Total Update time = ").append(getTotalUpdateTime()).append("\n");
-   *      int, java.lang.Object, int, java.util.Collection, java.util.Set)
+   * int, java.lang.Object, int, java.util.Collection, java.util.Set)
-  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator,
-      Object upperBoundKey, int upperBoundOperator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException {
+  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException {
-          .toLocalizedString());
+            .toLocalizedString());
-  }  
-  
+  }
+
-  void addMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException
-  {
+  void addMapping(Object key, Object value, RegionEntry entry) throws IMQException {
-    
-  }  
+
+  }
-  void saveMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException
-  {
+  void saveMapping(Object key, Object value, RegionEntry entry) throws IMQException {

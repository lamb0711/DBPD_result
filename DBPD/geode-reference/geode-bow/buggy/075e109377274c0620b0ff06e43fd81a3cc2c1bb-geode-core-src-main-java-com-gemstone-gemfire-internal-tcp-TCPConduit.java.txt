Caching the CLUSTER component SocketCreator in TCPConduit

This avoids fetching the SocketCreator each time it's going to be used.
TCPConduit holds onto it and it and Connection use the cached instance.

LocatorDUnitTest SSL tests were failing due to inadequate clean-up in
all of the DUnit JVMs.  Clean-up was only happening in the controller
JVM and in those that use the inherited distributed-system creation
methods.  LocatorDUnitTest can't use the inherited methods since they
force use of the DUnit Locator.  I've removed the FlakyTest designation
from the affected tests.

-  private volatile boolean inhibitNewConnections;
+  /**
+   * The socket producer used by the cluster
+   */
+  private final SocketCreator socketCreator;
-  //  private transient DistributedMembershipListener messageReceiver;
+    
+    this.socketCreator = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER);
-          socket = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER).createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, 0, tcpPortRange);
+          socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, 0, tcpPortRange);
-            socket = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER)
-                                         .createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, this.tcpBufferSize, tcpPortRange);
+            socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, this.tcpBufferSize, tcpPortRange);
-            socket = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER).createServerSocket(p, b, isBindAddress ? bindAddress : null, this.tcpBufferSize);
+            socket = socketCreator.createServerSocket(p, b, isBindAddress ? bindAddress : null, this.tcpBufferSize);
-          SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER).configureServerSSLSocket(othersock);
+          socketCreator.configureServerSSLSocket(othersock);
-        if (inhibitNewConnections) {
-          //          if (logger.isTraceEnabled(LogMarker.QA)) {
-          logger.info("Test hook: inhibiting acceptance of connection {}", othersock);
-          //          }
-          othersock.close();
-          while (inhibitNewConnections && !stopped) {
-            this.stopper.checkCancelInProgress(null);
-            boolean interrupted = Thread.interrupted();
-            try {
-              Thread.sleep(2000);
-            } catch (InterruptedException e) {
-              interrupted = true;
-            } finally {
-              if (interrupted) {
-                Thread.currentThread().interrupt();
-              }
-            }
-          } // while
-          if (logger.isTraceEnabled(LogMarker.QA)) {
-            logger.trace(LogMarker.QA, "Test hook: finished inhibiting acceptance of connections");
-          }
-        } else {
-          acceptConnection(othersock);
-        }
+
+        acceptConnection(othersock);
+        
+   * returns the SocketCreator that should be used to produce
+   * sockets for TCPConduit connections.
+   * @return
+   */
+  protected SocketCreator getSocketCreator() {
+    return socketCreator;
+  }
+  /**

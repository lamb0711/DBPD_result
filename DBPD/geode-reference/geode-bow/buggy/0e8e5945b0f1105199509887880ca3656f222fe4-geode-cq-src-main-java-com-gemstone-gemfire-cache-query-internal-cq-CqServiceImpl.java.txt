GEODE-1723 Merge from 82 for performance improvement.

Other improvement:We take lock on key while doing op on BucketRegion.
In that case we notify to other thread only when there is a thread
waiting for it. Modified one condition to log message to reduce garbage.

+import java.util.concurrent.ConcurrentHashMap;
+  private static final Integer MESSAGE_TYPE_LOCAL_CREATE = Integer.valueOf(MessageType.LOCAL_CREATE); 
+  private static final Integer MESSAGE_TYPE_LOCAL_UPDATE = Integer.valueOf(MessageType.LOCAL_UPDATE); 
+  private static final Integer MESSAGE_TYPE_LOCAL_DESTROY = Integer.valueOf(MessageType.LOCAL_DESTROY); 
+  private static final Integer MESSAGE_TYPE_EXCEPTION = Integer.valueOf(MessageType.EXCEPTION);
+  
-  private final HashMap<String, HashSet<String>> matchingCqMap;
+  private final ConcurrentHashMap matchingCqMap;
-    this.matchingCqMap = new HashMap<String, HashSet<String>>();
+    this.matchingCqMap = new ConcurrentHashMap<String, HashSet<String>>();
+  private static final ConcurrentHashMap<String, ConcurrentHashMap<ClientProxyMembershipID, String>> serverCqNameCache = new ConcurrentHashMap<>();
+
-  @Override
-    String cName = null;
-    if (clientProxyId.isDurable()) {
-      cName = cqName + "__" + clientProxyId.getDurableId();
+    ConcurrentHashMap<ClientProxyMembershipID, String> cache = serverCqNameCache.get(cqName);
+    if (null == cache) {
+      final ConcurrentHashMap<ClientProxyMembershipID, String> old = serverCqNameCache.putIfAbsent(cqName,
+          cache = new ConcurrentHashMap<ClientProxyMembershipID, String>());
+      if (null != old) {
+        cache = old;
+      }
-    else {
-      cName = cqName + "__" + clientProxyId.getDSMembership();
+
+    String cName = cache.get(clientProxyId);
+    if (null == cName) {
+      final StringBuilder sb = new StringBuilder(cqName).append("__");
+      if (clientProxyId.isDurable()) {
+        sb.append(clientProxyId.getDurableId());
+      } else {
+        sb.append(clientProxyId.getDSMembership());
+      }
+      cName = sb.toString();
+      cache.put(clientProxyId, cName);
+
-    
-          synchronized (cQuery) {
+          //synchronized (cQuery) 
+          {
-              // Apply query on new value.
-              if (!cqUnfilteredEventsSet_newValue.isEmpty()) {
-                executionStartTime = this.stats.startCqQueryExecution();
+              synchronized (cQuery) {
+                // Apply query on new value.
+                if (!cqUnfilteredEventsSet_newValue.isEmpty()) {
+                  executionStartTime = this.stats.startCqQueryExecution();
-                b_cqResults_newValue = evaluateQuery(cQuery, 
-                    new Object[] {cqUnfilteredEventsSet_newValue});
-                this.stats.endCqQueryExecution(executionStartTime);
+                  b_cqResults_newValue = evaluateQuery(cQuery, new Object[] { cqUnfilteredEventsSet_newValue });
+                  this.stats.endCqQueryExecution(executionStartTime);
+                }
-                  // Apply query on old value.
-                  if (!cqUnfilteredEventsSet_oldValue.isEmpty()) {
-                    executionStartTime = this.stats.startCqQueryExecution();
-                    b_cqResults_oldValue = evaluateQuery(cQuery, 
-                        new Object[] {cqUnfilteredEventsSet_oldValue});
-                    this.stats.endCqQueryExecution(executionStartTime);
-                  } else {
-                    if (isDebugEnabled) {
-                      logger.debug("old value for event with key {} is null - query execution not performed", eventKey);
+                  synchronized (cQuery) {
+                    // Apply query on old value.
+                    if (!cqUnfilteredEventsSet_oldValue.isEmpty()) {
+                      executionStartTime = this.stats.startCqQueryExecution();
+                      b_cqResults_oldValue = evaluateQuery(cQuery, new Object[] { cqUnfilteredEventsSet_oldValue });
+                      this.stats.endCqQueryExecution(executionStartTime);
+                    } else {
+                      if (isDebugEnabled) {
+                        logger.debug("old value for event with key {} is null - query execution not performed", eventKey);
+                      }
-              cqEvent = Integer.valueOf(MessageType.EXCEPTION); 
+              cqEvent = MESSAGE_TYPE_EXCEPTION; 
-                  cqEvent = Integer.valueOf(MessageType.LOCAL_UPDATE);
+                  cqEvent = MESSAGE_TYPE_LOCAL_UPDATE;
-                  cqEvent = Integer.valueOf(MessageType.LOCAL_CREATE);
+                  cqEvent = MESSAGE_TYPE_LOCAL_CREATE;
-                cqEvent = Integer.valueOf(MessageType.LOCAL_DESTROY);
+                cqEvent = MESSAGE_TYPE_LOCAL_DESTROY;
-          synchronized (this.matchingCqMap){
+          //synchronized (this.matchingCqMap){
-            HashSet matchingCqs = matchingCqMap.get(query);
+            Set matchingCqs = (Set)matchingCqMap.get(query);
-          }
+          //}
-      HashSet<String> matchingCQs = null;
+      Set<String> matchingCQs = null;
-        matchingCQs = new HashSet<String>();
+        matchingCQs = Collections.newSetFromMap(new ConcurrentHashMap());
-        matchingCQs = matchingCqMap.get(cqQuery);
+        matchingCQs = (Set)matchingCqMap.get(cqQuery);
-    	  HashSet matchingCQs = matchingCqMap.get(cqQuery);
+    	  Set matchingCQs = (Set)matchingCqMap.get(cqQuery);
-  public HashMap<String, HashSet<String>> getMatchingCqMap(){
+  public Map<String, HashSet<String>> getMatchingCqMap(){

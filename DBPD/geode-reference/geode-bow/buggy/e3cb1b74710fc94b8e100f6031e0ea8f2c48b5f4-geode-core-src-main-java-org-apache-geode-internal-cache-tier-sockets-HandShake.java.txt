GEODE-2257 Client configured to use locator with addPoolServer fails to connect

The first byte that a client sends is a connection-type that is >= 100.
The first bytes expected by a locator are the 4 bytes of an integer
indicating the protocol version.  I've changed the locator to read
the first byte and, if it's >= 100 send a reply byte back to the client
telling it that it's trying to contact a locator using a client/server
handshake.

The client has a new reply code that the locator is now using.  If the
client sees this reply code it will throw a GemFireConfigException.  Some
of these exceptions will be thrown in the background and get logged but
the thread initiating cache creation will also get this exception when
it invokes ClientCacheFactory.create().

The client-side error message will be in this form:
_Improperly configured client detected. Server at 10.154.30.28 is actually
a locator.  Use addPoolLocator to configure locators_.

The locator will also log a warning in this form so that alerts will be
raised:
_Unable to process request from 10.118.33.195 exception=Improperly
configured client detected - use addPoolLocator to configure its
locators instead of addPoolServer_.

+import org.apache.geode.GemFireConfigException;
+  public static final byte REPLY_SERVER_IS_LOCATOR = (byte) 67;
+
-  /** Singleton for client side */
-  // Client has no more a singleton handShake instance. Now each connection will
-  // have its own handShake instance.
-  private static HandShake handshake;
-
-  /** Constructor used by server side connection */
+  /**
+   * HandShake Constructor used by server side connection
+   */
-  // private void initSingleton(DistributedSystem sys) {
-  // id = ClientProxyMembershipID.getNewProxyMembership();
-  // this.system = sys;
-  // this.code = REPLY_OK;
-  // }
-
+  /**
+   * Client-side handshake. This form of HandShake can communicate with a server
+   */
+  /**
+   * Clone a HandShake to be used in creating other connections
+   */
-  /*
-   * private void read(DataInputStream dis,byte[] toFill) throws IOException { /* this.code = (byte)
-   * in.read(); if (this.code == -1) { throw new
-   * IOException(LocalizedStrings.HandShake_HANDSHAKE_READ_AT_END_OF_STREAM.toLocalizedString()); }
-   * if (this.code != REPLY_OK) { throw new
-   * IOException(LocalizedStrings.HandShake_HANDSHAKE_REPLY_CODE_IS_NOT_OK.toLocalizedString()); }
-   * try { ObjectInput in = new ObjectInputStream(is); this.id =
-   * ClientProxyMembershipID.readCanonicalized(in); } catch(IOException ioe) { this.code = -2; throw
-   * ioe; } catch(ClassNotFoundException cnfe) { this.code = -3; IOException e = new
-   * IOException(LocalizedStrings.HandShake_ERROR_DESERIALIZING_HANDSHAKE.toLocalizedString());
-   * e.initCause(cnfe); throw e; } } finally { synchronized (this) { this.isRead = true; } } }
-   */
-
-  public byte write(DataOutputStream dos, DataInputStream dis, byte communicationMode,
+  /**
+   * client-to-server handshake. Nothing is sent to the server prior to invoking this method.
+   */
+  private byte write(DataOutputStream dos, DataInputStream dis, byte communicationMode,
-   * 
-   * 
-   * @param dos
-   * @param dis
-   * @param p_credentials
-   * @param isNotification
-   * @param member
-   * @param heapdos stream to append data to.
-   * @throws IOException
-   * @throws GemFireSecurityException
-   * 
-   * @param dos
-   * @param dis
-   * @param authInit
-   * @param isNotification
-   * @param member
-   * @param heapdos
-   * @throws IOException
-   * @throws GemFireSecurityException
-  private DistributedMember getDistributedMember(Socket sock) {
+  private DistributedMember getIDForSocket(Socket sock) {
-  public ServerQueueStatus greet(Connection conn, ServerLocation location, byte communicationMode)
-      throws IOException, AuthenticationRequiredException, AuthenticationFailedException,
-      ServerRefusedConnectionException {
+  /**
+   * Client-side handshake with a Server
+   */
+  public ServerQueueStatus handshakeWithServer(Connection conn, ServerLocation location,
+      byte communicationMode) throws IOException, AuthenticationRequiredException,
+      AuthenticationFailedException, ServerRefusedConnectionException {
-      DistributedMember member = getDistributedMember(sock);
+      DistributedMember member = getIDForSocket(sock);
+      if (acceptanceCode == REPLY_SERVER_IS_LOCATOR) {
+        throw new GemFireConfigException("Improperly configured client detected.  " + "Server at "
+            + location + " is actually a locator.  Use addPoolLocator to configure locators.");
+      }
-  public ServerQueueStatus greetNotifier(Socket sock, boolean isPrimary)
+  /**
+   * Used by client-side CacheClientUpdater to handshake with a server in order to receive messages
+   * generated by subscriptions (register-interest, continuous query)
+   */
+  public ServerQueueStatus handshakeWithSubscriptionFeed(Socket sock, boolean isPrimary)
-      DistributedMember member = getDistributedMember(sock);
+      DistributedMember member = getIDForSocket(sock);
-    /*
-     * if (identity != null && identity.length > 0) { for (int i = 0; i < identity.length; i++) { if
-     * (this.identity[i] != that.identity[i]) return false; } } if (this.code != that.code) return
-     * false; return true;
-     */
-

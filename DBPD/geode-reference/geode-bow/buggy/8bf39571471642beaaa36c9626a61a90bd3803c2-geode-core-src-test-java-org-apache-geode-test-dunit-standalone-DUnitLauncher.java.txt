Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * For use within eclipse. This class completely skips hydra and just starts
- * some vms directly, creating a fake test configuration
+ * For use within eclipse. This class completely skips hydra and just starts some vms directly,
+ * creating a fake test configuration
- * Also, it's a good idea to set your working directory, because the test code
- * a lot of files that it leaves around.
+ * Also, it's a good idea to set your working directory, because the test code a lot of files that
+ * it leaves around.
-  
+
-  
+
-  public static final String RMI_PORT_PARAM = DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.RMI_PORT";
+  public static final String RMI_PORT_PARAM =
+      DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.RMI_PORT";
-  private static final String LAUNCHED_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.LAUNCHED";
+  private static final String LAUNCHED_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.LAUNCHED";
-  private DUnitLauncher() {
-  }
-  
+  private DUnitLauncher() {}
+
-      //TODO - this is hacky way to test for a hydra environment - see
-      //if there is registered test configuration object.
+      // TODO - this is hacky way to test for a hydra environment - see
+      // if there is registered test configuration object.
-   * Launch DUnit. If the unit test was launched through
-   * the hydra framework, leave the test alone.
+   * Launch DUnit. If the unit test was launched through the hydra framework, leave the test alone.
-    if(System.getProperties().contains(VM_NUM_PARAM)) {
-      //we're a dunit child vm, do nothing.
+    if (System.getProperties().contains(VM_NUM_PARAM)) {
+      // we're a dunit child vm, do nothing.
-    if(!isHydra() &&!isLaunched()) {
+    if (!isHydra() && !isLaunched()) {
-  
+
-  
+
-  private static void launch() throws URISyntaxException, AlreadyBoundException, IOException, InterruptedException, NotBoundException {
+  private static void launch() throws URISyntaxException, AlreadyBoundException, IOException,
+      InterruptedException, NotBoundException {
-    
-    //create an RMI registry and add an object to share our tests config
+
+    // create an RMI registry and add an object to share our tests config
-    System.setProperty(RMI_PORT_PARAM, ""+namingPort);
+    System.setProperty(RMI_PORT_PARAM, "" + namingPort);
-    
+
-//        System.out.println("shutting down DUnit JVMs");
-//        for (int i=0; i<NUM_VMS; i++) {
-//          try {
-//            processManager.getStub(i).shutDownVM();
-//          } catch (Exception e) {
-//            System.out.println("exception shutting down vm_"+i+": " + e);
-//          }
-//        }
-//        // TODO - hasLiveVMs always returns true
-//        System.out.print("waiting for JVMs to exit");
-//        long giveUp = System.currentTimeMillis() + 5000;
-//        while (giveUp > System.currentTimeMillis()) {
-//          if (!processManager.hasLiveVMs()) {
-//            return;
-//          }
-//          System.out.print(".");
-//          System.out.flush();
-//          try {
-//            Thread.sleep(1000);
-//          } catch (InterruptedException e) {
-//            break;
-//          }
-//        }
-//        System.out.println("\nkilling any remaining JVMs");
+        // System.out.println("shutting down DUnit JVMs");
+        // for (int i=0; i<NUM_VMS; i++) {
+        // try {
+        // processManager.getStub(i).shutDownVM();
+        // } catch (Exception e) {
+        // System.out.println("exception shutting down vm_"+i+": " + e);
+        // }
+        // }
+        // // TODO - hasLiveVMs always returns true
+        // System.out.print("waiting for JVMs to exit");
+        // long giveUp = System.currentTimeMillis() + 5000;
+        // while (giveUp > System.currentTimeMillis()) {
+        // if (!processManager.hasLiveVMs()) {
+        // return;
+        // }
+        // System.out.print(".");
+        // System.out.flush();
+        // try {
+        // Thread.sleep(1000);
+        // } catch (InterruptedException e) {
+        // break;
+        // }
+        // }
+        // System.out.println("\nkilling any remaining JVMs");
-    //Create a VM for the locator
+    // Create a VM for the locator
-    //wait for the VM to start up
-    if(!processManager.waitForVMs(STARTUP_TIMEOUT)) {
+    // wait for the VM to start up
+    if (!processManager.waitForVMs(STARTUP_TIMEOUT)) {
-    //Launch an initial set of VMs
-    for(int i=0; i < NUM_VMS; i++) {
+    // Launch an initial set of VMs
+    for (int i = 0; i < NUM_VMS; i++) {
-    //wait for the VMS to start up
-    if(!processManager.waitForVMs(STARTUP_TIMEOUT)) {
+    // wait for the VMS to start up
+    if (!processManager.waitForVMs(STARTUP_TIMEOUT)) {
-    //populate the Host class with our stubs. The tests use this host class
-    DUnitHost host = new DUnitHost(InetAddress.getLocalHost().getCanonicalHostName(), processManager);
+    // populate the Host class with our stubs. The tests use this host class
+    DUnitHost host =
+        new DUnitHost(InetAddress.getLocalHost().getCanonicalHostName(), processManager);
-  
+
-   * Add an appender to Log4j which sends all INFO+ messages to a separate file
-   * which will be used later to scan for suspect strings.  The pattern of the
-   * messages conforms to the original log format so that hydra will be able
-   * to parse them.
+   * Add an appender to Log4j which sends all INFO+ messages to a separate file which will be used
+   * later to scan for suspect strings. The pattern of the messages conforms to the original log
+   * format so that hydra will be able to parse them.
-    final LoggerContext appenderContext = ((org.apache.logging.log4j.core.Logger)
-        LogManager.getLogger(LogService.BASE_LOGGER_NAME)).getContext();
+    final LoggerContext appenderContext =
+        ((org.apache.logging.log4j.core.Logger) LogManager.getLogger(LogService.BASE_LOGGER_NAME))
+            .getContext();
-        "[%level{lowerCase=true} %date{yyyy/MM/dd HH:mm:ss.SSS z} <%thread> tid=%tid] %message%n%throwable%n", null, null, null,
-        Charset.defaultCharset(), true, false, "", "");
-    
+        "[%level{lowerCase=true} %date{yyyy/MM/dd HH:mm:ss.SSS z} <%thread> tid=%tid] %message%n%throwable%n",
+        null, null, null, Charset.defaultCharset(), true, false, "", "");
+
-        DUnitLauncher.class.getName(), "true", "false", "false", "0", layout, null, null, null, appenderContext.getConfiguration());
+        DUnitLauncher.class.getName(), "true", "false", "false", "0", layout, null, null, null,
+        appenderContext.getConfiguration());
-    LoggerConfig loggerConfig = appenderContext.getConfiguration().getLoggerConfig(LogService.BASE_LOGGER_NAME);
+    LoggerConfig loggerConfig =
+        appenderContext.getConfiguration().getLoggerConfig(LogService.BASE_LOGGER_NAME);
-  
+
-        LOCATOR_LOG_TO_DISK ? new File("locator-" + locatorPort + ".log") : new File(""); 
+        LOCATOR_LOG_TO_DISK ? new File("locator-" + locatorPort + ".log") : new File("");
-        //Disable the shared configuration on this locator.
-        //Shared configuration tests create their own locator
+        // Disable the shared configuration on this locator.
+        // Shared configuration tests create their own locator
-        //Tell the locator it's the first in the system for
-        //faster boot-up
+        // Tell the locator it's the first in the system for
+        // faster boot-up
-        
+
-    if(result.getException() != null) {
+    if (result.getException() != null) {
-    //fake out tests that are using a bunch of hydra stuff
-    String workspaceDir = System.getProperty(DUnitLauncher.WORKSPACE_DIR_PARAM) ;
+    // fake out tests that are using a bunch of hydra stuff
+    String workspaceDir = System.getProperty(DUnitLauncher.WORKSPACE_DIR_PARAM);
-    
+
-    
-    //Free off heap memory when disconnecting from the distributed system
+
+    // Free off heap memory when disconnecting from the distributed system
-    
-    //indicate that this CM is controlled by the eclipse dunit.
+
+    // indicate that this CM is controlled by the eclipse dunit.
-  
+
-        
+
-        
+
-        
+
+
+
+
-  
+
-    
+
-    public int getLocatorPort()  throws RemoteException{
+    public int getLocatorPort() throws RemoteException {
-    
+
-      //do nothing
+      // do nothing
-      
+
-        if(!processManager.waitForVMs(STARTUP_TIMEOUT)) {
+        if (!processManager.waitForVMs(STARTUP_TIMEOUT)) {
-  
+
-    
+
-    
+
-    
-    public void init(Registry registry, int numVMs) throws AccessException, RemoteException, NotBoundException, InterruptedException {
-      for(int i = 0; i < numVMs; i++) {
+
+    public void init(Registry registry, int numVMs)
+        throws AccessException, RemoteException, NotBoundException, InterruptedException {
+      for (int i = 0; i < numVMs; i++) {
-      
+
-      
+
-      
-      if(n == DEBUGGING_VM_NUM) {
-        //for ease of debugging, pass -1 to get the local VM
+
+      if (n == DEBUGGING_VM_NUM) {
+        // for ease of debugging, pass -1 to get the local VM
-      if(n >= oldVMCount) {
-        //If we don't have a VM with that number, dynamically create it.
+      if (n >= oldVMCount) {
+        // If we don't have a VM with that number, dynamically create it.
-          for(int i = oldVMCount; i <= n; i++) {
+          for (int i = oldVMCount; i <= n; i++) {
-          for(int i = oldVMCount; i <= n; i++) {
+          for (int i = oldVMCount; i <= n; i++) {
-      
+

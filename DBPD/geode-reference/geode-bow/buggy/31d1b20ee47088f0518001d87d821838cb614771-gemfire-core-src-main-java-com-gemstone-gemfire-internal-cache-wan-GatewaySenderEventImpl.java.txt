Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.InternalGemFireError;
+import com.gemstone.gemfire.internal.cache.CachedDeserializable;
+import com.gemstone.gemfire.internal.cache.Token;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.Releasable;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.ChunkWithHeapForm;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-    AsyncEvent, DataSerializableFixedID, Conflatable, Sizeable {
+    AsyncEvent, DataSerializableFixedID, Conflatable, Sizeable, Releasable {
-  protected static final Object TOKEN_UN_INITIALIZED = new Object();
-  
-  protected EntryEventImpl entryEvent;
-  
-  private LocalRegion region;
+  private transient LocalRegion region;
-  protected Object key = TOKEN_UN_INITIALIZED;
+  protected Object key;
-   * The serialized new value for this event's key
+   * The serialized new value for this event's key.
+   * May not be computed at construction time.
+  
+  /**
+   * The "object" form of the value.
+   * Will be null after this object is deserialized.
+   */
+  @Retained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+  protected transient Object valueObj;
+  protected transient boolean valueObjReleased;
-  protected Long shadowKey = new Long(-1);
+  protected Long shadowKey = Long.valueOf(-1L);
+  
+  protected boolean isInitialized;
+  private static final int INVALIDATE_ACTION = 5;
-  /**
-   * Is this thread in the process of deserializing this event?
-   */
-  public static final ThreadLocal isDeserializingValue = new ThreadLocal() {
-    @Override
-    protected Object initialValue() {
-      return Boolean.FALSE;
-    }
-  };
+//  /**
+//   * Is this thread in the process of deserializing this event?
+//   */
+//  public static final ThreadLocal isDeserializingValue = new ThreadLocal() {
+//    @Override
+//    protected Object initialValue() {
+//      return Boolean.FALSE;
+//    }
+//  };
+  @Retained
+  @Retained
-   * @param event
+   * @param ce
-  public GatewaySenderEventImpl(EnumListenerEvent operation, CacheEvent event,
+  @Retained
+  public GatewaySenderEventImpl(EnumListenerEvent operation, CacheEvent ce,
+    final EntryEventImpl event = (EntryEventImpl)ce;
-    this.entryEvent = (EntryEventImpl)event;
-    this.region = (LocalRegion)this.entryEvent.getRegion();
+    this.region = (LocalRegion)event.getRegion();
-    initializeId();
+    initializeId(event);
-    this.possibleDuplicate = this.entryEvent.isPossibleDuplicate(); 
+    this.possibleDuplicate = event.isPossibleDuplicate(); 
-    if (this.entryEvent.getVersionTag() != null) {
-      this.versionTimeStamp = this.entryEvent.getVersionTag().getVersionTimeStamp();
+    if (event.getVersionTag() != null) {
+      this.versionTimeStamp = event.getVersionTag().getVersionTimeStamp();
-    // Initialize the remainder of the event if necessary
+
+    // Set key
+    // System.out.println("this._entryEvent: " + event);
+    // System.out.println("this._entryEvent.getKey(): " +
+    // event.getKey());
+    this.key = event.getKey();
+
+    initializeValue(event);
+
+    // Set the callback arg
+    this.callbackArgument = (GatewaySenderEventCallbackArgument)
+        event.getRawCallbackArgument();
+
+    // Initialize the action and number of parts (called after _callbackArgument
+    // is set above)
+    initializeAction(this.operation);
+    
+    //initialize the operation detail 
+    initializeOperationDetail(event.getOperation());
+
+    setShadowKey(event.getTailKey());
+    
+   * Used to create a heap copy of an offHeap event.
+   * Note that this constructor produces an instance that does not need to be released.
+   */
+  protected GatewaySenderEventImpl(GatewaySenderEventImpl offHeapEvent) {
+    this.operation = offHeapEvent.operation;
+    this.action = offHeapEvent.action;
+    this.numberOfParts = offHeapEvent.numberOfParts;
+    this.id = offHeapEvent.id;
+    this.region = offHeapEvent.region;
+    this.regionPath = offHeapEvent.regionPath;
+    this.key = offHeapEvent.key;
+    this.callbackArgument = offHeapEvent.callbackArgument;
+    this.versionTimeStamp = offHeapEvent.versionTimeStamp;
+    this.possibleDuplicate = offHeapEvent.possibleDuplicate;
+    this.isAcked = offHeapEvent.isAcked;
+    this.isDispatched = offHeapEvent.isDispatched;
+    this.creationTime = offHeapEvent.creationTime;
+    this.bucketId = offHeapEvent.bucketId;
+    this.shadowKey = offHeapEvent.shadowKey;
+    this.isInitialized = offHeapEvent.isInitialized;
+
+    this.valueObj = null;
+    this.valueObjReleased = false;
+    this.valueIsObject = offHeapEvent.valueIsObject;
+    this.value = offHeapEvent.getSerializedValue();
+  }
+  
+  /**
+      break;
+    case INVALIDATE_ACTION:
+      op = Operation.INVALIDATE;
+      break;
-  public EntryEvent getEntryEvent(){
-    return this.entryEvent;
-  }
-  
+  public boolean isInitialized() {
+    return this.isInitialized;
+  }
-    return this.key == TOKEN_UN_INITIALIZED ? null : this.key;
-  }
-
-  /**
-   * Returns this event's serialized value
-   * 
-   * @return this event's serialized value
-   */
-  public byte[] getValue() {
-    return this.value;
+    return isInitialized() ? this.key : null;
+  
+  /**
+   * Return the value as a byte[] array, if it is plain byte array,
+   * otherwise return a cache deserializable or plain object, depending
+   * on if the currently held form of the object is serialized or not.
+   * 
+   * If the object is held off heap, this will copy it to the heap return the heap copy.
+   * 
+   *  //OFFHEAP TODO: Optimize callers by returning a reference to the off heap value
+   */
+  public Object getValue() {
+    if (CachedDeserializableFactory.preferObject()) {
+      // sqlf does not use CacheDeserializable wrappers
+      return getDeserializedValue();
+    }
+    Object rawValue = this.value;
+    if (rawValue == null) {
+      @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+      Object vo = this.valueObj;
+      if (vo instanceof StoredObject) {
+        rawValue = ((StoredObject) vo).getValueAsHeapByteArray();
+      } else {
+        rawValue = vo;
+      }
+    }
+    if (valueIsObject == 0x00) {
+      //if the value is a byte array, just return it
+      return rawValue;
+    } else if (CachedDeserializableFactory.preferObject()) {
+      // sqlf does not use CacheDeserializable wrappers
+      return rawValue;
+    } else if (rawValue instanceof byte[]) {
+      return CachedDeserializableFactory.create((byte[]) rawValue);
+    } else {
+      return rawValue;
+    }
+  }
+  
+  /**
+   * Return the currently held form of the object.
+   * May return a retained OFF_HEAP_REFERENCE.
+   */
+  @Retained
+  public Object getRawValue() {
+    @Retained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+    Object result = this.value;
+    if (result == null) {
+      result = this.valueObj;
+      if (result instanceof Chunk) {
+        if (this.valueObjReleased) {
+          result = null;
+        } else {
+          Chunk ohref = (Chunk) result;
+          if (!ohref.retain()) {
+            result = null;
+          } else if (this.valueObjReleased) {
+            ohref.release();
+            result = null;
+          }
+        }
+      }
+    }
+    return result;
+  }
+
+  /**
+   * This method is meant for internal use by the SimpleMemoryAllocatorImpl.
+   * Others should use getRawValue instead.
+   * @return if the result is an off-heap reference then callers must use it before this event is released.
+   */
+  @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+  public Object getValueObject() {
+    return this.valueObj;
+  }
-    isDeserializingValue.set(Boolean.TRUE);
-    Object obj = deserialize(this.value);
-    isDeserializingValue.set(Boolean.FALSE);
-    return obj;
+// TODO OFFHEAP MERGE: handle substituteValue here?
+    if (this.valueIsObject == 0x00) {
+      Object result = this.value;
+      if (result == null) {
+        @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+        Object so = this.valueObj;
+        if (this.valueObjReleased) {
+          throw new IllegalStateException("Value is no longer available. getDeserializedValue must be called before processEvents returns.");
+        }
+        if (so instanceof StoredObject) {
+          // TODO OFFHEAP: returns off-heap PdxInstance
+          return ((StoredObject)so).getValueAsDeserializedHeapObject();
+        } else {
+          throw new IllegalStateException("expected valueObj field to be an instance of StoredObject but it was " + so);
+        }
+      }
+      return result;
+    }
+    else {
+      Object vo = this.valueObj;
+      if (vo != null) {
+        if (vo instanceof StoredObject) {
+          @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+          StoredObject so = (StoredObject)vo;
+          // TODO OFFHEAP: returns off-heap PdxInstance
+          return so.getValueAsDeserializedHeapObject();
+        } else {
+          return vo; // it is already deserialized
+        }
+      } else {
+        if (this.value != null) {
+          Object result = EntryEventImpl.deserialize(this.value);
+          this.valueObj = result;
+          return result;
+        } else {
+          if (this.valueObjReleased) {
+            throw new IllegalStateException("Value is no longer available. getDeserializedValue must be called before processEvents returns.");
+          }
+          // both value and valueObj are null but we did not free it.
+          return null;
+        }
+      }
+    }
+  }
+  
+  /**
+   * Returns the value in the form of a String.
+   * This should be used by code that wants to log
+   * the value. This is a debugging exception.
+   */
+  public String getValueAsString(boolean deserialize) {
+// TODO OFFHEAP MERGE: handle substituteValue here?
+    Object v = this.value;
+    if (deserialize) {
+      try {
+        v = getDeserializedValue();
+      } catch (Exception e) {
+        return "Could not convert value to string because " + e;
+      } catch (InternalGemFireError e) { // catch this error for bug 49147
+        return "Could not convert value to string because " + e;
+      }
+    }
+    if (v == null) {
+      @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+      Object ov = this.valueObj;
+      if (ov instanceof CachedDeserializable) {
+        return ((CachedDeserializable) ov).getStringForm();
+      }
+    }
+    if (v != null) {
+      if (v instanceof byte[]) {
+        byte[] bav = (byte[]) v;
+        // Using Arrays.toString(bav) can cause us to run out of memory
+        return "byte[" + bav.length + "]";
+      } else {
+        return v.toString();
+      }
+    } else {
+      return "";
+    }
+  /**
+   * If the value owned of this event is just bytes return that byte array;
+   * otherwise serialize the value object and return the serialized bytes.
+   * Use {@link #getValueIsObject()} to determine if the result is raw or serialized bytes.
+   */
-    return this.value;
+    byte[] result = this.value;
+    if (result == null) {
+      @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+      Object vo = this.valueObj;
+      if (vo instanceof StoredObject) {
+        synchronized (this) {
+          result = this.value;
+          if (result == null) {
+            StoredObject so = (StoredObject) vo;
+            result = so.getValueAsHeapByteArray();
+            this.value = result;
+          }
+        }
+      } else {
+        synchronized (this) {
+          result = this.value;
+          if (result == null && vo != null && !(vo instanceof Token)) {
+            result = EntryEventImpl.serialize(vo);
+            this.value = result;
+          } else if (result == null) {
+            if (this.valueObjReleased) {
+              throw new IllegalStateException("Value is no longer available. getSerializedValue must be called before processEvents returns.");
+            }
+          }
+        }
+      }
+    }
+    return result;
-    if (this.key == TOKEN_UN_INITIALIZED) {
-      initialize();
-    }
+    initialize();
-    DataSerializer.writeObject(this.key, out);
-    DataSerializer.writeByteArray(this.value, out);
+    serializeKey(out);
+    DataSerializer.writeByteArray(getSerializedValue(), out);
-    out.writeLong(getVersionTimeStamp());
+    out.writeLong(getVersionTimeStamp());    
+  }
+
+  protected void serializeKey(DataOutput out) throws IOException {
+    DataSerializer.writeObject(this.key, out);
+    this.isInitialized = true;
-    this.key = DataSerializer.readObject(in);
+    deserializeKey(in);
+    // TODO should this call initializeKey()?
+  }
+
+  protected void deserializeKey(DataInput in) throws IOException,
+      ClassNotFoundException {
+    this.key = DataSerializer.readObject(in);
-        .append(deserialize(this.value)).append(";valueIsObject=")
+        .append(getValueAsString(true)).append(";valueIsObject=")
-  public static boolean isDeserializingValue() {
-    return ((Boolean)isDeserializingValue.get()).booleanValue();
-  }
-
-  public Object deserialize(byte[] serializedBytes) {
-    Object deserializedObject = serializedBytes;
-    // This is a debugging method so ignore all exceptions like
-    // ClassNotFoundException
-    try {
-      if (this.valueIsObject == 0x00) {
-        deserializedObject = serializedBytes;
-      } else {
-        deserializedObject = EntryEventImpl.deserialize(serializedBytes);
-      }
-    } catch (Exception e) {
-    }
-    return deserializedObject;
-  }
+//   public static boolean isDeserializingValue() {
+//     return ((Boolean)isDeserializingValue.get()).booleanValue();
+//   }
-    return this.value;
+    // Since all the uses of this are for logging
+    // changing it to return the string form of the value
+    // instead of the actual value.
+    return this.getValueAsString(true);
-    this.value = (byte[])value;
+    // Currently this method is never used.
+    // If someone does want to use it in the future
+    // then the implementation needs to be updated
+    // to correctly update value, valueObj, and valueIsObject
+    throw new UnsupportedOperationException();
-  private void initializeId() {
+  private void initializeId(EntryEventImpl event) {
-    this.id = this.entryEvent.getEventId();
+    this.id = event.getEventId();
-   * 
-   * @throws IOException
-  public void initialize() throws IOException {
-    // Set key
-    // System.out.println("this._entryEvent: " + this._entryEvent);
-    // System.out.println("this._entryEvent.getKey(): " +
-    // this._entryEvent.getKey());
-    if (this.key != TOKEN_UN_INITIALIZED) {
-      // We have already initialized, or initialized elsewhere. Lets return.
+  public void initialize() {
+    if (isInitialized()) {
-    this.key = this.entryEvent.getKey();
+    this.isInitialized = true;
+  }
+
+  // Initializes the value object. This function need a relook because the 
+  // serialization of the value looks unnecessary.
+  @Retained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+  protected void initializeValue(EntryEventImpl event) throws IOException {
-      // If the value is already serialized, use it.
-      this.valueIsObject = 0x01;
-      SerializedCacheValue serializedNewValue = this.entryEvent
-          .getSerializedNewValue();
-  
-      if (serializedNewValue == null) {
-        if (this.entryEvent.getCachedSerializedNewValue() != null) {
-          this.value = this.entryEvent.getCachedSerializedNewValue();
-        } else {
-        Object newValue = this.entryEvent.getRawNewValue();
-        if (newValue instanceof byte[]) {
-          // The value is byte[]. Set _valueIsObject flag to 0x00 (not an object)
-          this.value = (byte[])newValue;
-          this.valueIsObject = 0x00;
-        } else {
-          // The value is an object. Serialize it.
-          isSerializingValue.set(Boolean.TRUE);
-          this.value = CacheServerHelper.serialize(newValue);
-          isSerializingValue.set(Boolean.FALSE);
-          this.entryEvent.setCachedSerializedNewValue(this.value);
-        }
-        }
-      } else {
-        this.value = serializedNewValue.getSerializedValue();
+    // If the value is already serialized, use it.
+    this.valueIsObject = 0x01;
+    /**
+     * so ends up being stored in this.valueObj
+     */
+    @Retained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+    StoredObject so = null;
+    if (event.hasDelta()) {
+      this.valueIsObject = 0x02;
+    } else {
+      SimpleMemoryAllocatorImpl.setReferenceCountOwner(this);
+      so = event.getOffHeapNewValue();
+      SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);      
+        // TODO OFFHEAP MERGE: check for a cached serialized value first
+        // so we can use it instead of reading offheap
+        // If we do read offheap then add the serialize new value to the event cache
+    }
+    
+    if (so != null) {
+//    if (so != null  && !event.hasDelta()) {
+      // Since GatewaySenderEventImpl instances can live for a long time in the gateway region queue
+      // we do not want the StoredObject to be one that keeps the heap form cached.
+      if (so instanceof ChunkWithHeapForm) {
+        so = ((ChunkWithHeapForm) so).getChunkWithoutHeapForm(); // fixes 51999
+      this.valueObj = so;
+      if (!so.isSerialized()) {
+        this.valueIsObject = 0x00;
+      }
+    } else if (event.getCachedSerializedNewValue() != null) {
+      // We want this to have lower precedence than StoredObject so that the gateway
+      // can share a reference to the off-heap value.
+      this.value = event.getCachedSerializedNewValue();
+    } else {
+      final Object newValue = event.getRawNewValue(shouldApplyDelta());
+      assert !(newValue instanceof StoredObject); // since we already called getOffHeapNewValue() and it returned null
+      if (newValue instanceof CachedDeserializable) {
+        this.value = ((CachedDeserializable) newValue).getSerializedValue();
+      } else if (newValue instanceof byte[]) {
+        // The value is byte[]. Set _valueIsObject flag to 0x00 (not an object)
+        this.value = (byte[])newValue;
+        this.valueIsObject = 0x00;
+      } else {
+        // The value is an object. It will be serialized later when getSerializedValue is called.
+        this.valueObj = newValue;
+        // to prevent bug 48281 we need to serialize it now
+        this.getSerializedValue();
+        this.valueObj = null;
+      }
+    }
-        this.entryEvent.setCachedSerializedNewValue(this.value);
+        event.setCachedSerializedNewValue(this.value);
+  }
-    // Set the callback arg
-    this.callbackArgument = (GatewaySenderEventCallbackArgument)this.entryEvent
-        .getRawCallbackArgument();
-
-    // Initialize the action and number of parts (called after _callbackArgument
-    // is set above)
-    initializeAction(this.operation);
-    
-    //initialize the operation detail 
-    initializeOperationDetail(this.entryEvent.getOperation());
-    
-    setShadowKey(entryEvent.getTailKey());
-    
-    // The entry event is no longer necessary. Null it so it can be GCed.
-    this.entryEvent = null;
+  protected boolean shouldApplyDelta() {
+    return false;
+    } else if (operation == EnumListenerEvent.AFTER_INVALIDATE) {
+      // Initialize after invalidate action
+      this.action = INVALIDATE_ACTION;
+
+      // Initialize number of parts
+      // Since there is no value, there is one less part
+      this.numberOfParts = (this.callbackArgument == null) ? 7 : 8;
-    if (this.value != null) {
-      size += CachedDeserializableFactory.calcMemSize(this.value);
-    }
+    size += getSerializedValueSize();
+  public int getSerializedValueSize() {
+    @Unretained(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+    Object vo = this.valueObj;
+    if (vo instanceof StoredObject) {
+      return ((StoredObject) vo).getSizeInBytes();
+    } else {
+      return CachedDeserializableFactory.calcMemSize(getSerializedValue());
+    }
+  }
+  
+  @Override
+  @Released(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+  public void release() {
+    @Released(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE)
+    Object vo = this.valueObj;
+    if (OffHeapHelper.releaseAndTrackOwner(vo, this)) {
+      this.valueObj = null;
+      this.valueObjReleased = true;
+    }
+  }
+  
+  public static void release(@Released(OffHeapIdentifier.GATEWAY_SENDER_EVENT_IMPL_VALUE) Object o) {
+    if (o instanceof GatewaySenderEventImpl) {
+      ((GatewaySenderEventImpl) o).release();
+    }
+  }
+
+  /**
+   * Make a heap copy of this off-heap event and return it.
+   * A copy only needs to be made if the event's value is stored off-heap.
+   * If it is already on the java heap then just return "this".
+   * If it was stored off-heap and is no longer available (because it was released) then return null.
+   */
+  public GatewaySenderEventImpl makeHeapCopyIfOffHeap() {
+    if (this.value != null) {
+      // we have the value stored on the heap so return this
+      return this;
+    } else {
+      Object v = this.valueObj;
+      if (v == null) {
+        if (this.valueObjReleased) {
+          // this means that the original off heap value was freed
+          return null;
+        } else {
+          return this;
+        }
+      }
+      if (v instanceof Chunk) {
+        try {
+          return makeCopy();
+        } catch (IllegalStateException ex) {
+          // this means that the original off heap value was freed
+          return null;
+        }
+      } else {
+        // the valueObj does not use refCounts so just return this.
+        return this;
+      }
+    }
+  }
+  
+  protected GatewaySenderEventImpl makeCopy() {
+    return new GatewaySenderEventImpl(this);
+  }
+
+  public void copyOffHeapValue() {
+    if (this.value == null) {
+      this.value = getSerializedValue();
+    }
+  }

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class make sure that each member is alive and communicating to this member.
- * To make sure that we create the ring of members based on current view. On this
- * ring, each member make sure that next-member in ring is communicating with it.
- * For that we record last message timestamp from next-member. And if it sees this
- * member has not communicated in last period(member-timeout) then we check whether
- * this member is still alive or not. Based on that we informed probable coordinators
- * to remove that member from view.
+ * This class make sure that each member is alive and communicating to this member. To make sure
+ * that we create the ring of members based on current view. On this ring, each member make sure
+ * that next-member in ring is communicating with it. For that we record last message timestamp from
+ * next-member. And if it sees this member has not communicated in last period(member-timeout) then
+ * we check whether this member is still alive or not. Based on that we informed probable
+ * coordinators to remove that member from view.
- * It has {@link #suspect(InternalDistributedMember, String)} api, which can be used
- * to initiate suspect processing for any member. First is checks whether the member is
- * responding or not. Then it informs probable coordinators to remove that member from
- * view.
+ * It has {@link #suspect(InternalDistributedMember, String)} api, which can be used to initiate
+ * suspect processing for any member. First is checks whether the member is responding or not. Then
+ * it informs probable coordinators to remove that member from view.
- * It has {@link #checkIfAvailable(DistributedMember, String, boolean)} api to see
- * if that member is alive. Then based on removal flag it initiates the suspect processing
- * for that member.
+ * It has {@link #checkIfAvailable(DistributedMember, String, boolean)} api to see if that member is
+ * alive. Then based on removal flag it initiates the suspect processing for that member.
- * */
-@SuppressWarnings({ "SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems" })
+ */
+@SuppressWarnings({"SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems"})
-  
+
-   * The number of recipients of periodic heartbeats.  The recipients will
-   * be selected from the members that are likely to be monitoring this member.
+   * The number of recipients of periodic heartbeats. The recipients will be selected from the
+   * members that are likely to be monitoring this member.
-   * Member activity will be recorded per interval/period. Timer task will set interval's starting time.
-   * Each interval will be member-timeout/LOGICAL_INTERVAL. LOGICAL_INTERVAL may be configured
+   * Member activity will be recorded per interval/period. Timer task will set interval's starting
+   * time. Each interval will be member-timeout/LOGICAL_INTERVAL. LOGICAL_INTERVAL may be configured
-  public static final int LOGICAL_INTERVAL = Integer.getInteger("geode.logical-message-received-interval", 2);
+  public static final int LOGICAL_INTERVAL =
+      Integer.getInteger("geode.logical-message-received-interval", 2);
-  public static final long MEMBER_SUSPECT_COLLECTION_INTERVAL = Long.getLong("geode.suspect-member-collection-interval", 200);
+  public static final long MEMBER_SUSPECT_COLLECTION_INTERVAL =
+      Long.getLong("geode.suspect-member-collection-interval", 200);
-  
+
-  final ConcurrentMap<InternalDistributedMember, TimeStamp> memberTimeStamps = new ConcurrentHashMap<>();
-  
+  final ConcurrentMap<InternalDistributedMember, TimeStamp> memberTimeStamps =
+      new ConcurrentHashMap<>();
+
-  final private ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView = new ConcurrentHashMap<>();
-  
+  final private ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView =
+      new ConcurrentHashMap<>();
+
-  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
+  final private List<InternalDistributedMember> membersInFinalCheck =
+      Collections.synchronizedList(new ArrayList<>(30));
-  
+
-  
+
-  
+
-  static final int ERROR = 0x00;  
+  static final int ERROR = 0x00;
-  
+
-    
+
-   * This class sets start interval timestamp to record the activity of all members.
-   * That is used by {@link GMSHealthMonitor#contactedBy(InternalDistributedMember)} to
-   * record the activity of member.
+   * This class sets start interval timestamp to record the activity of all members. That is used by
+   * {@link GMSHealthMonitor#contactedBy(InternalDistributedMember)} to record the activity of
+   * member.
-      
+
-      
+
-      //this is the start of interval to record member activity
+      // this is the start of interval to record member activity
-        synchronized(GMSHealthMonitor.this) {
+        synchronized (GMSHealthMonitor.this) {
-        
+
-        
+
-   * Response will have requestId, which is used to get ResponseObject. Then it is used to
-   * notify waiting thread.
+   * Response will have requestId, which is used to get ResponseObject. Then it is used to notify
+   * waiting thread.
-        int  vmViewId = in.readInt();
+        int vmViewId = in.readInt();
-                   && uuidMSBs == myUUID.getMostSignificantBits()
-                   && vmViewId == myVmViewId) {
+            && uuidMSBs == myUUID.getMostSignificantBits() && vmViewId == myVmViewId) {
-            logger.debug("HealthMonitor: sending ERROR reply - my UUID is {},{} received is {},{}.  My viewID is {} received is {}", 
-              Long.toHexString(myUUID.getMostSignificantBits()),
-              Long.toHexString(myUUID.getLeastSignificantBits()), 
-              Long.toHexString(uuidMSBs),
-              Long.toHexString(uuidLSBs),
-              myVmViewId, vmViewId);
+            logger.debug(
+                "HealthMonitor: sending ERROR reply - my UUID is {},{} received is {},{}.  My viewID is {} received is {}",
+                Long.toHexString(myUUID.getMostSignificantBits()),
+                Long.toHexString(myUUID.getLeastSignificantBits()), Long.toHexString(uuidMSBs),
+                Long.toHexString(uuidLSBs), myVmViewId, vmViewId);
-  public static void loadEmergencyClasses() {
-  }
+  public static void loadEmergencyClasses() {}
-  
-  
+
+
-  
-  private HeartbeatRequestMessage constructHeartbeatRequestMessage(final InternalDistributedMember mbr) {
+
+  private HeartbeatRequestMessage constructHeartbeatRequestMessage(
+      final InternalDistributedMember mbr) {
-        
+
-   * This method sends heartbeat request to other member and waits for member-timeout
-   * time for response. If it doesn't see response then it returns false.
+   * This method sends heartbeat request to other member and waits for member-timeout time for
+   * response. If it doesn't see response then it returns false.
-      } else if (waitForResponse){
+      } else if (waitForResponse) {
-      logger.debug("GMSHealthMonitor checking thread interrupted, while waiting for response from member: {} .", member);
+      logger.debug(
+          "GMSHealthMonitor checking thread interrupted, while waiting for response from member: {} .",
+          member);
-      if(waitForResponse) {
+      if (waitForResponse) {
-   * During final check, establish TCP connection between current member and suspect member.
-   * And exchange PING/PONG message to see if the suspect member is still alive.
+   * During final check, establish TCP connection between current member and suspect member. And
+   * exchange PING/PONG message to see if the suspect member is still alive.
-    InternalDistributedSystem internalDistributedSystem = InternalDistributedSystem.getConnectedInstance();
+    InternalDistributedSystem internalDistributedSystem =
+        InternalDistributedSystem.getConnectedInstance();
-      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember, suspectMember.getInetAddress(), port);
-      clientSocket = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER).connect(suspectMember.getInetAddress(), port,
-          (int)memberTimeout, new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
+      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember,
+          suspectMember.getInetAddress(), port);
+      clientSocket =
+          SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
+              .connect(suspectMember.getInetAddress(), port, (int) memberTimeout,
+                  new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-    }
-    catch (IllegalStateException e) {
+    } catch (IllegalStateException e) {
-    }
-    finally {
+    } finally {
-  //Package protected for testing purposes
+  // Package protected for testing purposes
-          logger.debug("Received {}", (b == OK ? "OK" : (b == ERROR ? "ERROR" : "unknown response: " + b)));
+          logger.debug("Received {}",
+              (b == OK ? "OK" : (b == ERROR ? "ERROR" : "unknown response: " + b)));
-          //received ERROR
+          // received ERROR
-    } 
+    }
-  
+
-  
+
-//    synchronized (suspectRequests) {
-//      SuspectRequest sr = new SuspectRequest((InternalDistributedMember) mbr, reason);
-//      if (!suspectRequests.contains(sr)) {
-//        logger.info("Suspecting member {}. Reason= {}.", mbr, reason);
-//        suspectRequests.add(sr);
-//        suspectRequests.notify();
-//      }
-//    }
+    // synchronized (suspectRequests) {
+    // SuspectRequest sr = new SuspectRequest((InternalDistributedMember) mbr, reason);
+    // if (!suspectRequests.contains(sr)) {
+    // logger.info("Suspecting member {}. Reason= {}.", mbr, reason);
+    // suspectRequests.add(sr);
+    // suspectRequests.notify();
+    // }
+    // }
-    return inlineCheckIfAvailable(localAddress, currentView, initiateRemoval, (InternalDistributedMember)mbr, reason);
+    return inlineCheckIfAvailable(localAddress, currentView, initiateRemoval,
+        (InternalDistributedMember) mbr, reason);
-        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection thread " + id);
+        Thread th =
+            new Thread(Services.getThreadGroup(), r, "Geode Failure Detection thread " + id);
-//    suspectRequestCollectorThread = this.new RequestCollector<SuspectRequest>("Geode Suspect Message Collector", Services.getThreadGroup(), suspectRequests,
-//        new Callback<SuspectRequest>() {
-//      @Override
-//      public void process(List<SuspectRequest> requests) {
-//        GMSHealthMonitor.this.sendSuspectRequest(requests);
-//
-//      }
-//    }, MEMBER_SUSPECT_COLLECTION_INTERVAL);
-//    suspectRequestCollectorThread.setDaemon(true);
-//    suspectRequestCollectorThread.start()
-    
+    // suspectRequestCollectorThread = this.new RequestCollector<SuspectRequest>("Geode Suspect
+    // Message Collector", Services.getThreadGroup(), suspectRequests,
+    // new Callback<SuspectRequest>() {
+    // @Override
+    // public void process(List<SuspectRequest> requests) {
+    // GMSHealthMonitor.this.sendSuspectRequest(requests);
+    //
+    // }
+    // }, MEMBER_SUSPECT_COLLECTION_INTERVAL);
+    // suspectRequestCollectorThread.setDaemon(true);
+    // suspectRequestCollectorThread.start()
+
-        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Server thread " + id);
+        Thread th =
+            new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Server thread " + id);
-      serverSocket = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER).createServerSocketUsingPortRange(socketAddress, 50/*backlog*/,
-        true/*isBindAddress*/, false/*useNIO*/, 65536/*tcpBufferSize*/, portRange, false);
+      serverSocket = SocketCreatorFactory
+          .getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
+          .createServerSocketUsingPortRange(socketAddress, 50/* backlog */, true/* isBindAddress */,
+              false/* useNIO */, 65536/* tcpBufferSize */, portRange, false);
-      throw new GemFireConfigException("Unable to allocate a failure detection port in the membership-port range", e);
+      throw new GemFireConfigException(
+          "Unable to allocate a failure detection port in the membership-port range", e);
-  
+
-   * start the thread that listens for tcp/ip connections and responds
-   * to connection attempts
+   * start the thread that listens for tcp/ip connections and responds to connection attempts
-      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(), socketPort);
+      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(),
+          socketPort);
-        while (!services.getCancelCriterion().isCancelInProgress() 
+        while (!services.getCancelCriterion().isCancelInProgress()
-            serverSocketExecutor.execute(new ClientSocketHandler(socket)); //start();  [bruce] I'm seeing a lot of failures due to this thread not being created fast enough, sometimes as long as 30 seconds
-          
+            serverSocketExecutor.execute(new ClientSocketHandler(socket)); // start(); [bruce] I'm
+                                                                           // seeing a lot of
+                                                                           // failures due to this
+                                                                           // thread not being
+                                                                           // created fast enough,
+                                                                           // sometimes as long as
+                                                                           // 30 seconds
+
-  
+
-   * start the thread that periodically sends a message to processes
-   * that might be watching this process
+   * start the thread that periodically sends a message to processes that might be watching this
+   * process
+
-            Thread.sleep(memberTimeout/LOGICAL_INTERVAL);
+            Thread.sleep(memberTimeout / LOGICAL_INTERVAL);
-      
+
-            index = mbrs.size()-1;
+            index = mbrs.size() - 1;
-    for (Iterator<InternalDistributedMember> it=memberTimeStamps.keySet().iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = memberTimeStamps.keySet().iterator(); it
+        .hasNext();) {
-    for (Iterator<InternalDistributedMember> it=suspectedMemberInView.keySet().iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = suspectedMemberInView.keySet().iterator(); it
+        .hasNext();) {
-//    for (InternalDistributedMember mbr: newView.getMembers()) {
-//      if (!memberVsLastMsgTS.containsKey(mbr)) {
-//        CustomTimeStamp customTS = new CustomTimeStamp(System.currentTimeMillis());
-//        memberVsLastMsgTS.put(mbr, customTS);
-//      }
-//    }
+    // for (InternalDistributedMember mbr: newView.getMembers()) {
+    // if (!memberVsLastMsgTS.containsKey(mbr)) {
+    // CustomTimeStamp customTS = new CustomTimeStamp(System.currentTimeMillis());
+    // memberVsLastMsgTS.put(mbr, customTS);
+    // }
+    // }
-   * if nextTo == null
-   * then it watches member next to it.
+   * if nextTo == null then it watches member next to it.
-   * It becomes null when we suspect current neighbour, during that time it watches
-   * member next to suspect member.
+   * It becomes null when we suspect current neighbour, during that time it watches member next to
+   * suspect member.
-    
+
-    
+
-    
+
-  
+
-    setLocalAddress( services.getMessenger().getMemberID());
-    serverSocket = createServerSocket(localAddress.getInetAddress(), services.getConfig().getMembershipPortRange());
+    setLocalAddress(services.getMessenger().getMemberID());
+    serverSocket = createServerSocket(localAddress.getInetAddress(),
+        services.getConfig().getMembershipPortRange());
-        }
-        catch (IOException e) {
+        } catch (IOException e) {
-      }      
+      }
-      logger.info("GMSHealthMonitor serverSocketExecutor is " + (serverSocketExecutor.isTerminated() ? "terminated" : "not terminated"));
+      logger.info("GMSHealthMonitor serverSocketExecutor is "
+          + (serverSocketExecutor.isTerminated() ? "terminated" : "not terminated"));
-    
-//    if (suspectRequestCollectorThread != null) {
-//      suspectRequestCollectorThread.shutdown();
-//    }
+
+    // if (suspectRequestCollectorThread != null) {
+    // suspectRequestCollectorThread.shutdown();
+    // }
-    return scheduler.isShutdown() && checkExecutor.isShutdown() && serverSocketExecutor.isShutdown() /*&& !suspectRequestCollectorThread.isAlive()*/;
+    return scheduler.isShutdown() && checkExecutor.isShutdown()
+        && serverSocketExecutor.isShutdown() /* && !suspectRequestCollectorThread.isAlive() */;
-  public void memberSuspected(InternalDistributedMember initiator, InternalDistributedMember suspect, String reason) {
-  }
+  public void memberSuspected(InternalDistributedMember initiator,
+      InternalDistributedMember suspect, String reason) {}
-  
+
-    case HEARTBEAT_REQUEST:
-      if (beingSick || playingDead) {
-        logger.debug("sick member is ignoring check request");
-      } else {
-        processHeartbeatRequest((HeartbeatRequestMessage) m);
-      }
-      break;
-    case HEARTBEAT_RESPONSE:
-      if (beingSick || playingDead) {
-        logger.debug("sick member is ignoring check response");
-      } else {
-        processHeartbeat((HeartbeatMessage) m);
-      }
-      break;
-    case SUSPECT_MEMBERS_MESSAGE:
-      if (beingSick || playingDead) {
-        logger.debug("sick member is ignoring suspect message");
-      } else {
-        processSuspectMembersRequest((SuspectMembersMessage) m);
-      }
-      break;
-    default:
-      throw new IllegalArgumentException("unknown message type: " + m);
+      case HEARTBEAT_REQUEST:
+        if (beingSick || playingDead) {
+          logger.debug("sick member is ignoring check request");
+        } else {
+          processHeartbeatRequest((HeartbeatRequestMessage) m);
+        }
+        break;
+      case HEARTBEAT_RESPONSE:
+        if (beingSick || playingDead) {
+          logger.debug("sick member is ignoring check response");
+        } else {
+          processHeartbeat((HeartbeatMessage) m);
+        }
+        break;
+      case SUSPECT_MEMBERS_MESSAGE:
+        if (beingSick || playingDead) {
+          logger.debug("sick member is ignoring suspect message");
+        } else {
+          processSuspectMembersRequest((SuspectMembersMessage) m);
+        }
+        break;
+      default:
+        throw new IllegalArgumentException("unknown message type: " + m);
-    
+
-    
+
-    
+
-    if (me.getVmViewId() >= 0  &&  m.getTarget().equals(me)) {
+    if (me.getVmViewId() >= 0 && m.getTarget().equals(me)) {
-      logger.trace("Got heartbeat from member {}. {}", m.getSender(), (resp != null ? "Check thread still waiting" : "Check thread is not waiting"));
+      logger.trace("Got heartbeat from member {}. {}", m.getSender(),
+          (resp != null ? "Check thread still waiting" : "Check thread is not waiting"));
-      //we got heartbeat lets update timestamp
+      // we got heartbeat lets update timestamp
-   * Process a Suspect request from another member. This may cause this member
-   * to become the new membership coordinator.
-   * it will to final check on that member and then it will send remove request
-   * for that member
+   * Process a Suspect request from another member. This may cause this member to become the new
+   * membership coordinator. it will to final check on that member and then it will send remove
+   * request for that member
-    
+
-    
+
-      logger.info("Membership ignoring suspect request for " + incomingRequest + " from non-member " + incomingRequest.getSender());
-      services.getJoinLeave().remove(sender, "this process is initiating suspect processing but is no longer a member");
+      logger.info("Membership ignoring suspect request for " + incomingRequest + " from non-member "
+          + incomingRequest.getSender());
+      services.getJoinLeave().remove(sender,
+          "this process is initiating suspect processing but is no longer a member");
-      for (Iterator<SuspectRequest> it = incomingRequest.getMembers().iterator(); it.hasNext(); ) {
+      for (Iterator<SuspectRequest> it = incomingRequest.getMembers().iterator(); it.hasNext();) {
-    
+
-      for (SuspectRequest req: incomingRequest.getMembers()) {
-        logger.info("received suspect message from {} for {}: {}",
-           sender, req.getSuspectMember(), req.getReason());
+      for (SuspectRequest req : incomingRequest.getMembers()) {
+        logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(),
+            req.getReason());
-    }// coordinator ends
+    } // coordinator ends
-        for (SuspectRequest req: incomingRequest.getMembers()) {
-          logger.info("received suspect message from {} for {}: {}",
-             sender, req.getSuspectMember(), req.getReason());
+        for (SuspectRequest req : incomingRequest.getMembers()) {
+          logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(),
+              req.getReason());
-   * This method make sure that records suspectRequest. We need to make sure this
-   * on preferred coordinators, as elder coordinator might be in suspected list next. 
+   * This method make sure that records suspectRequest. We need to make sure this on preferred
+   * coordinators, as elder coordinator might be in suspected list next.
-      for (SuspectRequest sr: sMembers) {       
+      for (SuspectRequest sr : sMembers) {
-   * performs a "final" health check on the member.  If failure-detection
-   * socket information is available for the member (in the view) then
-   * we attempt to connect to its socket and ask if it's the expected member.
-   * Otherwise we send a heartbeat request and wait for a reply.
+   * performs a "final" health check on the member. If failure-detection socket information is
+   * available for the member (in the view) then we attempt to connect to its socket and ask if it's
+   * the expected member. Otherwise we send a heartbeat request and wait for a reply.
-      // suspected.  Since that code is updating this collection we
+      // suspected. Since that code is updating this collection we
-      //      NetView view;
-      //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
+      // NetView view;
+      // view = suspectedMemberInView.putIfAbsent(mbr, cv);
-      //      if (view == null || !view.equals(cv)) {
+      // if (view == null || !view.equals(cv)) {
-      //      }// scheduling for final check and removing it..
+      // }// scheduling for final check and removing it..
-  private boolean inlineCheckIfAvailable(
-      final InternalDistributedMember initiator, final NetView cv,
-      boolean initiateRemoval,
-      final InternalDistributedMember mbr, final String reason) {
+  private boolean inlineCheckIfAvailable(final InternalDistributedMember initiator,
+      final NetView cv, boolean initiateRemoval, final InternalDistributedMember mbr,
+      final String reason) {
-  
+
-          logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
+          logger.debug("\ncurrent view: {}\nports: {}", cv,
+              Arrays.toString(cv.getFailureDetectionPorts()));
-        //this will just send heartbeat request, it will not wait for response
-        //if we will get heartbeat then it will change the timestamp, which we are 
-        //checking below in case of tcp check failure..
+        // this will just send heartbeat request, it will not wait for response
+        // if we will get heartbeat then it will change the timestamp, which we are
+        // checking below in case of tcp check failure..
-  
+
-          logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
+          logger.info(
+              "Final check failed but detected recent message traffic for suspect member " + mbr);
-    
+
-  public void memberShutdown(DistributedMember mbr, String reason) {
-  }
-  
+  public void memberShutdown(DistributedMember mbr, String reason) {}
+
-//    synchronized (suspectRequests) {
-//      if (suspectRequests.size() > 0) {
-//        for (SuspectRequest sr: suspectRequests) {
-//          if (!requests.contains(sr)) {
-//            requests.add(sr);
-//          }
-//        }
-//        suspectRequests.clear();
-//      }
-//    }
+    // synchronized (suspectRequests) {
+    // if (suspectRequests.size() > 0) {
+    // for (SuspectRequest sr: suspectRequests) {
+    // if (!requests.contains(sr)) {
+    // requests.add(sr);
+    // }
+    // }
+    // suspectRequests.clear();
+    // }
+    // }
-      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e.hasMoreElements();) {
+      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e
+          .hasMoreElements();) {
-      filter.addAll(requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
-      recipients = currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
+      filter.addAll(
+          requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
+      recipients =
+          currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
-    
+
-    
+
-    
+
-    
+
-  
+

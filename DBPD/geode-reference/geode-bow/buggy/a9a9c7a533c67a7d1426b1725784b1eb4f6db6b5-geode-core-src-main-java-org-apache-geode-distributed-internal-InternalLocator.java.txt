GEODE-6825: Cleanup InternalLocator

General cleanup of code and fixup of IDE warnings.

* Minor formatting changes
* Reorder fields: static, final, volatile, mutable
* Rename some fields and vars with more descriptive names
* Change locatorStats field to private final
* Rename LogWriter method parameters
* Remove unnecessary uses of final from local vars
* Remove unnecessary uses of this
* Change getProperties().remove to clearProperty
* Deprecate getlocatorMembershipListener in favor of
  getLocatorMembershipListener
* Extract PrimaryHandler inner class to top level class
* Move non-static inner classes to bottom of outer class
* Make log4j statements use log4j parameters
* Remove old bug system references

+import static org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+import static org.apache.geode.internal.admin.remote.DistributionLocatorId.asDistributionLocatorIds;
-import java.util.HashMap;
-import org.apache.commons.lang3.exception.ExceptionUtils;
-import org.apache.geode.cache.GemFireCache;
-import org.apache.geode.distributed.internal.InternalDistributedSystem.DisconnectListener;
-import org.apache.geode.distributed.internal.tcpserver.TcpHandler;
+ *
+ *
+ *
-      DistributionConfig.GEMFIRE_PREFIX + "disable-floating-coordinator";
-
-  /**
-   * The tcp server responding to locator requests
-   */
-  private final TcpServer server;
-
-  /**
-   * @since GemFire 5.7
-   */
-  private final PrimaryHandler handler;
-
-  /**
-   * The distributed system owned by this locator, if any. Note that if a ds already exists because
-   * the locator is being colocated in a normal member this field will be null.
-   */
-  private InternalDistributedSystem myDs;
-  /**
-   * The cache owned by this locator, if any. Note that if a cache already exists because the
-   * locator is being colocated in a normal member this field will be null.
-   */
-  private InternalCache myCache;
-
-  /**
-   * product use logging
-   */
-  private ProductUseLog productUseLog;
-
-  private boolean peerLocator;
-
-  private ServerLocator serverLocator;
-
-  protected volatile LocatorStats stats;
-
-  private Properties env;
-
-  /**
-   * the TcpHandler used for peer location
-   */
-  private NetLocator locatorImpl;
-
-  private DistributionConfigImpl config;
-
-  private final LocatorMembershipListener locatorListener;
-
-  private WanLocatorDiscoverer locatorDiscoverer;
-
-  /**
-   * whether the locator was stopped during forced-disconnect processing but a reconnect will occur
-   */
-  private volatile boolean stoppedForReconnect;
-
-  private volatile boolean reconnected;
-
-  /**
-   * whether the locator was stopped during forced-disconnect processing
-   */
-  private volatile boolean forcedDisconnect;
-
-  private final AtomicBoolean shutdownHandled = new AtomicBoolean(false);
-
-  private InternalConfigurationPersistenceService configurationPersistenceService;
-
-  private volatile boolean isSharedConfigurationStarted = false;
-
-  private volatile Thread restartThread;
-  private LocatorClusterManagementService clusterManagementService;
-
-  private final LoggingSession loggingSession;
-
-  private final Set<LogConfigListener> logConfigListeners = new HashSet<>();
-
-  public boolean isSharedConfigurationEnabled() {
-    return this.config.getEnableClusterConfiguration();
-  }
-
-  private boolean loadFromSharedConfigDir() {
-    return this.config.getLoadClusterConfigFromDir();
-  }
-
-  public boolean isSharedConfigurationRunning() {
-    return this.configurationPersistenceService != null
-        && this.configurationPersistenceService.getStatus() == SharedConfigurationStatus.RUNNING;
-  }
+      GEMFIRE_PREFIX + "disable-floating-coordinator";
-  // TODO: getLocator() overrides static method of a superclass
+  /**
+   * The tcp server responding to locator requests
+   */
+  private final TcpServer server;
+
+  /**
+   * @since GemFire 5.7
+   */
+  private final PrimaryHandler handler;
+  private final LocatorMembershipListener locatorListener;
+  private final AtomicBoolean shutdownHandled = new AtomicBoolean(false);
+  private final LoggingSession loggingSession;
+  private final Set<LogConfigListener> logConfigListeners = new HashSet<>();
+
+  private final LocatorStats locatorStats;
+
+  /**
+   * whether the locator was stopped during forced-disconnect processing but a reconnect will occur
+   */
+  private volatile boolean stoppedForReconnect;
+  private volatile boolean reconnected;
+
+  /**
+   * whether the locator was stopped during forced-disconnect processing
+   */
+  private volatile boolean forcedDisconnect;
+  private volatile boolean isSharedConfigurationStarted;
+  private volatile Thread restartThread;
+
+  /**
+   * The distributed system owned by this locator, if any. Note that if a ds already exists because
+   * the locator is being colocated in a normal member this field will be null.
+   */
+  private InternalDistributedSystem internalDistributedSystem;
+
+  /**
+   * The cache owned by this locator, if any. Note that if a cache already exists because the
+   * locator is being colocated in a normal member this field will be null.
+   */
+  private InternalCache internalCache;
+
+  /**
+   * product use logging
+   */
+  private ProductUseLog productUseLog;
+  private boolean peerLocator;
+  private ServerLocator serverLocator;
+  private Properties env;
+
+  /**
+   * the TcpHandler used for peer location
+   */
+  private NetLocator netLocator;
+  private DistributionConfigImpl distributionConfig;
+  private WanLocatorDiscoverer locatorDiscoverer;
+  private InternalConfigurationPersistenceService configurationPersistenceService;
+  private LocatorClusterManagementService clusterManagementService;
+
-    // synchronize in order to fix #46336 (race condition in createLocator)
-  // TODO: hasLocator() overrides static method of a superclass
-  public LocatorMembershipListener getlocatorMembershipListener() {
-    return this.locatorListener;
-  }
-
-   * @param logger a log writer that should be used (logFile parameter is ignored)
-   * @param securityLogger the logger to be used for security related log messages
+   * @param logWriter a log writer that should be used (logFile parameter is ignored)
+   * @param securityLogWriter the logWriter to be used for security related log messages
-      InternalLogWriter logger,
-      InternalLogWriter securityLogger,
-      InetAddress bindAddress, String hostnameForClients,
-      Properties distributedSystemProperties,
+      InternalLogWriter logWriter, InternalLogWriter securityLogWriter, InetAddress bindAddress,
+      String hostnameForClients, Properties distributedSystemProperties,
-          new InternalLocator(port, loggingSession, logFile, logger, securityLogger, bindAddress,
+          new InternalLocator(port, loggingSession, logFile, logWriter, securityLogWriter,
+              bindAddress,
+   *
-   * @param logger a log writer that should be used (logFile parameter is ignored)
-   * @param securityLogger the logger to be used for security related log messages
+   * @param logWriter a log writer that should be used (logFile parameter is ignored)
+   * @param securityLogWriter the logWriter to be used for security related log messages
-   * @param dsProperties optional properties to configure the distributed system (e.g., mcast
+   * @param distributedSystemProperties optional properties to configure the distributed system
+   *        (e.g., mcast
-  public static InternalLocator startLocator(int port, File logFile, InternalLogWriter logger,
-      InternalLogWriter securityLogger,
-      InetAddress bindAddress,
-      boolean startDistributedSystem,
-      Properties dsProperties, String hostnameForClients)
-      throws IOException {
+  public static InternalLocator startLocator(int port, File logFile, InternalLogWriter logWriter,
+      InternalLogWriter securityLogWriter, InetAddress bindAddress, boolean startDistributedSystem,
+      Properties distributedSystemProperties, String hostnameForClients) throws IOException {
-      newLocator = createLocator(port, loggingSession, logFile, logger, securityLogger, bindAddress,
-          hostnameForClients, dsProperties, startDistributedSystem);
+      newLocator =
+          createLocator(port, loggingSession, logFile, logWriter, securityLogWriter, bindAddress,
+              hostnameForClients, distributedSystemProperties, startDistributedSystem);
-          final InternalDistributedSystem ids = newLocator.myDs;
-          if (ids != null) {
-            ids.getDistributionManager().addHostedLocators(ids.getDistributedMember(),
+          InternalDistributedSystem system = newLocator.internalDistributedSystem;
+          if (system != null) {
+            system.getDistributionManager().addHostedLocators(system.getDistributedMember(),
-      } catch (final LocatorCancelException lce) {
+      } catch (LocatorCancelException e) {
-        throw lce;
+        throw e;
-      InternalDistributedSystem sys = InternalDistributedSystem.getConnectedInstance();
-      if (sys != null) {
+
+      InternalDistributedSystem system = InternalDistributedSystem.getConnectedInstance();
+      if (system != null) {
-          newLocator.startServerLocation(sys);
+          newLocator.startServerLocation(system);
-      System.getProperties().remove(FORCE_LOCATOR_DM_TYPE);
+      System.clearProperty(FORCE_LOCATOR_DM_TYPE);
-
-  /***
+  /**
-   * @return true if this VM is a locator which should ignore a shutdown , false if it is a normal
+   * @return true if this VM is a locator which should ignore a shutdown, false if it is a normal
-    InternalDistributedSystem ids = internalLocator.myDs;
-    if (ids == null) {
+    InternalDistributedSystem system = internalLocator.internalDistributedSystem;
+    if (system == null) {
-    DistributionManager dm = ids.getDistributionManager();
-    if (dm.isLoner()) {
+    DistributionManager distributionManager = system.getDistributionManager();
+    if (distributionManager.isLoner()) {
-    ClusterDistributionManager distMgr = (ClusterDistributionManager) ids.getDistributionManager();
-    return distMgr.getDMType() == ClusterDistributionManager.LOCATOR_DM_TYPE;
+    ClusterDistributionManager clusterDistributionManager =
+        (ClusterDistributionManager) system.getDistributionManager();
+    return clusterDistributionManager.getDMType() == ClusterDistributionManager.LOCATOR_DM_TYPE;
-   * Creates a new {@code Locator} with the given port, log file, logger, and bind address.
+   * Creates a new {@code Locator} with the given port, log file, logWriter, and bind address.
-   * @param cfg the config if being called from a distributed system; otherwise null.
+   * @param distributionConfig the config if being called from a distributed system; otherwise null.
-      InternalLogWriter logWriter, InternalLogWriter securityLogWriter,
-      InetAddress bindAddress, String hostnameForClients,
-      Properties distributedSystemProperties,
-      DistributionConfigImpl cfg, boolean startDistributedSystem) {
-
+      InternalLogWriter logWriter, InternalLogWriter securityLogWriter, InetAddress bindAddress,
+      String hostnameForClients, Properties distributedSystemProperties,
+      DistributionConfigImpl distributionConfig, boolean startDistributedSystem) {
-    this.config = cfg;
+    this.distributionConfig = distributionConfig;
-    this.env = new Properties();
+    env = new Properties();
-    // value in distributedSystemProperties take precedence (#46870)
+    // value in distributedSystemProperties take precedence
-      this.env.setProperty(BIND_ADDRESS, bindAddress.getHostAddress());
+      env.setProperty(BIND_ADDRESS, bindAddress.getHostAddress());
-      this.env.putAll(distributedSystemProperties);
+      env.putAll(distributedSystemProperties);
-    this.env.setProperty(CACHE_XML_FILE, "");
+    env.setProperty(CACHE_XML_FILE, "");
-    if (this.config == null) {
-      this.config = new DistributionConfigImpl(this.env);
-      this.env.clear();
-      this.env.putAll(this.config.getProps());
+    if (this.distributionConfig == null) {
+      this.distributionConfig = new DistributionConfigImpl(env);
+      env.clear();
+      env.putAll(this.distributionConfig.getProps());
-    final boolean hasLogFileButConfigDoesNot = this.logFile != null && this.config.getLogFile()
-        .toString().equals(DistributionConfig.DEFAULT_LOG_FILE.toString());
+    boolean hasLogFileButConfigDoesNot =
+        this.logFile != null && this.distributionConfig.getLogFile()
+            .toString().equals(DistributionConfig.DEFAULT_LOG_FILE.toString());
-      this.config.unsafeSetLogFile(this.logFile);
+      this.distributionConfig.unsafeSetLogFile(this.logFile);
-    } else {
-      this.loggingSession = loggingSession;
+    this.loggingSession = loggingSession;
-      logWriter = LogWriterFactory.createLogWriterLogger(this.config, false);
+      LogWriterFactory.createLogWriterLogger(this.distributionConfig, false);
-      securityLogWriter = LogWriterFactory.createLogWriterLogger(this.config, true);
+      securityLogWriter = LogWriterFactory.createLogWriterLogger(this.distributionConfig, true);
-    SocketCreatorFactory.setDistributionConfig(this.config);
+    SocketCreatorFactory.setDistributionConfig(this.distributionConfig);
-    this.locatorListener = WANServiceProvider.createLocatorMembershipListener();
-    if (this.locatorListener != null) {
+    locatorListener = WANServiceProvider.createLocatorMembershipListener();
+    if (locatorListener != null) {
-      this.locatorListener.setConfig(getConfig());
+      locatorListener.setConfig(getConfig());
-    this.handler = new PrimaryHandler(this, locatorListener);
+    handler = new PrimaryHandler(this, locatorListener);
-    this.stats = new LocatorStats();
+    locatorStats = new LocatorStats();
-    this.server = new TcpServerFactory().makeTcpServer(port, this.bindAddress, null, this.config,
-        this.handler, new DelayedPoolStatHelper(), this.toString(), this);
+    server = new TcpServerFactory().makeTcpServer(port, this.bindAddress, null,
+        this.distributionConfig, handler, new DelayedPoolStatHelper(), toString(), this);
+  }
+
+  public boolean isSharedConfigurationEnabled() {
+    return distributionConfig.getEnableClusterConfiguration();
+  }
+
+  private boolean loadFromSharedConfigDir() {
+    return distributionConfig.getLoadClusterConfigFromDir();
+  }
+
+  public boolean isSharedConfigurationRunning() {
+    return configurationPersistenceService != null
+        && configurationPersistenceService.getStatus() == SharedConfigurationStatus.RUNNING;
+  }
+
+  public LocatorMembershipListener getLocatorMembershipListener() {
+    return locatorListener;
+  }
+
+  /**
+   * @deprecated Please use {@link #getLocatorMembershipListener()} instead.
+   */
+  @Deprecated
+  public LocatorMembershipListener getlocatorMembershipListener() {
+    return getLocatorMembershipListener();
-    this.server.start();
+    server.start();
-    return this.configurationPersistenceService;
+    return configurationPersistenceService;
-    return this.config;
+    return distributionConfig;
-    if (myCache == null) {
+    if (internalCache == null) {
-    return myCache;
+    return internalCache;
-          String.format("Peer location is already running for %s",
-              this));
+          String.format("Peer location is already running for %s", this));
-    String locatorsProp = this.config.getLocators();
+    String locatorsConfigValue = distributionConfig.getLocators();
-    boolean networkPartitionDetectionEnabled = this.config.getEnableNetworkPartitionDetection();
-    String securityUDPDHAlgo = this.config.getSecurityUDPDHAlgo();
+    boolean networkPartitionDetectionEnabled =
+        distributionConfig.getEnableNetworkPartitionDetection();
+    String securityUDPDHAlgo = distributionConfig.getSecurityUDPDHAlgo();
-      String prop = this.config.getSecurityPeerAuthInit();
+      String prop = distributionConfig.getSecurityPeerAuthInit();
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, locatorsProp,
-        locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats, securityUDPDHAlgo);
-    this.handler.addHandler(PeerLocatorRequest.class, this.locatorImpl);
-    this.peerLocator = true;
-    if (!this.server.isAlive()) {
+    netLocator = MemberFactory.newLocatorHandler(bindAddress, locatorsConfigValue,
+        locatorsAreCoordinators, networkPartitionDetectionEnabled, locatorStats, securityUDPDHAlgo);
+    handler.addHandler(PeerLocatorRequest.class, netLocator);
+    peerLocator = true;
+    if (!server.isAlive()) {
-    int boundPort = this.server.getPort();
+    int boundPort = server.getPort();
-    return this.locatorImpl;
+    return netLocator;
-   * <p>
-   * TODO: parameters peerLocator and serverLocator and b1 are never used
-      InternalLogWriter logger, InternalLogWriter logger1,
-      InetAddress addr,
-      Properties dsProperties, boolean peerLocator,
-      boolean serverLocator, String s, boolean b1)
-      throws IOException {
-    return startLocator(locatorPort, logFile, logger, logger1, addr, true, dsProperties, s);
+      InternalLogWriter logWriter, InternalLogWriter securityLogWriter, InetAddress bindAddress,
+      Properties distributedSystemProperties, boolean peerLocator, boolean serverLocator,
+      String hostnameForClients, boolean b1) throws IOException {
+    return startLocator(locatorPort, logFile, logWriter, securityLogWriter, bindAddress, true,
+        distributedSystemProperties, hostnameForClients);
-      if (this.bindAddress != null) {
-        sb.append(this.bindAddress.getHostAddress());
+      if (bindAddress != null) {
+        sb.append(bindAddress.getHostAddress());
-      if (this.peerLocator) {
+      if (peerLocator) {
-        // this.logger.config("ensuring that this locator is in the locators list");
-        String locatorsProp = this.config.getLocators();
-        if (StringUtils.isNotBlank(locatorsProp)) {
-          if (!locatorsProp.contains(thisLocator)) {
-            locatorsProp = locatorsProp + ',' + thisLocator;
+        String locatorsConfigValue = distributionConfig.getLocators();
+        if (StringUtils.isNotBlank(locatorsConfigValue)) {
+          if (!locatorsConfigValue.contains(thisLocator)) {
+            locatorsConfigValue = locatorsConfigValue + ',' + thisLocator;
-          locatorsProp = thisLocator;
+          locatorsConfigValue = thisLocator;
-          updateEnv.setProperty(LOCATORS, locatorsProp);
-          this.config.setApiProps(updateEnv);
-          // fix for bug 41248
-          String propName = DistributionConfig.GEMFIRE_PREFIX + LOCATORS;
-          if (System.getProperty(propName) != null) {
-            System.setProperty(propName, locatorsProp);
+          updateEnv.setProperty(LOCATORS, locatorsConfigValue);
+          distributionConfig.setApiProps(updateEnv);
+          String locatorsPropertyName = GEMFIRE_PREFIX + LOCATORS;
+          if (System.getProperty(locatorsPropertyName) != null) {
+            System.setProperty(locatorsPropertyName, locatorsConfigValue);
-        // No longer default mcast-port to zero. See 46277.
+        // No longer default mcast-port to zero.
-      Properties connectEnv = new Properties();
+      Properties distributedSystemProperties = new Properties();
-      connectEnv.put(DistributionConfig.DS_CONFIG_NAME, this.config);
+      distributedSystemProperties.put(DistributionConfig.DS_CONFIG_NAME, distributionConfig);
-      this.myDs = (InternalDistributedSystem) DistributedSystem.connect(connectEnv);
+      internalDistributedSystem =
+          (InternalDistributedSystem) DistributedSystem.connect(distributedSystemProperties);
-      if (this.peerLocator) {
-        this.locatorImpl.setMembershipManager(this.myDs.getDM().getMembershipManager());
+      if (peerLocator) {
+        netLocator.setMembershipManager(internalDistributedSystem.getDM().getMembershipManager());
-      this.myDs.addDisconnectListener(new DisconnectListener() {
-        @Override
-        public void onDisconnect(InternalDistributedSystem sys) {
-          stop(false, false, false);
-        }
-      });
+      internalDistributedSystem.addDisconnectListener(sys -> stop(false, false, false));
-      startCache(myDs);
+      startCache(internalDistributedSystem);
-      logger.info("Locator started on {}",
-          thisLocator);
+      logger.info("Locator started on {}", thisLocator);
-      myDs.setDependentLocator(this);
+      internalDistributedSystem.setDependentLocator(this);
-  private void startCache(DistributedSystem ds) {
+  private void startCache(DistributedSystem system) {
-      this.myCache = new InternalCacheBuilder(ds.getProperties())
-          .create((InternalDistributedSystem) ds);
-      internalCache = this.myCache;
+      this.internalCache = new InternalCacheBuilder(system.getProperties())
+          .create((InternalDistributedSystem) system);
+      internalCache = this.internalCache;
-      ((InternalDistributedSystem) ds).handleResourceEvent(ResourceEvent.LOCATOR_START, this);
+      ((InternalDistributedSystem) system).handleResourceEvent(ResourceEvent.LOCATOR_START, this);
-    if (myCache == null) {
+    if (internalCache == null) {
-    clusterManagementService =
-        new LocatorClusterManagementService(locator.myCache,
-            locator.configurationPersistenceService);
+    clusterManagementService = new LocatorClusterManagementService(locator.internalCache,
+        locator.configurationPersistenceService);
+
-    final String gemfireManagementWar = agentUtil.findWarLocation("geode-web-management");
+    String gemfireManagementWar = agentUtil.findWarLocation("geode-web-management");
-    Pair<String, Object> securityServiceAttr =
+    Pair<String, Object> securityServiceAttribute =
-            myCache.getSecurityService());
-    Pair<String, Object> cmServiceAttr =
+            internalCache.getSecurityService());
+    Pair<String, Object> clusterManagementServiceAttribute =
-      logger.info(
-          "System Property " + ClusterManagementService.FEATURE_FLAG
-              + "=true Geode Management API is enabled.");
-      myCache.getHttpService().ifPresent(x -> {
+      logger.info("System Property {}=true Geode Management API is enabled.",
+          ClusterManagementService.FEATURE_FLAG);
+      internalCache.getHttpService().ifPresent(x -> {
-          x.addWebApplication("/management", gemfireManagementWar, securityServiceAttr,
-              cmServiceAttr);
+          x.addWebApplication("/management", gemfireManagementWar, securityServiceAttribute,
+              clusterManagementServiceAttribute);
-      logger.info(
-          "System Property " + ClusterManagementService.FEATURE_FLAG
-              + "=false Geode Management API is disabled.");
+      logger.info("System Property {}=false Geode Management API is disabled.",
+          ClusterManagementService.FEATURE_FLAG);
-    this.env = null;
+    env = null;
+
+
-    this.locatorDiscoverer = WANServiceProvider.createLocatorDiscoverer();
-    if (this.locatorDiscoverer != null) {
-      this.locatorDiscoverer.discover(getPort(), this.config, this.locatorListener,
-          this.hostnameForClients);
+    locatorDiscoverer = WANServiceProvider.createLocatorDiscoverer();
+    if (locatorDiscoverer != null) {
+      locatorDiscoverer.discover(getPort(), distributionConfig, locatorListener,
+          hostnameForClients);
-          String.format("Server location is already running for %s",
-              this));
+          String.format("Server location is already running for %s", this));
-    ServerLocator serverLocator =
-        new ServerLocator(getPort(), this.bindAddress, this.hostnameForClients, this.logFile,
-            this.productUseLog, getConfig().getName(), distributedSystem, this.stats);
-    this.handler.addHandler(LocatorListRequest.class, serverLocator);
-    this.handler.addHandler(ClientConnectionRequest.class, serverLocator);
-    this.handler.addHandler(QueueConnectionRequest.class, serverLocator);
-    this.handler.addHandler(ClientReplacementRequest.class, serverLocator);
-    this.handler.addHandler(GetAllServersRequest.class, serverLocator);
-    this.handler.addHandler(LocatorStatusRequest.class, serverLocator);
+    ServerLocator serverLocator = new ServerLocator(getPort(), bindAddress, hostnameForClients,
+        logFile, productUseLog, getConfig().getName(), distributedSystem, locatorStats);
+    handler.addHandler(LocatorListRequest.class, serverLocator);
+    handler.addHandler(ClientConnectionRequest.class, serverLocator);
+    handler.addHandler(QueueConnectionRequest.class, serverLocator);
+    handler.addHandler(ClientReplacementRequest.class, serverLocator);
+    handler.addHandler(GetAllServersRequest.class, serverLocator);
+    handler.addHandler(LocatorStatusRequest.class, serverLocator);
-    if (!this.server.isAlive()) {
+    if (!server.isAlive()) {
-    this.productUseLog.monitorUse(distributedSystem);
+    productUseLog.monitorUse(distributedSystem);
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+    boolean isDebugEnabled = logger.isDebugEnabled();
-    this.stoppedForReconnect = stopForReconnect;
+    stoppedForReconnect = stopForReconnect;
-    if (this.server.isShuttingDown()) {
+    if (server.isShuttingDown()) {
-        if (isDebugEnabled && this.server.isAlive()) {
+        if (isDebugEnabled && server.isAlive()) {
-        while (this.server.isAlive() && System.currentTimeMillis() < endOfWait) {
+
+        while (server.isAlive() && System.currentTimeMillis() < endOfWait) {
+
-          if (this.server.isAlive()) {
+          if (server.isAlive()) {
-    if (this.locatorDiscoverer != null) {
-      this.locatorDiscoverer.stop();
-      this.locatorDiscoverer = null;
+    if (locatorDiscoverer != null) {
+      locatorDiscoverer.stop();
+      locatorDiscoverer = null;
-    if (this.server.isAlive()) {
+    if (server.isAlive()) {
-        new TcpClient().stop(this.bindAddress, getPort());
+        new TcpClient().stop(bindAddress, getPort());
+
-        this.server.join(TcpServer.SHUTDOWN_WAIT_TIME * 2);
+        server.join(TcpServer.SHUTDOWN_WAIT_TIME * 2);
-        logger.warn("Interrupted while stopping " + this, ex);
+        logger.warn("Interrupted while stopping {}", this, ex);
-      if (this.server.isAlive()) {
+      if (server.isAlive()) {
-    if (this.stoppedForReconnect) {
-      if (this.myDs != null) {
+    if (stoppedForReconnect) {
+      if (internalDistributedSystem != null) {
-    return this.server == null || !this.server.isAlive();
+    return server == null || !server.isAlive();
-  private void handleShutdown() {
-    if (!this.shutdownHandled.compareAndSet(false, true)) {
-      return; // already shutdown
+  void handleShutdown() {
+    if (!shutdownHandled.compareAndSet(false, true)) {
+      // already shutdown
+      return;
-    if (this.productUseLog != null) {
-      this.productUseLog.close();
+    if (productUseLog != null) {
+      productUseLog.close();
-    if (this.myDs != null) {
-      this.myDs.setDependentLocator(null);
+    if (internalDistributedSystem != null) {
+      internalDistributedSystem.setDependentLocator(null);
-    if (this.myCache != null && !this.stoppedForReconnect && !this.forcedDisconnect) {
+    if (internalCache != null && !stoppedForReconnect && !forcedDisconnect) {
-        this.myCache.close();
+        internalCache.close();
-    if (this.stats != null) {
-      this.stats.close();
+    if (locatorStats != null) {
+      locatorStats.close();
-    if (this.locatorListener != null) {
-      this.locatorListener.clearLocatorInfo();
+    if (locatorListener != null) {
+      locatorListener.clearLocatorInfo();
-    this.isSharedConfigurationStarted = false;
-    if (this.myDs != null && !this.forcedDisconnect) {
-      if (this.myDs.isConnected()) {
+    isSharedConfigurationStarted = false;
+    if (internalDistributedSystem != null && !forcedDisconnect) {
+      if (internalDistributedSystem.isConnected()) {
-        this.myDs.disconnect();
+        internalDistributedSystem.disconnect();
-      DistributedSystem ds = this.myDs;
+      DistributedSystem system = internalDistributedSystem;
-      this.server.join();
-      if (this.stoppedForReconnect) {
+      server.join();
+      if (stoppedForReconnect) {
-        while (ds.isConnected()) {
+        while (system.isConnected()) {
-          restarted = ds.waitUntilReconnected(-1, TimeUnit.SECONDS);
+          restarted = system.waitUntilReconnected(-1, TimeUnit.SECONDS);
-    this.restartThread = new LoggingThread(threadName, () -> {
+    restartThread = new LoggingThread(threadName, () -> {
-      InternalLocator.this.restartThread = null;
+      restartThread = null;
-    this.restartThread.start();
+    restartThread.start();
-    if (this.stoppedForReconnect) {
+    if (stoppedForReconnect) {
-      InternalDistributedSystem ds = this.myDs;
-      long waitTime = ds.getConfig().getMaxWaitTimeForReconnect() / 2;
-      QuorumChecker checker = null;
-      while (ds.getReconnectedSystem() == null && !ds.isReconnectCancelled()) {
-        if (checker == null) {
-          checker = this.myDs.getQuorumChecker();
-          if (checker != null) {
-            logger.info("The distributed system returned this quorum checker: {}", checker);
+      InternalDistributedSystem system = internalDistributedSystem;
+      long waitTime = system.getConfig().getMaxWaitTimeForReconnect() / 2;
+      QuorumChecker quorumChecker = null;
+
+      while (system.getReconnectedSystem() == null && !system.isReconnectCancelled()) {
+        if (quorumChecker == null) {
+          quorumChecker = internalDistributedSystem.getQuorumChecker();
+          if (quorumChecker != null) {
+            logger.info("The distributed system returned this quorum checker: {}", quorumChecker);
-        if (checker != null && !tcpServerStarted) {
-          boolean start = checker.checkForQuorum(3L * this.myDs.getConfig().getMemberTimeout());
+
+        if (quorumChecker != null && !tcpServerStarted) {
+          boolean start = quorumChecker
+              .checkForQuorum(3L * internalDistributedSystem.getConfig().getMemberTimeout());
-            // start up peer location. server location is started after the DS finishes
-            // reconnecting
+            // start up peer location. server location is started after the DS finishes reconnecting
-            if (this.locatorListener != null) {
-              this.locatorListener.clearLocatorInfo();
+            if (locatorListener != null) {
+              locatorListener.clearLocatorInfo();
-            this.stoppedForReconnect = false;
-            this.myDs = null;
-            this.myCache = null;
-            restartWithoutDS();
+            stoppedForReconnect = false;
+            internalDistributedSystem = null;
+            internalCache = null;
+            restartWithoutSystem();
+
-          ds.waitUntilReconnected(waitTime, TimeUnit.MILLISECONDS);
+          system.waitUntilReconnected(waitTime, TimeUnit.MILLISECONDS);
-          this.stoppedForReconnect = false;
+          stoppedForReconnect = false;
-      InternalDistributedSystem newSystem = (InternalDistributedSystem) ds.getReconnectedSystem();
+
+      InternalDistributedSystem newSystem =
+          (InternalDistributedSystem) system.getReconnectedSystem();
-          if (this.locatorListener != null) {
-            this.locatorListener.clearLocatorInfo();
+          if (locatorListener != null) {
+            locatorListener.clearLocatorInfo();
-          this.stoppedForReconnect = false;
+          stoppedForReconnect = false;
+
-          restartWithDS(newSystem, GemFireCacheImpl.getInstance());
+          restartWithSystem(newSystem, GemFireCacheImpl.getInstance());
-          this.stoppedForReconnect = true;
+          stoppedForReconnect = true;
+
+
-  private void restartWithoutDS() throws IOException {
+  private void restartWithoutSystem() throws IOException {
-      this.myDs = null;
-      this.myCache = null;
+      internalDistributedSystem = null;
+      internalCache = null;
+
-      this.server.restarting(null, null, null);
-      if (this.productUseLog.isClosed()) {
-        this.productUseLog.reopen();
+      server.restarting(null, null, null);
+
+      if (productUseLog.isClosed()) {
+        productUseLog.reopen();
-      if (!this.server.isAlive()) {
+
+      if (!server.isAlive()) {
-  private void restartWithDS(InternalDistributedSystem newSystem, InternalCache newCache)
+  private void restartWithSystem(InternalDistributedSystem newSystem, InternalCache newCache)
-
-      this.myDs = newSystem;
-      this.myCache = newCache;
-      this.myDs.setDependentLocator(this);
+      internalDistributedSystem = newSystem;
+      internalCache = newCache;
+      internalDistributedSystem.setDependentLocator(this);
-        this.server.restarting(newSystem, newCache, this.configurationPersistenceService);
+        server.restarting(newSystem, newCache, configurationPersistenceService);
-        this.myDs = null;
-        this.myCache = null;
+        internalDistributedSystem = null;
+        internalCache = null;
-      if (this.productUseLog.isClosed()) {
-        this.productUseLog.reopen();
+
+      if (productUseLog.isClosed()) {
+        productUseLog.reopen();
-      this.productUseLog.monitorUse(newSystem);
+
+      productUseLog.monitorUse(newSystem);
+
-        this.configurationPersistenceService =
+        configurationPersistenceService =
-      if (!this.server.isAlive()) {
+
+      if (!server.isAlive()) {
+
-      endStartLocator(this.myDs);
+      endStartLocator(internalDistributedSystem);
-    this.server.restartCompleted(newSystem);
+    server.restartCompleted(newSystem);
-    if (myDs == null) {
+    if (internalDistributedSystem == null) {
-    return myDs;
+    return internalDistributedSystem;
-    return this.peerLocator;
+    return peerLocator;
-    return this.serverLocator != null;
+    return serverLocator != null;
-    return this.serverLocator;
+    return serverLocator;
-    if (this.server != null) {
-      return this.server.getPort();
+    if (server != null) {
+      return server.getPort();
-    return config;
+    return distributionConfig;
-    return config;
+    return distributionConfig;
-  /**
-   * Apparently nothing provides RuntimeDistributionConfigImpl behavior in a stand-alone locator
-   * (without DS), so there are currently no callers of {@code logConfigChanged()}. Keep it?
-   */
-  @SuppressWarnings("unused")
-  void logConfigChanged() {
-    for (LogConfigListener listener : logConfigListeners) {
-      listener.configChanged();
-    }
-  }
-
-  class FetchSharedConfigStatus implements Callable<SharedConfigurationStatusResponse> {
-
-    static final int SLEEPTIME = 1000;
-    static final byte MAX_RETRIES = 5;
-
-    @Override
-    public SharedConfigurationStatusResponse call() throws InterruptedException {
-      final InternalLocator locator = InternalLocator.this;
-
-      SharedConfigurationStatusResponse response;
-      if (locator.configurationPersistenceService != null) {
-        response = locator.configurationPersistenceService.createStatusResponse();
-      } else {
-        response = new SharedConfigurationStatusResponse();
-        response.setStatus(SharedConfigurationStatus.UNDETERMINED);
-      }
-      return response;
-    }
-  }
-
-    ExecutorService es = this.myCache.getDistributionManager().getWaitingThreadPool();
+    ExecutorService waitingPoolExecutor =
+        internalCache.getDistributionManager().getWaitingThreadPool();
-        es.submit(new FetchSharedConfigStatus());
+        waitingPoolExecutor.submit(new FetchSharedConfigStatus());
-      logger.info("Exception occurred while fetching the status {}",
-          ExceptionUtils.getStackTrace(e));
+      logger.info("Exception occurred while fetching the status {}", getStackTrace(e));
-  public static class PrimaryHandler implements TcpHandler {
-
-    private volatile HashMap<Class, TcpHandler> handlerMapping = new HashMap<>();
-    private volatile HashSet<TcpHandler> allHandlers = new HashSet<>();
-    private TcpServer tcpServer;
-    private final LocatorMembershipListener locatorListener;
-    private final InternalLocator internalLocator;
-
-    PrimaryHandler(InternalLocator locator, LocatorMembershipListener listener) {
-      this.locatorListener = listener;
-      this.internalLocator = locator;
-    }
-
-    // this method is synchronized to make sure that no new handlers are added while
-    // initialization is taking place.
-    @Override
-    public synchronized void init(TcpServer tcpServer) {
-      if (this.locatorListener != null) {
-        // This is deferred until now as the initial requested port could have been 0
-        this.locatorListener.setPort(this.internalLocator.getPort());
-      }
-      this.tcpServer = tcpServer;
-      for (TcpHandler handler : this.allHandlers) {
-        handler.init(tcpServer);
-      }
-    }
-
-    @Override
-    public void restarting(DistributedSystem ds, GemFireCache cache,
-        InternalConfigurationPersistenceService sharedConfig) {
-      if (ds != null) {
-        for (TcpHandler handler : this.allHandlers) {
-          handler.restarting(ds, cache, sharedConfig);
-        }
-      }
-    }
-
-    @Override
-    public void restartCompleted(DistributedSystem ds) {
-      if (ds != null) {
-        for (TcpHandler handler : this.allHandlers) {
-          handler.restartCompleted(ds);
-        }
-      }
-    }
-
-    @Override
-    public Object processRequest(Object request) throws IOException {
-      long giveup = 0;
-      while (giveup == 0 || System.currentTimeMillis() < giveup) {
-        TcpHandler handler;
-        if (request instanceof PeerLocatorRequest) {
-          handler = this.handlerMapping.get(PeerLocatorRequest.class);
-        } else {
-          handler = this.handlerMapping.get(request.getClass());
-        }
-
-        if (handler != null) {
-          return handler.processRequest(request);
-        } else {
-          if (this.locatorListener != null) {
-            return this.locatorListener.handleRequest(request);
-          } else {
-            // either there is a configuration problem or the locator is still starting up
-            if (giveup == 0) {
-              int locatorWaitTime = this.internalLocator.getConfig().getLocatorWaitTime();
-              if (locatorWaitTime <= 0) {
-                // always retry some number of times
-                locatorWaitTime = 30;
-              }
-              giveup = System.currentTimeMillis() + locatorWaitTime * 1000L;
-              try {
-                Thread.sleep(1000);
-              } catch (InterruptedException ignored) {
-                // running in an executor - no need to set the interrupted flag on the thread
-                return null;
-              }
-            }
-          }
-        }
-      } // while
-      logger.info(
-          "Received a location request of class {} but the handler for this is "
-              + "either not enabled or is not ready to process requests",
-          request.getClass().getSimpleName());
-      return null;
-    }
-
-    @Override
-    public void shutDown() {
-      try {
-        for (TcpHandler handler : this.allHandlers) {
-          handler.shutDown();
-        }
-      } finally {
-        this.internalLocator.handleShutdown();
-      }
-    }
-
-    synchronized boolean isHandled(Class clazz) {
-      return this.handlerMapping.containsKey(clazz);
-    }
-
-    public synchronized void addHandler(Class clazz, TcpHandler handler) {
-      HashMap<Class, TcpHandler> tmpHandlerMapping = new HashMap<>(this.handlerMapping);
-      HashSet<TcpHandler> tmpAllHandlers = new HashSet<>(this.allHandlers);
-      tmpHandlerMapping.put(clazz, handler);
-      if (tmpAllHandlers.add(handler) && this.tcpServer != null) {
-        handler.init(this.tcpServer);
-      }
-      this.handlerMapping = tmpHandlerMapping;
-      this.allHandlers = tmpAllHandlers;
-    }
-
-    @Override
-    public void endRequest(Object request, long startTime) {
-      TcpHandler handler = this.handlerMapping.get(request.getClass());
-      if (handler != null) {
-        handler.endRequest(request, startTime);
-      }
-    }
-
-    @Override
-    public void endResponse(Object request, long startTime) {
-      TcpHandler handler = this.handlerMapping.get(request.getClass());
-      if (handler != null) {
-        handler.endResponse(request, startTime);
-      }
-    }
-  }
-
-      this.stats.hookupStats(sys,
-          SocketCreator.getLocalHost().getCanonicalHostName() + '-' + this.server.getBindAddress());
+      locatorStats.hookupStats(sys,
+          SocketCreator.getLocalHost().getCanonicalHostName() + '-' + server.getBindAddress());
-      Collection<DistributionLocatorId> locatorIds =
-          DistributionLocatorId.asDistributionLocatorIds(getLocators());
+      Collection<DistributionLocatorId> locatorIds = asDistributionLocatorIds(getLocators());
-    } else {
-      return locatorStrings;
-  }
-
-  /**
-   * A helper object so that the TcpServer can record its stats to the proper place. Stats are only
-   * recorded if a distributed system is started.
-   */
-  protected class DelayedPoolStatHelper implements PoolStatHelper {
-    @Override
-    public void startJob() {
-      stats.incRequestInProgress(1);
-
-    }
-
-    @Override
-    public void endJob() {
-      stats.incRequestInProgress(-1);
-    }
+    return locatorStrings;
-
-    if (!config.getEnableClusterConfiguration()) {
+    if (!distributionConfig.getEnableClusterConfiguration()) {
-    if (!config.getJmxManager()) {
+    if (!distributionConfig.getJmxManager()) {
-      logger.info("Cluster configuration service not enabled as it is only supported "
-          + "in dedicated locators");
+      logger.info(
+          "Cluster configuration service not enabled as it is only supported in dedicated locators");
-        // locator.configurationPersistenceService will already be created in case of auto-reconnect
+        // configurationPersistenceService will already be created in case of auto-reconnect
-            new InternalConfigurationPersistenceService(locator.myCache);
+            new InternalConfigurationPersistenceService(locator.internalCache);
-      if (!this.handler.isHandled(JmxManagerLocatorRequest.class)) {
-        this.handler.addHandler(JmxManagerLocatorRequest.class,
+      if (!handler.isHandled(JmxManagerLocatorRequest.class)) {
+        handler.addHandler(JmxManagerLocatorRequest.class,
-    if (!this.handler.isHandled(SharedConfigurationStatusRequest.class)) {
-      this.handler.addHandler(SharedConfigurationStatusRequest.class,
+    if (!handler.isHandled(SharedConfigurationStatusRequest.class)) {
+      handler.addHandler(SharedConfigurationStatusRequest.class,
-    if (!this.handler.isHandled(ClusterManagementServiceInfoRequest.class)) {
-      this.handler.addHandler(ClusterManagementServiceInfoRequest.class,
+    if (!handler.isHandled(ClusterManagementServiceInfoRequest.class)) {
+      handler.addHandler(ClusterManagementServiceInfoRequest.class,
-    return this.handler.isHandled(messageClass);
+    return handler.isHandled(messageClass);
+  class FetchSharedConfigStatus implements Callable<SharedConfigurationStatusResponse> {
+
+    @Override
+    public SharedConfigurationStatusResponse call() throws InterruptedException {
+      InternalLocator locator = InternalLocator.this;
+
+      SharedConfigurationStatusResponse response;
+      if (locator.configurationPersistenceService != null) {
+        response = locator.configurationPersistenceService.createStatusResponse();
+      } else {
+        response = new SharedConfigurationStatusResponse();
+        response.setStatus(SharedConfigurationStatus.UNDETERMINED);
+      }
+      return response;
+    }
+  }
+
+  /**
+   * A helper object so that the TcpServer can record its stats to the proper place. Stats are only
+   * recorded if a distributed system is started.
+   */
+  protected class DelayedPoolStatHelper implements PoolStatHelper {
+
+    @Override
+    public void startJob() {
+      locatorStats.incRequestInProgress(1);
+
+    }
+
+    @Override
+    public void endJob() {
+      locatorStats.incRequestInProgress(-1);
+    }
+  }

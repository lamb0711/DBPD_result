[GEODE-2324] keep private variables private.

* Update AcceptorImplDUnit test,
* Refactor AcceptorImpl.close into multiple methods.
* Remove a commented-out method.

-import org.apache.geode.internal.cache.tier.sockets.command.AcceptorImplObserver;
-  private volatile boolean shutdown = false;
+  private volatile boolean shutdownStarted = false;
-  // Assumed non-null. Do not set this to null.
-  private static AcceptorImplObserver acceptorImplObserver_do_not_access_directly =
-      new AcceptorImplObserver() {
-        @Override
-        public void beforeClose(AcceptorImpl acceptorImpl) {}
-
-        @Override
-        public void normalCloseTermination(AcceptorImpl acceptorImpl) {}
-
-        @Override
-        public void afterClose(AcceptorImpl acceptorImpl) {}
-      };
-
-  private static AcceptorImplObserver getAcceptorImplObserver() {
-    synchronized (AcceptorImpl.class) {
-      return acceptorImplObserver_do_not_access_directly;
-    }
-  }
-
-  public static void setObserver_TESTONLY(AcceptorImplObserver observer) {
-    synchronized (AcceptorImpl.class) {
-      if (observer != null) {
-        acceptorImplObserver_do_not_access_directly = observer;
-      }
-    }
-  }
-
-    return !this.shutdown;
+    return !this.shutdownStarted;
-    AcceptorImplObserver acceptorImplObserver = getAcceptorImplObserver();
-        acceptorImplObserver.beforeClose(this);
-        this.shutdown = true;
+        this.shutdownStarted = true;
-          // Well, we tried. Continue shutting down.
+
-        if (isSelector()) {
-          this.hsTimer.cancel();
-          if (this.tmpSel != null) {
-            try {
-              this.tmpSel.close();
-            } catch (IOException ignore) {
-            }
-          }
-          try {
-            wakeupSelector();
-            this.selector.close();
-          } catch (IOException ignore) {
-          }
-          if (this.selectorThread != null) {
-            this.selectorThread.interrupt();
-          }
-          this.commBufferQueue.clear();
-        }
+        shutdownSelectorIfIsSelector();
-        this.pool.shutdown();
-
-        try {
-          if (!this.pool.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
-            this.pool.shutdownNow();
-          }
-        } catch (InterruptedException ignore) {
-          Thread.currentThread().interrupt();
-          this.pool.shutdownNow();
-        }
-        this.hsPool.shutdownNow();
+        shutdownPools();
-        GemFireCacheImpl myCache = (GemFireCacheImpl) cache;
-        if (!myCache.forcedDisconnect()) {
-          Set<PartitionedRegion> prs = myCache.getPartitionedRegions();
-          for (PartitionedRegion pr : prs) {
-            Map<Integer, BucketAdvisor.BucketProfile> profiles =
-                new HashMap<Integer, BucketAdvisor.BucketProfile>();
-            // get all local real bucket advisors
-            Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
-            for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
-              BucketAdvisor advisor = entry.getValue();
-              BucketProfile bp = (BucketProfile) advisor.createProfile();
-              advisor.updateServerBucketProfile(bp);
-              profiles.put(entry.getKey(), bp);
-            }
-            Set receipients = new HashSet();
-            receipients = pr.getRegionAdvisor().adviseAllPRNodes();
-            // send it to all in one messgae
-            ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(receipients,
-                pr.getDistributionManager(), pr.getPRId(), profiles, true);
-            if (reply != null) {
-              reply.waitForRepliesUninterruptibly();
-            }
-
-            if (logger.isDebugEnabled()) {
-              logger.debug("sending messages to all peers for removing this server..");
-            }
-          }
-        }
-        acceptorImplObserver.normalCloseTermination(this);
+        notifyCacheMembersOfClose();
-    } finally {
-      acceptorImplObserver.afterClose(this);
+  private void notifyCacheMembersOfClose() {
+    GemFireCacheImpl myCache = (GemFireCacheImpl) cache;
+    if (!myCache.forcedDisconnect()) {
+      for (PartitionedRegion pr : myCache.getPartitionedRegions()) {
+        Map<Integer, BucketAdvisor.BucketProfile> profiles = new HashMap<>();
+        // get all local real bucket advisors
+        Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
+        for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
+          BucketAdvisor advisor = entry.getValue();
+          BucketProfile bp = (BucketProfile) advisor.createProfile();
+          advisor.updateServerBucketProfile(bp);
+          profiles.put(entry.getKey(), bp);
+        }
+
+        Set recipients = pr.getRegionAdvisor().adviseAllPRNodes();
+        // send it to all in one message
+        ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(recipients,
+            pr.getDistributionManager(), pr.getPRId(), profiles, true);
+        if (reply != null) {
+          reply.waitForRepliesUninterruptibly();
+        }
+
+        if (logger.isDebugEnabled()) {
+          logger.debug("sending messages to all peers for removing this server..");
+        }
+      }
+    }
+  }
+
+  private void shutdownSelectorIfIsSelector() {
+    if (isSelector()) {
+      this.hsTimer.cancel();
+      if (this.tmpSel != null) {
+        try {
+          this.tmpSel.close();
+        } catch (IOException ignore) {
+        }
+      }
+      try {
+        wakeupSelector();
+        this.selector.close();
+      } catch (IOException ignore) {
+      }
+      if (this.selectorThread != null) {
+        this.selectorThread.interrupt();
+      }
+      this.commBufferQueue.clear();
+    }
+  }
+
+  private void shutdownPools() {
+    this.pool.shutdown();
+    try {
+      if (!this.pool.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
+        this.pool.shutdownNow();
+      }
+    } catch (InterruptedException ignore) {
+      Thread.currentThread().interrupt();
+      this.pool.shutdownNow();
+    }
+    this.hsPool.shutdownNow();
+  }
+
+  public boolean isShutdownProperly() {
+    return !isRunning() && (selectorThread == null || !selectorThread.isAlive())
+        && (pool == null || pool.isShutdown()) && (hsPool == null || hsPool.isShutdown())
+        && (selector == null || !selector.isOpen());
+  }
-  // protected InetAddress getBindAddress() {
-  // return this.bindAddress;
-  // }
-
-  // /**
-  // * Calculates the bind address based on gemfire.properties.
-  // * Returns null if no bind address is configured.
-  // * @since GemFire 5.7
-  // */
-  // public static InetAddress calcBindAddress(Cache cache) throws IOException {
-  // InternalDistributedSystem system = (InternalDistributedSystem)cache
-  // .getDistributedSystem();
-  // DistributionConfig config = system.getConfig();
-  // InetAddress address = null;
-
-  // // Get the server-bind-address. If it is not null, use it.
-  // // If it is null, get the bind-address. If it is not null, use it.
-  // // Otherwise set default.
-  // String serverBindAddress = config.getServerBindAddress();
-  // if (serverBindAddress != null && serverBindAddress.length() > 0) {
-  // address = InetAddress.getByName(serverBindAddress);
-  // } else {
-  // String bindAddress = config.getBindAddress();
-  // if (bindAddress != null && bindAddress.length() > 0) {
-  // address = InetAddress.getByName(bindAddress);
-  // }
-  // }
-  // return address;
-  // }

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import org.apache.geode.*;
-import org.apache.geode.cache.*;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.ConcurrentModificationException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.CancelException;
+import org.apache.geode.InternalGemFireError;
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.StatisticsFactory;
+import org.apache.geode.SystemFailure;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.CacheException;
+import org.apache.geode.cache.CacheListener;
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.CustomExpiry;
+import org.apache.geode.cache.EntryEvent;
+import org.apache.geode.cache.EntryNotFoundException;
+import org.apache.geode.cache.ExpirationAction;
+import org.apache.geode.cache.ExpirationAttributes;
+import org.apache.geode.cache.MirrorType;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.internal.cache.*;
-import org.apache.geode.internal.cache.tier.sockets.*;
+import org.apache.geode.internal.cache.CacheServerImpl;
+import org.apache.geode.internal.cache.Conflatable;
+import org.apache.geode.internal.cache.EventID;
+import org.apache.geode.internal.cache.HARegion;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.RegionQueue;
+import org.apache.geode.internal.cache.tier.sockets.CacheClientNotifier;
+import org.apache.geode.internal.cache.tier.sockets.ClientMarkerMessageImpl;
+import org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID;
+import org.apache.geode.internal.cache.tier.sockets.ClientUpdateMessage;
+import org.apache.geode.internal.cache.tier.sockets.ClientUpdateMessageImpl;
+import org.apache.geode.internal.cache.tier.sockets.HAEventWrapper;
+import org.apache.geode.internal.cache.tier.sockets.HandShake;
-import org.apache.logging.log4j.Logger;
-
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.io.Serializable;
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.locks.*;
- * strucure called haContainer (an implementation of Map). The value against this wrapper will be
+ * structure called haContainer (an implementation of Map). The value against this wrapper will be
- * 
- * 
-  /** The <code>Region</code> backing this queue */
+  /** The {@code Region} backing this queue */
-   * The key into the <code>Region</code> used when putting entries onto the queue. The counter uses
+   * The key into the {@code Region} used when putting entries onto the queue. The counter uses
-   * 
-
-   * The <code>Map</code> mapping the regionName->key to the queue key. This index allows fast
-   * updating of entries in the queue for conflation.
+   * The {@code Map} mapping the regionName->key to the queue key. This index allows fast updating
+   * of entries in the queue for conflation.
-  // TODO:Asif: Should we worry about whether to some how make it writer
-  // preference?
-  /** Lock object for updating the queue size by different operations */
-  // private final Object SIZE_LOCK = new Object();
-  /** The name of the <code>Region</code> backing this queue */
+  /** The name of the {@code Region} backing this queue */
-   * voiolations can be expected , but should be analyzed thoroughly.
-   * 
-   * <p>
-   * author Asif
+   * violations can be expected , but should be analyzed thoroughly.
-   * When <code>remove()</code> will be called, these events stored in thread-local will be
-   * destroyed.
+   * When {@code remove()} will be called, these events stored in thread-local will be destroyed.
-   * Thread which creates the <code>QueueRemovalMessage</code> and sends it to other nodes in the
-   * system
+   * Thread which creates the {@code QueueRemovalMessage} and sends it to other nodes in the system
-   * 
-   * @param regionName
-    String result = regionName.replace('/', '#'); // [yogi]: region name cannot
-    // contain the separator '/'
-    return result;
+    return regionName.replace('/', '#');
-   * 
-   * @param regionName
-   * @param cache
-   * @throws IOException
-   * @throws ClassNotFoundException
-   * @throws CacheException
-   * @throws InterruptedException
-
-  protected HARegionQueue(String regionName, GemFireCacheImpl cache,
+  protected HARegionQueue(String regionName, InternalCache cache,
-    this.putGIIDataInRegion();
+    putGIIDataInRegion();
-  private void createHARegion(String processedRegionName, GemFireCacheImpl cache)
+  private void createHARegion(String processedRegionName, InternalCache cache)
-    GemFireCacheImpl cache = this.region.getCache();
+    InternalCache cache = this.region.getCache();
-          sb.append(" -- could not store.  found " + o);
+          sb.append(" -- could not store.  found ").append(o);
-   * derived class contructor , after the HARegionQueue contructor is complete. Otherwise, the
+   * derived class constructor , after the HARegionQueue contructor is complete. Otherwise, the
-   * 
-   * @throws CacheException
-   * @throws InterruptedException
-   * @param val
-   * @throws InterruptedException
-            ((HAEventWrapper) val).getKeyToConflate());
+            ((Conflatable) val).getKeyToConflate());
-   * @throws InterruptedException
-   * @throws CacheException
-   * @return boolean
-        this.region.put(ti, Long.valueOf(dace.lastDispatchedSequenceId));
+        this.region.put(ti, dace.lastDispatchedSequenceId);
-        // if (logger.isDebugEnabled()) {
-        // }
-    // update the stats
-    // if (logger.isDebugEnabled()) {
-    // this.stats.incEventsEnqued();
-    // }
-
-    this.giiCount++;
+    this.giiCount++; // TODO: non-atomic operation on volatile!
-      this.giiCount--;
+      this.giiCount--; // TODO: non-atomic operation on volatile!
-          } catch (NoSuchElementException e) {
-            // if (actualCount != expectedCount) {
-            // logger.severe(LocalizedStrings.DEBUG, "expected to drain "
-            // + expectedCount + " messages but drained " + actualCount
-            // + " queue.size() is now " + giiQueue.size() + ", in queue" + this, e);
-            // } else {
-            // logger.severe(LocalizedStrings.DEBUG, "drained " + actualCount + " messages. Queue
-            // size is " + giiQueue.size() + " in " + this);
-            // }
+          } catch (NoSuchElementException ignore) {
-          } catch (NoSuchElementException e) {
+          } catch (NoSuchElementException ignore) {
-          } catch (InterruptedException e) {
+          } catch (InterruptedException ignore) {
-            // logger.severe(LocalizedStrings.DEBUG, "endGiiQueueing interrupted - ignoring until
-            // draining completes");
-    Map<ThreadIdentifier, DispatchedAndCurrentEvents> events = this.eventsMap;
-        for (Map.Entry<ThreadIdentifier, DispatchedAndCurrentEvents> entry : events.entrySet()) {
+        for (Map.Entry<ThreadIdentifier, DispatchedAndCurrentEvents> entry : ((Map<ThreadIdentifier, DispatchedAndCurrentEvents>) this.eventsMap)
+            .entrySet()) {
-      } catch (ConcurrentModificationException e) { // TODO:WTF: bad practice but eventsMap is
-                                                    // ConcurrentHashMap
+      } catch (ConcurrentModificationException ignore) {
+        // TODO:WTF: bad practice but eventsMap is ConcurrentHashMap
-   * Implementation in BlokcingHARegionQueue class
-   * 
-   * @throws InterruptedException
+   * Implementation in BlockingHARegionQueue class
-   * 
-  public static synchronized void startHAServices(GemFireCacheImpl c) {
-
+  static synchronized void startHAServices(InternalCache cache) {
-      qrmThread = new QueueRemovalThread(c);
+      qrmThread = new QueueRemovalThread(cache);
-    Long previousPosition = (Long) latestIndexesForRegion.put(key, newPosition);
-    return previousPosition;
-
+    return (Long) latestIndexesForRegion.put(key, newPosition);
-   * 
-
-        } catch (CancelException e) {
+        } catch (CancelException ignore) {
-   * <p>
-   * author Asif
-   * 
+   *
-   * @throws CacheException
-    // if (HARegionQueue.this.isPrimary()) {
-    // logger.info(LocalizedStrings.DEBUG,
-    // "HARegionQueue: Entry Event being invalidated ="
-    // + event+", after current queue became primary.");
-    // }
-      boolean expired = dace.expireOrUpdate(expirySequenceID.longValue(), (ThreadIdentifier) key);
+      boolean expired = dace.expireOrUpdate(expirySequenceID, (ThreadIdentifier) key);
-   * avaialble for peek or take. This method is called from DispatchedAndCurrentEvents object. This
+   * available for peek or take. This method is called from DispatchedAndCurrentEvents object. This
-   * queue. In case of blokcing queue , this method also signals the waiting take & peek threads to
+   * queue. In case of blocking queue , this method also signals the waiting take & peek threads to
-   * <p>
-   * author Asif
-   * 
+   *
-   * @throws InterruptedException
-      // Asif:Notify the wiating peek threads or take threads of blocking queue
+      // Notify the waiting peek threads or take threads of blocking queue
-   * 
-   * <p>
-   * author Asif
-   * 
-   *        present in HARegion. This function is directly ivnoked from the basicInvalidate function
+   *        present in HARegion. This function is directly invoked from the basicInvalidate function
-   * @param position Long poistion counter for entry in the Region
+   * @param position Long position counter for entry in the Region
-   * @throws InterruptedException
-   * 
-      } catch (EntryNotFoundException enfe) {
-        // if (!this.region.isDestroyed()) {
-        // if (!HARegionQueue.this.destroyInProgress || !this.region.isDestroyed()) {
+      } catch (EntryNotFoundException ignore) {
-  /** Returns the <code>toString</code> for this RegionQueue object */
+  /** Returns the {@code toString} for this RegionQueue object */
-   * This method is inoked by the take function . For non blocking queue it returns null or a valid
+   * This method is invoked by the take function . For non blocking queue it returns null or a valid
-   * 
-   * @throws CacheException
-   * @throws InterruptedException
-   * 
-   * <p>
-   * author Asif
-   * 
+   *
-   * @throws InterruptedException
-   * 
-   * @throws InterruptedException
-   * 
-   * @throws InterruptedException
-          countersList.set(0, Long.valueOf(sequenceId));
+          countersList.set(0, sequenceId);
-          countersList.add(Long.valueOf(sequenceId));
+          countersList.add(sequenceId);
-      long lastDispatchedId = ((Long) removedEvents.remove(0)).longValue();
+      long lastDispatchedId = (Long) removedEvents.remove(0);
-      } catch (TimeoutException te) {
+      } catch (TimeoutException ignore) {
-   * @throws InterruptedException
-   *
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
-   * queue.This method should always be invoked within the <code>rwLock</code>.
+   * queue.This method should always be invoked within the {@code rwLock}.
-   * @throws CacheException
-    // TODO Auto-generated method stub
-
+    // nothing
-    // TODO Auto-generated method stub
+    // nothing
-   * 
-   * <p>
-   * author Asif
-   * 
+   *
-    Long lastSequenceNumber = Long.valueOf(sequenceId);
+    Long lastSequenceNumber = sequenceId;
-   * 
-   * <p>
-   * author Asif
-   * 
+   *
-   * @throws CacheException
-   * @throws InterruptedException
-
-        this.region.put(ti, Long.valueOf(dace.lastDispatchedSequenceId));
+        this.region.put(ti, dace.lastDispatchedSequenceId);
-        // if (logger.isDebugEnabled()) {
-        // }
-
-  void decrementTakeSidePutPermits() {
-
-  }
-
-
+    // nothing
-   * 
-   * <p>
-   * author Asif
-   * 
+   *
-   * @throws InterruptedException
-   * 
-   * @throws IOException
-   * @throws ClassNotFoundException
-   * @throws InterruptedException
-   * @throws CacheException
-  public static HARegionQueue getHARegionQueueInstance(String regionName, Cache cache,
+  public static HARegionQueue getHARegionQueueInstance(String regionName, InternalCache cache,
-    return getHARegionQueueInstance(regionName, (GemFireCacheImpl) cache,
+    return getHARegionQueueInstance(regionName, cache,
-   * @throws IOException
-   * @throws ClassNotFoundException
-   * @throws CacheException
-   * @throws InterruptedException
-  public static HARegionQueue getHARegionQueueInstance(String regionName, GemFireCacheImpl cache,
+  public static HARegionQueue getHARegionQueueInstance(String regionName, InternalCache cache,
-                .toLocalizedString(new Object[] {Integer.valueOf(BLOCKING_HA_QUEUE),
-                    Integer.valueOf(NON_BLOCKING_HA_QUEUE)}));
+                .toLocalizedString(new Object[] {BLOCKING_HA_QUEUE, NON_BLOCKING_HA_QUEUE}));
-      hrqa.setExpiryTime(expiryTime.intValue());
+      hrqa.setExpiryTime(expiryTime);
-   * @param regionName
-   * @param cache
-   * @param hrqa
-   * @param haRgnQType
-   * @param isDurable
-   * @throws IOException
-   * @throws ClassNotFoundException
-   * @throws CacheException
-   * @throws InterruptedException
-  public static HARegionQueue getHARegionQueueInstance(String regionName, Cache cache,
+  public static HARegionQueue getHARegionQueueInstance(String regionName, InternalCache cache,
-    return getHARegionQueueInstance(regionName, (GemFireCacheImpl) cache, hrqa, haRgnQType,
-        isDurable, container, null, HandShake.CONFLATION_DEFAULT, false, Boolean.FALSE);
+    return getHARegionQueueInstance(regionName, cache, hrqa, haRgnQType, isDurable, container, null,
+        HandShake.CONFLATION_DEFAULT, false, Boolean.FALSE);
-              } catch (InterruptedException e) {
+              } catch (InterruptedException ignore) {
-
-
-   * This is an implemention of RegionQueue where peek() & take () are blocking operation and will
+   * This is an implementation of RegionQueue where peek() & take () are blocking operation and will
-   * 
-   * 
-     * 
-     * @param regionName
-     * @param cache
-     * @param haContainer
-     * @throws IOException TODO-javadocs
-     * @throws ClassNotFoundException TODO-javadocs
-     * @throws CacheException TODO-javadocs
-     * @throws InterruptedException
-    protected BlockingHARegionQueue(String regionName, GemFireCacheImpl cache,
+    protected BlockingHARegionQueue(String regionName, InternalCache cache,
-     * 
-     * <p>
-     * author Asif
-    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "TLW_TWO_LOCK_WAIT")
+    @edu.umd.cs.findbugs.annotations.SuppressWarnings("TLW_TWO_LOCK_WAIT")
-                    // for (;;) {
+                    // TODO: wait called while holding two locks
-                    // }
-                    // TODO:Asif: The line below is meaningless. Comment it out
-                    // later
-                    this.permitMon.notify();
+                    // TODO: The line below is meaningless. Comment it out later
+                    this.permitMon.notifyAll();
-     * 
-     * <p>
-     * author Asif
-     * 
-     * @return int currnet Put permits
+     *
+     * @return int current Put permits
-
-     * 
-     * <p>
-     * author Asif
-     * 
-     * 
-     * <p>
-     * author Asif
-     * 
-          this.permitMon.notify();
+          this.permitMon.notifyAll();
-     * 
-     * 
-     * @throws InterruptedException
-    protected DurableHARegionQueue(String regionName, GemFireCacheImpl cache,
+    protected DurableHARegionQueue(String regionName, InternalCache cache,
-      /**
-       * ashetkar: Setting this threadlocal variable to null has no use as the current thread never
-       * uses it. Instead it should really be set null by message dispatcher thread while starting
-       * or resuming. This was added in revision 20914. Need to check if it really needs to be
-       * thread local.
+      /*
+       * Setting this threadlocal variable to null has no use as the current thread never uses it.
+       * Instead it should really be set null by message dispatcher thread while starting or
+       * resuming. This was added in revision 20914. Need to check if it really needs to be thread
+       * local.
-   * 
-   * <p>
-   * author Asif
-   * 
-     * @param regionName
-     * @param cache
-     * @param haContainer
-     * @throws IOException
-     * @throws ClassNotFoundException
-     * @throws CacheException
-     * @throws InterruptedException
-    TestOnlyHARegionQueue(String regionName, Cache cache, Map haContainer)
+    TestOnlyHARegionQueue(String regionName, InternalCache cache, Map haContainer)
-      this(regionName, (GemFireCacheImpl) cache, HARegionQueueAttributes.DEFAULT_HARQ_ATTRIBUTES,
-          haContainer, HandShake.CONFLATION_DEFAULT, false);
+      this(regionName, cache, HARegionQueueAttributes.DEFAULT_HARQ_ATTRIBUTES, haContainer,
+          HandShake.CONFLATION_DEFAULT, false);
-    TestOnlyHARegionQueue(String regionName, Cache cache)
+    TestOnlyHARegionQueue(String regionName, InternalCache cache)
-      this(regionName, (GemFireCacheImpl) cache, HARegionQueueAttributes.DEFAULT_HARQ_ATTRIBUTES,
-          new HashMap(), HandShake.CONFLATION_DEFAULT, false);
+      this(regionName, cache, HARegionQueueAttributes.DEFAULT_HARQ_ATTRIBUTES, new HashMap(),
+          HandShake.CONFLATION_DEFAULT, false);
-    TestOnlyHARegionQueue(String regionName, GemFireCacheImpl cache, HARegionQueueAttributes hrqa,
+    TestOnlyHARegionQueue(String regionName, InternalCache cache, HARegionQueueAttributes hrqa,
-     * Overloaded constructor to pass an <code>HashMap</code> instance as a haContainer.
+     * Overloaded constructor to pass an {@code HashMap} instance as a haContainer.
-     * @param regionName
-     * @param cache
-     * @param hrqa
-     * @throws IOException
-     * @throws ClassNotFoundException
-     * @throws CacheException
-     * @throws InterruptedException
-    TestOnlyHARegionQueue(String regionName, Cache cache, HARegionQueueAttributes hrqa)
+    TestOnlyHARegionQueue(String regionName, InternalCache cache, HARegionQueueAttributes hrqa)
-      this(regionName, (GemFireCacheImpl) cache, hrqa, new HashMap(), HandShake.CONFLATION_DEFAULT,
-          false);
+      this(regionName, cache, hrqa, new HashMap(), HandShake.CONFLATION_DEFAULT, false);
-   * size is reached, it will create a new <code>QueueRemovalMessage</code> and send it to all the
-   * nodes in the DistributedSystem
-   * 
-   * <p>
-   * author Mitul Bid
-   * 
+   * size is reached, it will create a new {@code QueueRemovalMessage} and send it to all the nodes
+   * in the DistributedSystem
-
-    private final GemFireCacheImpl cache;
+    private final InternalCache cache;
-    public QueueRemovalThread(GemFireCacheImpl c) {
+    public QueueRemovalThread(InternalCache cache) {
-      this.cache = c;
+      this.cache = cache;
-     * will create a new <code>QueueRemovalMessage</code> and send it to the other nodes
-     */
-    /**
-     * The thread will check the dispatchedMessages map for messages that have been dispatched. It
-     * will create a new <code>QueueRemovalMessage</code> and send it to the other nodes
+     * will create a new {@code QueueRemovalMessage} and send it to the other nodes
-          catch (CancelException e) {
+          catch (CancelException ignore) {
-        queueRemovalMessageList.add(Integer.valueOf(internalMap.size()));
+        queueRemovalMessageList.add(internalMap.size());
-          eventId = new EventID(tid.getMembershipID(), tid.getThreadID(), sequenceId.longValue());
+          eventId = new EventID(tid.getMembershipID(), tid.getThreadID(), sequenceId);
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
-   * Class whick keeps track of the positions ( keys) of underlying Region object for the events
+   * Class which keeps track of the positions ( keys) of underlying Region object for the events
-   * 
-   * <p>
-   * author Asif
-   * 
-     * 
-     * <p>
-     * author Asif
-     * 
-     * @throws CacheException
-     * @throws InterruptedException
-      // logger.debug("BRUCE: putObject() lastSequenceIDPut="+lastSequenceIDPut
-      // +"; adding sequenceID="+sequenceID + " for " + event);
-      // logger.info("putObject, sequenceID = " + sequenceID + "; lastSequenceIDPut = " +
-      // lastSequenceIDPut, new Exception("putObject"));
-          Long position = Long.valueOf(owningQueue.tailKey.incrementAndGet());
+          Long position = owningQueue.tailKey.incrementAndGet();
-     * availableIDs , Region & Counters set. Since this is executed within a synch block by the new
+     * availableIDs , Region & Counters set. Since this is executed within a sync block by the new
-     * poistion etc in the available IDs set. Also the new entry thraed & old entry thread are
-     * belonging to diffrenet ThreadIdentifier objects & hence hold different
+     * position etc in the available IDs set. Also the new entry thread & old entry thread are
+     * belonging to different ThreadIdentifier objects & hence hold different
-     * 
-     * @param oldPosition
-     * @throws CacheException
-     * @throws InterruptedException
-          // if (logger.isDebugEnabled()) {
-          // vrao: Fix for bug 39291:
+          // Fix for bug 39291:
-          // }
-
-     * 
-     * @param position
-          } catch (RegionDestroyedException ignore) {
+          } catch (RegionDestroyedException e) {
-                  ti, expVal, ignore);
+                  ti, expVal, e);
-                  new Object[] {ti, Long.valueOf(expVal), enfe}));
+                  new Object[] {ti, expVal, enfe}));
-          owningQueue.region.put(ti, Long.valueOf(this.lastDispatchedSequenceId));
+          owningQueue.region.put(ti, this.lastDispatchedSequenceId);
-     * @throws CacheException
-     * @throws InterruptedException
-     * @throws CacheException
-     * @throws InterruptedException
-   * 
-   * @throws CacheWriterException
-      } catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException ignore) {
-      } catch (CancelException e) {
+      } catch (CancelException ignore) {
-      } catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException ignore) {
-      } catch (CancelException e) {
+      } catch (CancelException ignore) {
-   * @param event
-   * @param position
-   * @param haEventWrapper An instance of <code>HAEventWrapper</code>
+   * @param haEventWrapper An instance of {@code HAEventWrapper}
-        if (!(this.availableIDsSize() == 0)) {
+        if (this.availableIDsSize() != 0) {
-            } catch (CancelException e) {
+            } catch (CancelException ignore) {
-   * <code>ClientUpdateMessage</code> instance.
+   * {@code ClientUpdateMessage} instance.
-   * @param conflatable
-   * @return An instance of <code>ClientUpdateMessage</code>
+   * @return An instance of {@code ClientUpdateMessage}
-   * @param wrapper
-   * <code>flag</code> is set to <code>true</code>, disables Entry Expiry Tasks.
+   * {@code flag} is set to {@code true}, disables Entry Expiry Tasks.
-   * Disables EntryExpiryTask for the HARegion (<code>this.region</code>).
+   * Disables EntryExpiryTask for the HARegion ({@code this.region}).
-          new Object[] {Integer.valueOf(oldTimeToLive)}));
+          new Object[] {oldTimeToLive}));
-      } catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException ignore) {
-
-}
+  /**
+   * A wrapper class whose underlying map gets replaced with a fresh one when QRM thread is
+   * operating on it. This wrapper acts as a means of communication between the QRM thread & the
+   * MapWrapper object contained in the HARegionQueue
+   */
+  static class MapWrapper {
+    Map map;
+    List list;
-/**
- * A wrapper class whose underlying map gets replaced with a fresh one when QRM thread is operating
- * on it. This wrapper acts as a means of communication between the QRM thread & the MapWrapper
- * object contained in the HARegionQueue
- * 
- * <p>
- * author ashahid
- */
+    boolean keepPrevAcks = false;
-class MapWrapper {
-  Map map;
-
-  List list;
-
-  boolean keepPrevAcks = false;
-
-  public MapWrapper() {
-    super();
-    map = new HashMap();
-    list = new LinkedList();
-  }
-
-  void put(Object key, Object o) {
-    synchronized (this.map) {
-      this.map.put(key, o);
+    public MapWrapper() {
+      super();
+      map = new HashMap();
+      list = new LinkedList();
-  }
-}
-
-/**
- * A wrapper class that has counter, key and the region-name for an event which was peeked and needs
- * to be removed. The key and regionName fields will be set only if conflation is true for the
- * event.
- * 
- * <p>
- * author dpatel
- * 
- */
-
-class RemovedEventInfo {
-  Long counter;
-
-  String regionName;
-
-  Object key;
-
-  public RemovedEventInfo(Long counter, String regionName, Object key) {
-    this.counter = counter;
-    this.regionName = regionName;
-    this.key = key;
-  }
-}
-
-
-/** this is used to expire thread identifiers, even in primary queues */
-class ThreadIdentifierCustomExpiry implements CustomExpiry {
-  private static final ExpirationAttributes DEFAULT_THREAD_ID_EXP_ATTS = new ExpirationAttributes(
-      HARegionQueue.DEFAULT_THREAD_ID_EXPIRY_TIME, ExpirationAction.LOCAL_INVALIDATE);
-  private static volatile ExpirationAttributes testExpAtts = null;
-
-  public ExpirationAttributes getExpiry(Region.Entry entry) {
-    // Use key to determine expiration.
-    Object key = entry.getKey();
-    if (key instanceof ThreadIdentifier) {
-      final int expTime = HARegionQueue.threadIdExpiryTime;
-      if (expTime != HARegionQueue.DEFAULT_THREAD_ID_EXPIRY_TIME) {
-        // This should only happen in unit test code
-        ExpirationAttributes result = testExpAtts;
-        if (result == null || result.getTimeout() != expTime) {
-          result = new ExpirationAttributes(expTime, ExpirationAction.LOCAL_INVALIDATE);
-          // save the expiration attributes in a static to prevent tests from creating lots of
-          // instances.
-          testExpAtts = result;
-        }
-        return result;
-      } else {
-        return DEFAULT_THREAD_ID_EXP_ATTS;
+    void put(Object key, Object o) {
+      synchronized (this.map) {
+        this.map.put(key, o);
-    } else {
-      return null;
-  public void close() {}
+  /**
+   * A wrapper class that has counter, key and the region-name for an event which was peeked and
+   * needs to be removed. The key and regionName fields will be set only if conflation is true for
+   * the event.
+   */
+  static class RemovedEventInfo {
+    Long counter;
+
+    String regionName;
+
+    Object key;
+
+    public RemovedEventInfo(Long counter, String regionName, Object key) {
+      this.counter = counter;
+      this.regionName = regionName;
+      this.key = key;
+    }
+  }
+
+  /** this is used to expire thread identifiers, even in primary queues */
+  static class ThreadIdentifierCustomExpiry implements CustomExpiry {
+    private static final ExpirationAttributes DEFAULT_THREAD_ID_EXP_ATTS = new ExpirationAttributes(
+        HARegionQueue.DEFAULT_THREAD_ID_EXPIRY_TIME, ExpirationAction.LOCAL_INVALIDATE);
+    private static volatile ExpirationAttributes testExpAtts = null;
+
+    public ExpirationAttributes getExpiry(Region.Entry entry) {
+      // Use key to determine expiration.
+      Object key = entry.getKey();
+      if (key instanceof ThreadIdentifier) {
+        final int expTime = HARegionQueue.threadIdExpiryTime;
+        if (expTime != HARegionQueue.DEFAULT_THREAD_ID_EXPIRY_TIME) {
+          // This should only happen in unit test code
+          ExpirationAttributes result = testExpAtts;
+          if (result == null || result.getTimeout() != expTime) {
+            result = new ExpirationAttributes(expTime, ExpirationAction.LOCAL_INVALIDATE);
+            // save the expiration attributes in a static to prevent tests from creating lots of
+            // instances.
+            testExpAtts = result;
+          }
+          return result;
+        } else {
+          return DEFAULT_THREAD_ID_EXP_ATTS;
+        }
+      } else {
+        return null;
+      }
+    }
+
+    public void close() {}
+  }

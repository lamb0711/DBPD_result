Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** <p>The internal implementation of the {@link CacheTransactionManager}
- * interface returned by {@link GemFireCacheImpl#getCacheTransactionManager}.
- * Internal operations 
-
- </code>TransactionListener</code> invocation, Region synchronization, transaction statistics and
-
- * transaction logging are handled here 
+/**
+ * <p>
+ * The internal implementation of the {@link CacheTransactionManager} interface returned by
+ * {@link GemFireCacheImpl#getCacheTransactionManager}. Internal operations
+ * 
+ * </code>TransactionListener</code> invocation, Region synchronization, transaction statistics and
+ * 
+ * transaction logging are handled here
-public class TXManagerImpl implements CacheTransactionManager,
-    MembershipListener {
+public class TXManagerImpl implements CacheTransactionManager, MembershipListener {
-  
+
-  // The unique transaction ID for this Manager 
+  // The unique transaction ID for this Manager
-  private static final TransactionListener[] EMPTY_LISTENERS =
-    new TransactionListener[0];
+  private static final TransactionListener[] EMPTY_LISTENERS = new TransactionListener[0];
-  
+
-  public final static int FAILOVER_TX_MAP_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "transactionFailoverMapSize", 1000);
-  
+  public final static int FAILOVER_TX_MAP_SIZE =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "transactionFailoverMapSize", 1000);
+
-   * used to store TXCommitMessages for client initiated transactions, so that when a client failsover,
-   * (after the delegate dies) the commit message can be sent to client.
-   * //TODO we really need to keep around only one msg for each thread on a client
+   * used to store TXCommitMessages for client initiated transactions, so that when a client
+   * failsover, (after the delegate dies) the commit message can be sent to client. //TODO we really
+   * need to keep around only one msg for each thread on a client
-  private Map<TXId ,TXCommitMessage> failoverMap = Collections.synchronizedMap(new LinkedHashMap<TXId, TXCommitMessage>() {
-    private static final long serialVersionUID = -4156018226167594134L;
+  private Map<TXId, TXCommitMessage> failoverMap =
+      Collections.synchronizedMap(new LinkedHashMap<TXId, TXCommitMessage>() {
+        private static final long serialVersionUID = -4156018226167594134L;
-    protected boolean removeEldestEntry(Entry eldest) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("TX: removing client initiated transaction from failover map:{} :{}", eldest.getKey(), (size()>FAILOVER_TX_MAP_SIZE));
-      }
-      return size() > FAILOVER_TX_MAP_SIZE;
-    };
-  });
+        protected boolean removeEldestEntry(Entry eldest) {
+          if (logger.isDebugEnabled()) {
+            logger.debug("TX: removing client initiated transaction from failover map:{} :{}",
+                eldest.getKey(), (size() > FAILOVER_TX_MAP_SIZE));
+          }
+          return size() > FAILOVER_TX_MAP_SIZE;
+        };
+      });
-  public static boolean ALLOW_PERSISTENT_TRANSACTIONS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ALLOW_PERSISTENT_TRANSACTIONS");
+  public static boolean ALLOW_PERSISTENT_TRANSACTIONS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ALLOW_PERSISTENT_TRANSACTIONS");
-  private ConcurrentMap<TXId, TXStateProxy> localTxMap = new ConcurrentHashMap<TXId, TXStateProxy>();
+  private ConcurrentMap<TXId, TXStateProxy> localTxMap =
+      new ConcurrentHashMap<TXId, TXStateProxy>();
-   * the time in minutes after which any suspended transaction are rolled back. default is 30 minutes
+   * the time in minutes after which any suspended transaction are rolled back. default is 30
+   * minutes
-  private volatile long suspendedTXTimeout = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "suspendedTxTimeout", 30);
-  
+  private volatile long suspendedTXTimeout =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "suspendedTxTimeout", 30);
+
-  
+
-   * The number of seconds to keep transaction states for disconnected clients.
-   * This allows the client to fail over to another server and still find
-   * the transaction state to complete the transaction.
+   * The number of seconds to keep transaction states for disconnected clients. This allows the
+   * client to fail over to another server and still find the transaction state to complete the
+   * transaction.
-  
-  /** Constructor that implements the {@link CacheTransactionManager}
-   * interface. Only only one instance per {@link org.apache.geode.cache.Cache}
+
+  /**
+   * Constructor that implements the {@link CacheTransactionManager} interface. Only only one
+   * instance per {@link org.apache.geode.cache.Cache}
-   * @param cachePerfStats 
+   * @param cachePerfStats
-  public TXManagerImpl(
-                       CachePerfStats cachePerfStats,
-                       Cache cache) {
+  public TXManagerImpl(CachePerfStats cachePerfStats, Cache cache) {
-    this.dm = ((InternalDistributedSystem)cache.getDistributedSystem())
-        .getDistributionManager();
+    this.dm = ((InternalDistributedSystem) cache.getDistributedSystem()).getDistributionManager();
-    this.transactionTimeToLive = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "cacheServer.transactionTimeToLive", 180);
+    this.transactionTimeToLive = Integer
+        .getInteger(DistributionConfig.GEMFIRE_PREFIX + "cacheServer.transactionTimeToLive", 180);
-  
-  
+
+
-  
+
-    if (((GemFireCacheImpl)this.cache).isClient()) {
-      throw new IllegalStateException(LocalizedStrings.TXManager_NO_WRITER_ON_CLIENT.toLocalizedString());
+    if (((GemFireCacheImpl) this.cache).isClient()) {
+      throw new IllegalStateException(
+          LocalizedStrings.TXManager_NO_WRITER_ON_CLIENT.toLocalizedString());
-  
+
-      return null;
+        return null;
-        throw new IllegalStateException(LocalizedStrings.TXManagerImpl_MORE_THAN_ONE_TRANSACTION_LISTENER_EXISTS.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.TXManagerImpl_MORE_THAN_ONE_TRANSACTION_LISTENER_EXISTS
+                .toLocalizedString());
-  
+
-  
+
+
-      throw new IllegalArgumentException(LocalizedStrings.TXManagerImpl_ADDLISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.TXManagerImpl_ADDLISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+
-      throw new IllegalArgumentException(LocalizedStrings.TXManagerImpl_REMOVELISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.TXManagerImpl_REMOVELISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+
-          throw new IllegalArgumentException(LocalizedStrings.TXManagerImpl_INITLISTENERS_PARAMETER_HAD_A_NULL_ELEMENT.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.TXManagerImpl_INITLISTENERS_PARAMETER_HAD_A_NULL_ELEMENT
+                  .toLocalizedString());
-  /** Build a new {@link TXId}, use it as part of the transaction
-   * state and associate with the current thread using a {@link
-   * ThreadLocal}.
+  /**
+   * Build a new {@link TXId}, use it as part of the transaction state and associate with the
+   * current thread using a {@link ThreadLocal}.
-        throw new java.lang.IllegalStateException(LocalizedStrings.TXManagerImpl_TRANSACTION_0_ALREADY_IN_PROGRESS.toLocalizedString(tid));
+        throw new java.lang.IllegalStateException(
+            LocalizedStrings.TXManagerImpl_TRANSACTION_0_ALREADY_IN_PROGRESS
+                .toLocalizedString(tid));
-      proxy = new DistTXStateProxyImplOnCoordinator(this, id, null);  
+      proxy = new DistTXStateProxyImplOnCoordinator(this, id, null);
-      proxy = new TXStateProxyImpl(this, id, null);  
+      proxy = new TXStateProxyImpl(this, id, null);
-  /** Build a new {@link TXId}, use it as part of the transaction
-   * state and associate with the current thread using a {@link
-   * ThreadLocal}. Flag the transaction to be enlisted with a JTA
-   * Transaction.  Should only be called in a context where we know
-   * there is no existing transaction.
+  /**
+   * Build a new {@link TXId}, use it as part of the transaction state and associate with the
+   * current thread using a {@link ThreadLocal}. Flag the transaction to be enlisted with a JTA
+   * Transaction. Should only be called in a context where we know there is no existing transaction.
-    
+
-      throw new IllegalStateException(LocalizedStrings.TXManagerImpl_THREAD_DOES_NOT_HAVE_AN_ACTIVE_TRANSACTION.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.TXManagerImpl_THREAD_DOES_NOT_HAVE_AN_ACTIVE_TRANSACTION
+              .toLocalizedString());
-    
-    tx.checkJTA(LocalizedStrings.TXManagerImpl_CAN_NOT_COMMIT_THIS_TRANSACTION_BECAUSE_IT_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_COMMIT.toLocalizedString());
-  
+
+    tx.checkJTA(
+        LocalizedStrings.TXManagerImpl_CAN_NOT_COMMIT_THIS_TRANSACTION_BECAUSE_IT_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_COMMIT
+            .toLocalizedString());
+
-  
-  /** Complete the transaction associated with the current
-   *  thread. When this method completes, the thread is no longer
-   *  associated with a transaction.
+
+  /**
+   * Complete the transaction associated with the current thread. When this method completes, the
+   * thread is no longer associated with a transaction.
-      throw new IllegalStateException(LocalizedStrings.TXManagerImpl_THREAD_DOES_NOT_HAVE_AN_ACTIVE_TRANSACTION.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.TXManagerImpl_THREAD_DOES_NOT_HAVE_AN_ACTIVE_TRANSACTION
+              .toLocalizedString());
-    tx.checkJTA(LocalizedStrings.TXManagerImpl_CAN_NOT_COMMIT_THIS_TRANSACTION_BECAUSE_IT_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_COMMIT.toLocalizedString());
+    tx.checkJTA(
+        LocalizedStrings.TXManagerImpl_CAN_NOT_COMMIT_THIS_TRANSACTION_BECAUSE_IT_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_COMMIT
+            .toLocalizedString());
-      saveTXStateForClientFailover(tx, TXCommitMessage.CMT_CONFLICT_MSG); //fixes #43350
+      saveTXStateForClientFailover(tx, TXCommitMessage.CMT_CONFLICT_MSG); // fixes #43350
-    this.cachePerfStats.txFailure(opEnd - opStart,
-                                  lifeTime, tx.getChanges());
+    this.cachePerfStats.txFailure(opEnd - opStart, lifeTime, tx.getChanges());
-      for (int i=0; i < listeners.length; i++) {
-        try {
-          listeners[i].afterFailedCommit(e);
-        } 
-        catch (VirtualMachineError err) {
-          SystemFailure.initiateFailure(err);
-          // If this ever returns, rethrow the error.  We're poisoned
-          // now, so don't let this thread continue.
-          throw err;
+        for (int i = 0; i < listeners.length; i++) {
+          try {
+            listeners[i].afterFailedCommit(e);
+          } catch (VirtualMachineError err) {
+            SystemFailure.initiateFailure(err);
+            // If this ever returns, rethrow the error. We're poisoned
+            // now, so don't let this thread continue.
+            throw err;
+          } catch (Throwable t) {
+            // Whenever you catch Error or Throwable, you must also
+            // catch VirtualMachineError (see above). However, there is
+            // _still_ a possibility that you are dealing with a cascading
+            // error condition, so you also need to check to see if the JVM
+            // is still usable:
+            SystemFailure.checkFailure();
+            logger.error(LocalizedMessage.create(
+                LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
+          }
-        catch (Throwable t) {
-          // Whenever you catch Error or Throwable, you must also
-          // catch VirtualMachineError (see above).  However, there is
-          // _still_ a possibility that you are dealing with a cascading
-          // error condition, so you also need to check to see if the JVM
-          // is still usable:
-          SystemFailure.checkFailure();
-          logger.error(LocalizedMessage.create(LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
-        }
-      }
-    this.cachePerfStats.txSuccess(opEnd - opStart,
-                                  lifeTime, tx.getChanges());
+    this.cachePerfStats.txSuccess(opEnd - opStart, lifeTime, tx.getChanges());
-      for (final TransactionListener listener : listeners) {
-        try {
-          listener.afterCommit(e);
-        } 
-        catch (VirtualMachineError err) {
-          SystemFailure.initiateFailure(err);
-          // If this ever returns, rethrow the error.  We're poisoned
-          // now, so don't let this thread continue.
-          throw err;
+        for (final TransactionListener listener : listeners) {
+          try {
+            listener.afterCommit(e);
+          } catch (VirtualMachineError err) {
+            SystemFailure.initiateFailure(err);
+            // If this ever returns, rethrow the error. We're poisoned
+            // now, so don't let this thread continue.
+            throw err;
+          } catch (Throwable t) {
+            // Whenever you catch Error or Throwable, you must also
+            // catch VirtualMachineError (see above). However, there is
+            // _still_ a possibility that you are dealing with a cascading
+            // error condition, so you also need to check to see if the JVM
+            // is still usable:
+            SystemFailure.checkFailure();
+            logger.error(LocalizedMessage.create(
+                LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
+          }
-        catch (Throwable t) {
-          // Whenever you catch Error or Throwable, you must also
-          // catch VirtualMachineError (see above).  However, there is
-          // _still_ a possibility that you are dealing with a cascading
-          // error condition, so you also need to check to see if the JVM
-          // is still usable:
-          SystemFailure.checkFailure();
-          logger.error(LocalizedMessage.create(LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
-        }
-      }
-  
+
-    TXStateProxyImpl tx = (TXStateProxyImpl)getTXState();
+    TXStateProxyImpl tx = (TXStateProxyImpl) getTXState();
-  /** Roll back the transaction associated with the current
-   *  thread. When this method completes, the thread is no longer
-   *  associated with a transaction.
+  /**
+   * Roll back the transaction associated with the current thread. When this method completes, the
+   * thread is no longer associated with a transaction.
-      throw new IllegalStateException(LocalizedStrings.TXManagerImpl_THREAD_DOES_NOT_HAVE_AN_ACTIVE_TRANSACTION.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.TXManagerImpl_THREAD_DOES_NOT_HAVE_AN_ACTIVE_TRANSACTION
+              .toLocalizedString());
-    tx.checkJTA(LocalizedStrings.TXManagerImpl_CAN_NOT_ROLLBACK_THIS_TRANSACTION_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_ROLLBACK.toLocalizedString());
+    tx.checkJTA(
+        LocalizedStrings.TXManagerImpl_CAN_NOT_ROLLBACK_THIS_TRANSACTION_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_ROLLBACK
+            .toLocalizedString());
-  
+
-    this.cachePerfStats.txRollback(opEnd - opStart,
-                                   lifeTime, tx.getChanges());
+    this.cachePerfStats.txRollback(opEnd - opStart, lifeTime, tx.getChanges());
-      for (int i = 0; i < listeners.length; i++) {
-        try {
-          listeners[i].afterRollback(e);
-        } 
-        catch (VirtualMachineError err) {
-          SystemFailure.initiateFailure(err);
-          // If this ever returns, rethrow the error.  We're poisoned
-          // now, so don't let this thread continue.
-          throw err;
+        for (int i = 0; i < listeners.length; i++) {
+          try {
+            listeners[i].afterRollback(e);
+          } catch (VirtualMachineError err) {
+            SystemFailure.initiateFailure(err);
+            // If this ever returns, rethrow the error. We're poisoned
+            // now, so don't let this thread continue.
+            throw err;
+          } catch (Throwable t) {
+            // Whenever you catch Error or Throwable, you must also
+            // catch VirtualMachineError (see above). However, there is
+            // _still_ a possibility that you are dealing with a cascading
+            // error condition, so you also need to check to see if the JVM
+            // is still usable:
+            SystemFailure.checkFailure();
+            logger.error(LocalizedMessage.create(
+                LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
+          }
-        catch (Throwable t) {
-          // Whenever you catch Error or Throwable, you must also
-          // catch VirtualMachineError (see above).  However, there is
-          // _still_ a possibility that you are dealing with a cascading
-          // error condition, so you also need to check to see if the JVM
-          // is still usable:
-          SystemFailure.checkFailure();
-          logger.error(LocalizedMessage.create(LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
-        }
-      }
-  
-  /** Reports the existance of a Transaction for this thread
+
+  /**
+   * Reports the existance of a Transaction for this thread
-  /** Gets the current transaction identifier or null if no transaction exists
+  /**
+   * Gets the current transaction identifier or null if no transaction exists
-    if (t!=null) {
+    if (t != null) {
-    } 
+    }
-  /** 
+  /**
-   * sets {@link TXStateProxy#setInProgress(boolean)} when a txContext is present.
-   * This method must only be used in fail-over scenarios.
+   * sets {@link TXStateProxy#setInProgress(boolean)} when a txContext is present. This method must
+   * only be used in fail-over scenarios.
+   * 
-      //After this, newly added TXStateProxy would not operate on the TXState.
+      // After this, newly added TXStateProxy would not operate on the TXState.
-      
-      proxies = this.hostedTXStates.values().toArray(new TXStateProxy[this.hostedTXStates.size()]);      
+
+      proxies = this.hostedTXStates.values().toArray(new TXStateProxy[this.hostedTXStates.size()]);
-    
-    for (TXStateProxy proxy: proxies) {
+
+    for (TXStateProxy proxy : proxies) {
-    for (TXStateProxy proxy: this.localTxMap.values()) {
+    for (TXStateProxy proxy : this.localTxMap.values()) {
-      for (int i=0; i < listeners.length; i++) {
+      for (int i = 0; i < listeners.length; i++) {
+
-    } 
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.error(LocalizedMessage.create(LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
+      logger.error(LocalizedMessage
+          .create(LocalizedStrings.TXManagerImpl_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
+
-   * If the current thread is in a transaction then suspend will
-   * cause it to no longer be in a transaction.
-   * @return the state of the transaction or null. Pass this value
-   *  to {@link TXManagerImpl#resume} to reactivate the suspended transaction.
+   * If the current thread is in a transaction then suspend will cause it to no longer be in a
+   * transaction.
+   * 
+   * @return the state of the transaction or null. Pass this value to {@link TXManagerImpl#resume}
+   *         to reactivate the suspended transaction.
+
+   * 
-        throw new java.lang.IllegalStateException(LocalizedStrings.TXManagerImpl_TRANSACTION_0_ALREADY_IN_PROGRESS.toLocalizedString(tid));
+        throw new java.lang.IllegalStateException(
+            LocalizedStrings.TXManagerImpl_TRANSACTION_0_ALREADY_IN_PROGRESS
+                .toLocalizedString(tid));
+
-  
+
-    if(currentInstance==null) {
+    if (currentInstance == null) {
-  
-  
-  
-  
+
+
+
-    if(currentInstance==null) {
+    if (currentInstance == null) {
-  
+
-    if(currentInstance != null) {
+    if (currentInstance != null) {
-  
+
-   * Associate the remote txState with the thread processing this message. Also,
-   * we acquire a lock on the txState, on which this thread operates.
-   * Some messages like SizeMessage should not create a new txState.
+   * Associate the remote txState with the thread processing this message. Also, we acquire a lock
+   * on the txState, on which this thread operates. Some messages like SizeMessage should not create
+   * a new txState.
+   * 
-   * @throws InterruptedException 
+   * @throws InterruptedException
-      synchronized(this.hostedTXStates) {
+      synchronized (this.hostedTXStates) {
-            val.setLocalTXState(new DistTXState(val,true));
+            val.setLocalTXState(new DistTXState(val, true));
-            val.setLocalTXState(new TXState(val,true));
+            val.setLocalTXState(new TXState(val, true));
-            //Another thread should complete the transaction
-            logger.info("{} has already finished." , val.getTxId());
+            // Another thread should complete the transaction
+            logger.info("{} has already finished.", val.getTxId());
-            //Failover op replaced with a new TXStateProxyImpl
-            //Use the new one instead.
+            // Failover op replaced with a new TXStateProxyImpl
+            // Use the new one instead.
-  
+
-   * Associate the remote txState with the thread processing this message. Also,
-   * we acquire a lock on the txState, on which this thread operates.
-   * Some messages like SizeMessage should not create a new txState.
+   * Associate the remote txState with the thread processing this message. Also, we acquire a lock
+   * on the txState, on which this thread operates. Some messages like SizeMessage should not create
+   * a new txState.
+   * 
-   * @throws InterruptedException 
+   * @throws InterruptedException
-  public TXStateProxy masqueradeAs(Message msg,InternalDistributedMember memberId, boolean probeOnly) throws InterruptedException {
+  public TXStateProxy masqueradeAs(Message msg, InternalDistributedMember memberId,
+      boolean probeOnly) throws InterruptedException {
-      synchronized(this.hostedTXStates) {
+      synchronized (this.hostedTXStates) {
-          // [sjigyasu] TODO: Conditionally create object based on distributed or non-distributed tx mode 
-          if (msg instanceof TransactionMessage && ((TransactionMessage)msg).isTransactionDistributed()) {
+          // [sjigyasu] TODO: Conditionally create object based on distributed or non-distributed tx
+          // mode
+          if (msg instanceof TransactionMessage
+              && ((TransactionMessage) msg).isTransactionDistributed()) {
-            //val.setLocalTXState(new DistTXState(val,true));
+            // val.setLocalTXState(new DistTXState(val,true));
-            //val.setLocalTXState(new TXState(val,true));
+            // val.setLocalTXState(new TXState(val,true));
-  
-  
-  
-  
+
+
+
+   * 
+   * 
-   * @param txId  
+   * 
+   * @param txId
-  
+
-   * Called when the CacheServer is shutdown.
-   * Removes txStates hosted on client's behalf
+   * Called when the CacheServer is shutdown. Removes txStates hosted on client's behalf
-  
+
+   * 
-  
+
+
-      Iterator<Map.Entry<TXId,TXStateProxy>> iterator = this.hostedTXStates.entrySet().iterator();
+      Iterator<Map.Entry<TXId, TXStateProxy>> iterator = this.hostedTXStates.entrySet().iterator();
-        Map.Entry<TXId,TXStateProxy> me = iterator.next();
+        Map.Entry<TXId, TXStateProxy> me = iterator.next();
-  public void memberJoined(InternalDistributedMember id) {
-  }
+  public void memberJoined(InternalDistributedMember id) {}
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-  }
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected, String reason) {
-  }
-  
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {}
+
+   * 
-      for (Map.Entry<TXId, TXStateProxy> entry: this.hostedTXStates.entrySet()) {
+      for (Map.Entry<TXId, TXStateProxy> entry : this.hostedTXStates.entrySet()) {
-  
+
+   * 
-      for (Map.Entry<TXId, TXStateProxy> entry: this.hostedTXStates.entrySet()) {
+      for (Map.Entry<TXId, TXStateProxy> entry : this.hostedTXStates.entrySet()) {
-        Map.Entry<TXId,TXStateProxy> entry = iterator.next();
+        Map.Entry<TXId, TXStateProxy> entry = iterator.next();
-        logger.debug("TX: storing client initiated transaction:{}; now there are {} entries in the failoverMap",
+        logger.debug(
+            "TX: storing client initiated transaction:{}; now there are {} entries in the failoverMap",
-        logger.debug("TX: storing client initiated transaction:{}; now there are {} entries in the failoverMap",
+        logger.debug(
+            "TX: storing client initiated transaction:{}; now there are {} entries in the failoverMap",
-  
+
-    synchronized(failoverMap) {
+    synchronized (failoverMap) {
-  
-  
+
+
-   * If the given transaction is already being completed by another thread
-   * this will wait for that completion to finish and will ensure that
-   * the result is saved in the client failover map.
+   * If the given transaction is already being completed by another thread this will wait for that
+   * completion to finish and will ensure that the result is saved in the client failover map.
+   * 
-      synchronized(this.hostedTXStates) {
+      synchronized (this.hostedTXStates) {
-      TXStateProxyImpl impl = (TXStateProxyImpl)val;
+      TXStateProxyImpl impl = (TXStateProxyImpl) val;
-        //saveTXStateForClientFailover(impl);
+        // saveTXStateForClientFailover(impl);
-  
+
-   * Returns the TXCommitMessage for a transaction that has been
-   * successfully completed.
+   * Returns the TXCommitMessage for a transaction that has been successfully completed.
+   * 
-   * @return the commit message or an exception token e.g 
-   * {@link TXCommitMessage#CMT_CONFLICT_MSG} if the transaction
-   * threw an exception
+   * @return the commit message or an exception token e.g {@link TXCommitMessage#CMT_CONFLICT_MSG}
+   *         if the transaction threw an exception
-    if (msg == TXCommitMessage.CMT_CONFLICT_MSG
-        || msg == TXCommitMessage.REBALANCE_MSG
+    if (msg == TXCommitMessage.CMT_CONFLICT_MSG || msg == TXCommitMessage.REBALANCE_MSG
-  
+
-   * Generates exception messages for the three TXCommitMessage tokens that represent
-   * exceptions during transaction execution. 
+   * Generates exception messages for the three TXCommitMessage tokens that represent exceptions
+   * during transaction execution.
+   * 
-      return new CommitConflictException(LocalizedStrings.
-            TXState_CONFLICT_DETECTED_IN_GEMFIRE_TRANSACTION_0.toLocalizedString(txId));
+      return new CommitConflictException(
+          LocalizedStrings.TXState_CONFLICT_DETECTED_IN_GEMFIRE_TRANSACTION_0
+              .toLocalizedString(txId));
-      return new TransactionDataRebalancedException(LocalizedStrings.
-          PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING.toLocalizedString());
+      return new TransactionDataRebalancedException(
+          LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
+              .toLocalizedString());
-      return new TransactionInDoubtException(LocalizedStrings.
-          ClientTXStateStub_COMMIT_FAILED_ON_SERVER.toLocalizedString());
+      return new TransactionInDoubtException(
+          LocalizedStrings.ClientTXStateStub_COMMIT_FAILED_ON_SERVER.toLocalizedString());
-  
+
-    public TXRemovalMessage() {
-    }
+    public TXRemovalMessage() {}
-    
+
-      DataSerializer.writeHashSet((HashSet<TXId>)this.txIds, out);
+      DataSerializer.writeHashSet((HashSet<TXId>) this.txIds, out);
-    
+
-    
+
-  private ConcurrentMap<TransactionId, TXStateProxy> suspendedTXs = new ConcurrentHashMap<TransactionId, TXStateProxy>();
-  
+  private ConcurrentMap<TransactionId, TXStateProxy> suspendedTXs =
+      new ConcurrentHashMap<TransactionId, TXStateProxy>();
+
-  
+
-          if (waitingThread == null
-              || !Thread.currentThread().equals(waitingThread)) {
+          if (waitingThread == null || !Thread.currentThread().equals(waitingThread)) {
-          LocalizedStrings.TXManagerImpl_UNKNOWN_TRANSACTION_OR_RESUMED
-              .toLocalizedString());
+          LocalizedStrings.TXManagerImpl_UNKNOWN_TRANSACTION_OR_RESUMED.toLocalizedString());
-          LocalizedStrings.TXManagerImpl_TRANSACTION_ACTIVE_CANNOT_RESUME
-              .toLocalizedString());
+          LocalizedStrings.TXManagerImpl_TRANSACTION_ACTIVE_CANNOT_RESUME.toLocalizedString());
-          LocalizedStrings.TXManagerImpl_UNKNOWN_TRANSACTION_OR_RESUMED
-              .toLocalizedString());
+          LocalizedStrings.TXManagerImpl_UNKNOWN_TRANSACTION_OR_RESUMED.toLocalizedString());
-  
+
-   * {@link #tryResume(TransactionId, long, TimeUnit)} for a particular
-   * transactionId
+   * {@link #tryResume(TransactionId, long, TimeUnit)} for a particular transactionId
-  private ConcurrentMap<TransactionId, Queue<Thread>> waitMap = new ConcurrentHashMap<TransactionId, Queue<Thread>>();
-  
+  private ConcurrentMap<TransactionId, Queue<Thread>> waitMap =
+      new ConcurrentHashMap<TransactionId, Queue<Thread>>();
+
-    return isHostedTxInProgress((TXId) transactionId)
-        || isSuspended(transactionId)
+    return isHostedTxInProgress((TXId) transactionId) || isSuspended(transactionId)
-   * The timeout after which any suspended transactions are
-   * rolled back if they are not resumed. If a negative
-   * timeout is passed, suspended transactions will never expire.
+   * The timeout after which any suspended transactions are rolled back if they are not resumed. If
+   * a negative timeout is passed, suspended transactions will never expire.
+   * 
-   * Return the timeout after which suspended transactions
-   * are rolled back.
+   * Return the timeout after which suspended transactions are rolled back.
+   * 
-  
+
-  private ConcurrentMap<TransactionId, SystemTimerTask> expiryTasks = new ConcurrentHashMap<TransactionId, SystemTimerTask>();
-  
+  private ConcurrentMap<TransactionId, SystemTimerTask> expiryTasks =
+      new ConcurrentHashMap<TransactionId, SystemTimerTask>();
+
+   * 
-    cache.getCCPTimer().schedule(task, TimeUnit.MILLISECONDS.convert(suspendedTXTimeout, expiryTimeUnit));
+    cache.getCCPTimer().schedule(task,
+        TimeUnit.MILLISECONDS.convert(suspendedTXTimeout, expiryTimeUnit));
-   * Task scheduled to expire a transaction when it is suspended.
-   * This task gets canceled if the transaction is resumed.
+   * Task scheduled to expire a transaction when it is suspended. This task gets canceled if the
+   * transaction is resumed.
-    
+
+
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TXManagerImpl_EXCEPTION_IN_TRANSACTION_TIMEOUT, txId), e);
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.TXManagerImpl_EXCEPTION_IN_TRANSACTION_TIMEOUT, txId), e);
-  private static class RefCountMapEntryCreator implements CustomEntryConcurrentHashMap.HashEntryCreator<AbstractRegionEntry, RefCountMapEntry> {
+  private static class RefCountMapEntryCreator implements
+      CustomEntryConcurrentHashMap.HashEntryCreator<AbstractRegionEntry, RefCountMapEntry> {
-    public HashEntry<AbstractRegionEntry, RefCountMapEntry> newEntry(AbstractRegionEntry key, int hash,
-        HashEntry<AbstractRegionEntry, RefCountMapEntry> next, RefCountMapEntry value) {
+    public HashEntry<AbstractRegionEntry, RefCountMapEntry> newEntry(AbstractRegionEntry key,
+        int hash, HashEntry<AbstractRegionEntry, RefCountMapEntry> next, RefCountMapEntry value) {
-  private static class RefCountMapEntry implements HashEntry<AbstractRegionEntry, RefCountMapEntry> {
+  private static class RefCountMapEntry
+      implements HashEntry<AbstractRegionEntry, RefCountMapEntry> {
-    private static final AtomicIntegerFieldUpdater<RefCountMapEntry> refCountUpdater
-      = AtomicIntegerFieldUpdater.newUpdater(RefCountMapEntry.class, "refCount");    
+    private static final AtomicIntegerFieldUpdater<RefCountMapEntry> refCountUpdater =
+        AtomicIntegerFieldUpdater.newUpdater(RefCountMapEntry.class, "refCount");
+
-  
-  private final CustomEntryConcurrentHashMap<AbstractRegionEntry, RefCountMapEntry> refCountMap
-    = new CustomEntryConcurrentHashMap<AbstractRegionEntry, RefCountMapEntry>(
-        CustomEntryConcurrentHashMap.DEFAULT_INITIAL_CAPACITY, 
-        CustomEntryConcurrentHashMap.DEFAULT_LOAD_FACTOR,
-        CustomEntryConcurrentHashMap.DEFAULT_CONCURRENCY_LEVEL,
-        true,
-        new RefCountMapEntryCreator());
-  
-  private static final MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object> incCallback = new MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object>() {
-    @Override
-    public RefCountMapEntry newValue(AbstractRegionEntry key, Object context,
-        Object createParams) {
-      return new RefCountMapEntry(key);
-    }
-    @Override
-    public void oldValueRead(RefCountMapEntry value) {
-      value.incRefCount();
-    }
-    @Override
-    public boolean doRemoveValue(RefCountMapEntry value, Object context,
-        Object removeParams) {
-      throw new IllegalStateException("doRemoveValue should not be called from create");
-    }
-  };
-  
-  private static final MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object> decCallback = new MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object>() {
-    @Override
-    public RefCountMapEntry newValue(AbstractRegionEntry key, Object context,
-        Object createParams) {
-      throw new IllegalStateException("newValue should not be called from remove");
-    }
-    @Override
-    public void oldValueRead(RefCountMapEntry value) {
-      throw new IllegalStateException("oldValueRead should not be called from remove");
-    }
-    @Override
-    public boolean doRemoveValue(RefCountMapEntry value, Object context,
-        Object removeParams) {
-      return value.decRefCount();
-    }
-  };
-  
+
+  private final CustomEntryConcurrentHashMap<AbstractRegionEntry, RefCountMapEntry> refCountMap =
+      new CustomEntryConcurrentHashMap<AbstractRegionEntry, RefCountMapEntry>(
+          CustomEntryConcurrentHashMap.DEFAULT_INITIAL_CAPACITY,
+          CustomEntryConcurrentHashMap.DEFAULT_LOAD_FACTOR,
+          CustomEntryConcurrentHashMap.DEFAULT_CONCURRENCY_LEVEL, true,
+          new RefCountMapEntryCreator());
+
+  private static final MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object> incCallback =
+      new MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object>() {
+        @Override
+        public RefCountMapEntry newValue(AbstractRegionEntry key, Object context,
+            Object createParams) {
+          return new RefCountMapEntry(key);
+        }
+
+        @Override
+        public void oldValueRead(RefCountMapEntry value) {
+          value.incRefCount();
+        }
+
+        @Override
+        public boolean doRemoveValue(RefCountMapEntry value, Object context, Object removeParams) {
+          throw new IllegalStateException("doRemoveValue should not be called from create");
+        }
+      };
+
+  private static final MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object> decCallback =
+      new MapCallback<AbstractRegionEntry, RefCountMapEntry, Object, Object>() {
+        @Override
+        public RefCountMapEntry newValue(AbstractRegionEntry key, Object context,
+            Object createParams) {
+          throw new IllegalStateException("newValue should not be called from remove");
+        }
+
+        @Override
+        public void oldValueRead(RefCountMapEntry value) {
+          throw new IllegalStateException("oldValueRead should not be called from remove");
+        }
+
+        @Override
+        public boolean doRemoveValue(RefCountMapEntry value, Object context, Object removeParams) {
+          return value.decRefCount();
+        }
+      };
+
+
-  
+
-  
+
-  
+
-  
-  //expire the transaction states for the lost proxy server based on timeout setting.  
-  private void expireClientTransactionsSentFromDepartedProxy(InternalDistributedMember proxyServer) {
+
+  // expire the transaction states for the lost proxy server based on timeout setting.
+  private void expireClientTransactionsSentFromDepartedProxy(
+      InternalDistributedMember proxyServer) {
-      return; 
+      return;
-      if (departedProxyServers != null) departedProxyServers.add(proxyServer);  
+      if (departedProxyServers != null)
+        departedProxyServers.add(proxyServer);
-          if (departedProxyServers != null) departedProxyServers.remove(proxyServer);
+          if (departedProxyServers != null)
+            departedProxyServers.remove(proxyServer);
-        ((GemFireCacheImpl)this.cache).getCCPTimer().schedule(task, timeout);
+        ((GemFireCacheImpl) this.cache).getCCPTimer().schedule(task, timeout);
-        if (!((GemFireCacheImpl)this.cache).isClosed()) {
+        if (!((GemFireCacheImpl) this.cache).isClosed()) {
-        //task not able to be scheduled due to cache is closing,
-        //do not set it in the test hook.
-        if (departedProxyServers != null) departedProxyServers.remove(proxyServer);
+        // task not able to be scheduled due to cache is closing,
+        // do not set it in the test hook.
+        if (departedProxyServers != null)
+          departedProxyServers.remove(proxyServer);
-  
-  private final Set<InternalDistributedMember> departedProxyServers = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "trackScheduledToBeRemovedTx") ?
-      new ConcurrentHashSet<InternalDistributedMember>() : null;
+
+  private final Set<InternalDistributedMember> departedProxyServers =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "trackScheduledToBeRemovedTx")
+          ? new ConcurrentHashSet<InternalDistributedMember>() : null;
-  
+
-   * Find all client originated transactions sent from the departed proxy server.
-   * Remove them from the hostedTXStates map after the set TransactionTimeToLive period.
+   * Find all client originated transactions sent from the departed proxy server. Remove them from
+   * the hostedTXStates map after the set TransactionTimeToLive period.
+   * 
-        Map.Entry<TXId,TXStateProxy> entry = iterator.next();
+        Map.Entry<TXId, TXStateProxy> entry = iterator.next();
-          //The TXState was not updated by any other proxy server, 
-          //The client would fail over to another proxy server.
-          //Remove it after waiting for transactionTimeToLive period.
+          // The TXState was not updated by any other proxy server,
+          // The client would fail over to another proxy server.
+          // Remove it after waiting for transactionTimeToLive period.
-  
+
-   * retrieve the transaction states for the given client from a certain proxy server.
-   * if transactions failed over, the new proxy server information should be stored
-   * in the TXState
+   * retrieve the transaction states for the given client from a certain proxy server. if
+   * transactions failed over, the new proxy server information should be stored in the TXState
+   * 
+   * 
-      for (Map.Entry<TXId, TXStateProxy> entry: this.hostedTXStates.entrySet()) {
+      for (Map.Entry<TXId, TXStateProxy> entry : this.hostedTXStates.entrySet()) {
-          TXState txstate = (TXState) ((TXStateProxyImpl)tx).realDeal;          
+          TXState txstate = (TXState) ((TXStateProxyImpl) tx).realDeal;
-  
+
-    // Check whether given flag and current flag are different and whether a transaction is in progress
+    // Check whether given flag and current flag are different and whether a transaction is in
+    // progress
-   * If explicitly set using setDistributed, this returns that value.
-   * If not, it returns the value of gemfire property "distributed-transactions" if set.
-   * If this is also not set, it returns the default value of this property.
+   * If explicitly set using setDistributed, this returns that value. If not, it returns the value
+   * of gemfire property "distributed-transactions" if set. If this is also not set, it returns the
+   * default value of this property.
-    
-     Boolean value = isTXDistributed.get();
+
+    Boolean value = isTXDistributed.get();
-  
+

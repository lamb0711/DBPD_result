Making renames and deletes closer to atomic

It's important that when a file is renamed, the new file appears
atomically with all of the data - according to the LuceneDirectory
interface. It's also important that during a delete the file does not
start missing chunks before it is actually deleted.

These changes address those two issues. I've introduced a UUID for the
file that is used instead of the filename as part of the chunk id. When
a file is renamed, the new file just points to the same UUID. Deletes
delete the File object first and the chunks later.

There are still some dangling issues - namely that there can be dangling
chunks for files that have been deleted. But I think the more severe
issues with a lack of atomicity are resolved now.

I've added a couple of unit tests of partial renames and partial
deletes. These tests work by wrapping the underlying "region" with a
wrapper that throws a CacheClosedException after a certain number of
operations have happened - essentially mimicking a member being closed
or killed.

-  public void deleteFile(final String name) {
+  public void deleteFile(final String name) throws FileNotFoundException {
+    File file = fileRegion.remove(name);
+    if(file == null) {
+      throw new FileNotFoundException(name);
+    }
-    final ChunkKey key = new ChunkKey(name, 0);
+    final ChunkKey key = new ChunkKey(file.id, 0);
-    
-    fileRegion.remove(name);
-
+  
-    final File destFile = createFile(dest);
-    
-    // TODO - What is the state of the system if 
-    // things crash in the middle of moving this file?
-    // Seems like a file will be left with some 
-    // dangling chunks at the end of the file
-    
-
+    
+    final File destFile = createFile(dest);
+    
-
-    // TODO copy on write?
-    final ChunkKey sourceKey = new ChunkKey(source, 0);
-    while (true) {
-      byte[] chunk = chunkRegion.remove(sourceKey);
-      if (null == chunk) {
-        // no more chunks
-        break;
-      }
-      putChunk(destFile, sourceKey.chunkId, chunk);
-      sourceKey.chunkId++;
-    }
+    destFile.id = sourceFile.id;
-    updateFile(destFile);
+    // TODO - What is the state of the system if 
+    // things crash in the middle of moving this file?
+    // Seems like we will have two files pointing
+    // at the same data
+
-    final ChunkKey key = new ChunkKey(file.getName(), id);
+    final ChunkKey key = new ChunkKey(file.id, id);
-    final ChunkKey key = new ChunkKey(file.getName(), id);
+    final ChunkKey key = new ChunkKey(file.id, id);

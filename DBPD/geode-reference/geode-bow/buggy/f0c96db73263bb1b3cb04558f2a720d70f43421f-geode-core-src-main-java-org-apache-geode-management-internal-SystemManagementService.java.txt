GEODE-7330: Prevent RegionDestroyedException in FederatingManager (#4193)

* GEODE-7330: Prevent RegionDestroyedException in FederatingManager

Cleanup management classes:
* Reduce method and field visibility as much as possible
* Remove unnecessary uses of this
* Reorder fields and methods based on visibility and other modifiers
* Use @VisibleForTesting annotation
* Fixup formatting and variable names

Make all FederatingManager fields final:
* Remove field setters for tests
* Introduce FederatingManagerFactory
* Add FederatingManagerFactory system property for tests to
  SystemManagementService
* Inject all FederatingManager fields via constructor
* Use Geode APIs in MBeanFederationErrorPathDUnitTest

Rename MBeanFederationErrorHandlingDistributedTest:
* Rename MBeanFederationErrorPathDUnitTest as
  MBeanFederationErrorHandlingDistributedTest
+import static java.util.Arrays.asList;
+import static java.util.stream.Collectors.toSet;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Collection;
-import java.util.stream.Collectors;
+import java.util.concurrent.ExecutorService;
+import org.apache.geode.annotations.Immutable;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.internal.logging.LoggingExecutors;
-import org.apache.geode.management.internal.beans.ManagementAdapter;
+  @Immutable
+  @VisibleForTesting
+  static final String FEDERATING_MANAGER_FACTORY_PROPERTY = "FEDERATING_MANAGER_FACTORY";
+
-   * core component for distribution
-   */
-  private LocalManager localManager;
-
-  /**
-   * whether the service is closed or not if cache is closed automatically this service will be
-   * closed
-   */
-  private volatile boolean closed = false;
-
-  /**
-   * has the management service has started yet
-   */
-  private volatile boolean isStarted = false;
-
-  /**
-  private FederatingManager federatingManager;
-
-   * This membership listener will listen on membership events after the node has transformed into a
-   * Managing node.
-   */
-  private ManagementMembershipListener listener;
-
-  /**
+  private final FederatingManagerFactory federatingManagerFactory;
-  public static BaseManagementService newSystemManagementService(
+  /**
+   * whether the service is closed or not if cache is closed automatically this service will be
+   * closed
+   */
+  private volatile boolean closed;
+
+  /**
+   * has the management service has started yet
+   */
+  private volatile boolean isStarted;
+
+  private LocalManager localManager;
+
+  private FederatingManager federatingManager;
+
+  /**
+   * This membership listener will listen on membership events after the node has transformed into a
+   * Managing node.
+   */
+  private ManagementMembershipListener listener;
+
+  static BaseManagementService newSystemManagementService(
-  protected SystemManagementService(InternalCacheForClientAccess cache) {
+  private SystemManagementService(InternalCacheForClientAccess cache) {
-    this.system = cache.getInternalDistributedSystem();
-    // This is a safe check to ensure Management service does not start for a
-    // system which is disconnected.
-    // Most likely scenario when this will happen is when a cache is closed and we are at this
-    // point.
+    system = cache.getInternalDistributedSystem();
+
+    jmxAdapter = new MBeanJMXAdapter(system.getDistributedMember());
+    repo = new ManagementResourceRepo();
+    notificationHub = new NotificationHub(repo);
-    this.jmxAdapter = new MBeanJMXAdapter(this.system.getDistributedMember());
-    this.repo = new ManagementResourceRepo();
-
-    this.notificationHub = new NotificationHub(repo);
-      this.agent = new ManagementAgent(system.getConfig(), cache);
+      agent = new ManagementAgent(system.getConfig(), cache);
-      this.agent = null;
+      agent = null;
-    ManagementFunction function = new ManagementFunction(notificationHub);
-    FunctionService.registerFunction(function);
-    this.proxyListeners = new CopyOnWriteArrayList<>();
-  }
-  /**
-   * This method will initialize all the internal components for Management and Monitoring
-   *
-   * It will a)start an JMX connectorServer b) create a notification hub c)register the
-   * ManagementFunction
-   */
-  private SystemManagementService init() {
-    try {
-      this.localManager =
-          new LocalManager(repo, system, this, cache, statisticsFactory, statisticsClock);
-      this.localManager.startManager();
-      this.listener = new ManagementMembershipListener(this);
-      system.getDistributionManager().addMembershipListener(listener);
-      isStarted = true;
-      return this;
-    } catch (CancelException e) {
-      // Rethrow all CancelExceptions (fix for defect 46339)
-      throw e;
-    } catch (Exception e) {
-      // Wrap all other exceptions as ManagementExceptions
-      logger.error(e.getMessage(), e);
-      throw new ManagementException(e);
-    }
-  }
+    FunctionService.registerFunction(new ManagementFunction(notificationHub));
-  /**
-   * For internal Use only
-   */
-  public LocalManager getLocalManager() {
-    return localManager;
-  }
-
-  public NotificationHub getNotificationHub() {
-    return notificationHub;
-  }
-
-  public FederatingManager getFederatingManager() {
-    return federatingManager;
-  }
-
-  public MBeanJMXAdapter getJMXAdapter() {
-    return jmxAdapter;
-  }
-
-  public ManagementAgent getManagementAgent() {
-    return agent;
-  }
-
-  public boolean isStartedAndOpen() {
-    return isStarted && !closed && system.isConnected();
-  }
-
-  private void verifyManagementService() {
-    if (!isStarted) {
-      throw new ManagementException(
-          "Management Service Not Started Yet");
-    }
-    if (!system.isConnected()) {
-      throw new ManagementException(
-          "Not Connected To Distributed System");
-    }
-    if (closed) {
-      throw new ManagementException(
-          "Management Service Is Closed");
-    }
+    proxyListeners = new CopyOnWriteArrayList<>();
+    federatingManagerFactory = createFederatingManagerFactory();
-        // its a no op, hence not logging any exception
+
-      // Stop the Federating Manager first . It will ensure MBeans are not getting federated.
-      // while un-registering
+      // Stop the Federating Manager first to avoid federating while un-registering
-      this.notificationHub.cleanUpListeners();
+      notificationHub.cleanUpListeners();
-      if (this.agent != null && this.agent.isRunning()) {
-        this.agent.stopAgent();
+      if (agent != null && agent.isRunning()) {
+        agent.stopAgent();
-      getInternalCache().getJmxManagerAdvisor().broadcastChange();
+      cache.getJmxManagerAdvisor().broadcastChange();
-    if (!objectName.getDomain().equalsIgnoreCase(ManagementConstants.OBJECTNAME__DEFAULTDOMAIN)) {
-      throw new ManagementException(
-          "Not A GemFire Domain MBean, can not Federate");
-    }
+    if (!objectName.getDomain().equalsIgnoreCase(ManagementConstants.OBJECTNAME__DEFAULTDOMAIN)) {
+      throw new ManagementException("Not A GemFire Domain MBean, can not Federate");
+    }
-      throw new ManagementException(
-          "MBean Not Registered In GemFire Domain");
+      throw new ManagementException("MBean Not Registered In GemFire Domain");
-      throw new ManagementException(
-          "MBean Does Not Have Notification Support");
+      throw new ManagementException("MBean Does Not Have Notification Support");
-    FederationComponent fedComp =
+    FederationComponent federationComponent =
-    if (ManagementAdapter.refreshOnInit.contains(interfaceClass)) {
-      fedComp.refreshObjectState(true);// Fixes 46387
+    if (asList(RegionMXBean.class, MemberMXBean.class).contains(interfaceClass)) {
+      federationComponent.refreshObjectState(true);
-    localManager.markForFederation(objectName, fedComp);
+    localManager.markForFederation(objectName, federationComponent);
-      afterCreateProxy(objectName, interfaceClass, object, fedComp);
+      afterCreateProxy(objectName, interfaceClass, object, federationComponent);
-
-    } else if (!federatingManager.isRunning()) {
+    }
+    if (!federatingManager.isRunning()) {
-  public <T> T getMBeanProxy(ObjectName objectName, Class<T> interfaceClass) {
-    if (!isStartedAndOpen()) {
-      return null;
-    }
-    if (federatingManager == null) {
-      return null;
-
-    } else if (!federatingManager.isRunning()) {
-      return null;
-    }
-
-    return federatingManager.findProxy(objectName, interfaceClass);
-  }
-
-    } else {
-      if (federatingManager == null) {
-        return Collections.emptySet();
-
-      } else if (!federatingManager.isRunning()) {
-        return Collections.emptySet();
-      }
-      return federatingManager.findAllProxies(member);
+    if (federatingManager == null) {
+      return Collections.emptySet();
+    }
+    if (!federatingManager.isRunning()) {
+      return Collections.emptySet();
+    }
+    return federatingManager.findAllProxies(member);
-    Set<ObjectName> mBeanNames = this.queryMBeanNames(member);
-    return mBeanNames.stream().filter(x -> "AsyncEventQueue".equals(x.getKeyProperty("service")))
-        .collect(Collectors.toSet());
+    return queryMBeanNames(member).stream()
+        .filter(x -> "AsyncEventQueue".equals(x.getKeyProperty("service")))
+        .collect(toSet());
-  public ObjectName registerInternalMBean(Object object, ObjectName objectName) {
-    verifyManagementService();
-    return jmxAdapter.registerMBean(object, objectName, true);
-  }
-
+
-      FederationComponent removedObj = localManager.getFedComponents().get(objectName);
-      if (removedObj != null) { // only for MBeans local to Manager , not
-                                // proxies
-        afterRemoveProxy(objectName, removedObj.getInterfaceClass(), removedObj.getMBeanObject(),
-            removedObj);
+      FederationComponent removed = localManager.getFedComponents().get(objectName);
+      if (removed != null) {
+        // only for MBeans local to Manager, not proxies
+        afterRemoveProxy(objectName, removed.getInterfaceClass(), removed.getMBeanObject(),
+            removed);
-  public boolean isManagerCreated() {
-    return isStartedAndOpen() && federatingManager != null;
-  }
-
-    if (!getInternalCache().getInternalDistributedSystem().getConfig().getJmxManager()) {
-      // fix for 45900
+    if (!cache.getInternalDistributedSystem().getConfig().getJmxManager()) {
+
+
+
-          if (this.agent != null) {
-            this.agent.startAgent();
+          if (agent != null) {
+            agent.startAgent();
-          getInternalCache().getJmxManagerAdvisor().broadcastChange();
+          cache.getJmxManagerAdvisor().broadcastChange();
-  private InternalCache getInternalCache() {
-    return this.cache;
-  }
-
-  /**
-   * Creates a Manager instance in stopped state.
-   */
-  public boolean createManager() {
-    synchronized (instances) {
-      if (federatingManager != null) {
-        return false;
-      }
-      system.handleResourceEvent(ResourceEvent.MANAGER_CREATE, null);
-      // An initialised copy of federating manager
-      federatingManager = new FederatingManager(jmxAdapter, repo, system, this, cache,
-          statisticsFactory, statisticsClock);
-      getInternalCache().getJmxManagerAdvisor().broadcastChange();
-      return true;
-    }
-  }
-
-        getInternalCache().getJmxManagerAdvisor().broadcastChange();
-        if (this.agent != null && this.agent.isRunning()) {
-          this.agent.stopAgent();
+        cache.getJmxManagerAdvisor().broadcastChange();
+        if (agent != null && agent.isRunning()) {
+          agent.stopAgent();
-  public void addProxyListener(ProxyListener listener) {
-    this.proxyListeners.add(listener);
-  }
-
-  public void removeProxyListener(ProxyListener listener) {
-    this.proxyListeners.remove(listener);
-  }
-
-  public List<ProxyListener> getProxyListeners() {
-    return this.proxyListeners;
-  }
-
-  public boolean afterCreateProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
+  @Override
+  public <T> T getMBeanInstance(ObjectName objectName, Class<T> interfaceClass) {
+    if (jmxAdapter.isLocalMBean(objectName)) {
+      return jmxAdapter.findMBeanByName(objectName, interfaceClass);
+    }
+    return getMBeanProxy(objectName, interfaceClass);
+  }
+
+  @Override
+  public void addMembershipListener(MembershipListener listener) {
+    universalListenerContainer.addMembershipListener(listener);
+  }
+
+  @Override
+  public void removeMembershipListener(MembershipListener listener) {
+    universalListenerContainer.removeMembershipListener(listener);
+  }
+
+  public LocalManager getLocalManager() {
+    return localManager;
+  }
+
+  public FederatingManager getFederatingManager() {
+    return federatingManager;
+  }
+
+  public MBeanJMXAdapter getJMXAdapter() {
+    return jmxAdapter;
+  }
+
+  public ManagementAgent getManagementAgent() {
+    return agent;
+  }
+
+  public <T> T getMBeanProxy(ObjectName objectName, Class<T> interfaceClass) {
+    if (!isStartedAndOpen()) {
+      return null;
+    }
+    if (federatingManager == null) {
+      return null;
+    }
+    if (!federatingManager.isRunning()) {
+      return null;
+    }
+    return federatingManager.findProxy(objectName, interfaceClass);
+  }
+
+  public ObjectName registerInternalMBean(Object object, ObjectName objectName) {
+    verifyManagementService();
+    return jmxAdapter.registerMBean(object, objectName, true);
+  }
+
+  public boolean isManagerCreated() {
+    return isStartedAndOpen() && federatingManager != null;
+  }
+
+  /**
+   * Creates a Manager instance in stopped state.
+   */
+  public boolean createManager() {
+    synchronized (instances) {
+      if (federatingManager != null) {
+        return false;
+      }
+      system.handleResourceEvent(ResourceEvent.MANAGER_CREATE, null);
+      // An initialised copy of federating manager
+      federatingManager = federatingManagerFactory.create(repo, system, this, cache,
+          statisticsFactory, statisticsClock, new MBeanProxyFactory(jmxAdapter, this),
+          new MemberMessenger(jmxAdapter, system),
+          LoggingExecutors.newFixedThreadPool("FederatingManager", true,
+              Runtime.getRuntime().availableProcessors()));
+      cache.getJmxManagerAdvisor().broadcastChange();
+      return true;
+    }
+  }
+
+  public void addProxyListener(ProxyListener listener) {
+    proxyListeners.add(listener);
+  }
+
+  public void removeProxyListener(ProxyListener listener) {
+    proxyListeners.remove(listener);
+  }
+
+  public void afterCreateProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
-    return true;
-  public boolean afterPseudoCreateProxy(ObjectName objectName, Class interfaceClass,
-      Object proxyObject, FederationComponent newVal) {
-    for (ProxyListener listener : proxyListeners) {
-      listener.afterPseudoCreateProxy(objectName, interfaceClass, proxyObject, newVal);
-    }
-    return true;
-  }
-
-  public boolean afterRemoveProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
+  public void afterRemoveProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
-    return true;
-  }
-
-  public boolean afterUpdateProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
-      FederationComponent newVal, FederationComponent oldVal) {
-    for (ProxyListener listener : proxyListeners) {
-      listener.afterUpdateProxy(objectName, interfaceClass, proxyObject, newVal, oldVal);
-    }
-    return true;
-  @Override
-  public <T> T getMBeanInstance(ObjectName objectName, Class<T> interfaceClass) {
-    if (jmxAdapter.isLocalMBean(objectName)) {
-      return jmxAdapter.findMBeanByName(objectName, interfaceClass);
-    } else {
-      return this.getMBeanProxy(objectName, interfaceClass);
-    }
-  }
-
-  public void logFine(String s) {
-    if (logger.isDebugEnabled()) {
-      logger.debug(s);
-    }
-  }
-
-  public void memberJoined(InternalDistributedMember id) {
+  void memberJoined(InternalDistributedMember id) {
-  public void memberDeparted(InternalDistributedMember id, boolean crashed) {
+  void memberDeparted(InternalDistributedMember id, boolean crashed) {
-  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+  void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
-  public void quorumLost(Set<InternalDistributedMember> failures,
-      List<InternalDistributedMember> remaining) {
+  void afterPseudoCreateProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
+      FederationComponent newVal) {
-      listener.quorumLost(system.getDistributionManager(), failures, remaining);
+      listener.afterPseudoCreateProxy(objectName, interfaceClass, proxyObject, newVal);
-  public static class UniversalListenerContainer {
+  boolean isStartedAndOpen() {
+    return isStarted && !closed && system.isConnected();
+  }
-    private List<MembershipListener> membershipListeners = new CopyOnWriteArrayList<>();
+  void afterUpdateProxy(ObjectName objectName, Class interfaceClass, Object proxyObject,
+      FederationComponent newVal, FederationComponent oldVal) {
+    for (ProxyListener listener : proxyListeners) {
+      listener.afterUpdateProxy(objectName, interfaceClass, proxyObject, newVal, oldVal);
+    }
+  }
-    public void memberJoined(InternalDistributedMember id) {
+  UniversalListenerContainer getUniversalListenerContainer() {
+    return universalListenerContainer;
+  }
+
+  private void verifyManagementService() {
+    if (!isStarted) {
+      throw new ManagementException(
+          "Management Service Not Started Yet");
+    }
+    if (!system.isConnected()) {
+      throw new ManagementException(
+          "Not Connected To Distributed System");
+    }
+    if (closed) {
+      throw new ManagementException(
+          "Management Service Is Closed");
+    }
+  }
+
+  /**
+   * This method will initialize all the internal components for Management and Monitoring
+   *
+   * It will: <br>
+   * a) start an JMX connectorServer <br>
+   * b) create a notification hub <br>
+   * c) register the ManagementFunction
+   */
+  private SystemManagementService init() {
+    try {
+      localManager =
+          new LocalManager(repo, system, this, cache, statisticsFactory, statisticsClock);
+      listener = new ManagementMembershipListener(this);
+
+      localManager.startManager();
+      system.getDistributionManager().addMembershipListener(listener);
+      isStarted = true;
+      return this;
+    } catch (CancelException e) {
+      // Rethrow all CancelExceptions
+      throw e;
+    } catch (Exception e) {
+      // Wrap all other exceptions as ManagementExceptions
+      logger.error(e.getMessage(), e);
+      throw new ManagementException(e);
+    }
+  }
+
+  private static FederatingManagerFactory createFederatingManagerFactory() {
+    try {
+      String federatingManagerFactoryName =
+          System.getProperty(FEDERATING_MANAGER_FACTORY_PROPERTY,
+              FederatingManagerFactoryImpl.class.getName());
+      Class<? extends FederatingManagerFactory> federatingManagerFactoryClass =
+          Class.forName(federatingManagerFactoryName)
+              .asSubclass(FederatingManagerFactory.class);
+      Constructor<? extends FederatingManagerFactory> constructor =
+          federatingManagerFactoryClass.getConstructor();
+      return constructor.newInstance();
+    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
+        | NoSuchMethodException | InvocationTargetException e) {
+      return new FederatingManagerFactoryImpl();
+    }
+  }
+
+  @VisibleForTesting
+  public NotificationHub getNotificationHub() {
+    return notificationHub;
+  }
+
+  private static class FederatingManagerFactoryImpl implements FederatingManagerFactory {
+
+    public FederatingManagerFactoryImpl() {
+      // must be public for instantiation by reflection
+    }
+
+    @Override
+    public FederatingManager create(ManagementResourceRepo repo, InternalDistributedSystem system,
+        SystemManagementService service, InternalCache cache, StatisticsFactory statisticsFactory,
+        StatisticsClock statisticsClock, MBeanProxyFactory proxyFactory, MemberMessenger messenger,
+        ExecutorService executorService) {
+      return new FederatingManager(repo, system, service, cache, statisticsFactory,
+          statisticsClock, proxyFactory, messenger, executorService);
+    }
+  }
+
+  static class UniversalListenerContainer {
+
+    private final Collection<MembershipListener> membershipListeners = new CopyOnWriteArrayList<>();
+
+    void memberJoined(InternalDistributedMember id) {
-    public void memberDeparted(InternalDistributedMember id, boolean crashed) {
+    void memberDeparted(InternalDistributedMember id, boolean crashed) {
-      if (!crashed) {
-        for (MembershipListener listener : membershipListeners) {
-          try {
-            listener.memberLeft(event);
-          } catch (Exception e) {
-            logger.error("Could not invoke listener event memberLeft for listener[{}] due to ",
-                listener.getClass(), e.getMessage(), e);
-          }
-        }
-      } else {
+      if (crashed) {
+      } else {
+        for (MembershipListener listener : membershipListeners) {
+          try {
+            listener.memberLeft(event);
+          } catch (Exception e) {
+            logger.error("Could not invoke listener event memberLeft for listener[{}] due to ",
+                listener.getClass(), e.getMessage(), e);
+          }
+        }
-    private MembershipEvent createEvent(InternalDistributedMember id) {
-      final String memberId = id.getId();
-      final DistributedMember member = id;
-
-      return new MembershipEvent() {
-
-        @Override
-        public String getMemberId() {
-          return memberId;
-        }
-
-        @Override
-        public DistributedMember getDistributedMember() {
-          return member;
-        }
-      };
-    }
-
-    public void addMembershipListener(MembershipListener listener) {
+    private void addMembershipListener(MembershipListener listener) {
-    public void removeMembershipListener(MembershipListener listener) {
+    private void removeMembershipListener(MembershipListener listener) {
-  }
-  public UniversalListenerContainer getUniversalListenerContainer() {
-    return universalListenerContainer;
-  }
+    private MembershipEvent createEvent(DistributedMember id) {
+      return new MembershipEvent() {
-  @Override
-  public void addMembershipListener(MembershipListener listener) {
-    universalListenerContainer.addMembershipListener(listener);
+        @Override
+        public String getMemberId() {
+          return id.getId();
+        }
-  }
-
-  @Override
-  public void removeMembershipListener(MembershipListener listener) {
-    universalListenerContainer.removeMembershipListener(listener);
+        @Override
+        public DistributedMember getDistributedMember() {
+          return id;
+        }
+      };
+    }

GEODE-1017: change off-memory from compaction to defragmentation

 Replaced references of compaction with `defragmentation`, to better
 convey the intent behind the operation.

-    } while (compact(chunkSize));
+    } while (defragment(chunkSize));
-    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " compactions=" + this.compactCount.get() + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments=" + stats.getFragments() + " largestFragment=" + stats.getLargestFragment() + " fragmentation=" + stats.getFragmentation());
+    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " defragmentations=" + this.defragmentationCount.get() + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments=" + stats.getFragments() + " largestFragment=" + stats.getLargestFragment() + " fragmentation=" + stats.getFragmentation());
-  protected final AtomicInteger compactCount = new AtomicInteger();
+  protected final AtomicInteger defragmentationCount = new AtomicInteger();
-   * Compacts memory and returns true if enough memory to allocate chunkSize
+   * Defragments memory and returns true if enough memory to allocate chunkSize
-   * up to 2G then the compactor may unify them together into a single Chunk and our 32-bit chunkSize
+   * up to 2G then the FreeListManager may unify them together into a single Chunk and our 32-bit chunkSize
-  boolean compact(int chunkSize) {
-    final long startCompactionTime = this.ma.getStats().startCompaction();
-    final int countPreSync = this.compactCount.get();
-    afterCompactCountFetched();
+  boolean defragment(int chunkSize) {
+    final long startDefragmentationTime = this.ma.getStats().startDefragmentation();
+    final int countPreSync = this.defragmentationCount.get();
+    afterDefragmentationCountFetched();
-        if (this.compactCount.get() != countPreSync) {
-          // someone else did a compaction while we waited on the sync.
+        if (this.defragmentationCount.get() != countPreSync) {
+          // someone else did a defragmentation while we waited on the sync.
-        // Signal any waiters that a compaction happened.
-        this.compactCount.incrementAndGet();
+        // Signal any waiters that a defragmentation happened.
+        this.defragmentationCount.incrementAndGet();
-      this.ma.getStats().endCompaction(startCompactionTime);
+      this.ma.getStats().endDefragmentation(startDefragmentationTime);
-  protected void afterCompactCountFetched() {
+  protected void afterDefragmentationCountFetched() {
-        // If diff > 0 then that memory will be lost during compaction.
+        // If diff > 0 then that memory will be lost during defragmentation.
-    // The compaction will create new fragments.
+    // The defragmentation will create new fragments.
-      // A concurrent compaction can cause this.
+      // A concurrent defragmentation can cause this.

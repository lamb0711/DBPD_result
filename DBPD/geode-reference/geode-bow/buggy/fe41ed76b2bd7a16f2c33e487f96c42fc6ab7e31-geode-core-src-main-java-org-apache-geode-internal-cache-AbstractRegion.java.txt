GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.cache.*;
-import org.apache.geode.cache.asyncqueue.AsyncEventQueue;
+import org.apache.geode.cache.AttributesMutator;
+import org.apache.geode.cache.CacheCallback;
+import org.apache.geode.cache.CacheListener;
+import org.apache.geode.cache.CacheLoader;
+import org.apache.geode.cache.CacheLoaderException;
+import org.apache.geode.cache.CacheStatistics;
+import org.apache.geode.cache.CacheWriter;
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.CustomExpiry;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.DiskWriteAttributes;
+import org.apache.geode.cache.EntryExistsException;
+import org.apache.geode.cache.EntryNotFoundException;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.EvictionAttributesMutator;
+import org.apache.geode.cache.ExpirationAction;
+import org.apache.geode.cache.ExpirationAttributes;
+import org.apache.geode.cache.MembershipAttributes;
+import org.apache.geode.cache.MirrorType;
+import org.apache.geode.cache.Operation;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAccessException;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.RegionDestroyedException;
+import org.apache.geode.cache.RegionMembershipListener;
+import org.apache.geode.cache.RegionService;
+import org.apache.geode.cache.RoleException;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.cache.StatisticsDisabledException;
+import org.apache.geode.cache.SubscriptionAttributes;
+import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.cache.query.*;
+import org.apache.geode.cache.query.FunctionDomainException;
+import org.apache.geode.cache.query.NameResolutionException;
+import org.apache.geode.cache.query.QueryInvocationTargetException;
+import org.apache.geode.cache.query.SelectResults;
+import org.apache.geode.cache.query.TypeMismatchException;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
-import org.apache.logging.log4j.Logger;
-
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.File;
-import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.atomic.AtomicLong;
- *
+
-  // RegionAttributes //
-  protected ExpirationAction entryIdleTimeoutExpirationAction;
+
+  private ExpirationAction entryIdleTimeoutExpirationAction;
+
-  protected ExpirationAction entryTimeToLiveExpirationAction;
+
+  ExpirationAction entryTimeToLiveExpirationAction;
+
-  protected ExpirationAction regionIdleTimeoutExpirationAction;
+  private ExpirationAction regionIdleTimeoutExpirationAction;
-  protected ExpirationAction regionTimeToLiveExpirationAction;
+  private ExpirationAction regionTimeToLiveExpirationAction;
+
-  protected boolean mcastEnabled;
+  private boolean mcastEnabled;
-  // merge42004: revision 42004 has not defined isPdxTypesRegion. It has come to cheetah branch from
-  // merge revision 39860. This is getting used in method getRemoteDsIds.
-
-  protected final boolean isPdxTypesRegion;
+  private final boolean isPdxTypesRegion;
-  protected boolean isGatewaySenderEnabled = false;
+  private boolean isGatewaySenderEnabled = false;
-  protected Set<String> visibleAsyncEventQueueIds;
+  private Set<String> visibleAsyncEventQueueIds;
-  protected Set<String> allGatewaySenderIds;
+  private Set<String> allGatewaySenderIds;
-  protected DiskWriteAttributes diskWriteAttributes;
+  private DiskWriteAttributes diskWriteAttributes;
-  // Asif : The ThreadLocal is used to identify if the thread is an
+  // The ThreadLocal is used to identify if the thread is an
-  private final ThreadLocal isIndexCreator = new ThreadLocal();
+  private static final ThreadLocal<Boolean> isIndexCreator = new ThreadLocal<>();
+
-  protected ExtensionPoint<Region<?, ?>> extensionPoint =
+  private ExtensionPoint<Region<?, ?>> extensionPoint =
-  protected final GemFireCacheImpl cache;
+  protected final InternalCache cache;
-  protected AbstractRegion(GemFireCacheImpl cache, RegionAttributes attrs, String regionName,
+  protected AbstractRegion(InternalCache cache, RegionAttributes attrs, String regionName,
-    this.lastModifiedTime = new AtomicLong(lastAccessedTime.get());
+    this.lastModifiedTime = new AtomicLong(this.lastAccessedTime.get());
-   *             {@link #AbstractRegion(GemFireCacheImpl, RegionAttributes, String, InternalRegionArguments)}
+   *             {@link #AbstractRegion(InternalCache, RegionAttributes, String, InternalRegionArguments)}
-  AbstractRegion(GemFireCacheImpl cache, int serialNumber, boolean isPdxTypeRegion,
+  AbstractRegion(InternalCache cache, int serialNumber, boolean isPdxTypeRegion,
-  /** ******************** No-Brainer methods ******************************** */
-
-    ignoreJTA = ignore;
+    this.ignoreJTA = ignore;
-  public final void create(Object key, Object value)
+  @Override
+  public void create(Object key, Object value)
-  public final Object destroy(Object key)
+  @Override
+  public Object destroy(Object key)
-  public Object get(Object name) throws CacheLoaderException, TimeoutException {
-    return get(name, null, true, null);
+  @Override
+  public Object get(Object key) throws CacheLoaderException, TimeoutException {
+    return get(key, null, true, null);
-  public Object put(Object name, Object value) throws TimeoutException, CacheWriterException {
-    return put(name, value, null);
+  @Override
+  public Object put(Object key, Object value) throws TimeoutException, CacheWriterException {
+    return put(key, value, null);
-  public Object get(Object name, Object aCallbackArgument)
+  @Override
+  public Object get(Object key, Object aCallbackArgument)
-    return get(name, aCallbackArgument, true, null);
+    return get(key, aCallbackArgument, true, null);
-  public final void localDestroyRegion() {
+  @Override
+  public void localDestroyRegion() {
-   * @throws TimeoutException
-   * @throws CacheLoaderException
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-  protected abstract DistributedMember getMyId();
+  protected abstract InternalDistributedMember getMyId();
+  @Override
+  @Override
-  public Map getAll(Collection keys, Object callback) {
+  public Map getAll(Collection keys, Object aCallbackArgument) {
-    return keys.isEmpty() ? new HashMap() : basicGetAll(keys, callback);
+    return keys.isEmpty() ? new HashMap() : basicGetAll(keys, aCallbackArgument);
-  /** ********************* RegionAttributes ********************************* */
-
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
-  public CacheLoader basicGetLoader() {
-    CacheLoader result = this.cacheLoader;
-    return result;
+  CacheLoader basicGetLoader() {
+    return this.cacheLoader;
-    CacheWriter result = this.cacheWriter;
-    return result;
+    return this.cacheWriter;
+  @Override
-    // checkReadiness();
+  @Override
+  @Override
-  private volatile ExpirationAttributes regionIdleTimeoutAtts;
+  private volatile ExpirationAttributes regionIdleTimeoutAttributes;
-  private void setRegionIdleTimeoutAtts() {
-    this.regionIdleTimeoutAtts =
+  private void setRegionIdleTimeoutAttributes() {
+    this.regionIdleTimeoutAttributes =
+  @Override
-    return this.regionIdleTimeoutAtts;
+    return this.regionIdleTimeoutAttributes;
-  protected void setEntryTimeToLiveAtts() {
+  void setEntryTimeToLiveAttributes() {
+  @Override
+  @Override
-  private volatile ExpirationAttributes entryIdleTimeoutAtts;
+  private volatile ExpirationAttributes entryIdleTimeoutAttributes;
-  protected void setEntryIdleTimeoutAtts() {
-    this.entryIdleTimeoutAtts =
+  private void setEntryIdleTimeoutAttributes() {
+    this.entryIdleTimeoutAttributes =
+  @Override
-    return this.entryIdleTimeoutAtts;
+    return this.entryIdleTimeoutAttributes;
+  @Override
+  @Override
-
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
-  public final boolean isPdxTypesRegion() {
+  public boolean isPdxTypesRegion() {
+  @Override
+  @Override
-  public Set<String> getVisibleAsyncEventQueueIds() {
+  Set<String> getVisibleAsyncEventQueueIds() {
-  public final Set<String> getAllGatewaySenderIds() {
+  public Set<String> getAllGatewaySenderIds() {
-  public final boolean checkNotifyGatewaySender() {
-    return (this.cache.getAllGatewaySenders().size() > 0 && this.allGatewaySenderIds.size() > 0);
-  }
-
-  public final Set<String> getActiveGatewaySenderIds() {
-    final Set<GatewaySender> allGatewaySenders;
-    HashSet<String> activeGatewaySenderIds = null;
-    final int sz = this.gatewaySenderIds.size();
-    if (sz > 0 && (allGatewaySenders = this.cache.getGatewaySenders()).size() > 0) {
-      for (GatewaySender sender : allGatewaySenders) {
-        if (sender.isRunning() && this.gatewaySenderIds.contains(sender.getId())) {
-          if (activeGatewaySenderIds == null) {
-            activeGatewaySenderIds = new HashSet<String>();
-          }
-          activeGatewaySenderIds.add(sender.getId());
-        }
-      }
-    }
-    return activeGatewaySenderIds;
-  }
-
-  public final Set<String> getActiveAsyncQueueIds() {
-    final Set<AsyncEventQueue> allAsyncQueues;
-    HashSet<String> activeAsyncQueueIds = null;
-    final int sz = this.asyncEventQueueIds.size();
-    if (sz > 0 && (allAsyncQueues = this.cache.getAsyncEventQueues()).size() > 0) {
-      for (AsyncEventQueue asyncQueue : allAsyncQueues) {
-        // merge42004:In cheetah asyncEventQueue has isRunning Method. It has come from merging
-        // branches. A mail regarding the asyncEventQueue is sent to Barry to get more
-        // clarification. We need to sort this out.
-        if (/*
-             * asyncQueue.isRunning() &&
-             */ this.asyncEventQueueIds.contains(asyncQueue.getId())) {
-          if (activeAsyncQueueIds == null) {
-            activeAsyncQueueIds = new HashSet<String>();
-          }
-          activeAsyncQueueIds.add(asyncQueue.getId());
-        }
-      }
-    }
-    return activeAsyncQueueIds;
-  }
-
-  public final List<Integer> getRemoteDsIds(Set<String> allGatewaySenderIds)
-      throws IllegalStateException {
-    final Set<GatewaySender> allGatewaySenders;
-    final int sz = allGatewaySenderIds.size();
-    if ((sz > 0 || isPdxTypesRegion)
-        && (allGatewaySenders = this.cache.getAllGatewaySenders()).size() > 0) {
-      List<Integer> allRemoteDSIds = new ArrayList<Integer>(sz);
+  List<Integer> getRemoteDsIds(Set<String> allGatewaySenderIds) throws IllegalStateException {
+    int sz = allGatewaySenderIds.size();
+    Set<GatewaySender> allGatewaySenders = this.cache.getAllGatewaySenders();
+    if ((sz > 0 || this.isPdxTypesRegion) && !allGatewaySenders.isEmpty()) {
+      List<Integer> allRemoteDSIds = new ArrayList<>(sz);
-        if (!isPdxTypesRegion) {
+        if (!this.isPdxTypesRegion) {
-          // is avaialble on this region
+          // is available on this region
-            /*
-             * // ParalleGatewaySender with DR is not allowed if (this.partitionAttributes == null
-             * && sender.isParallel()) { throw new IllegalStateException(LocalizedStrings
-             * .AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
-             * .toLocalizedString(sender.getId())); }
-             */
-  // protected final void initAllGatewaySenderIds() {
-  // HashSet<String> senderIds = new HashSet<String>();
-  // this.allGatewaySenderIds = senderIds;
-  // if (getGatewaySenderIds().isEmpty() && getAsyncEventQueueIds().isEmpty()) {
-  // return Collections.emptySet(); // fix for bug 45774
-  // }
-  // Set<String> tmp = new CopyOnWriteArraySet<String>();
-  // tmp.addAll(this.getGatewaySenderIds());
-  // for(String asyncQueueId : this.getAsyncEventQueueIds()){
-  // tmp.add(AsyncEventQueueImpl.getSenderIdFromAsyncEventQueueId(asyncQueueId));
-  // }
-  // return tmp;
-  // }
-
-  public boolean isGatewaySenderEnabled() {
+  boolean isGatewaySenderEnabled() {
+  @Override
-  private final void storeCacheListenersField(CacheListener[] value) {
+  private void storeCacheListenersField(CacheListener[] value) {
-        CacheListener[] nv = new CacheListener[value.length];
-        System.arraycopy(value, 0, nv, 0, nv.length);
-        value = nv;
+        CacheListener[] cacheListeners = new CacheListener[value.length];
+        System.arraycopy(value, 0, cacheListeners, 0, cacheListeners.length);
+        value = cacheListeners;
-  protected final CacheListener[] fetchCacheListenersField() {
+  CacheListener[] fetchCacheListenersField() {
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkRediness();
+  @Override
-    // checkReadiness();
+  @Override
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-    // checkReadiness();
+  @Override
-  public final String getDiskStoreName() {
+  @Override
+  public String getDiskStoreName() {
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-    return imSync;
+    return this.imSync;
-  // Asif : The ThreadLocal is used to identify if the thread is an
+  // The ThreadLocal is used to identify if the thread is an
-  public void setFlagForIndexCreationThread(boolean bool) {
-    this.isIndexCreator.set(bool ? Boolean.TRUE : null);
+  public void setFlagForIndexCreationThread(boolean value) {
+    isIndexCreator.set(value ? Boolean.TRUE : null);
-  // Asif : The boolean is used in AbstractRegionEntry to skip the synchronized
+  // The boolean is used in AbstractRegionEntry to skip the synchronized
-    Boolean bool = (Boolean) this.isIndexCreator.get();
-    return (bool != null) ? bool.booleanValue() : false;
+    Boolean value = isIndexCreator.get();
+    return value != null ? value : false;
-  /** ********************* AttributesMutator ******************************** */
-
+  @Override
-  // /**
-  // * A CacheListener implementation that delegates to an array of listeners.
-  // */
-  // public static class ArrayCacheListener implements CacheListener {
-  // private final CacheListener [] listeners;
-  // /**
-  // * Creates a cache listener given the list of listeners it will delegate to.
-  // */
-  // public ArrayCacheListener(CacheListener[] listeners) {
-  // this.listeners = listeners;
-  // }
-  // }
+  @Override
-    CacheListener result = null;
-    CacheListener[] oldListeners = null;
+    CacheListener[] oldListeners;
+    CacheListener result = null;
-      for (int i = 0; i < oldListeners.length; i++) {
-        if (aListener != oldListeners[i]) {
-          closeCacheCallback(oldListeners[i]);
+      for (CacheListener oldListener : oldListeners) {
+        if (aListener != oldListener) {
+          closeCacheCallback(oldListener);
+  @Override
+  @Override
+  @Override
+  @Override
-      allGatewaySenderIds = Collections.emptySet(); // fix for bug 45774
+      this.allGatewaySenderIds = Collections.emptySet(); // fix for bug 45774
-    allGatewaySenderIds = tmp;
+    this.allGatewaySenderIds = tmp;
-    Set<String> asyncEventQueueIds = new CopyOnWriteArraySet<>();
+    Set<String> visibleAsyncEventQueueIds = new CopyOnWriteArraySet<>();
-    asyncEventQueueIds.addAll(getAsyncEventQueueIds());
+    visibleAsyncEventQueueIds.addAll(getAsyncEventQueueIds());
-      asyncEventQueueIds.removeAll(internalRegionArgs.getInternalAsyncEventQueueIds());
+      visibleAsyncEventQueueIds.removeAll(internalRegionArgs.getInternalAsyncEventQueueIds());
-    this.visibleAsyncEventQueueIds = asyncEventQueueIds;
+    this.visibleAsyncEventQueueIds = visibleAsyncEventQueueIds;
-  public void addCacheListener(CacheListener cl) {
+  @Override
+  public void addCacheListener(CacheListener aListener) {
-    if (cl == null) {
+    if (aListener == null) {
-    CacheListener wcl = wrapRegionMembershipListener(cl);
+    CacheListener wcl = wrapRegionMembershipListener(aListener);
-        List l = Arrays.asList(oldListeners);
-        if (!l.contains(cl)) {
+        List<CacheListener> listeners = Arrays.asList(oldListeners);
+        if (!listeners.contains(aListener)) {
-   * @param cl a cache listener to be added to the region
+   * @param listener a cache listener to be added to the region
-  private CacheListener wrapRegionMembershipListener(CacheListener cl) {
-    if (cl instanceof RegionMembershipListener) {
-      return new WrappedRegionMembershipListener((RegionMembershipListener) cl);
+  private CacheListener wrapRegionMembershipListener(CacheListener listener) {
+    if (listener instanceof RegionMembershipListener) {
+      return new WrappedRegionMembershipListener((RegionMembershipListener) listener);
-    return cl;
+    return listener;
-    DistributedMember[] initMbrs = null;
-    CacheListener[] newcl = null;
-    synchronized (clSync) {
-      for (int i = 0; i < cacheListeners.length; i++) {
-        CacheListener cl = cacheListeners[i];
+    synchronized (this.clSync) {
+      DistributedMember[] members = null;
+      CacheListener[] newListeners = null;
+      for (int i = 0; i < this.cacheListeners.length; i++) {
+        CacheListener cl = this.cacheListeners[i];
-            if (initMbrs == null) {
-              initMbrs = (DistributedMember[]) initialMembers
+            if (members == null) {
+              members = (DistributedMember[]) initialMembers
-            wrml.initialMembers(this, initMbrs);
-            if (newcl == null) {
-              newcl = new CacheListener[cacheListeners.length];
-              System.arraycopy(cacheListeners, 0, newcl, 0, newcl.length);
+            wrml.initialMembers(this, members);
+            if (newListeners == null) {
+              newListeners = new CacheListener[this.cacheListeners.length];
+              System.arraycopy(this.cacheListeners, 0, newListeners, 0, newListeners.length);
-            newcl[i] = wrml.getWrappedListener();
+            newListeners[i] = wrml.getWrappedListener();
-      if (newcl != null) {
-        cacheListeners = newcl;
+      if (newListeners != null) {
+        this.cacheListeners = newListeners;
-
-  public void initCacheListeners(CacheListener[] addedListeners) {
+  @Override
+  public void initCacheListeners(CacheListener[] newListeners) {
-    CacheListener[] oldListeners = null;
-    if (addedListeners != null) {
-      listenersToAdd = new CacheListener[addedListeners.length];
-      for (int i = 0; i < addedListeners.length; i++) {
-        listenersToAdd[i] = wrapRegionMembershipListener(addedListeners[i]);
+    if (newListeners != null) {
+      listenersToAdd = new CacheListener[newListeners.length];
+      for (int i = 0; i < newListeners.length; i++) {
+        listenersToAdd[i] = wrapRegionMembershipListener(newListeners[i]);
+    CacheListener[] oldListeners;
-        CacheListener[] newListeners = new CacheListener[listenersToAdd.length];
-        System.arraycopy(listenersToAdd, 0, newListeners, 0, newListeners.length);
-        this.cacheListeners = newListeners;
+        CacheListener[] newCacheListeners = new CacheListener[listenersToAdd.length];
+        System.arraycopy(listenersToAdd, 0, newCacheListeners, 0, newCacheListeners.length);
+        this.cacheListeners = newCacheListeners;
-        for (int i = 0; i < oldListeners.length; i++) {
-          closeCacheCallback(oldListeners[i]);
+        for (CacheListener oldListener : oldListeners) {
+          closeCacheCallback(oldListener);
-        for (int i = 0; i < oldListeners.length; i++) {
-          closeCacheCallback(oldListeners[i]);
+        for (CacheListener oldListener : oldListeners) {
+          closeCacheCallback(oldListener);
-  public void removeCacheListener(CacheListener cl) {
+  @Override
+  public void removeCacheListener(CacheListener aListener) {
-    if (cl == null) {
+    if (aListener == null) {
-        List l = new ArrayList(Arrays.asList(oldListeners));
-        if (l.remove(cl)) {
-          if (l.isEmpty()) {
+        List newListeners = new ArrayList(Arrays.asList(oldListeners));
+        if (newListeners.remove(aListener)) {
+          if (newListeners.isEmpty()) {
-            CacheListener[] newListeners = new CacheListener[l.size()];
-            l.toArray(newListeners);
-            this.cacheListeners = newListeners;
+            CacheListener[] newCacheListeners = new CacheListener[newListeners.size()];
+            newListeners.toArray(newCacheListeners);
+            this.cacheListeners = newCacheListeners;
-          closeCacheCallback(cl);
-          if (l.isEmpty()) {
+          closeCacheCallback(aListener);
+          if (newListeners.isEmpty()) {
-  // synchronized so not reentrant
-  public synchronized CacheLoader setCacheLoader(CacheLoader cl) {
+  @Override
+  public synchronized CacheLoader setCacheLoader(CacheLoader cacheLoader) {
-    assignCacheLoader(cl);
+    assignCacheLoader(cacheLoader);
-  // synchronized so not reentrant
+  @Override
+  @Override
-    setEntryIdleTimeoutAtts();
+    setEntryIdleTimeoutAttributes();
+  @Override
+  @Override
-    setEntryTimeToLiveAtts();
+    setEntryTimeToLiveAttributes();
+  @Override
+  @Override
-    this.setRegionIdleTimeoutAtts();
+    this.setRegionIdleTimeoutAttributes();
+  @Override
+  @Override
-  /** ********************* CacheStatistics ******************************** */
-
+  @Override
+  @Override
+
-      Iterator subIt = subregions(false).iterator();
-      while (subIt.hasNext()) {
+      for (Object region : subregions(false)) {
-          LocalRegion r = (LocalRegion) subIt.next();
-          if (r.isInitialized()) {
-            mostRecent = Math.max(mostRecent, r.getLastModifiedTime());
+          LocalRegion localRegion = (LocalRegion) region;
+          if (localRegion.isInitialized()) {
+            mostRecent = Math.max(mostRecent, localRegion.getLastModifiedTime());
-        } catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException ignore) {
-  protected long basicGetLastModifiedTime() {
+  private long basicGetLastModifiedTime() {
-  protected long basicGetLastAccessedTime() {
+  private long basicGetLastAccessedTime() {
-  protected void basicSetLastModifiedTime(long t) {
+  private void basicSetLastModifiedTime(long t) {
-  protected void basicSetLastAccessedTime(long t) {
+  private void basicSetLastAccessedTime(long t) {
+  @Override
-      Iterator subIt = subregions(false).iterator();
-      while (subIt.hasNext()) {
+      for (Object region : subregions(false)) {
-          LocalRegion r = (LocalRegion) subIt.next();
-          if (r.isInitialized()) {
-            mostRecent = Math.max(mostRecent, r.getLastAccessedTime());
+          LocalRegion localRegion = (LocalRegion) region;
+          if (localRegion.isInitialized()) {
+            mostRecent = Math.max(mostRecent, localRegion.getLastAccessedTime());
-        } catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException ignore) {
+
-      Iterator subIt = subregions(false).iterator();
-      while (subIt.hasNext()) {
+      for (Object region : subregions(false)) {
-          LocalRegion r = (LocalRegion) subIt.next();
-          if (r.isInitialized()) {
-            mostRecentAccessed = Math.max(mostRecentAccessed, r.getLastAccessedTime());
-            mostRecentModified = Math.max(mostRecentModified, r.getLastModifiedTime());
+          LocalRegion localRegion = (LocalRegion) region;
+          if (localRegion.isInitialized()) {
+            mostRecentAccessed = Math.max(mostRecentAccessed, localRegion.getLastAccessedTime());
+            mostRecentModified = Math.max(mostRecentModified, localRegion.getLastModifiedTime());
-        } catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException ignore) {
-    // checkReadiness();
-  protected void setLastAccessedTime(long time, boolean hit) {
+  void setLastAccessedTime(long time, boolean hit) {
-  public final float getHitRatio() {
-    // checkReadiness();
+  @Override
+  public float getHitRatio() {
-    return total == 0L ? 0.0f : ((float) hits / total);
+    return total == 0L ? 0.0f : (float) hits / total;
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
+  @Override
-    // checkReadiness();
-  /** ****************** Protected Methods *********************************** */
-
-  protected void closeCacheCallback(CacheCallback cb) {
+  void closeCacheCallback(CacheCallback cb) {
-  protected void timeToLiveChanged(ExpirationAttributes oldTimeToLive) {}
+  protected void timeToLiveChanged(ExpirationAttributes oldTimeToLive) {
+    // nothing
+  }
-  protected void idleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {}
+  protected void idleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {
+    // nothing
+  }
-  protected void regionTimeToLiveChanged(ExpirationAttributes oldTimeToLive) {}
+  protected void regionTimeToLiveChanged(ExpirationAttributes oldTimeToLive) {
+    // nothing
+  }
-  protected void regionIdleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {};
+  protected void regionIdleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {
+    // nothing
+  }
-  protected final boolean isProxy() {
+  protected boolean isProxy() {
-  protected final boolean isCacheContentProxy() {
+  boolean isCacheContentProxy() {
-    this.entryExpiryPossible = !isProxy() && (this.entryTimeToLive > 0 || this.entryIdleTimeout > 0
-        || this.customEntryIdleTimeout != null || this.customEntryTimeToLive != null);
+    this.entryExpiryPossible = !isProxy() && (hasTimeToLive() || hasIdleTimeout());
+  }
+
+  private boolean hasTimeToLive() {
+    return this.entryTimeToLive > 0 || this.customEntryTimeToLive != null;
+  }
+
+  private boolean hasIdleTimeout() {
+    return this.entryIdleTimeout > 0 || this.customEntryIdleTimeout != null;
-  protected boolean isEntryExpiryPossible() {
+  boolean isEntryExpiryPossible() {
-  public ExpirationAction getEntryExpirationAction() {
+  ExpirationAction getEntryExpirationAction() {
-      return entryIdleTimeoutExpirationAction;
+      return this.entryIdleTimeoutExpirationAction;
-      return entryTimeToLiveExpirationAction;
+      return this.entryTimeToLiveExpirationAction;
-  /** ****************** Private Methods ************************************* */
-    PartitionAttributes<?, ?> pa = attrs.getPartitionAttributes();
-    if (this.offHeap && pa != null) {
-      PartitionAttributesImpl impl = (PartitionAttributesImpl) pa;
-      impl.setOffHeap(this.offHeap);
+    PartitionAttributes<?, ?> partitionAttributes = attrs.getPartitionAttributes();
+    if (this.offHeap && partitionAttributes != null) {
+      PartitionAttributesImpl impl = (PartitionAttributesImpl) partitionAttributes;
+      impl.setOffHeap(true);
-    // final boolean isNotPartitionedRegion = !(attrs.getPartitionAttributes() != null || attrs
-    // .getDataPolicy().withPartitioning());
-    // if (isNotPartitionedRegion && this.evictionAttributes != null
-      this.setEvictionController(
+      setEvictionController(
-    setRegionIdleTimeoutAtts();
+    setRegionIdleTimeoutAttributes();
-    setEntryTimeToLiveAtts();
+    setEntryTimeToLiveAttributes();
-    setEntryIdleTimeoutAtts();
+    setEntryIdleTimeoutAttributes();
-  public boolean existsValue(String predicate) throws FunctionDomainException,
+  @Override
+  public boolean existsValue(String queryPredicate) throws FunctionDomainException,
-    return !query(predicate).isEmpty();
+    return !query(queryPredicate).isEmpty();
-  public Object selectValue(String predicate) throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    SelectResults result = query(predicate);
+  @Override
+  public Object selectValue(String queryPredicate) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    SelectResults result = query(queryPredicate);
-              .toLocalizedString(Integer.valueOf(result.size())));
+              .toLocalizedString(result.size()));
+  @Override
+  @Override
-
-  public void setEvictionController(LRUAlgorithm evictionController) {
+  private void setEvictionController(LRUAlgorithm evictionController) {
-    return evictionController;
+    return this.evictionController;
-  protected void checkForNoAccess() {}
+  protected void checkForNoAccess() {
+    // nothing
+  }
-  protected void checkForLimitedOrNoAccess() {}
+  protected void checkForLimitedOrNoAccess() {
+    // nothing
+  }
-
-  public /* final */ GemFireCacheImpl getCache() {
+  @Override
+  public InternalCache getCache() {
-  public final RegionService getRegionService() {
+  @Override
+  public RegionService getRegionService() {
-  public final DM getDistributionManager() {
+  public DM getDistributionManager() {
-  // DataSerializableFixedID support
-  public final int getDSFID() {
+  @Override
+  public int getDSFID() {
-  // DataSerializableFixedID support
-  public final void toData(DataOutput out) throws IOException {
+  @Override
+  public void toData(DataOutput out) throws IOException {
-  // DataSerializableFixedID support
+  @Override
-    throw new UnsupportedOperationException();
+    throw new UnsupportedOperationException("fromData is not implemented");
-    throw new UnsupportedOperationException();
+    throw new UnsupportedOperationException("forceCompaction is not implemented");
+  @Override
+  @Override
-  protected static Object handleNotAvailable(Object v) {
-    if (v == Token.NOT_AVAILABLE) {
-      v = null;
+  static Object handleNotAvailable(Object object) {
+    if (object == Token.NOT_AVAILABLE) {
+      object = null;
-    return v;
+    return object;
-  public GemFireCacheImpl getGemFireCache() {
+  public InternalCache getGemFireCache() {
+  @Override
+  @Override
-    return extensionPoint;
+    return this.extensionPoint;
+  @Override

GEODE-5405: Refactor backup to remove duplication and clean up

-  public static final String DATA_STORES_TEMPORARY_DIRECTORY = "backupTemp_";
+  public static final String TEMPORARY_DIRECTORY_FOR_BACKUPS = "backupTemp_";
+
+  private final AtomicReference<BackupTask> currentTask = new AtomicReference<>();
-  final AtomicReference<BackupTask> currentTask = new AtomicReference<>();
-
-  private ExecutorService createExecutor() {
-    LoggingThreadGroup group = LoggingThreadGroup.createThreadGroup("BackupService Thread", logger);
-    ThreadFactory threadFactory = new ThreadFactory() {
-      private final AtomicInteger threadId = new AtomicInteger();
-
-      public Thread newThread(final Runnable command) {
-        Thread thread =
-            new Thread(group, command, "BackupServiceThread" + this.threadId.incrementAndGet());
-        thread.setDaemon(true);
-        return thread;
-      }
-    };
-    return Executors.newSingleThreadExecutor(threadFactory);
-  }
-
-    validateRequestingAdmin(sender);
+    validateRequestingSender(sender);
-      throw new IOException("Another backup already in progress");
+      throw new IOException("Another backup is already in progress");
-  void validateRequestingAdmin(InternalDistributedMember sender) {
-    // We need to watch for pure admin guys that depart. this allMembershipListener set
-    // looks like it should receive those events.
-    Set allIds =
-        cache.getDistributionManager().addAllMembershipListenerAndGetAllIds(membershipListener);
-    if (!allIds.contains(sender)) {
-      cleanup();
-      throw new IllegalStateException("The admin member requesting a backup has already departed");
-    }
-  }
-
-  void cleanup() {
-    cache.getDistributionManager().removeAllMembershipListener(membershipListener);
-    currentTask.set(null);
-  }
-
+  void validateRequestingSender(InternalDistributedMember sender) {
+    // We need to watch for pure admin guys that depart. this allMembershipListener set
+    // looks like it should receive those events.
+    Set allIds =
+        cache.getDistributionManager().addAllMembershipListenerAndGetAllIds(membershipListener);
+    if (!allIds.contains(sender)) {
+      cleanup();
+      throw new IllegalStateException("The member requesting a backup has already departed");
+    }
+  }
+
+  void setCurrentTask(BackupTask backupTask) {
+    currentTask.set(backupTask);
+  }
+
+  private ExecutorService createExecutor() {
+    LoggingThreadGroup group = LoggingThreadGroup.createThreadGroup("BackupService Thread", logger);
+    ThreadFactory threadFactory = new ThreadFactory() {
+
+      private final AtomicInteger threadId = new AtomicInteger();
+
+      @Override
+      public Thread newThread(final Runnable command) {
+        Thread thread =
+            new Thread(group, command, "BackupServiceThread" + threadId.incrementAndGet());
+        thread.setDaemon(true);
+        return thread;
+      }
+    };
+    return Executors.newSingleThreadExecutor(threadFactory);
+  }
+
+  private void cleanup() {
+    cache.getDistributionManager().removeAllMembershipListener(membershipListener);
+    currentTask.set(null);
+  }
+
+
-      // unused
+      // nothing
-      // unused
+      // nothing
-      // unused
+      // nothing

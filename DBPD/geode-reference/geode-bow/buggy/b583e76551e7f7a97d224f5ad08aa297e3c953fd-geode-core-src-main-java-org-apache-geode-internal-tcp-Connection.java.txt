GEODE-7256: Cleanup Connection classes and tests

* Minor cleanup of classes and tests

+import static java.lang.Boolean.FALSE;
+import static java.lang.ThreadLocal.withInitial;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+import static org.apache.geode.distributed.internal.DistributionConfigImpl.SECURITY_SYSTEM_PREFIX;
+import java.io.DataInput;
-import java.util.Iterator;
+import javax.net.ssl.SSLHandshakeException;
+import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.distributed.internal.DistributionConfigImpl;
-import org.apache.geode.distributed.internal.membership.gms.api.MembershipStatistics;
+
-  private static boolean IS_P2P_CONNECT_TIMEOUT_INITIALIZED = false;
+  private static boolean IS_P2P_CONNECT_TIMEOUT_INITIALIZED;
-  public static final int SMALL_BUFFER_SIZE =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "SMALL_BUFFER_SIZE", 4096);
+  static final int SMALL_BUFFER_SIZE =
+      Integer.getInteger(GEMFIRE_PREFIX + "SMALL_BUFFER_SIZE", 4096);
-  /** counter to give connections a unique id */
+  /**
+   * counter to give connections a unique id
+   */
-  private static final AtomicLong idCounter = new AtomicLong(1);
+  private static final AtomicLong ID_COUNTER = new AtomicLong(1);
-  /** string used as the reason for initiating suspect processing */
+  /**
+   * string used as the reason for initiating suspect processing
+   */
+  @VisibleForTesting
-  /** the table holding this connection */
+  /**
+   * the table holding this connection
+   */
-  private volatile boolean isRunning = false;
+  private volatile boolean isRunning;
-  /** true if connection is a shared resource that can be used by more than one thread */
+  /**
+   * true if connection is a shared resource that can be used by more than one thread
+   */
-  public boolean isSharedResource() {
-    return this.sharedResource;
-  }
-
-  /** The idle timeout timer task for this connection */
+  /**
+   * The idle timeout timer task for this connection
+   */
-  private static final ThreadLocal<Boolean> isReaderThread = new ThreadLocal<Boolean>() {
-    @Override
-    public Boolean initialValue() {
-      return Boolean.FALSE;
-    }
-  };
-
-  public static void makeReaderThread() {
-    // mark this thread as a reader thread
-    makeReaderThread(true);
-  }
-
-  private static void makeReaderThread(boolean v) {
-    isReaderThread.set(v);
-  }
-
-  // return true if this thread is a reader thread
-  private static boolean isReaderThread() {
-    return isReaderThread.get();
-  }
-
-  int getP2PConnectTimeout(DistributionConfig config) {
-    if (AlertingAction.isThreadAlerting()) {
-      return config.getMemberTimeout();
-    }
-    if (IS_P2P_CONNECT_TIMEOUT_INITIALIZED)
-      return P2P_CONNECT_TIMEOUT;
-    String connectTimeoutStr = System.getProperty("p2p.connectTimeout");
-    if (connectTimeoutStr != null) {
-      P2P_CONNECT_TIMEOUT = Integer.parseInt(connectTimeoutStr);
-    } else {
-      P2P_CONNECT_TIMEOUT = 6 * config.getMemberTimeout();
-    }
-    IS_P2P_CONNECT_TIMEOUT_INITIALIZED = true;
-    return P2P_CONNECT_TIMEOUT;
-  }
+  private static final ThreadLocal<Boolean> isReaderThread = withInitial(() -> FALSE);
-  private static final ThreadLocal<Boolean> isDominoThread = new ThreadLocal<Boolean>() {
-    @Override
-    public Boolean initialValue() {
-      return Boolean.FALSE;
-    }
-  };
+  private static final ThreadLocal<Boolean> isDominoThread = withInitial(() -> FALSE);
-  // return true if this thread is a reader thread
-  private static boolean tipDomino() {
-    if (DOMINO_THREAD_OWNED_SOCKETS) {
-      // mark this thread as one who wants to send ALL on TO sockets
-      ConnectionTable.threadWantsOwnResources();
-      isDominoThread.set(Boolean.TRUE);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  public static boolean isDominoThread() {
-    return isDominoThread.get();
-  }
-
-  /** the socket entrusted to this connection */
+  /**
+   * the socket entrusted to this connection
+   */
-  /** output stream/channel lock */
+  /**
+   * output stream/channel lock
+   */
-  /** the ID string of the conduit (for logging) */
-  private String conduitIdStr;
+  /**
+   * the ID string of the conduit (for logging)
+   */
+  private final String conduitIdStr;
-  /** Identifies the java group member on the other side of the connection. */
-  InternalDistributedMember remoteAddr;
+  private InternalDistributedMember remoteAddr;
-  private static final ThreadLocal<Integer> dominoCount = new ThreadLocal<Integer>() {
-    @Override
-    protected Integer initialValue() {
-      return 0;
-    }
-  };
+  private static final ThreadLocal<Integer> dominoCount = withInitial(() -> 0);
-  private int asyncDistributionTimeout = 0;
+  private int asyncDistributionTimeout;
-  private int asyncQueueTimeout = 0;
+  private int asyncQueueTimeout;
-  private long asyncMaxQueueSize = 0;
+  private long asyncMaxQueueSize;
-  private volatile boolean asyncQueuingInProgress = false;
+  private volatile boolean asyncQueuingInProgress;
-  // NOTE: LinkedBlockingQueue has a bug in which removes from the queue
-  // cause future offer to increase the size without adding anything to the queue.
-  // So I've changed from this backport class to a java.util.LinkedList
+  /**
+   * NOTE: LinkedBlockingQueue has a bug in which removes from the queue
+   * cause future offer to increase the size without adding anything to the queue.
+   * So I've changed from this backport class to a java.util.LinkedList
+   */
-  private volatile int replyCode;
-
-  private volatile boolean readerShuttingDown = false;
+  private volatile boolean readerShuttingDown;
-  volatile boolean connected = false;
+  volatile boolean connected;
-  private volatile boolean finishedConnecting = false;
+  private volatile boolean finishedConnecting;
-  private volatile boolean socketInUse = false;
-  volatile boolean timedOut = false;
+  private volatile boolean socketInUse;
+  volatile boolean timedOut;
-  private boolean lengthSet = false;
+  private boolean lengthSet;
-  boolean preserveOrder = false;
+  boolean preserveOrder;
-  private void setSendBufferSize(Socket sock) {
-    setSendBufferSize(sock, this.owner.getConduit().tcpBufferSize);
-  }
-
-  private void setReceiveBufferSize(Socket sock) {
-    setReceiveBufferSize(sock, this.owner.getConduit().tcpBufferSize);
-  }
-
-  private void setSendBufferSize(Socket sock, int requestedSize) {
-    setSocketBufferSize(sock, true, requestedSize);
-  }
-
-  private void setReceiveBufferSize(Socket sock, int requestedSize) {
-    setSocketBufferSize(sock, false, requestedSize);
-  }
-
-  private void setSocketBufferSize(Socket sock, boolean send, int requestedSize) {
-    if (requestedSize > 0) {
-      try {
-        int currentSize = send ? sock.getSendBufferSize() : sock.getReceiveBufferSize();
-        if (currentSize == requestedSize) {
-          if (send) {
-            this.sendBufferSize = currentSize;
-          }
-          return;
-        }
-        if (send) {
-          sock.setSendBufferSize(requestedSize);
-        } else {
-          sock.setReceiveBufferSize(requestedSize);
-        }
-      } catch (SocketException ignore) {
-      }
-      try {
-        int actualSize = send ? sock.getSendBufferSize() : sock.getReceiveBufferSize();
-        if (send) {
-          this.sendBufferSize = actualSize;
-        } else {
-          this.recvBufferSize = actualSize;
-        }
-        if (actualSize < requestedSize) {
-          logger.info("Socket {} is {} instead of the requested {}.",
-              (send ? "send buffer size" : "receive buffer size"),
-              actualSize, requestedSize);
-        } else if (actualSize > requestedSize) {
-          if (logger.isTraceEnabled()) {
-            logger.trace("Socket {} buffer size is {} instead of the requested {}",
-                (send ? "send" : "receive"), actualSize, requestedSize);
-          }
-          // Remember the request size which is smaller.
-          // This remembered value is used for allocating direct mem buffers.
-          if (send) {
-            this.sendBufferSize = requestedSize;
-          } else {
-            this.recvBufferSize = requestedSize;
-          }
-        }
-      } catch (SocketException ignore) {
-        if (send) {
-          this.sendBufferSize = requestedSize;
-        } else {
-          this.recvBufferSize = requestedSize;
-        }
-      }
-    }
-  }
-
-  /**
-   * Returns the size of the send buffer on this connection's socket.
-   */
-  int getSendBufferSize() {
-    int result = this.sendBufferSize;
-    if (result != -1) {
-      return result;
-    }
-    try {
-      result = getSocket().getSendBufferSize();
-    } catch (SocketException ignore) {
-      // just return a default
-      result = this.owner.getConduit().tcpBufferSize;
-    }
-    this.sendBufferSize = result;
-    return result;
-  }
-
-  /**
-   * creates a "reader" connection that we accepted (it was initiated by an explicit connect being
-   * done on
-   * the other side).
-   */
-  protected Connection(ConnectionTable t, Socket socket)
-      throws ConnectionException {
-    if (t == null) {
-      throw new IllegalArgumentException(
-          "Null ConnectionTable");
-    }
-    this.conduit = t.getConduit();
-    this.isReceiver = true;
-    this.owner = t;
-    this.socket = socket;
-    this.conduitIdStr = conduit.getSocketId().toString();
-    this.handshakeRead = false;
-    this.handshakeCancelled = false;
-    this.connected = true;
-
-    try {
-      socket.setTcpNoDelay(true);
-      socket.setKeepAlive(true);
-      setSendBufferSize(socket, SMALL_BUFFER_SIZE);
-      setReceiveBufferSize(socket);
-    } catch (SocketException e) {
-      // unable to get the settings we want. Don't log an error because it will
-      // likely happen a lot
-    }
-  }
-
-  void initReceiver() {
-    this.startReader(owner);
-  }
-
-  void setIdleTimeoutTask(SystemTimerTask task) {
-    this.idleTask = task;
-  }
-
-
-  /**
-   * Returns true if an idle connection was detected.
-   */
-  boolean checkForIdleTimeout() {
-    if (isSocketClosed()) {
-      return true;
-    }
-    if (isSocketInUse() || (this.sharedResource && !this.preserveOrder)) { // shared/unordered
-                                                                           // connections are used
-                                                                           // for failure-detection
-                                                                           // and are not subject to
-                                                                           // idle-timeout
-      return false;
-    }
-    boolean isIdle = !this.accessed;
-    this.accessed = false;
-    if (isIdle) {
-      this.timedOut = true;
-      this.owner.getConduit().getStats().incLostLease();
-      if (logger.isDebugEnabled()) {
-        logger.debug("Closing idle connection {} shared={} ordered={}", this, this.sharedResource,
-            this.preserveOrder);
-      }
-      try {
-        // Instead of calling requestClose
-        // we call closeForReconnect.
-        // We don't want this timeout close to close
-        // any other connections. The problem with
-        // requestClose has removeEndpoint set to true
-        // which will close an receivers we have if this
-        // connection is a shared one.
-        closeForReconnect(
-            "idle connection timed out");
-      } catch (Exception ignore) {
-      }
-    }
-    return isIdle;
-  }
-
-    bytes[MSG_HEADER_SIZE_OFFSET] = (byte) ((msglen / 0x1000000) & 0xff);
-    bytes[MSG_HEADER_SIZE_OFFSET + 1] = (byte) ((msglen / 0x10000) & 0xff);
-    bytes[MSG_HEADER_SIZE_OFFSET + 2] = (byte) ((msglen / 0x100) & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET] = (byte) (msglen / 0x1000000 & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET + 1] = (byte) (msglen / 0x10000 & 0xff);
+    bytes[MSG_HEADER_SIZE_OFFSET + 2] = (byte) (msglen / 0x100 & 0xff);
-    bytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID >> 8) & 0xff);
+    bytes[MSG_HEADER_ID_OFFSET] = (byte) (MsgIdGenerator.NO_MSG_ID >> 8 & 0xff);
+  private static final int HANDSHAKE_TIMEOUT_MS =
+      Integer.getInteger("p2p.handshakeTimeoutMs", 59000);
+  // private static final byte HANDSHAKE_VERSION = 1; // 501
+  // public static final byte HANDSHAKE_VERSION = 2; // cbb5x_PerfScale
+  // public static final byte HANDSHAKE_VERSION = 3; // durable_client
+  // public static final byte HANDSHAKE_VERSION = 4; // dataSerialMay19
+  // public static final byte HANDSHAKE_VERSION = 5; // split-brain bits
+  // public static final byte HANDSHAKE_VERSION = 6; // direct ack changes
+  // NOTICE: handshake_version should not be changed anymore. Use the gemfire version transmitted
+  // with the handshake bits and handle old handshakes based on that
+  private static final byte HANDSHAKE_VERSION = 7; // product version exchange during handshake
+
+  private final AtomicBoolean asyncCloseCalled = new AtomicBoolean();
+
+  private static final int CONNECT_HANDSHAKE_SIZE = 4096;
+
+  /** time between connection attempts */
+  private static final int RECONNECT_WAIT_TIME =
+      Integer.getInteger(GEMFIRE_PREFIX + "RECONNECT_WAIT_TIME", 2000);
+
+  /**
+   * Batch sends currently should not be turned on because: 1. They will be used for all sends
+   * (instead of just no-ack) and thus will break messages that wait for a response (or kill perf).
+   * 2. The buffer is not properly flushed and closed on shutdown. The code attempts to do this but
+   * must not be doing it correctly.
+   */
+  private static final boolean BATCH_SENDS = Boolean.getBoolean("p2p.batchSends");
+  private static final int BATCH_BUFFER_SIZE =
+      Integer.getInteger("p2p.batchBufferSize", 1024 * 1024);
+  private static final int BATCH_FLUSH_MS = Integer.getInteger("p2p.batchFlushTime", 50);
+  private final Object batchLock = new Object();
+  private ByteBuffer fillBatchBuffer;
+  private ByteBuffer sendBatchBuffer;
+  private BatchBufferFlusher batchFlusher;
+
+  /**
+   * use to test message prep overhead (no socket write). WARNING: turning this on completely
+   * disables distribution of batched sends
+   */
+  private static final boolean SOCKET_WRITE_DISABLED = Boolean.getBoolean("p2p.disableSocketWrite");
+
+  private final Object pusherSync = new Object();
+
+  private boolean disconnectRequested;
+
+  /**
+   * If true then act as if the socket buffer is full and start async queuing
+   */
+  @MutableForTesting
+  public static volatile boolean FORCE_ASYNC_QUEUE;
+
+  private static final int MAX_WAIT_TIME = 32; // ms (must be a power of 2)
+
+  /**
+   * stateLock is used to synchronize state changes.
+   */
+  private final Object stateLock = new Object();
+
+  /**
+   * for timeout processing, this is the current state of the connection
+   */
+  private byte connectionState = STATE_IDLE;
+
+  /* ~~~~~~~~~~~~~ connection states ~~~~~~~~~~~~~~~ */
+  /** the connection is idle, but may be in use */
+  private static final byte STATE_IDLE = 0;
+  /** the connection is in use and is transmitting data */
+  private static final byte STATE_SENDING = 1;
+  /** the connection is in use and is done transmitting */
+  private static final byte STATE_POST_SENDING = 2;
+  /** the connection is in use and is reading a direct-ack */
+  private static final byte STATE_READING_ACK = 3;
+  /** the connection is in use and has finished reading a direct-ack */
+  private static final byte STATE_RECEIVED_ACK = 4;
+  /** the connection is in use and is reading a message */
+  private static final byte STATE_READING = 5;
+  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+
+  /** set to true if we exceeded the ack-wait-threshold waiting for a response */
+  private volatile boolean ackTimedOut;
+
+  /**
+   * creates a "reader" connection that we accepted (it was initiated by an explicit connect being
+   * done on the other side).
+   */
+  protected Connection(ConnectionTable connectionTable, Socket socket) throws ConnectionException {
+    if (connectionTable == null) {
+      throw new IllegalArgumentException("Null ConnectionTable");
+    }
+    conduit = connectionTable.getConduit();
+    isReceiver = true;
+    owner = connectionTable;
+    this.socket = socket;
+    InetSocketAddress conduitSocketId = conduit.getSocketId();
+    conduitIdStr = conduitSocketId.toString();
+    handshakeRead = false;
+    handshakeCancelled = false;
+    connected = true;
+
+    try {
+      socket.setTcpNoDelay(true);
+      socket.setKeepAlive(true);
+      setSendBufferSize(socket, SMALL_BUFFER_SIZE);
+      setReceiveBufferSize(socket);
+    } catch (SocketException e) {
+      // unable to get the settings we want. Don't log an error because it will likely happen a lot
+    }
+  }
+
+  public boolean isSharedResource() {
+    return sharedResource;
+  }
+
+  public static void makeReaderThread() {
+    // mark this thread as a reader thread
+    makeReaderThread(true);
+  }
+
+  private static void makeReaderThread(boolean v) {
+    isReaderThread.set(v);
+  }
+
+  // return true if this thread is a reader thread
+  private static boolean isReaderThread() {
+    return isReaderThread.get();
+  }
+
+  @VisibleForTesting
+  int getP2PConnectTimeout(DistributionConfig config) {
+    if (AlertingAction.isThreadAlerting()) {
+      return config.getMemberTimeout();
+    }
+    if (IS_P2P_CONNECT_TIMEOUT_INITIALIZED)
+      return P2P_CONNECT_TIMEOUT;
+    String connectTimeoutStr = System.getProperty("p2p.connectTimeout");
+    if (connectTimeoutStr != null) {
+      P2P_CONNECT_TIMEOUT = Integer.parseInt(connectTimeoutStr);
+    } else {
+      P2P_CONNECT_TIMEOUT = 6 * config.getMemberTimeout();
+    }
+    IS_P2P_CONNECT_TIMEOUT_INITIALIZED = true;
+    return P2P_CONNECT_TIMEOUT;
+  }
+
+  // return true if this thread is a reader thread
+  private static boolean tipDomino() {
+    if (DOMINO_THREAD_OWNED_SOCKETS) {
+      // mark this thread as one who wants to send ALL on TO sockets
+      ConnectionTable.threadWantsOwnResources();
+      isDominoThread.set(Boolean.TRUE);
+      return true;
+    }
+    return false;
+  }
+
+  public static boolean isDominoThread() {
+    return isDominoThread.get();
+  }
+
+  private void setSendBufferSize(Socket sock) {
+    setSendBufferSize(sock, owner.getConduit().tcpBufferSize);
+  }
+
+  private void setReceiveBufferSize(Socket sock) {
+    setReceiveBufferSize(sock, owner.getConduit().tcpBufferSize);
+  }
+
+  private void setSendBufferSize(Socket sock, int requestedSize) {
+    setSocketBufferSize(sock, true, requestedSize);
+  }
+
+  private void setReceiveBufferSize(Socket sock, int requestedSize) {
+    setSocketBufferSize(sock, false, requestedSize);
+  }
+
+  private void setSocketBufferSize(Socket sock, boolean send, int requestedSize) {
+    if (requestedSize > 0) {
+      try {
+        int currentSize = send ? sock.getSendBufferSize() : sock.getReceiveBufferSize();
+        if (currentSize == requestedSize) {
+          if (send) {
+            sendBufferSize = currentSize;
+          }
+          return;
+        }
+        if (send) {
+          sock.setSendBufferSize(requestedSize);
+        } else {
+          sock.setReceiveBufferSize(requestedSize);
+        }
+      } catch (SocketException ignore) {
+      }
+      try {
+        int actualSize = send ? sock.getSendBufferSize() : sock.getReceiveBufferSize();
+        if (send) {
+          sendBufferSize = actualSize;
+        } else {
+          recvBufferSize = actualSize;
+        }
+        if (actualSize < requestedSize) {
+          logger.info("Socket {} is {} instead of the requested {}.",
+              send ? "send buffer size" : "receive buffer size",
+              actualSize, requestedSize);
+        } else if (actualSize > requestedSize) {
+          if (logger.isTraceEnabled()) {
+            logger.trace("Socket {} buffer size is {} instead of the requested {}",
+                send ? "send" : "receive", actualSize, requestedSize);
+          }
+          // Remember the request size which is smaller.
+          // This remembered value is used for allocating direct mem buffers.
+          if (send) {
+            sendBufferSize = requestedSize;
+          } else {
+            recvBufferSize = requestedSize;
+          }
+        }
+      } catch (SocketException ignore) {
+        if (send) {
+          sendBufferSize = requestedSize;
+        } else {
+          recvBufferSize = requestedSize;
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns the size of the send buffer on this connection's socket.
+   */
+  int getSendBufferSize() {
+    int result = sendBufferSize;
+    if (result != -1) {
+      return result;
+    }
+    try {
+      result = getSocket().getSendBufferSize();
+    } catch (SocketException ignore) {
+      // just return a default
+      result = owner.getConduit().tcpBufferSize;
+    }
+    sendBufferSize = result;
+    return result;
+  }
+
+  void initReceiver() {
+    startReader(owner);
+  }
+
+  void setIdleTimeoutTask(SystemTimerTask task) {
+    idleTask = task;
+  }
+
+  /**
+   * Returns true if an idle connection was detected.
+   */
+  boolean checkForIdleTimeout() {
+    if (isSocketClosed()) {
+      return true;
+    }
+    if (isSocketInUse() || sharedResource && !preserveOrder) {
+      // shared/unordered connections are used for failure-detection
+      // and are not subject to idle-timeout
+      return false;
+    }
+    boolean isIdle = !accessed;
+    accessed = false;
+    if (isIdle) {
+      timedOut = true;
+      owner.getConduit().getStats().incLostLease();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Closing idle connection {} shared={} ordered={}", this, sharedResource,
+            preserveOrder);
+      }
+      try {
+        // Instead of calling requestClose we call closeForReconnect.
+        // We don't want this timeout close to close any other connections.
+        // The problem with requestClose has removeEndpoint set to true
+        // which will close an receivers we have if this connection is a shared one.
+        closeForReconnect("idle connection timed out");
+      } catch (Exception ignore) {
+      }
+    }
+    return isIdle;
+  }
+
-    hdrSize |= (HANDSHAKE_VERSION << 24);
+    hdrSize |= HANDSHAKE_VERSION << 24;
-  static byte calcHdrVersion(int hdrSize) throws IOException {
+  static void calcHdrVersion(int hdrSize) throws IOException {
-    return ver;
-    if (this.isReceiver) {
+    if (isReceiver) {
-      Version
-          .writeOrdinal(bb, Version.CURRENT.ordinal(), true);
+      Version.writeOrdinal(bb, Version.CURRENT.ordinal(), true);
-  private static final int HANDSHAKE_TIMEOUT_MS =
-      Integer.getInteger("p2p.handshakeTimeoutMs", 59000);
-  // private static final byte HANDSHAKE_VERSION = 1; // 501
-  // public static final byte HANDSHAKE_VERSION = 2; // cbb5x_PerfScale
-  // public static final byte HANDSHAKE_VERSION = 3; // durable_client
-  // public static final byte HANDSHAKE_VERSION = 4; // dataSerialMay19
-  // public static final byte HANDSHAKE_VERSION = 5; // split-brain bits
-  // public static final byte HANDSHAKE_VERSION = 6; // direct ack changes
-  // NOTICE: handshake_version should not be changed anymore. Use the gemfire
-  // version transmitted with the handshake bits and handle old handshakes
-  // based on that
-  private static final byte HANDSHAKE_VERSION = 7; // product version exchange during handshake
-
-      synchronized (this.handshakeSync) {
-        if (!this.handshakeRead && !this.handshakeCancelled) {
-          boolean success = false;
+      synchronized (handshakeSync) {
+        if (!handshakeRead && !handshakeCancelled) {
+          boolean success = false;
-            while (!this.handshakeRead && !this.handshakeCancelled && msToWait > 0) {
-              this.handshakeSync.wait(msToWait); // spurious wakeup ok
-              if (!this.handshakeRead && !this.handshakeCancelled) {
+            while (!handshakeRead && !handshakeCancelled && msToWait > 0) {
+              handshakeSync.wait(msToWait); // spurious wakeup ok
+              if (!handshakeRead && !handshakeCancelled) {
-            if (!this.handshakeRead && !this.handshakeCancelled) {
+            if (!handshakeRead && !handshakeCancelled) {
-              if (this.remoteAddr != null) {
-                peerName = this.remoteAddr.toString();
+              if (remoteAddr != null) {
+                peerName = remoteAddr.toString();
-                owner.getDM().getDistribution().suspectMember(this.remoteAddr,
+                owner.getDM().getDistribution().suspectMember(remoteAddr,
-
-                peerName = "socket " + this.socket.getRemoteSocketAddress().toString() + ":"
-                    + this.socket.getPort();
+                peerName = "socket " + socket.getRemoteSocketAddress() + ":" + socket.getPort();
-            } else {
-              success = this.handshakeRead;
+            success = handshakeRead;
-            this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+            owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-              if (this.isReceiver) {
+              if (isReceiver) {
-                    !owner.getConduit().getMembership().addSurpriseMember(this.remoteAddr);
+                    !owner.getConduit().getMembership().addSurpriseMember(remoteAddr);
-              needToClose = true; // for bug 42159
+              needToClose = true;
-        } // !handshakeRead
-      } // synchronized
+        }
+      }
-        // moved this call outside of the sync for bug 42159
-          requestClose(reason); // fix for bug 31546
+          requestClose(reason);
-    synchronized (this.handshakeSync) {
+    synchronized (handshakeSync) {
-        this.handshakeRead = true;
+        handshakeRead = true;
-        this.handshakeCancelled = true;
+        handshakeCancelled = true;
-      this.handshakeSync.notify();
+      handshakeSync.notifyAll();
-  private final AtomicBoolean asyncCloseCalled = new AtomicBoolean();
-
-    // there is a problem with the network. See bug #46659
+    // there is a problem with the network
-      if (this.asyncCloseCalled.compareAndSet(false, true)) {
-        Socket s = this.socket;
+      if (asyncCloseCalled.compareAndSet(false, true)) {
+        Socket s = socket;
-          this.owner.getSocketCloser().asyncClose(s, String.valueOf(this.remoteAddr),
+          owner.getSocketCloser().asyncClose(s, String.valueOf(remoteAddr),
-  private static final int CONNECT_HANDSHAKE_SIZE = 4096;
-
-    InternalDistributedMember myAddr = this.owner.getConduit().getMemberId();
+    InternalDistributedMember myAddr = owner.getConduit().getMemberId();
-      while ((!owner.getConduit().getCancelCriterion().isCancelInProgress())
+      while (!owner.getConduit().getCancelCriterion().isCancelInProgress()
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
+          owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
-      Assert.assertTrue(myAddr.getDirectChannelPort() == this.owner.getConduit().getPort());
+      Assert.assertTrue(myAddr.getDirectChannelPort() == owner.getConduit().getPort());
-    InternalDistributedMember myAddr = this.owner.getConduit().getMemberId();
+    InternalDistributedMember myAddr = owner.getConduit().getMemberId();
-    connectHandshake.writeBoolean(this.sharedResource);
-    connectHandshake.writeBoolean(this.preserveOrder);
-    connectHandshake.writeLong(this.uniqueId);
+    connectHandshake.writeBoolean(sharedResource);
+    connectHandshake.writeBoolean(preserveOrder);
+    connectHandshake.writeLong(uniqueId);
-    // if (dominoCount.get() > 0) {
-    // connectHandshake.writeUTF(Thread.currentThread().getName());
-    // } else {
-    // String name = owner.getDM().getConfig().getName();
-    // if (name == null) {
-    // name = "pid="+OSProcess.getId();
-    // }
-    // connectHandshake.writeUTF("["+name+"] "+Thread.currentThread().getName());
-    // }
-   *
-  /** time between connection attempts */
-  private static final int RECONNECT_WAIT_TIME = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "RECONNECT_WAIT_TIME", 2000);
-
-  protected static Connection createSender(final Membership<InternalDistributedMember> mgr,
+  static Connection createSender(final Membership<InternalDistributedMember> mgr,
-    boolean warningPrinted = false;
-    boolean firstTime = true;
-    boolean severeAlertIssued = false;
-    boolean suspected = false;
-    long reconnectWaitTime = RECONNECT_WAIT_TIME;
-    boolean connectionErrorLogged = false;
+      boolean connectionErrorLogged = false;
+      long reconnectWaitTime = RECONNECT_WAIT_TIME;
+      boolean suspected = false;
+      boolean severeAlertIssued = false;
+      boolean firstTime = true;
+      boolean warningPrinted = false;
-                  remoteAddr, (ackTimeout) / 1000);
+                  remoteAddr, ackTimeout / 1000);
-        } else if (!suspected && (startTime > 0) && (ackTimeout > 0)
-            && (startTime + ackTimeout < now)) {
+        } else if (!suspected && startTime > 0 && ackTimeout > 0
+            && startTime + ackTimeout < now) {
-        } catch (javax.net.ssl.SSLHandshakeException se) {
+        } catch (SSLHandshakeException se) {
-                throw new IOException(String.format("Member %s left the group",
-                    remoteAddr));
+                throw new IOException(String.format("Member %s left the group", remoteAddr));
-    // Assert.assertTrue(conn != null);
-          String.format("Connection: failed construction for peer %s",
-              remoteAddr));
+          String.format("Connection: failed construction for peer %s", remoteAddr));
-
-      throw new IllegalArgumentException(
-          "ConnectionTable is null.");
+      throw new IllegalArgumentException("ConnectionTable is null.");
-    this.conduit = t.getConduit();
-    this.isReceiver = false;
-    this.owner = t;
+    conduit = t.getConduit();
+    isReceiver = false;
+    owner = t;
-    this.conduitIdStr = this.owner.getConduit().getSocketId().toString();
-    this.handshakeRead = false;
-    this.handshakeCancelled = false;
-    this.connected = true;
+    conduitIdStr = owner.getConduit().getSocketId().toString();
+    handshakeRead = false;
+    handshakeCancelled = false;
+    connected = true;
-    this.uniqueId = idCounter.getAndIncrement();
+    uniqueId = ID_COUNTER.getAndIncrement();
-    this.owner.addConnectingSocket(channel.socket(), addr.getAddress());
+    owner.addConnectingSocket(channel.socket(), addr.getAddress());
-      /*
-       * If conserve-sockets is false, the socket can be used for receiving responses, so set the
-       * receive buffer accordingly.
-       */
+      // If conserve-sockets is false, the socket can be used for receiving responses, so set the
+      // receive buffer accordingly.
-        setReceiveBufferSize(channel.socket(), this.owner.getConduit().tcpBufferSize);
+        setReceiveBufferSize(channel.socket(), owner.getConduit().tcpBufferSize);
-        // bug #45044 - jdk 1.7 sometimes throws an NPE here
+        // jdk 1.7 sometimes throws an NPE here
-        // bug #44469: for some reason NIO throws this runtime exception
-        // instead of an IOException on timeouts
+        // for some reason NIO throws this runtime exception instead of an IOException on timeouts
-            String.format("Attempt timed out after %s milliseconds",
-                connectTime));
+            String.format("Attempt timed out after %s milliseconds", connectTime));
-      this.owner.removeConnectingSocket(channel.socket());
+      owner.removeConnectingSocket(channel.socket());
-    this.socket = channel.socket();
+    socket = channel.socket();
-  /**
-   * Batch sends currently should not be turned on because: 1. They will be used for all sends
-   * (instead of just no-ack) and thus will break messages that wait for a response (or kill perf).
-   * 2. The buffer is not properly flushed and closed on shutdown. The code attempts to do this but
-   * must not be doing it correctly.
-   */
-  private static final boolean BATCH_SENDS = Boolean.getBoolean("p2p.batchSends");
-  private static final int BATCH_BUFFER_SIZE =
-      Integer.getInteger("p2p.batchBufferSize", 1024 * 1024);
-  private static final int BATCH_FLUSH_MS = Integer.getInteger("p2p.batchFlushTime", 50);
-  private final Object batchLock = new Object();
-  private ByteBuffer fillBatchBuffer;
-  private ByteBuffer sendBatchBuffer;
-  private BatchBufferFlusher batchFlusher;
-
-      this.fillBatchBuffer = ByteBuffer.allocateDirect(BATCH_BUFFER_SIZE);
-      this.sendBatchBuffer = ByteBuffer.allocateDirect(BATCH_BUFFER_SIZE);
+      fillBatchBuffer = ByteBuffer.allocateDirect(BATCH_BUFFER_SIZE);
+      sendBatchBuffer = ByteBuffer.allocateDirect(BATCH_BUFFER_SIZE);
-      this.fillBatchBuffer = ByteBuffer.allocate(BATCH_BUFFER_SIZE);
-      this.sendBatchBuffer = ByteBuffer.allocate(BATCH_BUFFER_SIZE);
+      fillBatchBuffer = ByteBuffer.allocate(BATCH_BUFFER_SIZE);
+      sendBatchBuffer = ByteBuffer.allocate(BATCH_BUFFER_SIZE);
-    this.batchFlusher = new BatchBufferFlusher();
-    this.batchFlusher.start();
+    batchFlusher = new BatchBufferFlusher();
+    batchFlusher.start();
-    // is done here as a failsafe.
+    // is done here as a fail safe.
-  public void setInputBuffer(ByteBuffer buffer) {
-    this.inputBuffer = buffer;
-  }
-
-  private class BatchBufferFlusher extends Thread {
-    private volatile boolean flushNeeded = false;
-    private volatile boolean timeToStop = false;
-    private DMStats stats;
-
-
-    BatchBufferFlusher() {
-      setDaemon(true);
-      this.stats = owner.getConduit().getStats();
-    }
-
-    /**
-     * Called when a message writer needs the current fillBatchBuffer flushed
-     */
-    void flushBuffer(ByteBuffer bb) {
-      final long start = DistributionStats.getStatTime();
-      try {
-        synchronized (this) {
-          synchronized (batchLock) {
-            if (bb != fillBatchBuffer) {
-              // it must have already been flushed. So just return
-              // and use the new fillBatchBuffer
-              return;
-            }
-          }
-          this.flushNeeded = true;
-          this.notify();
-        }
-        synchronized (batchLock) {
-          // Wait for the flusher thread
-          while (bb == fillBatchBuffer) {
-            Connection.this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-            boolean interrupted = Thread.interrupted();
-            try {
-              batchLock.wait(); // spurious wakeup ok
-            } catch (InterruptedException ex) {
-              interrupted = true;
-            } finally {
-              if (interrupted) {
-                Thread.currentThread().interrupt();
-              }
-            }
-          } // while
-        }
-      } finally {
-        owner.getConduit().getStats().incBatchWaitTime(start);
-      }
-    }
-
-    public void close() {
-      synchronized (this) {
-        this.timeToStop = true;
-        this.flushNeeded = true;
-        this.notify();
-      }
-    }
-
-    @Override
-    public void run() {
-      try {
-        synchronized (this) {
-          while (!timeToStop) {
-            if (!this.flushNeeded && fillBatchBuffer.position() <= (BATCH_BUFFER_SIZE / 2)) {
-              wait(BATCH_FLUSH_MS); // spurious wakeup ok
-            }
-            if (this.flushNeeded || fillBatchBuffer.position() > (BATCH_BUFFER_SIZE / 2)) {
-              final long start = DistributionStats.getStatTime();
-              synchronized (batchLock) {
-                // This is the only block of code that will swap
-                // the buffer references
-                this.flushNeeded = false;
-                ByteBuffer tmp = fillBatchBuffer;
-                fillBatchBuffer = sendBatchBuffer;
-                sendBatchBuffer = tmp;
-                batchLock.notifyAll();
-              }
-              // We now own the sendBatchBuffer
-              if (sendBatchBuffer.position() > 0) {
-                final boolean origSocketInUse = socketInUse;
-                socketInUse = true;
-                try {
-                  sendBatchBuffer.flip();
-                  SocketChannel channel = getSocket().getChannel();
-                  writeFully(channel, sendBatchBuffer, false, null);
-                  sendBatchBuffer.clear();
-                } catch (IOException | ConnectionException ex) {
-                  logger.fatal("Exception flushing batch send buffer: %s", ex);
-                  readerShuttingDown = true;
-                  requestClose(String.format("Exception flushing batch send buffer: %s",
-                      ex));
-                } finally {
-                  accessed();
-                  socketInUse = origSocketInUse;
-                }
-              }
-              this.stats.incBatchFlushTime(start);
-            }
-          }
-        }
-      } catch (InterruptedException ex) {
-        // time for this thread to shutdown
-        // Thread.currentThread().interrupt();
-      }
-    }
-  }
-
-    if (this.batchFlusher != null) {
-      this.batchFlusher.close();
+    if (batchFlusher != null) {
+      batchFlusher.close();
-  /**
-   * use to test message prep overhead (no socket write). WARNING: turning this on completely
-   * disables distribution of batched sends
-   */
-  private static final boolean SOCKET_WRITE_DISABLED = Boolean.getBoolean("p2p.disableSocketWrite");
-
-  private void batchSend(ByteBuffer src) throws IOException {
+  private void batchSend(ByteBuffer src) {
-      ByteBuffer dst = null;
-        synchronized (this.batchLock) {
-          dst = this.fillBatchBuffer;
+        ByteBuffer dst;
+        synchronized (batchLock) {
+          dst = fillBatchBuffer;
-            this.owner.getConduit().getStats().incBatchCopyTime(copyStart);
+            owner.getConduit().getStats().incBatchCopyTime(copyStart);
-        this.batchFlusher.flushBuffer(dst);
+        batchFlusher.flushBuffer(dst);
-      this.owner.getConduit().getStats().incBatchSendTime(start);
+      owner.getConduit().getStats().incBatchSendTime(start);
-    return this.closing.get();
+    return closing.get();
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "TLW_TWO_LOCK_WAIT")
+  @SuppressWarnings("TLW_TWO_LOCK_WAIT")
-    boolean removeEndpoint = p_removeEndpoint;
-    // use getAndSet outside sync on this to fix 42330
-    boolean onlyCleanup = this.closing.getAndSet(true);
+    // use getAndSet outside sync on this
+    boolean onlyCleanup = closing.getAndSet(true);
+    boolean removeEndpoint = p_removeEndpoint;
-        this.stopped = true;
-        if (this.connected) {
-          if (this.asyncQueuingInProgress && this.pusherThread != Thread.currentThread()) {
+        stopped = true;
+        if (connected) {
+          if (asyncQueuingInProgress && pusherThread != Thread.currentThread()) {
-            // See bug 37601.
-            synchronized (this.outgoingQueue) {
+            synchronized (outgoingQueue) {
-              while (this.asyncQueuingInProgress) {
-                // Don't do this: causes closes to not get done in the event
-                // of an orderly shutdown:
-                // this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+              while (asyncQueuingInProgress) {
-                  this.outgoingQueue.wait(); // spurious wakeup ok
+                  outgoingQueue.wait(); // spurious wakeup ok
-                  // this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
-              } // while
-            } // synchronized
-          }
-          this.connected = false;
-          closeSenderSem();
-          {
-            final DMStats stats = this.owner.getConduit().getStats();
-            if (this.finishedConnecting) {
-              if (this.isReceiver) {
-                stats.decReceivers();
-              } else {
-                stats.decSenders(this.sharedResource, this.preserveOrder);
+          connected = false;
+          closeSenderSem();
+
+          final DMStats stats = owner.getConduit().getStats();
+          if (finishedConnecting) {
+            if (isReceiver) {
+              stats.decReceivers();
+            } else {
+              stats.decSenders(sharedResource, preserveOrder);
+            }
+          }
+
-        if (!this.isReceiver) {
+        if (!isReceiver) {
-      } // synchronized
+      }
-      // moved the call to notifyHandshakeWaiter out of the above
-      // synchronized block to fix bug #42159
-      // wait a bit for the our reader thread to exit
-      // don't wait if we are the reader thread
+      // wait a bit for the our reader thread to exit don't wait if we are the reader thread
-      // we can't wait for the reader thread when running in an IBM JRE. See
-      // bug 41889
-      if (this.conduit.getConfig().getEnableNetworkPartitionDetection()
-          || this.conduit.getMemberId().getVmKind() == ClusterDistributionManager.ADMIN_ONLY_DM_TYPE
-          || this.conduit.getMemberId().getVmKind() == ClusterDistributionManager.LOCATOR_DM_TYPE) {
+      // we can't wait for the reader thread when running in an IBM JRE
+      if (conduit.getConfig().getEnableNetworkPartitionDetection()
+          || conduit.getMemberId().getVmKind() == ClusterDistributionManager.ADMIN_ONLY_DM_TYPE
+          || conduit.getMemberId().getVmKind() == ClusterDistributionManager.LOCATOR_DM_TYPE) {
-      {
-        // Now that readerThread is returned to a pool after we close
-        // we need to be more careful not to join on a thread that belongs
-        // to someone else.
-        Thread readerThreadSnapshot = this.readerThread;
-        if (!beingSick && readerThreadSnapshot != null && !isIBM && this.isRunning
-            && !this.readerShuttingDown && readerThreadSnapshot != Thread.currentThread()) {
-          try {
-            readerThreadSnapshot.join(500);
-            readerThreadSnapshot = this.readerThread;
-            if (this.isRunning && !this.readerShuttingDown && readerThreadSnapshot != null
-                && owner.getDM().getRootCause() == null) { // don't wait twice if there's a system
-                                                           // failure
-              readerThreadSnapshot.join(1500);
-              if (this.isRunning) {
-                logger.info("Timed out waiting for readerThread on {} to finish.",
-                    this);
-              }
+
+      // Now that readerThread is returned to a pool after we close
+      // we need to be more careful not to join on a thread that belongs
+      // to someone else.
+      Thread readerThreadSnapshot = readerThread;
+      if (!beingSick && readerThreadSnapshot != null && !isIBM && isRunning
+          && !readerShuttingDown && readerThreadSnapshot != Thread.currentThread()) {
+        try {
+          readerThreadSnapshot.join(500);
+          readerThreadSnapshot = readerThread;
+          if (isRunning && !readerShuttingDown && readerThreadSnapshot != null
+              && owner.getDM().getRootCause() == null) {
+            // don't wait twice if there's a system failure
+            readerThreadSnapshot.join(1500);
+            if (isRunning) {
+              logger.info("Timed out waiting for readerThread on {} to finish.",
+                  this);
-          } catch (IllegalThreadStateException ignore) {
-            // ignored - thread already stopped
-          } catch (InterruptedException ignore) {
-            Thread.currentThread().interrupt();
-            // but keep going, we're trying to close.
+        } catch (IllegalThreadStateException ignore) {
+          // ignored - thread already stopped
+        } catch (InterruptedException ignore) {
+          Thread.currentThread().interrupt();
+          // but keep going, we're trying to close.
-      if (this.isReceiver) {
-        this.owner.removeReceiver(this);
+      if (isReceiver) {
+        owner.removeReceiver(this);
-        if (this.sharedResource) {
-          if (!this.preserveOrder) {
-            // only remove endpoint when shared unordered connection
-            // is closed. This is part of the fix for bug 32980.
-            if (!this.isReceiver) {
+        if (sharedResource) {
+          if (!preserveOrder) {
+            // only remove endpoint when shared unordered connection is closed
+            if (!isReceiver) {
-              if (this.finishedConnecting) {
+              if (finishedConnecting) {
-                this.owner.removeEndpoint(this.remoteAddr, reason);
+                owner.removeEndpoint(remoteAddr, reason);
-            this.owner.removeSharedConnection(reason, this.remoteAddr, this.preserveOrder, this);
+            owner.removeSharedConnection(reason, remoteAddr, preserveOrder, this);
-        } else if (!this.isReceiver) {
-          this.owner.removeThreadConnection(this.remoteAddr, this);
+        } else if (!isReceiver) {
+          owner.removeThreadConnection(remoteAddr, this);
-        // This code is ok to do even if the ConnectionTable
-        // has never added this Connection to its maps since
-        // the calls in this block use our identity to do the removes.
-        if (this.sharedResource) {
-          this.owner.removeSharedConnection(reason, this.remoteAddr, this.preserveOrder, this);
-        } else if (!this.isReceiver) {
-          this.owner.removeThreadConnection(this.remoteAddr, this);
+        // This code is ok to do even if the ConnectionTable has never added this Connection to its
+        // maps since the calls in this block use our identity to do the removes.
+        if (sharedResource) {
+          owner.removeSharedConnection(reason, remoteAddr, preserveOrder, this);
+        } else if (!isReceiver) {
+          owner.removeThreadConnection(remoteAddr, this);
-    // This cancels the idle timer task, but it also removes the tasks
-    // reference to this connection, freeing up the connection (and it's buffers
-    // for GC sooner.
+    // This cancels the idle timer task, but it also removes the tasks reference to this connection,
+    // freeing up the connection (and it's buffers for GC sooner.
-
-  /** starts a reader thread */
+  /**
+   * starts a reader thread
+   */
-    Assert.assertTrue(!this.isRunning);
+    Assert.assertTrue(!isRunning);
-    this.isRunning = true;
+    isRunning = true;
-
-    this.readerThread = Thread.currentThread();
-    this.readerThread.setName(p2pReaderName());
+    readerThread = Thread.currentThread();
+    readerThread.setName(p2pReaderName());
-    makeReaderThread(this.isReceiver);
+    makeReaderThread(isReceiver);
-      // bug36060: do the socket close within a finally block
+      // do the socket close within a finally block
-      if (this.isReceiver) {
+      if (isReceiver) {
-        if (!this.sharedResource) {
-          this.conduit.getStats().incThreadOwnedReceivers(-1L, dominoCount.get());
+        if (!sharedResource) {
+          conduit.getStats().incThreadOwnedReceivers(-1L, dominoCount.get());
-        this.owner.removeAndCloseThreadOwnedSockets();
+        owner.removeAndCloseThreadOwnedSockets();
-      // make sure that if the reader thread exits we notify a thread waiting
-      // for the handshake.
-      // see bug 37524 for an example of listeners hung in waitForHandshake
+      // make sure that if the reader thread exits we notify a thread waiting for the handshake.
-      this.readerThread.setName("unused p2p reader");
-      synchronized (this.stateLock) {
-        this.isRunning = false;
-        this.readerThread = null;
+      readerThread.setName("unused p2p reader");
+      synchronized (stateLock) {
+        isRunning = false;
+        readerThread = null;
-    } // finally
+    }
-    ByteBuffer tmp = this.inputBuffer;
+    ByteBuffer tmp = inputBuffer;
-      this.inputBuffer = null;
-      final MembershipStatistics stats = this.owner.getConduit().getStats();
+      inputBuffer = null;
-    if (this.isReceiver) {
+    if (isReceiver) {
-    } else if (this.handshakeRead) {
+    } else if (handshakeRead) {
-    if (!this.isReceiver) {
+    if (!isReceiver) {
-    // take a snapshot of uniqueId to detect reconnect attempts; see bug 37592
+    // take a snapshot of uniqueId to detect reconnect attempts
-      // bug 37693: the channel was asynchronously closed. Our work
-      // is done.
+      // the channel was asynchronously closed. Our work is done.
-        requestClose(
-            "readMessages caught closed channel");
+        requestClose("readMessages caught closed channel");
-      return; // exit loop and thread
+      // exit loop and thread
+      return;
-          requestClose(
-              "readMessages caught shutdown");
+          requestClose("readMessages caught shutdown");
-        return; // bug37520: exit loop (and thread)
+        // exit loop (and thread)
+        return;
-          (this.isReceiver ? "receiver" : "sender"), ex.getMessage());
-      this.readerShuttingDown = true;
+          isReceiver ? "receiver" : "sender", ex.getMessage());
+      readerShuttingDown = true;
-        requestClose(String.format("Failed initializing socket %s",
-            ex));
+        requestClose(String.format("Failed initializing socket %s", ex));
-      // Assert.assertTrue(owner != null, "How did owner become null");
-    // fix for #40869
-    boolean isInitialRead = true;
-      for (;;) {
+      for (boolean isInitialRead = true;;) {
-          Socket s = this.socket;
-          if (s != null) {
-            try {
-              ioFilter.close(s.getChannel());
-              s.close();
-            } catch (IOException e) {
-              // don't care
-            }
+          try {
+            ioFilter.close(socket.getChannel());
+            socket.close();
+          } catch (IOException e) {
+            // don't care
-          SystemFailure.checkFailure(); // throws
+          SystemFailure.checkFailure();
-        if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
+        if (owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-            this.readerShuttingDown = true;
+            readerShuttingDown = true;
-          if (!this.isReceiver && (this.handshakeRead || this.handshakeCancelled)) {
+          if (!isReceiver && (handshakeRead || handshakeCancelled)) {
-              if (this.handshakeRead) {
+              if (handshakeRead) {
-          this.readerShuttingDown = true;
+          readerShuttingDown = true;
-            requestClose(
-                String.format("CacheClosed in channel read: %s", e));
+            requestClose(String.format("CacheClosed in channel read: %s", e));
-          this.readerShuttingDown = true;
+          readerShuttingDown = true;
-            requestClose(String.format("ClosedChannelException in channel read: %s",
-                e));
+            requestClose(String.format("ClosedChannelException in channel read: %s", e));
-          if (!isSocketClosed() && !"Socket closed".equalsIgnoreCase(e.getMessage()) // needed for
-                                                                                     // Solaris jdk
-                                                                                     // 1.4.2_08
-          ) {
+          // "Socket closed" check needed for Solaris jdk 1.4.2_08
+          if (!isSocketClosed() && !"Socket closed".equalsIgnoreCase(e.getMessage())) {
-          this.readerShuttingDown = true;
+          readerShuttingDown = true;
-            requestClose(
-                String.format("IOException in channel read: %s", e));
+            requestClose(String.format("IOException in channel read: %s", e));
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null); // bug 37101
+          owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-          this.readerShuttingDown = true;
+          readerShuttingDown = true;
-            requestClose(
-                String.format("%s exception in channel read", e));
+            requestClose(String.format("%s exception in channel read", e));
-      } // for
+      }
-      if (inputBuffer == null
-          || (inputBuffer.capacity() < packetBufferSize)) {
+      if (inputBuffer == null || inputBuffer.capacity() < packetBufferSize) {
-    if (this.isReceiver && this.handshakeRead && !this.preserveOrder && this.sharedResource) {
-      if (!this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-        this.owner.getDM().getDistribution().suspectMember(this.getRemoteAddress(),
+    if (isReceiver && handshakeRead && !preserveOrder && sharedResource) {
+      if (!owner.getConduit().getCancelCriterion().isCancelInProgress()) {
+        owner.getDM().getDistribution().suspectMember(getRemoteAddress(),
-    return (msg.contains("forcibly closed")) || (msg.contains("reset by peer"))
-        || (msg.contains("connection reset"));
+    return msg.contains("forcibly closed")
+        || msg.contains("reset by peer")
+        || msg.contains("connection reset");
-    return msgType == NORMAL_MSG_TYPE || msgType == CHUNKED_MSG_TYPE
+    return msgType == NORMAL_MSG_TYPE
+        || msgType == CHUNKED_MSG_TYPE
-    synchronized (this.destreamerLock) {
-      if (this.idleMsgDestreamer != null) {
-        this.idleMsgDestreamer.close();
-        this.idleMsgDestreamer = null;
+    synchronized (destreamerLock) {
+      if (idleMsgDestreamer != null) {
+        idleMsgDestreamer.close();
+        idleMsgDestreamer = null;
-      if (this.destreamerMap != null) {
-        Iterator it = this.destreamerMap.values().iterator();
-        while (it.hasNext()) {
-          MsgDestreamer md = (MsgDestreamer) it.next();
+      if (destreamerMap != null) {
+        for (Object o : destreamerMap.values()) {
+          MsgDestreamer md = (MsgDestreamer) o;
-        this.destreamerMap = null;
+        destreamerMap = null;
-  MsgDestreamer obtainMsgDestreamer(short msgId, final Version v) {
-    synchronized (this.destreamerLock) {
-      if (this.destreamerMap == null) {
-        this.destreamerMap = new HashMap();
+  private MsgDestreamer obtainMsgDestreamer(short msgId, final Version v) {
+    synchronized (destreamerLock) {
+      if (destreamerMap == null) {
+        destreamerMap = new HashMap();
-      Short key = new Short(msgId);
-      MsgDestreamer result = (MsgDestreamer) this.destreamerMap.get(key);
+      Short key = msgId;
+      MsgDestreamer result = (MsgDestreamer) destreamerMap.get(key);
-        result = this.idleMsgDestreamer;
+        result = idleMsgDestreamer;
-          this.idleMsgDestreamer = null;
+          idleMsgDestreamer = null;
-          result = new MsgDestreamer(this.owner.getConduit().getStats(),
-              this.conduit.getCancelCriterion(), v);
+          result =
+              new MsgDestreamer(owner.getConduit().getStats(), conduit.getCancelCriterion(), v);
-        this.destreamerMap.put(key, result);
+        destreamerMap.put(key, result);
-  void releaseMsgDestreamer(short msgId, MsgDestreamer md) {
-    Short key = new Short(msgId);
-    synchronized (this.destreamerLock) {
-      this.destreamerMap.remove(key);
-      if (this.idleMsgDestreamer == null) {
+  private void releaseMsgDestreamer(short msgId, MsgDestreamer md) {
+    synchronized (destreamerLock) {
+      destreamerMap.remove(msgId);
+      if (idleMsgDestreamer == null) {
-        this.idleMsgDestreamer = md;
+        idleMsgDestreamer = md;
-      DistributionManager dm = this.owner.getDM();
+      DistributionManager dm = owner.getDM();
-
-      throw new ConnectionException(
-          String.format("Not connected to %s", this.remoteAddr));
+      throw new ConnectionException(String.format("Not connected to %s", remoteAddr));
-    if (this.batchFlusher != null) {
+    if (batchFlusher != null) {
-    final boolean origSocketInUse = this.socketInUse;
+    final boolean origSocketInUse = socketInUse;
-      originalState = this.connectionState;
-      this.connectionState = STATE_SENDING;
+      originalState = connectionState;
+      connectionState = STATE_SENDING;
-    this.socketInUse = true;
+    socketInUse = true;
-      this.socketInUse = origSocketInUse;
+      socketInUse = origSocketInUse;
-        this.connectionState = originalState;
+        connectionState = originalState;
-   * If <code>use</code> is true then "claim" the connection for our use. If <code>use</code> is
-   * false then "release" the connection. Fixes bug 37657.
-   *
-   * @return true if connection was already in use at time of call; false if not.
+   * If {@code use} is true then "claim" the connection for our use. If {@code use} is
+   * false then "release" the connection.
-  public boolean setInUse(boolean use, long startTime, long ackWaitThreshold, long ackSAThreshold,
+  public void setInUse(boolean use, long startTime, long ackWaitThreshold, long ackSAThreshold,
-    final boolean origSocketInUse = this.socketInUse;
-        this.transmissionStartTime = startTime;
-        this.ackWaitTimeout = ackWaitThreshold;
-        this.ackSATimeout = ackSAThreshold;
-        this.ackConnectionGroup = connectionGroup;
-        this.ackThreadName = Thread.currentThread().getName();
+        transmissionStartTime = startTime;
+        ackWaitTimeout = ackWaitThreshold;
+        ackSATimeout = ackSAThreshold;
+        ackConnectionGroup = connectionGroup;
+        ackThreadName = Thread.currentThread().getName();
-        this.ackWaitTimeout = 0;
-        this.ackSATimeout = 0;
-        this.ackConnectionGroup = null;
-        this.ackThreadName = null;
+        ackWaitTimeout = 0;
+        ackSATimeout = 0;
+        ackConnectionGroup = null;
+        ackThreadName = null;
-      synchronized (this.stateLock) {
-        this.connectionState = STATE_IDLE;
+      synchronized (stateLock) {
+        connectionState = STATE_IDLE;
-      this.socketInUse = use;
+      socketInUse = use;
-    return origSocketInUse;
+  @VisibleForTesting
-    this.preserveOrder = false;
-    this.sharedResource = true;
-    this.handshakeRead = true;
+    preserveOrder = false;
+    sharedResource = true;
+    handshakeRead = true;
-
-  /** ensure that a task is running to monitor transmission and reading of acks */
+  /**
+   * ensure that a task is running to monitor transmission and reading of acks
+   */
-      final long msAW = this.owner.getDM().getConfig().getAckWaitThreshold() * 1000L;
-      final long msSA = this.owner.getDM().getConfig().getAckSevereAlertThreshold() * 1000L;
+      final long msAW = owner.getDM().getConfig().getAckWaitThreshold() * 1000L;
+      final long msSA = owner.getDM().getConfig().getAckSevereAlertThreshold() * 1000L;
-          byte connState = -1;
+          byte connState;
-            // since transmission and ack-receipt are performed serially, we don't
-            // want to complain about all receivers out just because one was slow. We therefore
-            // reset
-            // the time stamps and give others more time
-            for (Iterator it = group.iterator(); it.hasNext();) {
-              Connection con = (Connection) it.next();
+            // since transmission and ack-receipt are performed serially, we don't want to complain
+            // about all receivers out just because one was slow. We therefore reset the time stamps
+            // and give others more time
+            for (Object o : group) {
+              Connection con = (Connection) o;
-  /** ack-wait-threshold and ack-severe-alert-threshold processing */
+  /**
+   * ack-wait-threshold and ack-severe-alert-threshold processing
+   */
-    if (ackSATimeout > 0 && (transmissionStartTime + ackWaitTimeout + ackSATimeout) <= now) {
+    if (ackSATimeout > 0 && transmissionStartTime + ackWaitTimeout + ackSATimeout <= now) {
-    } else if (!ackTimedOut && (0 < ackWaitTimeout)
-        && (transmissionStartTime + ackWaitTimeout) <= now) {
+    }
+    if (!ackTimedOut && 0 < ackWaitTimeout
+        && transmissionStartTime + ackWaitTimeout <= now) {
-      final String state = (connectionState == Connection.STATE_SENDING)
+      final String state = connectionState == Connection.STATE_SENDING
-        this.owner.getDM().getDistribution()
+        owner.getDM().getDistribution()
-    final DMStats stats = this.owner.getConduit().getStats();
+    final DMStats stats = owner.getConduit().getStats();
-      // if we can conflate delay the copy to see if we can reuse
-      // an already allocated buffer.
+      // if we can conflate delay the copy to see if we can reuse an already allocated buffer.
-      final int origBufferPos = buffer.position(); // to fix bug 34832
+      final int origBufferPos = buffer.position();
-      synchronized (this.outgoingQueue) {
-        if (this.disconnectRequested) {
+      synchronized (outgoingQueue) {
+        if (disconnectRequested) {
-          throw new ConnectionException(String.format("Forced disconnect sent to %s",
-              this.remoteAddr));
+          throw new ConnectionException(String.format("Forced disconnect sent to %s", remoteAddr));
-        if (!force && !this.asyncQueuingInProgress) {
-          // reset buffer since we will be sending it. This fixes bug 34832
+        if (!force && !asyncQueuingInProgress) {
+          // reset buffer since we will be sending it
-            Object oldValue = this.conflatedKeys.put(ck, ck);
+            Object oldValue = conflatedKeys.put(ck, ck);
+
+
+
-              if (this.outgoingQueue.getLast() == oldck) {
-                this.outgoingQueue.removeLast();
+
+              if (outgoingQueue.getLast() == oldck) {
+                outgoingQueue.removeLast();
-              this.queuedBytes -= oldBytes;
+              queuedBytes -= oldBytes;
-            /* Object removedVal = */ this.conflatedKeys.remove(ck);
+            conflatedKeys.remove(ck);
-        {
-          long newQueueSize = newBytes + this.queuedBytes;
-          if (newQueueSize > this.asyncMaxQueueSize) {
-            logger.warn("Queued bytes {} exceeds max of {}, asking slow receiver {} to disconnect.",
-                newQueueSize, this.asyncMaxQueueSize, this.remoteAddr);
-            stats.incAsyncQueueSizeExceeded(1);
-            disconnectSlowReceiver();
-            // reset buffer since we will be sending it
-            buffer.position(origBufferPos);
-            return false;
-          }
+
+        long newQueueSize = newBytes + queuedBytes;
+        if (newQueueSize > asyncMaxQueueSize) {
+          logger.warn("Queued bytes {} exceeds max of {}, asking slow receiver {} to disconnect.",
+              newQueueSize, asyncMaxQueueSize, remoteAddr);
+          stats.incAsyncQueueSizeExceeded(1);
+          disconnectSlowReceiver();
+          // reset buffer since we will be sending it
+          buffer.position(origBufferPos);
+          return false;
-        this.outgoingQueue.addLast(objToQueue);
-        this.queuedBytes += newBytes;
+
+        outgoingQueue.addLast(objToQueue);
+        queuedBytes += newBytes;
-    } else {
-      startMessagePusher();
-      return true;
+    startMessagePusher();
+    return true;
-  private final Object pusherSync = new Object();
-
-    synchronized (this.pusherSync) {
-      while (this.pusherThread != null) {
+    synchronized (pusherSync) {
+      while (pusherThread != null) {
-          this.pusherSync.wait(); // spurious wakeup ok
+          pusherSync.wait(); // spurious wakeup ok
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+          owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-      this.asyncQueuingInProgress = true;
-      this.pusherThread =
-          new LoggingThread("P2P async pusher to " + this.remoteAddr, this::runMessagePusher);
-    } // synchronized
-    this.pusherThread.start();
+      asyncQueuingInProgress = true;
+      pusherThread = new LoggingThread("P2P async pusher to " + remoteAddr, this::runMessagePusher);
+    }
+    pusherThread.start();
-  private ByteBuffer takeFromOutgoingQueue() throws InterruptedException {
-    ByteBuffer result = null;
-    final DMStats stats = this.owner.getConduit().getStats();
+  private ByteBuffer takeFromOutgoingQueue() {
+    final DMStats stats = owner.getConduit().getStats();
-      synchronized (this.outgoingQueue) {
-        if (this.disconnectRequested) {
+      ByteBuffer result = null;
+      synchronized (outgoingQueue) {
+        if (disconnectRequested) {
-          this.asyncQueuingInProgress = false;
-          this.outgoingQueue.notifyAll();
+          asyncQueuingInProgress = false;
+          outgoingQueue.notifyAll();
-        // Object o = this.outgoingQueue.poll();
-          if (this.outgoingQueue.isEmpty()) {
+          if (outgoingQueue.isEmpty()) {
-          Object o = this.outgoingQueue.removeFirst();
+          Object o = outgoingQueue.removeFirst();
-              this.conflatedKeys.remove(o);
+              conflatedKeys.remove(o);
-          this.queuedBytes -= newBytes;
+          queuedBytes -= newBytes;
-          this.asyncQueuingInProgress = false;
-          this.outgoingQueue.notifyAll();
+          asyncQueuingInProgress = false;
+          outgoingQueue.notifyAll();
-  private boolean disconnectRequested = false;
-
-
-    synchronized (this.outgoingQueue) {
-      if (this.disconnectRequested) {
+    synchronized (outgoingQueue) {
+      if (disconnectRequested) {
-      this.disconnectRequested = true;
+      disconnectRequested = true;
-    DistributionManager dm = this.owner.getDM();
+    DistributionManager dm = owner.getDM();
-      this.owner.removeEndpoint(this.remoteAddr,
-          "no distribution manager");
+      owner.removeEndpoint(remoteAddr, "no distribution manager");
-    dm.getDistribution().requestMemberRemoval(this.remoteAddr,
+    dm.getDistribution().requestMemberRemoval(remoteAddr,
-    // Let's wait
-    // for that to happen and if it doesn't in X seconds
-    // then remove the endpoint.
-    final int FORCE_TIMEOUT = 3000;
-    while (dm.getOtherDistributionManagerIds().contains(this.remoteAddr)) {
+    // Let's wait for that to happen and if it doesn't in X seconds then remove the endpoint.
+    while (dm.getOtherDistributionManagerIds().contains(remoteAddr)) {
-        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
+        owner.getConduit().getCancelCriterion().checkCancelInProgress(ie);
-    this.owner.removeEndpoint(this.remoteAddr,
+    owner.removeEndpoint(remoteAddr,
-    if (dm.getOtherDistributionManagerIds().contains(this.remoteAddr)) {
+    if (dm.getOtherDistributionManagerIds().contains(remoteAddr)) {
-        logger.debug("Force disconnect timed out after waiting {} seconds", (FORCE_TIMEOUT / 1000));
+        final int FORCE_TIMEOUT = 3000;
+        logger.debug("Force disconnect timed out after waiting {} seconds", FORCE_TIMEOUT / 1000);
-      return;
-      final DMStats stats = this.owner.getConduit().getStats();
+      final DMStats stats = owner.getConduit().getStats();
-          while (this.asyncQueuingInProgress && this.connected) {
+          while (asyncQueuingInProgress && connected) {
-              Socket s = this.socket;
+              Socket s = socket;
-              SystemFailure.checkFailure(); // throws
+              SystemFailure.checkFailure();
-            if (this.owner.getConduit().getCancelCriterion().isCancelInProgress()) {
+            if (owner.getConduit().getCancelCriterion().isCancelInProgress()) {
-              long curQueuedBytes = this.queuedBytes;
-              if (curQueuedBytes > this.asyncMaxQueueSize) {
+              long curQueuedBytes = queuedBytes;
+              if (curQueuedBytes > asyncMaxQueueSize) {
-                    curQueuedBytes, this.asyncMaxQueueSize, this.remoteAddr);
+                    curQueuedBytes, asyncMaxQueueSize, remoteAddr);
-              // We should not add messagesSent here according to Bruce.
-              // The counts are increased elsewhere.
-              // messagesSent++;
+              // We should not add messagesSent. The counts are increased elsewhere.
-          } // while
+          }
-          synchronized (this.outgoingQueue) {
-            this.asyncQueuingInProgress = false;
-            this.outgoingQueue.notifyAll();
+          synchronized (outgoingQueue) {
+            asyncQueuingInProgress = false;
+            outgoingQueue.notifyAll();
-      } catch (InterruptedException ex) {
-        // someone wants us to stop.
-        // No need to set interrupt bit, we're quitting.
-        // No need to throw an error, we're quitting.
-        final String err =
-            String.format("P2P pusher io exception for %s", this);
+        String err = String.format("P2P pusher io exception for %s", this);
-      } catch (CancelException ex) { // bug 37367
-        final String err = String.format("P2P pusher %s caught CacheClosedException: %s",
-            this, ex);
+      } catch (CancelException ex) {
+        String err = String.format("P2P pusher %s caught CacheClosedException: %s", this, ex);
-        return;
-        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex); // bug 37101
+        owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-        stats.incAsyncQueueSize(-this.queuedBytes);
-        this.queuedBytes = 0;
+        stats.incAsyncQueueSize(-queuedBytes);
+        queuedBytes = 0;
-      synchronized (this.pusherSync) {
-        this.pusherThread = null;
-        this.pusherSync.notify();
+      synchronized (pusherSync) {
+        pusherThread = null;
+        pusherSync.notifyAll();
-    if (this.asyncQueuingInProgress) {
+    if (asyncQueuingInProgress) {
-    if (this.isReceiver) {
+    if (isReceiver) {
-    if (!this.preserveOrder) {
+    if (!preserveOrder) {
-    if (this.asyncDistributionTimeout == 0) {
+    if (asyncDistributionTimeout == 0) {
-  /**
-   * If true then act as if the socket buffer is full and start async queuing
-   */
-  @MutableForTesting
-  public static volatile boolean FORCE_ASYNC_QUEUE = false;
-
-  private static final int MAX_WAIT_TIME = (1 << 5); // ms (must be a power of 2)
-
-      synchronized (this.outLock) {
+      synchronized (outLock) {
-          if (this.asyncQueuingInProgress) {
+          if (asyncQueuingInProgress) {
-        int waitTime = 1;
-        if (this.asyncDistributionTimeout != 1) {
-          distributionTimeoutTarget = now + this.asyncDistributionTimeout;
+        if (asyncDistributionTimeout != 1) {
+          distributionTimeoutTarget = now + asyncDistributionTimeout;
-        long queueTimeoutTarget = now + this.asyncQueueTimeout;
+        long queueTimeoutTarget = now + asyncQueueTimeout;
+          int waitTime = 1;
-            this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+            owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-                      blockedMs += this.asyncDistributionTimeout;
+                      blockedMs += asyncDistributionTimeout;
-                          blockedMs, this.asyncDistributionTimeout);
+                          blockedMs, asyncDistributionTimeout);
-                long curQueuedBytes = this.queuedBytes;
-                if (curQueuedBytes > this.asyncMaxQueueSize) {
+                long curQueuedBytes = queuedBytes;
+                if (curQueuedBytes > asyncMaxQueueSize) {
-                      curQueuedBytes,
-                      this.asyncMaxQueueSize, this.remoteAddr);
+                      curQueuedBytes, asyncMaxQueueSize, remoteAddr);
-                  // we have waited long enough
-                  // the pusher has been idle too long!
+                  // we have waited long enough the pusher has been idle too long!
-                  blockedMs += this.asyncQueueTimeout;
+                  blockedMs += asyncQueueTimeout;
-                      this.asyncQueueTimeout, this.remoteAddr);
+                      asyncQueueTimeout, remoteAddr);
-                  synchronized (this.outgoingQueue) {
-                    this.asyncQueuingInProgress = false;
-                    this.outgoingQueue.notifyAll(); // for bug 42330
+                  synchronized (outgoingQueue) {
+                    asyncQueuingInProgress = false;
+                    outgoingQueue.notifyAll();
-                    this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+                    owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-              queueTimeoutTarget = System.currentTimeMillis() + this.asyncQueueTimeout;
+              queueTimeoutTarget = System.currentTimeMillis() + asyncQueueTimeout;
+  @VisibleForTesting
-    final DMStats stats = this.owner.getConduit().getStats();
-    if (!this.sharedResource) {
+    final DMStats stats = owner.getConduit().getStats();
+    if (!sharedResource) {
-      if (this.asyncQueuingInProgress) {
+      if (asyncQueuingInProgress) {
-      synchronized (this.outLock) {
+      synchronized (outLock) {
-        if (this.asyncQueuingInProgress) {
+        if (asyncQueuingInProgress) {
-      } // synchronized
+      }
-  /** gets the buffer for receiving message length bytes */
+  /**
+   * gets the buffer for receiving message length bytes
+   */
-      int allocSize = this.recvBufferSize;
+      int allocSize = recvBufferSize;
-        allocSize = this.owner.getConduit().tcpBufferSize;
+        allocSize = owner.getConduit().tcpBufferSize;
-   * stateLock is used to synchronize state changes.
-   */
-  private final Object stateLock = new Object();
-
-  /** for timeout processing, this is the current state of the connection */
-  private byte connectionState = STATE_IDLE;
-
-  /* ~~~~~~~~~~~~~ connection states ~~~~~~~~~~~~~~~ */
-  /** the connection is idle, but may be in use */
-  private static final byte STATE_IDLE = 0;
-  /** the connection is in use and is transmitting data */
-  private static final byte STATE_SENDING = 1;
-  /** the connection is in use and is done transmitting */
-  private static final byte STATE_POST_SENDING = 2;
-  /** the connection is in use and is reading a direct-ack */
-  private static final byte STATE_READING_ACK = 3;
-  /** the connection is in use and has finished reading a direct-ack */
-  private static final byte STATE_RECEIVED_ACK = 4;
-  /** the connection is in use and is reading a message */
-  private static final byte STATE_READING = 5;
-  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
-
-  /** set to true if we exceeded the ack-wait-threshold waiting for a response */
-  private volatile boolean ackTimedOut;
-
-  /**
-      throw new ConnectionException(
-          "connection is closed");
+      throw new ConnectionException("connection is closed");
-    synchronized (this.stateLock) {
-      this.connectionState = STATE_READING_ACK;
+    synchronized (stateLock) {
+      connectionState = STATE_READING_ACK;
-    boolean origSocketInUse = this.socketInUse;
-    this.socketInUse = true;
+    boolean origSocketInUse = socketInUse;
+    socketInUse = true;
-      ReplyMessage msg = null;
+      ReplyMessage msg;
-      ClusterDistributionManager dm = (ClusterDistributionManager) owner.getDM();
+      DistributionManager dm = owner.getDM();
-      } catch (Exception ex) {
+      } catch (Exception ignored) {
-      throw new ConnectionException(
-          String.format("Unable to read direct ack because: %s", e));
+      throw new ConnectionException(String.format("Unable to read direct ack because: %s", e));
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
+      owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
+      owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
-      } catch (Exception ex) {
+      } catch (Exception ignored) {
-      throw new ConnectionException(
-          String.format("Unable to read direct ack because: %s", e));
+      throw new ConnectionException(String.format("Unable to read direct ack because: %s", e));
-      this.socketInUse = origSocketInUse;
-      if (this.ackTimedOut) {
-        logger.info("Finished waiting for reply from {}",
-            getRemoteAddress());
-        this.ackTimedOut = false;
+      socketInUse = origSocketInUse;
+      if (ackTimedOut) {
+        logger.info("Finished waiting for reply from {}", getRemoteAddress());
+        ackTimedOut = false;
-      this.connectionState = STATE_RECEIVED_ACK;
+      connectionState = STATE_RECEIVED_ACK;
-
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+      owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-          if (this.handshakeRead) {
+          if (handshakeRead) {
-            if (!this.isReceiver) {
+            if (!isReceiver) {
-            } else {
-              if (readHandshakeForReceiver(dis)) {
-                ioFilter.doneReading(peerDataBuffer);
-                return;
-              }
+            }
+            if (readHandshakeForReceiver(dis)) {
+              ioFilter.doneReading(peerDataBuffer);
+              return;
-  private boolean readHandshakeForReceiver(DataInputStream dis) {
+  private boolean readHandshakeForReceiver(DataInput dis) {
-      InternalDistributedMember remote = DSFIDFactory.readInternalDistributedMember(dis);
-      setRemoteAddr(remote);
-      this.sharedResource = dis.readBoolean();
-      this.preserveOrder = dis.readBoolean();
-      this.uniqueId = dis.readLong();
+      remoteAddr = DSFIDFactory.readInternalDistributedMember(dis);
+      sharedResource = dis.readBoolean();
+      preserveOrder = dis.readBoolean();
+      uniqueId = dis.readLong();
-      this.remoteVersion = Version.readVersion(dis, true);
+      remoteVersion = Version.readVersion(dis, true);
-      if (this.remoteVersion == null
-          || (this.remoteVersion.compareTo(Version.GFE_80) >= 0)) {
+      if (remoteVersion == null
+          || remoteVersion.compareTo(Version.GFE_80) >= 0) {
-        if (this.sharedResource) {
+        if (sharedResource) {
-        // this.senderName = dis.readUTF();
-      if (!this.sharedResource) {
+      if (!sharedResource) {
-          logger.info(
-              "thread owned receiver forcing itself to send on thread owned sockets");
-          // bug #49565 - if domino count is >= 2 use shared resources.
+          logger.info("thread owned receiver forcing itself to send on thread owned sockets");
+          // if domino count is >= 2 use shared resources.
-          // } else {
-          // ConnectionTable.threadWantsSharedResources();
-        this.conduit.getStats().incThreadOwnedReceivers(1L, dominoNumber);
-        // Because this thread is not shared resource, it will be used for direct
-        // ack. Direct ack messages can be large. This call will resize the send
-        // buffer.
-        setSendBufferSize(this.socket);
+        conduit.getStats().incThreadOwnedReceivers(1L, dominoNumber);
+        // Because this thread is not shared resource, it will be used for direct ack.
+        // Direct ack messages can be large. This call will resize the send buffer.
+        setSendBufferSize(socket);
-      // String name = owner.getDM().getConfig().getName();
-      // if (name == null) {
-      // name = "pid="+OSProcess.getId();
-      // }
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e); // bug 37101
+      owner.getConduit().getCancelCriterion().checkCancelInProgress(e); // bug 37101
-      this.readerShuttingDown = true;
+      readerShuttingDown = true;
-      logger.debug("P2P handshake remoteAddr is {}{}", this.remoteAddr,
-          (this.remoteVersion != null ? " (" + this.remoteVersion + ')' : ""));
+      logger.debug("P2P handshake remoteAddr is {}{}", remoteAddr,
+          remoteVersion != null ? " (" + remoteVersion + ')' : "");
-      String authInit = System.getProperty(
-          DistributionConfigImpl.SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
-      boolean isSecure = authInit != null && authInit.length() != 0;
+      String authInit = System.getProperty(SECURITY_SYSTEM_PREFIX + SECURITY_PEER_AUTH_INIT);
+      boolean isSecure = authInit != null && !authInit.isEmpty();
-        if (owner.getConduit().waitForMembershipCheck(this.remoteAddr)) {
-          sendOKHandshakeReply(); // fix for bug 33224
+        if (owner.getConduit().waitForMembershipCheck(remoteAddr)) {
+          sendOKHandshakeReply();
-          // ARB: check if we need notifyHandshakeWaiter() call.
+          // check if we need notifyHandshakeWaiter() call.
-        sendOKHandshakeReply(); // fix for bug 33224
+        sendOKHandshakeReply();
-      this.finishedConnecting = true;
+      finishedConnecting = true;
-      this.readerShuttingDown = true;
+      readerShuttingDown = true;
-      messageType &= ~DIRECT_ACK_BIT; // clear the ack bit
+      // clear the ack bit
+      messageType &= ~DIRECT_ACK_BIT;
-    // Following validation fixes bug 31145
-      this.readerShuttingDown = true;
+      readerShuttingDown = true;
-      this.owner.getConduit().getStats().incMessagesBeingReceived(true, messageLength);
+      owner.getConduit().getStats().incMessagesBeingReceived(true, messageLength);
-      DistributionMessage msg;
-        long startSer = this.owner.getConduit().getStats().startMsgDeserialization();
+        long startSer = owner.getConduit().getStats().startMsgDeserialization();
+        DistributionMessage msg;
-        this.owner.getConduit().getStats().endMsgDeserialization(startSer);
+        owner.getConduit().getStats().endMsgDeserialization(startSer);
-          logger.warn("Message deserialization of {} did not read {} bytes.",
-              msg, bbis.available());
+          logger.warn("Message deserialization of {} did not read {} bytes.", msg,
+              bbis.available());
-          directAck = false; // don't respond (bug39117)
+          directAck = false; // don't respond
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
+          owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
-        sendFailureReply(ReplyProcessor21.getMessageRPId(),
-            "Error deserializing message", t,
+        sendFailureReply(ReplyProcessor21.getMessageRPId(), "Error deserializing message", t,
-      this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
+      owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
+        // ignored
-      this.owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
+      owner.getConduit().getStats().incMessagesBeingReceived(md.size() == 0,
-        this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
+        owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-        this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
+        owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+        owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
-        this.owner.getConduit().getStats().decMessagesBeingReceived(md.size());
+        owner.getConduit().getCancelCriterion().checkCancelInProgress(ex);
+        owner.getConduit().getStats().decMessagesBeingReceived(md.size());
-        logger.fatal("Unexpected failure deserializing message",
-            failureEx);
+        logger.fatal("Unexpected failure deserializing message", failureEx);
-          this.owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
+          owner.getConduit().getCancelCriterion().checkCancelInProgress(de);
-      this.replyCode = dis.readUnsignedByte();
+      int replyCode = dis.readUnsignedByte();
-          this.asyncDistributionTimeout = dis.readInt();
-          this.asyncQueueTimeout = dis.readInt();
-          this.asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
-          if (this.asyncDistributionTimeout != 0) {
-            logger.info("{} async configuration received {}.",
-                p2pReaderName(),
-                " asyncDistributionTimeout=" + this.asyncDistributionTimeout
-                    + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                    + " asyncMaxQueueSize="
-                    + (this.asyncMaxQueueSize / (1024 * 1024)));
+          asyncDistributionTimeout = dis.readInt();
+          asyncQueueTimeout = dis.readInt();
+          asyncMaxQueueSize = (long) dis.readInt() * (1024 * 1024);
+          if (asyncDistributionTimeout != 0) {
+            logger.info("{} async configuration received {}.", p2pReaderName(),
+                " asyncDistributionTimeout=" + asyncDistributionTimeout
+                    + " asyncQueueTimeout=" + asyncQueueTimeout
+                    + " asyncMaxQueueSize=" + asyncMaxQueueSize / (1024 * 1024));
-          this.remoteVersion = Version.readVersion(dis, true);
+          remoteVersion = Version.readVersion(dis, true);
-              String.format("Unknown handshake reply code: %s messageLength: %s", this.replyCode,
-                  this.messageLength);
-          if (replyCode == 0 && logger.isDebugEnabled()) { // bug 37113
+              "Unknown handshake reply code: " + replyCode + " messageLength: " + messageLength;
+          if (replyCode == 0 && logger.isDebugEnabled()) {
-          this.readerShuttingDown = true;
+          readerShuttingDown = true;
-          return;
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
+      owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
-      this.readerShuttingDown = true;
+      readerShuttingDown = true;
-      return;
-      logger.fatal("Throwable deserializing P2P handshake reply",
-          t);
-      this.readerShuttingDown = true;
+      logger.fatal("Throwable deserializing P2P handshake reply", t);
+      readerShuttingDown = true;
-      return;
-    Thread.currentThread().setName(THREAD_KIND_IDENTIFIER + " for " + this.remoteAddr + " "
-        + (this.sharedResource ? "" : "un") + "shared" + " " + (this.preserveOrder ? "" : "un")
-        + "ordered" + " uid=" + this.uniqueId + (dominoNumber > 0 ? (" dom #" + dominoNumber) : "")
-        + " port=" + this.socket.getPort());
+    Thread.currentThread().setName(THREAD_KIND_IDENTIFIER + " for " + remoteAddr + " "
+        + (sharedResource ? "" : "un") + "shared" + " " + (preserveOrder ? "" : "un")
+        + "ordered" + " uid=" + uniqueId + (dominoNumber > 0 ? " dom #" + dominoNumber : "")
+        + " port=" + socket.getPort());
-    final MembershipStatistics stats = this.owner.getConduit().getStats();
-      this.owner.getConduit().messageReceived(this, msg, bytesRead);
+      owner.getConduit().messageReceived(this, msg, bytesRead);
-  protected TCPConduit getConduit() {
-    return this.conduit;
+  TCPConduit getConduit() {
+    return conduit;
-    // fix for bug 37286
-    Socket result = this.socket;
+    Socket result = socket;
-      throw new SocketException(
-          "socket has been closed");
+      throw new SocketException("socket has been closed");
-    return this.socket.isClosed() || !this.socket.isConnected();
+    return socket.isClosed() || !socket.isConnected();
-    return this.stopped;
+    return stopped;
-    return this.socketInUse;
+    return socketInUse;
-
-    this.accessed = true;
+    accessed = true;
-    return this.remoteAddr;
+    return remoteAddr;
-    return this.remoteVersion;
+    return remoteVersion;
-    return String.valueOf(remoteAddr) + '@' + this.uniqueId
-        + (this.remoteVersion != null ? ('(' + this.remoteVersion.toString() + ')')
-            : "") /*
-                   * DEBUG + " accepted=" + this.isReceiver + " connected=" + this.connected +
-                   * " hash=" + System.identityHashCode(this) + " preserveOrder=" +
-                   * this.preserveOrder + " closing=" + isClosing() + ">"
-                   */;
+    return String.valueOf(remoteAddr) + '@' + uniqueId
+        + (remoteVersion != null ? '(' + remoteVersion.toString() + ')' : "");
-    return !this.isReceiver;
+    return !isReceiver;
-    return this.uniqueId;
+    return uniqueId;
-    if (!this.connected) {
-      throw new ConnectionException(
-          "connection is closed");
+    if (!connected) {
+      throw new ConnectionException("connection is closed");
-        this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+        owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
-          this.senderSem.acquire();
+          senderSem.acquire();
-      } // for
+      }
-    if (!this.connected) {
-      this.senderSem.release();
-      this.owner.getConduit().getCancelCriterion().checkCancelInProgress(null); // bug 37101
-      throw new ConnectionException(
-          "connection is closed");
+    if (!connected) {
+      senderSem.release();
+      owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+      throw new ConnectionException("connection is closed");
-    this.senderSem.release();
+    senderSem.release();
+  private class BatchBufferFlusher extends Thread {
+
+    private volatile boolean flushNeeded;
+    private volatile boolean timeToStop;
+    private final DMStats stats;
+
+    BatchBufferFlusher() {
+      setDaemon(true);
+      stats = owner.getConduit().getStats();
+    }
+
+    /**
+     * Called when a message writer needs the current fillBatchBuffer flushed
+     */
+    void flushBuffer(ByteBuffer bb) {
+      final long start = DistributionStats.getStatTime();
+      try {
+        synchronized (this) {
+          synchronized (batchLock) {
+            if (bb != fillBatchBuffer) {
+              // it must have already been flushed. So just return and use the new fillBatchBuffer
+              return;
+            }
+          }
+          flushNeeded = true;
+          notifyAll();
+        }
+        synchronized (batchLock) {
+          // Wait for the flusher thread
+          while (bb == fillBatchBuffer) {
+            owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+            boolean interrupted = Thread.interrupted();
+            try {
+              batchLock.wait(); // spurious wakeup ok
+            } catch (InterruptedException ex) {
+              interrupted = true;
+            } finally {
+              if (interrupted) {
+                Thread.currentThread().interrupt();
+              }
+            }
+          }
+        }
+      } finally {
+        owner.getConduit().getStats().incBatchWaitTime(start);
+      }
+    }
+
+    public void close() {
+      synchronized (this) {
+        timeToStop = true;
+        flushNeeded = true;
+        notifyAll();
+      }
+    }
+
+    @Override
+    public void run() {
+      try {
+        synchronized (this) {
+          while (!timeToStop) {
+            if (!flushNeeded && fillBatchBuffer.position() <= BATCH_BUFFER_SIZE / 2) {
+              wait(BATCH_FLUSH_MS); // spurious wakeup ok
+            }
+            if (flushNeeded || fillBatchBuffer.position() > BATCH_BUFFER_SIZE / 2) {
+              final long start = DistributionStats.getStatTime();
+              synchronized (batchLock) {
+                // This is the only block of code that will swap the buffer references
+                flushNeeded = false;
+                ByteBuffer tmp = fillBatchBuffer;
+                fillBatchBuffer = sendBatchBuffer;
+                sendBatchBuffer = tmp;
+                batchLock.notifyAll();
+              }
+              // We now own the sendBatchBuffer
+              if (sendBatchBuffer.position() > 0) {
+                final boolean origSocketInUse = socketInUse;
+                socketInUse = true;
+                try {
+                  sendBatchBuffer.flip();
+                  SocketChannel channel = getSocket().getChannel();
+                  writeFully(channel, sendBatchBuffer, false, null);
+                  sendBatchBuffer.clear();
+                } catch (IOException | ConnectionException ex) {
+                  logger.fatal("Exception flushing batch send buffer: %s", ex);
+                  readerShuttingDown = true;
+                  requestClose(String.format("Exception flushing batch send buffer: %s", ex));
+                } finally {
+                  accessed();
+                  socketInUse = origSocketInUse;
+                }
+              }
+              stats.incBatchFlushTime(start);
+            }
+          }
+        }
+      } catch (InterruptedException ex) {
+        // time for this thread to shutdown
+      }
+    }
+  }

GEODE-5055: Handle index in progress for old clients (#1961)

* If the Lucene query function is executed by an old client (< 1.6.0) on a new server, it will wait for the index to be created.
            * Server wont return a LuceneIndexCreationInProgressException back to the old client resulting in a ClassNotFoundException.
	    * LuceneIndexCreationInProgressException is wrapped in a FunctionException and sent to the caller function
	    * The caller unwraps and send the LuceneQueryException back to the user.
+import org.apache.geode.internal.cache.execute.PartitionedRegionFunctionResultSender;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+    if (context.getResultSender() instanceof PartitionedRegionFunctionResultSender) {
+      PartitionedRegionFunctionResultSender resultSender =
+          (PartitionedRegionFunctionResultSender) context.getResultSender();
+      Version clientVersion = resultSender.getClientVersion();
+      if (clientVersion != null) { // is a client server connection
+        if (clientVersion.ordinal() < Version.GEODE_160.ordinal()) {
+          execute(context, true);
+          return;
+        }
+      }
+    }
-  private void handleException(LuceneIndexCreationInProgressException ex,
+  private void handleIfRetryNeededOnException(LuceneIndexCreationInProgressException ex,
-        if (remoteMember.getVersionObject().ordinal() <= Version.GEODE_160.ordinal()) {
+        if (remoteMember.getVersionObject().ordinal() < Version.GEODE_160.ordinal()) {
-    // Will return the LuceneIndexCreationInProgressException as the new servers can handle this
-    // exception
-    throw ex;
+    // Cannot send IndexingInProgressException as the function may have been executed a new server
+    // on behalf of an old version client.
+    throw new FunctionException(new LuceneQueryException(
+        LocalizedStrings.LuceneQueryException_INDEX_NOT_AVAILABLE_CURRENTLY_INDEXING
+            .toLocalizedString()));
-        handleException(ex, ctx);
+        handleIfRetryNeededOnException(ex, ctx);
-        logger.debug("The lucene query should have waited for the index to be created");
-        throw ex;
+        logger.warn("The lucene query should have waited for the index to be created");
+        throw new FunctionException(new LuceneQueryException(
+            LocalizedStrings.LuceneQueryException_INDEX_NOT_AVAILABLE_CURRENTLY_INDEXING
+                .toLocalizedString()));

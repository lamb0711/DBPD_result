GEODE-6857: Moves function timeout to function operations.

* Extracts out an abstract function operation that manages setting
  and restoring timeout.

* Move timeout property read to AbstractExecution constructor.

+import static org.apache.geode.internal.cache.execute.AbstractExecution.DEFAULT_CLIENT_FUNCTION_TIMEOUT;
+
+   * @param timeoutMs timeout in milliseconds
-      byte hasResult, int mRetryAttempts) {
+      byte hasResult, int mRetryAttempts, final int timeoutMs) {
-    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-        resultCollector, hasResult, new HashSet<>());
+    ExecuteRegionFunctionOpImpl op =
+        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
+            resultCollector, hasResult, new HashSet<>(), timeoutMs);
-          resultCollector, hasResult, failedNodes, maxRetryAttempts);
+          resultCollector, hasResult, failedNodes, maxRetryAttempts, timeoutMs);
-      byte hasResult, int mRetryAttempts, boolean isHA, boolean optimizeForWrite) {
+      byte hasResult, int mRetryAttempts, boolean isHA, boolean optimizeForWrite,
+      final int timeoutMs) {
-    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-        resultCollector, hasResult, new HashSet<>(), isHA, optimizeForWrite, true);
+    ExecuteRegionFunctionOpImpl op =
+        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
+            resultCollector, hasResult, new HashSet<>(), isHA, optimizeForWrite, true, timeoutMs);
-          resultCollector, hasResult, failedNodes, maxRetryAttempts, isHA, optimizeForWrite);
+          resultCollector, hasResult, failedNodes, maxRetryAttempts, isHA, optimizeForWrite,
+          timeoutMs);
-      byte hasResult, Set<String> failedNodes, int retryAttempts) {
+      byte hasResult, Set<String> failedNodes, int retryAttempts, final int timeoutMs) {
-    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-        resultCollector, hasResult, new HashSet<>());
+    ExecuteRegionFunctionOpImpl op =
+        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
+            resultCollector, hasResult, new HashSet<>(), timeoutMs);
-      AbstractOp reExecuteOp = new ExecuteRegionFunctionOpImpl(op, (byte) 1/* isReExecute */, failedNodes);
+      AbstractOp reExecuteOp =
+          new ExecuteRegionFunctionOpImpl(op, (byte) 1/* isReExecute */, failedNodes);
-      boolean optimizeForWrite) {
+      boolean optimizeForWrite, final int timeoutMs) {
-    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-        resultCollector, hasResult, new HashSet<>(), isHA, optimizeForWrite, true);
+    ExecuteRegionFunctionOpImpl op =
+        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
+            resultCollector, hasResult, new HashSet<>(), isHA, optimizeForWrite, true, timeoutMs);
-      ExecuteRegionFunctionOpImpl reExecuteOp = new ExecuteRegionFunctionOpImpl(op, (byte) 1/* isReExecute */, failedNodes);
+      ExecuteRegionFunctionOpImpl reExecuteOp =
+          new ExecuteRegionFunctionOpImpl(op, (byte) 1/* isReExecute */, failedNodes);
-  static class ExecuteRegionFunctionOpImpl extends AbstractOp {
+  static class ExecuteRegionFunctionOpImpl extends AbstractOpWithTimeout {
-        Set<String> removedNodes) {
+        Set<String> removedNodes, final int timeoutMs) {
-          8 + serverRegionExecutor.getFilter().size() + removedNodes.size());
+          8 + serverRegionExecutor.getFilter().size() + removedNodes.size(), timeoutMs);
-      super(MessageType.EXECUTE_REGION_FUNCTION,
-          0);
+      super(MessageType.EXECUTE_REGION_FUNCTION, 0, DEFAULT_CLIENT_FUNCTION_TIMEOUT);
-        boolean calculateFnState) {
+        boolean calculateFnState, final int timeoutMs) {
-          8 + serverRegionExecutor.getFilter().size() + removedNodes.size());
+          8 + serverRegionExecutor.getFilter().size() + removedNodes.size(), timeoutMs);
-          newop.optimizeForWrite(), false);
+          newop.optimizeForWrite(), false, newop.getTimeoutMs());
-          8 + op.executor.getFilter().size() + removedNodes.size());
+          8 + op.executor.getFilter().size() + removedNodes.size(), op.getTimeoutMs());
-      if (ConnectionImpl
-          .getClientFunctionTimeout() == ConnectionImpl.DEFAULT_CLIENT_FUNCTION_TIMEOUT) {
+      if (getTimeoutMs() == DEFAULT_CLIENT_FUNCTION_TIMEOUT) {
-        Part.encodeInt(ConnectionImpl.getClientFunctionTimeout(), bytes, 1);
+        Part.encodeInt(getTimeoutMs(), bytes, 1);

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-@SuppressWarnings({ "deprecation", "unchecked" })
+@SuppressWarnings({"deprecation", "unchecked"})
-  private final Set<PersistentMemberPattern> newerSharedConfigurationLocatorInfo = new HashSet<PersistentMemberPattern>();
-  private final AtomicReference<SharedConfigurationStatus> status = new AtomicReference<SharedConfigurationStatus>();
+  private final Set<PersistentMemberPattern> newerSharedConfigurationLocatorInfo =
+      new HashSet<PersistentMemberPattern>();
+  private final AtomicReference<SharedConfigurationStatus> status =
+      new AtomicReference<SharedConfigurationStatus>();
-  private  GemFireCacheImpl cache;
+  private GemFireCacheImpl cache;
-    DistributedLockService sharedConfigDls = DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
+    DistributedLockService sharedConfigDls =
+        DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
-        sharedConfigDls = DLockService.create(SHARED_CONFIG_LOCK_SERVICE_NAME, (InternalDistributedSystem) ds, true, true);
+        sharedConfigDls = DLockService.create(SHARED_CONFIG_LOCK_SERVICE_NAME,
+            (InternalDistributedSystem) ds, true, true);
-      return  DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
+      return DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
-    this.cache = (GemFireCacheImpl)cache;
-    this.configDiskDirName = CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
-    String clusterConfigDir = cache.getDistributedSystem().getProperties().getProperty(CLUSTER_CONFIGURATION_DIR);
+    this.cache = (GemFireCacheImpl) cache;
+    this.configDiskDirName =
+        CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
+    String clusterConfigDir =
+        cache.getDistributedSystem().getProperties().getProperty(CLUSTER_CONFIGURATION_DIR);
+   * 
-  public boolean addJars(String []jarNames, byte[][]jarBytes, String[]groups)  {
+  public boolean addJars(String[] jarNames, byte[][] jarBytes, String[] groups) {
-      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
+      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
-   * @param loadSharedConfigFromDir when set to true, loads the configuration from the share_config directory
+   * 
+   * @param loadSharedConfigFromDir when set to true, loads the configuration from the share_config
+   *        directory
-        logger.info("Reading cluster configuration from '{}' directory", SharedConfiguration.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+        logger.info("Reading cluster configuration from '{}' directory",
+            SharedConfiguration.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
-        final DM dm =  cache.getDistributedSystem().getDistributionManager();
+        final DM dm = cache.getDistributedSystem().getDistributionManager();
-          Set<DistributedMember> locatorsWithSC = new HashSet<DistributedMember>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
+          Set<DistributedMember> locatorsWithSC = new HashSet<DistributedMember>(
+              dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-          //Send the config to other locators which host the shared configuration.
+          // Send the config to other locators which host the shared configuration.
-            final ImportSharedConfigurationArtifactsFunction fn = new ImportSharedConfigurationArtifactsFunction();
+            final ImportSharedConfigurationArtifactsFunction fn =
+                new ImportSharedConfigurationArtifactsFunction();
-            String zipFileName =  CliStrings.format(CliStrings.EXPORT_SHARED_CONFIG__FILE__NAME, new Timestamp(date.getTime()).toString());
+            String zipFileName = CliStrings.format(CliStrings.EXPORT_SHARED_CONFIG__FILE__NAME,
+                new Timestamp(date.getTime()).toString());
-              Object [] args = new Object[] {zipFileName, zipBytes};
+              Object[] args = new Object[] {zipFileName, zipBytes};
-        //Clear the configuration region and load the configuration read from the 'shared_config' directory
+        // Clear the configuration region and load the configuration read from the 'shared_config'
+        // directory
-      //Write out the existing configuration into the 'shared_config' directory
-      //And get deployed jars from other locators.
+      // Write out the existing configuration into the 'shared_config' directory
+      // And get deployed jars from other locators.
-       try {
+      try {
-    Properties securityProps =  cache.getDistributedSystem().getSecurityProperties();
+    Properties securityProps = cache.getDistributedSystem().getSecurityProperties();
-    if(clusterPropertiesConfig == null){
+    if (clusterPropertiesConfig == null) {
-      clusterProperties.setProperty(SECURITY_POST_PROCESSOR, securityProps.getProperty(SECURITY_POST_PROCESSOR));
+      clusterProperties.setProperty(SECURITY_POST_PROCESSOR,
+          securityProps.getProperty(SECURITY_POST_PROCESSOR));
-   * Creates a ConfigurationResponse based on the configRequest, configuration response contains the requested shared configuration
-   * This method locks the SharedConfiguration
+   * Creates a ConfigurationResponse based on the configRequest, configuration response contains the
+   * requested shared configuration This method locks the SharedConfiguration
-  public ConfigurationResponse createConfigurationReponse(final ConfigurationRequest configRequest) throws Exception {
+  public ConfigurationResponse createConfigurationReponse(final ConfigurationRequest configRequest)
+      throws Exception {
-    for (int i=0; i<configRequest.getNumAttempts(); i++) {
+    for (int i = 0; i < configRequest.getNumAttempts(); i++) {
-          logger.info("Building up configuration response with following configurations: {}", groups);
+          logger.info("Building up configuration response with following configurations: {}",
+              groups);
-            String[] jarNames = (String[])jars[0];
+            String[] jarNames = (String[]) jars[0];
-   * Create a response containing the status of the Shared configuration and information about other locators containing newer
-   * shared configuration data (if at all)
-   * @return {@link SharedConfigurationStatusResponse} containing the {@link SharedConfigurationStatus}
+   * Create a response containing the status of the Shared configuration and information about other
+   * locators containing newer shared configuration data (if at all)
+   * 
+   * @return {@link SharedConfigurationStatusResponse} containing the
+   *         {@link SharedConfigurationStatus}
-    //No group is specified, so delete in every single group if it exists.
+    // No group is specified, so delete in every single group if it exists.
-  public void modifyCacheAttributes(final XmlEntity xmlEntity, String [] groups) throws Exception {
+  public void modifyCacheAttributes(final XmlEntity xmlEntity, String[] groups) throws Exception {
-    //No group is specified, so modify the cache attributes for a in every single group if it exists.
+    // No group is specified, so modify the cache attributes for a in every single group if it
+    // exists.
-      //Modify the cache attributes
+      // Modify the cache attributes
-      //Change the xml content of the configuration and put it the config region
+      // Change the xml content of the configuration and put it the config region
-      String [] jarNames = new String[numJars];
+      String[] jarNames = new String[numJars];
-              jarNames[ctr]=jarName;
+              jarNames[ctr] = jarName;
-   * @return {@link String}  path of the shared configuration directory
+   * 
+   * @return {@link String} path of the shared configuration directory
-   * Gets the current status of the SharedConfiguration
-   * If the status is started , it determines if the shared configuration is waiting for new configuration on
-   * other locators
+   * Gets the current status of the SharedConfiguration If the status is started , it determines if
+   * the shared configuration is waiting for new configuration on other locators
+   * 
-        this.status.compareAndSet(SharedConfigurationStatus.STARTED, SharedConfigurationStatus.WAITING);
-        Set<PersistentMemberID> persMemIds =  waitingRegions.get(Region.SEPARATOR_CHAR + CONFIG_REGION_NAME);
+        this.status.compareAndSet(SharedConfigurationStatus.STARTED,
+            SharedConfigurationStatus.WAITING);
+        Set<PersistentMemberID> persMemIds =
+            waitingRegions.get(Region.SEPARATOR_CHAR + CONFIG_REGION_NAME);
+   * 
+   * 
-  public boolean removeJars(final String[] jarNames, String[] groups){
+  public boolean removeJars(final String[] jarNames, String[] groups) {
-          String dirPath = FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
+          String dirPath =
+              FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
-      String configDirFileName2 = CLUSTER_CONFIG_ARTIFACTS_DIR_NAME + new SimpleDateFormat("yyyyMMddhhmm").format(new Date()) + "." + System.nanoTime();
+      String configDirFileName2 = CLUSTER_CONFIG_ARTIFACTS_DIR_NAME
+          + new SimpleDateFormat("yyyyMMddhhmm").format(new Date()) + "." + System.nanoTime();
-    String dirPath = FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
+    String dirPath =
+        FilenameUtils.concat(getSharedConfigurationDirPath(), configuration.getConfigName());
-    Set<DistributedMember> locators = new HashSet<DistributedMember>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
+    Set<DistributedMember> locators =
+        new HashSet<DistributedMember>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-    String [] jarNames = null;
-    byte [][] jarBytes = null;
+    String[] jarNames = null;
+    byte[][] jarBytes = null;
-    ResultCollector<?, List<Object>> rc = (ResultCollector<?, List<Object>>) CliUtil.executeFunction(getAllJarsFunction, null , locators);
+    ResultCollector<?, List<Object>> rc = (ResultCollector<?, List<Object>>) CliUtil
+        .executeFunction(getAllJarsFunction, null, locators);
-          jarNames = (String[])jars[0];
+          jarNames = (String[]) jars[0];
-      for (int i=0; i<jarNames.length; i++) {
+      for (int i = 0; i < jarNames.length; i++) {
-            //This should NEVER happen
+            // This should NEVER happen
-   * Gets the region containing the shared configuration data.
-   * The region is created , if it does not exist already.
-   * Note : this could block if this locator contains stale persistent configuration data.
+   * Gets the region containing the shared configuration data. The region is created , if it does
+   * not exist already. Note : this could block if this locator contains stale persistent
+   * configuration data.
+   * 
-        File [] diskDirs = {diskDir};
-        cache.createDiskStoreFactory()
-        .setDiskDirs(diskDirs)
-        .setAutoCompact(true)
-        .setMaxOplogSize(10)
-        .create(CLUSTER_CONFIG_DISK_STORE_NAME);
+        File[] diskDirs = {diskDir};
+        cache.createDiskStoreFactory().setDiskDirs(diskDirs).setAutoCompact(true)
+            .setMaxOplogSize(10).create(CLUSTER_CONFIG_DISK_STORE_NAME);
-        AttributesFactory<String, Configuration> regionAttrsFactory = new AttributesFactory<String, Configuration>();
+        AttributesFactory<String, Configuration> regionAttrsFactory =
+            new AttributesFactory<String, Configuration>();
-        configRegion = cache.createVMRegion(CONFIG_REGION_NAME, regionAttrsFactory.create(), internalArgs);
+        configRegion =
+            cache.createVMRegion(CONFIG_REGION_NAME, regionAttrsFactory.create(), internalArgs);
-   * Reads the configuration information from the shared configuration directory and returns a {@link Configuration} object
+   * Reads the configuration information from the shared configuration directory and returns a
+   * {@link Configuration} object
+   * 
-  private Configuration readConfiguration(final String configName, final String configDirectory) throws SAXException, ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
+  private Configuration readConfiguration(final String configName, final String configDirectory)
+      throws SAXException, ParserConfigurationException, TransformerFactoryConfigurationError,
+      TransformerException {
-    String cacheXmlFullPath = FilenameUtils.concat(configDirectory, configuration.getCacheXmlFileName());
-    String propertiesFullPath = FilenameUtils.concat(configDirectory, configuration.getPropertiesFileName());
+    String cacheXmlFullPath =
+        FilenameUtils.concat(configDirectory, configuration.getCacheXmlFileName());
+    String propertiesFullPath =
+        FilenameUtils.concat(configDirectory, configuration.getPropertiesFileName());
-    String [] jarFileNames = file.list(jarFileFilter);
+    String[] jarFileNames = file.list(jarFileFilter);
-    if (jarFileNames != null && jarFileNames.length != 0 ) {
+    if (jarFileNames != null && jarFileNames.length != 0) {
+   * 
-   * Reads the "shared_config" directory and loads all the cache.xml, gemfire.properties and deployed jars information
+   * Reads the "shared_config" directory and loads all the cache.xml, gemfire.properties and
+   * deployed jars information
+   * 
-  private Map<String, Configuration> readSharedConfigurationFromDisk() throws SAXException, ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
+  private Map<String, Configuration> readSharedConfigurationFromDisk() throws SAXException,
+      ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
+   * 
-      for (int i=0; i<jarNames.length; i++) {
+      for (int i = 0; i < jarNames.length; i++) {
-      String []jarFileNames = dir.list(jarFileFilter);
+      String[] jarFileNames = dir.list(jarFileFilter);
-  private void writeCacheXml(final String dirPath, final Configuration configuration) throws IOException {
-    String fullPath = FilenameUtils.concat(dirPath,configuration.getCacheXmlFileName());
-    FileUtils.writeStringToFile(new File(fullPath), configuration.getCacheXmlContent(), "UTF-8") ;
+  private void writeCacheXml(final String dirPath, final Configuration configuration)
+      throws IOException {
+    String fullPath = FilenameUtils.concat(dirPath, configuration.getCacheXmlFileName());
+    FileUtils.writeStringToFile(new File(fullPath), configuration.getCacheXmlContent(), "UTF-8");
+   * 
-  private void writeJarFiles(final String dirPath, final String[] jarNames, final byte[][] jarBytes) {
-    for (int i=0; i<jarNames.length; i++) {
+  private void writeJarFiles(final String dirPath, final String[] jarNames,
+      final byte[][] jarBytes) {
+    for (int i = 0; i < jarNames.length; i++) {
-  private void writeProperties(final String dirPath, final Configuration configuration) throws IOException {
-    String fullPath = FilenameUtils.concat(dirPath,configuration.getPropertiesFileName());
+  private void writeProperties(final String dirPath, final Configuration configuration)
+      throws IOException {
+    String fullPath = FilenameUtils.concat(dirPath, configuration.getPropertiesFileName());
-   * Create a {@link Document} using
-   * {@link XmlUtils#createDocumentFromXml(String)} and if the version attribute
-   * is not equal to the current version then update the XML to the current
-   * schema and return the document.
+   * Create a {@link Document} using {@link XmlUtils#createDocumentFromXml(String)} and if the
+   * version attribute is not equal to the current version then update the XML to the current schema
+   * and return the document.
-  static Document createAndUpgradeDocumentFromXml(final String xmlContent) throws SAXException, ParserConfigurationException, IOException, XPathExpressionException {
+  static Document createAndUpgradeDocumentFromXml(final String xmlContent)
+      throws SAXException, ParserConfigurationException, IOException, XPathExpressionException {
-    if (!CacheXml.VERSION_LATEST.equals(XmlUtils.getAttribute(doc.getDocumentElement(), CacheXml.VERSION, CacheXml.GEODE_NAMESPACE))) {
-      doc = XmlUtils.upgradeSchema(doc, CacheXml.GEODE_NAMESPACE, CacheXml.LATEST_SCHEMA_LOCATION, CacheXml.VERSION_LATEST);
+    if (!CacheXml.VERSION_LATEST.equals(XmlUtils.getAttribute(doc.getDocumentElement(),
+        CacheXml.VERSION, CacheXml.GEODE_NAMESPACE))) {
+      doc = XmlUtils.upgradeSchema(doc, CacheXml.GEODE_NAMESPACE, CacheXml.LATEST_SCHEMA_LOCATION,
+          CacheXml.VERSION_LATEST);
+   * 
-   * @return String[] names of first level subdirectories, null if no subdirectories are found or if the path is incorrect
+   * @return String[] names of first level subdirectories, null if no subdirectories are found or if
+   *         the path is incorrect

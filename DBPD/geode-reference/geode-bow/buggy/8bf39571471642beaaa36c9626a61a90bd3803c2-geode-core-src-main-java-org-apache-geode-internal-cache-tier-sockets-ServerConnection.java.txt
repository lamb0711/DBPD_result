Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Provides an implementation for the server socket end of the hierarchical
- * cache connection. Each server connection runs in its own thread to maximize
- * concurrency and improve response times to edge requests
+ * Provides an implementation for the server socket end of the hierarchical cache connection. Each
+ * server connection runs in its own thread to maximize concurrency and improve response times to
+ * edge requests
-  
+
-   * This is a buffer that we add to client readTimeout value before we cleanup the connection. 
-   * This buffer time helps prevent EOF in the client instead of SocketTimeout
+   * This is a buffer that we add to client readTimeout value before we cleanup the connection. This
+   * buffer time helps prevent EOF in the client instead of SocketTimeout
-  
+
-  private static final ConcurrentHashMap<Integer, LinkedBlockingQueue<ByteBuffer>> commBufferMap = new ConcurrentHashMap<>(4, 0.75f, 1);
+  private static final ConcurrentHashMap<Integer, LinkedBlockingQueue<ByteBuffer>> commBufferMap =
+      new ConcurrentHashMap<>(4, 0.75f, 1);
-  
+
-  
+
-    for (LinkedBlockingQueue<ByteBuffer> q: commBufferMap.values()) {
+    for (LinkedBlockingQueue<ByteBuffer> q : commBufferMap.values()) {
-  //private InputStream in = null;
-  //private OutputStream out = null;
+  // private InputStream in = null;
+  // private OutputStream out = null;
-  
+
-   *  This timeout is request specific which come with message itself
-   *  Otherwise, timeout which comes during handshake is used.  
+   * This timeout is request specific which come with message itself Otherwise, timeout which comes
+   * during handshake is used.
-
-   private String membershipId;
-
-
-    * Uniquely identifying the client's ConnectionProxy object
-    *
-    *
-   private String proxyID ;
+   * 
+   * private String membershipId;
+   * 
+   * 
+   * Uniquely identifying the client's ConnectionProxy object
+   *
+   *
+   * private String proxyID ;
-  byte [] memberIdByteArray;
+  byte[] memberIdByteArray;
-   * Authorize client requests using this object. This is set when each
-   * operation on this connection is authorized in pre-operation phase.
+   * Authorize client requests using this object. This is set when each operation on this connection
+   * is authorized in pre-operation phase.
-   * Authorize client requests using this object. This is set when each
-   * operation on this connection is authorized in post-operation phase.
+   * Authorize client requests using this object. This is set when each operation on this connection
+   * is authorized in post-operation phase.
-   * The communication mode for this <code>ServerConnection</code>.
-   * Valid types include 'client-server', 'gateway-gateway' and
-   * 'monitor-server'.
+   * The communication mode for this <code>ServerConnection</code>. Valid types include
+   * 'client-server', 'gateway-gateway' and 'monitor-server'.
-  
-  private static ConcurrentHashMap<ClientProxyMembershipID, ClientUserAuths> proxyIdVsClientUserAuths = new ConcurrentHashMap<ClientProxyMembershipID, ClientUserAuths>();
- 
-  
+
+  private static ConcurrentHashMap<ClientProxyMembershipID, ClientUserAuths> proxyIdVsClientUserAuths =
+      new ConcurrentHashMap<ClientProxyMembershipID, ClientUserAuths>();
+
+
-  //this is constant(server and client) for first user request, after that it is random
-  //this also need to send in handshake
+  // this is constant(server and client) for first user request, after that it is random
+  // this also need to send in handshake
-  
+
-  
+
-  * A debug flag used for testing Backward compatibility
-  */
-  public static boolean TEST_VERSION_AFTER_HANDSHAKE_FLAG = false;
-  
-  public static short testVersionAfterHandshake = 4;
-  
-  /**
-   * Creates a new <code>ServerConnection</code> that processes messages
-   * received from an edge client over a given <code>Socket</code>.
+   * A debug flag used for testing Backward compatibility
-  public ServerConnection(
-    Socket s,
-    Cache c,
-    CachedRegionHelper helper,
-    CacheServerStats stats,
-    int hsTimeout,
-    int socketBufferSize,
-  String communicationModeStr,
-  byte communicationMode,
-  Acceptor acceptor)
-  {
+  public static boolean TEST_VERSION_AFTER_HANDSHAKE_FLAG = false;
+
+  public static short testVersionAfterHandshake = 4;
+
+  /**
+   * Creates a new <code>ServerConnection</code> that processes messages received from an edge
+   * client over a given <code>Socket</code>.
+   */
+  public ServerConnection(Socket s, Cache c, CachedRegionHelper helper, CacheServerStats stats,
+      int hsTimeout, int socketBufferSize, String communicationModeStr, byte communicationMode,
+      Acceptor acceptor) {
-    if(((AcceptorImpl)acceptor).isGatewayReceiver()) {
-      buffer
-        .append("GatewayReceiver connection from [");
+    if (((AcceptorImpl) acceptor).isGatewayReceiver()) {
+      buffer.append("GatewayReceiver connection from [");
+    } else {
+      buffer.append("Server connection from [");
-    else{
-      buffer
-        .append("Server connection from [");
-    }
-    buffer
-        .append(communicationModeStr)
-        .append(" host address=")
-        .append(s.getInetAddress().getHostAddress())
-        .append("; ")
-        .append(communicationModeStr)
-        .append(" port=")
-        .append(s.getPort())
-        .append("]");
+    buffer.append(communicationModeStr).append(" host address=")
+        .append(s.getInetAddress().getHostAddress()).append("; ").append(communicationModeStr)
+        .append(" port=").append(s.getPort()).append("]");
-    this.acceptor = (AcceptorImpl)acceptor;
+    this.acceptor = (AcceptorImpl) acceptor;
-    this.logWriter = (InternalLogWriter)c.getLoggerI18n();
-    this.securityLogWriter = (InternalLogWriter)c.getSecurityLoggerI18n();
+    this.logWriter = (InternalLogWriter) c.getLoggerI18n();
+    this.securityLogWriter = (InternalLogWriter) c.getSecurityLoggerI18n();
-    
+
-        logger.debug("{}: Accepted client connection from {}[client host name={}; client host address={}; client port={}]",
-            getName(), s.getInetAddress().getCanonicalHostName(), s.getInetAddress().getHostAddress(), s.getPort());
+        logger.debug(
+            "{}: Accepted client connection from {}[client host name={}; client host address={}; client port={}]",
+            getName(), s.getInetAddress().getCanonicalHostName(),
+            s.getInetAddress().getHostAddress(), s.getPort());
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-  
+
-    synchronized(this.handShakeMonitor) {
+    synchronized (this.handShakeMonitor) {
-//        synchronized (getCleanupTable()) {
+        // synchronized (getCleanupTable()) {
-            }
-            catch (CancelException e) {
+            } catch (CancelException e) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.ServerConnection_0_UNEXPECTED_CANCELLATION, getName()), e);
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.ServerConnection_0_UNEXPECTED_CANCELLATION, getName()), e);
-          }
-          else {
+          } else {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.ServerConnection_0_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE_1, new Object[] { this.name, new Byte(this.handshake.getCode()) }));
-            refuseHandshake(LocalizedStrings.ServerConnection_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE.toLocalizedString(), ServerHandShakeProcessor.REPLY_INVALID);
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.ServerConnection_0_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE_1,
+                new Object[] {this.name, new Byte(this.handshake.getCode())}));
+            refuseHandshake(LocalizedStrings.ServerConnection_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE
+                .toLocalizedString(), ServerHandShakeProcessor.REPLY_INVALID);
-//        }
+        // }
-  
+
-  
+
-    
+
-    
+
-  
+
-//    LogWriterI18n log = InternalDistributedSystem.getLoggerI18n();
-//    byte[] oldIdArray = proxyId.getMembershipByteArray();
-//    log.warning(LocalizedStrings.DEBUG, "Size comparison for " + proxyId.getDistributedMember()
-//        + "   old=" + oldIdArray.length + "   new=" + memberIdByteArray.length
-//        + "   diff=" + (oldIdArray.length - memberIdByteArray.length));
-    this.name = "Server connection from [" + proxyId + "; port="
-        + this.theSocket.getPort() + "]";
+    // LogWriterI18n log = InternalDistributedSystem.getLoggerI18n();
+    // byte[] oldIdArray = proxyId.getMembershipByteArray();
+    // log.warning(LocalizedStrings.DEBUG, "Size comparison for " + proxyId.getDistributedMember()
+    // + " old=" + oldIdArray.length + " new=" + memberIdByteArray.length
+    // + " diff=" + (oldIdArray.length - memberIdByteArray.length));
+    this.name = "Server connection from [" + proxyId + "; port=" + this.theSocket.getPort() + "]";
- protected void setPrincipal(Principal principal) {
+  protected void setPrincipal(Principal principal) {
-  
-  //hitesh:this is for backward compability
-  public long setUserAuthorizeAndPostAuthorizeRequest(
-      AuthorizeRequest authzRequest, AuthorizeRequestPP postAuthzRequest)
-      throws IOException {
+
+  // hitesh:this is for backward compability
+  public long setUserAuthorizeAndPostAuthorizeRequest(AuthorizeRequest authzRequest,
+      AuthorizeRequestPP postAuthzRequest) throws IOException {
-  
+
-  
+
-  
+
-  
+
-    synchronized (getCleanupTable()) {
-      Counter numRefs = (Counter)getCleanupTable().get(this.handshake);
-      byte epType = (byte)0 ;
-      int qSize = 0 ;
-      
-      if (this.proxyId.isDurable()) {
-        if (isDebugEnabled) {
-          logger.debug("looking if the Proxy existed for this durable client or not :{}", this.proxyId);
-        }
-        CacheClientProxy proxy = getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
-        if (proxy != null && proxy.waitRemoval()) {
-            proxy = getAcceptor().getCacheClientNotifier().getClientProxy(
-                this.proxyId);
-        }
-        if (proxy != null) {
+      synchronized (getCleanupTable()) {
+        Counter numRefs = (Counter) getCleanupTable().get(this.handshake);
+        byte epType = (byte) 0;
+        int qSize = 0;
+
+        if (this.proxyId.isDurable()) {
-            logger.debug("Proxy existed for this durable client :{} and proxy : {}", this.proxyId, proxy);
+            logger.debug("looking if the Proxy existed for this durable client or not :{}",
+                this.proxyId);
-          if(proxy.isPrimary()){
-            epType = (byte)2 ; 
-            qSize = proxy.getQueueSize();
-          }else {
-            epType = (byte)1;
-           qSize = proxy.getQueueSize();
+          CacheClientProxy proxy =
+              getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
+          if (proxy != null && proxy.waitRemoval()) {
+            proxy = getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
-        }    
-        // Bug Fix for 37986
-        if(numRefs == null){
-          // Check whether this is a durable client first. A durable client with
-          // the same id is not allowed. In this case, reject the client.
-          if (proxy != null && !proxy.isPaused()) {
-            // The handshake refusal message must be smaller than 127 bytes.
-            String handshakeRefusalMessage = LocalizedStrings.ServerConnection_DUPLICATE_DURABLE_CLIENTID_0
-              .toLocalizedString(proxyId.getDurableId());
-            logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON,
-                new Object[] {this.name, handshakeRefusalMessage}));
-            refuseHandshake(handshakeRefusalMessage, HandShake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT);
-            return result;
-          }      
+          if (proxy != null) {
+            if (isDebugEnabled) {
+              logger.debug("Proxy existed for this durable client :{} and proxy : {}", this.proxyId,
+                  proxy);
+            }
+            if (proxy.isPrimary()) {
+              epType = (byte) 2;
+              qSize = proxy.getQueueSize();
+            } else {
+              epType = (byte) 1;
+              qSize = proxy.getQueueSize();
+            }
+          }
+          // Bug Fix for 37986
+          if (numRefs == null) {
+            // Check whether this is a durable client first. A durable client with
+            // the same id is not allowed. In this case, reject the client.
+            if (proxy != null && !proxy.isPaused()) {
+              // The handshake refusal message must be smaller than 127 bytes.
+              String handshakeRefusalMessage =
+                  LocalizedStrings.ServerConnection_DUPLICATE_DURABLE_CLIENTID_0
+                      .toLocalizedString(proxyId.getDurableId());
+              logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON,
+                  new Object[] {this.name, handshakeRefusalMessage}));
+              refuseHandshake(handshakeRefusalMessage,
+                  HandShake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT);
+              return result;
+            }
+          }
-      }
-      if (numRefs != null) {
-        if (acceptHandShake(epType, qSize)) {
-          numRefs.incr();
-          this.incedCleanupTableRef = true;
-          result = true;
+        if (numRefs != null) {
+          if (acceptHandShake(epType, qSize)) {
+            numRefs.incr();
+            this.incedCleanupTableRef = true;
+            result = true;
+          }
+          return result;
+        } else {
+          if (acceptHandShake(epType, qSize)) {
+            clientJoined = true;
+            numRefs = new Counter();
+            getCleanupTable().put(this.handshake, numRefs);
+            numRefs.incr();
+            this.incedCleanupTableRef = true;
+            this.stats.incCurrentClients();
+            result = true;
+          }
+          return result;
-        return result;
-      }
-      else {
-        if (acceptHandShake(epType, qSize)) {
-          clientJoined = true;
-          numRefs = new Counter();
-          getCleanupTable().put(this.handshake, numRefs);
-          numRefs.incr();
-          this.incedCleanupTableRef = true;
-          this.stats.incCurrentClients();
-          result = true;
-        }
-        return result;
-      }
-    } // sync
+      } // sync
-      synchronized(getCleanupProxyIdTable()) {
+      synchronized (getCleanupProxyIdTable()) {
-          InternalDistributedMember idm = (InternalDistributedMember)this.proxyId.getDistributedMember();
+          InternalDistributedMember idm =
+              (InternalDistributedMember) this.proxyId.getDistributedMember();
-        logger.debug("{}registering client {}", (registerClient? "" : "not "), proxyId);
+        logger.debug("{}registering client {}", (registerClient ? "" : "not "), proxyId);
-        InternalClientMembership.notifyJoined(this.proxyId.getDistributedMember(),
-            true);
-        }
+        InternalClientMembership.notifyJoined(this.proxyId.getDistributedMember(), true);
+      }
-        //hitesh: it will add client 
+        // hitesh: it will add client
-      //hitesh:it will add client connection in set
+      // hitesh:it will add client connection in set
-      //Hitesh: add user creds in map for single user case. 
+      // Hitesh: add user creds in map for single user case.
-  
+
-    return this.acceptor.isRunning() 
-      && !((GemFireCacheImpl)this.acceptor.getCachedRegionHelper().getCache()).isClosed()
-      && !acceptor.getCachedRegionHelper().getCache().getCancelCriterion().isCancelInProgress();
+    return this.acceptor.isRunning()
+        && !((GemFireCacheImpl) this.acceptor.getCachedRegionHelper().getCache()).isClosed()
+        && !acceptor.getCachedRegionHelper().getCache().getCancelCriterion().isCancelInProgress();
-  protected void refuseHandshake(String msg, byte exception)
-  {
+  protected void refuseHandshake(String msg, byte exception) {
-    }
-    catch (IOException ignore) {
-    }
-    finally {
+    } catch (IOException ignore) {
+    } finally {
-  private boolean acceptHandShake(byte epType, int qSize)
-  {
+  private boolean acceptHandShake(byte epType, int qSize) {
-      this.handshake.accept(theSocket.getOutputStream(), theSocket.getInputStream()
-          , epType, qSize, this.communicationMode,
-          this.principal);
-    }
-    catch (IOException ioe) {
+      this.handshake.accept(theSocket.getOutputStream(), theSocket.getInputStream(), epType, qSize,
+          this.communicationMode, this.principal);
+    } catch (IOException ioe) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.
-          ServerConnection_0_HANDSHAKE_ACCEPT_FAILED_ON_SOCKET_1_2,
-          new Object[] {this.name, this.theSocket, ioe}));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.ServerConnection_0_HANDSHAKE_ACCEPT_FAILED_ON_SOCKET_1_2,
+            new Object[] {this.name, this.theSocket, ioe}));
-  
-  public void setCq(String cqName, boolean isDurable) throws Exception
-  {
+
+  public void setCq(String cqName, boolean isDurable) throws Exception {
-        secureBytes = ((HandShake)this.handshake).decryptBytes(secureBytes);
+        secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
-        CacheClientProxy proxy = getAcceptor().getCacheClientNotifier()
-            .getClientProxy(this.proxyId);
+        CacheClientProxy proxy =
+            getAcceptor().getCacheClientNotifier().getClientProxy(this.proxyId);
-  
+
-    void incr() { ++cnt; }
-    int decr() { return --cnt; }
-    int getCnt() { return cnt; }
+
+    void incr() {
+      ++cnt;
+    }
+
+    int decr() {
+      return --cnt;
+    }
+
+    int getCnt() {
+      return cnt;
+    }
-//  public void setUserAuthAttributes(ClientProxyMembershipID proxyId, AuthorizeRequest authzRequest, AuthorizeRequestPP postAuthzRequest) {
-//    UserAuthAttributes uaa = new UserAuthAttributes(authzRequest, postAuthzRequest);
-//  }
+  // public void setUserAuthAttributes(ClientProxyMembershipID proxyId, AuthorizeRequest
+  // authzRequest, AuthorizeRequestPP postAuthzRequest) {
+  // UserAuthAttributes uaa = new UserAuthAttributes(authzRequest, postAuthzRequest);
+  // }
-    //hitesh:to create new connection handshake
+    // hitesh:to create new connection handshake
-      //its initialized in verifyClientConnection call
-      if(getCommunicationMode() != Acceptor.GATEWAY_TO_GATEWAY)
-      	initializeClientUserAuths();
+      // its initialized in verifyClientConnection call
+      if (getCommunicationMode() != Acceptor.GATEWAY_TO_GATEWAY)
+        initializeClientUserAuths();
-      Assert.assertTrue((this.handshake.getVersion().ordinal() == testVersionAfterHandshake), "Found different version after handshake");
+      Assert.assertTrue((this.handshake.getVersion().ordinal() == testVersionAfterHandshake),
+          "Found different version after handshake");
-    }  
-  }  
+    }
+  }
-        //this.logger.fine("donormalMsg() msgType " + msg.getMessageType());
+        // this.logger.fine("donormalMsg() msgType " + msg.getMessageType());
-            logger.debug("{} ignoring message of type {} from client {} due to shutdown.", getName(), MessageType.getString(msg.getMessageType()), this.proxyId);
+            logger.debug("{} ignoring message of type {} from client {} due to shutdown.",
+                getName(), MessageType.getString(msg.getMessageType()), this.proxyId);
-            }
-            else {
+            } else {
-          logger.trace("{} received {} with txid {}", getName(), MessageType.getString(msg.getMessageType()), msg.getTransactionId());
+          logger.trace("{} received {} with txid {}", getName(),
+              MessageType.getString(msg.getMessageType()), msg.getTransactionId());
-        // if a subject exists for this uniqueId, binds the subject to this thread so that we can do authorization later
-        if(AcceptorImpl.isIntegratedSecurity() && !isInternalMessage() && this.communicationMode != Acceptor.GATEWAY_TO_GATEWAY) {
+        // if a subject exists for this uniqueId, binds the subject to this thread so that we can do
+        // authorization later
+        if (AcceptorImpl.isIntegratedSecurity() && !isInternalMessage()
+            && this.communicationMode != Acceptor.GATEWAY_TO_GATEWAY) {
-          if(subject!=null) {
+          if (subject != null) {
-    }
-    finally {
+    } finally {
-      if(threadState!=null){
+      if (threadState != null) {
-  
-  private void cleanClientAuths()
-  {
-    if (this.clientUserAuths != null )
-    {
-      this.clientUserAuths.cleanup(false);      
+
+  private void cleanClientAuths() {
+    if (this.clientUserAuths != null) {
+      this.clientUserAuths.cleanup(false);
+
-      boolean clientDeparted = false;
-      boolean unregisterClient=false;
-      setNotProcessingMessage();
-      synchronized(getCleanupTable()) {
-        if (this.incedCleanupTableRef) {
-          this.incedCleanupTableRef = false;
+    boolean clientDeparted = false;
+    boolean unregisterClient = false;
+    setNotProcessingMessage();
+    synchronized (getCleanupTable()) {
+      if (this.incedCleanupTableRef) {
+        this.incedCleanupTableRef = false;
-          Counter numRefs = (Counter) getCleanupTable().get(this.handshake);
-          if (numRefs != null) {
-            numRefs.decr();
-            if (numRefs.getCnt() <= 0) {
-              clientDeparted = true;
-              getCleanupTable().remove(this.handshake);
-              this.stats.decCurrentClients();
-            }
-          }
-          if (this.communicationMode == Acceptor.CLIENT_TO_SERVER_FOR_QUEUE) {
-            this.stats.decCurrentQueueConnections();
-          } else {
-            this.stats.decCurrentClientConnections();
+        Counter numRefs = (Counter) getCleanupTable().get(this.handshake);
+        if (numRefs != null) {
+          numRefs.decr();
+          if (numRefs.getCnt() <= 0) {
+            clientDeparted = true;
+            getCleanupTable().remove(this.handshake);
+            this.stats.decCurrentClients();
+        if (this.communicationMode == Acceptor.CLIENT_TO_SERVER_FOR_QUEUE) {
+          this.stats.decCurrentQueueConnections();
+        } else {
+          this.stats.decCurrentClientConnections();
+        }
+    }
-      synchronized(getCleanupProxyIdTable()) {
-        if (this.incedCleanupProxyIdTableRef) {
-          this.incedCleanupProxyIdTableRef = false;
-          Counter numRefs = (Counter) getCleanupProxyIdTable().get(this.proxyId);
-          if (numRefs != null) {
-            numRefs.decr();
-            if (numRefs.getCnt() <= 0) {
-              unregisterClient = true;
-              getCleanupProxyIdTable().remove(this.proxyId);
-              //here we can remove entry multiuser map for client
-              proxyIdVsClientUserAuths.remove(this.proxyId);
-              InternalDistributedMember idm = (InternalDistributedMember)this.proxyId.getDistributedMember();
-            }
+    synchronized (getCleanupProxyIdTable()) {
+      if (this.incedCleanupProxyIdTableRef) {
+        this.incedCleanupProxyIdTableRef = false;
+        Counter numRefs = (Counter) getCleanupProxyIdTable().get(this.proxyId);
+        if (numRefs != null) {
+          numRefs.decr();
+          if (numRefs.getCnt() <= 0) {
+            unregisterClient = true;
+            getCleanupProxyIdTable().remove(this.proxyId);
+            // here we can remove entry multiuser map for client
+            proxyIdVsClientUserAuths.remove(this.proxyId);
+            InternalDistributedMember idm =
+                (InternalDistributedMember) this.proxyId.getDistributedMember();
-      cleanup(timedOut);
-      if (getAcceptor().isRunning()) {
-        // If the client has departed notify bridge membership and unregister it from
-        // the heartbeat monitor; other wise just remove the connection.
-        if (clientDeparted && isFiringMembershipEvents()) {
-          if (this.clientDisconnectedCleanly && !forceClientCrashEvent) {
-            InternalClientMembership.notifyLeft(proxyId.getDistributedMember(), true);
-          } else {
-            InternalClientMembership.notifyCrashed(this.proxyId.getDistributedMember(), true);
-          }
-          // The client has departed. Remove this last connection and unregister it.
+    }
+    cleanup(timedOut);
+    if (getAcceptor().isRunning()) {
+      // If the client has departed notify bridge membership and unregister it from
+      // the heartbeat monitor; other wise just remove the connection.
+      if (clientDeparted && isFiringMembershipEvents()) {
+        if (this.clientDisconnectedCleanly && !forceClientCrashEvent) {
+          InternalClientMembership.notifyLeft(proxyId.getDistributedMember(), true);
+        } else {
+          InternalClientMembership.notifyCrashed(this.proxyId.getDistributedMember(), true);
+        }
+        // The client has departed. Remove this last connection and unregister it.
+      }
+    }
+
+    { // moved out of above if to fix bug 36751
+
+      boolean needsUnregister = false;
+      synchronized (this.chmLock) {
+        if (this.chmRegistered) {
+          needsUnregister = true;
+          this.chmRegistered = false;
-      
-      { // moved out of above if to fix bug 36751
-        
-        boolean needsUnregister = false;
-        synchronized (this.chmLock) {        
-          if (this.chmRegistered) {
-            needsUnregister = true;
-            this.chmRegistered = false;
-          }
-        }
-        if(unregisterClient)//last serverconnection call all close on auth objects
-          cleanClientAuths();  
-        this.clientUserAuths = null;
-        if (needsUnregister) {
-          this.acceptor.getClientHealthMonitor().removeConnection(this.proxyId, this);
-          if (unregisterClient) {
-            this.acceptor.getClientHealthMonitor().unregisterClient(this.proxyId, getAcceptor(),
-                this.clientDisconnectedCleanly);
-          }
+      if (unregisterClient)// last serverconnection call all close on auth objects
+        cleanClientAuths();
+      this.clientUserAuths = null;
+      if (needsUnregister) {
+        this.acceptor.getClientHealthMonitor().removeConnection(this.proxyId, this);
+        if (unregisterClient) {
+          this.acceptor.getClientHealthMonitor().unregisterClient(this.proxyId, getAcceptor(),
+              this.clientDisconnectedCleanly);
+    }
-      this.acceptor.getConnectionListener().connectionClosed(clientDeparted,
-          communicationMode);
+      this.acceptor.getConnectionListener().connectionClosed(clientDeparted, communicationMode);
-  private void initializeClientUserAuths()
-  {
+  private void initializeClientUserAuths() {
-  
-  static ClientUserAuths getClientUserAuths(ClientProxyMembershipID proxyId)
-  {
+
+  static ClientUserAuths getClientUserAuths(ClientProxyMembershipID proxyId) {
-    ClientUserAuths retCua  = proxyIdVsClientUserAuths.putIfAbsent(proxyId, cua);
-    
-    if(retCua == null)
+    ClientUserAuths retCua = proxyIdVsClientUserAuths.putIfAbsent(proxyId, cua);
+
+    if (retCua == null)
-  
+
-    
+
-  public boolean removeUserAuth(Message msg, boolean keepalive)
-  {
-    try
-    {
-      byte [] secureBytes = msg.getSecureBytes();
-      
-      secureBytes =  ((HandShake)this.handshake).decryptBytes(secureBytes);
-      
-      //need to decrypt it first then get connectionid
+  public boolean removeUserAuth(Message msg, boolean keepalive) {
+    try {
+      byte[] secureBytes = msg.getSecureBytes();
+
+      secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+
+      // need to decrypt it first then get connectionid
-      
+
-      
+
-        throw new  AuthenticationFailedException("Authentication failed");
+        throw new AuthenticationFailedException("Authentication failed");
-      
+
-        if(!removed)
+        if (!removed)
-  public byte[] setCredentials(Message msg)
-    throws Exception{
-    
-    try
-    {
-      //need to get connection id from secure part of message, before that need to insure encryption of id
-      //need to check here, whether it matches with serverConnection id or not
-      //need to decrpt bytes if its in DH mode
-      //need to get properties of credentials(need to remove extra stuff if something is there from client)
-      //need to generate unique-id for client
-      //need to send back in response with encrption 
+
+  public byte[] setCredentials(Message msg) throws Exception {
+
+    try {
+      // need to get connection id from secure part of message, before that need to insure
+      // encryption of id
+      // need to check here, whether it matches with serverConnection id or not
+      // need to decrpt bytes if its in DH mode
+      // need to get properties of credentials(need to remove extra stuff if something is there from
+      // client)
+      // need to generate unique-id for client
+      // need to send back in response with encrption
-         * This means that client and server VMs have different security settings.
-         * The server does not have any security settings specified while client
-         * has.
+         * This means that client and server VMs have different security settings. The server does
+         * not have any security settings specified while client has.
-         * Here, should we just ignore this and send the dummy security part
-         * (connectionId, userId) in the response (in this case, client needs to
-         * know that it is not expected to read any security part in any of the
-         * server response messages) or just throw an exception indicating bad
-         * configuration?
+         * Here, should we just ignore this and send the dummy security part (connectionId, userId)
+         * in the response (in this case, client needs to know that it is not expected to read any
+         * security part in any of the server response messages) or just throw an exception
+         * indicating bad configuration?
-        throw new  AuthenticationFailedException("Authentication failed");
+        throw new AuthenticationFailedException("Authentication failed");
-      
-      byte [] secureBytes = msg.getSecureBytes();
-      
-      secureBytes =  ((HandShake)this.handshake).decryptBytes(secureBytes);
-      
-      //need to decrypt it first then get connectionid
+
+      byte[] secureBytes = msg.getSecureBytes();
+
+      secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+
+      // need to decrypt it first then get connectionid
-      
+
-      
+
-        throw new  AuthenticationFailedException("Authentication failed");
+        throw new AuthenticationFailedException("Authentication failed");
-      
-      
+
+
-      
-      credBytes = ((HandShake)this.handshake).decryptBytes(credBytes);
-      
+
+      credBytes = ((HandShake) this.handshake).decryptBytes(credBytes);
+
-      // When here, security is enfored on server, if login returns a subject, then it's the newly integrated security, otherwise, do it the old way.
+      // When here, security is enfored on server, if login returns a subject, then it's the newly
+      // integrated security, otherwise, do it the old way.
-      String methodName = system.getProperties().getProperty(
-        SECURITY_CLIENT_AUTHENTICATOR);
+      String methodName = system.getProperties().getProperty(SECURITY_CLIENT_AUTHENTICATOR);
-        system.getSecurityProperties(), (InternalLogWriter) system.getLogWriter(), (InternalLogWriter) system
-          .getSecurityLogWriter(), this.proxyId.getDistributedMember());
-      if(principal instanceof Subject){
-        Subject subject = (Subject)principal;
+          system.getSecurityProperties(), (InternalLogWriter) system.getLogWriter(),
+          (InternalLogWriter) system.getSecurityLogWriter(), this.proxyId.getDistributedMember());
+      if (principal instanceof Subject) {
+        Subject subject = (Subject) principal;
-      }
-      else {
-        //this sets principal in map as well....
-        uniqueId = ServerHandShakeProcessor.getUniqueId(this, (Principal)principal);
+      } else {
+        // this sets principal in map as well....
+        uniqueId = ServerHandShakeProcessor.getUniqueId(this, (Principal) principal);
-      //create secure part which will be send in respones
+      // create secure part which will be send in respones
-  
+
-      logger.warn(LocalizedMessage.create(LocalizedStrings.ServerConnection_SERVER_FAILED_TO_ENCRYPT_DATA_0, ex));
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.ServerConnection_SERVER_FAILED_TO_ENCRYPT_DATA_0, ex));
-   * MessageType of the messages (typically internal commands) which do not need
-   * to participate in security should be added in the following if block. 
+   * MessageType of the messages (typically internal commands) which do not need to participate in
+   * security should be added in the following if block.
-//    this.logger.fine("getSecurityPart() msgType = "
-//        + this.requestMsg.msgType);
+    // this.logger.fine("getSecurityPart() msgType = "
+    // + this.requestMsg.msgType);
-        && (!this.requestMsg.getAndResetIsMetaRegion())
-        && (!isInternalMessage())) {
+        && (!this.requestMsg.getAndResetIsMetaRegion()) && (!isInternalMessage())) {
-    }
-    else {
+    } else {
-        logger.debug("ServerConnection.updateAndGetSecurityPart() not adding security part for msg type {}",
+        logger.debug(
+            "ServerConnection.updateAndGetSecurityPart() not adding security part for msg type {}",
- }
-
-  private boolean isInternalMessage(){
-    return (this.requestMsg.msgType == MessageType.CLIENT_READY
-            || this.requestMsg.msgType == MessageType.CLOSE_CONNECTION
-            || this.requestMsg.msgType == MessageType.GETCQSTATS_MSG_TYPE
-            || this.requestMsg.msgType == MessageType.GET_CLIENT_PARTITION_ATTRIBUTES
-            || this.requestMsg.msgType == MessageType.GET_CLIENT_PR_METADATA
-            || this.requestMsg.msgType == MessageType.INVALID
-            || this.requestMsg.msgType == MessageType.MAKE_PRIMARY
-            || this.requestMsg.msgType == MessageType.MONITORCQ_MSG_TYPE
-            || this.requestMsg.msgType == MessageType.PERIODIC_ACK
-            || this.requestMsg.msgType == MessageType.PING
-            || this.requestMsg.msgType == MessageType.REGISTER_DATASERIALIZERS
-            || this.requestMsg.msgType == MessageType.REGISTER_INSTANTIATORS
-            || this.requestMsg.msgType == MessageType.REQUEST_EVENT_VALUE
-            || this.requestMsg.msgType == MessageType.ADD_PDX_TYPE
-            || this.requestMsg.msgType == MessageType.GET_PDX_ID_FOR_TYPE
-            || this.requestMsg.msgType == MessageType.GET_PDX_TYPE_BY_ID
-            || this.requestMsg.msgType == MessageType.SIZE
-            || this.requestMsg.msgType == MessageType.TX_FAILOVER
-            || this.requestMsg.msgType == MessageType.TX_SYNCHRONIZATION
-            || this.requestMsg.msgType == MessageType.GET_FUNCTION_ATTRIBUTES
-            || this.requestMsg.msgType == MessageType.ADD_PDX_ENUM
-            || this.requestMsg.msgType == MessageType.GET_PDX_ID_FOR_ENUM
-            || this.requestMsg.msgType == MessageType.GET_PDX_ENUM_BY_ID
-            || this.requestMsg.msgType == MessageType.GET_PDX_TYPES
-            || this.requestMsg.msgType == MessageType.GET_PDX_ENUMS
-            || this.requestMsg.msgType == MessageType.COMMIT
-            || this.requestMsg.msgType == MessageType.ROLLBACK);
-  
+
+  private boolean isInternalMessage() {
+    return (this.requestMsg.msgType == MessageType.CLIENT_READY
+        || this.requestMsg.msgType == MessageType.CLOSE_CONNECTION
+        || this.requestMsg.msgType == MessageType.GETCQSTATS_MSG_TYPE
+        || this.requestMsg.msgType == MessageType.GET_CLIENT_PARTITION_ATTRIBUTES
+        || this.requestMsg.msgType == MessageType.GET_CLIENT_PR_METADATA
+        || this.requestMsg.msgType == MessageType.INVALID
+        || this.requestMsg.msgType == MessageType.MAKE_PRIMARY
+        || this.requestMsg.msgType == MessageType.MONITORCQ_MSG_TYPE
+        || this.requestMsg.msgType == MessageType.PERIODIC_ACK
+        || this.requestMsg.msgType == MessageType.PING
+        || this.requestMsg.msgType == MessageType.REGISTER_DATASERIALIZERS
+        || this.requestMsg.msgType == MessageType.REGISTER_INSTANTIATORS
+        || this.requestMsg.msgType == MessageType.REQUEST_EVENT_VALUE
+        || this.requestMsg.msgType == MessageType.ADD_PDX_TYPE
+        || this.requestMsg.msgType == MessageType.GET_PDX_ID_FOR_TYPE
+        || this.requestMsg.msgType == MessageType.GET_PDX_TYPE_BY_ID
+        || this.requestMsg.msgType == MessageType.SIZE
+        || this.requestMsg.msgType == MessageType.TX_FAILOVER
+        || this.requestMsg.msgType == MessageType.TX_SYNCHRONIZATION
+        || this.requestMsg.msgType == MessageType.GET_FUNCTION_ATTRIBUTES
+        || this.requestMsg.msgType == MessageType.ADD_PDX_ENUM
+        || this.requestMsg.msgType == MessageType.GET_PDX_ID_FOR_ENUM
+        || this.requestMsg.msgType == MessageType.GET_PDX_ENUM_BY_ID
+        || this.requestMsg.msgType == MessageType.GET_PDX_TYPES
+        || this.requestMsg.msgType == MessageType.GET_PDX_ENUMS
+        || this.requestMsg.msgType == MessageType.COMMIT
+        || this.requestMsg.msgType == MessageType.ROLLBACK);
+  }
+
-      }
-      catch (java.nio.channels.ClosedChannelException ignore) {
+      } catch (java.nio.channels.ClosedChannelException ignore) {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (IOException ex) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ServerConnection_0__UNEXPECTED_EXCEPTION, ex));
-      }
-      finally {
+      } catch (IOException ex) {
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.ServerConnection_0__UNEXPECTED_EXCEPTION, ex));
+      } finally {
-//        DistributedSystem.releaseThreadsSockets();
+        // DistributedSystem.releaseThreadsSockets();
-        //unset request specific timeout
+        // unset request specific timeout
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-    }
-    else {
+    } else {
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-          }
-          finally {
+          } finally {
-      }
-      finally {
+      } finally {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-  //private SelectionKey sKey = null;
+  // private SelectionKey sKey = null;
-   * Register this connection with the given selector for read events.
-   * Note that switch the channel to non-blocking so it can be in a selector.
+   * Register this connection with the given selector for read events. Note that switch the channel
+   * to non-blocking so it can be in a selector.
-    //logger.info("DEBUG: registerWithSelector " + this);
+    // logger.info("DEBUG: registerWithSelector " + this);
+
+
-    /*this.sKey = */getSelectableChannel().register(s, SelectionKey.OP_READ, this);
+    /* this.sKey = */getSelectableChannel().register(s, SelectionKey.OP_READ, this);
+
-    //logger.info("DEBUG: makeBlocking " + this);
+    // logger.info("DEBUG: makeBlocking " + this);
-//     if (this.sKey != null) {
-//       this.sKey = null;
-//     }
+    // if (this.sKey != null) {
+    // this.sKey = null;
+    // }
+
-  public int getSocketPort()
-  {
+
+  public int getSocketPort() {
-  public String getSocketHost()
-  {
+  public String getSocketHost() {
-//  private DistributedMember getClientDistributedMember() {
-//    return this.proxyId.getDistributedMember();
-//  }
+  // private DistributedMember getClientDistributedMember() {
+  // return this.proxyId.getDistributedMember();
+  // }
-  public void setRequestSpecificTimeout( int requestSpecificTimeout) {
+  public void setRequestSpecificTimeout(int requestSpecificTimeout) {
-  
+
-  
+
-    if (this.requestSpecificTimeout == -1 )  
+    if (this.requestSpecificTimeout == -1)
+
-      /* This is a buffer that we add to client readTimeout value before we cleanup the connection. 
-      * This buffer time helps prevent EOF in the client instead of SocketTimeout */
+      /*
+       * This is a buffer that we add to client readTimeout value before we cleanup the connection.
+       * This buffer time helps prevent EOF in the client instead of SocketTimeout
+       */
-  public String getSocketString()
-  {
+  public String getSocketString() {
-      StringBuffer buffer = new StringBuffer(50)
-        .append(theSocket.getInetAddress())
-        .append(':')
-        .append(theSocket.getPort())
-        .append(" timeout: " )
-        .append(theSocket.getSoTimeout());
+      StringBuffer buffer = new StringBuffer(50).append(theSocket.getInetAddress()).append(':')
+          .append(theSocket.getPort()).append(" timeout: ").append(theSocket.getSoTimeout());
-      return LocalizedStrings.ServerConnection_ERROR_IN_GETSOCKETSTRING_0.toLocalizedString(e.getLocalizedMessage());
+      return LocalizedStrings.ServerConnection_ERROR_IN_GETSOCKETSTRING_0
+          .toLocalizedString(e.getLocalizedMessage());
- 
+
-  if(justProcessed-this.latestBatchIdReplied!=1) {
-    this.stats.incOutOfOrderBatchIds();
-    logger.warn(LocalizedMessage.create(LocalizedStrings.ServerConnection_BATCH_IDS_ARE_OUT_OF_ORDER_SETTING_LATESTBATCHID_TO_0_IT_WAS_1,
-      new Object[] {Integer.valueOf(justProcessed), Integer.valueOf(this.latestBatchIdReplied)}));
-  }
+    if (justProcessed - this.latestBatchIdReplied != 1) {
+      this.stats.incOutOfOrderBatchIds();
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.ServerConnection_BATCH_IDS_ARE_OUT_OF_ORDER_SETTING_LATESTBATCHID_TO_0_IT_WAS_1,
+          new Object[] {Integer.valueOf(justProcessed),
+              Integer.valueOf(this.latestBatchIdReplied)}));
+    }
+
-  
+
-        theSocket = s;
-        theSocket.setSendBufferSize(socketBufferSize);
-        theSocket.setReceiveBufferSize(socketBufferSize);
-        if (getAcceptor().isSelector()) {
-          // set it on the message to null. This causes Message
-          // to fetch it from a thread local. That way we only need
-          // one per thread in our selector thread pool instead of
-          // one per connection.
-          commBuffer = null;
-        } else {
-          commBuffer = allocateCommBuffer(socketBufferSize, s);
-        }
-        requestMsg.setComms(this, theSocket, commBuffer, msgStats);
-        replyMsg.setComms(this, theSocket, commBuffer, msgStats);
-        responseMsg.setComms(this, theSocket, commBuffer, msgStats);
-        errorMsg.setComms(this, theSocket, commBuffer, msgStats);
+      theSocket = s;
+      theSocket.setSendBufferSize(socketBufferSize);
+      theSocket.setReceiveBufferSize(socketBufferSize);
+      if (getAcceptor().isSelector()) {
+        // set it on the message to null. This causes Message
+        // to fetch it from a thread local. That way we only need
+        // one per thread in our selector thread pool instead of
+        // one per connection.
+        commBuffer = null;
+      } else {
+        commBuffer = allocateCommBuffer(socketBufferSize, s);
+      }
+      requestMsg.setComms(this, theSocket, commBuffer, msgStats);
+      replyMsg.setComms(this, theSocket, commBuffer, msgStats);
+      responseMsg.setComms(this, theSocket, commBuffer, msgStats);
+      errorMsg.setComms(this, theSocket, commBuffer, msgStats);
-        chunkedResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-        queryResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-        executeFunctionResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-        registerInterestResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-        keySetResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-      }
-      catch(RuntimeException re) {
-        throw re;
-      }
-      catch(Exception e) {
-        logger.fatal(e.getMessage(), e);
-      }
+      chunkedResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+      queryResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+      executeFunctionResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+      registerInterestResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+      keySetResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+    } catch (RuntimeException re) {
+      throw re;
+    } catch (Exception e) {
+      logger.fatal(e.getMessage(), e);
+  }
+
-    return this.theSocket == null 
-        || !this.theSocket.isConnected()
-        || this.theSocket.isClosed();
+    return this.theSocket == null || !this.theSocket.isConnected() || this.theSocket.isClosed();
+
-        /*|| this.communicationMode == Acceptor.CLIENT_TO_SERVER_FOR_QUEUE*/) {
+    /* || this.communicationMode == Acceptor.CLIENT_TO_SERVER_FOR_QUEUE */) {
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-          LocalizedStrings.ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_AUTHORIZATION_CALLBACK_1,
-          new Object[] {this.name, ex});
+            LocalizedStrings.ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_AUTHORIZATION_CALLBACK_1,
+            new Object[] {this.name, ex});
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-          LocalizedStrings.ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_POSTPROCESS_AUTHORIZATION_CALLBACK_1,
-          new Object[] {this.name, ex});
+            LocalizedStrings.ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_POSTPROCESS_AUTHORIZATION_CALLBACK_1,
+            new Object[] {this.name, ex});
-  
+
-  
+
-  
+
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-  
+
-  
-  /**    
+
+  /**
-  /**    
+  /**
-  
-  /**    
+
+  /**
-  /**    
+  /**
-  
-  /**    
+
+  /**
-  /**    
+  /**
-  
-  /**    
+
+  /**
-  
-  /**    
+
+  /**
-  
-  /**    
+
+  /**
-  
+
-  
+
-  
+
- 
-  /* The four boolean fields and the String & Object field below are the transient data 
-   * We have made it fields just because we know that they will
-   * be operated by a single thread only & hence in effect behave as
-   * local variables.
+
+  /*
+   * The four boolean fields and the String & Object field below are the transient data We have made
+   * it fields just because we know that they will be operated by a single thread only & hence in
+   * effect behave as local variables.
- 
+
-  public void setModificationInfo(boolean potentialModification,
-      String modRegion, Object modKey) {
+  public void setModificationInfo(boolean potentialModification, String modRegion, Object modKey) {
-    case Command.RESPONDED:
-      this.responded = true;
-      break;
-    case Command.REQUIRES_RESPONSE:
-      this.requiresResponse = true;
-      break;
-    case Command.REQUIRES_CHUNKED_RESPONSE:
-      this.requiresChunkedResponse = true;
-      break;
-    default:
-      throw new IllegalArgumentException(LocalizedStrings.ServerConnection_THE_ID_PASSED_IS_0_WHICH_DOES_NOT_CORRESPOND_WITH_ANY_TRANSIENT_DATA
-          .toLocalizedString(Integer.valueOf(boolID)));
+      case Command.RESPONDED:
+        this.responded = true;
+        break;
+      case Command.REQUIRES_RESPONSE:
+        this.requiresResponse = true;
+        break;
+      case Command.REQUIRES_CHUNKED_RESPONSE:
+        this.requiresChunkedResponse = true;
+        break;
+      default:
+        throw new IllegalArgumentException(
+            LocalizedStrings.ServerConnection_THE_ID_PASSED_IS_0_WHICH_DOES_NOT_CORRESPOND_WITH_ANY_TRANSIENT_DATA
+                .toLocalizedString(Integer.valueOf(boolID)));
-    case Command.RESPONDED:
-      retVal = this.responded;
-      break;
-    case Command.REQUIRES_RESPONSE:
-      retVal = this.requiresResponse;
-      break;
-    case Command.REQUIRES_CHUNKED_RESPONSE:
-      retVal = this.requiresChunkedResponse;
-      break;
-    default:
-      throw new IllegalArgumentException(LocalizedStrings.ServerConnection_THE_ID_PASSED_IS_0_WHICH_DOES_NOT_CORRESPOND_WITH_ANY_TRANSIENT_DATA
-          .toLocalizedString(Integer.valueOf(boolID)));
+      case Command.RESPONDED:
+        retVal = this.responded;
+        break;
+      case Command.REQUIRES_RESPONSE:
+        retVal = this.requiresResponse;
+        break;
+      case Command.REQUIRES_CHUNKED_RESPONSE:
+        retVal = this.requiresChunkedResponse;
+        break;
+      default:
+        throw new IllegalArgumentException(
+            LocalizedStrings.ServerConnection_THE_ID_PASSED_IS_0_WHICH_DOES_NOT_CORRESPOND_WITH_ANY_TRANSIENT_DATA
+                .toLocalizedString(Integer.valueOf(boolID)));
-  public void setFlagProcessMessagesAsFalse( ) {
-    this.processMessages= false;
+  public void setFlagProcessMessagesAsFalse() {
+    this.processMessages = false;
-  
-  boolean getFlagProcessMessages( ) {
+
+  boolean getFlagProcessMessages() {
-  
+
-  //this is for old client before(<6.5), from 6.5 userAuthId comes in user request
+  // this is for old client before(<6.5), from 6.5 userAuthId comes in user request
-  
-  //this is for old client before(<6.5), from 6.5 userAuthId comes in user request
+
+  // this is for old client before(<6.5), from 6.5 userAuthId comes in user request
-  
-  private static class AuthIds
-  {
+
+  private static class AuthIds {
-    
-    public AuthIds(byte[] bytes) throws Exception
-    {
+
+    public AuthIds(byte[] bytes) throws Exception {
-      if (bytes.length == 8 ){
-        //only connectionid        
+      if (bytes.length == 8) {
+        // only connectionid
-      }
-      else if (bytes.length == 16) {
-        //first connectionId and then uniqueID
+      } else if (bytes.length == 16) {
+        // first connectionId and then uniqueID
-      }
-      else {
+      } else {
-      }        
+      }
-       
-    
+
+
-    
+
-  
+
-      return ((HandShake)this.handshake).encryptBytes(hdos.toByteArray());
+      return ((HandShake) this.handshake).encryptBytes(hdos.toByteArray());
-  public long getUniqueId(){
+  public long getUniqueId() {
-      || this.communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
+        || this.communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
-        //this.logger.fine("getAuthzRequest() isSecureMode = " + this.requestMsg.isSecureMode());
+        // this.logger.fine("getAuthzRequest() isSecureMode = " + this.requestMsg.isSecureMode());
-          //get uniqueID from message
-          byte [] secureBytes = this.requestMsg.getSecureBytes();
+          // get uniqueID from message
+          byte[] secureBytes = this.requestMsg.getSecureBytes();
-          secureBytes =  ((HandShake)this.handshake).decryptBytes(secureBytes);
+          secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
-              LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-                .toLocalizedString());
+                LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED.toLocalizedString());
-            LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-              .toLocalizedString());
+              LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED.toLocalizedString());
-      }
-      catch(Exception ex ) {
+      } catch (Exception ex) {
-          LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-            .toLocalizedString());
+            LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED.toLocalizedString());
-  public AuthorizeRequest getAuthzRequest()
-      throws AuthenticationRequiredException, IOException {
-    //look client version and return authzrequest
-    //for backward client it will be store in member variable userAuthId
-    //for other look "requestMsg" here and get unique-id from this to get the authzrequest
+  public AuthorizeRequest getAuthzRequest() throws AuthenticationRequiredException, IOException {
+    // look client version and return authzrequest
+    // for backward client it will be store in member variable userAuthId
+    // for other look "requestMsg" here and get unique-id from this to get the authzrequest
-    if(AcceptorImpl.isIntegratedSecurity())
+    if (AcceptorImpl.isIntegratedSecurity())
-      throw new AuthenticationRequiredException(
-          "User authorization attributes not found.");
+      throw new AuthenticationRequiredException("User authorization attributes not found.");
-      logger.debug("getAuthzRequest() authrequest: {}", ((authReq == null) ? "NULL (only authentication is required)" : "not null"));
+      logger.debug("getAuthzRequest() authrequest: {}",
+          ((authReq == null) ? "NULL (only authentication is required)" : "not null"));
-  public AuthorizeRequestPP getPostAuthzRequest() 
-  throws AuthenticationRequiredException, IOException {
+  public AuthorizeRequestPP getPostAuthzRequest()
+      throws AuthenticationRequiredException, IOException {
-    if(AcceptorImpl.isIntegratedSecurity())
+    if (AcceptorImpl.isIntegratedSecurity())
-    //look client version and return authzrequest
-    //for backward client it will be store in member variable userAuthId
-    //for other look "requestMsg" here and get unique-id from this to get the authzrequest
+    // look client version and return authzrequest
+    // for backward client it will be store in member variable userAuthId
+    // for other look "requestMsg" here and get unique-id from this to get the authzrequest
-      throw new AuthenticationRequiredException(
-          "User authorization attributes not found.");
+      throw new AuthenticationRequiredException("User authorization attributes not found.");
-  
+

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This operation ensures that a particular member has seen all state
- * changes for a Region prior to a point in time.  Currently this is
- * fixed at the time the member using this operation exchanged profiles
- * with other users of the Region, and is useful only for ensuring
- * consistency for InitialImageOperation.
+ * This operation ensures that a particular member has seen all state changes for a Region prior to
+ * a point in time. Currently this is fixed at the time the member using this operation exchanged
+ * profiles with other users of the Region, and is useful only for ensuring consistency for
+ * InitialImageOperation.
- * StateFlushOperation works with distribution advisors and with the
- * membership manager to flush cache operations from threads to communications
- * channels and then from the communications channels to the cache of the
- * member selected to be an initial image provider.
+ * StateFlushOperation works with distribution advisors and with the membership manager to flush
+ * cache operations from threads to communications channels and then from the communications
+ * channels to the cache of the member selected to be an initial image provider.
- * To make an operation subject to StateFlushOperation you must encapsulate
- * the message part of the operation (prior to asking for distribution advice)
- * in a try/finally block.  The try/finally block must work with the
- * distribution manager like this:
+ * To make an operation subject to StateFlushOperation you must encapsulate the message part of the
+ * operation (prior to asking for distribution advice) in a try/finally block. The try/finally block
+ * must work with the distribution manager like this:
- * </pre> 
+ * </pre>
- * On the receiving side the messaging system will look at the result of
- * invoking containsCacheContentChange() on the message.  If the message
- * does not return true from this message then state-flush will not wait
- * for it to be applied to the cache before GII starts.
+ * On the receiving side the messaging system will look at the result of invoking
+ * containsCacheContentChange() on the message. If the message does not return true from this
+ * message then state-flush will not wait for it to be applied to the cache before GII starts.
- * The messaging infrastructure will handle the rest for you.  For examples
- * look at the uses of startOperation() and endOperation().  There are some
- * complex examples in transaction processing and a more straightforward
- * example in DistributedCacheOperation.
+ * The messaging infrastructure will handle the rest for you. For examples look at the uses of
+ * startOperation() and endOperation(). There are some complex examples in transaction processing
+ * and a more straightforward example in DistributedCacheOperation.
-public class StateFlushOperation  {
+public class StateFlushOperation {
-  
+
-  
+
-  
-  
+
+
-      r.getDistributionAdvisor().forceNewMembershipVersion(); //force a new "view" so we can track current ops
+      r.getDistributionAdvisor().forceNewMembershipVersion(); // force a new "view" so we can track
+                                                              // current ops
-    for (InternalDistributedMember target: targets) {
+    for (InternalDistributedMember target : targets) {
-      if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP) && ((gr.channelState != null) && (gr.channelState.size() > 0)) ) {
-        logger.trace(LogMarker.STATE_FLUSH_OP, "channel states: {}", gr.channelStateDescription(gr.channelState));
+      if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP)
+          && ((gr.channelState != null) && (gr.channelState.size() > 0))) {
+        logger.trace(LogMarker.STATE_FLUSH_OP, "channel states: {}",
+            gr.channelStateDescription(gr.channelState));
-    if(r.getRegionMap().getARMLockTestHook()!=null) {
+    if (r.getRegionMap().getARMLockTestHook() != null) {
-    for (ReplyProcessor21 processor: processors) {
+    for (ReplyProcessor21 processor : processors) {
-  /** Constructor for StateFlushOperation
-   * @param r
-   *    The region whose state is to be flushed
+  /**
+   * Constructor for StateFlushOperation
+   * 
+   * @param r The region whose state is to be flushed
-  
+
+   * 
-  
-  
- /**
-  * flush state to the given target
-  * @param recipients
-  *    The members who may be making state changes to the region.  This is
-  *    typically taken from a CacheDistributionAdvisor membership set
- * @param target
-  *    The member who should have all state flushed to it
- * @param processorType
-  *    The execution processor type for the marker message that is sent to
-  *    all members using the given region
- * @param flushNewOps
- *      normally only ops that were started before region profile exchange
- *      are flushed.  Setting this to true causes the flush to wait for
- *      any started after the profile exchange as well.
-  * @throws InterruptedException
-  *     If the operation is interrupted, usually for shutdown, an
-  *     InterruptedException will be thrown
-  * @return
-  *    true if the state was flushed, false if not
-  */
-  public boolean flush(
-      Set recipients, 
-      DistributedMember target, 
-      int processorType, boolean flushNewOps)
-  throws InterruptedException  {
-    
-    Set recips = recipients;  // do not use recipients parameter past this point
+
+
+  /**
+   * flush state to the given target
+   * 
+   * @param recipients The members who may be making state changes to the region. This is typically
+   *        taken from a CacheDistributionAdvisor membership set
+   * @param target The member who should have all state flushed to it
+   * @param processorType The execution processor type for the marker message that is sent to all
+   *        members using the given region
+   * @param flushNewOps normally only ops that were started before region profile exchange are
+   *        flushed. Setting this to true causes the flush to wait for any started after the profile
+   *        exchange as well.
+   * @throws InterruptedException If the operation is interrupted, usually for shutdown, an
+   *         InterruptedException will be thrown
+   * @return true if the state was flushed, false if not
+   */
+  public boolean flush(Set recipients, DistributedMember target, int processorType,
+      boolean flushNewOps) throws InterruptedException {
+
+    Set recips = recipients; // do not use recipients parameter past this point
-    
+
-    
+
-//    if (recips.size() < 2 && !myId.equals(target)) {
-//      return true; // no state to flush to a single holder of the region
-//    }
+    // if (recips.size() < 2 && !myId.equals(target)) {
+    // return true; // no state to flush to a single holder of the region
+    // }
-    }
-    else {
+    } else {
-    StateFlushReplyProcessor gfprocessor =
-      new StateFlushReplyProcessor(dm, recips, target);
+    StateFlushReplyProcessor gfprocessor = new StateFlushReplyProcessor(dm, recips, target);
-    if (region != null &&
-        region.isUsedForPartitionedRegionBucket() &&
-        region.getDistributionConfig().getAckSevereAlertThreshold() > 0) {
+    if (region != null && region.isUsedForPartitionedRegionBucket()
+        && region.getDistributionConfig().getAckSevereAlertThreshold() > 0) {
-      logger.trace(LogMarker.STATE_FLUSH_OP, "Sending {} with processor {}", smm,  gfprocessor);
+      logger.trace(LogMarker.STATE_FLUSH_OP, "Sending {} with processor {}", smm, gfprocessor);
-              "failed to send StateMarkerMessage to target {}; returning from flush without waiting for replies", target);
+              "failed to send StateMarkerMessage to target {}; returning from flush without waiting for replies",
+              target);
-//      try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } // DEBUGGING - stall before getting membership to increase odds that target has left
+      // try { Thread.sleep(100); } catch (InterruptedException e) {
+      // Thread.currentThread().interrupt(); } // DEBUGGING - stall before getting membership to
+      // increase odds that target has left
-    }
-    catch (ReplyException re) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.StateFlushOperation_STATE_FLUSH_TERMINATED_WITH_EXCEPTION), re);
+    } catch (ReplyException re) {
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.StateFlushOperation_STATE_FLUSH_TERMINATED_WITH_EXCEPTION), re);
-   * This message is sent, e.g., before requesting an initial image from a single provider.
-   * It is sent to all members holding the region, and has the effect of causing
-   * those members to send a serial distribution message (a StateStabilizationMessage)
-   * to the image provider.  The provider then sends a reply message back to
-   * this process on behalf of the member receiving the .
+   * This message is sent, e.g., before requesting an initial image from a single provider. It is
+   * sent to all members holding the region, and has the effect of causing those members to send a
+   * serial distribution message (a StateStabilizationMessage) to the image provider. The provider
+   * then sends a reply message back to this process on behalf of the member receiving the .
+   * 
-   * This flushes the ordered messages in flight between members and the gii
-   * provider, so we don't miss data when the image is requested.
+   * 
+   * This flushes the ordered messages in flight between members and the gii provider, so we don't
+   * miss data when the image is requested.
-  public static final class StateMarkerMessage
-    extends DistributionMessage implements MessageWithReply {
+  public static final class StateMarkerMessage extends DistributionMessage
+      implements MessageWithReply {
-     * whether all regions must be flushed to the relay target.
-     * If this is true, then regionPath may be null.
+     * whether all regions must be flushed to the relay target. If this is true, then regionPath may
+     * be null.
-    
+
-    
+
-    public int getProcessorId() { return this.processorId; }
-    
+    public int getProcessorId() {
+      return this.processorId;
+    }
+
-    
+
-      // set the init level requirement so that we don't hang in CacheFactory.getInstance() (bug 36175)
+      // set the init level requirement so that we don't hang in CacheFactory.getInstance() (bug
+      // 36175)
-        GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
+        GemFireCacheImpl gfc = (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
-          region = (DistributedRegion)r;
+          region = (DistributedRegion) r;
-      }
-      finally {
+      } finally {
-    
+
-      // set the init level requirement so that we don't hang in CacheFactory.getInstance() (bug 36175)
+      // set the init level requirement so that we don't hang in CacheFactory.getInstance() (bug
+      // 36175)
-        GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
+        GemFireCacheImpl gfc = (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
-        for (LocalRegion r: gfc.getAllRegions()) {
+        for (LocalRegion r : gfc.getAllRegions()) {
-            result.add((DistributedRegion)r);
+            result.add((DistributedRegion) r);
-      }
-      finally {
+      } finally {
-    
+
-      }
-      else {
+      } else {
-        //    at which the sender "joined" this region to be put on the pipe
+        // at which the sender "joined" this region to be put on the pipe
-        //    to the relay point
+        // to the relay point
-        //    communication channel state information
+        // communication channel state information
-        gr.setRecipient((InternalDistributedMember)relayRecipient);
+        gr.setRecipient((InternalDistributedMember) relayRecipient);
-          for (DistributedRegion r: regions) {
+          for (DistributedRegion r : regions) {
-                  r.getDistributionAdvisor().forceNewMembershipVersion(); //force a new "view" so we can track current ops
+                  r.getDistributionAdvisor().forceNewMembershipVersion(); // force a new "view" so
+                                                                          // we can track current
+                                                                          // ops
-              boolean useMulticast = r.getMulticastEnabled()
-                                    && r.getSystem().getConfig().getMcastPort() != 0;
+              boolean useMulticast =
+                  r.getMulticastEnabled() && r.getSystem().getConfig().getMcastPort() != 0;
-                Map channelStates = dm.getMembershipManager().getMessageState(relayRecipient, useMulticast);
+                Map channelStates =
+                    dm.getMembershipManager().getMessageState(relayRecipient, useMulticast);
-                if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP) && ((gr.channelState != null) && (gr.channelState.size() > 0)) ) {
-                  logger.trace(LogMarker.STATE_FLUSH_OP, "channel states: {}", gr.channelStateDescription(gr.channelState));
+                if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP)
+                    && ((gr.channelState != null) && (gr.channelState.size() > 0))) {
+                  logger.trace(LogMarker.STATE_FLUSH_OP, "channel states: {}",
+                      gr.channelStateDescription(gr.channelState));
-        }
-        catch (CancelException cce) {
+        } catch (CancelException cce) {
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-              LocalizedStrings.StateFlushOperation_0__EXCEPTION_CAUGHT_WHILE_DETERMINING_CHANNEL_STATE, this), e);
-        }
-        catch (ThreadDeath td) {
+              LocalizedStrings.StateFlushOperation_0__EXCEPTION_CAUGHT_WHILE_DETERMINING_CHANNEL_STATE,
+              this), e);
+        } catch (ThreadDeath td) {
-        }
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-              LocalizedStrings.StateFlushOperation_0__THROWABLE_CAUGHT_WHILE_DETERMINING_CHANNEL_STATE, this), t);
-        }
-        finally {
+              LocalizedStrings.StateFlushOperation_0__THROWABLE_CAUGHT_WHILE_DETERMINING_CHANNEL_STATE,
+              this), t);
+        } finally {
-    
+
-    
+
-      relayRecipient = (DistributedMember)DataSerializer.readObject(din);
+      relayRecipient = (DistributedMember) DataSerializer.readObject(din);
-    
+
-      return "StateMarkerMessage(requestingMember="+this.getSender()
-      +",processorId="+processorId+",target="+relayRecipient
-      +",region="+regionPath+")";
+      return "StateMarkerMessage(requestingMember=" + this.getSender() + ",processorId="
+          + processorId + ",target=" + relayRecipient + ",region=" + regionPath + ")";
-    
-    
+
+
-  
+
-   * StateStabilizationMessage is sent by a distributed member to a member who
-   * is the target of a state flush.  The target then sends a StateStabilizedMessage
-   * to the sender of the StateStabilizationMessage when all state has been
-   * flushed to it.
-   * <p>author bruce
+   * StateStabilizationMessage is sent by a distributed member to a member who is the target of a
+   * state flush. The target then sends a StateStabilizedMessage to the sender of the
+   * StateStabilizationMessage when all state has been flushed to it.
+   * <p>
+   * author bruce
+   * 
-  public static final class StateStabilizationMessage
-    extends SerialDistributionMessage  {
+  public static final class StateStabilizationMessage extends SerialDistributionMessage {
-    /** a map of the communication channel state between the sending process
-     *  and the receiving process */
+    /**
+     * a map of the communication channel state between the sending process and the receiving
+     * process
+     */
-    
+
-    
+
-      if ( ! (state instanceof Map) ) {
+      if (!(state instanceof Map)) {
-      }
-      else {
-        Map csmap = (Map)state;
+      } else {
+        Map csmap = (Map) state;
-        for (Iterator it=csmap.entrySet().iterator(); it.hasNext(); ) {
-          Map.Entry entry = (Map.Entry)it.next();
+        for (Iterator it = csmap.entrySet().iterator(); it.hasNext();) {
+          Map.Entry entry = (Map.Entry) it.next();
-    
+
-              if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP) && ((channelState != null) && (channelState.size() > 0)) ) {
-                logger.trace(LogMarker.STATE_FLUSH_OP, "Waiting for channel states:  {}", channelStateDescription(channelState));
+              if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP)
+                  && ((channelState != null) && (channelState.size() > 0))) {
+                logger.trace(LogMarker.STATE_FLUSH_OP, "Waiting for channel states:  {}",
+                    channelStateDescription(channelState));
-                }
-                catch (InterruptedException e) {
+                } catch (InterruptedException e) {
-                }
-                finally {
+                } finally {
-          } 
-          catch (ThreadDeath td) {
+          } catch (ThreadDeath td) {
-          }
-          catch (VirtualMachineError err) {
+          } catch (VirtualMachineError err) {
-            // If this ever returns, rethrow the error.  We're poisoned
+            // If this ever returns, rethrow the error. We're poisoned
-          }
-          catch (Throwable e) {
+          } catch (Throwable e) {
-            // catch VirtualMachineError (see above).  However, there is
+            // catch VirtualMachineError (see above). However, there is
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.StateFlushOperation_EXCEPTION_CAUGHT_WHILE_WAITING_FOR_CHANNEL_STATE), e);
-          }
-          finally {
+            logger.fatal(
+                LocalizedMessage.create(
+                    LocalizedStrings.StateFlushOperation_EXCEPTION_CAUGHT_WHILE_WAITING_FOR_CHANNEL_STATE),
+                e);
+          } finally {
-            ga.setRecipient((InternalDistributedMember)requestingMember);
+            ga.setRecipient((InternalDistributedMember) requestingMember);
-            if(requestingMember.equals(dm.getDistributionManagerId())) {
-              ga.dmProcess(dm);  
+            if (requestingMember.equals(dm.getDistributionManagerId())) {
+              ga.dmProcess(dm);
-    
+
-    
+
-      requestingMember = (DistributedMember)DataSerializer.readObject(din);
+      requestingMember = (DistributedMember) DataSerializer.readObject(din);
-    
+
-      return "StateStabilizationMessage(recipients=" + getRecipientsDescription() + ",requestingMember="+requestingMember+",processorId="+processorId+")";
+      return "StateStabilizationMessage(recipients=" + getRecipientsDescription()
+          + ",requestingMember=" + requestingMember + ",processorId=" + processorId + ")";
-  
+
-   * StateStabilizedMessage is sent from a VM that will provide an initial image and is
-   * part of a higher-order protocol that is intended to force data in serial
-   * execution queues to be processed before the initial image is requested.
-   * <p>author bruce
+   * StateStabilizedMessage is sent from a VM that will provide an initial image and is part of a
+   * higher-order protocol that is intended to force data in serial execution queues to be processed
+   * before the initial image is requested.
+   * <p>
+   * author bruce
+   * 
-    
+
-      return (InternalDistributedMember)this.sendingMember;
+      return (InternalDistributedMember) this.sendingMember;
-    
+
-    
+
-      sendingMember = (DistributedMember)DataSerializer.readObject(din);
+      sendingMember = (DistributedMember) DataSerializer.readObject(din);
-  
+
-   * StateFlushReplyProcessor waits for proxy acks (StateStabilizedMessages) from the target
-   * vm.  If the target vm goes away, this processor wakes up immediately
+   * StateFlushReplyProcessor waits for proxy acks (StateStabilizedMessages) from the target vm. If
+   * the target vm goes away, this processor wakes up immediately
-  public static class StateFlushReplyProcessor extends ReplyProcessor21  {
-  
+  public static class StateFlushReplyProcessor extends ReplyProcessor21 {
+
-    
+
-    
+
-  
+
-      this.targetMember = (InternalDistributedMember)target;
+      this.targetMember = (InternalDistributedMember) target;
-      this.targetMemberHasLeft = targetMemberHasLeft // bug #43583 - perform an initial membership check
-              || !manager.isCurrentMember((InternalDistributedMember)target);
+      this.targetMemberHasLeft = targetMemberHasLeft // bug #43583 - perform an initial membership
+                                                     // check
+          || !manager.isCurrentMember((InternalDistributedMember) target);
-    
+
-      for (Iterator it=failures.iterator(); it.hasNext(); ) {
-        this.memberDeparted((InternalDistributedMember)it.next(), true);
+      for (Iterator it = failures.iterator(); it.hasNext();) {
+        this.memberDeparted((InternalDistributedMember) it.next(), true);
-    
+
-    
+
-      targetMemberHasLeft = targetMemberHasLeft || !getDistributionManager().isCurrentMember(targetMember);
+      targetMemberHasLeft =
+          targetMemberHasLeft || !getDistributionManager().isCurrentMember(targetMember);
-    
+
-      return "<" + shortName() + " " + this.getProcessorId() +
-        " targeting " + targetMember + " waiting for " + numMembers()
-        + " replies out of " + this.originalCount + " " + 
-        (exception == null ? "" : (" exception: " + exception)) +
-        " from " + membersToString() + ">";
+      return "<" + shortName() + " " + this.getProcessorId() + " targeting " + targetMember
+          + " waiting for " + numMembers() + " replies out of " + this.originalCount + " "
+          + (exception == null ? "" : (" exception: " + exception)) + " from " + membersToString()
+          + ">";

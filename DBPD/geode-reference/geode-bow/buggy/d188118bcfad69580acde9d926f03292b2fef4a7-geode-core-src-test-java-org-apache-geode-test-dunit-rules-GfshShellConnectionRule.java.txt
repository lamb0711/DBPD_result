Refactor test rules

* Refactor GfshShellConnectorRule so that it's easier to use it either as a rule or classRule
* Refactor LocatorServerStartupRule so that tests using it do not need to extend from Junit4DUnitTest and can be used as a class rule.
* properly close all the vms using the ServerStartupRule
* add NetstatDUnitTest

-import org.awaitility.Awaitility;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
+ *
+ * you can use this as Rule
+ * 
+ * @Rule GfshShellConnectionRule rule = new GfshSheelConnectionRule(); then after you connect to a
+ *       locator, you don't have to call disconnect() or close() at all, since the rule's after
+ *       takes care of it for you.
+ *
+ *       Or as a ClassRule
+ * @ClassRule GfshShellConnectionRule rule = new GfshSheelConnectionRule(); When using as a
+ *            ClassRule, if you call connect in a test, you will need to call disconnect after the
+ *            test as well. See NetstatDUnitTest for example.
+ *
-  private int port = 0;
-  private PortType portType = null;
-  private HeadlessGfsh gfsh;
-  private boolean connected;
+  private int port = -1;
+  private PortType portType = PortType.jmxManger;
+  private HeadlessGfsh gfsh = null;
+  private boolean connected = false;
-  public GfshShellConnectionRule(Locator locator) {
-    this(locator.getPort(), PortType.locator);
-  }
+  public GfshShellConnectionRule() {}
-    try {
-      this.gfsh = new HeadlessGfsh(getClass().getName(), 30, "gfsh_files");
-    } catch (Exception e) {
-      e.printStackTrace();
-    }
-    this.connected = false;
+  @Override
-    ConnectionConfiguration config = description.getAnnotation(ConnectionConfiguration.class);
-    if (config != null) {
-      connect(CliStrings.CONNECT__USERNAME, config.user(), CliStrings.CONNECT__PASSWORD,
-          config.password());
-    } else {
-      connect();
+    this.gfsh = new HeadlessGfsh(getClass().getName(), 30, "gfsh_files");
+    // do not connect if no port initialized
+    if (port < 0) {
+      return;
+
+    ConnectionConfiguration config = description.getAnnotation(ConnectionConfiguration.class);
+    if (config == null) {
+      connect(port, portType);
+      return;
+    }
+
+    connect(port, portType, CliStrings.CONNECT__USERNAME, config.user(),
+        CliStrings.CONNECT__PASSWORD, config.password());
+
-  public void connect(String... options) throws Exception {
+  public void connect(Locator locator, String... options) throws Exception {
+    connect(locator.getPort(), PortType.locator, options);
+  }
+
+  public void connectAndVerify(Locator locator, String... options) throws Exception {
+    connect(locator.getPort(), PortType.locator, options);
+    assertThat(this.connected).isTrue();
+  }
+
+  public void connect(int port, PortType type, String... options) throws Exception {
-    if (portType == PortType.locator) {
+    if (type == PortType.locator) {
-    } else if (portType == PortType.http) {
+    } else if (type == PortType.http) {
-    // Tried to wait on jmx connector server being ready, but it doesn't work.
-    AtomicReference<CommandResult> result = new AtomicReference<>();
-    Awaitility.await().atMost(2, TimeUnit.MINUTES).pollDelay(2, TimeUnit.SECONDS).until(() -> {
-      gfsh.executeCommand(connectCommand.toString());
-      result.set((CommandResult) gfsh.getResult());
-      System.out.println("connect result: " + result.get().getContent().toString());
-      return !gfsh.outputString.contains("no such object in table");
-    });
-
-    connected = (result.get().getStatus() == Result.Status.OK);
+    // can not use Awaitility here because it starts another thead, but the Gfsh instance is in a
+    // threadLocal variable, See Gfsh.getExistingInstance()
+    CommandResult result = null;
+    for (int i = 0; i < 50; i++) {
+      result = executeCommand(connectCommand.toString());
+      if (!gfsh.outputString.contains("no such object in table")) {
+        break;
+      }
+      Thread.currentThread().sleep(2000);
+    }
+    connected = (result.getStatus() == Result.Status.OK);
-
-  /**
-   * Override to tear down your specific external resource.
-   */
+  @Override
+    if (connected) {
+      disconnect();
+    }
+  public void disconnect() throws Exception {
+    gfsh.clear();
+    executeCommand("disconnect");
+    connected = false;
+  }
+
-    if (gfsh != null) {
-      gfsh.clear();
-      gfsh.executeCommand("disconnect");
-      gfsh.executeCommand("exit");
-      gfsh.terminate();
-      gfsh = null;
-    }
+    gfsh.executeCommand("exit");
+    gfsh.terminate();
+    gfsh = null;
-    System.out.println("command result: " + result.getContent());
+    System.out.println("Command Result: \n" + gfsh.outputString);
+
+  public String execute(String command) throws Exception {
+    executeCommand(command);
+    return gfsh.outputString;
+  }
+

Fixing problems with network partition detection

Recent changes in GMSJoinLeave and GMSHealthMonitor destabilized network
partition detection to the point that it was barely working.  This corrects
faults that were causing the failures - exponential barrages of suspect
processing and failure to detect loss of members during membership view
creation.

GMSJoinLeave's removeHealthyMembers and filterMembers methods had some problems
that resulted in unhealthy members not being detected.  GMSHealthMonitor
did not have barriers in place to prevent initiation of concurrent suspect
processing on the same member.  JGroupsMessenger was initiating final checks
on members if unable to send a message to them instead of merely raising
suspicion.

+  /** members who we have been declared dead in the current view */
+  
+  @Override
+  public boolean isMemberLeaving(DistributedMember mbr) {
+    if (getPendingRequestIDs(LEAVE_REQUEST_MESSAGE).contains(mbr)
+        || getPendingRequestIDs(REMOVE_MEMBER_REQUEST).contains(mbr)
+        || !currentView.contains(mbr)) {
+      return true;
+    }
+    synchronized(removedMembers) {
+      if (removedMembers.contains(mbr)) {
+        return true;
+      }
+    }
+    synchronized(leftMembers) {
+      if (leftMembers.contains(mbr)) {
+        return true;
+      }
+    }
+    return false;
+  }
-      logger.info("I am being told to leave the distributed system");
+      logger.info("I am being told to leave the distributed system by {}", incomingRequest.getSender());
+      return;
+    boolean fromMe = incomingRequest.getSender() == null ||
+        incomingRequest.getSender().equals(localAddress);
-    logger.info("Membership received a request to remove " + mbr
+    if (!fromMe) {
+      logger.info("Membership received a request to remove " + mbr
+    }
-      logger.debug("ignoring request as I already have a removal request for this member");
+      logger.debug("ignoring removal request as I already have a removal request for this member");
+        logger.fatal("This member is no longer in the membership view.  My ID is {} and the new view is {}", localAddress, view);
+        logger.debug("unresponsive members that could not be reached: {}", unresponsive);
+        
-     * @param mbrs
+     * @param suspects
-    private void removeHealthyMembers(final Collection<InternalDistributedMember> mbrs) throws InterruptedException {
-      List<Callable<InternalDistributedMember>> checkers = new ArrayList<Callable<InternalDistributedMember>>(mbrs.size());
+    private void removeHealthyMembers(final Set<InternalDistributedMember> suspects) throws InterruptedException {
+      List<Callable<InternalDistributedMember>> checkers = new ArrayList<Callable<InternalDistributedMember>>(suspects.size());
-      filterMembers(mbrs, newRemovals, REMOVE_MEMBER_REQUEST);
-      filterMembers(mbrs, newLeaves, LEAVE_REQUEST_MESSAGE);   
+      filterMembers(suspects, newRemovals, REMOVE_MEMBER_REQUEST);
+      filterMembers(suspects, newLeaves, LEAVE_REQUEST_MESSAGE);
+      newRemovals.removeAll(newLeaves);  // if we received a Leave req the member is "healthy" 
-      for (InternalDistributedMember mbr : mbrs) {
+      suspects.removeAll(newLeaves);
+      
+      for (InternalDistributedMember mbr : suspects) {
+        if (newRemovals.contains(mbr) || newLeaves.contains(mbr)) {
+          continue; // no need to check this member - it's already been checked or is leaving
+        }
-            // return the member id if it fails health checks
-                mbrs.remove(mbr);
+                suspects.remove(mbr);
+          @Override
+          public String toString() {
+            return mbr.toString();
+          }
-
-      mbrs.removeAll(newLeaves);
-
-      if (mbrs.isEmpty()) {
+      
+      if (checkers.isEmpty()) {
+        logger.debug("all unresponsive members are already scheduled to be removed");
-      
-      ExecutorService svc = Executors.newFixedThreadPool(mbrs.size(), new ThreadFactory() {
+
+      logger.debug("checking availability of these members: {}", checkers);
+      ExecutorService svc = Executors.newFixedThreadPool(suspects.size(), new ThreadFactory() {
-        List<Future<InternalDistributedMember>> futures;
-        futures = submitAll(svc, checkers);
+        // submit the tasks that will remove dead members from the suspects collection
+        submitAll(svc, checkers);
+        
+        // now wait for the tasks to do their work
-          while(waitTime>0 ) {
-            logger.debug("removeHealthyMembers: mbrs" + mbrs.size());
+          while ( waitTime > 0 ) {
+            logger.debug("removeHealthyMembers: mbrs" + suspects.size());
-            filterMembers(mbrs, newRemovals, REMOVE_MEMBER_REQUEST);
-            filterMembers(mbrs, newLeaves, LEAVE_REQUEST_MESSAGE);   
+            filterMembers(suspects, newRemovals, REMOVE_MEMBER_REQUEST);
+            filterMembers(suspects, newLeaves, LEAVE_REQUEST_MESSAGE);
+            newRemovals.removeAll(newLeaves);
-            if(mbrs.isEmpty()) {
+            suspects.removeAll(newLeaves);
+            
+            if(suspects.isEmpty() || newRemovals.containsAll(suspects)) {
-        
-        //we have waited for all members, now check if we considered any removeRequest;
-        //add them back to create new view
-        if(!newRemovals.isEmpty()) {
-          newRemovals.removeAll(newLeaves);
-          mbrs.addAll(newRemovals);
-        }
-        
-    protected void filterMembers(Collection<InternalDistributedMember> mbrs, Set<InternalDistributedMember> removalRequestForMembers, short requestType) {
-      Set<InternalDistributedMember> gotRemovalRequests = getPendingRequestIDs(requestType);
+    /**
+     * This gets pending requests and returns the IDs of any that are in the given collection
+     * @param mbrs collection of IDs to search for
+     * @param matchingMembers collection to store matching IDs in
+     * @param requestType leave/remove/join
+     */
+    protected void filterMembers(Collection<InternalDistributedMember> mbrs, Set<InternalDistributedMember> matchingMembers, short requestType) {
+      Set<InternalDistributedMember> requests = getPendingRequestIDs(requestType);
-      if(!gotRemovalRequests.isEmpty()) {
-        logger.debug("removeHealthyMembers: gotRemovalRequests " + gotRemovalRequests.size());
-        Iterator<InternalDistributedMember> itr = gotRemovalRequests.iterator();
+      if(!requests.isEmpty()) {
+        logger.debug("filterMembers: processing " + requests.size() + " requests for type " + requestType);
+        Iterator<InternalDistributedMember> itr = requests.iterator();
-          InternalDistributedMember removeMember = itr.next();
-          if(mbrs.contains(removeMember)) {
+          InternalDistributedMember memberID = itr.next();
+          if(mbrs.contains(memberID)) {
-            removalRequestForMembers.add(removeMember);
-            mbrs.remove(removeMember);
+            matchingMembers.add(memberID);

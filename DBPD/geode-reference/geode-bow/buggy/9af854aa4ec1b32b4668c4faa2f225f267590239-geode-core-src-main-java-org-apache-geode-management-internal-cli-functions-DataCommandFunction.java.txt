GEODE-2662: Gfsh displays field value on wrong line when receiving objects with missing fields

* DataCommandResult.buildTable refactored to scan for all necessary fields and build rows, padding with MISSING_VALUE as necessary.
* ServerStarterRule adjusted to build .withPDXPersistent() rather than take it as input to .startServer()
* Refactored a great deal for readability.
* this closes #500

-import java.io.IOException;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.apache.logging.log4j.Logger;
-import org.apache.shiro.subject.Subject;
-import org.json.JSONArray;
-
-import org.apache.geode.cache.CacheClosedException;
+import org.apache.logging.log4j.Logger;
+import org.apache.shiro.subject.Subject;
+import org.json.JSONArray;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
-      if (request.isGet())
+      if (request.isGet()) {
-      else if (request.isLocateEntry())
+      } else if (request.isLocateEntry()) {
-      else if (request.isPut())
+      } else if (request.isPut()) {
-      else if (request.isRemove())
+      } else if (request.isRemove()) {
-      else if (request.isSelect())
+      } else if (request.isSelect()) {
+      }
-    } catch (CacheClosedException e) {
-      e.printStackTrace();
-      functionContext.getResultSender().sendException(e);
-      e.printStackTrace();
+      logger.info("Exception occurred:", e);
+
+
-    if (queryString != null && !queryString.isEmpty()) {
-      QueryService qs = cache.getQueryService();
-
-      // TODO : Find out if is this optimised use. Can you have something equivalent of parsed
-      // queries with names
-      // where name can be retrieved to avoid parsing every-time
-      Query query = qs.newQuery(queryString);
-      DefaultQuery tracedQuery = (DefaultQuery) query;
-      WrappedIndexTrackingQueryObserver queryObserver = null;
-      String queryVerboseMsg = null;
-      long startTime = -1;
-      if (tracedQuery.isTraced()) {
-        startTime = NanoTimer.getTime();
-        queryObserver = new WrappedIndexTrackingQueryObserver();
-        QueryObserverHolder.setInstance(queryObserver);
-      }
-      List<SelectResultRow> list = new ArrayList<SelectResultRow>();
-
-      try {
-        Object results = query.execute();
-        if (tracedQuery.isTraced()) {
-          queryVerboseMsg = getLogMessage(queryObserver, startTime, queryString);
-          queryObserver.reset2();
-        }
-        if (results instanceof SelectResults) {
-          SelectResults selectResults = (SelectResults) results;
-          for (Iterator iter = selectResults.iterator(); iter.hasNext();) {
-            Object object = iter.next();
-            // Post processing
-            object = this.securityService.postProcess(principal, null, null, object, false);
-
-            if (object instanceof Struct) {
-              StructImpl impl = (StructImpl) object;
-              GfJsonObject jsonStruct = getJSONForStruct(impl, nestedObjectCount);
-              if (logger.isDebugEnabled())
-                logger.debug("SelectResults : Adding select json string : {}", jsonStruct);
-              list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_STRUCT_RESULT,
-                  jsonStruct.toString()));
-            } else {
-              if (JsonUtil.isPrimitiveOrWrapper(object.getClass())) {
-                if (logger.isDebugEnabled())
-                  logger.debug("SelectResults : Adding select primitive : {}", object);
-                list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_PRIMITIVE, object));
-              } else {
-                if (logger.isDebugEnabled())
-                  logger.debug("SelectResults : Bean Results class is {}", object.getClass());
-                String str = toJson(object);
-                GfJsonObject jsonBean;
-                try {
-                  jsonBean = new GfJsonObject(str);
-                } catch (GfJsonException e) {
-                  logger.fatal(e.getMessage(), e);
-                  jsonBean = new GfJsonObject();
-                  try {
-                    jsonBean.put("msg", e.getMessage());
-                  } catch (GfJsonException e1) {
-                  }
-                }
-                if (logger.isDebugEnabled())
-                  logger.debug("SelectResults : Adding bean json string : {}", jsonBean);
-                list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_BEAN, jsonBean.toString()));
-              }
-            }
-          }
-        } else {
-          if (logger.isDebugEnabled())
-            logger.debug("BeanResults : Bean Results class is {}", results.getClass());
-          String str = toJson(results);
-          GfJsonObject jsonBean;
-          try {
-            jsonBean = new GfJsonObject(str);
-          } catch (GfJsonException e) {
-            e.printStackTrace();
-            jsonBean = new GfJsonObject();
-            try {
-              jsonBean.put("msg", e.getMessage());
-            } catch (GfJsonException e1) {
-            }
-          }
-          if (logger.isDebugEnabled())
-            logger.debug("BeanResults : Adding bean json string : {}", jsonBean);
-          list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_BEAN, jsonBean.toString()));
-        }
-        return DataCommandResult.createSelectResult(queryString, list, queryVerboseMsg, null, null,
-            true);
-
-      } catch (FunctionDomainException e) {
-        logger.warn(e.getMessage(), e);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
-            e.getMessage(), false);
-      } catch (TypeMismatchException e) {
-        logger.warn(e.getMessage(), e);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
-            e.getMessage(), false);
-      } catch (NameResolutionException e) {
-        logger.warn(e.getMessage(), e);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
-            e.getMessage(), false);
-      } catch (QueryInvocationTargetException e) {
-        logger.warn(e.getMessage(), e);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
-            e.getMessage(), false);
-      } catch (GfJsonException e) {
-        logger.warn(e.getMessage(), e);
-        return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
-            e.getMessage(), false);
-      } finally {
-        if (queryObserver != null) {
-          QueryObserverHolder.reset();
-        }
-      }
-    } else {
+    if (StringUtils.isEmpty(queryString)) {
+
+    QueryService qs = cache.getQueryService();
+
+    // TODO : Find out if is this optimised use. Can you have something equivalent of parsed
+    // queries with names where name can be retrieved to avoid parsing every-time
+    Query query = qs.newQuery(queryString);
+    DefaultQuery tracedQuery = (DefaultQuery) query;
+    WrappedIndexTrackingQueryObserver queryObserver = null;
+    String queryVerboseMsg = null;
+    long startTime = -1;
+    if (tracedQuery.isTraced()) {
+      startTime = NanoTimer.getTime();
+      queryObserver = new WrappedIndexTrackingQueryObserver();
+      QueryObserverHolder.setInstance(queryObserver);
+    }
+    List<SelectResultRow> list = new ArrayList<>();
+
+    try {
+      Object results = query.execute();
+      if (tracedQuery.isTraced()) {
+        queryVerboseMsg = getLogMessage(queryObserver, startTime, queryString);
+        queryObserver.reset2();
+      }
+      if (results instanceof SelectResults) {
+        select_SelectResults((SelectResults) results, principal, list, nestedObjectCount);
+      } else {
+        select_NonSelectResults(results, list);
+      }
+      return DataCommandResult.createSelectResult(queryString, list, queryVerboseMsg, null, null,
+          true);
+
+    } catch (FunctionDomainException | GfJsonException | QueryInvocationTargetException
+        | NameResolutionException | TypeMismatchException e) {
+      logger.warn(e.getMessage(), e);
+      return DataCommandResult.createSelectResult(queryString, null, queryVerboseMsg, e,
+          e.getMessage(), false);
+    } finally {
+      if (queryObserver != null) {
+        QueryObserverHolder.reset();
+      }
+    }
+  }
+
+  private void select_NonSelectResults(Object results, List<SelectResultRow> list) {
+    if (logger.isDebugEnabled()) {
+      logger.debug("BeanResults : Bean Results class is {}", results.getClass());
+    }
+    String str = toJson(results);
+    GfJsonObject jsonBean;
+    try {
+      jsonBean = new GfJsonObject(str);
+    } catch (GfJsonException e) {
+      logger.info("Exception occurred:", e);
+      jsonBean = new GfJsonObject();
+      try {
+        jsonBean.put("msg", e.getMessage());
+      } catch (GfJsonException e1) {
+        logger.warn("Ignored GfJsonException:", e1);
+      }
+    }
+    if (logger.isDebugEnabled()) {
+      logger.debug("BeanResults : Adding bean json string : {}", jsonBean);
+    }
+    list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_BEAN, jsonBean.toString()));
+  }
+
+  private void select_SelectResults(SelectResults selectResults, Object principal,
+      List<SelectResultRow> list, AtomicInteger nestedObjectCount) throws GfJsonException {
+    for (Object object : selectResults) {
+      // Post processing
+      object = securityService.postProcess(principal, null, null, object, false);
+
+      if (object instanceof Struct) {
+        StructImpl impl = (StructImpl) object;
+        GfJsonObject jsonStruct = getJSONForStruct(impl, nestedObjectCount);
+        if (logger.isDebugEnabled()) {
+          logger.debug("SelectResults : Adding select json string : {}", jsonStruct);
+        }
+        list.add(
+            new SelectResultRow(DataCommandResult.ROW_TYPE_STRUCT_RESULT, jsonStruct.toString()));
+      } else if (JsonUtil.isPrimitiveOrWrapper(object.getClass())) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("SelectResults : Adding select primitive : {}", object);
+        }
+        list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_PRIMITIVE, object));
+      } else {
+        if (logger.isDebugEnabled()) {
+          logger.debug("SelectResults : Bean Results class is {}", object.getClass());
+        }
+        String str = toJson(object);
+        GfJsonObject jsonBean;
+        try {
+          jsonBean = new GfJsonObject(str);
+        } catch (GfJsonException e) {
+          logger.error(e.getMessage(), e);
+          jsonBean = new GfJsonObject();
+          try {
+            jsonBean.put("msg", e.getMessage());
+          } catch (GfJsonException e1) {
+            logger.warn("Ignored GfJsonException:", e1);
+          }
+        }
+        if (logger.isDebugEnabled()) {
+          logger.debug("SelectResults : Adding bean json string : {}", jsonBean);
+        }
+        list.add(new SelectResultRow(DataCommandResult.ROW_TYPE_BEAN, jsonBean.toString()));
+      }
+    }
-    } else if (object instanceof PdxInstance)
+    } else if (object instanceof PdxInstance) {
-    else
+    } else {
+    }
-    if (regionName == null || regionName.isEmpty()) {
+    if (StringUtils.isEmpty(regionName)) {
-    boolean allKeysFlag = (removeAllKeys == null || removeAllKeys.isEmpty());
-    if (allKeysFlag && (key == null)) {
-      return DataCommandResult.createRemoveResult(key, null, null,
+    if (StringUtils.isEmpty(removeAllKeys) && (key == null)) {
+      return DataCommandResult.createRemoveResult(null, null, null,
-        Object keyObject = null;
+        Object keyObject;
-          if (logger.isDebugEnabled())
+          if (logger.isDebugEnabled()) {
+          }
-          if (array[0] != null)
+          if (array[0] != null) {
+          }
-          if (logger.isDebugEnabled())
+          if (logger.isDebugEnabled()) {
+          }
-    if (regionName == null || regionName.isEmpty()) {
+    if (StringUtils.isEmpty(regionName)) {
-    if (key == null || key.isEmpty()) {
+    if (StringUtils.isEmpty(key)) {
-      if (logger.isDebugEnabled())
+      if (logger.isDebugEnabled()) {
+      }
-      Object keyObject = null;
+      Object keyObject;
-        value = this.securityService.postProcess(principal, regionName, keyObject, value, false);
+        value = securityService.postProcess(principal, regionName, keyObject, value, false);
-        if (logger.isDebugEnabled())
+        if (logger.isDebugEnabled()) {
+        }
-          if (array[0] != null)
+          if (array[0] != null) {
+          }
-        if (logger.isDebugEnabled())
+        if (logger.isDebugEnabled()) {
+        }
-    if (regionPath == null || regionPath.isEmpty()) {
+    if (StringUtils.isEmpty(regionPath)) {
-    if (key == null || key.isEmpty()) {
+    if (StringUtils.isEmpty(key)) {
-
-    List<Region> listofRegionStartingwithRegionPath = new ArrayList<Region>();
+    List<Region> listOfRegionsStartingWithRegionPath = new ArrayList<>();
-      for (int i = 0; i < regionPaths.size(); i++) {
-        String path = regionPaths.get(i);
+      for (String path : regionPaths) {
-          listofRegionStartingwithRegionPath.add(targetRegion);
+          listOfRegionsStartingWithRegionPath.add(targetRegion);
-      if (listofRegionStartingwithRegionPath.size() == 0) {
-        if (logger.isDebugEnabled())
+      if (listOfRegionsStartingWithRegionPath.size() == 0) {
+        if (logger.isDebugEnabled()) {
+        }
-        if (logger.isDebugEnabled())
+        if (logger.isDebugEnabled()) {
+        }
-      } else
-        listofRegionStartingwithRegionPath.add(region);
+      } else {
+        listOfRegionsStartingWithRegionPath.add(region);
+      }
-    Object keyObject = null;
+    Object keyObject;
-      logger.fatal(e.getMessage(), e);
+      logger.error(e.getMessage(), e);
-      logger.fatal(e.getMessage(), e);
+      logger.error(e.getMessage(), e);
-    Object value = null;
-    DataCommandResult.KeyInfo keyInfo = null;
+    Object value;
+    DataCommandResult.KeyInfo keyInfo;
-    for (Region region : listofRegionStartingwithRegionPath) {
+    for (Region region : listOfRegionsStartingWithRegionPath) {
-        Region localRegion = PartitionRegionHelper.getLocalData((PartitionedRegion) region);
+        Region localRegion = PartitionRegionHelper.getLocalData(region);
-          if (logger.isDebugEnabled())
+          if (logger.isDebugEnabled()) {
+          }
-          if (logger.isDebugEnabled())
+          if (logger.isDebugEnabled()) {
-          if (value != null)
+          }
+          if (value != null) {
-          else
+          } else {
+          }
-          if (logger.isDebugEnabled())
+          if (logger.isDebugEnabled()) {
+          }
-    if (regionName == null || regionName.isEmpty()) {
+    if (StringUtils.isEmpty(regionName)) {
-    if (key == null || key.isEmpty()) {
+    if (StringUtils.isEmpty(key)) {
-    if (value == null || value.isEmpty()) {
+    if (StringUtils.isEmpty(value)) {
-      Object keyObject = null;
-      Object valueObject = null;
+      Object keyObject;
+      Object valueObject;
-      if (putIfAbsent && region.containsKey(keyObject))
+      if (putIfAbsent && region.containsKey(keyObject)) {
-      else
+      } else {
+      }
-      if (array[0] != null)
+      if (array[0] != null) {
+      }
-    if (klassString == null || klassString.isEmpty())
+    if (StringUtils.isEmpty(klassString)) {
-    else {
-      Object o = null;
-      Class klass = ClassPathLoader.getLatest().forName(klassString);
+    }
+    Class klass = ClassPathLoader.getLatest().forName(klassString);
-      if (klass.equals(String.class))
-        return string;
+    if (klass.equals(String.class)) {
+      return string;
+    }
-      if (JsonUtil.isPrimitiveOrWrapper(klass)) {
-        try {
-          if (klass.equals(Byte.class)) {
-            o = Byte.parseByte(string);
-            return o;
-          } else if (klass.equals(Short.class)) {
-            o = Short.parseShort(string);
-            return o;
-          } else if (klass.equals(Integer.class)) {
-            o = Integer.parseInt(string);
-            return o;
-          } else if (klass.equals(Long.class)) {
-            o = Long.parseLong(string);
-            return o;
-          } else if (klass.equals(Double.class)) {
-            o = Double.parseDouble(string);
-            return o;
-          } else if (klass.equals(Boolean.class)) {
-            o = Boolean.parseBoolean(string);
-            return o;
-          } else if (klass.equals(Float.class)) {
-            o = Float.parseFloat(string);
-            return o;
-          }
-          return o;
-        } catch (NumberFormatException e) {
-          throw new IllegalArgumentException(
-              "Failed to convert input key to " + klassString + " Msg : " + e.getMessage());
-        }
-      }
-
+    if (JsonUtil.isPrimitiveOrWrapper(klass)) {
-        o = getObjectFromJson(string, klass);
-        return o;
-      } catch (IllegalArgumentException e) {
-        throw e;
+        if (klass.equals(Byte.class)) {
+          return Byte.parseByte(string);
+        } else if (klass.equals(Short.class)) {
+          return Short.parseShort(string);
+        } else if (klass.equals(Integer.class)) {
+          return Integer.parseInt(string);
+        } else if (klass.equals(Long.class)) {
+          return Long.parseLong(string);
+        } else if (klass.equals(Double.class)) {
+          return Double.parseDouble(string);
+        } else if (klass.equals(Boolean.class)) {
+          return Boolean.parseBoolean(string);
+        } else if (klass.equals(Float.class)) {
+          return Float.parseFloat(string);
+        }
+        return null;
+      } catch (NumberFormatException e) {
+        throw new IllegalArgumentException(
+            "Failed to convert input key to " + klassString + " Msg : " + e.getMessage());
+
+    return getObjectFromJson(string, klass);
-    V v = JsonUtil.jsonToObject(newString, klass);
-    return v;
+    return JsonUtil.jsonToObject(newString, klass);
+
+
-    Set regions = cache.rootRegions();
-    Iterator itor = regions.iterator();
+    Set<Region<?, ?>> regions = cache.rootRegions();
-    while (itor.hasNext()) {
-      String regionPath = ((Region) itor.next()).getFullPath();
+    for (Region rootRegion : regions) {
+      String regionPath = rootRegion.getFullPath();
-      Set subregionSet = region.subregions(true);
+      Set<Region> subregionSet = region.subregions(true);
-        for (Iterator subIter = subregionSet.iterator(); subIter.hasNext();) {
-          list.add(((Region) subIter.next()).getFullPath());
+        for (Region aSubregionSet : subregionSet) {
+          list.add(aSubregionSet.getFullPath());
-                                                          // works.
+      // works.
-        boolean paginationNeeded = (startCount < rows) && (endCount < rows) && interactive && flag;
+        boolean paginationNeeded = startCount < rows && endCount < rows && interactive;
-                if (nextStart < 0)
+                if (nextStart < 0) {
+                }
-              } else if ("q".equals(step))
+              } else if ("q".equals(step)) {
-              else
+              } else {
+              }
-  };
+  }
-        if (result.getSelectResult() != null)
+        if (result.getSelectResult() != null) {
+        }
-      if (interactive)
+      if (interactive) {
-      else
+      } else {
+      }
-      DataCommandResult dataResult = null;
+      DataCommandResult dataResult;
-      if (query == null || query.isEmpty()) {
+      if (StringUtils.isEmpty(query)) {
-      Set<String> regionsInQuery = null;
+      Set<String> regionsInQuery;
-        Set<String> regions = new HashSet<String>();
+        Set<String> regions = new HashSet<>();
-          this.securityService.authorizeRegionRead(region);
+          securityService.authorizeRegionRead(region);
-            Subject subject = this.securityService.getSubject();
+            Subject subject = securityService.getSubject();
-              request.setPrincipal((Serializable) subject.getPrincipal());
+              request.setPrincipal(subject.getPrincipal());
-            return (dataResult);
+            return dataResult;
-            return (dataResult =
-                DataCommandResult.createSelectInfoResult(null, null, -1, null, CliStrings.format(
-                    CliStrings.QUERY__MSG__REGIONS_NOT_FOUND, regionsInQuery.toString()), false));
+            return DataCommandResult.createSelectInfoResult(null, null, -1, null, CliStrings.format(
+                CliStrings.QUERY__MSG__REGIONS_NOT_FOUND, regionsInQuery.toString()), false);
-          return (dataResult = DataCommandResult.createSelectInfoResult(null, null, -1, null,
+          return DataCommandResult.createSelectInfoResult(null, null, -1, null,
-              false));
+              false);
-        return (dataResult = DataCommandResult.createSelectInfoResult(null, null, -1, null,
-            CliStrings.format(CliStrings.QUERY__MSG__INVALID_QUERY, qe.getMessage()), false));
+        return DataCommandResult.createSelectInfoResult(null, null, -1, null,
+            CliStrings.format(CliStrings.QUERY__MSG__INVALID_QUERY, qe.getMessage()), false);
-          || StringUtils.containsIgnoreCase(query, " count("))
+          || StringUtils.containsIgnoreCase(query, " count(")) {
+      }
-  };
+  }
-      if (interactive)
+      if (interactive) {
-      else {
+      } else {
-  };
+  }
-    Map<String, String> session = null;
+    Map<String, String> session;
-      if (size == null || size.isEmpty())
+      if (StringUtils.isEmpty(size)) {
-      else
+      } else {
+      }
-    if (pageSize == -1)
+    if (pageSize == -1) {
+    }
-    String rowCountString = null;
-          buf.append(entry.getKey().toString() + entry.getValue());
+          buf.append(entry.getKey().toString()).append(entry.getValue());
-    return "Query Executed" + (startTime > 0L ? " in " + time + " ms;" : ";")
-        + (rowCountString != null ? rowCountString : "")
-        + (usedIndexesString != null ? usedIndexesString : "");
+    return String.format("Query Executed%s%s", startTime > 0L ? " in " + time + " ms;" : ";",
+        usedIndexesString != null ? usedIndexesString : "");

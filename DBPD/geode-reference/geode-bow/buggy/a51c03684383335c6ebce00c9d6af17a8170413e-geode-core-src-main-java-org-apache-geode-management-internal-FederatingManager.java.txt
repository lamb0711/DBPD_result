GEODE-5923: Add test for local alerts and cleanup classes (#2710)

* Create DistributedSystemMXBeanIntegrationTest
* Add ignored test that confirms bug GEODE-5923
* Cleanup alert related classes and add lots of comments about how they work
+ * <p>
-  protected MBeanProxyFactory proxyFactory;
-
-  private MBeanJMXAdapter jmxAdapter;
+  private MBeanProxyFactory proxyFactory;
-  private SystemManagementService service;
+  private final SystemManagementService service;
-  private AtomicReference<Exception> latestException = new AtomicReference<>(null);
+  private final AtomicReference<Exception> latestException = new AtomicReference<>(null);
-  /**
-   * @param jmxAdapter JMX Adapter
-   * @param repo Management resource repo
-   * @param system Internal Distributed System
-   * @param service SystemManagement Service
-   */
-  public FederatingManager(MBeanJMXAdapter jmxAdapter, ManagementResourceRepo repo,
-      InternalDistributedSystem system, SystemManagementService service, InternalCache cache) {
+  FederatingManager(MBeanJMXAdapter jmxAdapter, ManagementResourceRepo repo,
+      InternalDistributedSystem system, SystemManagementService service,
+      InternalCache cache) {
-    this.proxyFactory = new MBeanProxyFactory(jmxAdapter, service);
-    this.jmxAdapter = jmxAdapter;
-    this.messenger = new MemberMessenger(jmxAdapter, repo, system);
+    proxyFactory = new MBeanProxyFactory(jmxAdapter, service);
+    messenger = new MemberMessenger(jmxAdapter, system);
-    this.proxyFactory = newProxyFactory;
+    proxyFactory = newProxyFactory;
-      Runtime rt = Runtime.getRuntime();
-      this.pooledMembershipExecutor =
-          LoggingExecutors.newFixedThreadPool("FederatingManager", false, rt.availableProcessors());
+      pooledMembershipExecutor = LoggingExecutors.newFixedThreadPool("FederatingManager", false,
+          Runtime.getRuntime().availableProcessors());
-
-
+  @Override
-   * This method will be invoked whenever a member stops being a managing node. The exception
-   * Management exception has to be handled by the caller. *
+   * This method will be invoked whenever a member stops being a managing node. The
+   * {@code ManagementException} has to be handled by the caller.
-      this.pooledMembershipExecutor.shutdownNow();
+      pooledMembershipExecutor.shutdownNow();
-
+   * <p>
-        logger.warn("Error federating new member {}: {}", member.getId(), e.getMessage());
+        logger.warn("Error federating new member {}", member.getId(), e);
+   * <p>
-    } catch (RejectedExecutionException ex) {
+    } catch (RejectedExecutionException ignored) {
-  private class RemoveMemberTask implements Runnable {
-
-    private DistributedMember member;
-
-    boolean crashed;
-
-    protected RemoveMemberTask(DistributedMember member, boolean crashed) {
-      this.member = member;
-      this.crashed = crashed;
-    }
-
-    public void run() {
-      removeMemberArtifacts(member, crashed);
-    }
-  }
-
-  private DistributedMember removeMemberArtifacts(DistributedMember member, boolean crashed) {
+  private void removeMemberArtifacts(DistributedMember member, boolean crashed) {
-    Region<NotificationKey, Notification> notifRegion = repo.getEntryFromNotifRegionMap(member);
+    Region<NotificationKey, Notification> notificationRegion =
+        repo.getEntryFromNotifRegionMap(member);
-    if (proxyRegion == null && notifRegion == null) {
-      return member;
+    if (proxyRegion == null && notificationRegion == null) {
+      return;
+
-    // If cache is closed all the regions would have been
-    // destroyed implicitly
+
+    // If cache is closed all the regions would have been destroyed implicitly
-      notifRegion.localDestroyRegion();
+      notificationRegion.localDestroyRegion();
+
-    return member;
+   * <p>
-  public void startManagingActivity() throws Exception {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+  private void startManagingActivity() {
+    boolean isDebugEnabled = logger.isDebugEnabled();
-    final List<Callable<DistributedMember>> giiTaskList = new ArrayList<>();
-    List<Future<DistributedMember>> futureTaskList;
+    List<Callable<DistributedMember>> giiTaskList = new ArrayList<>();
-      futureTaskList = pooledMembershipExecutor.invokeAll(giiTaskList);
+      List<Future<DistributedMember>> futureTaskList =
+          pooledMembershipExecutor.invokeAll(giiTaskList);
-
-        String memberId = null;
-
-          if (returnedMember != null) {
-            memberId = returnedMember.getId();
-          }
+          String memberId = returnedMember != null ? returnedMember.getId() : null;
-            logger.debug("ExecutionException during Management GII: {}", e.getMessage(), e);
+            logger.debug("ExecutionException during Management GII", e);
-            ManagementException mgEx = new ManagementException(e.fillInStackTrace());
-            logger.debug("InterruptedException while creating Monitoring resource with error : {}",
-                mgEx.getMessage(), mgEx);
+            logger.debug("InterruptedException while creating Monitoring resource with error",
+                new ManagementException(e));
-        ManagementException mgEx = new ManagementException(e.fillInStackTrace());
-        logger.debug("InterruptedException while creating Monitoring resource with error : ",
-            mgEx.getMessage(), mgEx);
+        logger.debug("InterruptedException while creating Monitoring resource with error",
+            new ManagementException(e));
+  private class RemoveMemberTask implements Runnable {
+
+    private final DistributedMember member;
+
+    boolean crashed;
+
+    RemoveMemberTask(DistributedMember member, boolean crashed) {
+      this.member = member;
+      this.crashed = crashed;
+    }
+
+    @Override
+    public void run() {
+      removeMemberArtifacts(member, crashed);
+    }
+  }
+
+   * <p>
-   * Managing Node side resources are created per member which is visible to this node
+   * <p>
+   * Managing Node side resources are created per member which is visible to this node:
-   * 1)Management Region : its a Replicated NO_ACK region 2)Notification Region : its a Replicated
-   * Proxy NO_ACK region
+   * <pre>
+   * 1)Management Region : its a Replicated NO_ACK region
+   * 2)Notification Region : its a Replicated Proxy NO_ACK region
+   * </pre>
-   * Listeners are added to the above two regions 1) ManagementCacheListener() 2)
-   * NotificationCacheListener
+   * <p>
+   * Listeners are added to the above two regions:
+   * <pre>
+   * 1) ManagementCacheListener
+   * 2) NotificationCacheListener
+   * </pre>
+   *
+   * <p>
-    private DistributedMember member;
+    private final DistributedMember member;
-    protected GIITask(DistributedMember member) {
+    GIITask(DistributedMember member) {
+    @Override
-        Region<String, Object> proxyMonitoringRegion;
-        Region<NotificationKey, Notification> proxyNotificationRegion;
-            InternalRegionArguments internalArgs = new InternalRegionArguments();
-            internalArgs.setIsUsedForMetaRegion(true);
+            InternalRegionArguments internalRegionArguments = new InternalRegionArguments();
+            internalRegionArguments.setIsUsedForMetaRegion(true);
-            final HasCachePerfStats monitoringRegionStats = new HasCachePerfStats() {
-              public CachePerfStats getCachePerfStats() {
-                return new CachePerfStats(cache.getDistributedSystem(), "managementRegionStats");
-              }
-            };
+            HasCachePerfStats monitoringRegionStats =
+                () -> new CachePerfStats(cache.getDistributedSystem(), "managementRegionStats");
-            internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
+            internalRegionArguments.setCachePerfStatsHolder(monitoringRegionStats);
-            AttributesFactory<String, Object> monitorAttrFactory = new AttributesFactory<>();
-            monitorAttrFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-            monitorAttrFactory.setDataPolicy(DataPolicy.REPLICATE);
-            monitorAttrFactory.setConcurrencyChecksEnabled(false);
-            ManagementCacheListener mgmtCacheListener = new ManagementCacheListener(proxyFactory);
-            monitorAttrFactory.addCacheListener(mgmtCacheListener);
+            AttributesFactory<String, Object> monitorAttributesFactory = new AttributesFactory<>();
+            monitorAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+            monitorAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
+            monitorAttributesFactory.setConcurrencyChecksEnabled(false);
+            ManagementCacheListener managementCacheListener =
+                new ManagementCacheListener(proxyFactory);
+            monitorAttributesFactory.addCacheListener(managementCacheListener);
-            RegionAttributes<String, Object> monitoringRegionAttrs = monitorAttrFactory.create();
+            RegionAttributes<String, Object> monitoringRegionAttrs =
+                monitorAttributesFactory.create();
-            AttributesFactory<NotificationKey, Notification> notifAttrFactory =
+            AttributesFactory<NotificationKey, Notification> notificationAttributesFactory =
-            notifAttrFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-            notifAttrFactory.setDataPolicy(DataPolicy.REPLICATE);
-            notifAttrFactory.setConcurrencyChecksEnabled(false);
+            notificationAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+            notificationAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
+            notificationAttributesFactory.setConcurrencyChecksEnabled(false);
-            notifAttrFactory.setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
-                ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
+            notificationAttributesFactory
+                .setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
+                    ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
-            notifAttrFactory.addCacheListener(notifListener);
+            notificationAttributesFactory.addCacheListener(notifListener);
-                notifAttrFactory.create();
+                notificationAttributesFactory.create();
-            boolean proxyMonitoringRegionCreated = false;
-            boolean proxyNotifRegionCreated = false;
+            boolean proxyMonitoringRegionCreated;
+            Region<String, Object> proxyMonitoringRegion;
-                  cache.createVMRegion(monitoringRegionName, monitoringRegionAttrs, internalArgs);
+                  cache.createVMRegion(monitoringRegionName, monitoringRegionAttrs,
+                      internalRegionArguments);
-                logger.debug("Error During Internal Region creation {}", e.getMessage(), e);
+                logger.debug("Error During Internal Region creation", e);
+            boolean proxyNotificationRegionCreated = false;
+            Region<NotificationKey, Notification> proxyNotificationRegion;
-                  cache.createVMRegion(notificationRegionName, notifRegionAttrs, internalArgs);
-              proxyNotifRegionCreated = true;
+                  cache.createVMRegion(notificationRegionName, notifRegionAttrs,
+                      internalRegionArguments);
+              proxyNotificationRegionCreated = true;
-                logger.debug("Error During Internal Region creation {}", e.getMessage(), e);
+                logger.debug("Error During Internal Region creation", e);
-              if (!proxyNotifRegionCreated && proxyMonitoringRegionCreated) {
-                // Destroy the proxy region if proxy notification
-                // region is not created
+              if (!proxyNotificationRegionCreated && proxyMonitoringRegionCreated) {
+                // Destroy the proxy region if proxy notification region is not created
-              mgmtCacheListener.markReady();
+              managementCacheListener.markReady();
-                logger.debug("Error During GII Proxy creation {}", e.getMessage(), e);
+                logger.debug("Error During GII Proxy creation", e);
-   * This will return the last updated time of the proxyMBean
+   * This will return the last updated time of the proxyMBean.
-   * @param objectName {@link javax.management.ObjectName} of the MBean
+   * @param objectName {@link ObjectName} of the MBean
+   *
-  public long getLastUpdateTime(ObjectName objectName) {
+  long getLastUpdateTime(ObjectName objectName) {
-   * Find a particular proxy instance for a {@link javax.management.ObjectName} ,
-   * {@link org.apache.geode.distributed.DistributedMember} and interface class If the proxy
-   * interface does not implement the given interface class a {@link java.lang.ClassCastException}.
-   * will be thrown
+   * Find a particular proxy instance for a {@link ObjectName}, {@link DistributedMember} and
+   * interface class If the proxy interface does not implement the given interface class a
+   * {@link ClassCastException} will be thrown
-   * @param objectName {@link javax.management.ObjectName} of the MBean
+   * @param objectName {@link ObjectName} of the MBean
+   *
-  public <T> T findProxy(ObjectName objectName, Class<T> interfaceClass) {
+  <T> T findProxy(ObjectName objectName, Class<T> interfaceClass) {
-   * Find a set of proxies given a {@link org.apache.geode.distributed.DistributedMember}
+   * Find a set of proxies given a {@link DistributedMember}.
-   * @param member {@link org.apache.geode.distributed.DistributedMember}
-   * @return a set of {@link javax.management.ObjectName}
+   * @param member {@link DistributedMember}
+   *
+   * @return a set of {@link ObjectName}
-  public Set<ObjectName> findAllProxies(DistributedMember member) {
+  Set<ObjectName> findAllProxies(DistributedMember member) {

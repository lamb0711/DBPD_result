GEODE-6322: refactor createRegionCommand to use RegionConfig only (#3156)

* get rid of usages of xxxArgs and RegionConfigFactory
* the resulting cluster configuration xml for region does not have excessive default values

+import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Optional;
-import javax.management.ObjectName;
-
+import joptsimple.internal.Strings;
-import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.apache.commons.lang3.builder.EqualsBuilder;
-import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.configuration.ClassNameType;
+import org.apache.geode.cache.configuration.DeclarableType;
+import org.apache.geode.cache.configuration.RegionAttributesType;
-import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.internal.config.JAXBService;
-import org.apache.geode.management.RegionAttributesData;
-import org.apache.geode.management.RegionMXBean;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
-import org.apache.geode.management.internal.cli.domain.PartitionArgs;
-import org.apache.geode.management.internal.cli.domain.RegionConfigFactory;
-import org.apache.geode.management.internal.cli.functions.RegionAttributesWrapper;
+  private static final String[] PARTITION_ATTRIBUTES = new String[] {
+      CliStrings.CREATE_REGION__COLOCATEDWITH,
+      CliStrings.CREATE_REGION__LOCALMAXMEMORY,
+      CliStrings.CREATE_REGION__RECOVERYDELAY,
+      CliStrings.CREATE_REGION__REDUNDANTCOPIES,
+      CliStrings.CREATE_REGION__STARTUPRECOVERYDDELAY,
+      CliStrings.CREATE_REGION__TOTALMAXMEMORY,
+      CliStrings.CREATE_REGION__TOTALNUMBUCKETS,
+      CliStrings.CREATE_REGION__PARTITION_RESOLVER
+  };
+
+    RegionConfig regionConfig = new RegionConfig();
+
+    // get the initial set of attributes either from shortcut or from the template region
+    InternalConfigurationPersistenceService persistenceService =
+        getConfigurationPersistenceService();
+    if (regionShortcut != null) {
+      regionConfig.setType(regionShortcut.name());
+    }
+    // get the attributes from the template region
+    else {
+      List<RegionConfig> templateRegionConfigs = new ArrayList<>();
+      // get the potential template region config from the cluster configuration
+      if (persistenceService != null) {
+        templateRegionConfigs = persistenceService.getGroups().stream()
+            .flatMap(g -> persistenceService.getCacheConfig(g, true).getRegions().stream())
+            .filter(c -> c.getName().equals(templateRegion.substring(1)))
+            .collect(Collectors.toList());
+      }
+      // as a last resort, go the member that hosts this region to retrieve the template's region
+      // xml
+      else {
+        // we would need to execute a function to the member hosting the template region to get the
+        // region xml. cluster configuration isn't always enabled, so we cannot guarantee that we
+        // can
+        // get the template region configuration from the cluster configuration.
+        Set<DistributedMember> regionAssociatedMembers = findMembersForRegion(templateRegion);
+
+        if (!regionAssociatedMembers.isEmpty()) {
+          List<CliFunctionResult> regionXmlResults = executeAndGetFunctionResult(
+              FetchRegionAttributesFunction.INSTANCE, templateRegion, regionAssociatedMembers);
+
+          JAXBService jaxbService = new JAXBService(CacheConfig.class);
+          templateRegionConfigs = regionXmlResults.stream().filter(CliFunctionResult::isSuccessful)
+              .map(CliFunctionResult::getResultObject).map(String.class::cast)
+              .map(s -> jaxbService.unMarshall(s, RegionConfig.class))
+              .collect(Collectors.toList());
+        }
+      }
+
+      if (templateRegionConfigs.isEmpty()) {
+        return ResultModel.createError("Template region " + templateRegion + " does not exist.");
+      }
+      if (templateRegionConfigs.size() == 1) {
+        regionConfig = templateRegionConfigs.get(0);
+      }
+      // found more than one configuration with this name. fail ff they have different attributes.
+      else {
+        RegionConfig first = templateRegionConfigs.get(0);
+        for (int i = 1; i < templateRegionConfigs.size(); i++) {
+          if (!EqualsBuilder.reflectionEquals(first, templateRegionConfigs.get(i), false, null,
+              true)) {
+            return ResultModel.createError("Multiple types of template region " + templateRegion
+                + " exist. Can not resolve template region attributes.");
+          }
+        }
+        regionConfig = first;
+      }
+    }
+
+    regionConfig.setName(regionPathData.getName());
+
+    // set partition attributes
+    RegionAttributesType regionAttributes = regionConfig.getRegionAttributes();
+    RegionAttributesType.PartitionAttributes delta =
+        RegionAttributesType.PartitionAttributes.generate(partitionResolver, null, prLocalMaxMemory,
+            prRecoveryDelay, prRedundantCopies, prStartupRecoveryDelay, prTotalMaxMemory,
+            prTotalNumBuckets, prColocatedWith);
+
+    RegionAttributesType.PartitionAttributes partitionAttributes =
+        RegionAttributesType.PartitionAttributes.combine(
+            regionAttributes.getPartitionAttributes(), delta);
+    regionAttributes.setPartitionAttributes(partitionAttributes);
+
-    PartitionArgs partitionArgs =
-        new PartitionArgs(prColocatedWith, prLocalMaxMemory, prRecoveryDelay,
-            prRedundantCopies, prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets,
-            partitionResolver);
-    if (regionShortcut != null && !regionShortcut.name().startsWith("PARTITION")
-        && !partitionArgs.isEmpty()) {
-      return ResultModel.createError(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__OPTION_0_CAN_BE_USED_ONLY_FOR_PARTITIONEDREGION,
-          partitionArgs.getUserSpecifiedPartitionAttributes()) + " "
-          + CliStrings.format(CliStrings.CREATE_REGION__MSG__0_IS_NOT_A_PARITIONEDREGION,
-              regionPath));
+    if (!regionAttributes.getDataPolicy().isPartition() && partitionAttributes != null) {
+      return ResultModel.createError(
+          String.format("Parameters %s can be used only for creating a Partitioned Region",
+              Strings.join(PARTITION_ATTRIBUTES, ", ")));
-    // validate gateway senders
+    // validate and set gateway senders
+      regionAttributes.setGatewaySenderIds(StringUtils.join(gatewaySenderIds, ","));
-    // validate if template region exists, if provided
-    if (templateRegion != null && !regionExists(templateRegion)) {
-      return ResultModel.createError(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_REGION_PATH_FOR_0_REGIONPATH_1_NOT_FOUND,
-          CliStrings.CREATE_REGION__USEATTRIBUTESFROM, templateRegion));
-    }
-
-    // get predefined attributes for a template region
-    RegionAttributesWrapper<?, ?> wrappedTemplateAttributes = null;
-    if (templateRegion != null) {
-      wrappedTemplateAttributes = getRegionAttributes(cache, templateRegion);
-      if (wrappedTemplateAttributes == null) {
-        return ResultModel.createError(CliStrings.format(
-            CliStrings.CREATE_REGION__MSG__COULD_NOT_RETRIEVE_REGION_ATTRS_FOR_PATH_0_VERIFY_REGION_EXISTS,
-            templateRegion));
+    // validating and set diskstore
+    if (diskStore != null) {
+      if (!regionAttributes.getDataPolicy().isPersistent()) {
+        String subMessage =
+            "Only regions with persistence or overflow to disk can specify DiskStore";
+        String message = subMessage + ". "
+            + CliStrings.format(
+                CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FROM_REGION_0_IS_NOT_WITH_PERSISTENCE,
+                new Object[] {templateRegion});
+        return ResultModel.createError(message);
-      if (wrappedTemplateAttributes.getRegionAttributes().getPartitionAttributes() == null
-          && !partitionArgs.isEmpty()) {
+      if (!diskStoreExists(diskStore)) {
-            CliStrings.CREATE_REGION__MSG__OPTION_0_CAN_BE_USED_ONLY_FOR_PARTITIONEDREGION,
-            partitionArgs.getUserSpecifiedPartitionAttributes()) + " "
-            + CliStrings.format(CliStrings.CREATE_REGION__MSG__0_IS_NOT_A_PARITIONEDREGION,
-                templateRegion));
+            CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_DISKSTORE_UNKNOWN_DISKSTORE_0,
+            new Object[] {diskStore}));
-    }
-
-    RegionAttributes<?, ?> regionAttributes;
-    if (wrappedTemplateAttributes != null) {
-      regionAttributes = wrappedTemplateAttributes.getRegionAttributes();
-    } else {
-      regionAttributes = cache.getRegionAttributes(regionShortcut.toString());
-    }
-
-    // validating diskstore with other attributes
-    if (diskStore != null && !regionAttributes.getDataPolicy().withPersistence()) {
-      String subMessage = "Only regions with persistence or overflow to disk can specify DiskStore";
-      String message = subMessage + ". "
-          + CliStrings.format(
-              CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FROM_REGION_0_IS_NOT_WITH_PERSISTENCE,
-              new Object[] {templateRegion});
-
-      return ResultModel.createError(message);
-    }
-
-    if (diskStore != null && !diskStoreExists(diskStore)) {
-      return ResultModel.createError(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_DISKSTORE_UNKNOWN_DISKSTORE_0,
-          new Object[] {diskStore}));
+      regionAttributes.setDiskStoreName(diskStore);
-    if (isAttributePersistent(regionAttributes)) {
+    if (regionAttributes.getDataPolicy().isPersistent()) {
-
-    Set<ClassName<CacheListener>> cacheListeners = new HashSet<>();
-      Arrays.stream(cacheListener).forEach(c -> cacheListeners.add(c));
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCacheListenerClasses() != null) {
-      cacheListeners.addAll(wrappedTemplateAttributes.getCacheListenerClasses());
+      // clean the old tempalte region's cache listener
+      regionAttributes.getCacheListeners().clear();
+      Arrays.stream(cacheListener)
+          .map(cl -> new DeclarableType(cl.getClassName(), cl.getInitProperties()))
+          .forEach(regionAttributes.getCacheListeners()::add);
-    ClassName<CacheLoader> cacheLoaderClassNameToPersist = null;
-      cacheLoaderClassNameToPersist = cacheLoader;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCacheLoaderClass() != null) {
-      cacheLoaderClassNameToPersist = wrappedTemplateAttributes.getCacheLoaderClass();
+      regionAttributes.setCacheLoader(
+          new DeclarableType(cacheLoader.getClassName(), cacheLoader.getInitProperties()));
-    ClassName<CacheWriter> cacheWriterClassNameToPersist = null;
-      cacheWriterClassNameToPersist = cacheWriter;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCacheWriterClass() != null) {
-      cacheWriterClassNameToPersist = wrappedTemplateAttributes.getCacheWriterClass();
+      regionAttributes.setCacheWriter(
+          new DeclarableType(cacheWriter.getClassName(), cacheWriter.getInitProperties()));
-    String compressorClassNameToPersist = null;
-      compressorClassNameToPersist = compressor;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCompressorClass() != null) {
-      compressorClassNameToPersist = wrappedTemplateAttributes.getCompressorClass();
+      regionAttributes.setCompressor(new ClassNameType(compressor));
-    String keyConstraintToPersist = null;
-      keyConstraintToPersist = keyConstraint;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getKeyConstraintClass() != null) {
-      keyConstraintToPersist = wrappedTemplateAttributes.getKeyConstraintClass();
+      regionAttributes.setKeyConstraint(keyConstraint);
-    String valueConstraintToPersist = null;
-      valueConstraintToPersist = valueConstraint;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getValueConstraintClass() != null) {
-      valueConstraintToPersist = wrappedTemplateAttributes.getValueConstraintClass();
+      regionAttributes.setValueConstraint(valueConstraint);
-    Set<String> asyncEventQueueIdSet = Optional.ofNullable(asyncEventQueueIds)
-        .map(a -> Arrays.stream(a).collect(Collectors.toSet()))
-        .orElse(null);
-    Set<String> gatewaySenderIdSet = Optional.ofNullable(gatewaySenderIds)
-        .map(a -> Arrays.stream(a).collect(Collectors.toSet()))
-        .orElse(null);
+    if (asyncEventQueueIds != null) {
+      regionAttributes.setAsyncEventQueueIds(Strings.join(asyncEventQueueIds, ","));
+    }
-    RegionConfig config = (new RegionConfigFactory()).generate(regionPath, keyConstraintToPersist,
-        valueConstraintToPersist, statisticsEnabled, entryExpirationIdleTime,
-        entryExpirationIdleTimeAction, entryExpirationTTL, entryExpirationTTLAction,
-        entryIdleTimeCustomExpiry,
-        entryTTLCustomExpiry, regionExpirationIdleTime, regionExpirationIdleTimeAction,
-        regionExpirationTTL, regionExpirationTTLAction, evictionAction, evictionMaxMemory,
-        evictionEntryCount, evictionObjectSizer, diskStore, diskSynchronous, enableAsyncConflation,
-        enableSubscriptionConflation, cacheListeners, cacheLoaderClassNameToPersist,
-        cacheWriterClassNameToPersist,
-        asyncEventQueueIdSet, gatewaySenderIdSet, concurrencyChecksEnabled, cloningEnabled,
-        mcastEnabled,
-        concurrencyLevel, partitionArgs, compressorClassNameToPersist, offHeap, regionAttributes);
+    if (offHeap != null) {
+      regionAttributes.setOffHeap(offHeap);
+    }
+    if (concurrencyLevel != null) {
+      regionAttributes.setConcurrencyLevel(concurrencyLevel.toString());
+    }
+    if (enableAsyncConflation != null) {
+      regionAttributes.setEnableAsyncConflation(enableAsyncConflation);
+    }
+    if (cloningEnabled != null) {
+      regionAttributes.setCloningEnabled(cloningEnabled);
+    }
+    if (concurrencyChecksEnabled != null) {
+      regionAttributes.setConcurrencyChecksEnabled(concurrencyChecksEnabled);
+    }
+    if (mcastEnabled != null) {
+      regionAttributes.setMulticastEnabled(mcastEnabled);
+    }
+    if (statisticsEnabled != null) {
+      regionAttributes.setStatisticsEnabled(statisticsEnabled);
+    }
+    if (enableSubscriptionConflation != null) {
+      regionAttributes.setEnableSubscriptionConflation(enableSubscriptionConflation);
+    }
+    if (diskSynchronous != null) {
+      regionAttributes.setDiskSynchronous(diskSynchronous);
+    }
+
+    regionAttributes.updateEntryIdleTime(entryExpirationIdleTime, entryExpirationIdleTimeAction,
+        entryIdleTimeCustomExpiry);
+    regionAttributes.updateEntryTimeToLive(entryExpirationTTL, entryExpirationTTLAction,
+        entryTTLCustomExpiry);
+    regionAttributes.updateRegionIdleTime(regionExpirationIdleTime, regionExpirationIdleTimeAction,
+        null);
+    regionAttributes.updateRegionTimeToLive(regionExpirationTTL, regionExpirationTTLAction, null);
+
+    // unlike expiration attributes, if any single eviction attributes is set, we will replace
+    // the template eviction attributes with this new eviction attributes. we do not combine
+    // the old and new.
+    RegionAttributesType.EvictionAttributes evictionAttributes =
+        RegionAttributesType.EvictionAttributes
+            .generate(evictionAction, evictionMaxMemory, evictionEntryCount, evictionObjectSizer);
+    if (evictionAttributes != null) {
+      regionAttributes.setEvictionAttributes(evictionAttributes);
+    }
-        new CreateRegionFunctionArgs(regionPath, config, ifNotExists);
+        new CreateRegionFunctionArgs(regionPath, regionConfig, ifNotExists);
-      config.getCustomRegionElements().addAll(extensions);
+      regionConfig.getCustomRegionElements().addAll(extensions);
-      resultModel.setConfigObject(new CreateRegionResult(config, regionPath));
+      resultModel.setConfigObject(new CreateRegionResult(regionConfig, regionPath));
-  RegionAttributesWrapper getRegionAttributes(InternalCache cache, String regionPath) {
-    if (!isClusterWideSameConfig(cache, regionPath)) {
-      throw new IllegalStateException(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FORM_REGIONS_EXISTS_BUT_DIFFERENT_SCOPE_OR_DATAPOLICY_USE_DESCRIBE_REGION_FOR_0,
-          regionPath));
-    }
-    RegionAttributesWrapper attributes = null;
-
-    // First check whether the region exists on a this manager, if yes then no
-    // need to use FetchRegionAttributesFunction to fetch RegionAttributes
-    try {
-      attributes = FetchRegionAttributesFunction.getRegionAttributes(cache, regionPath);
-    } catch (IllegalArgumentException e) {
-      /* region doesn't exist on the manager */
-    }
-
-    if (attributes == null) {
-      // find first member which has the region
-      Set<DistributedMember> regionAssociatedMembers = findMembersForRegion(regionPath);
-      if (regionAssociatedMembers != null && !regionAssociatedMembers.isEmpty()) {
-        DistributedMember distributedMember = regionAssociatedMembers.iterator().next();
-        ResultCollector<?, ?> resultCollector =
-            executeFunction(FetchRegionAttributesFunction.INSTANCE, regionPath, distributedMember);
-        List<?> resultsList = (List<?>) resultCollector.getResult();
-
-        if (resultsList != null && !resultsList.isEmpty()) {
-          for (Object object : resultsList) {
-            if (object instanceof IllegalArgumentException) {
-              throw (IllegalArgumentException) object;
-            } else if (object instanceof Throwable) {
-              Throwable th = (Throwable) object;
-              LogWrapper.getInstance(getCache()).info(ExceptionUtils.getStackTrace((th)));
-              throw new IllegalArgumentException(CliStrings.format(
-                  CliStrings.CREATE_REGION__MSG__COULD_NOT_RETRIEVE_REGION_ATTRS_FOR_PATH_0_REASON_1,
-                  regionPath, th.getMessage()));
-            } else { // has to be RegionAttributes
-              @SuppressWarnings("unchecked") // to avoid warning :(
-              RegionAttributesWrapper regAttr = ((RegionAttributesWrapper) object);
-              if (attributes == null) {
-                attributes = regAttr;
-                break;
-              } // attributes null check
-            } // not IllegalArgumentException or other throwable
-          } // iterate over list - there should be only one result in the list
-        } // result list is not null or empty
-      } // regionAssociatedMembers is not-empty
-    } // attributes are null because do not exist on local member
-
-    return attributes;
-  }
-
-    // either C is local, or E is local or E and C are both non-proxy regions. this is to make
-    // sure local, replicate or partition regions have unique names across the entire cluster
-    if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL") || !regionShortcut.isProxy()
-        && (regionBean.getMemberCount() > regionBean.getEmptyNodes())) {
+    // fail if either C is local, or E is local or E and C are both non-proxy regions. this is to
+    // make sure local, replicate or partition regions have unique names across the entire cluster
+    boolean existingRegionIsNotProxy = regionBean.getMemberCount() > regionBean.getEmptyNodes();
+    boolean toBeCreatedIsNotProxy = !regionShortcut.isProxy();
+    if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL") || (toBeCreatedIsNotProxy
+        && existingRegionIsNotProxy)) {
-  private boolean isClusterWideSameConfig(InternalCache cache, String regionPath) {
-    ManagementService managementService = getManagementService();
-
-    DistributedSystemMXBean dsMXBean = managementService.getDistributedSystemMXBean();
-
-    Set<DistributedMember> allMembers = getAllNormalMembers();
-
-    RegionAttributesData regionAttributesToValidateAgainst = null;
-    for (DistributedMember distributedMember : allMembers) {
-      ObjectName regionObjectName;
-      try {
-        regionObjectName = dsMXBean
-            .fetchRegionObjectName(CliUtil.getMemberNameOrId(distributedMember), regionPath);
-        RegionMXBean regionMBean =
-            managementService.getMBeanInstance(regionObjectName, RegionMXBean.class);
-        RegionAttributesData regionAttributes = regionMBean.listRegionAttributes();
-
-        if (regionAttributesToValidateAgainst == null) {
-          regionAttributesToValidateAgainst = regionAttributes;
-        } else if (!(regionAttributesToValidateAgainst.getScope()
-            .equals(regionAttributes.getScope())
-            || regionAttributesToValidateAgainst.getDataPolicy()
-                .equals(regionAttributes.getDataPolicy()))) {
-          return false;
-        }
-      } catch (Exception e) {
-        // ignore
-      }
-    }
-
-    return true;
-  }
-
-  private boolean isAttributePersistent(RegionAttributes attributes) {
-    return attributes != null && attributes.getDataPolicy() != null
-        && attributes.getDataPolicy().toString().contains("PERSISTENT");
-  }
-
-

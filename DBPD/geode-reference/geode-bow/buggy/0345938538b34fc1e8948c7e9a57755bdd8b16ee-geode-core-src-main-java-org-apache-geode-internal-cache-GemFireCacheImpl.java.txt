GEODE-7503: Cleanup GemFireCacheImpl (#4436)

* Move inner-classes to bottom of outer class

* Move fields to top of class

* More fields

* Fixup

* Fix IJ inspection warnings

* Remove bug system ticket numbers

* Cleanup javadocs, toString, and comments

* Use @VisibleForTesting annotation

* Move toString method and backupFiles field

* Pull javadocs up to interfaces.
Define VisibleForTesting methods in InternalCacheForTesting.
Identify more methods as VisibleForTesting.

* Fixup javadocs and minor warnings in Cache interfaces.

* Move unchecked util methods to UncheckedUtils inner class

* Move static constants and fields to top of class.
Rename FIVE_HOURS to FIVE_HOURS_MILLIS.
Review older TODOs.

* Move volatile fields above non-final fields

* Move non-final fields below volatile and final fields

* Move final fields above volatile fields

* wip

* Adjust whitespace and line feeds.
Remove more TODOs and comments.
Fix spelling typo.

* Import various static methods and constants
Adjust more line feeds
Adjust more white space

* Weaken declared types where it makes sense
Add more static imports

* Remove unnecessary uses of final on local vars

* Remove uncessary uses of final on local vars

* Fixup unchecked types
Restore return types to match the interfaces

* Minor cleanup

* Change Consumer<Void> to Runnable (duh)

* Adjust line feeds of large if-statement

* Remove SuppressWarnings

* Fix AssemblyContentsIntegrationTest

* Fixup GemFireCacheImpl

+import static java.lang.System.lineSeparator;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptySet;
+import static java.util.Collections.synchronizedMap;
+import static java.util.Collections.unmodifiableCollection;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.concurrent.Executors.newScheduledThreadPool;
+import static org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace;
+import static org.apache.geode.distributed.ConfigurationPersistenceService.CLUSTER_CONFIG;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_POST_PROCESSOR;
+import static org.apache.geode.distributed.internal.ClusterDistributionManager.ADMIN_ONLY_DM_TYPE;
+import static org.apache.geode.distributed.internal.ClusterDistributionManager.LOCATOR_DM_TYPE;
+import static org.apache.geode.distributed.internal.DistributionConfig.DEFAULT_DURABLE_CLIENT_ID;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+import static org.apache.geode.internal.cache.ColocationHelper.getColocatedChildRegions;
+import static org.apache.geode.internal.cache.GemFireCacheImpl.UncheckedUtils.asDistributedMemberSet;
+import static org.apache.geode.internal.cache.GemFireCacheImpl.UncheckedUtils.createMapArray;
+import static org.apache.geode.internal.cache.GemFireCacheImpl.UncheckedUtils.uncheckedCast;
+import static org.apache.geode.internal.cache.GemFireCacheImpl.UncheckedUtils.uncheckedRegionAttributes;
+import static org.apache.geode.internal.cache.LocalRegion.setThreadInitLevelRequirement;
+import static org.apache.geode.internal.cache.PartitionedRegion.DISK_STORE_FLUSHED;
+import static org.apache.geode.internal.cache.PartitionedRegion.OFFLINE_EQUAL_PERSISTED;
+import static org.apache.geode.internal.cache.PartitionedRegion.PRIMARY_BUCKETS_LOCKED;
+import static org.apache.geode.internal.cache.PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME;
+import static org.apache.geode.internal.cache.control.InternalResourceManager.ResourceType.HEAP_MEMORY;
+import static org.apache.geode.internal.cache.control.InternalResourceManager.ResourceType.OFFHEAP_MEMORY;
+import static org.apache.geode.internal.cache.util.UncheckedUtils.uncheckedRegion;
+import static org.apache.geode.internal.logging.CoreLoggingExecutors.newThreadPoolWithFixedFeed;
+import static org.apache.geode.internal.tcp.ConnectionTable.threadWantsSharedResources;
+import static org.apache.geode.logging.internal.executors.LoggingExecutors.newFixedThreadPool;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.util.SortedMap;
-import java.util.concurrent.Executors;
+import org.apache.geode.cache.asyncqueue.internal.InternalAsyncEventQueue;
-import org.apache.geode.distributed.ConfigurationPersistenceService;
-import org.apache.geode.distributed.ConfigurationProperties;
-import org.apache.geode.internal.cache.control.InternalResourceManager.ResourceType;
-import org.apache.geode.internal.cache.extension.Extensible;
-import org.apache.geode.internal.logging.CoreLoggingExecutors;
-import org.apache.geode.internal.statistics.StatisticsClockSupplier;
-import org.apache.geode.internal.tcp.ConnectionTable;
-import org.apache.geode.logging.internal.executors.LoggingExecutors;
-// TODO: somebody Come up with more reasonable values for {@link #DEFAULT_LOCK_TIMEOUT}, etc.
-@SuppressWarnings("deprecation")
-    DistributionAdvisee, StatisticsClockSupplier {
+    DistributionAdvisee {
-  /** The default number of seconds to wait for a distributed lock */
+  /**
+   * The default number of seconds to wait for a distributed lock
+   */
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultLockTimeout", 60);
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.defaultLockTimeout", 60);
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultLockLease", 120);
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.defaultLockLease", 120);
-  /** The default "copy on read" attribute value */
+  /**
+   * The default "copy on read" attribute value
+   */
-   * getcachefor
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultSearchTimeout", 300);
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.defaultSearchTimeout", 300);
+
+  /**
+   * Name of the default pool.
+   */
+  public static final String DEFAULT_POOL_NAME = "DEFAULT";
+
+  @VisibleForTesting
+  static final int EVENT_THREAD_LIMIT =
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.EVENT_THREAD_LIMIT", 16);
+
+  @VisibleForTesting
+  static final int PURGE_INTERVAL = 1000;
+
+  /**
+   * The number of threads that the QueryMonitor will use to mark queries as cancelled (see
+   * QueryMonitor class for reasons why a query might be cancelled). That processing is very
+   * efficient, so we don't foresee needing to raise this above 1.
+   */
+  private static final int QUERY_MONITOR_THREAD_POOL_SIZE = 1;
+
+  private static final int EVENT_QUEUE_LIMIT =
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.EVENT_QUEUE_LIMIT", 4096);
+
+  private static final int FIVE_HOURS_MILLIS = 5 * 60 * 60 * 1000;
+
+  private static final Pattern DOUBLE_BACKSLASH = Pattern.compile("\\\\");
+
+  /**
+   * Enables {@link #creationStack} when CacheExistsException issues arise in debugging
+   */
+  private static final boolean DEBUG_CREATION_STACK = false;
+
+  private static final boolean XML_PARAMETERIZATION_ENABLED =
+      !Boolean.getBoolean(GEMFIRE_PREFIX + "xml.parameterization.disabled");
+
+  /**
+   * Number of threads used to close PRs in shutdownAll. By default is the number of PRs in the
+   * cache.
+   */
+  private static final int shutdownAllPoolSize =
+      Integer.getInteger(GEMFIRE_PREFIX + "SHUTDOWN_ALL_POOL_SIZE", -1);
+
+  private static final ThreadLocal<GemFireCacheImpl> xmlCache = new ThreadLocal<>();
+
+  /**
+   * System property to limit the max query-execution time. By default its turned off (-1), the time
+   * is set in milliseconds.
+   */
+  @MutableForTesting
+  public static int MAX_QUERY_EXECUTION_TIME =
+      Integer.getInteger(GEMFIRE_PREFIX + "Cache.MAX_QUERY_EXECUTION_TIME", -1);
+
+  /**
+   * Used by unit tests to force cache creation to use a test generated cache.xml
+   */
+  @MutableForTesting
+  @VisibleForTesting
+  public static File testCacheXml;
+
+  /**
+   * If true then when a delta is applied the size of the entry value will be recalculated. If false
+   * (the default) then the size of the entry value is unchanged by a delta application. Not a final
+   * so that tests can change this value.
+   *
+   * @since GemFire h****** 6.1.2.9
+   */
+  @MutableForTesting
+  static boolean DELTAS_RECALCULATE_SIZE =
+      Boolean.getBoolean(GEMFIRE_PREFIX + "DELTAS_RECALCULATE_SIZE");
-   * Name of the default pool.
+   * Break any potential circularity in {@link #loadEmergencyClasses()}.
-  public static final String DEFAULT_POOL_NAME = "DEFAULT";
-
-
-  /**
-   * The number of threads that the QueryMonitor will use to mark queries as cancelled
-   * (see QueryMonitor class for reasons why a query might be cancelled).
-   * That processing is very efficient, so we don't foresee needing to raise this above 1.
-   */
-  private static final int QUERY_MONITOR_THREAD_POOL_SIZE = 1;
-
-  /**
-   * If true then when a delta is applied the size of the entry value will be recalculated. If false
-   * (the default) then the size of the entry value is unchanged by a delta application. Not a final
-   * so that tests can change this value.
-   *
-   * TODO: move or static or encapsulate with interface methods
-   *
-   * @since GemFire h****** 6.1.2.9
-   */
-  @MutableForTesting
-  static boolean DELTAS_RECALCULATE_SIZE =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DELTAS_RECALCULATE_SIZE");
-
-  private static final int EVENT_QUEUE_LIMIT =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.EVENT_QUEUE_LIMIT", 4096);
-
-  static final int EVENT_THREAD_LIMIT =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.EVENT_THREAD_LIMIT", 16);
-
-  /**
-   * System property to limit the max query-execution time. By default its turned off (-1), the time
-   * is set in milliseconds.
-   */
-  @MutableForTesting
-  public static int MAX_QUERY_EXECUTION_TIME =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.MAX_QUERY_EXECUTION_TIME", -1);
-
-  /**
-   * System property to disable query monitor even if resource manager is in use
-   */
-  private final boolean queryMonitorDisabledForLowMem = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY");
+  @MakeNotStatic
+  private static volatile boolean emergencyClassesLoaded;
-  private static boolean queryMonitorRequiredForResourceManager = false;
+  private static boolean queryMonitorRequiredForResourceManager;
-  /** time in milliseconds */
-  private static final int FIVE_HOURS = 5 * 60 * 60 * 1000;
+  /**
+   * TODO: remove static from defaultDiskStoreName and move methods to InternalCache
+   */
+  @MakeNotStatic
+  private static String defaultDiskStoreName = DiskStoreFactory.DEFAULT_DISK_STORE_NAME;
-  private static final Pattern DOUBLE_BACKSLASH = Pattern.compile("\\\\");
-
-  private volatile ConfigurationResponse configurationResponse;
+  /**
+   * System property to disable query monitor even if resource manager is in use
+   */
+  private final boolean queryMonitorDisabledForLowMem =
+      Boolean.getBoolean(GEMFIRE_PREFIX + "Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY");
-  private PoolFactory poolFactory;
-
-  /**
-   * It is not final to allow cache.xml parsing to set it.
-   */
-  private Pool defaultPool;
+  private final PoolFactory poolFactory;
-  private volatile boolean isInitialized;
-
-  volatile boolean isClosing = false; // used in Stopper inner class
-
-  /** Amount of time (in seconds) to wait for a distributed lock */
-  private int lockTimeout = DEFAULT_LOCK_TIMEOUT;
-
-  /** Amount of time a lease of a distributed lock lasts */
-  private int lockLease = DEFAULT_LOCK_LEASE;
-
-  /** Amount of time to wait for a {@code netSearch} to complete */
-  private int searchTimeout = DEFAULT_SEARCH_TIMEOUT;
-
-  /** Date on which this instances was created */
+  /**
+   * Date on which this instances was created
+   */
-  /** thread pool for event dispatching */
+  /**
+   * Thread pool for event dispatching
+   */
-   * the list of all cache servers. CopyOnWriteArrayList is used to allow concurrent add, remove and
+   * List of all cache servers. CopyOnWriteArrayList is used to allow concurrent add, remove and
+
-  private final List<CacheServer> unmodifiableAllCacheServers =
-      Collections.unmodifiableList(allCacheServers);
+  private final List<CacheServer> unmodifiableAllCacheServers = unmodifiableList(allCacheServers);
-   * Controls updates to the list of all gateway senders
-   *
-   * @see #allGatewaySenders
+   * Controls updates to the list of all gateway senders {@link #allGatewaySenders}.
-   * the set of all gateway senders. It may be fetched safely (for enumeration), but updates must by
-   * synchronized via {@link #allGatewaySendersLock}
-   */
-  private volatile Set<GatewaySender> allGatewaySenders = Collections.emptySet();
-
-  /**
-   * The list of all async event queues added to the cache. CopyOnWriteArrayList is used to allow
+   * List of all async event queues added to the cache. CopyOnWriteArrayList is used to allow
-   * The list of all async event queues added to the cache. CopyOnWriteArrayList is used to allow
+   * List of all async event queues added to the cache. CopyOnWriteArrayList is used to allow
-   * Fix for 42051 This is a map of regions that are in the process of being destroyed. We could
-   * potentially leave the regions in the pathToRegion map, but that would entail too many changes
-   * at this point in the release. We need to know which regions are being destroyed so that a
-   * profile exchange can get the persistent id of the destroying region and know not to persist
-   * that ID if it receives it as part of the persistent view.
+   * Map of regions that are in the process of being destroyed. We could potentially leave the
+   * regions in the pathToRegion map, but that would entail too many changes at this point in the
+   * release. We need to know which regions are being destroyed so that a profile exchange can get
+   * the persistent id of the destroying region and know not to persist that ID if it receives it as
+   * part of the persistent view.
-   * conflict resolver for WAN, if any
-   *
-   * GuardedBy {@link #allGatewayHubsLock}
+   * Transaction manager for this cache.
-  private GatewayConflictResolver gatewayConflictResolver;
-
-  /** Is this is "server" cache? */
-  private boolean isServer = false;
-
-  /** transaction manager for this cache */
-  private RestAgent restAgent;
-
-  private boolean isRESTServiceRunning = false;
-
-  /** Copy on Read feature for all read operations e.g. get */
-  private volatile boolean copyOnRead = DEFAULT_COPY_ON_READ;
-
-  /** The named region attributes registered with this cache. */
+  /**
+   * Named region attributes registered with this cache.
+   */
-      Collections.synchronizedMap(new HashMap<>());
+      synchronizedMap(new HashMap<>());
-   * if this cache was forced to close due to a forced-disconnect, we retain a
-   * ForcedDisconnectException that can be used as the cause
-   */
-  private boolean forcedDisconnect;
-
-  /**
-   * if this cache was forced to close due to a forced-disconnect or system failure, this keeps
-   * track of the reason
-   */
-  private volatile Throwable disconnectCause;
-
-  /** context where this cache was created -- for debugging, really... */
-  private Exception creationStack = null;
-
-  /**
-   * a system timer task for cleaning up old bridge thread event entries
+   * System timer task for cleaning up old bridge thread event entries.
-   * DistributedLockService for PartitionedRegions. Remains null until the first PartitionedRegion
-   * is created. Destroyed by GemFireCache when closing the cache. Protected by synchronization on
-   * this GemFireCache.
-   *
-   * GuardedBy prLockServiceLock
-   */
-  private DistributedLockService prLockService;
-
-  /**
-   * lock used to access prLockService
+   * Synchronization mutex for prLockService.
-   * DistributedLockService for GatewaySenders. Remains null until the first GatewaySender is
-   * created. Destroyed by GemFireCache when closing the cache.
-   *
-   * GuardedBy gatewayLockServiceLock
-   */
-  private volatile DistributedLockService gatewayLockService;
-
-  /**
-   * Lock used to access gatewayLockService
+   * Synchronization mutex for gatewayLockService.
-  private HeapEvictor heapEvictor = null;
-
-  private OffHeapEvictor offHeapEvictor = null;
-
-  private ResourceEventsListener resourceEventsListener;
-
-  /**
-   * Enabled when CacheExistsException issues arise in debugging
-   *
-   * @see #creationStack
-   */
-  private static final boolean DEBUG_CREATION_STACK = false;
-
-  private volatile QueryMonitor queryMonitor;
-
-  /** {@link PropertyResolver} to resolve ${} type property strings */
+  /**
+   * Resolves ${} type property strings.
+   */
-  private static final boolean XML_PARAMETERIZATION_ENABLED =
-      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "xml.parameterization.disabled");
-
-   * {@link ExtensionPoint} support.
-   *
-  private final SimpleExtensionPoint<Cache> extensionPoint = new SimpleExtensionPoint<>(this, this);
+  private final ExtensionPoint<Cache> extensionPoint = new SimpleExtensionPoint<>(this, this);
-  /** Map of Futures used to track Regions that are being reinitialized */
+  /**
+   * Map of futures used to track regions that are being reinitialized.
+   */
-  private final Consumer<Void> typeRegistryClose;
+  private final Runnable typeRegistryClose;
+  private final Stopper stopper = new Stopper();
+
+  private final boolean disableDisconnectDsOnCacheClose =
+      Boolean.getBoolean(GEMFIRE_PREFIX + "DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE");
+
+  private final ConcurrentMap<String, DiskStoreImpl> diskStores = new ConcurrentHashMap<>();
+
+  private final ConcurrentMap<String, DiskStoreImpl> regionOwnedDiskStores =
+      new ConcurrentHashMap<>();
+
+  /**
+   * Synchronization mutex for {@link #ccpTimer}.
+   */
+  private final Object ccpTimerMutex = new Object();
+
+  private final ExpirationScheduler expirationScheduler;
+
+  /**
+   * TODO make this a simple int guarded by riWaiters and get rid of the double-check
+   */
+  private final AtomicInteger registerInterestsInProgress = new AtomicInteger();
+
+  private final List<SimpleWaiter> riWaiters = new ArrayList<>();
+
+  private final InternalCacheForClientAccess cacheForClients =
+      new InternalCacheForClientAccess(this);
+
+  private volatile ConfigurationResponse configurationResponse;
+
+  private volatile boolean isInitialized;
+
+  private volatile boolean isClosing;
+
+  /**
+   * Set of all gateway senders. It may be fetched safely (for enumeration), but updates must by
+   * synchronized via {@link #allGatewaySendersLock}
+   */
+  private volatile Set<GatewaySender> allGatewaySenders = emptySet();
+
+  /**
+   * Copy on Read feature for all read operations.
+   */
+  private volatile boolean copyOnRead = DEFAULT_COPY_ON_READ;
+
+  /**
+   * Reason this cache was forced to close due to a forced-disconnect or system failure.
+   */
+  private volatile Throwable disconnectCause;
+
+  /**
+   * DistributedLockService for GatewaySenders. Remains null until the first GatewaySender is
+   * created. Destroyed by GemFireCache when closing the cache. Guarded by gatewayLockServiceLock.
+   */
+  private volatile DistributedLockService gatewayLockService;
+
+  private volatile QueryMonitor queryMonitor;
+
+  /**
+   * Not final to allow cache.xml parsing to set it.
+   */
+  private Pool defaultPool;
+
+  /**
+   * Amount of time (in seconds) to wait for a distributed lock
+   */
+  private int lockTimeout = DEFAULT_LOCK_TIMEOUT;
+
+  /**
+   * Amount of time a lease of a distributed lock lasts
+   */
+  private int lockLease = DEFAULT_LOCK_LEASE;
+
+  /**
+   * Amount of time to wait for a {@code netSearch} to complete
+   */
+  private int searchTimeout = DEFAULT_SEARCH_TIMEOUT;
+
+  /**
+   * Conflict resolver for WAN, if any. Guarded by {@link #allGatewayHubsLock}.
+   */
+  private GatewayConflictResolver gatewayConflictResolver;
+
+  /**
+   * True if this is a server cache.
+   */
+  private boolean isServer;
+
+  private RestAgent restAgent;
+
+  private boolean isRESTServiceRunning;
+
+  /**
+   * True if this cache was forced to close due to a forced-disconnect.
+   */
+  private boolean forcedDisconnect;
+
+  /**
+   * Context where this cache was created for debugging.
+   */
+  private Exception creationStack;
+
+  /**
+   * DistributedLockService for PartitionedRegions. Remains null until the first PartitionedRegion
+   * is created. Destroyed by GemFireCache when closing the cache. Protected by synchronization on
+   * prLockService. Guarded by prLockServiceLock.
+   */
+  private DistributedLockService prLockService;
+
+  private HeapEvictor heapEvictor;
+
+  private OffHeapEvictor offHeapEvictor;
+
+  private ResourceEventsListener resourceEventsListener;
+
+  /**
+   * Set to true during a cache close if user requested durable subscriptions to be kept.
+   *
+   * @since GemFire 5.7
+   */
+  private boolean keepAlive;
+
+  /**
+   * Timer for {@link CacheClientProxy}. Guarded by {@link #ccpTimerMutex}.
+   */
+  private SystemTimer ccpTimer;
+
+  private int cancelCount;
+
+  /**
+   * Some tests pass value in via constructor. Product code sets value after construction.
+   */
+  private TypeRegistry pdxRegistry;
+
+  private Declarable initializer;
+
+  private Properties initializerProps;
+
+  private List<File> backupFiles = emptyList();
+
-    // this works around jdk bug 6427854, reported in ticket #44434
+    // this works around jdk bug 6427854
-    if (lastError == 1 || lastError == 12) { // EPERM || ENOMEM
+    if (lastError == 1 || lastError == 12) {
+      // if EPERM || ENOMEM
-   * This is for debugging cache-open issues (esp. {@link CacheExistsException})
-   */
-  @Override
-  public String toString() {
-    final StringBuilder sb = new StringBuilder();
-    sb.append("GemFireCache[");
-    sb.append("id = ").append(System.identityHashCode(this));
-    sb.append("; isClosing = ").append(isClosing);
-    sb.append("; isShutDownAll = ").append(isCacheAtShutdownAll());
-    sb.append("; created = ").append(creationDate);
-    sb.append("; server = ").append(isServer);
-    sb.append("; copyOnRead = ").append(copyOnRead);
-    sb.append("; lockLease = ").append(lockLease);
-    sb.append("; lockTimeout = ").append(lockTimeout);
-    if (creationStack != null) {
-      // TODO: eliminate anonymous inner class and maybe move this to ExceptionUtils
-      sb.append(System.lineSeparator()).append("Creation context:").append(System.lineSeparator());
-      OutputStream os = new OutputStream() {
-        @Override
-        public void write(int i) {
-          sb.append((char) i);
-        }
-      };
-      PrintStream ps = new PrintStream(os);
-      creationStack.printStackTrace(ps);
-    }
-    sb.append("]");
-    return sb.toString();
-  }
-
-  /**
-   * Returns the last created instance of GemFireCache
+   * Returns the last created instance of GemFireCache.
-    InternalDistributedSystem system = InternalDistributedSystem.getAnyInstance();
+    InternalDistributedSystem system = getAnyInstance();
+
-
-    final GemFireCacheImpl result = getInstance();
+    GemFireCacheImpl result = getInstance();
-      throw result.getCacheClosedException(
-          "The cache has been closed.");
+      throw result.getCacheClosedException("The cache has been closed.");
-    throw new CacheClosedException(
-        "A cache has not yet been created.");
+    throw new CacheClosedException("A cache has not yet been created.");
-   * @deprecated use DM.getExistingCache instead.
+   * @deprecated Please use {@link DistributionManager#getExistingCache()} instead.
-   * Pdx is allowed to obtain the cache even while it is being closed
+   * Returns instance to pdx even while it is being closed.
-   * @deprecated Rather than fishing for a cache with this static method, use a cache that is passed
-   *             in to your method.
+   * @deprecated Please use a cache that is passed to your method instead.
-
+
+   * <p>
-    this(isClient, poolFactory, internalDistributedSystem, cacheConfig, useAsyncEventListeners,
+    this(isClient,
+        poolFactory,
+        internalDistributedSystem,
+        cacheConfig,
+        useAsyncEventListeners,
-        VOID -> TypeRegistry.init(),
-        VOID -> TypeRegistry.open(),
-        VOID -> TypeRegistry.close(),
+        TypeRegistry::init,
+        TypeRegistry::open,
+        TypeRegistry::close,
-  GemFireCacheImpl(boolean isClient, PoolFactory poolFactory,
-      InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig,
-      boolean useAsyncEventListeners, TypeRegistry typeRegistry,
+  GemFireCacheImpl(boolean isClient,
+      PoolFactory poolFactory,
+      InternalDistributedSystem internalDistributedSystem,
+      CacheConfig cacheConfig,
+      boolean useAsyncEventListeners,
+      TypeRegistry typeRegistry,
-      Consumer<Void> typeRegistryInit,
-      Consumer<Void> typeRegistryOpen,
-      Consumer<Void> typeRegistryClose,
+      Runnable typeRegistryInit,
+      Runnable typeRegistryOpen,
+      Runnable typeRegistryClose,
-    // Synchronized to prevent a new cache from being created
-    // before an old one has finished closing
+    // Synchronized to prevent a new cache from being created before an old one finishes closing
-      // start JTA transaction manager within this synchronized block
-      // to prevent race with cache close.
+      // start JTA transaction manager within synchronization to prevent race with cache close
-        // apply the cluster's properties configuration and initialize security using that
-        // configuration
-        ccLoader.applyClusterPropertiesConfiguration(configurationResponse,
-            system.getConfig());
+        // apply the cluster's properties config and initialize security using that config
+        ccLoader.applyClusterPropertiesConfiguration(configurationResponse, system.getConfig());
-        // We only support management on members of a distributed system
-        // Should do this: if (!getSystem().isLoner()) {
-        // but it causes quickstart.CqClientTest to hang
+        // only support management on members of a distributed system
-      if (dm.getDMType() == ClusterDistributionManager.ADMIN_ONLY_DM_TYPE) {
+      if (dm.getDMType() == ADMIN_ONLY_DM_TYPE) {
-        eventThreadPool = CoreLoggingExecutors.newThreadPoolWithFixedFeed("Message Event Thread",
+        eventThreadPool = newThreadPoolWithFixedFeed("Message Event Thread",
-              ConnectionTable.threadWantsSharedResources();
+              threadWantsSharedResources();
-      getInternalResourceManager().addResourceListener(ResourceType.HEAP_MEMORY, getHeapEvictor());
+      getInternalResourceManager().addResourceListener(HEAP_MEMORY, getHeapEvictor());
-      /*
-       * Only bother creating an off-heap evictor if we have off-heap memory enabled.
-       */
+      // Only bother creating an off-heap evictor if we have off-heap memory enabled.
-        getInternalResourceManager().addResourceListener(ResourceType.OFFHEAP_MEMORY,
-            getOffHeapEvictor());
+        getInternalResourceManager().addResourceListener(OFFHEAP_MEMORY, getOffHeapEvictor());
-      typeRegistryInit.accept(null);
+      typeRegistryInit.run();
-      typeRegistryOpen.accept(null);
+      typeRegistryOpen.run();
-        // Initialize the QRM thread frequency to default (1 second )to prevent spill
-        // over from previous Cache , as the interval is stored in a static
-        // volatile field.
+        // Initialize the QRM thread frequency to default (1 second )to prevent spill over from
+        // previous Cache, as the interval is stored in a static volatile field.
-    } // synchronized
+    }
+  /**
+   * This is for debugging cache-open issues such as {@link CacheExistsException}.
+   */
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("GemFireCache[");
+    sb.append("id = ").append(System.identityHashCode(this));
+    sb.append("; isClosing = ").append(isClosing);
+    sb.append("; isShutDownAll = ").append(isCacheAtShutdownAll());
+    sb.append("; created = ").append(creationDate);
+    sb.append("; server = ").append(isServer);
+    sb.append("; copyOnRead = ").append(copyOnRead);
+    sb.append("; lockLease = ").append(lockLease);
+    sb.append("; lockTimeout = ").append(lockTimeout);
+    if (creationStack != null) {
+      sb.append(lineSeparator()).append("Creation context:").append(lineSeparator());
+      sb.append(getStackTrace(creationStack));
+    }
+    sb.append("]");
+    return sb.toString();
+  }
+
-  /** generate XML for the cache before shutting down due to forced disconnect */
-    boolean sharedConfigEnabled =
-        getDistributionManager().getConfig().getUseSharedConfiguration();
+    boolean sharedConfigEnabled = getDistributionManager().getConfig().getUseSharedConfiguration();
-    if (!Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "autoReconnect-useCacheXMLFile")
+    if (!Boolean.getBoolean(GEMFIRE_PREFIX + "autoReconnect-useCacheXMLFile")
-      for (final Object o : getCacheServers()) {
+      for (Object o : getCacheServers()) {
-      ccLoader.applyClusterPropertiesConfiguration(configurationResponse,
-          system.getConfig());
+      ccLoader.applyClusterPropertiesConfiguration(configurationResponse, system.getConfig());
-   * Initialize the EventTracker's timer task. This is stored for tracking and shutdown purposes
+   * Initialize the EventTracker's timer task for tracking and shutdown purposes.
-    long lifetimeInMillis =
-        Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "messageTrackingTimeout",
-            PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT / 3);
+    long lifetimeInMillis = Long.getLong(GEMFIRE_PREFIX + "messageTrackingTimeout",
+        PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT / 3);
-  /**
-   * Used by Hydra tests to get handle of Rest Agent
-   *
-   */
+  @VisibleForTesting
-   * Request the shared configuration from the locator(s) which have the Cluster config service
-   * running
+   * Request the cluster configuration from the locator(s) if cluster config service is running.
+  @VisibleForTesting
-    final DistributionConfig config = system.getConfig();
+    DistributionConfig config = system.getConfig();
-    if (dm.getDMType() == ClusterDistributionManager.LOCATOR_DM_TYPE || isClient
-        || Locator.getLocator() != null) {
+    if (dm.getDMType() == LOCATOR_DM_TYPE || isClient || Locator.getLocator() != null) {
-      Configuration clusterConfig =
-          response.getRequestedConfiguration().get(ConfigurationPersistenceService.CLUSTER_CONFIG);
+      Configuration clusterConfig = response.getRequestedConfiguration().get(CLUSTER_CONFIG);
-        if (clusterSecProperties.containsKey(ConfigurationProperties.SECURITY_MANAGER)) {
+        if (clusterSecProperties.containsKey(SECURITY_MANAGER)) {
-        } else {
-          logger.info(
-              "The cache has been created with use-cluster-configuration=false. It will not receive any cluster configuration");
-          return null;
+        logger.info(
+            "The cache has been created with use-cluster-configuration=false. It will not receive any cluster configuration");
+        return null;
-      if (isMisConfigured(clusterSecProperties, serverSecProperties,
-          ConfigurationProperties.SECURITY_MANAGER)
-          || isMisConfigured(clusterSecProperties, serverSecProperties,
-              ConfigurationProperties.SECURITY_POST_PROCESSOR)) {
+      if (isMisConfigured(clusterSecProperties, serverSecProperties, SECURITY_MANAGER)
+          || isMisConfigured(clusterSecProperties, serverSecProperties, SECURITY_POST_PROCESSOR)) {
-      throw new GemFireConfigException(
-          "cluster configuration service not available", e);
+      throw new GemFireConfigException("cluster configuration service not available", e);
-   * When called, clusterProps and serverProps and key could not be null
+   * Arguments must not be null.
+  @VisibleForTesting
+    requireNonNull(clusterProps);
+    requireNonNull(serverProps);
+    requireNonNull(key);
+
-    if (StringUtils.isBlank(serverPropValue))
+    if (StringUtils.isBlank(serverPropValue)) {
+    }
-    if (StringUtils.isBlank(clusterPropValue))
+    if (StringUtils.isBlank(clusterPropValue)) {
+    }
-  /**
-   * Used by unit tests to force cache creation to use a test generated cache.xml
-   */
-  @MutableForTesting
-  public static File testCacheXml = null;
-
-  /**
-   * @return true if cache is created using a ClientCacheFactory
-   * @see #hasPool()
-   */
-  /**
-   * Method to check for GemFire client. In addition to checking for ClientCacheFactory, this method
-   * checks for any defined pools.
-   *
-   * @return true if the cache has pools declared
-   */
-  /**
-   * May return null (even on a client).
-   */
-  /**
-   * Perform initialization, solve the early escaped reference problem by putting publishing
-   * references to this instance in this method (vs. the constructor).
-   */
-    // moved this after initializeDeclarativeCache because in the future
-    // distributed system creation will not happen until we have read
-    // cache.xml file.
-    // For now this needs to happen before cache.xml otherwise
-    // we will not be ready for all the events that cache.xml
-    // processing can deliver (region creation, etc.).
-    // This call may need to be moved inside initializeDeclarativeCache.
-    jmxAdvisor.initializationGate(); // Entry to GemFire Management service
+    // Entry to GemFire Management service
+    jmxAdvisor.initializationGate();
-      logger.error("Cache initialization for {} failed because: {}", this, e); // fix GEODE-3038
+      logger.error("Cache initialization for {} failed because: {}", this, e);
-          close(); // fix for bug 34041
+          close();
+  @VisibleForTesting
-   * Initialize any services that provided as extensions to the cache using the service loader
-   * mechanism.
+   * Initialize any services provided as extensions to the cache using service loader.
-    return system.getDistributedMember()
-        .getVmKind() != ClusterDistributionManager.LOCATOR_DM_TYPE
-        && system.getDistributedMember()
-            .getVmKind() != ClusterDistributionManager.ADMIN_ONLY_DM_TYPE
+    return system.getDistributedMember().getVmKind() != LOCATOR_DM_TYPE
+        && system.getDistributedMember().getVmKind() != ADMIN_ONLY_DM_TYPE
-  private void startRestAgentServer(GemFireCacheImpl cache) {
+  private void startRestAgentServer(InternalCache cache) {
-
-
-    if (getMyId().getVmKind() == ClusterDistributionManager.LOCATOR_DM_TYPE) {
+    if (getMyId().getVmKind() == LOCATOR_DM_TYPE) {
+
-            String.format("Could not convert XML file %s to an URL.",
-                xmlFile),
-            ex);
+            String.format("Could not convert XML file %s to an URL.", xmlFile), ex);
+
-              String.format("Declarative Cache XML file/resource %s does not exist.",
-                  xmlFile));
-        } else {
-          throw new CacheXmlException(
-              String.format("Declarative XML file %s is not a file.",
-                  xmlFile));
+              String.format("Declarative Cache XML file/resource %s does not exist.", xmlFile));
+        throw new CacheXmlException(
+            String.format("Declarative XML file %s is not a file.", xmlFile));
-   * Initializes the contents of this {@code Cache} according to the declarative caching XML file
+   * Initialize the contents of this {@code Cache} according to the declarative caching XML file
-   *
-      return; // nothing needs to be done
+      // nothing needs to be done
+      return;
-      throw new CacheXmlException(
-          String.format("While opening Cache XML %s the following error occurred %s",
-              url.toString(), ex));
+      throw new CacheXmlException(String.format(
+          "While opening Cache XML %s the following error occurred %s", url.toString(), ex));
-      throw new CacheXmlException(String.format("While reading Cache XML %s. %s",
-          url, ex.getMessage()), ex.getCause());
+      throw new CacheXmlException(
+          String.format("While reading Cache XML %s. %s", url, ex.getMessage()), ex.getCause());
-        final String lineSeparator = System.getProperty("line.separator");
-            sb.append(lineSeparator).append(line);
+            sb.append(lineSeparator()).append(line);
-      logger.info("Initializing cache using {}:{}",
-          new Object[] {url.toString(), sb.toString()});
+      logger.info("Initializing cache using {}:{}", url, sb);
+
-      logger.info(
-          "Initializing cache using {}:{}",
-          new Object[] {"generated description from old cache", cacheXmlDescription});
+      logger.info("Initializing cache using {}:{}", "generated description from old cache",
+          cacheXmlDescription);
-      if (getMyId().getVmKind() == ClusterDistributionManager.LOCATOR_DM_TYPE) {
+      if (getMyId().getVmKind() == LOCATOR_DM_TYPE) {
-  /**
-   * Call to make this vm's dynamic region factory ready. Public so it can be called from
-   * CacheCreation during xml processing
-   */
-      throw new GemFireCacheException(
-          "dynamic region initialization failed",
-          ce);
+      throw new GemFireCacheException("dynamic region initialization failed", ce);
-  /**
-   * create diskStore factory with default attributes
-   *
-   * @since GemFire prPersistSprint2
-   */
-  /**
-   * create diskStore factory with predefined attributes
-   *
-   * @since GemFire prPersistSprint2
-   */
-  class Stopper extends CancelCriterion {
-
-    @Override
-    public String cancelInProgress() {
-      String reason = getDistributedSystem().getCancelCriterion().cancelInProgress();
-      if (reason != null) {
-        return reason;
-      }
-      if (disconnectCause != null) {
-        return disconnectCause.getMessage();
-      }
-      if (isClosing) {
-        return "The cache is closed."; // this + ": closed";
-      }
-      return null;
-    }
-
-    @Override
-    public RuntimeException generateCancelledException(Throwable throwable) {
-      String reason = cancelInProgress();
-      if (reason == null) {
-        return null;
-      }
-      RuntimeException result =
-          getDistributedSystem().getCancelCriterion().generateCancelledException(throwable);
-      if (result != null) {
-        return result;
-      }
-      if (disconnectCause == null) {
-        // No root cause, specify the one given and be done with it.
-        return new CacheClosedException(reason, throwable);
-      }
-
-      if (throwable == null) {
-        // Caller did not specify any root cause, so just use our own.
-        return new CacheClosedException(reason, disconnectCause);
-      }
-
-      // Attempt to stick rootCause at tail end of the exception chain.
-      try {
-        ThrowableUtils.setRootCause(throwable, disconnectCause);
-        return new CacheClosedException(reason, throwable);
-      } catch (IllegalStateException ignore) {
-        // Bug 39496 (JRockit related) Give up. The following
-        // error is not entirely sane but gives the correct general picture.
-        return new CacheClosedException(reason, disconnectCause);
-      }
-    }
-  }
-
-  private final Stopper stopper = new Stopper();
-
-  /** return true if the cache was closed due to being shunned by other members */
-  /** return a CacheClosedException with the given reason */
-  /** return a CacheClosedException with the given reason and cause */
-  /** if the cache was forcibly closed this exception will reflect the cause */
+  @VisibleForTesting
-  /**
-   * Set to true during a cache close if user requested durable subscriptions to be kept.
-   *
-   * @since GemFire 5.7
-   */
-  private boolean keepAlive;
-
-  /**
-   * Returns true if durable subscriptions (registrations and queries) should be preserved.
-   *
-   * @since GemFire 5.7
-   */
-   * break any potential circularity in {@link #loadEmergencyClasses()}
-   */
-  @MakeNotStatic
-  private static volatile boolean emergencyClassesLoaded = false;
-
-  /**
-   * Ensure that all the necessary classes for closing the cache are loaded
+   * Ensure that all the necessary classes for closing the cache are loaded.
-    if (emergencyClassesLoaded)
+    if (emergencyClassesLoaded) {
+    }
-    // leave the PdxSerializer set if we have one to prevent 43412
+    // leave the PdxSerializer set if we have one
-  /**
-   * Number of threads used to close PRs in shutdownAll. By default is the number of PRs in the
-   * cache
-   */
-  private static final int shutdownAllPoolSize =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "SHUTDOWN_ALL_POOL_SIZE", -1);
-
-    for (final PartitionedRegion pr : prSubMap.values()) {
+    for (PartitionedRegion pr : prSubMap.values()) {
+
+
-          throw new InternalGemFireError(
-              "unexpected exception");
+          throw new InternalGemFireError("unexpected exception");
-        // bug 44031 requires multithread shutDownAll should be grouped
-        // by root region. However, shutDownAllDuringRecovery.conf test revealed that
-        // we have to close colocated child regions first.
-        // Now check all the PR, if anyone has colocate-with attribute, sort all the
-        // PRs by colocation relationship and close them sequentially, otherwise still
-        // group them by root region.
-        SortedMap<String, Map<String, PartitionedRegion>> prTrees = getPRTrees();
+        // multithread shutDownAll should be grouped by root region. However, we have to close
+        // colocated child regions first. Now check all the PR, if anyone has colocate-with
+        // attribute, sort all the PRs by colocation relationship and close them sequentially,
+        // otherwise still group them by root region.
+
+        Map<String, Map<String, PartitionedRegion>> prTrees = getPRTrees();
-          for (final Map<String, PartitionedRegion> prSubMap : prTrees.values()) {
+          for (Map<String, PartitionedRegion> prSubMap : prTrees.values()) {
+            // for each root
-              ConnectionTable.threadWantsSharedResources();
+              threadWantsSharedResources();
-          } // for each root
+          }
-          for (final Map<String, PartitionedRegion> prSubMap : prTrees.values()) {
+          for (Map<String, PartitionedRegion> prSubMap : prTrees.values()) {
-    return LoggingExecutors
-        .newFixedThreadPool("ShutdownAll-", true,
-            shutdownAllPoolSize == -1 ? size : shutdownAllPoolSize);
+    return newFixedThreadPool("ShutdownAll-", true,
+        shutdownAllPoolSize == -1 ? size : shutdownAllPoolSize);
-        if (partitionedRegion.isDataStore() && partitionedRegion.getDataStore() != null
+        if (partitionedRegion.isDataStore()
+            && partitionedRegion.getDataStore() != null
-          @SuppressWarnings("unchecked")
-          Map<InternalDistributedMember, PersistentMemberID>[] bucketMaps = new Map[numBuckets];
+          Map<InternalDistributedMember, PersistentMemberID>[] bucketMaps =
+              createMapArray(numBuckets);
-            // get map <InternalDistributedMember, persistentID> for this bucket's
-            // remote members
+            // get map <InternalDistributedMember, persistentID> for this bucket's remote members
-          partitionedRegion.setShutDownAllStatus(PartitionedRegion.PRIMARY_BUCKETS_LOCKED);
+          partitionedRegion.setShutDownAllStatus(PRIMARY_BUCKETS_LOCKED);
-          partitionedRegion.getRegionAdvisor()
-              .waitForProfileStatus(PartitionedRegion.PRIMARY_BUCKETS_LOCKED);
+          partitionedRegion.getRegionAdvisor().waitForProfileStatus(PRIMARY_BUCKETS_LOCKED);
-            partitionedRegion.setShutDownAllStatus(PartitionedRegion.DISK_STORE_FLUSHED);
+            partitionedRegion.setShutDownAllStatus(DISK_STORE_FLUSHED);
-            partitionedRegion.getRegionAdvisor()
-                .waitForProfileStatus(PartitionedRegion.DISK_STORE_FLUSHED);
+            partitionedRegion.getRegionAdvisor().waitForProfileStatus(DISK_STORE_FLUSHED);
-          } // async write
+          }
-          // persist other members to OFFLINE_EQUAL for each bucket region
-          // iterate through all the bucketMaps and exclude the items whose
-          // idm is no longer online
+          // persist other members to OFFLINE_EQUAL for each bucket region iterate through all the
+          // bucketMaps and exclude the items whose idm is no longer online
-          partitionedRegion.setShutDownAllStatus(PartitionedRegion.OFFLINE_EQUAL_PERSISTED);
+          partitionedRegion.setShutDownAllStatus(OFFLINE_EQUAL_PERSISTED);
-          partitionedRegion.getRegionAdvisor()
-              .waitForProfileStatus(PartitionedRegion.OFFLINE_EQUAL_PERSISTED);
+          partitionedRegion.getRegionAdvisor().waitForProfileStatus(OFFLINE_EQUAL_PERSISTED);
-        } // dataStore
+        }
-        // after done all steps for buckets, close partitionedRegion
-        // close accessor directly
+        // after done all steps for buckets, close partitionedRegionÂ close accessor directly
-          throw new Error(
-              "CacheWriterException should not be thrown in localDestroyRegion",
-              e);
+          throw new Error("CacheWriterException should not be thrown in localDestroyRegion", e);
-          throw new Error(
-              "TimeoutException should not be thrown in localDestroyRegion",
-              e);
+          throw new Error("TimeoutException should not be thrown in localDestroyRegion", e);
-      } // synchronized
+      }
-  /**
-   * Gets or lazily creates the PartitionedRegion distributed lock service. This call will
-   * synchronize on this GemFireCache.
-   *
-   * @return the PartitionedRegion distributed lock service
-   */
-          prLockService =
-              DLockService.create(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME,
-                  getInternalDistributedSystem(), true /* distributed */,
-                  true /* destroyOnDisconnect */, true /* automateFreeResources */);
+          prLockService = DLockService.create(PARTITION_LOCK_SERVICE_NAME,
+              getInternalDistributedSystem(), true, true, true);
-          prLockService = DistributedLockService
-              .getServiceNamed(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
+          prLockService = DistributedLockService.getServiceNamed(PARTITION_LOCK_SERVICE_NAME);
-            throw e; // PARTITION_LOCK_SERVICE_NAME must be illegal!
+            // PARTITION_LOCK_SERVICE_NAME must be illegal!
+            throw e;
-  /**
-   * Gets or lazily creates the GatewaySender distributed lock service.
-   *
-   * @return the GatewaySender distributed lock service
-   */
-                getInternalDistributedSystem(), true /* distributed */,
-                true /* destroyOnDisconnect */, true /* automateFreeResources */);
+                getInternalDistributedSystem(), true, true, true);
-              throw e; // AbstractGatewaySender.LOCK_SERVICE_NAME must be illegal!
+              // AbstractGatewaySender.LOCK_SERVICE_NAME must be illegal!
+              throw e;
-      DistributedLockService.destroy(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
+      DistributedLockService.destroy(PARTITION_LOCK_SERVICE_NAME);
+  @Override
+  @VisibleForTesting
+  @Override
+  @VisibleForTesting
-  /** Used by test to inject an evictor */
+  /**
+   * Used by test to inject an evictor.
+   */
+  @VisibleForTesting
-  /** Used by test to inject an evictor */
+  /**
+   * Used by test to inject an evictor.
+   */
+  @VisibleForTesting
-  private final boolean DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE");
-
-    if (!keepDS && systemFailureCause == null // normal cache close
+    if (!keepDS && systemFailureCause == null
-          "Cache is shutting down distributed system connection.  "
-              + "isReconnecting={}  reconnectedSystem={} keepAlive={} keepDS={}",
+          "Cache is shutting down distributed system connection. isReconnecting={} reconnectedSystem={} keepAlive={} keepDS={}",
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+    boolean isDebugEnabled = logger.isDebugEnabled();
-      /*
-       * First close the ManagementService as it uses a lot of infra which will be closed by
-       * cache.close()
-       */
+      // First close the ManagementService
+
-
-          // ignore
-          // ignore
-        /*
-         * IMPORTANT: any operation during shut down that can time out (create a CancelException)
-         * must be inside of this try block. If all else fails, we *must* ensure that the cache gets
-         * closed!
-         */
+        // IMPORTANT: any operation during shut down that can time out (create a CancelException)
+        // must be inside of this try block. If all else fails, we *must* ensure that the cache gets
+        // closed!
-          // no need to track PR instances since we won't create any more
-          // cacheServers or gatewayHubs
+          // no need to track PR instances
-          {
-            final Operation op;
-            if (forcedDisconnect) {
-              op = Operation.FORCED_DISCONNECT;
-            } else if (isReconnecting()) {
-              op = Operation.CACHE_RECONNECT;
-            } else {
-              op = Operation.CACHE_CLOSE;
-            }
-            InternalRegion prRoot = null;
-
-            for (InternalRegion lr : rootRegionValues) {
-              if (isDebugEnabled) {
-                logger.debug("{}: processing region {}", this, lr.getFullPath());
-              }
-              if (PartitionedRegionHelper.PR_ROOT_REGION_NAME.equals(lr.getName())) {
-                prRoot = lr;
-              } else {
-                if (lr.getName().contains(ParallelGatewaySenderQueue.QSTRING)) {
-                  continue; // this region will be closed internally by parent region
-                }
-                if (isDebugEnabled) {
-                  logger.debug("{}: closing region {}...", this, lr.getFullPath());
-                }
-                try {
-                  lr.handleCacheClose(op);
-                } catch (RuntimeException e) {
-                  if (isDebugEnabled || !forcedDisconnect) {
-                    logger.warn(String.format("%s: error closing region %s",
-                        this, lr.getFullPath()), e);
-                  }
-                }
-              }
-            } // for
-
-            try {
-              if (isDebugEnabled) {
-                logger.debug("{}: finishing partitioned region close...", this);
-              }
-              PartitionedRegion.afterRegionsClosedByCacheClose(this);
-              if (prRoot != null) {
-                // do the PR meta root region last
-                prRoot.handleCacheClose(op);
-              }
-            } catch (CancelException e) {
-              logger.warn(String.format("%s: error in last stage of PartitionedRegion cache close",
-                  this),
-                  e);
-            }
-            destroyPartitionedRegionLockService();
+          Operation op;
+          if (forcedDisconnect) {
+            op = Operation.FORCED_DISCONNECT;
+          } else if (isReconnecting()) {
+            op = Operation.CACHE_RECONNECT;
+          } else {
+            op = Operation.CACHE_CLOSE;
+          InternalRegion prRoot = null;
+
+          for (InternalRegion lr : rootRegionValues) {
+            if (isDebugEnabled) {
+              logger.debug("{}: processing region {}", this, lr.getFullPath());
+            }
+            if (PartitionedRegionHelper.PR_ROOT_REGION_NAME.equals(lr.getName())) {
+              prRoot = lr;
+            } else {
+              if (lr.getName().contains(ParallelGatewaySenderQueue.QSTRING)) {
+                // this region will be closed internally by parent region
+                continue;
+              }
+              if (isDebugEnabled) {
+                logger.debug("{}: closing region {}...", this, lr.getFullPath());
+              }
+              try {
+                lr.handleCacheClose(op);
+              } catch (RuntimeException e) {
+                if (isDebugEnabled || !forcedDisconnect) {
+                  logger.warn(String.format("%s: error closing region %s", this, lr.getFullPath()),
+                      e);
+                }
+              }
+            }
+          }
+
+          try {
+            if (isDebugEnabled) {
+              logger.debug("{}: finishing partitioned region close...", this);
+            }
+            PartitionedRegion.afterRegionsClosedByCacheClose(this);
+            if (prRoot != null) {
+              // do the PR meta root region last
+              prRoot.handleCacheClose(op);
+            }
+          } catch (CancelException e) {
+            logger.warn(
+                String.format("%s: error in last stage of PartitionedRegion cache close", this), e);
+          }
+          destroyPartitionedRegionLockService();
+
-            // distributionManager = null;
-          if (distributionManager != null) { // Send CacheClosedMessage (and NOTHING ELSE) here
+          if (distributionManager != null) {
+            // Send CacheClosedMessage (and NOTHING ELSE) here
+
-              // Thread.currentThread().interrupt(); // TODO ??? should we reset this bit later?
+              // TODO: reset interrupt flag later?
-            // set closed state after telling others and getting responses
-            // to avoid complications with others still in the process of
-            // sending messages
+            // set closed state after telling others and getting responses to avoid complications
+            // with others still in the process of sending messages
+
-        // keepDS is used by ShutdownAll. It will override DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE
-        if (!DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE) {
+        // keepDS is used by ShutdownAll. It will override disableDisconnectDsOnCacheClose
+        if (!disableDisconnectDsOnCacheClose) {
-      typeRegistryClose.accept(null);
+      typeRegistryClose.run();
-    } // static synchronization on GemFireCache.class
+    }
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+    GemFireCacheImpl cache = getInstance();
-  private final ConcurrentMap<String, DiskStoreImpl> diskStores = new ConcurrentHashMap<>();
-
-  private final ConcurrentMap<String, DiskStoreImpl> regionOwnedDiskStores =
-      new ConcurrentHashMap<>();
-
-    // Added for M&M
-    if (!diskStore.getOwnedByRegion())
+    if (!diskStore.getOwnedByRegion()) {
+    }
+  @VisibleForTesting
-        // Added for M&M
+  @VisibleForTesting
-  // TODO: remove static from defaultDiskStoreName and move methods to InternalCache
-  @MakeNotStatic
-  private static String defaultDiskStoreName = DiskStoreFactory.DEFAULT_DISK_STORE_NAME;
-
-  /**
-   * Returns the DiskStore by name
-   *
-   * @since GemFire prPersistSprint2
-   */
-  /**
-   * Returns the DiskStore list
-   *
-   * @since GemFire prPersistSprint2
-   */
-    return Collections.unmodifiableCollection(diskStores.values());
+    return unmodifiableCollection(diskStores.values());
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+    boolean isDebugEnabled = logger.isDebugEnabled();
-    // Reset the unique id counter for durable clients.
-    // If a durable client stops/starts its cache, it needs
-    // to maintain the same unique id.
+    // Reset the unique id counter for durable clients. If a durable client stops/starts its cache,
+    // it needs to maintain the same unique id.
-  /**
-   * Returns the member id of my distributed system
-   *
-   * @since GemFire 5.0
-   */
-    return Collections
-        .unmodifiableSet(dm.getOtherNormalDistributionManagerIds());
+    return unmodifiableSet(dm.getOtherNormalDistributionManagerIds());
-  @SuppressWarnings("unchecked")
-  private Set<DistributedMember> asDistributedMemberSet(
-      Set<InternalDistributedMember> internalDistributedMembers) {
-    return (Set) internalDistributedMembers;
-  }
-
-    } else if (region instanceof PartitionedRegion) {
+    }
+    if (region instanceof PartitionedRegion) {
-    } else {
-      return Collections.emptySet();
+    return emptySet();
-      return Collections.emptySet();
-    } else {
-      return result;
+      return emptySet();
+    return result;
+  @Deprecated
+  @Deprecated
-  /**
-   * get the threadId/sequenceId sweeper task for this cache
-   *
-   * @return the sweeper task
-   */
-  /**
-   * Get the list of all instances of properties for Declarables with the given class name.
-   *
-   * @param className Class name of the declarable
-   * @return List of all instances of properties found for the given declarable
-   */
-  public List<Properties> getDeclarableProperties(final String className) {
+  public List<Properties> getDeclarableProperties(String className) {
-  /**
-   * Get the properties for the given declarable.
-   *
-   * @param declarable The declarable
-   * @return Properties found for the given declarable
-   */
-  public Properties getDeclarableProperties(final Declarable declarable) {
+  public Properties getDeclarableProperties(Declarable declarable) {
-  /**
-   * Returns the number of seconds that have elapsed since the Cache was created.
-   *
-   * @since GemFire 3.5
-   */
-  public int getUpTime() {
-    return (int) (System.currentTimeMillis() - creationDate.getTime()) / 1000;
+  public long getUpTime() {
+    return (System.currentTimeMillis() - creationDate.getTime()) / 1000;
-  /**
-   * All entry and region operations should be using this time rather than
-   * System.currentTimeMillis(). Specially all version stamps/tags must be populated with this
-   * timestamp.
-   *
-   * @return distributed cache time.
-   */
-    } else {
-      return System.currentTimeMillis();
+    return System.currentTimeMillis();
-   * Used to set the default pool on a new GemFireCache.
+   * Set the default pool on a new GemFireCache.
-  @Override
-  public synchronized void determineDefaultPool() {
+  private synchronized void determineDefaultPool() {
+
+
-      // look for a pool that already exists that is compatible with
-      // our PoolFactory.
+      // look for a pool that already exists that is compatible with our PoolFactory.
+
+
-  /**
-   * Determine whether the specified pool factory matches the pool factory used by this cache.
-   *
-   * @param poolFactory Prospective pool factory.
-   * @throws IllegalStateException When the specified pool factory does not match.
-   */
-      InternalRegionArguments ira = new InternalRegionArguments().setDestroyLockFlag(true)
-          .setRecreateFlag(false).setSnapshotInputStream(null).setImageTarget(null);
+      InternalRegionArguments ira = new InternalRegionArguments()
+          .setDestroyLockFlag(true)
+          .setRecreateFlag(false)
+          .setSnapshotInputStream(null)
+          .setImageTarget(null);
-      // only if loading snapshot, not here
-      throw new InternalGemFireError(
-          "unexpected exception", e);
+      throw new InternalGemFireError("unexpected exception", e);
-  @SuppressWarnings("unchecked")
-  private static <K, V> Region<K, V> uncheckedRegion(Region region) {
-    return region;
-  }
-
-
-    if (getMyId().getVmKind() == ClusterDistributionManager.LOCATOR_DM_TYPE) {
+    if (getMyId().getVmKind() == LOCATOR_DM_TYPE) {
+
+
-      throw new IllegalArgumentException(
-          "Attributes must not be null");
+      throw new IllegalArgumentException("Attributes must not be null");
-    InternalRegion region;
-    final InputStream snapshotInputStream = internalRegionArgs.getSnapshotInputStream();
+    InputStream snapshotInputStream = internalRegionArgs.getSnapshotInputStream();
-    final boolean recreate = internalRegionArgs.getRecreateFlag();
-    final boolean isPartitionedRegion = attrs.getPartitionAttributes() != null;
-    final boolean isReInitCreate = snapshotInputStream != null || imageTarget != null || recreate;
+    boolean recreate = internalRegionArgs.getRecreateFlag();
+    boolean isPartitionedRegion = attrs.getPartitionAttributes() != null;
+    boolean isReInitCreate = snapshotInputStream != null || imageTarget != null || recreate;
+    InternalRegion region;
-          // check for case where a root region is being reinitialized and we
-          // didn't
-          // find a region, i.e. the new region is about to be created
+          // check for case where a root region is being reinitialized
+          // and we didn't find a region, i.e. the new region is about to be created
-          if (!isReInitCreate) { // fix bug 33523
+          if (!isReInitCreate) {
-        } // synchronized
+        }
-        try { // future != null
+        try {
-          throw new Error("unexpected exception",
-              e);
+          throw new Error("unexpected exception", e);
-          // future was cancelled
-      } // for
+      }
+
-            // do this before removing the region from
-            // the root set to fix bug 41982.
+            // do this before removing the region from the root set
-            // bug #44672 - log the failure but don't override the original exception
-            logger.warn(String.format("Initialization failed for Region %s",
-                region.getFullPath()),
+            // log the failure but don't override the original exception
+            logger.warn(String.format("Initialization failed for Region %s", region.getFullPath()),
-            } // synchronized
+            }
-        } // success
+        }
-      // outside of sync make sure region is initialized to fix bug 37563
+      // outside of sync make sure region is initialized
-    // Added for M&M . Putting the callback here to avoid creating RegionMBean in case of Exception
+    // Putting the callback here to avoid creating RegionMBean in case of Exception
-  @SuppressWarnings("unchecked")
-  private static <K, V> RegionAttributes<K, V> uncheckedRegionAttributes(RegionAttributes region) {
-    return region;
-  }
-
-  @SuppressWarnings("unchecked")
-  public Region getRegion(String path) {
+  public <K, V> Region<K, V> getRegion(String path) {
-  /**
-   * returns a set of all current regions in the cache, including buckets
-   *
-   * @since GemFire 6.0
-   */
-      for (Region region : rootRegions.values()) {
+      for (Region<?, ?> region : rootRegions.values()) {
-          continue; // Skip internal regions
+          // Skip internal regions
+          continue;
-      throw new IllegalArgumentException(
-          "path cannot be null");
+      throw new IllegalArgumentException("path cannot be null");
-      throw new IllegalArgumentException(
-          "path cannot be empty");
+      throw new IllegalArgumentException("path cannot be empty");
-      throw new IllegalArgumentException(
-          String.format("path cannot be ' %s '", Region.SEPARATOR));
+      throw new IllegalArgumentException(String.format("path cannot be ' %s '", Region.SEPARATOR));
-  public InternalRegion getRegionByPath(String path) {
-    validatePath(path); // fix for bug 34892
+  public <K, V> Region<K, V> getRegionByPath(String path) {
+    return uncheckedRegion(getInternalRegionByPath(path));
+  }
+
+  @Override
+  public InternalRegion getInternalRegionByPath(String path) {
+    validatePath(path);
-    InternalRegion result = getRegionByPath(path);
+    Region<?, ?> result = getRegionByPath(path);
-      final InitializationLevel oldLevel =
-          LocalRegion.setThreadInitLevelRequirement(InitializationLevel.ANY_INIT); // go through
-      // initialization latches
+
+      // go through initialization latches
+      InitializationLevel oldLevel = setThreadInitLevelRequirement(InitializationLevel.ANY_INIT);
-          if (rootRegion == null)
+          if (rootRegion == null) {
+          }
-        result = (InternalRegion) rootRegion.getSubregion(pathParts[1], true);
+        result = rootRegion.getSubregion(pathParts[1], true);
-        LocalRegion.setThreadInitLevelRequirement(oldLevel);
+        setThreadInitLevelRequirement(oldLevel);
-    return result;
+    return (InternalRegion) result;
-  /**
-   * @param returnDestroyedRegion if true, okay to return a destroyed region
-   */
-  public Region getRegion(String path, boolean returnDestroyedRegion) {
+  public <K, V> Region<K, V> getRegion(String path, boolean returnDestroyedRegion) {
-    InternalRegion result = getRegionByPath(path);
+    InternalRegion result = getInternalRegionByPath(path);
+
-      } else {
-        return result;
+      return uncheckedRegion(result);
+
-    return rootRegion.getSubregion(pathParts[1], returnDestroyedRegion);
+    return uncheckedRegion(rootRegion.getSubregion(pathParts[1], returnDestroyedRegion));
-  /** Return true if this region is initializing */
-    final InitializationLevel oldLevel =
-        LocalRegion.setThreadInitLevelRequirement(InitializationLevel.ANY_INIT); // go through
-    // initialization latches
+    // go through initialization latches
+    InitializationLevel oldLevel = setThreadInitLevelRequirement(InitializationLevel.ANY_INIT);
-      LocalRegion.setThreadInitLevelRequirement(oldLevel);
+      setThreadInitLevelRequirement(oldLevel);
-  /** Return true if this region is initializing */
+  /**
+   * Return true if the region is initializing.
+   */
-        if (region.isSecret() || region.isUsedForMetaRegion()
-            || !includePRAdminRegions && (region.isUsedForPartitionedRegionAdmin()
-                || region.isUsedForPartitionedRegionBucket())) {
-          continue; // Skip administrative PartitionedRegions
+        if (region.isSecret()
+            || region.isUsedForMetaRegion()
+            || !includePRAdminRegions
+                && (region.isUsedForPartitionedRegionAdmin()
+                    || region.isUsedForPartitionedRegionBucket())) {
+          // Skip administrative PartitionedRegions
+          continue;
-    return Collections.unmodifiableSet(regions);
+    return unmodifiableSet(regions);
-  /**
-   * Called by notifier when a client goes away
-   *
-   * @since GemFire 5.7
-   */
-  /**
-   * Get a reference to a Region that is reinitializing, or null if that Region is not
-   * reinitializing or this thread is interrupted. If a reinitializing region is found, then this
-   * method blocks until reinitialization is complete and then returns the region.
-   */
-  /**
-   * Register the specified region name as reinitializing, creating and adding a Future for it to
-   * the map.
-   *
-   * @throws IllegalStateException if there is already a region by that name registered.
-   */
-          String.format("Found an existing reinitalizing region named %s",
+          String.format("Found an existing reinitializing region named %s",
-  /**
-   * Set the reinitialized region and unregister it as reinitializing.
-   *
-   * @throws IllegalStateException if there is no region by that name registered as reinitializing.
-   */
-  public void regionReinitialized(Region region) {
+  public void regionReinitialized(Region<?, ?> region) {
-  /**
-   * Clear a reinitializing region, e.g. reinitialization failed.
-   *
-   * @throws IllegalStateException if cannot find reinitializing region registered by that name.
-   */
-  /**
-   * Returns true if get should give a copy; false if a reference.
-   *
-   * @since GemFire 4.0
-   */
-  /**
-   * Implementation of {@link Cache#setCopyOnRead}
-   *
-   * @since GemFire 4.0
-   */
-  /**
-   * Implementation of {@link Cache#getCopyOnRead}
-   *
-   * @since GemFire 4.0
-   */
-  /**
-   * Remove the specified root region
-   *
-   * @param rootRgn the region to be removed
-   * @return true if root region was removed, false if not found
-   */
-      } else
-        return false;
+      }
+      return false;
-   * Makes note of a {@code CacheLifecycleListener}
+   * Add the {@code CacheLifecycleListener}.
-   * Removes a {@code CacheLifecycleListener}
+   * Remove the {@code CacheLifecycleListener}.
-   * @return Whether or not the listener was removed
+   * @return true if the listener was removed
-    return Collections.unmodifiableSet(regionListeners);
+    return unmodifiableSet(regionListeners);
-    return Collections.unmodifiableCollection(services.values());
+    return unmodifiableCollection(services.values());
-  /**
-   * Creates the single instance of the Transaction Manager for this cache. Returns the existing one
-   * upon request.
-   *
-   * @return the CacheTransactionManager instance.
-   *
-   * @since GemFire 4.0
-   */
-  /**
-   * GuardedBy {@link #ccpTimerMutex}
-   *
-   * @see CacheClientProxy
-   */
-  private SystemTimer ccpTimer;
-
-  /**
-   * @see #ccpTimer
-   */
-  private final Object ccpTimerMutex = new Object();
-
-  /**
-   * Get cache-wide CacheClientProxy SystemTimer
-   *
-   * @return the timer, lazily created
-   */
-        ccpTimer.cancel(); // poison it, don't throw.
+        // poison it, don't throw.
+        ccpTimer.cancel();
+  @VisibleForTesting
-  static final int PURGE_INTERVAL = 1000;
-
-  private int cancelCount = 0;
-
-  /**
-   * Does a periodic purge of the CCPTimer to prevent a large number of cancelled tasks from
-   * building up in it. See GEODE-2485.
-   */
-  private final ExpirationScheduler expirationScheduler;
-
-  /**
-   * Get cache-wide ExpirationScheduler
-   *
-   * @return the scheduler, lazily created
-   */
-  /**
-   * Returns the {@code Executor} (thread pool) that is used to execute cache event listeners.
-   * Returns {@code null} if no pool exists.
-   *
-   * @since GemFire 3.5
-   */
+  @VisibleForTesting
-        allGatewaySenders = Collections.unmodifiableSet(newSenders);
+        allGatewaySenders = unmodifiableSet(newSenders);
-      Region dynamicMetaRegion = getRegion(DynamicRegionFactory.DYNAMIC_REGION_LIST_NAME);
+      Region<?, ?> dynamicMetaRegion = getRegion(DynamicRegionFactory.DYNAMIC_REGION_LIST_NAME);
-        allGatewaySenders = Collections.unmodifiableSet(newSenders);
+        allGatewaySenders = unmodifiableSet(newSenders);
-  /**
-   * Returns List of GatewaySender (excluding the senders for internal use)
-   *
-   * @return List List of GatewaySender objects
-   */
-  /**
-   * Returns List of all GatewaySenders (including the senders for internal use)
-   *
-   * @return List List of GatewaySender objects
-   */
-      return Collections.emptySet();
+      return emptySet();
+  @VisibleForTesting
-    if (asyncQueue instanceof AsyncEventQueueImpl) {
-      removeGatewaySender(((AsyncEventQueueImpl) asyncQueue).getSender());
+    if (asyncQueue instanceof InternalAsyncEventQueue) {
+      removeGatewaySender(((InternalAsyncEventQueue) asyncQueue).getSender());
-  /** get the conflict resolver for WAN */
-  /** set the conflict resolver for WAN */
-    return Collections.unmodifiableList(allServers);
+    return unmodifiableList(allServers);
-  /**
-   * add a partitioned region to the set of tracked partitioned regions. This is used to notify the
-   * regions when this cache requires, or does not require notification of all region/entry events.
-   */
-  /**
-   * Returns a set of all current partitioned regions for test hook.
-   */
-  private SortedMap<String, Map<String, PartitionedRegion>> getPRTrees() {
+  private Map<String, Map<String, PartitionedRegion>> getPRTrees() {
-    SortedMap<String, PartitionedRegion> prMap = getPartitionedRegionMap();
+    Map<String, PartitionedRegion> prMap = getPartitionedRegionMap();
-      List<PartitionedRegion> childList = ColocationHelper.getColocatedChildRegions(pr);
+      List<PartitionedRegion> childList = getColocatedChildRegions(pr);
-    TreeMap<String, Map<String, PartitionedRegion>> prTrees = new TreeMap<>();
+    Map<String, Map<String, PartitionedRegion>> prTrees = new TreeMap<>();
-  private SortedMap<String, PartitionedRegion> getPartitionedRegionMap() {
-    SortedMap<String, PartitionedRegion> prMap = new TreeMap<>();
+  private Map<String, PartitionedRegion> getPartitionedRegionMap() {
+    Map<String, PartitionedRegion> prMap = new TreeMap<>();
-      // Do a getRegion to ensure that we wait for the partitioned region
-      // to finish initialization
+      // call getRegion to ensure that we wait for the partitioned region to finish initialization
-        Region pr = getRegion(regionName);
+        Region<?, ?> pr = getRegion(regionName);
-    LinkedHashMap<String, PartitionedRegion> orderedPrMap = new LinkedHashMap<>();
+    Map<String, PartitionedRegion> orderedPrMap = new LinkedHashMap<>();
-  private void addColocatedChildRecursively(LinkedHashMap<String, PartitionedRegion> prMap,
+  private void addColocatedChildRecursively(Map<String, PartitionedRegion> prMap,
-    for (PartitionedRegion colocatedRegion : ColocationHelper.getColocatedChildRegions(pr)) {
+    for (PartitionedRegion colocatedRegion : getColocatedChildRegions(pr)) {
-  /**
-   * check to see if any cache components require notification from a partitioned region.
-   * Notification adds to the messaging a PR must do on each put/destroy/invalidate operation and
-   * should be kept to a minimum
-   *
-   * @param region the partitioned region
-   * @return true if the region should deliver all of its events to this cache
-   */
-  private boolean hasSerialSenders(PartitionedRegion region) {
+  private boolean hasSerialSenders(InternalRegion region) {
-  /**
-   * remove a partitioned region from the set of tracked instances.
-   *
-   * @see #addPartitionedRegion(PartitionedRegion)
-   */
-  public InternalQueryService getQueryService() {
+  public QueryService getQueryService() {
-      return (InternalQueryService) getLocalQueryService();
+      return getLocalQueryService();
-    return (InternalQueryService) defaultPool.getQueryService();
+    return defaultPool.getQueryService();
+  }
+
+  @Override
+  public InternalQueryService getInternalQueryService() {
+    return (InternalQueryService) getQueryService();
-  /**
-   * @return Context jndi context associated with the Cache.
-   * @since GemFire 4.0
-   */
-  /**
-   * @return JTA TransactionManager associated with the Cache.
-   * @since GemFire 4.0
-   */
-  /**
-   * return the cq/interest information for a given region name, creating one if it doesn't exist
-   */
-  @SuppressWarnings("unchecked")
-  private static <K, V> Map<String, RegionAttributes<K, V>> uncheckedCast(
-      Map<String, RegionAttributes<?, ?>> namedRegionAttributes) {
-    return (Map) namedRegionAttributes;
-  }
-
-    return GemFireCacheImpl.<K, V>uncheckedCast(namedRegionAttributes).get(id);
+    return GemFireCacheImpl.UncheckedUtils.<K, V>uncheckedCast(namedRegionAttributes).get(id);
-    return Collections.unmodifiableMap(uncheckedCast(namedRegionAttributes));
+    return unmodifiableMap(uncheckedCast(namedRegionAttributes));
-  private static final ThreadLocal<GemFireCacheImpl> xmlCache = new ThreadLocal<>();
-
-    final GemFireCacheImpl oldValue = xmlCache.get();
+    GemFireCacheImpl oldValue = xmlCache.get();
-        char[] buffer = new char[1024];
+        char[] buffer = new char[1024];
-        /*
-         * Now replace all replaceable system properties here using {@code PropertyResolver}
-         */
+        // Now replace all replaceable system properties here using {@code PropertyResolver}
-        /*
-         * Turn the string back into the default encoding so that the XML parser can work correctly
-         * in the presence of an "encoding" attribute in the XML prolog.
-         */
+
+        // Turn the string back into the default encoding so that the XML parser can work correctly
+        // in the presence of an "encoding" attribute in the XML prolog.
-      if (Objects.nonNull(system) && Objects.nonNull(system.getConfig())
-          && !Objects.equals(DistributionConfig.DEFAULT_DURABLE_CLIENT_ID,
+      if (Objects.nonNull(system)
+          && Objects.nonNull(system.getConfig())
+          && !Objects.equals(DEFAULT_DURABLE_CLIENT_ID,
-                  DistributionConfig.DEFAULT_DURABLE_CLIENT_ID))) {
+                  DEFAULT_DURABLE_CLIENT_ID))) {
-  private List<File> backupFiles = Collections.emptyList();
-
-    return Collections.unmodifiableList(backupFiles);
+    return unmodifiableList(backupFiles);
-  // TODO make this a simple int guarded by riWaiters and get rid of the double-check
-  private final AtomicInteger registerInterestsInProgress = new AtomicInteger();
-
-  private final List<SimpleWaiter> riWaiters = new ArrayList<>();
-
-  // never changes but is currently only initialized in constructor by unit tests
-  private TypeRegistry pdxRegistry;
-
-  /**
-   * update stats for completion of a registerInterest operation
-   */
-      return; // just get out, all of the SimpleWaiters will die of their own accord
+      // just get out, all of the SimpleWaiters will die of their own accord
+      return;
+
-        // TODO: get rid of double-check
-        if (numInProgress == 0) { // all clear
+        if (numInProgress == 0) {
-        } // all clear
-      } // synchronized
+        }
+      }
-  /**
-   * Blocks until no register interests are in progress.
-   */
-    // In *this* particular context, let the caller know that
-    // its cache has been cancelled. doWait below would do that as
-    // well, so this is just an early out.
+    // In *this* particular context, let the caller know that its cache has been cancelled.
+    // doWait below would do that as well, so this is just an early out.
-        // TODO double-check
-      } // synchronized
+      }
-  /**
-   * Returns the QueryMonitor instance based on system property MAX_QUERY_EXECUTION_TIME.
-   *
-   * @since GemFire 6.0
-   */
+
-            maxTime = FIVE_HOURS;
+            maxTime = FIVE_HOURS_MILLIS;
-              new QueryMonitor((ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(
+              new QueryMonitor((ScheduledThreadPoolExecutor) newScheduledThreadPool(
-                  (runnable) -> new LoggingThread("QueryMonitor Thread", runnable)),
+                  runnable -> new LoggingThread("QueryMonitor Thread", runnable)),
-  /**
-   * Simple class to allow waiters for register interest. Has at most one thread that ever calls
-   * wait.
-   *
-   * @since GemFire 5.7
-   */
-  private class SimpleWaiter {
-    private boolean notified;
-
-    SimpleWaiter() {}
-
-    void doWait() {
-      synchronized (this) {
-        while (!notified) {
-          getCancelCriterion().checkCancelInProgress(null);
-          boolean interrupted = Thread.interrupted();
-          try {
-            wait(1000);
-          } catch (InterruptedException ignore) {
-            interrupted = true;
-          } finally {
-            if (interrupted) {
-              Thread.currentThread().interrupt();
-            }
-          }
-        }
-      }
-    }
-
-    void doNotify() {
-      synchronized (this) {
-        notified = true;
-        notifyAll();
-      }
-    }
-  }
-
+
-    // Remove this while loop when we release GEODE 2.0
-  /**
-   * @since GemFire 6.5
-   */
-  /**
-   * @since GemFire 6.5
-   */
-  /**
-   * @since GemFire 6.5
-   */
-  /**
-   * @since GemFire 6.5
-   */
-  /**
-   * @since GemFire 6.5
-   */
-  /**
-   * @since GemFire 6.5
-   */
-    } else {
-      return pool.getQueryService();
+    return pool.getQueryService();
-    } else {
-      throw new IllegalStateException(
-          "The pool " + pool.getName() + " did not have multiuser-authentication set to true");
+    throw new IllegalStateException(
+        "The pool " + pool.getName() + " did not have multiuser-authentication set to true");
-  /**
-   * Returns true if any of the GemFire services prefers PdxInstance. And application has not
-   * requested getObject() on the PdxInstance.
-   */
-    boolean pdxReadSerializedOverriden = false;
+    boolean pdxReadSerializedOverridden = false;
-      pdxReadSerializedOverriden = pdxRegistry.getPdxReadSerializedOverride();
+      pdxReadSerializedOverridden = pdxRegistry.getPdxReadSerializedOverride();
-    return (getPdxReadSerialized() || pdxReadSerializedOverriden)
+    return (getPdxReadSerialized() || pdxReadSerializedOverridden)
-  // test hook
+  @VisibleForTesting
-  // test hook
+  @Deprecated
+  @VisibleForTesting
-  /**
-   * Add to the map of declarable properties. Any properties that exactly match existing properties
-   * for a class in the list will be discarded (no duplicate Properties allowed).
-   *
-   * @param mapOfNewDeclarableProps Map of the declarable properties to add
-   */
-  public void addDeclarableProperties(final Map<Declarable, Properties> mapOfNewDeclarableProps) {
+  public void addDeclarableProperties(Map<Declarable, Properties> mapOfNewDeclarableProps) {
-              (Declarable oldKey, Declarable newKey) -> newKey instanceof Identifiable
+              (oldKey, newKey) -> newKey instanceof Identifiable
-          Supplier<Boolean> isValueEqual = () -> newEntry.getValue().equals(oldEntry.getValue());
+          Supplier<Boolean> isValueEqual =
+              () -> newEntry.getValue().equals(oldEntry.getValue());
-  private Declarable initializer;
-
-  private Properties initializerProps;
-
-  /**
-   * @see Extensible#getExtensionPoint()
-   * @since GemFire 8.1
-   */
-  private final InternalCacheForClientAccess cacheForClients =
-      new InternalCacheForClientAccess(this);
-
-    } else {
-      return null;
+    return null;
-  /**
-   * Feature factories may use this supplier to acquire the {@code StatisticsClock} which is
-   * created by the Cache as configured by {@link DistributionConfig#getEnableTimeStatistics()}.
-   *
-   * <p>
-   * Please pass the {@code StatisticsClock} through constructors where possible instead of
-   * accessing it from this supplier.
-   */
+  private class Stopper extends CancelCriterion {
+
+    @Override
+    public String cancelInProgress() {
+      String reason = getDistributedSystem().getCancelCriterion().cancelInProgress();
+      if (reason != null) {
+        return reason;
+      }
+      if (disconnectCause != null) {
+        return disconnectCause.getMessage();
+      }
+      if (isClosing) {
+        return "The cache is closed.";
+      }
+      return null;
+    }
+
+    @Override
+    public RuntimeException generateCancelledException(Throwable throwable) {
+      String reason = cancelInProgress();
+      if (reason == null) {
+        return null;
+      }
+      RuntimeException result =
+          getDistributedSystem().getCancelCriterion().generateCancelledException(throwable);
+      if (result != null) {
+        return result;
+      }
+      if (disconnectCause == null) {
+        // No root cause, specify the one given and be done with it.
+        return new CacheClosedException(reason, throwable);
+      }
+
+      if (throwable == null) {
+        // Caller did not specify any root cause, so just use our own.
+        return new CacheClosedException(reason, disconnectCause);
+      }
+
+      // Attempt to stick rootCause at tail end of the exception chain.
+      try {
+        ThrowableUtils.setRootCause(throwable, disconnectCause);
+        return new CacheClosedException(reason, throwable);
+      } catch (IllegalStateException ignore) {
+        // Give up. The following error is not entirely sane but gives the correct general picture.
+        return new CacheClosedException(reason, disconnectCause);
+      }
+    }
+  }
+
+  /**
+   * Support for waiters of register interest. Only one thread at most ever calls wait.
+   *
+   * @since GemFire 5.7
+   */
+  private class SimpleWaiter {
+
+    private boolean notified;
+
+    private void doWait() {
+      synchronized (this) {
+        while (!notified) {
+          getCancelCriterion().checkCancelInProgress(null);
+          boolean interrupted = Thread.interrupted();
+          try {
+            wait(1000);
+          } catch (InterruptedException ignore) {
+            interrupted = true;
+          } finally {
+            if (interrupted) {
+              Thread.currentThread().interrupt();
+            }
+          }
+        }
+      }
+    }
+
+    private void doNotify() {
+      synchronized (this) {
+        notified = true;
+        notifyAll();
+      }
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  static class UncheckedUtils {
+
+    static Map<InternalDistributedMember, PersistentMemberID>[] createMapArray(int size) {
+      return new Map[size];
+    }
+
+    static Set<DistributedMember> asDistributedMemberSet(
+        Set<InternalDistributedMember> internalDistributedMembers) {
+      return (Set) internalDistributedMembers;
+    }
+
+    static <K, V> RegionAttributes<K, V> uncheckedRegionAttributes(RegionAttributes region) {
+      return region;
+    }
+
+    static <K, V> Map<String, RegionAttributes<K, V>> uncheckedCast(
+        Map<String, RegionAttributes<?, ?>> namedRegionAttributes) {
+      return (Map) namedRegionAttributes;
+    }
+  }
+
+  @FunctionalInterface
+  @VisibleForTesting
+  @FunctionalInterface
+  @VisibleForTesting
+  @FunctionalInterface
+  @VisibleForTesting
+  @FunctionalInterface
+  @VisibleForTesting
+  @FunctionalInterface
+  @VisibleForTesting
+  @FunctionalInterface
+  @VisibleForTesting

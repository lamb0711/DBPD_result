GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+import java.util.Objects;
-  private static final ConcurrentMap/* <Integer, DataSerializer|Marker> */ idsToSerializers =
-      new ConcurrentHashMap();
+  private static final ConcurrentMap<Integer, Object /* DataSerializer|Marker */> idsToSerializers =
+      new ConcurrentHashMap<>();
-  private static final ConcurrentMap dsfidToClassMap =
-      logger.isTraceEnabled(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE) ? new ConcurrentHashMap()
+  private static final ConcurrentMap<Integer, String> dsfidToClassMap =
+      logger.isTraceEnabled(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE) ? new ConcurrentHashMap<>()
-  private static volatile Set listeners = new HashSet();
-  @MakeNotStatic
-  private static DataSerializer dvddeserializer;
+  private static volatile Set<RegistrationListener> listeners = new HashSet<>();
-    Collection<String> result = new ArrayList(1000);
+    ArrayList<String> result = new ArrayList<>(1000);
-        if (line.startsWith("#") || line.startsWith("//")) {
-          // comment line
-        } else {
+        if (!(line.startsWith("#") || line.startsWith("//"))) {
-  static DataSerializer newInstance(Class c) {
+  static DataSerializer newInstance(Class<? extends DataSerializer> c)
+      throws IllegalArgumentException {
-    Constructor init;
+    Constructor<? extends DataSerializer> init;
-      init = c.getDeclaredConstructor(new Class[0]);
+      init = c.getDeclaredConstructor();
-      s = (DataSerializer) init.newInstance(new Object[0]);
+      s = init.newInstance();
-  public static DataSerializer register(Class c, boolean distribute, EventID eventId,
+  public static DataSerializer register(Class<? extends DataSerializer> c, boolean distribute,
+      EventID eventId,
-  public static DataSerializer register(Class c, boolean distribute) {
+  public static DataSerializer register(Class<? extends DataSerializer> c, boolean distribute) {
-                  new Object[] {other.getClass().getName(), other.getId()}));
+                  other.getClass().getName(), other.getId()));
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
+  @SuppressWarnings("deprecation")
+  private static InternalCache getInternalCache() {
+    return GemFireCacheImpl.getInstance();
+  }
+
-                new Object[] {oldValue.getClass().getName(), oldValue.getId()}));
+                oldValue.getClass().getName(), oldValue.getId()));
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
-        Class dsClass = null;
+        Class<DataSerializer> dsClass;
-          dsClass = getCachedClass(sah.getClassName());
-
+          dsClass = InternalDataSerializer.getCachedClass(sah.getClassName());
-              dsClass);
+              c.getName());
-        Class dsClass = null;
+        Class<DataSerializer> dsClass;
-
-          logger.info(LogMarker.SERIALIZER_MARKER,
-              "Could not load DataSerializer class: {}",
-              dsClass);
+          logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}",
+              sah.getClassName());
-    Collection coll = new ArrayList(size);
+    List<DataSerializer> coll = new ArrayList<>(size);
-        coll.add(v);
+        coll.add((DataSerializer) v);
-        Class cl = getCachedClass(name);
+        Class<? extends DataSerializer> cl = getCachedClass(name);
-    return (DataSerializer[]) coll.toArray(new DataSerializer[coll.size()]);
+    return coll.toArray(new DataSerializer[0]);
-    return coll.toArray(new SerializerAttributesHolder[coll.size()]);
-  }
-
-  /**
-   * Persist this class's map to out TODO: saveRegistrations is unused
-   */
-  public static void saveRegistrations(DataOutput out) throws IOException {
-    for (Object v : idsToSerializers.values()) {
-      if (v instanceof InitMarker) {
-        v = ((Marker) v).getSerializer();
-      }
-      if (v instanceof DataSerializer) {
-        DataSerializer ds = (DataSerializer) v;
-        out.writeInt(ds.getId()); // since 5.7 an int instead of a byte
-        DataSerializer.writeClass(ds.getClass(), out);
-      }
-    }
-    if (!dsClassesToHolders.isEmpty()) {
-      Iterator<Entry<String, SerializerAttributesHolder>> iterator =
-          dsClassesToHolders.entrySet().iterator();
-      Class dsClass = null;
-      while (iterator.hasNext()) {
-        try {
-          dsClass = getCachedClass(iterator.next().getKey());
-        } catch (ClassNotFoundException ignored) {
-          logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}",
-              dsClass);
-          continue;
-        }
-        DataSerializer ds = register(dsClass, false);
-        iterator.remove();
-        idsToHolders.remove(ds.getId());
-        for (Class clazz : ds.getSupportedClasses()) {
-          supportedClassesToHolders.remove(clazz.getName());
-        }
-
-        out.writeInt(ds.getId()); // since 5.7 an int instead of a byte
-        DataSerializer.writeClass(ds.getClass(), out);
-      }
-    }
-    // We know that DataSerializer's id must be > 0 so write a zero
-    // to mark the end of the ds list.
-    out.writeInt(0); // since 5.7 an int instead of a byte
-  }
-
-  /**
-   * Read the data from in and register it with this class. TODO: loadRegistrations is unused
-   *
-   * @throws IllegalArgumentException if a registration fails
-   */
-  public static void loadRegistrations(DataInput in) throws IOException {
-    while (in.readInt() != 0) {
-      Class dsClass = null;
-      boolean skip = false;
-      try {
-        dsClass = DataSerializer.readClass(in);
-      } catch (ClassNotFoundException ignored) {
-        skip = true;
-      }
-      if (skip) {
-        continue;
-      }
-      register(dsClass, /* dsId, */ true);
-    }
+    return coll.toArray(new SerializerAttributesHolder[0]);
-      Set newSet = new HashSet(listeners);
+      Set<RegistrationListener> newSet = new HashSet<>(listeners);
-      Set newSet = new HashSet(listeners);
+      Set<RegistrationListener> newSet = new HashSet<>(listeners);
-    for (Object listener1 : listeners) {
-      RegistrationListener listener = (RegistrationListener) listener1;
+    for (RegistrationListener listener : listeners) {
-    for (Object listener1 : listeners) {
-      RegistrationListener listener = (RegistrationListener) listener1;
+    for (RegistrationListener listener : listeners) {
-        String existingClassName = (String) dsfidToClassMap.putIfAbsent(dsfid, newClassName);
+        String existingClassName = dsfidToClassMap.putIfAbsent(dsfid, newClassName);
-      throw new IOException(String.format("Serializer with Id %s is not registered",
-          new Object[] {serializerId}));
+      throw new IOException(String.format("Serializer with Id %s is not registered", serializerId));
-            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing HashSet with {} elements: {}", size, set);
+            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing Set with {} elements: {}", size, set);
-            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing HashSet with {} elements: {}", -1, set);
+            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing Set with {} elements: {}", -1, null);
-   * Reads a {@code Set} from a {@code DataInput} into the given non-null collection. Returns true
-   * if collection read is non-null else returns false. TODO: readCollection is unused
-   *
-   * @throws IOException A problem occurs while reading from {@code in}
-   * @throws ClassNotFoundException The class of one of the {@code Set}'s elements cannot be found.
-   * @see #writeSet
-   */
-  public static <E> boolean readCollection(DataInput in, Collection<E> c)
-      throws IOException, ClassNotFoundException {
-
-    checkIn(in);
-
-    final int size = readArrayLength(in);
-    if (size >= 0) {
-      for (int index = 0; index < size; ++index) {
-        E element = DataSerializer.readObject(in);
-        c.add(element);
-      }
-
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read Collection with {} elements: {}", size, c);
-      }
-      return true;
-    }
-    return false;
-  }
-
-  /**
-      Set result = new HashSet(size);
-      boolean longIDs = in.readBoolean();
-      for (int i = 0; i < size; i++) {
-        long l = longIDs ? in.readLong() : in.readInt();
-        result.add(l);
-      }
-      return result;
-    }
-  }
-
-  /**
-   * write a set of Long objects TODO: writeListOfLongs is unused
-   *
-   * @param list the set of Long objects
-   * @param hasLongIDs if false, write only ints, not longs
-   * @param out the output stream
-   */
-  public static void writeListOfLongs(List list, boolean hasLongIDs, DataOutput out)
-      throws IOException {
-    if (list == null) {
-      out.writeInt(-1);
-    } else {
-      out.writeInt(list.size());
-      out.writeBoolean(hasLongIDs);
-      for (Object aList : list) {
-        Long l = (Long) aList;
-        if (hasLongIDs) {
-          out.writeLong(l);
-        } else {
-          out.writeInt((int) l.longValue());
-        }
-      }
-    }
-  }
-
-  /**
-   * read a set of Long objects
-   */
-  public static List<Long> readListOfLongs(DataInput in) throws IOException {
-    int size = in.readInt();
-    if (size < 0) {
-      return null;
-    } else {
-      List result = new LinkedList();
+      Set<Long> result = new HashSet<>(size);
-  public static Class decodePrimitiveClass(byte typeCode) throws IOException {
+  public static Class<?> decodePrimitiveClass(byte typeCode) throws IOException {
-    BigInteger result = new BigInteger(DataSerializer.readByteArray(in));
+    BigInteger result = new BigInteger(Objects.requireNonNull(DataSerializer.readByteArray(in)));
-    InternalCache internalCache = GemFireCacheImpl.getInstance();
+    InternalCache internalCache = getInternalCache();
+  @SuppressWarnings("unchecked")
-    Class c = readClass(in);
+    Class<? extends DataSerializer> c = (Class<? extends DataSerializer>) readClass(in);
-      Constructor init = c.getConstructor(new Class[0]);
+      Constructor<? extends DataSerializer> init = c.getConstructor();
-      Object o = init.newInstance(new Object[0]);
+      Object o = init.newInstance();
-  // TODO: registerDVDDeserializer is unused
-  public static void registerDVDDeserializer(DataSerializer dvddeslzr) {
-    dvddeserializer = dvddeslzr;
-  }
-
+      case DATA_SERIALIZABLE:
-        return null;
-      case DATA_SERIALIZABLE:
-        return readDataSerializable(in);
-      out.write((int) data >>> 0 & 0xFF);
+      out.write((int) data & 0xFF);
-    } else if (code == LONG_VL) {
-      result = in.readLong();
-      throw new IllegalStateException("unexpected variable length code=" + code);
+      result = in.readLong();
-  public static Class<?> getCachedClass(String p_className) throws ClassNotFoundException {
+  @SuppressWarnings("unchecked")
+  public static <T> Class<T> getCachedClass(String p_className) throws ClassNotFoundException {
-      return ClassPathLoader.getLatest().forName(className);
+      return (Class<T>) ClassPathLoader.getLatest().forName(className);
-      return result;
+      return (Class<T>) result;
-   * Serializes a list of Integers. The argument may be null. Deserialize with
-   * readListOfIntegers().
-   *
-   * TODO: writeListOfIntegers is unused
-   */
-  public void writeListOfIntegers(List<Integer> list, DataOutput out) throws IOException {
-    if (list != null) {
-      InternalDataSerializer.writeArrayLength(list.size(), out);
-      for (Integer entry : list) {
-        out.writeInt(entry);
-      }
-    } else {
-      InternalDataSerializer.writeArrayLength(-1, out);
-    }
-  }
-
-  /**
-        Class<?> c;
+        Class<? extends DataSerializer> c;
-          c = getCachedClass(this.className); // fix for bug 41206
+          c = getCachedClass(this.className);
-        } catch (IllegalArgumentException ex) {
-          logger.warn(
-              "Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}",
-              this.className, getFullMessage(ex));
-        } catch (IllegalStateException ex) {
+        } catch (IllegalArgumentException | IllegalStateException ex) {
-        } catch (IllegalArgumentException ex) {
-          logger.warn(
-              "Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}",
-              this.className, getFullMessage(ex));
-        } catch (IllegalStateException ex) {
+        } catch (IllegalArgumentException | IllegalStateException ex) {
-      this.eventId = (EventID) DataSerializer.readObject(in);
+      this.eventId = DataSerializer.readObject(in);
-    protected Class resolveProxyClass(String[] interfaces)
-        throws IOException, ClassNotFoundException {
+    protected Class resolveProxyClass(String[] interfaces) throws ClassNotFoundException {
-  protected abstract static class WellKnownPdxDS extends WellKnownDS {
+  abstract static class WellKnownPdxDS extends WellKnownDS {

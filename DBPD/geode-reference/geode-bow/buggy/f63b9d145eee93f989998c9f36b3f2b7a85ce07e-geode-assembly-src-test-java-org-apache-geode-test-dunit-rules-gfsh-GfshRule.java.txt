GEODE-3103: GfshRule no longer clutters output

 - GfshRule writes via a logger rather than StdOut.  This will make it no longer clutter precheckin runs or the nightly build.
 - Introduce ProcessLogger to capture output from the Gfsh JVM so that tests can assert against the output.

+import java.util.stream.Collectors;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
-  private List<Process> processes = new ArrayList<>();
+  private List<GfshExecution> gfshExecutions;
-  public Process execute(String... commands) {
+  public GfshExecution execute(String... commands) {
-  public Process execute(GfshScript gfshScript) {
-    Process process;
+  protected GfshExecution execute(GfshScript gfshScript) {
+    GfshExecution gfshExecution;
-      process = gfshScript.toProcessBuilder(gfsh, temporaryFolder.getRoot()).start();
+      File workingDir = temporaryFolder.newFolder(gfshScript.getName());
+      Process process = toProcessBuilder(gfshScript, gfsh, workingDir).start();
+      gfshExecution = new GfshExecution(process, workingDir);
+      gfshExecutions.add(gfshExecution);
+      gfshScript.awaitIfNecessary(process);
-    processes.add(process);
-    gfshScript.awaitIfNecessary(process);
-
-    return process;
+    return gfshExecution;
+    gfshExecutions = new ArrayList<>();
-    stopMembersQuietly();
-    processes.forEach(Process::destroyForcibly);
-    processes.forEach((Process process) -> {
-      try {
-        // Process.destroyForcibly() may not terminate immediately
-        process.waitFor(1, TimeUnit.MINUTES);
-      } catch (InterruptedException ignore) {
-        // We ignore this exception so that we still attempt the rest of the cleanup.
-      }
-    });
+    gfshExecutions.stream().map(GfshExecution::getWorkingDir).collect(Collectors.toList())
+        .forEach(this::stopMembersQuietly);
+
+    gfshExecutions.stream().map(GfshExecution::getProcess).map(Process::destroyForcibly)
+        .forEach((Process process) -> {
+          try {
+            // Process.destroyForcibly() may not terminate immediately
+            process.waitFor(1, TimeUnit.MINUTES);
+          } catch (InterruptedException ignore) {
+            // We ignore this exception so that we still attempt the rest of the cleanup.
+          }
+        });
+
-  private void stopMembersQuietly() {
-    File[] directories = temporaryFolder.getRoot().listFiles(File::isDirectory);
+  protected ProcessBuilder toProcessBuilder(GfshScript gfshScript, Path gfshPath, File workingDir) {
+    List<String> commandsToExecute = new ArrayList<>();
+    commandsToExecute.add(gfshPath.toAbsolutePath().toString());
+
+    for (String command : gfshScript.getCommands()) {
+      commandsToExecute.add("-e " + command);
+    }
+
+    return new ProcessBuilder(commandsToExecute).directory(workingDir);
+  }
+
+  private void stopMembersQuietly(File parentDirectory) {
+    File[] potentalMemberDirectories = parentDirectory.listFiles(File::isDirectory);
-    Arrays.stream(directories).filter(isServerDir).forEach(this::stopServerInDir);
-    Arrays.stream(directories).filter(isLocatorDir).forEach(this::stopLocatorInDir);
+    Arrays.stream(potentalMemberDirectories).filter(isServerDir).forEach(this::stopServerInDir);
+    Arrays.stream(potentalMemberDirectories).filter(isLocatorDir).forEach(this::stopLocatorInDir);
-    GfshScript stopServerScript = new GfshScript("stop server --dir=" + dir.getAbsolutePath())
-        .awaitQuietlyAtMost(1, TimeUnit.MINUTES);
+    String stopServerCommand =
+        new CommandStringBuilder("stop server").addOption("dir", dir).toString();
+    GfshScript stopServerScript = new GfshScript(stopServerCommand).awaitQuietly();
-    GfshScript stopServerScript = new GfshScript("stop locator --dir=" + dir.getAbsolutePath())
-        .awaitQuietlyAtMost(1, TimeUnit.MINUTES);
+    String stopLocatorCommand =
+        new CommandStringBuilder("stop locator").addOption("dir", dir).toString();
+    GfshScript stopServerScript = new GfshScript(stopLocatorCommand).awaitQuietly();
+

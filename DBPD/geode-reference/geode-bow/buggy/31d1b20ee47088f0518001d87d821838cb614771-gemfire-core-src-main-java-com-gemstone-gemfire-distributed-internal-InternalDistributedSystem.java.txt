Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.internal.LinuxProcFsStatistics;
+import com.gemstone.gemfire.internal.cache.BridgeServerImpl;
+import com.gemstone.gemfire.internal.cache.xmlcache.BridgeServerCreation;
+import com.gemstone.gemfire.internal.offheap.MemoryAllocator;
+import com.gemstone.gemfire.internal.offheap.OffHeapStorage;
+  public static final CreationStackGenerator DEFAULT_CREATION_STACK_GENERATOR = new CreationStackGenerator() {
+    @Override
+    public Throwable generateCreationStack(final DistributionConfig config) {
+      return null;
+    }
+  };
+
-  public static final AtomicReference<CreationStackGenerator> TEST_CREATION_STACK_GENERATOR = new AtomicReference<CreationStackGenerator>(
-      new CreationStackGenerator() {
-        @Override
-        public Throwable generateCreationStack(final DistributionConfig config) {
-          return null;
-        }
-      });
-  
+  public static final AtomicReference<CreationStackGenerator> TEST_CREATION_STACK_GENERATOR = new AtomicReference<CreationStackGenerator>(DEFAULT_CREATION_STACK_GENERATOR);
+  private MemoryAllocator offHeapStore = null;
+  
+  public MemoryAllocator getOffHeapStore() {
+    return this.offHeapStore;
+  }
+  
+    final long offHeapMemorySize = OffHeapStorage.parseOffHeapMemorySize(getConfig().getOffHeapMemorySize());
+
+    this.offHeapStore = OffHeapStorage.createOffHeapStorage(getLogWriter(), this, offHeapMemorySize, this);
+    
+    // Note: this can only happen on a linux system
+    if (getConfig().getLockMemory()) {
+      // This calculation is not exact, but seems fairly close.  So far we have
+      // not loaded much into the heap and the current RSS usage is already 
+      // included the available memory calculation.
+      long avail = LinuxProcFsStatistics.getAvailableMemory(logger);
+      long size = offHeapMemorySize + Runtime.getRuntime().totalMemory();
+      if (avail < size) {
+        if (GemFireCacheImpl.ALLOW_MEMORY_LOCK_WHEN_OVERCOMMITTED) {
+          logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+        } else {
+          throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT.toLocalizedString(avail, size));
+        }
+      }
+      
+      logger.info("Locking memory. This may take a while...");
+      GemFireCacheImpl.lockMemory();
+      logger.info("Finished locking memory.");
+    }
+
+        if (getOffHeapStore() != null) {
+          getOffHeapStore().close();
+        }
+      } finally {
+      try {
+      }
+    List<BridgeServerCreation> cacheServerCreation = null;
+    
+        cacheServerCreation = cache.getCacheConfig().getCacheServerCreation();
-        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING, new Object[]{reconnectAttemptCounter}));
+        logger.info("Disconnecting old DistributedSystem to prepare for a reconnect attempt");
+            if (cacheServerCreation != null) {
+              for (BridgeServerCreation bridge: cacheServerCreation) {
+                BridgeServerImpl impl = (BridgeServerImpl)cache.addCacheServer();
+                impl.configureFrom(bridge);
+                try {
+                  if (!impl.isRunning()) {
+                    impl.start();
+                  }
+                } catch (IOException ex) {
+                  throw new GemFireIOException(
+                      LocalizedStrings.CacheCreation_WHILE_STARTING_BRIDGE_SERVER_0
+                          .toLocalizedString(impl), ex);
+                }
+              }
+            }

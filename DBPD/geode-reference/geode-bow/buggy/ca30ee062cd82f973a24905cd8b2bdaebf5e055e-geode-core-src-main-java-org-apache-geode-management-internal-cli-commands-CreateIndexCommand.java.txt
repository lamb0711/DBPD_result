GEODE-4858: refactor CreateIndexCommand and jdbc commands (#1853)

* use ClusterConfigurationService
* introduce SingleGfshCommand to ease update of cluster configuration
* get rid of default methods in CluterConfigurationService
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.RegionConfig;
-import org.apache.geode.distributed.internal.InternalClusterConfigurationService;
-import org.apache.geode.management.internal.cli.domain.IndexInfo;
+import org.apache.geode.management.cli.SingleGfshCommand;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
+import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.configuration.domain.XmlEntity;
-public class CreateIndexCommand extends InternalGfshCommand {
+public class CreateIndexCommand extends SingleGfshCommand {
-  // TODO : Add optionContext for indexName
-          help = CliStrings.CREATE_INDEX__GROUP__HELP) final String[] group) {
+          help = CliStrings.CREATE_INDEX__GROUP__HELP) final String[] groups) {
-    Result result;
-    final Set<DistributedMember> targetMembers = findMembers(group, memberNameOrID);
+    CommandResult result;
+    final Set<DistributedMember> targetMembers = findMembers(groups, memberNameOrID);
-    IndexInfo indexInfo = new IndexInfo(indexName, indexedExpression, regionPath, indexType);
-    List<CliFunctionResult> functionResults =
-        executeAndGetFunctionResult(createIndexFunction, indexInfo, targetMembers);
-    result = ResultBuilder.buildResult(functionResults);
-    XmlEntity xmlEntity = findXmlEntity(functionResults);
-
-    if (xmlEntity != null) {
-      persistClusterConfiguration(result,
-          () -> ((InternalClusterConfigurationService) getConfigurationService())
-              .addXmlEntity(xmlEntity, group));
+    RegionConfig.Index index = new RegionConfig.Index();
+    index.setName(indexName);
+    index.setExpression(indexedExpression);
+    index.setFromClause(regionPath);
+    if (indexType == IndexType.PRIMARY_KEY) {
+      index.setKeyIndex(true);
+    } else {
+      index.setKeyIndex(false);
+      index.setType(indexType.getName());
+
+    List<CliFunctionResult> functionResults =
+        executeAndGetFunctionResult(createIndexFunction, index, targetMembers);
+    result = ResultBuilder.buildResult(functionResults);
+    result.setConfigObject(index);
+
+  String getValidRegionName(String regionPath, CacheConfig cacheConfig) {
+    // Check to see if the region path contains an alias e.g "/region1 r1"
+    // Then the first string will be the regionPath
+    String[] regionPathTokens = regionPath.trim().split(" ");
+    regionPath = regionPathTokens[0];
+    // check to see if the region path is in the form of "--region=region.entrySet() z"
+    while (regionPath.contains(".") && cacheConfig.findRegionConfiguration(regionPath) == null) {
+      regionPath = regionPath.substring(0, regionPath.lastIndexOf("."));
+    }
+    return regionPath;
+  }
+
+  @Override
+  public void updateClusterConfig(String group, CacheConfig config, Object element) {
+    RegionConfig.Index index = (RegionConfig.Index) element;
+    String regionPath = getValidRegionName(index.getFromClause(), config);
+
+    RegionConfig regionConfig = config.findRegionConfiguration(regionPath);
+    if (regionConfig == null) {
+      throw new EntityNotFoundException("Region " + index.getFromClause() + " not found.");
+    }
+    regionConfig.getIndex().add(index);
+  }

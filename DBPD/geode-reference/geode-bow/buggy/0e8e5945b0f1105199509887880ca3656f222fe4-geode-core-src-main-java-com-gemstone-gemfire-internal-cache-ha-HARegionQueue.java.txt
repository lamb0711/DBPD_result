GEODE-1723 Merge from 82 for performance improvement.

Other improvement:We take lock on key while doing op on BucketRegion.
In that case we notify to other thread only when there is a thread
waiting for it. Modified one condition to log message to reduce garbage.

-   * The underlying map (may hold reference to a Region or a HashMap) for this
-   * HARegionQueue instance (and also shared by all the HARegionQueue instances
-   * associated with the same CacheClientNotifier).
+   * The underlying map (may hold reference to a Region or a ConcurrentHashMap)
+   * for this HARegionQueue instance (and also shared by all the HARegionQueue
+   * instances associated with the same CacheClientNotifier).
-    // TODO : Dinesh : verify whether (batchSize * 2) is needed or not
-    List batch = new ArrayList(batchSize * 2);
+    List batch = new ArrayList(limit);
+          
-              CqNameToOp cqNames = ((ClientUpdateMessage)event).getClientCq(clientProxyID);
+              CqNameToOp cqNames = ((ClientUpdateMessage) event).getClientCq(clientProxyID);
-                for (String cqName: cqNames.getNames()) {
-                  InternalCqQuery cq = ((InternalCqQuery)cqService.getClientCqFromServer(clientProxyID, cqName));
+                for (String cqName : cqNames.getNames()) {
+                  InternalCqQuery cq = ((InternalCqQuery) cqService.getClientCqFromServer(clientProxyID, cqName));
-      }
-      catch (Exception e) {
-       //catch exceptions that arise due to maintaining cq stats
-        //as maintaining cq stats should not affect the system.
+      } catch (Exception e) {
+        // catch exceptions that arise due to maintaining cq stats
+        // as maintaining cq stats should not affect the system.
-      container = new HAContainerMap(new HashMap());
+      container = new HAContainerMap(new ConcurrentHashMap());
-      container = new HAContainerMap(new HashMap());
+      container = new HAContainerMap(new ConcurrentHashMap());
-          Map.Entry entry = null;
-          synchronized (this.haContainer) {
-            entry = (Map.Entry)((HAContainerWrapper)this.haContainer)
+          //synchronized (this.haContainer) {
+          HAEventWrapper original = null;
+          do {
+            ClientUpdateMessageImpl old = (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer).putIfAbsent(haEventWrapper,
+                haEventWrapper.getClientUpdateMessage());
+            if (old != null) {
+              original = (HAEventWrapper) ((HAContainerWrapper) this.haContainer).getKey(haEventWrapper);
+              if (original == null) {
+                continue;
+              }
+              synchronized (original) {
+                // assert the entry is still present
+                if (((HAContainerWrapper) this.haContainer).getKey(original) != null) {
+                  original.incAndGetReferenceCount();
+                  addClientCQsAndInterestList(old, haEventWrapper, this.haContainer, this.regionName);
+                  haEventWrapper = original;
+                } else {
+                  original = null;
+                }
+              }
+            } else {
+              synchronized (haEventWrapper) {
+                haEventWrapper.incAndGetReferenceCount();
+                haEventWrapper.setHAContainer(this.haContainer);
+                if (!haEventWrapper.getPutInProgress()) {
+                  // This means that this is a GII'ed event. Hence we must
+                  // explicitly set 'clientUpdateMessage' to null.
+                  haEventWrapper.setClientUpdateMessage(null);
+                }
+                haEventWrapper.setIsRefFromHAContainer(true);
+              }
+              break;
+            }
+          } while (original == null);
+          /*  entry = (Map.Entry)((HAContainerWrapper)this.haContainer)
-          }
+          }//haContainer synchronized ends
-          }
+          }*/
-  public static void addClientCQsAndInterestList(Map.Entry entry,
-      HAEventWrapper haEventWrapper, Map haContainer, String regionName) {
+  public static void addClientCQsAndInterestList(ClientUpdateMessageImpl msg, HAEventWrapper haEventWrapper, Map haContainer, String regionName) {
-    ClientProxyMembershipID proxyID = ((HAContainerWrapper)haContainer)
-        .getProxyID(regionName);
+    ClientProxyMembershipID proxyID = ((HAContainerWrapper) haContainer).getProxyID(regionName);
-        ((ClientUpdateMessageImpl)entry.getValue()).addClientCqs(proxyID,
-            clientCQ);
+        msg.addClientCqs(proxyID, clientCQ);
-    ClientUpdateMessageImpl clientMsg = (ClientUpdateMessageImpl)haEventWrapper
-        .getClientUpdateMessage();
+    ClientUpdateMessageImpl clientMsg = (ClientUpdateMessageImpl) haEventWrapper.getClientUpdateMessage();
-      ((ClientUpdateMessageImpl)entry.getValue()).addClientInterestList(
-          proxyID, true);
-    }
-    else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
-      ((ClientUpdateMessageImpl)entry.getValue()).addClientInterestList(
-          proxyID, false);
+      msg.addClientInterestList(proxyID, true);
+    } else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
+      msg.addClientInterestList(proxyID, false);
-    Conflatable cum = null;
+    Conflatable msg = null;
-      cum = (Conflatable)HARegionQueue.this.haContainer.get(wrapper);
-      if (cum != null) {
+      msg = (Conflatable)HARegionQueue.this.haContainer.get(wrapper);
+      if (msg != null) {
-      cum = conflatable;
+      msg = conflatable;
-    return cum;
+    return msg;
-      synchronized (this.haContainer) {
+      synchronized (wrapper) {

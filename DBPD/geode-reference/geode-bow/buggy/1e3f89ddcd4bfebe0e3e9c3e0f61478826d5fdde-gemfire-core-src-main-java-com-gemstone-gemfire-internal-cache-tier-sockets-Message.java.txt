GEODE-478: Message class length field overflows if size is > 2GB

Message size is now restricted to 1GB.  If this is exceeded a
MessageTooLargeException is thrown.

I think the original intent of this ticket was to have messaging handle
the carving up of the message into multiple Messages somehow, but I think
this is the correct approach.  This will ensure that the problem doesn't
cause the current connection to be terminated and the operation retried
on another server and make sure that the exception gets back to the point
of initiation.

Barry already has a way to avoid large messages in WAN senders that can
be ported to Geode.

+  /**
+   * maximum size of an outgoing message.  See GEODE-478
+   */
+  static final int MAX_MESSAGE_SIZE = Integer.getInteger("gemfire.client.max-message-size", 1073741824).intValue();
+
+  
+  /**
+   * For boundary testing we may need to inject mock parts
+   * @param parts
+   */
+  void setParts(Part[] parts) {
+    this.partsList = parts;
+  }
+      int msgLen = 0;
-        int numOfSecureParts = 0;
-        Part securityPart = this.getSecurityPart();
-        boolean isSecurityHeader = false;
+        long totalPartLen = 0;
+        long headerLen = 0;
+        int partsToTransmit = this.numberOfParts;
-        if (securityPart != null) {
-          isSecurityHeader = true;
-          numOfSecureParts = 1;
-        }
-        else if (this.securePart != null) {
-          // This is a client sending this message.
-          securityPart = this.securePart;
-          isSecurityHeader = true;
-          numOfSecureParts = 1;          
-        }
-
-        int totalPartLen = 0;
-        for (int i=0;i<this.numberOfParts;i++){
+        for (int i=0; i < this.numberOfParts; i++) {
+          headerLen += PART_HEADER_SIZE;
-        if(numOfSecureParts == 1) {
-          totalPartLen += securityPart.getLength();
+        Part securityPart = this.getSecurityPart();
+        if (securityPart == null) {
+          securityPart = this.securePart;
-        int msgLen = (PART_HEADER_SIZE * (this.numberOfParts + numOfSecureParts)) + totalPartLen;
+        if (securityPart != null) {
+          headerLen += PART_HEADER_SIZE;
+          totalPartLen += securityPart.getLength();
+          partsToTransmit++;
+        }
+
+        if ( (headerLen + totalPartLen) > Integer.MAX_VALUE ) {
+          throw new MessageTooLargeException("Message size (" + (headerLen + totalPartLen) 
+              + ") exceeds maximum integer value");
+        }
+        
+        msgLen = (int)(headerLen + totalPartLen);
+        
+        if (msgLen > MAX_MESSAGE_SIZE) {
+          throw new MessageTooLargeException("Message size(" + msgLen
+              + ") exceeds gemfire.client.max-message-size setting (" + MAX_MESSAGE_SIZE + ")");
+        }
+        
-        packHeaderInfoForSending(msgLen, isSecurityHeader);
-        for (int i=0;i<this.numberOfParts + numOfSecureParts;i++) {
-          Part part = null;
-          if(i == this.numberOfParts) {
-            part = securityPart;
-          }
-          else {
-            part = partsList[i];
-          }
+        packHeaderInfoForSending(msgLen, (securityPart != null));
+        for (int i=0; i < partsToTransmit; i++) {
+          Part part = (i == this.numberOfParts) ? securityPart : partsList[i];
+
+          
-            part.sendTo(cb);
+            part.writeTo(cb);
-            // send partBytes
-              part.sendTo(this.sockCh, cb);
+              part.writeTo(this.sockCh, cb);
-              part.sendTo(this.os, cb);
+              part.writeTo(this.os, cb);

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
-  private static ThreadLocal<AtomicBoolean> queryExecutionStatus =
-      new ThreadLocal<AtomicBoolean>() {
-        @Override
-        protected AtomicBoolean initialValue() {
-          return new AtomicBoolean(Boolean.FALSE);
-        }
-      };
+  private static final ThreadLocal<AtomicBoolean> queryExecutionStatus =
+      ThreadLocal.withInitial(() -> new AtomicBoolean(Boolean.FALSE));
+
-  /** For DUnit test purpose */
+  /** For DUnit test purpose TODO: delete this ConcurrentMap */
+
-      queryThreads.notify();
+      queryThreads.notifyAll();
-    /** For dunit test purpose */
+    // For dunit test purpose
-   * 
-   * @param queryThread
-    DefaultQuery q = (DefaultQuery) query;
-    boolean[] queryCompleted = q.getQueryCompletedForMonitoring();
+    DefaultQuery defaultQuery = (DefaultQuery) query;
+    boolean[] queryCompleted = defaultQuery.getQueryCompletedForMonitoring();
-          if ((currentTime - queryTask.StartTime) > maxTimeSet) {
+          if (currentTime - queryTask.StartTime > maxTimeSet) {
-      q.setQueryCompletedForMonitoring(true);
+      defaultQuery.setQueryCompletedForMonitoring(true);
-    synchronized (stopped) {
+    synchronized (this.stopped) {
-      stopped.set(Boolean.TRUE);
+      this.stopped.set(Boolean.TRUE);
+  @Override
-    synchronized (stopped) {
-      if (stopped.get()) {
+    synchronized (this.stopped) {
+      if (this.stopped.get()) {
-      QueryThreadTask queryTask = null;
-      long sleepTime = 0;
+      QueryThreadTask queryTask;
+      long sleepTime;
+      // TODO: while-block cannot complete without throwing
-          synchronized (this.queryThreads) {
-            this.queryThreads.wait();
+          synchronized (queryThreads) {
+            queryThreads.wait();
-        if ((currentTime - queryTask.StartTime) < this.maxQueryExecutionTime) {
+        if (currentTime - queryTask.StartTime < this.maxQueryExecutionTime) {
-    } catch (InterruptedException ex) {
+    } catch (InterruptedException ignore) {
-      this.queryThreads.clear();
+      queryThreads.clear();
-  // Assumes LOW_MEMORY will only be set if query monitor is enabled
+  /**
+   * Assumes LOW_MEMORY will only be set if query monitor is enabled
+   */
-    synchronized (this.queryThreads) {
+    synchronized (queryThreads) {
-      queryThreads.notify();
+      queryThreads.notifyAll();
-      if (!queryCompleted[0]) { // cancel if query is not completed
+      if (!queryCompleted[0]) {
+        // cancel if query is not completed
-  // FOR TEST PURPOSE
+  /** FOR TEST PURPOSE */
-    return this.queryThreads.size();
+    return queryThreads.size();
-   *
-  private class QueryThreadTask {
+  private static class QueryThreadTask {
-    private final long StartTime;
+    // package-private to avoid synthetic accessor
+    final long StartTime;
-    private final Thread queryThread;
+    // package-private to avoid synthetic accessor
+    final Thread queryThread;
-    private final Query query;
+    // package-private to avoid synthetic accessor
+    final Query query;
-    private final AtomicBoolean queryExecutionStatus;
-
+    // package-private to avoid synthetic accessor
+    final AtomicBoolean queryExecutionStatus;
-      return new StringBuffer().append("QueryThreadTask[StartTime:").append(this.StartTime)
+      return new StringBuilder().append("QueryThreadTask[StartTime:").append(this.StartTime)
-          .append(", queryExecutionStatus:").append(this.queryExecutionStatus).append("]")
+          .append(", queryExecutionStatus:").append(this.queryExecutionStatus).append(']')
-

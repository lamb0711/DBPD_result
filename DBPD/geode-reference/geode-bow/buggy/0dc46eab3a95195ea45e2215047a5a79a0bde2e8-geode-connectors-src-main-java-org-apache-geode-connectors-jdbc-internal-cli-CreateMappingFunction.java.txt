GEODE-6010: change create jdbc-mapping to alter region and create async-queue (#2836)

create jdbc-mapping now also does the following:
-- alters the region to have a JdbcLoader as its cache-loader
-- if synchronous, alters the region to have a JdbcWriter as its cache-writer
-- if asynchronous, creates an async-event-queue and alters regions to have it
The async-event-queue is created parallel for partitioned regions, and serial for all other regions.

create jdbc-mapping now requires cluster configuration and uses it to check
all required preconditions before the command starts changing things.
 
Co-authored-by: Darrel Schneider <dschneider@pivotal.io>
Co-authored-by: Jianxia Chen <jchen@pivotal.io>
Co-authored-by: Scott Jewell <sjewell@pivotal.io>

+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.asyncqueue.AsyncEventQueueFactory;
+import org.apache.geode.connectors.jdbc.JdbcAsyncWriter;
+import org.apache.geode.connectors.jdbc.JdbcLoader;
+import org.apache.geode.connectors.jdbc.JdbcWriter;
+/**
+ * The Object[] must always be of size two.
+ * The first element must be a RegionMapping.
+ * The second element must be a Boolean that is true if synchronous.
+ */
-public class CreateMappingFunction extends CliFunction<RegionMapping> {
+public class CreateMappingFunction extends CliFunction<Object[]> {
-  public CliFunctionResult executeFunction(FunctionContext<RegionMapping> context)
+  public CliFunctionResult executeFunction(FunctionContext<Object[]> context)
-    RegionMapping regionMapping = context.getArguments();
+    Object[] arguments = context.getArguments();
+    RegionMapping regionMapping = (RegionMapping) arguments[0];
+    boolean synchronous = (boolean) arguments[1];
-    verifyRegionExists(context, regionMapping);
+    String regionName = regionMapping.getRegionName();
+    Region<?, ?> region = verifyRegionExists(context.getCache(), regionName);
+    String queueName = CreateMappingCommand.createAsyncEventQueueName(regionName);
+    if (!synchronous) {
+      createAsyncEventQueue(context.getCache(), queueName,
+          region.getAttributes().getDataPolicy().withPartitioning());
+    }
+    alterRegion(region, queueName, synchronous);
-  private void verifyRegionExists(FunctionContext<RegionMapping> context,
-      RegionMapping regionMapping) {
-    Cache cache = context.getCache();
-    String regionName = regionMapping.getRegionName();
-    if (cache.getRegion(regionName) == null) {
+  /**
+   * Change the existing region to have
+   * the JdbcLoader as its cache-loader
+   * and the given async-event-queue as one of its queues.
+   */
+  private void alterRegion(Region<?, ?> region, String queueName, boolean synchronous) {
+    region.getAttributesMutator().setCacheLoader(new JdbcLoader());
+    if (synchronous) {
+      region.getAttributesMutator().setCacheWriter(new JdbcWriter());
+    } else {
+      region.getAttributesMutator().addAsyncEventQueueId(queueName);
+    }
+  }
+
+  /**
+   * Create an async-event-queue with the given name.
+   * For a partitioned region a parallel queue is created.
+   * Otherwise a serial queue is created.
+   */
+  private void createAsyncEventQueue(Cache cache, String queueName, boolean isPartitioned) {
+    AsyncEventQueueFactory asyncEventQueueFactory = cache.createAsyncEventQueueFactory();
+    asyncEventQueueFactory.setParallel(isPartitioned);
+    asyncEventQueueFactory.create(queueName, new JdbcAsyncWriter());
+  }
+
+  private Region<?, ?> verifyRegionExists(Cache cache, String regionName) {
+    Region<?, ?> result = cache.getRegion(regionName);
+    if (result == null) {
+    return result;

GEODE-2080 Rest POST put call not working with region valueConstraint

If you set a value constraint on a cache Region you will be unable to store
objects in the region via the Rest API.  This change-set modifies
LocalRegion's constraint check to look for a Rest document and use its
type name in the constraint check

-import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.*;
-
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.AbstractSet;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.logging.log4j.Logger;
+import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+import org.apache.geode.pdx.JSONFormatter;
+import org.apache.geode.pdx.PdxInstance;
+import org.apache.logging.log4j.Logger;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.AbstractSet;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
-   * Currently used by the OpLog layer to initialize the {@link KeyWithRegionContext} if required.
+   * Currently used by the OpLog layer.
-   * Set to true if the region contains keys implementing {@link KeyWithRegionContext} that require
-   * setting up of region specific context after deserialization or recovery from disk.
-   */
-  private boolean keyRequiresRegionContext;
-
-  /**
+
-        if (!this.valueConstraint.isInstance(value))
+        if (!this.valueConstraint.isInstance(value)) {
+          String valueClassName = value.getClass().getName();
+          // check for a REST object, which has a @type field denoting its class
+          if (value instanceof PdxInstance) {
+            PdxInstance pdx = (PdxInstance) value;
+            if (pdx.getClassName().equals(JSONFormatter.JSON_CLASSNAME)) {
+              Object type = (String) pdx.getField("@type");
+              if (type != null && type instanceof String) {
+                valueClassName = (String) type;
+              } else {
+                return;
+              }
+            }
+            if (valueClassName.equals(this.valueConstraint.getName())) {
+              return;
+            }
+          }
-                      new Object[] {value.getClass().getName(), this.valueConstraint.getName()}));
+                      new Object[] {valueClassName, this.valueConstraint.getName()}));
+        }

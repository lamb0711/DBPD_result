GEODE-6529: Add timers for LocalRegion operations

* Add cache.region.operations.puts create timer.
* Add cache.region.operations.puts put timer.
* Add cache.region.operations.puts put-if-absent timer.
* Add cache.region.operations.puts replace timer.
* Add cache.region.operations.gets get timer.
* Add cache.region.operations.gets get-entry timer.
* Add cache.region.operations.contains containsKey timer.
* Add cache.region.operations.contains containsValue timer.
* Add cache.region.operations.contains containsKeyOnServer timer.
* Add cache.region.operations.contains containsValueForKey timer.

Co-authored-by: Michael Oleske <moleske@pivotal.io>
Co-authored-by: Dale Emery <demery@pivotal.io>
Co-authored-by: Kirk Lund <klund@apache.org>

+import io.micrometer.core.instrument.Timer;
+  private final Timer createTimer;
+  private final Timer putTimer;
+  private final Timer putIfAbsentTimer;
+  private final Timer replaceTimer;
+  private final Timer getTimer;
+  private final Timer getEntryTimer;
+  private final Timer containsKeyTimer;
+  private final Timer containsValueTimer;
+  private final Timer containsKeyOnServerTimer;
+  private final Timer containsValueForKeyTimer;
-    this(regionName, attrs, parentRegion, cache, internalRegionArgs, new LocalRegionDataView(),
-        RegionMapFactory::createVM, new DefaultEntryEventFactory());
+    this(regionName, attrs, parentRegion, cache, internalRegionArgs, new LocalRegionDataView());
-        RegionMapFactory::createVM, new DefaultEntryEventFactory());
+        RegionMapFactory::createVM, new DefaultServerRegionProxyConstructor(),
+        new DefaultEntryEventFactory(), (poolName) -> (PoolImpl) PoolManager.find(poolName));
-      InternalDataView internalDataView,
-      RegionMapConstructor regionMapConstructor, EntryEventFactory entryEventFactory)
+      InternalDataView internalDataView, RegionMapConstructor regionMapConstructor,
+      ServerRegionProxyConstructor serverRegionProxyConstructor,
+      EntryEventFactory entryEventFactory, PoolFinder poolFinder)
-    super(cache, attrs, regionName, internalRegionArgs);
+    super(cache, attrs, regionName, internalRegionArgs, poolFinder);
+
+    this.regionMapConstructor = regionMapConstructor;
+    this.entryEventFactory = entryEventFactory;
-    this.regionMapConstructor = regionMapConstructor;
-    this.entryEventFactory = entryEventFactory;
-    this.serverRegionProxy = this.getPoolName() != null ? new ServerRegionProxy(this) : null;
-    this.imageState = new UnsharedImageState(this.serverRegionProxy != null,
+    this.serverRegionProxy =
+        this.getPoolName() != null ? serverRegionProxyConstructor.create(this) : null;
+    this.imageState = new UnsharedImageState(getPoolName() != null,
+
+    createTimer = Timer.builder("cache.region.operations.puts")
+        .tag("region.name", regionName)
+        .tag("put.type", "create")
+        .register(cache.getMeterRegistry());
+
+    putTimer = Timer.builder("cache.region.operations.puts")
+        .tag("region.name", regionName)
+        .tag("put.type", "put")
+        .register(cache.getMeterRegistry());
+
+    putIfAbsentTimer = Timer.builder("cache.region.operations.puts")
+        .tag("region.name", regionName)
+        .tag("put.type", "put-if-absent")
+        .register(cache.getMeterRegistry());
+
+    replaceTimer = Timer.builder("cache.region.operations.puts")
+        .tag("region.name", regionName)
+        .tag("put.type", "replace")
+        .register(cache.getMeterRegistry());
+
+    getTimer = Timer.builder("cache.region.operations.gets")
+        .tag("region.name", regionName)
+        .tag("get.type", "get")
+        .register(cache.getMeterRegistry());
+
+    getEntryTimer = Timer.builder("cache.region.operations.gets")
+        .tag("region.name", regionName)
+        .tag("get.type", "get-entry")
+        .register(cache.getMeterRegistry());
+
+    containsKeyTimer = Timer.builder("cache.region.operations.contains")
+        .tag("region.name", regionName)
+        .tag("contains.type", "contains-key")
+        .register(cache.getMeterRegistry());
+
+    containsValueTimer = Timer.builder("cache.region.operations.contains")
+        .tag("region.name", regionName)
+        .tag("contains.type", "contains-value")
+        .register(cache.getMeterRegistry());
+
+    containsKeyOnServerTimer = Timer.builder("cache.region.operations.contains")
+        .tag("region.name", regionName)
+        .tag("contains.type", "contains-key-on-server")
+        .register(cache.getMeterRegistry());
+
+    containsValueForKeyTimer = Timer.builder("cache.region.operations.contains")
+        .tag("region.name", regionName)
+        .tag("contains.type", "contains-value-for-key")
+        .register(cache.getMeterRegistry());
-    @Released
-    EntryEventImpl event = newCreateEntryEvent(key, value, aCallbackArgument);
-    try {
-      validatedCreate(event, startPut);
-    } finally {
-      event.release();
-    }
+    createTimer.record(() -> {
+      @Released
+      EntryEventImpl event = newCreateEntryEvent(key, value, aCallbackArgument);
+      try {
+        validatedCreate(event, startPut);
+      } finally {
+        event.release();
+      }
+    });
-    Object result =
-        get(key, aCallbackArgument, generateCallbacks, false, false, null, clientEvent, false);
-    if (Token.isInvalid(result)) {
-      result = null;
-    }
-    return result;
+    return getTimer.record(() -> {
+      Object result =
+          get(key, aCallbackArgument, generateCallbacks, false, false, null, clientEvent, false);
+      if (Token.isInvalid(result)) {
+        result = null;
+      }
+      return result;
+    });
-    @Released
-    EntryEventImpl event = newUpdateEntryEvent(key, value, aCallbackArgument);
-    try {
-      return validatedPut(event, startPut);
-    } finally {
-      event.release();
-    }
+    return putTimer.record(() -> {
+      @Released
+      EntryEventImpl event = newUpdateEntryEvent(key, value, aCallbackArgument);
+      try {
+        return validatedPut(event, startPut);
+      } finally {
+        event.release();
+      }
+    });
-    validateKey(key);
-    checkReadiness();
-    checkForNoAccess();
-    discoverJTA();
-    return getDataView().getEntry(getKeyInfo(key), this, false);
+    return getEntryTimer.record(() -> {
+      validateKey(key);
+      checkReadiness();
+      checkForNoAccess();
+      discoverJTA();
+      return getDataView().getEntry(getKeyInfo(key), this, false);
+    });
-    checkReadiness();
-    checkForNoAccess();
-    return getDataView().containsKey(getKeyInfo(key), this);
+    return containsKeyTimer.record(() -> {
+      checkReadiness();
+      checkForNoAccess();
+      return getDataView().containsKey(getKeyInfo(key), this);
+    });
-    discoverJTA();
-    return getDataView().containsValueForKey(getKeyInfo(key), this);
+    return containsValueForKeyTimer.record(() -> {
+      discoverJTA();
+      return getDataView().containsValueForKey(getKeyInfo(key), this);
+    });
-    checkReadiness();
-    checkForNoAccess();
-    ServerRegionProxy proxy = getServerProxy();
-    if (proxy != null) {
-      return proxy.containsKey(key);
-    } else {
-      throw new UnsupportedOperationException(
-          "Server keySet requires a pool.");
-    }
+    return containsKeyOnServerTimer.record(() -> {
+      checkReadiness();
+      checkForNoAccess();
+      ServerRegionProxy proxy = getServerProxy();
+      if (proxy != null) {
+        return proxy.containsKey(key);
+      } else {
+        throw new UnsupportedOperationException(
+            "Server keySet requires a pool.");
+      }
+    });
-    if (value == null) {
-      throw new NullPointerException(
-          "Value for containsValue(value) cannot be null");
-    }
-    checkReadiness();
-    checkForNoAccess();
-    boolean result = false;
-    for (Object entry : new EntriesSet(this, false, IteratorType.VALUES, false)) {
-      if (entry != null) {
-        if (value.equals(entry)) {
-          result = true;
-          break;
+    return containsValueTimer.record(() -> {
+      if (value == null) {
+        throw new NullPointerException(
+            "Value for containsValue(value) cannot be null");
+      }
+      checkReadiness();
+      checkForNoAccess();
+      boolean result = false;
+      for (Object entry : new EntriesSet(this, false, IteratorType.VALUES, false)) {
+        if (entry != null) {
+          if (value.equals(entry)) {
+            result = true;
+            break;
+          }
-    }
-    return result;
+      return result;
+    });
-    checkIfConcurrentMapOpsAllowed();
-    validateArguments(key, value, callbackArgument);
+    return putIfAbsentTimer.record(() -> {
+      checkIfConcurrentMapOpsAllowed();
+      validateArguments(key, value, callbackArgument);
-    // TODO ConcurrentMap.putIfAbsent() treats null as an invalidation operation
-    // BUT we need to return the old value, which Invalidate isn't currently doing
+      // TODO ConcurrentMap.putIfAbsent() treats null as an invalidation operation
+      // BUT we need to return the old value, which Invalidate isn't currently doing
-    checkReadiness();
-    checkForLimitedOrNoAccess();
-    discoverJTA();
+      checkReadiness();
+      checkForLimitedOrNoAccess();
+      discoverJTA();
-    // This used to call the constructor which took the old value. It
-    // was modified to call the other EntryEventImpl constructor so that
-    // an id will be generated by default. Null was passed in anyway.
-    // generate EventID
+      // This used to call the constructor which took the old value. It
+      // was modified to call the other EntryEventImpl constructor so that
+      // an id will be generated by default. Null was passed in anyway.
+      // generate EventID
-    @Released
-    EntryEventImpl event = entryEventFactory.create(this, Operation.PUT_IF_ABSENT, key, value,
-        callbackArgument, false, getMyId());
+      @Released
+      EntryEventImpl event = entryEventFactory.create(this, Operation.PUT_IF_ABSENT, key, value,
+          callbackArgument, false, getMyId());
-    try {
-      if (generateEventID()) {
-        event.setNewEventId(this.cache.getDistributedSystem());
-      }
-      final Object oldValue = null;
-      final boolean ifNew = true;
-      final boolean ifOld = false;
-      final boolean requireOldValue = true;
-      if (!basicPut(event, ifNew, ifOld, oldValue, requireOldValue)) {
-        Object result = event.getOldValue();
-        if (event.isPossibleDuplicate() && putIfAbsentResultHasSameValue(false, value, result)) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("possible duplicate putIfAbsent event and result is the value to be put,"
-                + " treat this as a successful putIfAbsent");
+      try {
+        if (generateEventID()) {
+          event.setNewEventId(this.cache.getDistributedSystem());
+        }
+        final Object oldValue = null;
+        final boolean ifNew = true;
+        final boolean ifOld = false;
+        final boolean requireOldValue = true;
+        if (!basicPut(event, ifNew, ifOld, oldValue, requireOldValue)) {
+          Object result = event.getOldValue();
+          if (event.isPossibleDuplicate() && putIfAbsentResultHasSameValue(false, value, result)) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("possible duplicate putIfAbsent event and result is the value to be put,"
+                  + " treat this as a successful putIfAbsent");
+            }
+            return null;
+          }
+          return result;
+        } else {
+          if (!getDataView().isDeferredStats()) {
+            getCachePerfStats().endPut(startPut, false);
-        return result;
-      } else {
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, false);
-        }
-        return null;
+      } catch (EntryNotFoundException ignore) {
+        return event.getOldValue();
+      } finally {
+        event.release();
-    } catch (EntryNotFoundException ignore) {
-      return event.getOldValue();
-    } finally {
-      event.release();
-    }
+    });
-    return replace(key, oldValue, newValue, null);
+    return replaceTimer.record(() -> replace(key, oldValue, newValue, null));
-  public boolean replace(Object key, Object expectedOldValue, Object newValue, Object callbackArg) {
-
+  private boolean replace(Object key, Object expectedOldValue, Object newValue,
+      Object callbackArg) {
-    return replaceWithCallbackArgument(key, value, null);
+    return replaceTimer.record(() -> replaceWithCallbackArgument(key, value, null));
+  @VisibleForTesting
+  interface ServerRegionProxyConstructor {
+    ServerRegionProxy create(Region region);
+  }
+
+  private static class DefaultServerRegionProxyConstructor implements ServerRegionProxyConstructor {
+    @Override
+    public ServerRegionProxy create(Region region) {
+      return new ServerRegionProxy(region);
+    }
+  }
+

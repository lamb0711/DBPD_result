GEODE-3052 Restarting 2 locators together causes potential locator split brain

There were four problems that new unit tests hit:
1. when recovering a view from disk we were treating it as a definitive
(live) view.  I've moved it to a new variable in GMSLocator and set its
viewId to -1.  At the same time I set the initial GMSJoinLeave
SearchState.viewId to -100 so it will be overridden by the one returned
by the locator.  These changes allow GmsJoinLeave to know that the
potential coordinator is from a recovered view.

2. when trying to join with a recovered view GMSJoinLeave.join() was giving
up after the second ID in the view and becoming the coordinator.  It needs
to keep trying until the list is exhausted, and it shouldn't sleep between
attempts.

3. GMSLocator wasn't returning registrants for use in
findCoordinatorFromView().  This was causing it to choose itself as
the coordinator instead of using registrant sort order and choosing
a different registrant as the coordinator.

4. During concurrent startup GMSLocator didn't know when the decision
was made to become coordinator.  It is now notified of this decision
and processRequest() uses this flag to have it override anything in
the registrants set or in the recovered view.

-  private boolean isCoordinator;
+  private volatile boolean isCoordinator;
-    int viewId = -1;
+    int viewId = -100;
+
+    public String toString() {
+      StringBuffer sb = new StringBuffer(200);
+      sb.append("SearchState(locatorsContacted=").append(locatorsContacted)
+          .append("; alreadyTried=").append(alreadyTried).append("; registrants=")
+          .append(registrants).append("; possibleCoordinator=").append(possibleCoordinator)
+          .append("; viewId=").append(viewId).append("; hasContactedAJoinedLocator=")
+          .append(hasContactedAJoinedLocator).append("; view=").append(view).append("; responses=")
+          .append(responses).append(")");
+      return sb.toString();
+    }
+        logger.debug("state after looking for membership coordinator is {}", state);
-            // reset the tries count and timer since we haven't actually tried to join yet
-          logger.debug("sleeping for {} before making another attempt to find the coordinator",
-              retrySleep);
-          Thread.sleep(retrySleep);
+          if (found && !state.hasContactedAJoinedLocator) {
+            // if locators are restarting they may be handing out IDs from a stale view that
+            // we should go through quickly. Otherwise we should sleep a bit to let failure
+            // detection select a new coordinator
+            if (state.possibleCoordinator.getVmViewId() < 0) {
+              logger.debug("sleeping for {} before making another attempt to find the coordinator",
+                  retrySleep);
+              Thread.sleep(retrySleep);
+            }
+            // since we were given a coordinator that couldn't be used we should keep trying
+            tries = 0;
+            giveupTime = System.currentTimeMillis() + timeout;
+          }
-    logger.debug("Recording the request to be processed in the next membership view");
-    synchronized (viewRequests) {
-      viewRequests.add(request);
-      if (viewCreator != null && services.getMessenger().getClusterSecretKey() != null) {
+    try {
+      synchronized (viewRequests) {
-          JoinRequestMessage jreq = (JoinRequestMessage) request;
-          // this will inform about cluster-secret key, as we have authenticated at this point
-          JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(),
-              services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
-          services.getMessenger().send(response);
+          if (isCoordinator
+              && !services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo().isEmpty()) {
+            services.getMessenger().initClusterKey();
+            JoinRequestMessage jreq = (JoinRequestMessage) request;
+            // this will inform about cluster-secret key, as we have authenticated at this point
+            JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(),
+                services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
+            services.getMessenger().send(response);
+          }
+        logger.debug("Recording the request to be processed in the next membership view");
+        viewRequests.add(request);
+        viewRequests.notifyAll();
-      viewRequests.notifyAll();
+    } catch (RuntimeException | Error t) {
+      logger.warn("unable to record a membership view request due to this exception", t);
+      throw t;
+    org.apache.geode.distributed.internal.membership.gms.interfaces.Locator locator =
+        services.getLocator();
+    if (locator != null) {
+      locator.setIsCoordinator(true);
+    }
+      services.getMessenger().initClusterKey();
-      services.getMessenger().initClusterKey();
-    if (!state.hasContactedAJoinedLocator && state.view != null) {
+    if (!state.hasContactedAJoinedLocator && state.registrants.size() >= locators.size()
+        && state.view != null) {
+            if (response.getRegistrants() != null) {
+              state.registrants.addAll(response.getRegistrants());
+            }
-                if (response.getRegistrants() != null) {
-                  state.registrants.addAll(response.getRegistrants());
-                }
+    logger.debug("searching for coordinator in findCoordinatorFromView");
+
-    // FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried,
-    // state.viewId, services.getMessenger().getPublickey(
-    // localAddress), services.getMessenger().getRequestId());
-    // req.setRecipients(v.getMembers());
-
-        for (InternalDistributedMember mbr : v.getMembers()) {
+        for (InternalDistributedMember mbr : recipients) {
-        req.setRecipients(v.getMembers());
+        req.setRecipients(recipients);
+      org.apache.geode.distributed.internal.membership.gms.interfaces.Locator locator =
+          services.getLocator();
+      if (locator != null) {
+        locator.setIsCoordinator(false);
+      }

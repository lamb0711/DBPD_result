GEODE-7421:  deploy jar by REST API/JAVA API for Management

Co-authored-by: Joris Melchior <joris.melchior@gmail.com>
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.SimpleRemoteInputStream;
+import com.healthmarketscience.rmiio.exporter.RemoteStreamExporter;
+import org.apache.geode.management.ManagementService;
+import org.apache.geode.management.configuration.HasFile;
+import org.apache.geode.management.internal.ManagementAgent;
+import org.apache.geode.management.internal.SystemManagementService;
+import org.apache.geode.management.internal.configuration.validators.DeploymentValidator;
+  private final InternalCache cache;
-    this(persistenceService, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(),
+    this(cache, persistenceService, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(),
+    validators.put(Deployment.class, new DeploymentValidator());
-  public LocatorClusterManagementService(InternalConfigurationPersistenceService persistenceService,
+  public LocatorClusterManagementService(
+      InternalCache cache,
+      InternalConfigurationPersistenceService persistenceService,
+    this.cache = cache;
-      final String groupName =
-          AbstractConfiguration.isCluster(config.getGroup()) ? AbstractConfiguration.CLUSTER
-              : config.getGroup();
+      final String groupName = AbstractConfiguration.getGroupName(config.getGroup());
-
-        Arrays.asList(config, CacheElementOperation.CREATE),
+        config, CacheElementOperation.CREATE,
+    List<String> updatedGroups = new ArrayList<>();
+    List<String> failedGroups = new ArrayList<>();
-      configurationManager.add(config, groupName);
+      try {
+        configurationManager.add(config, groupName);
+        updatedGroups.add(groupName);
+      } catch (Exception e) {
+        logger.error(e.getMessage(), e);
+        failedGroups.add(groupName);
+      }
-    result.setStatus(StatusCode.OK,
-        "Successfully updated configuration for " + String.join(", ", groups) + ".");
+
+    setResultStatus(result, updatedGroups, failedGroups);
+  @VisibleForTesting
+  void setResultStatus(ClusterManagementRealizationResult result,
+      List<String> updatedGroups, List<String> failedGroups) {
+    String successMessage = null;
+    String failedMessage = null;
+    if (!updatedGroups.isEmpty()) {
+      successMessage =
+          "Successfully updated configuration for " + String.join(", ", updatedGroups) + ".";
+    }
+    if (!failedGroups.isEmpty()) {
+      failedMessage =
+          "Failed to update configuration for " + String.join(", ", failedGroups) + ".";
+    }
+
+    if (failedMessage == null) {
+      result.setStatus(StatusCode.OK, successMessage);
+      return;
+    }
+
+    if (successMessage == null) {
+      result.setStatus(StatusCode.FAIL_TO_PERSIST, failedMessage);
+      return;
+    }
+
+    // succeeded on some group and failed on some group
+    result.setStatus(StatusCode.FAIL_TO_PERSIST, successMessage + " " + failedMessage);
+    return;
+  }
+
-        Arrays.asList(config, CacheElementOperation.DELETE),
+        config, CacheElementOperation.DELETE,
-    if (failedGroups.isEmpty()) {
-      result.setStatus(StatusCode.OK,
-          "Successfully removed configuration for " + updatedGroups + ".");
-    } else {
-      String message = "Failed to update cluster configuration for " + failedGroups + ".";
-      result.setStatus(StatusCode.FAIL_TO_PERSIST, message);
-    }
+    setResultStatus(result, updatedGroups, failedGroups);
-          Arrays.asList(element, CacheElementOperation.GET),
+          element, CacheElementOperation.GET,
-  <R> List<R> executeAndGetFunctionResult(Function function, Object args,
+  <R> List<R> executeAndGetFunctionResult(Function function, AbstractConfiguration configuration,
+      CacheElementOperation operation,
-    Execution execution = FunctionService.onMembers(targetMembers).setArguments(args);
-    ((AbstractExecution) execution).setIgnoreDepartedMembers(true);
-    ResultCollector rc = execution.execute(function);
+    List<R> results = new ArrayList();
-    return (List<R>) rc.getResult();
+    File file = null;
+    if (configuration instanceof HasFile) {
+      file = ((HasFile) configuration).getFile();
+    }
+
+    if (file == null) {
+      Execution execution = FunctionService.onMembers(targetMembers)
+          .setArguments(Arrays.asList(configuration, operation, null));
+      ((AbstractExecution) execution).setIgnoreDepartedMembers(true);
+      ResultCollector rc = execution.execute(function);
+      return (List<R>) rc.getResult();
+    }
+
+    // if we have file arguments, we need to export the file input stream for each member
+    RemoteStreamExporter exporter = null;
+    ManagementAgent agent =
+        ((SystemManagementService) ManagementService.getExistingManagementService(cache))
+            .getManagementAgent();
+    exporter = agent.getRemoteStreamExporter();
+
+    for (DistributedMember member : targetMembers) {
+      FileInputStream fileInputStream = null;
+      SimpleRemoteInputStream inputStream = null;
+      RemoteInputStream remoteInputStream = null;
+      try {
+        fileInputStream = new FileInputStream(file.getAbsolutePath());
+        inputStream = new SimpleRemoteInputStream(fileInputStream);
+        remoteInputStream = exporter.export(inputStream);
+        Execution execution = FunctionService.onMember(member)
+            .setArguments(Arrays.asList(configuration, operation, remoteInputStream));
+        ((AbstractExecution) execution).setIgnoreDepartedMembers(true);
+        results.add(((List<R>) execution.execute(function).getResult()).get(0));
+      } catch (IOException e) {
+        raise(StatusCode.ILLEGAL_ARGUMENT, "Invalid file: " + file.getAbsolutePath());
+      } finally {
+        try {
+          if (fileInputStream != null) {
+            fileInputStream.close();
+          }
+          if (inputStream != null) {
+            inputStream.close();
+          }
+          if (remoteInputStream != null) {
+            remoteInputStream.close(true);
+          }
+        } catch (IOException ex) {
+          // ignore
+        }
+      }
+    }
+
+    return results;

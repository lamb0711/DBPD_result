GEODE-4817: Add support for SSL to the experimental driver. (#1683)

* GEODE-4817: Add support for SSL to the experimental driver.
- Adding a test that a locator can shut itself down
  with SSL. In order to use a locator with SSL, the
  locator must trust itself. Modifying the truststore
  and adding a test of shutting down a locator with SSL.
- The locator needs to trust itself. Fixing the
  truststore so that this test can shutdown.

    Signed-off-by: Dan Smith <dsmith@pivotal.io>

* GEODE-4817: Adding ssl tests with bad certificates

Adding tests that the client cannot connect if the server or the client
has a bad ssl certificate.

* GEODE-4817: Adding protocols and cipher parameters to the experimental driver

Adding parameters that let the user restrict the protocols and ciphers
used.

+import java.net.InetAddress;
+import java.security.GeneralSecurityException;
-
-  private final Set<InetSocketAddress> locators;
-  public ProtobufChannel(final Set<InetSocketAddress> locators, String username, String password)
-      throws IOException {
-    this.locators = locators;
-    this.socket = connectToAServer(username, password);
-  }
-
-  Message sendRequest(final Message request, MessageTypeCase expectedResult) throws IOException {
-    final OutputStream outputStream = socket.getOutputStream();
-    request.writeDelimitedTo(outputStream);
-    Message response = readResponse();
-
-    if (!response.getMessageTypeCase().equals(expectedResult)) {
-      throw new RuntimeException(
-          "Got invalid response for request " + request + ", response " + response);
-    }
-    return response;
+  public ProtobufChannel(final Set<InetSocketAddress> locators, String username, String password,
+      String keyStorePath, String trustStorePath, String protocols, String ciphers)
+      throws GeneralSecurityException, IOException {
+    socket = connectToAServer(locators, username, password, keyStorePath, trustStorePath, protocols,
+        ciphers);
-    this.socket.close();
+    socket.close();
-    return this.socket.isClosed();
+    return socket.isClosed();
-  private Socket connectToAServer(String username, String password) throws IOException {
-    InetSocketAddress server = findAServer(username, password);
-    Socket socket = new Socket(server.getAddress(), server.getPort());
+  private Socket connectToAServer(final Set<InetSocketAddress> locators, String username,
+      String password, String keyStorePath, String trustStorePath, String protocols, String ciphers)
+      throws GeneralSecurityException, IOException {
+    InetSocketAddress server =
+        findAServer(locators, username, password, keyStorePath, trustStorePath, protocols, ciphers);
+    Socket socket = createSocket(server.getAddress(), server.getPort(), keyStorePath,
+        trustStorePath, protocols, ciphers);
-  private InetSocketAddress findAServer(String username, String password) throws IOException {
+  private InetSocketAddress findAServer(final Set<InetSocketAddress> locators, String username,
+      String password, String keyStorePath, String trustStorePath, String protocols, String ciphers)
+      throws GeneralSecurityException, IOException {
-        locatorSocket = new Socket(locator.getAddress(), locator.getPort());
+        locatorSocket = createSocket(locator.getAddress(), locator.getPort(), keyStorePath,
+            trustStorePath, protocols, ciphers);
+  Message sendRequest(final Message request, MessageTypeCase expectedResult) throws IOException {
+    final OutputStream outputStream = socket.getOutputStream();
+    request.writeDelimitedTo(outputStream);
+    Message response = readResponse();
+
+    if (!response.getMessageTypeCase().equals(expectedResult)) {
+      throw new RuntimeException(
+          "Got invalid response for request " + request + ", response " + response);
+    }
+    return response;
+  }
+
+  private Socket createSocket(InetAddress host, int port, String keyStorePath,
+      String trustStorePath, String protocols, String ciphers)
+      throws GeneralSecurityException, IOException {
+    return new SocketFactory().setHost(host).setPort(port).setTimeout(5000)
+        .setKeyStorePath(keyStorePath).setTrustStorePath(trustStorePath).setProtocols(protocols)
+        .setCiphers(ciphers).connect();
+  }

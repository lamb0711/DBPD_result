GEODE-1372 Added support to keep multiple copies of cipher as those
are not thread safe. Added unit test for it.

+import java.util.ArrayList;
-
-
-  private Map<InternalDistributedMember, PeerEncryptor> memberToPeerEncryptor = new ConcurrentHashMap<>();
+  private int numberOfPeerEncryptorCopies = 10;
+  private ConcurrentHashMap<InternalDistributedMember, PeerEncryptor>[] copyOfPeerEncryptors;
+  private ClusterEncryptor[] clusterEncryptors;
+  private Map<InternalDistributedMember, byte[]> memberToPeerEncryptor = new ConcurrentHashMap<>();
+
+      
-    
+    initEncryptors();
+    initEncryptors();
+    initEncryptors();
+  
+  void initEncryptors() {
+    copyOfPeerEncryptors = new  ConcurrentHashMap[numberOfPeerEncryptorCopies];
+    clusterEncryptors = new ClusterEncryptor[numberOfPeerEncryptorCopies];
+  }
-    return this.clusterEncryptor.decryptBytes(data);
+    return getClusterEncryptor().decryptBytes(data);
-    return this.clusterEncryptor.encryptBytes(data);
+    return getClusterEncryptor().encryptBytes(data);
-      createPeerEncryptor(mbr, publickey);
+      //createPeerEncryptor(mbr, publickey);
+      memberToPeerEncryptor.put(mbr, publickey);
-    PeerEncryptor result = memberToPeerEncryptor.get(member);
+    Map<InternalDistributedMember, PeerEncryptor> m = getPeerEncryptorMap();
+
+    PeerEncryptor result = m.get(member);
-        result = memberToPeerEncryptor.get(member);
+        result = m.get(member);
-          result = createPeerEncryptor(member, (byte[]) view.getPublicKey(member));
+          byte[] pk = (byte[])memberToPeerEncryptor.get(member);
+          result = createPeerEncryptor(member, pk != null ? pk : (byte[]) view.getPublicKey(member));
+          m.put(member, result);
+  private Map<InternalDistributedMember, PeerEncryptor> getPeerEncryptorMap() {
+    int h = Math.abs(Thread.currentThread().getName().hashCode() % numberOfPeerEncryptorCopies);
+    ConcurrentHashMap m = copyOfPeerEncryptors[h];
+    
+    if(m == null) {
+      synchronized (copyOfPeerEncryptors) {
+        m = copyOfPeerEncryptors[h];
+        if(m == null) {
+          m = new ConcurrentHashMap<InternalDistributedMember, PeerEncryptor>();
+          copyOfPeerEncryptors[h] = m;          
+        }
+      }
+    }
+    return m;
+  }
+  
+  private ClusterEncryptor getClusterEncryptor() {
+    int h = Math.abs(Thread.currentThread().getName().hashCode() % numberOfPeerEncryptorCopies);
+    ClusterEncryptor c = clusterEncryptors[h];
+    
+    if(c == null) {
+      synchronized (copyOfPeerEncryptors) {
+        c = clusterEncryptors[h];
+        if(c == null) {
+          c = new ClusterEncryptor(getClusterSecretKey());
+          clusterEncryptors[h] = c;          
+        }
+      }
+    }
+    return c;
+  }
+  
-    PeerEncryptor result = new PeerEncryptor(peerKeyBytes);
-    memberToPeerEncryptor.put(member, result);
+    PeerEncryptor result = new PeerEncryptor(peerKeyBytes);    
-  static public byte[] encryptBytes(byte[] data, Cipher encrypt) throws Exception{
-    synchronized(GMSEncrypt.class) {
-      encodingsPerformed++;
-    }
+  static public byte[] encryptBytes(byte[] data, Cipher encrypt) throws Exception {
-      synchronized(GMSEncrypt.class) {
-        decodingsPerformed++;
-      }
-  protected static Cipher getEncryptCipher(String dhSKAlgo, PrivateKey privateKey, PublicKey peerPublicKey) 
-    throws Exception{
+  //this needs to synchronize as it uses private key of that member
+  protected static synchronized Cipher getEncryptCipher(String dhSKAlgo, PrivateKey privateKey, PublicKey peerPublicKey) throws Exception {
-      return encrypt;
-    }
-  
-  protected static Cipher getDecryptCipher(String dhSKAlgo, PrivateKey privateKey, PublicKey publicKey) throws Exception {
+    return encrypt;
+  }
+
+  //this needs to synchronize as it uses private key of that member
+  protected static synchronized Cipher getDecryptCipher(String dhSKAlgo, PrivateKey privateKey, PublicKey publicKey) throws Exception {
-            if(encrypt == null)
+            if (encrypt == null) {
-          }          
+            }
+          }
-          if(decrypt == null)
+          if (decrypt == null) {
-        }        
+          }
+        }

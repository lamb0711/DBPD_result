GEODE-11: Fixing bug that arises while using user defined analyzer in gfsh.

This closes #233

When we use an user defined analyzer class in gfsh, the cluster hangs because the create region message that is sent has a LuceneIndexCreationProfile has a user defined analyzer class. Fixed this by storing only the class name in LuceneIndexCreationProfile.

Signed-off-by: Gester Zhou <gzhou@pivotal.io>

GEODE-11: StandardAnalyzer is used when analyzer option is null

Using the string "null" in the analyzer option for create lucene index command will now set the field analyzer to be StandardAnalyzer.

GEODE-11: Added CliAvailabilityIndicator to lucene gfsh commands

The lucene gfsh commands were available offline. Changed this behavior by adding CliAvailabilityIndicator.

GEODE-11:Fix for "Comparison method violates general contract"

The search results are sorted by score and the compareTo method caused the "Comparison method violates general contract" error when it returned multiple results with same score.

Signed-off-by: Gester Zhou <gzhou@pivotal.io>

GEODE 11: Added a check to make sure StandardAnalyzer and NULL were considered the same.

LuceneIndexCreationProfile checks to makes sure the newly created index's field analyzers are consistent with existing indexes' field analyzers. However, when a field's analyzer is null and a new index is created with StandardAnalyzer on the same field, it failed. Fixed this issue by modifying the conditional checks. Added dunit tests to verify.

Signed-off-by: Gester Zhou <gzhou@pivotal.io>

GEODE 11: Added a check to make sure StandardAnalyzer and NULL were considered the same.

LuceneIndexCreationProfile checks to makes sure the newly created index's field analyzers are consistent with existing indexes' field analyzers. However, when a field's analyzer is null and a new index is created with StandardAnalyzer on the same field, it failed. Fixed this issue by modifying the conditional checks. Added dunit tests to verify.

Signed-off-by: Gester Zhou <gzhou@pivotal.io>

GEODE 11: Clean up of comparison code in LuceneIndexCreationProfile

Since the null in fieldAnalyzers are converted to Standard analyzer, a few checks become irrelevant. Modified the code and relevant tests.

Signed-off-by: Gester Zhou <gzhou@pivotal.io>

fix merge issue

+import org.apache.lucene.analysis.standard.StandardAnalyzer;
-  private Class<? extends Analyzer> analyzerClass;
+  private String analyzerClass;
-  private Map<String, Class<? extends Analyzer>> fieldAnalyzers;
+  private Map<String, String> fieldAnalyzers;
-    this.analyzerClass = analyzer.getClass();
+    this.analyzerClass = analyzer.getClass().getSimpleName();
-    this.analyzerClass = analyzer.getClass();
+    this.analyzerClass = analyzer.getClass().getSimpleName();
-  public Class<? extends Analyzer> getAnalyzerClass() {
+  public String getAnalyzerClass() {
-  public Map<String, Class<? extends Analyzer>> getFieldAnalyzers() {
+  public Map<String, String> getFieldAnalyzers() {
-    if (fieldAnalyzers != null && !fieldAnalyzers.isEmpty()) {
-      this.fieldAnalyzers = new HashMap<>();
-      for (Map.Entry<String, Analyzer> entry : fieldAnalyzers.entrySet()) {
-        // Null values are allowed in analyzers which means the default Analyzer is used
-        this.fieldAnalyzers.put(entry.getKey(), entry.getValue() == null ? null : entry.getValue().getClass());
+    this.fieldAnalyzers = new HashMap<>();
+    for (String field : fieldNames) {
+     if(fieldAnalyzers != null && !fieldAnalyzers.isEmpty())  {
+        this.fieldAnalyzers.put(field, fieldAnalyzers.get(field) == null ? StandardAnalyzer.class.getSimpleName() : fieldAnalyzers.get(field).getClass().getSimpleName());
+      } else {
+        this.fieldAnalyzers.put(field, StandardAnalyzer.class.getSimpleName());
-    LuceneIndexCreationProfile myProfile = (LuceneIndexCreationProfile) profile;
-    if (myProfile == null) {
+    LuceneIndexCreationProfile remoteProfile = (LuceneIndexCreationProfile) profile;
+    if (remoteProfile == null) {
-      if (!Arrays.equals(myProfile.getFieldNames(), getFieldNames())) {
-        result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELDS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELDS_3
-            .toString(myProfile.getIndexName(), regionPath, Arrays.toString(getFieldNames()),
-                Arrays.toString(myProfile.getFieldNames()));
+      if (!Arrays.equals(remoteProfile.getFieldNames(), getFieldNames())) {
+        return LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELDS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELDS_3
+            .toString(getIndexName(), regionPath, Arrays.toString(getFieldNames()), Arrays.toString(remoteProfile.getFieldNames()));
-      // Verify the field analyzer fields and classes are the same if either member sets field analyzers
-      if (myProfile.getFieldAnalyzers() != null || getFieldAnalyzers() != null) {
-        // Check for one member defining field analyzers while the other member does not
-        if (myProfile.getFieldAnalyzers() == null) {
-          result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELD_ANALYZERS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_NO_FIELD_ANALYZERS
-              .toString(myProfile.getIndexName(), regionPath, getFieldAnalyzers());
-        } else if (getFieldAnalyzers() == null) {
-          result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_NO_FIELD_ANALYZERS_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELD_ANALYZERS_2
-              .toString(myProfile.getIndexName(), regionPath, myProfile.getFieldAnalyzers());
-        } else {
-          // Both local and remote analyzers are set. Verify the sizes of the field analyzers are identical
-          if (myProfile.getFieldAnalyzers().size() != getFieldAnalyzers().size()) {
-            result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELD_ANALYZERS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELD_ANALYZERS_3
-                .toString(myProfile.getIndexName(), regionPath, getFieldAnalyzers(),
-                    myProfile.getFieldAnalyzers());
-          }
-
-          // Iterate the existing analyzers and compare them to the input analyzers
-          // Note: This is currently destructive to the input field analyzers map which should be ok since its a transient object.
-          for (Iterator<Map.Entry<String, Class<? extends Analyzer>>> i = myProfile.getFieldAnalyzers().entrySet().iterator(); i.hasNext(); ) {
-            Map.Entry<String, Class<? extends Analyzer>> entry = i.next();
-            // Remove the existing field's analyzer from the input analyzers
-            Class<? extends Analyzer> analyzerClass = getFieldAnalyzers().remove(entry.getKey());
-
-            // Verify the input field analyzer matches the current analyzer
-            if (analyzerClass == null && entry.getValue() != null) {
-              // The input field analyzers do not include the existing field analyzer
-              result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_NO_ANALYZER_ON_FIELD_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_3_ON_THAT_FIELD
-                  .toString(myProfile.getIndexName(), regionPath, entry.getKey(), entry.getValue().getName());
-              break;
-            } else if (analyzerClass != null && entry.getValue() == null) {
-              // The existing field analyzers do not include the input field analyzer
-              result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_ON_FIELD_3_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_NO_ANALYZER_ON_THAT_FIELD
-                  .toString(myProfile.getIndexName(), regionPath, analyzerClass.getName(), entry.getKey());
-              break;
-            } else {
-              if (analyzerClass != entry.getValue()) {
-                // The class of the input analyzer does not match the existing analyzer for the field
-                result = LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_ON_FIELD_3_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_4_ON_THAT_FIELD
-                    .toString(myProfile.getIndexName(), regionPath, analyzerClass.getName(), entry.getKey(), entry.getValue().getName());
-                break;
-              }
-            }
+      // Iterate the existing analyzers and compare them to the input analyzers
+      // Note: This is currently destructive to the input field analyzers map which should be ok since its a transient object.
+      if (!getFieldAnalyzers().equals(remoteProfile.getFieldAnalyzers())) {
+        if (getFieldAnalyzers().size() != remoteProfile.getFieldAnalyzers().size()) {
+          return LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_FIELDS_2_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_FIELDS_3
+              .toString(getIndexName(), regionPath, 
+                  Arrays.toString(getFieldAnalyzers().keySet().toArray()),
+                  Arrays.toString(remoteProfile.getFieldAnalyzers().keySet().toArray()));
+        }
+        // now the 2 maps should have the same size
+        for (String field:getFieldAnalyzers().keySet()) {
+          if (!remoteProfile.getFieldAnalyzers().get(field).equals(getFieldAnalyzers().get(field))) {
+            return LocalizedStrings.LuceneService_CANNOT_CREATE_INDEX_0_ON_REGION_1_WITH_ANALYZER_2_ON_FIELD_3_BECAUSE_ANOTHER_MEMBER_DEFINES_THE_SAME_INDEX_WITH_ANALYZER_4_ON_THAT_FIELD
+              .toString(getIndexName(), regionPath,
+                    getFieldAnalyzers().get(field), field,
+                    remoteProfile.getFieldAnalyzers().get(field)); 
-    DataSerializer.writeClass(this.analyzerClass, out);
+    DataSerializer.writeString(this.analyzerClass, out);
-    this.analyzerClass = (Class<? extends Analyzer>) DataSerializer.readClass(in);
+    this.analyzerClass = DataSerializer.readString(in);

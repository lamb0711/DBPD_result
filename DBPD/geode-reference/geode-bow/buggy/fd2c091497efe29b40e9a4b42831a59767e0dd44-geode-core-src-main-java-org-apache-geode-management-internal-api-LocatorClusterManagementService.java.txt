GEODE-6897: async operation framework for ClusterManagementService (#3801)

* GEODE-6897: create async operations framework for commands such as rebalance
-import java.util.HashMap;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+import org.apache.geode.management.api.ClusterManagementOperation;
+import org.apache.geode.management.api.ClusterManagementOperationResult;
+import org.apache.geode.management.api.JsonSerializable;
+import org.apache.geode.management.internal.ClusterManagementOperationStatusResult;
+import org.apache.geode.management.internal.operation.OperationHistoryManager;
+import org.apache.geode.management.internal.operation.OperationHistoryManager.OperationInstance;
+import org.apache.geode.management.internal.operation.OperationManager;
-  private ConfigurationPersistenceService persistenceService;
-  private Map<Class, ConfigurationManager> managers;
-  private Map<Class, ConfigurationValidator> validators;
-  private MemberValidator memberValidator;
-  private CacheElementValidator commonValidator;
+  private final ConfigurationPersistenceService persistenceService;
+  private final Map<Class, ConfigurationManager> managers;
+  private final Map<Class, ConfigurationValidator> validators;
+  private final OperationManager executorManager;
+  private final MemberValidator memberValidator;
+  private final CacheElementValidator commonValidator;
-    this(persistenceService, new HashMap<>(), new HashMap<>(), null, null);
+    this(persistenceService, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(),
+        new MemberValidator(cache, persistenceService), new CacheElementValidator(),
+        new OperationManager(new OperationHistoryManager()));
-    commonValidator = new CacheElementValidator();
-    memberValidator = new MemberValidator(cache, persistenceService);
-      Map<Class, ConfigurationManager> managers, Map<Class, ConfigurationValidator> validators,
-      MemberValidator memberValidator, CacheElementValidator commonValidator) {
+      Map<Class, ConfigurationManager> managers,
+      Map<Class, ConfigurationValidator> validators,
+      MemberValidator memberValidator,
+      CacheElementValidator commonValidator,
+      OperationManager executorManager) {
+    this.executorManager = executorManager;
+  public <A extends ClusterManagementOperation<V>, V extends JsonSerializable> ClusterManagementOperationResult<V> startOperation(
+      A op) {
+    CompletableFuture<V> future = executorManager.submit(op).getFuture();
+
+    ClusterManagementResult result = new ClusterManagementResult(
+        ClusterManagementResult.StatusCode.ACCEPTED, "async operation started");
+    return new ClusterManagementOperationResult<>(result, future);
+  }
+
+  /**
+   * this is intended for use by the REST controller. for Java usage, please use
+   * {@link #startOperation(ClusterManagementOperation)}
+   */
+  public <A extends ClusterManagementOperation<V>, V extends JsonSerializable> ClusterManagementOperationResult<V> startOperation(
+      A op, String uri) {
+    OperationInstance<A, V> operationInstance = executorManager.submit(op);
+
+    ClusterManagementResult result = new ClusterManagementResult(
+        ClusterManagementResult.StatusCode.ACCEPTED, "async operation started");
+
+    String opId = operationInstance.getId();
+    String instUri = uri + "/" + opId;
+    result.setUri(instUri);
+
+    return new ClusterManagementOperationResult<>(result, operationInstance.getFuture());
+  }
+
+  /**
+   * this is intended for use by the REST controller. for Java usage, please use
+   * {@link ClusterManagementOperationResult#getResult()}
+   */
+  public <V extends JsonSerializable> ClusterManagementOperationStatusResult<V> checkStatus(
+      String opId) {
+    final CompletableFuture<V> status = executorManager.getStatus(opId);
+    if (status == null) {
+      throw new EntityNotFoundException("Operation id = " + opId + " not found");
+    }
+    ClusterManagementOperationStatusResult<V> result =
+        new ClusterManagementOperationStatusResult<>();
+    if (!status.isDone()) {
+      result.setStatus(ClusterManagementResult.StatusCode.IN_PROGRESS, "in progress");
+    } else {
+      try {
+        result.setResult(status.get());
+        result.setStatus(ClusterManagementResult.StatusCode.OK, "finished successfully");
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        throw new RuntimeException(e);
+      } catch (ExecutionException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return result;
+  }
+
+  @Override
+  @Override
+  public void close() {
+    executorManager.close();
+  }
+

GEODE-2267:  add validation to the arguments and include export stats in the command

  * use the config to determine where the logs and stats are

-import static java.util.stream.Collectors.toSet;
-
-import org.apache.geode.internal.logging.InternalLogWriter;
+import org.apache.logging.log4j.Level;
-import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.attribute.BasicFileAttributes;
-import java.util.Arrays;
-import java.util.Set;
-  private final Set<String> permittedLogLevels;
+  private final Level thisLogLevel;
+  private final boolean thisLevelOnly;
-  public LogFilter(Set<String> permittedLogLevels, LocalDateTime startDate, LocalDateTime endDate) {
-    this.permittedLogLevels = (permittedLogLevels == null || permittedLogLevels.isEmpty())
-        ? allLogLevels() : permittedLogLevels;
+  public LogFilter(Level logLevel, LocalDateTime startDate, LocalDateTime endDate) {
+    this(logLevel, false, startDate, endDate);
+  }
+
+  public LogFilter(Level logLevel, boolean thisLevelOnly, LocalDateTime startDate,
+      LocalDateTime endDate) {
+    assert logLevel != null;
+    this.thisLogLevel = logLevel;
+    this.thisLevelOnly = thisLevelOnly;
-  protected LineFilterResult acceptsLogEntry(String logLevel, LocalDateTime logTimestamp) {
+  protected LineFilterResult acceptsLogEntry(Level logLevel, LocalDateTime logTimestamp) {
-      result = permittedLogLevels.contains(logLevel) ? LineFilterResult.LINE_ACCEPTED
-          : LineFilterResult.LINE_REJECTED;
+      if (thisLevelOnly) {
+        result = logLevel.intLevel() == thisLogLevel.intLevel() ? LineFilterResult.LINE_ACCEPTED
+            : LineFilterResult.LINE_REJECTED;
+      } else {
+        result = logLevel.isMoreSpecificThan(thisLogLevel) ? LineFilterResult.LINE_ACCEPTED
+            : LineFilterResult.LINE_REJECTED;
+      }
+    if (startDate == null && endDate == null) {
+      return true;
+    }
+
+    if (endDate == null) {
+      return getEndTimeOf(file).isAfter(startDate);
+    }
+
-      return true;
+      return getStartTimeOf(file).isBefore(endDate);
+
+    return (getEndTimeOf(file).isAfter(startDate) && getStartTimeOf(file).isBefore(endDate));
+
+  }
+
+  private static LocalDateTime getEndTimeOf(Path file) {
-      return (getEndTimeOf(file).isAfter(startDate));
-    } catch (IOException e) {
+      long lastModifiedMillis = file.toFile().lastModified();
+      return Instant.ofEpochMilli(lastModifiedMillis).atZone(ZoneId.systemDefault())
+          .toLocalDateTime();
+    } catch (Exception e) {
-      return true;
+      return LocalDateTime.MAX;
-  private static LocalDateTime getEndTimeOf(Path file) throws IOException {
-    long lastModifiedMillis = file.toFile().lastModified();
-    return Instant.ofEpochMilli(lastModifiedMillis).atZone(ZoneId.systemDefault())
-        .toLocalDateTime();
-  }
-
-  public static Set<String> allLogLevels() {
-    return Arrays.stream(InternalLogWriter.levelNames).collect(toSet());
+  private static LocalDateTime getStartTimeOf(Path file) {
+    try {
+      BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class);
+      long lastModifiedMillis = attributes.creationTime().toMillis();
+      return Instant.ofEpochMilli(lastModifiedMillis).atZone(ZoneId.systemDefault())
+          .toLocalDateTime();
+    } catch (Exception e) {
+      LOGGER.error("Unable to determine creation time", e);
+      return LocalDateTime.MIN;
+    }

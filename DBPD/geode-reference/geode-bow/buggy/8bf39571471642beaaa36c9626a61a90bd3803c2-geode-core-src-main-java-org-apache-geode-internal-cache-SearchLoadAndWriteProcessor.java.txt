Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implementation for distributed search, load and write operations in the
- * GemFire system. Provides an API for doing netSearch, netLoad, netSearchAndLoad and
- * netWrite. The class uses the DistributionAdvisor to route requests to the
- * appropriate members. It also uses the DistributionAdvisor to get region scope
- * and applies rules based on the scope. It makes uses of intelligent acceptors
- * that allow netSearch to happen as a one phase operation at all times.netLoad happens
- * as a one phase operation in all cases except where the scope is GLOBAL
- * At the receiving end, the request is converted into an appropriate message
- * whose process method responds to the request.
+ * Implementation for distributed search, load and write operations in the GemFire system. Provides
+ * an API for doing netSearch, netLoad, netSearchAndLoad and netWrite. The class uses the
+ * DistributionAdvisor to route requests to the appropriate members. It also uses the
+ * DistributionAdvisor to get region scope and applies rules based on the scope. It makes uses of
+ * intelligent acceptors that allow netSearch to happen as a one phase operation at all
+ * times.netLoad happens as a one phase operation in all cases except where the scope is GLOBAL At
+ * the receiving end, the request is converted into an appropriate message whose process method
+ * responds to the request.
-     Integer.getInteger("DistributionManager.OptimizedUpdateByteLimit", 2000).intValue();
+      Integer.getInteger("DistributionManager.OptimizedUpdateByteLimit", 2000).intValue();
-  static final long RETRY_TIME = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "search-retry-interval", 2000).longValue();
+  static final long RETRY_TIME =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "search-retry-interval", 2000).longValue();
-  private long lastModified =0;
+  private long lastModified = 0;
-  //private static Set availableAcceptHelperSet = new HashSet();
+  // private static Set availableAcceptHelperSet = new HashSet();
-  private boolean attemptedLocalLoad = false; // added for bug 39738 
+  private boolean attemptedLocalLoad = false; // added for bug 39738
-  private final Object  membersLock = new Object();
+  private final Object membersLock = new Object();
-  
+
-  Object doNetSearch()
-  throws TimeoutException {
+  Object doNetSearch() throws TimeoutException {
-    this.requestInProgress=true;
+    this.requestInProgress = true;
-    this.requestInProgress=false;
+    this.requestInProgress = false;
-  throws CacheLoaderException, TimeoutException {
+      throws CacheLoaderException, TimeoutException {
-    CacheLoader loader = ((AbstractRegion)region).basicGetLoader();
+    CacheLoader loader = ((AbstractRegion) region).basicGetLoader();
-    }
-    else {
+    } else {
-  boolean doNetWrite(CacheEvent event, Set netWriteRecipients,
-                     CacheWriter localWriter, int paction)
-  throws CacheWriterException, TimeoutException {
+  boolean doNetWrite(CacheEvent event, Set netWriteRecipients, CacheWriter localWriter, int paction)
+      throws CacheWriterException, TimeoutException {
-    @Released CacheEvent listenerEvent = getEventForListener(event);
+    @Released
+    CacheEvent listenerEvent = getEventForListener(event);
-    if (action == BEFOREUPDATE && listenerEvent.getOperation().isCreate()) {
-      action = BEFORECREATE;
-    }
-    boolean cacheWrote = netWrite(listenerEvent, action, netWriteRecipients);
-    this.requestInProgress = false;
-    return cacheWrote;
+      if (action == BEFOREUPDATE && listenerEvent.getOperation().isCreate()) {
+        action = BEFORECREATE;
+      }
+      boolean cacheWrote = netWrite(listenerEvent, action, netWriteRecipients);
+      this.requestInProgress = false;
+      return cacheWrote;
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected, String reason) {
-  }
-  
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-  }
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {}
+
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-        notifyAll(); // signal the waiter; we are not done; but we need the waiter to call sendNetSearchRequest
+        notifyAll(); // signal the waiter; we are not done; but we need the waiter to call
+                     // sendNetSearchRequest
-      if(responseQueue != null) responseQueue.remove(id);
+      if (responseQueue != null)
+        responseQueue.remove(id);
-    if (!this.remoteGetInProgress
-        && this.pendingResponders.isEmpty()) {
+    if (!this.remoteGetInProgress && this.pendingResponders.isEmpty()) {
+
+
-    /*if (this.requestInProgress && currentHelper != null &&
-        optimizer != null && optimizer.allRepliesReceived(currentHelper.nackServerChannel)) {
-       this.requestInProgress = false;
-        signalDone();
-    }*/
+    /*
+     * if (this.requestInProgress && currentHelper != null && optimizer != null &&
+     * optimizer.allRepliesReceived(currentHelper.nackServerChannel)) { this.requestInProgress =
+     * false; signalDone(); }
+     */
-        }
-        catch (CancelException ignore) {
+        } catch (CancelException ignore) {
-    }
-    finally {
+    } finally {
-      }
-      catch (IllegalArgumentException e) {
-      }
-      finally {
+      } catch (IllegalArgumentException e) {
+      } finally {
-    getProcessorKeeper().remove( this.processorId);
+    getProcessorKeeper().remove(this.processorId);
-      this.advisor = ((CacheDistributionAdvisee)this.region).getCacheDistributionAdvisor();
-      this.distributionManager= ((CacheDistributionAdvisee)theRegion).getDistributionManager();
+      this.advisor = ((CacheDistributionAdvisee) this.region).getCacheDistributionAdvisor();
+      this.distributionManager = ((CacheDistributionAdvisee) theRegion).getDistributionManager();
-   * Even though SearchLoadAndWriteProcessor may be in invoked in the context
-   * of a local region, most of the services it provides are relevant to
-   * distribution only. The 3 services it provides are netSearch, netLoad,
-   * netWrite
+   * Even though SearchLoadAndWriteProcessor may be in invoked in the context of a local region,
+   * most of the services it provides are relevant to distribution only. The 3 services it provides
+   * are netSearch, netLoad, netWrite
-   * If we have a local cache loader and the region is not global, then invoke the loader
-   * If the region is local, or the result is non-null, then return whatever the loader returned
-   * do a netSearch amongst selected peers
-   * if netSearch returns a blob, deserialize the blob and return that as the result
-   * netSearch failed, so all we can do at this point is do a load
-   * return result from load
+   * If we have a local cache loader and the region is not global, then invoke the loader If the
+   * region is local, or the result is non-null, then return whatever the loader returned do a
+   * netSearch amongst selected peers if netSearch returns a blob, deserialize the blob and return
+   * that as the result netSearch failed, so all we can do at this point is do a load return result
+   * from load
-  throws CacheLoaderException, TimeoutException {
+      throws CacheLoaderException, TimeoutException {
-    
+
-      TXEntryState tx = txState.txReadEntry(event.getKeyInfo(), region, false,true/*create txEntry is absent*/);
+      TXEntryState tx = txState.txReadEntry(event.getKeyInfo(), region, false,
+          true/* create txEntry is absent */);
-      if(localValue == Token.INVALID || dataPolicy.withReplication()) { 
+      if (localValue == Token.INVALID || dataPolicy.withReplication()) {
-      CacheLoader loader = ((AbstractRegion)region).basicGetLoader();
+      CacheLoader loader = ((AbstractRegion) region).basicGetLoader();
-        Assert.assertTrue(obj != Token.INVALID &&
-                          obj != Token.LOCAL_INVALID);
+        Assert.assertTrue(obj != Token.INVALID && obj != Token.LOCAL_INVALID);
-      Assert.assertTrue(this.result != Token.INVALID &&
-                          this.result != Token.LOCAL_INVALID);
+      Assert.assertTrue(this.result != Token.INVALID && this.result != Token.LOCAL_INVALID);
-        event.setSerializedNewValue((byte[])this.result);
+        event.setSerializedNewValue((byte[]) this.result);
-    if (this.netSearchDone) return;
+    if (this.netSearchDone)
+      return;
-    
+
-//    Object aCallbackArgument = null;
+    // Object aCallbackArgument = null;
-    start  = stats.startNetsearch();
+    start = stats.startNetsearch();
-      List<InternalDistributedMember> replicates = new ArrayList(advisor.adviseInitializedReplicates());
+      List<InternalDistributedMember> replicates =
+          new ArrayList(advisor.adviseInitializedReplicates());
-      for(InternalDistributedMember replicate : replicates) {
+      for (InternalDistributedMember replicate : replicates) {
-        synchronized(this) {
+        synchronized (this) {
-        if(this.authorative) {
-          if(this.result != null) {
+        if (this.authorative) {
+          if (this.result != null) {
-          //clear anything that might have been set by our query.
+          // clear anything that might have been set by our query.
-      boolean useMulticast = region.getMulticastEnabled()
-      && (region instanceof DistributedRegion)
-      && ((DistributedRegion)region).getSystem().getConfig().getMcastPort() != 0;
+      boolean useMulticast = region.getMulticastEnabled() && (region instanceof DistributedRegion)
+          && ((DistributedRegion) region).getSystem().getConfig().getMcastPort() != 0;
-      QueryMessage.sendMessage(this, this.regionName,this.key,useMulticast, sendSet, this.remainingTimeout,
-          attrs.getEntryTimeToLive().getTimeout(),
+      QueryMessage.sendMessage(this, this.regionName, this.key, useMulticast, sendSet,
+          this.remainingTimeout, attrs.getEntryTimeToLive().getTimeout(),
-        //      QueryMessage.sendMessage(this, this.regionName,this.key,useMulticast, sendSet,this.remainingTimeout ,
-        //                               attrs.getEntryTimeToLive().getTimeout(),
-        //                               attrs.getEntryIdleTimeout().getTimeout());
+        // QueryMessage.sendMessage(this, this.regionName,this.key,useMulticast,
+        // sendSet,this.remainingTimeout ,
+        // attrs.getEntryTimeToLive().getTimeout(),
+        // attrs.getEntryIdleTimeout().getTimeout());
-          }
-          else
+          } else
-  private void load(EntryEventImpl event)
-  throws CacheLoaderException, TimeoutException {
+  private void load(EntryEventImpl event) throws CacheLoaderException, TimeoutException {
-    CacheLoader loader = ((AbstractRegion)region).basicGetLoader();
+    CacheLoader loader = ((AbstractRegion) region).basicGetLoader();
-        //no one has a data Loader. No point getting a lock
+        // no one has a data Loader. No point getting a lock
-            locked = this.lock.tryLock(region.getCache().getLockTimeout(),
-                TimeUnit.SECONDS);
+            locked = this.lock.tryLock(region.getCache().getLockTimeout(), TimeUnit.SECONDS);
-              throw new TimeoutException(LocalizedStrings.SearchLoadAndWriteProcessor_TIMED_OUT_LOCKING_0_BEFORE_LOAD.toLocalizedString(key));
+              throw new TimeoutException(
+                  LocalizedStrings.SearchLoadAndWriteProcessor_TIMED_OUT_LOCKING_0_BEFORE_LOAD
+                      .toLocalizedString(key));
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-          }
-          finally {
+          } finally {
-              event.setSerializedNewValue((byte[])obj);
+              event.setSerializedNewValue((byte[]) obj);
-        }
-        else {
+        } else {
-      }
-      finally {
+      } finally {
-        //   called on this processor
-        if (!locked) this.lock = null;
+        // called on this processor
+        if (!locked)
+          this.lock = null;
-//      long start = System.currentTimeMillis();
+      // long start = System.currentTimeMillis();
-      if (this.isSerialized  && obj != null) {
-        event.setSerializedNewValue((byte[])obj);
-      }
-      else {
+      if (this.isSerialized && obj != null) {
+        event.setSerializedNewValue((byte[]) obj);
+      } else {
-//      long end = System.currentTimeMillis();
+      // long end = System.currentTimeMillis();
-  Object doNetLoad()
-  throws CacheLoaderException, TimeoutException {
-    if (this.netLoadDone) return null;
+  Object doNetLoad() throws CacheLoaderException, TimeoutException {
+    if (this.netLoadDone)
+      return null;
-      InternalDistributedMember[] loadCandidates = (InternalDistributedMember[])list.
-      toArray(new InternalDistributedMember[list.size()]);
+      InternalDistributedMember[] loadCandidates =
+          (InternalDistributedMember[]) list.toArray(new InternalDistributedMember[list.size()]);
-          NetLoadRequestMessage.sendMessage(this, this.regionName, this.key,
-          this.aCallbackArgument, next,this.remainingTimeout,
-          attrs.getEntryTimeToLive().getTimeout(),
-          attrs.getEntryIdleTimeout().getTimeout());
+          NetLoadRequestMessage.sendMessage(this, this.regionName, this.key, this.aCallbackArgument,
+              next, this.remainingTimeout, attrs.getEntryTimeToLive().getTimeout(),
+              attrs.getEntryIdleTimeout().getTimeout());
-            }
-            else {
+            } else {
-          }
-          else {
+          } else {
-            }
-            else {
+            } else {
-            throw new CacheLoaderException(LocalizedStrings.SearchLoadAndWriteProcessor_WHILE_INVOKING_A_REMOTE_NETLOAD_0.toLocalizedString(cause), cause);
+            throw new CacheLoaderException(
+                LocalizedStrings.SearchLoadAndWriteProcessor_WHILE_INVOKING_A_REMOTE_NETLOAD_0
+                    .toLocalizedString(cause),
+                cause);
-        } while(stayInLoop);
+        } while (stayInLoop);
-   * This exception is just used in the class to tell the caller
-   * that it should try again. InternalGemFireException used to be
-   * used for this which seems dangerous.
+   * This exception is just used in the class to tell the caller that it should try again.
+   * InternalGemFireException used to be used for this which seems dangerous.
-    //////////////////////  Constructors  //////////////////////
+    ////////////////////// Constructors //////////////////////
-  throws CacheLoaderException {
+      throws CacheLoaderException {
-      LoaderHelper loaderHelper = this.region.loaderHelperFactory.createLoaderHelper(this.key, this.aCallbackArgument, netSearchAllowed, 
-           true /*netLoadAllowed*/, this);
+      LoaderHelper loaderHelper = this.region.loaderHelperFactory.createLoaderHelper(this.key,
+          this.aCallbackArgument, netSearchAllowed, true /* netLoadAllowed */, this);
-      }
-      finally {
+      } finally {
-   * Returns an event for listener notification.  The event's operation
-   * may be altered to conform to the ConcurrentMap implementation specification.
-   * If the returned value is not == to the event parameter then the caller
-   * is responsible for releasing it.
+   * Returns an event for listener notification. The event's operation may be altered to conform to
+   * the ConcurrentMap implementation specification. If the returned value is not == to the event
+   * parameter then the caller is responsible for releasing it.
+   * 
-      EntryEventImpl r = (EntryEventImpl)event;
+      EntryEventImpl r = (EntryEventImpl) event;
-        if (result == r) result = new EntryEventImpl(r);
+        if (result == r)
+          result = new EntryEventImpl(r);
-        if (result == r) result = new EntryEventImpl(r);
+        if (result == r)
+          result = new EntryEventImpl(r);
-        if (result == r) result = new EntryEventImpl(r);
+        if (result == r)
+          result = new EntryEventImpl(r);
-  private boolean doLocalWrite(CacheWriter writer,CacheEvent pevent,int paction)
-  throws CacheWriterException {
+  private boolean doLocalWrite(CacheWriter writer, CacheEvent pevent, int paction)
+      throws CacheWriterException {
-      if (((EntryEventImpl)pevent).inhibitAllNotifications()){
+      if (((EntryEventImpl) pevent).inhibitAllNotifications()) {
-    @Released CacheEvent event = getEventForListener(pevent);
-    
+    @Released
+    CacheEvent event = getEventForListener(pevent);
+
-    switch(action) {
-      case BEFORECREATE:
-        writer.beforeCreate((EntryEvent)event);
-        break;
-      case BEFOREDESTROY:
-        writer.beforeDestroy((EntryEvent)event);
-        break;
-      case BEFOREUPDATE:
-        writer.beforeUpdate((EntryEvent)event);
-        break;
-      case BEFOREREGIONDESTROY:
-        writer.beforeRegionDestroy((RegionEvent)event);
-        break;
-      case BEFOREREGIONCLEAR:
-        writer.beforeRegionClear((RegionEvent)event);
-        break;
-      default:
-        break;
+      switch (action) {
+        case BEFORECREATE:
+          writer.beforeCreate((EntryEvent) event);
+          break;
+        case BEFOREDESTROY:
+          writer.beforeDestroy((EntryEvent) event);
+          break;
+        case BEFOREUPDATE:
+          writer.beforeUpdate((EntryEvent) event);
+          break;
+        case BEFOREREGIONDESTROY:
+          writer.beforeRegionDestroy((RegionEvent) event);
+          break;
+        case BEFOREREGIONCLEAR:
+          writer.beforeRegionClear((RegionEvent) event);
+          break;
+        default:
+          break;
-    }
+      }
-  throws CacheWriterException, TimeoutException {
+      throws CacheWriterException, TimeoutException {
-    InternalDistributedMember[] writeCandidates = (InternalDistributedMember[])list.
-      toArray(new InternalDistributedMember[list.size()]);
+    InternalDistributedMember[] writeCandidates =
+        (InternalDistributedMember[]) list.toArray(new InternalDistributedMember[list.size()]);
-    int index =0;
+    int index = 0;
-      NetWriteRequestMessage.sendMessage(this, this.regionName,this.remainingTimeout,
-      event,set,action);
+      NetWriteRequestMessage.sendMessage(this, this.regionName, this.remainingTimeout, event, set,
+          action);
-        if (this.remoteException instanceof CacheWriterException &&
-            this.remoteException.getCause() != null) {
+        if (this.remoteException instanceof CacheWriterException
+            && this.remoteException.getCause() != null) {
-        }
-        else {
+        } else {
-        throw new CacheWriterException(LocalizedStrings.SearchLoadAndWriteProcessor_WHILE_INVOKING_A_REMOTE_NETWRITE_0.toLocalizedString(cause), cause);
+        throw new CacheWriterException(
+            LocalizedStrings.SearchLoadAndWriteProcessor_WHILE_INVOKING_A_REMOTE_NETWRITE_0
+                .toLocalizedString(cause),
+            cause);
-    } while(index < writeCandidates.length);
+    } while (index < writeCandidates.length);
-  /** process a QueryMessage netsearch response 
-   * @param versionTag TODO*/
-  protected synchronized void incomingResponse(Object obj,
-                                               long lastModifiedTime,
-                                               boolean isPresent,
-                                               boolean serialized,
-                                               final boolean requestorTimedOut,
-                                               final InternalDistributedMember sender,
-                                               DistributionManager dm, VersionTag versionTag) {
+  /**
+   * process a QueryMessage netsearch response
+   * 
+   * @param versionTag TODO
+   */
+  protected synchronized void incomingResponse(Object obj, long lastModifiedTime, boolean isPresent,
+      boolean serialized, final boolean requestorTimedOut, final InternalDistributedMember sender,
+      DistributionManager dm, VersionTag versionTag) {
-        logger.debug("Ignoring netsearch response from {} because we're now doing a netload", sender);
+        logger.debug("Ignoring netsearch response from {} because we're now doing a netload",
+            sender);
-    
+
-        logger.debug("Processing response for processorId={}, isPresent is {}, sender is {}, key is {}, value is {}, version is {}",
+        logger.debug(
+            "Processing response for processorId={}, isPresent is {}, sender is {}, key is {}, value is {}, version is {}",
-    //Another thread got a response and that contained the value.
+    // Another thread got a response and that contained the value.
-    if ( isPresent ) {
+    if (isPresent) {
-        synchronized(this) {
+        synchronized (this) {
-      }
-      else {
+      } else {
-                public void run() {
-                  sendValueRequest(sender);
-                }
-              });
+              public void run() {
+                sendValueRequest(sender);
+              }
+            });
-          }
-          catch (RejectedExecutionException ex) {
+          } catch (RejectedExecutionException ex) {
-        if (responseQueue == null) responseQueue = new LinkedList();
+        if (responseQueue == null)
+          responseQueue = new LinkedList();
-    if (this.pendingResponders.isEmpty()
-        && (!remoteGetInProgress)) {
+    if (this.pendingResponders.isEmpty() && (!remoteGetInProgress)) {
-    NetSearchRequestMessage.sendMessage(this, this.regionName, this.key,
-                                        sender, this.remainingTimeout,
-                                        attrs.getEntryTimeToLive().getTimeout(),
-                                        attrs.getEntryIdleTimeout().getTimeout());
+    NetSearchRequestMessage.sendMessage(this, this.regionName, this.key, sender,
+        this.remainingTimeout, attrs.getEntryTimeToLive().getTimeout(),
+        attrs.getEntryIdleTimeout().getTimeout());
-   * This is the response from the accepted responder.
-   * Grab the result and store it.Unlike 2.0 where the
-   * the response was a 2 phase operation, here it is a
-   * single phase operation.
+   * This is the response from the accepted responder. Grab the result and store it.Unlike 2.0 where
+   * the the response was a 2 phase operation, here it is a single phase operation.
-  protected void incomingNetLoadReply(Object obj, long lastModifiedTime,
-      Object callbackArg, Exception e,
-      boolean serialized, boolean requestorTimedOut) {
+  protected void incomingNetLoadReply(Object obj, long lastModifiedTime, Object callbackArg,
+      Exception e, boolean serialized, boolean requestorTimedOut) {
+
-                                                   boolean serialized,
-                                                   boolean requestorTimedOut,
-                                                   boolean authorative,
-                                                   VersionTag versionTag) {
+      boolean serialized, boolean requestorTimedOut, boolean authorative, VersionTag versionTag) {
-    
+
-        //Force a timeout exception.
+        // Force a timeout exception.
-      }
-      else if(this.remainingTimeout <= 0) {
+      } else if (this.remainingTimeout <= 0) {
-      } 
-      else {
+      } else {
-      return (InternalDistributedMember)responseQueue.remove(0);
+      return (InternalDistributedMember) responseQueue.remove(0);
-  InternalDistributedMember nextResponder = nextAppropriateResponder();
+    InternalDistributedMember nextResponder = nextAppropriateResponder();
-      NetSearchRequestMessage.sendMessage(this, this.regionName, this.key,
-                   nextResponder,this.remainingTimeout,
-                   attrs.getEntryTimeToLive().getTimeout(),
-                   attrs.getEntryIdleTimeout().getTimeout()
-                   );
+      NetSearchRequestMessage.sendMessage(this, this.regionName, this.key, nextResponder,
+          this.remainingTimeout, attrs.getEntryTimeToLive().getTimeout(),
+          attrs.getEntryIdleTimeout().getTimeout());
-    }
-    else {
+    } else {
+
-  protected void incomingNetWriteReply(boolean netWriteSuccessful,Exception e,
-  boolean exe) {
+  protected void incomingNetWriteReply(boolean netWriteSuccessful, Exception e, boolean exe) {
-  
+
-  private synchronized void waitForObject2(final int timeoutMs)
-  throws TimeoutException {
+  private synchronized void waitForObject2(final int timeoutMs) throws TimeoutException {
-        final DM dm = this.region.cache.getDistributedSystem()
-            .getDistributionManager();
+        final DM dm = this.region.cache.getDistributedSystem().getDistributionManager();
-            throw new TimeoutException(LocalizedStrings.SearchLoadAndWriteProcessor_TIMED_OUT_WHILE_DOING_NETSEARCHNETLOADNETWRITE_PROCESSORID_0_KEY_IS_1.toLocalizedString(new Object[] {Integer.valueOf(this.processorId), this.key}));
+            throw new TimeoutException(
+                LocalizedStrings.SearchLoadAndWriteProcessor_TIMED_OUT_WHILE_DOING_NETSEARCHNETLOADNETWRITE_PROCESSORID_0_KEY_IS_1
+                    .toLocalizedString(new Object[] {Integer.valueOf(this.processorId), this.key}));
-          
+
-              throw new TimeoutException(LocalizedStrings.SearchLoadAndWriteProcessor_TIMEOUT_DURING_NETSEARCHNETLOADNETWRITE_DETAILS_0.toLocalizedString(sb));
+              throw new TimeoutException(
+                  LocalizedStrings.SearchLoadAndWriteProcessor_TIMEOUT_DURING_NETSEARCHNETLOADNETWRITE_DETAILS_0
+                      .toLocalizedString(sb));
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-          }
-          finally {
+          } finally {
-    return region.getCache().getSearchTimeout(); //CacheFactory.getInstance(((DistributedRegion)this.region).getSystem()).getSearchTimeout();
+    return region.getCache().getSearchTimeout(); // CacheFactory.getInstance(((DistributedRegion)this.region).getSystem()).getSearchTimeout();
-//  private AcceptHelper getAcceptHelper(boolean ackPortInit) {
-//    AcceptHelper  helper = null;
-//    synchronized(availableAcceptHelperSet) {
-//      if (availableAcceptHelperSet.size() <= 0) {
-//        helper = new AcceptHelper();
-//      }
-//      else {
-//        helper = (AcceptHelper)availableAcceptHelperSet.iterator().next();
-//        availableAcceptHelperSet.remove(helper);
-//      }
-//    }
-//    helper.reset(ackPortInit);
-//    return helper;
-//
-//  }
+  // private AcceptHelper getAcceptHelper(boolean ackPortInit) {
+  // AcceptHelper helper = null;
+  // synchronized(availableAcceptHelperSet) {
+  // if (availableAcceptHelperSet.size() <= 0) {
+  // helper = new AcceptHelper();
+  // }
+  // else {
+  // helper = (AcceptHelper)availableAcceptHelperSet.iterator().next();
+  // availableAcceptHelperSet.remove(helper);
+  // }
+  // }
+  // helper.reset(ackPortInit);
+  // return helper;
+  //
+  // }
-//  private void releaseAcceptHelper(AcceptHelper helper) {
-//    synchronized(availableAcceptHelperSet) {
-//      if (!availableAcceptHelperSet.contains(helper))
-//        availableAcceptHelperSet.add(helper);
-//    }
-//
-//  }
-  
-  @Override  
+  // private void releaseAcceptHelper(AcceptHelper helper) {
+  // synchronized(availableAcceptHelperSet) {
+  // if (!availableAcceptHelperSet.contains(helper))
+  // availableAcceptHelperSet.add(helper);
+  // }
+  //
+  // }
+
+  @Override
-    };
+    } ;
-          dr.removeClearCountReference();
-    };
+      dr.removeClearCountReference();
+    } ;
-  public void testNetSearchMessageDoGet(String theRegionName,
-          Object theKey,
-          int theTimeoutMs,
-          int theTtl,
-          int theIdleTime) {
+  public void testNetSearchMessageDoGet(String theRegionName, Object theKey, int theTimeoutMs,
+      int theTtl, int theIdleTime) {
-    nMsg.doGet((DistributionManager)this.distributionManager);
+    nMsg.doGet((DistributionManager) this.distributionManager);
-   * A QueryMessage is broadcast to every node that has the region defined,
-   * to find out who has a valid copy of the requested object.
+   * A QueryMessage is broadcast to every node that has the region defined, to find out who has a
+   * valid copy of the requested object.
-     * The object id of the processor object on the
-     * initiator node.  This will be communicated back in the response
-     * to enable transferring the result to the initiating VM.
+     * The object id of the processor object on the initiator node. This will be communicated back
+     * in the response to enable transferring the result to the initiating VM.
-    /** if true then always send back value even if it is large.
-     * Added for bug 35942.
+    /**
+     * if true then always send back value even if it is large. Added for bug 35942.
-     * Using a new or pooled message instance, create and send
-     * the query to all nodes.
+     * Using a new or pooled message instance, create and send the query to all nodes.
-    public static void sendMessage(SearchLoadAndWriteProcessor processor,
-    String regionName,
-    Object key,
-    boolean multicast,
-    Set recipients,
-    int timeoutMs,
-    int ttl,
-    int idleTime) {
+    public static void sendMessage(SearchLoadAndWriteProcessor processor, String regionName,
+        Object key, boolean multicast, Set recipients, int timeoutMs, int ttl, int idleTime) {
-      msg.initialize(processor, regionName, key, multicast, timeoutMs,ttl,idleTime);
+      msg.initialize(processor, regionName, key, multicast, timeoutMs, ttl, idleTime);
-    private void initialize(SearchLoadAndWriteProcessor processor,
-                              String theRegionName,
-                              Object theKey,
-                              boolean multicast,
-                              int theTimeoutMs,
-                              int theTtl,
-                              int theIdleTime) {
+    private void initialize(SearchLoadAndWriteProcessor processor, String theRegionName,
+        Object theKey, boolean multicast, int theTimeoutMs, int theTtl, int theIdleTime) {
-     * This method execute's on the receiver's node, and
-     * checks to see if the requested object exists in
-     * shared memory on this node, and if so, sends back
-     * a ResponseMessage.
+     * This method execute's on the receiver's node, and checks to see if the requested object
+     * exists in shared memory on this node, and if so, sends back a ResponseMessage.
-    @Override  
+    @Override
-    
-    @Override  
+
+    @Override
-      if (this.processorId != 0) flags |= HAS_PROCESSOR_ID;
-      if (this.ttl != 0) flags |= HAS_TTL;
-      if (this.idleTime != 0) flags |= HAS_IDLE_TIME;
-      if (this.alwaysSendResult) flags |= ALWAYS_SEND_RESULT;
+      if (this.processorId != 0)
+        flags |= HAS_PROCESSOR_ID;
+      if (this.ttl != 0)
+        flags |= HAS_TTL;
+      if (this.idleTime != 0)
+        flags |= HAS_IDLE_TIME;
+      if (this.alwaysSendResult)
+        flags |= ALWAYS_SEND_RESULT;
-      DataSerializer.writeObject(this.key,out);
+      DataSerializer.writeObject(this.key, out);
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-        this.ttl = (int)InternalDataSerializer.readSignedVL(in);
+        this.ttl = (int) InternalDataSerializer.readSignedVL(in);
-        this.idleTime = (int)InternalDataSerializer.readSignedVL(in);
+        this.idleTime = (int) InternalDataSerializer.readSignedVL(in);
-    @Override  
+    @Override
-      return "SearchLoadAndWriteProcessor.QueryMessage for \"" + this.key
-      + "\" in region \"" + this.regionName + "\", processorId " + processorId
-        + ", timeoutMs=" + this.timeoutMs
-        + ", ttl=" + this.ttl + ", idleTime=" + this.idleTime;
+      return "SearchLoadAndWriteProcessor.QueryMessage for \"" + this.key + "\" in region \""
+          + this.regionName + "\", processorId " + processorId + ", timeoutMs=" + this.timeoutMs
+          + ", ttl=" + this.ttl + ", idleTime=" + this.idleTime;
-//      boolean retVal = true;
+      // boolean retVal = true;
-      
+
-          || getSender().equals(dm.getDistributionManagerId()) ) {
+          || getSender().equals(dm.getDistributionManagerId())) {
-        //replyWithNull(dm); - bug 35266: don't send a reply
+        // replyWithNull(dm); - bug 35266: don't send a reply
-      
+
-        GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
-        if (gfc.isGlobalRegionInitializing(this.regionName)) {          
+        GemFireCacheImpl gfc = (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
+        if (gfc.isGlobalRegionInitializing(this.regionName)) {
-        
-        LocalRegion region  = (LocalRegion)CacheFactory
-          .getInstance(dm.getSystem()).getRegion(this.regionName);
+
+        LocalRegion region =
+            (LocalRegion) CacheFactory.getInstance(dm.getSystem()).getRegion(this.regionName);
-        if (region != null)  {
-	  setClearCountReference(region);	
-	  try {
+        if (region != null) {
+          setClearCountReference(region);
+          try {
-              synchronized(entry) {
+              synchronized (entry) {
-                    o = region.getNoLRU(this.key, false, true, true); // OFFHEAP: incrc, copy bytes, decrc
-                    if (o != null && !Token.isInvalid(o) && !Token.isRemoved(o) &&
-                        !region.isExpiredWithRegardTo(this.key,
-                            this.ttl,
-                            this.idleTime)) {
+                    o = region.getNoLRU(this.key, false, true, true); // OFFHEAP: incrc, copy bytes,
+                                                                      // decrc
+                    if (o != null && !Token.isInvalid(o) && !Token.isRemoved(o)
+                        && !region.isExpiredWithRegardTo(this.key, this.ttl, this.idleTime)) {
-                        o = ((CachedDeserializable)o).getSerializedValue();
+                        o = ((CachedDeserializable) o).getSerializedValue();
-                      if (isPresent
-                          && (this.alwaysSendResult
-                              || (ObjectSizer.DEFAULT.sizeof(o) < SMALL_BLOB_SIZE))) {
+                      if (isPresent && (this.alwaysSendResult
+                          || (ObjectSizer.DEFAULT.sizeof(o) < SMALL_BLOB_SIZE))) {
-                  }
-                  else {
+                  } else {
+            } else if (logger.isDebugEnabled()) {
+              logger.debug("Entry is null");
-            else
-              if (logger.isDebugEnabled()) {
-                logger.debug("Entry is null");
-              }
-	  }
-	  finally {
-	    removeClearCountReference(region);
-	  }
+          } finally {
+            removeClearCountReference(region);
+          }
-        ResponseMessage.sendMessage( this.key, this.getSender(),processorId,
-                                     (sendResult ? o : null),
-                                     lastModifiedCacheTime, isPresent, isSer,
-                                     requestorTimedOut, dm, tag);
-      }
-      catch (RegionDestroyedException rde) {
+        ResponseMessage.sendMessage(this.key, this.getSender(), processorId,
+            (sendResult ? o : null), lastModifiedCacheTime, isPresent, isSer, requestorTimedOut, dm,
+            tag);
+      } catch (RegionDestroyedException rde) {
-      }
-      catch (CancelException cce) {
+      } catch (CancelException cce) {
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-      }
-      finally {
+      } finally {
-      ResponseMessage.sendMessage(this.key,this.getSender(),processorId, null,
-                                  0,false, false, false,dm, null);
+      ResponseMessage.sendMessage(this.key, this.getSender(), processorId, null, 0, false, false,
+          false, dm, null);
+  /**
+   * The ResponseMessage is a reply to a QueryMessage, and contains the object's value, if it is
+   * below the byte limit, otherwise an indication of whether the sender has the value.
+   */
+  public static final class ResponseMessage extends HighPriorityDistributionMessage {
+
+    private Object key;
+
+    /** The gemfire id of the SearchLoadAndWrite object waiting for response */
+    private int processorId;
+
+    /** The value being transferred */
+    private Object result;
+
+    /** Object creation time on remote node */
+    private long lastModified;
+
+    /** is the value present */
+    private boolean isPresent;
+
+
+    /** Is blob serialized? */
+    private boolean isSerialized;
+
+    /** did the request time out at the sender */
+    private boolean requestorTimedOut;
+
+    /** the version of the object being returned */
+    private VersionTag versionTag;
+
+
+    public ResponseMessage() {}
+
+    public static void sendMessage(Object key, InternalDistributedMember recipient, int processorId,
+        Object result, long lastModified, boolean isPresent, boolean isSerialized,
+        boolean requestorTimedOut, DistributionManager distributionManager, VersionTag versionTag) {
+
+      // create a message
+      ResponseMessage msg = new ResponseMessage();
+      msg.initialize(key, processorId, result, lastModified, isPresent, isSerialized,
+          requestorTimedOut, versionTag);
+      msg.setRecipient(recipient);
+      distributionManager.putOutgoing(msg);
+
+    }
+
+    private void initialize(Object theKey, int theProcessorId, Object theResult,
+        long lastModifiedTime, boolean ispresent, boolean isserialized,
+        boolean requestorTimedOutFlag, VersionTag versionTag) {
+      this.key = theKey;
+      this.processorId = theProcessorId;
+      this.result = theResult;
+      this.lastModified = lastModifiedTime;
+      this.isPresent = ispresent;
+      this.isSerialized = isserialized;
+      this.requestorTimedOut = requestorTimedOutFlag;
+      this.versionTag = versionTag;
+    }
+
-     * The ResponseMessage is a reply to a QueryMessage, and contains the
-     * object's value, if it is below the byte limit, otherwise an indication
-     * of whether the sender has the value.
+     * Invoked on the receiver - which, in this case, was the initiator of the QueryMessage .
-    public static final class ResponseMessage extends HighPriorityDistributionMessage {
-
-      private Object key;
-
-      /** The gemfire id of the SearchLoadAndWrite object waiting for response */
-      private int processorId;
-
-      /** The value being transferred */
-      private Object result;
-
-      /** Object creation time on remote node */
-      private long lastModified;
-
-      /** is the value present*/
-      private boolean isPresent;
-
-
-      /** Is blob serialized? */
-      private boolean isSerialized;
-
-      /** did the request time out at the sender*/
-      private boolean requestorTimedOut;
-      
-      /** the version of the object being returned */
-      private VersionTag versionTag;
-      
-
-      public ResponseMessage() {}
-
-      public static void sendMessage(Object key,
-                                    InternalDistributedMember recipient,
-                                    int processorId,
-                                    Object result, long lastModified,
-                                    boolean isPresent, boolean isSerialized,
-                                    boolean requestorTimedOut,
-                                    DistributionManager distributionManager, VersionTag versionTag) {
-
-        // create a message
-        ResponseMessage msg = new ResponseMessage();
-        msg.initialize(key,processorId, result, lastModified,isPresent,isSerialized,requestorTimedOut, versionTag);
-        msg.setRecipient(recipient);
-        distributionManager.putOutgoing(msg);
-
-      }
-
-      private void initialize(Object theKey, int theProcessorId,  Object theResult,
-          long lastModifiedTime, boolean ispresent, boolean isserialized,
-          boolean requestorTimedOutFlag, VersionTag versionTag) {
-        this.key = theKey;
-        this.processorId = theProcessorId;
-        this.result = theResult;
-        this.lastModified = lastModifiedTime;
-        this.isPresent = ispresent;
-        this.isSerialized = isserialized;
-        this.requestorTimedOut = requestorTimedOutFlag;
-        this.versionTag = versionTag;
-      }
-
-      /**
-       * Invoked on the receiver - which, in this case, was the initiator of
-       * the QueryMessage .
-       */
-      @Override  
-      protected void process(DistributionManager dm) {
-        // NOTE: keep this method efficient since it is optimized
-        // by executing it in the p2p reader.
-        // This is done with this line in DistributionMessage.java:
-        // || c.equals(SearchLoadAndWriteProcessor.ResponseMessage.class)
-        SearchLoadAndWriteProcessor processor = null;
-        processor = (SearchLoadAndWriteProcessor)getProcessorKeeper().retrieve(this.processorId);
-        if (processor == null)  {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Response() SearchLoadAndWriteProcessor no longer exists"); 
-          }
-          return;
+    @Override
+    protected void process(DistributionManager dm) {
+      // NOTE: keep this method efficient since it is optimized
+      // by executing it in the p2p reader.
+      // This is done with this line in DistributionMessage.java:
+      // || c.equals(SearchLoadAndWriteProcessor.ResponseMessage.class)
+      SearchLoadAndWriteProcessor processor = null;
+      processor = (SearchLoadAndWriteProcessor) getProcessorKeeper().retrieve(this.processorId);
+      if (processor == null) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("Response() SearchLoadAndWriteProcessor no longer exists");
-        long lastModifiedSystemTime = 0;
-        if (this.lastModified != 0) {
-          lastModifiedSystemTime = this.lastModified;
-        }
-        if (this.versionTag != null) {
-          this.versionTag.replaceNullIDs(getSender());
-        }
-
-        processor.incomingResponse(this.result, lastModifiedSystemTime,
-                                   this.isPresent, this.isSerialized,
-                                   this.requestorTimedOut,
-                                   this.getSender(),
-                                   dm, versionTag);
+        return;
-      
-      @Override  
-      public boolean getInlineProcess() {           // optimization for bug 37075
-        return true;
+      long lastModifiedSystemTime = 0;
+      if (this.lastModified != 0) {
+        lastModifiedSystemTime = this.lastModified;
+      }
+      if (this.versionTag != null) {
+        this.versionTag.replaceNullIDs(getSender());
-      public int getDSFID() {
-        return RESPONSE_MESSAGE;
-      }
+      processor.incomingResponse(this.result, lastModifiedSystemTime, this.isPresent,
+          this.isSerialized, this.requestorTimedOut, this.getSender(), dm, versionTag);
+    }
-      @Override  
-      public void toData(DataOutput out) throws IOException  {
-        super.toData(out);
-        DataSerializer.writeObject(this.key, out);
-        out.writeInt(this.processorId);
-        DataSerializer.writeObject(this.result,out);
-        out.writeLong(this.lastModified);
-        out.writeBoolean(this.isPresent);
-        out.writeBoolean(this.isSerialized);
-        out.writeBoolean(this.requestorTimedOut);
-        DataSerializer.writeObject(this.versionTag, out);
-      }
+    @Override
+    public boolean getInlineProcess() { // optimization for bug 37075
+      return true;
+    }
-      @Override  
-      public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
-        super.fromData(in);
-        this.key = DataSerializer.readObject(in);
-        this.processorId = in.readInt();
-        this.result = DataSerializer.readObject(in);
-        this.lastModified = in.readLong();
-        this.isPresent = in.readBoolean();
-        this.isSerialized = in.readBoolean();
-        this.requestorTimedOut = in.readBoolean();
-        this.versionTag = (VersionTag)DataSerializer.readObject(in);
-      }
+    public int getDSFID() {
+      return RESPONSE_MESSAGE;
+    }
-      @Override  
-      public String toString() {
-        return "SearchLoadAndWriteProcessor.ResponseMessage for processorId " +
-        processorId + ", blob is " + this.result + ", isPresent is " + isPresent
-        + ", requestorTimedOut is " + requestorTimedOut + ", version is " + versionTag;
-      }
+    @Override
+    public void toData(DataOutput out) throws IOException {
+      super.toData(out);
+      DataSerializer.writeObject(this.key, out);
+      out.writeInt(this.processorId);
+      DataSerializer.writeObject(this.result, out);
+      out.writeLong(this.lastModified);
+      out.writeBoolean(this.isPresent);
+      out.writeBoolean(this.isSerialized);
+      out.writeBoolean(this.requestorTimedOut);
+      DataSerializer.writeObject(this.versionTag, out);
+    }
+
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+      super.fromData(in);
+      this.key = DataSerializer.readObject(in);
+      this.processorId = in.readInt();
+      this.result = DataSerializer.readObject(in);
+      this.lastModified = in.readLong();
+      this.isPresent = in.readBoolean();
+      this.isSerialized = in.readBoolean();
+      this.requestorTimedOut = in.readBoolean();
+      this.versionTag = (VersionTag) DataSerializer.readObject(in);
+    }
+
+    @Override
+    public String toString() {
+      return "SearchLoadAndWriteProcessor.ResponseMessage for processorId " + processorId
+          + ", blob is " + this.result + ", isPresent is " + isPresent + ", requestorTimedOut is "
+          + requestorTimedOut + ", version is " + versionTag;
+    }
-     * The object id of the processor object on the
-     * initiator node.  This will be communicated back in the response
-     * to enable transferring the result to the initiating VM.
+     * The object id of the processor object on the initiator node. This will be communicated back
+     * in the response to enable transferring the result to the initiating VM.
-    public NetSearchRequestMessage() {
-    }
+    public NetSearchRequestMessage() {}
-     * Using a new or pooled message instance, create and send
-     * the request for object value to the specified node.
+     * Using a new or pooled message instance, create and send the request for object value to the
+     * specified node.
-    public static void sendMessage(SearchLoadAndWriteProcessor processor,
-    String regionName,
-    Object key,
-    InternalDistributedMember recipient,
-    int timeoutMs,
-    int ttl,
-    int idleTime) {
+    public static void sendMessage(SearchLoadAndWriteProcessor processor, String regionName,
+        Object key, InternalDistributedMember recipient, int timeoutMs, int ttl, int idleTime) {
-      msg.initialize(processor, regionName, key,timeoutMs, ttl,idleTime);
+      msg.initialize(processor, regionName, key, timeoutMs, ttl, idleTime);
-    private void initialize(SearchLoadAndWriteProcessor processor,
-    String theRegionName,
-    Object theKey,
-    int timeoutMS,
-    int ttlMS,
-    int idleTimeMS) {
+    private void initialize(SearchLoadAndWriteProcessor processor, String theRegionName,
+        Object theKey, int timeoutMS, int ttlMS, int idleTimeMS) {
-    @Override  
+    @Override
-    @Override  
+    @Override
-      if (this.processorId != 0) flags |= HAS_PROCESSOR_ID;
-      if (this.ttl != 0) flags |= HAS_TTL;
-      if (this.idleTime != 0) flags |= HAS_IDLE_TIME;
+      if (this.processorId != 0)
+        flags |= HAS_PROCESSOR_ID;
+      if (this.ttl != 0)
+        flags |= HAS_TTL;
+      if (this.idleTime != 0)
+        flags |= HAS_IDLE_TIME;
-      DataSerializer.writeObject(this.key,out);
+      DataSerializer.writeObject(this.key, out);
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-        this.ttl = (int)InternalDataSerializer.readSignedVL(in);
+        this.ttl = (int) InternalDataSerializer.readSignedVL(in);
-        this.idleTime = (int)InternalDataSerializer.readSignedVL(in);
+        this.idleTime = (int) InternalDataSerializer.readSignedVL(in);
-    @Override  
+    @Override
-      + "\" in region \"" + this.regionName + "\", processorId " + processorId;
+          + "\" in region \"" + this.regionName + "\", processorId " + processorId;
-//      boolean retVal = true;
+      // boolean retVal = true;
-      long lastModifiedCacheTime =0;
+      long lastModifiedCacheTime = 0;
-        LocalRegion region = (LocalRegion)CacheFactory
-          .getInstance(dm.getSystem()).getRegion(this.regionName);
-        if (region != null)  {
-          setClearCountReference(region);		
-	  try {
-	    boolean initialized = region.isInitialized();
+        LocalRegion region =
+            (LocalRegion) CacheFactory.getInstance(dm.getSystem()).getRegion(this.regionName);
+        if (region != null) {
+          setClearCountReference(region);
+          try {
+            boolean initialized = region.isInitialized();
-                Object eov = region.getNoLRU(this.key, false, true, true); // OFFHEAP: incrc, copy bytes, decrc
+                Object eov = region.getNoLRU(this.key, false, true, true); // OFFHEAP: incrc, copy
+                                                                           // bytes, decrc
-//                    ebv = null; (redundant assignment)
-                  }
-                  else if (dm.cacheTimeMillis() - startTime < timeoutMs) {
+                    // ebv = null; (redundant assignment)
+                  } else if (dm.cacheTimeMillis() - startTime < timeoutMs) {
-                            byte[] bb = (byte[])tmp;
+                            byte[] bb = (byte[]) tmp;
-                      }
-                      else if (!(eov instanceof byte[])) {
+                      } else if (!(eov instanceof byte[])) {
-                      }
-                      else {
-                        ebv = (byte[])eov;
+                      } else {
+                        ebv = (byte[]) eov;
-                  }
-                  else {
+                  } else {
+              }
-            }
-            authoritative = region.getDataPolicy().withReplication() && initialized && !region.isDestroyed;
-	  }
-	  finally {
-	    removeClearCountReference(region);
-	  }
+            authoritative =
+                region.getDataPolicy().withReplication() && initialized && !region.isDestroyed;
+          } finally {
+            removeClearCountReference(region);
+          }
-        NetSearchReplyMessage.sendMessage(NetSearchRequestMessage.this.getSender(),
-                                          processorId, this.key, ebv, ebvObj, ebvLen,
-                                          lastModifiedCacheTime, isSer,
-                                          requestorTimedOut, authoritative, dm, versionTag);
-      }
-      catch (RegionDestroyedException rde) {
+        NetSearchReplyMessage.sendMessage(NetSearchRequestMessage.this.getSender(), processorId,
+            this.key, ebv, ebvObj, ebvLen, lastModifiedCacheTime, isSer, requestorTimedOut,
+            authoritative, dm, versionTag);
+      } catch (RegionDestroyedException rde) {
-      }
-      catch (CancelException cce) {
+      } catch (CancelException cce) {
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.warn(LocalizedMessage.create(LocalizedStrings.SearchLoadAndWriteProcessor_UNEXPECTED_EXCEPTION), t);
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.SearchLoadAndWriteProcessor_UNEXPECTED_EXCEPTION), t);
-      }
-      finally {
+      } finally {
-      NetSearchReplyMessage.sendMessage(NetSearchRequestMessage.this.getSender(),
-                                        processorId, this.key, null, null, 0, 0, false,
-                                        false,false,dm, null);
+      NetSearchReplyMessage.sendMessage(NetSearchRequestMessage.this.getSender(), processorId,
+          this.key, null, null, 0, 0, false, false, false, dm, null);
+
+    }
-  }
-
-  /*********************NetSearchReplyMessage ***************************************/
+  /********************* NetSearchReplyMessage ***************************************/
-   * The NetSearchReplyMessage is a reply to a NetSearchRequestMessage, and contains the
-   * object's value.
+   * The NetSearchReplyMessage is a reply to a NetSearchRequestMessage, and contains the object's
+   * value.
-    /** did the request time out at the sender*/
+    /** did the request time out at the sender */
-    
-    /** Does this member authoritatively know the value? This is used to distinguish
-     * a null response indicating the region was missing vs. a null value. */
+
+    /**
+     * Does this member authoritatively know the value? This is used to distinguish a null response
+     * indicating the region was missing vs. a null value.
+     */
-    
+
-    public static void sendMessage(InternalDistributedMember recipient,
-    int processorId,
-    Object key,
-    byte[] value, Object valueObj, int valueLen, long lastModified,
-    boolean isSerialized,
-    boolean requestorTimedOut,
-    boolean authoritative,
-    DistributionManager distributionManager, VersionTag versionTag
-    ) {
+    public static void sendMessage(InternalDistributedMember recipient, int processorId, Object key,
+        byte[] value, Object valueObj, int valueLen, long lastModified, boolean isSerialized,
+        boolean requestorTimedOut, boolean authoritative, DistributionManager distributionManager,
+        VersionTag versionTag) {
-      msg.initialize(processorId, value, valueObj, valueLen, lastModified,isSerialized,requestorTimedOut, authoritative, versionTag);
+      msg.initialize(processorId, value, valueObj, valueLen, lastModified, isSerialized,
+          requestorTimedOut, authoritative, versionTag);
-    private void initialize(int procId,
-        byte[] theValue, Object theValueObj, int valueObjLen,
-        long lastModifiedTime ,boolean isserialized, boolean requestorTimedout,
+    private void initialize(int procId, byte[] theValue, Object theValueObj, int valueObjLen,
+        long lastModifiedTime, boolean isserialized, boolean requestorTimedout,
-     * Invoked on the receiver - which, in this case, was the initiator of
-     * the NetSearchRequestMessage.  This concludes the net request, by
-     * communicating an object value.
+     * Invoked on the receiver - which, in this case, was the initiator of the
+     * NetSearchRequestMessage. This concludes the net request, by communicating an object value.
-    @Override  
+    @Override
-      processor = (SearchLoadAndWriteProcessor)getProcessorKeeper().retrieve(processorId);
-      if (processor == null)  {
+      processor = (SearchLoadAndWriteProcessor) getProcessorKeeper().retrieve(processorId);
+      if (processor == null) {
-          logger.debug("NetSearchReplyMessage() SearchLoadAndWriteProcessor {} no longer exists", processorId);
+          logger.debug("NetSearchReplyMessage() SearchLoadAndWriteProcessor {} no longer exists",
+              processorId);
-      processor.incomingNetSearchReply(this.value, lastModifiedSystemTime,
-                                       this.isSerialized, this.requestorTimedOut,
-                                       this.authoritative, this.versionTag);
+      processor.incomingNetSearchReply(this.value, lastModifiedSystemTime, this.isSerialized,
+          this.requestorTimedOut, this.authoritative, this.versionTag);
-    
-    @Override  
-    public void toData(DataOutput out) throws IOException  {
+
+    @Override
+    public void toData(DataOutput out) throws IOException {
-      if(this.isSerialized) booleans |= SERIALIZED;
-      if(this.requestorTimedOut) booleans |= REQUESTOR_TIMEOUT;
-      if(this.authoritative) booleans |= AUTHORATIVE;
-      if (this.versionTag != null) booleans |= VERSIONED;
-      if (this.versionTag instanceof DiskVersionTag) booleans |= PERSISTENT;
+      if (this.isSerialized)
+        booleans |= SERIALIZED;
+      if (this.requestorTimedOut)
+        booleans |= REQUESTOR_TIMEOUT;
+      if (this.authoritative)
+        booleans |= AUTHORATIVE;
+      if (this.versionTag != null)
+        booleans |= VERSIONED;
+      if (this.versionTag instanceof DiskVersionTag)
+        booleans |= PERSISTENT;
-    }
+      }
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      
-      this.isSerialized = (booleans & SERIALIZED )!= 0;
-      this.requestorTimedOut = (booleans & REQUESTOR_TIMEOUT)!= 0;
-      this.authoritative = (booleans & AUTHORATIVE)!= 0;
+
+      this.isSerialized = (booleans & SERIALIZED) != 0;
+      this.requestorTimedOut = (booleans & REQUESTOR_TIMEOUT) != 0;
+      this.authoritative = (booleans & AUTHORATIVE) != 0;
-    @Override  
+    @Override
-      return "SearchLoadAndWriteProcessor.NetSearchReplyMessage for processorId " +
-      processorId + ", blob is " + 
-//      this.value
-      (this.value == null ? "null" : "(" + this.value.length + " bytes)") +
-      " authorative=" + authoritative + " versionTag=" + this.versionTag
-      ;
+      return "SearchLoadAndWriteProcessor.NetSearchReplyMessage for processorId " + processorId
+          + ", blob is " +
+          // this.value
+          (this.value == null ? "null" : "(" + this.value.length + " bytes)") + " authorative="
+          + authoritative + " versionTag=" + this.versionTag;
-  /********************************NetLoadRequestMessage**********************/
+  /******************************** NetLoadRequestMessage **********************/
-     * The object id of the processor object on the
-     * initiator node.  This will be communicated back in the response
-     * to enable transferring the result to the initiating VM.
+     * The object id of the processor object on the initiator node. This will be communicated back
+     * in the response to enable transferring the result to the initiating VM.
-     * Using a new or pooled message instance, create and send
-     * the request for object value to the specified node.
+     * Using a new or pooled message instance, create and send the request for object value to the
+     * specified node.
-    public static void sendMessage(SearchLoadAndWriteProcessor processor,
-    String regionName,
-    Object key,
-    Object aCallbackArgument,
-    InternalDistributedMember recipient,
-    int timeoutMs,
-    int ttl,
-    int idleTime) {
+    public static void sendMessage(SearchLoadAndWriteProcessor processor, String regionName,
+        Object key, Object aCallbackArgument, InternalDistributedMember recipient, int timeoutMs,
+        int ttl, int idleTime) {
-      msg.initialize(processor, regionName, key,aCallbackArgument,timeoutMs,ttl,idleTime);
+      msg.initialize(processor, regionName, key, aCallbackArgument, timeoutMs, ttl, idleTime);
-      
+
-        throw new IllegalArgumentException(LocalizedStrings.SearchLoadAndWriteProcessor_MESSAGE_NOT_SERIALIZABLE.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.SearchLoadAndWriteProcessor_MESSAGE_NOT_SERIALIZABLE
+                .toLocalizedString());
-    private void initialize(SearchLoadAndWriteProcessor processor,
-        String theRegionName,
-        Object theKey,
-        Object callbackArgument,
-        int timeoutMS,
-        int ttlMS,
-        int idleTimeMS) {
+    private void initialize(SearchLoadAndWriteProcessor processor, String theRegionName,
+        Object theKey, Object callbackArgument, int timeoutMS, int ttlMS, int idleTimeMS) {
-    @Override  
+    @Override
-    @Override  
+    @Override
-      DataSerializer.writeObject(this.key,out);
-      DataSerializer.writeObject(this.aCallbackArgument,out);
+      DataSerializer.writeObject(this.key, out);
+      DataSerializer.writeObject(this.aCallbackArgument, out);
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    @Override  
+    @Override
-      + "\" in region \"" + this.regionName + "\", processorId " + processorId;
+          + "\" in region \"" + this.regionName + "\", processorId " + processorId;
-        GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
-        LocalRegion region = (LocalRegion)gfc.getRegion(this.regionName);
-        if (region != null
-            && region.isInitialized()
+        GemFireCacheImpl gfc = (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
+        LocalRegion region = (LocalRegion) gfc.getRegion(this.regionName);
+        if (region != null && region.isInitialized()
-          CacheLoader loader = ((AbstractRegion)region).basicGetLoader();
+          CacheLoader loader = ((AbstractRegion) region).basicGetLoader();
-              LoaderHelper loaderHelper = region.loaderHelperFactory.createLoaderHelper(this.key,
-                  this.aCallbackArgument, false, false, null);
-              CachePerfStats stats = region.getCachePerfStats();
-              long start = stats.startLoad();
-              try {
-                Object o = loader.load(loaderHelper);
-                Assert.assertTrue(o != Token.INVALID && o != Token.LOCAL_INVALID);
-                NetLoadReplyMessage.sendMessage(NetLoadRequestMessage.this.getSender(),
-                processorId, o,dm,loaderHelper.getArgument(),null,false, false);
+            LoaderHelper loaderHelper = region.loaderHelperFactory.createLoaderHelper(this.key,
+                this.aCallbackArgument, false, false, null);
+            CachePerfStats stats = region.getCachePerfStats();
+            long start = stats.startLoad();
+            try {
+              Object o = loader.load(loaderHelper);
+              Assert.assertTrue(o != Token.INVALID && o != Token.LOCAL_INVALID);
+              NetLoadReplyMessage.sendMessage(NetLoadRequestMessage.this.getSender(), processorId,
+                  o, dm, loaderHelper.getArgument(), null, false, false);
-              }
-              catch(Exception e) {
-                replyWithException(e,dm);
-              }
-              finally {
-                stats.endLoad(start);
-              }
-          }
-          else {
-            replyWithException(new TryAgainException(LocalizedStrings.SearchLoadAndWriteProcessor_NO_LOADER_DEFINED_0.toLocalizedString()), dm);
+            } catch (Exception e) {
+              replyWithException(e, dm);
+            } finally {
+              stats.endLoad(start);
+            }
+          } else {
+            replyWithException(new TryAgainException(
+                LocalizedStrings.SearchLoadAndWriteProcessor_NO_LOADER_DEFINED_0
+                    .toLocalizedString()),
+                dm);
-        }
-        else {
-          replyWithException(new TryAgainException(LocalizedStrings.SearchLoadAndWriteProcessor_TIMEOUT_EXPIRED_OR_REGION_NOT_READY_0.toLocalizedString()), dm);
+        } else {
+          replyWithException(new TryAgainException(
+              LocalizedStrings.SearchLoadAndWriteProcessor_TIMEOUT_EXPIRED_OR_REGION_NOT_READY_0
+                  .toLocalizedString()),
+              dm);
-      }
-      catch (RegionDestroyedException rde) {
-        replyWithException(rde,dm);
+      } catch (RegionDestroyedException rde) {
+        replyWithException(rde, dm);
-      }
-      catch (CancelException cce) {
-        replyWithException(cce,dm);
+      } catch (CancelException cce) {
+        replyWithException(cce, dm);
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        replyWithException(new InternalGemFireException(LocalizedStrings.SearchLoadAndWriteProcessor_ERROR_PROCESSING_REQUEST.toLocalizedString(), t), dm);
-      }
-      finally {
+        replyWithException(new InternalGemFireException(
+            LocalizedStrings.SearchLoadAndWriteProcessor_ERROR_PROCESSING_REQUEST
+                .toLocalizedString(),
+            t), dm);
+      } finally {
-      NetLoadReplyMessage.sendMessage(NetLoadRequestMessage.this.getSender(),
-      processorId, null ,
-      dm,this.aCallbackArgument,
-      e,
-      false,false);
+      NetLoadReplyMessage.sendMessage(NetLoadRequestMessage.this.getSender(), processorId, null, dm,
+          this.aCallbackArgument, e, false, false);
-   * The NetLoadReplyMessage is a reply to a RequestMessage, and contains the
-   * object's value.
+   * The NetLoadReplyMessage is a reply to a RequestMessage, and contains the object's value.
-    /** Loader parameter returned to sender*/
+    /** Loader parameter returned to sender */
-    public static void sendMessage(InternalDistributedMember recipient,
-    int processorId,
-    Object obj,
-    DistributionManager distributionManager,
-    Object aCallbackArgument,
-    Exception e,
-    boolean isSerialized,
-    boolean requestorTimedOut) {
+    public static void sendMessage(InternalDistributedMember recipient, int processorId, Object obj,
+        DistributionManager distributionManager, Object aCallbackArgument, Exception e,
+        boolean isSerialized, boolean requestorTimedOut) {
-      msg.initialize(processorId, obj,aCallbackArgument,e, isSerialized,requestorTimedOut);
+      msg.initialize(processorId, obj, aCallbackArgument, e, isSerialized, requestorTimedOut);
-    private void initialize(int procId, Object obj,
-        Object callbackArgument, Exception exe,
-        boolean isserialized,
-        boolean requestorTimedout) {
+    private void initialize(int procId, Object obj, Object callbackArgument, Exception exe,
+        boolean isserialized, boolean requestorTimedout) {
-     * Invoked on the receiver - which, in this case, was the initiator of
-     * the NetLoadRequestMessage.  This concludes the net request, by
-     * communicating an object value.
+     * Invoked on the receiver - which, in this case, was the initiator of the
+     * NetLoadRequestMessage. This concludes the net request, by communicating an object value.
-    @Override  
+    @Override
-      processor = (SearchLoadAndWriteProcessor)getProcessorKeeper().retrieve(processorId);
+      processor = (SearchLoadAndWriteProcessor) getProcessorKeeper().retrieve(processorId);
-      processor.incomingNetLoadReply(this.result, 0,this.aCallbackArgument,
-      this.e,this.isSerialized, this.requestorTimedOut);
+      processor.incomingNetLoadReply(this.result, 0, this.aCallbackArgument, this.e,
+          this.isSerialized, this.requestorTimedOut);
-    @Override  
-    public void toData(DataOutput out) throws IOException  {
+    @Override
+    public void toData(DataOutput out) throws IOException {
-      if(result instanceof byte[]) {
-        DataSerializer.writeByteArray((byte[])  this.result,out);
+      if (result instanceof byte[]) {
+        DataSerializer.writeByteArray((byte[]) this.result, out);
-        DataSerializer.writeObjectAsByteArray(this.result,out);
+        DataSerializer.writeObjectAsByteArray(this.result, out);
-      DataSerializer.writeObject(this.aCallbackArgument,out);
-      DataSerializer.writeObject(this.e,out);
+      DataSerializer.writeObject(this.aCallbackArgument, out);
+      DataSerializer.writeObject(this.e, out);
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.aCallbackArgument =  DataSerializer.readObject(in);
+      this.aCallbackArgument = DataSerializer.readObject(in);
-    @Override  
+    @Override
-      return "SearchLoadAndWriteProcessor.NetLoadReplyMessage for processorId " +
-      processorId + ", blob is " + this.result;
+      return "SearchLoadAndWriteProcessor.NetLoadReplyMessage for processorId " + processorId
+          + ", blob is " + this.result;
-     * The object id of the processor object on the
-     * initiator node.  This will be communicated back in the response
-     * to enable transferring the result to the initiating VM.
+     * The object id of the processor object on the initiator node. This will be communicated back
+     * in the response to enable transferring the result to the initiating VM.
-    /** The event being sent over to the remote writer*/
+    /** The event being sent over to the remote writer */
-    /**Action requested by sender*/
+    /** Action requested by sender */
-     * Using a new or pooled message instance, create and send
-     * the request for object value to the specified node.
+     * Using a new or pooled message instance, create and send the request for object value to the
+     * specified node.
-    public static void sendMessage(SearchLoadAndWriteProcessor processor,
-    String regionName,int timeoutMs,
-    CacheEvent event, Set recipients,
-    int action) {
+    public static void sendMessage(SearchLoadAndWriteProcessor processor, String regionName,
+        int timeoutMs, CacheEvent event, Set recipients, int action) {
-      msg.initialize(processor, regionName,timeoutMs, event,action);
+      msg.initialize(processor, regionName, timeoutMs, event, action);
-    private void initialize(SearchLoadAndWriteProcessor processor,
-        String theRegionName,int timeoutMS,
-        CacheEvent theEvent, int actionType) {
+    private void initialize(SearchLoadAndWriteProcessor processor, String theRegionName,
+        int timeoutMS, CacheEvent theEvent, int actionType) {
-    @Override  
+    @Override
-      DataSerializer.writeObject(this.event,out);
+      DataSerializer.writeObject(this.event, out);
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    @Override  
+    @Override
-      return "SearchLoadAndWriteProcessor.NetWriteRequestMessage " 
-      + " for region \"" + this.regionName + "\", processorId " + processorId;
+      return "SearchLoadAndWriteProcessor.NetWriteRequestMessage " + " for region \""
+          + this.regionName + "\", processorId " + processorId;
-    @Override  
+    @Override
-        GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
-        LocalRegion region = (LocalRegion)gfc.getRegion(this.regionName);
-        if (region != null &&  region.isInitialized() &&
-            (dm.cacheTimeMillis() - startTime < timeoutMs)) {
+        GemFireCacheImpl gfc = (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
+        LocalRegion region = (LocalRegion) gfc.getRegion(this.regionName);
+        if (region != null && region.isInitialized()
+            && (dm.cacheTimeMillis() - startTime < timeoutMs)) {
-            //         originated in this VM.  PartitionedRegion.put() with a cacheWriter is one
-            //         situation where this can occur
+            // originated in this VM. PartitionedRegion.put() with a cacheWriter is one
+            // situation where this can occur
-          }
-          else if (this.event instanceof RegionEventImpl) {
+          } else if (this.event instanceof RegionEventImpl) {
-              switch(action) {
+              switch (action) {
-              NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-              processorId,dm,true,null,false);
-            }
-            catch(CacheWriterException cwe) {
-              NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-              processorId, dm,false,cwe,true);
-            }
-            catch(Exception e) {
-              NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-              processorId, dm,false,e,false);
+              NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId,
+                  dm, true, null, false);
+            } catch (CacheWriterException cwe) {
+              NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId,
+                  dm, false, cwe, true);
+            } catch (Exception e) {
+              NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId,
+                  dm, false, e, false);
-          }
-          else {
-            NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-            processorId, dm,false,
-            new TryAgainException(LocalizedStrings.SearchLoadAndWriteProcessor_NO_CACHEWRITER_DEFINED_0.toLocalizedString()), true);
+          } else {
+            NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId,
+                dm, false,
+                new TryAgainException(
+                    LocalizedStrings.SearchLoadAndWriteProcessor_NO_CACHEWRITER_DEFINED_0
+                        .toLocalizedString()),
+                true);
-        }
-        else {
-          NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-                                            processorId, dm, false,
-                                            new TryAgainException(LocalizedStrings.SearchLoadAndWriteProcessor_TIMEOUT_EXPIRED_OR_REGION_NOT_READY_0.toLocalizedString()), true);
+        } else {
+          NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId, dm,
+              false,
+              new TryAgainException(
+                  LocalizedStrings.SearchLoadAndWriteProcessor_TIMEOUT_EXPIRED_OR_REGION_NOT_READY_0
+                      .toLocalizedString()),
+              true);
-      }
-      catch (RegionDestroyedException rde) {
-        NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-        processorId, dm,false,null,false);
+      } catch (RegionDestroyedException rde) {
+        NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId, dm,
+            false, null, false);
-      }
-      catch (DistributedSystemDisconnectedException e) {
+      } catch (DistributedSystemDisconnectedException e) {
-      }
-      catch (CancelException cce) {
-        dm.getCancelCriterion().checkCancelInProgress(cce); // TODO anyway to find the region or cache here?
-        NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-            processorId, dm,false,null,false);
-      }
-      catch (VirtualMachineError err) {
+      } catch (CancelException cce) {
+        dm.getCancelCriterion().checkCancelInProgress(cce); // TODO anyway to find the region or
+                                                            // cache here?
+        NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId, dm,
+            false, null, false);
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t){
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(),
-            processorId, dm,false,
-            new InternalGemFireException(LocalizedStrings.SearchLoadAndWriteProcessor_ERROR_PROCESSING_REQUEST.toLocalizedString(), t), true);
-      }
-      finally {
+        NetWriteReplyMessage.sendMessage(NetWriteRequestMessage.this.getSender(), processorId, dm,
+            false,
+            new InternalGemFireException(
+                LocalizedStrings.SearchLoadAndWriteProcessor_ERROR_PROCESSING_REQUEST
+                    .toLocalizedString(),
+                t),
+            true);
+      } finally {
-   * The NetWriteReplyMessage is a reply to a NetWriteRequestMessage, and contains the
-   * success code or exception that is propagated back to the requestor
+   * The NetWriteReplyMessage is a reply to a NetWriteRequestMessage, and contains the success code
+   * or exception that is propagated back to the requestor
-    public static void sendMessage(InternalDistributedMember recipient,
-    int processorId,
-    DistributionManager distributionManager,
-    boolean netWriteSucceeded,
-    Exception e,
-    boolean cacheWriterException) {
+    public static void sendMessage(InternalDistributedMember recipient, int processorId,
+        DistributionManager distributionManager, boolean netWriteSucceeded, Exception e,
+        boolean cacheWriterException) {
-    private void initialize(int procId, boolean netwriteSucceeded,
-    Exception except, boolean cacheWriterExcept) {
+    private void initialize(int procId, boolean netwriteSucceeded, Exception except,
+        boolean cacheWriterExcept) {
-     * Invoked on the receiver - which, in this case, was the initiator of
-     * the NetWriteRequestMessage.  This concludes the net write request, by
-     * communicating an object value.
+     * Invoked on the receiver - which, in this case, was the initiator of the
+     * NetWriteRequestMessage. This concludes the net write request, by communicating an object
+     * value.
-    @Override  
+    @Override
-      processor = (SearchLoadAndWriteProcessor)getProcessorKeeper().retrieve(processorId);
+      processor = (SearchLoadAndWriteProcessor) getProcessorKeeper().retrieve(processorId);
-      processor.incomingNetWriteReply(this.netWriteSucceeded, this.e,
-      this.cacheWriterException);
+      processor.incomingNetWriteReply(this.netWriteSucceeded, this.e, this.cacheWriterException);
-    @Override  
-    public void toData(DataOutput out) throws IOException  {
+    @Override
+    public void toData(DataOutput out) throws IOException {
-      DataSerializer.writeObject(this.e,out);
+      DataSerializer.writeObject(this.e, out);
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    @Override  
+    @Override
-      return "SearchLoadAndWriteProcessor.NetWriteReplyMessage for processorId " +
-      processorId ;
+      return "SearchLoadAndWriteProcessor.NetWriteReplyMessage for processorId " + processorId;

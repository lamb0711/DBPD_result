GEODE-6612: add entry count for list Region and rework filtering by groups (#3465)

Co-authored-by: Owen Nichols <onichols@pivotal.io>
Co-authored-by: Jens Deppe jdeppe@pivotal.io

* Create a RuntimeCacheElement interface to hold multiple groups
* Using RegionConfig can only set/get one group
+import java.util.Map;
+import org.apache.geode.management.configuration.RuntimeCacheElement;
+import org.apache.geode.management.internal.configuration.validators.CacheElementValidator;
-  private HashMap<Class, ConfigurationManager> managers;
-  private HashMap<Class, ConfigurationValidator> validators;
+  private Map<Class, ConfigurationManager> managers;
+  private Map<Class, ConfigurationValidator> validators;
-    managers.put(RegionConfig.class, new RegionConfigManager());
+    managers.put(RegionConfig.class, new RegionConfigManager(cache));
+    validators.put(CacheElement.class, new CacheElementValidator());
-      ConfigurationPersistenceService persistenceService, HashMap managers, HashMap validators) {
+      ConfigurationPersistenceService persistenceService, Map managers, Map validators) {
-    ClusterManagementResult result = new ClusterManagementResult();
-    ConfigurationManager configurationMutator = managers.get(config.getClass());
+    // first validate common attributes of all configuration object
+    validators.get(CacheElement.class).validate(config);
+      // exit early if config element already exists in cache config
+      CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
+      if (validator.exists(config, currentPersistedConfig)) {
+        throw new EntityExistsException("cache element " + config.getId() + " already exists.");
+      }
-    // exit early if config element already exists in cache config
-    CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
-    if (validator.exists(config, currentPersistedConfig)) {
-      throw new EntityExistsException("cache element " + config.getId() + " already exists.");
+    // validate that user used the correct config object type
+    ConfigurationManager configurationManager = managers.get(config.getClass());
+    if (configurationManager == null) {
+      throw new IllegalArgumentException(String.format("Configuration type %s is not supported.",
+          config.getClass().getSimpleName()));
+    ClusterManagementResult result = new ClusterManagementResult();
+
-        configurationMutator.add(config, cacheConfigForGroup);
+        configurationManager.add(config, cacheConfigForGroup);
-      List<CacheElement> listResults = manager.list(filter, null);
+      List<RuntimeCacheElement> listResults = manager.list(filter, null);
-    List<CacheElement> elements = new ArrayList<>();
+    List<RuntimeCacheElement> resultList = new ArrayList<>();
+
+    // get a list of all the resultList from all groups that satisfy the filter criteria (all
+    // filters
+    // have been applied except the group)
-      if (StringUtils.isBlank(filter.getGroup()) || group.equals(filter.getConfigGroup())) {
-        CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
-        List<CacheElement> listInGroup = manager.list(filter, currentPersistedConfig);
-        // only set the group attribute when the config level is not in the cluster level
-        if (!group.equals("cluster")) {
-          listInGroup.stream().forEach(e -> e.setGroup(group));
+      CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
+      List<RuntimeCacheElement> listInGroup = manager.list(filter, currentPersistedConfig);
+      for (RuntimeCacheElement element : listInGroup) {
+        element.getGroups().add(group);
+        int index = resultList.indexOf(element);
+        if (index >= 0) {
+          RuntimeCacheElement exist = resultList.get(index);
+          exist.getGroups().add(group);
+        } else {
+          resultList.add(element);
-        elements.addAll(listInGroup);
-    result.setResult(elements);
+    // filtering by group. Do this after iterating through all the groups because some region might
+    // belong to multiple groups and we want the "group" field to show that.
+    if (StringUtils.isNotBlank(filter.getGroup())) {
+      resultList =
+          resultList.stream().filter(e -> e.getGroups().contains(filter.getConfigGroup()))
+              .collect(Collectors.toList());
+    }
+
+    // if "cluster" is the only group of the element, remove it
+    for (RuntimeCacheElement element : resultList) {
+      if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
+        element.getGroups().clear();
+      }
+    }
+
+    result.setResult(resultList);
+

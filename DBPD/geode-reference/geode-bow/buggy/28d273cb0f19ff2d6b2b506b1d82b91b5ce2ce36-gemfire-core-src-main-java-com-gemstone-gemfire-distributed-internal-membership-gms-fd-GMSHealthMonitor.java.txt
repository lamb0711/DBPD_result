GEODE-77: members unfairly forced out of the distributed system

n integration testing members were, under heavy load, being forced out
of the distributed system in spite of the new tcp/ip final-checks.

This change set adds a recent-activity check to the doTCPCheckMember method
of GMSHealthMonitor.  It also corrects this method to use SocketCreator with
a background timeout task in case the tcp/ip socket timeout fails to work
(as it sometimes does).

During testing I also saw that GMSJoinLeave was not initiating a forced-
disconnect if it received a membership view showing that it was no longer
in the distributed system and modified it to do so.

+import java.util.Timer;
+import java.util.TimerTask;
+import com.gemstone.gemfire.internal.ConnectionWatcher;
+import com.gemstone.gemfire.internal.SocketCreator;
+        @SuppressWarnings("unused")
-        logger.trace("Unexpected exception", e);
+        logger.debug("Unexpected exception", e);
+      } catch (RuntimeException e) {
+        logger.debug("Unexpected runtime exception", e);
+        throw e;
+      } catch (Error e) {
+        logger.debug("Unexpected error", e);
+        throw e;
-          GMSHealthMonitor.this.sendSuspectMessage(mbr, reason);
+          GMSHealthMonitor.this.initiateSuspicion(mbr, reason);
-  private void sendSuspectMessage(InternalDistributedMember mbr, String reason) {
+  private void initiateSuspicion(InternalDistributedMember mbr, String reason) {
-            long now = System.currentTimeMillis();
-            if (ts != null && (now - ts.getTime()) <= memberTimeout) {
-              logger.trace("detected message traffic from member {}ms ago.  member-timeout is {}", now - ts.getTime(),
-                  memberTimeout);
+            if (checkRecentActivity(member)) {
-            logger.trace("no heartbeat response received from {}", member);
+            logger.trace("no heartbeat response received from {} and no recent activity", member);
+   * Check for recent messaging activity from the given member
+   * @param suspectMember
+   * @return whether there has been activity within memberTimeout ms
+   */
+  private boolean checkRecentActivity(InternalDistributedMember suspectMember) {
+    TimeStamp ts = memberTimeStamps.get(suspectMember);
+    return (ts != null && (System.currentTimeMillis() - ts.getTime()) <= memberTimeout);
+  }
+
+  /**
-    Socket clientSocket = new Socket();
+    Socket clientSocket = null;
+    // first check for a recent timestamp
+    if (checkRecentActivity(suspectMember)) {
+      return true;
+    }
-      InetSocketAddress addr = new InetSocketAddress(suspectMember.getInetAddress(), port);
-      clientSocket.connect(addr, (int) services.getConfig().getMemberTimeout());
+      clientSocket = SocketCreator.getDefaultInstance().connect(suspectMember.getInetAddress(), port,
+          (int)memberTimeout, new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
-          return false;
+          return checkRecentActivity(suspectMember);
-        return false;
+        return checkRecentActivity(suspectMember);
+      logger.debug("tcp/ip connection timed out");
-      logger.trace("Unexpected exception", e);
+      logger.debug("Unexpected exception", e);
-    sendSuspectMessage(mbr, reason);
+    initiateSuspicion(mbr, reason);
-    sendSuspectMessage(localAddress, "beSick invoked on GMSHealthMonitor");
+    initiateSuspicion(localAddress, "beSick invoked on GMSHealthMonitor");
-    sendSuspectMessage(localAddress, "playDead invoked on GMSHealthMonitor");
+    initiateSuspicion(localAddress, "playDead invoked on GMSHealthMonitor");
+                contactedBy(mbr);
-              contactedBy(mbr);
+  @Override
+  public void memberShutdown(DistributedMember mbr, String reason) {
+  }
+  
+  @Override
+  public int getFailureDetectionPort() {
+    return this.socketPort;
+  }
-  @Override
-  public void memberShutdown(DistributedMember mbr, String reason) {
+  private static class ConnectTimeoutTask extends TimerTask implements ConnectionWatcher {
+    Timer scheduler;
+    Socket socket;
+    long timeout;
+    
+    ConnectTimeoutTask(Timer scheduler, long timeout) {
+      this.scheduler = scheduler;
+      this.timeout = timeout;
+    }
+    
+    @Override
+    public void beforeConnect(Socket socket) {
+      this.socket = socket;
+      scheduler.schedule(this, timeout);
+    }
+
+    @Override
+    public void afterConnect(Socket socket) {
+      cancel();
+    }
+    
+    @Override
+    public void run() {
+      try {
+        if (socket != null) {
+          socket.close();
+        }
+      } catch (IOException e) {
+        // ignored - nothing useful to do here
+      }
+    }
+    
-  
-  @Override
-  public int getFailureDetectionPort() {
-    return this.socketPort;
-  }
-  

GEODE-4858: Update *DiskStore commands to use ResultModel and SingleGfshCommand (#1996)


+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.DiskDirType;
+import org.apache.geode.cache.configuration.DiskDirsType;
+import org.apache.geode.cache.configuration.DiskStoreType;
-import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;
-import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.cli.SingleGfshCommand;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
-import org.apache.geode.management.internal.configuration.domain.XmlEntity;
+import org.apache.geode.management.internal.cli.result.model.ResultModel;
-public class CreateDiskStoreCommand extends InternalGfshCommand {
+public class CreateDiskStoreCommand extends SingleGfshCommand {
-  public Result createDiskStore(
+  public ResultModel createDiskStore(
-
+    diskStoreAttributes.name = name;
-      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-    List<CliFunctionResult> results = executeAndGetFunctionResult(new CreateDiskStoreFunction(),
-        new Object[] {name, diskStoreAttributes}, targetMembers);
+    List<CliFunctionResult> functionResults = executeAndGetFunctionResult(
+        new CreateDiskStoreFunction(), new Object[] {name, diskStoreAttributes}, targetMembers);
-    CommandResult result = ResultBuilder.buildResult(results);
-    XmlEntity xmlEntity = findXmlEntity(results);
-
-    if (xmlEntity != null) {
-      persistClusterConfiguration(result,
-          () -> ((InternalConfigurationPersistenceService) getConfigurationPersistenceService())
-              .addXmlEntity(xmlEntity, groups));
-    }
+    ResultModel result = ResultModel.createMemberStatusResult(functionResults);
+    result.setConfigObject(createDiskStoreType(name, diskStoreAttributes));
+
+  private DiskStoreType createDiskStoreType(String name, DiskStoreAttributes diskStoreAttributes) {
+    DiskStoreType diskStoreType = new DiskStoreType();
+    diskStoreType.setAllowForceCompaction(diskStoreAttributes.getAllowForceCompaction());
+    diskStoreType.setAutoCompact(diskStoreAttributes.getAutoCompact());
+    diskStoreType
+        .setCompactionThreshold(Integer.toString(diskStoreAttributes.getCompactionThreshold()));
+
+    DiskDirsType diskDirsType = new DiskDirsType();
+    List<DiskDirType> diskDirs = diskDirsType.getDiskDirs();
+    for (int i = 0; i < diskStoreAttributes.getDiskDirs().length; i++) {
+      DiskDirType diskDir = new DiskDirType();
+      diskDir.setContent(diskStoreAttributes.getDiskDirs()[i].getName());
+      diskDir.setDirSize(Integer.toString(diskStoreAttributes.getDiskDirSizes()[i]));
+
+      diskDirs.add(diskDir);
+    }
+    diskStoreType.setDiskDirs(diskDirsType);
+    diskStoreType.setDiskUsageCriticalPercentage(
+        Integer.toString((int) diskStoreAttributes.getDiskUsageCriticalPercentage()));
+    diskStoreType.setDiskUsageWarningPercentage(
+        Integer.toString((int) diskStoreAttributes.getDiskUsageWarningPercentage()));
+    diskStoreType.setMaxOplogSize(Integer.toString((int) diskStoreAttributes.getMaxOplogSize()));
+    diskStoreType.setName(diskStoreAttributes.getName());
+    diskStoreType.setQueueSize(Integer.toString(diskStoreAttributes.getQueueSize()));
+    diskStoreType.setTimeInterval(Integer.toString((int) diskStoreAttributes.getTimeInterval()));
+    diskStoreType.setWriteBufferSize(Integer.toString(diskStoreAttributes.getWriteBufferSize()));
+
+    return diskStoreType;
+  }
+
+  @Override
+  public void updateClusterConfig(String group, CacheConfig config, Object configObject) {
+    DiskStoreType diskStoreType = (DiskStoreType) configObject;
+    config.getDiskStores().add(diskStoreType);
+  }

improvements to deadlock detection.  Addition of a main method to DeadlockDetector that recognizes findDeepestGraph, findDeadlockOnly, findThread and print commands.  We need a project to enable dependency monitoring in processes spawned with Gfsh and to collect dependencies and serialize them to disk so that this tool can be used to analyse distributed systems.

+import java.util.List;
+ * @author bschuchardt
+  /** add a collection of edges to this graph */
+  public void addEdges(Collection<Dependency> edges) {
+    for (Dependency dep: edges) {
+      addEdge(dep);
+    }
+  }
+  
-    edges.add(dependency);
-    Set<Dependency> outboundEdges = vertices.get(dependency.getDepender());
-    if(outboundEdges == null) {
-      outboundEdges = new HashSet();
-      vertices.put(dependency.getDepender(), outboundEdges);
+    if (!edges.contains(dependency)) {
+      edges.add(dependency);
+      Set<Dependency> outboundEdges = vertices.get(dependency.getDepender());
+      if(outboundEdges == null) {
+        outboundEdges = new HashSet();
+        vertices.put(dependency.getDepender(), outboundEdges);
+      }
+      outboundEdges.add(dependency);
+      
+      if(vertices.get(dependency.getDependsOn()) == null) {
+        vertices.put(dependency.getDependsOn(), new HashSet());
+      }
-    outboundEdges.add(dependency);
-    
-    if(vertices.get(dependency.getDependsOn()) == null) {
-      vertices.put(dependency.getDependsOn(), new HashSet());
-    }
-    
-      boolean foundCycle = visitCycle(start, unvisited, finished, cycle);
+      boolean foundCycle = visitCycle(start, unvisited, finished, cycle, 0);
+   * This will find the deepest call chain in the graph.  If a
+   * cycle is detected it will be returned.  Otherwise all
+   * subgraphs are traversed to find the one that has the most
+   * depth.  This usually indicates the thread that is blocking
+   * the most other threads.
+   */
+  public DependencyGraph findDeepestGraph() {
+    int depth = 0;
+    DependencyGraph deepest = null;
+    
+    for (Object dep: vertices.keySet()) {
+      int itsDepth = getDepth(dep);
+      if (itsDepth > depth) {
+        deepest = getSubGraph(dep);
+        depth = itsDepth;
+      }
+    }
+    
+    return deepest;
+  }
+  
+  
+  public DependencyGraph findDependenciesWith(String objectName) {
+    Object obj = null;
+    Dependency objDep = null;
+    for (Dependency dep: edges) {
+      if (dep.depender.toString().contains(objectName)) {
+        obj = dep.depender;
+        objDep = dep;
+        break;
+      }
+      if (dep.dependsOn.toString().contains(objectName)) {
+        obj = dep.dependsOn;
+        objDep = dep;
+        break;
+      }
+    }
+    if (obj == null) {
+      return null;
+    }
+    
+    DependencyGraph result = new DependencyGraph();
+    
+    Set<Object> dependsOnObj = new HashSet<>();
+    dependsOnObj.add(obj);
+    boolean anyAdded = true;
+    while (anyAdded) {
+      anyAdded = false;
+      for (Dependency dep: edges) {
+        if (dependsOnObj.contains(dep.dependsOn)
+            && !dependsOnObj.contains(dep.depender)) {
+          anyAdded = true;
+          dependsOnObj.add(dep.depender);
+        }
+      }
+    }
+    for (Object depender: dependsOnObj) {
+      if (!result.getVertices().contains(depender)) {
+        DependencyGraph subgraph = getSubGraph(depender);
+        result.addEdges(subgraph.getEdges());
+      }
+    }
+    return result;
+  }
+  
+  
+  /**
+   * @param depth the depth of the recursion chain up to this point
-      Set<Object> finished, CycleHolder cycle) {
+      Set<Object> finished, CycleHolder cycle, int depth) {
+    cycle.processDepth(depth);
+    
-      foundCycle |= visitCycle(dep.getDependsOn(), unvisited, finished, cycle);
+      foundCycle |= visitCycle(dep.getDependsOn(), unvisited, finished, cycle, depth+1);
+  /** return the depth of the subgraph for the given object */
+  private int getDepth(Object depender) {
+    Set<Object> unvisited = new HashSet<Object>(vertices.keySet());
+    Set<Object> finished = new HashSet<Object>(vertices.size());
+
+    Object start = depender;
+    CycleHolder cycle = new CycleHolder();
+
+    boolean foundCycle = visitCycle(start, unvisited, finished, cycle, 0);
+
+    if(foundCycle) {
+      return Integer.MAX_VALUE;
+    } else {
+      return cycle.getMaxDepth();
+    }
+  }
+  
+
+    private int maxDepth = 0;
+    
+    public void processDepth(int depth) {
+      if (depth > maxDepth) {
+        maxDepth = depth;
+      }
+    }
+    
+    public int getMaxDepth() {
+      return maxDepth;
+    }
+  

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import static org.apache.geode.distributed.ConfigurationProperties.CLUSTER_CONFIGURATION_DIR;
-import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
-import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_POST_PROCESSOR;
+import static org.apache.geode.distributed.ConfigurationProperties.*;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.nio.file.Path;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactoryConfigurationError;
+import org.apache.logging.log4j.Logger;
+import org.w3c.dom.Document;
+import org.xml.sax.SAXException;
+
-import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheLoaderException;
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.distributed.LeaseExpiredException;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
-import org.apache.logging.log4j.Logger;
-import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileFilter;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.nio.file.Path;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.stream.Collectors;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactoryConfigurationError;
-
+
+
-  public static final String SHARED_CONFIG_LOCK_NAME = "__CLUSTER_CONFIG_LOCK";
+  private static final String SHARED_CONFIG_LOCK_NAME = "__CLUSTER_CONFIG_LOCK";
-  private GemFireCacheImpl cache;
+  private final InternalCache cache;
-  public ClusterConfigurationService(Cache cache) throws IOException {
-    this.cache = (GemFireCacheImpl) cache;
+  public ClusterConfigurationService(InternalCache cache) throws IOException {
+    this.cache = cache;
-    configDirPath = FilenameUtils.concat(clusterConfigRootDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
-    configDiskDirPath = FilenameUtils.concat(clusterConfigRootDir, configDiskDirName);
-    sharedConfigLockingService = getSharedConfigLockService(cache.getDistributedSystem());
-    status.set(SharedConfigurationStatus.NOT_STARTED);
+    this.configDirPath =
+        FilenameUtils.concat(clusterConfigRootDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+    this.configDiskDirPath = FilenameUtils.concat(clusterConfigRootDir, configDiskDirName);
+    this.sharedConfigLockingService = getSharedConfigLockService(cache.getDistributedSystem());
+    this.status.set(SharedConfigurationStatus.NOT_STARTED);
-    } catch (IllegalArgumentException e) {
+    } catch (IllegalArgumentException ignore) {
-        Configuration configuration = (Configuration) configRegion.get(group);
+        Configuration configuration = configRegion.get(group);
-          logger.error("error updating cluster configuration for group " + group, e);
+          logger.error("error updating cluster configuration for group {}", group, e);
-        Configuration configuration = (Configuration) configRegion.get(group);
+        Configuration configuration = configRegion.get(group);
-            logger.error("error updating cluster configuration for group " + group, e);
+            logger.error("error updating cluster configuration for group {}", group, e);
-  // we don't need to trigger the change listener for this modification, so it's ok to
-  // operate on the original configuration object
+  /**
+   * we don't need to trigger the change listener for this modification, so it's ok to operate on
+   * the original configuration object
+   */
-            logger.error("error updating cluster configuration for group " + group, e);
+            logger.error("error updating cluster configuration for group {}", group, e);
-
-    boolean success = true;
+    boolean success = true;
-        String groupDir = FilenameUtils.concat(configDirPath, group);
+        String groupDir = FilenameUtils.concat(this.configDirPath, group);
-          File jarFile = new File(filePath);
+            File jarFile = new File(filePath);
-    boolean success = true;
+    boolean success = true;
+   * <p>
+   * used when creating cluster config response and used when uploading the jars to another locator
-  // used when creating cluster config response
-  // and used when uploading the jars to another locator
-  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws Exception {
+  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws IOException {
-  public void downloadJarFromOtherLocators(String groupName, String jarName) throws Exception {
+  public void downloadJarFromOtherLocators(String groupName, String jarName)
+      throws IllegalStateException, IOException {
-    DM dm = cache.getDistributionManager();
-    DistributedMember me = cache.getMyId();
+    DM dm = this.cache.getDistributionManager();
+    DistributedMember me = this.cache.getMyId();
-  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws Exception {
+  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws IOException {
-  public void initSharedConfiguration(boolean loadSharedConfigFromDir) throws Exception {
-    status.set(SharedConfigurationStatus.STARTED);
+  void initSharedConfiguration(boolean loadSharedConfigFromDir)
+      throws CacheLoaderException, TimeoutException, IllegalStateException, IOException,
+      TransformerException, SAXException, ParserConfigurationException {
+    this.status.set(SharedConfigurationStatus.STARTED);
-        Set<String> groups = configRegion.keySet();
-        for (String group : groups) {
-          Configuration config = configRegion.get(group);
+        for (Entry<String, Configuration> stringConfigurationEntry : configRegion.entrySet()) {
+          Configuration config = stringConfigurationEntry.getValue();
-            if (!(getPathToJarOnThisLocator(group, jar).toFile()).exists()) {
-              downloadJarFromOtherLocators(group, jar);
+            if (!getPathToJarOnThisLocator(stringConfigurationEntry.getKey(), jar).toFile()
+                .exists()) {
+              downloadJarFromOtherLocators(stringConfigurationEntry.getKey(), jar);
-    status.set(SharedConfigurationStatus.RUNNING);
+    this.status.set(SharedConfigurationStatus.RUNNING);
-    Properties securityProps = cache.getDistributedSystem().getSecurityProperties();
+    Properties securityProps = this.cache.getDistributedSystem().getSecurityProperties();
-  public ConfigurationResponse createConfigurationReponse(final ConfigurationRequest configRequest)
-      throws Exception {
+  public ConfigurationResponse createConfigurationResponse(final ConfigurationRequest configRequest)
+      throws LeaseExpiredException, IOException {
-      boolean isLocked = sharedConfigLockingService.lock(SHARED_CONFIG_LOCK_NAME, 5000, 5000);
+      boolean isLocked = this.sharedConfigLockingService.lock(SHARED_CONFIG_LOCK_NAME, 5000, 5000);
-        sharedConfigLockingService.unlock(SHARED_CONFIG_LOCK_NAME);
+        this.sharedConfigLockingService.unlock(SHARED_CONFIG_LOCK_NAME);
-  public SharedConfigurationStatusResponse createStatusResponse() {
+  SharedConfigurationStatusResponse createStatusResponse() {
-    response.addWaitingLocatorInfo(newerSharedConfigurationLocatorInfo);
+    response.addWaitingLocatorInfo(this.newerSharedConfigurationLocatorInfo);
-   * <p/>
+   * <p>
-        File file = new File(configDiskDirPath);
+        File file = new File(this.configDiskDirPath);
-      FileUtils.deleteDirectory(new File(configDirPath));
+      FileUtils.deleteDirectory(new File(this.configDirPath));
-    return new File(configDirPath).toPath().resolve(groupName).resolve(jarName);
+    return new File(this.configDirPath).toPath().resolve(groupName).resolve(jarName);
-    Configuration configuration = getConfigurationRegion().get(groupName);
-    return configuration;
+    return getConfigurationRegion().get(groupName);
-  public Map<String, Configuration> getEntireConfiguration() throws Exception {
+  public Map<String, Configuration> getEntireConfiguration() {
-      PersistentMemberManager pmm = cache.getPersistentMemberManager();
+      PersistentMemberManager pmm = this.cache.getPersistentMemberManager();
-          newerSharedConfigurationLocatorInfo.add(new PersistentMemberPattern(persMemId));
+          this.newerSharedConfigurationLocatorInfo.add(new PersistentMemberPattern(persMemId));
-  public void loadSharedConfigurationFromDisk() throws Exception {
+  public void loadSharedConfigurationFromDisk()
+      throws SAXException, ParserConfigurationException, TransformerException, IOException {
-        new File(configDirPath).listFiles((FileFilter) DirectoryFileFilter.INSTANCE);
-    Map<String, Configuration> sharedConfiguration = new HashMap<String, Configuration>();
+        new File(this.configDirPath).listFiles((FileFilter) DirectoryFileFilter.INSTANCE);
+      Map<String, Configuration> sharedConfiguration = new HashMap<>();
-      Region clusterRegion = getConfigurationRegion();
+      Region<String, Configuration> clusterRegion = getConfigurationRegion();
-    File configDirFile = new File(configDirPath);
+    File configDirFile = new File(this.configDirPath);
-          + new SimpleDateFormat("yyyyMMddhhmm").format(new Date()) + "." + System.nanoTime();
-      File configDirFile2 = new File(configDirFile.getParent(), configDirFileName2);
+          + new SimpleDateFormat("yyyyMMddhhmm").format(new Date()) + '.' + System.nanoTime();
+        File configDirFile2 = new File(configDirFile.getParent(), configDirFileName2);
-  public void writeConfigToFile(final Configuration configuration) throws Exception {
+  public void writeConfigToFile(final Configuration configuration) throws IOException {
+  // TODO: return value is never used
-    return sharedConfigLockingService.lock(SHARED_CONFIG_LOCK_NAME, -1, -1);
+    return this.sharedConfigLockingService.lock(SHARED_CONFIG_LOCK_NAME, -1, -1);
-    sharedConfigLockingService.unlock(SHARED_CONFIG_LOCK_NAME);
+    this.sharedConfigLockingService.unlock(SHARED_CONFIG_LOCK_NAME);
-
-    Region<String, Configuration> configRegion = cache.getRegion(CONFIG_REGION_NAME);
+    Region<String, Configuration> configRegion = this.cache.getRegion(CONFIG_REGION_NAME);
-        File diskDir = new File(configDiskDirPath);
+        File diskDir = new File(this.configDiskDirPath);
-            throw new IOException("Cannot create directory at " + configDiskDirPath);
+            // TODO: throw caught by containing try statement
+            throw new IOException("Cannot create directory at " + this.configDiskDirPath);
-        cache.createDiskStoreFactory().setDiskDirs(diskDirs).setAutoCompact(true)
+        this.cache.createDiskStoreFactory().setDiskDirs(diskDirs).setAutoCompact(true)
-        AttributesFactory<String, Configuration> regionAttrsFactory =
-            new AttributesFactory<String, Configuration>();
+        AttributesFactory<String, Configuration> regionAttrsFactory = new AttributesFactory<>();
-        configRegion =
-            cache.createVMRegion(CONFIG_REGION_NAME, regionAttrsFactory.create(), internalArgs);
+        configRegion = this.cache.createVMRegion(CONFIG_REGION_NAME, regionAttrsFactory.create(),
+            internalArgs);
-      throw e; // CONFIG: don't rethrow as Exception, keep it a subclass of CancelException
+      // CONFIG: don't rethrow as Exception, keep it a subclass of CancelException
+      throw e;
-  private File createConfigDirIfNecessary(final String configName) throws Exception {
+  private File createConfigDirIfNecessary(final String configName) throws IOException {
-  // check if it's ok from populate the properties from one member to another
-  public static boolean isMisConfigured(Properties fromProps, Properties toProps, String key) {
-    String fromPropValue = fromProps.getProperty(key);
-    String toPropValue = toProps.getProperty(key);
-
-    // if this to prop is not specified, this is always OK.
-    if (org.apache.commons.lang.StringUtils.isBlank(toPropValue))
-      return false;
-
-    // to props is not blank, but from props is blank, NOT OK.
-    if (org.apache.commons.lang.StringUtils.isBlank(fromPropValue))
-      return true;
-
-    // at this point check for eqality
-    return !fromPropValue.equals(toPropValue);
-  }

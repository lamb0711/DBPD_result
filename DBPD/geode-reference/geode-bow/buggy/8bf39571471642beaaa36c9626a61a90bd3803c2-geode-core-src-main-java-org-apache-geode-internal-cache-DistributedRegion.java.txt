Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+
-public class DistributedRegion extends LocalRegion implements 
-    CacheDistributionAdvisee
-{
+public class DistributedRegion extends LocalRegion implements CacheDistributionAdvisee {
-  
+
-  
+
-  
+
-   * True if this region is has any required roles defined and the LossAction is
-   * either NO_ACCESS or LIMITED_ACCESS. Reliability checks will only happen if
-   * this is true.
+   * True if this region is has any required roles defined and the LossAction is either NO_ACCESS or
+   * LIMITED_ACCESS. Reliability checks will only happen if this is true.
-   * Latch that is opened after initialization waits for required roles up to
-   * the <a href="DistributedSystem#member-timeout">member-timeout </a>.
+   * Latch that is opened after initialization waits for required roles up to the
+   * <a href="DistributedSystem#member-timeout">member-timeout </a>.
-  protected final StoppableCountDownLatch initializationLatchAfterMemberTimeout; 
+  protected final StoppableCountDownLatch initializationLatchAfterMemberTimeout;
-  
+
-   * This boolean is set to false when this region
-   * is non-persistent, but there are persistent members in the distributed system
-   * to which all region modifications should be forwarded
-   * see bug 45186
+   * This boolean is set to false when this region is non-persistent, but there are persistent
+   * members in the distributed system to which all region modifications should be forwarded see bug
+   * 45186
-  
+
-   * Lock to prevent multiple threads on this member from performing
-   * a clear at the same time.
+   * Lock to prevent multiple threads on this member from performing a clear at the same time.
-  protected DistributedRegion(String regionName, RegionAttributes attrs,
-      LocalRegion parentRegion, GemFireCacheImpl cache,
-      InternalRegionArguments internalRegionArgs) {
+  protected DistributedRegion(String regionName, RegionAttributes attrs, LocalRegion parentRegion,
+      GemFireCacheImpl cache, InternalRegionArguments internalRegionArgs) {
-    this.initializationLatchAfterMemberTimeout = new StoppableCountDownLatch(
-        getCancelCriterion(), 1);
+    this.initializationLatchAfterMemberTimeout =
+        new StoppableCountDownLatch(getCancelCriterion(), 1);
-    
+
-        && !isInternalRegion() && !attrs.getScope().isAck() && !doesNotDistribute() && attrs.getDataPolicy().withStorage()) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.DistributedRegion_REGION_0_1_SPLITBRAIN_CONFIG_WARNING,
-          new Object[] { regionName, attrs.getScope() })); 
+        && !isInternalRegion() && !attrs.getScope().isAck() && !doesNotDistribute()
+        && attrs.getDataPolicy().withStorage()) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.DistributedRegion_REGION_0_1_SPLITBRAIN_CONFIG_WARNING,
+          new Object[] {regionName, attrs.getScope()}));
-    if (!getDistributionManager().getConfig().getEnableNetworkPartitionDetection() 
-        && attrs.getDataPolicy().withPersistence() && !loggedNetworkPartitionWarning.getAndSet(true)) {
+    if (!getDistributionManager().getConfig().getEnableNetworkPartitionDetection()
+        && attrs.getDataPolicy().withPersistence()
+        && !loggedNetworkPartitionWarning.getAndSet(true)) {
-          new Object[] { regionName, attrs.getScope() }));
+          new Object[] {regionName, attrs.getScope()}));
-    boolean setRequiresReliabilityCheck = attrs.getMembershipAttributes()
-        .hasRequiredRoles()
-        &&
-        // note that the following includes NO_ACCESS, LIMITED_ACCESS,
+    boolean setRequiresReliabilityCheck = attrs.getMembershipAttributes().hasRequiredRoles() &&
+    // note that the following includes NO_ACCESS, LIMITED_ACCESS,
-    Set reqRoles = new HashSet(attrs.getMembershipAttributes()
-        .getRequiredRoles());
+    Set reqRoles = new HashSet(attrs.getMembershipAttributes().getRequiredRoles());
-        //         if
+        // if
-        //           tmp = cache.getReliableMessageQueueFactory().create(this);
-        //         }
+        // tmp = cache.getReliableMessageQueueFactory().create(this);
+        // }
-    if(internalRegionArgs.isUsedForPartitionedRegionBucket()) {
+    if (internalRegionArgs.isUsedForPartitionedRegionBucket()) {
-    } else if (this.allowsPersistence()){
-      //TODO prpersist - using this lock service is a hack. Maybe? Or maybe
-      //it's ok if we have one (rarely used) lock service for many operations?
-      //What does the resource manager do?
+    } else if (this.allowsPersistence()) {
+      // TODO prpersist - using this lock service is a hack. Maybe? Or maybe
+      // it's ok if we have one (rarely used) lock service for many operations?
+      // What does the resource manager do?
-        //TODO prpersist - this is just a quick and dirty storage mechanism so that
-        //I can test the storage.
+        // TODO prpersist - this is just a quick and dirty storage mechanism so that
+        // I can test the storage.
-        if(getDataPolicy().withPersistence()) {
+        if (getDataPolicy().withPersistence()) {
-        this.persistenceAdvisor = new PersistenceAdvisorImpl(distAdvisor, dl, storage, this.getFullPath(), diskStats, memberManager);
+        this.persistenceAdvisor = new PersistenceAdvisorImpl(distAdvisor, dl, storage,
+            this.getFullPath(), diskStats, memberManager);
-    if(this.persistenceAdvisor != null) {
+    if (this.persistenceAdvisor != null) {
-    
+
-  
+
-  
+
-   *  
+   * 
-  protected CacheDistributionAdvisor createDistributionAdvisor(InternalRegionArguments internalRegionArgs) {
-    return CacheDistributionAdvisor.createCacheDistributionAdvisor(this);  // Warning: potential early escape of object before full construction
+  protected CacheDistributionAdvisor createDistributionAdvisor(
+      InternalRegionArguments internalRegionArgs) {
+    return CacheDistributionAdvisor.createCacheDistributionAdvisor(this); // Warning: potential
+                                                                          // early escape of object
+                                                                          // before full
+                                                                          // construction
-  
+
-      return false; 
+      return false;
-    return this.concurrencyChecksEnabled &&
-        (this.srp == null) &&
-        !isTX() &&
-        this.scope.isDistributed() &&
-        !this.dataPolicy.withReplication();
+    return this.concurrencyChecksEnabled && (this.srp == null) && !isTX()
+        && this.scope.isDistributed() && !this.dataPolicy.withReplication();
-  
-  
+
+
-   * @see LocalRegion#virtualPut(EntryEventImpl, boolean, boolean, Object, 
-   * boolean, long, boolean)
+   * @see LocalRegion#virtualPut(EntryEventImpl, boolean, boolean, Object, boolean, long, boolean)
-  protected
-  boolean virtualPut(EntryEventImpl event,
-                     boolean ifNew,
-                     boolean ifOld,
-                     Object expectedOldValue,
-                     boolean requireOldValue,
-                     long lastModified,
-                     boolean overwriteDestroyed)
-  throws TimeoutException,
-         CacheWriterException {
+  protected boolean virtualPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue, long lastModified,
+      boolean overwriteDestroyed) throws TimeoutException, CacheWriterException {
-    
+
-        !event.isLocalLoad() &&
-        !event.isSingleHopPutOp()) { // Single Hop Op means dlock is already taken at origin node.
+        !event.isLocalLoad() && !event.isSingleHopPutOp()) { // Single Hop Op means dlock is already
+                                                             // taken at origin node.
-          if (re == null /*|| re.isTombstone()*/ || !this.generateVersionTag) {
+          if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
-              // putAll will send a single one-hop for empty regions.  for other missing entries
-              // we need to get a valid version number before modifying the local cache 
-              boolean didDistribute = RemotePutMessage.distribute(event, lastModified,
-                  false, false, expectedOldValue, requireOldValue, !this.generateVersionTag);
+              // putAll will send a single one-hop for empty regions. for other missing entries
+              // we need to get a valid version number before modifying the local cache
+              boolean didDistribute = RemotePutMessage.distribute(event, lastModified, false, false,
+                  expectedOldValue, requireOldValue, !this.generateVersionTag);
-                  // if the event wasn't applied by the one-hop replicate it will not have a version tag
+                  // if the event wasn't applied by the one-hop replicate it will not have a version
+                  // tag
-        return super.virtualPut(event,
-                                ifNew,
-                                ifOld,
-                                expectedOldValue,
-                                requireOldValue,
-                                lastModified,
-                                overwriteDestroyed);
-      }
-      else {
+        return super.virtualPut(event, ifNew, ifOld, expectedOldValue, requireOldValue,
+            lastModified, overwriteDestroyed);
+      } else {
-              "Cache encountered replay of event containing delta bytes for key "
-                  + event.getKey());
+              "Cache encountered replay of event containing delta bytes for key " + event.getKey());
-        // been successfully applied to the cache.  Distributed messages and
+        // been successfully applied to the cache. Distributed messages and
-        
+
-        // event, but putAll did not. We add the logic back here, not to put 
-        // back into DR.distributeUpdate() because we moved this part up into 
-        // LR.basicPutPart3 in purpose. Reviewed by Bruce.  
+        // event, but putAll did not. We add the logic back here, not to put
+        // back into DR.distributeUpdate() because we moved this part up into
+        // LR.basicPutPart3 in purpose. Reviewed by Bruce.
-        /* doing this so that other VMs will apply this no matter what. If it 
-         * is an "update" they will not apply it if they don't have the key.
-         * Because this is probably a retry, it will never get applied to this 
-         * local AbstractRegionMap, and so will never be flipped to a 'create'
+        /*
+         * doing this so that other VMs will apply this no matter what. If it is an "update" they
+         * will not apply it if they don't have the key. Because this is probably a retry, it will
+         * never get applied to this local AbstractRegionMap, and so will never be flipped to a
+         * 'create'
-          event.invokeCallbacks(this,true, true);
+          event.invokeCallbacks(this, true, true);
-    }
-    finally {
+    } finally {
-  
+
-    
+
-    
+
-      if (re == null /*|| re.isTombstone()*/ || !this.generateVersionTag) {
+      if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
-        boolean didDistribute = RemotePutMessage.distribute(event, lastModified,
-            ifNew, ifOld, null, false, !this.generateVersionTag);
+        boolean didDistribute = RemotePutMessage.distribute(event, lastModified, ifNew, ifOld, null,
+            false, !this.generateVersionTag);
-	  /*
-	   * force shared data view so that we just do the virtual op, accruing things in the put all operation for later
-	   */
-	if(isTX()) {
-		event.getPutAllOperation().addEntry(event);
-	} else {
-		getSharedDataView().putEntry(event, false, false, null, false, 0L, false);
-	}
+    /*
+     * force shared data view so that we just do the virtual op, accruing things in the put all
+     * operation for later
+     */
+    if (isTX()) {
+      event.getPutAllOperation().addEntry(event);
+    } else {
+      getSharedDataView().putEntry(event, false, false, null, false, 0L, false);
+    }
-  
+
-    // force shared data view so that we just do the virtual op, accruing things in the bulk operation for later
-    if(isTX()) {
+    // force shared data view so that we just do the virtual op, accruing things in the bulk
+    // operation for later
+    if (isTX()) {
-      //getSharedDataView().destroyExistingEntry(event, true, null);
+      // getSharedDataView().destroyExistingEntry(event, true, null);
-  
+
-  public void basicPutPart3(EntryEventImpl event, RegionEntry entry,
-      boolean isInitialized, long lastModified, boolean invokeCallbacks,
-      boolean ifNew, boolean ifOld, Object expectedOldValue,
-      boolean requireOldValue) {
-    
+  public void basicPutPart3(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+      long lastModified, boolean invokeCallbacks, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue) {
+
-    super.basicPutPart3(event, entry, isInitialized, lastModified,
-        invokeCallbacks, ifNew, ifOld, expectedOldValue, requireOldValue);
+    super.basicPutPart3(event, entry, isInitialized, lastModified, invokeCallbacks, ifNew, ifOld,
+        expectedOldValue, requireOldValue);
-  protected void distributeUpdate(EntryEventImpl event, long lastModified, boolean ifNew, boolean ifOld, Object expectedOldValue, boolean requireOldValue) {
+  protected void distributeUpdate(EntryEventImpl event, long lastModified, boolean ifNew,
+      boolean ifOld, Object expectedOldValue, boolean requireOldValue) {
-        if (event.getInhibitDistribution()) {
-          // this has already been distributed by a one-hop operation
-          distribute = false;
+      if (event.getInhibitDistribution()) {
+        // this has already been distributed by a one-hop operation
+        distribute = false;
+      }
+      if (distribute) {
+        UpdateOperation op = new UpdateOperation(event, lastModified);
+        if (logger.isTraceEnabled()) {
+          logger.trace("distributing operation for event : {} : for region : {}", event,
+              this.getName());
-        if (distribute) {
-          UpdateOperation op = new UpdateOperation(event, lastModified);
-          if (logger.isTraceEnabled()) {
-            logger.trace("distributing operation for event : {} : for region : {}", event, this.getName());
-          }
-          op.distribute();
-        }
+        op.distribute();
+      }
-    
+
-      logger.trace("shouldGenerateVersionTag this.generateVersionTag={} ccenabled={} dataPolicy={} event:{}",
+      logger.trace(
+          "shouldGenerateVersionTag this.generateVersionTag={} ccenabled={} dataPolicy={} event:{}",
-    if (!this.concurrencyChecksEnabled || this.dataPolicy == DataPolicy.EMPTY || !this.generateVersionTag) {
+    if (!this.concurrencyChecksEnabled || this.dataPolicy == DataPolicy.EMPTY
+        || !this.generateVersionTag) {
+
-   * Throws RegionAccessException if required roles are missing and the
-   * LossAction is NO_ACCESS
+   * Throws RegionAccessException if required roles are missing and the LossAction is NO_ACCESS
-   * @throws RegionAccessException
-   *           if required roles are missing and the LossAction is NO_ACCESS
+   * @throws RegionAccessException if required roles are missing and the LossAction is NO_ACCESS
-  protected void checkForNoAccess()
-  {
+  protected void checkForNoAccess() {
-          Set roles = Collections.unmodifiableSet(new HashSet(
-              this.missingRequiredRoles));
-          throw new RegionAccessException(LocalizedStrings.DistributedRegion_OPERATION_IS_DISALLOWED_BY_LOSSACTION_0_BECAUSE_THESE_REQUIRED_ROLES_ARE_MISSING_1.toLocalizedString(new Object[] {getMembershipAttributes().getLossAction(), roles}), getFullPath(), roles);
+          Set roles = Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
+          throw new RegionAccessException(
+              LocalizedStrings.DistributedRegion_OPERATION_IS_DISALLOWED_BY_LOSSACTION_0_BECAUSE_THESE_REQUIRED_ROLES_ARE_MISSING_1
+                  .toLocalizedString(
+                      new Object[] {getMembershipAttributes().getLossAction(), roles}),
+              getFullPath(), roles);
-   * Throws RegionAccessException is required roles are missing and the
-   * LossAction is either NO_ACCESS or LIMITED_ACCESS.
+   * Throws RegionAccessException is required roles are missing and the LossAction is either
+   * NO_ACCESS or LIMITED_ACCESS.
-   * @throws RegionAccessException
-   *           if required roles are missing and the LossAction is either
-   *           NO_ACCESS or LIMITED_ACCESS
+   * @throws RegionAccessException if required roles are missing and the LossAction is either
+   *         NO_ACCESS or LIMITED_ACCESS
-  protected void checkForLimitedOrNoAccess()
-  {
+  protected void checkForLimitedOrNoAccess() {
-          Set roles = Collections.unmodifiableSet(new HashSet(
-              this.missingRequiredRoles));
+          Set roles = Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
-          throw new RegionAccessException(LocalizedStrings.DistributedRegion_OPERATION_IS_DISALLOWED_BY_LOSSACTION_0_BECAUSE_THESE_REQUIRED_ROLES_ARE_MISSING_1
-              .toLocalizedString(new Object[] { getMembershipAttributes().getLossAction(), roles}), getFullPath(), roles);
+          throw new RegionAccessException(
+              LocalizedStrings.DistributedRegion_OPERATION_IS_DISALLOWED_BY_LOSSACTION_0_BECAUSE_THESE_REQUIRED_ROLES_ARE_MISSING_1
+                  .toLocalizedString(
+                      new Object[] {getMembershipAttributes().getLossAction(), roles}),
+              getFullPath(), roles);
-  
+
-    handleReliableDistribution(data, successfulRecipients,
-        Collections.EMPTY_SET, Collections.EMPTY_SET);
+    handleReliableDistribution(data, successfulRecipients, Collections.EMPTY_SET,
+        Collections.EMPTY_SET);
-  protected void handleReliableDistribution(ReliableDistributionData data,
-      Set successfulRecipients, Set otherRecipients1, Set otherRecipients2)
-  {
+  protected void handleReliableDistribution(ReliableDistributionData data, Set successfulRecipients,
+      Set otherRecipients1, Set otherRecipients2) {
-        InternalDistributedMember mbr = (InternalDistributedMember)iter.next();
+        InternalDistributedMember mbr = (InternalDistributedMember) iter.next();
-        InternalDistributedMember mbr = (InternalDistributedMember)iter.next();
+        InternalDistributedMember mbr = (InternalDistributedMember) iter.next();
-        InternalDistributedMember mbr = (InternalDistributedMember)iter.next();
+        InternalDistributedMember mbr = (InternalDistributedMember) iter.next();
-//       if (rp.isAllAccessWithQueuing()) {
-//         this.rmq.add(data, failedRoles);
-//       } else {
+      // if (rp.isAllAccessWithQueuing()) {
+      // this.rmq.add(data, failedRoles);
+      // } else {
-      throw new RegionDistributionException(LocalizedStrings.DistributedRegion_OPERATION_DISTRIBUTION_MAY_HAVE_FAILED_TO_NOTIFY_THESE_REQUIRED_ROLES_0.toLocalizedString(failedRoles), getFullPath(), failedRoles);
-//       }
+      throw new RegionDistributionException(
+          LocalizedStrings.DistributedRegion_OPERATION_DISTRIBUTION_MAY_HAVE_FAILED_TO_NOTIFY_THESE_REQUIRED_ROLES_0
+              .toLocalizedString(failedRoles),
+          getFullPath(), failedRoles);
+      // }
-   * Called when we do a distributed operation and don't have anyone to
-   * distributed it too. Since this is only called when no distribution was done
-   * (i.e. no recipients) we do not check isMissingRequiredRoles because it
-   * might not longer be true due to race conditions
+   * Called when we do a distributed operation and don't have anyone to distributed it too. Since
+   * this is only called when no distribution was done (i.e. no recipients) we do not check
+   * isMissingRequiredRoles because it might not longer be true due to race conditions
-   * @return false if this region has at least one required role and queuing is
-   *         configured. Returns true if sending to no one is ok.
-   * @throws RoleException
-   *           if a required role is missing and the LossAction is either
-   *           NO_ACCESS or LIMITED_ACCESS.
+   * @return false if this region has at least one required role and queuing is configured. Returns
+   *         true if sending to no one is ok.
+   * @throws RoleException if a required role is missing and the LossAction is either NO_ACCESS or
+   *         LIMITED_ACCESS.
-  protected boolean isNoDistributionOk()
-  {
+  protected boolean isNoDistributionOk() {
-      //       if (ra.getLossAction().isAllAccessWithQueuing()) {
-      //         return !ra.hasRequiredRoles();
-      //       } else {
+      // if (ra.getLossAction().isAllAccessWithQueuing()) {
+      // return !ra.hasRequiredRoles();
+      // } else {
-      throw new RegionDistributionException(LocalizedStrings.DistributedRegion_OPERATION_DISTRIBUTION_WAS_NOT_DONE_TO_THESE_REQUIRED_ROLES_0.toLocalizedString(failedRoles), getFullPath(), failedRoles);
-      //       }
+      throw new RegionDistributionException(
+          LocalizedStrings.DistributedRegion_OPERATION_DISTRIBUTION_WAS_NOT_DONE_TO_THESE_REQUIRED_ROLES_0
+              .toLocalizedString(failedRoles),
+          getFullPath(), failedRoles);
+      // }
-  
+
-   * returns true if this Region does not distribute its operations to other
-   * members.
+   * returns true if this Region does not distribute its operations to other members.
+   * 
-  
+
-  
-  
+
+
-   * Adjust the specified set of recipients by removing any of them that are
-   * currently having their data queued.
+   * Adjust the specified set of recipients by removing any of them that are currently having their
+   * data queued.
-   * @param recipients
-   *          the set of recipients that a message is to be distributed too.
-   *          Recipients that are currently having their data queued will be
-   *          removed from this set.
-   * @return the set, possibly null, of recipients that are currently having
-   *         their data queued.
+   * @param recipients the set of recipients that a message is to be distributed too. Recipients
+   *        that are currently having their data queued will be removed from this set.
+   * @return the set, possibly null, of recipients that are currently having their data queued.
-  protected Set adjustForQueuing(Set recipients)
-  {
+  protected Set adjustForQueuing(Set recipients) {
-    //     if (this.requiresReliabilityCheck) {
-    //       MembershipAttributes ra = getMembershipAttributes();
-    //       if (ra.getLossAction().isAllAccessWithQueuing()) {
-    //         Set currentQueuedRoles = this.rmq.getQueuingRoles();
-    //         if (currentQueuedRoles != null) {
-    //           // foreach recipient see if any of his roles are queued and if
-    //           // they are remove him from recipients and add him to result
-    //           Iterator it = recipients.iterator();
-    //           while (it.hasNext()) {
-    //             DistributedMember dm = (DistributedMember)it.next();
-    //             Set dmRoles = dm.getRoles();
-    //             if (!dmRoles.isEmpty()) {
-    //               if (intersects(dmRoles, currentQueuedRoles)) {
-    //                 it.remove(); // fix for bug 34447
-    //                 if (result == null) {
-    //                   result = new HashSet();
-    //                 }
-    //                 result.add(dm);
-    //               }
-    //             }
-    //           }
-    //         }
-    //       }
-    //     }
+    // if (this.requiresReliabilityCheck) {
+    // MembershipAttributes ra = getMembershipAttributes();
+    // if (ra.getLossAction().isAllAccessWithQueuing()) {
+    // Set currentQueuedRoles = this.rmq.getQueuingRoles();
+    // if (currentQueuedRoles != null) {
+    // // foreach recipient see if any of his roles are queued and if
+    // // they are remove him from recipients and add him to result
+    // Iterator it = recipients.iterator();
+    // while (it.hasNext()) {
+    // DistributedMember dm = (DistributedMember)it.next();
+    // Set dmRoles = dm.getRoles();
+    // if (!dmRoles.isEmpty()) {
+    // if (intersects(dmRoles, currentQueuedRoles)) {
+    // it.remove(); // fix for bug 34447
+    // if (result == null) {
+    // result = new HashSet();
+    // }
+    // result.add(dm);
+    // }
+    // }
+    // }
+    // }
+    // }
+    // }
-   * @param a
-   *          a non-null non-empty set
-   * @param b
-   *          a non-null non-empty set
+   * @param a a non-null non-empty set
+   * @param b a non-null non-empty set
-  public static boolean intersects(Set a, Set b)
-  {
+  public static boolean intersects(Set a, Set b) {
-    }
-    else {
+    } else {
-  public boolean requiresReliabilityCheck()
-  {
+  public boolean requiresReliabilityCheck() {
-   * If the region is in NO_ACCESS due to reliability configuration, then no
-   * expiration actions are allowed.
+   * If the region is in NO_ACCESS due to reliability configuration, then no expiration actions are
+   * allowed.
-   * If the region is in LIMITED_ACCESS due to reliability configuration, then
-   * only non-distributed expiration actions are allowed.
+   * If the region is in LIMITED_ACCESS due to reliability configuration, then only non-distributed
+   * expiration actions are allowed.
-  protected boolean isExpirationAllowed(ExpiryTask expiry)
-  {
+  protected boolean isExpirationAllowed(ExpiryTask expiry) {
-  protected boolean resumeReliability(InternalDistributedMember id,
-      Set newlyAcquiredRoles)
-  {
+  protected boolean resumeReliability(InternalDistributedMember id, Set newlyAcquiredRoles) {
-      }
-      else if (ra.isReinitialize()) {
+      } else if (ra.isReinitialize()) {
-    }
-    catch (Exception e) {
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+    } catch (Exception e) {
+      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+          e);
-                                      final Set newlyAcquiredRoles)
-                               throws RejectedExecutionException {
+      final Set newlyAcquiredRoles) throws RejectedExecutionException {
-      public void run()
-      {
+      public void run() {
-              RegionEventImpl event = new RegionEventImpl(
-                  DistributedRegion.this, Operation.REGION_REINITIALIZE, null,
-                  false, getMyId(), generateEventID());
+              RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
+                  Operation.REGION_REINITIALIZE, null, false, getMyId(), generateEventID());
-                RoleEventImpl relEvent = new RoleEventImpl(
-                    DistributedRegion.this, Operation.REGION_CREATE, null,
-                    true, id, newlyAcquiredRoles);
-                dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_GAIN,
-                    relEvent);
+                RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
+                    Operation.REGION_CREATE, null, true, id, newlyAcquiredRoles);
+                dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_GAIN, relEvent);
-        }
-        catch (Exception e) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+        } catch (Exception e) {
+          logger.fatal(
+              LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
-  private void resumeExpiration()
-  {
+  private void resumeExpiration() {
-    boolean isLimitedAccess = getMembershipAttributes().getLossAction()
-        .isLimitedAccess();
+    boolean isLimitedAccess = getMembershipAttributes().getLossAction().isLimitedAccess();
-        && (isNoAccess || (isLimitedAccess && getEntryTimeToLive().getAction()
-            .isDistributed()))) {
+        && (isNoAccess || (isLimitedAccess && getEntryTimeToLive().getAction().isDistributed()))) {
-    }
-    else 
-    if (getEntryIdleTimeout().getTimeout() > 0
-        && (isNoAccess || (isLimitedAccess && getEntryIdleTimeout().getAction()
-            .isDistributed()))) {
+    } else if (getEntryIdleTimeout().getTimeout() > 0
+        && (isNoAccess || (isLimitedAccess && getEntryIdleTimeout().getAction().isDistributed()))) {
-    }
-    else
-    if (getCustomEntryTimeToLive() != null || getCustomEntryIdleTimeout() != null) {
+    } else if (getCustomEntryTimeToLive() != null || getCustomEntryIdleTimeout() != null) {
-        && (isNoAccess || (isLimitedAccess && getRegionTimeToLive().getAction()
-            .isDistributed()))) {
+        && (isNoAccess || (isLimitedAccess && getRegionTimeToLive().getAction().isDistributed()))) {
-    if (getRegionIdleTimeout().getTimeout() > 0
-        && (isNoAccess || (isLimitedAccess && getRegionIdleTimeout()
-            .getAction().isDistributed()))) {
+    if (getRegionIdleTimeout().getTimeout() > 0 && (isNoAccess
+        || (isLimitedAccess && getRegionIdleTimeout().getAction().isDistributed()))) {
-   * A boolean used to indicate if its the intialization time i.e the
-   * distributed Region is created for the first time. The variable is used at
-   * the time of lost reliablility.
+   * A boolean used to indicate if its the intialization time i.e the distributed Region is created
+   * for the first time. The variable is used at the time of lost reliablility.
-   * Called when reliability is lost. If MembershipAttributes are configured
-   * with {@link LossAction#RECONNECT}then DistributedSystem reconnect will be
-   * called asynchronously.
+   * Called when reliability is lost. If MembershipAttributes are configured with
+   * {@link LossAction#RECONNECT}then DistributedSystem reconnect will be called asynchronously.
-      final Set newlyMissingRoles)
-  {
+      final Set newlyMissingRoles) {
-        }
-        else {
+        } else {
-         * Thread("Reconnect Distributed System") { public void run() { try { //
-         * TODO: may need to check isReconnecting and checkReadiness...
-         * initializationLatchAfterMemberTimeout.await(); // TODO:
-         * call reconnect here
-         * getSystem().tryReconnect((GemFireCache)getCache()); // added for
-         * reconnect. synchronized (missingRequiredRoles) { // any number of
-         * threads may be waiting on missingRequiredRoles
-         * missingRequiredRoles.notifyAll(); // need to fire an event if id is
-         * not null if (hasListener() && id != null) { RoleEventImpl relEvent =
-         * new RoleEventImpl( DistributedRegion.this, Operation.CACHE_RECONNECT,
-         * null, true, id, newlyMissingRoles); dispatchListenerEvent(
-         * EnumListenerEvent.AFTER_ROLE_LOSS, relEvent); } } } catch (Exception
-         * e) { } } };
-         * t.setDaemon(true); t.start();
+         * Thread("Reconnect Distributed System") { public void run() { try { // TODO: may need to
+         * check isReconnecting and checkReadiness... initializationLatchAfterMemberTimeout.await();
+         * // TODO: call reconnect here getSystem().tryReconnect((GemFireCache)getCache()); // added
+         * for reconnect. synchronized (missingRequiredRoles) { // any number of threads may be
+         * waiting on missingRequiredRoles missingRequiredRoles.notifyAll(); // need to fire an
+         * event if id is not null if (hasListener() && id != null) { RoleEventImpl relEvent = new
+         * RoleEventImpl( DistributedRegion.this, Operation.CACHE_RECONNECT, null, true, id,
+         * newlyMissingRoles); dispatchListenerEvent( EnumListenerEvent.AFTER_ROLE_LOSS, relEvent);
+         * } } } catch (Exception e) { } } }; t.setDaemon(true); t.start();
-    }
-    catch (CancelException cce) {
+    } catch (CancelException cce) {
-    }
-    catch (Exception e) {
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+    } catch (Exception e) {
+      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+          e);
-  private void doLostReliability(boolean isInitializing,
-      final InternalDistributedMember id, final Set newlyMissingRoles)
-  {
+  private void doLostReliability(boolean isInitializing, final InternalDistributedMember id,
+      final Set newlyMissingRoles) {
-        Thread t = new Thread(LocalizedStrings.DistributedRegion_RECONNECT_DISTRIBUTED_SYSTEM.toLocalizedString()) {
+        Thread t = new Thread(
+            LocalizedStrings.DistributedRegion_RECONNECT_DISTRIBUTED_SYSTEM.toLocalizedString()) {
-          public void run()
-          {
+          public void run() {
-              logger.debug("Reliability loss with policy of reconnect and membership thread doing reconnect");
+              logger.debug(
+                  "Reliability loss with policy of reconnect and membership thread doing reconnect");
-                  RoleEventImpl relEvent = new RoleEventImpl(
-                      DistributedRegion.this, Operation.CACHE_RECONNECT, null,
-                      true, id, newlyMissingRoles);
-                  dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_LOSS,
-                      relEvent);
+                  RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
+                      Operation.CACHE_RECONNECT, null, true, id, newlyMissingRoles);
+                  dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_LOSS, relEvent);
-            }
-            catch (Exception e) {
-              logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+            } catch (Exception e) {
+              logger.fatal(
+                  LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+                  e);
-      }
-      else {
+      } else {
-    }
-    catch (CancelException ignor) {
+    } catch (CancelException ignor) {
-    }
-    catch (Exception e) {
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+    } catch (Exception e) {
+      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+          e);
-  protected void lockCheckReadiness()
-  {
+  protected void lockCheckReadiness() {
-  public void localDestroyNoCallbacks(Object key)
-  {
+  public void localDestroyNoCallbacks(Object key) {
-      }
-      catch (LockServiceDestroyedException ignore) {
+      } catch (LockServiceDestroyedException ignore) {
-  public void localDestroy(Object key, Object aCallbackArgument)
-      throws EntryNotFoundException
-  {
+  public void localDestroy(Object key, Object aCallbackArgument) throws EntryNotFoundException {
-      }
-      catch (LockServiceDestroyedException ignore) {
+      } catch (LockServiceDestroyedException ignore) {
-      throws TimeoutException, EntryNotFoundException
-  {
+      throws TimeoutException, EntryNotFoundException {
-    }
-    finally {
+    } finally {
-  public Lock getRegionDistributedLock() throws IllegalStateException
-  {
+  public Lock getRegionDistributedLock() throws IllegalStateException {
-      throw new IllegalStateException(LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0.toLocalizedString(this.scope));
+      throw new IllegalStateException(
+          LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0
+              .toLocalizedString(this.scope));
-  public Lock getDistributedLock(Object key) throws IllegalStateException
-  {
+  public Lock getDistributedLock(Object key) throws IllegalStateException {
-      throw new IllegalStateException(LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0.toLocalizedString(this.scope));
+      throw new IllegalStateException(
+          LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0
+              .toLocalizedString(this.scope));
-      throw new IllegalStateException(LocalizedStrings.DistributedRegion_THIS_THREAD_HAS_SUSPENDED_ALL_LOCKING_FOR_THIS_REGION.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.DistributedRegion_THIS_THREAD_HAS_SUSPENDED_ALL_LOCKING_FOR_THIS_REGION
+              .toLocalizedString());
-   * @throws IllegalStateException
-   *           if region is not compatible with a region in another VM.
+   * @throws IllegalStateException if region is not compatible with a region in another VM.
-  protected void initialize(InputStream snapshotInputStream,
-      InternalDistributedMember imageTarget, InternalRegionArguments internalRegionArgs) throws TimeoutException,
-      IOException, ClassNotFoundException
-  {
+  protected void initialize(InputStream snapshotInputStream, InternalDistributedMember imageTarget,
+      InternalRegionArguments internalRegionArgs)
+      throws TimeoutException, IOException, ClassNotFoundException {
-     try {
+    try {
-        
+
- 
-        if (getDataPolicy().withReplication()
-            || getDataPolicy().withPreloaded()) {
-          getInitialImageAndRecovery(snapshotInputStream, imageTarget,
-              internalRegionArgs, recoverFromDisk, persistentId);
-        }
-        else {
+
+        if (getDataPolicy().withReplication() || getDataPolicy().withPreloaded()) {
+          getInitialImageAndRecovery(snapshotInputStream, imageTarget, internalRegionArgs,
+              recoverFromDisk, persistentId);
+        } else {
-      }
-      catch (DiskAccessException dae) {
+      } catch (DiskAccessException dae) {
-      super.initialize(null, null, null); // makes sure all latches are released if they haven't been already
-     } finally {
+      super.initialize(null, null, null); // makes sure all latches are released if they haven't
+                                          // been already
+    } finally {
-     }
+    }
-    new CopyOnWriteArraySet<DistributedMember>();
+      new CopyOnWriteArraySet<DistributedMember>();
-  private boolean checkInitialImageForReliability(
-      InternalDistributedMember imageTarget,
-      CacheDistributionAdvisor.InitialImageAdvice advice)
-  {
+  private boolean checkInitialImageForReliability(InternalDistributedMember imageTarget,
+      CacheDistributionAdvisor.InitialImageAdvice advice) {
-//    if (true)
-      return false;
-//    if (getMembershipAttributes().hasRequiredRoles()
-//        && getMembershipAttributes().getResumptionAction().isReinitialize()) {
-//      // are any required roles missing for GII with Reinitialize?
-//      Set missingRR = new HashSet(getMembershipAttributes().getRequiredRoles());
-//      missingRR.removeAll(getSystem().getDistributedMember().getRoles());
-//      for (Iterator iter = advice.replicates.iterator(); iter.hasNext();) {
-//        DistributedMember member = (DistributedMember)iter.next();
-//        missingRR.removeAll(member.getRoles());
-//      }
-//      for (Iterator iter = advice.others.iterator(); iter.hasNext();) {
-//        DistributedMember member = (DistributedMember)iter.next();
-//        missingRR.removeAll(member.getRoles());
-//      }
-//      for (Iterator iter = advice.preloaded.iterator(); iter.hasNext();) {
-//        DistributedMember member = (DistributedMember)iter.next();
-//        missingRR.removeAll(member.getRoles());
-//      }
-//      if (!missingRR.isEmpty()) {
-//        // entering immediate loss condition, which will cause reinit on resume
-//        this.giiMissingRequiredRoles = true;
-//      }
-//    }
-//    return this.giiMissingRequiredRoles;
+    // if (true)
+    return false;
+    // if (getMembershipAttributes().hasRequiredRoles()
+    // && getMembershipAttributes().getResumptionAction().isReinitialize()) {
+    // // are any required roles missing for GII with Reinitialize?
+    // Set missingRR = new HashSet(getMembershipAttributes().getRequiredRoles());
+    // missingRR.removeAll(getSystem().getDistributedMember().getRoles());
+    // for (Iterator iter = advice.replicates.iterator(); iter.hasNext();) {
+    // DistributedMember member = (DistributedMember)iter.next();
+    // missingRR.removeAll(member.getRoles());
+    // }
+    // for (Iterator iter = advice.others.iterator(); iter.hasNext();) {
+    // DistributedMember member = (DistributedMember)iter.next();
+    // missingRR.removeAll(member.getRoles());
+    // }
+    // for (Iterator iter = advice.preloaded.iterator(); iter.hasNext();) {
+    // DistributedMember member = (DistributedMember)iter.next();
+    // missingRR.removeAll(member.getRoles());
+    // }
+    // if (!missingRR.isEmpty()) {
+    // // entering immediate loss condition, which will cause reinit on resume
+    // this.giiMissingRequiredRoles = true;
+    // }
+    // }
+    // return this.giiMissingRequiredRoles;
-      boolean recoverFromDisk, PersistentMemberID persistentId) throws TimeoutException
-  {
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZING_REGION_0, this.getName()));
-  
+      boolean recoverFromDisk, PersistentMemberID persistentId) throws TimeoutException {
+    logger.info(LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZING_REGION_0,
+        this.getName()));
+
-    Boolean isCBool = (Boolean)isConversion.get();
-    boolean isForConversion = isCBool!=null?isCBool.booleanValue():false;
+    Boolean isCBool = (Boolean) isConversion.get();
+    boolean isForConversion = isCBool != null ? isCBool.booleanValue() : false;
-      throw new InternalGemFireError(LocalizedStrings.DistributedRegion_IF_LOADING_A_SNAPSHOT_THEN_SHOULD_NOT_BE_RECOVERING_ISRECOVERING_0_SNAPSHOTSTREAM_1.toLocalizedString(new Object[] {Boolean.valueOf(recoverFromDisk), snapshotInputStream}));
+      throw new InternalGemFireError(
+          LocalizedStrings.DistributedRegion_IF_LOADING_A_SNAPSHOT_THEN_SHOULD_NOT_BE_RECOVERING_ISRECOVERING_0_SNAPSHOTSTREAM_1
+              .toLocalizedString(
+                  new Object[] {Boolean.valueOf(recoverFromDisk), snapshotInputStream}));
-      targetProvider = new CreatePersistentRegionProcessor(this,
-          getPersistenceAdvisor(), recoverFromDisk);
-    }
-    else {
+      targetProvider =
+          new CreatePersistentRegionProcessor(this, getPersistenceAdvisor(), recoverFromDisk);
+    } else {
-      recovered_rvv = (this.getVersionVector()==null?null:this.getVersionVector().getCloneForTransmission());
+      recovered_rvv = (this.getVersionVector() == null ? null
+          : this.getVersionVector().getCloneForTransmission());
-      // initializeRegion will send out our profile
+    // initializeRegion will send out our profile
-    
-    if(persistenceAdvisor != null) {
+
+    if (persistenceAdvisor != null) {
-    
+
-    
+
-    // allow GII to invoke test hooks.  Do this just after releasing the
-    // before-gii latch for bug #48962.  See ConcurrentLeaveDuringGIIDUnitTest
+    // allow GII to invoke test hooks. Do this just after releasing the
+    // before-gii latch for bug #48962. See ConcurrentLeaveDuringGIIDUnitTest
-    
+
-          logger.debug("DistributedRegion.getInitialImageAndRecovery: About to load snapshot, isInitialized={}; {}",
+          logger.debug(
+              "DistributedRegion.getInitialImageAndRecovery: About to load snapshot, isInitialized={}; {}",
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-      }
-      catch (ClassNotFoundException e) {
+      } catch (ClassNotFoundException e) {
-    
+
-    //        consistency before the gii operation begins
-    //      if (isUsedForPartitionedRegionAdmin() ||
+    // consistency before the gii operation begins
+    // if (isUsedForPartitionedRegionAdmin() ||
-    //        releaseBeforeGetInitialImageLatch();
-    //        iiop.getFromAll(this.distAdvisor.adviseGeneric(), false);
-    //        cleanUpDestroyedTokens();
-    //        return;
-    //      }
+    // releaseBeforeGetInitialImageLatch();
+    // iiop.getFromAll(this.distAdvisor.adviseGeneric(), false);
+    // cleanUpDestroyedTokens();
+    // return;
+    // }
-    while(!done && !isDestroyed()) {
+    while (!done && !isDestroyed()) {
-      boolean attemptGetFromOne = 
-        imageSrc != null // we were given a specific member
-        || this.dataPolicy.withPreloaded()
-           && !advice.preloaded.isEmpty() // this is a preloaded region
-        || (!advice.replicates.isEmpty());
+      boolean attemptGetFromOne = imageSrc != null // we were given a specific member
+          || this.dataPolicy.withPreloaded() && !advice.preloaded.isEmpty() // this is a preloaded
+                                                                            // region
+          || (!advice.replicates.isEmpty());
-          if (LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER){
+          if (LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER) {
-              GIIStatus ret = iiop.getFromOne(Collections.singleton(imageSrc),
-                  targetRecreated, advice, recoverFromDisk, recovered_rvv);
+              GIIStatus ret = iiop.getFromOne(Collections.singleton(imageSrc), targetRecreated,
+                  advice, recoverFromDisk, recovered_rvv);
-          GIIStatus ret = iiop.getFromOne(advice.replicates, false, advice, recoverFromDisk, recovered_rvv);
+          GIIStatus ret =
+              iiop.getFromOne(advice.replicates, false, advice, recoverFromDisk, recovered_rvv);
-            GIIStatus ret_preload = iiop.getFromOne(advice.preloaded, false, advice, recoverFromDisk, recovered_rvv);
+            GIIStatus ret_preload =
+                iiop.getFromOne(advice.preloaded, false, advice, recoverFromDisk, recovered_rvv);
-        //If we got to this point, we failed in the GII. Cleanup
-        //any partial image we received
+        // If we got to this point, we failed in the GII. Cleanup
+        // any partial image we received
-        if(!isDestroyed()) {
-          if(recoverFromDisk) {
-            logger.info(LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZED_FROM_DISK,
-                new Object[] {this.getFullPath(), persistentId, getPersistentID()}));
-            if(persistentId != null) {
+        if (!isDestroyed()) {
+          if (recoverFromDisk) {
+            logger.info(
+                LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZED_FROM_DISK,
+                    new Object[] {this.getFullPath(), persistentId, getPersistentID()}));
+            if (persistentId != null) {
-            
+
-                  getDistributionManager().getDistributionManagerId(),
-                  getPersistentID());
-              logger.info(LocalizedMessage.create(LocalizedStrings.DistributedRegion_NEW_PERSISTENT_REGION_CREATED,
+                  getDistributionManager().getDistributionManagerId(), getPersistentID());
+              logger.info(LocalizedMessage.create(
+                  LocalizedStrings.DistributedRegion_NEW_PERSISTENT_REGION_CREATED,
-          
-          /* no more union GII
-            // do union getInitialImage
-            Set rest = new HashSet();
-            rest.addAll(advice.others);
-            rest.addAll(advice.preloaded);
-            // push profile w/ recovery flag turned off at same time that we
-            // do a union getInitialImage
-            boolean pushProfile = recoverFromDisk;
-            iiop.getFromAll(rest, pushProfile);
+
+          /*
+           * no more union GII // do union getInitialImage Set rest = new HashSet();
+           * rest.addAll(advice.others); rest.addAll(advice.preloaded); // push profile w/ recovery
+           * flag turned off at same time that we // do a union getInitialImage boolean pushProfile
+           * = recoverFromDisk; iiop.getFromAll(rest, pushProfile);
-  
-  private void synchronizeWith(InternalDistributedMember target, 
-      VersionSource idToRecover) {
+
+  private void synchronizeWith(InternalDistributedMember target, VersionSource idToRecover) {
-  
+
-   * If this region has concurrency controls enabled this will pull any missing
-   * changes from other replicates using InitialImageOperation and a filtered
-   * chunking protocol.
+   * If this region has concurrency controls enabled this will pull any missing changes from other
+   * replicates using InitialImageOperation and a filtered chunking protocol.
-  public void synchronizeForLostMember(InternalDistributedMember
-      lostMember, VersionSource lostVersionID) {
+  public void synchronizeForLostMember(InternalDistributedMember lostMember,
+      VersionSource lostVersionID) {
-    for (InternalDistributedMember target: targets) {
+    for (InternalDistributedMember target : targets) {
-  
+
-   * synchronize with another member wrt messages from the given "lost" member.
-   * This can be used when a primary bucket crashes to ensure that interrupted
-   * message distribution is mended.
+   * synchronize with another member wrt messages from the given "lost" member. This can be used
+   * when a primary bucket crashes to ensure that interrupted message distribution is mended.
-  private void synchronizeWith(InternalDistributedMember target,
-      VersionSource versionMember, InternalDistributedMember lostMember) {
+  private void synchronizeWith(InternalDistributedMember target, VersionSource versionMember,
+      InternalDistributedMember lostMember) {
-    //if we have a persistent region, instead of deleting everything on disk,
-    //we will just reset the "recovered from disk" flag. After
-    //the next GII we will delete these entries if they do not come
-    //in as part of the GII.
+    // if we have a persistent region, instead of deleting everything on disk,
+    // we will just reset the "recovered from disk" flag. After
+    // the next GII we will delete these entries if they do not come
+    // in as part of the GII.
-        } catch (Exception ex){
+        } catch (Exception ex) {
-  private void initMembershipRoles()
-  {
+  private void initMembershipRoles() {
-      Set others = this.distAdvisor
-          .addMembershipListenerAndAdviseGeneric(this.advisorListener);
+      Set others = this.distAdvisor.addMembershipListenerAndAdviseGeneric(this.advisorListener);
-          this.missingRequiredRoles.addAll(getMembershipAttributes()
-              .getRequiredRoles());
+          this.missingRequiredRoles.addAll(getMembershipAttributes().getRequiredRoles());
-          this.missingRequiredRoles.removeAll(getSystem()
-              .getDistributedMember().getRoles());
+          this.missingRequiredRoles.removeAll(getSystem().getDistributedMember().getRoles());
-            DistributedMember other = (DistributedMember)iter.next();
+            DistributedMember other = (DistributedMember) iter.next();
-//      boolean requiredRolesAreMissing = false;
+      // boolean requiredRolesAreMissing = false;
-              else if (getMembershipAttributes().getLossAction()
-                  .isLimitedAccess())
+              else if (getMembershipAttributes().getLossAction().isLimitedAccess())
-                else if (getMembershipAttributes().getLossAction()
-                    .isLimitedAccess())
-                  getCachePerfStats()
-                      .incReliableRegionsMissingLimitedAccess(-1);
+                else if (getMembershipAttributes().getLossAction().isLimitedAccess())
+                  getCachePerfStats().incReliableRegionsMissingLimitedAccess(-1);
-        }
-        else {
+        } else {
-              }
-              else {
+              } else {
-                else if (getMembershipAttributes().getLossAction()
-                    .isLimitedAccess())
+                else if (getMembershipAttributes().getLossAction().isLimitedAccess())
-                
+
-                  logger.debug("Initialization completed with missing required roles: {}", this.missingRequiredRoles);
+                  logger.debug("Initialization completed with missing required roles: {}",
+                      this.missingRequiredRoles);
-      }
-      catch (RegionDestroyedException ignore) {
+      } catch (RegionDestroyedException ignore) {
-      }
-      catch (CancelException ignore) {
+      } catch (CancelException ignore) {
-      }
-      catch (Exception e) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+      } catch (Exception e) {
+        logger.fatal(
+            LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+
-    return getDataPolicy().withPersistence()
-      && getDiskRegion().isRecreated();
+    return getDataPolicy().withPersistence() && getDiskRegion().isRecreated();
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="UL_UNRELEASED_LOCK")
-  protected void cleanUpDestroyedTokensAndMarkGIIComplete(GIIStatus giiStatus)
-  {
-    //We need to clean up the disk before we release the after get initial image latch
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "UL_UNRELEASED_LOCK")
+  protected void cleanUpDestroyedTokensAndMarkGIIComplete(GIIStatus giiStatus) {
+    // We need to clean up the disk before we release the after get initial image latch
-      Iterator/*<Object>*/ keysIt = getImageState().getDestroyedEntries();
+      Iterator/* <Object> */ keysIt = getImageState().getDestroyedEntries();
-      //need to do this before we release the afterGetInitialImageLatch
-      if(persistenceAdvisor != null) {
+      // need to do this before we release the afterGetInitialImageLatch
+      if (persistenceAdvisor != null) {
-    }
-    finally {
+    } finally {
-        try {
-          releaseAfterGetInitialImageLatch();
-        } finally { // make sure unlockGII is done for bug 40001
-          is.unlockGII();
-        }
+      try {
+        releaseAfterGetInitialImageLatch();
+      } finally { // make sure unlockGII is done for bug 40001
+        is.unlockGII();
+      }
-    
-    if (LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER){
+
+    if (LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER) {
-    
-    //"Initializing region {0}" which is not acompanied by a completed message. Users think thread is stuck in some operation. Hence adding this log
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZING_REGION_COMPLETED_0, this.getName()));
+
+    // "Initializing region {0}" which is not acompanied by a completed message. Users think thread
+    // is stuck in some operation. Hence adding this log
+    logger.info(LocalizedMessage.create(
+        LocalizedStrings.DistributedRegion_INITIALIZING_REGION_COMPLETED_0, this.getName()));
-  protected
-  void basicDestroy(EntryEventImpl event,
-                       boolean cacheWrite,
-                       Object expectedOldValue)
-  throws EntryNotFoundException, CacheWriterException, TimeoutException {
-    //  disallow local destruction for mirrored keysvalues regions
+  protected void basicDestroy(EntryEventImpl event, boolean cacheWrite, Object expectedOldValue)
+      throws EntryNotFoundException, CacheWriterException, TimeoutException {
+    // disallow local destruction for mirrored keysvalues regions
-    
+
-        if (re == null /*|| re.isTombstone()*/ || !this.generateVersionTag) {
+        if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
-            // removeAll will send a single one-hop for empty regions.  for other missing entries
-            // we need to get a valid version number before modifying the local cache 
-          // TODO: deltaGII: verify that delegating to a peer when this region is also a client is acceptable
-          boolean didDistribute = RemoteDestroyMessage.distribute(event, expectedOldValue, !this.generateVersionTag);
+            // removeAll will send a single one-hop for empty regions. for other missing entries
+            // we need to get a valid version number before modifying the local cache
+            // TODO: deltaGII: verify that delegating to a peer when this region is also a client is
+            // acceptable
+            boolean didDistribute =
+                RemoteDestroyMessage.distribute(event, expectedOldValue, !this.generateVersionTag);
-          if (!this.generateVersionTag && !didDistribute) {
-            throw new PersistentReplicatesOfflineException();
-          }
-          
-          if (didDistribute) {
-            if (logger.isTraceEnabled()) {
-              logger.trace("Event after remoteDestroy operation: {}", event);
+            if (!this.generateVersionTag && !didDistribute) {
+              throw new PersistentReplicatesOfflineException();
-            invokeWriter = false; // remote cache invoked the writer
-            if (event.getVersionTag() == null) {
-              // if the event wasn't applied by the one-hop replicate it will not have a version tag
-              // and so should not be applied to this cache
-              return;
+
+            if (didDistribute) {
+              if (logger.isTraceEnabled()) {
+                logger.trace("Event after remoteDestroy operation: {}", event);
+              }
+              invokeWriter = false; // remote cache invoked the writer
+              if (event.getVersionTag() == null) {
+                // if the event wasn't applied by the one-hop replicate it will not have a version
+                // tag
+                // and so should not be applied to this cache
+                return;
+              }
-          }
-      
+
-        }
-        catch (LockServiceDestroyedException ignore) {
+        } catch (LockServiceDestroyedException ignore) {
-  
+
-    } 
-    finally {
+    } finally {
-          event.invokeCallbacks(this,true, false);
+          event.invokeCallbacks(this, true, false);
-  void basicDestroyPart3(RegionEntry re, EntryEventImpl event,
-      boolean inTokenMode, boolean duringRI, boolean invokeCallbacks, Object expectedOldValue) {
-  
+  void basicDestroyPart3(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+      boolean duringRI, boolean invokeCallbacks, Object expectedOldValue) {
+
-  
+
-        DestroyOperation op =  new DestroyOperation(event);
+        DestroyOperation op = new DestroyOperation(event);
-  
+
-        }
-        catch (LockServiceDestroyedException ignore) {
+        } catch (LockServiceDestroyedException ignore) {
-  void basicInvalidateRegion(RegionEventImpl event)
-  {
+  void basicInvalidateRegion(RegionEventImpl event) {
-    if (!event.isDistributed() && getScope().isDistributed()
-        && getDataPolicy().withReplication()) {
-      throw new IllegalStateException(LocalizedStrings.DistributedRegion_NOT_ALLOWED_TO_DO_A_LOCAL_INVALIDATION_ON_A_REPLICATED_REGION.toLocalizedString());
+    if (!event.isDistributed() && getScope().isDistributed() && getDataPolicy().withReplication()) {
+      throw new IllegalStateException(
+          LocalizedStrings.DistributedRegion_NOT_ALLOWED_TO_DO_A_LOCAL_INVALIDATION_ON_A_REPLICATED_REGION
+              .toLocalizedString());
-   * decide if InvalidateRegionOperation should be sent to peers. broken out so
-   * that BucketRegion can override
+   * decide if InvalidateRegionOperation should be sent to peers. broken out so that BucketRegion
+   * can override
+   * 
-   * Distribute the invalidate of a region given its event.
-   * This implementation sends the invalidate to peers.
+   * Distribute the invalidate of a region given its event. This implementation sends the invalidate
+   * to peers.
+   * 
-   * @see LocalRegion#basicDestroyRegion(RegionEventImpl, boolean, boolean,
-   *      boolean)
+   * @see LocalRegion#basicDestroyRegion(RegionEventImpl, boolean, boolean, boolean)
-  void basicDestroyRegion(RegionEventImpl event, boolean cacheWrite,
-      boolean lock, boolean callbackEvents) throws CacheWriterException,
-      TimeoutException
-  {
+  void basicDestroyRegion(RegionEventImpl event, boolean cacheWrite, boolean lock,
+      boolean callbackEvents) throws CacheWriterException, TimeoutException {
-    //Keep track of regions that are being destroyed. This helps avoid a race
-    //when another member concurrently creates this region. See bug 42051.
+    // Keep track of regions that are being destroyed. This helps avoid a race
+    // when another member concurrently creates this region. See bug 42051.
-    if(!isClose) {
+    if (!isClose) {
-        if(!event.isReinitializing()) {
-          RegionEventImpl localEvent = new RegionEventImpl(this,
-              Operation.REGION_LOCAL_DESTROY, event.getCallbackArgument(), false, getMyId(),
-              generateEventID()/* generate EventID */);
-          distributeDestroyRegion(localEvent, false/*fixes bug 41111*/);
+        if (!event.isReinitializing()) {
+          RegionEventImpl localEvent =
+              new RegionEventImpl(this, Operation.REGION_LOCAL_DESTROY, event.getCallbackArgument(),
+                  false, getMyId(), generateEventID()/* generate EventID */);
+          distributeDestroyRegion(localEvent, false/* fixes bug 41111 */);
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    }
-    finally {
-      if(!isClose) {
+    } finally {
+      if (!isClose) {
- }
+  }
-  protected void distributeDestroyRegion(RegionEventImpl event,
-                                         boolean notifyOfRegionDeparture) {
-    if(persistenceAdvisor != null) {
+  protected void distributeDestroyRegion(RegionEventImpl event, boolean notifyOfRegionDeparture) {
+    if (persistenceAdvisor != null) {
-   * Return true if invalidation occurred; false if it did not, for example if
-   * it was already invalidated
+   * Return true if invalidation occurred; false if it did not, for example if it was already
+   * invalidated
-  void basicInvalidate(EntryEventImpl event) throws EntryNotFoundException
-  {
-    
+  void basicInvalidate(EntryEventImpl event) throws EntryNotFoundException {
+
-        throw new IllegalStateException(LocalizedStrings.DistributedRegion_NOT_ALLOWED_TO_DO_A_LOCAL_INVALIDATION_ON_A_REPLICATED_REGION.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.DistributedRegion_NOT_ALLOWED_TO_DO_A_LOCAL_INVALIDATION_ON_A_REPLICATED_REGION
+                .toLocalizedString());
-        if (re == null/* || re.isTombstone()*/ || !this.generateVersionTag) {
+        if (re == null/* || re.isTombstone() */ || !this.generateVersionTag) {
-          // TODO: deltaGII: verify that delegating to a peer when this region is also a client is acceptable
-          boolean didDistribute = RemoteInvalidateMessage.distribute(event, !this.generateVersionTag);
+          // TODO: deltaGII: verify that delegating to a peer when this region is also a client is
+          // acceptable
+          boolean didDistribute =
+              RemoteInvalidateMessage.distribute(event, !this.generateVersionTag);
-  
+
-    	if (!getConcurrencyChecksEnabled() || event.hasValidVersionTag()) {
+        if (!getConcurrencyChecksEnabled() || event.hasValidVersionTag()) {
-          event.invokeCallbacks(this,true, false);
-    	}
+          event.invokeCallbacks(this, true, false);
+        }
-  void basicInvalidatePart3(RegionEntry re, EntryEventImpl event,
-      boolean invokeCallbacks) {
+  void basicInvalidatePart3(RegionEntry re, EntryEventImpl event, boolean invokeCallbacks) {
-  
+
-  void basicUpdateEntryVersion(EntryEventImpl event)
-      throws EntryNotFoundException {
+  void basicUpdateEntryVersion(EntryEventImpl event) throws EntryNotFoundException {
-  protected void basicClear(RegionEventImpl ev)
-  {
+  protected void basicClear(RegionEventImpl ev) {
-    }
-    finally {
+    } finally {
-  
+
-  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite)  {
+  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite) {
-  
-  
+
+
-    boolean enableRVV = useRVV && this.dataPolicy.withReplication() && this.concurrencyChecksEnabled && !getDistributionManager().isLoner(); 
-    
-    //Fix for 46338 - apparently multiple threads from the same VM are allowed
-    //to suspend locking, which is what distributedLockForClear() does. We don't
-    //want that to happen, so we'll synchronize to make sure only one thread on
-    //this member performs a clear.
-    synchronized(clearLock) {
+    boolean enableRVV = useRVV && this.dataPolicy.withReplication() && this.concurrencyChecksEnabled
+        && !getDistributionManager().isLoner();
+
+    // Fix for 46338 - apparently multiple threads from the same VM are allowed
+    // to suspend locking, which is what distributedLockForClear() does. We don't
+    // want that to happen, so we'll synchronize to make sure only one thread on
+    // this member performs a clear.
+    synchronized (clearLock) {
-          Set<InternalDistributedMember> participants = getCacheDistributionAdvisor().adviseInvalidateRegion();
+          Set<InternalDistributedMember> participants =
+              getCacheDistributionAdvisor().adviseInvalidateRegion();
-        }
-        finally {
+        } finally {
-        Set<InternalDistributedMember> participants = getCacheDistributionAdvisor().adviseInvalidateRegion();
+        Set<InternalDistributedMember> participants =
+            getCacheDistributionAdvisor().adviseInvalidateRegion();
-    
+
-    if (!this.scope.isGlobal()) {  // non-global regions must lock when using RVV
+    if (!this.scope.isGlobal()) { // non-global regions must lock when using RVV
-      } catch(IllegalStateException e) {
+      } catch (IllegalStateException e) {
-  
+
-      } catch(IllegalStateException e) {
+      } catch (IllegalStateException e) {
-  /** obtain locks preventing generation of new versions in other members 
-   * @param participants 
+  /**
+   * obtain locks preventing generation of new versions in other members
+   * 
+   * @param participants
-  private void obtainWriteLocksForClear(RegionEventImpl regionEvent, Set<InternalDistributedMember> participants) {
+  private void obtainWriteLocksForClear(RegionEventImpl regionEvent,
+      Set<InternalDistributedMember> participants) {
-  
-  /** pause local operations so that a clear() can be performed and flush comm channels to the given member
-  */
+
+  /**
+   * pause local operations so that a clear() can be performed and flush comm channels to the given
+   * member
+   */
-    
+
-    if(alth!=null) alth.beforeLock(this, event);
-    
+    if (alth != null)
+      alth.beforeLock(this, event);
+
-      //Check for region destroyed after we have locked, to make sure
-      //we don't continue a clear if the region has been destroyed.
+      // Check for region destroyed after we have locked, to make sure
+      // we don't continue a clear if the region has been destroyed.
-      }      
+      }
-    
-    if(alth!=null) alth.afterLock(this, null);
+
+    if (alth != null)
+      alth.afterLock(this, null);
-  /** releases the locks obtained in obtainWriteLocksForClear 
-   * @param participants */
-  private void releaseWriteLocksForClear(RegionEventImpl regionEvent, Set<InternalDistributedMember> participants) {
-    
+  /**
+   * releases the locks obtained in obtainWriteLocksForClear
+   * 
+   * @param participants
+   */
+  private void releaseWriteLocksForClear(RegionEventImpl regionEvent,
+      Set<InternalDistributedMember> participants) {
+
-    if(alth!=null) alth.beforeRelease(this, regionEvent);
-    
+    if (alth != null)
+      alth.beforeRelease(this, regionEvent);
+
-    
-    if(alth!=null) alth.afterRelease(this, regionEvent);
+
+    if (alth != null)
+      alth.afterRelease(this, regionEvent);
-  
+
-      synchronized(clearLock) {
-        //do nothing;
-        //DAN - I'm a little scared that the compiler might optimize
-        //away this synchronization if we really do nothing. Hence
-        //my fine log message below. This might not be necessary.
+      synchronized (clearLock) {
+        // do nothing;
+        // DAN - I'm a little scared that the compiler might optimize
+        // away this synchronization if we really do nothing. Hence
+        // my fine log message below. This might not be necessary.
-    
+
-  
+
-    EventID eventId = new EventID(getSystem()); 
+    EventID eventId = new EventID(getSystem());
-    notifyClientsOfTombstoneGC(getVersionVector().getTombstoneGCVector(), keysRemoved, eventId, null);
+    notifyClientsOfTombstoneGC(getVersionVector().getTombstoneGCVector(), keysRemoved, eventId,
+        null);
-  
+
-      throw new UnsupportedOperationException(LocalizedStrings.DistributedRegion_LOCALCLEAR_IS_NOT_SUPPORTED_ON_DISTRIBUTED_REPLICATED_REGIONS.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.DistributedRegion_LOCALCLEAR_IS_NOT_SUPPORTED_ON_DISTRIBUTED_REPLICATED_REGIONS
+              .toLocalizedString());
-  
+
-   * @param list
-   *          List of QueuedOperation instances to send. Any messages sent will
-   *          be removed from this list
-   * @param role
-   *          the role that a recipient must be playing
-   * @return true if at least one message made it to at least one guy playing
-   *         the role
+   * @param list List of QueuedOperation instances to send. Any messages sent will be removed from
+   *        this list
+   * @param role the role that a recipient must be playing
+   * @return true if at least one message made it to at least one guy playing the role
-    SendQueueOperation op = new SendQueueOperation(getDistributionManager(),
-        this, list, role);
+    SendQueueOperation op = new SendQueueOperation(getDistributionManager(), this, list, role);
-  public final CacheDistributionAdvisor getDistributionAdvisor()
-  {
+  public final CacheDistributionAdvisor getDistributionAdvisor() {
-  public final CacheDistributionAdvisor getCacheDistributionAdvisor()
-  {
+  public final CacheDistributionAdvisor getCacheDistributionAdvisor() {
-  
+
-  
+
-    CacheProfile profile = (CacheProfile)p;
+    CacheProfile profile = (CacheProfile) p;
-    }
-    else {
+    } else {
-    if(getPersistenceAdvisor() != null) {
+    if (getPersistenceAdvisor() != null) {
-    profile.hasCacheServer = ((this.cache.getCacheServers().size() > 0)?true:false);
-    profile.requiresOldValueInEvents = this.dataPolicy.withReplication() &&
-       this.filterProfile != null && this.filterProfile.hasCQs();
+    profile.hasCacheServer = ((this.cache.getCacheServers().size() > 0) ? true : false);
+    profile.requiresOldValueInEvents = this.dataPolicy.withReplication()
+        && this.filterProfile != null && this.filterProfile.hasCQs();
-   * Return the DistributedLockService associated with this Region. This method
-   * will lazily create that service the first time it is invoked on this
-   * region.
+   * Return the DistributedLockService associated with this Region. This method will lazily create
+   * that service the first time it is invoked on this region.
-  public DistributedLockService getLockService()
-  {
+  public DistributedLockService getLockService() {
-//      Assert.assertTrue(this.scope.isGlobal());  since 7.0 this is used for distributing clear() ops
+      // Assert.assertTrue(this.scope.isGlobal()); since 7.0 this is used for distributing clear()
+      // ops
-          this.dlockService = DLockService.create(
-              getFullPath(), 
-              getSystem(), 
-              true /*distributed*/, 
-              false /*destroyOnDisconnect*/, // region destroy will destroy dls
-              false /*automateFreeResources*/); // manual freeResources only
+          this.dlockService = DLockService.create(getFullPath(), getSystem(),
+              true /* distributed */, false /* destroyOnDisconnect */, // region destroy will
+                                                                       // destroy dls
+              false /* automateFreeResources */); // manual freeResources only
-          logger.debug("LockService for {} is using LockLease={}, LockTimeout=", svcName, getCache().getLockLease(), getCache().getLockTimeout());
+          logger.debug("LockService for {} is using LockLease={}, LockTimeout=", svcName,
+              getCache().getLockLease(), getCache().getLockTimeout());
-  protected boolean isCurrentlyLockGrantor()
-  {
+  protected boolean isCurrentlyLockGrantor() {
-  public boolean isLockGrantor()
-  {
+  public boolean isLockGrantor() {
-  public void becomeLockGrantor()
-  {
+  public void becomeLockGrantor() {
-      throw new IllegalStateException(LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0.toLocalizedString(this.scope));
+      throw new IllegalStateException(
+          LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0
+              .toLocalizedString(this.scope));
-    }
-    finally {
+    } finally {
-  protected Object findObjectInSystem(KeyInfo keyInfo,
-                                      boolean isCreate,
-                                      TXStateInterface txState,
-                                      boolean generateCallbacks,
-                                      Object localValue,
-                                      boolean disableCopyOnRead,
-                                      boolean preferCD,
-                                      ClientProxyMembershipID requestingClient,
-                                      EntryEventImpl clientEvent,
-                                      boolean returnTombstones)
-      throws CacheLoaderException, TimeoutException
-  {
+  protected Object findObjectInSystem(KeyInfo keyInfo, boolean isCreate, TXStateInterface txState,
+      boolean generateCallbacks, Object localValue, boolean disableCopyOnRead, boolean preferCD,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) throws CacheLoaderException, TimeoutException {
-    final Object aCallbackArgument  = keyInfo.getCallbackArg();
+    final Object aCallbackArgument = keyInfo.getCallbackArg();
-    }
-    else {
+    } else {
-    @Released EntryEventImpl event = null;
-    @Retained Object result = null;
+    @Released
+    EntryEventImpl event = null;
+    @Retained
+    Object result = null;
-    {
-      if (this.srp != null) {
-        VersionTagHolder holder = new VersionTagHolder();
-        Object value = this.srp.get(key, aCallbackArgument, holder);
-        fromServer = value != null;
-        if (fromServer) {
-          event = EntryEventImpl.create(this, op, key, value,
-                                     aCallbackArgument, false,
-                                     getMyId(), generateCallbacks);
-          event.setVersionTag(holder.getVersionTag());
-          event.setFromServer(fromServer); // fix for bug 39358
-          if (clientEvent != null && clientEvent.getVersionTag() == null) {
-            clientEvent.setVersionTag(holder.getVersionTag());
+      {
+        if (this.srp != null) {
+          VersionTagHolder holder = new VersionTagHolder();
+          Object value = this.srp.get(key, aCallbackArgument, holder);
+          fromServer = value != null;
+          if (fromServer) {
+            event = EntryEventImpl.create(this, op, key, value, aCallbackArgument, false, getMyId(),
+                generateCallbacks);
+            event.setVersionTag(holder.getVersionTag());
+            event.setFromServer(fromServer); // fix for bug 39358
+            if (clientEvent != null && clientEvent.getVersionTag() == null) {
+              clientEvent.setVersionTag(holder.getVersionTag());
+            }
-    }
-    
-    if (!fromServer) {
-      //Do not generate Event ID
-      event = EntryEventImpl.create(this, op, key, null /*newValue*/,
-                                 aCallbackArgument, false,
-                                 getMyId(), generateCallbacks);
-      if (requestingClient != null) {
-        event.setContext(requestingClient);
-      }
-      SearchLoadAndWriteProcessor processor =
-        SearchLoadAndWriteProcessor.getProcessor();
-      try {
-        processor.initialize(this, key, aCallbackArgument);
-        // processor fills in event
-        processor.doSearchAndLoad(event, txState, localValue);
-        if (clientEvent != null && clientEvent.getVersionTag() == null) {
-          clientEvent.setVersionTag(event.getVersionTag());
-        }
-        lastModified = processor.getLastModified();
-      }
-      finally {
-        processor.release();
-      }
-    }
-    if (event.hasNewValue() && !isMemoryThresholdReachedForLoad()) {
-      try {
-        // Set eventId. Required for interested clients.
-        event.setNewEventId(cache.getDistributedSystem());
-        long startPut = CachePerfStats.getStatTime();
-        validateKey(key);
-//        if (event.getOperation().isLoad()) {
-//          this.performedLoad(event, lastModified, txState);
-//        }
-        // this next step also distributes the object to other processes, if necessary
+      if (!fromServer) {
+        // Do not generate Event ID
+        event = EntryEventImpl.create(this, op, key, null /* newValue */, aCallbackArgument, false,
+            getMyId(), generateCallbacks);
+        if (requestingClient != null) {
+          event.setContext(requestingClient);
+        }
+        SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();
-          // set the tail key so that the event is passed to GatewaySender queues.
-          // if the tailKey is not set, the event gets filtered out in ParallelGatewaySenderQueue
-          if (this instanceof BucketRegion) {
-          if (((BucketRegion)this).getPartitionedRegion().isParallelWanEnabled())
-          	((BucketRegion)this).handleWANEvent(event);
+          processor.initialize(this, key, aCallbackArgument);
+          // processor fills in event
+          processor.doSearchAndLoad(event, txState, localValue);
+          if (clientEvent != null && clientEvent.getVersionTag() == null) {
+            clientEvent.setVersionTag(event.getVersionTag());
-          re = basicPutEntry(event, lastModified);
-        } catch (ConcurrentCacheModificationException e) {
-          // the cache was modified while we were searching for this entry and
-          // the netsearch result was elided.  Return the current value from the cache
-          re = getRegionEntry(key);
-          if (re != null) {
-            event.setNewValue(re.getValue(this)); // OFFHEAP: need to incrc, copy to heap to setNewValue, decrc
-          }
-        }
-        if (!isTX()) {
-          getCachePerfStats().endPut(startPut, event.isOriginRemote());
+          lastModified = processor.getLastModified();
+        } finally {
+          processor.release();
-      catch (CacheWriterException cwe) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("findObjectInSystem: writer exception putting entry {} : {}", event, cwe);
+      if (event.hasNewValue() && !isMemoryThresholdReachedForLoad()) {
+        try {
+          // Set eventId. Required for interested clients.
+          event.setNewEventId(cache.getDistributedSystem());
+
+          long startPut = CachePerfStats.getStatTime();
+          validateKey(key);
+          // if (event.getOperation().isLoad()) {
+          // this.performedLoad(event, lastModified, txState);
+          // }
+          // this next step also distributes the object to other processes, if necessary
+          try {
+            // set the tail key so that the event is passed to GatewaySender queues.
+            // if the tailKey is not set, the event gets filtered out in ParallelGatewaySenderQueue
+            if (this instanceof BucketRegion) {
+              if (((BucketRegion) this).getPartitionedRegion().isParallelWanEnabled())
+                ((BucketRegion) this).handleWANEvent(event);
+            }
+            re = basicPutEntry(event, lastModified);
+          } catch (ConcurrentCacheModificationException e) {
+            // the cache was modified while we were searching for this entry and
+            // the netsearch result was elided. Return the current value from the cache
+            re = getRegionEntry(key);
+            if (re != null) {
+              event.setNewValue(re.getValue(this)); // OFFHEAP: need to incrc, copy to heap to
+                                                    // setNewValue, decrc
+            }
+          }
+          if (!isTX()) {
+            getCachePerfStats().endPut(startPut, event.isOriginRemote());
+          }
+        } catch (CacheWriterException cwe) {
+          if (logger.isDebugEnabled()) {
+            logger.debug("findObjectInSystem: writer exception putting entry {} : {}", event, cwe);
+          }
-    }
-    if (isCreate) {
-      recordMiss(re, key);
-    }
-    
-    if (preferCD) {
+      if (isCreate) {
+        recordMiss(re, key);
+      }
+
+      if (preferCD) {
-    } else {
-      result = event.getNewValue();     
-    }
-    return result;
+      } else {
+        result = event.getNewValue();
+      }
+      return result;
-        event.release();        
+        event.release();
-  
-  /** hook for subclasses to note that a cache load was performed
+
+  /**
+   * hook for subclasses to note that a cache load was performed
+   * 
-//  void performedLoad(EntryEventImpl event, long lastModifiedTime, TXState txState)
-//    throws CacheWriterException {
-//    // no action in DistributedRegion
-//  }
+  // void performedLoad(EntryEventImpl event, long lastModifiedTime, TXState txState)
+  // throws CacheWriterException {
+  // // no action in DistributedRegion
+  // }
-      throws CacheWriterException, EntryNotFoundException, TimeoutException
-  {
-    
+      throws CacheWriterException, EntryNotFoundException, TimeoutException {
+
-      Set netWriteRecipients = localWriter == null ? this.distAdvisor
-          .adviseNetWrite() : null;
+      Set netWriteRecipients = localWriter == null ? this.distAdvisor.adviseNetWrite() : null;
-      if ((localWriter != null
-          || (netWriteRecipients != null && !netWriteRecipients.isEmpty()))  && 
-          !event.inhibitAllNotifications()) {
+      if ((localWriter != null || (netWriteRecipients != null && !netWriteRecipients.isEmpty()))
+          && !event.inhibitAllNotifications()) {
-          SearchLoadAndWriteProcessor processor =
-            SearchLoadAndWriteProcessor.getProcessor();
+          SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();
-                                 SearchLoadAndWriteProcessor.BEFOREDESTROY);
+                SearchLoadAndWriteProcessor.BEFOREDESTROY);
-          }
-          finally {
+          } finally {
-        }
-        finally {
+        } finally {
-      throws CacheWriterException, TimeoutException
-  {
+      throws CacheWriterException, TimeoutException {
-      Set netWriteRecipients = localWriter == null ? this.distAdvisor
-          .adviseNetWrite() : null;
+      Set netWriteRecipients = localWriter == null ? this.distAdvisor.adviseNetWrite() : null;
-      if (localWriter != null
-          || (netWriteRecipients != null && !netWriteRecipients.isEmpty())) {
+      if (localWriter != null || (netWriteRecipients != null && !netWriteRecipients.isEmpty())) {
-          SearchLoadAndWriteProcessor processor =
-            SearchLoadAndWriteProcessor.getProcessor();
+          SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();
-                                 SearchLoadAndWriteProcessor.BEFOREREGIONDESTROY);
+                SearchLoadAndWriteProcessor.BEFOREREGIONDESTROY);
-          }
-          finally {
+          } finally {
-        }
-        finally {
+        } finally {
-  protected void distributedRegionCleanup(RegionEventImpl event)
-  {
+  protected void distributedRegionCleanup(RegionEventImpl event) {
-    if(persistenceAdvisor != null) {
+    if (persistenceAdvisor != null) {
-    
-    //Fix for bug 46338. Wait for in progress clears before destroying the
-    //lock service, because destroying the service immediately releases the dlock
+
+    // Fix for bug 46338. Wait for in progress clears before destroying the
+    // lock service, because destroying the service immediately releases the dlock
-    
+
-        dls = (DLockService)this.dlockService;
+        dls = (DLockService) this.dlockService;
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (Exception ex) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.DistributedRegion_DLS_DESTROY_MAY_HAVE_FAILED_FOR_0, this.getFullPath()), ex);
+      } catch (Exception ex) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.DistributedRegion_DLS_DESTROY_MAY_HAVE_FAILED_FOR_0,
+            this.getFullPath()), ex);
-    
-    //Fix for #48066 - make sure that region operations are completely
-    //distributed to peers before destroying the region.
+
+    // Fix for #48066 - make sure that region operations are completely
+    // distributed to peers before destroying the region.
-    Boolean flushOnClose = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "no-flush-on-close"); // test hook
-    if (!this.cache.forcedDisconnect() &&
-        flushOnClose && this.getDistributionManager().getMembershipManager() != null
+    Boolean flushOnClose =
+        !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "no-flush-on-close"); // test hook
+    if (!this.cache.forcedDisconnect() && flushOnClose
+        && this.getDistributionManager().getMembershipManager() != null
-            new Object[] { this, getFullPath() }), e);
+            new Object[] {this, getFullPath()}), e);
-   * In addition to inherited code this method also invokes
-   * RegionMembershipListeners
+   * In addition to inherited code this method also invokes RegionMembershipListeners
-  protected void postCreateRegion()
-  {
+  protected void postCreateRegion() {
-            RegionMembershipListener rml = (RegionMembershipListener)listeners[i];
+            RegionMembershipListener rml = (RegionMembershipListener) listeners[i];
-              DistributedMember[] otherDms = new DistributedMember[others
-                  .size()];
+              DistributedMember[] otherDms = new DistributedMember[others.size()];
-            }
-            catch (VirtualMachineError err) {
+            } catch (VirtualMachineError err) {
-              // If this ever returns, rethrow the error.  We're poisoned
+              // If this ever returns, rethrow the error. We're poisoned
-            }
-            catch (Throwable t) {
+            } catch (Throwable t) {
-              // catch VirtualMachineError (see above).  However, there is
+              // catch VirtualMachineError (see above). However, there is
-              logger.error(LocalizedMessage.create(LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER), t);
+              logger.error(
+                  LocalizedMessage.create(
+                      LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER),
+                  t);
-          if (sender.isParallel()
-              && allGatewaySenderIds.contains(sender.getId())) {
-            //Fix for Bug#51491. Once decided to support this configuration we have call addShadowPartitionedRegionForUserRR
-            if (sender.getId().contains(
-                AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {
+          if (sender.isParallel() && allGatewaySenderIds.contains(sender.getId())) {
+            // Fix for Bug#51491. Once decided to support this configuration we have call
+            // addShadowPartitionedRegionForUserRR
+            if (sender.getId().contains(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {
-                  LocalizedStrings.ParallelAsyncEventQueue_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1.toLocalizedString(new Object[] {
-                      AsyncEventQueueImpl
-                          .getAsyncEventQueueIdFromSenderId(sender.getId()),
-                      this.getFullPath() }));
+                  LocalizedStrings.ParallelAsyncEventQueue_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1
+                      .toLocalizedString(new Object[] {
+                          AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),
+                          this.getFullPath()}));
-                    .toLocalizedString(new Object[] { sender.getId(),
-                        this.getFullPath() }));
+                    .toLocalizedString(new Object[] {sender.getId(), this.getFullPath()}));
-   * Free resources held by this region. This method is invoked after
-   * isDestroyed has been set to true.
+   * Free resources held by this region. This method is invoked after isDestroyed has been set to
+   * true.
-  protected void postDestroyRegion(boolean destroyDiskRegion,
-      RegionEventImpl event)
-  {
+  protected void postDestroyRegion(boolean destroyDiskRegion, RegionEventImpl event) {
-    
+
-    }
-    catch (CancelException e) {
-      // I don't think this should ever happens:  bulletproofing for bug 39454
+    } catch (CancelException e) {
+      // I don't think this should ever happens: bulletproofing for bug 39454
-    
+
-  void cleanupFailedInitialization()
-  {
+  void cleanupFailedInitialization() {
-    } catch(RegionDestroyedException e) {
-      //someone else must have concurrently destroyed the region (maybe a distributed destroy)
-    } catch(CancelException e) {
-      //cache or DS is closed, ignore
-    } catch(VirtualMachineError e) {
+    } catch (RegionDestroyedException e) {
+      // someone else must have concurrently destroyed the region (maybe a distributed destroy)
+    } catch (CancelException e) {
+      // cache or DS is closed, ignore
+    } catch (VirtualMachineError e) {
-    } catch(Throwable t) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.DistributedRegion_ERROR_CLEANING_UP_FAILED_INITIALIZATION, this), t);
+    } catch (Throwable t) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.DistributedRegion_ERROR_CLEANING_UP_FAILED_INITIALIZATION, this), t);
-  void handleCacheClose(Operation op)
-  {
+  void handleCacheClose(Operation op) {
-    }
-    finally {
+    } finally {
-      CacheWriter localWriter, 
-      boolean requireOldValue,
-      Object expectedOldValue)
-      throws CacheWriterException, TimeoutException
-  {
-    if ((localWriter != null
-        || (netWriteRecipients != null && !netWriteRecipients.isEmpty())) &&
-        !event.inhibitAllNotifications()) {
+      CacheWriter localWriter, boolean requireOldValue, Object expectedOldValue)
+      throws CacheWriterException, TimeoutException {
+    if ((localWriter != null || (netWriteRecipients != null && !netWriteRecipients.isEmpty()))
+        && !event.inhibitAllNotifications()) {
-        SearchLoadAndWriteProcessor processor =
-          SearchLoadAndWriteProcessor.getProcessor();
+        SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();
-                                 SearchLoadAndWriteProcessor.BEFOREUPDATE);
-          }
-          else {
+                SearchLoadAndWriteProcessor.BEFOREUPDATE);
+          } else {
-                                 SearchLoadAndWriteProcessor.BEFORECREATE);
+                SearchLoadAndWriteProcessor.BEFORECREATE);
-        }
-        finally {
+        } finally {
-      }
-      finally {
+      } finally {
-    
+
-  protected void cacheListenersChanged(boolean nowHasListener)
-  {
+  protected void cacheListenersChanged(boolean nowHasListener) {
-  protected void cacheWriterChanged(CacheWriter oldWriter)
-  {
+  protected void cacheWriterChanged(CacheWriter oldWriter) {
-  protected void cacheLoaderChanged(CacheLoader oldLoader)
-  {
+  protected void cacheLoaderChanged(CacheLoader oldLoader) {
-  
+
-    List senderIds = this.getCacheDistributionAdvisor()
-        .adviseSameGatewaySenderIds(getGatewaySenderIds());
+    List senderIds =
+        this.getCacheDistributionAdvisor().adviseSameGatewaySenderIds(getGatewaySenderIds());
-              .toLocalizedString(new Object[] { this.getName(),
-                  senderIds.get(0), senderIds.get(1) }));
+              .toLocalizedString(
+                  new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
-    List asycnQueueIds = this.getCacheDistributionAdvisor()
-        .adviseSameAsyncEventQueueIds(getAsyncEventQueueIds());
+    List asycnQueueIds =
+        this.getCacheDistributionAdvisor().adviseSameAsyncEventQueueIds(getAsyncEventQueueIds());
-              .toLocalizedString(new Object[] { this.getName(),
-                  asycnQueueIds.get(0), asycnQueueIds.get(1) }));
+              .toLocalizedString(
+                  new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
+
-   * Wraps call to dlock service in order to throw RegionDestroyedException if
-   * dlock service throws IllegalStateException and isDestroyed is true.
+   * Wraps call to dlock service in order to throw RegionDestroyedException if dlock service throws
+   * IllegalStateException and isDestroyed is true.
-  private boolean isLockingSuspendedByCurrentThread()
-  {
+  private boolean isLockingSuspendedByCurrentThread() {
-    }
-    catch (IllegalStateException e) {
+    } catch (IllegalStateException e) {
-   * If this region's scope is GLOBAL, get a distributed lock on the given key,
-   * and return the Lock. The sender is responsible for unlocking.
+   * If this region's scope is GLOBAL, get a distributed lock on the given key, and return the Lock.
+   * The sender is responsible for unlocking.
-   * @throws NullPointerException
-   *           if key is null
+   * @throws NullPointerException if key is null
-  private Lock getDistributedLockIfGlobal(Object key) throws TimeoutException
-  {
+  private Lock getDistributedLockIfGlobal(Object key) throws TimeoutException {
-             msg = LocalizedStrings.DistributedRegion_ATTEMPT_TO_ACQUIRE_DISTRIBUTED_LOCK_FOR_0_FAILED_AFTER_WAITING_1_SECONDS;
-             msgArgs = new Object[] {key, Long.valueOf((System.currentTimeMillis() - start) / 1000L)};
+            msg =
+                LocalizedStrings.DistributedRegion_ATTEMPT_TO_ACQUIRE_DISTRIBUTED_LOCK_FOR_0_FAILED_AFTER_WAITING_1_SECONDS;
+            msgArgs =
+                new Object[] {key, Long.valueOf((System.currentTimeMillis() - start) / 1000L)};
-        }
-        catch (InterruptedException ex) {
+        } catch (InterruptedException ex) {
-            timeLeft = getCache().getLockTimeout()
-                - ((System.currentTimeMillis() - start) / 1000L);
+            timeLeft = getCache().getLockTimeout() - ((System.currentTimeMillis() - start) / 1000L);
-        }
-        finally {
+        } finally {
-        msg = LocalizedStrings.DistributedRegion_TIMED_OUT_AFTER_WAITING_0_SECONDS_FOR_THE_DISTRIBUTED_LOCK_FOR_1;
+        msg =
+            LocalizedStrings.DistributedRegion_TIMED_OUT_AFTER_WAITING_0_SECONDS_FOR_THE_DISTRIBUTED_LOCK_FOR_1;
-    }
-    else {
+    } else {
-   *  
+   * 
-  protected boolean checkEntryNotValid(RegionEntry mapEntry)
-  {
+  protected boolean checkEntryNotValid(RegionEntry mapEntry) {
-   * Get the best iterator for iterating over the contents of this
-   * region. This method will either an iterator that uses hash
-   * ordering from the entry map, or, in the case of an overflow
-   * region, an iterator that iterates over the entries in disk order. 
+   * Get the best iterator for iterating over the contents of this region. This method will either
+   * an iterator that uses hash ordering from the entry map, or, in the case of an overflow region,
+   * an iterator that iterates over the entries in disk order.
-    
+
-      //Wait for the disk region to recover values first.
+      // Wait for the disk region to recover values first.
-      if(dr.getNumOverflowOnDisk() > 0) {
+      if (dr.getNumOverflowOnDisk() > 0) {
-    } 
+    }
-  
-//   /**
-//    * The maximum number of entries that can be put into the diskMap before
-//    * some of them are read from disk and returned by this iterator.
-//    * The larger this number the more memory this iterator is allowed to consume
-//    * and the better it will do in optimally reading the pending entries.
-//    */
-//   static final long MAX_PENDING_ENTRIES = Long.getLong("gemfire.MAX_PENDING_ENTRIES", 1000000).longValue();
+
+  // /**
+  // * The maximum number of entries that can be put into the diskMap before
+  // * some of them are read from disk and returned by this iterator.
+  // * The larger this number the more memory this iterator is allowed to consume
+  // * and the better it will do in optimally reading the pending entries.
+  // */
+  // static final long MAX_PENDING_ENTRIES = Long.getLong("gemfire.MAX_PENDING_ENTRIES",
+  // 1000000).longValue();
-   * Should only be used if this region has entries on disk that are not in memory.
-   * This currently happens for overflow and for recovery when values are not recovered.
-   * The first iteration does a normal iteration of the regionEntries.
-   * But if it finds an entry that is currently only on disk
-   * it saves it in a list sorted by the location on disk.
-   * Once the regionEntries iterator has nothing more to iterate
-   * it starts iterating over, in disk order, the entries on disk.
+   * Should only be used if this region has entries on disk that are not in memory. This currently
+   * happens for overflow and for recovery when values are not recovered. The first iteration does a
+   * normal iteration of the regionEntries. But if it finds an entry that is currently only on disk
+   * it saves it in a list sorted by the location on disk. Once the regionEntries iterator has
+   * nothing more to iterate it starts iterating over, in disk order, the entries on disk.
-    //private final ArrayList<DiskPosition> diskList = new ArrayList<DiskPosition>(/*@todo presize based on number of entries only on disk*/);
+    // private final ArrayList<DiskPosition> diskList = new ArrayList<DiskPosition>(/*@todo presize
+    // based on number of entries only on disk*/);
-//     private long pendingCount = 0;
-    private final java.util.TreeMap<DiskPage, Object> diskMap = new java.util.TreeMap<DiskPage, Object>();
+    // private long pendingCount = 0;
+    private final java.util.TreeMap<DiskPage, Object> diskMap =
+        new java.util.TreeMap<DiskPage, Object>();
-//     /**
-//      * used to iterate over the fullest pages at the time we have
-//      * added MAX_PENDING_ENTRIES to diskMap;
-//      */
-//     private Iterator<Map.Entry<DiskPage, Object>> sortedDiskIt;
-    
-    public DiskSavyIterator() {
-    }
-    
+    // /**
+    // * used to iterate over the fullest pages at the time we have
+    // * added MAX_PENDING_ENTRIES to diskMap;
+    // */
+    // private Iterator<Map.Entry<DiskPage, Object>> sortedDiskIt;
+
+    public DiskSavyIterator() {}
+
-//       if (this.sortedDiskIt != null) {
-//         result = this.sortedDiskIt.hasNext();
-//         if (!result) {
-//           this.sortedDiskIt = null;
-//         } else {
-//           return result;
-//         }
-//       }
+      // if (this.sortedDiskIt != null) {
+      // result = this.sortedDiskIt.hasNext();
+      // if (!result) {
+      // this.sortedDiskIt = null;
+      // } else {
+      // return result;
+      // }
+      // }
-//         long start = System.currentTimeMillis();
-//         Collections.sort(this.diskList);
-//         long end = System.currentTimeMillis();
+        // long start = System.currentTimeMillis();
+        // Collections.sort(this.diskList);
+        // long end = System.currentTimeMillis();
-//         } else if (this.sortedDiskIt != null) {
-//           Map.Entry<DiskPage, Object> me = this.sortedDiskIt.next();
-//           // remove the page from the diskMap.
-//           this.diskMap.remove(me.getKey());
-//           Object v = me.getValue();
-//           int size = 1;
-//           if (v instanceof ArrayList) {
-//             ArrayList al = (ArrayList)v;
-//             size = al.size();
-//             // set up the iterator to start returning the entries on that page
-//             this.subIt = al.iterator();
-//             v = this.subIt.next();
-//           }
-          
-//           // decrement pendingCount by the number of entries on the page
-//           this.pendingCount -= size;
-//           // return the first region entry on this page
-//           return v;
+          // } else if (this.sortedDiskIt != null) {
+          // Map.Entry<DiskPage, Object> me = this.sortedDiskIt.next();
+          // // remove the page from the diskMap.
+          // this.diskMap.remove(me.getKey());
+          // Object v = me.getValue();
+          // int size = 1;
+          // if (v instanceof ArrayList) {
+          // ArrayList al = (ArrayList)v;
+          // size = al.size();
+          // // set up the iterator to start returning the entries on that page
+          // this.subIt = al.iterator();
+          // v = this.subIt.next();
+          // }
+
+          // // decrement pendingCount by the number of entries on the page
+          // this.pendingCount -= size;
+          // // return the first region entry on this page
+          // return v;
-          RegionEntry re = (RegionEntry)this.it.next();
+          RegionEntry re = (RegionEntry) this.it.next();
-              ArrayList al = (ArrayList)v;
+              ArrayList al = (ArrayList) v;
-//             this.pendingCount++;
-//             if (this.usingIt && this.pendingCount >= MAX_PENDING_ENTRIES) {
-//               // find the pages that have the most entries
-//               int largestPage = 1;
-//               ArrayList<Map.Entry<DiskPage, Object>> largestPages
-//                 = new ArrayList<Map.Entry<DiskPage, Object>>();
-//               for (Map.Entry<DiskPage, Object> me: this.diskMap.entrySet()) {
-//                 int meSize = 1;
-//                 if (me.getValue() instanceof ArrayList) {
-//                   meSize = ((ArrayList)me.getValue()).size();
-//                 }
-//                 if (meSize > largestPage) {
-//                   largestPage = meSize;
-//                   largestPages.clear(); // throw away smaller pages
-//                   largestPages.add(me);
-//                 } else if (meSize == largestPage) {
-//                   largestPages.add(me);
-//                 } else {
-//                   // ignore this page
-//                 }
-//               }
-//               Collections.sort(largestPages, new Comparator
-// <Map.Entry<DiskPage, Object>>() {
-//                   /**
-//                    * Note: this comparator imposes orderings that are inconsistent
-//                    * with equals.
-//                    */
-//                   public int compare(Map.Entry<DiskPage, Object> o1, Map.Entry<DiskPage, Object> o2) {
-//                     return o1.getKey().compareTo(o2.getKey());
-//                   }
-//                 });
-//               this.sortedDiskIt = largestPages.iterator();
-//               // loop around and fetch first value from sortedDiskIt
-//             }
+            // this.pendingCount++;
+            // if (this.usingIt && this.pendingCount >= MAX_PENDING_ENTRIES) {
+            // // find the pages that have the most entries
+            // int largestPage = 1;
+            // ArrayList<Map.Entry<DiskPage, Object>> largestPages
+            // = new ArrayList<Map.Entry<DiskPage, Object>>();
+            // for (Map.Entry<DiskPage, Object> me: this.diskMap.entrySet()) {
+            // int meSize = 1;
+            // if (me.getValue() instanceof ArrayList) {
+            // meSize = ((ArrayList)me.getValue()).size();
+            // }
+            // if (meSize > largestPage) {
+            // largestPage = meSize;
+            // largestPages.clear(); // throw away smaller pages
+            // largestPages.add(me);
+            // } else if (meSize == largestPage) {
+            // largestPages.add(me);
+            // } else {
+            // // ignore this page
+            // }
+            // }
+            // Collections.sort(largestPages, new Comparator
+            // <Map.Entry<DiskPage, Object>>() {
+            // /**
+            // * Note: this comparator imposes orderings that are inconsistent
+            // * with equals.
+            // */
+            // public int compare(Map.Entry<DiskPage, Object> o1, Map.Entry<DiskPage, Object> o2) {
+            // return o1.getKey().compareTo(o2.getKey());
+            // }
+            // });
+            // this.sortedDiskIt = largestPages.iterator();
+            // // loop around and fetch first value from sortedDiskIt
+            // }
-            ArrayList al = (ArrayList)v;
+            ArrayList al = (ArrayList) v;
-    
-    DiskPosition() {
-    }
+
+    DiskPosition() {}
+
-    
+
-        DiskPosition other = (DiskPosition)o;
+        DiskPosition other = (DiskPosition) o;
+
-    static final long DISK_PAGE_SIZE = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "DISK_PAGE_SIZE", 8 * 1024L).longValue();
-    
+    static final long DISK_PAGE_SIZE =
+        Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "DISK_PAGE_SIZE", 8 * 1024L).longValue();
+
-   * Returns the lock lease value to use for DistributedLock and
-   * RegionDistributedLock. -1 is supported as non-expiring lock.
+   * Returns the lock lease value to use for DistributedLock and RegionDistributedLock. -1 is
+   * supported as non-expiring lock.
-  protected long getLockLeaseForLock()
-  {
+  protected long getLockLeaseForLock() {
-   * Returns the lock timeout value to use for DistributedLock and
-   * RegionDistributedLock. -1 is supported as a lock that never times out.
+   * Returns the lock timeout value to use for DistributedLock and RegionDistributedLock. -1 is
+   * supported as a lock that never times out.
-  protected long getLockTimeoutForLock(long time, TimeUnit unit)
-  {
+  protected long getLockTimeoutForLock(long time, TimeUnit unit) {
-  
+
-  private class DistributedLock implements Lock
-  {
+  private class DistributedLock implements Lock {
-    public void lock()
-    {
+    public void lock() {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-    public void lockInterruptibly() throws InterruptedException
-    {
+    public void lockInterruptibly() throws InterruptedException {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-    public boolean tryLock()
-    {
+    public boolean tryLock() {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-      }
-      finally {
+      } finally {
-    public boolean tryLock(long time, TimeUnit unit)
-    throws InterruptedException  {
+    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
-    
+
-        throws InterruptedException  {
-//      if (Thread.interrupted()) throw new InterruptedException(); not necessary lockInterruptibly does this
+        throws InterruptedException {
+      // if (Thread.interrupted()) throw new InterruptedException(); not necessary lockInterruptibly
+      // does this
-      }
-      else {
+      } else {
-      
+
-      }
-      else {
+      } else {
-          waitInterval = Math.min(end-System.currentTimeMillis(), waitInterval);
+          waitInterval = Math.min(end - System.currentTimeMillis(), waitInterval);
-            gotLock = getLockService().lockInterruptibly(this.key,
-              waitInterval, getLockLeaseForLock());
-          }
-          else {
-            gotLock = getLockService().lock(this.key,
-                waitInterval, getLockLeaseForLock());
+            gotLock =
+                getLockService().lockInterruptibly(this.key, waitInterval, getLockLeaseForLock());
+          } else {
+            gotLock = getLockService().lock(this.key, waitInterval, getLockLeaseForLock());
-                DLockRemoteToken remoteToken =
-                  ((DLockService)getLockService()).queryLock(key);
+                DLockRemoteToken remoteToken = ((DLockService) getLockService()).queryLock(key);
-                  dm.getMembershipManager()
-                  .suspectMember(lockHolder,
+                  dm.getMembershipManager().suspectMember(lockHolder,
-                      + ackWaitThreshold / 1000 + " seconds");
+                          + ackWaitThreshold / 1000 + " seconds");
-              }
-              else if (elapsed > ackSAThreshold) {
-                DLockRemoteToken remoteToken =
-                  ((DLockService)getLockService()).queryLock(key);
+              } else if (elapsed > ackSAThreshold) {
+                DLockRemoteToken remoteToken = ((DLockService) getLockService()).queryLock(key);
-                    logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_GLOBAL_REGION_ENTRY_LOCK_HELD_BY_1,
-                        new Object[] {Long.valueOf(ackWaitThreshold+ackSAThreshold), lockHolder}));
+                    logger.fatal(LocalizedMessage.create(
+                        LocalizedStrings.DistributedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_GLOBAL_REGION_ENTRY_LOCK_HELD_BY_1,
+                        new Object[] {Long.valueOf(ackWaitThreshold + ackSAThreshold),
+                            lockHolder}));
-                }
-                else {
+                } else {
-        }
-        catch (IllegalStateException ex) {
+        } catch (IllegalStateException ex) {
-        }
-        finally {
+        } finally {
-    public void unlock()
-    {
+    public void unlock() {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-      }
-      finally {
+      } finally {
+
-      throw new UnsupportedOperationException(LocalizedStrings.DistributedRegion_NEWCONDITION_UNSUPPORTED.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.DistributedRegion_NEWCONDITION_UNSUPPORTED.toLocalizedString());
-  private class RegionDistributedLock implements Lock
-  {
+  private class RegionDistributedLock implements Lock {
-    public RegionDistributedLock() {
-    }
+    public RegionDistributedLock() {}
-    public void lock()
-    {
+    public void lock() {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-    public void lockInterruptibly() throws InterruptedException
-    {
-//      if (Thread.interrupted()) throw new InterruptedException(); not necessary suspendLockingInterruptibly does this
+    public void lockInterruptibly() throws InterruptedException {
+      // if (Thread.interrupted()) throw new InterruptedException(); not necessary
+      // suspendLockingInterruptibly does this
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-    public boolean tryLock()
-    {
+    public boolean tryLock() {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-    public boolean tryLock(long time, TimeUnit unit)
-        throws InterruptedException
-    {
-//      if (Thread.interrupted()) throw new InterruptedException(); not necessary suspendLockingINterruptibly does this
+    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+      // if (Thread.interrupted()) throw new InterruptedException(); not necessary
+      // suspendLockingINterruptibly does this
-        return getLockService().suspendLockingInterruptibly(
-            getLockTimeoutForLock(time, unit));
-      }
-      catch (IllegalStateException ex) {
+        return getLockService().suspendLockingInterruptibly(getLockTimeoutForLock(time, unit));
+      } catch (IllegalStateException ex) {
-    public void unlock()
-    {
+    public void unlock() {
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
+
-      throw new UnsupportedOperationException(LocalizedStrings.DistributedRegion_NEWCONDITION_UNSUPPORTED.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.DistributedRegion_NEWCONDITION_UNSUPPORTED.toLocalizedString());
-   * If this region's scope is GLOBAL, get the region distributed lock. The
-   * sender is responsible for unlocking.
+   * If this region's scope is GLOBAL, get the region distributed lock. The sender is responsible
+   * for unlocking.
-   * @return the acquired Lock if the region is GLOBAL and not already suspend,
-   *         otherwise null.
+   * @return the acquired Lock if the region is GLOBAL and not already suspend, otherwise null.
-  Lock getRegionDistributedLockIfGlobal() throws TimeoutException
-  {
+  Lock getRegionDistributedLockIfGlobal() throws TimeoutException {
-   * this.getRegionDistributedLockIfGlobal(); try {
-   * super.localDestroyRegion(aCallbackArgument); } finally { if (dlock != null) {
-   * dlock.unlock(); } } } catch (TimeoutException e) { throw new
+   * this.getRegionDistributedLockIfGlobal(); try { super.localDestroyRegion(aCallbackArgument); }
+   * finally { if (dlock != null) { dlock.unlock(); } } } catch (TimeoutException e) { throw new
-   * void destroyRegion(Object aCallbackArgument) throws CacheWriterException,
-   * TimeoutException { Lock dlock = this.getRegionDistributedLockIfGlobal();
-   * try { super.destroyRegion(aCallbackArgument); } finally { if (dlock !=
-   * null) { dlock.unlock(); } } }
-   * 
-   * void invalidateRegion(Object aCallbackArgument) throws TimeoutException {
+   * void destroyRegion(Object aCallbackArgument) throws CacheWriterException, TimeoutException {
-   * super.invalidateRegion(aCallbackArgument); } finally { if (dlock != null) {
-   * dlock.unlock(); } } }
+   * super.destroyRegion(aCallbackArgument); } finally { if (dlock != null) { dlock.unlock(); } } }
+   * 
+   * void invalidateRegion(Object aCallbackArgument) throws TimeoutException { Lock dlock =
+   * this.getRegionDistributedLockIfGlobal(); try { super.invalidateRegion(aCallbackArgument); }
+   * finally { if (dlock != null) { dlock.unlock(); } } }
-  
+
-   * Distribute the PutAllOp.
-   * This implementation distributes it to peers.
+   * Distribute the PutAllOp. This implementation distributes it to peers.
+   * 
-  public void postPutAllSend(DistributedPutAllOperation putAllOp, VersionedObjectList successfulPuts) {
+  public void postPutAllSend(DistributedPutAllOperation putAllOp,
+      VersionedObjectList successfulPuts) {
+
-  public void postRemoveAllSend(DistributedRemoveAllOperation op, VersionedObjectList successfulOps) {
+  public void postRemoveAllSend(DistributedRemoveAllOperation op,
+      VersionedObjectList successfulOps) {
-  
+
-  boolean isMissingRequiredRoles()
-  {
+  boolean isMissingRequiredRoles() {
-   * @throws IllegalStateException
-   *           if region is not configured with required roles
+   * @throws IllegalStateException if region is not configured with required roles
-  public Set waitForRequiredRoles(long timeout) throws InterruptedException
-  {
-    if (Thread.interrupted()) throw new InterruptedException();
+  public Set waitForRequiredRoles(long timeout) throws InterruptedException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
-      throw new IllegalStateException(LocalizedStrings.DistributedRegion_REGION_HAS_NOT_BEEN_CONFIGURED_WITH_REQUIRED_ROLES.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.DistributedRegion_REGION_HAS_NOT_BEEN_CONFIGURED_WITH_REQUIRED_ROLES
+              .toLocalizedString());
-          this.cache.getCancelCriterion().checkCancelInProgress(null); // bail if distribution has stopped
+          this.cache.getCancelCriterion().checkCancelInProgress(null); // bail if distribution has
+                                                                       // stopped
-      }
-      else { // use the timeout
+      } else { // use the timeout
-          this.cache.getCancelCriterion().checkCancelInProgress(null); // bail if distribution has stopped
+          this.cache.getCancelCriterion().checkCancelInProgress(null); // bail if distribution has
+                                                                       // stopped
-                  logger.debug("About to wait up to {} milliseconds for missing required roles.", timeToWait);
+                  logger.debug("About to wait up to {} milliseconds for missing required roles.",
+                      timeToWait);
-              }
-              else {
+              } else {
-        return Collections.unmodifiableSet(new HashSet(
-            this.missingRequiredRoles));
+        return Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
-    }
-    else {
+    } else {
-  public boolean isRoleInRegionMembership(Role role)
-  {
+  public boolean isRoleInRegionMembership(Role role) {
-  protected boolean basicIsRoleInRegionMembership(Role role)
-  {
+  protected boolean basicIsRoleInRegionMembership(Role role) {
-      DistributedMember member = (DistributedMember)iter.next();
+      DistributedMember member = (DistributedMember) iter.next();
-  
+
-    synchronized(this.advisorListener) {
+    synchronized (this.advisorListener) {
-        Object callback = TEST_HOOK_ADD_PROFILE? profile : null;
-        RegionEventImpl event = new RegionEventImpl(this,
-            Operation.REGION_CREATE, callback, true, profile.peerMemberId);
-        dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CREATE,
-              event);
+        Object callback = TEST_HOOK_ADD_PROFILE ? profile : null;
+        RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_CREATE, callback, true,
+            profile.peerMemberId);
+        dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CREATE, event);
-  protected void removeSenderFromAdvisor(InternalDistributedMember sender, int serial, boolean regionDestroyed)
-  {
+  protected void removeSenderFromAdvisor(InternalDistributedMember sender, int serial,
+      boolean regionDestroyed) {
-   * Used to get membership events from our advisor to implement
-   * RegionMembershipListener invocations.
+   * Used to get membership events from our advisor to implement RegionMembershipListener
+   * invocations.
-  protected class AdvisorListener implements MembershipListener
-  {
+  protected class AdvisorListener implements MembershipListener {
-    protected synchronized void addMembers(Set newMembers)
-    {
+    protected synchronized void addMembers(Set newMembers) {
-    protected synchronized Set getInitialMembers()
-    {
+    protected synchronized Set getInitialMembers() {
-    
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-    }
-    public void memberSuspect(InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {
-    }
-    
+    public void quorumLost(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {}
+
+    public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+        String reason) {}
+
-    
-    public synchronized void memberJoined(InternalDistributedMember id)
-    {
+
+    public synchronized void memberJoined(InternalDistributedMember id) {
-//      if (this.members == null && hasListener()) {
-//        RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
-//            Operation.REGION_CREATE, null, true, id);
-//        dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CREATE,
-//            event);
-//      }
+      // if (this.members == null && hasListener()) {
+      // RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
+      // Operation.REGION_CREATE, null, true, id);
+      // dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CREATE,
+      // event);
+      // }
-                  final Role role = (Role)it.next();
+                  final Role role = (Role) it.next();
-                      public void run()
-                      {
+                      public void run() {
-                  }
-                  catch (RejectedExecutionException ex) {
+                  } catch (RejectedExecutionException ex) {
-                else if (getMembershipAttributes().getLossAction()
-                    .isLimitedAccess())
-                  getCachePerfStats()
-                      .incReliableRegionsMissingLimitedAccess(-1);
+                else if (getMembershipAttributes().getLossAction().isLimitedAccess())
+                  getCachePerfStats().incReliableRegionsMissingLimitedAccess(-1);
-    public synchronized void memberDeparted(InternalDistributedMember id,
-        boolean crashed)
-    {
+    public synchronized void memberDeparted(InternalDistributedMember id, boolean crashed) {
-        RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
-            Operation.REGION_CLOSE, null, true, id);
+        RegionEventImpl event =
+            new RegionEventImpl(DistributedRegion.this, Operation.REGION_CLOSE, null, true, id);
-          dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CRASH,
-              event);
-        }
-        else {
+          dispatchListenerEvent(EnumListenerEvent.AFTER_REMOTE_REGION_CRASH, event);
+        } else {
-          //               could be close, local destroy, or destroy (or load snap?)
+          // could be close, local destroy, or destroy (or load snap?)
-            Role role = (Role)iter.next();
+            Role role = (Role) iter.next();
-                else if (getMembershipAttributes().getLossAction()
-                    .isLimitedAccess())
+                else if (getMembershipAttributes().getLossAction().isLimitedAccess())
+   * 
-    if (!this.getAttributes().getDataPolicy().withStorage()
-        || (this.concurrencyChecksEnabled && this.getAttributes()
-            .getDataPolicy() == DataPolicy.NORMAL)) {
+    if (!this.getAttributes().getDataPolicy().withStorage() || (this.concurrencyChecksEnabled
+        && this.getAttributes().getDataPolicy() == DataPolicy.NORMAL)) {
-   * Execute the provided named function in all locations that contain the given
-   * keys. So function can be executed on just one fabric node, executed in
-   * parallel on a subset of nodes in parallel across all the nodes.
+   * Execute the provided named function in all locations that contain the given keys. So function
+   * can be executed on just one fabric node, executed in parallel on a subset of nodes in parallel
+   * across all the nodes.
-   */  
+   */
-  public ResultCollector executeFunction(
-      final DistributedRegionFunctionExecutor execution,
-      final Function function, final Object args,
-      final ResultCollector rc, final Set filter,
+  public ResultCollector executeFunction(final DistributedRegionFunctionExecutor execution,
+      final Function function, final Object args, final ResultCollector rc, final Set filter,
-      final Set<InternalDistributedMember> singleMember = Collections
-          .singleton(getMyId());
+      final Set<InternalDistributedMember> singleMember = Collections.singleton(getMyId());
-        throw new FunctionException(LocalizedStrings
-            .DistributedRegion_NO_REPLICATED_REGION_FOUND_FOR_EXECUTING_FUNCTION_0
-              .toLocalizedString(function.getId()));
+        throw new FunctionException(
+            LocalizedStrings.DistributedRegion_NO_REPLICATED_REGION_FOUND_FOR_EXECUTING_FUNCTION_0
+                .toLocalizedString(function.getId()));
-    final LocalResultCollector<?, ?> localRC = execution
-        .getLocalResultCollector(function, rc);
+    final LocalResultCollector<?, ?> localRC = execution.getLocalResultCollector(function, rc);
-  private ResultCollector executeOnReplicate(
-      final DistributedRegionFunctionExecutor execution,
-      final Function function, final Object args, ResultCollector rc,
-      final Set filter, final DistributedMember target) {
+  private ResultCollector executeOnReplicate(final DistributedRegionFunctionExecutor execution,
+      final Function function, final Object args, ResultCollector rc, final Set filter,
+      final DistributedMember target) {
-    HashMap<InternalDistributedMember, Object> memberArgs = new HashMap<InternalDistributedMember, Object>();
-    memberArgs.put((InternalDistributedMember)target, execution.getArgumentsForMember(target.getId()));
-    
-    ResultSender resultSender = new DistributedRegionFunctionResultSender(null, rc,
-        function, execution.getServerResultSender());
-    
-    DistributedRegionFunctionResultWaiter waiter = new DistributedRegionFunctionResultWaiter(
-        this.getSystem(), this.getFullPath(), rc, function, filter,
-        Collections.singleton(target), memberArgs, resultSender);      
-    
-    rc = waiter.getFunctionResultFrom(Collections.singleton(target),
-        function, execution);
+    HashMap<InternalDistributedMember, Object> memberArgs =
+        new HashMap<InternalDistributedMember, Object>();
+    memberArgs.put((InternalDistributedMember) target,
+        execution.getArgumentsForMember(target.getId()));
+
+    ResultSender resultSender = new DistributedRegionFunctionResultSender(null, rc, function,
+        execution.getServerResultSender());
+
+    DistributedRegionFunctionResultWaiter waiter =
+        new DistributedRegionFunctionResultWaiter(this.getSystem(), this.getFullPath(), rc,
+            function, filter, Collections.singleton(target), memberArgs, resultSender);
+
+    rc = waiter.getFunctionResultFrom(Collections.singleton(target), function, execution);
-   * Implementation of {@link ProfileVisitor} that selects a random replicated
-   * member from the available ones for this region.
+   * Implementation of {@link ProfileVisitor} that selects a random replicated member from the
+   * available ones for this region.
-  static final class GetRandomReplicate implements
-      ProfileVisitor<DistributedMember> {
+  static final class GetRandomReplicate implements ProfileVisitor<DistributedMember> {
-    
+
-    public GetRandomReplicate() {
-    }
-    
+    public GetRandomReplicate() {}
+
-    
-    public boolean visit(DistributionAdvisor advisor, Profile profile,
-        int profileIndex, int numProfiles, DistributedMember member) {
-      final CacheProfile cp = (CacheProfile)profile;
+
+    public boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex,
+        int numProfiles, DistributedMember member) {
+      final CacheProfile cp = (CacheProfile) profile;
-    /* [sumedh] The old code causes creation of a unnecessary HashSet
-     * and population with all replicates (which may be large), then
-     * copy into an array and then selection of a random one from that.
-     * The new approach uses a much more efficient visitor instead.
-    Set replicates =  this.getCacheDistributionAdvisor().adviseReplicates();
-    if (replicates.isEmpty()) {
-      return null;
-    }
-    return (InternalDistributedMember)(replicates
-        .toArray()[new Random().nextInt(replicates.size())]);
-    */
+    /*
+     * [sumedh] The old code causes creation of a unnecessary HashSet and population with all
+     * replicates (which may be large), then copy into an array and then selection of a random one
+     * from that. The new approach uses a much more efficient visitor instead. Set replicates =
+     * this.getCacheDistributionAdvisor().adviseReplicates(); if (replicates.isEmpty()) { return
+     * null; } return (InternalDistributedMember)(replicates .toArray()[new
+     * Random().nextInt(replicates.size())]);
+     */
-  void executeOnRegion(DistributedRegionFunctionStreamingMessage msg,
-      final Function function, final Object args, int prid,
-      final Set filter, boolean isReExecute) throws IOException {
+  void executeOnRegion(DistributedRegionFunctionStreamingMessage msg, final Function function,
+      final Object args, int prid, final Set filter, boolean isReExecute) throws IOException {
-    final RegionFunctionContextImpl context = new RegionFunctionContextImpl(
-        function.getId(), this, args, filter, null, null, resultSender,
-        isReExecute);
-    FunctionStats stats = FunctionStats.getFunctionStats(function.getId(), dm.getSystem());    
+    final RegionFunctionContextImpl context = new RegionFunctionContextImpl(function.getId(), this,
+        args, filter, null, null, resultSender, isReExecute);
+    FunctionStats stats = FunctionStats.getFunctionStats(function.getId(), dm.getSystem());
-      stats.endFunctionExecution(start,function.hasResult());
-    }
-    catch (FunctionException functionException) {
+      stats.endFunctionExecution(start, function.hasResult());
+    } catch (FunctionException functionException) {
-        logger.debug("FunctionException occured on remote node  while executing Function: {}", function.getId(), functionException);
+        logger.debug("FunctionException occured on remote node  while executing Function: {}",
+            function.getId(), functionException);
-    }
-    catch (CacheClosedException cacheClosedexception) {
+    } catch (CacheClosedException cacheClosedexception) {
-        logger.debug("CacheClosedException occured on remote node  while executing Function: {}", function.getId(), cacheClosedexception);
+        logger.debug("CacheClosedException occured on remote node  while executing Function: {}",
+            function.getId(), cacheClosedexception);
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-        logger.debug("Exception occured on remote node  while executing Function: {}", function.getId(), exception);
+        logger.debug("Exception occured on remote node  while executing Function: {}",
+            function.getId(), exception);
-    } 
+    }
-  
-  ResultCollector executeLocally(
-      final DistributedRegionFunctionExecutor execution,
-      final Function function, final Object args, int prid,
-      final ResultCollector rc, final Set filter,
-      final ServerToClientFunctionResultSender sender) {
-    final LocalResultCollector<?, ?> localRC = execution
-        .getLocalResultCollector(function, rc);
+
+  ResultCollector executeLocally(final DistributedRegionFunctionExecutor execution,
+      final Function function, final Object args, int prid, final ResultCollector rc,
+      final Set filter, final ServerToClientFunctionResultSender sender) {
+    final LocalResultCollector<?, ?> localRC = execution.getLocalResultCollector(function, rc);
-    final DistributedRegionFunctionResultSender resultSender = new DistributedRegionFunctionResultSender(
-        dm, localRC, function, sender);
-    final RegionFunctionContextImpl context = new RegionFunctionContextImpl(
-        function.getId(), DistributedRegion.this, args, filter, null, null,
-        resultSender, execution.isReExecute());
+    final DistributedRegionFunctionResultSender resultSender =
+        new DistributedRegionFunctionResultSender(dm, localRC, function, sender);
+    final RegionFunctionContextImpl context = new RegionFunctionContextImpl(function.getId(),
+        DistributedRegion.this, args, filter, null, null, resultSender, execution.isReExecute());
-      if (event.getState().isCritical()
-          && !event.getPreviousState().isCritical()
-          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+      if (event.getState().isCritical() && !event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY
+              || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
-      } else if (!event.getState().isCritical()
-          && event.getPreviousState().isCritical()
-          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+      } else if (!event.getState().isCritical() && event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY
+              || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
-    synchronized(this.memoryThresholdReachedMembers) {
+    synchronized (this.memoryThresholdReachedMembers) {
-  
+
-    for (InternalDistributedMember idm: critialMembers) {
+    for (InternalDistributedMember idm : critialMembers) {
-    synchronized(this.memoryThresholdReachedMembers) {
+    synchronized (this.memoryThresholdReachedMembers) {
+   * 
-   * Test hook for bug 48578. Returns true if it sees a net loader.
-   * Returns false if it does not have one.
+   * Test hook for bug 48578. Returns true if it sees a net loader. Returns false if it does not
+   * have one.

Fixing problems with network partition detection

Recent changes in GMSJoinLeave and GMSHealthMonitor destabilized network
partition detection to the point that it was barely working.  This corrects
faults that were causing the failures - exponential barrages of suspect
processing and failure to detect loss of members during membership view
creation.

GMSJoinLeave's removeHealthyMembers and filterMembers methods had some problems
that resulted in unhealthy members not being detected.  GMSHealthMonitor
did not have barriers in place to prevent initiation of concurrent suspect
processing on the same member.  JGroupsMessenger was initiating final checks
on members if unable to send a message to them instead of merely raising
suspicion.

-//  /**
-//   * Members undergoing final checks
-//   */
-//  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
+  /**
+   * Members undergoing final checks
+   */
+  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
-        logger.debug("Unexpected exception", e);
+        // this is expected if it is a connection-timeout or other failure
+        // to connect
-            logger.info("Unexpected exception", e);
+            // expected if the socket is already closed
-   * It records the member activity for current time interval.
+   * Record the member activity for current time interval.
-    TimeStamp cTS = new TimeStamp(currentTimeStamp);
+    contactedBy(sender, currentTimeStamp);
+  }
+  
+  
+  /**
+   * Record member activity at a specified time
+   */
+  private void contactedBy(InternalDistributedMember sender, long timeStamp) {
+    TimeStamp cTS = new TimeStamp(timeStamp);
-      cTS.setTimeStamp(currentTimeStamp);
+      cTS.setTimeStamp(timeStamp);
+  
+    if (services.getJoinLeave().isMemberLeaving(mbr)) {
+      return;
+    }
+    long startTime = System.currentTimeMillis();
+          if (ts != null && ts.getTime() > startTime) {
+            return true;
+          }
-      logger.debug("Unexpected exception", e);
+      // this is expected if it is a connection-timeout or other failure
+      // to connect
-        logger.trace("Unexpected exception", e);
+        // expected
-        this.stats.incFinalCheckResponsesReceived();
-        this.stats.incTcpFinalCheckResponsesReceived();
+        if (b >= 0) {
+          this.stats.incFinalCheckResponsesReceived();
+          this.stats.incTcpFinalCheckResponsesReceived();
+        }
-      contactedBy(m.getSender());
+      contactedBy(m.getSender(), System.currentTimeMillis());
-//    List<InternalDistributedMember> membersChecked = new ArrayList<>(10);
-    try {
-      for (int i = 0; i < sMembers.size(); i++) {
-        final SuspectRequest sr = sMembers.get(i);
-        final InternalDistributedMember mbr = sr.getSuspectMember();
+    for (int i = 0; i < sMembers.size(); i++) {
+      final SuspectRequest sr = sMembers.get(i);
+      final InternalDistributedMember mbr = sr.getSuspectMember();
-        if (!cv.contains(mbr) /*|| membersInFinalCheck.contains(mbr)*/) {
-          continue;
-        }
-
-        if (mbr.equals(localAddress)) {
-          continue;// self
-        }
-        
-//        membersChecked.add(mbr);
-
-        // suspectMemberInView is now set by the heartbeat monitoring code
-        // to allow us to move on from watching members we've already
-        // suspected.  Since that code is updating this collection we
-        // cannot use it here as an indication that a member is currently
-        // undergoing a final check.
-        //      NetView view;
-        //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
-
-        //      if (view == null || !view.equals(cv)) {
-        final String reason = sr.getReason();
-        logger.debug("Scheduling final check for member {}; reason={}", mbr, reason);
-        // its a coordinator
-        checkExecutor.execute(new Runnable() {
-
-          @Override
-          public void run() {
-            try {
-              inlineCheckIfAvailable(initiator, cv, true, mbr,
-                  reason);
-            } catch (DistributedSystemDisconnectedException e) {
-              return;
-            } catch (Exception e) {
-              logger.info("Unexpected exception while verifying member", e);
-            } finally {
-              GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
-            }
-          }
-
-          
-        });
-        //      }// scheduling for final check and removing it..
+      if (!cv.contains(mbr) || membersInFinalCheck.contains(mbr)) {
+        continue;
-    } finally {
-//      membersInFinalCheck.removeAll(membersChecked);
+
+      if (mbr.equals(localAddress)) {
+        continue;// self
+      }
+
+      // suspectMemberInView is now set by the heartbeat monitoring code
+      // to allow us to move on from watching members we've already
+      // suspected.  Since that code is updating this collection we
+      // cannot use it here as an indication that a member is currently
+      // undergoing a final check.
+      //      NetView view;
+      //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
+
+      //      if (view == null || !view.equals(cv)) {
+      final String reason = sr.getReason();
+      logger.debug("Scheduling final check for member {}; reason={}", mbr, reason);
+      // its a coordinator
+      checkExecutor.execute(new Runnable() {
+
+        @Override
+        public void run() {
+          try {
+            inlineCheckIfAvailable(initiator, cv, true, mbr,
+                reason);
+          } catch (DistributedSystemDisconnectedException e) {
+            return;
+          } catch (Exception e) {
+            logger.info("Unexpected exception while verifying member", e);
+          } finally {
+            GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
+          }
+        }
+
+
+      });
+      //      }// scheduling for final check and removing it..
-    services.memberSuspected(initiator, mbr, reason);
-    long startTime = System.currentTimeMillis();
-    // for some reason we used to update the timestamp for the member
-    // with the startTime, but we don't want to do that because it looks
-    // like a heartbeat has been received
-
-    logger.info("Performing final check for suspect member {} reason={}", mbr, reason);
-    boolean pinged;
-    int port = cv.getFailureDetectionPort(mbr);
-    if (port <= 0) {
-      logger.info("Unable to locate failure detection port - requesting a heartbeat");
-      if (logger.isDebugEnabled()) {
-        logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
-      }
-      pinged = GMSHealthMonitor.this.doCheckMember(mbr);
-      GMSHealthMonitor.this.stats.incFinalCheckRequestsSent();
-      GMSHealthMonitor.this.stats.incUdpFinalCheckRequestsSent();
-      if (pinged) {
-        GMSHealthMonitor.this.stats.incFinalCheckResponsesReceived();
-        GMSHealthMonitor.this.stats.incUdpFinalCheckResponsesReceived();
-      }
-    } else {
-      pinged = GMSHealthMonitor.this.doTCPCheckMember(mbr, port);
+    if (services.getJoinLeave().isMemberLeaving(mbr)) {
+      return false;
-    if (!pinged && !isStopping) {
-      TimeStamp ts = memberTimeStamps.get(mbr);
-      if (ts == null || ts.getTime() <= startTime) {
-        logger.info("Final check failed - requesting removal of suspect member " + mbr);
-        if (initiateRemoval) {
-          services.getJoinLeave().remove(mbr, reason);
+
+    membersInFinalCheck.add(mbr);
+    try {
+      services.memberSuspected(initiator, mbr, reason);
+      long startTime = System.currentTimeMillis();
+      // for some reason we used to update the timestamp for the member
+      // with the startTime, but we don't want to do that because it looks
+      // like a heartbeat has been received
+  
+      logger.info("Performing final check for suspect member {} reason={}", mbr, reason);
+      boolean pinged;
+      int port = cv.getFailureDetectionPort(mbr);
+      if (port <= 0) {
+        logger.info("Unable to locate failure detection port - requesting a heartbeat");
+        if (logger.isDebugEnabled()) {
+          logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
-        failed = true;
+        pinged = GMSHealthMonitor.this.doCheckMember(mbr);
+        GMSHealthMonitor.this.stats.incFinalCheckRequestsSent();
+        GMSHealthMonitor.this.stats.incUdpFinalCheckRequestsSent();
+        if (pinged) {
+          GMSHealthMonitor.this.stats.incFinalCheckResponsesReceived();
+          GMSHealthMonitor.this.stats.incUdpFinalCheckResponsesReceived();
+        }
-        logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
+        pinged = GMSHealthMonitor.this.doTCPCheckMember(mbr, port);
+  
+      if (!pinged && !isStopping) {
+        TimeStamp ts = memberTimeStamps.get(mbr);
+        if (ts == null || ts.getTime() <= startTime) {
+          logger.info("Final check failed - requesting removal of suspect member " + mbr);
+          if (initiateRemoval) {
+            services.getJoinLeave().remove(mbr, reason);
+          }
+          failed = true;
+        } else {
+          logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
+        }
+      }
+      if (!failed) {
+        logger.info("Final check passed for suspect member " + mbr);
+      }
+      // whether it's alive or not, at this point we allow it to
+      // be watched again
+      suspectedMemberInView.remove(mbr);
+    } finally {
+      membersInFinalCheck.remove(mbr);
-    if (!failed) {
-      logger.info("Final check passed for suspect member " + mbr);
-    }
-    // whether it's alive or not, at this point we allow it to
-    // be watched again
-    suspectedMemberInView.remove(mbr);

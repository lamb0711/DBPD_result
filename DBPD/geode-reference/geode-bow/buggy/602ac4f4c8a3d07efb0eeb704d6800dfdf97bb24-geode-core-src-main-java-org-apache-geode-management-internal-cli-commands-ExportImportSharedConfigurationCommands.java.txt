GEODE-2261: do not use remote function calls to update the shared configuration

-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.commons.io.FileUtils;
+import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.distributed.internal.SharedConfiguration;
+import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
-import org.apache.geode.management.internal.cli.functions.ExportSharedConfigurationFunction;
-import org.apache.geode.management.internal.cli.functions.ImportSharedConfigurationArtifactsFunction;
-import org.apache.geode.management.internal.cli.functions.LoadSharedConfigurationFunction;
-import org.apache.geode.management.internal.cli.result.TabularResultData;
+import org.apache.geode.management.internal.configuration.domain.Configuration;
+import org.apache.geode.management.internal.configuration.utils.ZipUtils;
+import org.apache.logging.log4j.Logger;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-
-  private final ExportSharedConfigurationFunction exportSharedConfigurationFunction =
-      new ExportSharedConfigurationFunction();
-  private final ImportSharedConfigurationArtifactsFunction importSharedConfigurationFunction =
-      new ImportSharedConfigurationArtifactsFunction();
-  private final LoadSharedConfigurationFunction loadSharedConfiguration =
-      new LoadSharedConfigurationFunction();
-
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-    Set<? extends DistributedMember> locators =
-        cache.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration().keySet();
+    InternalLocator locator = InternalLocator.getLocator();
+    if (!locator.isSharedConfigurationRunning()) {
+      return ResultBuilder.createGemFireErrorResult(CliStrings.SHARED_CONFIGURATION_NOT_STARTED);
+    }
-    Optional<CliFunctionResult> functionResult = locators.stream()
-        .map((DistributedMember locator) -> exportSharedConfigurationFromLocator(locator, null))
-        .filter(CliFunctionResult::isSuccessful).findFirst();
+    SharedConfiguration sc = locator.getSharedConfiguration();
+    File zipFile = new File(zipFileName);
+    zipFile.getParentFile().mkdirs();
-    if (functionResult.isPresent()) {
+    try {
+      for (Configuration config : sc.getEntireConfiguration().values()) {
+        sc.writeConfig(config);
+      }
+      ZipUtils.zip(sc.getSharedConfigurationDirPath(), zipFile.getCanonicalPath());
+
-      byte[] byteData = functionResult.get().getByteData();
+      byte[] byteData = FileUtils.readFileToByteArray(zipFile);
-    } else {
+    } catch (Exception e) {
+      logSevere(e);
+    } finally {
+      zipFile.delete();
-  private CliFunctionResult exportSharedConfigurationFromLocator(DistributedMember locator,
-      Object[] args) {
-    ResultCollector rc = CliUtil.executeFunction(exportSharedConfigurationFunction, args, locator);
-    List<CliFunctionResult> results = (List<CliFunctionResult>) rc.getResult();
-
-    return results.get(0);
-  }
-
-    Set<? extends DistributedMember> locators =
-        cache.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration().keySet();
+    byte[][] shellBytesData = CommandExecutionContext.getBytesFromShell();
+    String zipFileName = CliUtil.bytesToNames(shellBytesData)[0];
+    byte[] zipBytes = CliUtil.bytesToData(shellBytesData)[0];
-    if (locators.isEmpty()) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.NO_LOCATORS_WITH_SHARED_CONFIG);
+    InternalLocator locator = InternalLocator.getLocator();
+
+    if (!locator.isSharedConfigurationRunning()) {
+      ErrorResultData errorData = ResultBuilder.createErrorResultData();
+      errorData.addLine(CliStrings.SHARED_CONFIGURATION_NOT_STARTED);
+      return ResultBuilder.buildResult(errorData);
-    byte[][] shellBytesData = CommandExecutionContext.getBytesFromShell();
-    String[] names = CliUtil.bytesToNames(shellBytesData);
-    byte[][] bytes = CliUtil.bytesToData(shellBytesData);
+    File zipFile = new File(zipFileName);
+    try {
+      SharedConfiguration sc = locator.getSharedConfiguration();
-    String zipFileName = names[0];
-    byte[] zipBytes = bytes[0];
+      // backup the old config
+      for (Configuration config : sc.getEntireConfiguration().values()) {
+        sc.writeConfig(config);
+      }
+      sc.renameExistingSharedConfigDirectory();
-    Object[] args = new Object[] {zipFileName, zipBytes};
+      sc.clearSharedConfiguration();
+      FileUtils.writeByteArrayToFile(zipFile, zipBytes);
+      ZipUtils.unzip(zipFileName, sc.getSharedConfigurationDirPath());
+      // load it from the disk
+      sc.loadSharedConfigurationFromDisk();
-    Optional<CliFunctionResult> functionResult = locators.stream()
-        .map((DistributedMember locator) -> importSharedConfigurationFromLocator(locator, args))
-        .filter(CliFunctionResult::isSuccessful).findFirst();
-
-    if (functionResult.isPresent()) {
-      infoData.addLine(functionResult.get().getMessage());
+      infoData.addLine(CliStrings.IMPORT_SHARED_CONFIG__SUCCESS__MSG);
-    } else {
+    } catch (Exception e) {
+      logSevere(e);
+    } finally {
+      FileUtils.deleteQuietly(zipFile);
-
-  private CliFunctionResult importSharedConfigurationFromLocator(DistributedMember locator,
-      Object[] args) {
-    ResultCollector rc = CliUtil.executeFunction(importSharedConfigurationFunction, args, locator);
-    List<CliFunctionResult> results = (List<CliFunctionResult>) rc.getResult();
-
-    return results.get(0);
-  }
-
-
+    private static final Logger logger = LogService.getLogger();
-              if (!saveDirFile.isDirectory())
+              if (!saveDirFile.isDirectory()) {
+              }
-          try {
-            if (!saveDirFile.canWrite()) {
-              return ResultBuilder.createGemFireErrorResult(
-                  CliStrings.format(CliStrings.EXPORT_SHARED_CONFIG__MSG__NOT_WRITEABLE,
-                      saveDirFile.getCanonicalPath()));
-            }
-          } catch (IOException ioex) {
+          if (!saveDirFile.canWrite()) {
+            return ResultBuilder.createGemFireErrorResult(
+                CliStrings.format(CliStrings.EXPORT_SHARED_CONFIG__MSG__NOT_WRITEABLE,
+                    saveDirFile.getCanonicalPath()));
+          logger.error(ioex);
-              CliStrings.EXPORT_SHARED_CONFIG__UNABLE__TO__EXPORT__CONFIG);
+              CliStrings.EXPORT_SHARED_CONFIG__UNABLE__TO__EXPORT__CONFIG + ": "
+                  + ioex.getMessage());

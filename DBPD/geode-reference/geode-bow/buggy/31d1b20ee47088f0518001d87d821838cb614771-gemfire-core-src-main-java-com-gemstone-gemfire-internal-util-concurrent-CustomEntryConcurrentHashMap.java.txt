Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.concurrent.RejectedExecutionException;
+import com.gemstone.gemfire.CancelException;
+import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.internal.cache.wan.GatewaySenderEventImpl;
+import com.gemstone.gemfire.internal.cache.OffHeapRegionEntry;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
-    final void clear() {
+    /**
+     * GemStone added the clearedEntries param and the result
+     */
+    final ArrayList<HashEntry<?,?>> clear(ArrayList<HashEntry<?,?>> clearedEntries) {
-          for (int i = 0; i < tab.length; i++) {
-            tab[i] = null;
+          // GemStone changes BEGIN
+          boolean collectEntries = clearedEntries != null;
+          if (!collectEntries) {
+            // see if we have a map with off-heap region entries
+            for (HashEntry<K, V> he : tab) {
+              if (he != null) {
+                collectEntries = he instanceof OffHeapRegionEntry;
+                if (collectEntries) {
+                  clearedEntries = new ArrayList<HashEntry<?, ?>>();
+                }
+                // after the first non-null entry we are done
+                break;
+              }
+            }
+          }
+          final boolean checkForGatewaySenderEvent = OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
+          final boolean skipProcessOffHeap = !collectEntries && !checkForGatewaySenderEvent;
+          if (skipProcessOffHeap) {
+            Arrays.fill(tab, null);
+          } else {
+            for (int i = 0; i < tab.length; i++) {
+              HashEntry<K, V> he = tab[i];
+              if (he == null) continue;
+              tab[i] = null;
+              if (collectEntries) {
+                clearedEntries.add(he);
+              } else {
+                for (HashEntry<K, V> p = he; p != null; p = p.getNextEntry()) {
+                  if (p instanceof RegionEntry) {
+                    // It is ok to call GatewaySenderEventImpl release without being synced
+                    // on the region entry. It will not create an orphan.
+                    GatewaySenderEventImpl.release(((RegionEntry) p)._getValue()); // OFFHEAP _getValue ok
+                  }
+                }
+              }
+            }
+            // GemStone changes END
+      return clearedEntries; // GemStone change
-    for (int i = 0; i < this.segments.length; ++i) {
-      this.segments[i].clear();
+    ArrayList<HashEntry<?,?>> entries = null;
+    try {
+      for (int i = 0; i < this.segments.length; ++i) {
+        entries = this.segments[i].clear(entries);
+      }
+    } finally {
+      if (entries != null) {
+        final ArrayList<HashEntry<?,?>> clearedEntries = entries;
+        final Runnable runnable = new Runnable() {
+          public void run() {
+            for (HashEntry<?,?> he: clearedEntries) {
+              for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
+                synchronized (p) {
+                  ((OffHeapRegionEntry)p).release();
+                }
+              }
+            }
+          }
+        };
+        boolean submitted = false;
+        InternalDistributedSystem ids = InternalDistributedSystem.getConnectedInstance();
+        if (ids != null) {
+          try {
+            ids.getDistributionManager().getWaitingThreadPool().submit(runnable);
+            submitted = true;
+          } catch (RejectedExecutionException e) {
+            // fall through with submitted false
+          } catch (CancelException e) {
+            // fall through with submitted false
+          } catch (NullPointerException e) {
+            // fall through with submitted false
+          }
+        }
+        if (!submitted) {
+          String name = this.getClass().getSimpleName()+"@"+this.hashCode()+" Clear Thread";
+          Thread thread = new Thread(runnable, name);
+          thread.setDaemon(true);
+          thread.start();
+        }
+      }

GEODE-11 Adding tests of closing a cache during index updates

Testing failover of lucene indexes by closing the cache while in the
middle of updating lucene indexes. Currently there are tests for closing
the cache before the index repository commit, and also during the commit
after a fixed number of updates to the underling index data regions.

I refactored the lucene tests to use 7 buckets, rather than 113, so they
take less time and are easier to debug.

I also removed a call to Thread.interrupt in the WAN code because it was
interrupting itself in my callback. We should never be using interrupt
in the product.

+import static com.gemstone.gemfire.cache.lucene.test.IndexRepositorySpy.doOnce;
-import static org.mockito.Mockito.*;
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import java.util.function.Consumer;
-import org.apache.lucene.analysis.Analyzer;
-import org.junit.Ignore;
-import org.mockito.Mockito;
-import org.mockito.stubbing.Answer;
+import com.gemstone.gemfire.cache.PartitionAttributes;
+import com.gemstone.gemfire.cache.PartitionAttributesFactory;
-import com.gemstone.gemfire.cache.lucene.internal.IndexRepositoryFactory;
-import com.gemstone.gemfire.cache.lucene.internal.LuceneIndexStats;
-import com.gemstone.gemfire.cache.lucene.internal.PartitionedRepositoryManager;
-import com.gemstone.gemfire.cache.lucene.internal.filesystem.FileSystemStats;
-import com.gemstone.gemfire.cache.lucene.internal.repository.IndexRepository;
-import com.gemstone.gemfire.cache.lucene.internal.repository.serializer.LuceneSerializer;
+import com.gemstone.gemfire.cache.lucene.test.IndexRepositorySpy;
-import com.gemstone.gemfire.internal.cache.BucketNotFoundException;
-import com.gemstone.gemfire.internal.cache.PartitionedRegion;
+  protected static final int NUM_BUCKETS = 7;
-
-
-  protected void putEntriesAndValidateQueryResults() {
-    SerializableRunnableIF createIndex = () -> {
-      LuceneService luceneService = LuceneServiceProvider.get(getCache());
-      luceneService.createIndex(INDEX_NAME, REGION_NAME, "text");
-    };
-    dataStore1.invoke(() -> initDataStore(createIndex));
-    accessor.invoke(() -> initAccessor(createIndex));
-    dataStore1.invoke(() -> LuceneTestUtilities.pauseSender(getCache()));
-
-    put113Entries();
-
-    dataStore2.invoke(() -> initDataStore(createIndex));
-    dataStore1.invoke(() -> LuceneTestUtilities.resumeSender(getCache()));
-
-    assertTrue(waitForFlushBeforeExecuteTextSearch(dataStore1, 60000));
-
-    executeTextSearch(accessor, "world", "text", 113);
-  }
-
-    put113Entries();
+    putEntryInEachBucket();
-    executeTextSearch(accessor, "world", "text", 113);
+    executeTextSearch(accessor, "world", "text", NUM_BUCKETS);
-    put113Entries();
+    putEntryInEachBucket();
-    executeTextSearch(accessor, "world", "text", 113);
+    executeTextSearch(accessor, "world", "text", NUM_BUCKETS);
-  protected void put113Entries() {
+  protected PartitionAttributes getPartitionAttributes() {
+    PartitionAttributesFactory factory = new PartitionAttributesFactory();
+    factory.setLocalMaxMemory(100);
+    factory.setTotalNumBuckets(NUM_BUCKETS);
+    return factory.create();
+  }
+
+  protected void putEntriesAndValidateQueryResults() {
+    SerializableRunnableIF createIndex = () -> {
+      LuceneService luceneService = LuceneServiceProvider.get(getCache());
+      luceneService.createIndex(INDEX_NAME, REGION_NAME, "text");
+    };
+    dataStore1.invoke(() -> initDataStore(createIndex));
+    accessor.invoke(() -> initAccessor(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.pauseSender(getCache()));
+
+    putEntryInEachBucket();
+
+    dataStore2.invoke(() -> initDataStore(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.resumeSender(getCache()));
+
+    assertTrue(waitForFlushBeforeExecuteTextSearch(dataStore1, 60000));
+
+    executeTextSearch(accessor, "world", "text", NUM_BUCKETS);
+  }
+
+  protected void putEntryInEachBucket() {
-      IntStream.range(0,113).forEach(i -> region.put(i, new TestObject("hello world")));
+      IntStream.range(0,NUM_BUCKETS).forEach(i -> region.put(i, new TestObject("hello world")));
-      spy.beforeWrite(doOnce(key -> rebalanceRegion(vm)));
+      spy.beforeWriteIndexRepository(doOnce(key -> rebalanceRegion(vm)));
-      spy.beforeWrite(doOnce(key -> moveBucket(destination, key)));
+      spy.beforeWriteIndexRepository(doOnce(key -> moveBucket(destination, key)));
-  protected static class IndexRepositorySpy extends IndexRepositoryFactory {
-
-    private Consumer<Object> beforeWrite = key -> {};
-
-    public static IndexRepositorySpy injectSpy() {
-      IndexRepositorySpy factory = new IndexRepositorySpy();
-      PartitionedRepositoryManager.indexRepositoryFactory = factory;
-      return factory;
-    }
-
-    public static void remove() {
-      PartitionedRepositoryManager.indexRepositoryFactory = new IndexRepositoryFactory();
-    }
-
-    private IndexRepositorySpy() {
-    }
-
-    @Override
-    public IndexRepository createIndexRepository(final Integer bucketId,
-                                                 final PartitionedRegion userRegion,
-                                                 final PartitionedRegion fileRegion,
-                                                 final PartitionedRegion chunkRegion,
-                                                 final LuceneSerializer serializer,
-                                                 final Analyzer analyzer,
-                                                 final LuceneIndexStats indexStats,
-                                                 final FileSystemStats fileSystemStats)
-      throws IOException
-    {
-      final IndexRepository indexRepo = super.createIndexRepository(bucketId, userRegion, fileRegion, chunkRegion,
-        serializer, analyzer,
-        indexStats,
-        fileSystemStats);
-      final IndexRepository spy = Mockito.spy(indexRepo);
-
-      Answer invokeBeforeWrite = invocation -> {
-        beforeWrite.accept(invocation.getArgumentAt(0, Object.class));
-        invocation.callRealMethod();
-        return null;
-      };
-      doAnswer(invokeBeforeWrite).when(spy).update(any(), any());
-      doAnswer(invokeBeforeWrite).when(spy).create(any(), any());
-      doAnswer(invokeBeforeWrite).when(spy).delete(any());
-
-      return spy;
-    }
-
-    /**
-     * Add a callback that runs before a call to
-     * {@link IndexRepository#create(Object, Object)}
-     */
-    public void beforeWrite(Consumer<Object> action) {
-      this.beforeWrite = action;
-    }
-  }
-
-  protected static <T> Consumer<T> doOnce(Consumer<T> consumer) {
-    return new Consumer<T>() {
-      boolean done;
-
-      @Override
-      public void accept(final T t) {
-        if (!done) {
-          done = true;
-          consumer.accept(t);
-        }
-      }
-    };
-  };
+  ;
+  ;

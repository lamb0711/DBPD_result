GEODE-6977: Improve WAN AutoDiscovery Resilience (#3808)

- Added unit tests.
- Fixed minor warnings.
- Added retry logic to the LocatorMembershipListenerImpl.
- Added extra logging (WARN level) when the auto-discovery fails after
  the configured retries.
- Changed the timeout when sending LocatorJoinMessage from 1 second to
  the configured member-timeout.
-import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.ThreadFactory;
+import org.apache.geode.internal.logging.LoggingThreadFactory;
-
-  private ConcurrentMap<Integer, Set<DistributionLocatorId>> allLocatorsInfo =
-      new ConcurrentHashMap<Integer, Set<DistributionLocatorId>>();
-
-  private ConcurrentMap<Integer, Set<String>> allServerLocatorsInfo =
-      new ConcurrentHashMap<Integer, Set<String>>();
-
-
-  private DistributionConfig config;
-
-  private TcpClient tcpClient;
+  static final int LOCATOR_DISTRIBUTION_RETRY_ATTEMPTS = 3;
+  static final String LOCATORS_DISTRIBUTOR_THREAD_NAME = "LocatorsDistributorThread";
+  private static final String LISTENER_FAILURE_MESSAGE =
+      "Locator Membership listener could not exchange locator information {}:{} with {}:{} after {} retry attempts";
+  private static final String LISTENER_FINAL_FAILURE_MESSAGE =
+      "Locator Membership listener permanently failed to exchange locator information {}:{} with {}:{} after {} retry attempts";
+  private DistributionConfig config;
+  private final TcpClient tcpClient;
+  private final ConcurrentMap<Integer, Set<String>> allServerLocatorsInfo =
+      new ConcurrentHashMap<>();
+  private final ConcurrentMap<Integer, Set<DistributionLocatorId>> allLocatorsInfo =
+      new ConcurrentHashMap<>();
-  public LocatorMembershipListenerImpl() {
+  LocatorMembershipListenerImpl() {
+  LocatorMembershipListenerImpl(TcpClient tcpClient) {
+    this.tcpClient = tcpClient;
+  }
+
+   * @param distributedSystemId Id of the joining locator.
+   * @param locator Id of the joining locator.
+   * @param sourceLocator Id of the locator that notified this locator about the new one.
-
-    Thread distributeLocator = new Thread(new Runnable() {
-      @Override
-      public void run() {
-        ConcurrentMap<Integer, Set<DistributionLocatorId>> remoteLocators = getAllLocatorsInfo();
-        ArrayList<DistributionLocatorId> locatorsToRemove = new ArrayList<DistributionLocatorId>();
+    // DistributionLocatorId for local locator.
+    DistributionLocatorId localLocatorId;
+    String localLocator = config.getStartLocator();
+    if (localLocator.equals(DistributionConfig.DEFAULT_START_LOCATOR)) {
+      localLocatorId = new DistributionLocatorId(port, config.getBindAddress());
+    } else {
+      localLocatorId = new DistributionLocatorId(localLocator);
+    }
-        String localLocator = config.getStartLocator();
-        DistributionLocatorId localLocatorId = null;
-        if (localLocator.equals(DistributionConfig.DEFAULT_START_LOCATOR)) {
-          localLocatorId = new DistributionLocatorId(port, config.getBindAddress());
-        } else {
-          localLocatorId = new DistributionLocatorId(localLocator);
-        }
-        locatorsToRemove.add(localLocatorId);
-        locatorsToRemove.add(locator);
-        locatorsToRemove.add(sourceLocator);
+    // Make a local copy of the current list of known locators.
+    ConcurrentMap<Integer, Set<DistributionLocatorId>> remoteLocators = getAllLocatorsInfo();
+    Map<Integer, Set<DistributionLocatorId>> localCopy = new HashMap<>();
+    for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : remoteLocators.entrySet()) {
+      Set<DistributionLocatorId> value = new CopyOnWriteHashSet<>(entry.getValue());
+      localCopy.put(entry.getKey(), value);
+    }
-        Map<Integer, Set<DistributionLocatorId>> localCopy =
-            new HashMap<Integer, Set<DistributionLocatorId>>();
-        for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : remoteLocators.entrySet()) {
-          Set<DistributionLocatorId> value =
-              new CopyOnWriteHashSet<DistributionLocatorId>(entry.getValue());
-          localCopy.put(entry.getKey(), value);
-        }
-        for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : localCopy.entrySet()) {
-          for (DistributionLocatorId removeLocId : locatorsToRemove) {
-            if (entry.getValue().contains(removeLocId)) {
-              entry.getValue().remove(removeLocId);
-            }
-          }
-          for (DistributionLocatorId value : entry.getValue()) {
-            try {
-              tcpClient.requestToServer(value.getHost(),
-                  new LocatorJoinMessage(distributedSystemId, locator, localLocatorId, ""), 1000,
-                  false);
-            } catch (Exception e) {
-              if (logger.isDebugEnabled()) {
-                logger.debug(
-                    "Locator Membership listener could not exchange locator information {}:{} with {}:{}",
-                    new Object[] {locator.getHostName(), locator.getPort(), value.getHostName(),
-                        value.getPort()});
-              }
-            }
-            try {
-              tcpClient.requestToServer(locator.getHost(),
-                  new LocatorJoinMessage(entry.getKey(), value, localLocatorId, ""), 1000, false);
-            } catch (Exception e) {
-              if (logger.isDebugEnabled()) {
-                logger.debug(
-                    "Locator Membership listener could not exchange locator information {}:{} with {}:{}",
-                    new Object[] {value.getHostName(), value.getPort(), locator.getHostName(),
-                        locator.getPort()});
-              }
-            }
-          }
-        }
+    // Remove locators that don't need to be notified (myself, the joining one and the one that
+    // notified myself).
+    List<DistributionLocatorId> ignoreList = Arrays.asList(locator, localLocatorId, sourceLocator);
+    for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : localCopy.entrySet()) {
+      for (DistributionLocatorId removeLocId : ignoreList) {
+        entry.getValue().remove(removeLocId);
-    });
-    distributeLocator.setDaemon(true);
-    distributeLocator.start();
+    }
+
+    // Launch Locators Distributor thread.
+    Runnable distributeLocatorsRunnable = new DistributeLocatorsRunnable(config.getMemberTimeout(),
+        tcpClient, localLocatorId, localCopy, locator, distributedSystemId);
+    ThreadFactory threadFactory =
+        new LoggingThreadFactory(LOCATORS_DISTRIBUTOR_THREAD_NAME, true);
+    Thread distributeLocatorsThread = threadFactory.newThread(distributeLocatorsRunnable);
+    distributeLocatorsThread.start();
+
+
+  @SuppressWarnings("unused")
+
+  private static class DistributeLocatorsRunnable implements Runnable {
+    private final int memberTimeout;
+    private final TcpClient tcpClient;
+    private final DistributionLocatorId localLocatorId;
+    private final Map<Integer, Set<DistributionLocatorId>> remoteLocators;
+    private final DistributionLocatorId joiningLocator;
+    private final int joiningLocatorDistributedSystemId;
+
+    DistributeLocatorsRunnable(int memberTimeout,
+        TcpClient tcpClient,
+        DistributionLocatorId localLocatorId,
+        Map<Integer, Set<DistributionLocatorId>> remoteLocators,
+        DistributionLocatorId joiningLocator,
+        int joiningLocatorDistributedSystemId) {
+
+      this.memberTimeout = memberTimeout;
+      this.tcpClient = tcpClient;
+      this.localLocatorId = localLocatorId;
+      this.remoteLocators = remoteLocators;
+      this.joiningLocator = joiningLocator;
+      this.joiningLocatorDistributedSystemId = joiningLocatorDistributedSystemId;
+    }
+
+    void sendMessage(DistributionLocatorId targetLocator, LocatorJoinMessage locatorJoinMessage,
+        Map<DistributionLocatorId, Set<LocatorJoinMessage>> failedMessages) {
+      DistributionLocatorId advertisedLocator = locatorJoinMessage.getLocator();
+
+      try {
+        tcpClient.requestToServer(targetLocator.getHost(), locatorJoinMessage, memberTimeout,
+            false);
+      } catch (Exception exception) {
+        if (logger.isDebugEnabled()) {
+          logger.debug(LISTENER_FAILURE_MESSAGE,
+              new Object[] {advertisedLocator.getHostName(), advertisedLocator.getPort(),
+                  targetLocator.getHostName(), targetLocator.getPort(), 1, exception});
+        }
+
+        if (!failedMessages.containsKey(targetLocator)) {
+          failedMessages.put(targetLocator, new HashSet<>());
+        }
+
+        failedMessages.get(targetLocator).add(locatorJoinMessage);
+      }
+    }
+
+    boolean retryMessage(DistributionLocatorId targetLocator, LocatorJoinMessage locatorJoinMessage,
+        int retryAttempt) {
+      DistributionLocatorId advertisedLocator = locatorJoinMessage.getLocator();
+
+      try {
+        tcpClient.requestToServer(targetLocator.getHost(), locatorJoinMessage, memberTimeout,
+            false);
+
+        return true;
+      } catch (Exception exception) {
+        if (retryAttempt == LOCATOR_DISTRIBUTION_RETRY_ATTEMPTS) {
+          logger.warn(LISTENER_FINAL_FAILURE_MESSAGE,
+              new Object[] {advertisedLocator.getHostName(), advertisedLocator.getPort(),
+                  targetLocator.getHostName(), targetLocator.getPort(), retryAttempt, exception});
+        } else {
+          if (logger.isDebugEnabled()) {
+            logger.debug(LISTENER_FAILURE_MESSAGE,
+                new Object[] {advertisedLocator.getHostName(), advertisedLocator.getPort(),
+                    targetLocator.getHostName(), targetLocator.getPort(), retryAttempt, exception});
+          }
+        }
+
+        return false;
+      }
+    }
+
+    @Override
+    public void run() {
+      Map<DistributionLocatorId, Set<LocatorJoinMessage>> failedMessages = new HashMap<>();
+      for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : remoteLocators.entrySet()) {
+        for (DistributionLocatorId value : entry.getValue()) {
+          // Notify known remote locator about the advertised locator.
+          LocatorJoinMessage advertiseNewLocatorMessage = new LocatorJoinMessage(
+              joiningLocatorDistributedSystemId, joiningLocator, localLocatorId, "");
+          sendMessage(value, advertiseNewLocatorMessage, failedMessages);
+
+          // Notify the advertised locator about remote known locator.
+          LocatorJoinMessage advertiseKnownLocatorMessage =
+              new LocatorJoinMessage(entry.getKey(), value, localLocatorId, "");
+          sendMessage(joiningLocator, advertiseKnownLocatorMessage, failedMessages);
+        }
+      }
+
+      // Retry failed messages and remove those that succeed.
+      if (!failedMessages.isEmpty()) {
+        for (int attempt = 1; attempt <= LOCATOR_DISTRIBUTION_RETRY_ATTEMPTS; attempt++) {
+
+          for (Map.Entry<DistributionLocatorId, Set<LocatorJoinMessage>> entry : failedMessages
+              .entrySet()) {
+            DistributionLocatorId targetLocator = entry.getKey();
+            Set<LocatorJoinMessage> joinMessages = entry.getValue();
+
+            for (LocatorJoinMessage locatorJoinMessage : joinMessages) {
+              if (retryMessage(targetLocator, locatorJoinMessage, attempt)) {
+                joinMessages.remove(locatorJoinMessage);
+              } else {
+                // Sleep between retries.
+                try {
+                  Thread.sleep(memberTimeout);
+                } catch (InterruptedException e) {
+                  Thread.currentThread().interrupt();
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }

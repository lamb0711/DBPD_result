GEODE-7256: Cleanup Connection classes and tests

* Minor cleanup of classes and tests

+import java.io.Closeable;
+import java.util.Collection;
-import java.util.Set;
-import org.apache.geode.distributed.internal.membership.gms.GMSMembership;
+import org.apache.geode.distributed.internal.membership.gms.api.MemberIdentifier;
- * <p>
- * </p>
-  /** warning when descriptor limit reached */
+  /**
+   * warning when descriptor limit reached
+   */
-  @MakeNotStatic
-  private static ThreadLocal threadWantsOwnResources = new ThreadLocal();
+  private static final ThreadLocal<Boolean> threadWantsOwnResources = new ThreadLocal<>();
-  protected final Map orderedConnectionMap = new ConcurrentHashMap();
+  private final Map orderedConnectionMap = new ConcurrentHashMap();
-  // ThreadLocal<Map>
-  protected final ThreadLocal<Map> threadOrderedConnMap;
+  static final ThreadLocal<Map> threadOrderedConnMap = new ThreadLocal<>();
-   * List of thread-owned ordered connection maps, for cleanup
-   *
-   * Accesses to the maps in this list need to be synchronized on their instance.
+   * List of thread-owned ordered connection maps, for cleanup. Accesses to the maps in this list
+   * need to be synchronized on their instance.
-   * Timer to kill idle threads
-   *
-   * guarded.By this
+   * Timer to kill idle threads. Guarded by this.
-  protected final Map unorderedConnectionMap = new ConcurrentHashMap();
+  private final Map unorderedConnectionMap = new ConcurrentHashMap();
-   * except for acks; only receive.
-   *
-   * Consists of a list of Connection
+   * except for acks; only receive. Consists of a list of Connection.
-  private volatile boolean closed = false;
+  private volatile boolean closed;
-      Long.getLong("p2p.READER_POOL_KEEP_ALIVE_TIME", 120).longValue();
+      Long.getLong("p2p.READER_POOL_KEEP_ALIVE_TIME", 120);
+   * <p>
-  private Map connectingSockets = new HashMap();
+  private final Map connectingSockets = new HashMap();
-  boolean threadOwnsResources() {
+  private boolean threadOwnsResources() {
-    return (Boolean) threadWantsOwnResources.get();
+    return threadWantsOwnResources.get();
+  public static ConnectionTable create(TCPConduit conduit) {
+    ConnectionTable ct = new ConnectionTable(conduit);
+    lastInstance.set(ct);
+    return ct;
+  }
-  private ConnectionTable(TCPConduit conduit) throws IOException {
-    this.owner = conduit;
-    this.idleConnTimer = (this.owner.idleConnectionTimeout != 0)
+  private ConnectionTable(TCPConduit conduit) {
+    owner = conduit;
+    idleConnTimer = owner.idleConnectionTimeout != 0
-    this.threadOrderedConnMap = new ThreadLocal();
-    this.threadConnMaps = new ArrayList();
-    this.threadConnectionMap = new ConcurrentHashMap();
-    this.p2pReaderThreadPool = createThreadPoolForIO(conduit.getDM().getSystem().isShareSockets());
-    this.socketCloser = new SocketCloser();
-    this.bufferPool = new BufferPool(owner.getStats());
+    threadConnMaps = new ArrayList();
+    threadConnectionMap = new ConcurrentHashMap();
+    p2pReaderThreadPool = createThreadPoolForIO(conduit.getDM().getSystem().isShareSockets());
+    socketCloser = new SocketCloser();
+    bufferPool = new BufferPool(owner.getStats());
-    } else {
-      return CoreLoggingExecutors.newThreadPoolWithSynchronousFeed("UnsharedP2PReader", 1,
-          Integer.MAX_VALUE, READER_POOL_KEEP_ALIVE_TIME);
+    return CoreLoggingExecutors.newThreadPoolWithSynchronousFeed("UnsharedP2PReader", 1,
+        Integer.MAX_VALUE, READER_POOL_KEEP_ALIVE_TIME);
-  protected void acceptConnection(Socket sock, PeerConnectionFactory peerConnectionFactory)
-      throws IOException, ConnectionException, InterruptedException {
-    InetAddress connAddress = sock.getInetAddress(); // for bug 44736
+  void acceptConnection(Socket sock, PeerConnectionFactory peerConnectionFactory)
+      throws IOException, ConnectionException {
+    InetAddress connAddress = sock.getInetAddress();
-    // boolean exceptionLogged = false;
-      this.owner.getCancelCriterion().checkCancelInProgress(null);
+      owner.getCancelCriterion().checkCancelInProgress(null);
-    } catch (IOException ex) {
+    } catch (ConnectionException | IOException ex) {
-      this.owner.getCancelCriterion().checkCancelInProgress(ex);
-      logger.warn(String.format("Failed to accept connection from %s because: %s",
-          new Object[] {(connAddress != null ? connAddress : "unavailable address"), ex}));
-      throw ex;
-    } catch (ConnectionException ex) {
-      // check for shutdown...
-      this.owner.getCancelCriterion().checkCancelInProgress(ex);
-      logger.warn(String.format("Failed to accept connection from %s because: %s",
-          new Object[] {(connAddress != null ? connAddress : "unavailable address"), ex}));
+      owner.getCancelCriterion().checkCancelInProgress(ex);
+      logger.warn("Failed to accept connection from {} because: {}",
+          connAddress != null ? connAddress : "unavailable address", ex);
-      // note: no need to call incFailedAccept here because it will be done
-      // in our caller.
+      // note: no need to call incFailedAccept here because it will be done in our caller.
-        closeCon("cancel after accept",
-            connection);
+        closeCon("cancel after accept", connection);
-      synchronized (this.receivers) {
-        this.owner.getStats().incReceivers();
-        if (this.closed) {
+      synchronized (receivers) {
+        owner.getStats().incReceivers();
+        if (closed) {
-          this.receivers.add(connection);
+          receivers.add(connection);
-            connection.remoteAddr);
+            connection.getRemoteAddress());
-
-
-      this.owner.getStats().incSenders(sharedResource, preserveOrder);
+      owner.getStats().incSenders(sharedResource, preserveOrder);
-        this.owner.getStats().incFailedConnect();
+        owner.getStats().incFailedConnect();
-    } // finally
+    }
-    // Update our list of connections -- either the
-    // orderedConnectionMap or unorderedConnectionMap
+    // Update our list of connections -- either the orderedConnectionMap or unorderedConnectionMap
-        // someone closed our pending connection
-        // so cleanup the connection we created
-        con.requestClose(
-            "pending connection cancelled");
+        // someone closed our pending connection so cleanup the connection we created
+        con.requestClose("pending connection cancelled");
-            // Fix for bug 31590
-            // someone closed our pending connect
-            // so cleanup the connection we created
+            // someone closed our pending connect so cleanup the connection we created
-              con.requestClose(
-                  "pending connection closed");
+              con.requestClose("pending connection closed");
-            // This should not happen. It means that someone else
-            // created the connection which should only happen if
-            // our Connection was rejected.
-            // Assert.assertTrue(false);
-            // The above assertion was commented out to try the
-            // following with bug 32680
+            // This should not happen. It means that someone else created the connection which
+            // should only happen if our Connection was rejected.
-          getConduit().getMemberId(), con.remoteAddr);
+          getConduit().getMemberId(), con.getRemoteAddress());
-    Connection result = null;
-    final Map m = preserveOrder ? this.orderedConnectionMap : this.unorderedConnectionMap;
+    final Map m = preserveOrder ? orderedConnectionMap : unorderedConnectionMap;
-    PendingConnection pc = null; // new connection, if needed
-    Object mEntry = null; // existing connection (if we don't create a new one)
+    // new connection, if needed
+    PendingConnection pc = null;
+
+    // existing connection (if we don't create a new one)
+    Object mEntry;
-      if (mEntry != null && (mEntry instanceof Connection)) {
+      if (mEntry instanceof Connection) {
-    } // synchronized
+    }
+    Connection result;
-      result = handleNewPendingConnection(id, true /* fixes bug 43386 */, preserveOrder, m, pc,
+      result = handleNewPendingConnection(id, true, preserveOrder, m, pc,
+
-        result = ((PendingConnection) mEntry).waitForConnect(this.owner.getMembership(),
+        result = ((PendingConnection) mEntry).waitForConnect(owner.getMembership(),
-                getConduit().getMemberId(), result.remoteAddr);
+                getConduit().getMemberId(), result.getRemoteAddress());
-    Map m = (Map) this.threadOrderedConnMap.get();
+    Map m = threadOrderedConnMap.get();
-      synchronized (this.threadConnMaps) {
-        if (this.closed) {
+      synchronized (threadConnMaps) {
+        if (closed) {
-          throw new DistributedSystemDisconnectedException(
-              "Connection table is closed");
+          throw new DistributedSystemDisconnectedException("Connection table is closed");
-        for (Iterator it = this.threadConnMaps.iterator(); it.hasNext();) {
+        for (Iterator it = threadConnMaps.iterator(); it.hasNext();) {
-        } // for
-        this.threadConnMaps.add(new WeakReference(m)); // ref added for bug 38011
-      } // synchronized
-      this.threadOrderedConnMap.set(m);
+        }
+        threadConnMaps.add(new WeakReference(m));
+      }
+      threadOrderedConnMap.set(m);
-    result = Connection.createSender(owner.getMembership(), this, true /* preserveOrder */,
-        id, false /* shared */, startTime, ackTimeout, ackSATimeout);
+    result = Connection.createSender(owner.getMembership(), this, true, id, false, startTime,
+        ackTimeout, ackSATimeout);
-    this.owner.getStats().incSenders(false/* shared */, true /* preserveOrder */);
+    owner.getStats().incSenders(false, true);
-      // fix for bug 43529
-    if (this.owner.idleConnectionTimeout != 0) {
+    if (owner.idleConnectionTimeout != 0) {
-          if (!this.closed) {
+          if (!closed) {
-            this.getIdleConnTimer().scheduleAtFixedRate(task, this.owner.idleConnectionTimeout,
-                this.owner.idleConnectionTimeout);
+            getIdleConnTimer().scheduleAtFixedRate(task, owner.idleConnectionTimeout,
+                owner.idleConnectionTimeout);
-          // bug #45077 - connection is closed before we schedule the timeout task,
+          // connection is closed before we schedule the timeout task,
-        // Unfortunately, cancelInProgress() is not set until *after*
-        // the shutdown message has been sent, so we need to check the
-        // "closeInProgress" bit instead.
+        // Unfortunately, cancelInProgress() is not set until *after* the shutdown message has been
+        // sent, so we need to check the "closeInProgress" bit instead.
-        throw new DistributedSystemDisconnectedException(
-            "The distributed system is shutting down",
+        throw new DistributedSystemDisconnectedException("The distributed system is shutting down",
-   * @throws java.io.IOException if the connection could not be created
+   * @throws IOException if the connection could not be created
-      throws java.io.IOException, DistributedSystemDisconnectedException {
-    if (this.closed) {
-      this.owner.getCancelCriterion().checkCancelInProgress(null);
-      throw new DistributedSystemDisconnectedException(
-          "Connection table is closed");
+      throws IOException, DistributedSystemDisconnectedException {
+    if (closed) {
+      owner.getCancelCriterion().checkCancelInProgress(null);
+      throw new DistributedSystemDisconnectedException("Connection table is closed");
-    Connection result = null;
+    Connection result;
-  protected synchronized void fileDescriptorsExhausted() {
+  synchronized void fileDescriptorsExhausted() {
-      threadWantsOwnResources = new ThreadLocal();
-  protected TCPConduit getConduit() {
+  TCPConduit getConduit() {
-  public BufferPool getBufferPool() {
+  BufferPool getBufferPool() {
-    return this.closed;
+    return closed;
-      ((Connection) c).closePartialConnect(reason, beingSick); // fix for bug 31666
+      ((Connection) c).closePartialConnect(reason, beingSick);
-  protected synchronized SystemTimer getIdleConnTimer() {
-    if (this.closed) {
+  synchronized SystemTimer getIdleConnTimer() {
+    if (closed) {
-    if (this.idleConnTimer == null) {
-      this.idleConnTimer = new SystemTimer(getDM().getSystem(), true);
+    if (idleConnTimer == null) {
+      idleConnTimer = new SystemTimer(getDM().getSystem(), true);
-    return this.idleConnTimer;
+    return idleConnTimer;
-    /*
-     * NOMUX if (inputMuxManager != null) { inputMuxManager.stop(); }
-     */
-    if (this.closed) {
+    if (closed) {
-    this.closed = true;
+    closed = true;
-      if (this.idleConnTimer != null) {
-        this.idleConnTimer.cancel();
+      if (idleConnTimer != null) {
+        idleConnTimer.cancel();
-    synchronized (this.orderedConnectionMap) {
-      for (Iterator it = this.orderedConnectionMap.values().iterator(); it.hasNext();) {
-        closeCon(
-            "Connection table being destroyed",
-            it.next());
+    synchronized (orderedConnectionMap) {
+      for (Object o : orderedConnectionMap.values()) {
+        closeCon("Connection table being destroyed", o);
-      this.orderedConnectionMap.clear();
+      orderedConnectionMap.clear();
-    synchronized (this.unorderedConnectionMap) {
-      for (Iterator it = this.unorderedConnectionMap.values().iterator(); it.hasNext();) {
-        closeCon(
-            "Connection table being destroyed",
-            it.next());
+    synchronized (unorderedConnectionMap) {
+      for (Object o : unorderedConnectionMap.values()) {
+        closeCon("Connection table being destroyed", o);
-      this.unorderedConnectionMap.clear();
+      unorderedConnectionMap.clear();
-    if (this.threadConnMaps != null) {
-      synchronized (this.threadConnMaps) {
-        for (Iterator it = this.threadConnMaps.iterator(); it.hasNext();) {
-          Reference r = (Reference) it.next();
-          Map m = (Map) r.get();
-          if (m != null) {
-            synchronized (m) {
-              for (Iterator mit = m.values().iterator(); mit.hasNext();) {
-                closeCon("Connection table being destroyed", mit.next());
+    if (threadConnMaps != null) {
+      synchronized (threadConnMaps) {
+        for (Object threadConnMap : threadConnMaps) {
+          Reference reference = (Reference) threadConnMap;
+          Map map = (Map) reference.get();
+          if (map != null) {
+            synchronized (map) {
+              for (Object o : map.values()) {
+                closeCon("Connection table being destroyed", o);
-        this.threadConnMaps.clear();
+        threadConnMaps.clear();
-    {
-      Executor localExec = this.p2pReaderThreadPool;
-      if (localExec != null) {
-        if (localExec instanceof ExecutorService) {
-          ((ExecutorService) localExec).shutdown();
-        }
+    Executor localExec = p2pReaderThreadPool;
+    if (localExec != null) {
+      if (localExec instanceof ExecutorService) {
+        ((ExecutorService) localExec).shutdown();
-    Map m = (Map) this.threadOrderedConnMap.get();
-    if (m != null) {
-      synchronized (m) {
-        m.clear();
+    Map map = threadOrderedConnMap.get();
+    if (map != null) {
+      synchronized (map) {
+        map.clear();
-    this.socketCloser.close();
+    socketCloser.close();
-    Executor local = this.p2pReaderThreadPool;
+    Executor local = p2pReaderThreadPool;
-  protected void closeReceivers(boolean beingSick) {
-    synchronized (this.receivers) {
-      for (Iterator it = this.receivers.iterator(); it.hasNext();) {
+  private void closeReceivers(boolean beingSick) {
+    synchronized (receivers) {
+      for (Iterator it = receivers.iterator(); it.hasNext();) {
-          closeCon(
-              "Connection table being destroyed",
-              con, beingSick);
+          closeCon("Connection table being destroyed", con, beingSick);
-          // ConnectingSocketInfo info = (ConnectingSocketInfo)entry.getValue();
-
-  protected void removeReceiver(Object con) {
-    synchronized (this.receivers) {
-      this.receivers.remove(con);
+  void removeReceiver(Object con) {
+    synchronized (receivers) {
+      receivers.remove(con);
-  /** remove an endpoint and notify the membership manager of the departure */
+
+  /**
+   * remove an endpoint and notify the membership manager of the departure
+   */
-  protected void removeEndpoint(DistributedMember memberID, String reason,
-      boolean notifyDisconnect) {
-    if (this.closed) {
+  void removeEndpoint(DistributedMember memberID, String reason, boolean notifyDisconnect) {
+    if (closed) {
-    synchronized (this.orderedConnectionMap) {
-      if (this.orderedConnectionMap.get(memberID) != null)
+    synchronized (orderedConnectionMap) {
+      if (orderedConnectionMap.get(memberID) != null)
-      synchronized (this.unorderedConnectionMap) {
-        if (this.unorderedConnectionMap.get(memberID) != null)
+      synchronized (unorderedConnectionMap) {
+        if (unorderedConnectionMap.get(memberID) != null)
-      ConcurrentMap cm = this.threadConnectionMap;
+      ConcurrentMap cm = threadConnectionMap;
-        ArrayList al = (ArrayList) cm.get(memberID);
-        needsRemoval = al != null && al.size() > 0;
+        List al = (ArrayList) cm.get(memberID);
+        needsRemoval = al != null && !al.isEmpty();
-      synchronized (this.orderedConnectionMap) {
-        Object c = this.orderedConnectionMap.remove(memberID);
+      synchronized (orderedConnectionMap) {
+        Object c = orderedConnectionMap.remove(memberID);
-      synchronized (this.unorderedConnectionMap) {
-        Object c = this.unorderedConnectionMap.remove(memberID);
-        if (remoteAddress == null && (c instanceof Connection)) {
+      synchronized (unorderedConnectionMap) {
+        Object c = unorderedConnectionMap.remove(memberID);
+        if (remoteAddress == null && c instanceof Connection) {
-      {
-        ConcurrentMap cm = this.threadConnectionMap;
-        if (cm != null) {
-          ArrayList al = (ArrayList) cm.remove(memberID);
-          if (al != null) {
-            synchronized (al) {
-              for (Iterator it = al.iterator(); it.hasNext();) {
-                Object c = it.next();
-                if (remoteAddress == null && (c instanceof Connection)) {
-                  remoteAddress = ((Connection) c).getRemoteAddress();
-                }
-                closeCon(reason, c);
+      ConcurrentMap cm = threadConnectionMap;
+      if (cm != null) {
+        List al = (ArrayList) cm.remove(memberID);
+        if (al != null) {
+          synchronized (al) {
+            for (Object c : al) {
+              if (remoteAddress == null && c instanceof Connection) {
+                remoteAddress = ((Connection) c).getRemoteAddress();
-              al.clear();
+              closeCon(reason, c);
+            al.clear();
-      Set toRemove = new HashSet();
+      Collection toRemove = new HashSet();
-          if (info.peerAddress.equals(((InternalDistributedMember) memberID).getInetAddress())) {
+          if (info.peerAddress.equals(((MemberIdentifier) memberID).getInetAddress())) {
-      for (Iterator it = toRemove.iterator(); it.hasNext();) {
-        Socket sock = (Socket) it.next();
+
+      for (Object o : toRemove) {
+        Closeable sock = (Socket) o;
-      // avoid deadlock when a NIC has failed by closing connections outside
-      // of the receivers sync (bug 38731)
+      // avoid deadlock when a NIC has failed by closing connections outside of the receivers sync
-      synchronized (this.receivers) {
+      synchronized (receivers) {
-      for (Iterator it = toRemove.iterator(); it.hasNext();) {
-        Connection con = (Connection) it.next();
+      for (Object o : toRemove) {
+        Connection con = (Connection) o;
-        this.socketCloser.releaseResourcesForAddress(remoteAddress.toString());
+        socketCloser.releaseResourcesForAddress(remoteAddress.toString());
-    return this.socketCloser;
+    return socketCloser;
-  protected boolean hasReceiversFor(DistributedMember endPoint) {
-    synchronized (this.receivers) {
-      for (Iterator it = receivers.iterator(); it.hasNext();) {
-        Connection con = (Connection) it.next();
+  boolean hasReceiversFor(DistributedMember endPoint) {
+    synchronized (receivers) {
+      for (Object receiver : receivers) {
+        Connection con = (Connection) receiver;
-      ArrayList al = (ArrayList) cm.get(stub);
+      List al = (ArrayList) cm.get(stub);
-  protected void removeThreadConnection(DistributedMember stub, Connection c) {
-    /*
-     * if (this.closed) { return; }
-     */
-    removeFromThreadConMap(this.threadConnectionMap, stub, c);
-    Map m = (Map) this.threadOrderedConnMap.get();
+  void removeThreadConnection(DistributedMember stub, Connection c) {
+    removeFromThreadConMap(threadConnectionMap, stub, c);
+    Map m = threadOrderedConnMap.get();
-      } // synchronized
-    } // m != null
+      }
+    }
-    if (this.closed) {
+    if (closed) {
-      synchronized (this.orderedConnectionMap) {
-        if (this.orderedConnectionMap.get(stub) == c) {
-          closeCon(reason, this.orderedConnectionMap.remove(stub));
+      synchronized (orderedConnectionMap) {
+        if (orderedConnectionMap.get(stub) == c) {
+          closeCon(reason, orderedConnectionMap.remove(stub));
-      synchronized (this.unorderedConnectionMap) {
-        if (this.unorderedConnectionMap.get(stub) == c) {
-          closeCon(reason, this.unorderedConnectionMap.remove(stub));
+      synchronized (unorderedConnectionMap) {
+        if (unorderedConnectionMap.get(stub) == c) {
+          closeCon(reason, unorderedConnectionMap.remove(stub));
-  public void removeAndCloseThreadOwnedSockets() {
-    Map m = (Map) this.threadOrderedConnMap.get();
+  void removeAndCloseThreadOwnedSockets() {
+    Map m = threadOrderedConnMap.get();
-          removeFromThreadConMap(this.threadConnectionMap, stub, c);
+          removeFromThreadConMap(threadConnectionMap, stub, c);
-        } // while
-      } // synchronized m
+        }
+      }
-    // lastInstance = null;
-  protected void getThreadOwnedOrderedConnectionState(DistributedMember member, Map result) {
-
-    ConcurrentMap cm = this.threadConnectionMap;
+  void getThreadOwnedOrderedConnectionState(DistributedMember member, Map result) {
+    ConcurrentMap cm = threadConnectionMap;
-        for (Iterator it = al.iterator(); it.hasNext();) {
-          Connection conn = (Connection) it.next();
+        for (Object o : al) {
+          Connection conn = (Connection) o;
-            result.put(Long.valueOf(conn.getUniqueId()), Long.valueOf(conn.getMessagesSent()));
+            result.put(conn.getUniqueId(), conn.getMessagesSent());
-  protected void waitForThreadOwnedOrderedConnectionState(DistributedMember member,
-      Map connectionStates) throws InterruptedException {
-    if (Thread.interrupted())
-      throw new InterruptedException(); // wisest to do this before the synchronize below
-    List r = null;
+  void waitForThreadOwnedOrderedConnectionState(DistributedMember member, Map connectionStates)
+      throws InterruptedException {
+    if (Thread.interrupted()) {
+      // wisest to do this before the synchronize below
+      throw new InterruptedException();
+    }
+    List r;
-    for (Iterator it = r.iterator(); it.hasNext();) {
-      Connection con = (Connection) it.next();
+    for (Object o : r) {
+      Connection con = (Connection) o;
-        Long state = (Long) connectionStates.remove(Long.valueOf(con.getUniqueId()));
+        Long state = (Long) connectionStates.remove(con.getUniqueId());
-          long count = state.longValue();
+          long count = state;
-    if (connectionStates.size() > 0) {
+    if (!connectionStates.isEmpty()) {
-    return this.owner.getDM();
+    return owner.getDM();
-  // public boolean isShuttingDown() {
-  // return this.owner.isShuttingDown();
-  // }
+  /** keep track of a socket that is trying to connect() for shutdown purposes */
+  void addConnectingSocket(Socket socket, InetAddress addr) {
+    synchronized (connectingSockets) {
+      connectingSockets.put(socket, new ConnectingSocketInfo(addr));
+    }
+  }
-  // protected void cleanupHighWater() {
-  // cleanup(highWater);
-  // }
+  /** remove a socket from the tracked set. It should be connected at this point */
+  void removeConnectingSocket(Socket socket) {
+    synchronized (connectingSockets) {
+      connectingSockets.remove(socket);
+    }
+  }
-  // protected void cleanupLowWater() {
-  // cleanup(lowWater);
-  // }
+  int getNumberOfReceivers() {
+    return receivers.size();
+  }
-  // private void cleanup(int maxConnections) {
-  /*
-   * if (maxConnections == 0 || maxConnections >= connections.size()) { return; } while
-   * (connections.size() > maxConnections) { Connection oldest = null; synchronized(connections) {
-   * for (Iterator iter = connections.values().iterator(); iter.hasNext(); ) { Connection c =
-   * (Connection)iter.next(); if (oldest == null || c.getTimeStamp() < oldest.getTimeStamp()) {
-   * oldest = c; } } } // sanity check - don't close anything fresher than 10 seconds or // we'll
-   * start thrashing if (oldest.getTimeStamp() > (System.currentTimeMillis() - 10000)) { if
-   * (owner.lowWaterConnectionCount > 0) { owner.lowWaterConnectionCount += 10; } if
-   * (owner.highWaterConnectionCount > 0) { owner.highWaterConnectionCount += 10; } new Object[] {
-   * owner.lowWaterConnectionCount, owner.highWaterConnectionCount }); break; } if (oldest != null)
-   * { oldest.close(); } }
-   */
-  // }
+  private class PendingConnection {
-  /*
-   * public void dumpConnectionTable() { Iterator iter = connectionMap.keySet().iterator(); while
-   * (iter.hasNext()) { Object key = iter.next(); Object val = connectionMap.get(key); } }
-   */
-  private /* static */ class PendingConnection {
-    private Connection conn = null;
+    private Connection conn;
-    public PendingConnection(boolean preserveOrder, DistributedMember id) {
+    private PendingConnection(boolean preserveOrder, DistributedMember id) {
-      this.connectingThread = Thread.currentThread();
+      connectingThread = Thread.currentThread();
-    public synchronized void notifyWaiters(Connection c) {
-      if (!this.pending)
-        return; // already done.
+    private synchronized void notifyWaiters(Connection c) {
+      if (!pending) {
+        return;
+      }
-      this.conn = c;
-      this.pending = false;
+      conn = c;
+      pending = false;
-            ((this.preserveOrder) ? "ordered" : "unordered"), this.id, this);
+            preserveOrder ? "ordered" : "unordered", id, this);
-      this.notifyAll();
+      notifyAll();
-    public synchronized Connection waitForConnect(Membership mgr, long startTime,
-        long ackTimeout, long ackSATimeout) throws IOException {
+    private synchronized Connection waitForConnect(Membership mgr, long startTime, long ackTimeout,
+        long ackSATimeout) {
-      final Map m = this.preserveOrder ? orderedConnectionMap : unorderedConnectionMap;
+      final Map m = preserveOrder ? orderedConnectionMap : unorderedConnectionMap;
-      boolean severeAlertIssued = false;
-      boolean suspected = false;
-        targetMember = this.id;
+        targetMember = id;
-      int attempt = 0;
-      for (;;) {
-        if (!this.pending) {
+      boolean suspected = false;
+      boolean severeAlertIssued = false;
+      for (int attempt = 0;;) {
+        if (!pending) {
-          this.wait(100); // spurious wakeup ok
+          wait(100);
-        if (!this.pending)
+        if (!pending) {
+        }
-                this.id, (ackTimeout) / 1000);
-            ((GMSMembership) mgr).suspectMember((InternalDistributedMember) targetMember,
+                id, ackTimeout / 1000);
+            mgr.suspectMember((InternalDistributedMember) targetMember,
-        Object e;
-        // synchronized (m) {
-        e = m.get(this.id);
-        // }
+        Object e = m.get(id);
-          if (logger.isDebugEnabled() && (attempt % 20 == 1)) {
+          if (logger.isDebugEnabled() && attempt % 20 == 1) {
-                ((this.preserveOrder) ? "ordered" : "unordered"), this.id, this);
+                preserveOrder ? "ordered" : "unordered", id, this);
-        } else if (e instanceof Connection) {
+        }
+        if (e instanceof Connection) {
-        } else {
-          // defer to the new instance
-          return ((PendingConnection) e).waitForConnect(mgr, startTime, ackTimeout, ackSATimeout);
+        // defer to the new instance
+        return ((PendingConnection) e).waitForConnect(mgr, startTime, ackTimeout, ackSATimeout);
-      } // for
-      return this.conn;
-
+      }
+      return conn;
-
-    IdleConnTT(Connection c) {
+    private IdleConnTT(Connection c) {
-      Connection con = this.c;
+      Connection con = c;
-      this.c = null;
+      c = null;
-      Connection con = this.c;
+      Connection con = c;
-  public static ConnectionTable create(TCPConduit conduit) throws IOException {
-    ConnectionTable ct = new ConnectionTable(conduit);
-    lastInstance.set(ct);
-    return ct;
-  }
-
-  /** keep track of a socket that is trying to connect() for shutdown purposes */
-  public void addConnectingSocket(Socket socket, InetAddress addr) {
-    synchronized (connectingSockets) {
-      connectingSockets.put(socket, new ConnectingSocketInfo(addr));
-    }
-  }
-
-  /** remove a socket from the tracked set. It should be connected at this point */
-  public void removeConnectingSocket(Socket socket) {
-    synchronized (connectingSockets) {
-      connectingSockets.remove(socket);
-    }
-  }
-
-
-    InetAddress peerAddress;
-    Thread connectingThread;
-    public ConnectingSocketInfo(InetAddress addr) {
-      this.peerAddress = addr;
-      this.connectingThread = Thread.currentThread();
+    private final InetAddress peerAddress;
+
+    private ConnectingSocketInfo(InetAddress addr) {
+      peerAddress = addr;
-
-  public int getNumberOfReceivers() {
-    return receivers.size();
-  }

GEODE-4009: add jdbc connection pooling (#1213)

* The HikariCP datasource implementation is used for connection pooling.
* removed prepared statement caching
* close is now called for all connections, statements, and result sets.
* renamed ConnectionManager to DataSourceManager
* renamed JdbcConnectorService to JdbcConnectorServiceImpl
* renamed InternalJdbcConnectorService to JdbcConnectorService

+import java.sql.Connection;
+import java.util.ArrayList;
+import java.util.Collections;
-  private ConnectionManager manager;
+  private final JdbcConnectorService configService;
+  private final DataSourceManager manager;
+  private final TableKeyColumnManager tableKeyColumnManager;
-  public SqlHandler(ConnectionManager manager) {
+  public SqlHandler(DataSourceManager manager, JdbcConnectorService configService) {
+    this(manager, new TableKeyColumnManager(), configService);
+  }
+
+  SqlHandler(DataSourceManager manager, TableKeyColumnManager tableKeyColumnManager,
+      JdbcConnectorService configService) {
+    this.tableKeyColumnManager = tableKeyColumnManager;
+    this.configService = configService;
+  Connection getConnection(ConnectionConfiguration config) {
+    try {
+      return manager.getDataSource(config).getConnection();
+    } catch (SQLException e) {
+      throw new IllegalStateException("Could not connect to " + config.getUrl(), e);
+    }
+  }
+
-    RegionMapping regionMapping = manager.getMappingForRegion(region.getName());
+    RegionMapping regionMapping = getMappingForRegion(region.getName());
-        manager.getConnectionConfig(regionMapping.getConnectionConfigName());
-
-    List<ColumnValue> columnList =
-        manager.getColumnToValueList(connectionConfig, regionMapping, key, null, Operation.GET);
+        getConnectionConfig(regionMapping.getConnectionConfigName());
-    PreparedStatement statement = manager.getPreparedStatement(
-        manager.getConnection(connectionConfig), columnList, tableName, Operation.GET, 0);
-    PdxInstanceFactory factory = getPdxInstanceFactory(region, regionMapping);
-    String keyColumnName = manager.getKeyColumnName(connectionConfig, tableName);
-    return executeReadStatement(statement, columnList, factory, regionMapping, keyColumnName);
+    PdxInstance result = null;
+    try (Connection connection = getConnection(connectionConfig)) {
+      List<ColumnValue> columnList =
+          getColumnToValueList(connection, regionMapping, key, null, Operation.GET);
+      try (PreparedStatement statement =
+          getPreparedStatement(connection, columnList, tableName, Operation.GET, 0)) {
+        PdxInstanceFactory factory = getPdxInstanceFactory(region, regionMapping);
+        String keyColumnName = getKeyColumnName(connection, tableName);
+        result = executeReadStatement(statement, columnList, factory, regionMapping, keyColumnName);
+      }
+    } catch (SQLException e) {
+      handleSQLException(e);
+    }
+    return result;
+  }
+
+  private RegionMapping getMappingForRegion(String regionName) {
+    RegionMapping regionMapping = this.configService.getMappingForRegion(regionName);
+    if (regionMapping == null) {
+      throw new IllegalStateException("JDBC mapping for region " + regionName
+          + " not found. Create the mapping with the gfsh command 'create jdbc-mapping'.");
+    }
+    return regionMapping;
+  }
+
+  private ConnectionConfiguration getConnectionConfig(String connectionConfigName) {
+    ConnectionConfiguration connectionConfig =
+        this.configService.getConnectionConfig(connectionConfigName);
+    if (connectionConfig == null) {
+      throw new IllegalStateException("JDBC connection with name " + connectionConfigName
+          + " not found. Create the connection with the gfsh command 'create jdbc-connection'");
+    }
+    return connectionConfig;
+  }
+
+  private String getKeyColumnName(Connection connection, String tableName) {
+    return this.tableKeyColumnManager.getKeyColumnName(connection, tableName);
-    synchronized (statement) {
-      try {
-        setValuesInStatement(statement, columnList);
-        ResultSet resultSet = statement.executeQuery();
+    try {
+      setValuesInStatement(statement, columnList);
+      try (ResultSet resultSet = statement.executeQuery()) {
-
-      } catch (SQLException e) {
-        handleSQLException(e);
-      } finally {
-        clearStatementParameters(statement);
+    } catch (SQLException e) {
+      handleSQLException(e);
-    RegionMapping regionMapping = manager.getMappingForRegion(region.getName());
-
-    if (regionMapping == null) {
-      throw new IllegalStateException(
-          "JDBC write failed. JDBC mapping for region " + region.getFullPath()
-              + " not found. Create the mapping with the gfsh command 'create jdbc-mapping'.");
-    }
+    RegionMapping regionMapping = getMappingForRegion(region.getName());
-        manager.getConnectionConfig(regionMapping.getConnectionConfigName());
-    if (connectionConfig == null) {
-      throw new IllegalStateException(
-          "JDBC write failed. JDBC connection with name " + regionMapping.getConnectionConfigName()
-              + " not found. Create the connection with the gfsh command 'create jdbc-connection'");
-    }
-
-    List<ColumnValue> columnList =
-        manager.getColumnToValueList(connectionConfig, regionMapping, key, value, operation);
+        getConnectionConfig(regionMapping.getConnectionConfigName());
-    PreparedStatement statement = manager.getPreparedStatement(
-        manager.getConnection(connectionConfig), columnList, tableName, operation, pdxTypeId);
-    int updateCount = executeWriteStatement(statement, columnList, operation, false);
-    // Destroy action not guaranteed to modify any database rows
-    if (operation.isDestroy()) {
-      return;
-    }
+    try (Connection connection = getConnection(connectionConfig)) {
+      List<ColumnValue> columnList =
+          getColumnToValueList(connection, regionMapping, key, value, operation);
+      int updateCount = 0;
+      try (PreparedStatement statement =
+          getPreparedStatement(connection, columnList, tableName, operation, pdxTypeId)) {
+        updateCount = executeWriteStatement(statement, columnList, operation, false);
+      }
-    if (updateCount <= 0) {
-      Operation upsertOp = getOppositeOperation(operation);
-      PreparedStatement upsertStatement = manager.getPreparedStatement(
-          manager.getConnection(connectionConfig), columnList, tableName, upsertOp, pdxTypeId);
-      updateCount = executeWriteStatement(upsertStatement, columnList, upsertOp, true);
-    }
+      // Destroy action not guaranteed to modify any database rows
+      if (operation.isDestroy()) {
+        return;
+      }
-    if (updateCount != 1) {
-      throw new IllegalStateException("Unexpected updateCount " + updateCount);
+      if (updateCount <= 0) {
+        Operation upsertOp = getOppositeOperation(operation);
+        try (PreparedStatement upsertStatement =
+            getPreparedStatement(connection, columnList, tableName, upsertOp, pdxTypeId)) {
+          updateCount = executeWriteStatement(upsertStatement, columnList, upsertOp, true);
+        }
+      }
+
+      if (updateCount != 1) {
+        throw new IllegalStateException("Unexpected updateCount " + updateCount);
+      }
+    } catch (SQLException e) {
+      handleSQLException(e);
-    synchronized (statement) {
-      try {
-        setValuesInStatement(statement, columnList);
-        updateCount = statement.executeUpdate();
-      } catch (SQLException e) {
-        if (handleException || operation.isDestroy()) {
-          handleSQLException(e);
-        }
-      } finally {
-        clearStatementParameters(statement);
+    try {
+      setValuesInStatement(statement, columnList);
+      updateCount = statement.executeUpdate();
+    } catch (SQLException e) {
+      if (handleException || operation.isDestroy()) {
+        handleSQLException(e);
-  private void clearStatementParameters(PreparedStatement statement) {
+  private PreparedStatement getPreparedStatement(Connection connection,
+      List<ColumnValue> columnList, String tableName, Operation operation, int pdxTypeId) {
+    String sqlStr = getSqlString(tableName, columnList, operation);
+    PreparedStatement statement = null;
-      statement.clearParameters();
-    } catch (SQLException ignore) {
+      statement = connection.prepareStatement(sqlStr);
+    } catch (SQLException e) {
+      handleSQLException(e);
+    }
+    return statement;
+  }
+
+  private String getSqlString(String tableName, List<ColumnValue> columnList, Operation operation) {
+    SqlStatementFactory statementFactory = new SqlStatementFactory();
+    if (operation.isCreate()) {
+      return statementFactory.createInsertSqlString(tableName, columnList);
+    } else if (operation.isUpdate()) {
+      return statementFactory.createUpdateSqlString(tableName, columnList);
+    } else if (operation.isDestroy()) {
+      return statementFactory.createDestroySqlString(tableName, columnList);
+    } else if (operation.isGet()) {
+      return statementFactory.createSelectQueryString(tableName, columnList);
+    } else {
+      throw new IllegalArgumentException("unsupported operation " + operation);
-  private void handleSQLException(SQLException e) {
-    throw new IllegalStateException("NYI: handleSQLException", e);
+  <K> List<ColumnValue> getColumnToValueList(Connection connection, RegionMapping regionMapping,
+      K key, PdxInstance value, Operation operation) {
+    String tableName = regionMapping.getRegionToTableName();
+    String keyColumnName = getKeyColumnName(connection, tableName);
+    ColumnValue keyColumnValue = new ColumnValue(true, keyColumnName, key);
+
+    if (operation.isDestroy() || operation.isGet()) {
+      return Collections.singletonList(keyColumnValue);
+    }
+
+    List<ColumnValue> result = createColumnValueList(regionMapping, value, keyColumnName);
+    result.add(keyColumnValue);
+    return result;
+  }
+
+  private List<ColumnValue> createColumnValueList(RegionMapping regionMapping, PdxInstance value,
+      String keyColumnName) {
+    List<ColumnValue> result = new ArrayList<>();
+    for (String fieldName : value.getFieldNames()) {
+      String columnName = regionMapping.getColumnNameForField(fieldName);
+      if (columnName.equalsIgnoreCase(keyColumnName)) {
+        continue;
+      }
+      ColumnValue columnValue = new ColumnValue(false, columnName, value.getField(fieldName));
+      result.add(columnValue);
+    }
+    return result;
+  }
+
+  static void handleSQLException(SQLException e) {
+    throw new IllegalStateException("JDBC connector detected unexpected SQLException", e);

 GEODE-5376: Remove SynchronizationRunnable (#2122)


  Remove TXSynchronizationRunnable to handle JTA beforeCompletion and afterCompletion can be executed on different member after client failover.



+import org.apache.geode.InternalGemFireError;
+import org.apache.geode.cache.FailedSynchronizationException;
+import org.apache.geode.cache.TransactionException;
+  // Access this variable should be in synchronized block.
+  private boolean beforeCompletionCalled;
-  public void beforeCompletion() throws SynchronizationCommitConflictException {
+  public synchronized void beforeCompletion() throws SynchronizationCommitConflictException {
-    this.proxy.getTxMgr().setTXState(null);
+    if (beforeCompletionCalled) {
+      // do not re-execute beforeCompletion again
+      return;
+    }
+    beforeCompletionCalled = true;
+    doBeforeCompletion();
+  }
+
+  private void doBeforeCompletion() {
-
-
-      this.proxy.getTxMgr().noteCommitFailure(opStart, this.jtaLifeTime, this);
+      proxy.getTxMgr().noteCommitFailure(opStart, this.jtaLifeTime, this);
-  public void afterCompletion(int status) {
-    // System.err.println("start afterCompletion");
-    final long opStart = CachePerfStats.getStatTime();
-    switch (status) {
-      case Status.STATUS_COMMITTED:
-        // System.err.println("begin commit in afterCompletion");
-        Assert.assertTrue(this.locks != null,
-            "Gemfire Transaction afterCompletion called with illegal state.");
-        try {
-          proxy.getTxMgr().setTXState(null);
-          commit();
-          saveTXCommitMessageForClientFailover();
-        } catch (CommitConflictException error) {
-          Assert.assertTrue(false, "Gemfire Transaction " + getTransactionId()
-              + " afterCompletion failed.due to CommitConflictException: " + error);
-        }
-
-        this.proxy.getTxMgr().noteCommitSuccess(opStart, this.jtaLifeTime, this);
-        this.locks = null;
-        // System.err.println("end commit in afterCompletion");
-        break;
-      case Status.STATUS_ROLLEDBACK:
-        this.jtaLifeTime = opStart - getBeginTime();
-        this.proxy.getTxMgr().setTXState(null);
-        rollback();
-        saveTXCommitMessageForClientFailover();
-        this.proxy.getTxMgr().noteRollbackSuccess(opStart, this.jtaLifeTime, this);
-        break;
-      default:
-        Assert.assertTrue(false, "Unknown JTA Synchronization status " + status);
+  public synchronized void afterCompletion(int status) {
+    this.proxy.getTxMgr().setTXState(null);
+    // For commit, beforeCompletion should be called. Otherwise
+    // throw FailedSynchronizationException().
+    if (wasBeforeCompletionCalled()) {
+      doAfterCompletion(status);
+    } else {
+      // rollback does not run beforeCompletion.
+      if (status != Status.STATUS_ROLLEDBACK) {
+        throw new FailedSynchronizationException(
+            "Could not execute afterCompletion when beforeCompletion was not executed");
+      }
+      doAfterCompletion(status);
-    // System.err.println("end afterCompletion");
-  private void saveTXCommitMessageForClientFailover() {
+  private void doAfterCompletion(int status) {
+    final long opStart = CachePerfStats.getStatTime();
+    try {
+      switch (status) {
+        case Status.STATUS_COMMITTED:
+          Assert.assertTrue(this.locks != null,
+              "Gemfire Transaction afterCompletion called with illegal state.");
+          try {
+            commit();
+            saveTXCommitMessageForClientFailover();
+          } catch (CommitConflictException error) {
+            Assert.assertTrue(false, "Gemfire Transaction " + getTransactionId()
+                + " afterCompletion failed.due to CommitConflictException: " + error);
+          }
+
+          this.proxy.getTxMgr().noteCommitSuccess(opStart, this.jtaLifeTime, this);
+          this.locks = null;
+          break;
+        case Status.STATUS_ROLLEDBACK:
+          this.jtaLifeTime = opStart - getBeginTime();
+          rollback();
+          saveTXCommitMessageForClientFailover();
+          this.proxy.getTxMgr().noteRollbackSuccess(opStart, this.jtaLifeTime, this);
+          break;
+        default:
+          Assert.assertTrue(false, "Unknown JTA Synchronization status " + status);
+      }
+    } catch (InternalGemFireError error) {
+      throw new TransactionException(error);
+    }
+  }
+
+  boolean wasBeforeCompletionCalled() {
+    return beforeCompletionCalled;
+  }
+
+  void saveTXCommitMessageForClientFailover() {

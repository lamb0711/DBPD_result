GEODE-982: refactor off-heap

- removed unused MemoryChunk implementations
- collapsed OffHeapCacheDeserializable into StoredObject
- Added Slab, SlabFactory, SlabImpl, and AddressableMemoryManager.
- collapsed MemoryChunkWithRefCount into StoredObject
- methods that access and modify the data now have Data in their name
- collapsed AddressableStoredObject into StoredObject
- changed product code to use the StoredObject interface
  instead of internal class implementations of it
- renamed DataAsAddress to TinyStoredObject
- renamed ObjectChunk to OffHeapStoredObject
- renamed ObjectChunkWithHeapForm to OffHeapStoredObjectWithHeapForm
- renamed allocateChunk to allocateOffHeapStoredObject
- renamed FakeChunk to SearchMarker
- renamed ObjectChunkSlice to OffHeapStoredObjectSlice
- renamed SyncChunkStack to OffHeapStoredObjectAddressStack
- renamed ChunkValueWrapper to OffHeapValueWrapper

-  private final AddressableMemoryChunk[] slabs;
+  private final Slab[] slabs;
-  final private AtomicReferenceArray<SyncChunkStack> tinyFreeLists = new AtomicReferenceArray<SyncChunkStack>(TINY_FREE_LIST_COUNT);
+  final private AtomicReferenceArray<OffHeapStoredObjectAddressStack> tinyFreeLists = new AtomicReferenceArray<OffHeapStoredObjectAddressStack>(TINY_FREE_LIST_COUNT);
-  private final ConcurrentSkipListSet<ObjectChunk> hugeChunkSet = new ConcurrentSkipListSet<ObjectChunk>();
+  private final ConcurrentSkipListSet<OffHeapStoredObject> hugeChunkSet = new ConcurrentSkipListSet<OffHeapStoredObject>();
-  List<ObjectChunk> getLiveChunks() {
-    ArrayList<ObjectChunk> result = new ArrayList<ObjectChunk>();
+  List<OffHeapStoredObject> getLiveChunks() {
+    ArrayList<OffHeapStoredObject> result = new ArrayList<OffHeapStoredObject>();
-  private void getLiveChunks(AddressableMemoryChunk slab, List<ObjectChunk> result) {
+  private void getLiveChunks(Slab slab, List<OffHeapStoredObject> result) {
-    while (addr <= (slab.getMemoryAddress() + slab.getSize() - ObjectChunk.MIN_CHUNK_SIZE)) {
+    while (addr <= (slab.getMemoryAddress() + slab.getSize() - OffHeapStoredObject.MIN_CHUNK_SIZE)) {
-        addr = f.getMemoryAddress() + f.getSize();
+        addr = f.getAddress() + f.getSize();
-        int curChunkSize = ObjectChunk.getSize(addr);
-        int refCount = ObjectChunk.getRefCount(addr);
+        int curChunkSize = OffHeapStoredObject.getSize(addr);
+        int refCount = OffHeapStoredObject.getRefCount(addr);
-          result.add(new ObjectChunk(addr));
+          result.add(new OffHeapStoredObject(addr));
-      if (addr >= (f.getMemoryAddress() + f.getFreeIndex()) && addr < (f.getMemoryAddress() + f.getSize())) {
+      if (addr >= (f.getAddress() + f.getFreeIndex()) && addr < (f.getAddress() + f.getSize())) {
-      if (freeSpace >= ObjectChunk.MIN_CHUNK_SIZE) {
+      if (freeSpace >= OffHeapStoredObject.MIN_CHUNK_SIZE) {
-      SyncChunkStack cl = this.tinyFreeLists.get(i);
+      OffHeapStoredObjectAddressStack cl = this.tinyFreeLists.get(i);
-    for (ObjectChunk c: this.hugeChunkSet) {
+    for (OffHeapStoredObject c: this.hugeChunkSet) {
-  public FreeListManager(SimpleMemoryAllocatorImpl ma, final AddressableMemoryChunk[] slabs) {
+  public FreeListManager(SimpleMemoryAllocatorImpl ma, final Slab[] slabs) {
-  public ObjectChunk allocate(int size) {
+  public OffHeapStoredObject allocate(int size) {
-    ObjectChunk result = basicAllocate(size, true);
+    OffHeapStoredObject result = basicAllocate(size, true);
-  private ObjectChunk basicAllocate(int size, boolean useSlabs) {
+  private OffHeapStoredObject basicAllocate(int size, boolean useSlabs) {
-      size += ObjectChunk.OFF_HEAP_HEADER_SIZE;
+      size += OffHeapStoredObject.HEADER_SIZE;
-  private ObjectChunk allocateFromFragments(int chunkSize) {
+  private OffHeapStoredObject allocateFromFragments(int chunkSize) {
-        ObjectChunk result = allocateFromFragment(i, chunkSize);
+        OffHeapStoredObject result = allocateFromFragment(i, chunkSize);
-        ObjectChunk result = allocateFromFragment(i, chunkSize);
+        OffHeapStoredObject result = allocateFromFragment(i, chunkSize);
-    for (ObjectChunk c: this.hugeChunkSet) {
+    for (OffHeapStoredObject c: this.hugeChunkSet) {
-      SyncChunkStack cl = this.tinyFreeLists.get(i);
+      OffHeapStoredObjectAddressStack cl = this.tinyFreeLists.get(i);
-        lw.info("Fragment at " + f.getMemoryAddress() + " of size " + f.getSize() + " has " + freeSpace + " bytes free.");
+        lw.info("Fragment at " + f.getAddress() + " of size " + f.getSize() + " has " + freeSpace + " bytes free.");
-        ArrayList<SyncChunkStack> freeChunks = new ArrayList<SyncChunkStack>();
+        ArrayList<OffHeapStoredObjectAddressStack> freeChunks = new ArrayList<OffHeapStoredObjectAddressStack>();
-        for (SyncChunkStack l: freeChunks) {
+        for (OffHeapStoredObjectAddressStack l: freeChunks) {
-                int lowSize = ObjectChunk.getSize(lowAddr);
+                int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                  ObjectChunk.setSize(lowAddr, lowSize + ObjectChunk.getSize(addr));
+                  OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-              int addrSize = ObjectChunk.getSize(addr);
+              int addrSize = OffHeapStoredObject.getSize(addr);
-                ObjectChunk.setSize(addr, addrSize + ObjectChunk.getSize(highAddr));
+                OffHeapStoredObject.setSize(addr, addrSize + OffHeapStoredObject.getSize(highAddr));
-                  int lowSize = ObjectChunk.getSize(lowAddr);
+                  int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                    ObjectChunk.setSize(lowAddr, lowSize + addrSize);
+                    OffHeapStoredObject.setSize(lowAddr, lowSize + addrSize);
-          int lowSize = ObjectChunk.getSize(lowAddr);
+          int lowSize = OffHeapStoredObject.getSize(lowAddr);
-            ObjectChunk.setSize(lowAddr, lowSize + ObjectChunk.getSize(addr));
+            OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-          int addrSize = ObjectChunk.getSize(addr);
+          int addrSize = OffHeapStoredObject.getSize(addr);
-        assert freeMemory > ObjectChunk.MIN_CHUNK_SIZE;
-        long maxPossibleFragments = freeMemory / ObjectChunk.MIN_CHUNK_SIZE;
+        assert freeMemory > OffHeapStoredObject.MIN_CHUNK_SIZE;
+        long maxPossibleFragments = freeMemory / OffHeapStoredObject.MIN_CHUNK_SIZE;
-  private void collectFreeChunks(List<SyncChunkStack> l) {
+  private void collectFreeChunks(List<OffHeapStoredObjectAddressStack> l) {
-  private void collectFreeFragmentChunks(List<SyncChunkStack> l) {
+  private void collectFreeFragmentChunks(List<OffHeapStoredObjectAddressStack> l) {
-    SyncChunkStack result = new SyncChunkStack();
+    OffHeapStoredObjectAddressStack result = new OffHeapStoredObjectAddressStack();
-      } while (diff >= ObjectChunk.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
-      if (diff < ObjectChunk.MIN_CHUNK_SIZE) {
+      } while (diff >= OffHeapStoredObject.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
+      if (diff < OffHeapStoredObject.MIN_CHUNK_SIZE) {
-      long chunkAddr = f.getMemoryAddress()+offset;
-      ObjectChunk.setSize(chunkAddr, diff);
+      long chunkAddr = f.getAddress()+offset;
+      OffHeapStoredObject.setSize(chunkAddr, diff);
-  private void collectFreeTinyChunks(List<SyncChunkStack> l) {
+  private void collectFreeTinyChunks(List<OffHeapStoredObjectAddressStack> l) {
-      SyncChunkStack cl = this.tinyFreeLists.get(i);
+      OffHeapStoredObjectAddressStack cl = this.tinyFreeLists.get(i);
-          l.add(new SyncChunkStack(head));
+          l.add(new OffHeapStoredObjectAddressStack(head));
-  private void collectFreeHugeChunks(List<SyncChunkStack> l) {
-    ObjectChunk c = this.hugeChunkSet.pollFirst();
-    SyncChunkStack result = null;
+  private void collectFreeHugeChunks(List<OffHeapStoredObjectAddressStack> l) {
+    OffHeapStoredObject c = this.hugeChunkSet.pollFirst();
+    OffHeapStoredObjectAddressStack result = null;
-        result = new SyncChunkStack();
+        result = new OffHeapStoredObjectAddressStack();
-      result.offer(c.getMemoryAddress());
+      result.offer(c.getAddress());
-  ObjectChunk allocateFromFragment(final int fragIdx, final int chunkSize) {
+  OffHeapStoredObject allocateFromFragment(final int fragIdx, final int chunkSize) {
-        if (extraSize < ObjectChunk.MIN_CHUNK_SIZE) {
+        if (extraSize < OffHeapStoredObject.MIN_CHUNK_SIZE) {
-          ObjectChunk result = new ObjectChunk(fragment.getMemoryAddress()+oldOffset, chunkSize+extraSize);
+          OffHeapStoredObject result = new OffHeapStoredObject(fragment.getAddress()+oldOffset, chunkSize+extraSize);
-          ObjectChunk result = basicAllocate(chunkSize, false);
+          OffHeapStoredObject result = basicAllocate(chunkSize, false);
-  private ObjectChunk allocateTiny(int size, boolean useFragments) {
+  private OffHeapStoredObject allocateTiny(int size, boolean useFragments) {
-  private ObjectChunk basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<SyncChunkStack> freeLists, boolean useFragments) {
-    SyncChunkStack clq = freeLists.get(idx);
+  private OffHeapStoredObject basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, boolean useFragments) {
+    OffHeapStoredObjectAddressStack clq = freeLists.get(idx);
-        ObjectChunk result = new ObjectChunk(memAddr);
+        OffHeapStoredObject result = new OffHeapStoredObject(memAddr);
-  private ObjectChunk allocateHuge(int size, boolean useFragments) {
+  private OffHeapStoredObject allocateHuge(int size, boolean useFragments) {
-    ObjectChunk sizeHolder = new FakeChunk(size);
-    NavigableSet<ObjectChunk> ts = this.hugeChunkSet.tailSet(sizeHolder);
-    ObjectChunk result = ts.pollFirst();
+    OffHeapStoredObject sizeHolder = new SearchMarker(size);
+    NavigableSet<OffHeapStoredObject> ts = this.hugeChunkSet.tailSet(sizeHolder);
+    OffHeapStoredObject result = ts.pollFirst();
-      if (result.getSize() - (HUGE_MULTIPLE - ObjectChunk.OFF_HEAP_HEADER_SIZE) < size) {
+      if (result.getSize() - (HUGE_MULTIPLE - OffHeapStoredObject.HEADER_SIZE) < size) {
-  private void checkDataIntegrity(ObjectChunk data) {
+  private void checkDataIntegrity(OffHeapStoredObject data) {
-   * ConcurrentSkipListSet. This is not a real chunk
+   * ConcurrentSkipListSet. This is not a real OffHeapStoredObject
-  private static class FakeChunk extends ObjectChunk {
+  private static class SearchMarker extends OffHeapStoredObject {
-    public FakeChunk(int size) {
+    public SearchMarker(int size) {
-      ObjectChunk.fill(addr);
+      OffHeapStoredObject.fill(addr);
-    int cSize = ObjectChunk.getSize(addr);
+    int cSize = OffHeapStoredObject.getSize(addr);
-  private void basicFree(long addr, int idx, AtomicReferenceArray<SyncChunkStack> freeLists) {
-    SyncChunkStack clq = freeLists.get(idx);
+  private void basicFree(long addr, int idx, AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists) {
+    OffHeapStoredObjectAddressStack clq = freeLists.get(idx);
-  protected SyncChunkStack createFreeListForEmptySlot(AtomicReferenceArray<SyncChunkStack> freeLists, int idx) {
-    return new SyncChunkStack();
+  protected OffHeapStoredObjectAddressStack createFreeListForEmptySlot(AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, int idx) {
+    return new OffHeapStoredObjectAddressStack();
-    this.hugeChunkSet.add(new ObjectChunk(addr)); // TODO make this a collection of longs
+    this.hugeChunkSet.add(new OffHeapStoredObject(addr)); // TODO make this a collection of longs
-            return Long.valueOf(o1.getMemoryAddress()).compareTo(o2.getMemoryAddress());
+            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-  private void addBlocksFromChunks(Collection<ObjectChunk> src, List<MemoryBlock> dest) {
-    for (ObjectChunk chunk : src) {
+  private void addBlocksFromChunks(Collection<OffHeapStoredObject> src, List<MemoryBlock> dest) {
+    for (OffHeapStoredObject chunk : src) {
-        addr = ObjectChunk.getNext(addr);
+        addr = OffHeapStoredObject.getNext(addr);
-            return Long.valueOf(o1.getMemoryAddress()).compareTo(o2.getMemoryAddress());
+            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-    public long getMemoryAddress() {
+    public long getAddress() {
-      return ObjectChunk.getSize(address);
+      return OffHeapStoredObject.getSize(address);
-        return getMemoryAddress() == ((TinyMemoryBlock) o).getMemoryAddress();
+        return getAddress() == ((TinyMemoryBlock) o).getAddress();
-      long value = this.getMemoryAddress();
+      long value = this.getAddress();
-      slabs[i].release();
+      slabs[i].free();
-  boolean okToReuse(AddressableMemoryChunk[] newSlabs) {
+  boolean okToReuse(Slab[] newSlabs) {
-      AddressableMemoryChunk slab = this.slabs[i];
+      Slab slab = this.slabs[i];

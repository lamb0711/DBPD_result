Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Provides the implementation of a distribution <code>Locator</code>
- * as well as internal-only functionality.
+ * Provides the implementation of a distribution <code>Locator</code> as well as internal-only
+ * functionality.
- * This class has APIs that perform essentially three layers of
- * services. At the bottom layer is the JGroups location service. On
- * top of that you can start a distributed system. And then on top
- * of that you can start server location services.
+ * This class has APIs that perform essentially three layers of services. At the bottom layer is the
+ * JGroups location service. On top of that you can start a distributed system. And then on top of
+ * that you can start server location services.
- * Server Location Service
- * DistributedSystem
- * Peer Location Service
+ * Server Location Service DistributedSystem Peer Location Service
- * The startLocator() methods provide a way to start all three
- * services in one call. Otherwise, the services can be started
- * independently
- * <code>
- * locator = createLocator()
- * locator.startPeerLocation();
- * locator.startDistributeSystem();
+ * The startLocator() methods provide a way to start all three services in one call. Otherwise, the
+ * services can be started independently <code> locator = createLocator()
+ * locator.startPeerLocation(); locator.startDistributeSystem();
+ * 
-   * How long (in milliseconds) a member that we haven't heard from
-   * in a while should live before we call it dead?
+   * How long (in milliseconds) a member that we haven't heard from in a while should live before we
+   * call it dead?
-  private static final int SHARED_CONFIG_STATUS_TIMEOUT = 10000; //10 seconds
+  private static final int SHARED_CONFIG_STATUS_TIMEOUT = 10000; // 10 seconds
-  public static final String LOCATORS_PREFERRED_AS_COORDINATORS = DistributionConfig.GEMFIRE_PREFIX + "disable-floating-coordinator";
+  public static final String LOCATORS_PREFERRED_AS_COORDINATORS =
+      DistributionConfig.GEMFIRE_PREFIX + "disable-floating-coordinator";
-  /////////////////////  Instance Fields  //////////////////////
+  ///////////////////// Instance Fields //////////////////////
-   * The distributed system owned by this locator, if any.
-   * Note that if a ds already exists because the locator is
-   * being colocated in a normal member this field will be null.
+   * The distributed system owned by this locator, if any. Note that if a ds already exists because
+   * the locator is being colocated in a normal member this field will be null.
-   * The cache owned by this locator, if any.
-   * Note that if a cache already exists because the locator is
-   * being colocated in a normal member this field will be null.
+   * The cache owned by this locator, if any. Note that if a cache already exists because the
+   * locator is being colocated in a normal member this field will be null.
-  //////////////////////  Static Methods  /////////////////////
+  ////////////////////// Static Methods /////////////////////
-   * Create a locator that listens on a given port. This locator will not have
-   * peer or server location services available until they are started by
-   * calling startServerLocation or startPeerLocation on the locator object.
+   * Create a locator that listens on a given port. This locator will not have peer or server
+   * location services available until they are started by calling startServerLocation or
+   * startPeerLocation on the locator object.
+   * 
-   * @param logger a log writer that should be used (logFile parameter is
-   * ignored)
+   * @param logger a log writer that should be used (logFile parameter is ignored)
-   * (e.g., mcast addr/port, other locators)
+   *        (e.g., mcast addr/port, other locators)
-  public static InternalLocator createLocator(int port,
-                                              File logFile,
-                                              File stateFile,
-                                              InternalLogWriter logger,
-                                              InternalLogWriter securityLogger,
-                                              InetAddress bindAddress,
-                                              String hostnameForClients,
-                                              java.util.Properties distributedSystemProperties,
-                                              boolean startDistributedSystem) throws IOException {
+  public static InternalLocator createLocator(int port, File logFile, File stateFile,
+      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
+      String hostnameForClients, java.util.Properties distributedSystemProperties,
+      boolean startDistributedSystem) throws IOException {
-        throw new IllegalStateException("A locator can not be created because one already exists in this JVM.");
+        throw new IllegalStateException(
+            "A locator can not be created because one already exists in this JVM.");
-      InternalLocator l = new InternalLocator(port, logFile, stateFile, logger, securityLogger, bindAddress, hostnameForClients, distributedSystemProperties, null, startDistributedSystem);
+      InternalLocator l =
+          new InternalLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+              hostnameForClients, distributedSystemProperties, null, startDistributedSystem);
-        throw new IllegalStateException("A locator can not be created because one already exists in this JVM.");
+        throw new IllegalStateException(
+            "A locator can not be created because one already exists in this JVM.");
-   * Creates a distribution locator that runs in this VM on the given
-   * port and bind address and creates a distributed system.
+   * Creates a distribution locator that runs in this VM on the given port and bind address and
+   * creates a distributed system.
+   * 
-   * @param dsProperties optional properties to configure the distributed system (e.g., mcast addr/port, other locators)
+   * @param dsProperties optional properties to configure the distributed system (e.g., mcast
+   *        addr/port, other locators)
-   * @param loadSharedConfigFromDir load the shared configuration from the shared configuration directory
+   * @param loadSharedConfigFromDir load the shared configuration from the shared configuration
+   *        directory
-  public static InternalLocator startLocator(int port,
-                                             File logFile,
-                                             File stateFile,
-                                             InternalLogWriter logger,
-                                             InternalLogWriter securityLogger,
-                                             InetAddress bindAddress,
-                                             java.util.Properties dsProperties,
-                                             boolean peerLocator,
-                                             boolean enableServerLocator,
-                                             String hostnameForClients,
-                                             boolean loadSharedConfigFromDir) throws IOException {
-    return startLocator(port, logFile, stateFile, logger, securityLogger, bindAddress, true, dsProperties, peerLocator, enableServerLocator, hostnameForClients, loadSharedConfigFromDir);
+  public static InternalLocator startLocator(int port, File logFile, File stateFile,
+      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
+      java.util.Properties dsProperties, boolean peerLocator, boolean enableServerLocator,
+      String hostnameForClients, boolean loadSharedConfigFromDir) throws IOException {
+    return startLocator(port, logFile, stateFile, logger, securityLogger, bindAddress, true,
+        dsProperties, peerLocator, enableServerLocator, hostnameForClients,
+        loadSharedConfigFromDir);
-   * Creates a distribution locator that runs in this VM on the given
-   * port and bind address.
+   * Creates a distribution locator that runs in this VM on the given port and bind address.
-   * This is for internal use only as it does not create a distributed
-   * system unless told to do so.
+   * This is for internal use only as it does not create a distributed system unless told to do so.
+   * 
-   * @param dsProperties optional properties to configure the distributed system (e.g., mcast addr/port, other locators)
+   * @param dsProperties optional properties to configure the distributed system (e.g., mcast
+   *        addr/port, other locators)
-  public static InternalLocator startLocator(int port,
-                                             File logFile,
-                                             File stateFile,
-                                             InternalLogWriter logger,
-                                             InternalLogWriter securityLogger,
-                                             InetAddress bindAddress,
-                                             boolean startDistributedSystem,
-                                             java.util.Properties dsProperties,
-                                             boolean peerLocator,
-                                             boolean enableServerLocator,
-                                             String hostnameForClients,
-                                             boolean loadSharedConfigFromDir) throws IOException {
+  public static InternalLocator startLocator(int port, File logFile, File stateFile,
+      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
+      boolean startDistributedSystem, java.util.Properties dsProperties, boolean peerLocator,
+      boolean enableServerLocator, String hostnameForClients, boolean loadSharedConfigFromDir)
+      throws IOException {
-      throw new IllegalArgumentException(LocalizedStrings.InternalLocator_EITHER_PEER_LOCATOR_OR_SERVER_LOCATOR_MUST_BE_ENABLED.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.InternalLocator_EITHER_PEER_LOCATOR_OR_SERVER_LOCATOR_MUST_BE_ENABLED
+              .toLocalizedString());
-      slocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress, hostnameForClients, dsProperties, startDistributedSystem);
+      slocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+          hostnameForClients, dsProperties, startDistributedSystem);
-      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero port in a variable to use here
+      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero
+      // port in a variable to use here
-            slocator.startDistributedSystem(); // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
+            slocator.startDistributedSystem(); // TODO:GEODE-1243: throws Exception if TcpServer
+                                               // still has zero for its locator port
-            ids.getDistributionManager().addHostedLocators(ids.getDistributedMember(), getLocatorStrings(), slocator.isSharedConfigurationEnabled());
+            ids.getDistributionManager().addHostedLocators(ids.getDistributedMember(),
+                getLocatorStrings(), slocator.isSharedConfigurationEnabled());
-      //    if(enableServerLocator) {
-      //      slocator.startServerLocation(InternalDistributedSystem.getConnectedInstance());
-      //  }
+      // if(enableServerLocator) {
+      // slocator.startServerLocation(InternalDistributedSystem.getConnectedInstance());
+      // }
-   * @return true if this VM is a locator which should ignore a shutdown , false if it is a normal member.
+   * 
+   * @return true if this VM is a locator which should ignore a shutdown , false if it is a normal
+   *         member.
-  ///////////////////////  Constructors  //////////////////////
+  /////////////////////// Constructors //////////////////////
-   * Creates a new <code>Locator</code> with the given port, log file, logger,
-   * and bind address.
+   * Creates a new <code>Locator</code> with the given port, log file, logger, and bind address.
+   * 
-   * @param logWriter a log writer that should be used (logFile parameter is
-   * ignored)
+   * @param logWriter a log writer that should be used (logFile parameter is ignored)
-   * (e.g., mcast addr/port, other locators)
+   *        (e.g., mcast addr/port, other locators)
-  private InternalLocator(int port,
-                          File logF,
-                          File stateF,
-                          InternalLogWriter logWriter,
-                          // LOG: 3 non-null sources: GemFireDistributionLocator, InternalDistributedSystem, LocatorLauncher
-                          InternalLogWriter securityLogWriter,
-                          // LOG: 1 non-null source: GemFireDistributionLocator(same instance as logWriter), InternalDistributedSystem
-                          InetAddress bindAddress,
-                          String hostnameForClients,
-                          java.util.Properties distributedSystemProperties,
-                          DistributionConfigImpl cfg,
-                          boolean startDistributedSystem) {
+  private InternalLocator(int port, File logF, File stateF, InternalLogWriter logWriter,
+      // LOG: 3 non-null sources: GemFireDistributionLocator, InternalDistributedSystem,
+      // LocatorLauncher
+      InternalLogWriter securityLogWriter,
+      // LOG: 1 non-null source: GemFireDistributionLocator(same instance as logWriter),
+      // InternalDistributedSystem
+      InetAddress bindAddress, String hostnameForClients,
+      java.util.Properties distributedSystemProperties, DistributionConfigImpl cfg,
+      boolean startDistributedSystem) {
-                                                                                  .toString()
-                                                                                  .equals(DistributionConfig.DEFAULT_LOG_FILE.toString());
+        .toString().equals(DistributionConfig.DEFAULT_LOG_FILE.toString());
-      this.config.unsafeSetLogFile(this.logFile); // LOG: this is(was) a hack for when logFile and config don't match -- if config specifies a different log-file things will break!
+      this.config.unsafeSetLogFile(this.logFile); // LOG: this is(was) a hack for when logFile and
+                                                  // config don't match -- if config specifies a
+                                                  // different log-file things will break!
-    final boolean hasLogFile = this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
-    final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null && !this.config.getSecurityLogFile().equals(new File(""));
+    final boolean hasLogFile =
+        this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
+    final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null
+        && !this.config.getSecurityLogFile().equals(new File(""));
-        LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, true, false, this.config, !startDistributedSystem);
+        LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, true, false,
+            this.config, !startDistributedSystem);
-        LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.SECURITY, true, false, this.config, false);
+        LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.SECURITY, true, false,
+            this.config, false);
-      logWriter = LogWriterFactory.createLogWriterLogger(false, false, this.config, !startDistributedSystem);
+      logWriter = LogWriterFactory.createLogWriterLogger(false, false, this.config,
+          !startDistributedSystem);
-      // We defer setting the port until the handler is init'd - that way we'll have an actual port in the
+      // We defer setting the port until the handler is init'd - that way we'll have an actual port
+      // in the
-    server = new TcpServer(port, this.bindAddress, null, this.config, this.handler, new DelayedPoolStatHelper(), group, this.toString());
+    server = new TcpServer(port, this.bindAddress, null, this.config, this.handler,
+        new DelayedPoolStatHelper(), group, this.toString());
-  //Reset the file names with the correct port number if startLocatorAndDS was called with port number 0
+  // Reset the file names with the correct port number if startLocatorAndDS was called with port
+  // number 0
-   * Start peer location in this locator. If you plan on starting a distributed
-   * system later, this method should be called first so that the distributed
-   * system can use this locator.
+   * Start peer location in this locator. If you plan on starting a distributed system later, this
+   * method should be called first so that the distributed system can use this locator.
+   * 
-      throw new IllegalStateException(LocalizedStrings.InternalLocator_PEER_LOCATION_IS_ALREADY_RUNNING_FOR_0.toLocalizedString(this));
+      throw new IllegalStateException(
+          LocalizedStrings.InternalLocator_PEER_LOCATION_IS_ALREADY_RUNNING_FOR_0
+              .toLocalizedString(this));
-    logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_STARTING_PEER_LOCATION_FOR_0, this));
+    logger.info(LocalizedMessage
+        .create(LocalizedStrings.InternalLocator_STARTING_PEER_LOCATION_FOR_0, this));
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
-        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, stats, securityUDPDHAlgo);
+    this.locatorImpl =
+        MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile, locatorsProp,
+            locatorsAreCoordinators, networkPartitionDetectionEnabled, stats, securityUDPDHAlgo);
-        logger.info("Cluster configuration service start up completed successfully and is now running ....");
+        logger.info(
+            "Cluster configuration service start up completed successfully and is now running ....");
-   * Start a distributed system whose life cycle is managed by this locator. When
-   * the locator is stopped, this distributed system will be disconnected. If a
-   * distributed system already exists, this method will have no affect.
+   * Start a distributed system whose life cycle is managed by this locator. When the locator is
+   * stopped, this distributed system will be disconnected. If a distributed system already exists,
+   * this method will have no affect.
+   * 
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_USING_EXISTING_DISTRIBUTED_SYSTEM__0, existing));
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.InternalLocator_USING_EXISTING_DISTRIBUTED_SYSTEM__0, existing));
-        //this.logger.config("ensuring that this locator is in the locators list");
+        // this.logger.config("ensuring that this locator is in the locators list");
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_STARTING_DISTRIBUTED_SYSTEM));
+      logger.info(
+          LocalizedMessage.create(LocalizedStrings.InternalLocator_STARTING_DISTRIBUTED_SYSTEM));
-      logger.info(LogMarker.CONFIG, LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_STARTUP_CONFIGURATIONN_0, this.config.toLoggerString()));
+      logger.info(LogMarker.CONFIG,
+          LocalizedMessage.create(
+              LocalizedStrings.InternalDistributedSystem_STARTUP_CONFIGURATIONN_0,
+              this.config.toLoggerString()));
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_LOCATOR_STARTED_ON__0, thisLocator));
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_LOCATOR_STARTED_ON__0,
+          thisLocator));
-   * End the initialization of the locator. This method should
-   * be called once the location services and distributed
-   * system are started.
+   * End the initialization of the locator. This method should be called once the location services
+   * and distributed system are started.
+   * 
-  public void endStartLocator(InternalDistributedSystem distributedSystem) throws UnknownHostException {
+  public void endStartLocator(InternalDistributedSystem distributedSystem)
+      throws UnknownHostException {
-    if(this.locatorDiscoverer != null) {
+    if (this.locatorDiscoverer != null) {
-   * Start server location services in this locator. Server location
-   * can only be started once there is a running distributed system.
-   * @param distributedSystem The distributed system which the server location services
-   * should use. If null, the method will try to find an already
-   * connected distributed system.
+   * Start server location services in this locator. Server location can only be started once there
+   * is a running distributed system.
+   * 
+   * @param distributedSystem The distributed system which the server location services should use.
+   *        If null, the method will try to find an already connected distributed system.
-      throw new IllegalStateException(LocalizedStrings.InternalLocator_SERVER_LOCATION_IS_ALREADY_RUNNING_FOR_0.toLocalizedString(this));
+      throw new IllegalStateException(
+          LocalizedStrings.InternalLocator_SERVER_LOCATION_IS_ALREADY_RUNNING_FOR_0
+              .toLocalizedString(this));
-    logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_STARTING_SERVER_LOCATION_FOR_0, this));
+    logger.info(LocalizedMessage
+        .create(LocalizedStrings.InternalLocator_STARTING_SERVER_LOCATION_FOR_0, this));
-        throw new IllegalStateException(LocalizedStrings.InternalLocator_SINCE_SERVER_LOCATION_IS_ENABLED_THE_DISTRIBUTED_SYSTEM_MUST_BE_CONNECTED.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.InternalLocator_SINCE_SERVER_LOCATION_IS_ENABLED_THE_DISTRIBUTED_SYSTEM_MUST_BE_CONNECTED
+                .toLocalizedString());
-    ServerLocator sl = new ServerLocator(getPort(), this.bindAddress, this.hostnameForClients, this.logFile, this.productUseLog, getConfig().getName(), distributedSystem, stats);
+    ServerLocator sl = new ServerLocator(getPort(), this.bindAddress, this.hostnameForClients,
+        this.logFile, this.productUseLog, getConfig().getName(), distributedSystem, stats);
-//    SocketCreatorFactory.close();
+    // SocketCreatorFactory.close();
-   * Was this locator stopped during forced-disconnect processing but should
-   * reconnect?
+   * Was this locator stopped during forced-disconnect processing but should reconnect?
+   * 
-      // locator can be created, if desired, when this method returns 
+      // locator can be created, if desired, when this method returns
-            logger.debug("60 seconds have elapsed waiting for the locator server to shut down - terminating wait and returning");
+            logger.debug(
+                "60 seconds have elapsed waiting for the locator server to shut down - terminating wait and returning");
-        logger.warn(LocalizedMessage.create(LocalizedStrings.InternalLocator_INTERRUPTED_WHILE_STOPPING__0, this), ex);
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.InternalLocator_INTERRUPTED_WHILE_STOPPING__0, this), ex);
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.InternalLocator_COULD_NOT_STOP__0__IN_60_SECONDS, this));
+        logger.fatal(LocalizedMessage
+            .create(LocalizedStrings.InternalLocator_COULD_NOT_STOP__0__IN_60_SECONDS, this));
-        logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_DISCONNECTING_DISTRIBUTED_SYSTEM_FOR_0, this));
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.InternalLocator_DISCONNECTING_DISTRIBUTED_SYSTEM_FOR_0, this));
+   * 
-   * reconnects the locator to a restarting DistributedSystem.  If quorum checks
-   * are enabled this will start peer location services before a distributed
-   * system is available if the quorum check succeeds.  It will then wait
-   * for the system to finish reconnecting before returning.  If quorum checks
-   * are not being done this merely waits for the distributed system to reconnect
-   * and then starts location services.
+   * reconnects the locator to a restarting DistributedSystem. If quorum checks are enabled this
+   * will start peer location services before a distributed system is available if the quorum check
+   * succeeds. It will then wait for the system to finish reconnecting before returning. If quorum
+   * checks are not being done this merely waits for the distributed system to reconnect and then
+   * starts location services.
+   * 
-            // start up peer location.  server location is started after the DS finishes
+            // start up peer location. server location is started after the DS finishes
-      //      LogWriter log = new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out);
+      // LogWriter log = new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out);
-        //        log.fine("reconnecting locator: starting location services");
+        // log.fine("reconnecting locator: starting location services");
-        throw new IllegalStateException("A locator can not be created because one already exists in this JVM.");
+        throw new IllegalStateException(
+            "A locator can not be created because one already exists in this JVM.");
-  private void restartWithDS(InternalDistributedSystem newSystem, GemFireCacheImpl newCache) throws IOException {
+  private void restartWithDS(InternalDistributedSystem newSystem, GemFireCacheImpl newCache)
+      throws IOException {
-        throw new IllegalStateException("A locator can not be created because one already exists in this JVM.");
+        throw new IllegalStateException(
+            "A locator can not be created because one already exists in this JVM.");
-   * Returns null if no server locator;
-   * otherwise returns the advisee that represents the server locator.
+   * Returns null if no server locator; otherwise returns the advisee that represents the server
+   * locator.
-   * Return the port on which the locator is actually listening. If called before the locator has actually
-   * started, this method will return null.
+   * Return the port on which the locator is actually listening. If called before the locator has
+   * actually started, this method will return null.
+   * 
-          if (status != SharedConfigurationStatus.STARTED || status != SharedConfigurationStatus.NOT_STARTED) {
+          if (status != SharedConfigurationStatus.STARTED
+              || status != SharedConfigurationStatus.NOT_STARTED) {
-    ExecutorService es = ((GemFireCacheImpl) myCache).getDistributionManager().getWaitingThreadPool();
-    Future<SharedConfigurationStatusResponse> statusFuture = es.submit(new FetchSharedConfigStatus());
+    ExecutorService es =
+        ((GemFireCacheImpl) myCache).getDistributionManager().getWaitingThreadPool();
+    Future<SharedConfigurationStatusResponse> statusFuture =
+        es.submit(new FetchSharedConfigStatus());
-    //private final List<LocatorJoinMessage> locatorJoinMessages;
+    // private final List<LocatorJoinMessage> locatorJoinMessages;
-    boolean willHaveServerLocator;  // flag to avoid warning about missing handlers during startup
+    boolean willHaveServerLocator; // flag to avoid warning about missing handlers during startup
-      //this.locatorJoinMessages = new ArrayList<LocatorJoinMessage>();
+      // this.locatorJoinMessages = new ArrayList<LocatorJoinMessage>();
-    //initialization is taking place.
+    // initialization is taking place.
-      for (Iterator itr = allHandlers.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = allHandlers.iterator(); itr.hasNext();) {
-    public void restarting(DistributedSystem ds, GemFireCache cache, SharedConfiguration sharedConfig) {
+    public void restarting(DistributedSystem ds, GemFireCache cache,
+        SharedConfiguration sharedConfig) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.InternalLocator_EXPECTED_ONE_OF_THESE_0_BUT_RECEIVED_1, new Object[] {
-              handlerMapping.keySet(), request
-            }));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.InternalLocator_EXPECTED_ONE_OF_THESE_0_BUT_RECEIVED_1,
+                new Object[] {handlerMapping.keySet(), request}));
-        for (Iterator itr = allHandlers.iterator(); itr.hasNext(); ) {
+        for (Iterator itr = allHandlers.iterator(); itr.hasNext();) {
-      stats.hookupStats(sys, SocketCreator.getLocalHost().getCanonicalHostName() + "-" + server.getBindAddress().toString());
+      stats.hookupStats(sys, SocketCreator.getLocalHost().getCanonicalHostName() + "-"
+          + server.getBindAddress().toString());
-   * Returns collection of locator strings representing every locator instance
-   * hosted by this member.
+   * Returns collection of locator strings representing every locator instance hosted by this
+   * member.
+   * 
-      Collection<DistributionLocatorId> locatorIds = DistributionLocatorId.asDistributionLocatorIds(getLocators());
+      Collection<DistributionLocatorId> locatorIds =
+          DistributionLocatorId.asDistributionLocatorIds(getLocators());
-   * A helper object so that the TcpServer can record
-   * its stats to the proper place. Stats are only recorded
-   * if a distributed system is started.
+   * A helper object so that the TcpServer can record its stats to the proper place. Stats are only
+   * recorded if a distributed system is started.
-      this.handler.addHandler(ConfigurationRequest.class, new ConfigurationRequestHandler(this.sharedConfig));
+      this.handler.addHandler(ConfigurationRequest.class,
+          new ConfigurationRequestHandler(this.sharedConfig));
-      this.handler.addHandler(SharedConfigurationStatusRequest.class, new SharedConfigurationStatusRequestHandler());
+      this.handler.addHandler(SharedConfigurationStatusRequest.class,
+          new SharedConfigurationStatusRequestHandler());

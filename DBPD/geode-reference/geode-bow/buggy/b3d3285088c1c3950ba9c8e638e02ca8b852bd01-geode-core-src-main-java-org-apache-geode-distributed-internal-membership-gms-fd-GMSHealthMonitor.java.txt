GEODE-1874: Changed setNextNeighbor to not create HashMap for every p2p invocation

- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
- * http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import static org.apache.geode.internal.DataSerializableFixedID.HEARTBEAT_REQUEST;
-import static org.apache.geode.internal.DataSerializableFixedID.HEARTBEAT_RESPONSE;
-import static org.apache.geode.internal.DataSerializableFixedID.SUSPECT_MEMBERS_MESSAGE;
+import static org.apache.geode.internal.DataSerializableFixedID.*;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
-import java.util.stream.*;
+import java.util.stream.Collectors;
- * 
- * This class make sure that each member is alive and communicating to this member. To make sure
- * that we create the ring of members based on current view. On this ring, each member make sure
- * that next-member in ring is communicating with it. For that we record last message timestamp from
- * next-member. And if it sees this member has not communicated in last period(member-timeout) then
- * we check whether this member is still alive or not. Based on that we informed probable
- * coordinators to remove that member from view.
- * 
- * It has {@link #suspect(InternalDistributedMember, String)} api, which can be used to initiate
- * suspect processing for any member. First is checks whether the member is responding or not. Then
- * it informs probable coordinators to remove that member from view.
- * 
- * It has {@link #checkIfAvailable(DistributedMember, String, boolean)} api to see if that member is
- * alive. Then based on removal flag it initiates the suspect processing for that member.
- * 
+ * <p>
+ * This class make sure that each member is alive and communicating to this member.
+ * To make sure that we create the ring of members based on current view. On this
+ * ring, each member make sure that next-member in ring is communicating with it.
+ * For that we record last message timestamp from next-member. And if it sees this
+ * member has not communicated in last period(member-timeout) then we check whether
+ * this member is still alive or not. Based on that we informed probable coordinators
+ * to remove that member from view.
+ * <p>
+ * It has {@link #suspect(InternalDistributedMember, String)} api, which can be used
+ * to initiate suspect processing for any member. First is checks whether the member is
+ * responding or not. Then it informs probable coordinators to remove that member from
+ * view.
+ * <p>
+ * It has {@link #checkIfAvailable(DistributedMember, String, boolean)} api to see
+ * if that member is alive. Then based on removal flag it initiates the suspect processing
+ * for that member.
-@SuppressWarnings({"SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems"})
+@SuppressWarnings({ "SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems" })
-  /** membership logger */
+  /**
+   * membership logger
+   */
-   * The number of recipients of periodic heartbeats. The recipients will be selected from the
-   * members that are likely to be monitoring this member.
+   * The number of recipients of periodic heartbeats.  The recipients will
+   * be selected from the members that are likely to be monitoring this member.
-   * Member activity will be recorded per interval/period. Timer task will set interval's starting
-   * time. Each interval will be member-timeout/LOGICAL_INTERVAL. LOGICAL_INTERVAL may be configured
+   * Member activity will be recorded per interval/period. Timer task will set interval's starting time.
+   * Each interval will be member-timeout/LOGICAL_INTERVAL. LOGICAL_INTERVAL may be configured
-  public static final int LOGICAL_INTERVAL =
-      Integer.getInteger("geode.logical-message-received-interval", 2);
+  public static final int LOGICAL_INTERVAL = Integer.getInteger("geode.logical-message-received-interval", 2);
-  /** stall time to wait for members leaving concurrently */
-  public static final long MEMBER_SUSPECT_COLLECTION_INTERVAL =
-      Long.getLong("geode.suspect-member-collection-interval", 200);
+  /**
+   * stall time to wait for members leaving concurrently
+   */
+  public static final long MEMBER_SUSPECT_COLLECTION_INTERVAL = Long.getLong("geode.suspect-member-collection-interval", 200);
-  /** this member's ID */
+  /**
+   * this member's ID
+   */
-  final ConcurrentMap<InternalDistributedMember, TimeStamp> memberTimeStamps =
-      new ConcurrentHashMap<>();
+  final ConcurrentMap<InternalDistributedMember, TimeStamp> memberTimeStamps = new ConcurrentHashMap<>();
-  final private ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView =
-      new ConcurrentHashMap<>();
+  final private ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView = new ConcurrentHashMap<>();
-  final private List<InternalDistributedMember> membersInFinalCheck =
-      Collections.synchronizedList(new ArrayList<>(30));
+  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
-  /** test hook */
+  /**
+   * test hook
+   */
-  /** test hook */
+  /**
+   * test hook
+   */
-  /** Statistics about health monitor */
+  /**
+   * Statistics about health monitor
+   */
+
-   * This class sets start interval timestamp to record the activity of all members. That is used by
-   * {@link GMSHealthMonitor#contactedBy(InternalDistributedMember)} to record the activity of
-   * member.
-   * 
+   * This class sets start interval timestamp to record the activity of all members.
+   * That is used by {@link GMSHealthMonitor#contactedBy(InternalDistributedMember)} to
+   * record the activity of member.
+   *
+
-      // this is the start of interval to record member activity
+      //this is the start of interval to record member activity
-   * Response will have requestId, which is used to get ResponseObject. Then it is used to notify
-   * waiting thread.
+   * Response will have requestId, which is used to get ResponseObject. Then it is used to
+   * notify waiting thread.
+
-        } else if (uuidLSBs == myUUID.getLeastSignificantBits()
-            && uuidMSBs == myUUID.getMostSignificantBits() && vmViewId == myVmViewId) {
+        } else if (uuidLSBs == myUUID.getLeastSignificantBits() && uuidMSBs == myUUID.getMostSignificantBits() && vmViewId == myVmViewId) {
-            logger.debug(
-                "HealthMonitor: sending ERROR reply - my UUID is {},{} received is {},{}.  My viewID is {} received is {}",
-                Long.toHexString(myUUID.getMostSignificantBits()),
-                Long.toHexString(myUUID.getLeastSignificantBits()), Long.toHexString(uuidMSBs),
-                Long.toHexString(uuidLSBs), myVmViewId, vmViewId);
+            logger.debug("HealthMonitor: sending ERROR reply - my UUID is {},{} received is {},{}.  My viewID is {} received is {}", Long.toHexString(myUUID.getMostSignificantBits()), Long.toHexString(myUUID.getLeastSignificantBits()), Long.toHexString(uuidMSBs), Long.toHexString(uuidLSBs), myVmViewId, vmViewId);
-  public static void loadEmergencyClasses() {}
+  public static void loadEmergencyClasses() {
+  }
+    //TODO Udo: why putIfAbsent. Surely only put is required
-  private HeartbeatRequestMessage constructHeartbeatRequestMessage(
-      final InternalDistributedMember mbr) {
+  private HeartbeatRequestMessage constructHeartbeatRequestMessage(final InternalDistributedMember mbr) {
-   * This method sends heartbeat request to other member and waits for member-timeout time for
-   * response. If it doesn't see response then it returns false.
+   * This method sends heartbeat request to other member and waits for member-timeout
+   * time for response. If it doesn't see response then it returns false.
-      logger.debug(
-          "GMSHealthMonitor checking thread interrupted, while waiting for response from member: {} .",
-          member);
+      logger.debug("GMSHealthMonitor checking thread interrupted, while waiting for response from member: {} .", member);
-   * During final check, establish TCP connection between current member and suspect member. And
-   * exchange PING/PONG message to see if the suspect member is still alive.
-   * 
+   * During final check, establish TCP connection between current member and suspect member.
+   * And exchange PING/PONG message to see if the suspect member is still alive.
+   *
+   *
-    InternalDistributedSystem internalDistributedSystem =
-        InternalDistributedSystem.getConnectedInstance();
+    InternalDistributedSystem internalDistributedSystem = InternalDistributedSystem.getConnectedInstance();
-      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember,
-          suspectMember.getInetAddress(), port);
-      clientSocket =
-          SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
-              .connect(suspectMember.getInetAddress(), port, (int) memberTimeout,
-                  new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
+      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember, suspectMember.getInetAddress(), port);
+      clientSocket = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER).connect(suspectMember.getInetAddress(), port, (int) memberTimeout, new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
-  // Package protected for testing purposes
+  //Package protected for testing purposes
-          logger.debug("Received {}",
-              (b == OK ? "OK" : (b == ERROR ? "ERROR" : "unknown response: " + b)));
+          logger.debug("Received {}", (b == OK ? "OK" : (b == ERROR ? "ERROR" : "unknown response: " + b)));
-          // received ERROR
+          //received ERROR
-    // synchronized (suspectRequests) {
-    // SuspectRequest sr = new SuspectRequest((InternalDistributedMember) mbr, reason);
-    // if (!suspectRequests.contains(sr)) {
-    // logger.info("Suspecting member {}. Reason= {}.", mbr, reason);
-    // suspectRequests.add(sr);
-    // suspectRequests.notify();
-    // }
-    // }
+    //    synchronized (suspectRequests) {
+    //      SuspectRequest sr = new SuspectRequest((InternalDistributedMember) mbr, reason);
+    //      if (!suspectRequests.contains(sr)) {
+    //        logger.info("Suspecting member {}. Reason= {}.", mbr, reason);
+    //        suspectRequests.add(sr);
+    //        suspectRequests.notify();
+    //      }
+    //    }
-    return inlineCheckIfAvailable(localAddress, currentView, initiateRemoval,
-        (InternalDistributedMember) mbr, reason);
+    return inlineCheckIfAvailable(localAddress, currentView, initiateRemoval, (InternalDistributedMember) mbr, reason);
-        Thread th =
-            new Thread(Services.getThreadGroup(), r, "Geode Failure Detection thread " + id);
+        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection thread " + id);
-    // suspectRequestCollectorThread = this.new RequestCollector<SuspectRequest>("Geode Suspect
-    // Message Collector", Services.getThreadGroup(), suspectRequests,
-    // new Callback<SuspectRequest>() {
-    // @Override
-    // public void process(List<SuspectRequest> requests) {
-    // GMSHealthMonitor.this.sendSuspectRequest(requests);
+    //    suspectRequestCollectorThread = this.new RequestCollector<SuspectRequest>("Geode Suspect Message Collector", Services.getThreadGroup(), suspectRequests,
+    //        new Callback<SuspectRequest>() {
+    //      @Override
+    //      public void process(List<SuspectRequest> requests) {
+    //        GMSHealthMonitor.this.sendSuspectRequest(requests);
-    // }
-    // }, MEMBER_SUSPECT_COLLECTION_INTERVAL);
-    // suspectRequestCollectorThread.setDaemon(true);
-    // suspectRequestCollectorThread.start()
+    //      }
+    //    }, MEMBER_SUSPECT_COLLECTION_INTERVAL);
+    //    suspectRequestCollectorThread.setDaemon(true);
+    //    suspectRequestCollectorThread.start()
-        Thread th =
-            new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Server thread " + id);
+        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Server thread " + id);
-      serverSocket = SocketCreatorFactory
-          .getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
-          .createServerSocketUsingPortRange(socketAddress, 50/* backlog */, true/* isBindAddress */,
-              false/* useNIO */, 65536/* tcpBufferSize */, portRange, false);
+      serverSocket = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER).createServerSocketUsingPortRange(socketAddress, 50/*backlog*/, true/*isBindAddress*/, false/*useNIO*/, 65536/*tcpBufferSize*/, portRange, false);
-      throw new GemFireConfigException(
-          "Unable to allocate a failure detection port in the membership-port range", e);
+      throw new GemFireConfigException("Unable to allocate a failure detection port in the membership-port range", e);
-   * start the thread that listens for tcp/ip connections and responds to connection attempts
+   * start the thread that listens for tcp/ip connections and responds
+   * to connection attempts
-      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(),
-          socketPort);
+      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(), socketPort);
-        while (!services.getCancelCriterion().isCancelInProgress()
-            && !GMSHealthMonitor.this.isStopping) {
+        while (!services.getCancelCriterion().isCancelInProgress() && !GMSHealthMonitor.this.isStopping) {
-            serverSocketExecutor.execute(new ClientSocketHandler(socket)); // start(); [bruce] I'm
-                                                                           // seeing a lot of
-                                                                           // failures due to this
-                                                                           // thread not being
-                                                                           // created fast enough,
-                                                                           // sometimes as long as
-                                                                           // 30 seconds
+            serverSocketExecutor.execute(new ClientSocketHandler(socket)); //start();  [bruce] I'm seeing a lot of failures due to this thread not being created fast enough, sometimes as long as 30 seconds
-   * start the thread that periodically sends a message to processes that might be watching this
-   * process
+   * start the thread that periodically sends a message to processes
+   * that might be watching this process
-        for (;;) {
+        for (; ; ) {
-    for (Iterator<InternalDistributedMember> it = memberTimeStamps.keySet().iterator(); it
-        .hasNext();) {
+    for (Iterator<InternalDistributedMember> it = memberTimeStamps.keySet().iterator(); it.hasNext(); ) {
-    for (Iterator<InternalDistributedMember> it = suspectedMemberInView.keySet().iterator(); it
-        .hasNext();) {
+    for (Iterator<InternalDistributedMember> it = suspectedMemberInView.keySet().iterator(); it.hasNext(); ) {
-    // for (InternalDistributedMember mbr: newView.getMembers()) {
-    // if (!memberVsLastMsgTS.containsKey(mbr)) {
-    // CustomTimeStamp customTS = new CustomTimeStamp(System.currentTimeMillis());
-    // memberVsLastMsgTS.put(mbr, customTS);
-    // }
-    // }
+    //    for (InternalDistributedMember mbr: newView.getMembers()) {
+    //      if (!memberVsLastMsgTS.containsKey(mbr)) {
+    //        CustomTimeStamp customTS = new CustomTimeStamp(System.currentTimeMillis());
+    //        memberVsLastMsgTS.put(mbr, customTS);
+    //      }
+    //    }
-   * 
-   * if nextTo == null then it watches member next to it.
-   * 
-   * It becomes null when we suspect current neighbour, during that time it watches member next to
-   * suspect member.
+   *
+   * if nextTo == null
+   * then it watches member next to it.
+   *
+   * It becomes null when we suspect current neighbour, during that time it watches
+   * member next to suspect member.
-    Set<InternalDistributedMember> checkAllSuspected = new HashSet<>(allMembers);
-    checkAllSuspected.removeAll(suspectedMemberInView.keySet());
-    checkAllSuspected.remove(localAddress);
-    if (checkAllSuspected.isEmpty() && allMembers.size() > 1) {
-      logger.info("All other members are suspect at this point");
-      nextNeighbor = null;
-      return;
+    //    Set<InternalDistributedMember> checkAllSuspected = new HashSet<>(allMembers);
+    //    checkAllSuspected.removeAll(suspectedMemberInView.keySet());
+    //    checkAllSuspected.remove(localAddress);
+    //    if (checkAllSuspected.isEmpty() && allMembers.size() > 1) {
+    //      logger.info("All other members are suspect at this point");
+    //      nextNeighbor = null;
+    //      return;
+    //    }
+
+    if (allMembers.size() > 1 && suspectedMemberInView.size() >= allMembers.size() - 1) {
+      boolean nonSuspectFound = false;
+      for (InternalDistributedMember member : allMembers) {
+        if (member.equals(localAddress)) {
+          continue;
+        }
+        if (!suspectedMemberInView.containsKey(member)) {
+          nonSuspectFound = true;
+          break;
+        }
+      }
+      if (!nonSuspectFound) {
+        logger.info("All other members are suspect at this point");
+        nextNeighbor = null;
+        return;
+      }
-    serverSocket = createServerSocket(localAddress.getInetAddress(),
-        services.getConfig().getMembershipPortRange());
+    serverSocket = createServerSocket(localAddress.getInetAddress(), services.getConfig().getMembershipPortRange());
-      logger.info("GMSHealthMonitor serverSocketExecutor is "
-          + (serverSocketExecutor.isTerminated() ? "terminated" : "not terminated"));
+      logger.info("GMSHealthMonitor serverSocketExecutor is " + (serverSocketExecutor.isTerminated() ? "terminated" : "not terminated"));
-    // if (suspectRequestCollectorThread != null) {
-    // suspectRequestCollectorThread.shutdown();
-    // }
+    //    if (suspectRequestCollectorThread != null) {
+    //      suspectRequestCollectorThread.shutdown();
+    //    }
-    return scheduler.isShutdown() && checkExecutor.isShutdown()
-        && serverSocketExecutor.isShutdown() /* && !suspectRequestCollectorThread.isAlive() */;
+    return scheduler.isShutdown() && checkExecutor.isShutdown() && serverSocketExecutor.isShutdown() /*&& !suspectRequestCollectorThread.isAlive()*/;
-  public void memberSuspected(InternalDistributedMember initiator,
-      InternalDistributedMember suspect, String reason) {}
+  public void memberSuspected(InternalDistributedMember initiator, InternalDistributedMember suspect, String reason) {
+  }
-      logger.trace("Got heartbeat from member {}. {}", m.getSender(),
-          (resp != null ? "Check thread still waiting" : "Check thread is not waiting"));
+      logger.trace("Got heartbeat from member {}. {}", m.getSender(), (resp != null ? "Check thread still waiting" : "Check thread is not waiting"));
-      // we got heartbeat lets update timestamp
+      //we got heartbeat lets update timestamp
-   * Process a Suspect request from another member. This may cause this member to become the new
-   * membership coordinator. it will to final check on that member and then it will send remove
-   * request for that member
+   * Process a Suspect request from another member. This may cause this member
+   * to become the new membership coordinator.
+   * it will to final check on that member and then it will send remove request
+   * for that member
-      logger.info("Membership ignoring suspect request for " + incomingRequest + " from non-member "
-          + incomingRequest.getSender());
-      services.getJoinLeave().remove(sender,
-          "this process is initiating suspect processing but is no longer a member");
+      logger.info("Membership ignoring suspect request for " + incomingRequest + " from non-member " + incomingRequest.getSender());
+      services.getJoinLeave().remove(sender, "this process is initiating suspect processing but is no longer a member");
-      for (Iterator<SuspectRequest> it = incomingRequest.getMembers().iterator(); it.hasNext();) {
+      for (Iterator<SuspectRequest> it = incomingRequest.getMembers().iterator(); it.hasNext(); ) {
-        logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(),
-            req.getReason());
+        logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(), req.getReason());
-    } // coordinator ends
+    }// coordinator ends
-          logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(),
-              req.getReason());
+          logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(), req.getReason());
-   * This method make sure that records suspectRequest. We need to make sure this on preferred
-   * coordinators, as elder coordinator might be in suspected list next.
+   * This method make sure that records suspectRequest. We need to make sure this
+   * on preferred coordinators, as elder coordinator might be in suspected list next. 
-   * performs a "final" health check on the member. If failure-detection socket information is
-   * available for the member (in the view) then we attempt to connect to its socket and ask if it's
-   * the expected member. Otherwise we send a heartbeat request and wait for a reply.
+   * performs a "final" health check on the member.  If failure-detection
+   * socket information is available for the member (in the view) then
+   * we attempt to connect to its socket and ask if it's the expected member.
+   * Otherwise we send a heartbeat request and wait for a reply.
-  private void checkIfAvailable(final InternalDistributedMember initiator,
-      List<SuspectRequest> sMembers, final NetView cv) {
+  private void checkIfAvailable(final InternalDistributedMember initiator, List<SuspectRequest> sMembers, final NetView cv) {
-      // suspected. Since that code is updating this collection we
+      // suspected.  Since that code is updating this collection we
-      // NetView view;
-      // view = suspectedMemberInView.putIfAbsent(mbr, cv);
+      //      NetView view;
+      //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
-      // if (view == null || !view.equals(cv)) {
+      //      if (view == null || !view.equals(cv)) {
-      // }// scheduling for final check and removing it..
+      //      }// scheduling for final check and removing it..
-  private boolean inlineCheckIfAvailable(final InternalDistributedMember initiator,
-      final NetView cv, boolean initiateRemoval, final InternalDistributedMember mbr,
-      final String reason) {
+  private boolean inlineCheckIfAvailable(final InternalDistributedMember initiator, final NetView cv, boolean initiateRemoval, final InternalDistributedMember mbr, final String reason) {
-          logger.debug("\ncurrent view: {}\nports: {}", cv,
-              Arrays.toString(cv.getFailureDetectionPorts()));
+          logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
-        // this will just send heartbeat request, it will not wait for response
-        // if we will get heartbeat then it will change the timestamp, which we are
-        // checking below in case of tcp check failure..
+        //this will just send heartbeat request, it will not wait for response
+        //if we will get heartbeat then it will change the timestamp, which we are 
+        //checking below in case of tcp check failure..
-          logger.info(
-              "Final check failed but detected recent message traffic for suspect member " + mbr);
+          logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
-  public void memberShutdown(DistributedMember mbr, String reason) {}
+  public void memberShutdown(DistributedMember mbr, String reason) {
+  }
-    // synchronized (suspectRequests) {
-    // if (suspectRequests.size() > 0) {
-    // for (SuspectRequest sr: suspectRequests) {
-    // if (!requests.contains(sr)) {
-    // requests.add(sr);
-    // }
-    // }
-    // suspectRequests.clear();
-    // }
-    // }
+    //    synchronized (suspectRequests) {
+    //      if (suspectRequests.size() > 0) {
+    //        for (SuspectRequest sr: suspectRequests) {
+    //          if (!requests.contains(sr)) {
+    //            requests.add(sr);
+    //          }
+    //        }
+    //        suspectRequests.clear();
+    //      }
+    //    }
-      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e
-          .hasMoreElements();) {
+      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e.hasMoreElements(); ) {
-      filter.addAll(
-          requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
-      recipients =
-          currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
+      filter.addAll(requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
+      recipients = currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
+

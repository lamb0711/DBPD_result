GEODE-7800: Add Redis PSUBSCRIBE and PUNSUBSCRIBE commands (#4705)

* GEODE-7800: Add Redis PSUBSCRIBE and PUNSUBSCRIBE commands

Similar to `SUBSCRIBE` and `UNSUBSCRIBE`, `PSUBSCRIBE` allows a client
to subscribe to a pattern. For example: `PSUBSCRIBE sal*s`

The subscription pattern is in the form of a glob supporting `*`, `?`
and ranges. https://redis.io/commands/psubscribe

Pattern subscriptions must be unsubscribed verbatim. i.e., the above
subscription would not be unsubscribed using the pattern `s*`, but must
be unsubscribed using the complete subscribed pattern, namely `sal*s`.

When clients subscribe to overlapping patterns (or channels) they will
receive a message for every matched subscription. Matches for a single
client are not conflated.

    Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
    Co-authored-by: John Hutchison <jhutchison@pivotal.io>
    Co-authored-by: Jens Deppe <jdeppe@pivotal.io>

* Fixes class names in sanctioned-geode-redis-serializables.txt

* Fixes flaky test

* Adds license to PublishResult

* Clean code using spA and make test reliable

stop propagating exceptions that get thrown when disconnecting Jedis

* Cleans up subscribers and publishers after each test or after the whole class as needed

* re-add ignoreExceptions to waitfor test helper method

Co-authored-by: Jens Deppe <jdeppe@pivotal.io>
Co-authored-by: Venkateswara Prasath Durairaj <xtreme-prasath@users.noreply.github.com>

-import java.util.ArrayList;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.redis.internal.org.apache.hadoop.fs.GlobPattern;
-  private Subscribers subscribers = new Subscribers();
+  private final Subscriptions subscriptions;
-  public PubSubImpl() {
+  public PubSubImpl(Subscriptions subscriptions) {
+    this.subscriptions = subscriptions;
+
-    if (subscribers.exists(channel, client)) {
-      return subscribers.findSubscribers(client).size();
+    if (subscriptions.exists(channel, client)) {
+      return subscriptions.findSubscriptions(client).size();
-    Subscriber subscriber = new Subscriber(client, channel, context);
-    subscribers.add(subscriber);
-    return subscribers.findSubscribers(client).size();
+    Subscription subscription = new ChannelSubscription(client, channel, context);
+    subscriptions.add(subscription);
+    return subscriptions.findSubscriptions(client).size();
+  }
+
+  @Override
+  public long psubscribe(GlobPattern pattern, ExecutionHandlerContext context, Client client) {
+    if (subscriptions.exists(pattern, client)) {
+      return subscriptions.findSubscriptions(client).size();
+    }
+    Subscription subscription = new PatternSubscription(client, pattern, context);
+    subscriptions.add(subscription);
+
+    return subscriptions.findSubscriptions(client).size();
-    this.subscribers.remove(channel, client);
-    return this.subscribers.findSubscribers(client).size();
+    this.subscriptions.remove(channel, client);
+    return this.subscriptions.findSubscriptions(client).size();
-  private long publishMessageToSubscribers(String channel, String message) {
-    Map<Boolean, List<Subscriber>> results = this.subscribers
-        .findSubscribers(channel)
+  @Override
+  public long punsubscribe(GlobPattern pattern, Client client) {
+    this.subscriptions.remove(pattern, client);
+    return this.subscriptions.findSubscriptions(client).size();
+  }
+
+  @VisibleForTesting
+  long publishMessageToSubscribers(String channel, String message) {
+
+    Map<Boolean, List<PublishResult>> results = this.subscriptions
+        .findSubscriptions(channel)
-        .collect(
-            Collectors.partitioningBy(subscriber -> subscriber.publishMessage(channel, message)));
+        .map(subscription -> subscription.publishMessage(channel, message))
+        .collect(Collectors.partitioningBy(PublishResult::isSuccessful));
-  private void prune(List<Subscriber> failedSubscribers) {
-    failedSubscribers.forEach(subscriber -> {
-      if (subscriber.client.isDead()) {
-        subscribers.remove(subscriber.client);
+  private void prune(List<PublishResult> failedSubscriptions) {
+    failedSubscriptions.forEach(publishResult -> {
+      Client client = publishResult.getClient();
+      if (client.isDead()) {
+        subscriptions.remove(client);
-
-  private class Subscribers {
-    List<Subscriber> subscribers = new ArrayList<>();
-
-    private boolean exists(String channel, Client client) {
-      return subscribers.stream().anyMatch(subscriber -> subscriber.isEqualTo(channel, client));
-    }
-
-    private List<Subscriber> findSubscribers(Client client) {
-      return subscribers.stream().filter(subscriber -> subscriber.client.equals(client))
-          .collect(Collectors.toList());
-    }
-
-    private List<Subscriber> findSubscribers(String channel) {
-      return subscribers.stream().filter(subscriber -> subscriber.channel.equals(channel))
-          .collect(Collectors.toList());
-    }
-
-    public void add(Subscriber subscriber) {
-      this.subscribers.add(subscriber);
-    }
-
-    public void remove(String channel, Client client) {
-      this.subscribers.removeIf(subscriber -> subscriber.isEqualTo(channel, client));
-    }
-
-    public void remove(Client client) {
-      this.subscribers.removeIf(subscriber -> subscriber.client.equals(client));
-    }
-  }

GEODE-5828: fixes replicates miss transaction commit. (#2571)

* GEODE-5828: fixes replicates miss transaction commit.

 * Always send CommitProcessQueryMessage to other replicates to see if anyone received second message
   as transaction originator for client transaction will be different from transation host.
 * Do not wait for transaction originator to depart when transaction host is crashed. Originator may
   not be the same as the crashed transaction host and never departs from distributed system.

* fix review comments.

-
-      final boolean processMsgReceived = txTracker.commitProcessReceived(this.trackerKey, dm);
+      final boolean processMsgReceived = txTracker.commitProcessReceived(this.trackerKey);
-    this.dm.removeMembershipListener(this);
+    getDistributionManager().removeMembershipListener(this);
-    if (this.farSiders != null && !this.farSiders.isEmpty()) {
+    if (getFarSiders() != null && !getFarSiders().isEmpty()) {
-          final TXCommitMessage mess = TXCommitMessage.this;
-          Object trackerKey = mess.getTrackerKey();
-          DistributedMember member = getMemberFromTrackerKey(trackerKey);
-          if (!mess.getSender().equals(member)) {
-            /*
-             * Do not send a CommitProcessQueryMessage when the sender of CommitMessage is not the
-             * member in the tracker key. (If this happens we are the redundant node for PR, and the
-             * primary just crashed).
-             */
-            txTracker.removeMessage(mess);
-            return;
-          }
-          CommitProcessQueryReplyProcessor replProc =
-              new CommitProcessQueryReplyProcessor(mess.dm, mess.farSiders);
-          CommitProcessQueryMessage query =
-              new CommitProcessQueryMessage(mess.getTrackerKey(), replProc.getProcessorId());
-          query.setRecipients(mess.farSiders);
-          mess.dm.putOutgoing(query);
-          // Wait for any one positive response or all negative responses.
-          // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
-          TXCommitMessage.this.dm.getCancelCriterion().checkCancelInProgress(null);
-          try {
-            replProc.waitForRepliesUninterruptibly();
-          } catch (ReplyException e) {
-            e.handleCause();
-          }
-          if (replProc.receivedACommitProcessMessage()) {
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
-                  mess.lockId, id);
-            }
-
-            try {
-              // Set processor to zero to avoid the ack to the now departed origin
-              mess.processorId = 0;
-              mess.basicProcess();
-            } finally {
-              txTracker.processed(mess);
-            }
-          } else {
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
-                  mess.lockId, id);
-            }
-            txTracker.removeMessage(mess);
-          }
-
-        }
-
-        private DistributedMember getMemberFromTrackerKey(Object trackerKey) {
-          if (trackerKey instanceof TXId) {
-            TXId id1 = (TXId) trackerKey;
-            return id1.getMemberId();
-          } else if (trackerKey instanceof TXLockId) {
-            TXLockId id2 = (TXLockId) trackerKey;
-            return id2.getMemberId();
-          }
-          return null;
+          doCommitProcessQuery(id);
+  HashSet getFarSiders() {
+    return farSiders;
+  }
+
+  DistributionManager getDistributionManager() {
+    return dm;
+  }
+
+  void doCommitProcessQuery(final InternalDistributedMember id) {
+    CommitProcessQueryReplyProcessor replyProcessor = createReplyProcessor();
+    CommitProcessQueryMessage queryMessage = createQueryMessage(replyProcessor);
+    queryMessage.setRecipients(this.farSiders);
+    getDistributionManager().putOutgoing(queryMessage);
+    // Wait for any one positive response or all negative responses.
+    // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
+    getDistributionManager().getCancelCriterion().checkCancelInProgress(null);
+    try {
+      replyProcessor.waitForRepliesUninterruptibly();
+    } catch (ReplyException e) {
+      e.handleCause();
+    }
+    if (replyProcessor.receivedACommitProcessMessage()) {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
+            lockId, id);
+      }
+
+      try {
+        // Set processor to zero to avoid the ack to the now departed origin
+        processorId = 0;
+        basicProcess();
+      } finally {
+        txTracker.processed(this);
+      }
+    } else {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
+            lockId, id);
+      }
+      txTracker.removeMessage(this);
+    }
+  }
+
+  CommitProcessQueryReplyProcessor createReplyProcessor() {
+    return new CommitProcessQueryReplyProcessor(dm, farSiders);
+  }
+
+  CommitProcessQueryMessage createQueryMessage(CommitProcessQueryReplyProcessor replyProcessor) {
+    return new CommitProcessQueryMessage(getTrackerKey(), replyProcessor.getProcessorId());
+  }
+
+  private DistributedMember getMemberFromTrackerKey(Object trackerKey) {
+    if (trackerKey instanceof TXId) {
+      TXId id1 = (TXId) trackerKey;
+      return id1.getMemberId();
+    } else if (trackerKey instanceof TXLockId) {
+      TXLockId id2 = (TXLockId) trackerKey;
+      return id2.getMemberId();
+    }
+    return null;
+  }
+

GEODE-7503: Add new unit tests for GemFireCacheImpl

Inject dependencies into GemFireCacheImpl constructor.

+import java.util.function.Consumer;
+import java.util.function.Function;
+import org.apache.geode.StatisticsFactory;
+import org.apache.geode.annotations.VisibleForTesting;
-  volatile Throwable disconnectCause; // used in Stopper inner class
+  private volatile Throwable disconnectCause;
+  /** Map of Futures used to track Regions that are being reinitialized */
+  private final ConcurrentMap<String, FutureResult<InternalRegion>> reinitializingRegions =
+      new ConcurrentHashMap<>();
+
+  private final HeapEvictorFactory heapEvictorFactory;
+  private final Consumer<Void> typeRegistryClose;
+  private final Function<InternalCache, String> typeRegistryGetPdxDiskStoreName;
+  private final Consumer<PdxSerializer> typeRegistrySetPdxSerializer;
+  private final TypeRegistryFactory typeRegistryFactory;
+  private final Consumer<org.apache.geode.cache.execute.Function> functionServiceRegisterFunction;
+  private final Function<Object, SystemTimer> systemTimerFactory;
+  private final ReplyProcessor21Factory replyProcessor21Factory;
+
-  /** Map of Futures used to track Regions that are being reinitialized */
-  private final ConcurrentMap<String, FutureResult<InternalRegion>> reinitializingRegions =
-      new ConcurrentHashMap<>();
-
+    this(isClient, poolFactory, internalDistributedSystem, cacheConfig, useAsyncEventListeners,
+        typeRegistry,
+        JNDIInvoker::mapTransactions,
+        SecurityServiceFactory::create,
+        () -> PoolManager.getAll().isEmpty(),
+        ManagementListener::new,
+        CqServiceProvider::create,
+        CachePerfStats::new,
+        TXManagerImpl::new,
+        PersistentMemberManager::new,
+        ResourceAdvisor::createResourceAdvisor,
+        JmxManagerAdvisee::new,
+        JmxManagerAdvisor::createJmxManagerAdvisor,
+        InternalResourceManager::createResourceManager,
+        DistributionAdvisor::createSerialNumber,
+        HeapEvictor::new,
+        VOID -> TypeRegistry.init(),
+        VOID -> TypeRegistry.open(),
+        VOID -> TypeRegistry.close(),
+        TypeRegistry::getPdxDiskStoreName,
+        TypeRegistry::setPdxSerializer,
+        TypeRegistry::new,
+        HARegionQueue::setMessageSyncInterval,
+        FunctionService::registerFunction,
+        object -> new SystemTimer(object, true),
+        TombstoneService::initialize,
+        ExpirationScheduler::new,
+        DiskStoreMonitor::new,
+        GatewaySenderQueueEntrySynchronizationListener::new,
+        BackupService::new,
+        ClientMetadataService::new,
+        TXEntryState.getFactory(),
+        ReplyProcessor21::new);
+  }
+
+  @VisibleForTesting
+  GemFireCacheImpl(boolean isClient, PoolFactory poolFactory,
+      InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig,
+      boolean useAsyncEventListeners, TypeRegistry typeRegistry,
+      Consumer<DistributedSystem> jndiTransactionMapper,
+      InternalSecurityServiceFactory securityServiceFactory,
+      Supplier<Boolean> isPoolManagerEmpty,
+      Function<InternalDistributedSystem, ManagementListener> managementListenerFactory,
+      Function<InternalCache, CqService> cqServiceFactory,
+      CachePerfStatsFactory cachePerfStatsFactory,
+      TXManagerImplFactory txManagerImplFactory,
+      Supplier<PersistentMemberManager> persistentMemberManagerFactory,
+      Function<DistributionAdvisee, ResourceAdvisor> resourceAdvisorFactory,
+      Function<InternalCacheForClientAccess, JmxManagerAdvisee> jmxManagerAdviseeFactory,
+      Function<JmxManagerAdvisee, JmxManagerAdvisor> jmxManagerAdvisorFactory,
+      Function<InternalCache, InternalResourceManager> internalResourceManagerFactory,
+      Supplier<Integer> serialNumberSupplier,
+      HeapEvictorFactory heapEvictorFactory,
+      Consumer<Void> typeRegistryInit,
+      Consumer<Void> typeRegistryOpen,
+      Consumer<Void> typeRegistryClose,
+      Function<InternalCache, String> typeRegistryGetPdxDiskStoreName,
+      Consumer<PdxSerializer> typeRegistrySetPdxSerializer,
+      TypeRegistryFactory typeRegistryFactory,
+      Consumer<Integer> haRegionQueueSetMessageSyncInterval,
+      Consumer<org.apache.geode.cache.execute.Function> functionServiceRegisterFunction,
+      Function<Object, SystemTimer> systemTimerFactory,
+      Function<InternalCache, TombstoneService> tombstoneServiceFactory,
+      Function<InternalDistributedSystem, ExpirationScheduler> expirationSchedulerFactory,
+      Function<File, DiskStoreMonitor> diskStoreMonitorFactory,
+      Supplier<RegionEntrySynchronizationListener> gatewaySenderQueueEntrySynchronizationListener,
+      Function<InternalCache, BackupService> backupServiceFactory,
+      Function<Cache, ClientMetadataService> clientMetadataServiceFactory,
+      TXEntryStateFactory txEntryStateFactory,
+      ReplyProcessor21Factory replyProcessor21Factory) {
-    this.cacheConfig = cacheConfig; // do early for bug 43213
+    this.cacheConfig = cacheConfig;
+    this.heapEvictorFactory = heapEvictorFactory;
+    this.typeRegistryClose = typeRegistryClose;
+    this.typeRegistryGetPdxDiskStoreName = typeRegistryGetPdxDiskStoreName;
+    this.typeRegistrySetPdxSerializer = typeRegistrySetPdxSerializer;
+    this.typeRegistryFactory = typeRegistryFactory;
+    this.functionServiceRegisterFunction = functionServiceRegisterFunction;
+    this.systemTimerFactory = systemTimerFactory;
+    this.replyProcessor21Factory = replyProcessor21Factory;
+
-      // to prevent race with cache close. fixes bug 43987
-      JNDIInvoker.mapTransactions(internalDistributedSystem);
+      // to prevent race with cache close.
+      jndiTransactionMapper.accept(internalDistributedSystem);
-            SecurityServiceFactory.create(system.getConfig().getSecurityProps(), cacheConfig);
+            securityServiceFactory.create(system.getConfig().getSecurityProps(), cacheConfig);
-      if (!this.isClient && PoolManager.getAll().isEmpty()) {
+      if (!this.isClient && isPoolManagerEmpty.get()) {
-          resourceEventsListener = new ManagementListener(system);
+          resourceEventsListener = managementListenerFactory.apply(system);
-            system.getInternalLogWriter()
-                .info("Running in local mode since no locators were specified.");
+            logger.info("Running in local mode since no locators were specified.");
-        throw new IllegalStateException(
-            "Cannot create a Cache in an admin-only VM.");
+        throw new IllegalStateException("Cannot create a Cache in an admin-only VM.");
-      cqService = CqServiceProvider.create(this);
+      cqService = cqServiceFactory.apply(this);
-      cachePerfStats = new CachePerfStats(
+      cachePerfStats = cachePerfStatsFactory.create(
-      transactionManager = new TXManagerImpl(cachePerfStats, this, statisticsClock);
+      transactionManager = txManagerImplFactory.create(cachePerfStats, this, statisticsClock);
-      persistentMemberManager = new PersistentMemberManager();
+      persistentMemberManager = persistentMemberManagerFactory.get();
-      resourceAdvisor = ResourceAdvisor.createResourceAdvisor(this);
+      resourceAdvisor = resourceAdvisorFactory.apply(this);
-      jmxAdvisor = JmxManagerAdvisor
-          .createJmxManagerAdvisor(new JmxManagerAdvisee(getCacheForProcessingClientRequests()));
+      jmxAdvisor = jmxManagerAdvisorFactory.apply(jmxManagerAdviseeFactory.apply(cacheForClients));
-      resourceManager = InternalResourceManager.createResourceManager(this);
-      serialNumber = DistributionAdvisor.createSerialNumber();
+      resourceManager = internalResourceManagerFactory.apply(this);
+      serialNumber = serialNumberSupplier.get();
-      tombstoneService = TombstoneService.initialize(this);
+      tombstoneService = tombstoneServiceFactory.apply(this);
-      TypeRegistry.init();
+      typeRegistryInit.accept(null);
-      TypeRegistry.open();
+      typeRegistryOpen.accept(null);
-        HARegionQueue.setMessageSyncInterval(HARegionQueue.DEFAULT_MESSAGE_SYNC_INTERVAL);
+        haRegionQueueSetMessageSyncInterval.accept(HARegionQueue.DEFAULT_MESSAGE_SYNC_INTERVAL);
-      FunctionService.registerFunction(new PRContainsValueFunction());
-      expirationScheduler = new ExpirationScheduler(system);
+      functionServiceRegisterFunction.accept(new PRContainsValueFunction());
+      expirationScheduler = expirationSchedulerFactory.apply(system);
-      // uncomment following line when debugging CacheExistsException
-        creationStack = new Exception(
-            String.format("Created GemFireCache %s", toString()));
+        creationStack = new Exception(String.format("Created GemFireCache %s", toString()));
-      txEntryStateFactory = TXEntryState.getFactory();
+      this.txEntryStateFactory = txEntryStateFactory;
-      diskMonitor = new DiskStoreMonitor(systemConfig.getLogFile());
+      diskMonitor = diskStoreMonitorFactory.apply(systemConfig.getLogFile());
-      addRegionEntrySynchronizationListener(new GatewaySenderQueueEntrySynchronizationListener());
-      backupService = new BackupService(this);
+      addRegionEntrySynchronizationListener(gatewaySenderQueueEntrySynchronizationListener.get());
+      backupService = backupServiceFactory.apply(this);
-    clientMetadataService = new ClientMetadataService(this);
+    clientMetadataService = clientMetadataServiceFactory.apply(this);
+  @Override
-    FunctionService.registerFunction(new FindRestEnabledServersFunction());
+    functionServiceRegisterFunction.accept(new FindRestEnabledServersFunction());
-        pdxRegistry = new TypeRegistry(this, true);
+        pdxRegistry = typeRegistryFactory.create(this, true);
-        pdxRegistry = new TypeRegistry(this, false);
+        pdxRegistry = typeRegistryFactory.create(this, false);
-        heapEvictor = new HeapEvictor(this, statisticsClock);
+        heapEvictor = heapEvictorFactory.create(this, statisticsClock);
-      // fix for bug 36512 "GemFireCache.close is not thread safe"
-      // ALL CODE FOR CLOSE SHOULD NOW BE UNDER STATIC SYNCHRONIZATION
-      // OF synchronized (GemFireCache.class) {
+      // ALL CODE FOR CLOSE SHOULD NOW BE UNDER STATIC SYNCHRONIZATION OF GemFireCacheImpl.class
-            Set<? extends DistributedMember> otherMembers =
+            Set<InternalDistributedMember> otherMembers =
-            ReplyProcessor21 processor = new ReplyProcessor21(system, otherMembers);
+            ReplyProcessor21 processor = replyProcessor21Factory.create(system, otherMembers);
-      TypeRegistry.close();
-      // do this late to prevent 43412
-      TypeRegistry.setPdxSerializer(null);
+
+      typeRegistryClose.accept(null);
+      typeRegistrySetPdxSerializer.accept(null);
-      // Fix for #49856
+
-
-
-    String pdxDSName = TypeRegistry.getPdxDiskStoreName(this);
+    String pdxDSName = typeRegistryGetPdxDiskStoreName.apply(this);
-      ccpTimer = new SystemTimer(getDistributedSystem(), true);
+      ccpTimer = systemTimerFactory.apply(getDistributedSystem());
-    TypeRegistry.setPdxSerializer(serializer);
+    typeRegistrySetPdxSerializer.accept(serializer);
+  @Override
+
+  @VisibleForTesting
+  void setDisconnectCause(Throwable disconnectCause) {
+    this.disconnectCause = disconnectCause;
+  }
+
+  interface TXManagerImplFactory {
+    TXManagerImpl create(CachePerfStats cachePerfStats, InternalCache cache,
+        StatisticsClock statisticsClock);
+  }
+
+  interface InternalSecurityServiceFactory {
+    SecurityService create(Properties properties, CacheConfig cacheConfig);
+  }
+
+  interface CachePerfStatsFactory {
+    CachePerfStats create(StatisticsFactory factory, StatisticsClock clock);
+  }
+
+  interface TypeRegistryFactory {
+    TypeRegistry create(InternalCache cache, boolean disableTypeRegistry);
+  }
+
+  interface HeapEvictorFactory {
+    HeapEvictor create(InternalCache cache, StatisticsClock statisticsClock);
+  }
+
+  interface ReplyProcessor21Factory {
+    ReplyProcessor21 create(InternalDistributedSystem system,
+        Collection<InternalDistributedMember> initMembers);
+  }

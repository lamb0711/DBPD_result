GEODE-6825: Cleanup GMSLocator

General cleanup of code and fixup of IDE warnings.

* Remove unnecessary uses of this
* Remove use of transient from non-serializable class
* Make field(s) final
* Use more descriptive var names
* Change assert to non-assert null-check
* Use @VisibleForTesting annoation
* Remove Jira ticket numbers
* Make log4j statements use log4j parameters
* Declare vars closer to where they are used
* Use try-with-resource instead of try-finally
* Minor reformatting changes

+import java.util.Objects;
-  /* package */ static final int LOCATOR_FILE_STAMP = 0x7b8cf741;
+  static final int LOCATOR_FILE_STAMP = 0x7b8cf741;
-  private Services services;
-  private final LocatorStats stats;
-  private InternalDistributedMember localAddress;
-
+  private final LocatorStats locatorStats;
-  private Map<InternalDistributedMemberWrapper, byte[]> registerMbrVsPK = new ConcurrentHashMap<>();
+  private final Map<InternalDistributedMemberWrapper, byte[]> publicKeys =
+      new ConcurrentHashMap<>();
+
+  private volatile boolean isCoordinator;
+
+  private Services services;
+  private InternalDistributedMember localAddress;
-  private transient NetView view;
+  private NetView view;
-  private transient NetView recoveredView;
+  private NetView recoveredView;
-  private volatile boolean isCoordinator;
-
-   * @param stats the locator statistics object
+   * @param locatorStats the locator statistics object
-      boolean networkPartitionDetectionEnabled, LocatorStats stats, String securityUDPDHAlgo) {
+      boolean networkPartitionDetectionEnabled, LocatorStats locatorStats,
+      String securityUDPDHAlgo) {
-    if (this.locatorString == null || this.locatorString.length() == 0) {
-      this.locators = new ArrayList<>(0);
+    if (this.locatorString == null || this.locatorString.isEmpty()) {
+      locators = new ArrayList<>(0);
-      this.locators = GMSUtil.parseLocators(locatorString, bindAddress);
+      locators = GMSUtil.parseLocators(locatorString, bindAddress);
-    this.stats = stats;
+    this.locatorStats = locatorStats;
-      assert localAddress != null : "member address should have been established";
+      Objects.requireNonNull(localAddress, "member address should have been established");
-          synchronized (this.registrants) {
-            this.registrants.add(localAddress);
+          synchronized (registrants) {
+            registrants.add(localAddress);
-      this.notifyAll();
+      notifyAll();
-    this.viewFile = file.getAbsoluteFile();
-    return this.viewFile;
+    viewFile = file.getAbsoluteFile();
+    return viewFile;
-    if (this.viewFile == null) {
-      // GEODE-4180, use absolute paths
-      this.viewFile = new File("locator" + server.getPort() + "view.dat").getAbsoluteFile();
+    if (viewFile == null) {
+      viewFile = new File("locator" + server.getPort() + "view.dat").getAbsoluteFile();
-    synchronized (this.registrants) {
+    synchronized (registrants) {
-    logger.info("Peer locator received new membership view: " + view);
+    logger.info("Peer locator received new membership view: {}", view);
-    this.recoveredView = null;
+    recoveredView = null;
-      logger.info("Location services has received notification that this node is becoming"
-          + " membership coordinator");
+      logger.info(
+          "Location services has received notification that this node is becoming membership coordinator");
-    Object response = null;
-
+    Object response = null;
-        registerMbrVsPK.put(new InternalDistributedMemberWrapper(findRequest.getMemberID()),
+        publicKeys.put(new InternalDistributedMemberWrapper(findRequest.getMemberID()),
-      logger.debug("Rejecting a request to find the coordinator - membership services are"
-          + " still initializing");
+      logger.debug(
+          "Rejecting a request to find the coordinator - membership services are still initializing");
-    InternalDistributedMember coordinator = null;
-
-    boolean fromView = false;
-    NetView v = this.view;
-    if (v == null) {
-      v = this.recoveredView;
+    NetView responseView = view;
+    if (responseView == null) {
+      responseView = recoveredView;
-    if (v != null) {
+    InternalDistributedMember coordinator = null;
+    boolean fromView = false;
+    if (responseView != null) {
-      for (InternalDistributedMember id : v.getMembers()) {
+      for (InternalDistributedMember id : responseView.getMembers()) {
-          NetView newView = new NetView(v, v.getViewId());
+          NetView newView = new NetView(responseView, responseView.getViewId());
-          v = newView;
+          responseView = newView;
-      if (v.getViewId() > findRequest.getLastViewId()) {
+      if (responseView.getViewId() > findRequest.getLastViewId()) {
-        coordinator = v.getCoordinator(Collections.emptyList());
+        coordinator = responseView.getCoordinator(Collections.emptyList());
-        coordinator = v.getCoordinator(findRequest.getRejectedCoordinators());
+        coordinator = responseView.getCoordinator(findRequest.getRejectedCoordinators());
-        if (v != null && localAddress != null && !localAddress.equals(v.getCoordinator())) {
-          v = null;
+        if (responseView != null && localAddress != null
+            && !localAddress.equals(responseView.getCoordinator())) {
+          responseView = null;
-      if (v != null) {
-        coordinatorPublicKey = (byte[]) v.getPublicKey(coordinator);
+      if (responseView != null) {
+        coordinatorPublicKey = (byte[]) responseView.getPublicKey(coordinator);
-      return new FindCoordinatorResponse(coordinator, localAddress, fromView, v,
-          new HashSet<>(registrants),
-          this.networkPartitionDetectionEnabled, this.usePreferredCoordinators,
+      return new FindCoordinatorResponse(coordinator, localAddress, fromView, responseView,
+          new HashSet<>(registrants), networkPartitionDetectionEnabled, usePreferredCoordinators,
-      logger.warn("Peer locator is unable to delete persistent membership information in "
-          + viewFile.getAbsolutePath());
+      logger.warn("Peer locator is unable to delete persistent membership information in {}",
+          viewFile.getAbsolutePath());
-    try {
-      ObjectOutputStream oos = null;
-      try {
-        oos = new ObjectOutputStream(new FileOutputStream(viewFile));
-        oos.writeInt(LOCATOR_FILE_STAMP);
-        oos.writeInt(Version.CURRENT_ORDINAL);
-        DataSerializer.writeObject(view, oos);
-      } finally {
-        if (oos != null) {
-          oos.flush();
-          oos.close();
-        }
-      }
+    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(viewFile))) {
+      oos.writeInt(LOCATOR_FILE_STAMP);
+      oos.writeInt(Version.CURRENT_ORDINAL);
+      DataSerializer.writeObject(view, oos);
-      this.viewFile = null;
+      viewFile = null;
-
-    stats.endLocatorRequest(startTime);
+    locatorStats.endLocatorRequest(startTime);
-    stats.endLocatorResponse(startTime);
+    locatorStats.endLocatorResponse(startTime);
-  public byte[] getPublicKey(InternalDistributedMember mbr) {
-    return registerMbrVsPK.get(new InternalDistributedMemberWrapper(mbr));
+  public byte[] getPublicKey(InternalDistributedMember member) {
+    return publicKeys.get(new InternalDistributedMemberWrapper(member));
-    registerMbrVsPK.clear();
+    publicKeys.clear();
-
-  // test hook
+  @VisibleForTesting
-    } else {
-      synchronized (registrants) {
-        return new ArrayList<>(registrants);
-      }
+    }
+    synchronized (registrants) {
+      return new ArrayList<>(registrants);
-    for (HostAddress other : this.locators) {
+    for (HostAddress other : locators) {
-        logger.info("Peer locator recovered state from " + other);
+        logger.info("Peer locator recovered state from {}", other);
-    } // for
+    }
-      logger.info("Peer locator attempting to recover from " + other);
+      logger.info("Peer locator attempting to recover from {}", other);
-        this.view = ((GetViewResponse) response).getView();
+        view = ((GetViewResponse) response).getView();
-    } catch (IOException | ClassNotFoundException ex) {
+    } catch (IOException | ClassNotFoundException e) {
-          ex.getMessage());
+          e.getMessage());
-  /* package */ boolean recoverFromFile(File file) throws InternalGemFireException {
+  boolean recoverFromFile(File file) throws InternalGemFireException {
-      logger.info("recovery file not found: " + file.getAbsolutePath());
+      logger.info("recovery file not found: {}", file.getAbsolutePath());
-    logger.info("Peer locator recovering from " + file.getAbsolutePath());
+    logger.info("Peer locator recovering from {}", file.getAbsolutePath());
-      ObjectInput ois2 = ois;
-      int version = ois2.readInt();
+      ObjectInput input = ois;
+      int version = input.readInt();
-        ois2 = new VersionedObjectInput(ois2, geodeVersion);
+        input = new VersionedObjectInput(input, geodeVersion);
-      Object o = DataSerializer.readObject(ois2);
-      recoveredView = (NetView) o;
-      recoveredView.setViewId(-1); // this is not a valid view so it shouldn't have a usable Id
+      recoveredView = DataSerializer.readObject(input);
+      // this is not a valid view so it shouldn't have a usable Id
+      recoveredView.setViewId(-1);
-      // GEODE-3052 - remove locators from the view. Since we couldn't recover from an existing
+      // Remove locators from the view. Since we couldn't recover from an existing
-      logger.info("Peer locator recovered membership is " + recoveredView);
+      logger.info("Peer locator recovered membership is {}", recoveredView);
-      String msg =
+      String message =
-      logger.warn(msg, e);
+      logger.warn(message, e);
-        logger.warn("Peer locator was unable to recover from or delete " + file);
-        this.viewFile = null;
+        logger.warn("Peer locator was unable to recover from or delete {}", file);
+        viewFile = null;
-      throw new InternalGemFireException(msg, e);
+      throw new InternalGemFireException(message, e);
-

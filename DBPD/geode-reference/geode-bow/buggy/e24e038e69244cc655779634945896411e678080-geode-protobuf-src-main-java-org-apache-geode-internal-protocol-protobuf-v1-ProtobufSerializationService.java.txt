GEODE-4080: Protobuf JSON objects are in a proto string (#1171)

* GEODE-4080: Protobuf JSON objects are in a proto string

In the process, remove a couple of serialization-related classes that
are no longer really applicable.

* Catch `JSONFormatterException` and return it as a `EncodingException`.
* Change some names and add ProtobufSerializationService, which is the big
reason for all this churn.
* Get rid of the codec package
* Inline the serialization type enum
* Make encoding methods throw EncodingException.
* Don't use exceptions for control flow.

This meant renaming ProtobufPrimitiveTypes to ProtobufEncodingTypes.

Signed-off-by: Brian Rowe <browe@pivotal.io>
+import com.google.protobuf.ByteString;
+
+import org.apache.geode.internal.protocol.protobuf.v1.utilities.exception.UnknownProtobufEncodingType;
+import org.apache.geode.internal.protocol.serialization.JsonPdxConverter;
-import org.apache.geode.internal.protocol.serialization.SerializationType;
-import org.apache.geode.internal.protocol.serialization.TypeCodec;
-import org.apache.geode.internal.protocol.serialization.exception.UnsupportedEncodingTypeException;
-import org.apache.geode.internal.protocol.serialization.registry.SerializationCodecRegistry;
-import org.apache.geode.internal.protocol.serialization.registry.exception.CodecNotRegisteredForTypeException;
+import org.apache.geode.internal.protocol.serialization.exception.EncodingException;
+import org.apache.geode.pdx.PdxInstance;
-public class ProtobufSerializationService implements SerializationService<BasicTypes.EncodingType> {
-  private SerializationCodecRegistry serializationCodecRegistry = new SerializationCodecRegistry();
+public class ProtobufSerializationService implements SerializationService<BasicTypes.EncodedValue> {
+  private final JsonPdxConverter jsonPdxConverter = new JsonPdxConverter();
+  /**
+   * @param value the value to be encoded
+   *
+   * @return EncodedValue message with the serialized value
+   * @throws EncodingException
+   */
-  public byte[] encode(BasicTypes.EncodingType encodingTypeValue, Object value)
-      throws UnsupportedEncodingTypeException, CodecNotRegisteredForTypeException {
-    TypeCodec codecForType = getTypeCodecForProtobufType(encodingTypeValue);
-    return codecForType.encode(value);
-  }
-
-  @Override
-  public Object decode(BasicTypes.EncodingType encodingTypeValue, byte[] value)
-      throws UnsupportedEncodingTypeException, CodecNotRegisteredForTypeException {
-    if (encodingTypeValue == BasicTypes.EncodingType.INVALID) {
-      return null;
+  public BasicTypes.EncodedValue encode(Object value) throws EncodingException {
+    BasicTypes.EncodedValue.Builder builder = BasicTypes.EncodedValue.newBuilder();
+    try {
+      ProtobufEncodingTypes protobufEncodingTypes = ProtobufEncodingTypes.valueOf(value.getClass());
+      switch (protobufEncodingTypes) {
+        case INT: {
+          builder.setIntResult((Integer) value);
+          break;
+        }
+        case LONG: {
+          builder.setLongResult((Long) value);
+          break;
+        }
+        case SHORT: {
+          builder.setShortResult((Short) value);
+          break;
+        }
+        case BYTE: {
+          builder.setByteResult((Byte) value);
+          break;
+        }
+        case DOUBLE: {
+          builder.setDoubleResult((Double) value);
+          break;
+        }
+        case FLOAT: {
+          builder.setFloatResult((Float) value);
+          break;
+        }
+        case BINARY: {
+          builder.setBinaryResult(ByteString.copyFrom((byte[]) value));
+          break;
+        }
+        case BOOLEAN: {
+          builder.setBooleanResult((Boolean) value);
+          break;
+        }
+        case STRING: {
+          builder.setStringResult((String) value);
+          break;
+        }
+        case PDX_OBJECT: {
+          builder.setJsonObjectResult(jsonPdxConverter.encode((PdxInstance) value));
+          break;
+        }
+      }
+    } catch (UnknownProtobufEncodingType unknownProtobufEncodingType) {
+      throw new EncodingException("No protobuf encoding for type " + value.getClass().getName());
-    TypeCodec codecForType = getTypeCodecForProtobufType(encodingTypeValue);
-    return codecForType.decode(value);
+    return builder.build();
-  private TypeCodec getTypeCodecForProtobufType(BasicTypes.EncodingType encodingTypeValue)
-      throws UnsupportedEncodingTypeException, CodecNotRegisteredForTypeException {
-    SerializationType serializationTypeForEncodingType =
-        EncodingTypeTranslator.getSerializationTypeForEncodingType(encodingTypeValue);
-
-    return serializationCodecRegistry.getCodecForType(serializationTypeForEncodingType);
+  /**
+   * @param encodedValue - The value to be decoded
+   * @return A decoded object representing encodedValue
+   * @throws EncodingException if the value cannot be decoded.
+   */
+  @Override
+  public Object decode(BasicTypes.EncodedValue encodedValue) throws EncodingException {
+    switch (encodedValue.getValueCase()) {
+      case BINARYRESULT:
+        return encodedValue.getBinaryResult().toByteArray();
+      case BOOLEANRESULT:
+        return encodedValue.getBooleanResult();
+      case BYTERESULT:
+        return (byte) encodedValue.getByteResult();
+      case DOUBLERESULT:
+        return encodedValue.getDoubleResult();
+      case FLOATRESULT:
+        return encodedValue.getFloatResult();
+      case INTRESULT:
+        return encodedValue.getIntResult();
+      case LONGRESULT:
+        return encodedValue.getLongResult();
+      case SHORTRESULT:
+        return (short) encodedValue.getShortResult();
+      case STRINGRESULT:
+        return encodedValue.getStringResult();
+      case JSONOBJECTRESULT:
+        return jsonPdxConverter.decode(encodedValue.getJsonObjectResult());
+      case VALUE_NOT_SET:
+        return null;
+      default:
+        throw new EncodingException(
+            "Unknown Protobuf encoding type: " + encodedValue.getValueCase());
+    }
+
+  /**
+   * Maps classes to encoding for protobuf.
+   *
+   * This currently conflates object type with serialization, which may be an issue if we add more
+   * types of object serialization.
+   */
+  private enum ProtobufEncodingTypes {
+
+    STRING(String.class),
+    INT(Integer.class),
+    LONG(Long.class),
+    SHORT(Short.class),
+    BYTE(Byte.class),
+    BOOLEAN(Boolean.class),
+    DOUBLE(Double.class),
+    FLOAT(Float.class),
+    BINARY(byte[].class),
+
+    // This will probably have to change once the protocol supports multiple object encodings.
+    PDX_OBJECT(PdxInstance.class);
+
+    private Class clazz;
+
+    ProtobufEncodingTypes(Class clazz) {
+      this.clazz = clazz;
+    }
+
+    public static ProtobufEncodingTypes valueOf(Class unencodedValueClass)
+        throws UnknownProtobufEncodingType {
+      for (ProtobufEncodingTypes protobufEncodingTypes : values()) {
+        if (protobufEncodingTypes.clazz.equals(unencodedValueClass)) {
+          return protobufEncodingTypes;
+        }
+      }
+      throw new UnknownProtobufEncodingType(
+          "There is no primitive protobuf type mapping for class:" + unencodedValueClass);
+    }
+  }
+

 GEODE-6580: Cleanup static analyzer warnings. (#3415)

+
+import org.apache.geode.cache.server.CacheServer;
-  public static final boolean ENFORCE_SAFE_CLOSE = false;
+  private static final boolean ENFORCE_SAFE_CLOSE = false;
-  private final AtomicReference primaryMember = new AtomicReference();
+  private final AtomicReference<InternalDistributedMember> primaryMember = new AtomicReference<>();
-  protected final RegionAdvisor regionAdvisor;
+  private final RegionAdvisor regionAdvisor;
-    this.pRegion = this.regionAdvisor.getPartitionedRegion();
-    this.redundancyTracker =
+    pRegion = this.regionAdvisor.getPartitionedRegion();
+    redundancyTracker =
-  public void resetParentAdvisor(int bucketId) {
-    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(this.pRegion);
+  private void resetParentAdvisor(int bucketId) {
+    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(pRegion);
-              this.parentAdvisor =
+              parentAdvisor =
-        this.parentAdvisor = colocatedRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
+        parentAdvisor = colocatedRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
-      this.parentAdvisor = null;
+      parentAdvisor = null;
-    if (this.pRegion.isFixedPartitionedRegion()) {
-      List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
+    if (pRegion.isFixedPartitionedRegion()) {
+      List<FixedPartitionAttributesImpl> fpas = pRegion.getFixedPartitionAttributesImpl();
-            startingBucketAdvisor = this.regionAdvisor.getBucketAdvisor(fpa.getStartingBucketID());
+            startingBucketAdvisor = regionAdvisor.getBucketAdvisor(fpa.getStartingBucketID());
-  public void tryLockIfPrimary() {
+  void tryLockIfPrimary() {
-        this.primaryMoveWriteLock.lock();
+        primaryMoveWriteLock.lock();
-        this.primaryMoveWriteLock.unlock();
+        primaryMoveWriteLock.unlock();
-      this.primaryMoveWriteLock.lock();
+      primaryMoveWriteLock.lock();
-        this.primaryMoveWriteLock.unlock();
+        primaryMoveWriteLock.unlock();
-   * @return true if children were all deposed as primaries
-   * @guarded.By this
-  private boolean deposePrimaryForColocatedChildren() {
+  private void deposePrimaryForColocatedChildren() {
-
-    // getColocatedChildRegions returns only the child PRs directly colocated
-    // with thisPR...
-    List<PartitionedRegion> colocatedChildPRs =
-        ColocationHelper.getColocatedChildRegions(this.pRegion);
+    List<PartitionedRegion> colocatedChildPRs = ColocationHelper.getColocatedChildRegions(pRegion);
-    return deposedChildPrimaries;
-  private boolean deposeOtherPrimaryBucketForFixedPartition() {
+  private void deposeOtherPrimaryBucketForFixedPartition() {
-    List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> fpas = pRegion.getFixedPartitionAttributesImpl();
-        } else {
-          continue;
-    return deposedOtherPrimaries;
-    Profile locProfiles[] = this.profiles; // volatile read
+    Profile[] locProfiles = profiles; // volatile read
-  Queue getVolunteeringQueue() {
-    return this.regionAdvisor.getVolunteeringQueue();
+  private Queue<Runnable> getVolunteeringQueue() {
+    return regionAdvisor.getVolunteeringQueue();
-  Semaphore getVolunteeringSemaphore() {
-    return this.regionAdvisor.getVolunteeringSemaphore();
+  private Semaphore getVolunteeringSemaphore() {
+    return regionAdvisor.getVolunteeringSemaphore();
-  PartitionedRegionStats getPartitionedRegionStats() {
-    return this.regionAdvisor.getPartitionedRegionStats();
+  private PartitionedRegionStats getPartitionedRegionStats() {
+    return regionAdvisor.getPartitionedRegionStats();
-    this.regionAdvisor.incrementBucketCount(profile);
+    regionAdvisor.incrementBucketCount(profile);
-      this.notifyAll();
+      notifyAll();
-    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), profile.peerMemberId, false);
+    regionAdvisor.updateBucketStatus(getBucket().getId(), profile.peerMemberId, false);
-      this.notifyAll();
+      notifyAll();
-    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), profile.peerMemberId, false);
+    regionAdvisor.updateBucketStatus(getBucket().getId(), profile.peerMemberId, false);
-      this.regionAdvisor.updateBucketStatus(this.getBucket().getId(),
+      regionAdvisor.updateBucketStatus(getBucket().getId(),
-      this.regionAdvisor.decrementsBucketCount(profile);
+      regionAdvisor.decrementsBucketCount(profile);
-          profile.getDistributedMember(), profile);
+          profile != null ? profile.getDistributedMember() : null, profile);
-    ProfileId elector = this.primaryElector;
+    ProfileId elector = primaryElector;
-      this.primaryElector = getBucket().getDistributionManager().getId();
-      this.getBucket().getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
-        @Override
-        public void run() {
-          getBucket().getPartitionedRegion().getRedundancyProvider()
-              .finishIncompleteBucketCreation(getBucket().getId());
-        }
-      });
+      primaryElector = getBucket().getDistributionManager().getId();
+      getBucket().getDistributionManager().getWaitingThreadPool().execute(
+          () -> getBucket().getPartitionedRegion().getRedundancyProvider()
+              .finishIncompleteBucketCreation(getBucket().getId()));
-      return new SetFromMap<E>(map);
+      return new SetFromMap<>(map);
+  @SuppressWarnings("NullableProblems")
-    @SuppressWarnings("unchecked")
-      backingSet = m == null ? Collections.<E>emptySet() : m.keySet();
+      backingSet = m == null ? Collections.emptySet() : m.keySet();
-    int bucketId = this.getBucket().getId();
+    int bucketId = getBucket().getId();
-        newSetFromMap(new HashMap<ServerBucketProfile, Boolean>());
-    for (Profile p : this.profiles) {
+        newSetFromMap(new HashMap<>());
+    for (Profile p : profiles) {
-    this.regionAdvisor.setClientBucketProfiles(bucketId, serverProfiles);
+    regionAdvisor.setClientBucketProfiles(bucketId, serverProfiles);
-    this.localProfile = p;
+    localProfile = p;
-    return this.localProfile;
+    return localProfile;
-  public Set adviseProfileExchange() {
+  public Set<InternalDistributedMember> adviseProfileExchange() {
-    Assert.assertTrue(this.regionAdvisor.isInitialized());
-    return this.regionAdvisor.adviseBucketProfileExchange();
+    Assert.assertTrue(regionAdvisor.isInitialized());
+    return regionAdvisor.adviseBucketProfileExchange();
-  public Set adviseProfileUpdate() {
+  public Set<InternalDistributedMember> adviseProfileUpdate() {
-    return this.regionAdvisor.adviseGeneric();
+    return regionAdvisor.adviseGeneric();
-   * If the current member is primary for this bucket return true, otherwise, give some time for the
-   * current member to become primary and then return whether it is a primary (true/false).
-   */
-  public boolean isPrimaryWithWait() {
-    if (this.isPrimary()) {
-      return true;
-    }
-    // wait for the current member to become primary holder
-    InternalDistributedMember primary = waitForNewPrimary();
-    if (primary != null) {
-      return true;
-    }
-    return false;
-  }
-
-  /**
-    DistributionManager dm = this.regionAdvisor.getDistributionManager();
+    DistributionManager dm = regionAdvisor.getDistributionManager();
-    InternalDistributedMember newPrimary = waitForPrimaryMember(timeout);
-    return newPrimary;
+    return waitForPrimaryMember(timeout);
-  public void removePrimary(InternalDistributedMember member) {
+  private void removePrimary(InternalDistributedMember member) {
-        boolean wasPrimary = isPrimary() && this.getDistributionManager().getId().equals(member);
-        final InternalDistributedMember currentPrimary =
-            (InternalDistributedMember) this.primaryMember.get();
+        boolean wasPrimary = isPrimary() && getDistributionManager().getId().equals(member);
+        final InternalDistributedMember currentPrimary = primaryMember.get();
-          this.primaryMember.set(null);
+          primaryMember.set(null);
-          if (this.pRegion.isFixedPartitionedRegion()) {
+          if (pRegion.isFixedPartitionedRegion()) {
-                this.regionAdvisor.adviseFixedPrimaryPartitionDataStore(this.getBucket().getId());
-            if (primaryMember == null || primaryMember.equals(member)) {
-              needToVolunteerForPrimary = true;
-            } else {
-              needToVolunteerForPrimary = false;
-            }
+                regionAdvisor.adviseFixedPrimaryPartitionDataStore(getBucket().getId());
+            needToVolunteerForPrimary = primaryMember == null || primaryMember.equals(member);
-        Bucket br = this.regionAdvisor.getBucket(getBucket().getId());
-        if (br != null && br instanceof BucketRegion) {
+        Bucket br = regionAdvisor.getBucket(getBucket().getId());
+        if (br instanceof BucketRegion) {
-        if (this.pRegion.isFixedPartitionedRegion()) {
+        if (pRegion.isFixedPartitionedRegion()) {
-  protected void closeAdvisor() {
+  void closeAdvisor() {
-      this.requestPrimaryState(CLOSED);
-      this.redundancyTracker.closeBucket();
-      this.localProfile = null;
+      requestPrimaryState(CLOSED);
+      redundancyTracker.closeBucket();
+      localProfile = null;
-      return this.primaryState == CLOSED;
+      return primaryState == CLOSED;
-      return this.primaryState == IS_PRIMARY_HOSTING;
+      return primaryState == IS_PRIMARY_HOSTING;
-  protected boolean isVolunteering() {
+  private boolean isVolunteering() {
-      return this.primaryState == VOLUNTEERING_HOSTING;
+      return primaryState == VOLUNTEERING_HOSTING;
-  protected boolean isBecomingPrimary() {
+  private boolean isBecomingPrimary() {
-      return this.primaryState == BECOMING_HOSTING && this.volunteeringDelegate != null
-          && this.volunteeringDelegate.isAggressive();
+      return primaryState == BECOMING_HOSTING && volunteeringDelegate != null
+          && volunteeringDelegate.isAggressive();
-      return this.primaryState == NO_PRIMARY_HOSTING || this.primaryState == OTHER_PRIMARY_HOSTING
-          || this.primaryState == VOLUNTEERING_HOSTING || this.primaryState == BECOMING_HOSTING
-          || this.primaryState == IS_PRIMARY_HOSTING;
+      return primaryState == NO_PRIMARY_HOSTING || primaryState == OTHER_PRIMARY_HOSTING
+          || primaryState == VOLUNTEERING_HOSTING || primaryState == BECOMING_HOSTING
+          || primaryState == IS_PRIMARY_HOSTING;
-      if (this.volunteeringDelegate == null) {
+      if (volunteeringDelegate == null) {
-      this.volunteeringDelegate.volunteerForPrimary();
+      volunteeringDelegate.volunteerForPrimary();
-    this.volunteeringDelegate = delegate;
+    volunteeringDelegate = delegate;
-        this.getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+        getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-            this.wait(waitTime); // spurious wakeup ok
+            wait(waitTime); // spurious wakeup ok
-            vDelegate = this.volunteeringDelegate;
+            vDelegate = volunteeringDelegate;
-              this.volunteeringDelegate = vDelegate;
+              volunteeringDelegate = vDelegate;
-            if (this.volunteeringDelegate == null) {
-              this.volunteeringDelegate = new VolunteeringDelegate();
+            if (volunteeringDelegate == null) {
+              volunteeringDelegate = new VolunteeringDelegate();
-            this.volunteeringDelegate.volunteerForPrimary();
+            volunteeringDelegate.volunteerForPrimary();
-                DeposePrimaryBucketMessage.send(otherPrimary, this.pRegion, getBucket().getId());
+                DeposePrimaryBucketMessage.send(otherPrimary, pRegion, getBucket().getId());
-    return (InternalDistributedMember) this.primaryMember.get();
+    return primaryMember.get();
-  protected boolean acquiredPrimaryLock() {
+  private boolean acquiredPrimaryLock() {
-          Bucket br = this.regionAdvisor.getBucket(getBucket().getId());
-          if (br != null && br instanceof BucketRegion) {
+          Bucket br = regionAdvisor.getBucket(getBucket().getId());
+          if (br instanceof BucketRegion) {
-          Bucket br = this.regionAdvisor.getBucket(getBucket().getId());
-          if (br != null && br instanceof BucketRegion) {
+          Bucket br = regionAdvisor.getBucket(getBucket().getId());
+          if (br instanceof BucketRegion) {
-          if (br != null && br instanceof BucketRegion) {
+          if (br instanceof BucketRegion) {
-    PartitionListener[] listeners = this.pRegion.getPartitionListeners();
+    PartitionListener[] listeners = pRegion.getPartitionListeners();
-    for (int i = 0; i < listeners.length; i++) {
-      PartitionListener listener = listeners[i];
+    for (PartitionListener listener : listeners) {
-    PartitionListener[] listeners = this.pRegion.getPartitionListeners();
+    PartitionListener[] listeners = pRegion.getPartitionListeners();
-    for (int i = 0; i < listeners.length; i++) {
-      PartitionListener listener = listeners[i];
+    for (PartitionListener listener : listeners) {
-  DistributedMemberLock getPrimaryLock(boolean createDLS) {
+  private DistributedMemberLock getPrimaryLock(boolean createDLS) {
-      if (this.primaryLock == null) {
+      if (primaryLock == null) {
-          catch (IllegalStateException e) {
+          catch (IllegalStateException | DistributedSystemDisconnectedException e) {
-          } catch (DistributedSystemDisconnectedException e) {
-            // this would certainly prevent us from creating a DLS... messy
-            return null;
-          }
+          } // this would certainly prevent us from creating a DLS... messy
+
-        this.primaryLock = new DistributedMemberLock(dls, getAdvisee().getName(),
+        primaryLock = new DistributedMemberLock(dls, getAdvisee().getName(),
-      return this.primaryLock;
+      return primaryLock;
-  protected void acquirePrimaryRecursivelyForColocated() {
+  private void acquirePrimaryRecursivelyForColocated() {
-                if (acquired && this.pRegion.isFixedPartitionedRegion()) {
+                if (acquired && pRegion.isFixedPartitionedRegion()) {
-  protected void acquirePrimaryForRestOfTheBucket() {
-    List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
+  private void acquirePrimaryForRestOfTheBucket() {
+    List<FixedPartitionAttributesImpl> fpas = pRegion.getFixedPartitionAttributesImpl();
-        } else {
-          continue;
-  protected boolean setVolunteering() {
+  private boolean setVolunteering() {
-  protected boolean setBecoming() {
+  private boolean setBecoming() {
-  protected InternalDistributedMember waitForPrimaryMember(long timeout) {
+  private InternalDistributedMember waitForPrimaryMember(long timeout) {
-          this.getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+          getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-                      new Object[] {warnTime / 1000L, this, this.adviseInitialized()});
+                      new Object[] {warnTime / 1000L, this, adviseInitialized()});
-          this.wait(timeLeft); // spurious wakeup ok
+          wait(timeLeft); // spurious wakeup ok
-          this.wait(timeLeft); // spurious wakeup ok
+          wait(timeLeft); // spurious wakeup ok
-  private static final long BUCKET_STORAGE_WAIT =
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "BUCKET_STORAGE_WAIT", 15000).longValue(); // 15
-                                                                                                  // seconds
-
-  public boolean waitForStorage() {
-    synchronized (this) {
-      // let's park this thread and wait for storage!
-      StopWatch timer = new StopWatch(true);
-      try {
-        for (;;) {
-          if (this.regionAdvisor.isBucketLocal(getBucket().getId())) {
-            return true;
-          }
-          getProxyBucketRegion().getPartitionedRegion().checkReadiness();
-          if (isClosed()) {
-            return false;
-          }
-          long timeLeft = BUCKET_STORAGE_WAIT - timer.elapsedTimeMillis();
-          if (timeLeft <= 0) {
-            return false;
-          }
-          if (logger.isDebugEnabled()) {
-            logger.debug("Waiting for bucket storage" + this);
-          }
-          this.wait(timeLeft); // spurious wakeup ok
-        }
-      } catch (InterruptedException e) {
-        // abort and return null
-        Thread.currentThread().interrupt();
-      }
-      return false;
-    }
-  }
-
-  public synchronized void clearPrimaryElector() {
+  synchronized void clearPrimaryElector() {
-  public synchronized void setPrimaryElector(InternalDistributedMember newPrimaryElector) {
+  synchronized void setPrimaryElector(InternalDistributedMember newPrimaryElector) {
-    if (this.primaryElector != null) {
+    if (primaryElector != null) {
-        this.primaryElector = null;
+        primaryElector = null;
-        this.primaryElector = newPrimaryElector;
+        primaryElector = newPrimaryElector;
-        this.primaryElector = null;
+        primaryElector = null;
-        this.primaryElector = newPrimaryElector;
+        primaryElector = newPrimaryElector;
-    boolean wasPrimary = false;
+    boolean wasPrimary;
-            this.primaryMember.set(null);
+            primaryMember.set(null);
-      this.volunteeringDelegate = null;
+      volunteeringDelegate = null;
-        this.notifyAll();
+        notifyAll();
-    if (this.getDistributionManager().getSystem().isLoner()) {
+    if (getDistributionManager().getSystem().isLoner()) {
-    final int partitionedRegionId = this.pRegion.getPRId();
+    final int partitionedRegionId = pRegion.getPRId();
-    HashSet hostsAndProxyMembers = new HashSet();
+    HashSet<InternalDistributedMember> hostsAndProxyMembers = new HashSet<>();
-      return this.primaryState == OTHER_PRIMARY_NOT_HOSTING
-          || this.primaryState == OTHER_PRIMARY_HOSTING || this.primaryState == IS_PRIMARY_HOSTING;
+      return primaryState == OTHER_PRIMARY_NOT_HOSTING
+          || primaryState == OTHER_PRIMARY_HOSTING || primaryState == IS_PRIMARY_HOSTING;
-    if (!this.pRegion.isShadowPR()) {
+    if (!pRegion.isShadowPR()) {
-      List servers = null;
-      servers = cache.getCacheServers();
+      List<CacheServer> servers = cache.getCacheServers();
-      HashSet<BucketServerLocation66> serverLocations = new HashSet<BucketServerLocation66>();
-      for (Object object : servers) {
-        CacheServerImpl server = (CacheServerImpl) object;
+      HashSet<BucketServerLocation66> serverLocations = new HashSet<>();
+      for (CacheServer cacheServer : servers) {
+        CacheServerImpl server = (CacheServerImpl) cacheServer;
-              server.getPort(), server.getExternalAddress()
-              /* .getExternalAddress(false/ checkServerRunning ) */, getBucket().isPrimary(), Integer.valueOf(version).byteValue(), server.getCombinedGroups());
+              server.getPort(), server.getExternalAddress(), getBucket().isPrimary(),
+              Integer.valueOf(version).byteValue(), server.getCombinedGroups());
-  void setPrimaryMember(InternalDistributedMember id) {
+  private void setPrimaryMember(InternalDistributedMember id) {
-    this.primaryMember.set(id);
-    this.everHadPrimary = true;
+    primaryMember.set(id);
+    everHadPrimary = true;
-    this.notifyAll(); // wake up any threads in waitForPrimaryMember
+    notifyAll(); // wake up any threads in waitForPrimaryMember
-  public void setHadPrimary() {
-    this.everHadPrimary = true;
+  void setHadPrimary() {
+    everHadPrimary = true;
-  public boolean getHadPrimary() {
-    return this.everHadPrimary;
+  boolean getHadPrimary() {
+    return everHadPrimary;
-    Set primaryMembers = adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        assert profile instanceof BucketProfile;
-        BucketProfile srp = (BucketProfile) profile;
-        return srp.isPrimary;
-      }
+    Set<InternalDistributedMember> primaryMembers = adviseFilter(profile -> {
+      assert profile instanceof BucketProfile;
+      BucketProfile srp = (BucketProfile) profile;
+      return srp.isPrimary;
-    return (InternalDistributedMember[]) primaryMembers
-        .toArray(new InternalDistributedMember[primaryMembers.size()]);
+    return primaryMembers.toArray(new InternalDistributedMember[0]);
-  boolean findAndSetPrimaryMember() {
+  private boolean findAndSetPrimaryMember() {
-      setPrimaryMember(this.getDistributionManager().getDistributionManagerId());
+      setPrimaryMember(getDistributionManager().getDistributionManagerId());
-  public Set<InternalDistributedMember> adviseInitialized() {
-    return adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        assert profile instanceof BucketProfile;
-        BucketProfile bucketProfile = (BucketProfile) profile;
-        return bucketProfile.isHosting;
-      }
+  Set<InternalDistributedMember> adviseInitialized() {
+    return adviseFilter(profile -> {
+      assert profile instanceof BucketProfile;
+      BucketProfile bucketProfile = (BucketProfile) profile;
+      return bucketProfile.isHosting;
-  public Set<InternalDistributedMember> adviseRecoveredFromDisk() {
+  Set<InternalDistributedMember> adviseRecoveredFromDisk() {
-    Profile[] locProfiles = this.profiles; // grab current profiles
+    Profile[] locProfiles = profiles; // grab current profiles
-  protected void releasePrimaryLock() {
+  private void releasePrimaryLock() {
-    return primaryStateToString(this.primaryState);
+    return primaryStateToString(primaryState);
-    final byte fromState = this.primaryState;
+    final byte fromState = primaryState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-                new Object[] {this.primaryStateToString(),
-                    this.primaryStateToString(requestedState)}));
+                primaryStateToString(), primaryStateToString(requestedState)));
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-                new Object[] {this.primaryStateToString(),
-                    this.primaryStateToString(requestedState)}));
+                primaryStateToString(),
+                primaryStateToString(requestedState)));
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-                new Object[] {this.primaryStateToString(),
-                    this.primaryStateToString(requestedState)}));
+                primaryStateToString(),
+                primaryStateToString(requestedState)));
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState;
+            primaryState = requestedState;
-                new Object[] {this.primaryStateToString(),
-                    this.primaryStateToString(requestedState)}));
+                primaryStateToString(),
+                primaryStateToString(requestedState)));
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-                new Object[] {this.primaryStateToString(),
-                    this.primaryStateToString(requestedState)}));
+                primaryStateToString(),
+                primaryStateToString(requestedState)));
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-            this.primaryState = requestedState; {
+            primaryState = requestedState; {
-                new Object[] {this.primaryStateToString(),
-                    this.primaryStateToString(requestedState)}));
+                primaryStateToString(),
+                primaryStateToString(requestedState)));
-            throw new IllegalStateException("Cannot change from " + this.primaryStateToString()
-                + " to " + this.primaryStateToString(requestedState));
+            throw new IllegalStateException("Cannot change from " + primaryStateToString()
+                + " to " + primaryStateToString(requestedState));
-                    new Object[] {this.primaryStateToString(),
-                        this.primaryStateToString(requestedState), getAdvisee().getName()}));
+                    primaryStateToString(),
+                    primaryStateToString(requestedState), getAdvisee().getName()));
-    return this.primaryState == requestedState;
+    return primaryState == requestedState;
-      this.primaryState = requestedState;
+      primaryState = requestedState;
-    return this.regionAdvisor.adviseAllPRNodes();
+    return regionAdvisor.adviseAllPRNodes();
-  public Set adviseRequiresTwoMessages() {
+  public Set<InternalDistributedMember> adviseRequiresTwoMessages() {
-  public Set adviseNotInitialized() {
-    return adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        assert profile instanceof CacheProfile;
-        CacheProfile cp = (CacheProfile) profile;
-        return !cp.regionInitialized;
-      }
+  private Set<InternalDistributedMember> adviseNotInitialized() {
+    return adviseFilter(profile -> {
+      assert profile instanceof CacheProfile;
+      CacheProfile cp = (CacheProfile) profile;
+      return !cp.regionInitialized;
-    return this.regionAdvisor.adviseNetWrite();
+    return regionAdvisor.adviseNetWrite();
-    // String identity = super.toString();
-    // String identity = "BucketAdvisor " + getAdvisee().getFullPath() +
-    // ":" + getAdvisee().getSerialNumber();
-    // identity = identity.substring(identity.lastIndexOf(".")+1);
-    // final StringBuffer sb = new StringBuffer("[" + identity + ": ");
-  public void endBucketCreation() {
+  void endBucketCreation() {
-      this.isPrimary = bucket.isPrimary();
-      this.isHosting = bucket.isHosting();
+      isPrimary = bucket.isPrimary();
+      isHosting = bucket.isHosting();
-      sb.append("; isPrimary=" + this.isPrimary);
-      sb.append("; isHosting=" + this.isHosting);
-      sb.append("; isInitializing=" + this.isInitializing);
+      sb.append("; isPrimary=").append(isPrimary);
+      sb.append("; isHosting=").append(isHosting);
+      sb.append("; isInitializing=").append(isInitializing);
-      this.isPrimary = in.readBoolean();
-      this.isHosting = in.readBoolean();
-      this.isInitializing = in.readBoolean();
+      isPrimary = in.readBoolean();
+      isHosting = in.readBoolean();
+      isInitializing = in.readBoolean();
-      out.writeBoolean(this.isPrimary);
-      out.writeBoolean(this.isHosting);
-      out.writeBoolean(this.isInitializing);
+      out.writeBoolean(isPrimary);
+      out.writeBoolean(isHosting);
+      out.writeBoolean(isInitializing);
-      this.bucketId = bucket.getId();
-      this.bucketServerLocations = serverLocations;
+      bucketId = bucket.getId();
+      bucketServerLocations = serverLocations;
-        sb.append("; hostName=" + location.getHostName());
-        sb.append("; port=" + location.getPort());
+        sb.append("; hostName=").append(location.getHostName());
+        sb.append("; port=").append(location.getPort());
-      this.bucketServerLocations = SerializationHelper.readBucketServerLocationSet(in);
-      this.bucketId = DataSerializer.readPrimitiveInt(in);
+      bucketServerLocations = SerializationHelper.readBucketServerLocationSet(in);
+      bucketId = DataSerializer.readPrimitiveInt(in);
-      DataSerializer.writePrimitiveInt(this.bucketId, out);
+      DataSerializer.writePrimitiveInt(bucketId, out);
-      return this.bucketServerLocations;
+      return bucketServerLocations;
-      final int prime = 31;
-      int result = 1;
-      result = prime * bucketId + sl.getPort();
-      return result;
+      return 31 * bucketId + sl.getPort();
-      if (other.bucketId != this.bucketId) {
+      if (other.bucketId != bucketId) {
-      if (other.bucketServerLocations.size() != this.bucketServerLocations.size()) {
+      if (other.bucketServerLocations.size() != bucketServerLocations.size()) {
-      if (!other.bucketServerLocations.containsAll(this.bucketServerLocations)) {
-        return false;
-      }
-      return true;
+      return other.bucketServerLocations.containsAll(bucketServerLocations);
-        return this.aggressive;
+        return aggressive;
-          execute(new Runnable() {
-            @Override
-            public void run() {
-              doVolunteerForPrimary();
-            }
-          });
+          execute(this::doVolunteerForPrimary);
-        if (this.volunteeringThread != null) {
+        if (volunteeringThread != null) {
-        this.aggressive = true;
+        aggressive = true;
-          BucketAdvisor.this.primaryMoveWriteLock.lock();
+          primaryMoveWriteLock.lock();
-            boolean acquiredLock = false;
+            boolean acquiredLock;
-            BucketAdvisor.this.primaryMoveWriteLock.unlock();
+            primaryMoveWriteLock.unlock();
-      } catch (RegionDestroyedException e) {
-        handleException(e, false);
-      } catch (CancelException e) {
+      } catch (RegionDestroyedException | CancelException e) {
-        if (Thread.currentThread().equals(this.volunteeringThread)) {
+        if (Thread.currentThread().equals(volunteeringThread)) {
-        if (this.volunteeringThread != null) {
+        if (volunteeringThread != null) {
-        this.volunteeringThread = Thread.currentThread();
+        volunteeringThread = Thread.currentThread();
-            this.aggressive = false;
-            this.volunteeringThread = null;
+            aggressive = false;
+            volunteeringThread = null;
-        if (!Thread.currentThread().equals(this.volunteeringThread)) {
+        if (!Thread.currentThread().equals(volunteeringThread)) {
-        if (!isHosting()) {
-          return false;
-        }
+        return isHosting();
-        return true;
-      if (Thread.currentThread().equals(this.volunteeringThread)) {
-        this.volunteeringThread = null;
-        this.aggressive = false;
+      if (Thread.currentThread().equals(volunteeringThread)) {
+        volunteeringThread = null;
+        aggressive = false;
-      Queue volunteeringQueue = getVolunteeringQueue();
+      Queue<Runnable> volunteeringQueue = getVolunteeringQueue();
-      return new Runnable() {
-        @Override
-        public void run() {
-          getPartitionedRegionStats().incVolunteeringThreads(1);
-          boolean releaseSemaphore = true;
-          try {
-            Queue volunteeringQueue = getVolunteeringQueue();
-            Runnable queuedWork = null;
-            while (true) {
-              // SystemFailure.checkFailure();
-              getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-              synchronized (volunteeringQueue) {
-                // synchronized volunteeringQueue for coordination between threads adding
-                // work to the queue and checking for a consuming thread and the existing
-                // consuming thread to determine if it can exit since the queue is empty.
-                queuedWork = (Runnable) volunteeringQueue.poll();
-                if (queuedWork == null) {
-                  // the queue is empty... no more work... so return
-                  // @todo why release the semaphore here are sync'ed?
-                  // we could just let the finally block do it.
-                  getVolunteeringSemaphore().release();
-                  releaseSemaphore = false;
-                  return;
-                }
-                // still more work in the queue so let's run it
-              }
-              try {
-                queuedWork.run();
-              } catch (CancelException e) {
+      return () -> {
+        getPartitionedRegionStats().incVolunteeringThreads(1);
+        boolean releaseSemaphore = true;
+        try {
+          Queue<Runnable> volunteeringQueue = getVolunteeringQueue();
+          Runnable queuedWork;
+          while (true) {
+            // SystemFailure.checkFailure();
+            getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+            synchronized (volunteeringQueue) {
+              // synchronized volunteeringQueue for coordination between threads adding
+              // work to the queue and checking for a consuming thread and the existing
+              // consuming thread to determine if it can exit since the queue is empty.
+              queuedWork = volunteeringQueue.poll();
+              if (queuedWork == null) {
+                // the queue is empty... no more work... so return
+                // @todo why release the semaphore here are sync'ed?
+                // we could just let the finally block do it.
+                getVolunteeringSemaphore().release();
+                releaseSemaphore = false;
-              } catch (RuntimeException e) {
-                // log and continue consuming queue
-                logger.error(e.getMessage(), e);
+              // still more work in the queue so let's run it
-          } finally {
-            getPartitionedRegionStats().incVolunteeringThreads(-1);
-            if (releaseSemaphore) {
-              // Clean up, just in case
-              getVolunteeringSemaphore().release();
-              releaseSemaphore = false;
+            try {
+              queuedWork.run();
+            } catch (CancelException e) {
+              return;
+            } catch (RuntimeException e) {
+              // log and continue consuming queue
+              logger.error(e.getMessage(), e);
+        } finally {
+          getPartitionedRegionStats().incVolunteeringThreads(-1);
+          if (releaseSemaphore) {
+            // Clean up, just in case
+            getVolunteeringSemaphore().release();
+          }
-  public boolean setShadowBucketDestroyed(boolean destroyed) {
-    return this.shadowBucketDestroyed = destroyed;
+  void setShadowBucketDestroyed(boolean destroyed) {
+    shadowBucketDestroyed = destroyed;
-    return this.shadowBucketDestroyed;
+    return shadowBucketDestroyed;

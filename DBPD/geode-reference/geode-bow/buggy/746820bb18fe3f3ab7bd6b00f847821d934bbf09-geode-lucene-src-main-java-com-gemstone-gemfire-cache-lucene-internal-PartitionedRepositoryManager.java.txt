GEODE-11: create index repository using raw Lucene directory.

GEODE-11: add RawDirectory using index instance

GEODE-11: add abstract class for index and repositoryManager

remove commented lines in test code

-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import org.apache.lucene.analysis.Analyzer;
-
-import com.gemstone.gemfire.InternalGemFireError;
-import com.gemstone.gemfire.cache.Region;
-import com.gemstone.gemfire.cache.execute.RegionFunctionContext;
-import com.gemstone.gemfire.cache.lucene.internal.filesystem.FileSystemStats;
-import com.gemstone.gemfire.cache.lucene.internal.repository.RepositoryManager;
-import com.gemstone.gemfire.internal.cache.BucketNotFoundException;
-import com.gemstone.gemfire.internal.cache.BucketRegion;
-import com.gemstone.gemfire.internal.cache.execute.InternalRegionFunctionContext;
-import com.gemstone.gemfire.internal.util.concurrent.CopyOnWriteHashMap;
-public class PartitionedRepositoryManager implements RepositoryManager {
+public class PartitionedRepositoryManager extends AbstractPartitionedRepositoryManager {
-  /** map of the parent bucket region to the index repository
-   * 
-   * This is based on the BucketRegion in case a bucket is rebalanced, we don't want to 
-   * return a stale index repository. If a bucket moves off of this node and
-   * comes back, it will have a new BucketRegion object.
-   * 
-   * It is weak so that the old BucketRegion will be garbage collected. 
-   */
-  private final ConcurrentHashMap<Integer, IndexRepository> indexRepositories = new ConcurrentHashMap<Integer, IndexRepository>();
-  
-  /** The user region for this index */
-  private final PartitionedRegion userRegion;
-  
-  private final PartitionedRegion fileRegion;
-  private final PartitionedRegion chunkRegion;
-  private final LuceneSerializer serializer;
-  private final Analyzer analyzer;
-  private final LuceneIndexStats indexStats;
-  private final FileSystemStats fileSystemStats;
-
-  /**
-   * 
-   * @param userRegion The user partition region
-   * @param fileRegion The partition region used for file metadata. Should be colocated with the user pr
-   * @param chunkRegion The partition region users for chunk metadata.
-   * @param serializer The serializer that should be used for converting objects to lucene docs.
-   */
-  public PartitionedRepositoryManager(PartitionedRegion userRegion,
-                                      PartitionedRegion fileRegion,
-                                      PartitionedRegion chunkRegion,
-                                      LuceneSerializer serializer,
-                                      Analyzer analyzer,
-                                      LuceneIndexStats indexStats,
-                                      FileSystemStats fileSystemStats) {
-    this.userRegion = userRegion;
-    this.fileRegion = fileRegion;
-    this.chunkRegion = chunkRegion;
-    this.serializer = serializer;
-    this.analyzer = analyzer;
-    this.indexStats = indexStats;
-    this.fileSystemStats = fileSystemStats;
+  public PartitionedRepositoryManager(LuceneIndexImpl index,
+      LuceneSerializer serializer) {
+    super(index, serializer);
-  public IndexRepository getRepository(Region region, Object key, Object callbackArg) throws BucketNotFoundException {
-    BucketRegion userBucket = userRegion.getBucketRegion(key, callbackArg);
-    if(userBucket == null) {
-      throw new BucketNotFoundException("User bucket was not found for region " + region + "key " +  key + " callbackarg " + callbackArg);
-    }
-    
-    return getRepository(userBucket.getId());
-  }
-  
-  @Override
-  public Collection<IndexRepository> getRepositories(RegionFunctionContext ctx) throws BucketNotFoundException {
-    
-    Region<Object, Object> region = ctx.getDataSet();
-    Set<Integer> buckets = ((InternalRegionFunctionContext) ctx).getLocalBucketSet(region);
-    ArrayList<IndexRepository> repos = new ArrayList<IndexRepository>(buckets.size());
-    for(Integer bucketId : buckets) {
-      BucketRegion userBucket = userRegion.getDataStore().getLocalBucketById(bucketId);
-      if(userBucket == null) {
-        throw new BucketNotFoundException("User bucket was not found for region " + region + "bucket id " + bucketId);
-      } else {
-        repos.add(getRepository(userBucket.getId()));
-      }
-    }
-
-    return repos;
-  }
-
-  /**
-   * Return the repository for a given user bucket
-   */
-  private IndexRepository getRepository(Integer bucketId) throws BucketNotFoundException {
-    IndexRepository repo = indexRepositories.get(bucketId);
-    if(repo != null && !repo.isClosed()) {
-      return repo;
-    }
-
-    repo = indexRepositories.compute(bucketId, (key, oldRepository) -> {
-      if(oldRepository != null && !oldRepository.isClosed()) {
-        return oldRepository;
-      }
-      if(oldRepository != null) {
-        oldRepository.cleanup();
-      }
-
-      try {
-        return indexRepositoryFactory.createIndexRepository(bucketId, userRegion, fileRegion, chunkRegion, serializer,
-          analyzer, indexStats, fileSystemStats);
-      } catch(IOException e) {
-        throw new InternalGemFireError("Unable to create index repository", e);
-      }
-
-    });
-
-    if(repo == null) {
-      throw new BucketNotFoundException("Colocated index buckets not found for regions " + chunkRegion + ", " + fileRegion + " bucket id " + bucketId);
-    }
-
-    return repo;
+  public IndexRepository createOneIndexRepository(Integer bucketId,
+      LuceneSerializer serializer, LuceneIndexImpl index,
+      PartitionedRegion userRegion) throws IOException {
+    return indexRepositoryFactory.createIndexRepository(bucketId, serializer, index, userRegion);

GEODE-4693: fix JDBCLoader on non-object pdx fields (#1517)

If the region mapping has a pdxClassName then the JdbcLoader will look for a pdx type that is already defined and use its field types when creating the PdxInstance. If the pdx type does not have a field that corresponds to an existing column then an exception is thrown.

A pdx field of type "char" or an instance of "java.lang.Character" will be sent to SQL as a String of size 1.
A pdx field of type "Date" will be sent to SQL as a java.sql.Timestamp.

A new external API was added to GemFireCache. It is the method "registerPdxMetaData".
It only needs to be called on clients if they are going to do reads using a JdbcLoader of data that wa s not written using the JdbcWriter or JdbcAsyncWriter.
-import java.sql.ResultSetMetaData;
+import org.apache.geode.InternalGemFireException;
-import org.apache.geode.pdx.PdxInstanceFactory;
-  public SqlHandler(DataSourceManager manager, JdbcConnectorService configService) {
-    this(manager, new TableKeyColumnManager(), configService);
-  }
-
-  SqlHandler(DataSourceManager manager, TableKeyColumnManager tableKeyColumnManager,
+  public SqlHandler(DataSourceManager manager, TableKeyColumnManager tableKeyColumnManager,
-        PdxInstanceFactory factory = getPdxInstanceFactory(region, regionMapping);
-        String keyColumnName = getKeyColumnName(connection, tableName);
-        result = executeReadStatement(statement, columnList, factory, regionMapping, keyColumnName);
+        try (ResultSet resultSet = executeReadQuery(statement, columnList)) {
+          String keyColumnName = getKeyColumnName(connection, tableName);
+          InternalCache cache = (InternalCache) region.getRegionService();
+          SqlToPdxInstanceCreator sqlToPdxInstanceCreator =
+              new SqlToPdxInstanceCreator(cache, regionMapping, resultSet, keyColumnName);
+          result = sqlToPdxInstanceCreator.create();
+        }
+  private ResultSet executeReadQuery(PreparedStatement statement, List<ColumnValue> columnList)
+      throws SQLException {
+    setValuesInStatement(statement, columnList);
+    return statement.executeQuery();
+  }
+
+
-      throw new IllegalStateException("JDBC mapping for region " + regionName
+      throw new JdbcConnectorException("JDBC mapping for region " + regionName
-      throw new IllegalStateException("JDBC connection with name " + connectionConfigName
+      throw new JdbcConnectorException("JDBC connection with name " + connectionConfigName
-  private <K, V> PdxInstanceFactory getPdxInstanceFactory(Region<K, V> region,
-      RegionMapping regionMapping) {
-    InternalCache cache = (InternalCache) region.getRegionService();
-    String valueClassName = regionMapping.getPdxClassName();
-    PdxInstanceFactory factory;
-    if (valueClassName != null) {
-      factory = cache.createPdxInstanceFactory(valueClassName);
-    } else {
-      factory = cache.createPdxInstanceFactory("no class", false);
-    }
-    return factory;
-  }
-
-  PdxInstance executeReadStatement(PreparedStatement statement, List<ColumnValue> columnList,
-      PdxInstanceFactory factory, RegionMapping regionMapping, String keyColumnName)
-      throws SQLException {
-    PdxInstance pdxInstance = null;
-    setValuesInStatement(statement, columnList);
-    try (ResultSet resultSet = statement.executeQuery()) {
-      if (resultSet.next()) {
-        ResultSetMetaData metaData = resultSet.getMetaData();
-        int ColumnsNumber = metaData.getColumnCount();
-        for (int i = 1; i <= ColumnsNumber; i++) {
-          Object columnValue = resultSet.getObject(i);
-          String columnName = metaData.getColumnName(i);
-          String fieldName = mapColumnNameToFieldName(columnName, regionMapping);
-          if (regionMapping.isPrimaryKeyInValue() || !keyColumnName.equalsIgnoreCase(columnName)) {
-            factory.writeField(fieldName, columnValue, Object.class);
-          }
-        }
-        if (resultSet.next()) {
-          throw new JdbcConnectorException(
-              "Multiple rows returned for query: " + resultSet.getStatement().toString());
-        }
-        pdxInstance = factory.create();
-      }
-    }
-    return pdxInstance;
-  }
-
-      statement.setObject(index, columnValue.getValue());
+      Object value = columnValue.getValue();
+      if (value instanceof Character) {
+        value = ((Character) value).toString();
+      }
+      statement.setObject(index, value);
-  private String mapColumnNameToFieldName(String columnName, RegionMapping regionMapping) {
-    return regionMapping.getFieldNameForColumn(columnName);
-  }
-
-      if (updateCount != 1) {
-        throw new IllegalStateException("Unexpected updateCount " + updateCount);
-      }
+      assert updateCount == 1;
-      throw new IllegalArgumentException("unsupported operation " + operation);
+      throw new InternalGemFireException("unsupported operation " + operation);
+

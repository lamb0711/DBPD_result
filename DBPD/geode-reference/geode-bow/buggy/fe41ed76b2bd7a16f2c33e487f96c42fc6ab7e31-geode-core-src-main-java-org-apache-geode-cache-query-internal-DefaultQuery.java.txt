GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
+
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicLong;
-
-
- *
-
+
+
-  private final Cache cache;
-  // private Pool pool;
+
+  private final InternalCache cache;
+
-  protected AtomicLong totalExecutionTime = new AtomicLong(0);
-  private QueryStatistics stats;
-  // TODO : Toggle the flag appropriately when implementing the compile() functionality
-  private boolean isCompiled = false;
+  private final AtomicLong totalExecutionTime = new AtomicLong(0);
+
+  private final QueryStatistics stats;
-  public static final int COMPILED_QUERY_CLEAR_TIME =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Query.COMPILED_QUERY_CLEAR_TIME",
-          10 * 60 * 1000).intValue();
+  public static final int COMPILED_QUERY_CLEAR_TIME = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "Query.COMPILED_QUERY_CLEAR_TIME", 10 * 60 * 1000);
-  // Use to represent null result.
-  // Used while adding PR results to the results-queue, which is a blocking queue.
+  /**
+   * Use to represent null result. Used while adding PR results to the results-queue, which is a
+   * blocking queue.
+   */
+
-  // This is declared as array so that it can be synchronized between
-  // two threads to validate the state.
+  /**
+   * This is declared as array so that it can be synchronized between two threads to validate the
+   * state.
+   */
-  // Holds the CQ reference. In cases of peer PRs this will be set to null
-  // even though isCqQuery is set to true.
+  /**
+   * Holds the CQ reference. In cases of peer PRs this will be set to null even though isCqQuery is
+   * set to true.
+   */
-  private static final ThreadLocal<Boolean> pdxReadSerialized = new ThreadLocal() {
-    @Override
-    protected Boolean initialValue() {
-      return new Boolean(Boolean.FALSE);
-    }
-  };
+  private static final ThreadLocal<Boolean> pdxReadSerialized =
+      ThreadLocal.withInitial(() -> Boolean.FALSE);
-  // indicates query executed remotely
+  /** indicates query executed remotely */
-  public static final Set<String> reservedKeywords = new HashSet<String>();
+  public static final Set<String> reservedKeywords = new HashSet<>();
-          return new HashMap<String, Set<String>>();
+          return new HashMap<>();
-  public static void setPdxClasstofieldsmap(Map<String, Set<String>> map) {
-    pdxClassToFieldsMap.set(map);
-  }
-
-  public DefaultQuery(String queryString, Cache cache, boolean isForRemote) {
+  public DefaultQuery(String queryString, InternalCache cache, boolean isForRemote) {
-    CompiledSelect cs = this.getSimpleSelect();
+    CompiledSelect cs = getSimpleSelect();
-    this.traceOn = (compiler.isTraceRequested() || QUERY_VERBOSE);
+    this.traceOn = compiler.isTraceRequested() || QUERY_VERBOSE;
-  /*
+  /**
-
+  @Override
-    return stats;
+    return this.stats;
-
+  @Override
-
+  @Override
-  public Object execute(Object[] parameters) throws FunctionDomainException, TypeMismatchException,
+  @Override
+  public Object execute(Object[] params) throws FunctionDomainException, TypeMismatchException,
-    if (parameters == null) {
+    if (params == null) {
-    // If pool is associated with the Query; execute the query on pool.
-    // ServerSide query.
+    // If pool is associated with the Query; execute the query on pool. ServerSide query.
-      return executeOnServer(parameters);
+      return executeOnServer(params);
-    Object result = null;
-    QueryExecutor qe = checkQueryOnPR(parameters);
+    QueryExecutor qe = checkQueryOnPR(params);
+    Object result = null;
-      // Setting the readserialized flag for local queries
-      setPdxReadSerialized(cache, true);
-      ExecutionContext context = new QueryExecutionContext(parameters, this.cache, this);
+      // Setting the readSerialized flag for local queries
+      setPdxReadSerialized(this.cache, true);
+      ExecutionContext context = new QueryExecutionContext(params, this.cache, this);
-        result = qe.executeQuery(this, parameters, null);
+        result = qe.executeQuery(this, params, null);
-      // Get QueryMonitor.
-      if (GemFireCacheImpl.getInstance() != null) {
-        queryMonitor = GemFireCacheImpl.getInstance().getQueryMonitor();
-      }
+      queryMonitor = this.cache.getQueryMonitor();
+
-    } catch (QueryExecutionCanceledException e) {
+    } catch (QueryExecutionCanceledException ignore) {
-      if (canceledException != null) {
-        throw canceledException;
+      if (this.canceledException != null) {
+        throw this.canceledException;
-      setPdxReadSerialized(cache, false);
+      setPdxReadSerialized(this.cache, false);
-
-  // For Order by queries ,since they are already ordered by the comparator
-  // && it takes care of conversion, we do not have to wrap it in a wrapper
-  public boolean needsPDXDeserializationWrapper(boolean isQueryOnPR) {
-    if (!isRemoteQuery() && !this.cache.getPdxReadSerialized()) {
-      return true;
-      /*
-       * if(isQueryOnPR) { // if the query is on PR we need a top level pdx deserialization wrapper
-       * only in case of //order by query or non distinct query CompiledSelect cs =
-       * this.getSimpleSelect(); if(cs != null) { return cs.getOrderByAttrs() != null ; }else {
-       * return true; } }else { return true; }
-       */
-    } else {
-      return false;
-    }
+  /**
+   * For Order by queries ,since they are already ordered by the comparator && it takes care of
+   * conversion, we do not have to wrap it in a wrapper
+   */
+  private boolean needsPDXDeserializationWrapper(boolean isQueryOnPR) {
+    return !isRemoteQuery() && !this.cache.getPdxReadSerialized();
-      if (proxyCache != null) {
+      if (this.proxyCache != null) {
-      // } catch (QueryExecutionCanceledException e) {
-      // throw canceledException;
-    Object result = null;
-    // Check if QueryMonitor is eabled, if enabled add query to be monitored.
-    QueryMonitor queryMonitor = null;
+    // Check if QueryMonitor is enabled, if enabled add query to be monitored.
+    QueryMonitor queryMonitor = this.cache.getQueryMonitor();
-    if (GemFireCacheImpl.getInstance() != null) {
-      queryMonitor = GemFireCacheImpl.getInstance().getQueryMonitor();
-    }
+    Object result = null;
-      if (this.traceOn && this.cache != null) {
-
+      if (this.traceOn) {
-
+
-      observer.beforeQueryEvaluation(compiledQuery, context);
-      Object results = null;
+      observer.beforeQueryEvaluation(this.compiledQuery, context);
+      Object results = null;
-      } catch (QueryExecutionCanceledException e) {
+      } catch (QueryExecutionCanceledException ignore) {
-        if (canceledException != null) {
-          throw canceledException;
+        if (this.canceledException != null) {
+          throw this.canceledException;
-      // } catch (QueryExecutionCanceledException e) {
-      // throw canceledException;
-
-    // check for PartititionedRegions. If a PartitionedRegion is referred to in the query,
+    // check for PartitionedRegions. If a PartitionedRegion is referred to in the query,
-    // QueryExecutor foundPR = null;
-    // Region otherRgn = null;
-
-    List<QueryExecutor> prs = new ArrayList<QueryExecutor>();
-    for (Iterator itr = getRegionsInQuery(parameters).iterator(); itr.hasNext();) {
-      String regionPath = (String) itr.next();
+    List<QueryExecutor> prs = new ArrayList<>();
+    for (final Object o : getRegionsInQuery(parameters)) {
+      String regionPath = (String) o;
-    } else if (prs.size() > 1) { // colocation checks; valid for more the one PRs
+    } else if (prs.size() > 1) {
+      // colocation checks; valid for more the one PRs
+
-          if ((((PartitionedRegion) eachPR).getColocatedByList().contains(allPRs)
-              || ((PartitionedRegion) allPRs).getColocatedByList().contains(eachPR))) {
+          if (((PartitionedRegion) eachPR).getColocatedByList().contains(allPRs)
+              || ((PartitionedRegion) allPRs).getColocatedByList().contains(eachPR)) {
+
+
+        @Override
-          for (Iterator itr = projs.iterator(); itr.hasNext();) {
-            Object[] rawProj = (Object[]) itr.next();
+          for (Object proj1 : projs) {
+            Object[] rawProj = (Object[]) proj1;
-        List orderBys = select.getOrderByAttrs();
+        List<CompiledSortCriterion> orderBys = select.getOrderByAttrs();
-          for (Iterator itr = orderBys.iterator(); itr.hasNext();) {
-            CompiledValue orderBy = (CompiledValue) itr.next();
+          for (CompiledSortCriterion orderBy : orderBys) {
-    numExecutions.incrementAndGet();
-    totalExecutionTime.addAndGet(executionTime);
-    ((GemFireCacheImpl) this.cache).getCachePerfStats().endQueryExecution(executionTime);
+    this.numExecutions.incrementAndGet();
+    this.totalExecutionTime.addAndGet(executionTime);
+    this.cache.getCachePerfStats().endQueryExecution(executionTime);
-
+  @Override
-
+  @Override
-    return this.isCompiled;
+    return false;
-
-    return traceOn;
+    return this.traceOn;
-
+    @Override
-      return totalExecutionTime.get();
+      return DefaultQuery.this.totalExecutionTime.get();
+    @Override
-      return numExecutions.get();
+      return DefaultQuery.this.numExecutions.get();
-    compiledQuery.getRegionsInQuery(regions, parameters);
+    this.compiledQuery.getRegionsInQuery(regions, parameters);
-   *
-   * @return int idenitifying the limit. A value of -1 indicates that no limit is imposed or the
+   * @return int identifying the limit. A value of -1 indicates that no limit is imposed or the
-   * @throws QueryInvocationTargetException
-   * @throws NameResolutionException
-   * @throws TypeMismatchException
-   * @throws FunctionDomainException
-  public void setServerProxy(ServerProxy serverProxy) {
+  void setServerProxy(ServerProxy serverProxy) {
-    return canceledException;
+    return this.canceledException;
-  public boolean[] getQueryCompletedForMonitoring() {
+  boolean[] getQueryCompletedForMonitoring() {
-  public void setQueryCompletedForMonitoring(boolean value) {
+  // TODO: parameter value is always true
+  void setQueryCompletedForMonitoring(boolean value) {
+   * <p>
+   * TODO: parameter isCanceled is always true
-
+  @Override
-    StringBuffer tempBuff = new StringBuffer("Query String = ");
-    tempBuff.append(this.queryString);
-    tempBuff.append(';');
-    tempBuff.append("isCancelled = ");
-    tempBuff.append(this.isCanceled);
-    tempBuff.append("; Total Executions = ");
-    tempBuff.append(this.numExecutions);
-    tempBuff.append("; Total Execution Time = ");
-    tempBuff.append(this.totalExecutionTime);
-    return tempBuff.toString();
+    StringBuilder sb = new StringBuilder("Query String = ");
+    sb.append(this.queryString);
+    sb.append(';');
+    sb.append("isCancelled = ");
+    sb.append(this.isCanceled);
+    sb.append("; Total Executions = ");
+    sb.append(this.numExecutions);
+    sb.append("; Total Execution Time = ");
+    sb.append(this.totalExecutionTime);
+    return sb.toString();
-  public static String getLogMessage(QueryObserver observer, long startTime, int resultSize,
+  private static String getLogMessage(QueryObserver observer, long startTime, int resultSize,
+    float time = (NanoTimer.getTime() - startTime) / 1.0e6f;
+
-    String rowCountString = null;
-    float time = 0.0f;
-
-    time = (NanoTimer.getTime() - startTime) / 1.0e6f;
-
-      StringBuffer buf = new StringBuffer();
-      buf.append(" indexesUsed(");
-      buf.append(usedIndexes.size());
-      buf.append(")");
+      StringBuilder sb = new StringBuilder();
+      sb.append(" indexesUsed(");
+      sb.append(usedIndexes.size());
+      sb.append(')');
-        buf.append(":");
+        sb.append(':');
-          buf.append(entry.getKey().toString() + entry.getValue());
+          sb.append(entry.getKey()).append(entry.getValue());
-            buf.append(",");
+            sb.append(',');
-      usedIndexesString = buf.toString();
+      usedIndexesString = sb.toString();
-          + observer.getClass().getName() + ")";
+          + observer.getClass().getName() + ')';
+    String rowCountString = null;
-      rowCountString = " rowCount = " + resultSize + ";";
+      rowCountString = " rowCount = " + resultSize + ';';
-        + (usedIndexesString != null ? usedIndexesString : "") + " \"" + query + "\"";
+        + (usedIndexesString != null ? usedIndexesString : "") + " \"" + query + '"';
-  public static String getLogMessage(IndexTrackingQueryObserver indexObserver, long startTime,
+  private static String getLogMessage(IndexTrackingQueryObserver indexObserver, long startTime,
-    String usedIndexesString = null;
-    String rowCountString = null;
+    String usedIndexesString = null;
-      StringBuffer buf = new StringBuffer();
-      buf.append(" indexesUsed(");
-      buf.append(usedIndexes.size());
-      buf.append(")");
-      if (usedIndexes.size() > 0) {
-        buf.append(":");
+      StringBuilder sb = new StringBuilder();
+      sb.append(" indexesUsed(");
+      sb.append(usedIndexes.size());
+      sb.append(')');
+      if (!usedIndexes.isEmpty()) {
+        sb.append(':');
-          buf.append(entry.getKey().toString() + "(Results: " + entry.getValue() + ", Bucket: "
-              + bucket.getId() + ")");
+          sb.append(entry.getKey()).append("(Results: ").append(entry.getValue())
+              .append(", Bucket: ").append(bucket.getId()).append(")");
-            buf.append(",");
+            sb.append(',');
-      usedIndexesString = buf.toString();
+      usedIndexesString = sb.toString();
-          " indexesUsed(NA due to other observer in the way: " + otherObserver + ")";
+          " indexesUsed(NA due to other observer in the way: " + otherObserver + ')';
-    rowCountString = " rowCount = " + resultSize + ";";
-    return "Query Executed" + (startTime > 0L ? " in " + time + " ms;" : ";")
-        + (rowCountString != null ? rowCountString : "")
-        + (usedIndexesString != null ? usedIndexesString : "") + " \"" + query + "\"";
+    String rowCountString = " rowCount = " + resultSize + ';';
+    return "Query Executed" + (startTime > 0L ? " in " + time + " ms;" : ";") + rowCountString
+        + (usedIndexesString != null ? usedIndexesString : "") + " \"" + query + '"';
-  public Object execute(RegionFunctionContext context, Object[] parameters)
+  public Object execute(RegionFunctionContext context, Object[] params)
-    Object result = null;
-    if (parameters == null) {
+    if (params == null) {
-    QueryExecutor qe = checkQueryOnPR(parameters);
+    QueryExecutor qe = checkQueryOnPR(params);
+    Object result = null;
-        Set buckets = null;
-        buckets = (localDataSet).getBucketSet();
-        result = qe.executeQuery(this, parameters, buckets);
+        Set<Integer> buckets = localDataSet.getBucketSet();
+        result = qe.executeQuery(this, params, buckets);
-      // } catch (QueryExecutionCanceledException e) {
-      // throw canceledException;
-          DefaultQuery.getLogMessage(indexObserver, startTime, resultSize, queryString);
+          DefaultQuery.getLogMessage(indexObserver, startTime, resultSize, this.queryString);
-      Iterator<Collection> iterator = result.iterator();
-      while (iterator.hasNext()) {
-        resultSize += iterator.next().size();
+      for (Collection aResult : result) {
+        resultSize += aResult.size();
-          DefaultQuery.getLogMessage(indexObserver, startTime, resultSize, queryString);
+          DefaultQuery.getLogMessage(indexObserver, startTime, resultSize, this.queryString);
-    return isRemoteQuery;
+    return this.isRemoteQuery;
-   * 
-   * @param cs
-   * @param context
-  public void keepResultsSerialized(CompiledSelect cs, ExecutionContext context) {
+  void keepResultsSerialized(CompiledSelect cs, ExecutionContext context) {
-        setKeepSerialized(true);
+        setKeepSerialized();
-    return keepSerialized;
+    return this.keepSerialized;
-  private void setKeepSerialized(boolean keepSerialized) {
-    this.keepSerialized = keepSerialized;
+  private void setKeepSerialized() {
+    this.keepSerialized = true;
-
-    public void doTestHook(int spot);
+    void doTestHook(int spot);
-    public void doTestHook(String spot);
+    void doTestHook(String spot);

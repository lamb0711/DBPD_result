GEODE-5464: Generify DistributionManager and related classes (#2174)

GEODE-5464: Generify DistributionManager and related classes

* Augment various collections to use generics
* Inline some iterator loops that were trivially "foreach" loops
* remove unused code
* Inline some redundant local variables
* make some methods more private
* change some tests to use `InternalDistributedMember` instead of
  `DistributedMember`.
* Make ThrottlingMemLinkedQueueWithDMStats generic and use atomic.
  - The previous synchronization looked quite wrong.
-import java.util.NoSuchElementException;
-  public static final boolean DEBUG_NO_ACKNOWLEDGEMENTS =
+  private static final boolean DEBUG_NO_ACKNOWLEDGEMENTS =
-  private static ThreadLocal<Boolean> isStartupThread = new ThreadLocal();
+  private static ThreadLocal<Boolean> isStartupThread = new ThreadLocal<>();
-  protected final InternalDistributedMember localAddress;
+  private final InternalDistributedMember localAddress;
-  protected volatile Set<MembershipListener> allMembershipListeners = Collections.emptySet();
+  private volatile Set<MembershipListener> allMembershipListeners = Collections.emptySet();
-  private final Object allMembershipListenersLock = new MembershipListenersLock();
+  private final Object allMembershipListenersLock = new Object();
-  private final BlockingQueue<MemberEvent> membershipEventQueue = new LinkedBlockingQueue();
+  private final BlockingQueue<MemberEvent> membershipEventQueue = new LinkedBlockingQueue<>();
-  protected DistributionStats stats;
+  protected final DistributionStats stats;
-  private final Object membersLock = new MembersLock();
+  private final Object membersLock = new Object();
-  private ThrottlingMemLinkedQueueWithDMStats serialQueue;
+  private ThrottlingMemLinkedQueueWithDMStats<Runnable> serialQueue;
-      Collections.synchronizedMap(new HashMap<InternalDistributedMember, String>());
+      Collections.synchronizedMap(new HashMap<>());
-  volatile Throwable rootCause = null;
+  private volatile Throwable rootCause = null;
-
-
-          for (InternalDistributedMember m : (List<InternalDistributedMember>) distributionManager
+          for (InternalDistributedMember m : distributionManager
-    this.membershipListeners = new ConcurrentHashMap();
+    this.membershipListeners = new ConcurrentHashMap<>();
-    {
-      long statId = OSProcess.getId();
-      /*
-       * deadcoded since we don't know the channel id yet. if (statId == 0 || statId == -1) { statId
-       * = getMembershipPort(); }
-       */
-      this.stats = new DistributionStats(system, statId);
-      DistributionStats.enableClockStats = system.getConfig().getEnableTimeStatistics();
-    }
+
+    long statId = OSProcess.getId();
+    this.stats = new DistributionStats(system, statId);
+    DistributionStats.enableClockStats = system.getConfig().getEnableTimeStatistics();
-          this.serialQueue = new ThrottlingMemLinkedQueueWithDMStats(TOTAL_SERIAL_QUEUE_BYTE_LIMIT,
-              TOTAL_SERIAL_QUEUE_THROTTLE, SERIAL_QUEUE_SIZE_LIMIT, SERIAL_QUEUE_SIZE_THROTTLE,
-              this.stats.getSerialQueueHelper());
+          this.serialQueue =
+              new ThrottlingMemLinkedQueueWithDMStats<>(TOTAL_SERIAL_QUEUE_BYTE_LIMIT,
+                  TOTAL_SERIAL_QUEUE_THROTTLE, SERIAL_QUEUE_SIZE_LIMIT, SERIAL_QUEUE_SIZE_THROTTLE,
+                  this.stats.getSerialQueueHelper());
-        SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue,
+
+        this.serialThread = new SerialQueuedExecutorWithDMStats(poolQueue,
-        this.serialThread = executor;
-        BlockingQueue poolQueue;
+        BlockingQueue<Runnable> poolQueue;
-          poolQueue = new OverflowQueueWithDMStats(this.stats.getOverflowQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getOverflowQueueHelper());
-          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-        ThreadPoolExecutor pool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS,
+        this.threadPool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS,
-        this.threadPool = pool;
-        BlockingQueue poolQueue;
+        BlockingQueue<Runnable> poolQueue;
-          poolQueue = new OverflowQueueWithDMStats(this.stats.getHighPriorityQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getHighPriorityQueueHelper());
-          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-        BlockingQueue poolQueue;
+        BlockingQueue<Runnable> poolQueue;
-          poolQueue = new SynchronousQueue();
+          poolQueue = new SynchronousQueue<>();
-          poolQueue = new OverflowQueueWithDMStats(this.stats.getWaitingQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getWaitingQueueHelper());
-        BlockingQueue poolQueue;
-        poolQueue = new OverflowQueueWithDMStats(this.stats.getWaitingQueueHelper());
+        BlockingQueue<Runnable> poolQueue;
+        poolQueue = new OverflowQueueWithDMStats<>(this.stats.getWaitingQueueHelper());
-        BlockingQueue poolQueue;
+        BlockingQueue<Runnable> poolQueue;
-          poolQueue = new OverflowQueueWithDMStats(this.stats.getPartitionedRegionQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getPartitionedRegionQueueHelper());
-          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-          SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue,
+          this.partitionedRegionThread = new SerialQueuedExecutorWithDMStats(poolQueue,
-          this.partitionedRegionThread = executor;
-        BlockingQueue poolQueue;
+        BlockingQueue<Runnable> poolQueue;
-          poolQueue = new OverflowQueueWithDMStats(this.stats.getFunctionExecutionQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getFunctionExecutionQueueHelper());
-          poolQueue = new OverflowQueueWithDMStats(INCOMING_QUEUE_LIMIT,
+          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-          SerialQueuedExecutorWithDMStats executor = new SerialQueuedExecutorWithDMStats(poolQueue,
+          this.functionExecutionThread = new SerialQueuedExecutorWithDMStats(poolQueue,
-          this.functionExecutionThread = executor;
-  public static Boolean getIsStartupThread() {
+  private static Boolean getIsStartupThread() {
-  public static void setIsStartupThread(Boolean isStartup) {
+  private static void setIsStartupThread(Boolean isStartup) {
-  /* implementation of DM.getOldestMember */
-  @Override
-  public DistributedMember getOldestMember(Collection c) throws NoSuchElementException {
-    List<InternalDistributedMember> view = getViewMembers();
-    for (int i = 0; i < view.size(); i++) {
-      Object viewMbr = view.get(i);
-      Iterator it = c.iterator();
-      while (it.hasNext()) {
-        Object nextMbr = it.next();
-        if (viewMbr.equals(nextMbr)) {
-          return (DistributedMember) nextMbr;
-        }
-      }
-    }
-    throw new NoSuchElementException(
-        LocalizedStrings.DistributionManager_NONE_OF_THE_GIVEN_MANAGERS_IS_IN_THE_CURRENT_MEMBERSHIP_VIEW
-            .toLocalizedString());
-  }
-
-      for (;;) {
-        if (readyForMessages)
-          break;
+      while (!readyForMessages) {
-      } // for
+      }
-      for (;;) {
-        if (this.readyToSendMsgs)
-          break;
+      while (!this.readyToSendMsgs) {
-  public Set getDistributionManagerIds() {
+  public Set<InternalDistributedMember> getDistributionManagerIds() {
-        this.hostedLocatorsAll = new HashMap<InternalDistributedMember, Collection<String>>();
+        this.hostedLocatorsAll = new HashMap<>();
-          new HashMap<InternalDistributedMember, Collection<String>>(this.hostedLocatorsAll);
+          new HashMap<>(this.hostedLocatorsAll);
-            new HashMap<InternalDistributedMember, Collection<String>>(
+            new HashMap<>(
-  public Set getDistributionManagerIdsIncludingAdmin() {
+  public Set<InternalDistributedMember> getDistributionManagerIdsIncludingAdmin() {
-  public Set getOtherDistributionManagerIds() {
+  public Set<InternalDistributedMember> getOtherDistributionManagerIds() {
-    Set result = new HashSet(getDistributionManagerIds());
+    Set<InternalDistributedMember> result = new HashSet<>(getDistributionManagerIds());
-  public Set getOtherNormalDistributionManagerIds() {
+  public Set<InternalDistributedMember> getOtherNormalDistributionManagerIds() {
-    Set result = new HashSet(getNormalDistributionManagerIds());
+    Set<InternalDistributedMember> result = new HashSet<>(getNormalDistributionManagerIds());
-  public Set addMembershipListenerAndGetDistributionManagerIds(MembershipListener l) {
+  public Set<InternalDistributedMember> addMembershipListenerAndGetDistributionManagerIds(
+      MembershipListener l) {
-  public Set putOutgoing(final DistributionMessage msg) {
+  public Set<InternalDistributedMember> putOutgoing(final DistributionMessage msg) {
-      Set newAllMembershipListeners = new HashSet(this.allMembershipListeners);
+      Set<MembershipListener> newAllMembershipListeners =
+          new HashSet<>(this.allMembershipListeners);
-      Set newAllMembershipListeners = new HashSet(this.allMembershipListeners);
+      Set<MembershipListener> newAllMembershipListeners =
+          new HashSet<>(this.allMembershipListeners);
-    if (ds != null && ds.isDisconnecting()) {
-      return true;
-    }
-    return false;
+    return ds != null && ds.isDisconnecting();
-              (MemberEvent) ClusterDistributionManager.this.membershipEventQueue.take();
+              ClusterDistributionManager.this.membershipEventQueue.take();
-      HashSet tmp = new HashSet(this.adminConsoles);
+      HashSet<InternalDistributedMember> tmp = new HashSet<>(this.adminConsoles);
-  public Set getAllOtherMembers() {
-    Set result = new HashSet(getDistributionManagerIdsIncludingAdmin());
+  public Set<InternalDistributedMember> getAllOtherMembers() {
+    Set<InternalDistributedMember> result =
+        new HashSet<>(getDistributionManagerIdsIncludingAdmin());
-    for (Iterator<InternalDistributedMember> it = members.iterator(); it.hasNext();) {
-      InternalDistributedMember id = it.next();
-      if (id.getVersionObject().compareTo(version) < 0) {
-        it.remove();
-      }
-    }
+    members.removeIf(id -> id.getVersionObject().compareTo(version) < 0);
-    for (Iterator<InternalDistributedMember> it = members.iterator(); it.hasNext();) {
-      InternalDistributedMember id = it.next();
-      if (id.getVersionObject().compareTo(version) >= 0) {
-        it.remove();
-      }
-    }
+    members.removeIf(id -> id.getVersionObject().compareTo(version) >= 0);
-  public Set addAllMembershipListenerAndGetAllIds(MembershipListener l) {
+  public Set<InternalDistributedMember> addAllMembershipListenerAndGetAllIds(MembershipListener l) {
-    Set equivs = StartupMessage.getMyAddresses(this);
+    Set<InetAddress> equivs = StartupMessage.getMyAddresses(this);
-      equivs = new HashSet();
+      equivs = new HashSet<>();
-    Set allOthers = new HashSet(getViewMembers());
+    Set<InternalDistributedMember> allOthers = new HashSet<>(getViewMembers());
-    boolean isAdminDM = getId().getVmKind() == ClusterDistributionManager.ADMIN_ONLY_DM_TYPE
-        || getId().getVmKind() == ClusterDistributionManager.LOCATOR_DM_TYPE
-        || ClusterDistributionManager.isDedicatedAdminVM()
-        || Boolean.getBoolean(InternalLocator.FORCE_LOCATOR_DM_TYPE);
-
-  private Set unfinishedStartups = null;
+  private Set<InternalDistributedMember> unfinishedStartups = null;
-  public void setUnfinishedStartups(Collection s) {
+  public void setUnfinishedStartups(Collection<InternalDistributedMember> s) {
-      unfinishedStartups = new HashSet(s);
+      unfinishedStartups = new HashSet<>(s);
-        Map<InternalDistributedMember, InternalDistributedMember> tmp = new HashMap(this.members);
+        Map<InternalDistributedMember, InternalDistributedMember> tmp = new HashMap<>(this.members);
-            tmp = Collections.EMPTY_MAP;
+            tmp = Collections.emptyMap();
-        Set tmp2 = new HashSet(this.membersAndAdmin);
+        Set<InternalDistributedMember> tmp2 = new HashSet<>(this.membersAndAdmin);
-            tmp2 = Collections.EMPTY_SET;
+            tmp2 = Collections.emptySet();
-      tmp = new HashMap(this.members);
+      tmp = new HashMap<>(this.members);
-      Set stmp = new HashSet(this.membersAndAdmin);
+      Set<InternalDistributedMember> stmp = new HashSet<>(this.membersAndAdmin);
-    HashSet tmp = null;
+    HashSet<InternalDistributedMember> tmp = null;
-      tmp = new HashSet(this.membersAndAdmin);
+      tmp = new HashSet<>(this.membersAndAdmin);
-    for (Iterator iter = allMembershipListeners.iterator(); iter.hasNext();) {
-      MembershipListener listener = (MembershipListener) iter.next();
+    for (MembershipListener listener : allMembershipListeners) {
-        Set tmp = new HashSet(this.membersAndAdmin);
+        Set<InternalDistributedMember> tmp = new HashSet<>(this.membersAndAdmin);
-            tmp = Collections.EMPTY_SET;
+            tmp = Collections.emptySet();
-        Set tmp = new HashSet(this.adminConsoles);
+        Set<InternalDistributedMember> tmp = new HashSet<>(this.adminConsoles);
-          tmp = Collections.EMPTY_SET;
+          tmp = Collections.emptySet();
-      for (Iterator iter = allMembershipListeners.iterator(); iter.hasNext();) {
-        MembershipListener listener = (MembershipListener) iter.next();
+      for (MembershipListener listener : allMembershipListeners) {
-  public void shutdownMessageReceived(InternalDistributedMember theId, String reason) {
+  void shutdownMessageReceived(InternalDistributedMember theId, String reason) {
-    boolean crashed = p_crashed;
-    String reason = p_reason;
-      handleConsoleShutdown(theId, crashed, reason);
+      handleConsoleShutdown(theId, p_crashed, p_reason);
-    if (removeManager(theId, crashed, reason)) {
+    if (removeManager(theId, p_crashed, p_reason)) {
-      if (crashed && !isCloseInProgress()) {
+      if (p_crashed && !isCloseInProgress()) {
-        addMemberEvent(new MemberCrashedEvent(theId, reason));
+        addMemberEvent(new MemberCrashedEvent(theId, p_reason));
-        addMemberEvent(new MemberDepartedEvent(theId, reason));
+        addMemberEvent(new MemberDepartedEvent(theId, p_reason));
-      logger.info(LocalizedMessage.create(msg, new Object[] {theId, prettifyReason(reason)}));
+      logger.info(LocalizedMessage.create(msg, new Object[] {theId, prettifyReason(p_reason)}));
-    Set allOthers = new HashSet(getViewMembers());
+    Set<InternalDistributedMember> allOthers = new HashSet<>(getViewMembers());
-  Set sendOutgoing(DistributionMessage message) throws NotSerializableException {
+  Set<InternalDistributedMember> sendOutgoing(DistributionMessage message)
+      throws NotSerializableException {
-    Set result = sendViaMembershipManager(message.getRecipients(), message,
-        ClusterDistributionManager.this, this.stats);
+    Set<InternalDistributedMember> result =
+        sendViaMembershipManager(message.getRecipients(), message,
+            ClusterDistributionManager.this, this.stats);
-  Set sendMessage(DistributionMessage message) throws NotSerializableException {
-    Set result = null;
+  private Set<InternalDistributedMember> sendMessage(DistributionMessage message)
+      throws NotSerializableException {
+    Set<InternalDistributedMember> result = null;
-      result = new HashSet();
+      result = new HashSet<>();
-      /*
-       * if (ex instanceof org.apache.geode.GemFireIpcResourceException) { return; }
-       */
-  private Set sendViaMembershipManager(InternalDistributedMember[] destinations,
+  private Set<InternalDistributedMember> sendViaMembershipManager(
+      InternalDistributedMember[] destinations,
-      HashSet result = new HashSet();
-      for (int i = 0; i < destinations.length; i++) {
-        result.add(destinations[i]);
-      }
+      HashSet<InternalDistributedMember> result = new HashSet<>();
+      Collections.addAll(result, destinations);
-  void scheduleIncomingMessage(DistributionMessage message) {
+  private void scheduleIncomingMessage(DistributionMessage message) {
-    // if (Thread.currentThread().isInterrupted())
-    // throw new RuntimeException("Interrupted");
-              public void viewInstalled(NetView view) {}
-
-  public OverflowQueueWithDMStats getSerialQueue(InternalDistributedMember sender) {
+  public OverflowQueueWithDMStats<Runnable> getSerialQueue(InternalDistributedMember sender) {
-  private final ConcurrentMap hmMap = new ConcurrentHashMap();
+  private final ConcurrentMap<InternalDistributedMember, HealthMonitor> hmMap =
+      new ConcurrentHashMap<>();
-    return (HealthMonitor) this.hmMap.get(owner);
+    return this.hmMap.get(owner);
-    Set mbrs = getDistributionManagerIds();
-    for (Iterator mbrIter = mbrs.iterator(); mbrIter.hasNext();) {
-      Set roles = ((InternalDistributedMember) mbrIter.next()).getRoles();
-      for (Iterator rolesIter = roles.iterator(); rolesIter.hasNext();) {
-        Role mbrRole = (Role) rolesIter.next();
+    Set<InternalDistributedMember> mbrs = getDistributionManagerIds();
+    for (InternalDistributedMember mbr : mbrs) {
+      Set<Role> roles = (mbr).getRoles();
+      for (Role mbrRole : roles) {
-    Set mbrs = getDistributionManagerIds();
-    for (Iterator mbrIter = mbrs.iterator(); mbrIter.hasNext();) {
-      Set roles = ((InternalDistributedMember) mbrIter.next()).getRoles();
-      for (Iterator rolesIter = roles.iterator(); rolesIter.hasNext();) {
-        Role mbrRole = (Role) rolesIter.next();
-        if (mbrRole.equals(role)) {
+    Set<InternalDistributedMember> mbrs = getDistributionManagerIds();
+    for (InternalDistributedMember mbr : mbrs) {
+      Set<Role> roles = mbr.getRoles();
+      for (Role mbrRole : roles) {
+        if ((mbrRole).equals(role)) {
-  public Set getAllRoles() {
-    Set allRoles = new HashSet();
-    Set mbrs = getDistributionManagerIds();
-    for (Iterator mbrIter = mbrs.iterator(); mbrIter.hasNext();) {
-      Set roles = ((InternalDistributedMember) mbrIter.next()).getRoles();
-      for (Iterator rolesIter = roles.iterator(); rolesIter.hasNext();) {
-        Role mbrRole = (Role) rolesIter.next();
-        allRoles.add(mbrRole);
-      }
+  public Set<Role> getAllRoles() {
+    Set<Role> allRoles = new HashSet<>();
+    Set<InternalDistributedMember> mbrs = getDistributionManagerIds();
+    for (InternalDistributedMember mbr : mbrs) {
+      allRoles.addAll(mbr.getRoles());
-    ConcurrentMap serialQueuedExecutorMap = new ConcurrentHashMap(MAX_SERIAL_QUEUE_THREAD);
+    final ConcurrentMap<Integer, SerialQueuedExecutorWithDMStats> serialQueuedExecutorMap =
+        new ConcurrentHashMap<>(MAX_SERIAL_QUEUE_THREAD);
-    Map serialQueuedMap = new HashMap(MAX_SERIAL_QUEUE_THREAD);
+    final Map<Integer, OverflowQueueWithDMStats<Runnable>> serialQueuedMap =
+        new HashMap<>(MAX_SERIAL_QUEUE_THREAD);
-    Map senderToSerialQueueIdMap = new HashMap();
+    final Map<InternalDistributedMember, Integer> senderToSerialQueueIdMap = new HashMap<>();
-    ArrayList threadMarkedForUse = new ArrayList();
+    final ArrayList<Integer> threadMarkedForUse = new ArrayList<>();
-    DistributionStats stats;
-    ThreadGroup threadGroup;
+    final DistributionStats stats;
+    final ThreadGroup threadGroup;
-        queueId = (Integer) senderToSerialQueueIdMap.get(sender);
+        queueId = senderToSerialQueueIdMap.get(sender);
-          queueId = (Integer) threadMarkedForUse.remove(0);
+          queueId = threadMarkedForUse.remove(0);
-    public OverflowQueueWithDMStats getSerialQueue(InternalDistributedMember sender) {
+    OverflowQueueWithDMStats<Runnable> getSerialQueue(InternalDistributedMember sender) {
-      return (OverflowQueueWithDMStats) serialQueuedMap.get(queueId);
+      return serialQueuedMap.get(queueId);
-    public SerialQueuedExecutorWithDMStats getThrottledSerialExecutor(
+    SerialQueuedExecutorWithDMStats getThrottledSerialExecutor(
-    public SerialQueuedExecutorWithDMStats getSerialExecutor(InternalDistributedMember sender) {
+    SerialQueuedExecutorWithDMStats getSerialExecutor(InternalDistributedMember sender) {
-          (SerialQueuedExecutorWithDMStats) serialQueuedExecutorMap.get(queueId)) != null) {
+          serialQueuedExecutorMap.get(queueId)) != null) {
-      BlockingQueue poolQueue;
+      OverflowQueueWithDMStats<Runnable> poolQueue;
-        poolQueue = new OverflowQueueWithDMStats(stats.getSerialQueueHelper());
+        poolQueue = new OverflowQueueWithDMStats<>(stats.getSerialQueueHelper());
-        poolQueue = new ThrottlingMemLinkedQueueWithDMStats(SERIAL_QUEUE_BYTE_LIMIT,
+        poolQueue = new ThrottlingMemLinkedQueueWithDMStats<>(SERIAL_QUEUE_BYTE_LIMIT,
-      for (Iterator iter = serialQueuedExecutorMap.values().iterator(); iter.hasNext();) {
-        ExecutorService executor = (ExecutorService) iter.next();
+      for (ExecutorService executor : serialQueuedExecutorMap.values()) {
-      for (Iterator iter = serialQueuedExecutorMap.values().iterator(); iter.hasNext();) {
-        ExecutorService executor = (ExecutorService) iter.next();
+      for (ExecutorService executor : serialQueuedExecutorMap
+          .values()) {
-   * A simple class used for locking the list of members of the distributed system. We give this
-   * lock its own class so that it shows up nicely in stack traces.
-   */
-  private static class MembersLock {
-    protected MembersLock() {
-
-    }
-  }
-
-  /**
-   * A simple class used for locking the list of membership listeners. We give this lock its own
-   * class so that it shows up nicely in stack traces.
-   */
-  private static class MembershipListenersLock {
-    protected MembershipListenersLock() {}
-  }
-
-  /**
-    Set<InternalDistributedMember> buddyMembers = new HashSet<InternalDistributedMember>();
+    Set<InternalDistributedMember> buddyMembers = new HashSet<>();
-      Set targetAddrs = getEquivalents(targetMember.getInetAddress());
+      Set<InetAddress> targetAddrs = getEquivalents(targetMember.getInetAddress());
-  public void printStacks(Collection ids, boolean useNative) {
-    Set requiresMessage = new HashSet();
+  public void printStacks(Collection<InternalDistributedMember> ids, boolean useNative) {
+    Set<InternalDistributedMember> requiresMessage = new HashSet<>();
-    for (DistributedMember m : (Set<DistributedMember>) getDistributionManagerIdsIncludingAdmin()) {
+    for (DistributedMember m : getDistributionManagerIdsIncludingAdmin()) {
-          result = new HashSet<DistributedMember>();
+          result = new HashSet<>();
-  public Set getNormalDistributionManagerIds() {
+  public Set<InternalDistributedMember> getNormalDistributionManagerIds() {
-      HashSet<InternalDistributedMember> result = new HashSet<InternalDistributedMember>();
+      HashSet<InternalDistributedMember> result = new HashSet<>();
-      HashSet<InternalDistributedMember> result = new HashSet<InternalDistributedMember>();
+      HashSet<InternalDistributedMember> result = new HashSet<>();

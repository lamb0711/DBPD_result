GEODE-77 fixes for failing unit and integration tests

  if the coordinator returned by locators doesn't work we now
  ask other members in the view returned by the locator

  leave & crash events now ack the view currently being installed
  so that it won't wait for the associated members

  views are always installed using the two-phase protocol.
  GemFire did this and some algorithms, such as rebalancing,
  are thrown off if departed members are in the view when
  a rebalance starts.

  views are always transmitted by the View Creator thread.
  GMSJoinLeave.becomeCoordinator() installs an initial view
  into the View Creator before starting it if there is a view
  to prepare and install.

  Rebalance operations targetting a new member were failing to
  achieve balance if an old ID for that member was still in the
  membership view.  We now detect those old IDs and remove them
  when the new member joins.

  ClientProxyMembershipID was not being deserialized properly
  after being transmitted from one member to another.

  HealthMonitor classes with Ping in their names are renamed to
  Check.  I've found that Ping confuses people - they
  sometimes think that gemfire is using network ping protocol

  HealthMonitor beSick/playDead were tightened up

  HealthMonitor was not recording activity from other members unless
  it was currently watching that member.  This caused a lot of
  unnecessary suspicion when switching from one member to another.

  HealthMonitor wasn't clear about who was raising suspicion and
  who was the target of the suspicion.

  FindCoordinatorRequest was using java serialization for rejected
  coordinator IDs.

  GMSMembershipManager's latestViewLock use wasn't quite the same
  as in the membership manager in GemFire 8.2 and caused a deadlock.

  fixing GEODE-360: PRTombstoneMessage should ignore
  ForceReattemptException

  LogFileParser wasn't recognizing timestamps for thread dumps, causing
  them to be mis-sorted when merging log files.

-import static com.gemstone.gemfire.internal.DataSerializableFixedID.PING_REQUEST;
-import static com.gemstone.gemfire.internal.DataSerializableFixedID.PING_RESPONSE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.CHECK_REQUEST;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.CHECK_RESPONSE;
-import com.gemstone.gemfire.distributed.internal.membership.gms.messages.PingRequestMessage;
-import com.gemstone.gemfire.distributed.internal.membership.gms.messages.PingResponseMessage;
+import com.gemstone.gemfire.distributed.internal.membership.gms.messages.CheckRequestMessage;
+import com.gemstone.gemfire.distributed.internal.membership.gms.messages.CheckResponseMessage;
-  volatile private InternalDistributedMember nextNeighbour;
+  volatile private InternalDistributedMember nextNeighbor;
-  private ExecutorService pingExecutor;
+  private ExecutorService checkExecutor;
+    } else {
+      cTS = new CustomTimeStamp();
+      cTS.setTimeStamp(currentTimeStamp);
+      memberVsLastMsgTS.put(sender, cTS);
-      InternalDistributedMember neighbour = nextNeighbour;
+      InternalDistributedMember neighbour = nextNeighbor;
-        CustomTimeStamp nextNeighbourTS;
+        CustomTimeStamp nextNeighborTS;
-          nextNeighbourTS = GMSHealthMonitor.this.memberVsLastMsgTS.get(neighbour);
+          nextNeighborTS = GMSHealthMonitor.this.memberVsLastMsgTS.get(neighbour);
-        if (nextNeighbourTS == null) {
+        if (nextNeighborTS == null) {
-        long lastTS = currentTime - nextNeighbourTS.getTimeStamp();
+        long lastTS = currentTime - nextNeighborTS.getTimeStamp();
-  private PingRequestMessage constructPingRequestMessage(final InternalDistributedMember pingMember) {
+  private CheckRequestMessage constructCheckRequestMessage(final InternalDistributedMember mbr) {
-    final PingRequestMessage prm = new PingRequestMessage(pingMember, reqId);
-    prm.setRecipient(pingMember);
+    final CheckRequestMessage prm = new CheckRequestMessage(mbr, reqId);
+    prm.setRecipient(mbr);
-  private void checkMember(final InternalDistributedMember pingMember) {
+  private void checkMember(final InternalDistributedMember mbr) {
-    // as ping may take time
-    setNextNeighbour(cv, pingMember);
+    // as check may take time
+    setNextNeighbor(cv, mbr);
-    // we need to ping this member
-    pingExecutor.execute(new Runnable() {
+    // we need to check this member
+    checkExecutor.execute(new Runnable() {
-        boolean pinged = GMSHealthMonitor.this.doCheckMember(pingMember);
+        boolean pinged = GMSHealthMonitor.this.doCheckMember(mbr);
-          String reason = String.format("Member isn't responding to check message: %s", pingMember);
-          GMSHealthMonitor.this.sendSuspectMessage(pingMember, reason);
+          String reason = String.format("Member isn't responding to check message: %s", mbr);
+          GMSHealthMonitor.this.sendSuspectMessage(mbr, reason);
-          logger.trace("Setting next neighbour as member {} has not responded.", pingMember);
+          logger.trace("Setting next neighbour as member {} has not responded.", mbr);
-          setNextNeighbour(GMSHealthMonitor.this.currentView, null);
+          setNextNeighbor(GMSHealthMonitor.this.currentView, null);
+    if (beingSick || playingDead) {
+      logger.debug("sick member is not sending suspect message concerning {}", mbr);
+      return;
+    }
-    final PingRequestMessage prm = constructPingRequestMessage(pingMember);
+    final CheckRequestMessage prm = constructCheckRequestMessage(pingMember);
-      pingExecutor = Executors.newCachedThreadPool(new ThreadFactory() {
+      checkExecutor = Executors.newCachedThreadPool(new ThreadFactory() {
-    setNextNeighbour(newView, null);
+    setNextNeighbor(newView, null);
-  private synchronized void setNextNeighbour(NetView newView, InternalDistributedMember nextTo) {
+  private synchronized void setNextNeighbor(NetView newView, InternalDistributedMember nextTo) {
-      int nextNeighbourIndex = (index + 1) % allMembers.size();
-      nextNeighbour = allMembers.get(nextNeighbourIndex);
-      logger.trace("Next neighbour to check is {}", nextNeighbour);
+      int nextNeighborIndex = (index + 1) % allMembers.size();
+      nextNeighbor = allMembers.get(nextNeighborIndex);
+      logger.trace("Next neighbour to check is {}", nextNeighbor);
-  public InternalDistributedMember getNextNeighbour() {
-    return nextNeighbour;
+  public InternalDistributedMember getNextNeighbor() {
+    return nextNeighbor;
-    services.getMessenger().addHandler(PingRequestMessage.class, this);
-    services.getMessenger().addHandler(PingResponseMessage.class, this);
+    services.getMessenger().addHandler(CheckRequestMessage.class, this);
+    services.getMessenger().addHandler(CheckResponseMessage.class, this);
-      pingExecutor.shutdown();
+      checkExecutor.shutdown();
-    return scheduler.isShutdown() && pingExecutor.isShutdown() && !suspectRequestCollectorThread.isAlive();
+    return scheduler.isShutdown() && checkExecutor.isShutdown() && !suspectRequestCollectorThread.isAlive();
-    logger.debug("HealthMonitor processing {}", m);
+    logger.trace("HealthMonitor processing {}", m);
-    case PING_REQUEST:
-      processPingRequest((PingRequestMessage) m);
+    case CHECK_REQUEST:
+      if (beingSick || playingDead) {
+        logger.debug("sick member is ignoring check request");
+      } else {
+        processCheckRequest((CheckRequestMessage) m);
+      }
-    case PING_RESPONSE:
-      processPingResponse((PingResponseMessage) m);
+    case CHECK_RESPONSE:
+      if (beingSick || playingDead) {
+        logger.debug("sick member is ignoring check response");
+      } else {
+        processCheckResponse((CheckResponseMessage) m);
+      }
-      processSuspectMembersRequest((SuspectMembersMessage) m);
+      if (beingSick || playingDead) {
+        logger.debug("sick member is ignoring suspect message");
+      } else {
+        processSuspectMembersRequest((SuspectMembersMessage) m);
+      }
-  private void processPingRequest(PingRequestMessage m) {
+  private void processCheckRequest(CheckRequestMessage m) {
-    if (beingSick || playingDead) {
+    if (this.isStopping || this.playingDead) {
-      PingResponseMessage prm = new PingResponseMessage(m.getRequestId());
+      CheckResponseMessage prm = new CheckResponseMessage(m.getRequestId());
-      logger.debug("Ignoring ping request intended for {}.  My ID is {}", m.getTarget(), me);
+      logger.debug("Ignoring check request intended for {}.  My ID is {}", m.getTarget(), me);
-  private void processPingResponse(PingResponseMessage m) {
-    Response pingResp = requestIdVsResponse.get(m.getRequestId());
-    logger.debug("Got check response from member {}. {}", m.getSender(), (pingResp != null ? "Check Thread still waiting" : "Check thread is not waiting"));
-    if (pingResp != null) {
-      synchronized (pingResp) {
-        pingResp.setResponseMsg(m);
-        pingResp.notify();
+  private void processCheckResponse(CheckResponseMessage m) {
+    Response resp = requestIdVsResponse.get(m.getRequestId());
+    logger.trace("Got check response from member {}. {}", m.getSender(), (resp != null ? "Check Thread still waiting" : "Check thread is not waiting"));
+    if (resp != null) {
+      synchronized (resp) {
+        resp.setResponseMsg(m);
+        resp.notify();
+    InternalDistributedMember sender = incomingRequest.getSender();
+
+      for (SuspectRequest req: incomingRequest.getMembers()) {
+        logger.info("received suspect message from {}: {}",
+           sender, req.getReason());
+      }
+        for (SuspectRequest req: incomingRequest.getMembers()) {
+          logger.info("received suspect message from {} for {}: {}",
+             sender, req.getSuspectMember(), req.getReason());
+        }
-        logger.debug("Doing final check for member {}", mbr);
+        logger.debug("Doing final check for member {}; reason={}", mbr, reason);
-        pingExecutor.execute(new Runnable() {
+        checkExecutor.execute(new Runnable() {
-            if (logger != null && logger.isDebugEnabled())
+            if (logger != null && logger.isDebugEnabled()) {
+            }
+    if (beingSick || playingDead) {
+      logger.debug("sick member is not sending suspect request");
+      return;
+    }

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-@Api(value = "queries", description = "Rest api for gemfire query execution", produces = MediaType.APPLICATION_JSON_VALUE)
+@Api(value = "queries", description = "Rest api for gemfire query execution",
+    produces = MediaType.APPLICATION_JSON_VALUE)
-  
+
-  
-  private final ConcurrentHashMap<String, DefaultQuery> compiledQueries = new ConcurrentHashMap<String, DefaultQuery>();
-  
+
+  private final ConcurrentHashMap<String, DefaultQuery> compiledQueries =
+      new ConcurrentHashMap<String, DefaultQuery>();
+
+   * 
-  
+
+   * 
-  @RequestMapping(method = RequestMethod.GET,  produces = { MediaType.APPLICATION_JSON_UTF8_VALUE })
-  @ApiOperation(
-    value = "list all parametrized queries",
-    notes = "List all parametrized queries by id/name",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 500, message = "if GemFire throws an error or exception" )
-  } )
+  @RequestMapping(method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
+  @ApiOperation(value = "list all parametrized queries",
+      notes = "List all parametrized queries by id/name", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 500, message = "if GemFire throws an error or exception")})
-    final Region<String, String> parametrizedQueryRegion = getQueryStore(PARAMETERIZED_QUERIES_REGION);
-    
-    String queryListAsJson =  JSONUtils.formulateJsonForListQueriesCall(parametrizedQueryRegion);
-    final HttpHeaders headers = new HttpHeaders();  
+    final Region<String, String> parametrizedQueryRegion =
+        getQueryStore(PARAMETERIZED_QUERIES_REGION);
+
+    String queryListAsJson = JSONUtils.formulateJsonForListQueriesCall(parametrizedQueryRegion);
+    final HttpHeaders headers = new HttpHeaders();
-  } 
-  
+  }
+
+   * 
-  @ApiOperation(
-    value = "create a parametrized Query",
-    notes = "Prepare the specified parametrized query and assign the corresponding ID for lookup",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 201, message = "Successfully created." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 409, message = "QueryId already assigned to other query." ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception." )
-  } )
+  @ApiOperation(value = "create a parametrized Query",
+      notes = "Prepare the specified parametrized query and assign the corresponding ID for lookup",
+      response = void.class)
+  @ApiResponses({@ApiResponse(code = 201, message = "Successfully created."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 409, message = "QueryId already assigned to other query."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")})
-                                  @RequestParam(value = "q", required = false) String oqlInUrl,
-                                  @RequestBody(required = false) final String oqlInBody)
-  {
+      @RequestParam(value = "q", required = false) String oqlInUrl,
+      @RequestBody(required = false) final String oqlInBody) {
-    logger.debug("Creating a named, parametrized Query ({}) with ID ({})...", oqlStatement, queryId);
+    logger.debug("Creating a named, parametrized Query ({}) with ID ({})...", oqlStatement,
+        queryId);
-    // store the compiled OQL statement with 'queryId' as the Key into the hidden, ParameterizedQueries Region...
-    final String existingOql = createNamedQuery(PARAMETERIZED_QUERIES_REGION, queryId, oqlStatement);
+    // store the compiled OQL statement with 'queryId' as the Key into the hidden,
+    // ParameterizedQueries Region...
+    final String existingOql =
+        createNamedQuery(PARAMETERIZED_QUERIES_REGION, queryId, oqlStatement);
-      return new ResponseEntity<String>(JSONUtils.formulateJsonForExistingQuery(queryId, existingOql), headers, HttpStatus.CONFLICT);
+      return new ResponseEntity<String>(
+          JSONUtils.formulateJsonForExistingQuery(queryId, existingOql), headers,
+          HttpStatus.CONFLICT);
+   * 
-  @RequestMapping(method = RequestMethod.GET, value = "/adhoc", produces = { MediaType.APPLICATION_JSON_UTF8_VALUE })
-  @ApiOperation(
-    value = "run an adhoc query",
-    notes = "Run an unnamed (unidentified), ad-hoc query passed as a URL parameter",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception" )
-  } )
+  @RequestMapping(method = RequestMethod.GET, value = "/adhoc",
+      produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
+  @ApiOperation(value = "run an adhoc query",
+      notes = "Run an unnamed (unidentified), ad-hoc query passed as a URL parameter",
+      response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception")})
-    
-    // NOTE Query.execute throws many checked Exceptions; let the BaseControllerAdvice Exception handlers catch
+
+    // NOTE Query.execute throws many checked Exceptions; let the BaseControllerAdvice Exception
+    // handlers catch
-      Object queryResult =  query.execute();
+      Object queryResult = query.execute();
-      throw new GemfireRestException("A function was applied to a parameter that is improper for that function!", fde);
+      throw new GemfireRestException(
+          "A function was applied to a parameter that is improper for that function!", fde);
-    }catch (NameResolutionException nre) {
+    } catch (NameResolutionException nre) {
-    }catch (IllegalArgumentException iae) {
-      throw new GemfireRestException(" The number of bound parameters does not match the number of placeholders!", iae);
-    }catch (IllegalStateException ise) {
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(
+          " The number of bound parameters does not match the number of placeholders!", iae);
+    } catch (IllegalStateException ise) {
-    }catch (QueryExecutionTimeoutException qete) {
-      throw new GemfireRestException("Query execution time is exceeded max query execution time (gemfire.Cache.MAX_QUERY_EXECUTION_TIME) configured! ", qete);
-    }catch (QueryInvocationTargetException qite) {
-      throw new GemfireRestException("Data referenced in from clause is not available for querying!", qite);
-    }catch (QueryExecutionLowMemoryException qelme) {
-      throw new GemfireRestException("Query execution gets canceled due to low memory conditions and the resource manager critical heap percentage has been set!", qelme);
-    }
-    catch (Exception e) {
+    } catch (QueryExecutionTimeoutException qete) {
+      throw new GemfireRestException(
+          "Query execution time is exceeded max query execution time (gemfire.Cache.MAX_QUERY_EXECUTION_TIME) configured! ",
+          qete);
+    } catch (QueryInvocationTargetException qite) {
+      throw new GemfireRestException(
+          "Data referenced in from clause is not available for querying!", qite);
+    } catch (QueryExecutionLowMemoryException qelme) {
+      throw new GemfireRestException(
+          "Query execution gets canceled due to low memory conditions and the resource manager critical heap percentage has been set!",
+          qelme);
+    } catch (Exception e) {
+   * 
-  @RequestMapping(method = RequestMethod.POST, value = "/{query}", produces = {MediaType.APPLICATION_JSON_VALUE})
-  @ApiOperation(
-    value = "run parametrized query",
-    notes = "run the specified named query passing in scalar values for query parameters in the GemFire cluster",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "Query successfully executed." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 400, message = "Query bind params specified as JSON document in the request body is invalid" ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception" )   
-  } )
+  @RequestMapping(method = RequestMethod.POST, value = "/{query}",
+      produces = {MediaType.APPLICATION_JSON_VALUE})
+  @ApiOperation(value = "run parametrized query",
+      notes = "run the specified named query passing in scalar values for query parameters in the GemFire cluster",
+      response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "Query successfully executed."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 400,
+          message = "Query bind params specified as JSON document in the request body is invalid"),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception")})
-                                              @RequestBody String arguments)
-  {
+      @RequestBody String arguments) {
-    
+
-      
-      //Convert arguments into Object[]
+
+      // Convert arguments into Object[]
-      
+
-        
+
-          String.format("No Query with ID (%1$s) was found!", queryId)));
-        try {   
+            String.format("No Query with ID (%1$s) was found!", queryId)));
+        try {
-        compiledQueries.putIfAbsent(queryId, (DefaultQuery)compiledQuery);
-      }  
-       // NOTE Query.execute throws many checked Exceptions; let the BaseControllerAdvice Exception handlers catch
-       // and handle the Exceptions appropriately (500 Server Error)!
-       try {
-         Object queryResult =  compiledQuery.execute(args);
-         return processQueryResponse(queryResult, queryId);
-       } catch (FunctionDomainException fde) {
-         throw new GemfireRestException("A function was applied to a parameter that is improper for that function!", fde);
-       } catch (TypeMismatchException tme) {
-         throw new GemfireRestException("Bind parameter is not of the expected type!", tme);
-       } catch (NameResolutionException nre) {
-         throw new GemfireRestException("Name in the query cannot be resolved!", nre);
-       } catch (IllegalArgumentException iae) {
-         throw new GemfireRestException(" The number of bound parameters does not match the number of placeholders!", iae);
-       } catch (IllegalStateException ise) {
-         throw new GemfireRestException("Query is not permitted on this type of region!", ise);
-       } catch (QueryExecutionTimeoutException qete) {
-         throw new GemfireRestException("Query execution time is exceeded  max query execution time (gemfire.Cache.MAX_QUERY_EXECUTION_TIME) configured!", qete);
-       } catch (QueryInvocationTargetException qite) {
-         throw new GemfireRestException("Data referenced in from clause is not available for querying!", qite);
-       } catch (QueryExecutionLowMemoryException qelme) {
-         throw new GemfireRestException("Query gets canceled due to low memory conditions and the resource manager critical heap percentage has been set!", qelme);
-       } catch (Exception e) {
-         throw new GemfireRestException("Error encountered while executing named query!", e);
-       }
-     } else {
-       throw new GemfireRestException(" Bind params either not specified or not processed properly by the server!"); 
-     }
+        compiledQueries.putIfAbsent(queryId, (DefaultQuery) compiledQuery);
+      }
+      // NOTE Query.execute throws many checked Exceptions; let the BaseControllerAdvice Exception
+      // handlers catch
+      // and handle the Exceptions appropriately (500 Server Error)!
+      try {
+        Object queryResult = compiledQuery.execute(args);
+        return processQueryResponse(queryResult, queryId);
+      } catch (FunctionDomainException fde) {
+        throw new GemfireRestException(
+            "A function was applied to a parameter that is improper for that function!", fde);
+      } catch (TypeMismatchException tme) {
+        throw new GemfireRestException("Bind parameter is not of the expected type!", tme);
+      } catch (NameResolutionException nre) {
+        throw new GemfireRestException("Name in the query cannot be resolved!", nre);
+      } catch (IllegalArgumentException iae) {
+        throw new GemfireRestException(
+            " The number of bound parameters does not match the number of placeholders!", iae);
+      } catch (IllegalStateException ise) {
+        throw new GemfireRestException("Query is not permitted on this type of region!", ise);
+      } catch (QueryExecutionTimeoutException qete) {
+        throw new GemfireRestException(
+            "Query execution time is exceeded  max query execution time (gemfire.Cache.MAX_QUERY_EXECUTION_TIME) configured!",
+            qete);
+      } catch (QueryInvocationTargetException qite) {
+        throw new GemfireRestException(
+            "Data referenced in from clause is not available for querying!", qite);
+      } catch (QueryExecutionLowMemoryException qelme) {
+        throw new GemfireRestException(
+            "Query gets canceled due to low memory conditions and the resource manager critical heap percentage has been set!",
+            qelme);
+      } catch (Exception e) {
+        throw new GemfireRestException("Error encountered while executing named query!", e);
+      }
+    } else {
+      throw new GemfireRestException(
+          " Bind params either not specified or not processed properly by the server!");
+    }
+   * 
-  @ApiOperation(
-    value = "update parametrized query",
-    notes = "Update named, parametrized query by ID",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "Updated successfully." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 404, message = "queryId does not exist." ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception." )   
-  } )
+  @ApiOperation(value = "update parametrized query",
+      notes = "Update named, parametrized query by ID", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "Updated successfully."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 404, message = "queryId does not exist."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")})
-  public ResponseEntity<?> update( @PathVariable("query") final String queryId,
-                                   @RequestParam(value = "q", required = false) String oqlInUrl,
-                                   @RequestBody(required = false) final String oqlInBody) {
+  public ResponseEntity<?> update(@PathVariable("query") final String queryId,
+      @RequestParam(value = "q", required = false) String oqlInUrl,
+      @RequestBody(required = false) final String oqlInBody) {
-    logger.debug("Updating a named, parametrized Query ({}) with ID ({})...", oqlStatement, queryId);
+    logger.debug("Updating a named, parametrized Query ({}) with ID ({})...", oqlStatement,
+        queryId);
-    // update the OQL statement with 'queryId' as the Key into the hidden, ParameterizedQueries Region...
+    // update the OQL statement with 'queryId' as the Key into the hidden, ParameterizedQueries
+    // Region...
-  //delete named, parametrized query
+  // delete named, parametrized query
+   * 
-  @ApiOperation(
-    value = "delete parametrized query",
-    notes = "delete named, parametrized query by ID",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "Deleted successfully." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 404, message = "queryId does not exist." ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception" )   
-  } )
+  @ApiOperation(value = "delete parametrized query",
+      notes = "delete named, parametrized query by ID", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "Deleted successfully."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 404, message = "queryId does not exist."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception")})
-    //delete the OQL statement with 'queryId' as the Key into the hidden,
+    // delete the OQL statement with 'queryId' as the Key into the hidden,
-  
+

GEODE-6534: Remove unnecessary uses of this in LocalRegion

-    return this.stopper;
+    return stopper;
-    this.EXPIRY_UNITS_MS = parentRegion != null ? parentRegion.EXPIRY_UNITS_MS
+    EXPIRY_UNITS_MS = parentRegion != null ? parentRegion.EXPIRY_UNITS_MS
-    this.sharedDataView = internalDataView;
+    sharedDataView = internalDataView;
-    this.fullPath = calcFullPath(regionName, parentRegion);
+    fullPath = calcFullPath(regionName, parentRegion);
-    this.offHeap = attrs.getOffHeap() || Boolean.getBoolean(myName + ":OFF_HEAP");
+    offHeap = attrs.getOffHeap() || Boolean.getBoolean(myName + ":OFF_HEAP");
-    this.initializationLatchBeforeGetInitialImage = new StoppableCountDownLatch(this.stopper, 1);
-    this.initializationLatchAfterGetInitialImage = new StoppableCountDownLatch(this.stopper, 1);
-    this.afterRegionCreateEventLatch = new StoppableCountDownLatch(this.stopper, 1);
+    initializationLatchBeforeGetInitialImage = new StoppableCountDownLatch(stopper, 1);
+    initializationLatchAfterGetInitialImage = new StoppableCountDownLatch(stopper, 1);
+    afterRegionCreateEventLatch = new StoppableCountDownLatch(stopper, 1);
-      this.hasOwnStats = false;
-      this.cachePerfStats = internalRegionArgs.getCachePerfStatsHolder().getCachePerfStats();
+      hasOwnStats = false;
+      cachePerfStats = internalRegionArgs.getCachePerfStatsHolder().getCachePerfStats();
-        this.hasOwnStats = false;
-        this.cachePerfStats = cache.getCachePerfStats();
+        hasOwnStats = false;
+        cachePerfStats = cache.getCachePerfStats();
-        this.hasOwnStats = true;
-        this.cachePerfStats = new RegionPerfStats(
+        hasOwnStats = true;
+        cachePerfStats = new RegionPerfStats(
-    this.diskStoreImpl = findDiskStore(attrs, internalRegionArgs);
-    this.diskRegion = createDiskRegion(internalRegionArgs);
-    this.entries = createRegionMap(internalRegionArgs);
-    this.subregions = new ConcurrentHashMap();
+    diskStoreImpl = findDiskStore(attrs, internalRegionArgs);
+    diskRegion = createDiskRegion(internalRegionArgs);
+    entries = createRegionMap(internalRegionArgs);
+    subregions = new ConcurrentHashMap();
-      this.loaderHelperFactory = internalRegionArgs.getLoaderHelperFactory();
+      loaderHelperFactory = internalRegionArgs.getLoaderHelperFactory();
-      this.loaderHelperFactory = this;
+      loaderHelperFactory = this;
-    this.isUsedForPartitionedRegionAdmin = internalRegionArgs.isUsedForPartitionedRegionAdmin();
-    this.isUsedForPartitionedRegionBucket = internalRegionArgs.isUsedForPartitionedRegionBucket();
-    this.isUsedForMetaRegion = internalRegionArgs.isUsedForMetaRegion();
-    this.isMetaRegionWithTransactions = internalRegionArgs.isMetaRegionWithTransactions();
-    this.isUsedForSerialGatewaySenderQueue = internalRegionArgs.isUsedForSerialGatewaySenderQueue();
-    this.isUsedForParallelGatewaySenderQueue =
+    isUsedForPartitionedRegionAdmin = internalRegionArgs.isUsedForPartitionedRegionAdmin();
+    isUsedForPartitionedRegionBucket = internalRegionArgs.isUsedForPartitionedRegionBucket();
+    isUsedForMetaRegion = internalRegionArgs.isUsedForMetaRegion();
+    isMetaRegionWithTransactions = internalRegionArgs.isMetaRegionWithTransactions();
+    isUsedForSerialGatewaySenderQueue = internalRegionArgs.isUsedForSerialGatewaySenderQueue();
+    isUsedForParallelGatewaySenderQueue =
-    this.serialGatewaySender = internalRegionArgs.getSerialGatewaySender();
+    serialGatewaySender = internalRegionArgs.getSerialGatewaySender();
-      this.filterProfile = new FilterProfile(this);
+      filterProfile = new FilterProfile(this);
-    this.serverRegionProxy =
-        this.getPoolName() != null ? serverRegionProxyConstructor.create(this) : null;
-    this.imageState = new UnsharedImageState(getPoolName() != null,
+    serverRegionProxy =
+        getPoolName() != null ? serverRegionProxyConstructor.create(this) : null;
+    imageState = new UnsharedImageState(getPoolName() != null,
-        getAttributes().getDataPolicy().withPersistence(), this.stopper);
+        getAttributes().getDataPolicy().withPersistence(), stopper);
-    this.supportsTX = !isSecret() && !isUsedForPartitionedRegionAdmin() && !isUsedForMetaRegion()
+    supportsTX = !isSecret() && !isUsedForPartitionedRegionAdmin() && !isUsedForMetaRegion()
-    this.testCallable = internalRegionArgs.getTestCallable();
+    testCallable = internalRegionArgs.getTestCallable();
-      this.cacheServiceProfiles.putAll(internalRegionArgs.getCacheServiceProfiles());
+      cacheServiceProfiles.putAll(internalRegionArgs.getCacheServiceProfiles());
-    if (this.diskRegion != null) {
-      result = this.diskRegion.useExistingRegionMap(this);
+    if (diskRegion != null) {
+      result = diskRegion.useExistingRegionMap(this);
-      ma.statisticsEnabled = this.statisticsEnabled;
-      ma.loadFactor = this.loadFactor;
-      ma.initialCapacity = this.initialCapacity;
-      ma.concurrencyLevel = this.concurrencyLevel;
+      ma.statisticsEnabled = statisticsEnabled;
+      ma.loadFactor = loadFactor;
+      ma.initialCapacity = initialCapacity;
+      ma.concurrencyLevel = concurrencyLevel;
-    return this.versionVector;
+    return versionVector;
-    if (!this.getConcurrencyChecksEnabled()) {
+    if (!getConcurrencyChecksEnabled()) {
-      return this.fullPath; // avoids creating another sync object - could be anything unique to
-                            // this region
+      return fullPath; // avoids creating another sync object - could be anything unique to
+                       // this region
-    if (this.getDataPolicy().withPersistence()) {
+    if (getDataPolicy().withPersistence()) {
-    } else if (!this.getDataPolicy().withStorage()) {
+    } else if (!getDataPolicy().withStorage()) {
-    return this.cache.isClosed();
+    return cache.isClosed();
-    return this.entries.getEntry(key);
+    return entries.getEntry(key);
-      this.entries.removeIfDestroyed(key); // fixes bug 41957
+      entries.removeIfDestroyed(key); // fixes bug 41957
-    return this.serverRegionProxy;
+    return serverRegionProxy;
-    return this.serverRegionProxy != null;
+    return serverRegionProxy != null;
-    this.destroyLock = new Semaphore(1);
+    destroyLock = new Semaphore(1);
-    return this.cache.getInternalDistributedSystem().getDistributedMember();
+    return cache.getInternalDistributedSystem().getDistributedMember();
-    if (this.getDataPolicy().withPersistence()) {
+    if (getDataPolicy().withPersistence()) {
-      return this.cache.getInternalDistributedSystem().getDistributedMember();
+      return cache.getInternalDistributedSystem().getDistributedMember();
-    attrs = this.cache.invokeRegionBefore(this, subregionName, attrs, internalRegionArgs);
+    attrs = cache.invokeRegionBefore(this, subregionName, attrs, internalRegionArgs);
-          if (this.reinitialized_old) {
+          if (reinitialized_old) {
-        synchronized (this.subregionsLock) {
+        synchronized (subregionsLock) {
-          existing = (LocalRegion) this.subregions.get(subregionName);
+          existing = (LocalRegion) subregions.get(subregionName);
-                newRegion = new BucketRegionQueue(subregionName, regionAttributes, this, this.cache,
+                newRegion = new BucketRegionQueue(subregionName, regionAttributes, this, cache,
-                newRegion = new BucketRegion(subregionName, regionAttributes, this, this.cache,
+                newRegion = new BucketRegion(subregionName, regionAttributes, this, cache,
-              newRegion = new PartitionedRegion(subregionName, regionAttributes, this, this.cache,
+              newRegion = new PartitionedRegion(subregionName, regionAttributes, this, cache,
-                  ? new LocalRegion(subregionName, regionAttributes, this, this.cache,
+                  ? new LocalRegion(subregionName, regionAttributes, this, cache,
-                  : new DistributedRegion(subregionName, regionAttributes, this, this.cache,
+                  : new DistributedRegion(subregionName, regionAttributes, this, cache,
-            Object previousValue = this.subregions.putIfAbsent(subregionName, newRegion);
+            Object previousValue = subregions.putIfAbsent(subregionName, newRegion);
-              this.cache.regionReinitialized(newRegion); // fix for bug 33534
+              cache.regionReinitialized(newRegion); // fix for bug 33534
-        this.cache.setRegionByPath(newRegion.getFullPath(), newRegion);
+        cache.setRegionByPath(newRegion.getFullPath(), newRegion);
-            this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY,
+            cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY,
-                  this.cache.getInternalResourceManager().getHeapMonitor().getState().isCritical(),
-                  this.cache.getResourceAdvisor().adviseCriticalMembers());
+                  cache.getInternalResourceManager().getHeapMonitor().getState().isCritical(),
+                  cache.getResourceAdvisor().adviseCriticalMembers());
-                  this.cache.getInternalResourceManager().getHeapMonitor().getState().isCritical()
-                      || this.cache.getInternalResourceManager().getOffHeapMonitor().getState()
+                  cache.getInternalResourceManager().getHeapMonitor().getState().isCritical()
+                      || cache.getInternalResourceManager().getOffHeapMonitor().getState()
-                  this.cache.getResourceAdvisor().adviseCriticalMembers());
+                  cache.getResourceAdvisor().adviseCriticalMembers());
-            InternalDistributedSystem system = this.cache.getInternalDistributedSystem();
+            InternalDistributedSystem system = cache.getInternalDistributedSystem();
-          this.cache.setRegionByPath(newRegion.getFullPath(), null);
+          cache.setRegionByPath(newRegion.getFullPath(), null);
-          this.cache.getInternalResourceManager(false).removeResourceListener(newRegion);
+          cache.getInternalResourceManager(false).removeResourceListener(newRegion);
-    this.cache.invokeRegionAfter(newRegion);
+    cache.invokeRegionAfter(newRegion);
-      event.setNewEventId(this.cache.getDistributedSystem());
+      event.setNewEventId(cache.getDistributedSystem());
-      event.setNewEventId(this.cache.getDistributedSystem());
+      event.setNewEventId(cache.getDistributedSystem());
-    this.cache.invokeBeforeDestroyed(this);
+    cache.invokeBeforeDestroyed(this);
-      return this.sharedDataView;
+      return sharedDataView;
-    if (this.diskRegion != null) {
-      this.diskRegion.setClearCountReference();
+    if (diskRegion != null) {
+      diskRegion.setClearCountReference();
-        regionEntry = this.entries.getEntry(keyInfo.getKey());
+        regionEntry = entries.getEntry(keyInfo.getKey());
-        final boolean disabled = this.entries.disableLruUpdateCallback();
+        final boolean disabled = entries.disableLruUpdateCallback();
-            this.entries.enableLruUpdateCallback();
+            entries.enableLruUpdateCallback();
-            this.entries.lruUpdateCallback();
+            entries.lruUpdateCallback();
-            this.handleDiskAccessException(dae);
+            handleDiskAccessException(dae);
-      if (this.diskRegion != null) {
-        this.diskRegion.removeClearCountReference();
+      if (diskRegion != null) {
+        diskRegion.removeClearCountReference();
-    boolean disabledLRUCallback = this.entries.disableLruUpdateCallback();
+    boolean disabledLRUCallback = entries.disableLruUpdateCallback();
-        this.handleDiskAccessException(dae);
+        handleDiskAccessException(dae);
-        this.entries.enableLruUpdateCallback();
-        this.entries.lruUpdateCallback();
+        entries.enableLruUpdateCallback();
+        entries.lruUpdateCallback();
-    if (!this.statisticsEnabled) {
+    if (!statisticsEnabled) {
-    FutureResult thisFuture = new FutureResult(this.stopper);
-    Future otherFuture = (Future) this.getFutures.putIfAbsent(keyInfo.getKey(), thisFuture);
+    FutureResult thisFuture = new FutureResult(stopper);
+    Future otherFuture = (Future) getFutures.putIfAbsent(keyInfo.getKey(), thisFuture);
-      boolean partitioned = this.getDataPolicy().withPartitioning();
+      boolean partitioned = getDataPolicy().withPartitioning();
-      this.getFutures.remove(keyInfo.getKey());
+      getFutures.remove(keyInfo.getKey());
-    return this.compressor == null && this.cache.isCopyOnRead()
-        && !this.isUsedForPartitionedRegionAdmin && !this.isUsedForMetaRegion && !getOffHeap()
+    return compressor == null && cache.isCopyOnRead()
+        && !isUsedForPartitionedRegionAdmin && !isUsedForMetaRegion && !getOffHeap()
-    return this.fullPath;
+    return fullPath;
-    return this.parentRegion;
+    return parentRegion;
-      event.setNewEventId(this.cache.getDistributedSystem());
+      event.setNewEventId(cache.getDistributedSystem());
-        if (!this.hasServerProxy()) {
+        if (!hasServerProxy()) {
-                extractDelta = !this.getSystem().getMemberId().equals(ids.getId())
+                extractDelta = !getSystem().getMemberId().equals(ids.getId())
-          this.getCachePerfStats().endDeltaPrepared(start);
+          getCachePerfStats().endDeltaPrepared(start);
-    if (!this.isDestroyed) {
+    if (!isDestroyed) {
-      if (!this.initialized && this.diskRegion != null
-          && (regionMap = this.diskRegion.getRecoveredEntryMap()) != null
+      if (!initialized && diskRegion != null
+          && (regionMap = diskRegion.getRecoveredEntryMap()) != null
-    RegionEntry re = this.entries.getEntry(key);
+    RegionEntry re = entries.getEntry(key);
-    return this.cache.isClosed();
+    return cache.isClosed();
-    return this.isDestroyed;
+    return isDestroyed;
-    if (this.isDestroyed) {
+    if (isDestroyed) {
-    return this.regionUserAttribute;
+    return regionUserAttribute;
-    this.regionUserAttribute = value;
+    regionUserAttribute = value;
-    if (!this.getConcurrencyChecksEnabled()) {
+    if (!getConcurrencyChecksEnabled()) {
-    if (contains && this.imageState.isClient()) {
+    if (contains && imageState.isClient()) {
-      RegionEntry regionEntry = this.entries.getEntry(keyInfo.getKey());
+      RegionEntry regionEntry = entries.getEntry(keyInfo.getKey());
-    if (this.diskRegion != null) {
-      this.diskRegion.setClearCountReference();
+    if (diskRegion != null) {
+      diskRegion.setClearCountReference();
-      RegionEntry entry = this.entries.getEntry(keyInfo.getKey());
+      RegionEntry entry = entries.getEntry(keyInfo.getKey());
-      if (this.diskRegion != null) {
-        this.diskRegion.removeClearCountReference();
+      if (diskRegion != null) {
+        diskRegion.removeClearCountReference();
-    return this.regionName;
+    return regionName;
-    if (this.isUsedForPartitionedRegionBucket()) {
-      return this.getPartitionedRegion().getName();
+    if (isUsedForPartitionedRegionBucket()) {
+      return getPartitionedRegion().getName();
-    return this.regionName;
+    return regionName;
-      if (this.imageState.isClient() && !this.getConcurrencyChecksEnabled()) {
-        return result - this.imageState.getDestroyedEntriesCount();
+      if (imageState.isClient() && !getConcurrencyChecksEnabled()) {
+        return result - imageState.getDestroyedEntriesCount();
-      return result - this.tombstoneCount.get();
+      return result - tombstoneCount.get();
-    return this.diskRegion;
+    return diskRegion;
-      this.entries.evictValue(key);
+      entries.evictValue(key);
-    if (this.diskRegion == null) {
+    if (diskRegion == null) {
-      this.diskRegion.asynchForceFlush();
+      diskRegion.asynchForceFlush();
-    if (this.diskRegion != null) {
-      this.diskRegion.flushForTesting();
+    if (diskRegion != null) {
+      diskRegion.flushForTesting();
-        event.setNewEventId(this.cache.getDistributedSystem());
+        event.setNewEventId(cache.getDistributedSystem());
-      event.setNewEventId(this.cache.getDistributedSystem());
+      event.setNewEventId(cache.getDistributedSystem());
-        event.setNewEventId(this.cache.getDistributedSystem());
+        event.setNewEventId(cache.getDistributedSystem());
-      if (!this.isDestroyed) {
-        this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
+      if (!isDestroyed) {
+        cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
-    if (this.scope.isLocal()) {
+    if (scope.isLocal()) {
-      if (this.diskRegion != null) {
+      if (diskRegion != null) {
-          this.diskRegion.initializeOwner(this);
-          this.diskRegion.finishInitializeOwner(this, GIIStatus.NO_GII);
+          diskRegion.initializeOwner(this);
+          diskRegion.finishInitializeOwner(this, GIIStatus.NO_GII);
-          PersistentMemberID oldId = this.diskRegion.getMyInitializingID();
+          PersistentMemberID oldId = diskRegion.getMyInitializingID();
-            oldId = this.diskRegion.getMyPersistentID();
+            oldId = diskRegion.getMyPersistentID();
-            PersistentMemberID newId = this.diskRegion.generatePersistentID();
-            this.diskRegion.setInitializing(newId);
-            this.diskRegion.setInitialized();
+            PersistentMemberID newId = diskRegion.generatePersistentID();
+            diskRegion.setInitializing(newId);
+            diskRegion.setInitialized();
-          this.handleDiskAccessException(dae, true);
+          handleDiskAccessException(dae, true);
-    if (snapshotInputStream != null && this.scope.isLocal()) {
+    if (snapshotInputStream != null && scope.isLocal()) {
-        this.handleDiskAccessException(dae);
+        handleDiskAccessException(dae);
-      logger.debug("LocalRegion.createOQLIndexes on region {}", this.getFullPath());
+      logger.debug("LocalRegion.createOQLIndexes on region {}", getFullPath());
-    if (this.indexManager == null) {
-      this.indexManager = IndexUtils.getIndexManager(cache, this, true);
+    if (indexManager == null) {
+      indexManager = IndexUtils.getIndexManager(cache, this, true);
-    DiskRegion dr = this.getDiskRegion();
+    DiskRegion dr = getDiskRegion();
-            ExecutionContext externalContext = new ExecutionContext(null, this.cache);
+            ExecutionContext externalContext = new ExecutionContext(null, cache);
-            indexes.add(this.indexManager.createIndex(icd.getIndexName(), icd.getIndexType(),
+            indexes.add(indexManager.createIndex(icd.getIndexName(), icd.getIndexType(),
-                    ? icd.getIndexFromClause() : this.getFullPath();
+                    ? icd.getIndexFromClause() : getFullPath();
-              icd.getIndexName(), this.getFullPath(), ex);
+              icd.getIndexName(), getFullPath(), ex);
-        this.indexManager.setPopulateFlagForIndexes(indexes);
+        indexManager.setPopulateFlagForIndexes(indexes);
-      this.indexManager.setPopulateFlagForIndexes(prIndexes);
+      indexManager.setPopulateFlagForIndexes(prIndexes);
-      this.indexManager.populateIndexes(indexes);
+      indexManager.populateIndexes(indexes);
-      logger.info("Failed to update index on region {}: {}", this.getFullPath(), ex.getMessage());
+      logger.info("Failed to update index on region {}: {}", getFullPath(), ex.getMessage());
-    releaseLatch(this.getInitializationLatchBeforeGetInitialImage());
+    releaseLatch(getInitializationLatchBeforeGetInitialImage());
-    releaseLatch(this.getInitializationLatchAfterGetInitialImage());
+    releaseLatch(getInitializationLatchAfterGetInitialImage());
-    releaseLatch(this.afterRegionCreateEventLatch);
+    releaseLatch(afterRegionCreateEventLatch);
-    StoppableCountDownLatch latch = this.afterRegionCreateEventLatch;
+    StoppableCountDownLatch latch = afterRegionCreateEventLatch;
-        if (!this.cache.forcedDisconnect()) {
+        if (!cache.forcedDisconnect()) {
-    this.cache.getInternalResourceManager(false).removeResourceListener(this);
+    cache.getInternalResourceManager(false).removeResourceListener(this);
-      Collection values = this.subregions.values();
+      Collection values = subregions.values();
-          if (!this.cache.forcedDisconnect()) {
+          if (!cache.forcedDisconnect()) {
-        if (this.indexManager != null) {
+        if (indexManager != null) {
-              this.indexManager.removeBucketIndexes(getPartitionedRegion());
+              indexManager.removeBucketIndexes(getPartitionedRegion());
-            this.indexManager.destroy();
+            indexManager.destroy();
-        if (!this.cache.forcedDisconnect()) {
+        if (!cache.forcedDisconnect()) {
-        this.reinitialized_old = true;
+        reinitialized_old = true;
-      this.cache.setRegionByPath(getFullPath(), null);
+      cache.setRegionByPath(getFullPath(), null);
-      if (this.diskRegion != null) {
-        this.diskRegion.prepareForClose(this);
+      if (diskRegion != null) {
+        diskRegion.prepareForClose(this);
-      this.isDestroyed = true;
+      isDestroyed = true;
-      this.cache.getInternalResourceManager(false).removeResourceListener(this);
+      cache.getInternalResourceManager(false).removeResourceListener(this);
-      if (this.getConcurrencyChecksEnabled() && this.getDataPolicy().withReplication()
-          && !this.cache.isClosed()) {
-        this.cache.getTombstoneService().unscheduleTombstones(this);
+      if (getConcurrencyChecksEnabled() && getDataPolicy().withReplication()
+          && !cache.isClosed()) {
+        cache.getTombstoneService().unscheduleTombstones(this);
-      if (this.hasOwnStats) {
-        this.cachePerfStats.close();
+      if (hasOwnStats) {
+        cachePerfStats.close();
-    this.entries.close(null);
+    entries.close(null);
-    return this.entries.clear(rvv, null);
+    return entries.clear(rvv, null);
-    if (fromServer && value == Token.TOMBSTONE && !this.getConcurrencyChecksEnabled()) {
+    if (fromServer && value == Token.TOMBSTONE && !getConcurrencyChecksEnabled()) {
-          event.setNewEventId(this.cache.getDistributedSystem());
+          event.setNewEventId(cache.getDistributedSystem());
-    LoaderHelper loaderHelper = this.loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
+    LoaderHelper loaderHelper = loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
-    result = this.getCache().convertPdxInstanceIfNeeded(result, preferCD);
+    result = getCache().convertPdxInstanceIfNeeded(result, preferCD);
-      RegionEntry entry = this.entries.getEntry(key);
+      RegionEntry entry = entries.getEntry(key);
-    if (this.keyConstraint != null) {
-      if (!this.keyConstraint.isInstance(key))
+    if (keyConstraint != null) {
+      if (!keyConstraint.isInstance(key))
-                key.getClass().getName(), this.keyConstraint.getName()));
+                key.getClass().getName(), keyConstraint.getName()));
-    if (this.valueConstraint != null) {
+    if (valueConstraint != null) {
-          if (this.doExpensiveValidations) {
+          if (doExpensiveValidations) {
-        if (!this.valueConstraint.isInstance(value)) {
+        if (!valueConstraint.isInstance(value)) {
-            if (valueClassName.equals(this.valueConstraint.getName())) {
+            if (valueClassName.equals(valueConstraint.getName())) {
-                  valueClassName, this.valueConstraint.getName()));
+                  valueClassName, valueConstraint.getName()));
-    return this.cachePerfStats;
+    return cachePerfStats;
-    return this.cachePerfStats;
+    return cachePerfStats;
-    this.tombstoneCount.addAndGet(delta);
-    this.cachePerfStats.incTombstoneCount(delta);
+    tombstoneCount.addAndGet(delta);
+    cachePerfStats.incTombstoneCount(delta);
-    this.cachePerfStats.incEntryCount(-delta);
+    cachePerfStats.incEntryCount(-delta);
-    return this.tombstoneCount.get();
+    return tombstoneCount.get();
-          entry.getVersionStamp().asVersionTag(), this.tombstoneCount.get(),
-          this.entries.size()/* , new Exception("stack trace") */);
+          entry.getVersionStamp().asVersionTag(), tombstoneCount.get(),
+          entries.size()/* , new Exception("stack trace") */);
-          this.tombstoneCount.get(), this.entries.size()/* , new Exception("stack trace") */);
+          tombstoneCount.get(), entries.size()/* , new Exception("stack trace") */);
-      if (this.entries instanceof AbstractRegionMap) {
-        ((AbstractRegionMap) this.entries).verifyTombstoneCount(this.tombstoneCount);
+      if (entries instanceof AbstractRegionMap) {
+        ((AbstractRegionMap) entries).verifyTombstoneCount(tombstoneCount);
-    if (!this.getConcurrencyChecksEnabled()) {
+    if (!getConcurrencyChecksEnabled()) {
-    if (!this.versionVector.containsTombstoneGCVersions(regionGCVersions)) {
-      keys = this.cache.getTombstoneService().gcTombstones(this, regionGCVersions,
+    if (!versionVector.containsTombstoneGCVersions(regionGCVersions)) {
+      keys = cache.getTombstoneService().gcTombstones(this, regionGCVersions,
-    if (this.getConcurrencyChecksEnabled()) {
-      this.cache.getTombstoneService().gcTombstoneKeys(this, tombstoneKeys);
+    if (getConcurrencyChecksEnabled()) {
+      cache.getTombstoneService().gcTombstoneKeys(this, tombstoneKeys);
-    if (this.getDataPolicy().withPersistence()) {
+    if (getDataPolicy().withPersistence()) {
-      return this.getConcurrencyChecksEnabled()
-          && (entry.getVersionStamp().hasValidVersion() || this.getDataPolicy().withReplication());
+      return getConcurrencyChecksEnabled()
+          && (entry.getVersionStamp().hasValidVersion() || getDataPolicy().withReplication());
-    this.setConcurrencyChecksEnabled(true);
-    if (this.getDataPolicy().withStorage()) {
-      RegionEntryFactory versionedEntryFactory = this.entries.getEntryFactory().makeVersioned();
-      Assert.assertTrue(this.entries.isEmpty(),
-          "RegionMap should be empty but was of size:" + this.entries.size());
-      this.entries.setEntryFactory(versionedEntryFactory);
+    setConcurrencyChecksEnabled(true);
+    if (getDataPolicy().withStorage()) {
+      RegionEntryFactory versionedEntryFactory = entries.getEntryFactory().makeVersioned();
+      Assert.assertTrue(entries.isEmpty(),
+          "RegionMap should be empty but was of size:" + entries.size());
+      entries.setEntryFactory(versionedEntryFactory);
-    if (this.scope == Scope.LOCAL && attrs.getScope() != Scope.LOCAL) {
+    if (scope == Scope.LOCAL && attrs.getScope() != Scope.LOCAL) {
-    RegionEntry regionEntry = this.entries.getEntry(keyInfo.getKey());
+    RegionEntry regionEntry = entries.getEntry(keyInfo.getKey());
-    RegionEntry re = this.entries.getEntry(key);
+    RegionEntry re = entries.getEntry(key);
-    RegionEntry re = this.entries.getEntry(key);
+    RegionEntry re = entries.getEntry(key);
-    RegionEntry re = this.entries.getEntry(key);
+    RegionEntry re = entries.getEntry(key);
-      this.cache.registerInterestStarted();
-      this.riCnt++;
+      cache.registerInterestStarted();
+      riCnt++;
-      this.riCnt--;
-      Assert.assertTrue(this.riCnt >= 0, "register interest count can not be < 0 ");
-      if (this.riCnt == 0) {
+      riCnt--;
+      Assert.assertTrue(riCnt >= 0, "register interest count can not be < 0 ");
+      if (riCnt == 0) {
-      this.cache.registerInterestCompleted();
+      cache.registerInterestCompleted();
-      this.clearKeysOfInterest(key, interestType, interestResultPolicy);
+      clearKeysOfInterest(key, interestType, interestResultPolicy);
-        for (Object entryKey : this.keySet(allowTombstones)) {
+        for (Object entryKey : keySet(allowTombstones)) {
-          if (this.containsKey(entryKey) || allowTombstones && this.containsTombstone(entryKey)) {
+          if (containsKey(entryKey) || allowTombstones && containsTombstone(entryKey)) {
-        if (this.containsKey(interestArg)
-            || (allowTombstones && this.containsTombstone(interestArg))) {
+        if (containsKey(interestArg)
+            || (allowTombstones && containsTombstone(interestArg))) {
-    for (Iterator it = this.entrySet(false).iterator(); it.hasNext();) {
+    for (Iterator it = entrySet(false).iterator(); it.hasNext();) {
-              this.entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, null,
+              entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, null,
-            boolean isTombstone = this.getConcurrencyChecksEnabled() && entry.isKeyNotOnServer()
+            boolean isTombstone = getConcurrencyChecksEnabled() && entry.isKeyNotOnServer()
-                this.entries.initialImagePut(currentKey, 0, val, false, false, tag, null, false);
+                entries.initialImagePut(currentKey, 0, val, false, false, tag, null, false);
-              RegionEntry regionEntry = this.entries.getEntry(currentKey);
+              RegionEntry regionEntry = entries.getEntry(currentKey);
-                this.entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, tag,
+                entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, tag,
-                      this.entries.removeEntry(currentKey, regionEntry, false);
+                      entries.removeEntry(currentKey, regionEntry, false);
-        this.handleDiskAccessException(dae);
+        handleDiskAccessException(dae);
-    return this.reinitialized_new;
+    return reinitialized_new;
-    this.cache.regionReinitializing(getFullPath());
+    cache.regionReinitializing(getFullPath());
-      LocalRegion parent = this.parentRegion;
+      LocalRegion parent = parentRegion;
-      if (this.diskStoreImpl != null
-          && this.diskStoreImpl.getName().equals(DiskStoreFactory.DEFAULT_DISK_STORE_NAME)
-          && this.diskStoreName == null && !useDefaultDiskStore()) {
-        this.diskStoreName = this.diskStoreImpl.getName();
+      if (diskStoreImpl != null
+          && diskStoreImpl.getName().equals(DiskStoreFactory.DEFAULT_DISK_STORE_NAME)
+          && diskStoreName == null && !useDefaultDiskStore()) {
+        diskStoreName = diskStoreImpl.getName();
-        newRegion = this.cache.createVMRegion(this.regionName, attrs, internalRegionArguments);
+        newRegion = cache.createVMRegion(regionName, attrs, internalRegionArguments);
-        newRegion = parent.createSubregion(this.regionName, attrs, internalRegionArguments);
+        newRegion = parent.createSubregion(regionName, attrs, internalRegionArguments);
-        this.cache.unregisterReinitializingRegion(thePath);
+        cache.unregisterReinitializingRegion(thePath);
-        if (this.getConcurrencyChecksEnabled()) {
+        if (getConcurrencyChecksEnabled()) {
-    this.reinitialized_new = true;
+    reinitialized_new = true;
-    if (this.initialized) {
+    if (initialized) {
-        return checkForInitialization(this.getInitializationLatchAfterGetInitialImage());
+        return checkForInitialization(getInitializationLatchAfterGetInitialImage());
-        return checkForInitialization(this.getInitializationLatchBeforeGetInitialImage());
+        return checkForInitialization(getInitializationLatchBeforeGetInitialImage());
-    if (this.initialized) {
+    if (initialized) {
-        waitOnInitialization(this.getInitializationLatchAfterGetInitialImage());
+        waitOnInitialization(getInitializationLatchAfterGetInitialImage());
-        waitOnInitialization(this.getInitializationLatchBeforeGetInitialImage());
+        waitOnInitialization(getInitializationLatchBeforeGetInitialImage());
-      this.cache.getCancelCriterion().checkCancelInProgress(null);
+      cache.getCancelCriterion().checkCancelInProgress(null);
-        this.cache.getCancelCriterion().checkCancelInProgress(e);
+        cache.getCancelCriterion().checkCancelInProgress(e);
-    if (this.initialized) {
+    if (initialized) {
-    waitOnInitialization(this.getInitializationLatchAfterGetInitialImage());
+    waitOnInitialization(getInitializationLatchAfterGetInitialImage());
-    RegionEntry regionEntry = this.entries.getEntry(key);
+    RegionEntry regionEntry = entries.getEntry(key);
-    Assert.assertTrue(this.diskRegion != null);
+    Assert.assertTrue(diskRegion != null);
-    RegionEntry regionEntry = this.entries.initRecoveredEntry(key, re);
+    RegionEntry regionEntry = entries.initRecoveredEntry(key, re);
-    Assert.assertTrue(this.diskRegion != null);
+    Assert.assertTrue(diskRegion != null);
-    RegionEntry regionEntry = this.entries.updateRecoveredEntry(key, re);
+    RegionEntry regionEntry = entries.updateRecoveredEntry(key, re);
-    this.entries.copyRecoveredEntries(rm);
+    entries.copyRecoveredEntries(rm);
-    this.versionVector.recordGCVersion(member, gcVersion);
+    versionVector.recordGCVersion(member, gcVersion);
-    DiskRegion region = this.getDiskRegion();
+    DiskRegion region = getDiskRegion();
-    if (this.getConcurrencyChecksEnabled()) {
+    if (getConcurrencyChecksEnabled()) {
-      this.versionVector.initRecoveredVersion(member, versionHolder, latestOplog);
-      DiskRegion region = this.getDiskRegion();
+      versionVector.initRecoveredVersion(member, versionHolder, latestOplog);
+      DiskRegion region = getDiskRegion();
-    if (this.getConcurrencyChecksEnabled()) {
-      this.versionVector.recordVersion(tag.getMemberID(), tag.getRegionVersion());
-      DiskRegion region = this.getDiskRegion();
+    if (getConcurrencyChecksEnabled()) {
+      versionVector.recordVersion(tag.getMemberID(), tag.getRegionVersion());
+      DiskRegion region = getDiskRegion();
-    if (this.getConcurrencyChecksEnabled()) {
-      DiskRegion region = this.getDiskRegion();
+    if (getConcurrencyChecksEnabled()) {
+      DiskRegion region = getDiskRegion();
-    return this.entries.regionEntries().iterator();
+    return entries.regionEntries().iterator();
-    RegionVersionVector rvv = this.getVersionVector();
+    RegionVersionVector rvv = getVersionVector();
-    final boolean forceNewEntryInClientCache = this.serverRegionProxy != null
+    final boolean forceNewEntryInClientCache = serverRegionProxy != null
-      if (this.getConcurrencyChecksEnabled() && event.getVersionTag() != null
+      if (getConcurrencyChecksEnabled() && event.getVersionTag() != null
-        this.stopper.checkCancelInProgress(null);
+        stopper.checkCancelInProgress(null);
-    this.entries.txApplyInvalidate(key, newValue, didDestroy, transactionId, event, localOp,
+    entries.txApplyInvalidate(key, newValue, didDestroy, transactionId, event, localOp,
-    if (this.testCallable != null) {
-      this.testCallable.call(this, Operation.INVALIDATE, regionEntry);
+    if (testCallable != null) {
+      testCallable.call(this, Operation.INVALIDATE, regionEntry);
-    this.entries.txApplyPut(putOp, key, newValue, didDestroy, transactionId, event, eventId,
+    entries.txApplyPut(putOp, key, newValue, didDestroy, transactionId, event, eventId,
-    if (this.testCallable != null) {
+    if (testCallable != null) {
-      this.testCallable.call(this, op, regionEntry);
+      testCallable.call(this, op, regionEntry);
-      if (this.indexManager != null) {
+      if (indexManager != null) {
-          this.indexManager.updateIndexes(regionEntry,
+          indexManager.updateIndexes(regionEntry,
-    if (this.statisticsEnabled && !clearConflict) {
+    if (statisticsEnabled && !clearConflict) {
-        this.stopper.checkCancelInProgress(null);
+        stopper.checkCancelInProgress(null);
-        this.stopper.checkCancelInProgress(null);
+        stopper.checkCancelInProgress(null);
-    if (!this.concurrencyMessageIssued && tag == null && this.getConcurrencyChecksEnabled()) {
-      this.concurrencyMessageIssued = true;
+    if (!concurrencyMessageIssued && tag == null && getConcurrencyChecksEnabled()) {
+      concurrencyMessageIssued = true;
-          new Object[] {!this.getConcurrencyChecksEnabled(), this.getConcurrencyChecksEnabled(),
+          new Object[] {!getConcurrencyChecksEnabled(), getConcurrencyChecksEnabled(),
-    if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
+    if (generateEventID() && !cache.getCacheServers().isEmpty()) {
-        if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
+        if (generateEventID() && !cache.getCacheServers().isEmpty()) {
-          final boolean forceNewEntry = this.getConcurrencyChecksEnabled();
+          final boolean forceNewEntry = getConcurrencyChecksEnabled();
-        if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
+        if (generateEventID() && !cache.getCacheServers().isEmpty()) {
-      if (this.getConcurrencyChecksEnabled() && event.getVersionTag() != null
+      if (getConcurrencyChecksEnabled() && event.getVersionTag() != null
-    if (this.keyConstraint != null) {
-      if (!this.keyConstraint.isInstance(event.getKey())) {
+    if (keyConstraint != null) {
+      if (!keyConstraint.isInstance(event.getKey())) {
-                event.getKey().getClass().getName(), this.keyConstraint.getName()));
+                event.getKey().getClass().getName(), keyConstraint.getName()));
-      oldEntry = this.entries.basicPut(event, lastModified, ifNew, ifOld, expectedOldValue,
+      oldEntry = entries.basicPut(event, lastModified, ifNew, ifOld, expectedOldValue,
-    if (mySRP != null && this.getDataPolicy() == DataPolicy.EMPTY) {
+    if (mySRP != null && getDataPolicy() == DataPolicy.EMPTY) {
-      InternalResourceManager.getInternalResourceManager(this.cache).getHeapMonitor()
+      InternalResourceManager.getInternalResourceManager(cache).getHeapMonitor()
-        Collections.singleton(this.cache.getMyId()));
+        Collections.singleton(cache.getMyId()));
-      if (!clearConflict && this.indexManager != null) {
+      if (!clearConflict && indexManager != null) {
-            this.indexManager.updateIndexes(entry,
+            indexManager.updateIndexes(entry,
-      } else if (this.isUsedForPartitionedRegionBucket) {
+      } else if (isUsedForPartitionedRegionBucket) {
-        if (event.isBulkOpInProgress() && this.isUsedForPartitionedRegionBucket) {
+        if (event.isBulkOpInProgress() && isUsedForPartitionedRegionBucket) {
-            this.stopper.checkCancelInProgress(null);
+            stopper.checkCancelInProgress(null);
-    FilterProfile filterProfile = this.getFilterProfile();
+    FilterProfile filterProfile = getFilterProfile();
-            && !this.scope.isDistributedNoAck() && entryEvent.getDeltaBytes() != null;
+            && !scope.isDistributedNoAck() && entryEvent.getDeltaBytes() != null;
-        logger.debug("{}: notifying {} cache servers of event: {}", this.getName(), numBS,
+        logger.debug("{}: notifying {} cache servers of event: {}", getName(), numBS,
-      if (!this.isUsedForPartitionedRegionBucket()) {
+      if (!isUsedForPartitionedRegionBucket()) {
-          if (!this.getDataPolicy().withStorage() && sender.isParallel()) {
+          if (!getDataPolicy().withStorage() && sender.isParallel()) {
-    final TXStateProxy tx = this.cache.getTXMgr().pauseTransaction();
+    final TXStateProxy tx = cache.getTXMgr().pauseTransaction();
-          if (this.parentRegion != null) {
+          if (parentRegion != null) {
-            this.parentRegion.updateStats();
+            parentRegion.updateStats();
-            this.destroyedSubregionSerialNumbers = collectSubregionSerialNumbers();
+            destroyedSubregionSerialNumbers = collectSubregionSerialNumbers();
-            if (!this.cache.forcedDisconnect()) {
+            if (!cache.forcedDisconnect()) {
-          Assert.assertTrue(this.isDestroyed);
+          Assert.assertTrue(isDestroyed);
-            InternalDistributedSystem system = this.cache.getInternalDistributedSystem();
+            InternalDistributedSystem system = cache.getInternalDistributedSystem();
-            LocalRegion parent = this.parentRegion;
+            LocalRegion parent = parentRegion;
-              this.cache.removeRoot(this);
+              cache.removeRoot(this);
-              parent.subregions.remove(this.regionName, this);
+              parent.subregions.remove(regionName, this);
-            if (!this.cache.forcedDisconnect()) {
+            if (!cache.forcedDisconnect()) {
-      this.cache.getTXMgr().unpauseTransaction(tx);
+      cache.getTXMgr().unpauseTransaction(tx);
-      final LogWriter logWriter = this.cache.getLogger();
+      final LogWriter logWriter = cache.getLogger();
-      InternalResourceManager rm = this.cache.getInternalResourceManager();
+      InternalResourceManager rm = cache.getInternalResourceManager();
-    if (this.diskRegion != null) {
+    if (diskRegion != null) {
-        this.diskRegion.endDestroy(this);
+        diskRegion.endDestroy(this);
-        this.diskRegion.close(this);
+        diskRegion.close(this);
-    if (this.versionVector != null) {
+    if (versionVector != null) {
-        this.cache.getDistributionManager().removeMembershipListener(this.versionVector);
+        cache.getDistributionManager().removeMembershipListener(versionVector);
-      if (this.getConcurrencyChecksEnabled() && event.getVersionTag() != null
+      if (getConcurrencyChecksEnabled() && event.getVersionTag() != null
-      final boolean needRIDestroyToken = inRI && this.riCnt > 0;
+      final boolean needRIDestroyToken = inRI && riCnt > 0;
-      return this.entries.destroy(event, inTokenMode, needRIDestroyToken, cacheWrite, isEviction,
+      return entries.destroy(event, inTokenMode, needRIDestroyToken, cacheWrite, isEviction,
-            this.fullPath);
+            fullPath);
-      event.setNewEventId(this.cache.getDistributedSystem());
+      event.setNewEventId(cache.getDistributedSystem());
-    if (inTokenMode && !(this.getConcurrencyChecksEnabled() || event.isFromRILocalDestroy())) {
+    if (inTokenMode && !(getConcurrencyChecksEnabled() || event.isFromRILocalDestroy())) {
-      if (this.getConcurrencyChecksEnabled() && !(this instanceof HARegion)) {
+      if (getConcurrencyChecksEnabled() && !(this instanceof HARegion)) {
-    if (event.isBulkOpInProgress() && this.isUsedForPartitionedRegionBucket) {
+    if (event.isBulkOpInProgress() && isUsedForPartitionedRegionBucket) {
-      if (isInitialized() && (!inTokenMode || duringRI) || this.isUsedForPartitionedRegionBucket) {
+      if (isInitialized() && (!inTokenMode || duringRI) || isUsedForPartitionedRegionBucket) {
-          this.stopper.checkCancelInProgress(null);
+          stopper.checkCancelInProgress(null);
-    final boolean needRIDestroyToken = inRI && this.riCnt > 0;
+    final boolean needRIDestroyToken = inRI && riCnt > 0;
-      this.entries.txApplyDestroy(key, rmtOrigin, event, inTokenMode, needRIDestroyToken, op,
+      entries.txApplyDestroy(key, rmtOrigin, event, inTokenMode, needRIDestroyToken, op,
-    if (this.testCallable != null) {
-      this.testCallable.call(this, Operation.DESTROY, re);
+    if (testCallable != null) {
+      testCallable.call(this, Operation.DESTROY, re);
-    final TXStateProxy tx = this.cache.getTXMgr().pauseTransaction();
+    final TXStateProxy tx = cache.getTXMgr().pauseTransaction();
-      this.setRegionInvalid(true);
+      setRegionInvalid(true);
-      this.cache.getTXMgr().unpauseTransaction(tx);
+      cache.getTXMgr().unpauseTransaction(tx);
-        if (this.cache.getEventThreadPool() == null) {
+        if (cache.getEventThreadPool() == null) {
-            this.cache.getEventThreadPool().execute(eventDispatcher);
+            cache.getEventThreadPool().execute(eventDispatcher);
-    if (this.initialized) {
+    if (initialized) {
-    StoppableCountDownLatch latch = this.getInitializationLatchAfterGetInitialImage();
+    StoppableCountDownLatch latch = getInitializationLatchAfterGetInitialImage();
-      this.initialized = true;
+      initialized = true;
-      this.cache.getCancelCriterion().checkCancelInProgress(null);
+      cache.getCancelCriterion().checkCancelInProgress(null);
-        this.cache.getCancelCriterion().checkCancelInProgress(ie);
+        cache.getCancelCriterion().checkCancelInProgress(ie);
-    this.isDestroyed = true;
+    isDestroyed = true;
-    this.cache.getInternalResourceManager(false).removeResourceListener(this);
+    cache.getInternalResourceManager(false).removeResourceListener(this);
-    this.destroyedSubregionSerialNumbers = collectSubregionSerialNumbers();
+    destroyedSubregionSerialNumbers = collectSubregionSerialNumbers();
-      if (this.diskRegion != null) {
+      if (diskRegion != null) {
-          this.diskRegion.cleanupFailedInitialization(this);
+          diskRegion.cleanupFailedInitialization(this);
-      this.cache.invokeCleanupFailedInitialization(this);
+      cache.invokeCleanupFailedInitialization(this);
-      this.releaseLatches();
+      releaseLatches();
-    synchronized (this.subregionsLock) {
-      this.subregions.remove(subregion.getName());
+    synchronized (subregionsLock) {
+      subregions.remove(subregion.getName());
-    if (this.statisticsEnabled && !isProxy()) {
+    if (statisticsEnabled && !isProxy()) {
-    LocalRegion region = toRegion(this.subregions.get(name));
+    LocalRegion region = toRegion(subregions.get(name));
-      region = (LocalRegion) this.cache.getReinitializingRegion(thePath);
+      region = (LocalRegion) cache.getReinitializingRegion(thePath);
-    if (!this.statisticsEnabled) {
+    if (!statisticsEnabled) {
-      if (!this.cache.forcedDisconnect()) {
+      if (!cache.forcedDisconnect()) {
-      String poolName = this.getPoolName();
-      PoolImpl pool = (PoolImpl) PoolManager.find(this.getPoolName());
+      String poolName = getPoolName();
+      PoolImpl pool = (PoolImpl) PoolManager.find(getPoolName());
-    if (!this.isDestroyed) { // don't destroy if already destroyed
+    if (!isDestroyed) { // don't destroy if already destroyed
-    if (this.cache.isClosed()) {
-      throw this.cache.getCacheClosedException(null, null);
+    if (cache.isClosed()) {
+      throw cache.getCacheClosedException(null, null);
-      this.cache.getCancelCriterion().checkCancelInProgress(null);
+      cache.getCancelCriterion().checkCancelInProgress(null);
-    if (this.isDestroyed) {
+    if (isDestroyed) {
-      if (this.reinitialized_old) {
+      if (reinitialized_old) {
-      } else if (this.cache.isCacheAtShutdownAll()) {
+      } else if (cache.isCacheAtShutdownAll()) {
-        this.cache.getCancelCriterion().checkCancelInProgress(null);
+        cache.getCancelCriterion().checkCancelInProgress(null);
-    if (this.isDestroyedForParallelWAN) {
+    if (isDestroyedForParallelWAN) {
-    for (RegionEntry regionEntry : this.entries.regionEntriesInVM()) {
+    for (RegionEntry regionEntry : entries.regionEntriesInVM()) {
-    for (Object regionObject : this.subregions.values()) {
+    for (Object regionObject : subregions.values()) {
-    for (Object regionObject : this.subregions.values()) {
+    for (Object regionObject : subregions.values()) {
-    return this.diskStoreImpl;
+    return diskStoreImpl;
-    if (this.diskStoreImpl == null) {
+    if (diskStoreImpl == null) {
-    if (this.getAttributes().getConcurrencyChecksEnabled()) {
+    if (getAttributes().getConcurrencyChecksEnabled()) {
-    return DiskRegion.create(this.diskStoreImpl, getFullPath(), false,
+    return DiskRegion.create(diskStoreImpl, getFullPath(), false,
-    synchronized (this.regionExpiryLock) {
-      RegionTTLExpiryTask task = this.regionTTLExpiryTask;
+    synchronized (regionExpiryLock) {
+      RegionTTLExpiryTask task = regionTTLExpiryTask;
-      if (this.regionTimeToLive > 0) {
-        this.regionTTLExpiryTask = (RegionTTLExpiryTask) this.cache.getExpirationScheduler()
+      if (regionTimeToLive > 0) {
+        regionTTLExpiryTask = (RegionTTLExpiryTask) cache.getExpirationScheduler()
-        if (this.regionTTLExpiryTask != null) {
+        if (regionTTLExpiryTask != null) {
-            logger.debug("Initialized Region TTL Expiry Task {}", this.regionTTLExpiryTask);
+            logger.debug("Initialized Region TTL Expiry Task {}", regionTTLExpiryTask);
-        this.regionTTLExpiryTask = null;
+        regionTTLExpiryTask = null;
-    synchronized (this.regionExpiryLock) {
-      if (this.regionTTLExpiryTask != null && this.regionTTLExpiryTask != callingTask) {
+    synchronized (regionExpiryLock) {
+      if (regionTTLExpiryTask != null && regionTTLExpiryTask != callingTask) {
-      if (this.regionTimeToLive <= 0) {
-        this.regionTTLExpiryTask = null;
+      if (regionTimeToLive <= 0) {
+        regionTTLExpiryTask = null;
-            this.regionTTLExpiryTask);
+            regionTTLExpiryTask);
-      this.regionTTLExpiryTask =
-          (RegionTTLExpiryTask) this.cache.getExpirationScheduler().addExpiryTask(task);
+      regionTTLExpiryTask =
+          (RegionTTLExpiryTask) cache.getExpirationScheduler().addExpiryTask(task);
-    synchronized (this.regionExpiryLock) {
-      RegionIdleExpiryTask task = this.regionIdleExpiryTask;
+    synchronized (regionExpiryLock) {
+      RegionIdleExpiryTask task = regionIdleExpiryTask;
-      if (this.regionIdleTimeout > 0) {
-        this.regionIdleExpiryTask = (RegionIdleExpiryTask) this.cache.getExpirationScheduler()
+      if (regionIdleTimeout > 0) {
+        regionIdleExpiryTask = (RegionIdleExpiryTask) cache.getExpirationScheduler()
-        if (this.regionIdleExpiryTask != null) {
+        if (regionIdleExpiryTask != null) {
-            logger.debug("Initialized Region Idle Expiry Task {}", this.regionIdleExpiryTask);
+            logger.debug("Initialized Region Idle Expiry Task {}", regionIdleExpiryTask);
-        this.regionIdleExpiryTask = null;
+        regionIdleExpiryTask = null;
-    synchronized (this.regionExpiryLock) {
-      if (this.regionIdleExpiryTask != null && this.regionIdleExpiryTask != callingTask) {
+    synchronized (regionExpiryLock) {
+      if (regionIdleExpiryTask != null && regionIdleExpiryTask != callingTask) {
-      if (this.regionIdleTimeout <= 0) {
-        this.regionIdleExpiryTask = null;
+      if (regionIdleTimeout <= 0) {
+        regionIdleExpiryTask = null;
-            this.regionIdleExpiryTask);
+            regionIdleExpiryTask);
-      this.regionIdleExpiryTask =
-          (RegionIdleExpiryTask) this.cache.getExpirationScheduler().addExpiryTask(task);
+      regionIdleExpiryTask =
+          (RegionIdleExpiryTask) cache.getExpirationScheduler().addExpiryTask(task);
-    return this.entryIdleTimeout > 0 || this.customEntryIdleTimeout != null;
+    return entryIdleTimeout > 0 || customEntryIdleTimeout != null;
-    synchronized (this.regionExpiryLock) {
-      task = this.regionTTLExpiryTask;
+    synchronized (regionExpiryLock) {
+      task = regionTTLExpiryTask;
-        this.regionTTLExpiryTask = null;
+        regionTTLExpiryTask = null;
-    synchronized (this.regionExpiryLock) {
-      task = this.regionIdleExpiryTask;
+    synchronized (regionExpiryLock) {
+      task = regionIdleExpiryTask;
-        this.regionIdleExpiryTask = null;
+        regionIdleExpiryTask = null;
-    if (this.customEntryTimeToLive != null) {
+    if (customEntryTimeToLive != null) {
-    if (this.entryTimeToLive > 0 && (oldTimeout == 0 || this.entryTimeToLive < oldTimeout)) {
+    if (entryTimeToLive > 0 && (oldTimeout == 0 || entryTimeToLive < oldTimeout)) {
-    if (this.customEntryIdleTimeout != null) {
+    if (customEntryIdleTimeout != null) {
-    if (this.entryIdleTimeout > 0 && (oldTimeout == 0 || this.entryIdleTimeout < oldTimeout)) {
+    if (entryIdleTimeout > 0 && (oldTimeout == 0 || entryIdleTimeout < oldTimeout)) {
-    Iterator<RegionEntry> it = this.entries.regionEntries().iterator();
+    Iterator<RegionEntry> it = entries.regionEntries().iterator();
-    if (this.customEntryIdleTimeout != null || this.customEntryTimeToLive != null) {
+    if (customEntryIdleTimeout != null || customEntryTimeToLive != null) {
-      final RegionAttributes<?, ?> regionAttributes = this.getAttributes();
+      final RegionAttributes<?, ?> regionAttributes = getAttributes();
-            this.checkEntryTimeoutAction("timeToLive", ttlAttributes.getAction());
+            checkEntryTimeoutAction("timeToLive", ttlAttributes.getAction());
-            this.checkEntryTimeoutAction("idleTimeout", idleAttributes.getAction());
+            checkEntryTimeoutAction("idleTimeout", idleAttributes.getAction());
-    RegionEntry re = this.getRegionEntry(key);
+    RegionEntry re = getRegionEntry(key);
-    return this.entryExpiryTasks.get(re);
+    return entryExpiryTasks.get(re);
-    return this.regionIdleExpiryTask;
+    return regionIdleExpiryTask;
-    return this.regionTTLExpiryTask;
+    return regionTTLExpiryTask;
-        oldTask = this.entryExpiryTasks.get(regionEntry);
+        oldTask = entryExpiryTasks.get(regionEntry);
-          if (this.customEntryIdleTimeout != null || this.customEntryTimeToLive != null) {
+          if (customEntryIdleTimeout != null || customEntryTimeToLive != null) {
-      oldTask = this.entryExpiryTasks.put(regionEntry, newTask);
-      ExpirationScheduler scheduler = this.cache.getExpirationScheduler();
+      oldTask = entryExpiryTasks.put(regionEntry, newTask);
+      ExpirationScheduler scheduler = cache.getExpirationScheduler();
-        this.entryExpiryTasks.remove(regionEntry);
+        entryExpiryTasks.remove(regionEntry);
-      this.entryExpiryTasks.remove(regionEntry, expiryTask);
+      entryExpiryTasks.remove(regionEntry, expiryTask);
-        this.cache.getExpirationScheduler().incCancels();
+        cache.getExpirationScheduler().incCancels();
-      EntryExpiryTask oldTask = this.entryExpiryTasks.remove(regionEntry);
+      EntryExpiryTask oldTask = entryExpiryTasks.remove(regionEntry);
-          this.cache.getExpirationScheduler().incCancels();
+          cache.getExpirationScheduler().incCancels();
-    if (this.entryExpiryTasks == null)
+    if (entryExpiryTasks == null)
-    if (this.entryExpiryTasks.isEmpty())
+    if (entryExpiryTasks.isEmpty())
-    for (EntryExpiryTask task : this.entryExpiryTasks.values()) {
+    for (EntryExpiryTask task : entryExpiryTasks.values()) {
-      this.cache.getExpirationScheduler().forcePurge();
+      cache.getExpirationScheduler().forcePurge();
-    return this.imageState;
+    return imageState;
-    return this.parentRegion;
+    return parentRegion;
-    if (this.supportsTX) {
+    if (supportsTX) {
-    final RegionEntry regionEntry = this.basicGetTXEntry(keyInfo);
+    final RegionEntry regionEntry = basicGetTXEntry(keyInfo);
-    if (this.ignoreJTA) {
+    if (ignoreJTA) {
-        if (!this.ignoreJTA && this.cache.getJTATransactionManager() != null) {
+        if (!ignoreJTA && cache.getJTATransactionManager() != null) {
-          Transaction jtaTransaction = this.cache.getJTATransactionManager().getTransaction();
+          Transaction jtaTransaction = cache.getJTATransactionManager().getTransaction();
-          txState = this.cache.getTXMgr().beginJTA();
+          txState = cache.getTXMgr().beginJTA();
-        this.stopper.checkCancelInProgress(se);
+        stopper.checkCancelInProgress(se);
-    if (this.cache == null) {
+    if (cache == null) {
-    this.cache.getTXMgr().setTXState(null);
+    cache.getTXMgr().setTXState(null);
-      jtaTransName = this.cache.getJTATransactionManager().getTransaction().toString();
+      jtaTransName = cache.getJTATransactionManager().getTransaction().toString();
-    return this.entries.disableLruUpdateCallback();
+    return entries.disableLruUpdateCallback();
-    this.entries.enableLruUpdateCallback();
+    entries.enableLruUpdateCallback();
-      this.entries.lruUpdateCallback();
+      entries.lruUpdateCallback();
-    this.entries.decTxRefCount(regionEntry);
+    entries.decTxRefCount(regionEntry);
-    names.addAll(this.subregions.keySet());
+    names.addAll(subregions.keySet());
-    this.entries.incRecentlyUsed();
+    entries.incRecentlyUsed();
-    return this.entries;
+    return entries;
-    boolean isClient = this.imageState.isClient();
+    boolean isClient = imageState.isClient();
-    boolean isClient = this.imageState.isClient();
+    boolean isClient = imageState.isClient();
-    return this.size() <= 0;
+    return size() <= 0;
-    if (useRVV && this.getDataPolicy().withReplication() && this.getConcurrencyChecksEnabled()) {
-      rvv = this.versionVector.getCloneForTransmission();
+    if (useRVV && getDataPolicy().withReplication() && getConcurrencyChecksEnabled()) {
+      rvv = versionVector.getCloneForTransmission();
-    if (this.serverRegionProxy != null) {
+    if (serverRegionProxy != null) {
-    if (rvv != null && this.getDataPolicy().withStorage()) {
+    if (rvv != null && getDataPolicy().withStorage()) {
-            getLineSeparator(), this.versionVector.fullToString(), rvv);
+            getLineSeparator(), versionVector.fullToString(), rvv);
-      boolean result = this.versionVector.waitToDominate(rvv, this);
+      boolean result = versionVector.waitToDominate(rvv, this);
-              this.versionVector.fullToString());
+              versionVector.fullToString());
-      this.cacheWriteBeforeRegionClear(regionEvent);
+      cacheWriteBeforeRegionClear(regionEvent);
-    this.cancelAllEntryExpiryTasks();
+    cancelAllEntryExpiryTasks();
-    if (this.diskRegion != null) {
+    if (diskRegion != null) {
-      if (this.getDataPolicy().withPersistence()) {
+      if (getDataPolicy().withPersistence()) {
-              this.diskRegion.getRegionVersionVector());
+              diskRegion.getRegionVersionVector());
-        this.diskRegion.writeRVV(this, null);
-        this.diskRegion.writeRVVGC(this);
+        diskRegion.writeRVV(this, null);
+        diskRegion.writeRVVGC(this);
-      this.diskRegion.clear(this, rvv);
+      diskRegion.clear(this, rvv);
-      if (!this.getDataPolicy().withPersistence()) {
+      if (!getDataPolicy().withPersistence()) {
-      if (this.indexManager != null) {
+      if (indexManager != null) {
-          this.indexManager.rerunIndexCreationQuery();
+          indexManager.rerunIndexCreationQuery();
-            createTombstone = entry.getVersionTag() != null && this.getConcurrencyChecksEnabled();
+            createTombstone = entry.getVersionTag() != null && getConcurrencyChecksEnabled();
-              TXStateProxy txState = this.cache.getTXMgr().pauseTransaction();
+              TXStateProxy txState = cache.getTXMgr().pauseTransaction();
-                this.cache.getTXMgr().unpauseTransaction(txState);
+                cache.getTXMgr().unpauseTransaction(txState);
-    return this.getDataPolicy().withStorage();
+    return getDataPolicy().withStorage();
-      event.reserveNewEventId(this.cache.getDistributedSystem(), map.size());
+      event.reserveNewEventId(cache.getDistributedSystem(), map.size());
-        TXStateProxyImpl txState = (TXStateProxyImpl) this.cache.getTxManager().getTXState();
+        TXStateProxyImpl txState = (TXStateProxyImpl) cache.getTxManager().getTXState();
-        new VersionedObjectList(map.size(), true, this.getConcurrencyChecksEnabled());
+        new VersionedObjectList(map.size(), true, getConcurrencyChecksEnabled());
-        && !isTX() && this.getDataPolicy() != DataPolicy.EMPTY;
+        && !isTX() && getDataPolicy() != DataPolicy.EMPTY;
-      event.reserveNewEventId(this.cache.getDistributedSystem(), keys.size());
+      event.reserveNewEventId(cache.getDistributedSystem(), keys.size());
-        TXStateProxyImpl txState = (TXStateProxyImpl) this.cache.getTxManager().getTXState();
+        TXStateProxyImpl txState = (TXStateProxyImpl) cache.getTxManager().getTXState();
-        new VersionedObjectList(keys.size(), true, this.getConcurrencyChecksEnabled());
+        new VersionedObjectList(keys.size(), true, getConcurrencyChecksEnabled());
-    if (this.versionVector != null && this.getDataPolicy().withReplication()) {
-      this.versionVector.lockForCacheModification(this);
+    if (versionVector != null && getDataPolicy().withReplication()) {
+      versionVector.lockForCacheModification(this);
-    if (this.versionVector != null && this.getDataPolicy().withReplication()) {
-      this.versionVector.releaseCacheModificationLock(this);
+    if (versionVector != null && getDataPolicy().withReplication()) {
+      versionVector.releaseCacheModificationLock(this);
-    if (!this.getDataPolicy().withStorage() && this.getConcurrencyChecksEnabled()
+    if (!getDataPolicy().withStorage() && getConcurrencyChecksEnabled()
-            this.isUsedForPartitionedRegionBucket
+            isUsedForPartitionedRegionBucket
-    if (!this.getDataPolicy().withStorage() && this.getConcurrencyChecksEnabled()
+    if (!getDataPolicy().withStorage() && getConcurrencyChecksEnabled()
-            this.isUsedForPartitionedRegionBucket
+            isUsedForPartitionedRegionBucket
-    for (Object regionObject : this.subregions.values()) {
+    for (Object regionObject : subregions.values()) {
-    return this.isUsedForPartitionedRegionAdmin;
+    return isUsedForPartitionedRegionAdmin;
-    return this.getConcurrencyChecksEnabled() && this.getDataPolicy().withReplication()
-        && !this.isUsedForPartitionedRegionAdmin && !this.isUsedForMetaRegion
-        && !this.isUsedForSerialGatewaySenderQueue;
+    return getConcurrencyChecksEnabled() && getDataPolicy().withReplication()
+        && !isUsedForPartitionedRegionAdmin && !isUsedForMetaRegion
+        && !isUsedForSerialGatewaySenderQueue;
-    if (this.diskRegion != null) {
-      this.diskRegion.forceRolling();
+    if (diskRegion != null) {
+      diskRegion.forceRolling();
-      return this.diskDirs;
+      return diskDirs;
-      return this.diskSizes;
+      return diskSizes;
-    return this.isUsedForPartitionedRegionBucket;
+    return isUsedForPartitionedRegionBucket;
-    return this.isUsedForSerialGatewaySenderQueue;
+    return isUsedForSerialGatewaySenderQueue;
-    return this.isUsedForParallelGatewaySenderQueue;
+    return isUsedForParallelGatewaySenderQueue;
-      this.cacheServiceProfiles.remove(profileID);
+      cacheServiceProfiles.remove(profileID);
-    return this.serialGatewaySender;
+    return serialGatewaySender;
-    Set<String> regionGatewaySenderIds = this.getAllGatewaySenderIds();
+    Set<String> regionGatewaySenderIds = getAllGatewaySenderIds();
-    if (!this.isUsedForPartitionedRegionBucket) {
+    if (!isUsedForPartitionedRegionBucket) {
-    return this.isUsedForMetaRegion;
+    return isUsedForMetaRegion;
-    return this.isMetaRegionWithTransactions;
+    return isMetaRegionWithTransactions;
-    return this.cacheServiceProfiles.getSnapshot();
+    return cacheServiceProfiles.getSnapshot();
-      this.cacheServiceProfiles.put(profile.getId(), profile);
+      cacheServiceProfiles.put(profile.getId(), profile);
-    return !isSecret() || this.getDataPolicy().withPersistence();
+    return !isSecret() || getDataPolicy().withPersistence();
-    return !this.cache.getCacheServers().isEmpty() && !this.isUsedForPartitionedRegionAdmin
-        && !this.isUsedForPartitionedRegionBucket && !this.isUsedForMetaRegion;
+    return !cache.getCacheServers().isEmpty() && !isUsedForPartitionedRegionAdmin
+        && !isUsedForPartitionedRegionBucket && !isUsedForMetaRegion;
-    if (this.cache.isClosed() || this.isDestroyed) {
+    if (cache.isClosed() || isDestroyed) {
-    this.filterProfile.cleanupForClient(clientNotifier, client);
+    filterProfile.cleanupForClient(clientNotifier, client);
-    return this.filterProfile;
+    return filterProfile;
-    if (!this.isDestroyed) {
+    if (!isDestroyed) {
-    return this.destroyedSubregionSerialNumbers;
+    return destroyedSubregionSerialNumbers;
-    for (Object entryObject : this.subregions.entrySet()) {
+    for (Object entryObject : subregions.entrySet()) {
-    return this.entries.lruLimitExceeded(getDiskRegionView());
+    return entries.lruLimitExceeded(getDiskRegionView());
-    RegionEntry regionEntry = this.entries.getEntry(key);
+    RegionEntry regionEntry = entries.getEntry(key);
-    return this.sharedDataView;
+    return sharedDataView;
-    synchronized (this.entries) {
-      if (this.entries instanceof AbstractRegionMap) {
-        ((AbstractRegionMap) this.entries).verifyTombstoneCount(this.tombstoneCount);
+    synchronized (entries) {
+      if (entries instanceof AbstractRegionMap) {
+        ((AbstractRegionMap) entries).verifyTombstoneCount(tombstoneCount);
-          this.toString());
-      if (this.entries instanceof AbstractRegionMap) {
-        ((AbstractRegionMap) this.entries).dumpMap();
+          toString());
+      if (entries instanceof AbstractRegionMap) {
+        ((AbstractRegionMap) entries).dumpMap();
-    if (this.serverRegionProxy == null
-        && (this.getDataPolicy() == DataPolicy.NORMAL && this.scope.isDistributed()
-            || this.getDataPolicy() == DataPolicy.EMPTY)) {
+    if (serverRegionProxy == null
+        && (getDataPolicy() == DataPolicy.NORMAL && scope.isDistributed()
+            || getDataPolicy() == DataPolicy.EMPTY)) {
-    return this.getDataPolicy().withStorage();
+    return getDataPolicy().withStorage();
-          event.setNewEventId(this.cache.getDistributedSystem());
+          event.setNewEventId(cache.getDistributedSystem());
-        event.setNewEventId(this.cache.getDistributedSystem());
+        event.setNewEventId(cache.getDistributedSystem());
-        event.setNewEventId(this.cache.getDistributedSystem());
+        event.setNewEventId(cache.getDistributedSystem());
-        event.setNewEventId(this.cache.getDistributedSystem());
+        event.setNewEventId(cache.getDistributedSystem());
-      this.stopper.checkCancelInProgress(null);
+      stopper.checkCancelInProgress(null);
-      this.stopper.checkCancelInProgress(null);
+      stopper.checkCancelInProgress(null);
-      this.stopper.checkCancelInProgress(null);
+      stopper.checkCancelInProgress(null);
-    synchronized (this.regionExpiryLock) {
+    synchronized (regionExpiryLock) {
-        this.txRefCount++;
+        txRefCount++;
-        this.txRefCount--;
-        assert this.txRefCount >= 0;
-        if (this.txRefCount == 0) {
-          if (this.regionTTLExpiryTask == null && this.regionTimeToLive > 0) {
-            this.addTTLExpiryTask();
+        txRefCount--;
+        assert txRefCount >= 0;
+        if (txRefCount == 0) {
+          if (regionTTLExpiryTask == null && regionTimeToLive > 0) {
+            addTTLExpiryTask();
-          if (this.regionIdleExpiryTask == null && this.regionIdleTimeout > 0) {
-            this.addIdleExpiryTask();
+          if (regionIdleExpiryTask == null && regionIdleTimeout > 0) {
+            addIdleExpiryTask();
-    synchronized (this.regionExpiryLock) {
+    synchronized (regionExpiryLock) {
-        if (regionExpiryTask != this.regionTTLExpiryTask) {
+        if (regionExpiryTask != regionTTLExpiryTask) {
-          this.regionTTLExpiryTask = null;
+          regionTTLExpiryTask = null;
-        if (regionExpiryTask != this.regionIdleExpiryTask) {
+        if (regionExpiryTask != regionIdleExpiryTask) {
-          this.regionIdleExpiryTask = null;
+          regionIdleExpiryTask = null;
-      if (this.txRefCount > 0) {
+      if (txRefCount > 0) {
-    return this.entries.getEvictions();
+    return entries.getEvictions();
-    this.memoryThresholdReached.set(reached);
+    memoryThresholdReached.set(reached);
-        private Iterator currentIterator = LocalRegion.this.subregions.values().iterator();
+        private Iterator currentIterator = subregions.values().iterator();
-          if (this.nextElement != null) {
+          if (nextElement != null) {
-              this.nextElement = element;
+              nextElement = element;
-          return this.currentIterator != null && this.currentIterator.hasNext();
+          return currentIterator != null && currentIterator.hasNext();
-          if (this.nextElement != null) {
-            Object next = this.nextElement;
-            this.nextElement = null;
+          if (nextElement != null) {
+            Object next = nextElement;
+            nextElement = null;
-              if (this.queue == null || this.queue.isEmpty()) {
+              if (queue == null || queue.isEmpty()) {
-                this.currentIterator = (Iterator) queue.remove(0);
+                currentIterator = (Iterator) queue.remove(0);
-              if (this.queue == null) {
-                this.queue = new ArrayList();
+              if (queue == null) {
+                queue = new ArrayList();
-              this.queue.add(nextIterator);
+              queue.add(nextIterator);
-            if (this.queue == null || this.queue.isEmpty()) {
-              this.currentIterator = null;
+            if (queue == null || queue.isEmpty()) {
+              currentIterator = null;
-              this.currentIterator = (Iterator) this.queue.remove(0);
+              currentIterator = (Iterator) queue.remove(0);
-      if (this.recursive) {
+      if (recursive) {
-        return LocalRegion.this.subregions.size();
+        return subregions.size();
-      List temp = new ArrayList(this.size());
+      List temp = new ArrayList(size());
-      List temp = new ArrayList(this.size());
+      List temp = new ArrayList(size());
-      Cache cache = LocalRegion.this.getCache();
+      Cache cache = getCache();
-      Cache cache = LocalRegion.this.getCache();
+      Cache cache = getCache();
-      if (LocalRegion.this.offHeap && event instanceof EntryEventImpl) {
+      if (offHeap && event instanceof EntryEventImpl) {
-        dispatchEvent(LocalRegion.this, this.event, this.op);
+        dispatchEvent(LocalRegion.this, event, op);
-        this.release();
+        release();
-      if (LocalRegion.this.offHeap && this.event instanceof EntryEventImpl) {
-        ((Releasable) this.event).release();
+      if (offHeap && event instanceof EntryEventImpl) {
+        ((Releasable) event).release();

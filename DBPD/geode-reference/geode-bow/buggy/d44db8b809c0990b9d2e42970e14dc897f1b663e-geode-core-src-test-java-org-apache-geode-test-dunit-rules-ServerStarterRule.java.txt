GEODE-2395: use random ports when starting the jmx manager and http services

* be able to configure the various aspects of the rules before starting the server when declaring the rules.
* delete the unnecessary abstract test classes
* allowing tests to use default ports if needed
* created HttpClientRule to ease the connection to to pulse server

-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS;
+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.START_DEV_REST_API;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.AvailablePortHelper;
- * You can create this rule either with a property or without a property. If created with a
- * property, The rule will automatically start the server for you with the properties given.
- *
- * If created without a property, the rule won't start the server until you specicially call one of
- * the startServer function.
- *
- * Either way, the rule will handle properly stopping the server for you.
- *
-public class ServerStarterRule extends MemberStarterRule implements Server {
+public class ServerStarterRule extends MemberStarterRule<ServerStarterRule> implements Server {
+  private int embeddedLocatorPort = -1;
-   * up to the caller's responsibility to delete it.
+   * the caller's responsibility to delete it.
-    this.workingDir = workingDir;
+    super(workingDir);
+  public ServerStarterRule withEmbeddedLocator() {
+    embeddedLocatorPort = AvailablePortHelper.getRandomAvailableTCPPort();
+    properties.setProperty("start-locator", "localhost[" + embeddedLocatorPort + "]");
+    return this;
+  }
+
+  public ServerStarterRule withRestService() {
+    return withRestService(false);
+  }
+
+  public ServerStarterRule withRestService(boolean useDefaultPort) {
+    properties.setProperty(START_DEV_REST_API, "true");
+    properties.setProperty(HTTP_SERVICE_BIND_ADDRESS, "localhost");
+    if (!useDefaultPort) {
+      httpPort = AvailablePortHelper.getRandomAvailableTCPPort();
+      properties.setProperty(HTTP_SERVICE_PORT, httpPort + "");
+    }
+    return this;
+  }
+
-    return startServer(new Properties(), -1, false);
+    return startServer(false);
-  public ServerStarterRule startServer(int locatorPort) {
-    return startServer(new Properties(), locatorPort, false);
-  }
-
-  public ServerStarterRule startServer(int locatorPort, boolean pdxPersistent) {
-    return startServer(new Properties(), locatorPort, pdxPersistent);
-  }
-
-  public ServerStarterRule startServer(Properties properties) {
-    return startServer(properties, -1, false);
+  public ServerStarterRule createRegion(RegionShortcut type, String name) {
+    cache.createRegionFactory(type).create(name);
+    return this;
-    return startServer(properties, locatorPort, false);
+    return withProperties(properties).withConnectionToLocator(locatorPort).startServer();
-  public ServerStarterRule startServer(Properties properties, int locatorPort,
-      boolean pdxPersistent) {
-    if (properties == null) {
-      properties = new Properties();
-    }
-    if (!properties.containsKey(NAME)) {
-      properties.setProperty(NAME, "server");
-    }
-    name = properties.getProperty(NAME);
-    if (!properties.containsKey(LOG_FILE)) {
-      properties.setProperty(LOG_FILE, new File(name + ".log").getAbsolutePath().toString());
-    }
-
-    if (locatorPort > 0) {
-      properties.setProperty(LOCATORS, "localhost[" + locatorPort + "]");
-    }
-    if (!properties.containsKey(MCAST_PORT)) {
-      properties.setProperty(MCAST_PORT, "0");
-    }
-
-    if (!properties.containsKey(LOCATORS)) {
-      properties.setProperty(LOCATORS, "");
-    }
-    if (properties.containsKey(JMX_MANAGER_PORT)) {
-      jmxPort = Integer.parseInt(properties.getProperty(JMX_MANAGER_PORT));
-      if (jmxPort > 0) {
-        if (!properties.containsKey(JMX_MANAGER))
-          properties.put(JMX_MANAGER, "true");
-        if (!properties.containsKey(JMX_MANAGER_START))
-          properties.put(JMX_MANAGER_START, "true");
-      }
-    }
-    CacheFactory cf = new CacheFactory(properties);
+  public ServerStarterRule startServer(boolean pdxPersistent) {
+    normalizeProperties();
+    CacheFactory cf = new CacheFactory(this.properties);
+    DistributionConfig config =
+        ((InternalDistributedSystem) cache.getDistributedSystem()).getConfig();
+    jmxPort = config.getJmxManagerPort();
+    httpPort = config.getHttpServicePort();
+
+  public int getEmbeddedLocatorPort() {
+    return embeddedLocatorPort;
+  }
+

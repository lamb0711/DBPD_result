Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Triggers centralized eviction(asynchronously) when the ResourceManager sends
- * an eviction event for on-heap regions. This is registered with the ResourceManager.
+ * Triggers centralized eviction(asynchronously) when the ResourceManager sends an eviction event
+ * for on-heap regions. This is registered with the ResourceManager.
-  
+
-      DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.MAX_EVICTOR_THREADS", (Runtime.getRuntime().availableProcessors() * 4)) + 1;
+      DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.MAX_EVICTOR_THREADS",
+      (Runtime.getRuntime().availableProcessors() * 4)) + 1;
-  public static final boolean DISABLE_HEAP_EVICTIOR_THREAD_POOL = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.DISABLE_HEAP_EVICTIOR_THREAD_POOL");
+  public static final boolean DISABLE_HEAP_EVICTIOR_THREAD_POOL =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX
+          + "HeapLRUCapacityController.DISABLE_HEAP_EVICTIOR_THREAD_POOL");
-  public static final boolean EVICT_HIGH_ENTRY_COUNT_BUCKETS_FIRST = Boolean.valueOf(
-      System.getProperty(
-          DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.evictHighEntryCountBucketsFirst",
-          "true")).booleanValue(); 
+  public static final boolean EVICT_HIGH_ENTRY_COUNT_BUCKETS_FIRST =
+      Boolean
+          .valueOf(System.getProperty(DistributionConfig.GEMFIRE_PREFIX
+              + "HeapLRUCapacityController.evictHighEntryCountBucketsFirst", "true"))
+          .booleanValue();
-  public static final int MINIMUM_ENTRIES_PER_BUCKET = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.inlineEvictionThreshold", 0);
-  
-  public static final long TOTAL_BYTES_TO_EVICT_FROM_HEAP; 
-  
-  public static final int BUCKET_SORTING_INTERVAL = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.higherEntryCountBucketCalculationInterval",
-      100).intValue();
-  
+  public static final int MINIMUM_ENTRIES_PER_BUCKET = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.inlineEvictionThreshold", 0);
+
+  public static final long TOTAL_BYTES_TO_EVICT_FROM_HEAP;
+
+  public static final int BUCKET_SORTING_INTERVAL =
+      Integer
+          .getInteger(DistributionConfig.GEMFIRE_PREFIX
+              + "HeapLRUCapacityController.higherEntryCountBucketCalculationInterval", 100)
+          .intValue();
+
-  
+
-        DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.evictionBurstPercentage", "0.4"));
+        DistributionConfig.GEMFIRE_PREFIX + "HeapLRUCapacityController.evictionBurstPercentage",
+        "0.4"));
-    TOTAL_BYTES_TO_EVICT_FROM_HEAP = (long)(maxTenuredBytes * 0.01 * evictionBurstPercentage);
+    TOTAL_BYTES_TO_EVICT_FROM_HEAP = (long) (maxTenuredBytes * 0.01 * evictionBurstPercentage);
-  
+
-  protected final Cache cache;  
+  protected final Cache cache;
-  private final ArrayList testTaskSetSizes = new  ArrayList();
+  private final ArrayList testTaskSetSizes = new ArrayList();
-  
+
-  
+
-  
+
-    return (region.getEvictionAttributes().getAlgorithm().isLRUHeap() 
-        && (region.getDataStore() != null) 
-        && !region.getAttributes().getOffHeap());
+    return (region.getEvictionAttributes().getAlgorithm().isLRUHeap()
+        && (region.getDataStore() != null) && !region.getAttributes().getOffHeap());
-  
+
-    return (region.getEvictionAttributes().getAlgorithm().isLRUHeap() 
+    return (region.getEvictionAttributes().getAlgorithm().isLRUHeap()
-  
+
-    InternalResourceManager irm = (InternalResourceManager)cache
-        .getResourceManager();
-    
+    InternalResourceManager irm = (InternalResourceManager) cache.getResourceManager();
+
-        PartitionedRegion pr = (PartitionedRegion)listener;
+        PartitionedRegion pr = (PartitionedRegion) listener;
-      }
-      else if (listener instanceof LocalRegion) {
-        LocalRegion lr = (LocalRegion)listener;
+      } else if (listener instanceof LocalRegion) {
+        LocalRegion lr = (LocalRegion) listener;
-      while(iter.hasNext()){
+      while (iter.hasNext()) {
-          if (((BucketRegion)lr).getNumEntriesInVM() <= HeapEvictor.MINIMUM_ENTRIES_PER_BUCKET) {
+          if (((BucketRegion) lr).getNumEntriesInVM() <= HeapEvictor.MINIMUM_ENTRIES_PER_BUCKET) {
-        }        
+        }
-  
-  private List<LocalRegion> getAllSortedRegionList(){
+
+  private List<LocalRegion> getAllSortedRegionList() {
-    
-    //Capture the sizes so that they do not change while sorting
+
+    // Capture the sizes so that they do not change while sorting
-    for(LocalRegion r : allRegionList) {
-      long size = r instanceof BucketRegion ?((BucketRegion)r).getSizeForEviction() : r.size();
+    for (LocalRegion r : allRegionList) {
+      long size = r instanceof BucketRegion ? ((BucketRegion) r).getSizeForEviction() : r.size();
-    
-    //Sort with respect to other PR buckets also in case of multiple PRs
+
+    // Sort with respect to other PR buckets also in case of multiple PRs
-      public int compare(LocalRegion r1, LocalRegion r2) {        
+      public int compare(LocalRegion r1, LocalRegion r2) {
-        }
-        else if (numEntries1 < numEntries2) {
+        } else if (numEntries1 < numEntries2) {
-    return (GemFireCacheImpl)this.cache;
+    return (GemFireCacheImpl) this.cache;
-  
+
-    final ThreadGroup evictorThreadGroup = LoggingThreadGroup.createThreadGroup(
-        getEvictorThreadGroupName(), logger);
+    final ThreadGroup evictorThreadGroup =
+        LoggingThreadGroup.createThreadGroup(getEvictorThreadGroupName(), logger);
-        Thread t = new Thread(evictorThreadGroup, command, getEvictorThreadName()
-            + next++);
+        Thread t = new Thread(evictorThreadGroup, command, getEvictorThreadName() + next++);
-      this.poolQueue = new OverflowQueueWithDMStats(getGemFireCache().getCachePerfStats().getEvictionQueueStatHelper());
-      this.evictorThreadPool = new ThreadPoolExecutor(MAX_EVICTOR_THREADS, MAX_EVICTOR_THREADS,
-          15, TimeUnit.SECONDS, this.poolQueue, evictorThreadFactory);
+      this.poolQueue = new OverflowQueueWithDMStats(
+          getGemFireCache().getCachePerfStats().getEvictionQueueStatHelper());
+      this.evictorThreadPool = new ThreadPoolExecutor(MAX_EVICTOR_THREADS, MAX_EVICTOR_THREADS, 15,
+          TimeUnit.SECONDS, this.poolQueue, evictorThreadFactory);
-   * The task(i.e the region on which eviction needs to be performed) is
-   * assigned to the threadpool.
+   * The task(i.e the region on which eviction needs to be performed) is assigned to the threadpool.
-    if(isRunning.get()) {
+    if (isRunning.get()) {
-   * returns the total number of tasks that are currently being executed or
-   * queued for execution
+   * returns the total number of tasks that are currently being executed or queued for execution
-    if(isRunning.get()){
-    return this.evictorThreadPool.getActiveCount()
-        + this.evictorThreadPool.getQueue().size();
+    if (isRunning.get()) {
+      return this.evictorThreadPool.getActiveCount() + this.evictorThreadPool.getQueue().size();
-  
+
-    float numEntriesInVm = 0 ;
-    for(LocalRegion lr : allRegionList){
-      if(lr instanceof BucketRegion){
-        numEntriesInVm = numEntriesInVm + ((BucketRegion)lr).getSizeForEviction();
-      }else {
+    float numEntriesInVm = 0;
+    for (LocalRegion lr : allRegionList) {
+      if (lr instanceof BucketRegion) {
+        numEntriesInVm = numEntriesInVm + ((BucketRegion) lr).getSizeForEviction();
+      } else {
-    for(LocalRegion lr : allRegionList){
+    for (LocalRegion lr : allRegionList) {
-      if(lr instanceof BucketRegion){
-        regionEntryCnt = ((BucketRegion)lr).getSizeForEviction();
-      }else {
+      if (lr instanceof BucketRegion) {
+        regionEntryCnt = ((BucketRegion) lr).getSizeForEviction();
+      } else {
-      float percentage = (regionEntryCnt/numEntriesInVm);
-      long bytesToEvictPerTask = (long)(getTotalBytesToEvict() * percentage);
-      regionsForSingleTask.add(lr);      
+      float percentage = (regionEntryCnt / numEntriesInVm);
+      long bytesToEvictPerTask = (long) (getTotalBytesToEvict() * percentage);
+      regionsForSingleTask.add(lr);
-        submitRegionEvictionTask(new RegionEvictorTask(regionsForSingleTask, this,bytesToEvictPerTask));
-      }else {
+        submitRegionEvictionTask(
+            new RegionEvictorTask(regionsForSingleTask, this, bytesToEvictPerTask));
+      } else {
-      }       
+      }
-      Iterator iterator=evictorTaskSet.iterator();
-      while(iterator.hasNext())
-      {
-        RegionEvictorTask regionEvictorTask=(RegionEvictorTask)iterator.next();
+      Iterator iterator = evictorTaskSet.iterator();
+      while (iterator.hasNext()) {
+        RegionEvictorTask regionEvictorTask = (RegionEvictorTask) iterator.next();
-      evictorTaskSet.add(new RegionEvictorTask(regionsForSingleTask, this,bytesToEvictPerTask));
+      evictorTaskSet.add(new RegionEvictorTask(regionsForSingleTask, this, bytesToEvictPerTask));
-    //Add leftover regions to last task 
+    // Add leftover regions to last task
-    
-    Iterator iterator=evictorTaskSet.iterator();
-    while(iterator.hasNext())
-    {
-      RegionEvictorTask regionEvictorTask=(RegionEvictorTask)iterator.next();
+
+    Iterator iterator = evictorTaskSet.iterator();
+    while (iterator.hasNext()) {
+      RegionEvictorTask regionEvictorTask = (RegionEvictorTask) iterator.next();
-  
+
-  // garbage collection is run, it's difficult to determine when to stop 
-  // evicting.  So, an initial calculation is done to determine the number of
+  // garbage collection is run, it's difficult to determine when to stop
+  // evicting. So, an initial calculation is done to determine the number of
-  // eviction threshold.  This number is stored in 'numFastLoops' and we
-  // quickly loop through this number performing evictions.  We then continue
+  // eviction threshold. This number is stored in 'numFastLoops' and we
+  // quickly loop through this number performing evictions. We then continue
-  // eviction event with an updated "number of bytes used".  If we get another
+  // eviction event with an updated "number of bytes used". If we get another
+
-    
+
-    if(this.isRunning.get() && event.isLocal()) {
+    if (this.isRunning.get() && event.isLocal()) {
-        
+
-            logWriter.fine("Updating eviction in response to memory event: " + event + ". previousBytesUsed=" + previousBytesUsed);
+            logWriter.fine("Updating eviction in response to memory event: " + event
+                + ". previousBytesUsed=" + previousBytesUsed);
-            numFastLoops = (int) ((event.getBytesUsed() - event.getThresholds().getEvictionThresholdClearBytes()
-                + getTotalBytesToEvict()) / getTotalBytesToEvict());
+            numFastLoops = (int) ((event.getBytesUsed()
+                - event.getThresholds().getEvictionThresholdClearBytes() + getTotalBytesToEvict())
+                / getTotalBytesToEvict());
-          
+
-        
+
-        
+
-        numFastLoops = (int) ((event.getBytesUsed() - event.getThresholds().getEvictionThresholdClearBytes()
-            + getTotalBytesToEvict()) / getTotalBytesToEvict());
+        numFastLoops =
+            (int) ((event.getBytesUsed() - event.getThresholds().getEvictionThresholdClearBytes()
+                + getTotalBytesToEvict()) / getTotalBytesToEvict());
-        
+
-  
+
-                    logWriter.fine("Eviction loop delay time calculated to be " + delayTime + " milliseconds. Fast Loops="
-                        + numFastLoops + ", Loop #=" + numEvictionLoopsCompleted+1);
+                    logWriter.fine("Eviction loop delay time calculated to be " + delayTime
+                        + " milliseconds. Fast Loops=" + numFastLoops + ", Loop #="
+                        + numEvictionLoopsCompleted + 1);
-                
+
-        
+
-          
+
-      delayTime = 3000;  // Way below the threshold
+      delayTime = 3000; // Way below the threshold
-    
-    return delayTime;  
+
+    return delayTime;
-  
+
-  
+
-  
-  public ArrayList testOnlyGetSizeOfTasks()
-  {
-    if(isRunning.get())
+
+  public ArrayList testOnlyGetSizeOfTasks() {
+    if (isRunning.get())
-  
+
-  
+
-  
+
-  
+

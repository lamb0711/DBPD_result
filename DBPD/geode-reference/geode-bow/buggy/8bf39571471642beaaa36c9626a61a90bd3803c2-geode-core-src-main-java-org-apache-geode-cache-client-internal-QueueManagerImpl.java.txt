Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Manages Client Queues. Responsible for creating callback connections and
- * satisfying redundancy requirements.
+ * Manages Client Queues. Responsible for creating callback connections and satisfying redundancy
+ * requirements.
-//  private static final long SERVER_LOCATION_TIMEOUT = Long.getLong(
-//      "gemfire.QueueManagerImpl.SERVER_LOCATION_TIMEOUT", 120000).longValue();
+  // private static final long SERVER_LOCATION_TIMEOUT = Long.getLong(
+  // "gemfire.QueueManagerImpl.SERVER_LOCATION_TIMEOUT", 120000).longValue();
-  
+
-  public QueueManagerImpl(
-      InternalPool pool, 
-      EndpointManager endpointManager,
-      ConnectionSource source, 
-      ConnectionFactory factory,
-      int queueRedundancyLevel, 
-      long redundancyRetryInterval, 
-      InternalLogWriter securityLogger,
+  public QueueManagerImpl(InternalPool pool, EndpointManager endpointManager,
+      ConnectionSource source, ConnectionFactory factory, int queueRedundancyLevel,
+      long redundancyRetryInterval, InternalLogWriter securityLogger,
-    
-    
+
+
-    
+
-    QueueConnectionImpl primary = (QueueConnectionImpl)
-      queueConnections.getPrimary();
+    QueueConnectionImpl primary = (QueueConnectionImpl) queueConnections.getPrimary();
-        result = ((CacheClientUpdater)cu).isAlive();
+        result = ((CacheClientUpdater) cu).isAlive();
-  
+
-      return queueConnections;
+    return queueConnections;
-  
+
-        while (snapshot.getPrimary() == null
-            && !snapshot.primaryDiscoveryFailed() && !shuttingDown && pool.getPoolOrCacheCancelInProgress()==null) {
+        while (snapshot.getPrimary() == null && !snapshot.primaryDiscoveryFailed() && !shuttingDown
+            && pool.getPoolOrCacheCancelInProgress() == null) {
-    
+
-      GemFireException exception  = snapshot.getPrimaryDiscoveryException();
-      if(exception == null || exception instanceof NoSubscriptionServersAvailableException) {
+      GemFireException exception = snapshot.getPrimaryDiscoveryException();
+      if (exception == null || exception instanceof NoSubscriptionServersAvailableException) {
-      }
-      else { 
+      } else {
-        if(!recoveryThread.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_TIMEOUT_WAITING_FOR_RECOVERY_THREAD_TO_COMPLETE));
+        if (!recoveryThread.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.QueueManagerImpl_TIMEOUT_WAITING_FOR_RECOVERY_THREAD_TO_COMPLETE));
-    
-    QueueConnectionImpl primary = (QueueConnectionImpl) queueConnections
-        .getPrimary();
-    if(logger.isDebugEnabled()) {
+
+    QueueConnectionImpl primary = (QueueConnectionImpl) queueConnections.getPrimary();
+    if (logger.isDebugEnabled()) {
-        if(logger.isDebugEnabled()) {
+        if (logger.isDebugEnabled()) {
-          LocalizedStrings.QueueManagerImpl_ERROR_CLOSING_PRIMARY_CONNECTION_TO_0,
-          primary.getEndpoint()), e);
+            LocalizedStrings.QueueManagerImpl_ERROR_CLOSING_PRIMARY_CONNECTION_TO_0,
+            primary.getEndpoint()), e);
-          if(logger.isDebugEnabled()) {
+          if (logger.isDebugEnabled()) {
-  
-  
+
+
-    for(int i = 0; i < backups.size(); i++) {
+    for (int i = 0; i < backups.size(); i++) {
-//    TODO - use yet another Timer or the like for these tasks? We know
-      //we don't want them in the recoveryThread, because the ThreadIdToSequenceIdExpiryTask
-      //will wait for primary recovery.
+      // TODO - use yet another Timer or the like for these tasks? We know
+      // we don't want them in the recoveryThread, because the ThreadIdToSequenceIdExpiryTask
+      // will wait for primary recovery.
-      //When a server is removed from the blacklist, try again
-      //to establish redundancy (if we need to)
+      // When a server is removed from the blacklist, try again
+      // to establish redundancy (if we need to)
-  
-  
+
+
-    synchronized(lock) {
+    synchronized (lock) {
-      } catch(NoSubscriptionServersAvailableException e) {
+      } catch (NoSubscriptionServersAvailableException e) {
-      if(primary.sendClientReady()) {
+      if (primary.sendClientReady()) {
-            LocalizedStrings.QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0,
-            primary));
-          ReadyForEventsOp.execute(pool, primary); 
-        } catch(Exception e) {
-          if(logger.isDebugEnabled()) {
+              LocalizedStrings.QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0, primary));
+          ReadyForEventsOp.execute(pool, primary);
+        } catch (Exception e) {
+          if (logger.isDebugEnabled()) {
-  
+
-        LocalizedStrings.QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0, primary));
+          LocalizedStrings.QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0, primary));
-    } catch(Exception e) {
-      if(logger.isDebugEnabled()) {
+    } catch (Exception e) {
+      if (logger.isDebugEnabled()) {
-  
+
-    //We must be synchronized while checking to see if we have a queue connection for the endpoint,
-    //because when we need to prevent a race between adding a queue connection to the map
-    //and the endpoint for that connection crashing.
+    // We must be synchronized while checking to see if we have a queue connection for the endpoint,
+    // because when we need to prevent a race between adding a queue connection to the map
+    // and the endpoint for that connection crashing.
-      logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_ENDPOINT_CRASHED_SCHEDULING_RECOVERY, 
-                        new Object[]{deadConnection.getUpdater() != null ?(deadConnection.getUpdater().isPrimary()? "Primary" : "Redundant") : "Queue", endpoint}));
+      logger
+          .info(LocalizedMessage.create(
+              LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_ENDPOINT_CRASHED_SCHEDULING_RECOVERY,
+              new Object[] {deadConnection.getUpdater() != null
+                  ? (deadConnection.getUpdater().isPrimary() ? "Primary" : "Redundant") : "Queue",
+                  endpoint}));
+
-   * This method checks whether queue connection exist on this endpoint or not.
-   *  if its there then it just destroys connection as clientUpdate thread is not there to read that connection.
+   * This method checks whether queue connection exist on this endpoint or not. if its there then it
+   * just destroys connection as clientUpdate thread is not there to read that connection.
-  public void checkEndpoint(ClientUpdater ccu, Endpoint endpoint)
-  {
+  public void checkEndpoint(ClientUpdater ccu, Endpoint endpoint) {
-    
+
-      if(shuttingDown)
+      if (shuttingDown)
-      //if same client updater then only remove as we don't know whether it has created new updater/connection on same endpoint or not..
+      // if same client updater then only remove as we don't know whether it has created new
+      // updater/connection on same endpoint or not..
-        }  catch(Exception e) {
-          logger.warn("Error destroying client to server connection to {}", deadConnection.getEndpoint(), e);
+        } catch (Exception e) {
+          logger.warn("Error destroying client to server connection to {}",
+              deadConnection.getEndpoint(), e);
-      }      
-    }    
-    
-    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_CACHE_CLIENT_UPDATER_FOR_ON_ENDPOINT_EXITING_SCHEDULING_RECOVERY,
-                new Object[]{(deadConnection != null && deadConnection.getUpdater() != null)?(deadConnection.getUpdater().isPrimary()? "Primary" : "Redundant"): "Queue", endpoint}));
-    scheduleRedundancySatisfierIfNeeded(0);//one more chance
+      }
+    }
+
+    logger
+        .info(
+            LocalizedMessage.create(
+                LocalizedStrings.QueueManagerImpl_CACHE_CLIENT_UPDATER_FOR_ON_ENDPOINT_EXITING_SCHEDULING_RECOVERY,
+                new Object[] {(deadConnection != null && deadConnection.getUpdater() != null)
+                    ? (deadConnection.getUpdater().isPrimary() ? "Primary" : "Redundant") : "Queue",
+                    endpoint}));
+    scheduleRedundancySatisfierIfNeeded(0);// one more chance
-    
+
-        LocalizedStrings.QueueManagerImpl_COULD_NOT_CREATE_A_QUEUE_NO_QUEUE_SERVERS_AVAILABLE);
+          LocalizedStrings.QueueManagerImpl_COULD_NOT_CREATE_A_QUEUE_NO_QUEUE_SERVERS_AVAILABLE);
-    SortedMap/* <ServerQueueStatus,Connection> */oldQueueServers = new TreeMap(
-        QSIZE_COMPARATOR);
+    SortedMap/* <ServerQueueStatus,Connection> */ oldQueueServers = new TreeMap(QSIZE_COMPARATOR);
-      } catch(GemFireSecurityException e) {
+      } catch (GemFireSecurityException e) {
-      newPrimary = (Connection) oldQueueServers.remove(oldQueueServers
-          .lastKey());
+      newPrimary = (Connection) oldQueueServers.remove(oldQueueServers.lastKey());
-    
+
-      QueueConnectionImpl queueConnection = initializeQueueConnection(
-          connection, false, null);
+      QueueConnectionImpl queueConnection = initializeQueueConnection(connection, false, null);
-        if(!addToConnectionList(primaryQueue, true)) {
+        if (!addToConnectionList(primaryQueue, true)) {
-        logger.debug("SubscriptionManager - Some initial connections failed. Trying to create redundant queues");
+        logger.debug(
+            "SubscriptionManager - Some initial connections failed. Trying to create redundant queues");
-        logger.debug("SubscriptionManager - Intial primary creation failed. Trying to create a new primary");
+        logger.debug(
+            "SubscriptionManager - Intial primary creation failed. Trying to create a new primary");
-      while(primaryQueue == null) { 
+      while (primaryQueue == null) {
-        if(primaryQueue == null) {
-          //couldn't find a server to make primary
+        if (primaryQueue == null) {
+          // couldn't find a server to make primary
-        if(!addToConnectionList(primaryQueue, true)) {
+        if (!addToConnectionList(primaryQueue, true)) {
-        logger.debug("SubscriptionManager - Unable to create a new primary queue, using one of the redundant queues");
+        logger.debug(
+            "SubscriptionManager - Unable to create a new primary queue, using one of the redundant queues");
-      while(primaryQueue == null) {
+      while (primaryQueue == null) {
-        if(primaryQueue == null) {
-          //no backup servers available
+        if (primaryQueue == null) {
+          // no backup servers available
-        if(!addToConnectionList(primaryQueue, true)) {
-          synchronized(lock) {
-            //make sure we don't retry this same connection.
+        if (!addToConnectionList(primaryQueue, true)) {
+          synchronized (lock) {
+            // make sure we don't retry this same connection.
-        queueConnections = queueConnections.setPrimaryDiscoveryFailed(
-            new NoSubscriptionServersAvailableException(LocalizedStrings.QueueManagerImpl_COULD_NOT_INITIALIZE_A_PRIMARY_QUEUE_ON_STARTUP_NO_QUEUE_SERVERS_AVAILABLE.toLocalizedString()));
+        queueConnections =
+            queueConnections.setPrimaryDiscoveryFailed(new NoSubscriptionServersAvailableException(
+                LocalizedStrings.QueueManagerImpl_COULD_NOT_INITIALIZE_A_PRIMARY_QUEUE_ON_STARTUP_NO_QUEUE_SERVERS_AVAILABLE
+                    .toLocalizedString()));
-    }
-    else {
+    } else {
-          LocalizedStrings.QueueManagerImpl_UNABLE_TO_INITIALIZE_ENOUGH_REDUNDANT_QUEUES_ON_STARTUP_THE_REDUNDANCY_COUNT_IS_CURRENTLY_0,  
+          LocalizedStrings.QueueManagerImpl_UNABLE_TO_INITIALIZE_ENOUGH_REDUNDANT_QUEUES_ON_STARTUP_THE_REDUNDANCY_COUNT_IS_CURRENTLY_0,
-    if(cache != null) {
+    if (cache != null) {
-    //Primary queue was found, alert the affected cqs if necessary
+      // Primary queue was found, alert the affected cqs if necessary
-    //No primary queue was found, alert the affected cqs if necessary
+    // No primary queue was found, alert the affected cqs if necessary
-    if(cache != null) {
+    if (cache != null) {
-  
+
-    if(pool.getPoolOrCacheCancelInProgress() != null) {
+    if (pool.getPoolOrCacheCancelInProgress() != null) {
-    while (pool.getPoolOrCacheCancelInProgress()==null && ((additionalBackups = redundancyLevel - getCurrentRedundancy()) > 0
-        || redundancyLevel == -1))  {
+    while (pool.getPoolOrCacheCancelInProgress() == null
+        && ((additionalBackups = redundancyLevel - getCurrentRedundancy()) > 0
+            || redundancyLevel == -1)) {
-      
-      if(redundancyLevel != -1 && printRecoveringRedundant) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_REDUNDANT_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));
+
+      if (redundancyLevel != -1 && printRecoveringRedundant) {
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_REDUNDANT_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));
-       }
-      
-      List servers = findQueueServers(excludedServers, redundancyLevel == -1 ? -1 : additionalBackups, false, 
-                            (redundancyLevel == -1 ? false : printRedundancyNotSatisfiedError),
-                                    LocalizedStrings.QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_REDUNDANT_CLIENT_QUEUE);
+      }
+
+      List servers = findQueueServers(excludedServers,
+          redundancyLevel == -1 ? -1 : additionalBackups, false,
+          (redundancyLevel == -1 ? false : printRedundancyNotSatisfiedError),
+          LocalizedStrings.QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_REDUNDANT_CLIENT_QUEUE);
-          
-          if(printRedundancyNotSatisfiedError) {
-          logger.info(LocalizedMessage.create(
-            LocalizedStrings.QueueManagerImpl_REDUNDANCY_LEVEL_0_IS_NOT_SATISFIED_BUT_THERE_ARE_NO_MORE_SERVERS_AVAILABLE_REDUNDANCY_IS_CURRENTLY_1,
-            new Object[] { Integer.valueOf(redundancyLevel), Integer.valueOf(getCurrentRedundancy())}));
-          }          
+
+          if (printRedundancyNotSatisfiedError) {
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.QueueManagerImpl_REDUNDANCY_LEVEL_0_IS_NOT_SATISFIED_BUT_THERE_ARE_NO_MORE_SERVERS_AVAILABLE_REDUNDANCY_IS_CURRENTLY_1,
+                new Object[] {Integer.valueOf(redundancyLevel),
+                    Integer.valueOf(getCurrentRedundancy())}));
+          }
-        printRedundancyNotSatisfiedError = false;//printed above
+        printRedundancyNotSatisfiedError = false;// printed above
-        } catch(GemFireSecurityException e) {
+        } catch (GemFireSecurityException e) {
-        QueueConnectionImpl queueConnection = initializeQueueConnection(
-            connection, false, null);
+        QueueConnectionImpl queueConnection = initializeQueueConnection(connection, false, null);
-              //  we lost our queue at some point. We Need to recover
+              // we lost our queue at some point. We Need to recover
-              //redundancy satisfied
+              // redundancy satisfied
-                logger.debug("SubscriptionManager redundancy satisfier - created a queue on server {}", queueConnection.getEndpoint());
+                logger.debug(
+                    "SubscriptionManager redundancy satisfier - created a queue on server {}",
+                    queueConnection.getEndpoint());
-              if(recoverInterest) {
+              if (recoverInterest) {
-          } 
+          }
-      } 
-    }    
+      }
+    }
-      if(haveSentClientReady) {
+      if (haveSentClientReady) {
-      if(updater == null) {
+      if (updater == null) {
-      if(pool.getPoolOrCacheCancelInProgress() == null && logger.isDebugEnabled()) {
+      if (pool.getPoolOrCacheCancelInProgress() == null && logger.isDebugEnabled()) {
+
-    while (primary == null && pool.getPoolOrCacheCancelInProgress()==null) {
-      List servers = findQueueServers(excludedServers, 1, false, 
-                                       printPrimaryNotFoundError,
-                                       LocalizedStrings.QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE);
-      printPrimaryNotFoundError = false; //printed above
+    while (primary == null && pool.getPoolOrCacheCancelInProgress() == null) {
+      List servers = findQueueServers(excludedServers, 1, false, printPrimaryNotFoundError,
+          LocalizedStrings.QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE);
+      printPrimaryNotFoundError = false; // printed above
-        connection = factory
-          .createClientToServerConnection((ServerLocation) servers.get(0), true);
+        connection = factory.createClientToServerConnection((ServerLocation) servers.get(0), true);
-      } catch(Exception e) {
-        if(logger.isDebugEnabled()) {
-          logger.debug("SubscriptionManagerImpl - error creating a connection to server {}", servers.get(0));
+      } catch (Exception e) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("SubscriptionManagerImpl - error creating a connection to server {}",
+              servers.get(0));
-    
-    if(primary != null && sentClientReady && primary.sendClientReady()) {
+
+    if (primary != null && sentClientReady && primary.sendClientReady()) {
-  private List findQueueServers(Set excludedServers, int count,
-      boolean findDurable, boolean printErrorMessage, StringId msgId) {
+  private List findQueueServers(Set excludedServers, int count, boolean findDurable,
+      boolean printErrorMessage, StringId msgId) {
-      if(pool.getPoolOrCacheCancelInProgress()!=null) {
+      if (pool.getPoolOrCacheCancelInProgress() != null) {
-    } catch(GemFireSecurityException e) {
-      //propagate the security exception immediately.
+    } catch (GemFireSecurityException e) {
+      // propagate the security exception immediately.
-      /*logger
-          .warning(
-              LocalizedStrings.QueueManagerImpl_COULD_NOT_RETRIEVE_LIST_OF_SERVERS_FOR_SUBSCRIPTION_0,
-              new Object[] { e.getMessage() });*/
+      /*
+       * logger .warning(
+       * LocalizedStrings.QueueManagerImpl_COULD_NOT_RETRIEVE_LIST_OF_SERVERS_FOR_SUBSCRIPTION_0,
+       * new Object[] { e.getMessage() });
+       */
-    
-    if(printErrorMessage)
-    {
-      if(servers == null || servers.isEmpty())
-      {
-        logger.error(LocalizedMessage.create(msgId, 
-          new Object[]{ (excludedServers!= null?excludedServers.size(): 0), (ex != null?ex.getMessage(): "no exception")}));
+
+    if (printErrorMessage) {
+      if (servers == null || servers.isEmpty()) {
+        logger.error(LocalizedMessage.create(msgId,
+            new Object[] {(excludedServers != null ? excludedServers.size() : 0),
+                (ex != null ? ex.getMessage() : "no exception")}));
-   * Find a new primary, adding any failed servers we encounter to the excluded
-   * servers list
+   * Find a new primary, adding any failed servers we encounter to the excluded servers list
-   * First we try to make a backup server the primary, but if run out of backup
-   * servers we will try to find a new server.
+   * First we try to make a backup server the primary, but if run out of backup servers we will try
+   * to find a new server.
-    if(pool.getPoolOrCacheCancelInProgress() != null) {
+    if (pool.getPoolOrCacheCancelInProgress() != null) {
-      logger.debug("SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover");
+      logger.debug(
+          "SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover");
-    if(printRecoveringPrimary) {
-     logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));
-     printRecoveringPrimary = false;
+    if (printRecoveringPrimary) {
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));
+      printRecoveringPrimary = false;
-    
+
-    while(newPrimary == null && pool.getPoolOrCacheCancelInProgress()==null) {
+    while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {
-      //Hitesh now lets say that server crashed
-      if(newPrimary == null) {
-        //could not find a backup to promote
+      // Hitesh now lets say that server crashed
+      if (newPrimary == null) {
+        // could not find a backup to promote
-      if(!addToConnectionList(newPrimary, true)) {
-        synchronized(lock) {
-          //make sure we don't retry the same backup server
+      if (!addToConnectionList(newPrimary, true)) {
+        synchronized (lock) {
+          // make sure we don't retry the same backup server
-    
-    if(newPrimary != null) {
+
+    if (newPrimary != null) {
-        logger.debug("SubscriptionManager redundancy satisfier - Switched backup server to primary: {}", newPrimary.getEndpoint());
+        logger.debug(
+            "SubscriptionManager redundancy satisfier - Switched backup server to primary: {}",
+            newPrimary.getEndpoint());
-     
-      //new primary from back up server was found, alert affected cqs if necessary
+
+      // new primary from back up server was found, alert affected cqs if necessary
-      printRecoveringPrimary =true;
+      printRecoveringPrimary = true;
-    while(newPrimary == null) {
+    while (newPrimary == null) {
-      if(newPrimary == null) {
-        //could not find a new primary to create
+      if (newPrimary == null) {
+        // could not find a new primary to create
-      if(!addToConnectionList(newPrimary, true)) {
+      if (!addToConnectionList(newPrimary, true)) {
-      
+
-          logger.debug("SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}", newPrimary.getEndpoint());
+          logger.debug(
+              "SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}",
+              newPrimary.getEndpoint());
-        if(!recoverInterest(newPrimary, true)) {
+        if (!recoverInterest(newPrimary, true)) {
-        //New primary queue was found from a non backup, alert the affected cqs
+        // New primary queue was found from a non backup, alert the affected cqs
-    //No primary queue was found, alert the affected cqs
+    // No primary queue was found, alert the affected cqs
-  private QueueConnectionImpl initializeQueueConnection(Connection connection,
-      boolean isPrimary, ClientUpdater failedUpdater) {
+  private QueueConnectionImpl initializeQueueConnection(Connection connection, boolean isPrimary,
+      ClientUpdater failedUpdater) {
-      ClientUpdater updater = factory.createServerToClientConnection(connection
-          .getEndpoint(), this, isPrimary, failedUpdater);
+      ClientUpdater updater = factory.createServerToClientConnection(connection.getEndpoint(), this,
+          isPrimary, failedUpdater);
-        logger.debug("error creating subscription connection to server {}", connection.getEndpoint(), e);
+        logger.debug("error creating subscription connection to server {}",
+            connection.getEndpoint(), e);
-  //need flag whether primary is created from backup
-  // for backuup queue lets assume before we add connection, endpoint crashed, now we put in connection but CCU may died as endpoint closed....
-  // so before putting connection need to see if something(crash) happen we should be able to recover from it
+
+  // need flag whether primary is created from backup
+  // for backuup queue lets assume before we add connection, endpoint crashed, now we put in
+  // connection but CCU may died as endpoint closed....
+  // so before putting connection need to see if something(crash) happen we should be able to
+  // recover from it
-    synchronized(lock) {
+    synchronized (lock) {
-      if(cu == null || (! cu.isAlive() ) || (!cu.isProcessing()) )
-        return false;//don't add
-      //now still CCU can died but then it will execute Checkendpoint with lock it will remove connection connection and it will reschedule it.
-      if(connection.getEndpoint().isClosed() || shuttingDown || pool.getPoolOrCacheCancelInProgress()!=null) {
+      if (cu == null || (!cu.isAlive()) || (!cu.isProcessing()))
+        return false;// don't add
+      // now still CCU can died but then it will execute Checkendpoint with lock it will remove
+      // connection connection and it will reschedule it.
+      if (connection.getEndpoint().isClosed() || shuttingDown
+          || pool.getPoolOrCacheCancelInProgress() != null) {
-        if(isPrimary) {
+        if (isPrimary) {
-        } else {          
+        } else {
-    
-    if(isBadConnection) {
-      if(logger.isDebugEnabled()) {
-        logger.debug("Endpoint {} crashed while creating a connection. The connection will be destroyed", connection.getEndpoint());
+
+    if (isBadConnection) {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Endpoint {} crashed while creating a connection. The connection will be destroyed",
+            connection.getEndpoint());
-      }  catch(Exception e) {
-        logger.warn("Error destroying client to server connection to {}", connection.getEndpoint(), e);
+      } catch (Exception e) {
+        logger.warn("Error destroying client to server connection to {}", connection.getEndpoint(),
+            e);
-    
+
-    if(shuttingDown) {
+    if (shuttingDown) {
-    
+
-      if(shuttingDown) {
+      if (shuttingDown) {
-      if (queueConnections.getPrimary() == null
-          || getCurrentRedundancy() < redundancyLevel || redundancyLevel == -1
-          || queueConnections.primaryDiscoveryFailed()) {
+      if (queueConnections.getPrimary() == null || getCurrentRedundancy() < redundancyLevel
+          || redundancyLevel == -1 || queueConnections.primaryDiscoveryFailed()) {
-        ScheduledFuture future = recoveryThread.schedule(redundancySatisfierTask,
-            delay, TimeUnit.MILLISECONDS);
-        redundancySatisfierTask.setFuture(future);
-        } catch(RejectedExecutionException e) {
-          //ignore, the timer has been cancelled, which means we're shutting down.
+          ScheduledFuture future =
+              recoveryThread.schedule(redundancySatisfierTask, delay, TimeUnit.MILLISECONDS);
+          redundancySatisfierTask.setFuture(future);
+        } catch (RejectedExecutionException e) {
+          // ignore, the timer has been cancelled, which means we're shutting down.
-  
+
-    
-    if(pool.getPoolOrCacheCancelInProgress() != null) {
+
+    if (pool.getPoolOrCacheCancelInProgress() != null) {
-    
+
-    } 
-    catch (CancelException ignore) {
+    } catch (CancelException ignore) {
-        LocalizedStrings.QueueManagerImpl_QUEUEMANAGERIMPL_FAILED_TO_RECOVER_INTEREST_TO_SERVER_0,
-        newConnection.getServer()), t);
+          LocalizedStrings.QueueManagerImpl_QUEUEMANAGERIMPL_FAILED_TO_RECOVER_INTEREST_TO_SERVER_0,
+          newConnection.getServer()), t);
-    .getRegionToInterestsMap(interestType, isDurable, !receiveValues).values().iterator();
+        .getRegionToInterestsMap(interestType, isDurable, !receiveValues).values().iterator();
-      recoverSingleRegion(e.getRegion(), e.getInterests(), interestType,
-          recoveredConnection, isDurable, receiveValues, isFirstNewConnection);
+      recoverSingleRegion(e.getRegion(), e.getInterests(), interestType, recoveredConnection,
+          isDurable, receiveValues, isFirstNewConnection);
-    while(i.hasNext()) {
-      Map.Entry e = (Map.Entry)i.next();
-      ClientCQ cqi = (ClientCQ)e.getKey();
+    while (i.hasNext()) {
+      Map.Entry e = (Map.Entry) i.next();
+      ClientCQ cqi = (ClientCQ) e.getKey();
-        UserAttributes.userAttributes.set(((DefaultQueryService)this.pool
-            .getQueryService()).getUserAttributes(name));
+        UserAttributes.userAttributes
+            .set(((DefaultQueryService) this.pool.getQueryService()).getUserAttributes(name));
-        if (((CqStateImpl)cqi.getState()).getState() != CqStateImpl.INIT) {
+        if (((CqStateImpl) cqi.getState()).getState() != CqStateImpl.INIT) {
-  
+
-      Connection recoveredConnection, boolean isDurable,
-      boolean receiveValues, boolean isFirstNewConnection) {
+      Connection recoveredConnection, boolean isDurable, boolean receiveValues,
+      boolean isFirstNewConnection) {
-      logger.debug("{}.recoverSingleRegion starting kind={} region={}: {}", this, InterestType.getString(interestType), r.getFullPath(), keys);
+      logger.debug("{}.recoverSingleRegion starting kind={} region={}: {}", this,
+          InterestType.getString(interestType), r.getFullPath(), keys);
-    
+
-      
+
-    	// Gester: we only consolidate the key into list for InterestType.KEY
-        LinkedList keyList = (LinkedList)policyMap.get(pol);
+        // Gester: we only consolidate the key into list for InterestType.KEY
+        LinkedList keyList = (LinkedList) policyMap.get(pol);
-          
+
-    	recoverSingleKey(r, key, pol, interestType, recoveredConnection,
-    	    isDurable, receiveValues, isFirstNewConnection);
+        recoverSingleKey(r, key, pol, interestType, recoveredConnection, isDurable, receiveValues,
+            isFirstNewConnection);
-    
+
-      LinkedList keyList = (LinkedList)me.getValue();
-      InterestResultPolicy pol = (InterestResultPolicy)me.getKey();
-      recoverSingleKey(r, keyList, pol, interestType, recoveredConnection,
-          isDurable, receiveValues, isFirstNewConnection);
+      LinkedList keyList = (LinkedList) me.getValue();
+      InterestResultPolicy pol = (InterestResultPolicy) me.getKey();
+      recoverSingleKey(r, keyList, pol, interestType, recoveredConnection, isDurable, receiveValues,
+          isFirstNewConnection);
-  private void recoverSingleKey(LocalRegion r, Object keys,
-      InterestResultPolicy policy, int interestType, Connection recoveredConnection,
-      boolean isDurable, boolean receiveValues, boolean isFirstNewConnection) {
+  private void recoverSingleKey(LocalRegion r, Object keys, InterestResultPolicy policy,
+      int interestType, Connection recoveredConnection, boolean isDurable, boolean receiveValues,
+      boolean isFirstNewConnection) {
-          logger.debug("{}.recoverSingleRegion :Endpoint recovered is primary so clearing the keys of interest starting kind={} region={}: {}", this, InterestType.getString(interestType), r.getFullPath(), keys);
+          logger.debug(
+              "{}.recoverSingleRegion :Endpoint recovered is primary so clearing the keys of interest starting kind={} region={}: {}",
+              this, InterestType.getString(interestType), r.getFullPath(), keys);
-      serverKeys = r.getServerProxy().registerInterestOn(recoveredConnection,
-          keys, interestType, policy, isDurable, !receiveValues,
-          r.getAttributes().getDataPolicy().ordinal);
-      // Restore keys based on server's response
-      if (isFirstNewConnection) {
-        // only if this recoveredEP becomes primaryEndpoint
-        r.refreshEntriesFromServerKeys(recoveredConnection, serverKeys, policy);
-      }
+        serverKeys = r.getServerProxy().registerInterestOn(recoveredConnection, keys, interestType,
+            policy, isDurable, !receiveValues, r.getAttributes().getDataPolicy().ordinal);
+        // Restore keys based on server's response
+        if (isFirstNewConnection) {
+          // only if this recoveredEP becomes primaryEndpoint
+          r.refreshEntriesFromServerKeys(recoveredConnection, serverKeys, policy);
+        }
-          serverKeys = r.getServerProxy().registerInterestOn(recoveredConnection,
-              keys, interestType, InterestResultPolicy.NONE, isDurable, !receiveValues,
+          serverKeys = r.getServerProxy().registerInterestOn(recoveredConnection, keys,
+              interestType, InterestResultPolicy.NONE, isDurable, !receiveValues,
-          serverKeys = r.getServerProxy().registerInterestOn(recoveredConnection,
-              keys, interestType, policy, isDurable, !receiveValues,
-              r.getAttributes().getDataPolicy().ordinal);
+          serverKeys =
+              r.getServerProxy().registerInterestOn(recoveredConnection, keys, interestType, policy,
+                  isDurable, !receiveValues, r.getAttributes().getDataPolicy().ordinal);
-  private void recoverInterestList(final Connection recoveredConnection,
-      boolean durable, boolean receiveValues, boolean isFirstNewConnection) {
-    recoverSingleList(InterestType.KEY, recoveredConnection, durable, receiveValues, isFirstNewConnection);
-    recoverSingleList(InterestType.REGULAR_EXPRESSION, recoveredConnection, durable, receiveValues, isFirstNewConnection);
-    recoverSingleList(InterestType.FILTER_CLASS, recoveredConnection, durable, receiveValues, isFirstNewConnection);
-    recoverSingleList(InterestType.OQL_QUERY, recoveredConnection, durable, receiveValues, isFirstNewConnection);
+  private void recoverInterestList(final Connection recoveredConnection, boolean durable,
+      boolean receiveValues, boolean isFirstNewConnection) {
+    recoverSingleList(InterestType.KEY, recoveredConnection, durable, receiveValues,
+        isFirstNewConnection);
+    recoverSingleList(InterestType.REGULAR_EXPRESSION, recoveredConnection, durable, receiveValues,
+        isFirstNewConnection);
+    recoverSingleList(InterestType.FILTER_CLASS, recoveredConnection, durable, receiveValues,
+        isFirstNewConnection);
+    recoverSingleList(InterestType.OQL_QUERY, recoveredConnection, durable, receiveValues,
+        isFirstNewConnection);
-    //recoverCqs(recoveredConnection, durable);
-    //recoverSingleList(InterestType.CQ, recoveredConnection, durable,isFirstNewConnection);
+    // recoverCqs(recoveredConnection, durable);
+    // recoverSingleList(InterestType.CQ, recoveredConnection, durable,isFirstNewConnection);
-    if ( getPool().isDurableClient()) {
+    if (getPool().isDurableClient()) {
-  
+
-   * A comparator which sorts queue elements in the order of primary first
-   * redundant with smallest queue size ... redundant with largest queue size
+   * A comparator which sorts queue elements in the order of primary first redundant with smallest
+   * queue size ... redundant with largest queue size
-        int diff =  s1.getServerQueueSize() - s2.getServerQueueSize();
-        if(diff != 0) {
+        int diff = s1.getServerQueueSize() - s2.getServerQueueSize();
+        if (diff != 0) {
-   * A data structure for holding the current set of connections the
-   * queueConnections reference should be maintained by making a copy of this
-   * data structure for each change.
+   * A data structure for holding the current set of connections the queueConnections reference
+   * should be maintained by making a copy of this data structure for each change.
-   * Note the the order of the backups is significant. The first backup in the
-   * list is the first server that will be become primary after the primary
-   * fails, etc.
+   * Note the the order of the backups is significant. The first backup in the list is the first
+   * server that will be become primary after the primary fails, etc.
-   * The order of backups in this list is the reverse of the order or endpoints
-   * from the old ConnectionProxyImpl .
+   * The order of backups in this list is the reverse of the order or endpoints from the old
+   * ConnectionProxyImpl .
-    private final Map/* <Endpoint, QueueConnection> */connectionMap;
-    private final List/* <QueueConnection> */backups;
+    private final Map/* <Endpoint, QueueConnection> */ connectionMap;
+    private final List/* <QueueConnection> */ backups;
-     * The primaryDiscoveryException flag is stronger than just not having any
-     * queue connections It also means we tried all of the possible queue
-     * servers and we'ren't able to connect.
+     * The primaryDiscoveryException flag is stronger than just not having any queue connections It
+     * also means we tried all of the possible queue servers and we'ren't able to connect.
-    public ConnectionList setPrimaryDiscoveryFailed(
-        GemFireException p_discoveryException) {
+    public ConnectionList setPrimaryDiscoveryFailed(GemFireException p_discoveryException) {
-      if(discoveryException == null) {
-        discoveryException = new NoSubscriptionServersAvailableException("Primary discovery failed.");
+      if (discoveryException == null) {
+        discoveryException =
+            new NoSubscriptionServersAvailableException("Primary discovery failed.");
-    public List/* <QueueConnection> */getBackups() {
+    public List/* <QueueConnection> */ getBackups() {
-    
+
-     * Return the cache client updater from the previously
-     * failed primary
+     * Return the cache client updater from the previously failed primary
+     * 
-      if(failedPrimary != null) {
+      if (failedPrimary != null) {
-    
+
-    public Set/* <ServerLocation> */getAllLocations() {
+    public Set/* <ServerLocation> */ getAllLocations() {
-        org.apache.geode.cache.client.internal.Endpoint endpoint = (org.apache.geode.cache.client.internal.Endpoint) itr.next();
+        org.apache.geode.cache.client.internal.Endpoint endpoint =
+            (org.apache.geode.cache.client.internal.Endpoint) itr.next();
-  
+
-    if(t instanceof GemFireSecurityException) {
+    if (t instanceof GemFireSecurityException) {
-    } else { 
+    } else {
-   * Asynchronous task which tries to restablish a primary connection and
-   * satisfy redundant requirements.
+   * Asynchronous task which tries to restablish a primary connection and satisfy redundant
+   * requirements.
-   * This task should only be running in a single thread at a time. This task is
-   * the only way that new queue servers will be added, and the only way that a
-   * backup server can transistion to a primary server.
+   * This task should only be running in a single thread at a time. This task is the only way that
+   * new queue servers will be added, and the only way that a backup server can transistion to a
+   * primary server.
-          if(pool.getPoolOrCacheCancelInProgress()!=null) {
-	    /* wake up waiters so they can detect cancel */
-	    lock.notifyAll();
+          if (pool.getPoolOrCacheCancelInProgress() != null) {
+            /* wake up waiters so they can detect cancel */
+            lock.notifyAll();
-      } 
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      } 
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-          if(t instanceof GemFireSecurityException) {
-            queueConnections = queueConnections.setPrimaryDiscoveryFailed((GemFireSecurityException) t);
+          if (t instanceof GemFireSecurityException) {
+            queueConnections =
+                queueConnections.setPrimaryDiscoveryFailed((GemFireSecurityException) t);
-        if(isCancelled) {
+        if (isCancelled) {

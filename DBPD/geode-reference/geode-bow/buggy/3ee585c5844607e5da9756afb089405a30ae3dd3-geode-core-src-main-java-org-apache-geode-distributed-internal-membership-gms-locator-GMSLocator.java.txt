GEODE-3052 Restarting 2 locators together causes potential locator split brain

There were four problems that new unit tests hit:
1. when recovering a view from disk we were treating it as a definitive
(live) view.  I've moved it to a new variable in GMSLocator and set its
viewId to -1.  At the same time I set the initial GMSJoinLeave
SearchState.viewId to -100 so it will be overridden by the one returned
by the locator.  These changes allow GmsJoinLeave to know that the
potential coordinator is from a recovered view.

2. when trying to join with a recovered view GMSJoinLeave.join() was giving
up after the second ID in the view and becoming the coordinator.  It needs
to keep trying until the list is exhausted, and it shouldn't sleep between
attempts.

3. GMSLocator wasn't returning registrants for use in
findCoordinatorFromView().  This was causing it to choose itself as
the coordinator instead of using registrant sort order and choosing
a different registrant as the coordinator.

4. During concurrent startup GMSLocator didn't know when the decision
was made to become coordinator.  It is now notified of this decision
and processRequest() uses this flag to have it override anything in
the registrants set or in the recovered view.

+  private transient NetView recoveredView;
+
+  private volatile boolean isCoordinator;
+
+      } else if (localAddress != null) {
+        synchronized (this.registrants) {
+          this.registrants.add(localAddress);
+        }
+    this.recoveredView = null;
+  @Override
+  public void setIsCoordinator(boolean isCoordinator) {
+    this.isCoordinator = isCoordinator;
+  }
+        if (v == null) {
+          v = this.recoveredView;
+        }
+
+        synchronized (registrants) {
+          registrants.add(findRequest.getMemberID());
+        }
-          int viewId = v.getViewId();
-          if (viewId > findRequest.getLastViewId()) {
+
+          if (v.getViewId() > findRequest.getLastViewId()) {
-            registrants.add(findRequest.getMemberID());
+          if (isCoordinator) {
+            coord = localAddress;
+            InternalDistributedMember viewCoordinator = null;
+            if (v != null) {
+              viewCoordinator = v.getCoordinator();
+            }
+            fromView = viewCoordinator != null && !viewCoordinator.equals(localAddress);
+            if (!fromView) {
+              logger.info("This member is becoming coordinator");
+              v = null;
+            }
+          }
-          if (view != null) {
-            coordPk = (byte[]) view.getPublicKey(coord);
+          if (v != null) {
+            coordPk = (byte[]) v.getPublicKey(coord);
-          response = new FindCoordinatorResponse(coord, localAddress, fromView, view,
+          response = new FindCoordinatorResponse(coord, localAddress, fromView, v,
-      this.view = (NetView) o;
-      List<InternalDistributedMember> members = new ArrayList<>(view.getMembers());
+      recoveredView = (NetView) o;
+      recoveredView.setViewId(-1); // this is not a valid view so it shouldn't have a usable Id
+      List<InternalDistributedMember> members = new ArrayList<>(recoveredView.getMembers());
-          view.remove(member);
+          recoveredView.remove(member);
-      logger.info("Peer locator initial membership is " + view);
+      logger.info("Peer locator recovered membership is " + recoveredView);

GEODE-7421:  deploy jar by REST API/JAVA API for Management

Co-authored-by: Joris Melchior <joris.melchior@gmail.com>
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.RemoteInputStreamClient;
+import org.apache.commons.io.IOUtils;
+import org.apache.geode.management.configuration.HasFile;
+import org.apache.geode.management.internal.beans.FileUploader;
-    InternalCache cache = (InternalCache) context.getCache();
+    RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);
-    if (operation == CacheElementOperation.GET) {
-      try {
+    InternalCache cache = (InternalCache) context.getCache();
+    try {
+      if (operation == CacheElementOperation.GET) {
-      } catch (Exception e) {
-        logger.error(e.getMessage(), e);
-        context.getResultSender().lastResult(null);
-      }
-    } else {
-      try {
+      } else {
-            .lastResult(executeUpdate(context, cache, cacheElement, operation));
-      } catch (Exception e) {
-        logger.error(e.getMessage(), e);
-        context.getResultSender().lastResult(new RealizationResult()
-            .setSuccess(false)
-            .setMemberName(context.getMemberName())
-            .setMessage(e.getMessage()));
+            .lastResult(executeUpdate(context, cache, cacheElement, operation, jarStream));
+    } catch (Exception e) {
+      logger.error(e.getMessage(), e);
+      context.getResultSender().lastResult(new RealizationResult()
+          .setSuccess(false)
+          .setMemberName(context.getMemberName())
+          .setMessage(e.getMessage()));
+
-      CacheElementOperation operation) {
+      CacheElementOperation operation, RemoteInputStream jarStream) throws Exception {
+    // the the function parameter contains streamed file, staging the file first
+    if ((cacheElement instanceof HasFile) && jarStream != null) {
+      HasFile configuration = (HasFile) cacheElement;
+      Set<File> files = stageFileContent(Collections.singletonList(configuration.getFileName()),
+          Collections.singletonList(jarStream));
+      configuration.setFile(files.iterator().next());
+    }
+
+
+  public static Set<File> stageFileContent(List<String> jarNames,
+      List<RemoteInputStream> jarStreams) throws IOException {
+    Set<File> stagedJars = new HashSet<>();
+
+    try {
+      Path tempDir = FileUploader.createSecuredTempDirectory("deploy-");
+
+      for (int i = 0; i < jarNames.size(); i++) {
+        Path tempJar = Paths.get(tempDir.toString(), jarNames.get(i));
+        FileOutputStream fos = new FileOutputStream(tempJar.toString());
+
+        InputStream input = RemoteInputStreamClient.wrap(jarStreams.get(i));
+
+        IOUtils.copyLarge(input, fos);
+
+        fos.close();
+        input.close();
+
+        stagedJars.add(tempJar.toFile());
+      }
+    } catch (IOException iox) {
+      for (int i = 0; i < jarStreams.size(); i++) {
+        try {
+          jarStreams.get(i).close(true);
+        } catch (IOException ex) {
+          // Ignored
+        }
+      }
+      throw iox;
+    }
+
+    return stagedJars;
+  }
+
+  @Override
+  public boolean isHA() {
+    return false;
+  }

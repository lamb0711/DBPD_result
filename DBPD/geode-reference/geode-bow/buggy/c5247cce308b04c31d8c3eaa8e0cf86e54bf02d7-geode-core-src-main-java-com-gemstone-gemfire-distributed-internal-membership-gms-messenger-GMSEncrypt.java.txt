GEODE-1372 added unit test and some more fixes.

-import java.util.Set;
-import org.apache.logging.log4j.Logger;
-import com.gemstone.gemfire.internal.logging.LogService;
-  private static final Logger logger = LogService.getLogger();
-
-
-  protected void installView(NetView view) throws Exception {
+  protected void installView(NetView view) {
-  
-  protected void installView(NetView view, InternalDistributedMember mbr) throws Exception {
+
+  protected void installView(NetView view, InternalDistributedMember mbr) {
-   // this.view.setPublicKey(mbr, getPublicKeyBytes());
-    // TODO remove ciphers for departed members
-    //addClusterKey();
-  
-  protected byte[] getSecretBytes() {
+
+  protected byte[] getClusterSecretKey() {
-  
-  protected synchronized void addClusterKey() throws Exception {
-    this.clusterEncryptor = new ClusterEncryptor(this);
+
+  protected synchronized void initClusterSecretKey() throws Exception {
+    if(this.clusterEncryptor == null) {
+      this.clusterEncryptor = new ClusterEncryptor(this);
+    }
-  
-  protected synchronized void addClusterKey(byte[] secretBytes) throws Exception {
+
+  protected synchronized void addClusterKey(byte[] secretBytes) {
+    //TODO we are reseeting here, in case there is some race
+  
+  public byte[] decryptData(byte[] data, byte[] pkBytes) throws Exception {
+    PeerEncryptor encryptor = new PeerEncryptor(pkBytes);
+    return encryptor.decryptBytes(data);    
+  }
+  
+  protected byte[] getPublicKey(InternalDistributedMember member) {
+    try {
+      InternalDistributedMember localMbr = services.getMessenger().getMemberID();
+      if (localMbr != null && localMbr.equals(member)) {
+        return this.dhPublicKey.getEncoded();// local one
+      }
+      return getPeerEncryptor(member).peerPublicKey.getEncoded();
+    } catch (Exception e) {
+      throw new RuntimeException("Not found public key for member " + member, e);
+    }
+  }
+  
+  protected void setPublicKey(byte[] publickey, InternalDistributedMember mbr) {
+    try {
+      createPeerEncryptor(mbr, publickey);
+    }catch(Exception e) {
+      throw new RuntimeException("Unable to create peer encryptor " +  mbr, e);
+    }
+  }
-      // PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
-  protected synchronized PeerEncryptor getPeerEncryptor(InternalDistributedMember member) throws Exception{
+  protected PeerEncryptor getPeerEncryptor(InternalDistributedMember member) throws Exception {
-      result = createPeerEncryptor(member);
+      synchronized (this) {
+        result = memberToPeerEncryptor.get(member);
+        if (result == null) {
+          result = createPeerEncryptor(member, (byte[]) view.getPublicKey(member));
+        }
+      }
-  private PeerEncryptor createPeerEncryptor(InternalDistributedMember member) throws Exception {
-    byte[] peerKeyBytes = (byte[]) view.getPublicKey(member);
+  private PeerEncryptor createPeerEncryptor(InternalDistributedMember member, byte[] peerKeyBytes) throws Exception {
-    public byte [] encryptBytes(byte[] data) throws Exception {
+    public synchronized byte[] encryptBytes(byte[] data) throws Exception {
-    
-    public byte[] decryptBytes(byte[] data) throws Exception
-    {
+
+    public synchronized byte[] decryptBytes(byte[] data) throws Exception {
-  protected static Cipher getEncryptCipher(String dhSKAlgo, byte[] secretBytes) 
-      throws Exception{
-      
-      Cipher encrypt = null;
+  protected static Cipher getEncryptCipher(String dhSKAlgo, byte[] secretBytes) throws Exception {
-      int keysize = getKeySize(dhSKAlgo);
-      int blocksize = getBlockSize(dhSKAlgo);
+    Cipher encrypt = null;
-      if (keysize == -1 || blocksize == -1) {
-        //TODO how should we do here
-        /*SecretKey sKey = ka.generateSecret(dhSKAlgo);
-        encrypt = Cipher.getInstance(dhSKAlgo);
-        encrypt.init(Cipher.ENCRYPT_MODE, sKey);*/
-      }
-      else {
-        String dhAlgoStr = getDhAlgoStr(dhSKAlgo);
+    int keysize = getKeySize(dhSKAlgo);
+    int blocksize = getBlockSize(dhSKAlgo);
-        SecretKeySpec sks = new SecretKeySpec(secretBytes, 0, keysize, dhAlgoStr);
-        IvParameterSpec ivps = new IvParameterSpec(secretBytes, keysize, blocksize);
+    if (keysize == -1 || blocksize == -1) {
+      // TODO how should we do here, should we just throw runtime exception?
+      /* SecretKey sKey = ka.generateSecret(dhSKAlgo);
+       * encrypt = Cipher.getInstance(dhSKAlgo);
+       * encrypt.init(Cipher.ENCRYPT_MODE, sKey); */
+    } else {
-        encrypt = Cipher.getInstance(dhAlgoStr + "/CBC/PKCS5Padding");
-        encrypt.init(Cipher.ENCRYPT_MODE, sks, ivps);
-      }
+      String dhAlgoStr = getDhAlgoStr(dhSKAlgo);
+      SecretKeySpec sks = new SecretKeySpec(secretBytes, 0, keysize, dhAlgoStr);
+      IvParameterSpec ivps = new IvParameterSpec(secretBytes, keysize, blocksize);
+
+      encrypt = Cipher.getInstance(dhAlgoStr + "/CBC/PKCS5Padding");
+      encrypt.init(Cipher.ENCRYPT_MODE, sks, ivps);
+    }
-      //TODO: how to do here
-      /*SecretKey sKey = ka.generateSecret(dhSKAlgo);
-      decrypt = Cipher.getInstance(dhSKAlgo);
-      decrypt.init(Cipher.DECRYPT_MODE, sKey);*/
+      // TODO: how to do here, should we just throw runtime exception?
+      /* SecretKey sKey = ka.generateSecret(dhSKAlgo);
+       * decrypt = Cipher.getInstance(dhSKAlgo);
+       * decrypt.init(Cipher.DECRYPT_MODE, sKey); */
-      String algoStr = getDhAlgoStr(dhSKAlgo);
-
-   * that will be created using publickey of all the members..
-   *
+    //TODO: need to look this is thread safe
-    int viewId;
-    Set<InternalDistributedMember> mbrs;
-    
+
-    
-    public byte [] encryptBytes(byte[] data) throws Exception {
+
+    public synchronized byte[] encryptBytes(byte[] data) throws Exception {
-    
-    public byte[] decryptBytes(byte[] data) throws Exception
-    {
+
+    public synchronized byte[] decryptBytes(byte[] data) throws Exception {

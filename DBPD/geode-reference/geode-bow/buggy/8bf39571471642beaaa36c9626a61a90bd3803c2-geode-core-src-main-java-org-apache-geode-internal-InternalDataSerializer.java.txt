Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Contains static methods for data serializing instances of internal
- * GemFire classes.  It also contains the implementation of the
- * distribution messaging (and shared memory management) needed to
- * support data serialization.
+ * Contains static methods for data serializing instances of internal GemFire classes. It also
+ * contains the implementation of the distribution messaging (and shared memory management) needed
+ * to support data serialization.
-  
+
-   * Maps Class names to their DataSerializer.  This is used to
-   * find a DataSerializer during serialization.
+   * Maps Class names to their DataSerializer. This is used to find a DataSerializer during
+   * serialization.
-  private static final ConcurrentHashMap<String, DataSerializer> classesToSerializers = new ConcurrentHashMap<String, DataSerializer>();
-  
-  private static final String serializationVersionTxt = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "serializationVersion");
+  private static final ConcurrentHashMap<String, DataSerializer> classesToSerializers =
+      new ConcurrentHashMap<String, DataSerializer>();
+
+  private static final String serializationVersionTxt =
+      System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "serializationVersion");
-   * support for old GemFire clients and WAN sites - needed to
-   * enable moving from GemFire to Geode
+   * support for old GemFire clients and WAN sites - needed to enable moving from GemFire to Geode
+   * 
-    vINVALID,
-    v660, // includes 6.6.0.x and 6.6.1.x. Note that no serialization changes were made in 6.6 until 6.6.2
+    vINVALID, v660, // includes 6.6.0.x and 6.6.1.x. Note that no serialization changes were made in
+                    // 6.6 until 6.6.2
+
-  
+
-    } else if (serializationVersionTxt.startsWith("6.6.0") || serializationVersionTxt.startsWith("6.6.1")) {
+    } else if (serializationVersionTxt.startsWith("6.6.0")
+        || serializationVersionTxt.startsWith("6.6.1")) {
+
-  
+
-      throw new IllegalArgumentException("The system property \"gemfire.serializationVersion\" was set to \"" + serializationVersionTxt + "\" which is not a valid serialization version. Valid versions must start with \"6.6.0\", \"6.6.1\", or \"6.6.2\"");
+      throw new IllegalArgumentException(
+          "The system property \"gemfire.serializationVersion\" was set to \""
+              + serializationVersionTxt
+              + "\" which is not a valid serialization version. Valid versions must start with \"6.6.0\", \"6.6.1\", or \"6.6.2\"");
-  private static void initializeWellKnownSerializers() { 
+
+  private static void initializeWellKnownSerializers() {
-  
-    classesToSerializers.put("java.lang.String",
-                             new WellKnownPdxDS() {
+
+    classesToSerializers.put("java.lang.String", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 try {
-                                   writeString((String)o, out);
-                                 }
-                                 catch (UTFDataFormatException ex) {
-                                   // See bug 30428
-                                   String s = "While writing a String of length " +
-                                     ((String)o).length();
-                                   UTFDataFormatException ex2 = new UTFDataFormatException(s);
-                                   ex2.initCause(ex);
-                                   throw ex2;
-                                 }
-                                 return true;
-                               }});
-    classesToSerializers.put("java.net.InetAddress",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        try {
+          writeString((String) o, out);
+        } catch (UTFDataFormatException ex) {
+          // See bug 30428
+          String s = "While writing a String of length " + ((String) o).length();
+          UTFDataFormatException ex2 = new UTFDataFormatException(s);
+          ex2.initCause(ex);
+          throw ex2;
+        }
+        return true;
+      }
+    });
+    classesToSerializers.put("java.net.InetAddress", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 InetAddress address = (InetAddress) o;
-                                 out.writeByte(INET_ADDRESS);
-                                 writeInetAddress(address, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.net.Inet4Address",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        InetAddress address = (InetAddress) o;
+        out.writeByte(INET_ADDRESS);
+        writeInetAddress(address, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.net.Inet4Address", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 InetAddress address = (InetAddress) o;
-                                 out.writeByte(INET_ADDRESS);
-                                 writeInetAddress(address, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.net.Inet6Address",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        InetAddress address = (InetAddress) o;
+        out.writeByte(INET_ADDRESS);
+        writeInetAddress(address, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.net.Inet6Address", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 InetAddress address = (InetAddress) o;
-                                 out.writeByte(INET_ADDRESS);
-                                 writeInetAddress(address, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Class",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        InetAddress address = (InetAddress) o;
+        out.writeByte(INET_ADDRESS);
+        writeInetAddress(address, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Class", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Class c = (Class) o;
-                                 if (c.isPrimitive()) {
-                                   writePrimitiveClass(c, out);
-                                 }
-                                 else {
-                                   out.writeByte(CLASS);
-                                   writeClass(c, out);
-                                 }
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Boolean",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Class c = (Class) o;
+        if (c.isPrimitive()) {
+          writePrimitiveClass(c, out);
+        } else {
+          out.writeByte(CLASS);
+          writeClass(c, out);
+        }
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Boolean", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Boolean value = (Boolean) o;
-                                 out.writeByte(BOOLEAN);
-                                 writeBoolean(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Character",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Boolean value = (Boolean) o;
+        out.writeByte(BOOLEAN);
+        writeBoolean(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Character", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Character value = (Character) o;
-                                 out.writeByte(CHARACTER);
-                                 writeCharacter(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Byte",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Character value = (Character) o;
+        out.writeByte(CHARACTER);
+        writeCharacter(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Byte", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Byte value = (Byte) o;
-                                 out.writeByte(BYTE);
-                                 writeByte(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Short",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Byte value = (Byte) o;
+        out.writeByte(BYTE);
+        writeByte(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Short", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Short value = (Short) o;
-                                 out.writeByte(SHORT);
-                                 writeShort(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Integer",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Short value = (Short) o;
+        out.writeByte(SHORT);
+        writeShort(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Integer", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Integer value = (Integer) o;
-                                 out.writeByte(INTEGER);
-                                 writeInteger(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Long",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Integer value = (Integer) o;
+        out.writeByte(INTEGER);
+        writeInteger(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Long", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Long value = (Long) o;
-                                 out.writeByte(LONG);
-                                 writeLong(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Float",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Long value = (Long) o;
+        out.writeByte(LONG);
+        writeLong(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Float", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Float value = (Float) o;
-                                 out.writeByte(FLOAT);
-                                 writeFloat(value, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.lang.Double",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Float value = (Float) o;
+        out.writeByte(FLOAT);
+        writeFloat(value, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.lang.Double", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Double value = (Double) o;
-                                 out.writeByte(DOUBLE);
-                                 writeDouble(value, out);
-                                 return true;
-                               }});
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Double value = (Double) o;
+        out.writeByte(DOUBLE);
+        writeDouble(value, out);
+        return true;
+      }
+    });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(BOOLEAN_ARRAY);
-                                 writeBooleanArray((boolean[]) o, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            out.writeByte(BOOLEAN_ARRAY);
+            writeBooleanArray((boolean[]) o, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 byte[] array = (byte[]) o;
-                                 out.writeByte(BYTE_ARRAY);
-                                 writeByteArray(array, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            byte[] array = (byte[]) o;
+            out.writeByte(BYTE_ARRAY);
+            writeByteArray(array, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(CHAR_ARRAY);
-                                 writeCharArray((char[]) o, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            out.writeByte(CHAR_ARRAY);
+            writeCharArray((char[]) o, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 double[] array = (double[]) o;
-                                 out.writeByte(DOUBLE_ARRAY);
-                                 writeDoubleArray(array, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            double[] array = (double[]) o;
+            out.writeByte(DOUBLE_ARRAY);
+            writeDoubleArray(array, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 float[] array = (float[]) o;
-                                 out.writeByte(FLOAT_ARRAY);
-                                 writeFloatArray(array, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            float[] array = (float[]) o;
+            out.writeByte(FLOAT_ARRAY);
+            writeFloatArray(array, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 int[] array = (int[]) o;
-                                 out.writeByte(INT_ARRAY);
-                                 writeIntArray(array, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            int[] array = (int[]) o;
+            out.writeByte(INT_ARRAY);
+            writeIntArray(array, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 long[] array = (long[]) o;
-                                 out.writeByte(LONG_ARRAY);
-                                 writeLongArray(array, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            long[] array = (long[]) o;
+            out.writeByte(LONG_ARRAY);
+            writeLongArray(array, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 short[] array = (short[]) o;
-                                 out.writeByte(SHORT_ARRAY);
-                                 writeShortArray(array, out);
-                                 return true;
-                               }});
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            short[] array = (short[]) o;
+            out.writeByte(SHORT_ARRAY);
+            writeShortArray(array, out);
+            return true;
+          }
+        });
-                             new WellKnownPdxDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 String[] array = (String[]) o;
-                                 out.writeByte(STRING_ARRAY);
-                                 writeStringArray(array, out);
-                                 return true;
-                               }});
-    classesToSerializers.put(TimeUnit.NANOSECONDS.getClass().getName(),
-        new WellKnownDS() {
-          @Override public final boolean toData(Object o, DataOutput out)
-            throws IOException {
-            out.writeByte(TIME_UNIT);
-            out.writeByte(TIME_UNIT_NANOSECONDS);
+        new WellKnownPdxDS() {
+          @Override
+          public final boolean toData(Object o, DataOutput out) throws IOException {
+            String[] array = (String[]) o;
+            out.writeByte(STRING_ARRAY);
+            writeStringArray(array, out);
-          }});
-    classesToSerializers.put(TimeUnit.MICROSECONDS.getClass().getName(),
-        new WellKnownDS() {
-          @Override public final boolean toData(Object o, DataOutput out)
-            throws IOException {
-            out.writeByte(TIME_UNIT);
-            out.writeByte(TIME_UNIT_MICROSECONDS);
-            return true;
-          }});
-    classesToSerializers.put(TimeUnit.MILLISECONDS.getClass().getName(),
-        new WellKnownDS() {
-          @Override public final boolean toData(Object o, DataOutput out)
-            throws IOException {
-            out.writeByte(TIME_UNIT);
-            out.writeByte(TIME_UNIT_MILLISECONDS);
-            return true;
-          }});
-    classesToSerializers.put(TimeUnit.SECONDS.getClass().getName(),
-        new WellKnownDS() {
-          @Override public final boolean toData(Object o, DataOutput out)
-            throws IOException {
-            out.writeByte(TIME_UNIT);
-            out.writeByte(TIME_UNIT_SECONDS);
-            return true;
-          }});
-    classesToSerializers.put("java.util.Date",
-                             new WellKnownPdxDS() {
+          }
+        });
+    classesToSerializers.put(TimeUnit.NANOSECONDS.getClass().getName(), new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Date date = (Date) o;
-                                 out.writeByte(DATE);
-                                 writeDate(date, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.io.File",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(TIME_UNIT);
+        out.writeByte(TIME_UNIT_NANOSECONDS);
+        return true;
+      }
+    });
+    classesToSerializers.put(TimeUnit.MICROSECONDS.getClass().getName(), new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 File file = (File) o;
-                                 out.writeByte(FILE);
-                                 writeFile(file, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.ArrayList",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(TIME_UNIT);
+        out.writeByte(TIME_UNIT_MICROSECONDS);
+        return true;
+      }
+    });
+    classesToSerializers.put(TimeUnit.MILLISECONDS.getClass().getName(), new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 ArrayList list = (ArrayList) o;
-                                 out.writeByte(ARRAY_LIST);
-                                 writeArrayList(list, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.LinkedList",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(TIME_UNIT);
+        out.writeByte(TIME_UNIT_MILLISECONDS);
+        return true;
+      }
+    });
+    classesToSerializers.put(TimeUnit.SECONDS.getClass().getName(), new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 LinkedList list = (LinkedList) o;
-                                 out.writeByte(LINKED_LIST);
-                                 writeLinkedList(list, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.Vector",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(TIME_UNIT);
+        out.writeByte(TIME_UNIT_SECONDS);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.Date", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(VECTOR);
-                                 writeVector((Vector) o, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.Stack",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Date date = (Date) o;
+        out.writeByte(DATE);
+        writeDate(date, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.io.File", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(STACK);
-                                 writeStack((Stack) o, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.HashSet",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        File file = (File) o;
+        out.writeByte(FILE);
+        writeFile(file, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.ArrayList", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 HashSet list = (HashSet) o;
-                                 out.writeByte(HASH_SET);
-                                 writeHashSet(list, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.LinkedHashSet",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        ArrayList list = (ArrayList) o;
+        out.writeByte(ARRAY_LIST);
+        writeArrayList(list, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.LinkedList", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(LINKED_HASH_SET);
-                                 writeLinkedHashSet((LinkedHashSet) o, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.HashMap",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        LinkedList list = (LinkedList) o;
+        out.writeByte(LINKED_LIST);
+        writeLinkedList(list, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.Vector", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 HashMap list = (HashMap) o;
-                                 out.writeByte(HASH_MAP);
-                                 writeHashMap(list, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.IdentityHashMap",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(VECTOR);
+        writeVector((Vector) o, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.Stack", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(IDENTITY_HASH_MAP);
-                                 writeIdentityHashMap((IdentityHashMap) o, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.Hashtable",
-                             new WellKnownPdxDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(STACK);
+        writeStack((Stack) o, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.HashSet", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(HASH_TABLE);
-                                 writeHashtable((Hashtable) o, out);
-                                 return true;
-                               }});
-    // We can't add this here because it would cause writeObject to not be compatible with previous releases
-//    classesToSerializers.put("java.util.concurrent.ConcurrentHashMap",
-//                             new WellKnownDS() {
-//                              @Override
-//                              public final boolean toData(Object o, DataOutput out)
-//                                throws IOException {
-//                                out.writeByte(CONCURRENT_HASH_MAP);
-//                                writeConcurrentHashMap((ConcurrentHashMap<?, ?>) o, out);
-//                                return true;
-//                              }});
-    classesToSerializers.put("java.util.Properties",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        HashSet list = (HashSet) o;
+        out.writeByte(HASH_SET);
+        writeHashSet(list, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.LinkedHashSet", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 Properties props  = (Properties) o;
-                                 out.writeByte(PROPERTIES);
-                                 writeProperties(props, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.TreeMap",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(LINKED_HASH_SET);
+        writeLinkedHashSet((LinkedHashSet) o, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.HashMap", new WellKnownPdxDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(TREE_MAP);
-                                 writeTreeMap((TreeMap) o, out);
-                                 return true;
-                               }});
-    classesToSerializers.put("java.util.TreeSet",
-                             new WellKnownDS() {
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        HashMap list = (HashMap) o;
+        out.writeByte(HASH_MAP);
+        writeHashMap(list, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.IdentityHashMap", new WellKnownDS() {
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 out.writeByte(TREE_SET);
-                                 writeTreeSet((TreeSet) o, out);
-                                 return true;
-                               }});
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(IDENTITY_HASH_MAP);
+        writeIdentityHashMap((IdentityHashMap) o, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.Hashtable", new WellKnownPdxDS() {
+      @Override
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(HASH_TABLE);
+        writeHashtable((Hashtable) o, out);
+        return true;
+      }
+    });
+    // We can't add this here because it would cause writeObject to not be compatible with previous
+    // releases
+    // classesToSerializers.put("java.util.concurrent.ConcurrentHashMap",
+    // new WellKnownDS() {
+    // @Override
+    // public final boolean toData(Object o, DataOutput out)
+    // throws IOException {
+    // out.writeByte(CONCURRENT_HASH_MAP);
+    // writeConcurrentHashMap((ConcurrentHashMap<?, ?>) o, out);
+    // return true;
+    // }});
+    classesToSerializers.put("java.util.Properties", new WellKnownDS() {
+      @Override
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        Properties props = (Properties) o;
+        out.writeByte(PROPERTIES);
+        writeProperties(props, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.TreeMap", new WellKnownDS() {
+      @Override
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(TREE_MAP);
+        writeTreeMap((TreeMap) o, out);
+        return true;
+      }
+    });
+    classesToSerializers.put("java.util.TreeSet", new WellKnownDS() {
+      @Override
+      public final boolean toData(Object o, DataOutput out) throws IOException {
+        out.writeByte(TREE_SET);
+        writeTreeSet((TreeSet) o, out);
+        return true;
+      }
+    });
-      classesToSerializers.put("java.math.BigInteger",
-          new WellKnownDS() {
+      classesToSerializers.put("java.math.BigInteger", new WellKnownDS() {
-        public final boolean toData(Object o, DataOutput out)
-        throws IOException {
+        public final boolean toData(Object o, DataOutput out) throws IOException {
-        }});
-      classesToSerializers.put("java.math.BigDecimal",
-          new WellKnownDS() {
+        }
+      });
+      classesToSerializers.put("java.math.BigDecimal", new WellKnownDS() {
-        public final boolean toData(Object o, DataOutput out)
-        throws IOException {
+        public final boolean toData(Object o, DataOutput out) throws IOException {
-        }});
-      classesToSerializers.put("java.util.UUID",
-          new WellKnownDS() {
+        }
+      });
+      classesToSerializers.put("java.util.UUID", new WellKnownDS() {
-        public final boolean toData(Object o, DataOutput out)
-        throws IOException {
+        public final boolean toData(Object o, DataOutput out) throws IOException {
-        }});
-      classesToSerializers.put("java.sql.Timestamp",
-          new WellKnownDS() {
+        }
+      });
+      classesToSerializers.put("java.sql.Timestamp", new WellKnownDS() {
-        public final boolean toData(Object o, DataOutput out)
-        throws IOException {
+        public final boolean toData(Object o, DataOutput out) throws IOException {
-        }});
+        }
+      });
-  
-  /** Maps the id of a serializer to its <code>DataSerializer</code>.
-   */
-  private static final ConcurrentMap/*<Integer, DataSerializer|Marker>*/ idsToSerializers = new ConcurrentHashMap();
-   * Contains the classnames of the data serializers (and not the supported
-   * classes) not yet loaded into the vm as keys and their corresponding holder
-   * instances as values.
+   * Maps the id of a serializer to its <code>DataSerializer</code>.
-  private static final ConcurrentHashMap<String, SerializerAttributesHolder> dsClassesToHolders = new ConcurrentHashMap<String, SerializerAttributesHolder>();
+  private static final ConcurrentMap/* <Integer, DataSerializer|Marker> */ idsToSerializers =
+      new ConcurrentHashMap();
-   * Contains the id of the data serializers not yet loaded into the vm as keys
-   * and their corresponding holder instances as values.
+   * Contains the classnames of the data serializers (and not the supported classes) not yet loaded
+   * into the vm as keys and their corresponding holder instances as values.
-  private static final ConcurrentHashMap<Integer, SerializerAttributesHolder> idsToHolders = new ConcurrentHashMap<Integer, SerializerAttributesHolder>();
+  private static final ConcurrentHashMap<String, SerializerAttributesHolder> dsClassesToHolders =
+      new ConcurrentHashMap<String, SerializerAttributesHolder>();
-   * Contains the classnames of supported classes as keys and their
-   * corresponding SerializerAttributesHolder instances as values. This applies
-   * only to the data serializers which have not been loaded into the vm.
+   * Contains the id of the data serializers not yet loaded into the vm as keys and their
+   * corresponding holder instances as values.
-  private static final ConcurrentHashMap<String, SerializerAttributesHolder> supportedClassesToHolders = new ConcurrentHashMap<String, SerializerAttributesHolder>();
+  private static final ConcurrentHashMap<Integer, SerializerAttributesHolder> idsToHolders =
+      new ConcurrentHashMap<Integer, SerializerAttributesHolder>();
-  /** <code>RegistrationListener</code>s that receive callbacks when
-   * <code>DataSerializer</code>s and <code>Instantiator</code>s are
-   * registered.
-   * Note: copy-on-write access used for this set
+  /**
+   * Contains the classnames of supported classes as keys and their corresponding
+   * SerializerAttributesHolder instances as values. This applies only to the data serializers which
+   * have not been loaded into the vm.
+   */
+  private static final ConcurrentHashMap<String, SerializerAttributesHolder> supportedClassesToHolders =
+      new ConcurrentHashMap<String, SerializerAttributesHolder>();
+
+  /**
+   * <code>RegistrationListener</code>s that receive callbacks when <code>DataSerializer</code>s and
+   * <code>Instantiator</code>s are registered. Note: copy-on-write access used for this set
-  ////////////////////  Static Methods  ////////////////////
+  //////////////////// Static Methods ////////////////////
-   * Convert the given unsigned byte to an int.
-   * The returned value will be in the range [0..255] inclusive
+   * Convert the given unsigned byte to an int. The returned value will be in the range [0..255]
+   * inclusive
-   * @throws IllegalArgumentException
-   *         If the class can't be instantiated
+   * @throws IllegalArgumentException If the class can't be instantiated
-      throw new IllegalArgumentException(LocalizedStrings.DataSerializer_0_DOES_NOT_EXTEND_DATASERIALIZER.toLocalizedString(c.getName()));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DataSerializer_0_DOES_NOT_EXTEND_DATASERIALIZER
+              .toLocalizedString(c.getName()));
-      } 
+      }
-      throw new IllegalArgumentException(LocalizedStrings.DataSerializer_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0.toLocalizedString(c.getName()));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DataSerializer_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0
+              .toLocalizedString(c.getName()));
-      RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.DataSerializer_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0.toLocalizedString(c.getName()));
+      RuntimeException ex2 = new IllegalArgumentException(
+          LocalizedStrings.DataSerializer_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0
+              .toLocalizedString(c.getName()));
-      RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.DataSerializer_WHILE_INSTANTIATING_AN_INSTANCE_OF_0.toLocalizedString(c.getName()));
+      RuntimeException ex2 = new IllegalArgumentException(
+          LocalizedStrings.DataSerializer_WHILE_INSTANTIATING_AN_INSTANCE_OF_0
+              .toLocalizedString(c.getName()));
-  
+
-   * Registers a <code>DataSerializer</code> instance with the data
-   * serialization framework.
+   * Registers a <code>DataSerializer</code> instance with the data serialization framework.
-   * @param distribute
-   *        Should the registered <code>DataSerializer</code> be
-   *        distributed to other members of the distributed system?
+   * @param distribute Should the registered <code>DataSerializer</code> be distributed to other
+   *        members of the distributed system?
-  
-  public static DataSerializer _register(DataSerializer s,
-                                        boolean distribute) {
+
+  public static DataSerializer _register(DataSerializer s, boolean distribute) {
-      throw new IllegalArgumentException(LocalizedStrings.InternalDataSerializer_CANNOT_CREATE_A_DATASERIALIZER_WITH_ID_0.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.InternalDataSerializer_CANNOT_CREATE_A_DATASERIALIZER_WITH_ID_0
+              .toLocalizedString());
-      final StringId msg = LocalizedStrings.InternalDataSerializer_THE_DATASERIALIZER_0_HAS_NO_SUPPORTED_CLASSES_ITS_GETSUPPORTEDCLASSES_METHOD_MUST_RETURN_AT_LEAST_ONE_CLASS;
+      final StringId msg =
+          LocalizedStrings.InternalDataSerializer_THE_DATASERIALIZER_0_HAS_NO_SUPPORTED_CLASSES_ITS_GETSUPPORTEDCLASSES_METHOD_MUST_RETURN_AT_LEAST_ONE_CLASS;
-          final StringId msg = LocalizedStrings.InternalDataSerializer_THE_DATASERIALIZER_GETSUPPORTEDCLASSES_METHOD_FOR_0_RETURNED_AN_ARRAY_THAT_CONTAINED_A_NULL_ELEMENT;
+          final StringId msg =
+              LocalizedStrings.InternalDataSerializer_THE_DATASERIALIZER_GETSUPPORTEDCLASSES_METHOD_FOR_0_RETURNED_AN_ARRAY_THAT_CONTAINED_A_NULL_ELEMENT;
-          final StringId msg = LocalizedStrings.InternalDataSerializer_THE_DATASERIALIZER_GETSUPPORTEDCLASSES_METHOD_FOR_0_RETURNED_AN_ARRAY_THAT_CONTAINED_AN_ARRAY_CLASS_WHICH_IS_NOT_ALLOWED_SINCE_ARRAYS_HAVE_BUILTIN_SUPPORT;
+          final StringId msg =
+              LocalizedStrings.InternalDataSerializer_THE_DATASERIALIZER_GETSUPPORTEDCLASSES_METHOD_FOR_0_RETURNED_AN_ARRAY_THAT_CONTAINED_AN_ARRAY_CLASS_WHICH_IS_NOT_ALLOWED_SINCE_ARRAYS_HAVE_BUILTIN_SUPPORT;
-            oldMarker = (Marker)oldSerializer;
+            oldMarker = (Marker) oldSerializer;
-          throw new IllegalStateException(LocalizedStrings.InternalDataSerializer_A_DATASERIALIZER_OF_CLASS_0_IS_ALREADY_REGISTERED_WITH_ID_1_SO_THE_DATASERIALIZER_OF_CLASS_2_COULD_NOT_BE_REGISTERED.toLocalizedString(new Object[] {other.getClass().getName(), Integer.valueOf(other.getId())}));
+          throw new IllegalStateException(
+              LocalizedStrings.InternalDataSerializer_A_DATASERIALIZER_OF_CLASS_0_IS_ALREADY_REGISTERED_WITH_ID_1_SO_THE_DATASERIALIZER_OF_CLASS_2_COULD_NOT_BE_REGISTERED
+                  .toLocalizedString(
+                      new Object[] {other.getClass().getName(), Integer.valueOf(other.getId())}));
-              oldMsg = "A DataSerializer of class "
-                + oldS.getClass().getName()
-                + " is already registered to support class ";
+              oldMsg = "A DataSerializer of class " + oldS.getClass().getName()
+                  + " is already registered to support class ";
-            String msg = oldMsg
-              + classes[i].getName()
-              + " so the DataSerializer of class "
-              + s.getClass().getName()
-              + " could not be registered.";
+            String msg = oldMsg + classes[i].getName() + " so the DataSerializer of class "
+                + s.getClass().getName() + " could not be registered.";
- // if dataserializer is getting registered for first time
+    // if dataserializer is getting registered for first time
-    
+
-    
+
-   * Marks a <code>DataSerializer</code> className for registration with the
-   * data serialization framework. Does not necessarily load the classes into
-   * this VM.
+   * Marks a <code>DataSerializer</code> className for registration with the data serialization
+   * framework. Does not necessarily load the classes into this VM.
-   * @param distribute
-   *          If true, distribute this data serializer.
-   * @param eventId
-   *          Event id
-   * @param proxyId
-   *          proxy id
+   * @param distribute If true, distribute this data serializer.
+   * @param eventId Event id
+   * @param proxyId proxy id
-  public static void register(String className, boolean distribute,
-      EventID eventId, ClientProxyMembershipID proxyId, int id) {
-    register(className, distribute, new SerializerAttributesHolder(className,
-        eventId, proxyId, id));
+  public static void register(String className, boolean distribute, EventID eventId,
+      ClientProxyMembershipID proxyId, int id) {
+    register(className, distribute,
+        new SerializerAttributesHolder(className, eventId, proxyId, id));
-   * Marks a <code>DataSerializer</code> className for registration with the
-   * data serialization framework. Does not necessarily load the classes into
-   * this VM.
+   * Marks a <code>DataSerializer</code> className for registration with the data serialization
+   * framework. Does not necessarily load the classes into this VM.
-   * @param distribute
-   *          If true, distribute this data serializer.
+   * @param distribute If true, distribute this data serializer.
-    SerializerAttributesHolder oldValue = dsClassesToHolders.putIfAbsent(
-        className, holder);
+    SerializerAttributesHolder oldValue = dsClassesToHolders.putIfAbsent(className, holder);
-      if (oldValue.getId() != 0 && holder.getId() != 0
-          && oldValue.getId() != holder.getId()) {
+      if (oldValue.getId() != 0 && holder.getId() != 0 && oldValue.getId() != holder.getId()) {
-        ((Marker)ds).notifyAll();
+        ((Marker) ds).notifyAll();
-  public static void updateSupportedClassesMap(
-      HashMap<Integer, ArrayList<String>> map) {
+  public static void updateSupportedClassesMap(HashMap<Integer, ArrayList<String>> map) {
-        supportedClassesToHolders.putIfAbsent(supportedClassName,
-            idsToHolders.get(e.getKey()));
+        supportedClassesToHolders.putIfAbsent(supportedClassName, idsToHolders.get(e.getKey()));
-  public static void updateSupportedClassesMap(String dsClassName,
-      String supportedClassName) {
-    supportedClassesToHolders.putIfAbsent(supportedClassName,
-        dsClassesToHolders.get(dsClassName));
+  public static void updateSupportedClassesMap(String dsClassName, String supportedClassName) {
+    supportedClassesToHolders.putIfAbsent(supportedClassName, dsClassesToHolders.get(dsClassName));
-    
-    public SerializerAttributesHolder () {
-    }
-    public SerializerAttributesHolder(String name, EventID event,
-        ClientProxyMembershipID proxy, int id) {
+    public SerializerAttributesHolder() {}
+
+    public SerializerAttributesHolder(String name, EventID event, ClientProxyMembershipID proxy,
+        int id) {
-     * @return String the classname of the data serializer this instance
-     *         represents.
+     * @return String the classname of the data serializer this instance represents.
-      return "SerializerAttributesHolder[name=" + this.className + ",id=" + this.id + ",eventId=" + this.eventId + "]";
+      return "SerializerAttributesHolder[name=" + this.className + ",id=" + this.id + ",eventId="
+          + this.eventId + "]";
-  private static void sendRegistrationMessageToServers(DataSerializer dataSerializer)
-  {
+  private static void sendRegistrationMessageToServers(DataSerializer dataSerializer) {
-  private static void sendRegistrationMessageToServers(
-      SerializerAttributesHolder holder) {
+  private static void sendRegistrationMessageToServers(SerializerAttributesHolder holder) {
-  private static void sendRegistrationMessageToClients(DataSerializer dataSerializer)
-  {
+  private static void sendRegistrationMessageToClients(DataSerializer dataSerializer) {
-      serializedDataSerializer[0] = CacheServerHelper.serialize(dataSerializer
-          .getClass().toString().substring(6));
+      serializedDataSerializer[0] =
+          CacheServerHelper.serialize(dataSerializer.getClass().toString().substring(6));
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-        logger.trace(LogMarker.SERIALIZER, "InternalDataSerializer encountered an IOException while serializing DataSerializer :{}", dataSerializer);
+        logger.trace(LogMarker.SERIALIZER,
+            "InternalDataSerializer encountered an IOException while serializing DataSerializer :{}",
+            dataSerializer);
-    ClientDataSerializerMessage clientDataSerializerMessage = new ClientDataSerializerMessage(
-        EnumListenerEvent.AFTER_REGISTER_DATASERIALIZER, serializedDataSerializer,
-        (ClientProxyMembershipID)dataSerializer.getContext(),
-        (EventID)dataSerializer.getEventId(),
-        new Class[][]{dataSerializer.getSupportedClasses()});
+    ClientDataSerializerMessage clientDataSerializerMessage =
+        new ClientDataSerializerMessage(EnumListenerEvent.AFTER_REGISTER_DATASERIALIZER,
+            serializedDataSerializer, (ClientProxyMembershipID) dataSerializer.getContext(),
+            (EventID) dataSerializer.getEventId(),
+            new Class[][] {dataSerializer.getSupportedClasses()});
-  public static EventID generateEventId(){
+  public static EventID generateEventId() {
-    if(cache == null){
+    if (cache == null) {
+
-   * Unregisters a <code>Serializer</code> that was previously
-   * registered with the data serialization framework.
+   * Unregisters a <code>Serializer</code> that was previously registered with the data
+   * serialization framework.
-        o = ((Marker)o).getSerializer();
+        o = ((Marker) o).getSerializer();
-      DataSerializer s = (DataSerializer)o;
+      DataSerializer s = (DataSerializer) o;
-  
+
-   * Returns the <code>DataSerializer</code> for the given class.  If
-   * no class has been registered, <code>null</code> is returned.
-   * Remember that it is okay to return <code>null</code> in this
-   * case.  This method is invoked when writing an object.  If a
-   * serializer isn't available, then its the user's fault.
+   * Returns the <code>DataSerializer</code> for the given class. If no class has been registered,
+   * <code>null</code> is returned. Remember that it is okay to return <code>null</code> in this
+   * case. This method is invoked when writing an object. If a serializer isn't available, then its
+   * the user's fault.
-          logger.info(LogMarker.SERIALIZER, LocalizedMessage.create(LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0, dsClass));
+          logger.info(LogMarker.SERIALIZER,
+              LocalizedMessage.create(
+                  LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0,
+                  dsClass));
-    SerializerAttributesHolder sah=idsToHolders.get(idx);
+    SerializerAttributesHolder sah = idsToHolders.get(idx);
-        result = ((Marker)o).getSerializer();
+        result = ((Marker) o).getSerializer();
-      //SerializerAttributesHolder sah = idsToHolders.get(idx);
+      // SerializerAttributesHolder sah = idsToHolders.get(idx);
-          logger.info(LogMarker.SERIALIZER, LocalizedMessage.create(LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0, dsClass));
+          logger.info(LogMarker.SERIALIZER,
+              LocalizedMessage.create(
+                  LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0,
+                  dsClass));
+
-        v = ((Marker)v).getSerializer();
+        v = ((Marker) v).getSerializer();
-    Iterator<Entry<String, SerializerAttributesHolder>> iterator = dsClassesToHolders.entrySet().iterator();
+    Iterator<Entry<String, SerializerAttributesHolder>> iterator =
+        dsClassesToHolders.entrySet().iterator();
-        Class cl = getCachedClass(name); 
+        Class cl = getCachedClass(name);
-        logger.info(LogMarker.SERIALIZER, LocalizedMessage.create(LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0, name));
+        logger.info(LogMarker.SERIALIZER, LocalizedMessage.create(
+            LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0, name));
-   * Returns all the data serializers in this vm. This method, unlike
-   * {@link #getSerializers()}, does not force loading of the data serializers
-   * which were not loaded in the vm earlier.
+   * Returns all the data serializers in this vm. This method, unlike {@link #getSerializers()},
+   * does not force loading of the data serializers which were not loaded in the vm earlier.
-    Collection<SerializerAttributesHolder> coll = new ArrayList<InternalDataSerializer.SerializerAttributesHolder>(
-        size);
+    Collection<SerializerAttributesHolder> coll =
+        new ArrayList<InternalDataSerializer.SerializerAttributesHolder>(size);
-        v = ((Marker)v).getSerializer();
+        v = ((Marker) v).getSerializer();
-        DataSerializer s = (DataSerializer)v;
-        coll.add(new SerializerAttributesHolder(s.getClass().getName(),
-            (EventID)s.getEventId(), (ClientProxyMembershipID)s.getContext(), s
-                .getId()));
+        DataSerializer s = (DataSerializer) v;
+        coll.add(new SerializerAttributesHolder(s.getClass().getName(), (EventID) s.getEventId(),
+            (ClientProxyMembershipID) s.getContext(), s.getId()));
-    Iterator<Entry<String, SerializerAttributesHolder>> iterator = dsClassesToHolders
-        .entrySet().iterator();
+    Iterator<Entry<String, SerializerAttributesHolder>> iterator =
+        dsClassesToHolders.entrySet().iterator();
-  
+
-   * Persist this class's map to out 
+   * Persist this class's map to out
-        v = ((Marker)v).getSerializer();
+        v = ((Marker) v).getSerializer();
-        DataSerializer ds = (DataSerializer)v;
+        DataSerializer ds = (DataSerializer) v;
-      Iterator<Entry<String, SerializerAttributesHolder>> iterator = dsClassesToHolders
-          .entrySet().iterator();
+      Iterator<Entry<String, SerializerAttributesHolder>> iterator =
+          dsClassesToHolders.entrySet().iterator();
-          logger.info(LogMarker.SERIALIZER, LocalizedMessage.create(LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0, dsClass));
+          logger.info(LogMarker.SERIALIZER,
+              LocalizedMessage.create(
+                  LocalizedStrings.InternalDataSerializer_COULD_NOT_LOAD_DATASERIALIZER_CLASS_0,
+                  dsClass));
+   * 
-  public static void loadRegistrations(DataInput in) throws IOException
-  {
+  public static void loadRegistrations(DataInput in) throws IOException {
-      register(dsClass, /*dsId,*/ true);
+      register(dsClass, /* dsId, */ true);
-   * Adds a <code>RegistrationListener</code> that will receive
-   * callbacks when <code>DataSerializer</code>s and
-   * <code>Instantiator</code>s are registered.
+   * Adds a <code>RegistrationListener</code> that will receive callbacks when
+   * <code>DataSerializer</code>s and <code>Instantiator</code>s are registered.
-   * Removes a <code>RegistrationListener</code> so that it no longer
-   * receives callbacks.
+   * Removes a <code>RegistrationListener</code> so that it no longer receives callbacks.
-   * Alerts all <code>RegistrationListener</code>s that a new
-   * <code>DataSerializer</code> has been registered
+   * Alerts all <code>RegistrationListener</code>s that a new <code>DataSerializer</code> has been
+   * registered
-   * Alerts all <code>RegistrationListener</code>s that a new
-   * <code>Instantiator</code> has been registered
+   * Alerts all <code>RegistrationListener</code>s that a new <code>Instantiator</code> has been
+   * registered
-   * If we are connected to a distributed system, send a message to
-   * other members telling them about a newly-registered serializer.
+   * If we are connected to a distributed system, send a message to other members telling them about
+   * a newly-registered serializer.
-      throw new IllegalStateException(LocalizedStrings.InternalDataSerializer_ATTEMPTED_TO_SERIALIZE_ILLEGAL_DSFID.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.InternalDataSerializer_ATTEMPTED_TO_SERIALIZE_ILLEGAL_DSFID
+              .toLocalizedString());
-   if (dsfid <= Byte.MAX_VALUE && dsfid >= Byte.MIN_VALUE) {
+    if (dsfid <= Byte.MAX_VALUE && dsfid >= Byte.MIN_VALUE) {
-  
+
-    throws IOException
-  {
+      throws IOException {
-      if (dsfid != DataSerializableFixedID.NO_FIXED_ID && dsfid != DataSerializableFixedID.ILLEGAL) {
+      if (dsfid != DataSerializableFixedID.NO_FIXED_ID
+          && dsfid != DataSerializableFixedID.ILLEGAL) {
-        String existingClassName = (String)dsfidToClassMap.putIfAbsent(Integer.valueOf(dsfid), newClassName);
+        String existingClassName =
+            (String) dsfidToClassMap.putIfAbsent(Integer.valueOf(dsfid), newClassName);
-          logger.trace(LogMarker.DEBUG_DSFID, "dsfid={} is used for class {} and class {}", dsfid, existingClassName, newClassName);
+          logger.trace(LogMarker.DEBUG_DSFID, "dsfid={} is used for class {} and class {}", dsfid,
+              existingClassName, newClassName);
-      //Serializing a PDX can result in a cache closed exception. Just rethrow
+      // Serializing a PDX can result in a cache closed exception. Just rethrow
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw new ToDataException("toData failed on dsfid=" + dsfid+" msg:"+t.getMessage(),  t);
+      throw new ToDataException("toData failed on dsfid=" + dsfid + " msg:" + t.getMessage(), t);
-   * Data serializes an instance of a well-known class to the given
-   * <code>DataOutput</code>.
+   * Data serializes an instance of a well-known class to the given <code>DataOutput</code>.
-   * @return <code>true</code> if <code>o</code> was actually
-   *         written to <code>out</code>
+   * @return <code>true</code> if <code>o</code> was actually written to <code>out</code>
-  public static boolean writeWellKnownObject(Object o,
-                                              DataOutput out, boolean ensurePdxCompatibility)
-    throws IOException {
+  public static boolean writeWellKnownObject(Object o, DataOutput out,
+      boolean ensurePdxCompatibility) throws IOException {
+
-   * Data serializes an instance of a "user class" (that is, a class
-   * that can be handled by a registered <code>DataSerializer</code>)
-   * to the given <code>DataOutput</code>.
+   * Data serializes an instance of a "user class" (that is, a class that can be handled by a
+   * registered <code>DataSerializer</code>) to the given <code>DataOutput</code>.
-   * @return <code>true</code> if <code>o</code> was written to
-   *         <code>out</code>.
+   * @return <code>true</code> if <code>o</code> was written to <code>out</code>.
-    throws IOException {
+      throws IOException {
-    final DataSerializer serializer =
-      InternalDataSerializer.getSerializer(c);
+    final DataSerializer serializer = InternalDataSerializer.getSerializer(c);
-          out.writeByte((byte)id);
+          out.writeByte((byte) id);
-          throw new ToDataException("toData failed on DataSerializer with id=" + id + " for class " + c,  io);
+          throw new ToDataException(
+              "toData failed on DataSerializer with id=" + id + " for class " + c, io);
-        //Serializing a PDX can result in a cache closed exception. Just rethrow
+        // Serializing a PDX can result in a cache closed exception. Just rethrow
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        throw new ToDataException("toData failed on DataSerializer with id=" + id + " for class " + c,  t);
+        throw new ToDataException(
+            "toData failed on DataSerializer with id=" + id + " for class " + c, t);
-          LocalizedStrings.DataSerializer_SERIALIZER_0_A_1_SAID_THAT_IT_COULD_SERIALIZE_AN_INSTANCE_OF_2_BUT_ITS_TODATA_METHOD_RETURNED_FALSE
-          .toLocalizedString(new Object[]{Integer.valueOf(serializer.getId()), serializer.getClass().getName(), o.getClass().getName()}));
+            LocalizedStrings.DataSerializer_SERIALIZER_0_A_1_SAID_THAT_IT_COULD_SERIALIZE_AN_INSTANCE_OF_2_BUT_ITS_TODATA_METHOD_RETURNED_FALSE
+                .toLocalizedString(new Object[] {Integer.valueOf(serializer.getId()),
+                    serializer.getClass().getName(), o.getClass().getName()}));
-      byte[][] byteArrays = (byte[][])o;
+      byte[][] byteArrays = (byte[][]) o;
-    } else if (is662SerializationEnabled() && (o.getClass().isEnum()
-        /* for bug 52271 */ || (o.getClass().getSuperclass() != null && o.getClass().getSuperclass().isEnum()))) {
+    } else if (is662SerializationEnabled()
+        && (o.getClass().isEnum()/* for bug 52271 */ || (o.getClass().getSuperclass() != null
+            && o.getClass().getSuperclass().isEnum()))) {
-        writePdxEnum((Enum<?>)o, out);
+        writePdxEnum((Enum<?>) o, out);
-        writeGemFireEnum((Enum<?>)o, out);
+        writeGemFireEnum((Enum<?>) o, out);
-        GemFireCacheImpl gfc = GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed.");
+        GemFireCacheImpl gfc = GemFireCacheImpl
+            .getForPdx("PDX registry is unavailable because the Cache has been closed.");
-          //Serializing a PDX can result in a cache closed exception. Just rethrow
+          // Serializing a PDX can result in a cache closed exception. Just rethrow
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-          throw new ToDataException("PdxSerializer failed when calling toData on " + o.getClass(),  t);
+          throw new ToDataException("PdxSerializer failed when calling toData on " + o.getClass(),
+              t);
-      throw new NonPortableClassException("Instances of " + o.getClass() + " are not compatible with non-java PDX.");
+      throw new NonPortableClassException(
+          "Instances of " + o.getClass() + " are not compatible with non-java PDX.");
-   * Test to see if the object is in the gemfire package,
-   * to see if we should pass it on to a users custom serializater.
+   * Test to see if the object is in the gemfire package, to see if we should pass it on to a users
+   * custom serializater.
-            || o.getClass().getName().startsWith("org.apache.")
-             || o.getClass().getName().startsWith("org.apache.geode"))
-      && !(o instanceof PdxSerializerObject);
+        || o.getClass().getName().startsWith("org.apache.")
+        || o.getClass().getName().startsWith("org.apache.geode"))
+        && !(o instanceof PdxSerializerObject);
-   * Reads an object that was serialized by a customer ("user")
-   * <code>DataSerializer</code> from the given <code>DataInput</code>.
+   * Reads an object that was serialized by a customer ("user") <code>DataSerializer</code> from the
+   * given <code>DataInput</code>.
-   * @throws IOException
-   *         If the serializer that can deserialize the object is
-   *         not registered.
+   * @throws IOException If the serializer that can deserialize the object is not registered.
-    throws IOException, ClassNotFoundException {
-    DataSerializer serializer =
-      InternalDataSerializer.getSerializer(serializerId);
+      throws IOException, ClassNotFoundException {
+    DataSerializer serializer = InternalDataSerializer.getSerializer(serializerId);
-      throw new IOException(LocalizedStrings.DataSerializer_SERIALIZER_0_IS_NOT_REGISTERED.toLocalizedString(new Object[] { Integer.valueOf(serializerId) }));
+      throw new IOException(LocalizedStrings.DataSerializer_SERIALIZER_0_IS_NOT_REGISTERED
+          .toLocalizedString(new Object[] {Integer.valueOf(serializerId)}));
-   * Checks to make sure a <code>DataOutput</code> is not
-   * <code>null</code>.
+   * Checks to make sure a <code>DataOutput</code> is not <code>null</code>.
-   * @throws NullPointerException
-   *         If <code>out</code> is <code>null</code>
+   * @throws NullPointerException If <code>out</code> is <code>null</code>
+
-   * Checks to make sure a <code>DataInput</code> is not
-   * <code>null</code>.
+   * Checks to make sure a <code>DataInput</code> is not <code>null</code>.
-   * @throws NullPointerException
-   *         If <code>in</code> is <code>null</code>
+   * @throws NullPointerException If <code>in</code> is <code>null</code>
-   * This method is internal because its semantics (that is, its
-   * ability to write any kind of <code>Set</code>) are different from
-   * the <code>write</code>XXX methods of the external
-   * <code>DataSerializer</code>. 
+   * This method is internal because its semantics (that is, its ability to write any kind of
+   * <code>Set</code>) are different from the <code>write</code>XXX methods of the external
+   * <code>DataSerializer</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeSet(Collection<?> set, DataOutput out)
-      throws IOException {
+  public static void writeSet(Collection<?> set, DataOutput out) throws IOException {
-    
+
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>HashSet</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while writing to <code>out</code>
+   * @throws ClassNotFoundException The class of one of the <Code>HashSet</code>'s elements cannot
+   *         be found.
-  public static Set readSet(DataInput in) 
-    throws IOException, ClassNotFoundException {
+  public static Set readSet(DataInput in) throws IOException, ClassNotFoundException {
-   * Reads a <code>Set</code> from a <code>DataInput</code> into the given
-   * non-null collection. Returns true if collection read is non-null else
-   * returns false.
+   * Reads a <code>Set</code> from a <code>DataInput</code> into the given non-null collection.
+   * Returns true if collection read is non-null else returns false.
-   * @throws IOException
-   *           A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *           The class of one of the <Code>Set</code>'s elements cannot be
-   *           found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>Set</code>'s elements cannot be
+   *         found.
-        element = DataSerializer.<E> readObject(in);
+        element = DataSerializer.<E>readObject(in);
+   * 
-  public static void writeSetOfLongs(Set set, boolean hasLongIDs, DataOutput out) throws IOException {
+  public static void writeSetOfLongs(Set set, boolean hasLongIDs, DataOutput out)
+      throws IOException {
-      for (Iterator it=set.iterator(); it.hasNext(); ) {
-        Long l = (Long)it.next();
+      for (Iterator it = set.iterator(); it.hasNext();) {
+        Long l = (Long) it.next();
-          out.writeInt((int)l.longValue());
+          out.writeInt((int) l.longValue());
-  
+
-      for (int i=0; i<size; i++) {
-        long l = longIDs? in.readLong() : in.readInt();
+      for (int i = 0; i < size; i++) {
+        long l = longIDs ? in.readLong() : in.readInt();
+   * 
-  public static void writeListOfLongs(List list, boolean hasLongIDs, DataOutput out) throws IOException {
+  public static void writeListOfLongs(List list, boolean hasLongIDs, DataOutput out)
+      throws IOException {
-      for (Iterator it=list.iterator(); it.hasNext(); ) {
-        Long l = (Long)it.next();
+      for (Iterator it = list.iterator(); it.hasNext();) {
+        Long l = (Long) it.next();
-          out.writeInt((int)l.longValue());
+          out.writeInt((int) l.longValue());
-  
+
-      for (int i=0; i<size; i++) {
-        long l = longIDs? in.readLong() : in.readInt();
+      for (int i = 0; i < size; i++) {
+        long l = longIDs ? in.readLong() : in.readInt();
-  
-  
+
+
-   * Writes the type code for a primitive type Class
-   * to <code>DataOutput</code>.
+   * Writes the type code for a primitive type Class to <code>DataOutput</code>.
-  public static final void writePrimitiveClass(Class c, DataOutput out)
-  throws IOException {
+  public static final void writePrimitiveClass(Class c, DataOutput out) throws IOException {
-    }
-    else if (c == Character.TYPE) {
+    } else if (c == Character.TYPE) {
-    }
-    else if (c == Byte.TYPE) {
+    } else if (c == Byte.TYPE) {
-    }
-    else if (c == Short.TYPE) {
+    } else if (c == Short.TYPE) {
-    }
-    else if (c == Integer.TYPE) {
+    } else if (c == Integer.TYPE) {
-    }
-    else if (c == Long.TYPE) {
+    } else if (c == Long.TYPE) {
-    }
-    else if (c == Float.TYPE) {
+    } else if (c == Float.TYPE) {
-    }
-    else if (c == Double.TYPE) {
+    } else if (c == Double.TYPE) {
-    }
-    else if (c == Void.TYPE) {
+    } else if (c == Void.TYPE) {
-    }
-    else if (c == null) {
+    } else if (c == null) {
-    }
-    else {
-      throw new InternalGemFireError(LocalizedStrings.InternalDataSerializer_UNKNOWN_PRIMITIVE_TYPE_0.toLocalizedString(c.getName()));
+    } else {
+      throw new InternalGemFireError(
+          LocalizedStrings.InternalDataSerializer_UNKNOWN_PRIMITIVE_TYPE_0
+              .toLocalizedString(c.getName()));
-  
+
-        throw new InternalGemFireError(LocalizedStrings.InternalDataSerializer_UNEXPECTED_TYPECODE_0.toLocalizedString(Byte.valueOf(typeCode)));
+        throw new InternalGemFireError(LocalizedStrings.InternalDataSerializer_UNEXPECTED_TYPECODE_0
+            .toLocalizedString(Byte.valueOf(typeCode)));
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static TimeUnit readTimeUnit(DataInput in)
-    throws IOException {
+  public static TimeUnit readTimeUnit(DataInput in) throws IOException {
-    case TIME_UNIT_NANOSECONDS:
-      unit = TimeUnit.NANOSECONDS;
-      break;
-    case TIME_UNIT_MICROSECONDS:
-      unit = TimeUnit.MICROSECONDS;
-      break;
-    case TIME_UNIT_MILLISECONDS:
-      unit = TimeUnit.MILLISECONDS;
-      break;
-    case TIME_UNIT_SECONDS:
-      unit = TimeUnit.SECONDS;
-      break;
-    default:
-      throw new IOException(LocalizedStrings.DataSerializer_UNKNOWN_TIMEUNIT_TYPE_0.toLocalizedString(Byte.valueOf(type)));
+      case TIME_UNIT_NANOSECONDS:
+        unit = TimeUnit.NANOSECONDS;
+        break;
+      case TIME_UNIT_MICROSECONDS:
+        unit = TimeUnit.MICROSECONDS;
+        break;
+      case TIME_UNIT_MILLISECONDS:
+        unit = TimeUnit.MILLISECONDS;
+        break;
+      case TIME_UNIT_SECONDS:
+        unit = TimeUnit.SECONDS;
+        break;
+      default:
+        throw new IOException(LocalizedStrings.DataSerializer_UNKNOWN_TIMEUNIT_TYPE_0
+            .toLocalizedString(Byte.valueOf(type)));
+
+
+
+
-  //private static final HashSet seenClassNames = DEBUG_DSFID ? new HashSet(): null;
-  private static final ConcurrentMap dsfidToClassMap = logger.isTraceEnabled(LogMarker.DEBUG_DSFID) ? new ConcurrentHashMap(): null;
-  
-  public static final void writeUserDataSerializableHeader(int classId,
-                                                           DataOutput out)
-    throws IOException
-  {
+  // private static final HashSet seenClassNames = DEBUG_DSFID ? new HashSet(): null;
+  private static final ConcurrentMap dsfidToClassMap =
+      logger.isTraceEnabled(LogMarker.DEBUG_DSFID) ? new ConcurrentHashMap() : null;
+
+  public static final void writeUserDataSerializableHeader(int classId, DataOutput out)
+      throws IOException {
-   * @throws IOException
-   *           A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeCharArray(char[] array, int length, DataOutput out)
-      throws IOException {
+  public static void writeCharArray(char[] array, int length, DataOutput out) throws IOException {
-  
+
+   * 
-  public static final void basicWriteObject(Object o, DataOutput out, boolean ensurePdxCompatibility)
-    throws IOException {
+  public static final void basicWriteObject(Object o, DataOutput out,
+      boolean ensurePdxCompatibility) throws IOException {
-      DataSerializableFixedID dsfid = (DataSerializableFixedID)o;
+      DataSerializableFixedID dsfid = (DataSerializableFixedID) o;
-      writePdx(out, GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed."), o, null);
+      writePdx(out, GemFireCacheImpl
+          .getForPdx("PDX registry is unavailable because the Cache has been closed."), o, null);
-//         if (DEBUG_DSFID) {
-//           if (logger.infoEnabled()) {
-//             boolean alreadySeen;
-//             synchronized (seenClassNames) {
-//               alreadySeen = seenClassNames.add(c.getName());
-//             }
-//             if (alreadySeen) {
-//               // this class should be made a DSFID if it is a product class
-//               logger.info("DataSerialized class " + c.getName(), new RuntimeException("CALLSTACK"));
-//             }
-//           }
-//         }
+        // if (DEBUG_DSFID) {
+        // if (logger.infoEnabled()) {
+        // boolean alreadySeen;
+        // synchronized (seenClassNames) {
+        // alreadySeen = seenClassNames.add(c.getName());
+        // }
+        // if (alreadySeen) {
+        // // this class should be made a DSFID if it is a product class
+        // logger.info("DataSerialized class " + c.getName(), new RuntimeException("CALLSTACK"));
+        // }
+        // }
+        // }
-      ((Sendable)o).sendTo(out);
+      ((Sendable) o).sendTo(out);
-        logger.trace(LogMarker.DUMP_SERIALIZED, "DataSerializer Serializing an instance of {}", o.getClass().getName());
+        logger.trace(LogMarker.DUMP_SERIALIZED, "DataSerializer Serializing an instance of {}",
+            o.getClass().getName());
-      /* If the (internally known) ThreadLocal named "DataSerializer.DISALLOW_JAVA_SERIALIZATION" is set,
-       * then an exception will be thrown if we try to do standard Java Serialization.
-       * This is used to catch Java serialization early for the case where the data is being
-       * sent to a non-Java client
+      /*
+       * If the (internally known) ThreadLocal named "DataSerializer.DISALLOW_JAVA_SERIALIZATION" is
+       * set, then an exception will be thrown if we try to do standard Java Serialization. This is
+       * used to catch Java serialization early for the case where the data is being sent to a
+       * non-Java client
-        throw new NotSerializableException(LocalizedStrings.DataSerializer_0_IS_NOT_DATASERIALIZABLE_AND_JAVA_SERIALIZATION_IS_DISALLOWED.toLocalizedString(o.getClass().getName()));
+        throw new NotSerializableException(
+            LocalizedStrings.DataSerializer_0_IS_NOT_DATASERIALIZABLE_AND_JAVA_SERIALIZATION_IS_DISALLOWED
+                .toLocalizedString(o.getClass().getName()));
-//       if (out instanceof DSDataOutput) {
-//         // Unwrap the DSDataOutput to avoid one layer of
-//         // delegation.  This also prevents us from having to flush
-//         // the ObjectOutputStream.
-//         out = ((DSDataOutput) out).out;
-//       }
+      // if (out instanceof DSDataOutput) {
+      // // Unwrap the DSDataOutput to avoid one layer of
+      // // delegation. This also prevents us from having to flush
+      // // the ObjectOutputStream.
+      // out = ((DSDataOutput) out).out;
+      // }
-  
+
-  
+
-   * @throws IOException 
+   * @throws IOException
-      GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed.").getPdxRegistry();
+        GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed.")
+            .getPdxRegistry();
+
-   * @throws IOException
-   * since 6.6.2
+   * @throws IOException since 6.6.2
-    GemFireCacheImpl gfc = GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed.");
+    GemFireCacheImpl gfc = GemFireCacheImpl
+        .getForPdx("PDX registry is unavailable because the Cache has been closed.");
-    
+
-  
+
-   * write an object in java Serializable form with a SERIALIZABLE DSCODE so
-   * that it can be deserialized with DataSerializer.readObject()
+   * write an object in java Serializable form with a SERIALIZABLE DSCODE so that it can be
+   * deserialized with DataSerializer.readObject()
+   * 
-  public static final void writeSerializableObject(Object o, DataOutput out)
-    throws IOException {
+  public static final void writeSerializableObject(Object o, DataOutput out) throws IOException {
-      ((ObjectOutputStream)out).writeObject(o);
+      ((ObjectOutputStream) out).writeObject(o);
-        stream = (OutputStream)out;
+        stream = (OutputStream) out;
-            public void write(int b) throws IOException {
-              out2.write(b);
-            }
+          public void write(int b) throws IOException {
+            out2.write(b);
+          }
-            //               public void write(byte[] b) throws IOException {
-            //                 out.write(b);
-            //               }
+          // public void write(byte[] b) throws IOException {
+          // out.write(b);
+          // }
-            //               public void write(byte[] b, int off, int len)
-            //                 throws IOException {
-            //                 out.write(b, off, len);
-            //               }
-          };
+          // public void write(byte[] b, int off, int len)
+          // throws IOException {
+          // out.write(b, off, len);
+          // }
+        };
-      ObjectOutput oos = new ObjectOutputStream(stream);
-      if ( stream instanceof VersionedDataStream ) {
-        Version v = ((VersionedDataStream)stream).getVersion();
-        if (v != null && v != Version.CURRENT) { 
-          oos = new VersionedObjectOutput(oos, v);
+        ObjectOutput oos = new ObjectOutputStream(stream);
+        if (stream instanceof VersionedDataStream) {
+          Version v = ((VersionedDataStream) stream).getVersion();
+          if (v != null && v != Version.CURRENT) {
+            oos = new VersionedObjectOutput(oos, v);
+          }
-      }
-      oos.writeObject(o);
-      // To fix bug 35568 just call flush. We can't call close because
-      // it calls close on the wrapped OutputStream.
-      oos.flush();
+        oos.writeObject(o);
+        // To fix bug 35568 just call flush. We can't call close because
+        // it calls close on the wrapped OutputStream.
+        oos.flush();
-  
+
-   * For backward compatibility this method should be used to invoke
-   * toData on a DSFID or DataSerializable.  It will invoke the
-   * correct toData method based on the class's version information.
-   * This method does not write information about the class of the
-   * object.  When deserializing use the method invokeFromData to
-   * read the contents of the object.
+   * For backward compatibility this method should be used to invoke toData on a DSFID or
+   * DataSerializable. It will invoke the correct toData method based on the class's version
+   * information. This method does not write information about the class of the object. When
+   * deserializing use the method invokeFromData to read the contents of the object.
-      
+
-              ds.getClass()
-                  .getMethod(
-                      "toDataPre_" + versions[i].getMethodSuffix(),
-                      new Class[] { DataOutput.class }).invoke(ds, out);
+              ds.getClass().getMethod("toDataPre_" + versions[i].getMethodSuffix(),
+                  new Class[] {DataOutput.class}).invoke(ds, out);
-      
+
-          ((DataSerializableFixedID)ds).toData(out);
+          ((DataSerializableFixedID) ds).toData(out);
-          ((DataSerializable)ds).toData(out);
+          ((DataSerializable) ds).toData(out);
-        throw new ToDataException("toData failed on DataSerializable " + ds.getClass(),  io);
+        throw new ToDataException("toData failed on DataSerializable " + ds.getClass(), io);
-      //Serializing a PDX can result in a cache closed exception. Just rethrow
+      // Serializing a PDX can result in a cache closed exception. Just rethrow
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw new ToDataException("toData failed on DataSerializable " + ds.getClass(),  t);
+      throw new ToDataException("toData failed on DataSerializable " + ds.getClass(), t);
-  
+
-   * For backward compatibility this method should be used to invoke
-   * fromData on a DSFID or DataSerializable.  It will invoke the
-   * correct fromData method based on the class's version information.
-   * This method does not read information about the class of the
-   * object.  When serializing use the method invokeToData to
-   * write the contents of the object.
+   * For backward compatibility this method should be used to invoke fromData on a DSFID or
+   * DataSerializable. It will invoke the correct fromData method based on the class's version
+   * information. This method does not read information about the class of the object. When
+   * serializing use the method invokeToData to write the contents of the object.
-   * @param ds  the object to write
-   * @param in  the input stream.
+   * @param ds the object to write
+   * @param in the input stream.
-  public static final void invokeFromData(Object ds, DataInput in) throws IOException, ClassNotFoundException {
+  public static final void invokeFromData(Object ds, DataInput in)
+      throws IOException, ClassNotFoundException {
-              ds.getClass()
-                  .getMethod(
-                      "fromDataPre" + "_" + versions[i].getMethodSuffix(),
-                      new Class[] { DataInput.class }).invoke(ds, in);
+              ds.getClass().getMethod("fromDataPre" + "_" + versions[i].getMethodSuffix(),
+                  new Class[] {DataInput.class}).invoke(ds, in);
-          ((DataSerializableFixedID)ds).fromData(in);
+          ((DataSerializableFixedID) ds).fromData(in);
-          ((DataSerializable)ds).fromData(in);
+          ((DataSerializable) ds).fromData(in);
-      SerializationException ex2 = new SerializationException(LocalizedStrings.DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_0.toLocalizedString(ds.getClass().getName()), ex);
+      SerializationException ex2 = new SerializationException(
+          LocalizedStrings.DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_0
+              .toLocalizedString(ds.getClass().getName()),
+          ex);
-  
+
-    throws IOException, ClassNotFoundException
-  {
+      throws IOException, ClassNotFoundException {
-      SerializationException ex2 = new SerializationException(LocalizedStrings.DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_0.toLocalizedString(c.getName()), ex);
+      SerializationException ex2 = new SerializationException(
+          LocalizedStrings.DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_0
+              .toLocalizedString(c.getName()),
+          ex);
-  private static final Object
-    readDataSerializableFixedID(final DataInput in)
-    throws IOException, ClassNotFoundException
-  {
+
+  private static final Object readDataSerializableFixedID(final DataInput in)
+      throws IOException, ClassNotFoundException {
-      
+
-      SerializationException ex2 = new SerializationException(LocalizedStrings.DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_0.toLocalizedString(c.getName()), ex);
+      SerializationException ex2 = new SerializationException(
+          LocalizedStrings.DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_0
+              .toLocalizedString(c.getName()),
+          ex);
-   * Get the {@link Version} of the peer or disk store that created this
-   * {@link DataInput}.
+   * Get the {@link Version} of the peer or disk store that created this {@link DataInput}.
-      final Version v = ((VersionedDataStream)in).getVersion();
+      final Version v = ((VersionedDataStream) in).getVersion();
-    }
-    else {
+    } else {
-   * Get the {@link Version} of the peer or disk store that created this
-   * {@link DataInput}. Returns null if the version is same as this member's.
+   * Get the {@link Version} of the peer or disk store that created this {@link DataInput}. Returns
+   * null if the version is same as this member's.
-      return ((VersionedDataStream)in).getVersion();
-    }
-    else {
+      return ((VersionedDataStream) in).getVersion();
+    } else {
-   * Get the {@link Version} of the peer or disk store that created this
-   * {@link DataOutput}.
+   * Get the {@link Version} of the peer or disk store that created this {@link DataOutput}.
-      final Version v = ((VersionedDataStream)out).getVersion();
+      final Version v = ((VersionedDataStream) out).getVersion();
-    }
-    else {
+    } else {
-   * Get the {@link Version} of the peer or disk store that created this
-   * {@link DataOutput}. Returns null if the version is same as this member's.
+   * Get the {@link Version} of the peer or disk store that created this {@link DataOutput}. Returns
+   * null if the version is same as this member's.
-      return ((VersionedDataStream)out).getVersion();
-    }
-    else {
+      return ((VersionedDataStream) out).getVersion();
+    } else {
-  private static final byte SHORT_ARRAY_LEN = -2; // array len encoded as unsigned short in next 2 bytes
+  private static final byte SHORT_ARRAY_LEN = -2; // array len encoded as unsigned short in next 2
+                                                  // bytes
-  private static final int MAX_BYTE_ARRAY_LEN = ((byte)-4) & 0xFF; 
-  
-  public static void writeArrayLength(int len, DataOutput out)
-    throws IOException {
+  private static final int MAX_BYTE_ARRAY_LEN = ((byte) -4) & 0xFF;
+
+  public static void writeArrayLength(int len, DataOutput out) throws IOException {
-  public static int readArrayLength(DataInput in)
-    throws IOException {
+
+  public static int readArrayLength(DataInput in) throws IOException {
-   * Serializes a list of Integers.  The argument may be null.  Deserialize with
-   * readListOfIntegers().
+   * Serializes a list of Integers. The argument may be null. Deserialize with readListOfIntegers().
-   * Reads a list of integers serialized by writeListOfIntegers.  This
-   * will return null if the object serialized by writeListOfIntegers was null. 
+   * Reads a list of integers serialized by writeListOfIntegers. This will return null if the object
+   * serialized by writeListOfIntegers was null.
-    }
-    else if (size == 0) {
+    } else if (size == 0) {
-    }
-    else {
+    } else {
-  
+
-   * Reads and discards an array of <code>byte</code>s from a
-   * <code>DataInput</code>.
+   * Reads and discards an array of <code>byte</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void skipByteArray(DataInput in)
-    throws IOException {
+  public static void skipByteArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length != -1) {
-        in.skipBytes(length);
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Skipped byte array of length {}", length);
-        }
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length != -1) {
+      in.skipBytes(length);
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Skipped byte array of length {}", length);
+  }
-    throws IOException, ClassNotFoundException
-  {
+      throws IOException, ClassNotFoundException {
-  
+
-      throws IOException, ClassNotFoundException
-    {
-      checkIn(in);
-      byte header = in.readByte();
-      if (header == DS_FIXED_ID_BYTE) {
-        return in.readByte();
-      } else if (header == DS_FIXED_ID_SHORT) {
-        return in.readShort();
-      } else if (header == DS_NO_FIXED_ID) {
-        return Integer.MAX_VALUE;//is that correct??
-      } else if (header == DS_FIXED_ID_INT) {
-        return in.readInt();
-      } else {
-        throw new IllegalStateException("unexpected byte: " + header + " while reading dsfid");
-      }
+      throws IOException, ClassNotFoundException {
+    checkIn(in);
+    byte header = in.readByte();
+    if (header == DS_FIXED_ID_BYTE) {
+      return in.readByte();
+    } else if (header == DS_FIXED_ID_SHORT) {
+      return in.readShort();
+    } else if (header == DS_NO_FIXED_ID) {
+      return Integer.MAX_VALUE;// is that correct??
+    } else if (header == DS_FIXED_ID_INT) {
+      return in.readInt();
+    } else {
+      throw new IllegalStateException("unexpected byte: " + header + " while reading dsfid");
-  
+  }
+
-   * Reads an instance of <code>String</code> from a
-   * <code>DataInput</code> given the header byte already being read.
-   * The return value may be <code>null</code>.
+   * Reads an instance of <code>String</code> from a <code>DataInput</code> given the header byte
+   * already being read. The return value may be <code>null</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-      return new String(buf, 0);  // intentionally using deprecated constructor
-    }
-    else if (header == DSCODE.STRING) {
+      return new String(buf, 0); // intentionally using deprecated constructor
+    } else if (header == DSCODE.STRING) {
-    }
-    else if (header == DSCODE.NULL_STRING) {
+    } else if (header == DSCODE.NULL_STRING) {
-    }
-    else if (header == DSCODE.HUGE_STRING_BYTES) {
+    } else if (header == DSCODE.HUGE_STRING_BYTES) {
-    }
-    else if (header == DSCODE.HUGE_STRING) {
+    } else if (header == DSCODE.HUGE_STRING) {
-      for (int i=0; i < len; i++) {
+      for (int i = 0; i < len; i++) {
-    }
-    else {
+    } else {
-  
+
-   * Just like readObject but make sure and pdx deserialized is not
-   * a PdxInstance. 
+   * Just like readObject but make sure and pdx deserialized is not a PdxInstance.
+   * 
-  throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-  
+
-    case DS_FIXED_ID_BYTE:
-      return DSFIDFactory.create(in.readByte(), in);
-    case DS_FIXED_ID_SHORT:
-      return DSFIDFactory.create(in.readShort(), in);
-    case DS_FIXED_ID_INT:
-      return DSFIDFactory.create(in.readInt(), in);
-    case DS_NO_FIXED_ID:
-      return readDataSerializableFixedID(in);
-    case NULL:
-      return null;
-    case NULL_STRING:
-    case STRING:
-    case HUGE_STRING:
-    case STRING_BYTES:
-    case HUGE_STRING_BYTES:
-      return readString(in, header);
-    case CLASS:
-      return readClass(in);
-    case DATE:
-      return readDate(in);
-    case FILE:
-      return readFile(in);
-    case INET_ADDRESS:
-      return readInetAddress(in);
-    case BOOLEAN:
-      return readBoolean(in);
-    case CHARACTER:
-      return readCharacter(in);
-    case BYTE:
-      return readByte(in);
-    case SHORT:
-      return readShort(in);
-    case INTEGER:
-      return readInteger(in);
-    case LONG:
-      return readLong(in);
-    case FLOAT:
-      return readFloat(in);
-    case DOUBLE:
-      return readDouble(in);
-    case BYTE_ARRAY:
-      return readByteArray(in);
-    case ARRAY_OF_BYTE_ARRAYS:
-      return readArrayOfByteArrays(in);  
-    case SHORT_ARRAY:
-      return readShortArray(in);
-    case STRING_ARRAY:
-      return readStringArray(in);
-    case INT_ARRAY:
-      return readIntArray(in);
-    case LONG_ARRAY:
-      return readLongArray(in);
-    case FLOAT_ARRAY:
-      return readFloatArray(in);
-    case DOUBLE_ARRAY:
-      return readDoubleArray(in);
-    case BOOLEAN_ARRAY:
-      return readBooleanArray(in);
-    case CHAR_ARRAY:
-      return readCharArray(in);
-    case OBJECT_ARRAY:
-      return readObjectArray(in);
-    case ARRAY_LIST:
-      return readArrayList(in);
-    case LINKED_LIST:
-      return readLinkedList(in);
-    case HASH_SET:
-      return readHashSet(in);
-    case LINKED_HASH_SET:
-      return readLinkedHashSet(in);
-    case HASH_MAP:
-      return readHashMap(in);
-    case IDENTITY_HASH_MAP:
-      return readIdentityHashMap(in);
-    case HASH_TABLE:
-      return readHashtable(in);
-    case CONCURRENT_HASH_MAP:
-      return readConcurrentHashMap(in);
-    case PROPERTIES:
-      return readProperties(in);
-    case TIME_UNIT:
-      return readTimeUnit(in);
-    case USER_CLASS:
-      return readUserObject(in, in.readByte());
-    case USER_CLASS_2:
-      return readUserObject(in, in.readShort());
-    case USER_CLASS_4:
-      return readUserObject(in, in.readInt());
-    case VECTOR:
-      return readVector(in);
-    case STACK:
-      return readStack(in);
-    case TREE_MAP:
-      return readTreeMap(in);
-    case TREE_SET:
-      return readTreeSet(in);
-    case BOOLEAN_TYPE:
-      return Boolean.TYPE;
-    case CHARACTER_TYPE:
-      return Character.TYPE;
-    case BYTE_TYPE:
-      return Byte.TYPE;
-    case SHORT_TYPE:
-      return Short.TYPE;
-    case INTEGER_TYPE:
-      return Integer.TYPE;
-    case LONG_TYPE:
-      return Long.TYPE;
-    case FLOAT_TYPE:
-      return Float.TYPE;
-    case DOUBLE_TYPE:
-      return Double.TYPE;
-    case VOID_TYPE:
-      return Void.TYPE;
+      case DS_FIXED_ID_BYTE:
+        return DSFIDFactory.create(in.readByte(), in);
+      case DS_FIXED_ID_SHORT:
+        return DSFIDFactory.create(in.readShort(), in);
+      case DS_FIXED_ID_INT:
+        return DSFIDFactory.create(in.readInt(), in);
+      case DS_NO_FIXED_ID:
+        return readDataSerializableFixedID(in);
+      case NULL:
+        return null;
+      case NULL_STRING:
+      case STRING:
+      case HUGE_STRING:
+      case STRING_BYTES:
+      case HUGE_STRING_BYTES:
+        return readString(in, header);
+      case CLASS:
+        return readClass(in);
+      case DATE:
+        return readDate(in);
+      case FILE:
+        return readFile(in);
+      case INET_ADDRESS:
+        return readInetAddress(in);
+      case BOOLEAN:
+        return readBoolean(in);
+      case CHARACTER:
+        return readCharacter(in);
+      case BYTE:
+        return readByte(in);
+      case SHORT:
+        return readShort(in);
+      case INTEGER:
+        return readInteger(in);
+      case LONG:
+        return readLong(in);
+      case FLOAT:
+        return readFloat(in);
+      case DOUBLE:
+        return readDouble(in);
+      case BYTE_ARRAY:
+        return readByteArray(in);
+      case ARRAY_OF_BYTE_ARRAYS:
+        return readArrayOfByteArrays(in);
+      case SHORT_ARRAY:
+        return readShortArray(in);
+      case STRING_ARRAY:
+        return readStringArray(in);
+      case INT_ARRAY:
+        return readIntArray(in);
+      case LONG_ARRAY:
+        return readLongArray(in);
+      case FLOAT_ARRAY:
+        return readFloatArray(in);
+      case DOUBLE_ARRAY:
+        return readDoubleArray(in);
+      case BOOLEAN_ARRAY:
+        return readBooleanArray(in);
+      case CHAR_ARRAY:
+        return readCharArray(in);
+      case OBJECT_ARRAY:
+        return readObjectArray(in);
+      case ARRAY_LIST:
+        return readArrayList(in);
+      case LINKED_LIST:
+        return readLinkedList(in);
+      case HASH_SET:
+        return readHashSet(in);
+      case LINKED_HASH_SET:
+        return readLinkedHashSet(in);
+      case HASH_MAP:
+        return readHashMap(in);
+      case IDENTITY_HASH_MAP:
+        return readIdentityHashMap(in);
+      case HASH_TABLE:
+        return readHashtable(in);
+      case CONCURRENT_HASH_MAP:
+        return readConcurrentHashMap(in);
+      case PROPERTIES:
+        return readProperties(in);
+      case TIME_UNIT:
+        return readTimeUnit(in);
+      case USER_CLASS:
+        return readUserObject(in, in.readByte());
+      case USER_CLASS_2:
+        return readUserObject(in, in.readShort());
+      case USER_CLASS_4:
+        return readUserObject(in, in.readInt());
+      case VECTOR:
+        return readVector(in);
+      case STACK:
+        return readStack(in);
+      case TREE_MAP:
+        return readTreeMap(in);
+      case TREE_SET:
+        return readTreeSet(in);
+      case BOOLEAN_TYPE:
+        return Boolean.TYPE;
+      case CHARACTER_TYPE:
+        return Character.TYPE;
+      case BYTE_TYPE:
+        return Byte.TYPE;
+      case SHORT_TYPE:
+        return Short.TYPE;
+      case INTEGER_TYPE:
+        return Integer.TYPE;
+      case LONG_TYPE:
+        return Long.TYPE;
+      case FLOAT_TYPE:
+        return Float.TYPE;
+      case DOUBLE_TYPE:
+        return Double.TYPE;
+      case VOID_TYPE:
+        return Void.TYPE;
-    case USER_DATA_SERIALIZABLE:
-      return readUserDataSerializable(in, in.readByte());
-    case USER_DATA_SERIALIZABLE_2:
-      return readUserDataSerializable(in, in.readShort());
-    case USER_DATA_SERIALIZABLE_4:
-      return readUserDataSerializable(in, in.readInt());
+      case USER_DATA_SERIALIZABLE:
+        return readUserDataSerializable(in, in.readByte());
+      case USER_DATA_SERIALIZABLE_2:
+        return readUserDataSerializable(in, in.readShort());
+      case USER_DATA_SERIALIZABLE_4:
+        return readUserDataSerializable(in, in.readInt());
-    case DATA_SERIALIZABLE:
-      return readDataSerializable(in);
+      case DATA_SERIALIZABLE:
+        return readDataSerializable(in);
-    case SERIALIZABLE: {
-      final boolean isDebugEnabled_SERIALIZER = logger.isTraceEnabled(LogMarker.SERIALIZER);
-      Object serializableResult = null;
-      if (in instanceof DSObjectInputStream) {
-        serializableResult = ((DSObjectInputStream)in).readObject();
-      } else {
-        InputStream stream;
-        if (in instanceof InputStream) {
-          stream = (InputStream)in;
+      case SERIALIZABLE: {
+        final boolean isDebugEnabled_SERIALIZER = logger.isTraceEnabled(LogMarker.SERIALIZER);
+        Object serializableResult = null;
+        if (in instanceof DSObjectInputStream) {
+          serializableResult = ((DSObjectInputStream) in).readObject();
-          stream = new InputStream() {
-            @Override
+          InputStream stream;
+          if (in instanceof InputStream) {
+            stream = (InputStream) in;
+          } else {
+            stream = new InputStream() {
+              @Override
-        }
+          }
-        ObjectInput ois = new DSObjectInputStream(stream);
-        if ( stream instanceof VersionedDataStream ) {
-          Version v = ((VersionedDataStream)stream).getVersion();
-          if (v != null && v != Version.CURRENT) { 
-            ois = new VersionedObjectInput(ois, v);
+          ObjectInput ois = new DSObjectInputStream(stream);
+          if (stream instanceof VersionedDataStream) {
+            Version v = ((VersionedDataStream) stream).getVersion();
+            if (v != null && v != Version.CURRENT) {
+              ois = new VersionedObjectInput(ois, v);
+            }
+          }
+
+          serializableResult = ois.readObject();
+
+          if (isDebugEnabled_SERIALIZER) {
+            logger.trace(LogMarker.SERIALIZER, "Read Serializable object: {}", serializableResult);
-
-        serializableResult = ois.readObject();
-        
-          logger.trace(LogMarker.SERIALIZER, "Read Serializable object: {}", serializableResult);
+          logger.trace(LogMarker.SERIALIZER, "deserialized instanceof {}",
+              serializableResult.getClass());
+        return serializableResult;
-      if (isDebugEnabled_SERIALIZER) {
-        logger.trace(LogMarker.SERIALIZER, "deserialized instanceof {}", serializableResult.getClass());
-      }
-      return serializableResult;
-    }
-    default:
-      String s = "Unknown header byte: " + header;
-      throw new IOException(s);
+      default:
+        String s = "Unknown header byte: " + header;
+        throw new IOException(s);
-    throws IOException, ClassNotFoundException {
-    Instantiator instantiator =
-      InternalInstantiator.getInstantiator(classId);
+      throws IOException, ClassNotFoundException {
+    Instantiator instantiator = InternalInstantiator.getInstantiator(classId);
-      logger.error(LogMarker.SERIALIZER, LocalizedMessage.create(LocalizedStrings.DataSerializer_NO_INSTANTIATOR_HAS_BEEN_REGISTERED_FOR_CLASS_WITH_ID_0, classId));
-      throw new IOException(LocalizedStrings.DataSerializer_NO_INSTANTIATOR_HAS_BEEN_REGISTERED_FOR_CLASS_WITH_ID_0.toLocalizedString(classId));
+      logger.error(LogMarker.SERIALIZER,
+          LocalizedMessage.create(
+              LocalizedStrings.DataSerializer_NO_INSTANTIATOR_HAS_BEEN_REGISTERED_FOR_CLASS_WITH_ID_0,
+              classId));
+      throw new IOException(
+          LocalizedStrings.DataSerializer_NO_INSTANTIATOR_HAS_BEEN_REGISTERED_FOR_CLASS_WITH_ID_0
+              .toLocalizedString(classId));
-          CanonicalInstantiator ci = (CanonicalInstantiator)instantiator;
+          CanonicalInstantiator ci = (CanonicalInstantiator) instantiator;
-        SerializationException ex2 = new SerializationException(LocalizedStrings.DataSerializer_COULD_NOT_DESERIALIZE_AN_INSTANCE_OF_0.toLocalizedString(instantiator.getInstantiatedClass().getName()), ex);
+        SerializationException ex2 = new SerializationException(
+            LocalizedStrings.DataSerializer_COULD_NOT_DESERIALIZE_AN_INSTANCE_OF_0
+                .toLocalizedString(instantiator.getInstantiatedClass().getName()),
+            ex);
+
+
-  
-  public final static boolean writePdx(DataOutput out, GemFireCacheImpl gfc,
-      Object pdx, PdxSerializer pdxSerializer) throws IOException {
+
+  public final static boolean writePdx(DataOutput out, GemFireCacheImpl gfc, Object pdx,
+      PdxSerializer pdxSerializer) throws IOException {
-        //Hack to make sure we don't pass internal objects to the user's 
-        //serializer
-        if(isGemfireObject(pdx)) {
+        // Hack to make sure we don't pass internal objects to the user's
+        // serializer
+        if (isGemfireObject(pdx)) {
-      //Serializing a PDX can result in a cache closed exception. Just rethrow
+      // Serializing a PDX can result in a cache closed exception. Just rethrow
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-        throw new ToDataException("PdxSerializer failed when calling toData on " + pdx.getClass(),  t);
+        throw new ToDataException("PdxSerializer failed when calling toData on " + pdx.getClass(),
+            t);
-        throw new ToDataException("toData failed on PdxSerializable " + pdx.getClass(),  t);
+        throw new ToDataException("toData failed on PdxSerializable " + pdx.getClass(), t);
-    
-    GemFireCacheImpl gfc = GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed.");
+
+    GemFireCacheImpl gfc = GemFireCacheImpl
+        .getForPdx("PDX registry is unavailable because the Cache has been closed.");
-    
+
-    dmStats.incPdxDeserialization(len+9);
-    
+    dmStats.incPdxDeserialization(len + 9);
+
-//      if (logger.isDebugEnabled()) {
-//        gfc.getLogger().info("returning PdxInstance", new Exception("stack trace"));
-//      }
+      // if (logger.isDebugEnabled()) {
+      // gfc.getLogger().info("returning PdxInstance", new Exception("stack trace"));
+      // }
-//      if (logger.isDebugEnabled()) {
-//        gfc.getLogger().info("returning domain object", new Exception("stack trace"));
-//      }
+      // if (logger.isDebugEnabled()) {
+      // gfc.getLogger().info("returning domain object", new Exception("stack trace"));
+      // }
-    } 
+    }
+
-   * Reads a PdxInstance from dataBytes and returns it. If the first object
-   * read is not pdx encoded returns null.
+   * Reads a PdxInstance from dataBytes and returns it. If the first object read is not pdx encoded
+   * returns null.
-        //gfc.getLogger().info("logger.isDebugEnabled(): pdxType="+ pdxType);
+        // gfc.getLogger().info("logger.isDebugEnabled(): pdxType="+ pdxType);
-  /////////////////////////////   START Test only methods /////////////////////////////
+  ///////////////////////////// START Test only methods /////////////////////////////
-  /////////////////////////////   END Test only methods /////////////////////////////
+  ///////////////////////////// END Test only methods /////////////////////////////
-  ///////////////////////  Inner Classes  ///////////////////////
+  /////////////////////// Inner Classes ///////////////////////
-   * A marker object for <Code>DataSerializer</code>s that have not
-   * been registered.  Using this marker object allows us to
-   * asynchronously send <Code>DataSerializer</code> registration
-   * updates.  If the serialized bytes arrive at a VM before the
-   * registration message does, the deserializer will wait an amount
-   * of time for the registration message to arrive.
+   * A marker object for <Code>DataSerializer</code>s that have not been registered. Using this
+   * marker object allows us to asynchronously send <Code>DataSerializer</code> registration
+   * updates. If the serialized bytes arrive at a VM before the registration message does, the
+   * deserializer will wait an amount of time for the registration message to arrive.
-    
+
-     * Sets the serializer associated with this marker.  It will
-     * notify any threads that are waiting for the serializer to be
-     * registered.
+     * Sets the serializer associated with this marker. It will notify any threads that are waiting
+     * for the serializer to be registered.
-   * A marker object for <Code>DataSerializer</code>s that have not
-   * been registered.  Using this marker object allows us to
-   * asynchronously send <Code>DataSerializer</code> registration
-   * updates.  If the serialized bytes arrive at a VM before the
-   * registration message does, the deserializer will wait an amount
-   * of time for the registration message to arrive.
-   * Made public for unit test access.
+   * A marker object for <Code>DataSerializer</code>s that have not been registered. Using this
+   * marker object allows us to asynchronously send <Code>DataSerializer</code> registration
+   * updates. If the serialized bytes arrive at a VM before the registration message does, the
+   * deserializer will wait an amount of time for the registration message to arrive. Made public
+   * for unit test access.
+   * 
-     * Number of milliseconds to wait. Also used by InternalInstantiator.
-     * Note that some tests set this to a small amount to speed up failures.
-     * Made public for unit test access.
+     * Number of milliseconds to wait. Also used by InternalInstantiator. Note that some tests set
+     * this to a small amount to speed up failures. Made public for unit test access.
-    public static int WAIT_MS = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "InternalDataSerializer.WAIT_MS", 60 * 1000);
+    public static int WAIT_MS = Integer.getInteger(
+        DistributionConfig.GEMFIRE_PREFIX + "InternalDataSerializer.WAIT_MS", 60 * 1000);
-     * Returns the serializer associated with this marker.  If the
-     * serializer has not been registered yet, then this method will
-     * wait until the serializer is registered.  If this method has to
+     * Returns the serializer associated with this marker. If the serializer has not been registered
+     * yet, then this method will wait until the serializer is registered. If this method has to
-//               if (!this.hasBeenSet) {
-//                 logger.info("logger.isDebugEnabled() getSerializer had to wait for " + remainingMs + "ms",
-//                             new Exception("STACK"));
-//               }
+              // if (!this.hasBeenSet) {
+              // logger.info("logger.isDebugEnabled() getSerializer had to wait for " + remainingMs
+              // + "ms",
+              // new Exception("STACK"));
+              // }
-   * A marker object for <Code>DataSerializer</code>s that is in the process
-   * of being registered.
-   * It is possible for getSerializer to return <code>null</code>
+   * A marker object for <Code>DataSerializer</code>s that is in the process of being registered. It
+   * is possible for getSerializer to return <code>null</code>
-     * Returns the serializer associated with this marker.  If the
-     * serializer has not been registered yet, then this method will
-     * wait until the serializer is registered.  If this method has to
+     * Returns the serializer associated with this marker. If the serializer has not been registered
+     * yet, then this method will wait until the serializer is registered. If this method has to
-     * Returns the serializer associated with this marker.
-     * Waits forever (unless interrupted) for it to be initialized.
-     * Returns null if this Marker failed to initialize.
+     * Returns the serializer associated with this marker. Waits forever (unless interrupted) for it
+     * to be initialized. Returns null if this Marker failed to initialize.
-   * A distribution message that alerts other members of the
-   * distributed cache of a new <code>DataSerializer</code> being
-   * registered.
+   * A distribution message that alerts other members of the distributed cache of a new
+   * <code>DataSerializer</code> being registered.
-    /** The id of the <code>DataSerializer</code> that was
-     * registered
-     * since 5.7 an int instead of a byte
+    /**
+     * The id of the <code>DataSerializer</code> that was registered since 5.7 an int instead of a
+     * byte
-    /** The eventId of the <codE>DataSerializer</code> that was
-     * registered */
+    /**
+     * The eventId of the <codE>DataSerializer</code> that was registered
+     */
-    
+
-    private static final Version[] dsfidVersions = new Version[]{};
+    private static final Version[] dsfidVersions = new Version[] {};
-     * Creates a new <code>RegistrationMessage</code> that broadcasts
-     * that the given <code>DataSerializer</code> was registered.
+     * Creates a new <code>RegistrationMessage</code> that broadcasts that the given
+     * <code>DataSerializer</code> was registered.
-      this.eventId = (EventID)s.getEventId();
+      this.eventId = (EventID) s.getEventId();
-    
+
-    
-    
-    
+
+
+
-          logger.warn("Could not load data serializer class {} so both clients of this server and this server will not have this data serializer. Load failed because: {}",
+          logger.warn(
+              "Could not load data serializer class {} so both clients of this server and this server will not have this data serializer. Load failed because: {}",
-          logger.warn("Could not create an instance of data serializer for class {} so both clients of this server and this server will not have this data serializer. Create failed because: {}",
+          logger.warn(
+              "Could not create an instance of data serializer for class {} so both clients of this server and this server will not have this data serializer. Create failed because: {}",
-          logger.warn("Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}",
+          logger.warn(
+              "Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}",
-          logger.warn("Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}",
+          logger.warn(
+              "Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}",
-          logger.warn("Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}",
+          logger.warn(
+              "Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}",
-          logger.warn("Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}",
+          logger.warn(
+              "Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}",
-     }
+      }
-    
+
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.eventId = (EventID)DataSerializer.readObject(in);
+      this.eventId = (EventID) DataSerializer.readObject(in);
-      .toLocalizedString(new Object[]{Integer.valueOf(this.id), this.className});
+          .toLocalizedString(new Object[] {Integer.valueOf(this.id), this.className});
-   * A listener whose listener methods are invoked when {@link
-   * DataSerializer}s and {@link Instantiator}s are registered.  This
-   * is part of the fix for bug 31422.
+   * A listener whose listener methods are invoked when {@link DataSerializer}s and
+   * {@link Instantiator}s are registered. This is part of the fix for bug 31422.
-     * Invoked when a new <code>Instantiator</code> is {@linkplain
-     * Instantiator#register(Instantiator) registered}.
+     * Invoked when a new <code>Instantiator</code> is
+     * {@linkplain Instantiator#register(Instantiator) registered}.
-     * Invoked when a new <code>DataSerializer</code> is {@linkplain
-     * DataSerializer#register(Class) registered}.
+     * Invoked when a new <code>DataSerializer</code> is {@linkplain DataSerializer#register(Class)
+     * registered}.
-   * An <code>ObjectInputStream</code> whose {@link #resolveClass}
-   * method loads classes from the current context class loader.
+   * An <code>ObjectInputStream</code> whose {@link #resolveClass} method loads classes from the
+   * current context class loader.
-     * Creates a new <code>DSObjectInputStream</code> that delegates
-     * its behavior to a given <code>InputStream</code>.
+     * Creates a new <code>DSObjectInputStream</code> that delegates its behavior to a given
+     * <code>InputStream</code>.
-      throws IOException, ClassNotFoundException {
+        throws IOException, ClassNotFoundException {
-     try {
-       Class clazz = getCachedClass(className);
-       return clazz;
+      try {
+        Class clazz = getCachedClass(className);
+        return clazz;
-      throws IOException, ClassNotFoundException {
+        throws IOException, ClassNotFoundException {
-        Class cl =
-          getCachedClass(interfaces[i]);
+        Class cl = getCachedClass(interfaces[i]);
-              String s =
-                "conflicting non-public interface class loaders";
+              String s = "conflicting non-public interface class loaders";
-//   /**
-//    * A <code>DataOutput</code> that writes special header information
-//    * before it writes any other data.  It is passed to a
-//    * <code>DataSerializer</code>'s {@link
-//    * DataSerializer#toData(Object, DataOutput)} method to ensure
-//    * that the stream has the correct format.
-//    */
-//   private static class DSDataOutput implements DataOutput {
-//     /** Has the header information been written? */
-//     private boolean headerWritten = false;
+  // /**
+  // * A <code>DataOutput</code> that writes special header information
+  // * before it writes any other data. It is passed to a
+  // * <code>DataSerializer</code>'s {@link
+  // * DataSerializer#toData(Object, DataOutput)} method to ensure
+  // * that the stream has the correct format.
+  // */
+  // private static class DSDataOutput implements DataOutput {
+  // /** Has the header information been written? */
+  // private boolean headerWritten = false;
-//     /** The id of serializer that is writing to this output */
-//     private byte serializerId;
+  // /** The id of serializer that is writing to this output */
+  // private byte serializerId;
-//     /** The output stream to which this DSDataOutput writes */
-//     protected DataOutput out;
+  // /** The output stream to which this DSDataOutput writes */
+  // protected DataOutput out;
-//     //////////////////////  Constructors  //////////////////////
+  // ////////////////////// Constructors //////////////////////
-//     /**
-//      * Creates a new <code>DSDataOutput</code> that write to the
-//      * given output stream.
-//      */
-//     DSDataOutput(DataOutput out) {
-//       this.out = out;
-//     }
+  // /**
+  // * Creates a new <code>DSDataOutput</code> that write to the
+  // * given output stream.
+  // */
+  // DSDataOutput(DataOutput out) {
+  // this.out = out;
+  // }
-//     /////////////////////  Instance Methods  ////////////////////
+  // ///////////////////// Instance Methods ////////////////////
-//     /**
-//      * Sets the id of the serializer that will possibly write to
-//      * this stream.
-//      */
-//     void setSerializerId(byte id) {
-//       this.serializerId = id;
-//     }
+  // /**
+  // * Sets the id of the serializer that will possibly write to
+  // * this stream.
+  // */
+  // void setSerializerId(byte id) {
+  // this.serializerId = id;
+  // }
-//     /**
-//      * Returns whether or not any data hass been written to this
-//      * stream.
-//      */
-//     boolean hasWritten() {
-//       return this.headerWritten;
-//     }
+  // /**
+  // * Returns whether or not any data hass been written to this
+  // * stream.
+  // */
+  // boolean hasWritten() {
+  // return this.headerWritten;
+  // }
-//     /**
-//      * Write the {@link #USER_CLASS} "class id" followed by the id
-//      * of the serializer.
-//      */
-//     private void writeHeader() throws IOException {
-//       if (!headerWritten) {
-//         out.writeByte(USER_CLASS);
-//         out.writeByte(serializerId);
-//         this.headerWritten = true;
-//       }
-//     }
+  // /**
+  // * Write the {@link #USER_CLASS} "class id" followed by the id
+  // * of the serializer.
+  // */
+  // private void writeHeader() throws IOException {
+  // if (!headerWritten) {
+  // out.writeByte(USER_CLASS);
+  // out.writeByte(serializerId);
+  // this.headerWritten = true;
+  // }
+  // }
-//     public void write(int b) throws IOException {
-//       writeHeader();
-//       out.write(b);
-//     }
+  // public void write(int b) throws IOException {
+  // writeHeader();
+  // out.write(b);
+  // }
-//     public void write(byte[] b) throws IOException {
-//       writeHeader();
-//       out.write(b);
-//     }
+  // public void write(byte[] b) throws IOException {
+  // writeHeader();
+  // out.write(b);
+  // }
-//     public void write(byte[] b, int off, int len)
-//       throws IOException {
-//       writeHeader();
-//       out.write(b, off, len);
-//     }
+  // public void write(byte[] b, int off, int len)
+  // throws IOException {
+  // writeHeader();
+  // out.write(b, off, len);
+  // }
-//     public void writeBoolean(boolean v) throws IOException {
-//       writeHeader();
-//       out.writeBoolean(v);
-//     }
+  // public void writeBoolean(boolean v) throws IOException {
+  // writeHeader();
+  // out.writeBoolean(v);
+  // }
-//     public void writeByte(int v) throws IOException {
-//       writeHeader();
-//       out.writeByte(v);
-//     }
+  // public void writeByte(int v) throws IOException {
+  // writeHeader();
+  // out.writeByte(v);
+  // }
-//     public void writeShort(int v) throws IOException {
-//       writeHeader();
-//       out.writeShort(v);
-//     }
+  // public void writeShort(int v) throws IOException {
+  // writeHeader();
+  // out.writeShort(v);
+  // }
-//     public void writeChar(int v) throws IOException {
-//       writeHeader();
-//       out.writeChar(v);
-//     }
+  // public void writeChar(int v) throws IOException {
+  // writeHeader();
+  // out.writeChar(v);
+  // }
-//     public void writeInt(int v) throws IOException {
-//       writeHeader();
-//       out.writeInt(v);
-//     }
+  // public void writeInt(int v) throws IOException {
+  // writeHeader();
+  // out.writeInt(v);
+  // }
-//     public void writeLong(long v) throws IOException {
-//       writeHeader();
-//       out.writeLong(v);
-//     }
+  // public void writeLong(long v) throws IOException {
+  // writeHeader();
+  // out.writeLong(v);
+  // }
-//     public void writeFloat(float v) throws IOException {
-//       writeHeader();
-//       out.writeFloat(v);
-//     }
+  // public void writeFloat(float v) throws IOException {
+  // writeHeader();
+  // out.writeFloat(v);
+  // }
-//     public void writeDouble(double v) throws IOException {
-//       writeHeader();
-//       out.writeDouble(v);
-//     }
+  // public void writeDouble(double v) throws IOException {
+  // writeHeader();
+  // out.writeDouble(v);
+  // }
-//     public void writeBytes(String s) throws IOException {
-//       writeHeader();
-//       out.writeBytes(s);
-//     }
+  // public void writeBytes(String s) throws IOException {
+  // writeHeader();
+  // out.writeBytes(s);
+  // }
-//     public void writeChars(String s) throws IOException {
-//       writeHeader();
-//       out.writeChars(s);
-//     }
+  // public void writeChars(String s) throws IOException {
+  // writeHeader();
+  // out.writeChars(s);
+  // }
-//     public void writeUTF(String str) throws IOException {
-//       writeHeader();
-//       out.writeUTF(str);
-//     }
+  // public void writeUTF(String str) throws IOException {
+  // writeHeader();
+  // out.writeUTF(str);
+  // }
-//   }
+  // }
-   * Used to implement serialization code for the well known classes we support
-   * in DataSerializer.
+   * Used to implement serialization code for the well known classes we support in DataSerializer.
+   * 
+
+
-  
+
-    throws IOException {
+      throws IOException {
-  
+
-   * Write a variable length long the old way (pre 7.0). Use this
-   * only in contexts where you might need to communicate with pre 7.0
-   * members or files.
+   * Write a variable length long the old way (pre 7.0). Use this only in contexts where you might
+   * need to communicate with pre 7.0 members or files.
-    if(data < 0) {
+    if (data < 0) {
-   * Write a variable length long the old way (pre 7.0). Use this
-   * only in contexts where you might need to communicate with pre 7.0
-   * members or files.
+   * Write a variable length long the old way (pre 7.0). Use this only in contexts where you might
+   * need to communicate with pre 7.0 members or files.
-  
+
-   * Encode a long as a variable length array. 
+   * Encode a long as a variable length array.
-   * This method is appropriate for unsigned integers. For signed integers,
-   * negative values will always consume 10 bytes, so it is recommended to
-   * use writeSignedVL instead.
+   * This method is appropriate for unsigned integers. For signed integers, negative values will
+   * always consume 10 bytes, so it is recommended to use writeSignedVL instead.
-   * This is taken from the varint encoding in protobufs (BSD licensed).
-   * See https://developers.google.com/protocol-buffers/docs/encoding
+   * This is taken from the varint encoding in protobufs (BSD licensed). See
+   * https://developers.google.com/protocol-buffers/docs/encoding
-        out.writeByte((int)data);
+        out.writeByte((int) data);
-        out.writeByte(((int)data & 0x7F) | 0x80);
+        out.writeByte(((int) data & 0x7F) | 0x80);
-  
+
-   * Decode a long as a variable length array. 
+   * Decode a long as a variable length array.
-   * This is taken from the varint encoding in protobufs (BSD licensed).
-   * See https://developers.google.com/protocol-buffers/docs/encoding
+   * This is taken from the varint encoding in protobufs (BSD licensed). See
+   * https://developers.google.com/protocol-buffers/docs/encoding
-      result |= (long)(b & 0x7F) << shift;
+      result |= (long) (b & 0x7F) << shift;
-  
+
-   * Encode a signed long as a variable length array. 
+   * Encode a signed long as a variable length array.
-   * This method is appropriate for signed integers. It uses
-   * zig zag encoding to so that negative numbers will be respresented more
-   * compactly. For unsigned values, writeUnsignedVL will be more efficient. 
+   * This method is appropriate for signed integers. It uses zig zag encoding to so that negative
+   * numbers will be respresented more compactly. For unsigned values, writeUnsignedVL will be more
+   * efficient.
-  
+
-   * Decode a signed long as a variable length array. 
+   * Decode a signed long as a variable length array.
-   * This method is appropriate for signed integers. It uses
-   * zig zag encoding to so that negative numbers will be respresented more
-   * compactly. For unsigned values, writeUnsignedVL will be more efficient. 
+   * This method is appropriate for signed integers. It uses zig zag encoding to so that negative
+   * numbers will be respresented more compactly. For unsigned values, writeUnsignedVL will be more
+   * efficient.
-   * Decode a ZigZag-encoded 64-bit value.  ZigZag encodes signed integers
-   * into values that can be efficiently encoded with varint.  (Otherwise,
-   * negative values must be sign-extended to 64 bits to be varint encoded,
-   * thus always taking 10 bytes on the wire.)
+   * Decode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be
+   * efficiently encoded with varint. (Otherwise, negative values must be sign-extended to 64 bits
+   * to be varint encoded, thus always taking 10 bytes on the wire.)
-   * @param n An unsigned 64-bit integer, stored in a signed int because
-   *          Java has no explicit unsigned support.
+   * @param n An unsigned 64-bit integer, stored in a signed int because Java has no explicit
+   *        unsigned support.
-   * This is taken from the varint encoding in protobufs (BSD licensed).
-   * See https://developers.google.com/protocol-buffers/docs/encoding
+   *         This is taken from the varint encoding in protobufs (BSD licensed). See
+   *         https://developers.google.com/protocol-buffers/docs/encoding
-   * Encode a ZigZag-encoded 64-bit value.  ZigZag encodes signed integers
-   * into values that can be efficiently encoded with varint.  (Otherwise,
-   * negative values must be sign-extended to 64 bits to be varint encoded,
-   * thus always taking 10 bytes on the wire.)
+   * Encode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be
+   * efficiently encoded with varint. (Otherwise, negative values must be sign-extended to 64 bits
+   * to be varint encoded, thus always taking 10 bytes on the wire.)
-   * @return An unsigned 64-bit integer, stored in a signed int because
-   *         Java has no explicit unsigned support.
-   *         
-   * This is taken from the varint encoding in protobufs (BSD licensed).
-   * See https://developers.google.com/protocol-buffers/docs/encoding
+   * @return An unsigned 64-bit integer, stored in a signed int because Java has no explicit
+   *         unsigned support.
+   * 
+   *         This is taken from the varint encoding in protobufs (BSD licensed). See
+   *         https://developers.google.com/protocol-buffers/docs/encoding
-    // Note:  the right-shift must be arithmetic
+    // Note: the right-shift must be arithmetic
-  public static final boolean LOAD_CLASS_EACH_TIME = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "loadClassOnEveryDeserialization");
-  private static final CopyOnWriteHashMap<String, WeakReference<Class<?>>> classCache = LOAD_CLASS_EACH_TIME ? null : new CopyOnWriteHashMap<String, WeakReference<Class<?>>>();
+  public static final boolean LOAD_CLASS_EACH_TIME =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "loadClassOnEveryDeserialization");
+  private static final CopyOnWriteHashMap<String, WeakReference<Class<?>>> classCache =
+      LOAD_CLASS_EACH_TIME ? null : new CopyOnWriteHashMap<String, WeakReference<Class<?>>>();
-  
+
+

GEODE-5535: Upgrade FastClasspathScanner to 4.0.6 (#2310)

- Use less memory for scanning by reusing a single
  instance of ClassGraph.
-import java.lang.reflect.Modifier;
-import java.util.HashSet;
+import java.util.Arrays;
+import java.util.Collection;
-import io.github.lukehutch.fastclasspathscanner.FastClasspathScanner;
-
+import io.github.classgraph.ClassGraph;
+import io.github.classgraph.ClassInfoList;
+import io.github.classgraph.ScanResult;
-  public static Set<Class<?>> scanPackagesForClassesImplementing(Class<?> implementedInterface,
-      String... packagesToScan) {
-    Set<Class<?>> classesImplementing = new HashSet<>();
-    new FastClasspathScanner(packagesToScan)
-        .matchClassesImplementing(implementedInterface, classesImplementing::add).scan();
-    return classesImplementing.stream().filter(ClasspathScanLoadHelper::isInstantiable)
-        .collect(toSet());
+  private final ScanResult scanResult;
+
+  public ClasspathScanLoadHelper(Collection<String> packagesToScan) {
+    scanResult = new ClassGraph().whitelistPackages(packagesToScan.toArray(new String[] {}))
+        .enableClassInfo()
+        .enableAnnotationInfo().scan();
-  public static Set<Class<?>> scanClasspathForAnnotation(Class<?> annotation,
-      String... packagesToScan) {
-    Set<Class<?>> classesWithAnnotation = new HashSet<>();
-    new FastClasspathScanner(packagesToScan)
-        .matchClassesWithAnnotation(annotation, classesWithAnnotation::add).scan();
-    return classesWithAnnotation;
+  public Set<Class<?>> scanPackagesForClassesImplementing(Class<?> implementedInterface,
+      String... onlyFromPackages) {
+    ClassInfoList classInfoList = scanResult.getClassesImplementing(implementedInterface.getName())
+        .filter(ci -> !ci.isAbstract() && !ci.isInterface() && ci.isPublic());
+
+    classInfoList = classInfoList
+        .filter(ci -> Arrays.stream(onlyFromPackages).anyMatch(p -> ci.getName().startsWith(p)));
+
+    return classInfoList.loadClasses().stream().collect(toSet());
-  private static boolean isInstantiable(Class<?> klass) {
-    int modifiers = klass.getModifiers();
+  public Set<Class<?>> scanClasspathForAnnotation(Class<?> annotation, String... onlyFromPackages) {
+    ClassInfoList classInfoList = scanResult.getClassesWithAnnotation(annotation.getName());
-    return !Modifier.isAbstract(modifiers) && !Modifier.isInterface(modifiers)
-        && Modifier.isPublic(modifiers);
+    classInfoList = classInfoList
+        .filter(ci -> Arrays.stream(onlyFromPackages).anyMatch(p -> ci.getName().startsWith(p)));
+
+    return classInfoList.loadClasses().stream().collect(toSet());
+

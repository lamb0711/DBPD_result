GEODE-7171: Encapsulate metrics session (#4203)

Metrics session responsibilities are starting to appear in too many
parts of Geode. This change encapsulates those responsibilities into a
single class.

Changes to core Geode classes:

- GemFireCacheImpl no longer holds a meter registry or the set of "user"
  registries added by the cache builder.

- InternalCacheBuilder no longer constructs objects on behalf of the
  metrics session.  Instead, it gathers meter registries and other
  details into a MetricsService.Builder, which it passes to the
  InternalDistributedSystem.Builder.

- InternalDistributedSystem no longer knows about client meter
  registries. Instead, it holds a MetricsService, which remembers its
  builder.  During reconnect, the InternalDistributedSystem retrieves
  the builder from its metrics service, and uses the builder to build
  a similar metrics service in the reconnected system.

New classes and interfaces (org.apache.geode.metrics.internal):

- StandardMeterBinder
  - Binds standard meter binders to the meter registry.
  - close() closes the closeable binders, freeing their resources.

- MetricsService interface
  - Extends MetricsSession.
  - Adds methods to start and stop the service, and to access the
    service's meter registry.
  - Adds a method that returns the builder that built the metrics
    service, so that reconnect can use the same builder to build the
    metrics service for the reconnected system.

- InternalDistributedSystemMetricsService
  - Implements MetricsService.
  - Creates and retains a composite meter registry to manage meters.
  - Configures the composite composite registry:
    - Adds common tags that describe the system
    - Adds client meter registries to the composite.
    - Applies a StandardMeterBinder to add standard meters to the
      registry.
  - Discovers, starts, and stops metrics publishing services.
  - Adds and removes sub-registries as instructed by publishing
    services.
  - When stopped, stops each publishing service, closes all closeable
    meter binders, removes all sub-registries, and closes its composite
    meter registry.

- MetricsService.Builder interface

- InternalDistriburtedSystemMetricsService.Builder
  - Implements MetricsService.Builder
  - Accumulates and retains constructor parameters for the eventual
    InternalDistributedSystemMetricsService.
  - In particular, maintains a collection of meter registries added by
    the cache builder. It calls these 'persistent' registries, because
    they will persist across reconnects.

Other changes:

- Added MetricsSession parameter to MetricsPublishingService.stop().

Authored-by: Dale Emery <demery@pivotal.io>
+import org.apache.geode.metrics.internal.MetricsService;
+  private MetricsService metricsService;
-  /** services provided by other modules */
+  /**
+   * services provided by other modules
+   */
-      SecurityConfig securityConfig) {
+      SecurityConfig securityConfig, MetricsService.Builder metricsSessionBuilder) {
-      return new Builder(config)
+      return new Builder(config, metricsSessionBuilder)
-      InternalDistributedSystem newSystem = new Builder(config)
+      InternalDistributedSystem newSystem = new Builder(config, metricsSessionBuilder)
-  private final Set<DisconnectListener> disconnectListeners = new LinkedHashSet<>(); // needs to be
-                                                                                     // ordered
+  private final Set<DisconnectListener> disconnectListeners = new LinkedHashSet<>();
-  // needs to be ordered
-    ((DistributionConfigImpl) originalConfig).checkForDisallowedDefaults(); // throws
-                                                                            // IllegalStateEx
+    // throws IllegalStateEx
+    ((DistributionConfigImpl) originalConfig).checkForDisallowedDefaults();
-  private void initialize(SecurityManager securityManager, PostProcessor postProcessor) {
+  private void initialize(SecurityManager securityManager, PostProcessor postProcessor,
+      MetricsService.Builder metricsServiceBuilder) {
-            "This thread is initializing a new DistributedSystem in order to reconnect to other members");
+            "This thread is initializing a new DistributedSystem in order to reconnect to other "
+                + "members");
-                "System memory appears to be over committed by {} bytes.  You may experience instability, performance issues, or terminated processes due to the Linux OOM killer.",
+                "System memory appears to be over committed by {} bytes.  You may experience "
+                    + "instability, performance issues, or terminated processes due to the Linux "
+                    + "OOM killer.",
-                    "Insufficient free memory (%s) when attempting to lock %s bytes.  Either reduce the amount of heap or off-heap memory requested or free up additional system memory.  You may also specify -Dgemfire.Cache.ALLOW_MEMORY_OVERCOMMIT=true on the command-line to override the constraint check.",
+                    "Insufficient free memory (%s) when attempting to lock %s bytes.  Either "
+                        + "reduce the amount of heap or off-heap memory requested or free up "
+                        + "additional system memory.  You may also specify -Dgemfire.Cache"
+                        + ".ALLOW_MEMORY_OVERCOMMIT=true on the command-line to override the "
+                        + "constraint check.",
+      metricsService = metricsServiceBuilder.build(this);
+      metricsService.start();
+
+  public MeterRegistry getMeterRegistry() {
+    return metricsService.getMeterRegistry();
+  }
+
-                                                  // closing the cache
+            // closing the cache
+      metricsService.stop();
-     *
-    Set<MeterRegistry> meterRegistries = null;
-      meterRegistries = cache.getMeterSubregistries();
-                  "Stopping the checkrequiredrole thread because reconnect : {} reached the max number of reconnect tries : {}",
+                  "Stopping the checkrequiredrole thread because reconnect : {} reached the max "
+                      + "number of reconnect tries : {}",
-
-            newDS = (InternalDistributedSystem) connect(configProps);
+            newDS = connectInternal(configProps, null, metricsService.getRebuilder());
-
-                InternalCacheBuilder cacheBuilder = new InternalCacheBuilder()
-                    .setCacheXMLDescription(cacheXML);
-                for (MeterRegistry meterRegistry : meterRegistries) {
-                  cacheBuilder.addMeterSubregistry(meterRegistry);
-                }
-                cache = cacheBuilder.create(reconnectDS);
+                cache = new InternalCacheBuilder()
+                    .setCacheXMLDescription(cacheXML)
+                    .create(reconnectDS);
-                    "Exception occurred while trying to create the cache during reconnect.  Auto-reconnect is terminating.",
+                    "Exception occurred while trying to create the cache during reconnect.  "
+                        + "Auto-reconnect is terminating.",
-   *
-                "A connection to a distributed system already exists in this VM.  It has the following configuration:%s",
+                "A connection to a distributed system already exists in this VM.  It has the "
+                    + "following configuration:%s",
-                "A connection to a distributed system already exists in this VM.  It has the following configuration:%s",
+                "A connection to a distributed system already exists in this VM.  It has the "
+                    + "following configuration:%s",
+    private MetricsService.Builder metricsServiceBuilder;
-    public Builder(Properties configProperties) {
+    public Builder(Properties configProperties, MetricsService.Builder metricsServiceBuilder) {
+      this.metricsServiceBuilder = metricsServiceBuilder;
-        InternalDistributedSystem newSystem = new InternalDistributedSystem(
-            new ConnectionConfigImpl(configProperties), defaultStatisticsManagerFactory(),
-            FunctionStatsManager::new);
+        InternalDistributedSystem newSystem =
+            new InternalDistributedSystem(new ConnectionConfigImpl(
+                configProperties), defaultStatisticsManagerFactory(),
+                FunctionStatsManager::new);
-            .initialize(securityConfig.getSecurityManager(), securityConfig.getPostProcessor());
+            .initialize(securityConfig.getSecurityManager(), securityConfig.getPostProcessor(),
+                metricsServiceBuilder);
-      InternalDistributedSystem internalDistributedSystem = new InternalDistributedSystem(
-          connectionConfig, statisticsManagerFactory, FunctionStatsManager::new);
+      InternalDistributedSystem internalDistributedSystem =
+          new InternalDistributedSystem(connectionConfig, statisticsManagerFactory,
+              FunctionStatsManager::new);

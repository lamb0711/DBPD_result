GEODE-6803: be able to configure pdx using management rest api (#3638)

* Add PdxManagementController and PdxManager
* add RestEndPoint.getUri for single config object uri for HATOS, make it part of the json response
* rename RuntimeCacheElement to MultiGroupCacheElement since the only usage of it is to support multi group.
* make MultiGroupCacheElement a suplimental interface and list does not have to return MultiGroupCacheElement
* do not require servers to be present in order to create a cache element
* when realizer is not present, assuming the servers needs to be bounced in order for the config change to take effect
+import java.util.Collections;
+import org.apache.geode.cache.configuration.PdxType;
-import org.apache.geode.management.configuration.RuntimeCacheElement;
+import org.apache.geode.management.configuration.MultiGroupCacheElement;
+import org.apache.geode.management.internal.configuration.mutators.PdxManager;
-  private Map<Class, ConfigurationManager> managers;
+  private Map<Class, ConfigurationManager<? extends CacheElement>> managers;
+    managers.put(PdxType.class, new PdxManager());
-    if (targetedMembers.size() == 0) {
-      return new ClusterManagementResult(false,
-          "No members found in group '" + group + "' to create cache element");
-    }
-
+
+    // add the config object which includes the HATOS information of the element created
+    if (result.isSuccessful()) {
+      result.setResult(Collections.singletonList(config));
+    }
-  public ClusterManagementResult list(CacheElement filter) {
-    ConfigurationManager manager = managers.get(filter.getClass());
+  public <T extends CacheElement> ClusterManagementResult list(T filter) {
+    ConfigurationManager<T> manager = (ConfigurationManager<T>) managers.get(filter.getClass());
+
-      List<RuntimeCacheElement> listResults = manager.list(filter, null);
+      List<? extends T> listResults = manager.list(filter, null);
-    List<RuntimeCacheElement> resultList = new ArrayList<>();
-
-    // get a list of all the resultList from all groups that satisfy the filter criteria (all
-    // filters
-    // have been applied except the group)
+    List<T> resultList = new ArrayList<>();
-      List<RuntimeCacheElement> listInGroup = manager.list(filter, currentPersistedConfig);
-      for (RuntimeCacheElement element : listInGroup) {
-        element.getGroups().add(group);
-        int index = resultList.indexOf(element);
-        if (index >= 0) {
-          RuntimeCacheElement exist = resultList.get(index);
-          exist.getGroups().add(group);
-        } else {
+      List<? extends T> listInGroup = manager.list(filter, currentPersistedConfig);
+      for (T element : listInGroup) {
+        if (group.equals(element.getConfigGroup()) || element instanceof MultiGroupCacheElement) {
+          element.setGroup(group);
-    // filtering by group. Do this after iterating through all the groups because some region might
-    // belong to multiple groups and we want the "group" field to show that.
-    if (StringUtils.isNotBlank(filter.getGroup())) {
-      resultList =
-          resultList.stream().filter(e -> e.getGroups().contains(filter.getConfigGroup()))
-              .collect(Collectors.toList());
+    // if empty result, return immediately
+    if (resultList.size() == 0) {
+      return result;
-    // if "cluster" is the only group of the element, remove it
-    for (RuntimeCacheElement element : resultList) {
-      if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
-        element.getGroups().clear();
+    // right now the list contains [{regionA, group1}, {regionA, group2}...], if the elements are
+    // MultiGroupCacheElement, we need to consolidate the list into [{regionA, [group1, group2]}
+    if (resultList.get(0) instanceof MultiGroupCacheElement) {
+      List<MultiGroupCacheElement> multiGroupList = new ArrayList<>();
+      for (T element : resultList) {
+        int index = multiGroupList.indexOf(element);
+        if (index >= 0) {
+          MultiGroupCacheElement exist = multiGroupList.get(index);
+          exist.getGroups().add(element.getGroup());
+        } else {
+          multiGroupList.add((MultiGroupCacheElement) element);
+        }
+      }
+      if (StringUtils.isNotBlank(filter.getGroup())) {
+        multiGroupList = multiGroupList.stream()
+            .filter(e -> e.getGroups().contains(filter.getConfigGroup()))
+            .collect(Collectors.toList());
+      }
+      // if "cluster" is the only group, clear it
+      for (MultiGroupCacheElement element : multiGroupList) {
+        if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
+          element.getGroups().clear();
+        }
+      }
+      resultList =
+          (List<T>) multiGroupList.stream().map(CacheElement.class::cast)
+              .collect(Collectors.toList());
+    } else {
+      // for non-MultiGroup CacheElement, just clear out the "cluster" group
+      for (T element : resultList) {
+        if ("cluster".equals(element.getGroup())) {
+          element.setGroup(null);
+        }
-    List<RuntimeCacheElement> result = list.getResult(RuntimeCacheElement.class);
+    List<CacheElement> result = list.getResult(CacheElement.class);
+    if (targetMembers.size() == 0) {
+      return Collections.emptyList();
+    }
+

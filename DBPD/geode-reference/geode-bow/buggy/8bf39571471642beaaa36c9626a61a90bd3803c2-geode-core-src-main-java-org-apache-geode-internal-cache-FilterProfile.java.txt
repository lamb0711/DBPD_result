Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * FilterProfile represents a distributed system member and is used for
- * two purposes: processing client-bound events, and providing information
- * for profile exchanges.
+ * FilterProfile represents a distributed system member and is used for two purposes: processing
+ * client-bound events, and providing information for profile exchanges.
- * FilterProfiles represent client IDs, including durable Queue IDs, with
- * long integers.  This reduces the size of routing information when sent
- * over the network.
+ * FilterProfiles represent client IDs, including durable Queue IDs, with long integers. This
+ * reduces the size of routing information when sent over the network.
-  
+
-    REGISTER_KEY, REGISTER_KEYS, REGISTER_PATTERN, REGISTER_FILTER,
-    UNREGISTER_KEY, UNREGISTER_KEYS, UNREGISTER_PATTERN, UNREGISTER_FILTER,
-    CLEAR,
-    HAS_CQ, REGISTER_CQ, CLOSE_CQ, STOP_CQ, SET_CQ_STATE
+    REGISTER_KEY, REGISTER_KEYS, REGISTER_PATTERN, REGISTER_FILTER, UNREGISTER_KEY, UNREGISTER_KEYS, UNREGISTER_PATTERN, UNREGISTER_FILTER, CLEAR, HAS_CQ, REGISTER_CQ, CLOSE_CQ, STOP_CQ, SET_CQ_STATE
+
-   * these booleans tell whether the associated operationType pertains to CQs
-   * or not
+   * these booleans tell whether the associated operationType pertains to CQs or not
-  static boolean[] isCQOperation = {
-    false, false, false, false,
-    false, false, false, false,
-    false,
-    true, true, true, true, true
-  };
-  
+  static boolean[] isCQOperation =
+      {false, false, false, false, false, false, false, false, false, true, true, true, true, true};
+
-  
+
-   * The keys in which clients are interested. This is a map keyed on client id,
-   * with a HashSet of the interested keys as the values.
+   * The keys in which clients are interested. This is a map keyed on client id, with a HashSet of
+   * the interested keys as the values.
-  
+
-   * The patterns in which clients are interested. This is a map keyed on
-   * client id, with a HashMap (key name to compiled pattern) as the values.
+   * The patterns in which clients are interested. This is a map keyed on client id, with a HashMap
+   * (key name to compiled pattern) as the values.
-  private final Map<Object, Map<Object, Pattern>> patternsOfInterestInv = new CopyOnWriteHashMap<>();
-  
- /**
-   * The filtering classes in which clients are interested. This is a map
-   * keyed on client id, with a HashMap (key name to {@link InterestFilter})
-   * as the values.
+  private final Map<Object, Map<Object, Pattern>> patternsOfInterestInv =
+      new CopyOnWriteHashMap<>();
+
+  /**
+   * The filtering classes in which clients are interested. This is a map keyed on client id, with a
+   * HashMap (key name to {@link InterestFilter}) as the values.
-  
+
-  
+
-  
+
-    
+
-  
+
-   * since client identifiers can be long, we use a mapping for on-wire
-   * operations
+   * since client identifiers can be long, we use a mapping for on-wire operations
-  
+
-  
+
-  
+
-   * Queues the Filter Profile messages that are received during profile 
-   * exchange. 
+   * Queues the Filter Profile messages that are received during profile exchange.
-  private volatile Map<InternalDistributedMember, LinkedList<OperationMessage>> filterProfileMsgQueue = new HashMap<>();
-  
+  private volatile Map<InternalDistributedMember, LinkedList<OperationMessage>> filterProfileMsgQueue =
+      new HashMap<>();
+
-  
+
-   * used for instantiation of a profile associated with a region and
-   * not describing region filters in a different process.  Do not use
-   * this method when instantiating profiles to store in distribution
-   * advisor profiles.
+   * used for instantiation of a profile associated with a region and not describing region filters
+   * in a different process. Do not use this method when instantiating profiles to store in
+   * distribution advisor profiles.
+   * 
-  public static boolean isCqOp(operationType opType){
+  public static boolean isCqOp(operationType opType) {
-  
+
-   * @param inputClientID 
-   *          The identity of the interested client
-   * @param interest
-   *          The key in which to register interest
+   * @param inputClientID The identity of the interested client
+   * @param interest The key in which to register interest
-   * @param updatesAsInvalidates
-   *          whether the client just wants invalidations
+   * @param updatesAsInvalidates whether the client just wants invalidations
-  public Set registerClientInterest(Object inputClientID,
-      Object interest, int typeOfInterest, boolean updatesAsInvalidates) {
+  public Set registerClientInterest(Object inputClientID, Object interest, int typeOfInterest,
+      boolean updatesAsInvalidates) {
-    
-    Long clientID = getClientIDForMaps(inputClientID);
-    synchronized(this.interestListLock) {
-      switch (typeOfInterest) {
-      case InterestType.KEY:
-        opType = operationType.REGISTER_KEY;
-        Map<Object, Set> koi = updatesAsInvalidates?
-            getKeysOfInterestInv() : getKeysOfInterest();
-        registerKeyInMap(interest, keysRegistered, clientID, koi);
-        break;
-      case InterestType.REGULAR_EXPRESSION:
-        opType = operationType.REGISTER_PATTERN;
-        if (((String)interest).equals(".*")) {
-          Set akc = updatesAsInvalidates? getAllKeyClientsInv() : getAllKeyClients();
-          if (akc.add(clientID)) {
-            keysRegistered.add(interest);
-          }
-        } else {
-          Map<Object, Map<Object, Pattern>> pats = updatesAsInvalidates?
-              getPatternsOfInterestInv() : getPatternsOfInterest();
-          registerPatternInMap(interest, keysRegistered, clientID, pats);
-        }
-        break;
-      case InterestType.FILTER_CLASS: {
-        opType = operationType.REGISTER_FILTER;
-        Map<Object, Map>filts = updatesAsInvalidates?
-            getFiltersOfInterestInv() : getFiltersOfInterest();
-        registerFilterClassInMap(interest, clientID, filts);
-        break;
-      }
-      default:
-        throw new InternalGemFireError(LocalizedStrings.CacheClientProxy_UNKNOWN_INTEREST_TYPE.toLocalizedString());
+    Long clientID = getClientIDForMaps(inputClientID);
+    synchronized (this.interestListLock) {
+      switch (typeOfInterest) {
+        case InterestType.KEY:
+          opType = operationType.REGISTER_KEY;
+          Map<Object, Set> koi =
+              updatesAsInvalidates ? getKeysOfInterestInv() : getKeysOfInterest();
+          registerKeyInMap(interest, keysRegistered, clientID, koi);
+          break;
+        case InterestType.REGULAR_EXPRESSION:
+          opType = operationType.REGISTER_PATTERN;
+          if (((String) interest).equals(".*")) {
+            Set akc = updatesAsInvalidates ? getAllKeyClientsInv() : getAllKeyClients();
+            if (akc.add(clientID)) {
+              keysRegistered.add(interest);
+            }
+          } else {
+            Map<Object, Map<Object, Pattern>> pats =
+                updatesAsInvalidates ? getPatternsOfInterestInv() : getPatternsOfInterest();
+            registerPatternInMap(interest, keysRegistered, clientID, pats);
+          }
+          break;
+        case InterestType.FILTER_CLASS: {
+          opType = operationType.REGISTER_FILTER;
+          Map<Object, Map> filts =
+              updatesAsInvalidates ? getFiltersOfInterestInv() : getFiltersOfInterest();
+          registerFilterClassInMap(interest, clientID, filts);
+          break;
+        }
+
+        default:
+          throw new InternalGemFireError(
+              LocalizedStrings.CacheClientProxy_UNKNOWN_INTEREST_TYPE.toLocalizedString());
-  private void registerFilterClassInMap(Object interest, Long clientID,
-      Map<Object, Map> filts) {
+  private void registerFilterClassInMap(Object interest, Long clientID, Map<Object, Map> filts) {
-      filterClass = ClassLoadUtil.classFromName((String)interest);
-      filter = (InterestFilter)filterClass.newInstance();
-    }
-    catch (ClassNotFoundException cnfe) {
-      throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_NOT_FOUND_IN_CLASSPATH.toLocalizedString(interest), cnfe);
-    }
-    catch (Exception e) {
-      throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_COULD_NOT_BE_INSTANTIATED.toLocalizedString(interest), e);
+      filterClass = ClassLoadUtil.classFromName((String) interest);
+      filter = (InterestFilter) filterClass.newInstance();
+    } catch (ClassNotFoundException cnfe) {
+      throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_NOT_FOUND_IN_CLASSPATH
+          .toLocalizedString(interest), cnfe);
+    } catch (Exception e) {
+      throw new RuntimeException(LocalizedStrings.CacheClientProxy_CLASS_0_COULD_NOT_BE_INSTANTIATED
+          .toLocalizedString(interest), e);
-  private void registerPatternInMap(Object interest, Set keysRegistered,
-      Long clientID, Map<Object, Map<Object, Pattern>> pats) {
+  private void registerPatternInMap(Object interest, Set keysRegistered, Long clientID,
+      Map<Object, Map<Object, Pattern>> pats) {
-      // If the pattern didn't exist, add it to the set of keys to pass to any listeners. 
+      // If the pattern didn't exist, add it to the set of keys to pass to any listeners.
-  private void registerKeyInMap(Object interest, Set keysRegistered,
-      Long clientID, Map<Object, Set> koi) {
+  private void registerKeyInMap(Object interest, Set keysRegistered, Long clientID,
+      Map<Object, Set> koi) {
-   * @param inputClientID
-   *          The identity of the client that is losing interest
-   * @param interest
-   *          The key in which to unregister interest
+   * @param inputClientID The identity of the client that is losing interest
+   * @param interest The key in which to unregister interest
-  public Set unregisterClientInterest(Object inputClientID,
-      Object interest, int interestType) {
+  public Set unregisterClientInterest(Object inputClientID, Object interest, int interestType) {
-      clientID = (Long)inputClientID;
+      clientID = (Long) inputClientID;
-          logger.debug("region profile unable to find '{}' for unregistration.  Probably means there is no durable queue.", inputClientID);
+          logger.debug(
+              "region profile unable to find '{}' for unregistration.  Probably means there is no durable queue.",
+              inputClientID);
-      case InterestType.KEY: {
-        opType = operationType.UNREGISTER_KEY;
-        unregisterClientKeys(inputClientID, interest,
-            clientID, keysUnregistered);
-        break;
-      }
-      case InterestType.REGULAR_EXPRESSION: {
-        opType = operationType.UNREGISTER_PATTERN;
-        unregisterClientPattern(interest, clientID,
-            keysUnregistered);
-        break;
-      }
-      case InterestType.FILTER_CLASS: {
-        opType = operationType.UNREGISTER_FILTER;
-        unregisterClientFilterClass(interest, clientID);
-        break;
-      }
-      default:
-        throw new InternalGemFireError(LocalizedStrings.CacheClientProxy_BAD_INTEREST_TYPE.toLocalizedString());
+        case InterestType.KEY: {
+          opType = operationType.UNREGISTER_KEY;
+          unregisterClientKeys(inputClientID, interest, clientID, keysUnregistered);
+          break;
+        }
+        case InterestType.REGULAR_EXPRESSION: {
+          opType = operationType.UNREGISTER_PATTERN;
+          unregisterClientPattern(interest, clientID, keysUnregistered);
+          break;
+        }
+        case InterestType.FILTER_CLASS: {
+          opType = operationType.UNREGISTER_FILTER;
+          unregisterClientFilterClass(interest, clientID);
+          break;
+        }
+        default:
+          throw new InternalGemFireError(
+              LocalizedStrings.CacheClientProxy_BAD_INTEREST_TYPE.toLocalizedString());
-  private void unregisterClientPattern(Object interest, Long clientID,
-      Set keysUnregistered) {
-    if (interest instanceof String && ((String)interest).equals(".*")) { // ALL_KEYS
+  private void unregisterClientPattern(Object interest, Long clientID, Set keysUnregistered) {
+    if (interest instanceof String && ((String) interest).equals(".*")) { // ALL_KEYS
-        keysUnregistered.add(".*"); 
+        keysUnregistered.add(".*");
-        keysUnregistered.add(".*"); 
+        keysUnregistered.add(".*");
-    }
-    else {
+    } else {
-  private void unregisterPatternFromMap(Map<Object, Map<Object, Pattern>> map,
-      Object interest, Long clientID, Set keysUnregistered) {
+  private void unregisterPatternFromMap(Map<Object, Map<Object, Pattern>> map, Object interest,
+      Long clientID, Set keysUnregistered) {
-        keysUnregistered.add(interest); 
+        keysUnregistered.add(interest);
-      Map removed = (Map)interestMap.remove(clientID);
+      Map removed = (Map) interestMap.remove(clientID);
-      } 
+      }
-  private void unregisterAllKeys(Object interest, Long clientID,
-      Set keysUnregistered) {
+  private void unregisterAllKeys(Object interest, Long clientID, Set keysUnregistered) {
-      keysUnregistered.add(interest); 
+      keysUnregistered.add(interest);
-      keysUnregistered.add(interest); 
+      keysUnregistered.add(interest);
-  private void unregisterClientKeys(Object inputClientID, Object interest,
-      Long clientID, Set keysUnregistered) {
+  private void unregisterClientKeys(Object inputClientID, Object interest, Long clientID,
+      Set keysUnregistered) {
-      } 
+      }
-   * @param keys
-   *          The list of keys in which to register interest
+   * @param keys The list of keys in which to register interest
-  public Set registerClientInterestList(Object inputClientID,
-      List keys, boolean updatesAsInvalidates) {
+  public Set registerClientInterestList(Object inputClientID, List keys,
+      boolean updatesAsInvalidates) {
-      Map<Object, Set> koi = updatesAsInvalidates?getKeysOfInterestInv():getKeysOfInterest();
-      CopyOnWriteHashSet interestList = (CopyOnWriteHashSet)koi.get(clientID);
+      Map<Object, Set> koi = updatesAsInvalidates ? getKeysOfInterestInv() : getKeysOfInterest();
+      CopyOnWriteHashSet interestList = (CopyOnWriteHashSet) koi.get(clientID);
-  
+
-   * @param inputClientID
-   *          The fully-qualified name of the region in which to unregister
-   *          interest
-   * @param keys
-   *          The list of keys in which to unregister interest
+   * @param inputClientID The fully-qualified name of the region in which to unregister interest
+   * @param keys The list of keys in which to unregister interest
-  public Set unregisterClientInterestList(Object inputClientID,
-      List keys) {
+  public Set unregisterClientInterestList(Object inputClientID, List keys) {
-      CopyOnWriteHashSet interestList = (CopyOnWriteHashSet)getKeysOfInterest().get(clientID);
+      CopyOnWriteHashSet interestList = (CopyOnWriteHashSet) getKeysOfInterest().get(clientID);
-      interestList = (CopyOnWriteHashSet)getKeysOfInterestInv().get(clientID);
+      interestList = (CopyOnWriteHashSet) getKeysOfInterestInv().get(clientID);
-  
+
-  
+
-    return hasAllKeysInterestFor(clientID, false) ||
-      hasAllKeysInterestFor(clientID, true);
+    return hasAllKeysInterestFor(clientID, false) || hasAllKeysInterestFor(clientID, true);
-  
+
-  
- 
+
+
-      clientID = (Long)inputClientID;
+      clientID = (Long) inputClientID;
-    return
-      this.hasAllKeysInterestFor(clientID, true)  ||
-      this.hasKeysOfInterestFor(clientID, true)   ||
-      this.hasRegexInterestFor(clientID, true)    ||
-      this.hasFilterInterestFor(clientID, true)   ||
-      this.hasKeysOfInterestFor(clientID, false)  ||
-      this.hasRegexInterestFor(clientID, false)   ||
-      this.hasAllKeysInterestFor(clientID, false) ||
-      this.hasFilterInterestFor(clientID, false);
+    return this.hasAllKeysInterestFor(clientID, true) || this.hasKeysOfInterestFor(clientID, true)
+        || this.hasRegexInterestFor(clientID, true) || this.hasFilterInterestFor(clientID, true)
+        || this.hasKeysOfInterestFor(clientID, false) || this.hasRegexInterestFor(clientID, false)
+        || this.hasAllKeysInterestFor(clientID, false)
+        || this.hasFilterInterestFor(clientID, false);
-   * Returns whether this interest list has any keys, patterns or filters of
-   * interest. It answers the question: Are any clients being notified because
-   * of this interest list? @return whether this interest list has any keys,
-   * patterns or filters of interest
+   * Returns whether this interest list has any keys, patterns or filters of interest. It answers
+   * the question: Are any clients being notified because of this interest list? @return whether
+   * this interest list has any keys, patterns or filters of interest
-    return
-      (!this.getAllKeyClients().isEmpty())         ||
-      (!this.getAllKeyClientsInv().isEmpty())      ||
-      (!this.getKeysOfInterest().isEmpty())        ||
-      (!this.getPatternsOfInterest().isEmpty())    ||
-      (!this.getFiltersOfInterest().isEmpty())     ||
-      (!this.getKeysOfInterestInv().isEmpty())     ||
-      (!this.getPatternsOfInterestInv().isEmpty()) ||
-      (!this.getFiltersOfInterestInv().isEmpty());
+    return (!this.getAllKeyClients().isEmpty()) || (!this.getAllKeyClientsInv().isEmpty())
+        || (!this.getKeysOfInterest().isEmpty()) || (!this.getPatternsOfInterest().isEmpty())
+        || (!this.getFiltersOfInterest().isEmpty()) || (!this.getKeysOfInterestInv().isEmpty())
+        || (!this.getPatternsOfInterestInv().isEmpty())
+        || (!this.getFiltersOfInterestInv().isEmpty());
-      clientID = (Long)inputClientID;
+      clientID = (Long) inputClientID;
-        
+
-   * Obtains the number of CQs registered on the region.
-   * Assumption: CQs are not duplicated among clients.
+   * Obtains the number of CQs registered on the region. Assumption: CQs are not duplicated among
+   * clients.
-  public void incCqCount(){
+  public void incCqCount() {
-  public void decCqCount(){
+  public void decCqCount() {
-  
+
-    return (ServerCQ)this.cqs.get(cqName);
+    return (ServerCQ) this.cqs.get(cqName);
-  
+
-      logger.debug("Adding CQ {} to this members FilterProfile.", cq.getServerCqName()); 
+      logger.debug("Adding CQ {} to this members FilterProfile.", cq.getServerCqName());
-    
-    //cq.setFilterID(cqMap.getWireID(cq.getServerCqName()));
+
+    // cq.setFilterID(cqMap.getWireID(cq.getServerCqName()));
-      this.logger.debug("Stopping CQ {} on this members FilterProfile.", cq.getServerCqName()); 
+      this.logger.debug("Stopping CQ {} on this members FilterProfile.", cq.getServerCqName());
-    // To avoid any conflict with the CQ names while maintained in 
+    // To avoid any conflict with the CQ names while maintained in
-    // The CQ will be identified in the remote node using its 
+    // The CQ will be identified in the remote node using its
-  
+
+   * 
-  void processRegisterCq(String serverCqName, ServerCQ ServerCQ,
-      boolean addToCqMap) {
-    ServerCQ cq = (ServerCQ)ServerCQ;
+  void processRegisterCq(String serverCqName, ServerCQ ServerCQ, boolean addToCqMap) {
+    ServerCQ cq = (ServerCQ) ServerCQ;
-      CqStateImpl cqState = (CqStateImpl)cq.getState();
+      CqStateImpl cqState = (CqStateImpl) cq.getState();
-      cq.registerCq(null, null, cqState.getState());    
-    } catch (Exception ex){
+      cq.registerCq(null, null, cqState.getState());
+    } catch (Exception ex) {
-        logger.debug("Error while initializing the CQs with FilterProfile for CQ {}, Error : {}", serverCqName, ex.getMessage(), ex);
+        logger.debug("Error while initializing the CQs with FilterProfile for CQ {}, Error : {}",
+            serverCqName, ex.getMessage(), ex);
-    
+
-    if (cq.getCqBaseRegion() != null ) {
-      FilterProfile pf =  cq.getCqBaseRegion().getFilterProfile();
+    if (cq.getCqBaseRegion() != null) {
+      FilterProfile pf = cq.getCqBaseRegion().getFilterProfile();
-  
+
-    ServerCQ cq = (ServerCQ)this.cqs.get(serverCqName);
-    if (cq != null){
+    ServerCQ cq = (ServerCQ) this.cqs.get(serverCqName);
+    if (cq != null) {
-      } catch (Exception ex){
+      } catch (Exception ex) {
-          logger.debug("Unable to close the CQ with the filterProfile, on region {} for CQ {}, Error : {}", this.region.getFullPath(),
-              serverCqName, ex.getMessage(), ex);
+          logger.debug(
+              "Unable to close the CQ with the filterProfile, on region {} for CQ {}, Error : {}",
+              this.region.getFullPath(), serverCqName, ex.getMessage(), ex);
-  
+
-    ServerCQ cq = (ServerCQ)this.cqs.get(serverCqName);
-    if (cq != null){
-      CqStateImpl cqState = (CqStateImpl)ServerCQ.getState(); 
+    ServerCQ cq = (ServerCQ) this.cqs.get(serverCqName);
+    if (cq != null) {
+      CqStateImpl cqState = (CqStateImpl) ServerCQ.getState();
-    ServerCQ cq = (ServerCQ)this.cqs.get(serverCqName);
-    if (cq != null){
+    ServerCQ cq = (ServerCQ) this.cqs.get(serverCqName);
+    if (cq != null) {
-      } catch (Exception ex){
+      } catch (Exception ex) {
-          logger.debug("Unable to stop the CQ with the filterProfile, on region {} for CQ {}, Error : {}",
+          logger.debug(
+              "Unable to stop the CQ with the filterProfile, on region {} for CQ {}, Error : {}",
-      logger.debug("Stopping CQ {} on this members FilterProfile.", cq.getServerCqName()); 
+      logger.debug("Stopping CQ {} on this members FilterProfile.", cq.getServerCqName());
-  
-  void cleanupForClient(CacheClientNotifier ccn,
-      ClientProxyMembershipID client) {
+
+  void cleanupForClient(CacheClientNotifier ccn, ClientProxyMembershipID client) {
-      Map.Entry cqEntry = (Map.Entry)cqIter.next();
-      ServerCQ cq = (ServerCQ)cqEntry.getValue();
+      Map.Entry cqEntry = (Map.Entry) cqIter.next();
+      ServerCQ cq = (ServerCQ) cqEntry.getValue();
-      if (clientId.equals(client)){
+      if (clientId.equals(client)) {
-  
+
-   * this will be get called when we remove other server profile from
-   * region advisor.
+   * this will be get called when we remove other server profile from region advisor.
-    
-    if(tmpCq.size() > 0) {
-      for(Object serverCqName: tmpCq.keySet()) {
-        processCloseCq((String)serverCqName);
+
+    if (tmpCq.size() > 0) {
+      for (Object serverCqName : tmpCq.keySet()) {
+        processCloseCq((String) serverCqName);
-  
+
-   * Returns if old value is required for CQ processing or not.
-   * In order to reduce the query processing time CQ caches the 
-   * event keys its already seen, if the key is cached than the 
-   * old value is not required.
+   * Returns if old value is required for CQ processing or not. In order to reduce the query
+   * processing time CQ caches the event keys its already seen, if the key is cached than the old
+   * value is not required.
-    if (this.hasCQs()){
-      if (!CqServiceProvider.MAINTAIN_KEYS){
+    if (this.hasCQs()) {
+      if (!CqServiceProvider.MAINTAIN_KEYS) {
-        ServerCQ cq = (ServerCQ)cqIter.next();
+        ServerCQ cq = (ServerCQ) cqIter.next();
-      }  
+      }
-    msg.interest = interest;  
+    msg.interest = interest;
-  
+
-    Set recipients = ((CacheDistributionAdvisee)this.region).getDistributionAdvisor()
-      .adviseProfileUpdate();
+    Set recipients =
+        ((CacheDistributionAdvisee) this.region).getDistributionAdvisor().adviseProfileUpdate();
-    // we only need to distribute for PRs.  Other regions do local filter processing
-    if ( ! (this.region instanceof PartitionedRegion) ) {
+    // we only need to distribute for PRs. Other regions do local filter processing
+    if (!(this.region instanceof PartitionedRegion)) {
-      // that flag is only used during region initialization.  Otherwise we
+      // that flag is only used during region initialization. Otherwise we
-  
+
-  private final Profile[] localProfileArray = new Profile[]{localProfile};
-  
-  
+  private final Profile[] localProfileArray = new Profile[] {localProfile};
+
+
-  
+
-  /** 
-   * Compute the full routing information for the given set of peers.  This will
-   * not include local routing information from interest processing.  That
-   * is done by getFilterRoutingInfoPart2 */
-  public FilterRoutingInfo getFilterRoutingInfoPart1(CacheEvent event, Profile[] peerProfiles, Set cacheOpRecipients) {
+  /**
+   * Compute the full routing information for the given set of peers. This will not include local
+   * routing information from interest processing. That is done by getFilterRoutingInfoPart2
+   */
+  public FilterRoutingInfo getFilterRoutingInfoPart1(CacheEvent event, Profile[] peerProfiles,
+      Set cacheOpRecipients) {
-    for (int i=0; i<peerProfiles.length; i++) {
-      if (((CacheProfile)peerProfiles[i]).hasCacheServer) {
+    for (int i = 0; i < peerProfiles.length; i++) {
+      if (((CacheProfile) peerProfiles[i]).hasCacheServer) {
-      final boolean processLocalProfile = event.getOperation().isEntry() && ((EntryEventImpl)event).getTransactionId() != null;
+      final boolean processLocalProfile =
+          event.getOperation().isEntry() && ((EntryEventImpl) event).getTransactionId() != null;
-    
+
-//    return fillInInterestRoutingInfo(event, peerProfiles, frInfo, cacheOpRecipients);
+    // return fillInInterestRoutingInfo(event, peerProfiles, frInfo, cacheOpRecipients);
-  
-  
+
+
+   * 
-      boolean isInConflict = event.getOperation().isEntry() &&
-          ((EntryEventImpl)event).isConcurrencyConflict();
+      boolean isInConflict =
+          event.getOperation().isEntry() && ((EntryEventImpl) event).isConcurrencyConflict();
-      if (!isInConflict && cqService.isRunning() && this.region != null /*&& !(
-          this.region.isUsedForPartitionedRegionBucket() ||   // partitioned region CQ 
-          this.region instanceof PartitionedRegion)*/) {        // processing is done in part 1
+      if (!isInConflict && cqService.isRunning()
+          && this.region != null /*
+                                  * && !( this.region.isUsedForPartitionedRegionBucket() || //
+                                  * partitioned region CQ this.region instanceof PartitionedRegion)
+                                  */) { // processing is done in part 1
-  
+
+   * 
-        Profile local = processLocalProfile? this.localProfile : null;
+        Profile local = processLocalProfile ? this.localProfile : null;
-        // If this ever returns, re-throw the error.  We're poisoned
+        // If this ever returns, re-throw the error. We're poisoned
-        logger.error(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_EXCEPTION_OCCURRED_WHILE_PROCESSING_CQS), t);
+        logger.error(LocalizedMessage.create(
+            LocalizedStrings.CacheClientNotifier_EXCEPTION_OCCURRED_WHILE_PROCESSING_CQS), t);
-   private CqService getCqService(Region region) {
+  private CqService getCqService(Region region) {
-   *  computes FilterRoutingInfo objects for each of the given events
+   * computes FilterRoutingInfo objects for each of the given events
-  public void getLocalFilterRoutingForPutAllOp(DistributedPutAllOperation dpao, DistributedPutAllOperation.PutAllEntryData[] putAllData) {
+  public void getLocalFilterRoutingForPutAllOp(DistributedPutAllOperation dpao,
+      DistributedPutAllOperation.PutAllEntryData[] putAllData) {
-    
+
-      boolean doCQs = cqService.isRunning() && this.region != null /*&& !(this.region.isUsedForPartitionedRegionBucket()
-          || (this.region instanceof PartitionedRegion))*/;
-      for (int idx=0; idx < size; idx++) {
+      boolean doCQs = cqService.isRunning()
+          && this.region != null /*
+                                  * && !(this.region.isUsedForPartitionedRegionBucket() ||
+                                  * (this.region instanceof PartitionedRegion))
+                                  */;
+      for (int idx = 0; idx < size; idx++) {
-          @Unretained final EntryEventImpl ev = dpao.getEventForPosition(idx);
+          @Unretained
+          final EntryEventImpl ev = dpao.getEventForPosition(idx);
-              || this.patternsOfInterestInv != null
-              || this.filtersOfInterestInv != null) {
+              || this.patternsOfInterestInv != null || this.filtersOfInterestInv != null) {
-                this.keysOfInterestInv, this.patternsOfInterestInv,
-                this.filtersOfInterestInv);
+                this.keysOfInterestInv, this.patternsOfInterestInv, this.filtersOfInterestInv);
-              || this.patternsOfInterest != null
-              || this.filtersOfInterest != null) {
-            clients = this.getInterestedClients(ev, this.allKeyClients,
-                this.keysOfInterest, this.patternsOfInterest,
-                this.filtersOfInterest);
+              || this.patternsOfInterest != null || this.filtersOfInterest != null) {
+            clients = this.getInterestedClients(ev, this.allKeyClients, this.keysOfInterest,
+                this.patternsOfInterest, this.filtersOfInterest);
-  *  computes FilterRoutingInfo objects for each of the given events
-  */
- public void getLocalFilterRoutingForRemoveAllOp(DistributedRemoveAllOperation op, RemoveAllEntryData[] removeAllData) {
-   if (this.region != null && this.localProfile.hasCacheServer) {
-     Set clientsInv = null;
-     Set clients = null;
-     int size = removeAllData.length;
-     CqService cqService = getCqService(op.getRegion());
-     boolean doCQs = cqService.isRunning() && this.region != null;
-     for (int idx=0; idx < size; idx++) {
-       RemoveAllEntryData pEntry = removeAllData[idx];
-       if (pEntry != null) {
-         @Unretained final EntryEventImpl ev = op.getEventForPosition(idx);
-         FilterRoutingInfo fri = pEntry.filterRouting;
-         FilterInfo fi = null;
-         if (fri != null) {
-           fi = fri.getLocalFilterInfo();
-         }
-         if (logger.isDebugEnabled()) {
-           logger.debug("Finding locally interested clients for {}", ev);
-         }
-         if (doCQs) {
-           if (fri == null) {
-             fri = new FilterRoutingInfo();
-           }
-           fillInCQRoutingInfo(ev, true, NO_PROFILES, fri);
-           fi = fri.getLocalFilterInfo();
-         }
-         if (this.allKeyClientsInv != null || this.keysOfInterestInv != null
-             || this.patternsOfInterestInv != null
-             || this.filtersOfInterestInv != null) {
-           clientsInv = this.getInterestedClients(ev, this.allKeyClientsInv,
-               this.keysOfInterestInv, this.patternsOfInterestInv,
-               this.filtersOfInterestInv);
-         }
-         if (this.allKeyClients != null || this.keysOfInterest != null
-             || this.patternsOfInterest != null
-             || this.filtersOfInterest != null) {
-           clients = this.getInterestedClients(ev, this.allKeyClients,
-               this.keysOfInterest, this.patternsOfInterest,
-               this.filtersOfInterest);
-         }
-         if (clients != null || clientsInv != null) {
-           if (fi == null) {
-             fi = new FilterInfo();
-             // no need to create or update a FilterRoutingInfo at this time
-           }
-           fi.setInterestedClients(clients);
-           fi.setInterestedClientsInv(clientsInv);
-         }
-         //        if (this.logger.fineEnabled()) {
-         //          this.region.getLogWriterI18n().fine("setting event routing to " + fi);
-         //        }
-         ev.setLocalFilterInfo(fi);
-       }
-     }
-   }
- }
+   * computes FilterRoutingInfo objects for each of the given events
+   */
+  public void getLocalFilterRoutingForRemoveAllOp(DistributedRemoveAllOperation op,
+      RemoveAllEntryData[] removeAllData) {
+    if (this.region != null && this.localProfile.hasCacheServer) {
+      Set clientsInv = null;
+      Set clients = null;
+      int size = removeAllData.length;
+      CqService cqService = getCqService(op.getRegion());
+      boolean doCQs = cqService.isRunning() && this.region != null;
+      for (int idx = 0; idx < size; idx++) {
+        RemoveAllEntryData pEntry = removeAllData[idx];
+        if (pEntry != null) {
+          @Unretained
+          final EntryEventImpl ev = op.getEventForPosition(idx);
+          FilterRoutingInfo fri = pEntry.filterRouting;
+          FilterInfo fi = null;
+          if (fri != null) {
+            fi = fri.getLocalFilterInfo();
+          }
+          if (logger.isDebugEnabled()) {
+            logger.debug("Finding locally interested clients for {}", ev);
+          }
+          if (doCQs) {
+            if (fri == null) {
+              fri = new FilterRoutingInfo();
+            }
+            fillInCQRoutingInfo(ev, true, NO_PROFILES, fri);
+            fi = fri.getLocalFilterInfo();
+          }
+          if (this.allKeyClientsInv != null || this.keysOfInterestInv != null
+              || this.patternsOfInterestInv != null || this.filtersOfInterestInv != null) {
+            clientsInv = this.getInterestedClients(ev, this.allKeyClientsInv,
+                this.keysOfInterestInv, this.patternsOfInterestInv, this.filtersOfInterestInv);
+          }
+          if (this.allKeyClients != null || this.keysOfInterest != null
+              || this.patternsOfInterest != null || this.filtersOfInterest != null) {
+            clients = this.getInterestedClients(ev, this.allKeyClients, this.keysOfInterest,
+                this.patternsOfInterest, this.filtersOfInterest);
+          }
+          if (clients != null || clientsInv != null) {
+            if (fi == null) {
+              fi = new FilterInfo();
+              // no need to create or update a FilterRoutingInfo at this time
+            }
+            fi.setInterestedClients(clients);
+            fi.setInterestedClientsInv(clientsInv);
+          }
+          // if (this.logger.fineEnabled()) {
+          // this.region.getLogWriterI18n().fine("setting event routing to " + fi);
+          // }
+          ev.setLocalFilterInfo(fi);
+        }
+      }
+    }
+  }
-   * Fills in the routing information for clients that have registered
-   * interest in the given event.  The routing information is stored in
-   * the given FilterRoutingInfo object for use in message delivery.
+   * Fills in the routing information for clients that have registered interest in the given event.
+   * The routing information is stored in the given FilterRoutingInfo object for use in message
+   * delivery.
+   * 
-  public FilterRoutingInfo fillInInterestRoutingInfo(CacheEvent event, Profile[] profiles, 
+  public FilterRoutingInfo fillInInterestRoutingInfo(CacheEvent event, Profile[] profiles,
-    
+
-    
-    for (int i=0; i < profiles.length; i++) {
-      CacheProfile cf = (CacheProfile)profiles[i];
-      
+
+    for (int i = 0; i < profiles.length; i++) {
+      CacheProfile cf = (CacheProfile) profiles[i];
+
-      
+
-      
+
-      
+
-          if (frInfo == null) frInfo = new FilterRoutingInfo();
-          frInfo.addInterestedClients(cf.getDistributedMember(),
-              Collections.EMPTY_SET, Collections.EMPTY_SET, false);
+          if (frInfo == null)
+            frInfo = new FilterRoutingInfo();
+          frInfo.addInterestedClients(cf.getDistributedMember(), Collections.EMPTY_SET,
+              Collections.EMPTY_SET, false);
-        EntryEvent entryEvent = (EntryEvent)event;
+        EntryEvent entryEvent = (EntryEvent) event;
-        if (pf.allKeyClients != null || pf.keysOfInterest != null
-            || pf.patternsOfInterest != null || pf.filtersOfInterest != null) {
-          clients = pf.getInterestedClients(entryEvent, pf.allKeyClients,
-              pf.keysOfInterest, pf.patternsOfInterest, pf.filtersOfInterest);
+        if (pf.allKeyClients != null || pf.keysOfInterest != null || pf.patternsOfInterest != null
+            || pf.filtersOfInterest != null) {
+          clients = pf.getInterestedClients(entryEvent, pf.allKeyClients, pf.keysOfInterest,
+              pf.patternsOfInterest, pf.filtersOfInterest);
-      if (pf.isLocalProfile){
+      if (pf.isLocalProfile) {
-          logger.debug("Setting local interested clients={} and clientsInv={}", clients, clientsInv);
+          logger.debug("Setting local interested clients={} and clientsInv={}", clients,
+              clientsInv);
-        if (frInfo == null) frInfo = new FilterRoutingInfo();
+        if (frInfo == null)
+          frInfo = new FilterRoutingInfo();
-        if (cacheOpRecipients.contains(cf.getDistributedMember()) || // always send a routing with CacheOperationMessages
-            (clients != null && !clients.isEmpty()) ||
-            (clientsInv != null && !clientsInv.isEmpty())) {
+        if (cacheOpRecipients.contains(cf.getDistributedMember()) || // always send a routing with
+                                                                     // CacheOperationMessages
+            (clients != null && !clients.isEmpty())
+            || (clientsInv != null && !clientsInv.isEmpty())) {
-            logger.debug("Adding interested clients={} and clientsIn={} to {}", clients, clientsInv, filterRoutingInfo);
+            logger.debug("Adding interested clients={} and clientsIn={} to {}", clients, clientsInv,
+                filterRoutingInfo);
-          if (frInfo == null) frInfo = new FilterRoutingInfo();
-          frInfo.addInterestedClients(cf.getDistributedMember(),
-            clients, clientsInv, this.clientMap.hasLongID);
+          if (frInfo == null)
+            frInfo = new FilterRoutingInfo();
+          frInfo.addInterestedClients(cf.getDistributedMember(), clients, clientsInv,
+              this.clientMap.hasLongID);
-   * get the clients interested in the given event that are attached to this
-   * server.
+   * get the clients interested in the given event that are attached to this server.
+   * 
-  private Set getInterestedClients(EntryEvent event,
-      Set akc, Map<Object, Set> koi, Map<Object, Map<Object, Pattern>> pats,
-      Map<Object, Map>foi) {
+  private Set getInterestedClients(EntryEvent event, Set akc, Map<Object, Set> koi,
+      Map<Object, Map<Object, Pattern>> pats, Map<Object, Map> foi) {
-      for (Iterator it=koi.entrySet().iterator(); it.hasNext(); ) {
-        Map.Entry entry = (Map.Entry)it.next();
-        Set keys = (Set)entry.getValue();
+      for (Iterator it = koi.entrySet().iterator(); it.hasNext();) {
+        Map.Entry entry = (Map.Entry) it.next();
+        Set keys = (Set) entry.getValue();
-          if (result == null) result = new HashSet();
+          if (result == null)
+            result = new HashSet();
-            logger.debug("client {} matched for key list (size {})", clientID, koi.get(clientID).size());
+            logger.debug("client {} matched for key list (size {})", clientID,
+                koi.get(clientID).size());
-      for (Iterator it=pats.entrySet().iterator(); it.hasNext(); ) {
-        Map.Entry entry = (Map.Entry)it.next();
-        String stringKey = (String)event.getKey();
-        Map<Object, Pattern> interestList = (Map<Object, Pattern>)entry.getValue();
-        for (Pattern keyPattern: interestList.values()) {
+      for (Iterator it = pats.entrySet().iterator(); it.hasNext();) {
+        Map.Entry entry = (Map.Entry) it.next();
+        String stringKey = (String) event.getKey();
+        Map<Object, Pattern> interestList = (Map<Object, Pattern>) entry.getValue();
+        for (Pattern keyPattern : interestList.values()) {
-            if (result == null) result = new HashSet();
+            if (result == null)
+              result = new HashSet();
-      SerializedCacheValue<?> serValue = event.getSerializedNewValue();
-      serialized = (serValue != null);
-      if (!serialized) {
-        value = event.getNewValue();
-      } else {
-        value = serValue.getSerializedValue();
-      }
+        SerializedCacheValue<?> serValue = event.getSerializedNewValue();
+        serialized = (serValue != null);
+        if (!serialized) {
+          value = event.getNewValue();
+        } else {
+          value = serValue.getSerializedValue();
+        }
-      for (Iterator it=foi.entrySet().iterator(); it.hasNext(); ) {
-        Map.Entry entry = (Map.Entry)it.next();
-        Map<String, InterestFilter> interestList = (Map<String, InterestFilter>)entry.getValue();
-        for (InterestFilter filter: interestList.values()) {
-          if (
-           (op.isCreate()  && filter.notifyOnCreate(iev)) ||
-           (op.isUpdate()  && filter.notifyOnUpdate(iev)) ||
-           (op.isDestroy() && filter.notifyOnDestroy(iev)) ||
-           (op.isInvalidate() && filter.notifyOnInvalidate(iev))
-           ) {
+      for (Iterator it = foi.entrySet().iterator(); it.hasNext();) {
+        Map.Entry entry = (Map.Entry) it.next();
+        Map<String, InterestFilter> interestList = (Map<String, InterestFilter>) entry.getValue();
+        for (InterestFilter filter : interestList.values()) {
+          if ((op.isCreate() && filter.notifyOnCreate(iev))
+              || (op.isUpdate() && filter.notifyOnUpdate(iev))
+              || (op.isDestroy() && filter.notifyOnDestroy(iev))
+              || (op.isInvalidate() && filter.notifyOnInvalidate(iev))) {
-            if (result == null) result = new HashSet();
+            if (result == null)
+              result = new HashSet();
-              logger.debug("client {} matched for filter ({})", clientID, getFiltersOfInterest().get(clientID));
+              logger.debug("client {} matched for filter ({})", clientID,
+                  getFiltersOfInterest().get(clientID));
-  
-  
+
+
-    
+
-    
+
-      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT); // do this before CacheFactory.getInstance for bug 33471
+      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT); // do this
+                                                                                      // before
+                                                                                      // CacheFactory.getInstance
+                                                                                      // for bug
+                                                                                      // 33471
-        for (int i=0; i < numCQs; i++){
+        for (int i = 0; i < numCQs; i++) {
-        } 
+        }
-    
+
-  
+
-    InternalDataSerializer.invokeToData(((InternalDistributedMember)memberID), out);
+    InternalDataSerializer.invokeToData(((InternalDistributedMember) memberID), out);
-    
+
-    for (Iterator it=theCQs.entrySet().iterator(); it.hasNext(); ) {
-      Map.Entry entry = (Map.Entry)it.next();
-      String name = (String)entry.getKey();
-      ServerCQ cq = (ServerCQ)entry.getValue();
+    for (Iterator it = theCQs.entrySet().iterator(); it.hasNext();) {
+      Map.Entry entry = (Map.Entry) it.next();
+      String name = (String) entry.getKey();
+      ServerCQ cq = (ServerCQ) entry.getValue();
-  
+
-  public int getAllKeyClientsSize(){
+  public int getAllKeyClientsSize() {
-  public int getAllKeyClientsInvSize(){
+  public int getAllKeyClientsInvSize() {
-  
+
-   * When clients are registered they are assigned a Long identifier.
-   * This method maps between the real client ID and its Long identifier.
+   * When clients are registered they are assigned a Long identifier. This method maps between the
+   * real client ID and its Long identifier.
-      clientID = (Long)inputClientID;
+      clientID = (Long) inputClientID;
-    return "FilterProfile(id=" + (this.isLocalProfile? "local" : this.memberID)
-//    + ";  allKeys: " + this.allKeyClients
-//    + ";  keys: " + this.keysOfInterest
-//    + ";  patterns: " + this.patternsOfInterest
-//    + ";  filters: " + this.filtersOfInterest
-//    + ";  allKeysInv: " + this.allKeyClientsInv
-//    + ";  keysInv: " + this.keysOfInterestInv
-//    + ";  patternsInv: " + this.patternsOfInterestInv
-//    + ";  filtersInv: " + this.filtersOfInterestInv
-    + ";  numCQs: " + ((this.cqCount == null)?0:this.cqCount.get())
-    + (isDebugEnabled? (";  " + getClientMappingString()) : "")
-    + (isDebugEnabled? (";  " + getCqMappingString()) : "")
-    + ")";
+    return "FilterProfile(id=" + (this.isLocalProfile ? "local" : this.memberID)
+    // + "; allKeys: " + this.allKeyClients
+    // + "; keys: " + this.keysOfInterest
+    // + "; patterns: " + this.patternsOfInterest
+    // + "; filters: " + this.filtersOfInterest
+    // + "; allKeysInv: " + this.allKeyClientsInv
+    // + "; keysInv: " + this.keysOfInterestInv
+    // + "; patternsInv: " + this.patternsOfInterestInv
+    // + "; filtersInv: " + this.filtersOfInterestInv
+        + ";  numCQs: " + ((this.cqCount == null) ? 0 : this.cqCount.get())
+        + (isDebugEnabled ? (";  " + getClientMappingString()) : "")
+        + (isDebugEnabled ? (";  " + getCqMappingString()) : "") + ")";
-  
+
-    for (int i=1; it.hasNext(); i++) {
+    for (int i = 1; it.hasNext(); i++) {
-  
+
-    for (int i=1; it.hasNext(); i++) {
+    for (int i = 1; it.hasNext(); i++) {
-  
+
-   * given a collection of on-wire identifiers, this returns a set of
-   * the client/server identifiers for each client or durable queue
+   * given a collection of on-wire identifiers, this returns a set of the client/server identifiers
+   * for each client or durable queue
+   * 
-  
+
-   * given a collection of on-wire identifiers, this returns a set of
-   * the CQ identifiers they correspond to
+   * given a collection of on-wire identifiers, this returns a set of the CQ identifiers they
+   * correspond to
+   * 
-  
+
+   * 
-    return (String)cqMap.getRealID(integerID);
+    return (String) cqMap.getRealID(integerID);
-  
+
-  
+
-   * Returns the filter profile messages received while members cache profile 
-   * exchange was in progress. 
+   * Returns the filter profile messages received while members cache profile exchange was in
+   * progress.
+   * 
-  public List getQueuedFilterProfileMsgs(InternalDistributedMember member){
-    synchronized (this.filterProfileMsgQueue){
+  public List getQueuedFilterProfileMsgs(InternalDistributedMember member) {
+    synchronized (this.filterProfileMsgQueue) {
-   * Removes the filter profile messages from the queue that are received  
-   * while the members cache profile exchange was in progress. 
+   * Removes the filter profile messages from the queue that are received while the members cache
+   * profile exchange was in progress.
+   * 
-  public List removeQueuedFilterProfileMsgs(InternalDistributedMember member){
-    synchronized (this.filterProfileMsgQueue){
+  public List removeQueuedFilterProfileMsgs(InternalDistributedMember member) {
+    synchronized (this.filterProfileMsgQueue) {
-  
+
+   * 
-  public void addToFilterProfileQueue(InternalDistributedMember member, OperationMessage message){
+  public void addToFilterProfileQueue(InternalDistributedMember member, OperationMessage message) {
-    }    
-    synchronized (this.filterProfileMsgQueue){
+    }
+    synchronized (this.filterProfileMsgQueue) {
-      if (msgs == null){
+      if (msgs == null) {
-  
+
+   * 
-  public void processQueuedFilterProfileMsgs(List msgs){
+  public void processQueuedFilterProfileMsgs(List msgs) {
-    
-    if (msgs != null){
+
+    if (msgs != null) {
-          OperationMessage msg = (OperationMessage)iter.next();
+          OperationMessage msg = (OperationMessage) iter.next();
-        } catch (Exception ex){
+        } catch (Exception ex) {
-  
+
-   * OperationMessage synchronously propagates a change in the profile to
-   * another member.  It is a serial message so that there is no chance
-   * of out-of-order execution.
+   * OperationMessage synchronously propagates a change in the profile to another member. It is a
+   * serial message so that there is no chance of out-of-order execution.
-  public static class OperationMessage extends HighPriorityDistributionMessage 
-     implements MessageWithReply {
-    
+  public static class OperationMessage extends HighPriorityDistributionMessage
+      implements MessageWithReply {
+
-    
-    /* (non-Javadoc)
-     * @see org.apache.geode.distributed.internal.DistributionMessage#process(org.apache.geode.distributed.internal.DistributionManager)
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.geode.distributed.internal.DistributionMessage#process(org.apache.geode.
+     * distributed.internal.DistributionManager)
-        // we only need to record the delta if this is a partitioned region 
-        if ( ! (r instanceof PartitionedRegion) ) {
+        // we only need to record the delta if this is a partitioned region
+        if (!(r instanceof PartitionedRegion)) {
- 
-        CacheDistributionAdvisor cda = (CacheDistributionAdvisor)r.getDistributionAdvisor();
+
+        CacheDistributionAdvisor cda = (CacheDistributionAdvisor) r.getDistributionAdvisor();
-          (CacheDistributionAdvisor.CacheProfile)cda.getProfile(getSender());
-        if (cp == null) {  // PR accessors do not keep filter profiles around
+            (CacheDistributionAdvisor.CacheProfile) cda.getProfile(getSender());
+        if (cp == null) { // PR accessors do not keep filter profiles around
-            logger.debug("No cache profile to update, adding filter profile message to queue. Message :{}", this);
+            logger.debug(
+                "No cache profile to update, adding filter profile message to queue. Message :{}",
+                this);
-          FilterProfile localFP = ((PartitionedRegion)r).getFilterProfile();
+          FilterProfile localFP = ((PartitionedRegion) r).getFilterProfile();
-          if (fp == null) {  // PR accessors do not keep filter profiles around
+          if (fp == null) { // PR accessors do not keep filter profiles around
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-      }
-      finally {
+      } finally {
-          fp.registerClientInterest(clientID, this.interest, InterestType.KEY, updatesAsInvalidates);
+          fp.registerClientInterest(clientID, this.interest, InterestType.KEY,
+              updatesAsInvalidates);
-          fp.registerClientInterest(clientID, this.interest, InterestType.REGULAR_EXPRESSION, updatesAsInvalidates);
+          fp.registerClientInterest(clientID, this.interest, InterestType.REGULAR_EXPRESSION,
+              updatesAsInvalidates);
-          fp.registerClientInterest(clientID, this.interest, InterestType.FILTER_CLASS, updatesAsInvalidates);
+          fp.registerClientInterest(clientID, this.interest, InterestType.FILTER_CLASS,
+              updatesAsInvalidates);
-          fp.registerClientInterestList(clientID, (List)this.interest, updatesAsInvalidates);
+          fp.registerClientInterestList(clientID, (List) this.interest, updatesAsInvalidates);
-          fp.unregisterClientInterestList(clientID, (List)this.interest);
+          fp.unregisterClientInterestList(clientID, (List) this.interest);
-          throw new IllegalArgumentException("Unknown filter profile operation type in operation: " + this);
+          throw new IllegalArgumentException(
+              "Unknown filter profile operation type in operation: " + this);
-    }      
-    
+    }
+
-            result = (CacheDistributionAdvisee)lr;
+            result = (CacheDistributionAdvisee) lr;
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-    
+
-      
+
-        out.writeUTF(((ServerCQ)this.cq).getServerCqName());
-        if (this.opType == operationType.REGISTER_CQ || 
-            this.opType == operationType.SET_CQ_STATE){
-          InternalDataSerializer.invokeToData((ServerCQ)this.cq, out);
+        out.writeUTF(((ServerCQ) this.cq).getServerCqName());
+        if (this.opType == operationType.REGISTER_CQ || this.opType == operationType.SET_CQ_STATE) {
+          InternalDataSerializer.invokeToData((ServerCQ) this.cq, out);
-      } 
+      }
-      if (isCqOp(this.opType)){
+      if (isCqOp(this.opType)) {
-        if (this.opType == operationType.REGISTER_CQ || 
-            this.opType == operationType.SET_CQ_STATE){
+        if (this.opType == operationType.REGISTER_CQ || this.opType == operationType.SET_CQ_STATE) {
-    
+
-      return this.getShortClassName() + "(processorId=" + this.processorId
-      + "; region=" + this.regionName
-      + "; operation=" + this.opType
-      + "; clientID=" + this.clientID
-      + "; profileVersion=" + this.profileVersion
-      + (isCqOp(this.opType)?("; CqName="+this.serverCqName):"")
-      + ")";
+      return this.getShortClassName() + "(processorId=" + this.processorId + "; region="
+          + this.regionName + "; operation=" + this.opType + "; clientID=" + this.clientID
+          + "; profileVersion=" + this.profileVersion
+          + (isCqOp(this.opType) ? ("; CqName=" + this.serverCqName) : "") + ")";
-    
+
-    
+
-        synchronized(this) {
+        synchronized (this) {
-          logger.trace(LogMarker.BRIDGE_SERVER, "Profile for {} mapped {} to {}", region.getFullPath(), realId, result);
+          logger.trace(LogMarker.BRIDGE_SERVER, "Profile for {} mapped {} to {}",
+              region.getFullPath(), realId, result);
-    
+
-    
-    
+
+
-     * given a collection of on-wire identifiers, this returns a set of
-     * the real identifiers (e.g., client IDs or durable queue IDs)
+     * given a collection of on-wire identifiers, this returns a set of the real identifiers (e.g.,
+     * client IDs or durable queue IDs)
+     * 
-      for (Object id: integerIDs) {
+      for (Object id : integerIDs) {
-    
+
+   * 
-  public boolean isInterestedInAllKeys(Object id){
+  public boolean isInterestedInAllKeys(Object id) {
-  
+
-   * Returns true if the client is interested in all keys, for which 
-   * updates are sent as invalidates.  
+   * Returns true if the client is interested in all keys, for which updates are sent as
+   * invalidates.
+   * 
-  public boolean isInterestedInAllKeysInv(Object id){
+  public boolean isInterestedInAllKeysInv(Object id) {
-  
+
+   * 
-  public Set getKeysOfInterest(Object id){
+  public Set getKeysOfInterest(Object id) {
-  
-  public int getKeysOfInterestSize(){
+
+  public int getKeysOfInterestSize() {
-  
+
-   * Returns the set of client interested keys for which updates are sent
-   * as invalidates.  
+   * Returns the set of client interested keys for which updates are sent as invalidates.
+   * 
-  public Set getKeysOfInterestInv(Object id){
+  public Set getKeysOfInterestInv(Object id) {
-  
-  public int getKeysOfInterestInvSize(){
+
+  public int getKeysOfInterestInvSize() {
-  
+
+   * 
-  public Set getPatternsOfInterest(Object id){
+  public Set getPatternsOfInterest(Object id) {
-    Map patterns = this.getPatternsOfInterest().get(clientMap.getWireID(id)); 
-    if (patterns != null){
+    Map patterns = this.getPatternsOfInterest().get(clientMap.getWireID(id));
+    if (patterns != null) {
-  
-  public int getPatternsOfInterestSize(){
-    return  this.getPatternsOfInterest().size(); 
+
+  public int getPatternsOfInterestSize() {
+    return this.getPatternsOfInterest().size();
-  
+
-   * Returns the set of client interested patterns for which updates are sent
-   * as invalidates.  
+   * Returns the set of client interested patterns for which updates are sent as invalidates.
+   * 
-  public Set getPatternsOfInterestInv(Object id){
+  public Set getPatternsOfInterestInv(Object id) {
-    if (interests != null){
+    if (interests != null) {
-  
-  public int getPatternsOfInterestInvSize(){
-    return  this.getPatternsOfInterestInv().size(); 
+
+  public int getPatternsOfInterestInvSize() {
+    return this.getPatternsOfInterestInv().size();
-  
+
+   * 
-  public Set getFiltersOfInterest(Object id){
+  public Set getFiltersOfInterest(Object id) {
-    if (interests != null){
+    if (interests != null) {
-  
+
-   * Returns the set of client interested filters for which updates are sent
-   * as invalidates.  
+   * Returns the set of client interested filters for which updates are sent as invalidates.
+   * 
-  public Set getFiltersOfInterestInv(Object id){
+  public Set getFiltersOfInterestInv(Object id) {
-    if (interests != null){
+    if (interests != null) {
-  
+
-  
+
+

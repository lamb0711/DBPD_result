GEODE-4059: Changing protobuf handshake to not need communication mode bytes

This closes pull request #1137

Squashed commit of the following:

commit d9f5144cd7f7ddcf42eb7eb5febed531cbf67362
Merge: 6fa9bf6c8 8fd707201
Author: Bruce Schuchardt <bschuchardt@pivotal.io>
Date:   Fri Dec 8 09:34:55 2017 -0800

    Merge branch 'feature/GEODE-4059' of https://github.com/WireBaron/geode into WireBaron-feature/GEODE-4059

commit 8fd707201f0e02b1fdf81c1596f93d3fd9ccb0cf
Author: Brian Rowe <browe@pivotal.io>
Date:   Thu Dec 7 14:53:28 2017 -0800

    Removing extra handshake from a unit test.

    Signed-off-by: Galen O'Sullivan <gosullivan@pivotal.io>

commit 7d07c6f5163d99b92a12ca856a1b397fda6e0eb4
Author: Galen O'Sullivan <gosullivan@pivotal.io>
Date:   Wed Dec 6 16:20:25 2017 -0800

    GEODE-4059: Changing protobuf handshake to not need communication mode bytes

    - Moved handshake proto messages into top level handshake.proto
    - Changed protobuf communication mode to match leading byte of handshake
    - Updated handshake handler and tests to handle changes
    - Modified locator to accept protobuf communication mode in lieu of gossip

    Signed-off-by: Brian Rowe <browe@pivotal.io>

+import org.apache.geode.cache.UnsupportedVersionException;
-      Object request, response;
-        int gossipVersion = readGossipVersion(socket, input);
+        // read the first byte & check for an improperly configured client pool trying
+        // to contact a cache server
+        int firstByte = input.readUnsignedByte();
+        if (firstByte == CommunicationMode.ReservedForGossip.getModeNumber()) {
+          processOneConnection(socket, startTime, input);
+        } else if (firstByte == CommunicationMode.ProtobufClientServerProtocol.getModeNumber()) {
+          handleProtobufConnection(socket, input);
+        } else if (CommunicationMode.isValidMode(firstByte)) {
+          socket.getOutputStream().write(HandShake.REPLY_SERVER_IS_LOCATOR);
+          throw new Exception("Improperly configured client detected - use addPoolLocator to "
+              + "configure its locators instead of addPoolServer.");
-        short versionOrdinal;
-        if (gossipVersion == NON_GOSSIP_REQUEST_VERSION) {
-          if (input.readUnsignedByte() == PROTOBUF_CLIENT_SERVER_PROTOCOL
-              && Boolean.getBoolean("geode.feature-protobuf-protocol")) {
-            try {
-              int protocolVersion = input.readUnsignedByte();
-              ClientProtocolService clientProtocolService =
-                  clientProtocolServiceLoader.lookupService(protocolVersion);
-              clientProtocolService.initializeStatistics("LocatorStats",
-                  internalLocator.getDistributedSystem());
-              try (ClientProtocolProcessor pipeline =
-                  clientProtocolService.createProcessorForLocator(internalLocator)) {
-                pipeline.processMessage(input, socket.getOutputStream());
-              } catch (IncompatibleVersionException e) {
-                // should not happen on the locator as there is no handshake.
-                log.error("Unexpected exception in client message processing", e);
-              }
-            } catch (ServiceLoadingFailureException e) {
-              log.error("There was an error looking up the client protocol service", e);
-              socket.close();
-              throw new IOException("There was an error looking up the client protocol service", e);
-            } catch (ServiceVersionNotFoundException e) {
-              log.error("Unable to find service matching the client protocol version byte", e);
-              socket.close();
-              throw new IOException(
-                  "Unable to find service matching the client protocol version byte", e);
-            }
-          } else {
-            rejectUnknownProtocolConnection(socket, gossipVersion);
-          }
-        } else if (gossipVersion <= getCurrentGossipVersion()
-            && GOSSIP_TO_GEMFIRE_VERSION_MAP.containsKey(gossipVersion)) {
-          // Create a versioned stream to remember sender's GemFire version
-          versionOrdinal = (short) GOSSIP_TO_GEMFIRE_VERSION_MAP.get(gossipVersion);
-
-          if (Version.GFE_71.compareTo(versionOrdinal) <= 0) {
-            // Recent versions of TcpClient will send the version ordinal
-            versionOrdinal = input.readShort();
-          }
-
-          if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
-            log.debug("Locator reading request from " + socket.getInetAddress() + " with version "
-                + Version.fromOrdinal(versionOrdinal, false));
-          }
-          input = new VersionedDataInputStream(input, Version.fromOrdinal(versionOrdinal, false));
-          request = DataSerializer.readObject(input);
-          if (log.isDebugEnabled()) {
-            log.debug("Locator received request " + request + " from " + socket.getInetAddress());
-          }
-          if (request instanceof ShutdownRequest) {
-            shuttingDown = true;
-            // Don't call shutdown from within the worker thread, see java bug #6576792.
-            // Closing the socket will cause our acceptor thread to shutdown the executor
-            this.serverSocketPortAtClose = srv_sock.getLocalPort();
-            srv_sock.close();
-            response = new ShutdownResponse();
-          } else if (request instanceof InfoRequest) {
-            response = handleInfoRequest(request);
-          } else if (request instanceof VersionRequest) {
-            response = handleVersionRequest(request);
-          } else {
-            response = handler.processRequest(request);
-          }
-
-          handler.endRequest(request, startTime);
-
-          startTime = DistributionStats.getStatTime();
-          if (response != null) {
-            DataOutputStream output = new DataOutputStream(socket.getOutputStream());
-            if (versionOrdinal != Version.CURRENT_ORDINAL) {
-              output =
-                  new VersionedDataOutputStream(output, Version.fromOrdinal(versionOrdinal, false));
-            }
-            DataSerializer.writeObject(response, output);
-            output.flush();
-          }
-
-          handler.endResponse(request, startTime);
-          // Close the socket. We can not accept requests from a newer version
-          rejectUnknownProtocolConnection(socket, gossipVersion);
+          rejectUnknownProtocolConnection(socket, firstByte);
-  private void rejectUnknownProtocolConnection(Socket socket, int gossipVersion)
-      throws IOException {
-    try {
-      socket.getOutputStream().write("unknown protocol version".getBytes());
-      socket.getOutputStream().flush();
-    } catch (IOException e) {
-      log.debug("exception in sending reply to process using unknown protocol " + gossipVersion, e);
-    }
-    socket.close();
-  }
-
-  private int readGossipVersion(Socket sock, DataInputStream input) throws Exception {
-    // read the first byte & check for an improperly configured client pool trying
-    // to contact a cache server
-    int firstByte = input.readUnsignedByte();
-    if (CommunicationMode.isValidMode(firstByte)) {
-      sock.getOutputStream().write(HandShake.REPLY_SERVER_IS_LOCATOR);
-      throw new Exception("Improperly configured client detected - use addPoolLocator to "
-          + "configure its locators instead of addPoolServer.");
-    }
-
-    int gossipVersion = firstByte;
+  private void processOneConnection(Socket socket, long startTime, DataInputStream input)
+      throws IOException, UnsupportedVersionException, ClassNotFoundException {
+    // At this point we've read the leading byte of the gossip version and found it to be 0,
+    // continue reading the next three bytes
+    int gossipVersion = 0;
-    return gossipVersion;
+
+    Object request;
+    Object response;
+    short versionOrdinal;
+    if (gossipVersion <= getCurrentGossipVersion()
+        && GOSSIP_TO_GEMFIRE_VERSION_MAP.containsKey(gossipVersion)) {
+      // Create a versioned stream to remember sender's GemFire version
+      versionOrdinal = (short) GOSSIP_TO_GEMFIRE_VERSION_MAP.get(gossipVersion);
+
+      if (Version.GFE_71.compareTo(versionOrdinal) <= 0) {
+        // Recent versions of TcpClient will send the version ordinal
+        versionOrdinal = input.readShort();
+      }
+
+      if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
+        log.debug("Locator reading request from " + socket.getInetAddress() + " with version "
+            + Version.fromOrdinal(versionOrdinal, false));
+      }
+      input = new VersionedDataInputStream(input, Version.fromOrdinal(versionOrdinal, false));
+      request = DataSerializer.readObject(input);
+      if (log.isDebugEnabled()) {
+        log.debug("Locator received request " + request + " from " + socket.getInetAddress());
+      }
+      if (request instanceof ShutdownRequest) {
+        shuttingDown = true;
+        // Don't call shutdown from within the worker thread, see java bug #6576792.
+        // Closing the socket will cause our acceptor thread to shutdown the executor
+        this.serverSocketPortAtClose = srv_sock.getLocalPort();
+        srv_sock.close();
+        response = new ShutdownResponse();
+      } else if (request instanceof InfoRequest) {
+        response = handleInfoRequest(request);
+      } else if (request instanceof VersionRequest) {
+        response = handleVersionRequest(request);
+      } else {
+        response = handler.processRequest(request);
+      }
+
+      handler.endRequest(request, startTime);
+
+      startTime = DistributionStats.getStatTime();
+      if (response != null) {
+        DataOutputStream output = new DataOutputStream(socket.getOutputStream());
+        if (versionOrdinal != Version.CURRENT_ORDINAL) {
+          output =
+              new VersionedDataOutputStream(output, Version.fromOrdinal(versionOrdinal, false));
+        }
+        DataSerializer.writeObject(response, output);
+        output.flush();
+      }
+
+      handler.endResponse(request, startTime);
+    } else {
+      // Close the socket. We can not accept requests from a newer version
+      rejectUnknownProtocolConnection(socket, gossipVersion);
+    }
+  }
+
+  private void rejectUnknownProtocolConnection(Socket socket, int gossipVersion) {
+    try {
+      socket.getOutputStream().write("unknown protocol version".getBytes());
+      socket.getOutputStream().flush();
+      socket.close();
+    } catch (IOException e) {
+      log.debug("exception in sending reply to process using unknown protocol " + gossipVersion, e);
+    }
+  }
+
+  private void handleProtobufConnection(Socket socket, DataInputStream input) throws Exception {
+    if (!Boolean.getBoolean("geode.feature-protobuf-protocol")) {
+      log.warn("Incoming protobuf connection, but protobuf not enabled on this locator.");
+      socket.close();
+      return;
+    }
+
+    try {
+      ClientProtocolService clientProtocolService = clientProtocolServiceLoader.lookupService();
+      clientProtocolService.initializeStatistics("LocatorStats",
+          internalLocator.getDistributedSystem());
+      try (ClientProtocolProcessor pipeline =
+          clientProtocolService.createProcessorForLocator(internalLocator)) {
+        pipeline.processMessage(input, socket.getOutputStream());
+      } catch (IncompatibleVersionException e) {
+        // should not happen on the locator as there is no handshake.
+        log.error("Unexpected exception in client message processing", e);
+      }
+    } catch (ServiceLoadingFailureException e) {
+      log.error("There was an error looking up the client protocol service", e);
+      socket.close();
+      throw new IOException("There was an error looking up the client protocol service", e);
+    } catch (ServiceVersionNotFoundException e) {
+      log.error("Unable to find service matching the client protocol version byte", e);
+      socket.close();
+      throw new IOException("Unable to find service matching the client protocol version byte", e);
+    }

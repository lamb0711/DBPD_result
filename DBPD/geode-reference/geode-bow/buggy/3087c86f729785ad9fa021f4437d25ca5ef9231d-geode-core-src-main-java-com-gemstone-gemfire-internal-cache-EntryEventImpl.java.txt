GEODE-982: refactor off-heap

- removed unused MemoryChunk implementations
- collapsed OffHeapCacheDeserializable into StoredObject
- Added Slab, SlabFactory, SlabImpl, and AddressableMemoryManager.
- collapsed MemoryChunkWithRefCount into StoredObject
- methods that access and modify the data now have Data in their name
- collapsed AddressableStoredObject into StoredObject
- changed product code to use the StoredObject interface
  instead of internal class implementations of it
- renamed DataAsAddress to TinyStoredObject
- renamed ObjectChunk to OffHeapStoredObject
- renamed ObjectChunkWithHeapForm to OffHeapStoredObjectWithHeapForm
- renamed allocateChunk to allocateOffHeapStoredObject
- renamed FakeChunk to SearchMarker
- renamed ObjectChunkSlice to OffHeapStoredObjectSlice
- renamed SyncChunkStack to OffHeapStoredObjectAddressStack
- renamed ChunkValueWrapper to OffHeapValueWrapper

-import com.gemstone.gemfire.internal.offheap.ObjectChunk;
-        if (ov instanceof StoredObject) {
-          // TODO OFFHEAP: returns off-heap PdxInstance
-          return ((StoredObject) ov).getValueAsDeserializedHeapObject();
-        } else
+        // TODO OFFHEAP: returns off-heap PdxInstance
-    if (v instanceof ObjectChunk) {
+    if (isOffHeapReference(v)) {
-      if (!((ObjectChunk) v).retain()) {
+      if (!((StoredObject) v).retain()) {
-    return (this.newValue instanceof ObjectChunk) || (this.oldValue instanceof ObjectChunk);
+    return isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue);
-    if (!this.offHeapOk && result instanceof ObjectChunk) {
+    if (!this.offHeapOk && isOffHeapReference(result)) {
+  private static boolean isOffHeapReference(Object ref) {
+    return (ref instanceof StoredObject) && ((StoredObject)ref).hasRefCount();
+  }
+  
-      if (curOldValue instanceof ObjectChunk) {
-        if (ReferenceCountHelper.trackReferenceCounts()) {
-          OffHeapHelper.releaseAndTrackOwner(curOldValue, new OldValueOwner());
-        } else {
-          OffHeapHelper.release(curOldValue);
-        }
+      if (ReferenceCountHelper.trackReferenceCounts()) {
+        OffHeapHelper.releaseAndTrackOwner(curOldValue, new OldValueOwner());
+      } else {
+        OffHeapHelper.release(curOldValue);
-    if (v instanceof ObjectChunk) {
+    if (isOffHeapReference(v)) {
+      StoredObject so = (StoredObject) v;
-        boolean couldNotRetain = (!((ObjectChunk) v).retain());
+        boolean couldNotRetain = (!so.retain());
-        if (!((ObjectChunk) v).retain()) {
+        if (!so.retain()) {
-    if (!this.offHeapOk && result instanceof ObjectChunk) {
+    if (!this.offHeapOk && isOffHeapReference(result)) {
-   * Note that in some cases sqlf ignores the request to deserialize.
-      if (nv instanceof StoredObject) {
-        // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
-        // TODO OFFHEAP: returns off-heap PdxInstance
-        return ((StoredObject) nv).getValueAsDeserializedHeapObject();
-      } else
+      // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
+      // TODO OFFHEAP: returns off-heap PdxInstance
-      if (tmp instanceof StoredObject) {
-        if (!((StoredObject) tmp).isSerialized()) {
-          // TODO OFFHEAP can we handle offheap byte[] better?
-          return null;
-        }
+      CachedDeserializable cd = (CachedDeserializable) tmp;
+      if (!cd.isSerialized()) {
+        // TODO OFFHEAP can we handle offheap byte[] better?
+        return null;
-      return new SerializedCacheValueImpl(this, getRegion(), this.re,
-          (CachedDeserializable)tmp, bytes);
+      return new SerializedCacheValueImpl(this, getRegion(), this.re, cd, bytes);
-      if (nv instanceof ObjectChunk) {
+      if (so.hasRefCount()) {
-      if (ov instanceof ObjectChunk) {
+      if (so.hasRefCount()) {
-   * Note that in some cases sqlf ignores the request to deserialize.
-    final Object tmp = basicGetNewValue();
-    if (tmp instanceof StoredObject) {
-      StoredObject result = (StoredObject) tmp;
-      if (!result.retain()) {
-        return null;
-      }
-      return result;
-    } else {
-      return null;
-    }
+    return convertToStoredObject(basicGetNewValue());
-    final Object tmp = basicGetOldValue();
-    if (tmp instanceof StoredObject) {
-      StoredObject result = (StoredObject) tmp;
-      if (!result.retain()) {
-        return null;
-      }
-      return result;
-    } else {
-      return null;
-    }
+    return convertToStoredObject(basicGetOldValue());
-  /**
-   * Result may be unretained because sqlf getDeserializedForReading returns unretained.
-   */
+  private static StoredObject convertToStoredObject(final Object tmp) {
+    if (!(tmp instanceof StoredObject)) {
+      return null;
+    }
+    StoredObject result = (StoredObject) tmp;
+    if (!result.retain()) {
+      return null;
+    }
+    return result;
+  }
+  
-      if (val instanceof StoredObject) {
-        // TODO OFFHEAP: returns off-heap PdxInstance
-        return ((StoredObject) val).getValueAsDeserializedHeapObject();
-      } else 
-      if (v instanceof ObjectChunk) {
-        if (!((ObjectChunk) v).isCompressed()) { // fix bug 52109
+      if (v instanceof StoredObject) {
+        if (!((StoredObject) v).isCompressed()) { // fix bug 52109
-      if (!success && reentry instanceof OffHeapRegionEntry && v instanceof ObjectChunk) {
-        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (ObjectChunk)v);
+      if (!success && reentry instanceof OffHeapRegionEntry && v instanceof StoredObject) {
+        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (StoredObject)v);
-   * to Chunk's off-heap address.
+   * to the StoredObject's off-heap address.
-  public static @Unretained Object deserializeChunk(ObjectChunk bytes) {
+  public static @Unretained Object deserializeOffHeap(StoredObject bytes) {
-          if (nv instanceof StoredObject) {
-            newValueSerialized = ((StoredObject) nv).isSerialized();
-          }
+          newValueSerialized = ((CachedDeserializable) nv).isSerialized();
-        if (ov instanceof StoredObject) {
-          oldValueSerialized = ((StoredObject) ov).isSerialized();
-        }
+        oldValueSerialized = ((CachedDeserializable) ov).isSerialized();
-      if (tmp instanceof StoredObject) {
-        if (!((StoredObject) tmp).isSerialized()) {
-          // TODO OFFHEAP can we handle offheap byte[] better?
-          return null;
-        }
+      CachedDeserializable cd = (CachedDeserializable) tmp;
+      if (!cd.isSerialized()) {
+        // TODO OFFHEAP can we handle offheap byte[] better?
+        return null;
-      return new SerializedCacheValueImpl(this, this.region, this.re,
-          (CachedDeserializable)tmp, this.oldValueBytes);
+      return new SerializedCacheValueImpl(this, this.region, this.re, cd, this.oldValueBytes);
-      if (cd instanceof ObjectChunk) {
+      if (isOffHeapReference(cd)) {
+
+    @Override
+    public boolean isSerialized() {
+      return getCd().isSerialized();
+    }
+
+    @Override
+    public boolean usesHeapForStorage() {
+      return getCd().usesHeapForStorage();
+    }
-    if (ov instanceof ObjectChunk) {
+    if (ov instanceof StoredObject) {
-        ((ObjectChunk) ov).release();
+        ((StoredObject) ov).release();
-        ((ObjectChunk) ov).release();
+        ((StoredObject) ov).release();
-    if (this.newValue instanceof ObjectChunk || this.oldValue instanceof ObjectChunk) {
+    if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
-   * @throws IllegalStateException if called with an event for sqlf data.
-    if (ov instanceof ObjectChunk) {
+    if (isOffHeapReference(ov)) {
-    if (nv instanceof ObjectChunk) {
+    if (isOffHeapReference(nv)) {
-    if (this.newValue instanceof ObjectChunk || this.oldValue instanceof ObjectChunk) {
+    if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
-    return this.oldValue instanceof ObjectChunk;
+    return isOffHeapReference(this.oldValue);

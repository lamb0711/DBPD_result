Consolidate Http request

-import java.net.URISyntaxException;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.List;
-import org.apache.commons.io.FileUtils;
-import org.apache.commons.lang.StringUtils;
-import org.springframework.http.HttpEntity;
-import org.springframework.http.HttpHeaders;
-import org.springframework.http.HttpMethod;
-import org.springframework.http.ResponseEntity;
-import org.springframework.http.client.ClientHttpResponse;
-import org.springframework.http.client.SimpleClientHttpRequestFactory;
-import org.springframework.http.converter.HttpMessageConverter;
-import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
-import org.springframework.web.client.ResourceAccessException;
-import org.springframework.web.client.RestTemplate;
-import org.springframework.web.util.UriComponentsBuilder;
-import org.apache.geode.annotations.TestingOnly;
-import org.apache.geode.internal.GemFireVersion;
-import org.apache.geode.management.internal.web.http.converter.SerializableObjectHttpMessageConverter;
-import org.apache.geode.management.internal.web.http.support.SimpleHttpRequester;
+import org.apache.geode.management.internal.web.http.support.HttpRequester;
-  private static final long DEFAULT_INITIAL_DELAY = TimeUnit.SECONDS.toMillis(1);
-  private static final long DEFAULT_PERIOD = TimeUnit.MILLISECONDS.toMillis(2000);
-
-  private static final String REST_API_BASE_URL = "http://localhost:8080";
-  private static final String REST_API_VERSION = "/v1";
-  private static final String REST_API_WEB_APP_CONTEXT = "/geode-mgmt";
-  private static final String REST_API_URL =
-      REST_API_BASE_URL + REST_API_WEB_APP_CONTEXT + REST_API_VERSION;
-  private static final String USER_AGENT_HTTP_REQUEST_HEADER_VALUE =
-      "GemFire-Shell/v" + GemFireVersion.getGemFireVersion();
-
-  private static final TimeUnit DEFAULT_TIME_UNIT = TimeUnit.MILLISECONDS;
+  protected static final long DEFAULT_INITIAL_DELAY = TimeUnit.SECONDS.toMillis(1);
+  protected static final long DEFAULT_PERIOD = TimeUnit.MILLISECONDS.toMillis(2000);
+  protected static final TimeUnit DEFAULT_TIME_UNIT = TimeUnit.MILLISECONDS;
+  protected static final String CMD_QUERY_PARAMETER = "cmd";
+  protected static final String COMMANDS_URI = "/management/commands";
+  protected static final String RESOURCES_REQUEST_PARAMETER = "resources";
-  private static final String RESOURCES_REQUEST_PARAMETER = "resources";
-
-  // hosting the M&M REST API (interface)
-  // a list of acceptable content/media types supported by Gfsh
-  private final List<MediaType> acceptableMediaTypes = Arrays.asList(MediaType.APPLICATION_JSON,
-      MediaType.TEXT_PLAIN, MediaType.APPLICATION_OCTET_STREAM);
+  private final String baseUrl;
-  private volatile RestTemplate restTemplate;
+  private volatile HttpRequester httpRequester;
-  // the base URL of the GemFire Manager's embedded HTTP service and REST API interface
-  private final String baseUrl;
-
-
-  protected Properties securityProperties;
-
-  /**
-   * Default no-arg constructor to create an instance of the SimpleHttpOperationInvoker class for
-   * testing purposes.
-   */
-  @TestingOnly
-  HttpOperationInvoker() {
-    this(REST_API_URL);
-  }
-
-  /**
-   * Default, public, no-arg constructor to create an instance of the HttpOperationInvoker class for
-   * testing purposes.
-   */
-  @TestingOnly
-  private HttpOperationInvoker(final String baseUrl) {
-    this.baseUrl = baseUrl;
-    this.executorService = null;
-    this.gfsh = null;
-    this.restTemplate = null;
-  }
+  private boolean connected = false;
-   * via HTTP for processing along with the base URL to the GemFire Manager's embedded HTTP service
+   * via HTTP for procsessing along with the base URL to the GemFire Manager's embedded HTTP service
-    this.baseUrl = StringUtils.defaultIfBlank(baseUrl, REST_API_URL);
-    this.securityProperties = securityProperties;
+    this.baseUrl = baseUrl;
+    this.httpRequester = new HttpRequester(securityProperties);
+
+    // request ping and then schedule the ping to access the "alive" state, this will trigger
+    // authentication check
+    httpRequester.get(HttpRequester.createURI(baseUrl, "/ping"), String.class);
+    connected = true;
-    // requests to the Manager's
-    // HTTP service or Web Service to assess the "alive" state
+    // requests to the Manager's HTTP service or Web Service to assess the "alive" state
-
-    // constructs an instance of the Spring RestTemplate for M&M REST API (interface) operations
-    this.restTemplate = new RestTemplate(new SimpleClientHttpRequestFactory());
-
-    // add our custom HttpMessageConverter for serializing DTO Objects into the HTTP request
-    // message body and de-serializing HTTP response message body content back into DTO Objects
-    List<HttpMessageConverter<?>> converters = this.restTemplate.getMessageConverters();
-    // remove the MappingJacksonHttpConverter
-    for (int i = converters.size() - 1; i >= 0; i--) {
-      HttpMessageConverter converter = converters.get(i);
-      if (converter instanceof MappingJackson2HttpMessageConverter) {
-        converters.remove(converter);
-      }
-    }
-    converters.add(new SerializableObjectHttpMessageConverter());
-
-    // set the ResponseErrorHandler handling any errors originating from our HTTP request
-    this.restTemplate.setErrorHandler(new RestOperationErrorHandler(gfsh));
-
-    setupBackgroundPingRequest();
-    initClusterId();
-  }
-
-  private void setupBackgroundPingRequest() {
-    SimpleHttpRequester requester = new SimpleHttpRequester(gfsh, securityProperties);
-    getExecutorService().scheduleAtFixedRate(() -> {
+    executorService.scheduleAtFixedRate(() -> {
-        requester.exchange(baseUrl.concat("/ping"), String.class);
+        httpRequester.get(HttpRequester.createURI(baseUrl, "/ping"), String.class);
+
+    // initialize cluster id
+    clusterId = (Integer) getAttribute(ManagementConstants.OBJECTNAME__DISTRIBUTEDSYSTEM_MXBEAN,
+        "DistributedSystemId");
-  private ScheduledExecutorService getExecutorService() {
+  protected ScheduledExecutorService getExecutorService() {
-   * Returns a reference to the Spring RestTemplate used by this HTTP-based OperationInvoker to send
-   * HTTP requests to GemFire's REST interface, making REST API calls.
-   *
-   * @return an instance of the Spring RestTemplate used to make REST API web service calls.
-   * @see org.springframework.web.client.RestTemplate
-   */
-  private RestTemplate getRestTemplate() {
-    return this.restTemplate;
-  }
-
-  /**
-   * Handles resource access errors such as ConnectExceptions when the server-side process/service
-   * is not listening for client connections, or the connection to the server/service fails.
-   *
-   * @param e the ResourceAccessException resulting in some sort of I/O error.
-   * @return a user-friendly String message describing the problem and appropriate action/response
-   *         by the user.
-   * @see #stop()
-   * @see org.springframework.web.client.ResourceAccessException
-   */
-  protected String handleResourceAccessException(final ResourceAccessException e) {
-    stop();
-
-    return String.format(
-        "The connection to the GemFire Manager's HTTP service @ %1$s failed with: %2$s. "
-            + "Please try reconnecting or see the GemFire Manager's log file for further details.",
-        baseUrl, e.getMessage());
-  }
-
-  /**
-  private void printDebug(final String message, final Object... args) {
+  protected void printDebug(final String message, final Object... args) {
-  private <T> T get(URI url, Class<T> responseType) {
-    return send(url, HttpMethod.GET, null, null, responseType);
-  }
-  private <T> T post(URI url, MediaType mediaType, Object content, Class<T> responseType) {
-    return send(url, HttpMethod.POST, mediaType, content, responseType);
-  }
-
-
-  private <T> T send(URI url, HttpMethod method, MediaType mediaType, Object content,
-      Class<T> responseType) {
-    HttpHeaders headers = new HttpHeaders();
-    headers.add(HttpHeaders.USER_AGENT, USER_AGENT_HTTP_REQUEST_HEADER_VALUE);
-    headers.setAccept(acceptableMediaTypes);
-    if (mediaType != null) {
-      headers.setContentType(mediaType);
-    }
-
-    if (this.securityProperties != null) {
-      for (String key : securityProperties.stringPropertyNames()) {
-        headers.add(key, securityProperties.getProperty(key));
-      }
-    }
-
-    HttpEntity<Object> httpEntity = new HttpEntity<>(content, headers);
-
-    final ResponseEntity<T> response =
-        getRestTemplate().exchange(url, method, httpEntity, responseType);
-    return response.getBody();
-  }
-
-  Object extractResponse(ClientHttpResponse response) throws IOException {
-    MediaType mediaType = response.getHeaders().getContentType();
-    if (mediaType.equals(MediaType.APPLICATION_JSON)) {
-      return org.apache.commons.io.IOUtils.toString(response.getBody(), "UTF-8");
-    } else {
-      Path tempFile = Files.createTempFile("fileDownload", "");
-      if (tempFile.toFile().exists()) {
-        FileUtils.deleteQuietly(tempFile.toFile());
-      }
-      Files.copy(response.getBody(), tempFile);
-      return tempFile;
-    }
-  }
-
-  private void addHeaderValues(org.springframework.http.client.ClientHttpRequest request) {
-    // update the headers
-    request.getHeaders().add(HttpHeaders.USER_AGENT, USER_AGENT_HTTP_REQUEST_HEADER_VALUE);
-    request.getHeaders().setAccept(acceptableMediaTypes);
-
-    if (this.securityProperties != null) {
-      for (String key : securityProperties.stringPropertyNames()) {
-        request.getHeaders().add(key, securityProperties.getProperty(key));
-      }
-    }
-  }
-    return (getRestTemplate() != null);
+    return connected;
-
-  private URI createURI(String path) {
-    try {
-      return new URI(baseUrl + path);
-    } catch (URISyntaxException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-    final URI link = UriComponentsBuilder.fromHttpUrl(baseUrl).path("/mbean/attribute")
-        .queryParam("resourceName", resourceName).queryParam("attributeName", attributeName).build()
-        .encode().toUri();
+    final URI link = HttpRequester.createURI(baseUrl, "/mbean/attribute", "resourceName",
+        resourceName, "attributeName", attributeName);
-      return IOUtils.deserializeObject(get(link, byte[].class));
+      return IOUtils.deserializeObject(httpRequester.get(link, byte[].class));
-  /**
-   * Gets the identifier of the GemFire cluster.
-   *
-   * @return an integer value indicating the identifier of the GemFire cluster.
-   */
-  private void initClusterId() {
-    if (isReady()) {
-      try {
-        clusterId = (Integer) getAttribute(ManagementConstants.OBJECTNAME__DISTRIBUTEDSYSTEM_MXBEAN,
-            "DistributedSystemId");
-        printDebug("Cluster ID (%1$s)", clusterId);
-      } catch (Exception ignore) {
-        printDebug("Failed to determine cluster ID: %1$s", ignore.getMessage());
-      }
-    }
-  }
-
-    final URI link = createURI("/mbean/operation");
+    final URI link = HttpRequester.createURI(baseUrl, "/mbean/operation");
-    MultiValueMap<String, Object> content = new LinkedMultiValueMap<>();
+    MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
-      byte[] postResult = post(link, MediaType.MULTIPART_FORM_DATA, content, byte[].class);
-      return IOUtils.deserializeObject(postResult);
+      return IOUtils.deserializeObject(
+          httpRequester.post(link, MediaType.MULTIPART_FORM_DATA, content, byte[].class));
-    final URI link = createURI("/mbean/query");
+    final URI link = HttpRequester.createURI(baseUrl, "/mbean/query");
-      return (Set<ObjectName>) IOUtils.deserializeObject(post(link, null, content, byte[].class));
+      return (Set<ObjectName>) IOUtils
+          .deserializeObject(httpRequester.post(link, null, content, byte[].class));
-
-    restTemplate = null;
+    httpRequester = null;
+    connected = false;
-    return String.format("GemFire Manager HTTP service @ %1$s", baseUrl);
+    return String.format("GemFire Manager HTTP service @ %1$s", httpRequester);
-    URI link = command.getHttpRequestUrl(baseUrl);
+    URI link =
+        HttpRequester.createURI(baseUrl, COMMANDS_URI, CMD_QUERY_PARAMETER, command.getUserInput());
-      MultiValueMap<String, Object> content = new LinkedMultiValueMap<>();
+      MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
-      return post(link, MediaType.MULTIPART_FORM_DATA, content, String.class);
+      return httpRequester.post(link, MediaType.MULTIPART_FORM_DATA, content, String.class);
-    return getRestTemplate().execute(link, HttpMethod.POST, this::addHeaderValues,
-        this::extractResponse);
+    // when no file data to upload, this handles file download over http
+    return httpRequester.executeWithResponseExtractor(link);

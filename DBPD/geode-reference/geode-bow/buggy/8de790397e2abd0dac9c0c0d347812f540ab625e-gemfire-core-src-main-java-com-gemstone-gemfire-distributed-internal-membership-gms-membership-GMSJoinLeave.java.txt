GEODE-77 improved suspect processing, multicast fix for Windows

GMSHealthMonitor was allowing the service to watch itself if it ran out of other members to watch.  This change set modifies that behavior to set the "next neighbor" to null, causing suspect processing to halt until a member transitions out of "suspect" state or a new membership view is installed.

I also found that GMSHealthMonitor wasn't notifying the Manager when a member goes into final-check state, so that membership listeners weren't being notified of suspect events.  This was causing a unit test failure.

JGroupsMessenger now fools the JGroups stack into thinking an IPv4 stack is being used even if IPv6 is available, so that JGroups will use an IPv4 address.  JGroups was selecting an IPv6 address, making communications with IPv4 members impossible and causing a schizm between the GemFire member address and the JGroups address.

The JGroups log level is now set to WARN in the default log4j2.xml settings file.

-    if (Boolean.getBoolean(BYPASS_DISCOVERY)) {
-      becomeCoordinator();
-      return true;
-    }
-    
-    SearchState state = searchState;
-    
-    long timeout = services.getConfig().getJoinTimeout();
-    logger.debug("join timeout is set to {}", timeout);
-    long retrySleep =  JOIN_RETRY_SLEEP;
-    long startTime = System.currentTimeMillis();
-    long giveupTime = startTime + timeout;
-
-    for (int tries=0; !this.isJoined; tries++) {
-
-      boolean found = findCoordinator();
-      if (found) {
-        logger.debug("found possible coordinator {}", state.possibleCoordinator);
-        if (localAddress.getNetMember().preferredForCoordinator()
-            && state.possibleCoordinator.equals(this.localAddress)) {
-          if (tries > 2 || System.currentTimeMillis() < giveupTime ) {
-            becomeCoordinator();
-            return true;
+    try {
+      if (Boolean.getBoolean(BYPASS_DISCOVERY)) {
+        becomeCoordinator();
+        return true;
+      }
+      
+      SearchState state = searchState;
+      
+      long timeout = services.getConfig().getJoinTimeout();
+      logger.debug("join timeout is set to {}", timeout);
+      long retrySleep =  JOIN_RETRY_SLEEP;
+      long startTime = System.currentTimeMillis();
+      long giveupTime = startTime + timeout;
+  
+      for (int tries=0; !this.isJoined; tries++) {
+        logger.debug("searching for the membership coordinator");
+        boolean found = findCoordinator();
+        if (found) {
+          logger.debug("found possible coordinator {}", state.possibleCoordinator);
+          if (localAddress.getNetMember().preferredForCoordinator()
+              && state.possibleCoordinator.equals(this.localAddress)) {
+            if (tries > 2 || System.currentTimeMillis() < giveupTime ) {
+              becomeCoordinator();
+              return true;
+            }
+          } else {
+            if (attemptToJoin()) {
+              return true;
+            }
+            if (System.currentTimeMillis() > giveupTime) {
+              break;
+            }
+            if (!state.possibleCoordinator.equals(localAddress)) {
+              state.alreadyTried.add(state.possibleCoordinator);
+            }
-          if (attemptToJoin()) {
-            return true;
-          }
-          if (!state.possibleCoordinator.equals(localAddress)) {
-            state.alreadyTried.add(state.possibleCoordinator);
-          }
-      } else {
-        if (System.currentTimeMillis() > giveupTime) {
-          break;
+        try {
+          logger.debug("sleeping for {} before making another attempt to find the coordinator", retrySleep);
+          Thread.sleep(retrySleep);
+        } catch (InterruptedException e) {
+          logger.debug("retry sleep interrupted - giving up on joining the distributed system");
+          return false;
+        }
+      } // for
+      
+      if (!this.isJoined) {
+        logger.debug("giving up attempting to join the distributed system after " + (System.currentTimeMillis() - startTime) + "ms");
+      }
+      
+      // to preserve old behavior we need to throw a SystemConnectException if
+      // unable to contact any of the locators
+      if (!this.isJoined && state.hasContactedALocator) {
+        throw new SystemConnectException("Unable to join the distributed system in "
+           + (System.currentTimeMillis()-startTime) + "ms");
+      }
+      
+      return this.isJoined;
+    } finally {
+      // notify anyone waiting on the address to be completed
+      if (this.isJoined) {
+        synchronized(this.localAddress) {
+          this.localAddress.notifyAll();
-      try {
-        Thread.sleep(retrySleep);
-      } catch (InterruptedException e) {
-        logger.debug("retry sleep interrupted - giving up on joining the distributed system");
-        return false;
-      }
-    } // for
-    
-    if (!this.isJoined) {
-      logger.debug("giving up attempting to join the distributed system after " + (System.currentTimeMillis() - startTime) + "ms");
-    
-    // to preserve old behavior we need to throw a SystemConnectException if
-    // unable to contact any of the locators
-    if (!this.isJoined && state.hasContactedALocator) {
-      throw new SystemConnectException("Unable to join the distributed system in "
-         + (System.currentTimeMillis()-startTime) + "ms");
-    }
-    
-    return this.isJoined;
-    logger.info((preparing? "preparing" : "sending") + " new view " + view);
-
+      logger.info("no recipients for new view aside from myself");
+    logger.info((preparing? "preparing" : "sending") + " new view " + view);
+
+    pendingRemovals.removeAll(view.getCrashedMembers());
-logger.debug("waiting for view responses");
+      logger.debug("waiting for view responses");
+      
-    logger.info("Membership: processing {}", m);
+    logger.debug("Membership: processing {}", m);
-            anyResponses = false;
+            anyResponses = true;
-              
-              boolean enabled = response.isNetworkPartitionDetectionEnabled();
-              if (!enabled && services.getConfig().isNetworkPartitionDetectionEnabled()) {
-                throw new GemFireConfigException("locator at "+addr
-                    +" does not have network-partition-detection enabled but my configuration has it enabled");
-              }
-
-              GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
-              mbr.setSplitBrainEnabled(enabled);
-              services.getConfig().setNetworkPartitionDetectionEnabled(enabled);
-              services.getConfig().getDistributionConfig().setEnableNetworkPartitionDetection(enabled);
-
-              if (response.isUsePreferredCoordinators()) {
-                this.quorumRequired = true;
-                logger.debug("The locator indicates that all locators should be preferred as coordinators");
-                if (services.getLocator() != null
-                    || Locator.hasLocator()
-                    || !services.getConfig().getDistributionConfig().getStartLocator().isEmpty()
-                    || localAddress.getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
-                  ((GMSMember)localAddress.getNetMember()).setPreferredForCoordinator(true);
-                }
-              } else {
-                ((GMSMember)localAddress.getNetMember()).setPreferredForCoordinator(true);
-              }
+              inheritSettingsFromLocator(addr, response);
-        try { Thread.sleep(2000); } catch (InterruptedException e) {
+        try { Thread.sleep(1000); } catch (InterruptedException e) {
+   * Some settings are gleaned from locator responses and set into the local
+   * configuration
+   */
+  private void inheritSettingsFromLocator(InetSocketAddress addr, FindCoordinatorResponse response) {
+    boolean enabled = response.isNetworkPartitionDetectionEnabled();
+    if (!enabled && services.getConfig().isNetworkPartitionDetectionEnabled()) {
+      throw new GemFireConfigException("locator at "+addr
+          +" does not have network-partition-detection enabled but my configuration has it enabled");
+    }
+
+    GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
+    mbr.setSplitBrainEnabled(enabled);
+    services.getConfig().setNetworkPartitionDetectionEnabled(enabled);
+    services.getConfig().getDistributionConfig().setEnableNetworkPartitionDetection(enabled);
+
+    if (response.isUsePreferredCoordinators()) {
+      this.quorumRequired = true;
+      logger.debug("The locator indicates that all locators should be preferred as coordinators");
+      if (services.getLocator() != null
+          || Locator.hasLocator()
+          || !services.getConfig().getDistributionConfig().getStartLocator().isEmpty()
+          || localAddress.getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
+        ((GMSMember)localAddress.getNetMember()).setPreferredForCoordinator(true);
+      }
+    } else {
+      ((GMSMember)localAddress.getNetMember()).setPreferredForCoordinator(true);
+    }
+  }
+  
+  /**
-      if (logger.isInfoEnabled()) {
+      if (logger.isInfoEnabled()
+          && !newView.getCreator().equals(localAddress)) { // view-creator logs this
-    // TODO Auto-generated method stub
-    
+  }
+
+  @Override
+  public void memberSuspected(InternalDistributedMember initiator, InternalDistributedMember suspect) {
+    prepareProcessor.memberSuspected(initiator, suspect);
+    viewProcessor.memberSuspected(initiator, suspect);
-      notRepliedYet.removeAll(pendingLeaves);
+    synchronized void memberSuspected(InternalDistributedMember initiator,
+        InternalDistributedMember suspect) {
+      if (waiting) {
+        // we will do a final check on this member if it hasn't already
+        // been done, so stop waiting for it now
+        logger.debug("view response processor recording suspect status for {}", suspect);
+        pendingRemovals.add(suspect);
+        checkIfDone();
+      }
+    }
+    
+        logger.debug("view response processor recording leave request for {}", mbr);
+        logger.debug("view response processor recording remove request for {}", mbr);
+        checkIfDone();
+        logger.debug("view response processor recording response for {}", sender);
+      checkIfDone();
+    }
+    
+    /** call with synchronized(this) */
+    private void checkIfDone() {
+      } else {
+        logger.debug("Still waiting for these view replies: {}", notRepliedYet);
+              if (viewRequests.size() == 1) {
+                // start the timer when we have only one request because
+                // concurrent startup / shutdown of multiple members is
+                // a common occurrence
+                okayToCreateView = System.currentTimeMillis() + MEMBER_REQUEST_COLLECTION_INTERVAL;
+                continue;
+              }
+        logger.debug("view preparation phase completed.  prepared={}", prepared);
+
-        try {
-          removeHealthyMembers(unresponsive);
-        } catch (InterruptedException e) {
-          // abort the view if interrupted
-          shutdown = true;
-          return;
+        if (!unresponsive.isEmpty()) {
+          try {
+            removeHealthyMembers(unresponsive);
+          } catch (InterruptedException e) {
+            // abort the view if interrupted
+            shutdown = true;
+            return;
+          }

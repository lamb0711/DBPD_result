Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-  
+
-  
+
-   * Does a region put on a server using connections from the given pool
-   * to communicate with the server.
+   * Does a region put on a server using connections from the given pool to communicate with the
+   * server.
+   * 
-  public static Object execute(ExecutablePool pool,
-                             LocalRegion region,
-                             Object key,
-                             Object value,
-                             byte[] deltaBytes,
-                             EntryEventImpl event,
-                             Operation operation,
-                             boolean requireOldValue, Object expectedOldValue,
-                             Object callbackArg,
-                             boolean prSingleHopEnabled) {
-    PutOpImpl op = new PutOpImpl(region, key, value, deltaBytes, event,
-        operation, requireOldValue,
-        expectedOldValue, callbackArg,
-        false/*donot send full obj; send delta*/, prSingleHopEnabled);
+  public static Object execute(ExecutablePool pool, LocalRegion region, Object key, Object value,
+      byte[] deltaBytes, EntryEventImpl event, Operation operation, boolean requireOldValue,
+      Object expectedOldValue, Object callbackArg, boolean prSingleHopEnabled) {
+    PutOpImpl op = new PutOpImpl(region, key, value, deltaBytes, event, operation, requireOldValue,
+        expectedOldValue, callbackArg, false/* donot send full obj; send delta */,
+        prSingleHopEnabled);
-      ServerLocation server = cms.getBucketServerLocation(region,
-          Operation.UPDATE, key, value, callbackArg);
+      ServerLocation server =
+          cms.getBucketServerLocation(region, Operation.UPDATE, key, value, callbackArg);
-          PoolImpl poolImpl = (PoolImpl)pool;
-          boolean onlyUseExistingCnx = ((poolImpl.getMaxConnections() != -1 && poolImpl
-              .getConnectionCount() >= poolImpl.getMaxConnections()) ? true
-              : false);
-          op.setAllowDuplicateMetadataRefresh(! onlyUseExistingCnx);
-          return pool.executeOn(new ServerLocation(server.getHostName(), server
-              .getPort()), op, true, onlyUseExistingCnx);
-        }
-        catch (AllConnectionsInUseException e) {
-        }
-        catch (ServerConnectivityException e) {
+          PoolImpl poolImpl = (PoolImpl) pool;
+          boolean onlyUseExistingCnx = ((poolImpl.getMaxConnections() != -1
+              && poolImpl.getConnectionCount() >= poolImpl.getMaxConnections()) ? true : false);
+          op.setAllowDuplicateMetadataRefresh(!onlyUseExistingCnx);
+          return pool.executeOn(new ServerLocation(server.getHostName(), server.getPort()), op,
+              true, onlyUseExistingCnx);
+        } catch (AllConnectionsInUseException e) {
+        } catch (ServerConnectivityException e) {
-  
-  public static Object execute(ExecutablePool pool, String regionName,
-      Object key, Object value, byte[] deltaBytes, EntryEventImpl event, Operation operation,
-      boolean requireOldValue, Object expectedOldValue,
-      Object callbackArg, boolean prSingleHopEnabled, boolean isMetaRegionPutOp) {
-    AbstractOp op = new PutOpImpl(regionName, key, value, deltaBytes, event,
-        operation, requireOldValue,
-        expectedOldValue, callbackArg,
-        false/*donot send full obj; send delta*/,  prSingleHopEnabled);
-    ((PutOpImpl)op).setMetaRegionPutOp(isMetaRegionPutOp);
+  public static Object execute(ExecutablePool pool, String regionName, Object key, Object value,
+      byte[] deltaBytes, EntryEventImpl event, Operation operation, boolean requireOldValue,
+      Object expectedOldValue, Object callbackArg, boolean prSingleHopEnabled,
+      boolean isMetaRegionPutOp) {
+
+    AbstractOp op = new PutOpImpl(regionName, key, value, deltaBytes, event, operation,
+        requireOldValue, expectedOldValue, callbackArg, false/* donot send full obj; send delta */,
+        prSingleHopEnabled);
+    ((PutOpImpl) op).setMetaRegionPutOp(isMetaRegionPutOp);
-  
+
-   * This is a unit test method.
-   * It does a region put on a server using the given connection from the given pool
-   * to communicate with the server. Do not call this method if the value is 
-   * Delta instance.
-   * @param con the connection to use 
+   * This is a unit test method. It does a region put on a server using the given connection from
+   * the given pool to communicate with the server. Do not call this method if the value is Delta
+   * instance.
+   * 
+   * @param con the connection to use
-  public static void execute(Connection con,
-                             ExecutablePool pool,
-                             String regionName,
-                             Object key,
-                             Object value,
-                             EntryEventImpl event,
-                             Object callbackArg,
-                             boolean prSingleHopEnabled) {
-    AbstractOp op = new PutOpImpl(regionName, key, value, null,
-        event, Operation.CREATE, false,
-        null, callbackArg, false /*donot send full Obj; send delta*/, prSingleHopEnabled);
+  public static void execute(Connection con, ExecutablePool pool, String regionName, Object key,
+      Object value, EntryEventImpl event, Object callbackArg, boolean prSingleHopEnabled) {
+    AbstractOp op = new PutOpImpl(regionName, key, value, null, event, Operation.CREATE, false,
+        null, callbackArg, false /* donot send full Obj; send delta */, prSingleHopEnabled);
-                                                               
+
-  
+
-    
+
-    
+
-     * the operation will have either a region or a regionName.  Names seem
-     * to be used by unit tests to exercise operations without creating a
-     * real region 
+     * the operation will have either a region or a regionName. Names seem to be used by unit tests
+     * to exercise operations without creating a real region
-    
+
-    
+
-    
+
-    
-    
-    public PutOpImpl(String regionName , Object key, Object value, byte[] deltaBytes, 
-        EntryEventImpl event,
-        Operation op, boolean requireOldValue,
-        Object expectedOldValue, Object callbackArg,
-        boolean sendFullObj, boolean prSingleHopEnabled) {
-        super(MessageType.PUT, 7 + (callbackArg != null? 1:0) + (expectedOldValue != null? 1:0));
-        final boolean isDebugEnabled = logger.isDebugEnabled();
-        if (isDebugEnabled) {
-          logger.debug("PutOpImpl constructing(1) message for {}; operation={}", event.getEventId(), op);
-        }
-        this.key = key;
-        this.callbackArg = callbackArg;
-        this.event = event;
-        this.value = value;
-        this.regionName = regionName;
-        this.prSingleHopEnabled = prSingleHopEnabled;
-        this.requireOldValue = requireOldValue;
-        this.expectedOldValue = expectedOldValue;
-        getMessage().addStringPart(regionName);
-        getMessage().addObjPart(op);
-        int flags = 0;
-        if (requireOldValue) flags |= 0x01;
-        if (expectedOldValue != null) flags |= 0x02;
-        getMessage().addIntPart(flags);
-        if (expectedOldValue != null) {
-          getMessage().addObjPart(expectedOldValue);
-        }
-        getMessage().addStringOrObjPart(key);
-        // Add message part for sending either delta or full value
-        if (!sendFullObj && deltaBytes != null && op == Operation.UPDATE) {
-          getMessage().addObjPart(Boolean.TRUE);
-          getMessage().addBytesPart(deltaBytes);
-          this.deltaSent = true;
-          if (isDebugEnabled) {
-            logger.debug("PutOp: Sending delta for key {}", this.key);
-          }
-        }
-        else if (value instanceof CachedDeserializable) {
-          CachedDeserializable cd = (CachedDeserializable) value;
-          if (!cd.isSerialized()) {
-            // it is a byte[]
-            getMessage().addObjPart(Boolean.FALSE);
-            getMessage().addObjPart(cd.getDeserializedForReading());
-          } else {
-            getMessage().addObjPart(Boolean.FALSE);
-            Object cdValue = cd.getValue();
-            if (cdValue instanceof byte[]) {
-              getMessage().addRawPart((byte[])cdValue, true);
-            }
-            else {
-              getMessage().addObjPart(cdValue);
-            }
-          }
-        }
-        else {
-          getMessage().addObjPart(Boolean.FALSE);
-          getMessage().addObjPart(value);
-        }
-        getMessage().addBytesPart(event.getEventId().calcBytes());
-        if (callbackArg != null) {
-          getMessage().addObjPart(callbackArg);
-        }
-    }
-    public PutOpImpl(Region region, Object key, Object value, byte[] deltaBytes,
-        EntryEventImpl event, 
-        Operation op, boolean requireOldValue, 
-        Object expectedOldValue, Object callbackArg,
-        boolean sendFullObj, boolean prSingleHopEnabled) {
-      super(MessageType.PUT, 7 + (callbackArg != null? 1:0) + (expectedOldValue != null? 1:0));
+
+    public PutOpImpl(String regionName, Object key, Object value, byte[] deltaBytes,
+        EntryEventImpl event, Operation op, boolean requireOldValue, Object expectedOldValue,
+        Object callbackArg, boolean sendFullObj, boolean prSingleHopEnabled) {
+      super(MessageType.PUT,
+          7 + (callbackArg != null ? 1 : 0) + (expectedOldValue != null ? 1 : 0));
+      final boolean isDebugEnabled = logger.isDebugEnabled();
+      if (isDebugEnabled) {
+        logger.debug("PutOpImpl constructing(1) message for {}; operation={}", event.getEventId(),
+            op);
+      }
-      this.region = (LocalRegion)region;
-      this.regionName = region.getFullPath();
+      this.regionName = regionName;
-      final boolean isDebugEnabled = logger.isDebugEnabled();
-      if (isDebugEnabled) {
-        logger.debug("PutOpImpl constructing message with operation={}", op);
-      }
-      getMessage().addStringPart(region.getFullPath());
+      this.requireOldValue = requireOldValue;
+      this.expectedOldValue = expectedOldValue;
+      getMessage().addStringPart(regionName);
-      if (requireOldValue) flags |= 0x01;
-      if (expectedOldValue != null) flags |= 0x02;
+      if (requireOldValue)
+        flags |= 0x01;
+      if (expectedOldValue != null)
+        flags |= 0x02;
-      }
-      else if (value instanceof CachedDeserializable) {
+      } else if (value instanceof CachedDeserializable) {
-            getMessage().addRawPart((byte[])cdValue, true);
-          }
-          else {
+            getMessage().addRawPart((byte[]) cdValue, true);
+          } else {
+      } else {
+        getMessage().addObjPart(Boolean.FALSE);
+        getMessage().addObjPart(value);
-      else {
+      getMessage().addBytesPart(event.getEventId().calcBytes());
+      if (callbackArg != null) {
+        getMessage().addObjPart(callbackArg);
+      }
+    }
+
+    public PutOpImpl(Region region, Object key, Object value, byte[] deltaBytes,
+        EntryEventImpl event, Operation op, boolean requireOldValue, Object expectedOldValue,
+        Object callbackArg, boolean sendFullObj, boolean prSingleHopEnabled) {
+      super(MessageType.PUT,
+          7 + (callbackArg != null ? 1 : 0) + (expectedOldValue != null ? 1 : 0));
+      this.key = key;
+      this.callbackArg = callbackArg;
+      this.event = event;
+      this.value = value;
+      this.region = (LocalRegion) region;
+      this.regionName = region.getFullPath();
+      this.prSingleHopEnabled = prSingleHopEnabled;
+      final boolean isDebugEnabled = logger.isDebugEnabled();
+      if (isDebugEnabled) {
+        logger.debug("PutOpImpl constructing message with operation={}", op);
+      }
+      getMessage().addStringPart(region.getFullPath());
+      getMessage().addObjPart(op);
+      int flags = 0;
+      if (requireOldValue)
+        flags |= 0x01;
+      if (expectedOldValue != null)
+        flags |= 0x02;
+      getMessage().addIntPart(flags);
+      if (expectedOldValue != null) {
+        getMessage().addObjPart(expectedOldValue);
+      }
+      getMessage().addStringOrObjPart(key);
+      // Add message part for sending either delta or full value
+      if (!sendFullObj && deltaBytes != null && op == Operation.UPDATE) {
+        getMessage().addObjPart(Boolean.TRUE);
+        getMessage().addBytesPart(deltaBytes);
+        this.deltaSent = true;
+        if (isDebugEnabled) {
+          logger.debug("PutOp: Sending delta for key {}", this.key);
+        }
+      } else if (value instanceof CachedDeserializable) {
+        CachedDeserializable cd = (CachedDeserializable) value;
+        if (!cd.isSerialized()) {
+          // it is a byte[]
+          getMessage().addObjPart(Boolean.FALSE);
+          getMessage().addObjPart(cd.getDeserializedForReading());
+        } else {
+          getMessage().addObjPart(Boolean.FALSE);
+          Object cdValue = cd.getValue();
+          if (cdValue instanceof byte[]) {
+            getMessage().addRawPart((byte[]) cdValue, true);
+          } else {
+            getMessage().addObjPart(cdValue);
+          }
+        }
+      } else {
-      throw new UnsupportedOperationException("processResponse should not be invoked in PutOp.  Use processResponse(Message, Connection)");
+      throw new UnsupportedOperationException(
+          "processResponse should not be invoked in PutOp.  Use processResponse(Message, Connection)");
-     * @param msg
-     *                the message containing the response
-     * @param con
-     *                Connection on which this op is executing
-     * @throws Exception
-     *                 if response could not be processed or we received a
-     *                 response with a server exception.
+     * @param msg the message containing the response
+     * 
+     * @param con Connection on which this op is executing
+     * 
+     * @throws Exception if response could not be processed or we received a response with a server
+     * exception.
+     * 
-    protected Object processResponse(Message msg, Connection con)
-        throws Exception {
+    protected Object processResponse(Message msg, Connection con) throws Exception {
-            byte myVersion = cms.getMetaDataVersion(region, Operation.UPDATE,
-                               key, value, callbackArg);
+            byte myVersion =
+                cms.getMetaDataVersion(region, Operation.UPDATE, key, value, callbackArg);
-      if (msg.getMessageType() == MessageType.REPLY
-          &&  msg.getNumberOfParts() > 1) {
+      if (msg.getMessageType() == MessageType.REPLY && msg.getNumberOfParts() > 1) {
-            ByteArrayInputStream in = new ByteArrayInputStream((byte[])oldValue);
+            ByteArrayInputStream in = new ByteArrayInputStream((byte[]) oldValue);
-//          if (lw.fineEnabled()) {
-//            lw.fine("read old value from server response: " + oldValue);
-//          }
+          // if (lw.fineEnabled()) {
+          // lw.fine("read old value from server response: " + oldValue);
+          // }
-          VersionTag tag = (VersionTag)msg.getPart(partIdx++).getObject();
+          VersionTag tag = (VersionTag) msg.getPart(partIdx++).getObject();
-    
+
-     * @param msg
-     *                the message containing the response
-     * @param opName
-     *                text describing this op
-     * @param con
-     *                Connection on which this op is executing
-     * @throws Exception
-     *                 if response could not be processed or we received a
-     *                 response with a server exception.
+     * @param msg the message containing the response
+     * @param opName text describing this op
+     * @param con Connection on which this op is executing
+     * @throws Exception if response could not be processed or we received a response with a server
+     *         exception.
-    private final void processAck(Message msg, String opName, Connection con)
-        throws Exception
-    {
+    private final void processAck(Message msg, String opName, Connection con) throws Exception {
-      }
-      else {
+      } else {
-          AbstractOp op = new PutOpImpl(this.regionName, this.key, this.value,
-                null, this.event, Operation.CREATE, this.requireOldValue,
-                this.expectedOldValue, this.callbackArg,
-                true /* send full obj */, this.prSingleHopEnabled);
-          
+          AbstractOp op = new PutOpImpl(this.regionName, this.key, this.value, null, this.event,
+              Operation.CREATE, this.requireOldValue, this.expectedOldValue, this.callbackArg,
+              true /* send full obj */, this.prSingleHopEnabled);
+
-        }
-        else if (msgType == MessageType.EXCEPTION) {
+        } else if (msgType == MessageType.EXCEPTION) {
-          throw new ServerOperationException(s, (Throwable)part.getObject());
+          throw new ServerOperationException(s, (Throwable) part.getObject());
-        }
-        else if (isErrorResponse(msgType)) {
+        } else if (isErrorResponse(msgType)) {
-        }
-        else {
-          throw new InternalGemFireError("Unexpected message type "
-              + MessageType.getString(msgType));
+        } else {
+          throw new InternalGemFireError(
+              "Unexpected message type " + MessageType.getString(msgType));
-    protected void processSecureBytes(Connection cnx, Message message)
-        throws Exception {
+    protected void processSecureBytes(Connection cnx, Message message) throws Exception {
+
+
-    
+
-      return "PutOp:"+key;
+      return "PutOp:" + key;
-    
- /**
-   * Attempts to read a response to this operation by reading it from the given
-   * connection, and returning it.
-   * 
-   * @param cnx
-   *                the connection to read the response from
-   * @return the result of the operation or
-   *         <code>null</code if the operation has no result.
+
+    /**
+     * Attempts to read a response to this operation by reading it from the given connection, and
+     * returning it.
+     * 
+     * @param cnx the connection to read the response from
+     * @return the result of the operation or <code>null</code if the operation has no result.
-   */
+     */
-    protected Object attemptReadResponse(Connection cnx) throws Exception
-    {
+    protected Object attemptReadResponse(Connection cnx) throws Exception {
-        msg.setComms(cnx.getSocket(), cnx.getInputStream(), cnx
-            .getOutputStream(), cnx.getCommBuffer(), cnx.getStats());
+        msg.setComms(cnx.getSocket(), cnx.getInputStream(), cnx.getOutputStream(),
+            cnx.getCommBuffer(), cnx.getStats());
-          }
-          finally {
+          } finally {
-        }
-        else {
+        } else {
-          }
-          finally {
+          } finally {
-      }
-      else {
+      } else {

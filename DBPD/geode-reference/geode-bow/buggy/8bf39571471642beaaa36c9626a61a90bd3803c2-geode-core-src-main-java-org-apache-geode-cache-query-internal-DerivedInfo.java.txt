Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-    String key = QueryUtils.getCompiledIdFromPath(indexInfo._path).getId() + ":" + index.getCanonicalizedIteratorDefinitions()[0];
+    String key = QueryUtils.getCompiledIdFromPath(indexInfo._path).getId() + ":"
+        + index.getCanonicalizedIteratorDefinitions()[0];
-    newDerivatives.add(new Object[] { QueryUtils.getCompiledIdFromPath(indexInfo._path).getId(), sr });
+    newDerivatives
+        .add(new Object[] {QueryUtils.getCompiledIdFromPath(indexInfo._path).getId(), sr});
-    // This solution would have duplicates. The problem is the way we doNestedIteration. The map would
-    // have all values be associated with the current nested level object which is not what the values would represent
+    // This solution would have duplicates. The problem is the way we doNestedIteration. The map
+    // would
+    // have all values be associated with the current nested level object which is not what the
+    // values would represent
-    // String key = QueryUtils.getCompiledIdFromPath(indexInfo._path).getId() + ":" + definitions[i];
+    // String key = QueryUtils.getCompiledIdFromPath(indexInfo._path).getId() + ":" +
+    // definitions[i];
-    // newDerivatives.add(new Object[]{getCompiledIdFromPath(indexInfo._path).getId(), srs[indexToIterateOn]});
+    // newDerivatives.add(new Object[]{getCompiledIdFromPath(indexInfo._path).getId(),
+    // srs[indexToIterateOn]});
-  public void computeDerivedJoinResults(IndexInfo theCallingIndex, ExecutionContext context, CompiledValue iterOps) throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+  public void computeDerivedJoinResults(IndexInfo theCallingIndex, ExecutionContext context,
+      CompiledValue iterOps) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-        createDerivedJoinResultsFromOpsList((QueryUtils.getCompiledIdFromPath(theCallingIndex._path)).getId(), context, opsList);
+        createDerivedJoinResultsFromOpsList(
+            (QueryUtils.getCompiledIdFromPath(theCallingIndex._path)).getId(), context, opsList);
-        createDerivedJoinResultsFromCC((QueryUtils.getCompiledIdFromPath(theCallingIndex._path)).getId(), (CompiledComparison) iterOps, context);
+        createDerivedJoinResultsFromCC(
+            (QueryUtils.getCompiledIdFromPath(theCallingIndex._path)).getId(),
+            (CompiledComparison) iterOps, context);
-  private void createDerivedJoinResultsFromOpsList(String theCallingIndexId, ExecutionContext context, List opsList) throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+  private void createDerivedJoinResultsFromOpsList(String theCallingIndexId,
+      ExecutionContext context, List opsList) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-    // Now let's derive from our derivatives (for multiple join clauses that can be chained, such as a.id = 1 and a.id = b.id and b.id = c.id
+    // Now let's derive from our derivatives (for multiple join clauses that can be chained, such as
+    // a.id = 1 and a.id = b.id and b.id = c.id
-  private void derivedDerivative(Object[] idDerivedAndResults, ExecutionContext context, List expansionList) throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+  private void derivedDerivative(Object[] idDerivedAndResults, ExecutionContext context,
+      List expansionList) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-  private RuntimeIterator getMatchingRuntimeIterator(String receiverId, List expansionList) throws QueryInvocationTargetException {
+  private RuntimeIterator getMatchingRuntimeIterator(String receiverId, List expansionList)
+      throws QueryInvocationTargetException {
-   Example query : "Select * from /region1 r, /region2 s where r.id = 1 and r.id = s.id"
-   Up until this point we have evaluated the r.id portion
-   We determine if the path (r) matches any of the paths in the current cc (r.id = s.id)
-   If so we figure out which side it matches (in this case the left side and create a new compiled comparison
-   This new cc will set the left side as s.id and the right side as the evaluated value, in this case it happens to be 1 but
-   it could be another field from the object instead.
+   * Example query : "Select * from /region1 r, /region2 s where r.id = 1 and r.id = s.id" Up until
+   * this point we have evaluated the r.id portion We determine if the path (r) matches any of the
+   * paths in the current cc (r.id = s.id) If so we figure out which side it matches (in this case
+   * the left side and create a new compiled comparison This new cc will set the left side as s.id
+   * and the right side as the evaluated value, in this case it happens to be 1 but it could be
+   * another field from the object instead.
-  private void createDerivedJoinResultsFromCC(String theCallingIndexReceiverId, CompiledComparison cc, ExecutionContext context) throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  private void createDerivedJoinResultsFromCC(String theCallingIndexReceiverId,
+      CompiledComparison cc, ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      evaluateDerivedJoin(context, cc._right, new CompiledLiteral(cc._left.evaluate(context)), cc.getOperator());
+      evaluateDerivedJoin(context, cc._right, new CompiledLiteral(cc._left.evaluate(context)),
+          cc.getOperator());
-      evaluateDerivedJoin(context, cc._left, new CompiledLiteral(cc._right.evaluate(context)), cc.getOperator());
+      evaluateDerivedJoin(context, cc._left, new CompiledLiteral(cc._right.evaluate(context)),
+          cc.getOperator());
- 
-  /*
-   Called by createDerivedJoinResultsFromCCa
-   Creates the new cc, executes the cc and releases any newly obtain index locks
-  */ 
-  private void evaluateDerivedJoin(ExecutionContext context, CompiledValue newLeftSide, CompiledValue newRightSide, int operator) 
-   throws TypeMismatchException, FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
-   CompiledComparison dcc = createDerivedJoin(context, newLeftSide, newRightSide, operator);
-   IndexInfo[] indexInfos = (IndexInfo[]) dcc.getIndexInfo(context);
-   try {
-     if (indexInfos != null && isValidIndexTypeToDerive(indexInfos[0]._getIndex())) {
-       populateDerivedResultsFromDerivedJoin(context, dcc, indexInfos[0]);
-     }
-   } finally {
-     if (indexInfos != null) {
-       Index index = (Index) indexInfos[0]._index;
-       Index prIndex = ((AbstractIndex) index).getPRIndex();
-       if (prIndex != null) {
-         ((PartitionedIndex) prIndex).releaseIndexReadLockForRemove();
-       } else {
-         ((AbstractIndex) index).releaseIndexReadLockForRemove();
-       }
-     }
-   }
-  }
-   Does the evaluation/execution of the cc and stores them into our map
-   We prevent limit and order by to be conducted by the index at this time as we do not those applied
-   We have no idea what the other operands are and do not want to limit results as the first X results may not 
-   fulfill all operands.
+   * Called by createDerivedJoinResultsFromCCa Creates the new cc, executes the cc and releases any
+   * newly obtain index locks
-  private void populateDerivedResultsFromDerivedJoin(ExecutionContext context, CompiledComparison dcc, IndexInfo indexInfo) throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    // overwrite context values to disable limit, order by etc that should not be done by a derived join
-    // If we apply limit at this point, we cannot guarantee that after we iterate, the we do not continue to
+  private void evaluateDerivedJoin(ExecutionContext context, CompiledValue newLeftSide,
+      CompiledValue newRightSide, int operator) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+    CompiledComparison dcc = createDerivedJoin(context, newLeftSide, newRightSide, operator);
+    IndexInfo[] indexInfos = (IndexInfo[]) dcc.getIndexInfo(context);
+    try {
+      if (indexInfos != null && isValidIndexTypeToDerive(indexInfos[0]._getIndex())) {
+        populateDerivedResultsFromDerivedJoin(context, dcc, indexInfos[0]);
+      }
+    } finally {
+      if (indexInfos != null) {
+        Index index = (Index) indexInfos[0]._index;
+        Index prIndex = ((AbstractIndex) index).getPRIndex();
+        if (prIndex != null) {
+          ((PartitionedIndex) prIndex).releaseIndexReadLockForRemove();
+        } else {
+          ((AbstractIndex) index).releaseIndexReadLockForRemove();
+        }
+      }
+    }
+  }
+
+  /*
+   * Does the evaluation/execution of the cc and stores them into our map We prevent limit and order
+   * by to be conducted by the index at this time as we do not those applied We have no idea what
+   * the other operands are and do not want to limit results as the first X results may not fulfill
+   * all operands.
+   */
+  private void populateDerivedResultsFromDerivedJoin(ExecutionContext context,
+      CompiledComparison dcc, IndexInfo indexInfo) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    // overwrite context values to disable limit, order by etc that should not be done by a derived
+    // join
+    // If we apply limit at this point, we cannot guarantee that after we iterate, the we do not
+    // continue to
-    Boolean originalCanApplyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+    Boolean originalCanApplyLimit =
+        (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
-    Boolean originalCanApplyOrderBy = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    Boolean originalCanApplyOrderBy =
+        (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    //The following if block is not currently used other than the else
-    //This would be needed once we figure out how to handle nested object indexes (range, map, etc)
-    //The issue we have right now with these indexes is the results will come back as a tuple, if we use those as is, we end up 
-    //reusing the evaluated values even if they did not come from the top level object leading to duplicate results or incorrect tupling
+    // The following if block is not currently used other than the else
+    // This would be needed once we figure out how to handle nested object indexes (range, map, etc)
+    // The issue we have right now with these indexes is the results will come back as a tuple, if
+    // we use those as is, we end up
+    // reusing the evaluated values even if they did not come from the top level object leading to
+    // duplicate results or incorrect tupling
-      //createObjectResultsFromStructResults(indexInfo, sr);
+      // createObjectResultsFromStructResults(indexInfo, sr);
-  //Not used at this time.  Was left over from attempt to speed up Range Indexes
+  // Not used at this time. Was left over from attempt to speed up Range Indexes
-  private void createObjectResultsFromStructResults(IndexInfo indexInfo, SelectResults sr) {
-    Iterator srIterator = sr.iterator();
-    SelectResults[] newSrs = null;
-
-    while (srIterator.hasNext()) {
-      Struct struct = (Struct) srIterator.next();
-      Object[] fieldValues = struct.getFieldValues();
-      int structLength = struct.getFieldValues().length;
-      if (newSrs == null) {
-        newSrs = new FakeSelectResults[structLength];
-        for (int x = 0; x < structLength; x++) {
-          newSrs[x] = new FakeSelectResults();
-        }
-      }
-      for (int i = 0; i < structLength; i++) {
-        newSrs[i].add(fieldValues[i]);
-      }
-    }
-
-    if (newSrs != null) {
-      this.addDerivedResults(indexInfo, newSrs);
-    }
-  }
-  */
+   * private void createObjectResultsFromStructResults(IndexInfo indexInfo, SelectResults sr) {
+   * Iterator srIterator = sr.iterator(); SelectResults[] newSrs = null;
+   * 
+   * while (srIterator.hasNext()) { Struct struct = (Struct) srIterator.next(); Object[] fieldValues
+   * = struct.getFieldValues(); int structLength = struct.getFieldValues().length; if (newSrs ==
+   * null) { newSrs = new FakeSelectResults[structLength]; for (int x = 0; x < structLength; x++) {
+   * newSrs[x] = new FakeSelectResults(); } } for (int i = 0; i < structLength; i++) {
+   * newSrs[i].add(fieldValues[i]); } }
+   * 
+   * if (newSrs != null) { this.addDerivedResults(indexInfo, newSrs); } }
+   */
-  private CompiledComparison createDerivedJoin(ExecutionContext context, CompiledValue newLeft, CompiledValue newRight, int op)
-    throws TypeMismatchException, NameResolutionException {
+  private CompiledComparison createDerivedJoin(ExecutionContext context, CompiledValue newLeft,
+      CompiledValue newRight, int op) throws TypeMismatchException, NameResolutionException {
-  //Given a compiled value, we check to see if the receiver id of a CompiledPath matches the receiverId passed in
+  // Given a compiled value, we check to see if the receiver id of a CompiledPath matches the
+  // receiverId passed in
-      CompiledPath path = (CompiledPath)cv;
+      CompiledPath path = (CompiledPath) cv;

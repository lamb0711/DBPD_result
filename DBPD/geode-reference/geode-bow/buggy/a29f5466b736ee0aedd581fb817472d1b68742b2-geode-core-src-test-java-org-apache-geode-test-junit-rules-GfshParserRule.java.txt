GEODE-3542: Add null guards in the case of invalid commands

- Prior commits seem to have introduced some instability

-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
-import org.junit.rules.ExternalResource;
-import org.springframework.shell.core.Completion;
-import org.springframework.shell.core.Converter;
-import org.springframework.shell.event.ParseResult;
-import org.springframework.util.ReflectionUtils;
-
+import org.apache.geode.management.internal.cli.result.ResultBuilder;
+import org.junit.rules.ExternalResource;
+import org.springframework.shell.core.Completion;
+import org.springframework.shell.core.Converter;
+import org.springframework.util.ReflectionUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
-    CliAroundInterceptor interceptor = null;
-    String interceptorClass =
-        parseResult.getMethod().getAnnotation(CliMetaData.class).interceptor();
-    if (!CliMetaData.ANNOTATION_NULL_VALUE.equals(interceptorClass)) {
-      try {
-        interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest().forName(interceptorClass)
-            .newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
+    if (parseResult == null) {
+      return ResultBuilder.createUserErrorResult("Invalid command: " + command);
+    }
-      Result preExecResult = interceptor.preExecution(parseResult);
-      if (Result.Status.ERROR.equals(preExecResult.getStatus())) {
-        return (CommandResult) preExecResult;
+    CliAroundInterceptor interceptor = null;
+    CliMetaData cliMetaData = parseResult.getMethod().getAnnotation(CliMetaData.class);
+
+    if (cliMetaData != null) {
+      String interceptorClass = cliMetaData.interceptor();
+      if (!CliMetaData.ANNOTATION_NULL_VALUE.equals(interceptorClass)) {
+        try {
+          interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest().forName(interceptorClass)
+              .newInstance();
+        } catch (Exception e) {
+          throw new RuntimeException(e);
+        }
+
+        Result preExecResult = interceptor.preExecution(parseResult);
+        if (Result.Status.ERROR.equals(preExecResult.getStatus())) {
+          return (CommandResult) preExecResult;
+        }

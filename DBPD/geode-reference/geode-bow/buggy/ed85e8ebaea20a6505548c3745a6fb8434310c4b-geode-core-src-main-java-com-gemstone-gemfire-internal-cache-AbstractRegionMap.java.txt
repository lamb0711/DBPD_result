GEODE-1714: fix disk stats

A number of places were found that did not correctly
change the DiskRegionStats: entriesInVM and entriesOnlyOnDisk.
Also found places that did not correctly change
the entry count and size of a PR bucket region.
EntriesInVM is supposed to only count entries that have a value
stored in the JVM. But it was also counting invalid entries.
Since invalid entries do not have a value this stat no longer counts them.

+          // TODO: passing value to createEntry causes a problem with the disk stats.
+          //   The disk stats have already been set to track oldRe.
+          //   So when we call createEntry we probably want to give it REMOVED_PHASE1
+          //   and then set the value in copyRecoveredEntry it a way that does not
+          //   change the disk stats. This also depends on DiskEntry.Helper.initialize not changing the stats for REMOVED_PHASE1
+          } else {
+            _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(newRe));
-          _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(newRe));
-      incEntryCount(size());
-            incEntryCount(-1);
+        } else {
+          _getOwner().updateSizeOnCreate(re.getKey(), _getOwner().calculateRegionEntryValueSize(re));
-        _getOwner().updateSizeOnCreate(re.getKey(), _getOwner().calculateRegionEntryValueSize(re));
+      incEntryCount(size());
-        _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(newRe));
+        } else {
+          _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(newRe));
-        
+        // incEntryCount is called for a tombstone because scheduleTombstone does entryCount--.
-          if (re.isTombstone()) {
+          boolean oldValueWasTombstone = re.isTombstone();
+          if (oldValueWasTombstone) {
+            // unscheduleTombstone incs entryCount which is ok
+            // because we either set the value after this so that
+            // the entry exists or we call scheduleTombstone which
+            // will dec entryCount.
+            _getOwner().updateSizeOnRemove(key, oldSize);
+          } else if (oldValueWasTombstone) {
+            _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(re));
+          } else {
+            _getOwner().updateSizeOnPut(key, oldSize, _getOwner().calculateRegionEntryValueSize(re));
-          _getOwner().updateSizeOnPut(key, oldSize, _getOwner().calculateRegionEntryValueSize(re));
+                      owner.updateSizeOnRemove(key, oldSize);
+        // TODO: if inTokenMode then Token.DESTROYED is ok but what about !inTokenMode because owner.concurrencyChecksEnabled? In that case we do not want a DESTROYED token.

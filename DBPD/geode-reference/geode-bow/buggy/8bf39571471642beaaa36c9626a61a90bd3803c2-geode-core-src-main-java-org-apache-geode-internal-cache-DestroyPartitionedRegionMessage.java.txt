Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * 1) To destroy the
- * {@link org.apache.geode.internal.cache.PartitionedRegion} for all members
- * specified (typically sent to all members that have the
- * <code>PartitionedRegion</code> defined.) <br>
- * 2) To inform the other nodes that {@link org.apache.geode.internal.cache.PartitionedRegion} is closed/locally destroyed or cache is closed on a node<br>
+ * 1) To destroy the {@link org.apache.geode.internal.cache.PartitionedRegion} for all members
+ * specified (typically sent to all members that have the <code>PartitionedRegion</code> defined.)
+ * <br>
+ * 2) To inform the other nodes that {@link org.apache.geode.internal.cache.PartitionedRegion} is
+ * closed/locally destroyed or cache is closed on a node<br>
- * Sending this message should flush all previous
- * {@link org.apache.geode.cache.Region} operations, which means this
- * operation should not over-ride
- * {@link org.apache.geode.internal.cache.partitioned.PartitionMessage#getProcessorId()}.  It is critical 
- * guarantee delivery of events sent prior to this message.
-
+ * Sending this message should flush all previous {@link org.apache.geode.cache.Region} operations,
+ * which means this operation should not over-ride
+ * {@link org.apache.geode.internal.cache.partitioned.PartitionMessage#getProcessorId()}. It is
+ * critical guarantee delivery of events sent prior to this message.
+ * 
-public final class DestroyPartitionedRegionMessage extends PartitionMessage
-{
+public final class DestroyPartitionedRegionMessage extends PartitionMessage {
-  
+
-  
+
-  
+
-  
+
-  public DestroyPartitionedRegionMessage() {
-  }
+  public DestroyPartitionedRegionMessage() {}
-      ReplyProcessor21 processor,
-      final RegionEventImpl event, int serials[]) {
+      ReplyProcessor21 processor, final RegionEventImpl event, int serials[]) {
-   * @param recipients
-   *          set of members who have the PartitionedRegion defined.
-   * @param r
-   *          the PartitionedRegion to destroy on each member
+   * @param recipients set of members who have the PartitionedRegion defined.
+   * @param r the PartitionedRegion to destroy on each member
-      final RegionEventImpl event, int serials[])
-  {
+      final RegionEventImpl event, int serials[]) {
-    DestroyPartitionedRegionResponse resp = new DestroyPartitionedRegionResponse(r.getSystem(),
-        recipients);
-    DestroyPartitionedRegionMessage m = new DestroyPartitionedRegionMessage(
-        recipients, r,
-        resp, event, serials);
+    DestroyPartitionedRegionResponse resp =
+        new DestroyPartitionedRegionResponse(r.getSystem(), recipients);
+    DestroyPartitionedRegionMessage m =
+        new DestroyPartitionedRegionMessage(recipients, r, resp, event, serials);
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, 
-      PartitionedRegion r, long startTime) throws CacheException {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws CacheException {
-            
+
-      if (pp==null) { //Fix for bug#36863
+      if (pp == null) { // Fix for bug#36863
-     // final Lock isClosingWriteLock  = r.getRegionAdvisor().getPartitionProfile(getSender()).getIsClosingWriteLock();
-      
+      // final Lock isClosingWriteLock =
+      // r.getRegionAdvisor().getPartitionProfile(getSender()).getIsClosingWriteLock();
+
-      
+
-      // profile.  If we have a newer profile, ignore the request.
+      // profile. If we have a newer profile, ignore the request.
-          logger.debug("Not removing region {}l serial requested = {}; actual is {}", r.getName(), this.prSerial, r.getSerialNumber());
+          logger.debug("Not removing region {}l serial requested = {}; actual is {}", r.getName(),
+              this.prSerial, r.getSerialNumber());
-//      r.getRegionAdvisor().removeId(this.sender);
+        // r.getRegionAdvisor().removeId(this.sender);
-      
+
-     /* } finally {
-        isClosingWriteLock.unlock();
-      }*/
+      /*
+       * } finally { isClosingWriteLock.unlock(); }
+       */
-    
-    // If region's isDestroyed flag is true, we can check if local destroy is done or not and if NOT, 
+
+    // If region's isDestroyed flag is true, we can check if local destroy is done or not and if
+    // NOT,
-    
-    if (logger.isTraceEnabled(LogMarker.DM)) {  
+
+    if (logger.isTraceEnabled(LogMarker.DM)) {
-    RegionEventImpl event = new RegionEventImpl(r, this.op,
-        this.cbArg, true, r.getMyId());
+    RegionEventImpl event = new RegionEventImpl(r, this.op, this.cbArg, true, r.getMyId());
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-    for (int i = 0; i < bucketSerials.length; i ++) {
+    for (int i = 0; i < bucketSerials.length; i++) {
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    for (int i = 0; i < len ; i ++) {
+    for (int i = 0; i < len; i++) {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-    for (int i = 0; i < this.bucketSerials.length; i ++) {
+    for (int i = 0; i < this.bucketSerials.length; i++) {
-   * The response on which to wait for all the replies.  This response ignores any exceptions received from the "far side"
+   * The response on which to wait for all the replies. This response ignores any exceptions
+   * received from the "far side"
-  static public class DestroyPartitionedRegionResponse extends ReplyProcessor21
-  {
-    public DestroyPartitionedRegionResponse(InternalDistributedSystem system,
-        Set initMembers) {
+  static public class DestroyPartitionedRegionResponse extends ReplyProcessor21 {
+    public DestroyPartitionedRegionResponse(InternalDistributedSystem system, Set initMembers) {
-     * Ignore any incoming exception from other VMs, we just want an
-     * acknowledgement that the message was processed.
+     * Ignore any incoming exception from other VMs, we just want an acknowledgement that the
+     * message was processed.
-    protected void processException(ReplyException ex)
-    {
+    protected void processException(ReplyException ex) {

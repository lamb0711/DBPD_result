[MNG-5977] Improve output readability of our MavenTransferListener implementations

* Applied a general decimal formatter which automatically scales file sizes between [0,10) (one decimal digit) and [10,1000) (whole numbers) along with proper size and time units
* The progress meter will now properly
** tell the amount of transfers along with file names (in debug mode) and absolute progress by size
** visually seperate parallel transfers with " | "
* Optimized and reduced padding to the cases where it actually is necessary
* Padding has to be applied to every event which can succeed with progress update
* Synchronize all calls to console to avoid race conditions where output is terminated by a carriage return only. If no sync is done, SLF4J or INIT/SUCCEEDED update can interleave and overwrite the progress while being shorter as the progress itself.
* Replaced the concurrent hash map with a synchronized linked hash map to retain order of the progress meter. It will behave now like a queue.
* Work around a rounding bug existed upto Java 7
  See http://stackoverflow.com/q/22797964/696632 and Oracle's bugfix
  Announcement: http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html

Race conditions cannot be avoided if -T is employed since one does not have access to the output stream of a SLF4J backend to synchronize on.

+import org.apache.commons.lang3.Validate;
+    // CHECKSTYLE_OFF: LineLength
+    /**
+     * Formats file size with the associated <a href="https://en.wikipedia.org/wiki/Metric_prefix">SI</a> prefix
+     * (GB, MB, kB) and using the patterns <code>#0.0</code> for numbers between 1 and 10
+     * and <code>###0</code> for numbers between 10 and 1000+ by default.
+     *
+     * @see <a href="https://en.wikipedia.org/wiki/Metric_prefix">https://en.wikipedia.org/wiki/Metric_prefix</a>
+     * @see <a href="https://en.wikipedia.org/wiki/Binary_prefix">https://en.wikipedia.org/wiki/Binary_prefix</a>
+     * @see <a
+     *      href="https://en.wikipedia.org/wiki/Octet_%28computing%29">https://en.wikipedia.org/wiki/Octet_(computing)</a>
+     */
+    // CHECKSTYLE_ON: LineLength
+    // TODO Move me to Maven Shared Utils
+    static class FileSizeFormat
+    {
+        static enum ScaleUnit
+        {
+            BYTE
+            {
+                @Override
+                public long bytes()
+                {
+                    return 1L;
+                }
+
+                @Override
+                public String symbol()
+                {
+                    return "B";
+                }
+            },
+            KILOBYTE
+            {
+                @Override
+                public long bytes()
+                {
+                    return 1000L;
+                }
+
+                @Override
+                public String symbol()
+                {
+                    return "kB";
+                }
+            },
+            MEGABYTE
+            {
+                @Override
+                public long bytes()
+                {
+                    return KILOBYTE.bytes() * KILOBYTE.bytes();
+                }
+
+                @Override
+                public String symbol()
+                {
+                    return "MB";
+                }
+            },
+            GIGABYTE
+            {
+                @Override
+                public long bytes()
+                {
+                    return MEGABYTE.bytes() * KILOBYTE.bytes();
+                };
+
+                @Override
+                public String symbol()
+                {
+                    return "GB";
+                }
+            };
+
+            public abstract long bytes();
+            public abstract String symbol();
+
+            public static ScaleUnit getScaleUnit( long size )
+            {
+                Validate.isTrue( size >= 0L, "file size cannot be negative: %s", size );
+
+                if ( size >= GIGABYTE.bytes() )
+                {
+                    return GIGABYTE;
+                }
+                else if ( size >= MEGABYTE.bytes() )
+                {
+                    return MEGABYTE;
+                }
+                else if ( size >= KILOBYTE.bytes() )
+                {
+                    return KILOBYTE;
+                }
+                else
+                {
+                    return BYTE;
+                }
+            }
+        }
+
+        private DecimalFormat smallFormat;
+        private DecimalFormat largeFormat;
+
+        public FileSizeFormat( Locale locale )
+        {
+            smallFormat = new DecimalFormat( "#0.0", new DecimalFormatSymbols( locale ) );
+            largeFormat = new DecimalFormat( "###0", new DecimalFormatSymbols( locale ) );
+        }
+
+        public String format( long size )
+        {
+            return format( size, null );
+        }
+
+        public String format( long size, ScaleUnit unit )
+        {
+            return format( size, unit, false );
+        }
+
+        public String format( long size, ScaleUnit unit, boolean omitSymbol )
+        {
+            Validate.isTrue( size >= 0L, "file size cannot be negative: %s", size );
+
+            if ( unit == null )
+            {
+                unit = ScaleUnit.getScaleUnit( size );
+            }
+
+            double scaledSize = (double) size / unit.bytes();
+            String scaledSymbol = " " + unit.symbol();
+
+            if ( omitSymbol )
+            {
+                scaledSymbol = "";
+            }
+
+            if ( unit == ScaleUnit.BYTE )
+            {
+                return largeFormat.format( size ) + scaledSymbol;
+            }
+
+            if ( scaledSize < 0.05 || scaledSize >= 10.0 )
+            {
+                return largeFormat.format( scaledSize ) + scaledSymbol;
+            }
+            else
+            {
+                return smallFormat.format( scaledSize ) + scaledSymbol;
+            }
+        }
+
+        public String formatProgress( long progressedSize, long size )
+        {
+            Validate.isTrue( progressedSize >= 0L, "progressed file size cannot be negative: %s", progressedSize );
+            Validate.isTrue( size >= 0L && progressedSize <= size || size < 0L,
+                "progressed file size cannot be greater than size: %s > %s", progressedSize, size );
+
+            if ( size >= 0L && progressedSize != size )
+            {
+                ScaleUnit unit = ScaleUnit.getScaleUnit( size );
+                String formattedProgressedSize = format( progressedSize, unit, true );
+                String formattedSize = format( size, unit );
+
+                return formattedProgressedSize + "/" + formattedSize;
+            }
+            else
+            {
+                return format( progressedSize );
+            }
+        }
+    }
+
-        String message = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";
+        String action = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";
-        out.println( message + ": " + event.getResource().getRepositoryUrl() + event.getResource().getResourceName() );
+        TransferResource resource = event.getResource();
+        out.println( action + ": " + resource.getRepositoryUrl() + resource.getResourceName() );
-
+        // TODO This needs to be colorized
-        if ( contentLength >= 0 )
+
+        FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH );
+        String result = ( event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded" );
+        String len = format.format( contentLength );
+
+        String throughput = "";
+        long duration = System.currentTimeMillis() - resource.getTransferStartTime();
+        if ( duration > 0L )
-            String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded" );
-            String len = contentLength >= 1024 ? toKB( contentLength ) + " KB" : contentLength + " B";
-
-            String throughput = "";
-            long duration = System.currentTimeMillis() - resource.getTransferStartTime();
-            if ( duration > 0 )
-            {
-                DecimalFormat format = new DecimalFormat( "0.0", new DecimalFormatSymbols( Locale.ENGLISH ) );
-                double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 );
-                throughput = " at " + format.format( kbPerSec ) + " KB/sec";
-            }
-
-            out.println( type + ": " + resource.getRepositoryUrl() + resource.getResourceName() + " (" + len
-                + throughput + ")" );
+            double bytesPerSecond = contentLength / ( duration / 1000.0 );
+            throughput = " at " + format.format( (long) bytesPerSecond ) + "/s";
-    }
-    protected long toKB( long bytes )
-    {
-        return ( bytes + 1023 ) / 1024;
+        out.println( result + ": " + resource.getRepositoryUrl() + resource.getResourceName() + " (" + len
+            + throughput + ")" );

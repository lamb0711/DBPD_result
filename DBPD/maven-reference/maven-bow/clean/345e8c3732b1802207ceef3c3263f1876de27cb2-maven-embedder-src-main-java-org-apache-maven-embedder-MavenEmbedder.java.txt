MEVENIDE-484 - embedder's project loading didn't take the artifact handlers in plugin extensions into account when loading project dependencies.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@498975 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;
+import org.apache.maven.plugin.InvalidPluginException;
+import org.apache.maven.plugin.version.PluginVersionNotFoundException;
+import org.apache.maven.plugin.version.PluginVersionResolutionException;
-
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.maven.model.Plugin;
+import org.apache.maven.plugin.PluginManager;
+import org.apache.maven.plugin.PluginManagerException;
+import org.apache.maven.plugin.PluginNotFoundException;
+    
+    /**
+     * mkleint: protected so that IDE integrations can selectively allow downloading artifacts
+     *  from remote repositories (if they prohibit by default on project loading)
+     */ 
+    protected void verifyPlugin( Plugin plugin, MavenProject project ) 
+            throws ComponentLookupException, 
+                   ArtifactResolutionException, 
+                   PluginVersionResolutionException, 
+                   ArtifactNotFoundException, 
+                   InvalidVersionSpecificationException, 
+                   InvalidPluginException, 
+                   PluginManagerException, 
+                   PluginNotFoundException, 
+                   PluginVersionNotFoundException 
+    {
+        PluginManager pluginManager = (PluginManager) container.lookup( PluginManager.ROLE );
+        pluginManager.verifyPlugin(plugin, project, settings, localRepository);
+    }
+    
+    /**
+     * protected for tests only..
+     */
+    protected Map getPluginExtensionComponents(Plugin plugin) throws PluginManagerException 
+    {
+        try
+        {
+            PluginManager pluginManager = (PluginManager) container.lookup( PluginManager.ROLE );
+            return pluginManager.getPluginComponents( plugin, ArtifactHandler.ROLE );
+        }
+        catch ( ComponentLookupException e )
+        {
+            getLogger().debug( "Unable to find the lifecycle component in the extension", e );
+            return new HashMap();
+        }
+    }
+    
+    /**
+     * mkleint: copied from DefaultLifecycleExecutor
+     * 
+     * @todo Not particularly happy about this. Would like WagonManager and ArtifactTypeHandlerManager to be able to
+     * lookup directly, or have them passed in
+     * 
+     * @todo Move this sort of thing to the tail end of the project-building process
+     */
+    private Map findArtifactTypeHandlers( MavenProject project )
+        throws Exception
+    {
+        Map map = new HashMap();
+            
+        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )
+        {
+            Plugin plugin = (Plugin) i.next();
+
+            if ( plugin.isExtensions() )
+            {
+                verifyPlugin( plugin, project);
+                map.putAll( getPluginExtensionComponents(plugin));
+
+
+                // shudder...
+                for ( Iterator j = map.values().iterator(); j.hasNext(); )
+                {
+                    ArtifactHandler handler = (ArtifactHandler) j.next();
+                    if ( project.getPackaging().equals( handler.getPackaging() ) )
+                    {
+                        project.getArtifact().setArtifactHandler( handler );
+                    }
+                }
+            }
+        }
+        return map;
+    }
+    
-
+        
+            project = readProject( new File (request.getPomFile()) );
+            //mkleint: copied from DefaultLifecycleExecutor    
+            Map handlers = findArtifactTypeHandlers( project );
+            //is this necessary in this context, I doubt it..mkleint
+            artifactHandlerManager.addHandlers( handlers );
+            
+
+            
+        }
+        catch (PluginManagerException e) 
+        {
+            return new DefaultMavenExecutionResult( project, Collections.singletonList( e ) );
+        }
+        catch ( PluginNotFoundException e )
+        {
+            return new DefaultMavenExecutionResult( project, Collections.singletonList( e ) );
+        //mkleint: why do we have so many various exception handlings with same result?
+        catch (Exception e) 
+        {
+            return new DefaultMavenExecutionResult( project, Collections.singletonList( e ) );
+        }

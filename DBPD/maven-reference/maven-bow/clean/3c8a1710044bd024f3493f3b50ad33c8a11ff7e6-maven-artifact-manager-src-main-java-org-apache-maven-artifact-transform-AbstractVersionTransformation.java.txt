remove legacy metadata handling

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@292155 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.maven.artifact.metadata.LegacyArtifactMetadata;
-import org.apache.maven.artifact.repository.ArtifactRepositoryPolicy;
-import org.apache.maven.wagon.ResourceDoesNotExistException;
-import java.io.File;
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-    /**
-     * @todo remove in beta-2 - used for legacy handling
-     */
-    private static Set resolvedArtifactCache = new HashSet();
-
-            version = resolveLegacyVersion( artifact, localRepository, remoteRepositories );
-            if ( version == null )
-            {
-                version = artifact.getBaseVersion();
-            }
+            // use the local copy, or if it doesn't exist - go to the remote repo for it
+            version = artifact.getBaseVersion();
-
-    /**
-     * @todo remove in beta-2 - used for legacy handling
-     */
-    private String resolveLegacyVersion( Artifact artifact, ArtifactRepository localRepository,
-                                         List remoteRepositories )
-        throws ArtifactMetadataRetrievalException
-    {
-        LegacyArtifactMetadata localMetadata = createLegacyMetadata( artifact );
-        File f = new File( localRepository.getBasedir(),
-                           localRepository.pathOfLocalRepositoryMetadata( localMetadata, null ) );
-        if ( f.exists() )
-        {
-            try
-            {
-                localMetadata.readFromFile( f );
-            }
-            catch ( IOException e )
-            {
-                throw new ArtifactMetadataRetrievalException( "Error reading local metadata", e );
-            }
-        }
-        else
-        {
-            localMetadata = null;
-        }
-
-        boolean alreadyResolved = alreadyResolved( artifact );
-        if ( !alreadyResolved )
-        {
-            if ( !wagonManager.isOnline() )
-            {
-                LegacyArtifactMetadata metadata = createLegacyMetadata( artifact );
-                getLogger().debug(
-                    "System is offline. Cannot resolve metadata:\n" + metadata.extendedToString() + "\n\n" );
-
-                return null;
-            }
-
-            boolean checkedUpdates = false;
-            for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
-            {
-                ArtifactRepository repository = (ArtifactRepository) i.next();
-
-                ArtifactRepositoryPolicy policy = artifact.isSnapshot() ? repository.getSnapshots()
-                    : repository.getReleases();
-
-                if ( !policy.isEnabled() )
-                {
-                    getLogger().debug( "Legacy metadata: " + artifact.getId() + ": Skipping disabled repository " +
-                        repository.getId() + " (" + repository.getUrl() + ")" );
-                }
-                else
-                {
-                    boolean checkForUpdates = localMetadata == null ||
-                        policy.checkOutOfDate( localMetadata.getLastModified() );
-
-                    if ( checkForUpdates )
-                    {
-                        checkedUpdates = true;
-
-                        LegacyArtifactMetadata remoteMetadata;
-
-                        try
-                        {
-                            remoteMetadata = createLegacyMetadata( artifact );
-
-                            remoteMetadata.retrieveFromRemoteRepository( repository, wagonManager,
-                                                                         policy.getChecksumPolicy() );
-
-                            getLogger().warn( "Using old-style versioning metadata from remote repo for " + artifact );
-
-                            if ( localMetadata == null || remoteMetadata.compareTo( localMetadata ) > 0 )
-                            {
-                                // remote is newer
-                                artifact.setRepository( repository );
-                                localMetadata = remoteMetadata;
-                                getLogger().debug( "Found repository for the artifact." );
-                            }
-                        }
-                        catch ( ResourceDoesNotExistException e )
-                        {
-                            getLogger().debug( "Legacy metadata for: " + artifact.getId() +
-                                " could not be found on repository: " + repository.getId() );
-                        }
-                        catch ( ArtifactMetadataRetrievalException e )
-                        {
-                            getLogger().warn( "Legacy metadata for: " + artifact.getId() +
-                                " could not be found on repository: " + repository.getId(), e );
-                        }
-                    }
-                    else
-                    {
-                        getLogger().debug( "resolveMetaData: " + artifact.getId() + ": NOT checking for updates from " +
-                            repository.getId() + " (" + repository.getUrl() + ")" );
-                    }
-                }
-            }
-
-            // touch the file if it was checked for updates, but don't create it if it did't exist to avoid
-            // storing SNAPSHOT as the actual version which doesn't exist remotely.
-            if ( checkedUpdates && localMetadata != null && localMetadata.getLastModified().getTime() > 0 )
-            {
-                localMetadata.storeInLocalRepository( localRepository );
-            }
-
-            resolvedArtifactCache.add( getCacheKey( artifact ) );
-        }
-
-        if ( localMetadata != null && artifact.getFile().exists() &&
-            !localMetadata.newerThanFile( artifact.getFile() ) )
-        {
-            if ( getLogger().isDebugEnabled() && !alreadyResolved )
-            {
-                // Locally installed file is newer, don't use the resolved version
-                getLogger().debug( artifact.getArtifactId() + ": using locally installed snapshot" );
-            }
-            localMetadata = null;
-        }
-
-        return localMetadata != null ? localMetadata.constructVersion() : null;
-    }
-
-    protected abstract LegacyArtifactMetadata createLegacyMetadata( Artifact artifact );
-
-    /**
-     * @todo remove in beta-2 - used for legacy handling
-     */
-    private boolean alreadyResolved( Artifact artifact )
-    {
-        return resolvedArtifactCache.contains( getCacheKey( artifact ) );
-    }
-
-    /**
-     * @todo remove in beta-2 - used for legacy handling
-     */
-    private static String getCacheKey( Artifact artifact )
-    {
-        // No type - one per POM
-        return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getBaseVersion();
-    }

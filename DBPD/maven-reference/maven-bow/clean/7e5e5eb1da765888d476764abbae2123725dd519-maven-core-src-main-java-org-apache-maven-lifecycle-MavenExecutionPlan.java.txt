[MNG-4633] Weave mode operational.

Replaced approximation-based algorithm for detecting upstream-mojo dependencies with
a proper phase based solution. Revised re-resolution strategy of reactor artifacts

There are a few minor performance inefficiencies (only in weave mode), that will be
sorted for beta-2.

Improved logging, and also added initial graphviz-format log output support

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@934425 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
-    final List<String> phases;
+    final List<String> phasesInExecutionPlan;
-        lastMojoExecutionForAllPhases = new HashMap<String, ExecutionPlanItem>();
+        lastMojoExecutionForAllPhases = new LinkedHashMap<String, ExecutionPlanItem>();
-        String firstPhasePreset = getFirstPhasePresentInPlan();
-
-        List<String> phases = null;
+        LinkedHashSet<String> totalPhaseSet = new LinkedHashSet<String>();
-            final Lifecycle lifecycle = defaultLifecycles.get( firstPhasePreset );
-            if ( lifecycle != null )
+            for ( String phase : getDistinctPhasesInOrderOfExecutionPlanAppearance( planItem ) )
-                phases = lifecycle.getPhases();
+                final Lifecycle lifecycle = defaultLifecycles.get( phase );
+                if ( lifecycle != null )
+                {
+                    totalPhaseSet.addAll( lifecycle.getPhases() );
+                }
-        this.phases = phases;
+        this.phasesInExecutionPlan = new ArrayList<String>( totalPhaseSet );
-            final String phaseName = executionPlanItem.getLifecyclePhase();
-            if ( phaseName != null )
-            {
-                lastInExistingPhases.put( phaseName, executionPlanItem );
-            }
+            lastInExistingPhases.put( executionPlanItem.getLifecyclePhase(), executionPlanItem );
-        ExecutionPlanItem forThis;
+        ExecutionPlanItem forThisPhase;
-        if ( phases != null )
+        for ( String phase : totalPhaseSet )
-            for ( String phase : phases )
+            forThisPhase = lastInExistingPhases.get( phase );
+            if ( forThisPhase != null )
-                forThis = lastInExistingPhases.get( phase );
-                if ( forThis != null )
-                {
-                    lastSeenExecutionPlanItem = forThis;
-                }
-                lastMojoExecutionForAllPhases.put( phase, lastSeenExecutionPlanItem );
-
+                lastSeenExecutionPlanItem = forThisPhase;
+            lastMojoExecutionForAllPhases.put( phase, lastSeenExecutionPlanItem );
+
-    }
-    private String getFirstPhasePresentInPlan()
-    {
-        for ( ExecutionPlanItem executionPlanItem : getExecutionPlanItems() )
-        {
-            final String phase = executionPlanItem.getLifecyclePhase();
-            if ( phase != null )
-            {
-                return phase;
-            }
-        }
-        return null;
-        ExecutionPlanItem result = lastMojoExecutionForAllPhases.get( requestedPhase );
-        int i = phases.indexOf( requestedPhase );
-        while ( result == null && i > 0 )
-        {
-            final String previousPhase = phases.get( --i );
-            result = lastMojoExecutionForAllPhases.get( previousPhase );
-
-        }
-        return result;
+        return lastMojoExecutionForAllPhases.get( requestedPhase );
+
+    private static Iterable<String> getDistinctPhasesInOrderOfExecutionPlanAppearance(
+        List<ExecutionPlanItem> planItems )
+    {
+        LinkedHashSet<String> result = new LinkedHashSet<String>();
+        for ( ExecutionPlanItem executionPlanItem : planItems )
+        {
+            final String phase = executionPlanItem.getLifecyclePhase();
+            if ( !result.contains( phase ) )
+            {
+                result.add( phase );
+            }
+        }
+        return result;
+    }
+
+    public void waitUntilAllDone()
+        throws InterruptedException
+    {
+        for ( ExecutionPlanItem executionPlanItem : getExecutionPlanItems() )
+        {
+            executionPlanItem.waitUntilDone();
+        }
+    }
+
+    public boolean containsPhase( String phase )
+    {
+        return phasesInExecutionPlan.contains( phase );
+    }
+
+

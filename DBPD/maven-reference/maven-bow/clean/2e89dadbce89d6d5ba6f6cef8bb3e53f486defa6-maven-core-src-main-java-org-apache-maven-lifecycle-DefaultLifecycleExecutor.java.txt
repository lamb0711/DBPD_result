PR: MNG-1311

Added a stack of lifecycle fork-points that will be removed from each successively deeper level of forking in a cumulative manner, to prevent multi-node cycles in addition to simply blocking two-node cycles.

The basic problem with the recursion check that was in there was a type mismatch on the contents of a java.util.List. It's fixed now.


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@355383 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Stack;
+            Stack forkEntryPoints = new Stack();
-                executeGoalWithLifecycle( task, session, lifecycleMappings, project, lifecycle );
+                executeGoalWithLifecycle( task, forkEntryPoints, session, lifecycleMappings, project, lifecycle );
-                executeStandaloneGoal( task, session, project );
+                executeStandaloneGoal( task, forkEntryPoints, session, project );
-    private void executeGoalWithLifecycle( String task, MavenSession session, Map lifecycleMappings,
-                                           MavenProject project, Lifecycle lifecycle )
+    private void executeGoalWithLifecycle( String task, Stack forkEntryPoints, MavenSession session,
+                                           Map lifecycleMappings, MavenProject project, Lifecycle lifecycle )
-            executeGoals( goals, session, project );
+            executeGoals( goals, forkEntryPoints, session, project );
-    private void executeStandaloneGoal( String task, MavenSession session, MavenProject project )
+    private void executeStandaloneGoal( String task, Stack forkEntryPoints, MavenSession session, MavenProject project )
-        executeGoals( Collections.singletonList( new MojoExecution( mojoDescriptor ) ), session, project );
+        executeGoals( Collections.singletonList( new MojoExecution( mojoDescriptor ) ), forkEntryPoints, session, project );
-    private void executeGoals( List goals, MavenSession session, MavenProject project )
+    private void executeGoals( List goals, Stack forkEntryPoints, MavenSession session, MavenProject project )
-                forkLifecycle( mojoDescriptor, session, project );
+                forkEntryPoints.push( mojoDescriptor );
+                
+                forkLifecycle( mojoDescriptor, forkEntryPoints, session, project );
+                
+                forkEntryPoints.pop();
-                        forkLifecycle( descriptor, session, project );
+                        forkEntryPoints.push( descriptor );
+                        
+                        forkLifecycle( descriptor, forkEntryPoints, session, project );
+                        
+                        forkEntryPoints.pop();
-    private void forkLifecycle( MojoDescriptor mojoDescriptor, MavenSession session, MavenProject project )
+    private void forkLifecycle( MojoDescriptor mojoDescriptor, Stack ancestorLifecycleForkers, MavenSession session, MavenProject project )
-                forkProjectLifecycle( mojoDescriptor, session, reactorProject );
+                forkProjectLifecycle( mojoDescriptor, ancestorLifecycleForkers, session, reactorProject );
-            forkProjectLifecycle( mojoDescriptor, session, project );
+            forkProjectLifecycle( mojoDescriptor, ancestorLifecycleForkers, session, project );
-    private void forkProjectLifecycle( MojoDescriptor mojoDescriptor, MavenSession session, MavenProject project )
+    private void forkProjectLifecycle( MojoDescriptor mojoDescriptor, Stack forkEntryPoints, MavenSession session, MavenProject project )
+        forkEntryPoints.push( mojoDescriptor );
+        
-            removeFromLifecycle( mojoDescriptor, lifecycleMappings );
+            removeFromLifecycle( forkEntryPoints, lifecycleMappings );
-            executeGoalWithLifecycle( targetPhase, session, lifecycleMappings, executionProject, lifecycle );
+            executeGoalWithLifecycle( targetPhase, forkEntryPoints, session, lifecycleMappings, executionProject, lifecycle );
-            executeGoals( Collections.singletonList( new MojoExecution( desc ) ), session, executionProject );
+            executeGoals( Collections.singletonList( new MojoExecution( desc ) ), forkEntryPoints, session, executionProject );
-    private void removeFromLifecycle( MojoDescriptor mojoDescriptor, Map lifecycleMappings )
+    private void removeFromLifecycle( Stack lifecycleForkers, Map lifecycleMappings )
-        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();
-
-        String mojoIdWithVersion = pluginDescriptor.getGroupId() + ":" + pluginDescriptor.getArtifactId() + ":" +
-            pluginDescriptor.getVersion() + ":" + mojoDescriptor.getGoal();
-
-        String mojoIdWithoutVersion =
-            pluginDescriptor.getGroupId() + ":" + pluginDescriptor.getArtifactId() + ":" + mojoDescriptor.getGoal();
-
-        for ( Iterator it = lifecycleMappings.values().iterator(); it.hasNext(); )
+        for ( Iterator it = lifecycleForkers.iterator(); it.hasNext(); )
-            List tasks = (List) it.next();
-
-            if ( tasks.remove( mojoIdWithVersion ) || tasks.remove( mojoIdWithoutVersion ) )
+            MojoDescriptor mojoDescriptor = (MojoDescriptor) it.next();
+            
+            for ( Iterator lifecycleIterator = lifecycleMappings.values().iterator(); lifecycleIterator.hasNext(); )
-                getLogger().warn( "Removing: " + mojoDescriptor.getGoal() +
-                    " from forked lifecycle, to prevent recursive invocation of this mojo." );
+                List tasks = (List) lifecycleIterator.next();
+                
+                boolean removed = false;
+                for ( Iterator taskIterator = tasks.iterator(); taskIterator.hasNext(); )
+                {
+                    MojoExecution execution = (MojoExecution) taskIterator.next();
+                    
+                    if ( mojoDescriptor.equals( execution.getMojoDescriptor() ) )
+                    {
+                        taskIterator.remove();
+                        removed = true;
+                    }
+                }
+                
+                if ( removed )
+                {
+                    getLogger().warn(
+                                      "Removing: " + mojoDescriptor.getGoal()
+                                          + " from forked lifecycle, to prevent recursive invocation." );
+                }

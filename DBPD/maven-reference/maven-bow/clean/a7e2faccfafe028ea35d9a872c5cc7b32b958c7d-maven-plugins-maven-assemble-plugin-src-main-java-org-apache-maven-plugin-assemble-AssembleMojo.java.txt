add dependency handling, and make bugfixes to the assemble plugin


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@163798 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.artifact.Artifact;
+import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
+import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
+import org.apache.maven.plugins.assemble.model.DependencySet;
+import org.codehaus.plexus.archiver.ArchiverException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+ * @requiresDependencyResolution test
+ * @parameter name="dependencies" type="java.util.Set" required="false" validator="" expression="#project.artifacts" description=""
+    private Set dependencies;
+
-            // TODO: how, might we plugin this into an installer, such as NSIS?
+            // TODO: how, might we plug this into an installer, such as NSIS?
-                Archiver archiver;
-                if ( format.startsWith( "tar" ) )
-                {
-                    TarArchiver tarArchiver = new TarArchiver();
-                    archiver = tarArchiver;
-                    int index = format.indexOf( '.' );
-                    if ( index >= 0 )
-                    {
-                        // TODO: this needs a cleanup in plexus archiver - use a real typesafe enum
-                        TarArchiver.TarCompressionMethod tarCompressionMethod = new TarArchiver.TarCompressionMethod();
-                        // TODO: this should accept gz and bz2 as well so we can skip over the switch
-                        String compression = format.substring( index + 1 );
-                        if ( compression.equals( "gz" ) )
-                        {
-                            tarCompressionMethod.setValue( "gzip" );
-                        }
-                        else if ( compression.equals( "bz2" ) )
-                        {
-                            tarCompressionMethod.setValue( "bzip2" );
-                        }
-                        else
-                        {
-                            // TODO: better handling
-                            throw new IllegalArgumentException( "Unknown compression format: " + compression );
-                        }
-                        tarArchiver.setCompression( tarCompressionMethod );
-                    }
-                }
-                else if ( format.startsWith( "zip" ) )
-                {
-                    archiver = new ZipArchiver();
-                }
-                else if ( format.startsWith( "jar" ) )
-                {
-                    // TODO: use MavenArchiver for manifest?
-                    archiver = new JarArchiver();
-                }
-                else
-                {
-                    // TODO: better handling
-                    throw new IllegalArgumentException( "Unknown format: " + format );
-                }
+                Archiver archiver = createArchiver( format );
-                for ( Iterator j = assembly.getFilesets().iterator(); j.hasNext(); )
-                {
-                    FileSet fileset = (FileSet) j.next();
-                    String directory = fileset.getDirectory();
-                    String output = fileset.getOutputDirectory();
-                    if ( directory == null )
-                    {
-                        directory = basedir;
-                        if ( output == null )
-                        {
-                            output = "/";
-                        }
-                    }
-                    else
-                    {
-                        if ( output == null )
-                        {
-                            output = directory;
-                        }
-                    }
-                    if ( !output.endsWith( "/" ) && !output.endsWith( "\\" ) )
-                    {
-                        // TODO: shouldn't archiver do this?
-                        output += '/';
-                    }
-
-                    String[] includes = (String[]) fileset.getIncludes().toArray( EMPTY_STRING_ARRAY );
-                    if ( includes.length == 0 )
-                    {
-                        includes = null;
-                    }
-                    String[] excludes = null;
-                    if ( !fileset.getExcludes().isEmpty() )
-                    {
-                        excludes = (String[]) fileset.getExcludes().toArray( EMPTY_STRING_ARRAY );
-                    }
-                    // TODO: default excludes?
-                    archiver.addDirectory( new File( directory ), output, includes, excludes );
-                }
+                processFileSets( archiver, assembly.getFileSets() );
+                processDependencySets( archiver, assembly.getDependencySets() );
+
+    private void processDependencySets( Archiver archiver, List dependencySets )
+        throws ArchiverException
+    {
+        for ( Iterator i = dependencySets.iterator(); i.hasNext(); )
+        {
+            DependencySet depedencySet = (DependencySet) i.next();
+            String output = depedencySet.getOutputDirectory();
+            output = getOutputDirectory( output );
+
+            AndArtifactFilter filter = new AndArtifactFilter();
+            filter.add( new ScopeArtifactFilter( depedencySet.getScope() ) );
+            if ( !depedencySet.getIncludes().isEmpty() )
+            {
+                filter.add( new IncludesArtifactFilter( depedencySet.getIncludes() ) );
+            }
+            if ( !depedencySet.getExcludes().isEmpty() )
+            {
+                filter.add( new ExcludesArtifactFilter( depedencySet.getExcludes() ) );
+            }
+
+            // TODO: includes and excludes
+            for ( Iterator j = dependencies.iterator(); j.hasNext(); )
+            {
+                Artifact artifact = (Artifact) j.next();
+
+                if ( filter.include( artifact ) )
+                {
+                    archiver.addFile( artifact.getFile(), output + artifact.getFile().getName() );
+                }
+            }
+        }
+    }
+
+    private String getOutputDirectory( String output )
+    {
+        if ( output == null )
+        {
+            output = "";
+        }
+        if ( !output.endsWith( "/" ) && !output.endsWith( "\\" ) )
+        {
+            // TODO: shouldn't archiver do this?
+            output += '/';
+        }
+
+        if ( output.startsWith( "/" ) )
+        {
+            output = finalName + output;
+        }
+        else
+        {
+            output = finalName + "/" + output;
+        }
+        return output;
+    }
+
+    private Archiver createArchiver( String format )
+        throws ArchiverException
+    {
+        Archiver archiver;
+        if ( format.startsWith( "tar" ) )
+        {
+            TarArchiver tarArchiver = new TarArchiver();
+            archiver = tarArchiver;
+            int index = format.indexOf( '.' );
+            if ( index >= 0 )
+            {
+                // TODO: this needs a cleanup in plexus archiver - use a real typesafe enum
+                TarArchiver.TarCompressionMethod tarCompressionMethod = new TarArchiver.TarCompressionMethod();
+                // TODO: this should accept gz and bz2 as well so we can skip over the switch
+                String compression = format.substring( index + 1 );
+                if ( compression.equals( "gz" ) )
+                {
+                    tarCompressionMethod.setValue( "gzip" );
+                }
+                else if ( compression.equals( "bz2" ) )
+                {
+                    tarCompressionMethod.setValue( "bzip2" );
+                }
+                else
+                {
+                    // TODO: better handling
+                    throw new IllegalArgumentException( "Unknown compression format: " + compression );
+                }
+                tarArchiver.setCompression( tarCompressionMethod );
+            }
+        }
+        else if ( format.startsWith( "zip" ) )
+        {
+            archiver = new ZipArchiver();
+        }
+        else if ( format.startsWith( "jar" ) )
+        {
+            // TODO: use MavenArchiver for manifest?
+            archiver = new JarArchiver();
+        }
+        else
+        {
+            // TODO: better handling
+            throw new IllegalArgumentException( "Unknown format: " + format );
+        }
+        return archiver;
+    }
+
+    private void processFileSets( Archiver archiver, java.util.List fileSets )
+        throws ArchiverException
+    {
+        for ( Iterator i = fileSets.iterator(); i.hasNext(); )
+        {
+            FileSet fileSet = (FileSet) i.next();
+            String directory = fileSet.getDirectory();
+            String output = fileSet.getOutputDirectory();
+            if ( directory == null )
+            {
+                directory = basedir;
+                if ( output == null )
+                {
+                    output = "";
+                }
+            }
+            else
+            {
+                if ( output == null )
+                {
+                    output = directory;
+                }
+            }
+            output = getOutputDirectory( output );
+
+            String[] includes = (String[]) fileSet.getIncludes().toArray( EMPTY_STRING_ARRAY );
+            if ( includes.length == 0 )
+            {
+                includes = null;
+            }
+
+            List excludesList = fileSet.getExcludes();
+            excludesList.addAll( getDefaultExcludes() );
+            String[] excludes = (String[]) excludesList.toArray( EMPTY_STRING_ARRAY );
+
+            // TODO: default excludes should be in the archiver?
+            archiver.addDirectory( new File( directory ), output, includes, excludes );
+        }
+    }
+
+    public List getDefaultExcludes()
+    {
+        List defaultExcludes = new ArrayList();
+        defaultExcludes.add( "**/*~" );
+        defaultExcludes.add( "**/#*#" );
+        defaultExcludes.add( "**/.#*" );
+        defaultExcludes.add( "**/%*%" );
+        defaultExcludes.add( "**/._*" );
+
+        // CVS
+        defaultExcludes.add( "**/CVS" );
+        defaultExcludes.add( "**/CVS/**" );
+        defaultExcludes.add( "**/.cvsignore" );
+
+        // SCCS
+        defaultExcludes.add( "**/SCCS" );
+        defaultExcludes.add( "**/SCCS/**" );
+
+        // Visual SourceSafe
+        defaultExcludes.add( "**/vssver.scc" );
+
+        // Subversion
+        defaultExcludes.add( "**/.svn" );
+        defaultExcludes.add( "**/.svn/**" );
+
+        // Mac
+        defaultExcludes.add( "**/.DS_Store" );
+
+        return defaultExcludes;
+    }
+
+    // TODO: move to maven-artifact - generally useful
+    private static class AndArtifactFilter
+        implements ArtifactFilter
+    {
+        private final List filters = new ArrayList();
+
+        public boolean include( Artifact artifact )
+        {
+            boolean include = true;
+            for ( Iterator i = filters.iterator(); i.hasNext() && include; )
+            {
+                ArtifactFilter filter = (ArtifactFilter) i.next();
+                if ( !filter.include( artifact ) )
+                {
+                    include = false;
+                }
+            }
+            return include;
+        }
+
+        public void add( ArtifactFilter artifactFilter )
+        {
+            filters.add( artifactFilter );
+        }
+    }
+
+    private static class IncludesArtifactFilter
+        implements ArtifactFilter
+    {
+        private final List patterns;
+
+        public IncludesArtifactFilter( List patterns )
+        {
+            this.patterns = patterns;
+        }
+
+        public boolean include( Artifact artifact )
+        {
+            String id = artifact.getGroupId() + ":" + artifact.getArtifactId();
+
+            boolean matched = false;
+            for ( Iterator i = patterns.iterator(); i.hasNext() & !matched; )
+            {
+                // TODO: what about wildcards? Just specifying groups? versions?
+                if ( id.equals( i.next() ) )
+                {
+                    matched = true;
+                }
+            }
+            return matched;
+        }
+    }
+
+    private static class ExcludesArtifactFilter
+        extends IncludesArtifactFilter
+    {
+        public ExcludesArtifactFilter( List patterns )
+        {
+            super( patterns );
+        }
+
+        public boolean include( Artifact artifact )
+        {
+            return !super.include( artifact );
+        }
+    }

Adding -V|--show-version, and cleaning up interpolation to correspond with recent refactoriing in 2.0.x branch. Also, changing super-POM to use basedir/build.directory expressions in build paths, to enable paths to respond to changes in other, more basic paths (like outputDirectory responding to a change in build.directory). This is in preparation for merging over the dynamicBuild behavior.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@671936 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.project.DefaultProjectBuilderConfiguration;
+import org.apache.maven.project.ProjectBuilderConfiguration;
-import org.codehaus.plexus.util.StringUtils;
-import java.util.Collections;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import java.util.Properties;
-    private static final Pattern EXPRESSION_PATTERN = Pattern.compile( "\\$\\{([^}]+)\\}" );
-    private static final List PROJECT_PREFIXES = Arrays.asList( new String[]{ "pom.", "project." } );
-    private static final List TRANSLATED_PATH_EXPRESSIONS;
+    private static final List<String> PROJECT_PREFIXES = Arrays.asList( new String[]{ "pom.", "project." } );
+    private static final List<String> TRANSLATED_PATH_EXPRESSIONS;
-        List translatedPrefixes = new ArrayList();
+        List<String> translatedPrefixes = new ArrayList<String>();
-    public Model interpolate( Model model, Map context )
+    public Model interpolate( Model model, Map<String, ?> context )
-        return interpolate( model, context, Collections.EMPTY_MAP, null, true );
+        Properties props = new Properties();
+        props.putAll( context );
+
+        return interpolate( model,
+                            null,
+                            new DefaultProjectBuilderConfiguration().setExecutionProperties( props ),
+                            true );
-    public Model interpolate( Model model, Map context, boolean strict )
+    public Model interpolate( Model model, Map<String, ?> context, boolean strict )
-        return interpolate( model, context, Collections.EMPTY_MAP, null, true );
-    }
+        Properties props = new Properties();
+        props.putAll( context );
-    public Model interpolate( Model model,
-                              Map context,
-                              Map overrideContext,
-                              boolean strict )
-        throws ModelInterpolationException
-    {
-        return interpolate( model, context, Collections.EMPTY_MAP, null, true );
+        return interpolate( model,
+                            null,
+                            new DefaultProjectBuilderConfiguration().setExecutionProperties( props ),
+                            true );
-     * @param outputDebugMessages If true, print any feedback from the interpolator out to the DEBUG log-level.
+     * @param debugMessages If true, print any feedback from the interpolator out to the DEBUG log-level.
-    public Model interpolate( Model model, Map context, Map overrideContext, File projectDir, boolean outputDebugMessages )
+    public Model interpolate( Model model, File projectDir, ProjectBuilderConfiguration config, boolean debugMessages )
-        serializedModel = interpolateInternal( serializedModel, model, context, overrideContext, projectDir, outputDebugMessages );
+        serializedModel = interpolate( serializedModel, model, projectDir, config, debugMessages );
-     * @param outputDebugMessages
+     * @param debugMessages
-    private String interpolateInternal( String src,
+    public String interpolate( String src,
-                                        Map context,
-                                        Map overrideContext,
-                                        boolean outputDebugMessages )
+                                        ProjectBuilderConfiguration config,
+                                        boolean debugMessages )
+        String timestampFormat = DEFAULT_BUILD_TIMESTAMP_FORMAT;
+
+        Properties modelProperties = model.getProperties();
+        if ( modelProperties != null )
+        {
+            timestampFormat = modelProperties.getProperty( BUILD_TIMESTAMP_FORMAT_PROPERTY, timestampFormat );
+        }
+
-        interpolator.addValueSource( new MapBasedValueSource( overrideContext ) );
+        interpolator.addValueSource( new BuildTimestampValueSource( config.getBuildStartTime(), timestampFormat ) );
+        interpolator.addValueSource( new MapBasedValueSource( config.getExecutionProperties() ) );
-        interpolator.addValueSource( new PrefixedValueSourceWrapper( new MapBasedValueSource( model.getProperties() ), PROJECT_PREFIXES, true ) );
+        interpolator.addValueSource( new PrefixedValueSourceWrapper( new MapBasedValueSource( modelProperties ), PROJECT_PREFIXES, true ) );
-        interpolator.addValueSource( new MapBasedValueSource( context ) );
+        interpolator.addValueSource( new MapBasedValueSource( config.getUserProperties() ) );
-        Matcher matcher = EXPRESSION_PATTERN.matcher( result );
-        while ( matcher.find() )
+        try
-            String wholeExpr = matcher.group( 0 );
-
-            Object value;
-            try
-            {
-                value = interpolator.interpolate( wholeExpr, "", recursionInterceptor );
-            }
-            catch( InterpolationException e )
-            {
-                throw new ModelInterpolationException( e.getMessage(), e );
-            }
-
-            if ( value == null || value.equals(  wholeExpr ) )
-            {
-                continue;
-            }
-
-            // FIXME: Does this account for the case where ${project.build.directory} -> ${build.directory}??
-            if ( value != null )
-            {
-                // if the expression refers to itself, skip it.
-                // replace project. expressions with pom. expressions to circumvent self-referencing expressions using
-                // the 2 different model expressions.
-                if ( StringUtils.replace( value.toString(), "${project.", "${pom." ).indexOf(
-                    StringUtils.replace( wholeExpr, "${project.", "${pom." ) ) > -1 )
-                {
-                    throw new ModelInterpolationException( wholeExpr, "Expression value '" + value
-                        + "' references itself in '" + model.getId() + "'." );
-                }
-
-                result = StringUtils.replace( result, wholeExpr, value.toString() );
-                // could use:
-                // result = matcher.replaceFirst( stringValue );
-                // but this could result in multiple lookups of stringValue, and replaceAll is not correct behaviour
-                matcher.reset( result );
-            }
-
-/*
-        // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
-        // timing of executing the interpolation
-
-            else
-            {
-                throw new ModelInterpolationException(
-                    "Expression '" + wholeExpr + "' did not evaluate to anything in the model" );
-            }
-*/
+            result = interpolator.interpolate( result, "", recursionInterceptor );
+        }
+        catch( InterpolationException e )
+        {
+            throw new ModelInterpolationException( e.getMessage(), e );
-        if ( outputDebugMessages )
+        if ( debugMessages )
-            List feedback = interpolator.getFeedback();
+            List<?> feedback = interpolator.getFeedback();
-                for ( Iterator it = feedback.iterator(); it.hasNext(); )
+                for ( Iterator<?> it = feedback.iterator(); it.hasNext(); )

MNG-5575: Separate distinct build strategies into their own new Builder implementation. The interface is not ideal yet, but gives us a cleaner
separation of implementations and gives us a path forward.

+import java.util.List;
+import java.util.Map;
+
-import org.apache.maven.execution.MavenExecutionRequest;
+import org.apache.maven.lifecycle.internal.builder.Builder;
+import org.apache.maven.lifecycle.internal.builder.BuilderNotFoundException;
-import java.util.List;
-import java.util.concurrent.CompletionService;
-import java.util.concurrent.ExecutorCompletionService;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
-
+ * 
-
-    private LifecycleModuleBuilder lifecycleModuleBuilder;
-
-    @Requirement
-    private LifecycleWeaveBuilder lifeCycleWeaveBuilder;
-
-    @Requirement
-    private LifecycleThreadedBuilder lifecycleThreadedBuilder;
-
-    @Requirement
-    private ThreadConfigurationService threadConfigService;
+    private Map<String, Builder> builders;
+        ReactorContext reactorContext = null;
+        ProjectBuildList projectBuilds = null;
-            if ( !session.isUsingPOMsFromFilesystem() && lifecycleTaskSegmentCalculator.requiresProject( session ) )
+            if ( buildExecutionRequiresProject( session ) && projectIsNotPresent( session ) )
-            final MavenExecutionRequest executionRequest = session.getRequest();
-            boolean isThreaded = executionRequest.isThreadConfigurationPresent();
-            session.setParallel( isThreaded );
-
-
-            ProjectBuildList projectBuilds = buildListCalculator.calculateProjectBuilds( session, taskSegments );
+            projectBuilds = buildListCalculator.calculateProjectBuilds( session, taskSegments );
-
-            ReactorContext callableContext =
-                new ReactorContext( result, projectIndex, oldContextClassLoader, reactorBuildStatus );
+            reactorContext = new ReactorContext( result, projectIndex, oldContextClassLoader, reactorBuildStatus );
-            if ( isThreaded )
+            String builderId = session.getRequest().getBuilderId();
+            Builder builder = builders.get( builderId );
+            if ( builder == null )
-                ExecutorService executor =
-                    threadConfigService.getExecutorService( executionRequest.getThreadCount(),
-                                                            executionRequest.isPerCoreThreadCount(),
-                                                            session.getProjects().size() );
-                try
-                {
-
-                    final boolean isWeaveMode = LifecycleWeaveBuilder.isWeaveMode( executionRequest );
-                    if ( isWeaveMode )
-                    {
-                        lifecycleDebugLogger.logWeavePlan( session );
-                        lifeCycleWeaveBuilder.build( projectBuilds, callableContext, taskSegments, session, executor,
-                                                     reactorBuildStatus );
-                    }
-                    else
-                    {
-                        ConcurrencyDependencyGraph analyzer =
-                            new ConcurrencyDependencyGraph( projectBuilds, session.getProjectDependencyGraph() );
-
-                        CompletionService<ProjectSegment> service =
-                            new ExecutorCompletionService<ProjectSegment>( executor );
-
-                        lifecycleThreadedBuilder.build( session, callableContext, projectBuilds, taskSegments, analyzer,
-                                                        service );
-                    }
-                }
-                finally
-                {
-                    executor.shutdown();
-                    // If the builder has terminated with an exception we want to catch any stray threads before going
-                    // to System.exit in the mavencli.
-                    executor.awaitTermination( 5, TimeUnit.SECONDS ) ;
-                }
+                throw new BuilderNotFoundException( String.format( "The builder requested using id = %s cannot be found", builderId ) );
-            else
-            {
-                singleThreadedBuild( session, callableContext, projectBuilds, taskSegments, reactorBuildStatus );
-            }
+
+            logger.info( "" );
+            logger.info( String.format( "Using the builder %s", builder.getClass().getName() ) );
+            builder.build( session, reactorContext, projectBuilds, taskSegments, reactorBuildStatus );
-    private void singleThreadedBuild( MavenSession session, ReactorContext callableContext,
-                                      ProjectBuildList projectBuilds, List<TaskSegment> taskSegments,
-                                      ReactorBuildStatus reactorBuildStatus )
+    private boolean buildExecutionRequiresProject( MavenSession session )
-        for ( TaskSegment taskSegment : taskSegments )
-        {
-            for ( ProjectSegment projectBuild : projectBuilds.getByTaskSegment( taskSegment ) )
-            {
-                try
-                {
-                    lifecycleModuleBuilder.buildProject( session, callableContext, projectBuild.getProject(),
-                                                         taskSegment );
-                    if ( reactorBuildStatus.isHalted() )
-                    {
-                        break;
-                    }
-                }
-                catch ( Exception e )
-                {
-                    break;  // Why are we just ignoring this exception? Are exceptions are being used for flow control
-                }
+        return lifecycleTaskSegmentCalculator.requiresProject( session );
+    }
-            }
-        }
+    private boolean projectIsNotPresent( MavenSession session )
+    {
+        return !session.getRequest().isProjectPresent();

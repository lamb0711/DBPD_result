o swapping the branch to trunk


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@779660 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import org.apache.maven.artifact.metadata.ArtifactMetadataRetrievalException;
-
-    private boolean online = true;
-
-    // ----------------------------------------------------------------------
-    // Components
-    // ----------------------------------------------------------------------
-
+    private ArtifactMetadataSource source;
+    
+    @Requirement
-    //@Requirement 
-    private ArtifactMetadataSource metadataSource;
-    
-    // ----------------------------------------------------------------------
-    // Implementation
-    // ----------------------------------------------------------------------
-
-    public void setOnline( boolean online )
-    {
-        this.online = online;
-    }
-
-    public boolean isOnline()
-    {
-        return online;
-    }
-
-    public void resolveAlways( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository, TransferListener downloadMonitor )
+    public void resolveAlways( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository )
-        resolve( artifact, remoteRepositories, localRepository, downloadMonitor, true );
+        resolve( artifact, remoteRepositories, localRepository, null, true );
+        
+            
+            return;
-        else if ( !artifact.isResolved() )
+        
+        if ( !artifact.isResolved() )
-            String localPath = localRepository.pathOf( artifact );
+            artifact = localRepository.find( artifact );
+            
+            if ( artifact.isFromAuthoritativeRepository() )
+            {
+                return;
+            }
+            
+            if ( artifact.isSnapshot() && artifact.isResolved() )
+            {
+                return;
+            }
+            
+            //String localPath = localRepository.pathOf( artifact );
-            artifact.setFile( new File( localRepository.getBasedir(), localPath ) );
+            //artifact.setFile( new File( localRepository.getBasedir(), localPath ) );
+            boolean destinationExists = destination.exists();
+            
-            // TODO: Should it matter whether it's a locally installed snapshot??
-            if ( force || !destination.exists() || ( artifact.isSnapshot() && !localCopy && isOnline() ) )
+            if ( force || !destination.exists() || ( artifact.isSnapshot() && !localCopy ) )
-                if ( !isOnline() )
-                {
-                    throw new ArtifactResolutionException( "The repository system is offline and the artifact "
-                        + artifact + " is not available in the local repository.", artifact );
-                }
-
-                // locally resolved...no need to hit the remote repo.
-
+                                        
+            // 1.0-SNAPSHOT
+            //
+            // 1)         pom = 1.0-SoNAPSHOT
+            // 2)         pom = 1.0-yyyymmdd.hhmmss
+            // 3) baseVersion = 1.0-SNAPSHOT
+                // 1.0-SNAPSHOT
+                // Make a file with a 1.0-SNAPSHOT format
-
+                
+                // if the timestamped version was resolved or the copy doesn't exist then copy a version
+                // of the file like 1.0-SNAPSHOT. Even if there is a timestamped version the non-timestamped
+                // version will be created.
+                // We are only going to use the 1.0-SNAPSHOT version
+                // Set the version to the 1.0-SNAPSHOT version
-
+        
-        ArtifactResolutionRequest request = new ArtifactResolutionRequest().setArtifact( originatingArtifact ).setResolveRoot( false ).setArtifactDependencies( artifacts ).setManagedVersionMap( managedVersions )
-            .setLocalRepository( localRepository ).setRemoteRepostories( remoteRepositories ).setMetadataSource( source ).setFilter( filter ).setListeners( listeners );
+        ArtifactResolutionRequest request = new ArtifactResolutionRequest()
+            .setArtifact( originatingArtifact )
+            .setResolveRoot( false )
+            // This is required by the surefire plugin
+            .setArtifactDependencies( artifacts )            
+            .setManagedVersionMap( managedVersions )
+            .setLocalRepository( localRepository )
+            .setRemoteRepostories( remoteRepositories )
+            .setFilter( filter )
+            .setListeners( listeners );
-
+    
-        ArtifactMetadataSource source = request.getMetadataSource();
-        ArtifactFilter filter = request.getFilter();
+        ArtifactFilter filter = request.getFilter();                       
+        //TODO: hack because metadata isn't generated in m2e correctly and i want to run the maven i have in the workspace
-                // Won't happen
+                e.printStackTrace();
+                // won't happen
-        
+
-        
+                        
-        {
+        {            
-                result.addArtifact( rootArtifact );
-
-        if ( artifacts == null || artifacts.size() == 0 )
+        
+        if ( request.isResolveTransitively() )
+            try
+            {
+                Set<Artifact> directArtifacts = source.retrieve( rootArtifact, localRepository, remoteRepositories ).getArtifacts();
+
+                if ( artifacts == null || artifacts.isEmpty() )
+                {
+                    artifacts = directArtifacts;
+                }
+                else
+                {
+                    List<Artifact> allArtifacts = new ArrayList<Artifact>();
+                    allArtifacts.addAll( artifacts );
+                    allArtifacts.addAll( directArtifacts );
+
+                    Map<String, Artifact> mergedArtifacts = new LinkedHashMap<String, Artifact>();
+                    for ( Artifact artifact : allArtifacts )
+                    {
+                        String conflictId = artifact.getDependencyConflictId();
+                        if ( !mergedArtifacts.containsKey( conflictId ) )
+                        {
+                            mergedArtifacts.put( conflictId, artifact );
+                        }
+                    }
+
+                    artifacts = new LinkedHashSet<Artifact>( mergedArtifacts.values() );
+                }
+            }
+            catch ( ArtifactMetadataRetrievalException e )
+            {
+                // need to add metadata resolution exception
+                return result;
+            }
+        }
+        
+        if ( artifacts == null || artifacts.isEmpty() )
+        {
+            if ( request.isResolveRoot() )
+            {
+                result.addArtifact( rootArtifact );
+            }
-        
-        // After the collection we will have the artifact object in the result but they will not be resolved yet.
-        result = artifactCollector.collect( artifacts, rootArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners );
+        // After the collection we will have the artifact object in the result but they will not be resolved yet.
+        result = artifactCollector.collect( artifacts, rootArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners, null );
+                        
-
+                
-
+                
+        // We want to send the root artifact back in the result but we need to do this after the other dependencies
+        // have been resolved.
+        if ( request.isResolveRoot() )
+        {            
+            // Add the root artifact (as the first artifact to retain logical order of class path!)
+            Set<Artifact> allArtifacts = new LinkedHashSet<Artifact>();
+            allArtifacts.add( rootArtifact );
+            allArtifacts.addAll( result.getArtifacts() );
+            result.setArtifacts( allArtifacts );
+        }                        
+                 

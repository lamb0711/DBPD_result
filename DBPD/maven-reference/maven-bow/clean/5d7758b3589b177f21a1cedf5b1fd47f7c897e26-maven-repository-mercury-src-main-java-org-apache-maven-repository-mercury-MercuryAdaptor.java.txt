o pull from trunky dunk dunk


git-svn-id: https://svn.apache.org/repos/asf/maven/components/branches/MNG-2766@767707 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
+import org.apache.maven.artifact.resolver.filter.ExcludesArtifactFilter;
+import org.apache.maven.artifact.resolver.filter.IncludesArtifactFilter;
+import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
+import org.apache.maven.mercury.artifact.ArtifactScopeEnum;
+import org.apache.maven.mercury.artifact.MetadataTreeNode;
+import org.apache.maven.repository.MavenArtifactMetadata;
+import org.apache.maven.repository.MetadataGraph;
+import org.apache.maven.repository.MetadataGraphNode;
+    
+    private static Map<String, Repository> _repos = Collections.synchronizedMap(  new HashMap<String, Repository>() );
+    
-                                                   List<ArtifactRepository> remoteRepositories,
-                                                   DependencyProcessor dependencyProcessor )
+                                                   List<?> remoteRepositories,
+                                                   DependencyProcessor dependencyProcessor
+                                                 )
-
+        
-        List<Repository> res = new ArrayList<Repository>( nRepos );
+        Map<String, Repository> repos = new LinkedHashMap<String, Repository>(nRepos);
+        
-            LocalRepositoryM2 lr =
-                new LocalRepositoryM2( localRepository.getId(), new File( localRepository.getUrl() ),
-                                       dependencyProcessor );
-            res.add( lr );
+            String url = localRepository.getUrl();
+            
+            LocalRepositoryM2 lr = (LocalRepositoryM2) _repos.get( url );
+            
+            if( lr == null )
+                try
+                {
+                    URI rootURI = new URI( url );
+                    
+                    File localRepoDir =  new File( rootURI );
+                    
+                    lr = new LocalRepositoryM2( localRepository.getId(), localRepoDir, dependencyProcessor );
+                    
+                    _repos.put( url, lr );
+                }
+                catch ( URISyntaxException e )
+                {
+                    throw new IllegalArgumentException( e );
+                }
+                repos.put( url, lr );
-            for ( ArtifactRepository ar : remoteRepositories )
+            for ( Object o : remoteRepositories )
-                Server server;
-                try
+                String url;
+                String id;
+                
+                if( ArtifactRepository.class.isAssignableFrom( o.getClass() ))
-                    server = new Server( ar.getId(), new URL( ar.getUrl() ) );
+                    ArtifactRepository ar = (ArtifactRepository) o;
+                    url = ar.getUrl();
+                    id = ar.getId();
-                catch ( MalformedURLException e )
+                else if( org.apache.maven.model.Repository.class.isAssignableFrom( o.getClass() ))
-                    throw new IllegalArgumentException( e );
+                    org.apache.maven.model.Repository ar = (org.apache.maven.model.Repository) o;
+                    url = ar.getUrl();
+                    id = ar.getId();
-                RemoteRepositoryM2 rr = new RemoteRepositoryM2( server, dependencyProcessor );
+                else
+                    throw new IllegalArgumentException( "found illegal class in the remote repository list - " + o.getClass().getName() );
+                
+                RemoteRepositoryM2 rr = (RemoteRepositoryM2) _repos.get( url );
+                
+                if( rr == null )
+                {
+                    Server server;
+                    try
+                    {
+                        server = new Server( id, new URL( url ) );
+                    }
+                    catch ( MalformedURLException e )
+                    {
+                        throw new IllegalArgumentException( e );
+                    }
+                    rr = new RemoteRepositoryM2( server, dependencyProcessor );
+                    _repos.put( url, rr );
+                }
-                res.add( rr );
+                repos.put( url, rr );
+        List<Repository> res = new ArrayList<Repository>( repos.size() );
+
+        for( Entry<String, Repository> e : repos.entrySet() )
+            res.add( e.getValue() );
+        
+//System.out.println("Converted "+nRepos+" -> "+res.size());
+//
-    public static ArtifactMetadata toMercuryBasicMetadata( Artifact a )
+    private static void setInExClusion( ArtifactMetadata md, List<String> patterns, boolean inc )
-        ArtifactMetadata md = new ArtifactMetadata();
-        md.setGroupId( a.getGroupId() );
-        md.setArtifactId( a.getArtifactId() );
-        md.setVersion( a.getVersion() );
-        md.setType( a.getType() );
-        md.setScope( a.getScope() );
-
-        return md;
+        if( Util.isEmpty( patterns ) )
+            return;
+        
+        List<ArtifactMetadata> lusions = new ArrayList<ArtifactMetadata>( patterns.size() );
+        
+        for( String pattern : patterns )
+            lusions.add( new ArtifactMetadata(pattern) );
+        
+        if( inc )
+            md.setInclusions( lusions );
+        else
+            md.setExclusions( lusions );
-
+    
-
+        
+        if( "test-jar".equals( a.getType() ) )
+        {
+            md.setType( "jar" );
+            md.setClassifier( "tests" );
+        }
+        
+        ArtifactFilter af = a.getDependencyFilter();
+        
+        if( af != null )
+        {
+            if( ExcludesArtifactFilter.class.isAssignableFrom( af.getClass() ) )
+            {
+                setInExClusion( md, ((ExcludesArtifactFilter)af).getPatterns(), false );
+            }
+            else if( IncludesArtifactFilter.class.isAssignableFrom( af.getClass() ) )
+                {
+                    setInExClusion( md, ((IncludesArtifactFilter)af).getPatterns(), true );
+                }
+        }
-        Artifact ma = a.getClassifier() == null 
-                        ? af.createArtifact( a.getGroupId(), a.getArtifactId(), a.getVersion(), a.getScope(), a.getType() )
-                        : af.createArtifactWithClassifier( a.getGroupId(), a.getArtifactId(), a.getVersion(), a.getType(), a.getClassifier() )
+        boolean isTestJar = "test-jar".equals( a.getType() );
+        
+        String type = isTestJar ? "jar" : a.getType();
+        
+        String classifier = isTestJar ? "tests" : a.getType();
+        
+        Artifact ma = classifier == null 
+                        ? af.createArtifact( a.getGroupId(), a.getArtifactId(), a.getVersion(), a.getScope(), type )
+                        : af.createArtifactWithClassifier( a.getGroupId(), a.getArtifactId(), a.getVersion(), type, classifier )
+        
+        ma.setResolved( a.getFile() != null );
+        
+        ma.setResolvedVersion( a.getVersion() );
-        Artifact ma = a.getClassifier() == null 
-                                ? af.createArtifact( a.getGroupId(), a.getArtifactId(), a.getVersion(), a.getScope(), a.getType() )
-                                : af.createArtifactWithClassifier( a.getGroupId(), a.getArtifactId(), a.getVersion(), a.getType(), a.getClassifier() )
+        boolean isTestJar = "test-jar".equals( a.getType() );
+        
+        String type = isTestJar ? "jar" : a.getType();
+        
+        String classifier = isTestJar ? "tests" : a.getType();
+        
+        Artifact ma = classifier == null 
+                                ? af.createArtifact( a.getGroupId(), a.getArtifactId(), a.getVersion(), a.getScope(), type )
+                                : af.createArtifactWithClassifier( a.getGroupId(), a.getArtifactId(), a.getVersion(), type, classifier )
+    
+    public static ArtifactMetadata toMercuryArtifactMetadata( MavenArtifactMetadata md )
+    {
+        ArtifactMetadata mmd = new ArtifactMetadata();
+        mmd.setGroupId( md.getGroupId() );
+        mmd.setArtifactId( md.getArtifactId() );
+        mmd.setVersion( md.getVersion() );
+        mmd.setClassifier( md.getClassifier() );
+        mmd.setType( md.getType() );
+        
+        if( "test-jar".equals( md.getType() ) )
+        {
+            mmd.setType( "jar" );
+            mmd.setClassifier( "tests" );
+        }
+
+        return mmd;
+    }
+    
+    public static MavenArtifactMetadata toMavenArtifactMetadata( ArtifactMetadata md )
+    {
+        MavenArtifactMetadata mmd = new MavenArtifactMetadata();
+        mmd.setGroupId( md.getGroupId() );
+        mmd.setArtifactId( md.getArtifactId() );
+        mmd.setVersion( md.getVersion() );
+        mmd.setClassifier( md.getClassifier() );
+        mmd.setType( md.getType() );
+        
+        if( "test-jar".equals( md.getType() ) )
+        {
+            mmd.setType( "jar" );
+            mmd.setClassifier( "tests" );
+        }
+
+        return mmd;
+    }
+    
+    public static MavenArtifactMetadata toMavenArtifactMetadata( Artifact md )
+    {
+        MavenArtifactMetadata mmd = new MavenArtifactMetadata();
+        mmd.setGroupId( md.getGroupId() );
+        mmd.setArtifactId( md.getArtifactId() );
+        mmd.setVersion( md.getVersion() );
+        mmd.setClassifier( md.getClassifier() );
+        mmd.setType( md.getType() );
+        
+        if( "test-jar".equals( md.getType() ) )
+        {
+            mmd.setType( "jar" );
+            mmd.setClassifier( "tests" );
+        }
+
+        return mmd;
+    }
+    
+    public static MetadataGraph resolvedTreeToGraph( MetadataTreeNode root )
+    {
+        if( root == null )
+            return null;
+        
+        MetadataGraphNode entry = new MetadataGraphNode( toMavenArtifactMetadata( root.getMd() ) );
+        
+        MetadataGraph graph = new MetadataGraph(entry);
+        
+        graph.addNode( entry );
+        
+        addKids( root, entry, graph );
+        
+        return graph;
+    }
+    
+    private static final void addKids( MetadataTreeNode tParent, MetadataGraphNode gParent, MetadataGraph graph )
+    {
+        if( !tParent.hasChildren() )
+            return;
+        
+        for( MetadataTreeNode kid : tParent.getChildren() )
+        {
+            MavenArtifactMetadata mmd = toMavenArtifactMetadata( kid.getMd() );
+            
+            MetadataGraphNode node = graph.findNode( mmd );
+            
+            node.addIncident( gParent );
+            
+            gParent.addIncident( node );
+            
+            addKids( kid, node, graph );
+        }
+    }
+
+    /**
+     * @param reqArtifact 
+     * @param isPlugin 
+     * @param filter
+     * @return
+     */
+    public static ArtifactScopeEnum extractScope( Artifact reqArtifact, boolean isPlugin, ArtifactFilter filter )
+    {
+        String scopeStr = reqArtifact.getScope(); //org.apache.maven.mercury.artifact.Artifact.SCOPE_COMPILE;
+        
+        if( filter != null )
+        {
+            if( ScopeArtifactFilter.class.isAssignableFrom( filter.getClass() ) )
+                scopeStr = ((ScopeArtifactFilter)filter).getScope(); 
+        }
+        
+//        if( "org.apache.maven.plugins:maven-remote-resources-plugin".equals( 
+//                                                      reqArtifact.getGroupId()+":"+reqArtifact.getArtifactId() 
+//                                                                           )
+//        ) scopeStr = null;
+        
+//        else if( isPlugin )
+//            scopeStr = org.apache.maven.mercury.artifact.Artifact.SCOPE_RUNTIME;
+        
+        if( scopeStr != null )
+        {
+            if( org.apache.maven.mercury.artifact.Artifact.SCOPE_COMPILE.equals( scopeStr ) )
+                return ArtifactScopeEnum.compile;
+            else if( org.apache.maven.mercury.artifact.Artifact.SCOPE_TEST.equals( scopeStr ) )
+                return ArtifactScopeEnum.test;
+            else if( org.apache.maven.mercury.artifact.Artifact.SCOPE_PROVIDED.equals( scopeStr ) )
+                return ArtifactScopeEnum.provided;
+            else if( org.apache.maven.mercury.artifact.Artifact.SCOPE_RUNTIME.equals( scopeStr ) )
+                return ArtifactScopeEnum.runtime;
+            else if( Artifact.SCOPE_RUNTIME_PLUS_SYSTEM.equals( scopeStr ) )
+                return ArtifactScopeEnum.runtime;
+            else if( org.apache.maven.mercury.artifact.Artifact.SCOPE_SYSTEM.equals( scopeStr ) )
+                return ArtifactScopeEnum.system;
+        }
+
+        return null;
+    }
+    
+    public static Map<String,ArtifactMetadata> toMercuryVersionMap(Map<String,Artifact> map  )
+    {
+        if( Util.isEmpty( map ) )
+            return null;
+        
+        Map<String,ArtifactMetadata> res = new HashMap<String, ArtifactMetadata>( map.size() );
+        
+        for( Entry<String, Artifact> e : map.entrySet() )
+        {
+            res.put( e.getKey(), toMercuryMetadata( e.getValue() ) );
+        }
+        
+        return res;
+    }

Merge branch 'eclipse-aether' of github.com:tesla/tesla-build into eclipse-aether

Conflicts:
	.gitignore
	pom.xml

+import java.io.FileInputStream;
+import javax.inject.Inject;
+import javax.inject.Named;
+
+import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader;
+import org.codehaus.plexus.util.IOUtil;
-import org.sonatype.aether.RepositoryCache;
-import org.sonatype.aether.RepositoryEvent.EventType;
-import org.sonatype.aether.RepositorySystemSession;
-import org.sonatype.aether.RequestTrace;
-import org.sonatype.aether.SyncContext;
-import org.sonatype.aether.artifact.Artifact;
-import org.sonatype.aether.impl.MetadataResolver;
-import org.sonatype.aether.impl.RepositoryEventDispatcher;
-import org.sonatype.aether.impl.SyncContextFactory;
-import org.sonatype.aether.impl.VersionResolver;
-import org.sonatype.aether.impl.internal.CacheUtils;
-import org.sonatype.aether.metadata.Metadata;
-import org.sonatype.aether.repository.ArtifactRepository;
-import org.sonatype.aether.repository.LocalRepository;
-import org.sonatype.aether.repository.RemoteRepository;
-import org.sonatype.aether.repository.WorkspaceReader;
-import org.sonatype.aether.repository.WorkspaceRepository;
-import org.sonatype.aether.resolution.MetadataRequest;
-import org.sonatype.aether.resolution.MetadataResult;
-import org.sonatype.aether.resolution.VersionRequest;
-import org.sonatype.aether.resolution.VersionResolutionException;
-import org.sonatype.aether.resolution.VersionResult;
-import org.sonatype.aether.spi.locator.Service;
-import org.sonatype.aether.spi.locator.ServiceLocator;
-import org.sonatype.aether.spi.log.Logger;
-import org.sonatype.aether.spi.log.NullLogger;
-import org.sonatype.aether.util.ConfigUtils;
-import org.sonatype.aether.util.DefaultRequestTrace;
-import org.sonatype.aether.util.listener.DefaultRepositoryEvent;
-import org.sonatype.aether.util.metadata.DefaultMetadata;
+import org.eclipse.aether.RepositoryCache;
+import org.eclipse.aether.RepositoryEvent.EventType;
+import org.eclipse.aether.RepositoryEvent;
+import org.eclipse.aether.RepositorySystemSession;
+import org.eclipse.aether.RequestTrace;
+import org.eclipse.aether.SyncContext;
+import org.eclipse.aether.artifact.Artifact;
+import org.eclipse.aether.impl.MetadataResolver;
+import org.eclipse.aether.impl.RepositoryEventDispatcher;
+import org.eclipse.aether.impl.SyncContextFactory;
+import org.eclipse.aether.impl.VersionResolver;
+import org.eclipse.aether.internal.impl.CacheUtils;
+import org.eclipse.aether.metadata.DefaultMetadata;
+import org.eclipse.aether.metadata.Metadata;
+import org.eclipse.aether.repository.ArtifactRepository;
+import org.eclipse.aether.repository.LocalRepository;
+import org.eclipse.aether.repository.RemoteRepository;
+import org.eclipse.aether.repository.WorkspaceReader;
+import org.eclipse.aether.repository.WorkspaceRepository;
+import org.eclipse.aether.resolution.MetadataRequest;
+import org.eclipse.aether.resolution.MetadataResult;
+import org.eclipse.aether.resolution.VersionRequest;
+import org.eclipse.aether.resolution.VersionResolutionException;
+import org.eclipse.aether.resolution.VersionResult;
+import org.eclipse.aether.spi.locator.Service;
+import org.eclipse.aether.spi.locator.ServiceLocator;
+import org.eclipse.aether.spi.log.Logger;
+import org.eclipse.aether.spi.log.LoggerFactory;
+import org.eclipse.aether.spi.log.NullLoggerFactory;
+import org.eclipse.aether.util.ConfigUtils;
- * Maven meta-version resolver: supports <code>*-SNAPSHOT</code>, <code>RELEASE</code> and <code>LATEST</code>
- * meta-version resolution from
- * <a href="../maven-repository-metadata/repository-metadata.html#class_versioning"><code>versioning</code>
- * element in repositories' <code>maven-metadata.xml</code></a>.
- * 
- * @see Versioning
+@Named
+    private static final String MAVEN_METADATA_XML = "maven-metadata.xml";
+
-    @Requirement
-    private Logger logger = NullLogger.INSTANCE;
+    @SuppressWarnings( "unused" )
+    @Requirement( role = LoggerFactory.class )
+    private Logger logger = NullLoggerFactory.LOGGER;
+    public DefaultVersionResolver()
+    {
+        // enable no-arg constructor
+    }
+
+    @Inject
+    DefaultVersionResolver( MetadataResolver metadataResolver, SyncContextFactory syncContextFactory,
+                            RepositoryEventDispatcher repositoryEventDispatcher, LoggerFactory loggerFactory )
+    {
+        setMetadataResolver( metadataResolver );
+        setSyncContextFactory( syncContextFactory );
+        setLoggerFactory( loggerFactory );
+        setRepositoryEventDispatcher( repositoryEventDispatcher );
+    }
+
-        setLogger( locator.getService( Logger.class ) );
+        setLoggerFactory( locator.getService( LoggerFactory.class ) );
-    public DefaultVersionResolver setLogger( Logger logger )
+    public DefaultVersionResolver setLoggerFactory( LoggerFactory loggerFactory )
-        this.logger = ( logger != null ) ? logger : NullLogger.INSTANCE;
+        this.logger = NullLoggerFactory.getSafeLogger( loggerFactory, getClass() );
+    void setLogger( LoggerFactory loggerFactory )
+    {
+        // plexus support
+        setLoggerFactory( loggerFactory );
+    }
+
+        RequestTrace trace = RequestTrace.newChild( request.getTrace(), request );
+
-
+        Metadata metadata;
+
-            Map<String, VersionInfo> infos = readVersionInfoMap( session, result, Metadata.Nature.RELEASE, null );
-
-            resolve( result, infos, RELEASE );
+            metadata =
+                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,
+                                     Metadata.Nature.RELEASE );
-            Map<String, VersionInfo> infos =
-                readVersionInfoMap( session, result, Metadata.Nature.RELEASE_OR_SNAPSHOT, null );
-
-            if ( !resolve( result, infos, LATEST ) )
-            {
-                resolve( result, infos, RELEASE );
-            }
-
-            if ( result.getVersion() != null && result.getVersion().endsWith( SNAPSHOT ) )
-            {
-                VersionRequest subRequest = new VersionRequest();
-                subRequest.setArtifact( artifact.setVersion( result.getVersion() ) );
-                if ( result.getRepository() instanceof RemoteRepository )
-                {
-                    subRequest.setRepositories( Collections.singletonList( (RemoteRepository) result.getRepository() ) );
-                }
-                else
-                {
-                    subRequest.setRepositories( request.getRepositories() );
-                }
-                VersionResult subResult = resolveVersion( session, subRequest );
-                result.setVersion( subResult.getVersion() );
-                result.setRepository( subResult.getRepository() );
-                for ( Exception exception : subResult.getExceptions() )
-                {
-                    result.addException( exception );
-                }
-            }
+            metadata =
+                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,
+                                     Metadata.Nature.RELEASE_OR_SNAPSHOT );
-                result.setVersion( version );
+                metadata = null;
-
-                return result;
-                Map<String, VersionInfo> infos =
-                                readVersionInfoMap( session, result, Metadata.Nature.SNAPSHOT, version );
+                metadata =
+                    new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), version, MAVEN_METADATA_XML,
+                                         Metadata.Nature.SNAPSHOT );
+            }
+        }
+        else
+        {
+            metadata = null;
+        }
+        if ( metadata == null )
+        {
+            result.setVersion( version );
+        }
+        else
+        {
+            List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );
+
+            metadataRequests.add( new MetadataRequest( metadata, null, request.getRequestContext() ) );
+
+            for ( RemoteRepository repository : request.getRepositories() )
+            {
+                MetadataRequest metadataRequest =
+                    new MetadataRequest( metadata, repository, request.getRequestContext() );
+                metadataRequest.setDeleteLocalCopyIfMissing( true );
+                metadataRequest.setFavorLocalRepository( true );
+                metadataRequest.setTrace( trace );
+                metadataRequests.add( metadataRequest );
+            }
+
+            List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );
+
+            Map<String, VersionInfo> infos = new HashMap<String, VersionInfo>();
+
+            for ( MetadataResult metadataResult : metadataResults )
+            {
+                result.addException( metadataResult.getException() );
+
+                ArtifactRepository repository = metadataResult.getRequest().getRepository();
+                if ( repository == null )
+                {
+                    repository = session.getLocalRepository();
+                }
+
+                Versioning versioning = readVersions( session, trace, metadataResult.getMetadata(), repository, result );
+                merge( artifact, infos, versioning, repository );
+            }
+
+            if ( RELEASE.equals( version ) )
+            {
+                resolve( result, infos, RELEASE );
+            }
+            else if ( LATEST.equals( version ) )
+            {
+                if ( !resolve( result, infos, LATEST ) )
+                {
+                    resolve( result, infos, RELEASE );
+                }
+
+                if ( result.getVersion() != null && result.getVersion().endsWith( SNAPSHOT ) )
+                {
+                    VersionRequest subRequest = new VersionRequest();
+                    subRequest.setArtifact( artifact.setVersion( result.getVersion() ) );
+                    if ( result.getRepository() instanceof RemoteRepository )
+                    {
+                        subRequest.setRepositories( Collections.singletonList( (RemoteRepository) result.getRepository() ) );
+                    }
+                    else
+                    {
+                        subRequest.setRepositories( request.getRepositories() );
+                    }
+                    VersionResult subResult = resolveVersion( session, subRequest );
+                    result.setVersion( subResult.getVersion() );
+                    result.setRepository( subResult.getRepository() );
+                    for ( Exception exception : subResult.getExceptions() )
+                    {
+                        result.addException( exception );
+                    }
+                }
+            }
+            else
+            {
-
-
-        }
-        else
-        {
-            result.setVersion( version );
-            return result;
+            if ( StringUtils.isEmpty( result.getVersion() ) )
+            {
+                throw new VersionResolutionException( result );
+            }
-        if ( StringUtils.isEmpty( result.getVersion() ) )
-        {
-            throw new VersionResolutionException( result );
-        }
-
-        if ( cacheKey != null && isSafelyCacheable( session, artifact ) )
+        if ( cacheKey != null && metadata != null && isSafelyCacheable( session, artifact ) )
-    private Map<String, VersionInfo> readVersionInfoMap( RepositorySystemSession session, VersionResult result,
-                                                         Metadata.Nature nature, String version )
-    {
-        VersionRequest request = result.getRequest();
-        Artifact artifact = request.getArtifact();
-
-        Metadata metadata =
-            new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), version,
-                                 MavenMetadata.MAVEN_METADATA_XML, nature );
-
-        RequestTrace trace = DefaultRequestTrace.newChild( request.getTrace(), request );
-
-        List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() + 1 );
-
-        metadataRequests.add( new MetadataRequest( metadata, null, request.getRequestContext() ) );
-
-        for ( RemoteRepository repository : request.getRepositories() )
-        {
-            MetadataRequest metadataRequest = new MetadataRequest( metadata, repository, request.getRequestContext() );
-            metadataRequest.setDeleteLocalCopyIfMissing( true );
-            metadataRequest.setFavorLocalRepository( true );
-            metadataRequest.setTrace( trace );
-
-            metadataRequests.add( metadataRequest );
-        }
-
-        List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );
-
-        Map<String, VersionInfo> infos = new HashMap<String, VersionInfo>();
-
-        for ( MetadataResult metadataResult : metadataResults )
-        {
-            result.addException( metadataResult.getException() );
-
-            ArtifactRepository repository = metadataResult.getRequest().getRepository();
-            if ( repository == null )
-            {
-                repository = session.getLocalRepository();
-            }
-
-            Versioning versioning = readVersions( session, trace, metadataResult.getMetadata(), repository, result );
-
-            merge( request.getArtifact(), infos, versioning, repository );
-        }
-
-        return infos;
-    }
-
-
-        if ( metadata == null )
-        {
-            return new Versioning();
-        }
-
-        SyncContext syncContext = syncContextFactory.newInstance( session, true );
-
+        FileInputStream fis = null;
-            syncContext.acquire( null, Collections.singleton( metadata ) );
-
-            versioning = MavenMetadata.read( metadata.getFile() ).getVersioning();
-
-            /*
-             * NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata
-             * of the local repository. This is especially troublesome during snapshot resolution so we try
-             * to handle that gracefully.
-             */
-            if ( versioning != null && repository instanceof LocalRepository )
+            if ( metadata != null )
-                Snapshot snapshot = versioning.getSnapshot();
-                if ( snapshot != null && snapshot.getBuildNumber() > 0 )
+                SyncContext syncContext = syncContextFactory.newInstance( session, true );
+
+                try
-                    Versioning repaired = new Versioning();
-                    repaired.setLastUpdated( versioning.getLastUpdated() );
-                    snapshot = new Snapshot();
-                    snapshot.setLocalCopy( true );
-                    repaired.setSnapshot( snapshot );
+                    syncContext.acquire( null, Collections.singleton( metadata ) );
-                    versioning = repaired;
+                    if ( metadata.getFile() != null && metadata.getFile().exists() )
+                    {
+                        fis = new FileInputStream( metadata.getFile() );
+                        org.apache.maven.artifact.repository.metadata.Metadata m =
+                            new MetadataXpp3Reader().read( fis, false );
+                        versioning = m.getVersioning();
-                    throw new IOException( "Snapshot information corrupted with remote repository data"
-                        + ", please verify that no remote repository uses the id '" + repository.getId()
-                        + "'" );
+                        /*
+                         * NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata
+                         * of the local repository. This is especially troublesome during snapshot resolution so we try
+                         * to handle that gracefully.
+                         */
+                        if ( versioning != null && repository instanceof LocalRepository )
+                        {
+                            if ( versioning.getSnapshot() != null && versioning.getSnapshot().getBuildNumber() > 0 )
+                            {
+                                Versioning repaired = new Versioning();
+                                repaired.setLastUpdated( versioning.getLastUpdated() );
+                                Snapshot snapshot = new Snapshot();
+                                snapshot.setLocalCopy( true );
+                                repaired.setSnapshot( snapshot );
+                                versioning = repaired;
+
+                                throw new IOException( "Snapshot information corrupted with remote repository data"
+                                    + ", please verify that no remote repository uses the id '" + repository.getId()
+                                    + "'" );
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    syncContext.close();
-            syncContext.release();
+            IOUtil.close( fis );
-        DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace );
+        RepositoryEvent.Builder event = new RepositoryEvent.Builder( session, EventType.METADATA_INVALID );
+        event.setTrace( trace );
-        repositoryEventDispatcher.dispatch( event );
+        repositoryEventDispatcher.dispatch( event.build() );
-}
+}

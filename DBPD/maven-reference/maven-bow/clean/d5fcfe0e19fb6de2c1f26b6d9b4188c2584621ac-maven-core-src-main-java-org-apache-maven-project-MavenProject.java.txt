o swapping the branch to trunk


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@779660 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.maven.artifact.factory.ArtifactFactory;
-import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
-import org.apache.maven.project.artifact.ActiveProjectArtifact;
-import org.apache.maven.project.artifact.InvalidDependencyVersionException;
-import org.apache.maven.repository.MavenRepositoryWrapper;
-import org.apache.maven.repository.VersionNotFoundException;
-    implements Cloneable, MavenRepositoryWrapper
+    implements Cloneable
-    private List<MavenProject> collectedProjects = Collections.emptyList();
-
-    private List<ArtifactRepository> pluginArtifactRepositories;
-
-    private File parentFile;
-
-    public File getParentFile()
-    {
-        return parentFile;
-    }
-
-    public void setParentFile( File parentFile )
-    {
-        this.parentFile = parentFile;
-    }
-
-        if ( model == null )
-        {
-            throw new IllegalArgumentException( "model: null" );
-        }
+     * @deprecated use {@link #clone()} so subclasses can provide a copy of the same class
+     */
+    @Deprecated
+    public MavenProject( MavenProject project )
+    {
+        deepCopy( project );
+    }
+    
+    @Deprecated
+    public MavenProject( Model model, RepositorySystem repositorySystem )
+    {        
+        this.repositorySystem = repositorySystem;
+        setModel( model );
+    }
+
+    private File parentFile;
+
+    public File getParentFile()
+    {
+        return parentFile;
+    }
+
+    public void setParentFile( File parentFile )
+    {
+        this.parentFile = parentFile;
+    }
+
+    /**
-        /*
-        DistributionManagement dm = model.getDistributionManagement();
+        remoteArtifactRepositories = new ArrayList<ArtifactRepository>();
-        if ( dm != null )
+        for ( Repository r : model.getRepositories() )
-            ArtifactRepository repo = repositorySystem.buildArtifactRepository( dm.getRepository() );
-            setReleaseArtifactRepository( repo );
+            try
+            {
+                remoteArtifactRepositories.add( repositorySystem.buildArtifactRepository( r ) );
+            }
+            catch ( InvalidRepositoryException e )
+            {
+            }
-        */
+        for ( Repository r : model.getPluginRepositories() )
+        {
+            try
+            {
+                remoteArtifactRepositories.add( repositorySystem.buildArtifactRepository( r ) );
+            }
+            catch ( InvalidRepositoryException e )
+            {
-        setRemoteArtifactRepositories( (projectBuilderConfiguration.getRemoteRepositories() != null) ? new ArrayList<ArtifactRepository>(projectBuilderConfiguration.getRemoteRepositories()) : new ArrayList<ArtifactRepository>());
- 
-        for(Repository r: model.getPluginRepositories())
-		{
-			try {
-				remoteArtifactRepositories.add(repositorySystem.buildArtifactRepository( r ));
-			} catch (InvalidRepositoryException e) {
+            }
+        }
-			}
-		}   
-        for(Repository r: model.getPluginRepositories())
-		{
-			try {
-				remoteArtifactRepositories.add(repositorySystem.buildArtifactRepository( r ));
-			} catch (InvalidRepositoryException e) {
+        remoteArtifactRepositories = repositorySystem.getMirrors( remoteArtifactRepositories );
-			}
-		}        
-    }
-
-    /**
-     * @deprecated use {@link #clone()} so subclasses can provide a copy of the same class
-     */
-    @Deprecated
-    public MavenProject( MavenProject project )
-    {
-        deepCopy( project );
+        if ( projectBuilderConfiguration.getRemoteRepositories() != null )
+        {
+            remoteArtifactRepositories.addAll( projectBuilderConfiguration.getRemoteRepositories() );
+        }
+                    //TODO: awful
-                    parent = mavenProjectBuilder.buildFromRepository( getParentArtifact(), this.remoteArtifactRepositories, projectBuilderConfiguration.getLocalRepository() );
+                    parent = mavenProjectBuilder.buildFromRepository( getParentArtifact(), projectBuilderConfiguration );
+                    // TODO: awful
-        {
+        {                        
+
+    @Deprecated
+    @Deprecated
+    //TODO: this checking for file == null happens because the resolver has been confused about the root
+    // artifact or not. things like the stupid dummy artifact coming from surefire.
-
+        
-        {
+        {            
-            {
+            {                
+                                                
+        
+        /*
+        System.out.println( "TEST CLASSPATH: ");
+        for( String s : list )
+        {
+            System.out.println( ">>>>> " + s );
+        }
+        */
+        
+    @Deprecated
+    @Deprecated
+    @Deprecated
+    @Deprecated
+    @Deprecated
+    @Deprecated
-    public void addPlugin( Plugin plugin )
-    {
-        Build build = getModelBuild();
-
-        if ( !build.getPluginsAsMap().containsKey( plugin.getKey() ) )
-        {
-            injectPluginManagementInfo( plugin );
-
-            build.addPlugin( plugin );
-
-            build.flushPluginMap();
-        }
-    }
-
-    //TODO: remove ModelUtils
-    public void injectPluginManagementInfo( Plugin plugin )
-    {
-        PluginManagement pm = getModelBuild().getPluginManagement();
-
-        if ( pm != null )
-        {
-            Map<String, Plugin> pmByKey = pm.getPluginsAsMap();
-
-            String pluginKey = plugin.getKey();
-
-            if ( ( pmByKey != null ) && pmByKey.containsKey( pluginKey ) )
-            {
-                Plugin pmPlugin = pmByKey.get( pluginKey );
-
-                ModelUtils.mergePluginDefinitions( plugin, pmPlugin, false );
-            }
-        }
-    }
-
-    public List<MavenProject> getCollectedProjects()
-    {
-        return collectedProjects;
-    }
-
-    public void setCollectedProjects( List<MavenProject> collectedProjects )
-    {
-        this.collectedProjects = collectedProjects;
-    }
-
-        this.pluginArtifactRepositories = pluginArtifactRepositories;
-    /**
-     * @return {@link Set} &lt; {@link Artifact} >
-     * @todo the lazy initialisation of this makes me uneasy.
-     */
-    public Set<Artifact> createArtifacts( ArtifactFactory artifactFactory, String inheritedScope, ArtifactFilter dependencyFilter )
-        throws InvalidDependencyVersionException
-    {
-        try
-        {
-            return repositorySystem.createArtifacts( getDependencies(), inheritedScope, dependencyFilter, this );
-        }
-        catch ( VersionNotFoundException e )
-        {
-            throw new InvalidDependencyVersionException( e.getProjectId(), e.getDependency(), e.getPomFile(), e.getCauseException() );
-        }
-    }
-
-    
-    public Artifact find( Artifact artifact )
-    {
-        return replaceWithActiveArtifact( artifact );
-    }
-
-    public Artifact replaceWithActiveArtifact( Artifact pluginArtifact )
-    {
-        if ( ( getProjectReferences() != null ) && !getProjectReferences().isEmpty() )
-        {
-            String refId = getProjectReferenceId( pluginArtifact.getGroupId(), pluginArtifact.getArtifactId(), pluginArtifact.getVersion() );
-            MavenProject ref = getProjectReferences().get( refId );
-            if ( ref != null )
-            {
-                if ( ref.getArtifact() != null
-                    && ref.getArtifact().getDependencyConflictId().equals( pluginArtifact.getDependencyConflictId() ) )
-                {
-                    // if the project artifact doesn't exist, don't use it. We haven't built that far.
-                    if ( ref.getArtifact().getFile() != null && ref.getArtifact().getFile().exists() )
-                    {
-                        // FIXME: Why aren't we using project.getArtifact() for the second parameter here??
-                        Artifact resultArtifact = new ActiveProjectArtifact( ref, pluginArtifact );
-                        return resultArtifact;
-                    }
-                    else
-                    {
-                        logMissingSiblingProjectArtifact( pluginArtifact );
-                    }
-                }
-
-                Artifact attached = findMatchingArtifact( ref.getAttachedArtifacts(), pluginArtifact );
-                if ( attached != null )
-                {
-                    if ( attached.getFile() != null && attached.getFile().exists() )
-                    {
-                        Artifact resultArtifact = ArtifactUtils.copyArtifact( attached );
-                        resultArtifact.setScope( pluginArtifact.getScope() );
-                        return resultArtifact;
-                    }
-                    else
-                    {
-                        logMissingSiblingProjectArtifact( pluginArtifact );
-                    }
-                }
-
-                /**
-                 * Patch/workaround for: MNG-2871
-                 * 
-                 * We want to use orginal artifact (packaging:ejb) when we are resolving ejb-client
-                 * package and we didn't manage to find attached to project one.
-                 * 
-                 * The scenario is such that somebody run "mvn test" in composity project, and
-                 * ejb-client.jar will not be attached to ejb.jar (because it is done in package
-                 * phase)
-                 * 
-                 * We prefer in such a case use orginal sources (of ejb.jar) instead of failure
-                 */
-                if ( ( ref.getArtifactId().equals( pluginArtifact.getArtifactId() ) ) && ( ref.getGroupId().equals( pluginArtifact.getGroupId() ) ) && ( ref.getArtifact().getType().equals( "ejb" ) )
-                    && ( pluginArtifact.getType().equals( "ejb-client" ) ) && ( ( ref.getArtifact().getFile() != null ) && ref.getArtifact().getFile().exists() ) )
-                {
-                    pluginArtifact = new ActiveProjectArtifact( ref, pluginArtifact );
-                    return pluginArtifact;
-                }
-            }
-        }
-        return pluginArtifact;
-    }
-
-    /**
-     * Tries to resolve the specified artifact from the given collection of attached project artifacts.
-     * 
-     * @param artifacts The attached artifacts, may be <code>null</code>.
-     * @param requestedArtifact The artifact to resolve, must not be <code>null</code>.
-     * @return The matching artifact or <code>null</code> if not found.
-     */
-    private Artifact findMatchingArtifact( List<Artifact> artifacts, Artifact requestedArtifact )
-    {
-        if ( artifacts != null && !artifacts.isEmpty() )
-        {
-            // first try matching by dependency conflict id
-            String requestedId = requestedArtifact.getDependencyConflictId();
-            for ( Artifact artifact : artifacts )
-            {
-                if ( requestedId.equals( artifact.getDependencyConflictId() ) )
-                {
-                    return artifact;
-                }
-            }
-
-            // next try matching by repository conflict id
-            requestedId = getRepositoryConflictId( requestedArtifact );
-            for ( Artifact artifact : artifacts )
-            {
-                if ( requestedId.equals( getRepositoryConflictId( artifact ) ) )
-                {
-                    return artifact;
-                }
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Gets the repository conflict id of the specified artifact. Unlike the dependency conflict id, the repository
-     * conflict id uses the artifact file extension instead of the artifact type. Hence, the repository conflict id more
-     * closely reflects the identity of artifacts as perceived by a repository.
-     * 
-     * @param artifact The artifact, must not be <code>null</code>.
-     * @return The repository conflict id, never <code>null</code>.
-     */
-    private String getRepositoryConflictId( Artifact artifact )
-    {
-        StringBuffer buffer = new StringBuffer( 128 );
-        buffer.append( artifact.getGroupId() );
-        buffer.append( ':' ).append( artifact.getArtifactId() );
-        if ( artifact.getArtifactHandler() != null )
-        {
-            buffer.append( ':' ).append( artifact.getArtifactHandler().getExtension() );
-        }
-        else
-        {
-            buffer.append( ':' ).append( artifact.getType() );
-        }
-        if ( artifact.hasClassifier() )
-        {
-            buffer.append( ':' ).append( artifact.getClassifier() );
-        }
-        return buffer.toString();
-    }
-
-    private void logMissingSiblingProjectArtifact( Artifact artifact )
-    {
-        /* TODO
-        if ( logger == null )
-        {
-            return;
-        }
-        
-        StringBuffer message = new StringBuffer();
-        message.append( "A dependency of the current project (or of one the plugins used in its build) was found in the reactor, " );
-        message.append( "\nbut had not been built at the time it was requested. It will be resolved from the repository instead." );
-        message.append( "\n\nCurrent Project: " ).append( getName() );
-        message.append( "\nRequested Dependency: " ).append( artifact.getId() );
-        message.append( "\n\nNOTE: You may need to run this build to the 'compile' lifecycle phase, or farther, in order to build the dependency artifact." );
-        message.append( "\n" );
-        
-        logger.warn( message.toString() );
-        */
-    }
-
+   
-        if ( project.getCollectedProjects() != null )
-        {
-            setCollectedProjects( ( Collections.unmodifiableList( project.getCollectedProjects() ) ) );
-        }
-
-
-        /*
-        if ( project.getReleaseArtifactRepository() != null )
-        {
-            setReleaseArtifactRepository( project.getReleaseArtifactRepository() );
-        }
-
-        if ( project.getSnapshotArtifactRepository() != null )
-        {
-            setSnapshotArtifactRepository( project.getSnapshotArtifactRepository() );
-        }
-        */

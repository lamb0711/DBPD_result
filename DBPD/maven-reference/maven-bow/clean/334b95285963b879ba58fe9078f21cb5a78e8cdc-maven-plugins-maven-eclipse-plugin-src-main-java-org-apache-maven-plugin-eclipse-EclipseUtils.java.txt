o Did some refactoring: moving utility methods to EclipseUtils so there's no
  confusion as to which project is used.

o Use executedProject everywhere except for acquiring the artifact list; the 
  executedProject misses that list (that's because no deps are resolved in
  the forked lifecycle execution; it's delayed until the plugin is encountered
  and it's requiresDependencyResolution is seen.)

o Added flag -Declipse.downloadSources=true|false to skip source downloading


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@289188 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import org.apache.maven.artifact.Artifact;
+import org.apache.maven.model.Resource;
+import org.apache.maven.plugin.logging.Log;
+    
+    
+
+    public static EclipseSourceDir[] buildDirectoryList( MavenProject project, File basedir, Log log )
+    {
+        File projectBaseDir = project.getFile().getParentFile();
+
+        // avoid duplicated entries
+        Set directories = new TreeSet();
+
+        EclipseUtils.extractSourceDirs( directories, project.getCompileSourceRoots(), basedir, projectBaseDir, false, null );
+
+        EclipseUtils.extractResourceDirs( directories, project.getBuild().getResources(), project, basedir, projectBaseDir, false,
+                             null, log );
+
+        EclipseUtils.extractSourceDirs( directories, project.getTestCompileSourceRoots(), basedir, projectBaseDir, true,
+                           EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild()
+                               .getTestOutputDirectory(), false ) );
+
+        EclipseUtils.extractResourceDirs( directories, project.getBuild().getTestResources(), project, basedir, projectBaseDir,
+                             true, EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild()
+                                 .getTestOutputDirectory(), false ), log );
+
+        return (EclipseSourceDir[]) directories.toArray( new EclipseSourceDir[directories.size()] );
+    }
+
+
+
+    private static void extractSourceDirs( Set directories, List sourceRoots, File basedir, File projectBaseDir, boolean test,
+                                   String output )
+    {
+        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )
+        {
+            String sourceRoot = (String) it.next();
+
+            if ( new File( sourceRoot ).isDirectory() )
+            {
+                sourceRoot = EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, sourceRoot, !projectBaseDir
+                    .equals( basedir ) );
+
+                directories.add( new EclipseSourceDir( sourceRoot, output, test, null, null ) );
+            }
+        }
+    }
+
+    private static void extractResourceDirs( Set directories, List resources, MavenProject project, File basedir,
+                                     File projectBaseDir, boolean test, String output, Log log )
+    {
+        for ( Iterator it = resources.iterator(); it.hasNext(); )
+        {
+
+            Resource resource = (Resource) it.next();
+            String includePattern = null;
+            String excludePattern = null;
+
+            if ( resource.getIncludes().size() != 0 )
+            {
+                // @todo includePattern = ?
+                log.warn( Messages.getString( "EclipsePlugin.includenotsupported" ) ); //$NON-NLS-1$
+            }
+
+            if ( resource.getExcludes().size() != 0 )
+            {
+                // @todo excludePattern = ?
+                log.warn( Messages.getString( "EclipsePlugin.excludenotsupported" ) ); //$NON-NLS-1$
+            }
+
+            //          Example of setting include/exclude patterns for future reference.
+            //
+            //          TODO: figure out how to merge if the same dir is specified twice
+            //          with different in/exclude patterns. We can't write them now,
+            //                      since only the the first one would be included.
+            //
+            //          if ( resource.getIncludes().size() != 0 )
+            //          {
+            //              writer.addAttribute(
+            //                      "including", StringUtils.join( resource.getIncludes().iterator(), "|" )
+            //                      );
+            //          }
+            //
+            //          if ( resource.getExcludes().size() != 0 )
+            //          {
+            //              writer.addAttribute(
+            //                      "excluding", StringUtils.join( resource.getExcludes().iterator(), "|" )
+            //              );
+            //          }
+
+            if ( !StringUtils.isEmpty( resource.getTargetPath() ) )
+            {
+                output = resource.getTargetPath();
+            }
+
+            File resourceDirectory = new File( resource.getDirectory() );
+
+            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )
+            {
+                continue;
+            }
+
+            String resourceDir = resource.getDirectory();
+            resourceDir = EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, resourceDir, !projectBaseDir
+                .equals( basedir ) );
+
+            if ( output != null )
+            {
+                output = EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, output, false );
+            }
+
+            directories.add( new EclipseSourceDir( resourceDir, output, test, includePattern, excludePattern ) );
+        }
+    }
+
+    
+    /**
+     * Utility method that locates a project producing the given artifact.
+     *
+     * @param reactorProjects a list of projects to search.
+     * @param artifact the artifact a project should produce.
+     * @return null or the first project found producing the artifact.
+     */
+    public static MavenProject findReactorProject( List reactorProjects, Artifact artifact )
+    {
+        if ( reactorProjects == null )
+        {
+            return null; // we're a single project
+        }
+
+        for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )
+        {
+            MavenProject project = (MavenProject) it.next();
+
+            if ( project.getGroupId().equals( artifact.getGroupId() )
+                && project.getArtifactId().equals( artifact.getArtifactId() )
+                && project.getVersion().equals( artifact.getVersion() ) )
+            {
+                return project;
+            }
+        }
+
+        return null;
+    }
+    
+
+    
+    /**
+     * Returns the list of referenced artifacts produced by reactor projects.
+     * @return List of Artifacts
+     */
+    public static List resolveReactorArtifacts( MavenProject project, List reactorProjects )
+    {
+        List referencedProjects = new ArrayList();
+
+        Set artifacts = project.getArtifacts();
+
+        for ( Iterator it = artifacts.iterator(); it.hasNext(); )
+        {
+            Artifact artifact = (Artifact) it.next();
+
+            MavenProject refProject = EclipseUtils.findReactorProject( reactorProjects, artifact );
+
+            if ( refProject != null )
+            {
+                referencedProjects.add( artifact );
+            }
+        }
+
+        return referencedProjects;
+    }
+

Working on: MNG-576

o Implemented plan from my comments on MNG-576 for looking up lifecycle mappings within plugins.

o Fixed subtle bug in DefaultWagonManager for verifying checksums, where the destination file was being used to verify the checksum rather than the recently download temp destination.

o Fixed the DefaultRepositoryMetadataManager.resolve(..) method to allow the locally-installed metadata to be used if it is newer than the one resolved from the repository.

o Moved the lifecycle mappings for the EJB and WAR plugins out to META-INF/plexus/components.xml in the respective plugin's src/main/resources directory. it0016 and it0017 still pass.

o Changed the distributionManagement repository for maven-plugins/pom.xml to have id of 'central-plugins' and then added a normal artifact repository definition for central-plugins to that pom, to allow locally-installed repository metadata for the plugins to be put in the right place (and these builds should have access to the central plugin repo anyway).

o Changed the DefaultPluginMappingBuilder to only warn when plugins.xml for a particular plugin group is missing.



git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@216273 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.lifecycle.mapping.LifecycleMapping;
+import org.codehaus.classworlds.ClassRealm;
+import org.codehaus.classworlds.ClassWorld;
+import org.codehaus.classworlds.DuplicateRealmException;
+import org.codehaus.plexus.component.discovery.ComponentDiscoverer;
+import org.codehaus.plexus.component.discovery.ComponentDiscovererManager;
+import org.codehaus.plexus.component.discovery.ComponentDiscoveryEvent;
+import org.codehaus.plexus.component.discovery.ComponentDiscoveryListener;
+import org.codehaus.plexus.component.discovery.DefaultComponentDiscoverer;
+import org.codehaus.plexus.component.discovery.PlexusXmlComponentDiscoverer;
+import org.codehaus.plexus.component.repository.ComponentDescriptor;
+import org.codehaus.plexus.component.repository.ComponentSetDescriptor;
+import org.codehaus.plexus.configuration.PlexusConfigurationException;
+import org.codehaus.plexus.context.Context;
+import org.codehaus.plexus.context.DefaultContext;
+import java.net.MalformedURLException;
+import java.util.ArrayList;
-    private String outputDirectory;
+    private String metadataDirectory;
+
+    /**
+     * @parameter expression="${project.build.outputDirectory}"
+     * @required
+     * @readonly
+     */
+    private String classesDirectory;
-    public void execute() throws MojoExecutionException
+    public void execute()
+        throws MojoExecutionException
-        
+
-                
+
-        
+
-        
+
-        
+
-        
+
-            
+
-            
+
-            
+
-            
+
-                
+
-        
-        boolean prefixAlreadyMapped = false;
-        
+
-            
-            if ( preExisting.getPrefix().equals( getGoalPrefix() ) )
+
+            if ( preExisting.getArtifactId().equals( project.getArtifactId() ) )
-                prefixAlreadyMapped = true;
-                
-                if ( !preExisting.getArtifactId().equals( project.getArtifactId() ) )
-                {
-                    // TODO: In this case, should we rather just replace the existing plugin mapping??
-                    
-                    throw new MojoExecutionException( "Cannot map plugin to it's prefix in plugins.xml metadata; the prefix: \'" + getGoalPrefix() + "\' is already mapped to: " + preExisting.getArtifactId() ); 
-                }
-                else
-                {
-                    getLog().info( "NOT updating plugins.xml metadata; this plugin is already mapped." ); 
-                }
-                
+                getLog().info( "Updating pre-existing plugin-mapping metadata." );
+
+                pluginMap.removePlugin( preExisting );
+
-        
-        if ( !prefixAlreadyMapped )
+
+        MappedPlugin mappedPlugin = new MappedPlugin();
+
+        mappedPlugin.setArtifactId( project.getArtifactId() );
+
+        mappedPlugin.setPrefix( getGoalPrefix() );
+
+        mappedPlugin.setPackagingHandlers( extractPackagingHandlers() );
+
+        pluginMap.addPlugin( mappedPlugin );
+
+        Writer writer = null;
+        try
-            MappedPlugin mappedPlugin = new MappedPlugin();
-            
-            mappedPlugin.setArtifactId( project.getArtifactId() );
-            
-            mappedPlugin.setPrefix( getGoalPrefix() );
-            
-            pluginMap.addPlugin( mappedPlugin );
-            
-            Writer writer = null;
-            try
-            {
-                File updatedMetadataFile = new File( outputDirectory, metadata.getRepositoryPath() ).getAbsoluteFile();
+            File updatedMetadataFile = new File( metadataDirectory, metadata.getRepositoryPath() ).getAbsoluteFile();
-                File dir = updatedMetadataFile.getParentFile();
+            File dir = updatedMetadataFile.getParentFile();
-                if ( !dir.exists() )
-                {
-                    dir.mkdirs();
-                }
-                
-                writer = new FileWriter( updatedMetadataFile );
-                
-                PluginMappingXpp3Writer mappingWriter = new PluginMappingXpp3Writer();
-                
-                mappingWriter.write( writer, pluginMap );
-                
-                metadata.setFile( updatedMetadataFile );
-            }
-            catch ( IOException e )
+            if ( !dir.exists() )
-                throw new MojoExecutionException( "Error writing repository metadata to build directory.", e );
+                dir.mkdirs();
-            finally
-            {
-                IOUtil.close( writer );
-            }
+
+            writer = new FileWriter( updatedMetadataFile );
+
+            PluginMappingXpp3Writer mappingWriter = new PluginMappingXpp3Writer();
+
+            mappingWriter.write( writer, pluginMap );
+
+            metadata.setFile( updatedMetadataFile );
+        }
+        catch ( IOException e )
+        {
+            throw new MojoExecutionException( "Error writing repository metadata to build directory.", e );
+        }
+        finally
+        {
+            IOUtil.close( writer );
-    
+
+    private List extractPackagingHandlers()
+        throws MojoExecutionException
+    {
+        List packagingHandlers = new ArrayList();
+
+        Context ctx = new DefaultContext();
+
+        ClassWorld discoveryWorld = new ClassWorld();
+
+        try
+        {
+            ClassRealm discoveryRealm = discoveryWorld.newRealm( "packageHandler-discovery" );
+
+            File classDir = new File( classesDirectory ).getAbsoluteFile();
+
+            discoveryRealm.addConstituent( classDir.toURL() );
+
+            packagingHandlers
+                .addAll( discoverLifecycleMappings( ctx, discoveryRealm, new DefaultComponentDiscoverer() ) );
+
+            packagingHandlers.addAll( discoverLifecycleMappings( ctx, discoveryRealm,
+                                                                 new PlexusXmlComponentDiscoverer() ) );
+        }
+        catch ( DuplicateRealmException e )
+        {
+            throw new MojoExecutionException( "Error constructing class-realm for lifecycle-mapping detection.", e );
+        }
+        catch ( MalformedURLException e )
+        {
+            throw new MojoExecutionException( "Error constructing class-realm for lifecycle-mapping detection.", e );
+        }
+        catch ( PlexusConfigurationException e )
+        {
+            throw new MojoExecutionException( "Error detecting lifecycle-mappings.", e );
+        }
+
+        return packagingHandlers;
+    }
+
+    private List discoverLifecycleMappings( Context ctx, ClassRealm discoveryRealm, ComponentDiscoverer discoverer )
+        throws PlexusConfigurationException
+    {
+        discoverer.setManager( new DummyComponentDiscovererManager() );
+        
+        List packagingHandlers = new ArrayList();
+
+        List componentSetDescriptors = discoverer.findComponents( ctx, discoveryRealm );
+
+        if ( componentSetDescriptors != null )
+        {
+            for ( Iterator it = componentSetDescriptors.iterator(); it.hasNext(); )
+            {
+                ComponentSetDescriptor setDescriptor = (ComponentSetDescriptor) it.next();
+
+                List components = setDescriptor.getComponents();
+
+                if ( components != null )
+                {
+                    for ( Iterator componentIterator = components.iterator(); componentIterator.hasNext(); )
+                    {
+                        ComponentDescriptor descriptor = (ComponentDescriptor) componentIterator.next();
+
+                        if ( LifecycleMapping.ROLE.equals( descriptor.getRole() ) )
+                        {
+                            packagingHandlers.add( descriptor.getRoleHint() );
+                        }
+                    }
+                }
+            }
+        }
+
+        return packagingHandlers;
+    }
+
-        
+
+    public static class DummyComponentDiscovererManager implements ComponentDiscovererManager
+    {
+
+        DummyComponentDiscovererManager()
+        {
+        }
+        
+        public List getComponentDiscoverers()
+        {
+            return null;
+        }
+
+        public void registerComponentDiscoveryListener( ComponentDiscoveryListener listener )
+        {
+        }
+
+        public void removeComponentDiscoveryListener( ComponentDiscoveryListener listener )
+        {
+        }
+
+        public void fireComponentDiscoveryEvent( ComponentDiscoveryEvent event )
+        {
+        }
+
+        public void initialize()
+        {
+        }
+
+        public List getListenerDescriptors()
+        {
+            return null;
+        }
+        
+    }

[MNG-4651]  Re-added missing methods for 3.x site plugin

Also clarified role of LifecylceExecutor as a 'facade providing lifecycle services'

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@939028 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.maven.execution.*;
-import org.apache.maven.lifecycle.internal.BuildListCalculator;
-import org.apache.maven.lifecycle.internal.ConcurrencyDependencyGraph;
-import org.apache.maven.lifecycle.internal.ExecutionEventCatapult;
-import org.apache.maven.lifecycle.internal.LifecycleDebugLogger;
+import org.apache.maven.execution.MavenSession;
+import org.apache.maven.lifecycle.internal.DependencyContext;
-import org.apache.maven.lifecycle.internal.LifecycleModuleBuilder;
+import org.apache.maven.lifecycle.internal.LifecycleExecutionPlanCalculatorImpl;
+import org.apache.maven.lifecycle.internal.LifecycleStarter;
-import org.apache.maven.lifecycle.internal.LifecycleThreadedBuilder;
-import org.apache.maven.lifecycle.internal.LifecycleWeaveBuilder;
-import org.apache.maven.lifecycle.internal.ProjectBuildList;
+import org.apache.maven.lifecycle.internal.MojoExecutor;
-import org.apache.maven.lifecycle.internal.ProjectSegment;
-import org.apache.maven.lifecycle.internal.ReactorBuildStatus;
-import org.apache.maven.lifecycle.internal.ReactorContext;
-import org.apache.maven.lifecycle.internal.ThreadConfigurationService;
+import org.apache.maven.plugin.MojoExecution;
-import org.codehaus.plexus.logging.Logger;
+import java.util.Collections;
-import java.util.concurrent.CompletionService;
-import java.util.concurrent.ExecutorCompletionService;
-import java.util.concurrent.ExecutorService;
+import java.util.TreeSet;
+ * A facade that provides lifecycle services to components outside maven core.
+ *
+ * Note that this component is not normally used from within core itself.
+ *  
-    private ExecutionEventCatapult eventCatapult;
-
-    @Requirement
-    private Logger logger;
-
-    @Requirement
-    private LifecycleModuleBuilder lifecycleModuleBuilder;
-
-    @Requirement
-    private LifecycleWeaveBuilder lifeCycleWeaveBuilder;
-
-    @Requirement
-    private LifecycleThreadedBuilder lifecycleThreadedBuilder;
-
-    @Requirement
-    private BuildListCalculator buildListCalculator;
-
-    @Requirement
-    private LifecycleDebugLogger lifecycleDebugLogger;
-
-    @Requirement
-    private ThreadConfigurationService threadConfigService;
+    private MojoExecutor mojoExecutor;
-    public DefaultLifecycleExecutor()
-    {
-    }
+    @Requirement
+    private LifecycleStarter lifecycleStarter;
+
-        eventCatapult.fire( ExecutionEvent.Type.SessionStarted, session, null );
-
-        MavenExecutionResult result = session.getResult();
-
-        try
-        {
-            if ( !session.isUsingPOMsFromFilesystem() && lifecycleTaskSegmentCalculator.requiresProject( session ) )
-            {
-                throw new MissingProjectException( "The goal you specified requires a project to execute" +
-                    " but there is no POM in this directory (" + session.getExecutionRootDirectory() + ")." +
-                    " Please verify you invoked Maven from the correct directory." );
-            }
-
-            final MavenExecutionRequest executionRequest = session.getRequest();
-            boolean isThreaded = executionRequest.isThreadConfigurationPresent();
-            session.setParallel( isThreaded );
-
-            List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );
-
-            ProjectBuildList projectBuilds = buildListCalculator.calculateProjectBuilds( session, taskSegments );
-
-            if ( projectBuilds.isEmpty() )
-            {
-                throw new NoGoalSpecifiedException( "No goals have been specified for this build." +
-                    " You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or" +
-                    " <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>." +
-                    " Available lifecycle phases are: " + defaultLifeCycles.getLifecyclePhaseList() + "." );
-            }
-
-            ProjectIndex projectIndex = new ProjectIndex( session.getProjects() );
-
-            if ( logger.isDebugEnabled() )
-            {
-                lifecycleDebugLogger.debugReactorPlan( projectBuilds );
-            }
-
-            ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();
-
-            ReactorBuildStatus reactorBuildStatus = new ReactorBuildStatus( session.getProjectDependencyGraph() );
-            ReactorContext callableContext =
-                new ReactorContext( result, projectIndex, oldContextClassLoader, reactorBuildStatus );
-
-            if ( isThreaded )
-            {
-                ExecutorService executor = threadConfigService.getExecutorService( executionRequest.getThreadCount(),
-                                                                                   executionRequest.isPerCoreThreadCount(),
-                                                                                   session.getProjects().size() );
-                try
-                {
-
-                    final boolean isWeaveMode = LifecycleWeaveBuilder.isWeaveMode( executionRequest );
-                    if ( isWeaveMode )
-                    {
-                        lifecycleDebugLogger.logWeavePlan( session );
-                        CompletionService<ProjectSegment> service =
-                            new ExecutorCompletionService<ProjectSegment>( executor );
-                        lifeCycleWeaveBuilder.build( projectBuilds, callableContext, taskSegments, session, service,
-                                                     reactorBuildStatus );
-                    }
-                    else
-                    {
-                        ConcurrencyDependencyGraph analyzer =
-                            new ConcurrencyDependencyGraph( projectBuilds, session.getProjectDependencyGraph() );
-
-                        CompletionService<ProjectSegment> service =
-                            new ExecutorCompletionService<ProjectSegment>( executor );
-
-                        lifecycleThreadedBuilder.build( session, callableContext, projectBuilds, taskSegments, analyzer,
-                                                        service );
-                    }
-                }
-                finally
-                {
-                    executor.shutdown();
-                }
-            }
-            else
-            {
-                singleThreadedBuild( session, callableContext, projectBuilds, taskSegments, reactorBuildStatus );
-            }
-
-        }
-
-        catch (
-
-            Exception e
-
-            )
-
-        {
-            result.addException( e );
-        }
-
-        eventCatapult.fire( ExecutionEvent.Type.SessionEnded, session, null );
+        lifecycleStarter.execute( session );
-    private void singleThreadedBuild( MavenSession session, ReactorContext callableContext,
-                                      ProjectBuildList projectBuilds, List<TaskSegment> taskSegments,
-                                      ReactorBuildStatus reactorBuildStatus )
-    {
-        for ( TaskSegment taskSegment : taskSegments )
-        {
-            for ( ProjectSegment projectBuild : projectBuilds.getByTaskSegment( taskSegment ) )
-            {
-                try
-                {
-                    lifecycleModuleBuilder.buildProject( session, callableContext, projectBuild.getProject(),
-                                                         taskSegment );
-                    if ( reactorBuildStatus.isHalted() )
-                    {
-                        break;
-                    }
-                }
-                catch ( Exception e )
-                {
-                    break;  // Why are we just ignoring this exception? Are exceptions are being used for flow control
-                }
-
-            }
-        }
-    }
-
-    /**
-     * * CRUFT GOES BELOW HERE ***
-     */
-
+    // TODO: But for some reason the whole plexus appcontext refuses to start when I try this.
+    // Site 3.x
+    public void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
+        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
+        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
+        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
+    {
+        lifecycleExecutionPlanCalculator.calculateForkedExecutions( mojoExecution, session );
+    }
+
+
+    // Site 3.x
+    public List<MavenProject> executeForkedExecutions( MojoExecution mojoExecution, MavenSession session )
+        throws LifecycleExecutionException
+    {
+        Set<String> requiredDependencyResolutionScopes = new TreeSet<String>();
+        Set<String> requiredDependencyCollectionScopes = new TreeSet<String>();
+                                             // Ok, so this method could probably have a better location.
+        LifecycleExecutionPlanCalculatorImpl.collectDependencyRequirements( requiredDependencyResolutionScopes,
+                                                                            requiredDependencyCollectionScopes,
+                                                                            mojoExecution );
+
+        final DependencyContext context =
+            new DependencyContext( requiredDependencyCollectionScopes, requiredDependencyResolutionScopes,
+                                   mojoExecution.getMojoDescriptor().isAggregator() );
+        mojoExecutor.executeForkedExecutions( mojoExecution, session, new ProjectIndex( session.getProjects() ),
+                                              context );
+        return Collections.emptyList();
+    }
+
+

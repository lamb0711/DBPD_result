Throwing exception if infinite loop detected in phase vs. executePhase...this is probably not optimal, but it's a start.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@233104 13f79535-47bb-0310-9956-ffa450edef68

+        
+        String mojoPhase = findFirstPhaseBindingForMojo( mojoDescriptor, lifecycleMappings );
+        
+        int mojoPhaseIdx = phases.indexOf( mojoPhase );
+        int execPhaseIdx = phases.indexOf( task );
+        
+        if ( mojoPhaseIdx > -1 && mojoPhaseIdx <= execPhaseIdx )
+        {
+            throw new LifecycleExecutionException( "Infinite loop detected in build process. Mojo: \'"
+                + mojoDescriptor.getGoal() + "\' declares executePhase of: \'" + task
+                + "\' but is itself bound to phase: \'" + mojoPhase
+                + "\'. This will result in infinite forking of build execution." );
+        }
+    private String findFirstPhaseBindingForMojo( MojoDescriptor mojoDescriptor, Map lifecycleMappings )
+    {
+        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();
+        
+        String mojoIdWithVersion = pluginDescriptor.getGroupId() + ":" + pluginDescriptor.getArtifactId() + ":"
+            + pluginDescriptor.getVersion() + ":" + mojoDescriptor.getGoal();
+        
+        String mojoIdWithoutVersion = pluginDescriptor.getGroupId() + ":" + pluginDescriptor.getArtifactId() + ":"
+            + mojoDescriptor.getGoal();
+            
+        for ( Iterator it = lifecycleMappings.entrySet().iterator(); it.hasNext(); )
+        {
+            Map.Entry entry = (Map.Entry) it.next();
+            
+            String phase = (String) entry.getKey();
+            List tasks = (List) entry.getValue();
+            
+            if ( tasks.contains( mojoIdWithVersion ) || tasks.contains( mojoIdWithoutVersion ) )
+            {
+                return phase;
+            }
+        }
+        
+        return null;
+    }
+
-                if ( execution.getPhase() != null )
-                {
-                    addToLifecycleMappings( phaseMap, execution.getPhase(), mojoExecution, settings );
-                }
-                else if ( mojoDescriptor.getPhase() != null )
+                
+                String phase = execution.getPhase();
+                
+                if ( phase == null )
-                    addToLifecycleMappings( phaseMap, mojoDescriptor.getPhase(), mojoExecution, settings );
+                    phase = mojoDescriptor.getPhase();
+                }
+                
+                if ( phase != null )
+                {
+                    if ( mojoDescriptor.isDirectInvocationOnly() )
+                    {
+                        throw new LifecycleExecutionException( "Mojo: \'" + goal + "\' requires direct invocation. It cannot be used as part of the lifecycle (it was included via the POM)." );
+                    }
+                    
+                    addToLifecycleMappings( phaseMap, phase, mojoExecution, settings );

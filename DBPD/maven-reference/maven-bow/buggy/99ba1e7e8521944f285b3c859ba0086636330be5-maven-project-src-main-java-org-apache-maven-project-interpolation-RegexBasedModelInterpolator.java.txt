PR: MNG-2339 - ${project.*} evaluated badly

This commit makes sure that pom.* and project.* are resolved using the model reflector,
but if the prefix isn't pom or project, context and model properties are consulted.
If the value still isn't found, the model reflector is used as a legacy fallback,
and a warning is printed.

Also, project.* is deprecated in favour of pom.*.

TODO: env.*.

N.B.: there's loads of warnings about ${artifactId}. I can turn these off,
but if you specify -DartifactId on the commandline, all hell breaks loose.

See http://docs.codehaus.org/display/MAVEN/Refactoring+Interpolation


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@549786 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+import java.util.Set;
+     * @param strict  This parameter is ignored!
+    /**
+     * Interpolates all expressions in the src parameter.
+     * <p>
+     * The algorithm used for each expression is:
+     * <ul>
+     *   <li>If it starts with either "pom." or "project.", the expression is evaluated against the model.</li>
+     *   <li>If the value is null, get the value from the context.</li>
+     *   <li>If the value is null, but the context contains the expression, don't replace the expression string
+     *       with the value, and continue to find other expressions.</li>
+     *   <li>If the value is null, get it from the model properties.</li>
+     *   <li>
+     *
+     *
+     */
+        Logger logger = getLogger();
+
+            String prefix = matcher.group( 1 );
-            Object value = context.get( realExpr );
+            prefix = prefix == null ? "" : prefix;
+
+            Object value = null;
+
+            boolean isPomExpression = "pom.".equals( prefix ) || "project.".equals( prefix );
+
+            if ( logger != null && "project.".equals( prefix ) )
+            {
+                logger.warn( "Deprecated expression: " + wholeExpr + " - 'project.' prefix is deprecated."
+                    + " Use 'pom.': ${pom." + realExpr + "} (model: " + model.getId() + ")" );
+            }
+
+            if ( isPomExpression )
+            {
+                value = getValueFromModel( realExpr, model, wholeExpr, logger );
+            }
+                value = context.get( realExpr );
+
-                if ( context.containsKey( realExpr ) )
+                if ( value == null && context.containsKey( realExpr ) )
-
-                value = model.getProperties().getProperty( realExpr );
-                try
-                {
-                    // NOTE: We've already trimmed off any leading expression parts like 'project.'
-                    // or 'pom.', and now we have to ensure that the ReflectionValueExtractor
-                    // doesn't try to do it again.
-                    value = ReflectionValueExtractor.evaluate( realExpr, model, false );
-                }
-                catch ( Exception e )
-                {
-                    Logger logger = getLogger();
-                    if ( logger != null )
-                    {
-                        logger.debug( "POM interpolation cannot proceed with expression: " + wholeExpr + ". Skipping...", e );
-                    }
-                }
+                value = model.getProperties().getProperty( realExpr );
-            // if the expression refers to itself, skip it.
-            if ( String.valueOf( value ).indexOf( wholeExpr ) > -1 )
+            // Any expression, not just artifactId, version etc., but also scm.repository 
+            // were evaluated against the model, even if there is no prefix.
+            // If the 2.1 strategy fails, try the legacy approach. If it yields a result, warn for it.
+            if ( value == null && prefix.length() == 0 )
-                throw new ModelInterpolationException( wholeExpr, "Expression value '" + value + "' references itself in '" + model.getId() + "'." );
+                value = getValueFromModel( realExpr, model, wholeExpr, logger );
+
+                if ( value != null && logger != null )
+                {
+                    logger.warn( "Deprecated expression: " + wholeExpr + " - missing prefix. Use ${pom."
+                        + realExpr + "} (model: " + model.getId() + ")" );
+                }
-                result = StringUtils.replace( result, wholeExpr, String.valueOf( value ) );
+                // if the expression refers to itself, skip it.
+                // replace project. expressions with pom. expressions to circumvent self-referencing expressions using
+                // the 2 different model expressions.
+                if ( StringUtils.replace( value.toString(), "${project.", "${pom." ).indexOf(
+                    StringUtils.replace( wholeExpr, "${project.", "${pom." ) ) > -1 )
+                {
+                    throw new ModelInterpolationException( wholeExpr, "Expression value '" + value
+                        + "' references itself in '" + model.getId() + "'." );
+                }
+
+                result = StringUtils.replace( result, wholeExpr, value.toString() );
+    private static Object getValueFromModel( String realExpr, Model model, String wholeExpr, Logger logger )
+    {
+        try
+        {
+            // NOTE: We've already trimmed off any leading expression parts like 'project.'
+            // or 'pom.', and now we have to ensure that the ReflectionValueExtractor
+            // doesn't try to do it again.
+            return ReflectionValueExtractor.evaluate( realExpr, model, false );
+        }
+        catch ( Exception e )
+        {
+            if ( logger != null )
+            {
+                logger.debug( "POM interpolation cannot proceed with expression: " + wholeExpr + ". Skipping...", e );
+            }
+
+            return null;
+        }
+    }

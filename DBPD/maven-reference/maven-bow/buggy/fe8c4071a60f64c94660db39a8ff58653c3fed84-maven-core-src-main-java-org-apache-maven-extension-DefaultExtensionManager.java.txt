Switching back to selectively import extensions into a project-specific ClassRealm, except this time extension realms will be shared (the origin of the aforementioned imports) to conserve memory tied up by classloading. Similarly, plugin realms are managed using a key produced from g:a:v of the plugin, plus the hashcode of all g:a:v of the plugin-level dependencies aggregated into one string, to distinguish the deploy plugin 2.0 with no deps from the deploy plugin 2.0 with a plugin-level dep on wagon-webdav. Plugin realms have their parent realms managed by the pluginManager now prior to lookup or execution of the mojo instance, and PluginDescriptor.(classRealm|artifacts) attributes are set for each execution. Likewise, the MavenPluginCollector now tracks plugin descriptors with their version information included, instead of just using g:a.

Had to bump the plexus-container-default version up to alpha-36 to fix a problem in ClassicSingletonComponentManager. All realms for extensions, plugins, and projects (which contain only imports from extensions) are now managed by the MavenRealmManager.


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@591391 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
+import org.apache.maven.artifact.resolver.ArtifactResolutionException;
-import org.apache.maven.execution.MavenProjectSession;
+import org.apache.maven.execution.MavenExecutionRequest;
+import org.apache.maven.execution.MavenRealmManager;
+import org.apache.maven.execution.MavenSession;
+import org.apache.maven.execution.RealmManagementException;
+import org.apache.maven.execution.RealmUtils;
+import org.apache.maven.model.Plugin;
+import org.apache.maven.monitor.event.DefaultEventDispatcher;
+import org.apache.maven.monitor.event.EventDispatcher;
+import org.apache.maven.plugin.InvalidPluginException;
+import org.apache.maven.plugin.PluginManager;
+import org.apache.maven.plugin.PluginManagerException;
+import org.apache.maven.plugin.PluginNotFoundException;
+import org.apache.maven.plugin.descriptor.PluginDescriptor;
+import org.apache.maven.plugin.version.PluginVersionNotFoundException;
+import org.apache.maven.plugin.version.PluginVersionResolutionException;
-import org.codehaus.plexus.classworlds.ClassWorld;
-import org.codehaus.plexus.classworlds.realm.ClassRealm;
-import org.codehaus.plexus.classworlds.realm.DuplicateRealmException;
-import org.codehaus.plexus.classworlds.realm.NoSuchRealmException;
-import org.codehaus.plexus.component.discovery.ComponentDiscoverer;
-import org.codehaus.plexus.component.discovery.ComponentDiscovererManager;
-import org.codehaus.plexus.component.discovery.ComponentDiscoveryEvent;
-import org.codehaus.plexus.component.discovery.ComponentDiscoveryListener;
-import org.codehaus.plexus.component.discovery.DefaultComponentDiscoverer;
-import org.codehaus.plexus.component.repository.ComponentDescriptor;
-import org.codehaus.plexus.component.repository.ComponentSetDescriptor;
-import org.codehaus.plexus.component.repository.exception.ComponentRepositoryException;
-import org.codehaus.plexus.configuration.PlexusConfigurationException;
-import java.net.MalformedURLException;
-import java.util.Collection;
-import java.util.Map;
+    private PluginManager pluginManager;
+
-                              ArtifactRepository localRepository )
+                              MavenExecutionRequest request )
-                      localRepository,
+                      request,
-                      MavenProjectSession.createProjectId( groupId, artifactId, version ) );
+                      groupId,
+                      artifactId,
+                      version );
+    }
+
+    public void addPluginAsExtension( Plugin plugin,
+                              Model originatingModel,
+                              List remoteRepositories,
+                              MavenExecutionRequest request )
+        throws ExtensionManagerException
+    {
+        Parent originatingParent = originatingModel.getParent();
+
+        String groupId = originatingModel.getGroupId();
+
+        if ( ( groupId == null ) && ( originatingParent != null ) )
+        {
+            groupId = originatingParent.getGroupId();
+        }
+
+        String artifactId = originatingModel.getArtifactId();
+
+        String version = originatingModel.getVersion();
+
+        if ( ( version == null ) && ( originatingParent != null ) )
+        {
+            version = originatingParent.getVersion();
+        }
+
+        Artifact pluginArtifact = artifactFactory.createBuildArtifact( plugin.getGroupId(),
+                                                                       plugin.getArtifactId(),
+                                                                       plugin.getVersion(), "maven-plugin" );
+
+        getLogger().debug( "Starting extension-addition process for: " + pluginArtifact );
+
+        ArtifactFilter coreFilter = artifactFilterManager.getArtifactFilter();
+        MavenRealmManager realmManager = request.getRealmManager();
+
+        // if the extension is null,
+        // or if it's excluded by the core filter,
+        //
+        // skip it.
+        if ( ( pluginArtifact != null )
+             && coreFilter.include( pluginArtifact ) )
+        {
+            if ( !realmManager.hasExtensionRealm( pluginArtifact ) )
+            {
+                MavenProject dummyProject = new MavenProject( originatingModel );
+                EventDispatcher dispatcher = new DefaultEventDispatcher( request.getEventMonitors() );
+                MavenSession session = new MavenSession( container, request, dispatcher, null );
+
+                PluginDescriptor pd;
+                try
+                {
+                    pd = pluginManager.verifyPlugin( plugin, dummyProject, session );
+                    pluginArtifact = pd.getPluginArtifact();
+                }
+                catch ( ArtifactResolutionException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+                catch ( ArtifactNotFoundException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+                catch ( PluginNotFoundException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+                catch ( PluginVersionResolutionException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+                catch ( InvalidPluginException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+                catch ( PluginManagerException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+                catch ( PluginVersionNotFoundException e )
+                {
+                    throw new ExtensionManagerException( "Failed to resolve extension plugin: " + pluginArtifact, pluginArtifact, groupId, artifactId, version, e );
+                }
+
+                try
+                {
+                    realmManager.createExtensionRealm( pluginArtifact, pd.getArtifacts() );
+                }
+                catch ( RealmManagementException e )
+                {
+                    String projectId = RealmUtils.createProjectId( groupId, artifactId, version );
+                    throw new ExtensionManagerException( "Unable to create extension ClassRealm for extension: " + pluginArtifact.getId() + " within session for project: " + projectId, pluginArtifact, groupId, artifactId, version, e );
+                }
+            }
+
+            try
+            {
+                realmManager.importExtensionsIntoProjectRealm( groupId, artifactId, version, pluginArtifact );
+            }
+            catch ( RealmManagementException e )
+            {
+                throw new ExtensionManagerException( "Unable to import extension components into project realm.", pluginArtifact, groupId, artifactId, version, e );
+            }
+        }
-                              ArtifactRepository localRepository )
+                              MavenExecutionRequest request )
-                      localRepository,
+                      request,
-                      MavenProjectSession.createProjectId( project.getGroupId(), project.getArtifactId(), project.getVersion() )  );
-    }
-
-    private String createExtensionRealmId( Artifact realmArtifact )
-    {
-        return "/extensions/" + ArtifactUtils.versionlessKey( realmArtifact );
+                      project.getGroupId(),
+                      project.getArtifactId(),
+                      project.getVersion() );
-                               ArtifactRepository localRepository,
+                               MavenExecutionRequest request,
-                               String projectId )
+                               String projectGroupId,
+                               String projectArtifactId,
+                               String projectVersion )
+        MavenRealmManager realmManager = request.getRealmManager();
-        // if it's already been added to the current project-session,
-            String realmId = createExtensionRealmId( extensionArtifact );
-            try
+            if ( !realmManager.hasExtensionRealm( extensionArtifact ) )
-                container.getClassWorld().getRealm( realmId );
+                ArtifactFilter filter =
+                    new ProjectArtifactExceptionFilter( coreFilter, projectArtifact );
-                // if we find the realm, we don't need to proceed, we've already added this extension.
-                return;
-            }
-            catch ( NoSuchRealmException e )
-            {
-                // proceed.
-            }
+                ResolutionGroup resolutionGroup;
-            ArtifactFilter filter =
-                new ProjectArtifactExceptionFilter( coreFilter, projectArtifact );
-
-            ResolutionGroup resolutionGroup;
-
-            try
-            {
-                resolutionGroup = artifactMetadataSource.retrieve( extensionArtifact, localRepository, remoteRepositories );
-            }
-            catch ( ArtifactMetadataRetrievalException e )
-            {
-                throw new ExtensionManagerException( "Unable to download metadata from repository for extension artifact '" +
-                    extensionArtifact.getId() + "': " + e.getMessage(), extensionArtifact, projectId, e );
-            }
-
-            // We use the same hack here to make sure that plexus 1.1 is available for extensions that do
-            // not declare plexus-utils but need it. MNG-2900
-//            DefaultPluginManager.checkPlexusUtils( resolutionGroup, artifactFactory );
-
-            Set dependencies = new LinkedHashSet();
-
-            dependencies.add( extensionArtifact );
-            dependencies.addAll( resolutionGroup.getArtifacts() );
-
-            ArtifactResolutionRequest dependencyReq = new ArtifactResolutionRequest().setArtifact( projectArtifact )
-                                                                           .setArtifactDependencies( dependencies )
-                                                                           .setFilter( filter )
-                                                                           .setLocalRepository( localRepository )
-                                                                           .setRemoteRepostories( remoteRepositories )
-                                                                           .setMetadataSource( artifactMetadataSource );
-
-            // TODO: Make this work with managed dependencies, or an analogous management section in the POM.
-            ArtifactResolutionResult result = artifactResolver.resolve( dependencyReq );
-
-            if ( result.hasCircularDependencyExceptions() || result.hasErrorArtifactExceptions()
-                 || result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() )
-            {
-                throw new ExtensionManagerException( "Failed to resolve extension: " + extensionArtifact, extensionArtifact, projectId, result );
-            }
-
-            Set resultArtifacts = result.getArtifacts();
-
-            if ( !extensionArtifact.isResolved() || ( extensionArtifact.getFile() == null ) )
-            {
-                throw new ExtensionManagerException( "Extension artifact was not resolved, or has no file associated with it.", extensionArtifact, projectId );
-            }
-
-            ClassRealm extensionRealm;
-            try
-            {
-                extensionRealm = container.getContainerRealm().createChildRealm( realmId );
-            }
-            catch ( DuplicateRealmException e )
-            {
-                throw new ExtensionManagerException( "Unable to create extension ClassRealm for extension: " + extensionArtifact.getId() + " within session for project: " + projectId, extensionArtifact, projectId, e );
-            }
-
-            for ( Iterator i = resultArtifacts.iterator(); i.hasNext(); )
-            {
-                Artifact a = (Artifact) i.next();
-
-                if ( activeArtifactResolver != null )
-                {
-                    a = activeArtifactResolver.replaceWithActiveArtifact( a );
-                }
-
-                getLogger().debug( "Adding to extension classpath: " + a.getFile() + " in classRealm: " + extensionRealm.getId() );
+                ArtifactRepository localRepository = request.getLocalRepository();
-                    extensionRealm.addURL( a.getFile().toURL() );
+                    resolutionGroup = artifactMetadataSource.retrieve( extensionArtifact, localRepository, remoteRepositories );
-                catch ( MalformedURLException e )
+                catch ( ArtifactMetadataRetrievalException e )
-                    throw new ExtensionManagerException( "Unable to generate URL from extension artifact file: " + a.getFile(), extensionArtifact, projectId, e );
+                    throw new ExtensionManagerException( "Unable to download metadata from repository for extension artifact '" +
+                        extensionArtifact.getId() + "': " + e.getMessage(), extensionArtifact, projectGroupId, projectArtifactId, projectVersion, e );
-            }
-            importLocalExtensionComponents( extensionRealm, projectId, extensionArtifact );
-        }
-    }
+                // We use the same hack here to make sure that plexus 1.1 is available for extensions that do
+                // not declare plexus-utils but need it. MNG-2900
+//                DefaultPluginManager.checkPlexusUtils( resolutionGroup, artifactFactory );
-    private void importLocalExtensionComponents( ClassRealm extensionRealm,
-                                                 String projectId,
-                                                 Artifact extensionArtifact )
-        throws ExtensionManagerException
-    {
-        ClassWorld discoveryWorld = new ClassWorld();
-        try
-        {
-            // Create an entire new ClassWorld, ClassRealm for discovering
-            // the immediate components of the extension artifact, so we don't pollute the
-            // container with component descriptors or realms that don't have any meaning beyond discovery.
-            ClassRealm discoveryRealm = new ClassRealm( discoveryWorld, "discovery", Thread.currentThread().getContextClassLoader() );
-            try
-            {
-                discoveryRealm.addURL( extensionArtifact.getFile().toURL() );
-            }
-            catch ( MalformedURLException e )
-            {
-                throw new ExtensionManagerException( "Unable to generate URL from extension artifact for local-component discovery: " + extensionArtifact.getFile(), extensionArtifact, projectId, e );
-            }
+                Set dependencies = new LinkedHashSet();
-            ComponentDiscoverer discoverer = new DefaultComponentDiscoverer();
-            discoverer.setManager( new DummyDiscovererManager() );
+                dependencies.add( extensionArtifact );
+                dependencies.addAll( resolutionGroup.getArtifacts() );
-            ClassRealm realm = container.getContainerRealm();
-            try
-            {
-                // Find the extension component descriptors that exist ONLY in the immediate extension
-                // artifact...this prevents us from adding plexus-archiver components to the mix, for instance,
-                // when the extension uses that dependency.
-                List componentSetDescriptors = discoverer.findComponents( container.getContext(), discoveryRealm );
-                for ( Iterator it = componentSetDescriptors.iterator(); it.hasNext(); )
+                ArtifactResolutionRequest dependencyReq = new ArtifactResolutionRequest().setArtifact( projectArtifact )
+                                                                               .setArtifactDependencies( dependencies )
+                                                                               .setFilter( filter )
+                                                                               .setLocalRepository( localRepository )
+                                                                               .setRemoteRepostories( remoteRepositories )
+                                                                               .setMetadataSource( artifactMetadataSource );
+
+                // TODO: Make this work with managed dependencies, or an analogous management section in the POM.
+                ArtifactResolutionResult result = artifactResolver.resolve( dependencyReq );
+
+                if ( result.hasCircularDependencyExceptions() || result.hasErrorArtifactExceptions()
+                     || result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() )
-                    ComponentSetDescriptor compSet = (ComponentSetDescriptor) it.next();
-                    for ( Iterator compIt = compSet.getComponents().iterator(); compIt.hasNext(); )
+                    throw new ExtensionManagerException( "Failed to resolve extension: " + extensionArtifact, extensionArtifact, projectGroupId, projectArtifactId, projectVersion, result );
+                }
+
+                Set resultArtifacts = new LinkedHashSet();
+                for ( Iterator iterator = result.getArtifacts().iterator(); iterator.hasNext(); )
+                {
+                    Artifact a = (Artifact) iterator.next();
+
+
+                    if ( activeArtifactResolver != null )
-                        // For each component in the extension artifact:
-                        ComponentDescriptor comp = (ComponentDescriptor) compIt.next();
-                        String implementation = comp.getImplementation();
-
-                        try
-                        {
-                            getLogger().debug( "Importing: " + implementation + "\nwith role: " + comp.getRole() + "\nand hint: " + comp.getRoleHint() + "\nfrom extension realm: " + extensionRealm.getId() + "\nto container realm: " + realm.getId() );
-
-                            // Import the extension component's implementation class into the project-level
-                            // realm.
-                            realm.importFrom( extensionRealm.getId(), implementation );
-
-                            // Set the realmId to be used in looking up this extension component to the
-                            // project-level realm, since we now have a restricted import
-                            // that allows most of the extension to stay hidden, and the
-                            // specific local extension components are still accessible
-                            // from the project-level realm.
-                            comp.setRealmId( realm.getId() );
-
-                            // Finally, add the extension component's descriptor (with projectRealm
-                            // set as the lookup realm) to the container.
-                            container.addComponentDescriptor( comp );
-                        }
-                        catch ( NoSuchRealmException e )
-                        {
-                            throw new ExtensionManagerException( "Failed to create import for component: " + implementation + " from extension realm: " + extensionRealm.getId() + " to project realm: " + realm.getId(), extensionArtifact, projectId, e );
-                        }
+                        a = activeArtifactResolver.replaceWithActiveArtifact( a );
+
+                    getLogger().debug( "Adding: " + a.getFile() + " to classpath for extension: " + extensionArtifact.getId() );
+                    resultArtifacts.add( a );
-            }
-            catch ( PlexusConfigurationException e )
-            {
-                throw new ExtensionManagerException( "Unable to discover extension components.", extensionArtifact, projectId, e );
-            }
-            catch ( ComponentRepositoryException e )
-            {
-                throw new ExtensionManagerException( "Unable to discover extension components from imports added to project-session realm.", extensionArtifact, projectId, e );
-            }
-        }
-        finally
-        {
-            Collection realms = discoveryWorld.getRealms();
-            for ( Iterator it = realms.iterator(); it.hasNext(); )
-            {
-                ClassRealm realm = (ClassRealm) it.next();
+
+                // TODO: This shouldn't be required, now that we're checking the core filter before getting here.
+                if ( !extensionArtifact.isResolved() || ( extensionArtifact.getFile() == null ) )
+                {
+                    throw new ExtensionManagerException( "Extension artifact was not resolved, or has no file associated with it.", extensionArtifact, projectGroupId, projectArtifactId, projectVersion );
+                }
+
-                    discoveryWorld.disposeRealm( realm.getId() );
+                    realmManager.createExtensionRealm( extensionArtifact, resultArtifacts );
-                catch ( NoSuchRealmException e )
+                catch ( RealmManagementException e )
+                    String projectId = RealmUtils.createProjectId( projectGroupId, projectArtifactId, projectVersion );
+                    throw new ExtensionManagerException( "Unable to create extension ClassRealm for extension: " + extensionArtifact.getId() + " within session for project: " + projectId, extensionArtifact, projectGroupId, projectArtifactId, projectVersion, e );
+
+            try
+            {
+                realmManager.importExtensionsIntoProjectRealm( projectGroupId, projectArtifactId, projectVersion, extensionArtifact );
+            }
+            catch ( RealmManagementException e )
+            {
+                throw new ExtensionManagerException( "Unable to import extension components into project realm.", extensionArtifact, projectGroupId, projectArtifactId, projectVersion, e );
+            }
-
-    private static final class DummyDiscovererManager implements ComponentDiscovererManager
-    {
-
-        public void fireComponentDiscoveryEvent( ComponentDiscoveryEvent arg0 )
-        {
-        }
-
-        public List getComponentDiscoverers()
-        {
-            return null;
-        }
-
-        public Map getComponentDiscoveryListeners()
-        {
-            return null;
-        }
-
-        public List getListeners()
-        {
-            return null;
-        }
-
-        public void initialize()
-        {
-        }
-
-        public void registerComponentDiscoveryListener( ComponentDiscoveryListener arg0 )
-        {
-        }
-
-        public void removeComponentDiscoveryListener( ComponentDiscoveryListener arg0 )
-        {
-        }
-
-    }

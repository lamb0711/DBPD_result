o Enabled request tracing for repository events to provide more context for event spies

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@1074195 13f79535-47bb-0310-9956-ffa450edef68

+import org.sonatype.aether.RequestTrace;
+import org.sonatype.aether.SyncContext;
+import org.sonatype.aether.util.DefaultRequestTrace;
+import org.sonatype.aether.impl.SyncContextFactory;
+    @SuppressWarnings( "unused" )
+    @Requirement
+    private SyncContextFactory syncContextFactory;
+
+        setSyncContextFactory( locator.getService( SyncContextFactory.class ) );
+    public DefaultVersionResolver setSyncContextFactory( SyncContextFactory syncContextFactory )
+    {
+        if ( syncContextFactory == null )
+        {
+            throw new IllegalArgumentException( "sync context factory has not been specified" );
+        }
+        this.syncContextFactory = syncContextFactory;
+        return this;
+    }
+
+        RequestTrace trace = DefaultRequestTrace.newChild( request.getTrace(), request );
+
+                metadataRequest.setTrace( trace );
-                Versioning versioning = readVersions( session, metadataResult.getMetadata(), repository, result );
+                Versioning versioning = readVersions( session, trace, metadataResult.getMetadata(), repository, result );
-    private Versioning readVersions( RepositorySystemSession session, Metadata metadata, ArtifactRepository repository,
-                                     VersionResult result )
+    private Versioning readVersions( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
+                                     ArtifactRepository repository, VersionResult result )
-            if ( metadata != null && metadata.getFile() != null && metadata.getFile().exists() )
+            if ( metadata != null )
-                fis = new FileInputStream( metadata.getFile() );
-                org.apache.maven.artifact.repository.metadata.Metadata m = new MetadataXpp3Reader().read( fis, false );
-                versioning = m.getVersioning();
+                SyncContext syncContext = syncContextFactory.newInstance( session, true );
-                /*
-                 * NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata of the
-                 * local repository. This is especially troublesome during snapshot resolution so we try to handle that
-                 * gracefully.
-                 */
-                if ( versioning != null && repository instanceof LocalRepository )
+                try
-                    if ( versioning.getSnapshot() != null && versioning.getSnapshot().getBuildNumber() > 0 )
-                    {
-                        Versioning repaired = new Versioning();
-                        repaired.setLastUpdated( versioning.getLastUpdated() );
-                        Snapshot snapshot = new Snapshot();
-                        snapshot.setLocalCopy( true );
-                        repaired.setSnapshot( snapshot );
-                        versioning = repaired;
+                    syncContext.acquire( null, Collections.singleton( metadata ) );
-                        throw new IOException( "Snapshot information corrupted with remote repository data"
-                            + ", please verify that no remote repository uses the id '" + repository.getId() + "'" );
+                    if ( metadata.getFile() != null && metadata.getFile().exists() )
+                    {
+                        fis = new FileInputStream( metadata.getFile() );
+                        org.apache.maven.artifact.repository.metadata.Metadata m =
+                            new MetadataXpp3Reader().read( fis, false );
+                        versioning = m.getVersioning();
+
+                        /*
+                         * NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata
+                         * of the local repository. This is especially troublesome during snapshot resolution so we try
+                         * to handle that gracefully.
+                         */
+                        if ( versioning != null && repository instanceof LocalRepository )
+                        {
+                            if ( versioning.getSnapshot() != null && versioning.getSnapshot().getBuildNumber() > 0 )
+                            {
+                                Versioning repaired = new Versioning();
+                                repaired.setLastUpdated( versioning.getLastUpdated() );
+                                Snapshot snapshot = new Snapshot();
+                                snapshot.setLocalCopy( true );
+                                repaired.setSnapshot( snapshot );
+                                versioning = repaired;
+
+                                throw new IOException( "Snapshot information corrupted with remote repository data"
+                                    + ", please verify that no remote repository uses the id '" + repository.getId()
+                                    + "'" );
+                            }
+                        }
+                finally
+                {
+                    syncContext.release();
+                }
-            invalidMetadata( session, metadata, repository, e );
+            invalidMetadata( session, trace, metadata, repository, e );
-    private void invalidMetadata( RepositorySystemSession session, Metadata metadata, ArtifactRepository repository,
-                                  Exception exception )
+    private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
+                                  ArtifactRepository repository, Exception exception )
-            DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session );
+            DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace );

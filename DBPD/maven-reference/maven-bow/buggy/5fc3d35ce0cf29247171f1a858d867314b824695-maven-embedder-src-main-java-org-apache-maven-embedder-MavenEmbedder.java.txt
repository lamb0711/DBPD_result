Removing maven-build-context, and replacing it with caching aspects for model-lineage stuff and project instances. Still needs caching for artifact resolution, and I have an aspect for this too, but it's not enabled yet, since it's still buggy.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@595215 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.maven.context.BuildContextManager;
-    private BuildContextManager buildContextManager;
-
-        try
-        {
-            return readProject( mavenProject, request );
-        }
-        finally
-        {
-            buildContextManager.clearBuildContext();
-            request.getRealmManager().clear();
-        }
+        return readProject( mavenProject, request );
-            try
-            {
-                request = populator.populateDefaults( request, configuration );
+            request = populator.populateDefaults( request, configuration );
-                // This is necessary to make the MavenEmbedderProjectWithExtensionReadingTest work which uses
-                // a custom type for a dependency like this:
-                //
-                // <dependency>
-                //   <groupId>junit</groupId>
-                //   <artifactId>junit</artifactId>
-                //   <version>3.8.1</version>
-                //   <scope>test</scope>
-                //   <type>mkleint</type>
-                // </dependency>
-                //
-                // If the artifact handlers are not loaded up-front then this dependency element is not
-                // registered as an artifact and is not added to the classpath elements.
-
-                MavenProject project = readProject( request.getPom(), request );
-
-//                Map handlers = findArtifactTypeHandlers( project );
-
-                //TODO: ok this is crappy, now there are active collections so when new artifact handlers
-                // enter the system they should be available.
-
-//                artifactHandlerManager.addHandlers( handlers );
-            }
-            catch ( MavenEmbedderException e )
-            {
-                return result.addUnknownException( e );
-            }
-            catch ( ProjectBuildingException e )
-            {
-                return result.addProjectBuildingException( e );
-            }
-            catch ( ExtensionScanningException e )
-            {
-                return result.addExtensionScanningException( e );
-            }
-
-            ReactorManager reactorManager = maven.createReactorManager( request, result );
-
-            if ( result.hasExceptions() )
-            {
-                return result;
-            }
-
-            MavenProjectBuildingResult projectBuildingResult;
-
-            try
-            {
-                projectBuildingResult = mavenProjectBuilder.buildWithDependencies(
-                    request.getPom(),
-                    request.getLocalRepository(),
-                    request.getProfileManager() );
-            }
-            catch ( ProjectBuildingException e )
-            {
-                return result.addProjectBuildingException( e );
-            }
-
-            if ( reactorManager.hasMultipleProjects() )
-            {
-                result.setProject( projectBuildingResult.getProject() );
-
-                result.setTopologicallySortedProjects( reactorManager.getSortedProjects() );
-            }
-            else
-            {
-                result.setProject( projectBuildingResult.getProject() );
-
-                result.setTopologicallySortedProjects( Arrays.asList( new MavenProject[]{ projectBuildingResult.getProject()} ) );
-            }
-
-            result.setArtifactResolutionResult( projectBuildingResult.getArtifactResolutionResult() );
-
-            // From this I could produce something that would help IDE integrators create importers:
-            // - topo sorted list of projects
-            // - binary dependencies
-            // - source dependencies (projects in the reactor)
+            // This is necessary to make the MavenEmbedderProjectWithExtensionReadingTest work which uses
+            // a custom type for a dependency like this:
-            // We could create a layer approach here. As to do anything you must resolve a projects artifacts,
-            // and with that set you could then subsequently execute goals for each of those project.
+            // <dependency>
+            //   <groupId>junit</groupId>
+            //   <artifactId>junit</artifactId>
+            //   <version>3.8.1</version>
+            //   <scope>test</scope>
+            //   <type>mkleint</type>
+            // </dependency>
+            //
+            // If the artifact handlers are not loaded up-front then this dependency element is not
+            // registered as an artifact and is not added to the classpath elements.
+            readProject( request.getPom(), request );
+
+//            Map handlers = findArtifactTypeHandlers( project );
+
+            //TODO: ok this is crappy, now there are active collections so when new artifact handlers
+            // enter the system they should be available.
+
+//            artifactHandlerManager.addHandlers( handlers );
+        }
+        catch ( MavenEmbedderException e )
+        {
+            return result.addUnknownException( e );
+        }
+        catch ( ProjectBuildingException e )
+        {
+            return result.addProjectBuildingException( e );
+        }
+        catch ( ExtensionScanningException e )
+        {
+            return result.addExtensionScanningException( e );
+        }
+
+        ReactorManager reactorManager = maven.createReactorManager( request, result );
+
+        if ( result.hasExceptions() )
+        {
-        finally
+
+        MavenProjectBuildingResult projectBuildingResult;
+
+        try
-            buildContextManager.clearBuildContext();
-            request.getRealmManager().clear();
+            projectBuildingResult = mavenProjectBuilder.buildWithDependencies(
+                request.getPom(),
+                request.getLocalRepository(),
+                request.getProfileManager() );
+        catch ( ProjectBuildingException e )
+        {
+            return result.addProjectBuildingException( e );
+        }
+
+        if ( reactorManager.hasMultipleProjects() )
+        {
+            result.setProject( projectBuildingResult.getProject() );
+
+            result.setTopologicallySortedProjects( reactorManager.getSortedProjects() );
+        }
+        else
+        {
+            result.setProject( projectBuildingResult.getProject() );
+
+            result.setTopologicallySortedProjects( Arrays.asList( new MavenProject[]{ projectBuildingResult.getProject()} ) );
+        }
+
+        result.setArtifactResolutionResult( projectBuildingResult.getArtifactResolutionResult() );
+
+        // From this I could produce something that would help IDE integrators create importers:
+        // - topo sorted list of projects
+        // - binary dependencies
+        // - source dependencies (projects in the reactor)
+        //
+        // We could create a layer approach here. As to do anything you must resolve a projects artifacts,
+        // and with that set you could then subsequently execute goals for each of those project.
+
+        return result;
-        try
-        {
-            artifactResolver.resolve( artifact, remoteRepositories, localRepository );
-        }
-        finally
-        {
-            buildContextManager.clearBuildContext();
-        }
+        artifactResolver.resolve( artifact, remoteRepositories, localRepository );
-            buildContextManager = (BuildContextManager) container.lookup( BuildContextManager.ROLE );
-
-        buildContextManager.clearBuildContext();
-
-
-            buildContextManager.clearBuildContext();
-            request.getRealmManager().clear();

o Restored lifecycle forking

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@799310 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.plugin.lifecycle.Execution;
+import org.apache.maven.plugin.lifecycle.Phase;
-        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginManagerException
+        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
+        CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException,
+        InvalidPluginDescriptorException, PluginManagerException, LifecyclePhaseNotFoundException,
+        LifecycleNotFoundException
-            calculateForkedExecutions( mojoExecution, project, new HashSet<MojoDescriptor>() );
+            calculateForkedExecutions( mojoExecution, session, project, new HashSet<MojoDescriptor>() );
-    private void calculateExecutionForLifecyclePhase( MavenSession session, List<MojoExecution> lifecyclePlan, String lifecyclePhase ) 
-        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException        
-    {        
-        MavenProject project = session.getCurrentProject();
-        
-        // 1.
-        //
-        // Based on the lifecycle phase we are given, let's find the corresponding lifecycle.
-        //
+    private void calculateExecutionForLifecyclePhase( MavenSession session, List<MojoExecution> lifecyclePlan,
+                                                      String lifecyclePhase )
+        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
+        CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException,
+        InvalidPluginDescriptorException, LifecyclePhaseNotFoundException
+    {
+        Map<String, List<MojoExecution>> phaseToMojoMapping = calculateLifecycleMappings( session, lifecyclePhase );
+
+        for ( List<MojoExecution> mojoExecutions : phaseToMojoMapping.values() )
+        {
+            lifecyclePlan.addAll( mojoExecutions );
+        }
+    }
+
+    private Map<String, List<MojoExecution>> calculateLifecycleMappings( MavenSession session, String lifecyclePhase )
+        throws LifecyclePhaseNotFoundException, PluginNotFoundException, PluginResolutionException,
+        PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException,
+        InvalidPluginDescriptorException
+    {
+        /*
+         * Determine the lifecycle that corresponds to the given phase.
+         */
+
-        // 2. 
-        //
-        // If we are dealing with the "clean" or "site" lifecycle then there are currently no lifecycle mappings but there are default phases
-        // that need to be run instead.
-        //
-        // Now we need to take into account the packaging type of the project. For a project of type WAR, the lifecycle where mojos are mapped
-        // on to the given phases in the lifecycle are going to be a little different then, say, a project of type JAR.
-        //
-
-        // 3.
-        //
-        // Once we have the lifecycle mapping for the given packaging, we need to know whats phases we need to worry about executing.
-        //
-
-        // Create an ordered Map of the phases in the lifecycle to a list of mojos to execute.
-        Map<String, List<MojoExecution>> phaseToMojoMapping = new LinkedHashMap<String, List<MojoExecution>>();
-
-        // 4.
-
-        //TODO: need to separate the lifecycles
-
-            logger.info( "Invalid task '"
-                + lifecyclePhase
-                + "' : you must specify a valid lifecycle phase, or a goal in the format plugin:goal or pluginGroupId:pluginArtifactId:pluginVersion:goal" );
-            throw new MojoNotFoundException( lifecyclePhase, null );
+            logger.info( "Invalid task '" + lifecyclePhase + "' : you must specify a valid lifecycle phase"
+                + ", or a goal in the format <plugin-prefix>:<goal> or"
+                + " <plugin-group-id>:<plugin-artifact-id>:<plugin-version>:<goal>" );
+            throw new LifecyclePhaseNotFoundException( lifecyclePhase );
-        
+
+        /*
+         * Initialize mapping from lifecycle phase to bound mojos. The key set of this map denotes the phases the caller
+         * is interested in, i.e. all phases up to and including the specified phase.
+         */
+
+        Map<String, List<MojoExecution>> lifecycleMappings = new LinkedHashMap<String, List<MojoExecution>>();
+
-            List<MojoExecution> mojos = new ArrayList<MojoExecution>();
+            List<MojoExecution> mojoExecutions = new ArrayList<MojoExecution>();
-            //TODO: remove hard coding
+            // TODO: remove hard coding
-                mojos.add( new MojoExecution( plugin, "clean", "default-clean" ) );                
+                mojoExecutions.add( new MojoExecution( plugin, "clean", "default-clean" ) );
-            // This is just just laying out the initial structure of the mojos to run in each phase of the
-            // lifecycle. Everything is now done in the project builder correctly so this could likely
-            // go away shortly. We no longer need to pull out bits from the default lifecycle. The MavenProject
-            // comes to us intact as it should.
+            lifecycleMappings.put( phase, mojoExecutions );
-            phaseToMojoMapping.put( phase, mojos );
+            if ( phase.equals( lifecyclePhase ) )
+            {
+                break;
+            }
-        // 5. Just build up the list of mojos that will execute for every phase.
-        //
-        // This will be useful for having the complete build plan and then we can filter/optimize later.
-        //
+        /*
+         * Grab plugin executions that are bound to the selected lifecycle phases from project. The effective model of
+         * the project already contains the plugin executions induced by the project's packaging type. Remember, all
+         * phases of interest and only those are in the lifecyle mapping, if a phase has no value in the map, we are not
+         * interested in any of the executions bound to it.
+         */
+
+        MavenProject project = session.getCurrentProject();
+
-                // to examine the phase it is associated to.                
+                // to examine the phase it is associated to.
-                    for ( String goal : execution.getGoals() )
+                    List<MojoExecution> mojoExecutions = lifecycleMappings.get( execution.getPhase() );
+                    if ( mojoExecutions != null )
-                        if ( phaseToMojoMapping.get( execution.getPhase() ) == null )
+                        for ( String goal : execution.getGoals() )
-                            // This is happening because executions in the POM are getting mixed into the clean lifecycle
-                            // So for the lifecycle mapping we need a map with the phases as keys so we can easily check
-                            // if this phase belongs to the given lifecycle. this shows the system is messed up. this
-                            // shouldn't happen.
-                            phaseToMojoMapping.put( execution.getPhase(), new ArrayList<MojoExecution>() );
+                            MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
+                            mojoExecutions.add( mojoExecution );
-
-                        MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
-                        phaseToMojoMapping.get( execution.getPhase() ).add( mojoExecution );
-                        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), project.getPluginArtifactRepositories() );
+                        MojoDescriptor mojoDescriptor =
+                            pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(),
+                                                             project.getPluginArtifactRepositories() );
-                        if ( mojoDescriptor.getPhase() != null && phaseToMojoMapping.get( mojoDescriptor.getPhase() ) != null )
+                        List<MojoExecution> mojoExecutions = lifecycleMappings.get( mojoDescriptor.getPhase() );
+                        if ( mojoExecutions != null )
-                            phaseToMojoMapping.get( mojoDescriptor.getPhase() ).add( mojoExecution );
+                            mojoExecutions.add( mojoExecution );
-        // 6. 
-        //
-        // We are only interested in the phases that correspond to the lifecycle we are trying to run. If we are running the "clean"
-        // lifecycle we are not interested in goals -- like "generate-sources -- that belong to the default lifecycle.
-        //        
-        for ( String phase : phaseToMojoMapping.keySet() )
-        {
-            lifecyclePlan.addAll( phaseToMojoMapping.get( phase ) );
+        return lifecycleMappings;
+    }
-            if ( phase.equals( lifecyclePhase ) )
-            {
-                break;
-            }
-        }
-    }   
-
-    private void calculateForkedExecutions( MojoExecution mojoExecution, MavenProject project,
+    private void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session, MavenProject project,
-        throws MojoNotFoundException
+        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
+        PluginDescriptorParsingException, CycleDetectedInPluginGraphException, NoPluginFoundForPrefixException,
+        InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
-            // TODO
+            String forkedPhase = mojoDescriptor.getExecutePhase();
+            Map<String, List<MojoExecution>> lifecycleMappings = calculateLifecycleMappings( session, forkedPhase );
+
+            for ( List<MojoExecution> forkedExecutions : lifecycleMappings.values() )
+            {
+                for ( MojoExecution forkedExecution : forkedExecutions )
+                {
+                    if ( forkedExecution.getMojoDescriptor() == null )
+                    {
+                        MojoDescriptor forkedMojoDescriptor =
+                            pluginManager.getMojoDescriptor( forkedExecution.getPlugin(), forkedExecution.getGoal(),
+                                                             session.getLocalRepository(),
+                                                             project.getPluginArtifactRepositories() );
+
+                        forkedExecution.setMojoDescriptor( forkedMojoDescriptor );
+                    }
+
+                    populateMojoExecutionConfiguration( project, forkedExecution, false );
+                }
+            }
+
+            String forkedLifecycle = mojoDescriptor.getExecuteLifecycle();
+
+            if ( StringUtils.isNotEmpty( forkedLifecycle ) )
+            {
+                org.apache.maven.plugin.lifecycle.Lifecycle lifecycleOverlay;
+
+                try
+                {
+                    lifecycleOverlay = pluginDescriptor.getLifecycleMapping( forkedLifecycle );
+                }
+                catch ( IOException e )
+                {
+                    throw new PluginDescriptorParsingException( pluginDescriptor.getPlugin(), e );
+                }
+                catch ( XmlPullParserException e )
+                {
+                    throw new PluginDescriptorParsingException( pluginDescriptor.getPlugin(), e );
+                }
+
+                if ( lifecycleOverlay == null )
+                {
+                    throw new LifecycleNotFoundException( forkedLifecycle );
+                }
+
+                for ( Phase phase : lifecycleOverlay.getPhases() )
+                {
+                    List<MojoExecution> forkedExecutions = lifecycleMappings.get( phase.getId() );
+                    if ( forkedExecutions != null )
+                    {
+                        for ( Execution execution : phase.getExecutions() )
+                        {
+                            for ( String goal : execution.getGoals() )
+                            {
+                                MojoDescriptor forkedMojoDescriptor;
+
+                                if ( goal.indexOf( ':' ) < 0 )
+                                {
+                                    forkedMojoDescriptor = pluginDescriptor.getMojo( goal );
+                                    if ( forkedMojoDescriptor == null )
+                                    {
+                                        throw new MojoNotFoundException( goal, pluginDescriptor );
+                                    }
+                                }
+                                else
+                                {
+                                    forkedMojoDescriptor = getMojoDescriptor( goal, session );
+                                }
+
+                                MojoExecution forkedExecution =
+                                    new MojoExecution( forkedMojoDescriptor, mojoExecution.getExecutionId() );
+
+                                Xpp3Dom forkedConfiguration = (Xpp3Dom) execution.getConfiguration();
+
+                                forkedExecution.setConfiguration( forkedConfiguration );
+
+                                populateMojoExecutionConfiguration( project, forkedExecution, true );
+
+                                forkedExecutions.add( forkedExecution );
+                            }
+                        }
+
+                        Xpp3Dom phaseConfiguration = (Xpp3Dom) phase.getConfiguration();
+                        if ( phaseConfiguration != null )
+                        {
+                            for ( MojoExecution forkedExecution : forkedExecutions )
+                            {
+                                Xpp3Dom executionConfiguration = forkedExecution.getConfiguration();
+
+                                Xpp3Dom mergedConfiguration =
+                                    Xpp3Dom.mergeXpp3Dom( phaseConfiguration, executionConfiguration );
+
+                                forkedExecution.setConfiguration( mergedConfiguration );
+                            }
+                        }
+                    }
+                }
+            }
+
+            for ( List<MojoExecution> forkedExecutions : lifecycleMappings.values() )
+            {
+                for ( MojoExecution forkedExecution : forkedExecutions )
+                {
+                    calculateForkedExecutions( forkedExecution, session, project, alreadyForkedExecutions );
+
+                    mojoExecution.addForkedExecution( forkedExecution );
+                }
+            }
-            calculateForkedExecutions( forkedExecution, project, alreadyForkedExecutions );
+            calculateForkedExecutions( forkedExecution, session, project, alreadyForkedExecutions );
-        if ( plugin != null )
+        if ( plugin != null && StringUtils.isNotEmpty( mojoExecution.getExecutionId() ) )
-                    mojoExecution.setConfiguration( mojoConfiguration );
+                    Xpp3Dom mergedConfiguration =
+                        Xpp3Dom.mergeXpp3Dom( mojoExecution.getConfiguration(), mojoConfiguration );
+
+                    mojoExecution.setConfiguration( mergedConfiguration );
+            Xpp3Dom mojoDom = defaultDom;
+
-                mojoExecution.setConfiguration( Xpp3Dom.mergeXpp3Dom( projectDom, defaultDom, Boolean.TRUE ) );
+                mojoDom = Xpp3Dom.mergeXpp3Dom( projectDom, defaultDom, Boolean.TRUE );
-            else
-            {
-                mojoExecution.setConfiguration( defaultDom );
-            }
+
+            mojoDom = Xpp3Dom.mergeXpp3Dom( mojoExecution.getConfiguration(), mojoDom );
+
+            mojoExecution.setConfiguration( mojoDom );
-    }    
+    }
-        if ( numTokens == 2 )
+        else if ( numTokens == 2 )

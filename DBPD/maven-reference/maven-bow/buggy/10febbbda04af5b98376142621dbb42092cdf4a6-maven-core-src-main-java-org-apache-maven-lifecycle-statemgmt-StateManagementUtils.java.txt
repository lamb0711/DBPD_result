Replaced old build-plan mess with a single recursive plan instance that tracks direct invocation forks as well as lifecycle forks. All unit tests run, and I'm running integration tests now, to see if this fixes it0013.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@541938 13f79535-47bb-0310-9956-ffa450edef68

- * Constructs and matches MojoBinding instances that refer to the forked-execution context manager
- * mojos.
+ * Constructs and matches MojoBinding instances that refer to the forked-execution context manager mojos.
- *
+ * 
+    public static final String RESOLVE_LATE_BOUND_PLUGIN_GOAL = "resolve-late-bound-plugin";
+
-     * Create a new MojoBinding instance that refers to the internal mojo used to setup a new 
-     * forked-execution context. Also, set the configuration to contain the forkId for this new
-     * context.
+     * Create a new MojoBinding instance that refers to the internal mojo used to setup a new forked-execution context.
+     * Also, set the configuration to contain the forkId for this new context.
-        
+
-        
+
-        
+
-     * Create a new MojoBinding instance that refers to the internal mojo used to end a 
-     * forked-execution context. Also, set the configuration to contain the forkId for this new
-     * context.
+     * Create a new MojoBinding instance that refers to the internal mojo used to end a forked-execution context. Also,
+     * set the configuration to contain the forkId for this new context.
-        
+
-        
+
-     * Create a new MojoBinding instance that refers to the internal mojo used to cleanup a completed 
-     * forked-execution context. Also, set the configuration to contain the forkId for this new
-     * context.
+     * Create a new MojoBinding instance that refers to the internal mojo used to cleanup a completed forked-execution
+     * context. Also, set the configuration to contain the forkId for this new context.
-        
+
-        
+
-    
+
-     * Return true if the specified MojoBinding refers to the internal mojo used to setup a new
-     * forked-execution context. This is useful for formatting when listing the build plan, when
-     * expression of these actual mojo names isn't necessarily useful, and can be confusing.
+     * Return true if the specified MojoBinding refers to the internal mojo used to setup a new forked-execution
+     * context. This is useful for formatting when listing the build plan, when expression of these actual mojo names
+     * isn't necessarily useful, and can be confusing.
-    public static boolean isForkedExecutionStartMarker( MojoBinding binding )
+    public static boolean isForkedExecutionStartMarker( final MojoBinding binding )
-            && START_FORKED_EXECUTION_GOAL.equals( binding.getGoal() );
+                        && START_FORKED_EXECUTION_GOAL.equals( binding.getGoal() );
-     * Return true if the specified MojoBinding refers to the internal mojo used to end a
-     * forked-execution context. This is useful for formatting when listing the build plan, when
-     * expression of these actual mojo names isn't necessarily useful, and can be confusing.
+     * Return true if the specified MojoBinding refers to the internal mojo used to end a forked-execution context. This
+     * is useful for formatting when listing the build plan, when expression of these actual mojo names isn't
+     * necessarily useful, and can be confusing.
-    public static boolean isForkedExecutionEndMarker( MojoBinding binding )
+    public static boolean isForkedExecutionEndMarker( final MojoBinding binding )
-            && END_FORKED_EXECUTION_GOAL.equals( binding.getGoal() );
+                        && END_FORKED_EXECUTION_GOAL.equals( binding.getGoal() );
-     * forked-execution context. This is useful for formatting when listing the build plan, when
-     * expression of these actual mojo names isn't necessarily useful, and can be confusing.
+     * forked-execution context. This is useful for formatting when listing the build plan, when expression of these
+     * actual mojo names isn't necessarily useful, and can be confusing.
-    public static boolean isForkedExecutionClearMarker( MojoBinding binding )
+    public static boolean isForkedExecutionClearMarker( final MojoBinding binding )
-            && CLEAR_FORKED_EXECUTION_GOAL.equals( binding.getGoal() );
+                        && CLEAR_FORKED_EXECUTION_GOAL.equals( binding.getGoal() );
+    }
+
+    /**
+     * Create a new MojoBinding instance that refers to the internal mojo used to resolve a late-bound plugin just
+     * before it is to be used. Also, set the configuration to contain the parameters necessary for this resolution.
+     */
+    public static MojoBinding createResolveLateBoundMojoBinding( final MojoBinding lateBound )
+    {
+        MojoBinding binding = new MojoBinding();
+
+        binding.setGroupId( GROUP_ID );
+        binding.setArtifactId( ARTIFACT_ID );
+        binding.setVersion( VERSION );
+        binding.setGoal( RESOLVE_LATE_BOUND_PLUGIN_GOAL );
+        binding.setOrigin( ORIGIN );
+
+        Xpp3Dom config = new Xpp3Dom( "configuration" );
+        Xpp3Dom param = new Xpp3Dom( "groupId" );
+        param.setValue( lateBound.getGroupId() );
+
+        config.addChild( param );
+
+        param = new Xpp3Dom( "artifactId" );
+        param.setValue( lateBound.getArtifactId() );
+
+        config.addChild( param );
+
+        if ( lateBound.getVersion() != null )
+        {
+            param = new Xpp3Dom( "version" );
+            param.setValue( lateBound.getVersion() );
+
+            config.addChild( param );
+        }
+
+        param = new Xpp3Dom( "goal" );
+        param.setValue( lateBound.getGoal() );
+
+        config.addChild( param );
+
+        binding.setConfiguration( config );
+
+        return binding;
+    }
+
+    /**
+     * Return true if the specified MojoBinding refers to the internal mojo used to resolve a late-bound mojo. This is
+     * useful for formatting when listing the build plan, when expression of these actual mojo names isn't necessarily
+     * useful, and can be confusing.
+     */
+    public static boolean isResolveLateBoundMojoBinding( final MojoBinding binding )
+    {
+        return GROUP_ID.equals( binding.getGroupId() ) && ARTIFACT_ID.equals( binding.getArtifactId() )
+                        && RESOLVE_LATE_BOUND_PLUGIN_GOAL.equals( binding.getGoal() );

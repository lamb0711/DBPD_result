[MNG-4633] Reactor artifact resolution in weave mode

Resolves artifacts from within reactor build.
No longer requires artifacts to be present in local repository before building weave mode ;)

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@935334 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Collections;
+import java.util.HashSet;
-    private LifecycleDependencyResolver lifecycleDependencyResolver;
-
-    @Requirement
-    private final Map<MavenProject, MavenExecutionPlan> executionPlans =
-        Collections.synchronizedMap( new HashMap<MavenProject, MavenExecutionPlan>() );
+    private Map<MavenProject, MavenExecutionPlan> executionPlans = new HashMap<MavenProject, MavenExecutionPlan>( );
-    public LifecycleWeaveBuilder( MojoExecutor mojoExecutor, BuilderCommon builderCommon, Logger logger,
-                                  LifecycleDependencyResolver lifecycleDependencyResolver,
-                                  ExecutionEventCatapult eventCatapult )
+    public LifecycleWeaveBuilder(MojoExecutor mojoExecutor, BuilderCommon builderCommon, Logger logger,
+                                 ExecutionEventCatapult eventCatapult)
-                ThreadOutputMuxer muxer = null;  // new ThreadOutputMuxer( segmentChunks, System.out );
+                    ThreadOutputMuxer muxer = null;  // new ThreadOutputMuxer( segmentChunks, System.out );
+                Set<String> projectArtifacts = new HashSet<String>();
+                Set<Artifact> projectArtifactsA = new HashSet<Artifact>();
+                for (ProjectSegment segmentChunk : segmentChunks) {
+                    Artifact artifact = segmentChunk.getProject().getArtifact();
+                    if (artifact != null) {
+                        projectArtifacts.add( ArtifactUtils.key(artifact));
+                        projectArtifactsA.add( artifact);
+                    }
+                }
-                                                            projectBuild.getTaskSegment() );
+                                                            projectBuild.getTaskSegment(), projectArtifactsA );
+                        for (Artifact dependency : projectBuild.getProject().getDependencyArtifacts()) {
+                            String s = ArtifactUtils.key(dependency);
+                            if ( projectArtifacts.contains(s)){
+                                dependency.setFile( null);
+                                dependency.setResolved( false);
+                                dependency.setRepository( null);
+                            }
+                        }
+                        
-                    while ( current != null && !reactorBuildStatus.isHalted() &&
-                        !reactorBuildStatus.isBlackListed( projectBuild.getProject() ) )
+                    while (current != null && !reactorBuildStatus.isHaltedOrBlacklisted( projectBuild.getProject() ))
-                        if ( schedule != null && schedule.isMojoSynchronized() )
-                        {
-                            synchronized ( current.getPlugin() )
-                            {
-                                buildExecutionPlanItem( reactorContext, current, projectBuild, dependencyContext,
-                                                        phaseRecorder );
-                            }
-                        }
-                        else
-                        {
-                            buildExecutionPlanItem( reactorContext, current, projectBuild, dependencyContext,
-                                                    phaseRecorder );
-                        }
+                        buildExecutionPlanItem(current, phaseRecorder, schedule, reactorContext, projectBuild, dependencyContext);
-                            boolean mustReResolved = false;
-
-                                for ( MavenProject upstreamProject : projectBuild.getImmediateUpstreamProjects() )
-                                {
-                                    final MavenExecutionPlan upstreamPlan = executionPlans.get( upstreamProject );
-                                    final String nextPhase = nextPlanItem.getLifecyclePhase();
-                                    final ExecutionPlanItem inSchedule = upstreamPlan.findLastInPhase( nextPhase );
-
-                                    if ( inSchedule != null )
-                                    {
-                                        if ( upstreamPhaseModifiesArtifactResolutionState( inSchedule ) )
-                                        {
-                                            String key = ArtifactUtils.key( upstreamProject.getGroupId(),
-                                                                            upstreamProject.getArtifactId(),
-                                                                            upstreamProject.getVersion() );
-                                            final Set<Artifact> deps =
-                                                projectBuild.getProject().getDependencyArtifacts();
-                                            for ( Artifact dep : deps )
-                                            {
-                                                String depKey =
-                                                    ArtifactUtils.key( dep.getGroupId(), dep.getArtifactId(),
-                                                                       dep.getVersion() );
-                                                if ( key.equals( depKey ) )
-                                                {
-                                                    dep.setResolved( false );
-                                                    mustReResolved = true;
-                                                }
-                                            }
-                                        }
-                                        long startWait = System.currentTimeMillis();
-                                        inSchedule.waitUntilDone();
-                                        builtLogItem.addWait( upstreamProject, inSchedule, startWait );
-                                    }
-                                    else if ( !upstreamPlan.containsPhase( nextPhase ) )
-                                    {
-                                        // Still a bit of a kludge; if we cannot connect in a sensible way to
-                                        // the upstream build plan we just revert to waiting for it all to
-                                        // complete. Real problem is per-mojo phase->lifecycle mapping
-                                        builtLogItem.addDependency( upstreamProject, "No phase tracking possible " );
-                                        upstreamPlan.waitUntilAllDone();
-                                    }
-                                    else
-                                    {
-                                        builtLogItem.addDependency( upstreamProject, "No schedule" );
-                                    }
-                                }
+                                waitForAppropriateUpstreamExecutionsToFinish(builtLogItem, nextPlanItem, projectBuild);
-                            if ( mustReResolved )
-                            {
-                                lifecycleDependencyResolver.resolveDependencies( false, projectBuild.getProject(),
-                                                                                 projectBuild.getSession(),
-                                                                                 executionPlan );
-                            }
+                            reResolveReactorDependencies(nextPlanItem, projectBuild);
+
-    private boolean upstreamPhaseModifiesArtifactResolutionState( ExecutionPlanItem inSchedule )
-    {
-        final String phase = inSchedule.getLifecyclePhase();
-        return "install".equals( phase ) || "compile".equals( phase ) || "test-compile".equals( phase );
+    private void reResolveReactorDependencies(ExecutionPlanItem nextPlanItem, ProjectSegment projectBuild) {
+        if ( requiresReResolutionOfUpstreamReactorArtifacts( nextPlanItem ) )
+        {
+            reresolveUpstreamProjectArtifacts(projectBuild);
+        }
+        else if (requiresReResolutionOfUpstreamTestScopedReactorArtifacts( nextPlanItem))
+        {
+            reresolveUpstreamTestScopedArtifacts( projectBuild);
+        }
+    private void waitForAppropriateUpstreamExecutionsToFinish(BuildLogItem builtLogItem, ExecutionPlanItem nextPlanItem, ProjectSegment projectBuild) throws InterruptedException {
+        for ( MavenProject upstreamProject : projectBuild.getImmediateUpstreamProjects() )
+        {
+            final MavenExecutionPlan upstreamPlan = executionPlans.get( upstreamProject );
+            final String nextPhase = nextPlanItem.getLifecyclePhase();
+            final ExecutionPlanItem inSchedule = upstreamPlan.findLastInPhase( nextPhase );
+
+            if ( inSchedule != null )
+            {
+                long startWait = System.currentTimeMillis();
+                inSchedule.waitUntilDone();
+                builtLogItem.addWait( upstreamProject, inSchedule, startWait );
+            }
+            else if ( !upstreamPlan.containsPhase( nextPhase ) )
+            {
+                // Still a bit of a kludge; if we cannot connect in a sensible way to
+                // the upstream build plan we just revert to waiting for it all to
+                // complete. Real problem is per-mojo phase->lifecycle mapping
+                builtLogItem.addDependency( upstreamProject, "No phase tracking possible " );
+                upstreamPlan.waitUntilAllDone();
+            }
+            else
+            {
+                builtLogItem.addDependency( upstreamProject, "No schedule" );
+            }
+        }
+    }
+
+    private void reresolveUpstreamProjectArtifacts(ProjectSegment projectBuild) {
+        for ( MavenProject upstreamProject : projectBuild.getTransitiveUpstreamProjects() ){
+            Artifact upStreamArtifact = upstreamProject.getArtifact();
+            Artifact dependencyArtifact =  findDependency(projectBuild.getProject(), upStreamArtifact);
+            if (dependencyArtifact != null){
+                dependencyArtifact.setFile( upStreamArtifact.getFile());
+                dependencyArtifact.setResolved( true );
+                dependencyArtifact.setRepository( upStreamArtifact.getRepository());
+            }
+
+        }
+    }
+
+    private void reresolveUpstreamTestScopedArtifacts(ProjectSegment projectBuild) {
+        for ( MavenProject upstreamProject : projectBuild.getTransitiveUpstreamProjects() ){
+            Artifact upStreamArtifact = findTestScopedArtifact(upstreamProject);
+            Artifact dependencyArtifact =  findDependency(projectBuild.getProject(), upStreamArtifact);
+            if (dependencyArtifact != null){
+                dependencyArtifact.setFile( upStreamArtifact.getFile());
+                dependencyArtifact.setResolved( upStreamArtifact.isResolved());
+                dependencyArtifact.setRepository( upStreamArtifact.getRepository());
+            }
+
+        }
+    }
+
+    private Artifact findTestScopedArtifact(MavenProject upstreamProject) {
+        if ( upstreamProject == null){
+            return null;
+        }
+        
+        List<Artifact> artifactList = upstreamProject.getAttachedArtifacts();
+        for (Artifact artifact : artifactList) {
+            if (Artifact.SCOPE_TEST.equals( artifact.getScope())){
+                return artifact;
+            }
+        }
+        return null;
+    }
+
+    private static Artifact findDependency(MavenProject project, Artifact upStreamArtifact) {
+        if (upStreamArtifact == null){
+            return null;
+        }
+        
+        String key = ArtifactUtils.key( upStreamArtifact.getGroupId(),
+                                        upStreamArtifact.getArtifactId(),
+                                        upStreamArtifact.getVersion() );
+        final Set<Artifact> deps = project.getDependencyArtifacts();
+        for ( Artifact dep : deps )
+        {
+            String depKey = ArtifactUtils.key(dep.getGroupId(), dep.getArtifactId(), dep.getVersion());
+            if ( key.equals( depKey ) )
+            {
+                return dep;
+            }
+        }
+        return null;
+
+    }
+
+    private boolean requiresReResolutionOfUpstreamReactorArtifacts( ExecutionPlanItem nextExecutionPlanItem )
+    {
+        final String phase = nextExecutionPlanItem.getLifecyclePhase();
+        return "package".equals(phase) ||  "install".equals( phase ) || "compile".equals( phase );
+    }
+
+    private boolean requiresReResolutionOfUpstreamTestScopedReactorArtifacts( ExecutionPlanItem nextExecutionPlanItem )
+    {
+        final String phase = nextExecutionPlanItem.getLifecyclePhase();
+        return "package".equals(phase) || "install".equals( phase ) || "compile".equals( phase ) || "test-compile".equals( phase );
+    }
+
+    private void buildExecutionPlanItem(ExecutionPlanItem current, PhaseRecorder phaseRecorder, Schedule schedule, ReactorContext reactorContext, ProjectSegment projectBuild, DependencyContext dependencyContext) throws LifecycleExecutionException {
+        if ( schedule != null && schedule.isMojoSynchronized() )
+        {
+            synchronized ( current.getPlugin() )
+            {
+                buildExecutionPlanItem( reactorContext, current, projectBuild, dependencyContext,
+                                        phaseRecorder );
+            }
+        }
+        else
+        {
+            buildExecutionPlanItem( reactorContext, current, projectBuild, dependencyContext,
+                                    phaseRecorder );
+        }
+    }
+
+

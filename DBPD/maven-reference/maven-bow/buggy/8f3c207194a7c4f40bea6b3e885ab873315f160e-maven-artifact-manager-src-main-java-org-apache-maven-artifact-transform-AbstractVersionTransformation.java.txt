PR: MNG-613
changes versioning to use repository metadata

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@278881 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.maven.artifact.metadata.AbstractVersionArtifactMetadata;
-import org.apache.maven.artifact.metadata.VersionArtifactMetadata;
+import org.apache.maven.artifact.metadata.LegacyArtifactMetadata;
+import org.apache.maven.artifact.metadata.SnapshotArtifactMetadata;
+import org.apache.maven.artifact.repository.metadata.ArtifactRepositoryMetadata;
+import org.apache.maven.artifact.repository.metadata.Metadata;
+import org.apache.maven.artifact.repository.metadata.RepositoryMetadataManager;
+import org.apache.maven.artifact.repository.metadata.Snapshot;
+import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader;
+import org.codehaus.plexus.util.IOUtil;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.Reader;
+ * @todo try and refactor to remove abstract methods - not particular happy about current design
+    protected RepositoryMetadataManager repositoryMetadataManager;
+
-     * @todo very primitve. Probably we can cache artifacts themselves in a central location, as well as reset the flag over time in a long running process.
+     * @todo remove in beta-2 - used for legacy handling
-        ArtifactMetadata localMetadata = resolveMetadata( artifact, localRepository, remoteRepositories );
+        // TODO: can we improve on this?
+        ArtifactMetadata metadata = new ArtifactRepositoryMetadata( artifact );
-        String version;
+        repositoryMetadataManager.resolve( metadata, remoteRepositories, localRepository );
-        if ( localMetadata == null )
+/*
+        // TODO: can this go directly into the manager? At least share with DefaultPluginMappingManager
+        // TODO: use this, cache the output, select from that list instead of the next set
+        Versioning versioning = new Versioning();
+        for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
-            version = artifact.getVersion();
+            ArtifactRepository repository = (ArtifactRepository) i.next();
+
+            mergeVersioning( versioning, loadVersioningInformation( metadata, repository, localRepository ) );
-        else
+        mergeVersioning( versioning, loadVersioningInformation( metadata, localRepository, localRepository ) );
+
+        String version = selectVersion( versioning, artifact.getVersion() );
+*/
+        ArtifactRepositoryMetadata localMetadata = null;
+        for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
-            VersionArtifactMetadata versionMetadata = (VersionArtifactMetadata) localMetadata;
-            version = versionMetadata.constructVersion();
+            ArtifactRepository repository = (ArtifactRepository) i.next();
+
+            localMetadata = loadVersioningInformation( metadata, repository, localRepository, artifact );
+            if ( localMetadata != null )
+            {
+                artifact.setRepository( repository );
+                // TODO: merge instead (see above)
+                break;
+            }
+        }
+        ArtifactRepositoryMetadata m = loadVersioningInformation( metadata, localRepository, localRepository,
+                                                                  artifact );
+        if ( m != null )
+        {
+            localMetadata = m;
+            // TODO: figure out way to avoid duplicated message
+            if ( getLogger().isDebugEnabled() /*&& !alreadyResolved*/ )
+            {
+                // Locally installed file is newer, don't use the resolved version
+                getLogger().debug( artifact.getArtifactId() + ": using locally installed snapshot" );
+            }
+        }
+
+        String version = null;
+        if ( localMetadata != null )
+        {
+            version = constructVersion( localMetadata );
+        }
+
+        if ( version == null )
+        {
+            version = resolveLegacyVersion( artifact, localRepository, remoteRepositories );
+            if ( version == null )
+            {
+                version = artifact.getVersion();
+            }
-    /**
-     * @param artifact
-     * @param localRepository
-     * @param remoteRepositories
-     * @return
-     * @throws ArtifactMetadataRetrievalException
-     * @todo share with DefaultRepositoryMetadataManager
-     */
-    private ArtifactMetadata resolveMetadata( Artifact artifact, ArtifactRepository localRepository,
-                                              List remoteRepositories )
+    protected Snapshot resolveLatestSnapshotVersion( Artifact artifact, ArtifactRepository localRepository,
+                                                     ArtifactRepository remoteRepository )
-        getLogger().debug( "resolveMetaData(" + artifact.getId()+ "): repositories: " + remoteRepositories);
+        // TODO: can we improve on this?
+        ArtifactMetadata metadata = new ArtifactRepositoryMetadata( artifact );
-        VersionArtifactMetadata localMetadata;
-        try
+        repositoryMetadataManager.resolveAlways( metadata, localRepository, remoteRepository );
+
+        ArtifactRepositoryMetadata m = loadVersioningInformation( metadata, remoteRepository, localRepository,
+                                                                  artifact );
+        Snapshot snapshot;
+        if ( m == null )
-            localMetadata = readFromLocalRepository( artifact, localRepository );
+            snapshot = new Snapshot();
+
+            try
+            {
+                SnapshotArtifactMetadata snapshotMetadata = new SnapshotArtifactMetadata( artifact );
+                snapshotMetadata.retrieveFromRemoteRepository( remoteRepository, wagonManager,
+                                                               ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN );
+                getLogger().warn( "Using old-style versioning metadata from remote repo for " + artifact );
+
+                snapshot.setTimestamp( snapshotMetadata.getTimestamp() );
+                snapshot.setBuildNumber( snapshotMetadata.getBuildNumber() );
+            }
+            catch ( ResourceDoesNotExistException e1 )
+            {
+                // safe to ignore, use default snapshot data
+                getLogger().debug( "Unable to find legacy metadata - ignoring" );
+            }
-        catch ( IOException e )
+        else
-            throw new ArtifactMetadataRetrievalException( "Error reading local metadata", e );
+            snapshot = m.getSnapshot();
+        }
+        return snapshot;
+    }
+
+    protected abstract String constructVersion( ArtifactRepositoryMetadata metadata );
+
+/* TODO
+    private void mergeVersioning( Versioning dest, Versioning source )
+    {
+        // TODO: currently, it is first wins. We should probably compare the versions, or check timestamping?
+        // This could also let us choose the newer of the locally installed version and the remotely built version
+        if ( dest.getLatest() == null )
+        {
+            dest.setLatest( source.getLatest() );
+        }
+        if ( dest.getRelease() == null )
+        {
+            dest.setRelease( source.getRelease() );
+        }
+        if ( dest.getSnapshot() == null )
+        {
+            dest.setSnapshot( source.getSnapshot() );
+        }
+        for ( Iterator i = source.getVersions().iterator(); i.hasNext(); )
+        {
+            String version = (String) i.next();
+            if ( !dest.getVersions().contains( version ) )
+            {
+                dest.getVersions().add( version );
+            }
+        }
+    }
+*/
+
+    /**
+     * @todo remove in beta-2 - used for legacy handling
+     */
+    private String resolveLegacyVersion( Artifact artifact, ArtifactRepository localRepository,
+                                         List remoteRepositories )
+        throws ArtifactMetadataRetrievalException
+    {
+        LegacyArtifactMetadata localMetadata = createLegacyMetadata( artifact );
+        File f = new File( localRepository.getBasedir(),
+                           localRepository.pathOfLocalRepositoryMetadata( localMetadata, null ) );
+        if ( f.exists() )
+        {
+            try
+            {
+                localMetadata.readFromFile( f );
+            }
+            catch ( IOException e )
+            {
+                throw new ArtifactMetadataRetrievalException( "Error reading local metadata", e );
+            }
-                if ( policy == null || !policy.isEnabled() )
+                if ( !policy.isEnabled() )
-                    // TODO: should be able to calculate this less often
-                        getLogger().info(
-                            artifact.getId() + ": checking for updates from " + repository.getId() +
-                            " (" + repository.getUrl() + ")" );
-
-                        VersionArtifactMetadata remoteMetadata;
+                        LegacyArtifactMetadata remoteMetadata;
-                            remoteMetadata = retrieveFromRemoteRepository( artifact, repository, localMetadata,
-                                                                           policy.getChecksumPolicy() );
+                            remoteMetadata = createLegacyMetadata( artifact );
+
+                            remoteMetadata.retrieveFromRemoteRepository( repository, wagonManager,
+                                                                         policy.getChecksumPolicy() );
+
+                            getLogger().warn( "Using old-style versioning metadata from remote repo for " + artifact );
+
+                            int difference = remoteMetadata.compareTo( localMetadata );
+                            if ( difference > 0 )
+                            {
+                                // remote is newer
+                                artifact.setRepository( repository );
+
+                                localMetadata = remoteMetadata;
+                            }
-                            getLogger().debug( "resolveMetaData: Artifact version metadata for: " +
-                                artifact.getId() + " could not be found on repository: " + repository.getId(), e );
-
-                            continue;
-                        }
-
-                        int difference = remoteMetadata.compareTo( localMetadata );
-                        if ( difference > 0 )
-                        {
-                            // remote is newer
-                            artifact.setRepository( repository );
-
-                            localMetadata = remoteMetadata;
+                            getLogger().debug( "resolveMetaData: Artifact version metadata for: " + artifact.getId() +
+                                " could not be found on repository: " + repository.getId(), e );
-                        getLogger().debug( "resolveMetaData: " + artifact.getId() +
-                            ": NOT checking for updates from " + repository.getId() +
-                            " (" + repository.getUrl() + ")" );
+                        getLogger().debug( "resolveMetaData: " + artifact.getId() + ": NOT checking for updates from " +
+                            repository.getId() + " (" + repository.getUrl() + ")" );
-            // touch the file if it was checked for updates, but don't create it if it doesn't exist remotely to avoid
+            // touch the file if it was checked for updates, but don't create it if it did't exist to avoid
-                localMetadata.storeInLocalRepository( localRepository,
-                                                      null ); // TODO: fix artifact repository - but this will be removed anyway
+                localMetadata.storeInLocalRepository( localRepository );
-        // TODO: if the POM and JAR are inconsistent, this might mean that different version of each are used
-        return localMetadata;
+        return localMetadata != null ? localMetadata.constructVersion() : null;
-    protected VersionArtifactMetadata retrieveFromRemoteRepository( Artifact artifact,
-                                                                    ArtifactRepository remoteRepository,
-                                                                    ArtifactMetadata localMetadata,
-                                                                    String checksumPolicy )
-        throws ArtifactMetadataRetrievalException, ResourceDoesNotExistException
-    {
-        AbstractVersionArtifactMetadata metadata = createMetadata( artifact );
+    /**
+     * Select the version to use based on a merged versioning element.
+     *
+     * @param versioning the versioning element
+     * @param defaultVersion the version to select if none is selected from versioning
+     * @return the version selected
+     */
+//    protected abstract String selectVersion( Versioning versioning, String defaultVersion );
+    protected abstract LegacyArtifactMetadata createLegacyMetadata( Artifact artifact );
-        metadata.retrieveFromRemoteRepository( remoteRepository, wagonManager, checksumPolicy );
-
-        return metadata;
-    }
-
-    protected abstract AbstractVersionArtifactMetadata createMetadata( Artifact artifact );
-
-    private VersionArtifactMetadata readFromLocalRepository( Artifact artifact, ArtifactRepository localRepository )
-        throws IOException
-    {
-        // TODO: we could cache the results of this, perhaps inside the artifact repository?
-        AbstractVersionArtifactMetadata metadata = createMetadata( artifact );
-        metadata.readFromLocalRepository( localRepository,
-                                          null ); // TODO: fix artifact repository - but this will be removed anyway
-        return metadata;
-    }
-
+    /**
+     * @todo remove in beta-2 - used for legacy handling
+     */
+    /**
+     * @todo remove in beta-2 - used for legacy handling
+     */
+
+    private ArtifactRepositoryMetadata loadVersioningInformation( ArtifactMetadata repoMetadata,
+                                                                  ArtifactRepository remoteRepository,
+                                                                  ArtifactRepository localRepository,
+                                                                  Artifact artifact )
+        throws ArtifactMetadataRetrievalException
+    {
+        File metadataFile = new File( localRepository.getBasedir(),
+                                      localRepository.pathOfLocalRepositoryMetadata( repoMetadata, remoteRepository ) );
+
+        ArtifactRepositoryMetadata newMetadata = null;
+        if ( metadataFile.exists() )
+        {
+            Metadata metadata = readMetadata( metadataFile );
+            if ( metadata.getVersioning() != null )
+            {
+                newMetadata = new ArtifactRepositoryMetadata( artifact, metadata.getVersioning() );
+            }
+        }
+        return newMetadata;
+    }
+
+    /**
+     * @todo share with DefaultPluginMappingManager.
+     */
+    private static Metadata readMetadata( File mappingFile )
+        throws ArtifactMetadataRetrievalException
+    {
+        Metadata result;
+
+        Reader fileReader = null;
+        try
+        {
+            fileReader = new FileReader( mappingFile );
+
+            MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();
+
+            result = mappingReader.read( fileReader );
+        }
+        catch ( FileNotFoundException e )
+        {
+            throw new ArtifactMetadataRetrievalException( "Cannot read version information from: " + mappingFile, e );
+        }
+        catch ( IOException e )
+        {
+            throw new ArtifactMetadataRetrievalException( "Cannot read version information from: " + mappingFile, e );
+        }
+        catch ( XmlPullParserException e )
+        {
+            throw new ArtifactMetadataRetrievalException( "Cannot parse version information from: " + mappingFile, e );
+        }
+        finally
+        {
+            IOUtil.close( fileReader );
+        }
+        return result;
+    }

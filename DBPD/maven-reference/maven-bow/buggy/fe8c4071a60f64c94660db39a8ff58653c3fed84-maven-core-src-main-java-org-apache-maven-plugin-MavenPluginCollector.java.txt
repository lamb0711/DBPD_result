Switching back to selectively import extensions into a project-specific ClassRealm, except this time extension realms will be shared (the origin of the aforementioned imports) to conserve memory tied up by classloading. Similarly, plugin realms are managed using a key produced from g:a:v of the plugin, plus the hashcode of all g:a:v of the plugin-level dependencies aggregated into one string, to distinguish the deploy plugin 2.0 with no deps from the deploy plugin 2.0 with a plugin-level dep on wagon-webdav. Plugin realms have their parent realms managed by the pluginManager now prior to lookup or execution of the mojo instance, and PluginDescriptor.(classRealm|artifacts) attributes are set for each execution. Likewise, the MavenPluginCollector now tracks plugin descriptors with their version information included, instead of just using g:a.

Had to bump the plexus-container-default version up to alpha-36 to fix a problem in ClassicSingletonComponentManager. All realms for extensions, plugins, and projects (which contain only imports from extensions) are now managed by the MavenRealmManager.


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@591391 13f79535-47bb-0310-9956-ffa450edef68

-import org.codehaus.plexus.logging.AbstractLogEnabled;
-            // TODO: see comment in getPluginDescriptor
-            String key = Plugin.constructKey( pluginDescriptor.getGroupId(), pluginDescriptor.getArtifactId() );
+            String key = constructPluginKey( pluginDescriptor );
-
-                // TODO: throw an (not runtime) exception if there is a prefix overlap - means doing so elsewhere
-                // we also need to deal with multiple versions somehow - currently, first wins
-                if ( !pluginIdsByPrefix.containsKey( pluginDescriptor.getGoalPrefix() ) )
-                {
-                    pluginIdsByPrefix.put( pluginDescriptor.getGoalPrefix(), pluginDescriptor );
-                }
-        return "maven-plugin-collector";    
+        return "maven-plugin-collector";
-        // TODO: include version, but can't do this in the plugin manager as it is not resolved to the right version
-        // at that point. Instead, move the duplication check to the artifact container, or store it locally based on
-        // the unresolved version?
-        return (PluginDescriptor) pluginDescriptors.get( plugin.getKey() );
+        String key = constructPluginKey( plugin );
+        return (PluginDescriptor) pluginDescriptors.get( key );
+    }
+
+    private String constructPluginKey( Plugin plugin )
+    {
+        return plugin.getGroupId() + ":" + plugin.getArtifactId() + ":" + plugin.getVersion();
+    }
+
+    private String constructPluginKey( PluginDescriptor pluginDescriptor )
+    {
+        return pluginDescriptor.getGroupId() + ":" + pluginDescriptor.getArtifactId() + ":" + pluginDescriptor.getVersion();
-        // TODO: see comment in getPluginDescriptor
-        return pluginDescriptors.containsKey( plugin.getKey() );
+        String key = constructPluginKey( plugin );
+        return pluginDescriptors.containsKey( key );
-    public PluginDescriptor getPluginDescriptorForPrefix( String prefix )
+    public Set getPluginDescriptorsForPrefix( String prefix )
-        return (PluginDescriptor) pluginIdsByPrefix.get( prefix );
-    }
-
-    public void flushPluginDescriptor( Plugin plugin )
-    {
-        pluginsInProcess.remove( plugin.getKey() );
-        pluginDescriptors.remove( plugin.getKey() );
-        
-        for ( Iterator it = pluginIdsByPrefix.entrySet().iterator(); it.hasNext(); )
+        Set result = new HashSet();
+        for ( Iterator it = pluginDescriptors.values().iterator(); it.hasNext(); )
-            Map.Entry entry = (Map.Entry) it.next();
-            
-            if ( plugin.getKey().equals( entry.getValue() ) )
+            PluginDescriptor pd = (PluginDescriptor) it.next();
+            if ( pd.getGoalPrefix().equals( prefix ) )
-                it.remove();
+                result.add( pd );
+
+        return result;

PR: MNG-613
push shared code into metadata manager

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@280232 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader;
+import org.codehaus.plexus.util.IOUtil;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.Reader;
-    public void resolve( ArtifactMetadata metadata, List remoteRepositories, ArtifactRepository localRepository )
+    public void resolve( RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository )
-        boolean alreadyResolved = alreadyResolved( metadata );
-        if ( !alreadyResolved )
+        // TODO: currently this is first wins, but really we should take the latest by comparing either the
+        // snapshot timestamp, or some other timestamp later encoded into the metadata.
+        loadMetadata( metadata, localRepository, localRepository );
+
+        for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
-            for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
+            ArtifactRepository repository = (ArtifactRepository) i.next();
+
+            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots()
+                : repository.getReleases();
+
+            if ( !policy.isEnabled() )
-                ArtifactRepository repository = (ArtifactRepository) i.next();
-
-                ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots()
-                    : repository.getReleases();
-
-                if ( !policy.isEnabled() )
-                {
-                    getLogger().debug( "Skipping disabled repository " + repository.getId() );
-                }
-                else
+                getLogger().debug( "Skipping disabled repository " + repository.getId() );
+            }
+            else
+            {
+                boolean alreadyResolved = alreadyResolved( metadata );
+                if ( !alreadyResolved )
+                    cachedMetadata.add( metadata.getKey() );
+                loadMetadata( metadata, repository, localRepository );
-
-            cachedMetadata.add( metadata.getKey() );
-    public void resolveAlways( ArtifactMetadata metadata, ArtifactRepository localRepository,
+    private void loadMetadata( RepositoryMetadata repoMetadata, ArtifactRepository remoteRepository,
+                               ArtifactRepository localRepository )
+        throws ArtifactMetadataRetrievalException
+    {
+        File metadataFile = new File( localRepository.getBasedir(),
+                                      localRepository.pathOfLocalRepositoryMetadata( repoMetadata, remoteRepository ) );
+
+        if ( metadataFile.exists() )
+        {
+            Metadata metadata = readMetadata( metadataFile );
+            repoMetadata.setRepository( remoteRepository );
+
+            if ( repoMetadata.getMetadata() != null )
+            {
+                metadata.merge( repoMetadata.getMetadata() );
+            }
+            repoMetadata.setMetadata( metadata );
+        }
+    }
+
+    /**
+     * @todo share with DefaultPluginMappingManager.
+     */
+    protected static Metadata readMetadata( File mappingFile )
+        throws ArtifactMetadataRetrievalException
+    {
+        Metadata result;
+
+        Reader fileReader = null;
+        try
+        {
+            fileReader = new FileReader( mappingFile );
+
+            MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();
+
+            result = mappingReader.read( fileReader );
+        }
+        catch ( FileNotFoundException e )
+        {
+            throw new ArtifactMetadataRetrievalException( "Cannot read version information from: " + mappingFile, e );
+        }
+        catch ( IOException e )
+        {
+            throw new ArtifactMetadataRetrievalException( "Cannot read version information from: " + mappingFile, e );
+        }
+        catch ( XmlPullParserException e )
+        {
+            throw new ArtifactMetadataRetrievalException( "Cannot parse version information from: " + mappingFile, e );
+        }
+        finally
+        {
+            IOUtil.close( fileReader );
+        }
+        return result;
+    }
+
+    public void resolveAlways( RepositoryMetadata metadata, ArtifactRepository localRepository,
+
+        if ( file.exists() )
+        {
+            Metadata prevMetadata = readMetadata( file );
+            metadata.setMetadata( prevMetadata );
+        }
-        resolveAlways( metadata, localRepository, deploymentRepository );
+
+        File file = new File( localRepository.getBasedir(),
+                              localRepository.pathOfLocalRepositoryMetadata( metadata, deploymentRepository ) );
+
+        resolveAlways( metadata, deploymentRepository, file, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN );
-            File f = new File( localRepository.getBasedir(),
-                               localRepository.pathOfLocalRepositoryMetadata( metadata, deploymentRepository ) );
-            wagonManager.putArtifactMetadata( f, metadata, deploymentRepository );
+            wagonManager.putArtifactMetadata( file, metadata, deploymentRepository );

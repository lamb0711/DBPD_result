MNG-4634 Allow custom lifecycles

Build extensions plugins can now define new lifecycles. Implementation guarantees 
that standard lifecycles, i.e. default, clean and site, are considered before custom
lifecycles. It assumes that phase names are globally unique and ignores any
duplicate phase names (with a warning).

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@933848 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
-import org.apache.maven.plugin.*;
+import org.apache.maven.plugin.InvalidPluginDescriptorException;
+import org.apache.maven.plugin.MojoExecution;
+import org.apache.maven.plugin.MojoNotFoundException;
+import org.apache.maven.plugin.PluginDescriptorParsingException;
+import org.apache.maven.plugin.PluginNotFoundException;
+import org.apache.maven.plugin.PluginResolutionException;
-import org.codehaus.plexus.personality.plexus.lifecycle.phase.Initializable;
-import org.codehaus.plexus.personality.plexus.lifecycle.phase.InitializationException;
+import org.codehaus.plexus.logging.Logger;
-import java.util.*;
-
-//TODO: The configuration for the lifecycle needs to be externalized so that I can use the annotations properly for the wiring and reference and external source for the lifecycle configuration.
+// TODO: The configuration for the lifecycle needs to be externalized so that I can use the annotations properly for the
+// wiring and reference and external source for the lifecycle configuration.
-    implements Initializable
+    public static final String[] STANDARD_LIFECYCLES = { "default", "clean", "site" };
+
-    private List<Lifecycle> lifecycles;
+    // @Requirement(role=Lifecycle.class)
+    private Map<String, Lifecycle> lifecycles;
+
+    // @Requirement
+    private Logger logger;
-    /**
-     * We use this to display all the lifecycles available and their phases to users. Currently this is primarily
-     * used in the IDE integrations where a UI is presented to the user and they can select the lifecycle phase
-     * they would like to execute.
-     */
-    private Map<String, Lifecycle> lifecycleMap;
-
-    /**
-     * We use this to map all phases to the lifecycle that contains it. This is used so that a user can specify the
-     * phase they want to execute and we can easily determine what lifecycle we need to run.
-     */
-    private Map<String, Lifecycle> phaseToLifecycleMap;
-
-    @SuppressWarnings({"UnusedDeclaration"})
+    @SuppressWarnings( { "UnusedDeclaration" } )
-        this.lifecycles = lifecycles;
+        this.lifecycles = new LinkedHashMap<String, Lifecycle>();
-    }
-
-    public void initialize()
-        throws InitializationException
-    {
-        lifecycleMap = new HashMap<String, Lifecycle>();
-
-        // If people are going to make their own lifecycles then we need to tell people how to namespace them correctly so
-        // that they don't interfere with internally defined lifecycles.
-
-        phaseToLifecycleMap = new HashMap<String, Lifecycle>();
-            for ( String phase : lifecycle.getPhases() )
-            {
-                // The first definition wins.
-                if ( !phaseToLifecycleMap.containsKey( phase ) )
-                {
-                    phaseToLifecycleMap.put( phase, lifecycle );
-                }
-            }
-
-            lifecycleMap.put( lifecycle.getId(), lifecycle );
+            this.lifecycles.put( lifecycle.getId(), lifecycle );
-
-     *
+     * 
-        return phaseToLifecycleMap.get( key );
+        return getPhaseToLifecycleMap().get( key );
+    /**
+     * We use this to map all phases to the lifecycle that contains it. This is used so that a user can specify the
+     * phase they want to execute and we can easily determine what lifecycle we need to run.
+     */
+        // If people are going to make their own lifecycles then we need to tell people how to namespace them correctly
+        // so
+        // that they don't interfere with internally defined lifecycles.
+
+        HashMap<String, Lifecycle> phaseToLifecycleMap = new HashMap<String, Lifecycle>();
+
+        for ( Lifecycle lifecycle : getLifeCycles() )
+        {
+            if ( logger.isDebugEnabled() )
+            {
+                logger.debug( "Custom lifecycle " + lifecycle.toString() );
+            }
+            
+            for ( String phase : lifecycle.getPhases() )
+            {
+                // The first definition wins.
+                if ( !phaseToLifecycleMap.containsKey( phase ) )
+                {
+                    phaseToLifecycleMap.put( phase, lifecycle );
+                }
+                else
+                {
+                    Lifecycle original = phaseToLifecycleMap.get( phase );
+                    logger.warn( "Duplicated lifecycle phase " + phase + ". Defined in " + original.getId()
+                        + " but also in " + lifecycle.getId() );
+                }
+            }
+        }
+
-        return lifecycles;
+        // ensure canonical order of standard lifecycles
+
+        Map<String, Lifecycle> lifecycles = new LinkedHashMap<String, Lifecycle>( this.lifecycles );
+
+        LinkedHashSet<String> lifecycleNames = new LinkedHashSet<String>( Arrays.asList( STANDARD_LIFECYCLES ) );
+        lifecycleNames.addAll( lifecycles.keySet() );
+        ArrayList<Lifecycle> result = new ArrayList<Lifecycle>();
+        for ( String name : lifecycleNames )
+        {
+            result.add( lifecycles.get( name ) );
+        }
+
+        return result;
-        for ( Lifecycle lifecycle : lifecycles )
+        for ( Lifecycle lifecycle : lifecycles.values() )

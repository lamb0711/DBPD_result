[MNG-1927] This adds the test mojos required to fix ${pom.build.*} expansion to full paths, the problem was the
           new interpolator so the one from 2.0 was used and some envar handling was back ported. Unit tests
           have been added for envar handling as well as an IT. The maven-core-it script will now set
           an envar which is used in it0090.



git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@368108 13f79535-47bb-0310-9956-ffa450edef68

-import org.codehaus.plexus.util.interpolation.EnvarBasedValueSource;
-import org.codehaus.plexus.util.interpolation.MapBasedValueSource;
-import org.codehaus.plexus.util.interpolation.ObjectBasedValueSource;
-import org.codehaus.plexus.util.interpolation.RegexBasedInterpolator;
+import org.codehaus.plexus.logging.Logger;
+import org.codehaus.plexus.util.StringUtils;
+import org.codehaus.plexus.util.cli.CommandLineUtils;
+import org.codehaus.plexus.util.introspection.ReflectionValueExtractor;
+import java.util.Properties;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
-    public Model interpolate( Model project, Map context )
+    private static final Pattern EXPRESSION_PATTERN = Pattern.compile( "\\$\\{(pom\\.|project\\.|env\\.)?([^}]+)\\}" );
+
+    private Properties envars;
+
+    public RegexBasedModelInterpolator( Properties envars )
+    {
+        this.envars = envars;
+    }
+
+    public RegexBasedModelInterpolator()
+        throws IOException
+    {
+        envars = CommandLineUtils.getSystemEnvVars();
+    }
+
+    public Model interpolate( Model model, Map context )
-        return interpolate( project, context, true );
+        return interpolate( model, context, true );
-     * @param model The inbound Model instance, to serialize and reference for expression resolution
+     * @param model   The inbound Model instance, to serialize and reference for expression resolution
-
-        RegexBasedInterpolator interpolator = new RegexBasedInterpolator();
-
-        interpolator.addValueSource( new MapBasedValueSource( context ) );
-        interpolator.addValueSource( new MapBasedValueSource( model.getProperties() ) );
-        interpolator.addValueSource( new ObjectBasedValueSource( model ) );
-
-        try
-        {
-            interpolator.addValueSource( new EnvarBasedValueSource() );
-        }
-        catch ( IOException e )
-        {
-            getLogger().warn( "Cannot initialize environment variables resolver. Skipping environmental resolution." );
-            getLogger().debug( "Failed to initialize envar resolver. Skipping environmental resolution.", e );
-        }
-
-        serializedModel = interpolator.interpolate(serializedModel, "pom|project" );
+        serializedModel = interpolateInternal( serializedModel, model, context );
-            model = modelReader.read( sReader, strict );
+            model = modelReader.read( sReader );
+    private String interpolateInternal( String src, Model model, Map context )
+        throws ModelInterpolationException
+    {
+        String result = src;
+        Matcher matcher = EXPRESSION_PATTERN.matcher( result );
+        while ( matcher.find() )
+        {
+            String wholeExpr = matcher.group( 0 );
+            String realExpr = matcher.group( 2 );
+
+            Object value = context.get( realExpr );
+
+            if ( value == null )
+            {
+                value = model.getProperties().getProperty( realExpr );
+            }
+
+            if ( value == null )
+            {
+                try
+                {
+                    value = ReflectionValueExtractor.evaluate( realExpr, model );
+                }
+                catch ( Exception e )
+                {
+                    Logger logger = getLogger();
+                    if ( logger != null )
+                    {
+                        logger.debug( "POM interpolation cannot proceed with expression: " + wholeExpr + ". Skipping...", e );
+                    }
+                }
+            }
+
+            if ( value == null )
+            {
+                value = envars.getProperty( realExpr );
+            }
+
+            // if the expression refers to itself, skip it.
+            if ( wholeExpr.equals( value ) )
+            {
+                throw new ModelInterpolationException( wholeExpr, model.getId() + " references itself." );
+            }
+
+            if ( value != null )
+            {
+                result = StringUtils.replace( result, wholeExpr, String.valueOf( value ) );
+                // could use:
+                // result = matcher.replaceFirst( stringValue );
+                // but this could result in multiple lookups of stringValue, and replaceAll is not correct behaviour
+                matcher.reset( result );
+            }
+/*
+        // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
+        // timing of executing the interpolation
+
+            else
+            {
+                throw new ModelInterpolationException(
+                    "Expression '" + wholeExpr + "' did not evaluate to anything in the model" );
+            }
+*/
+        }
+
+        return result;
+    }
+

o separating out the MavenEmbedderProjectWithExtensionReadingTest which shows that the artifacts handlers must be loaded up-front
  in the readProjectWithDependencies method because it is not being done in the core unless projects are executed. So Milos' assertion
  is correct. I'm now looking at a layered approach for project resolution and then execution so that the readProjectWithDependencies
  (which is essential for IDE integration) will yield something that can be pushed into the lifecycle executor. Right now there
  is much duplication which makes the IDE integration crappy.

  Another result of this is trying to create a simple IDE import model that gives back client code the fully resolved, topo sorted
  set of projects which point to binary dependencies outside the reactor, and to source folders inside the reactor. The result will
  be a useful model for all IDE integration, right now everyone is doing their own thing. This model will need hooks for customization
  to take into account turning "workspace resolution" on/off and allow easy overriding of this process.

o Fixed IT0035



git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@572366 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
-        MavenProject project;
-
-            //mkleint: copied from DefaultLifecycleExecutor
-            project = readProject( new File( request.getPomFile() ) );
+            // This is necessary to make the MavenEmbedderProjectWithExtensionReadingTest work which uses
+            // a custom type for a dependency like this:
+            //
+            // <dependency>
+            //   <groupId>junit</groupId>
+            //   <artifactId>junit</artifactId>
+            //   <version>3.8.1</version>
+            //   <scope>test</scope>
+            //   <type>mkleint</type>
+            // </dependency>
+            //
+            // If the artifact handlers are not loaded up-front then this dependency element is not
+            // registered as an artifact and is not added to the classpath elements.
+
+            MavenProject project = readProject( new File( request.getPomFile() ) );
-            //is this necessary in this context, I doubt it..mkleint
-
-            // At this point real project building, and artifact resolution have not occured.
-
-            result.addException( e );
-
-            return result;
+            return result.addException( e );
-        MavenProjectBuildingResult r = null;
-
-        result.setTopologicallySortedProjects( reactorManager.getSortedProjects() );
-
-        // Now I should be able to pass this projects to the next request so that I don't have to process
-        // any local projects again. And this logic is still too complicated.
+        MavenProjectBuildingResult projectBuildingResult = null;
-            r = mavenProjectBuilder.buildWithDependencies(
+            projectBuildingResult = mavenProjectBuilder.buildWithDependencies(
-        result.setProject( r.getProject() );
+        if ( reactorManager.hasMultipleProjects() )
+        {
+            result.setProject( projectBuildingResult.getProject() );
-        result.setArtifactResolutionResult( r.getArtifactResolutionResult() );
+            result.setTopologicallySortedProjects( reactorManager.getSortedProjects() );
+        }
+        else
+        {
+            result.setProject( projectBuildingResult.getProject() );
+            result.setTopologicallySortedProjects( Arrays.asList( new MavenProject[]{ projectBuildingResult.getProject()} ) );
+        }
+
+        result.setArtifactResolutionResult( projectBuildingResult.getArtifactResolutionResult() );
+
+        // From this I could produce something that would help IDE integrators create importers:
+        // - topo sorted list of projects
+        // - binary dependencies
+        // - source dependencies (projects in the reactor)
+        //
+        // We could create a layer approach here. As to do anything you must resolve a projects artifacts,
+        // and with that set you could then subsequently execute goals for each of those project.

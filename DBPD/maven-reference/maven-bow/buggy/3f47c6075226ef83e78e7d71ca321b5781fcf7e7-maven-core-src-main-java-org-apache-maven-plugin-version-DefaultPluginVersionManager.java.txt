Cleaned up plugin-version resolution.

o Added four command-line options:

  --check-plugin-updates is a synonym for --update-plugins
  
  --no-plugin-registry turns off usage of plugin-registry.xml for plugin version resolution for the current build.
  
  --check-plugin-latest turns on usage of LATEST metadata for plugin version resolution for the current build.

  --no-plugin-latest turns off usage of LATEST metadata for plugin version resolution for the current build.

o Added settings.xml configuration <usePluginRegistry>true|false</usePluginRegistry> to en/disable the use of plugin-registry.xml for plugin version resolution. The default value is true, to use the plugin-registry.xml.

o Added plugin-registry.xml configuration <checkLatest>true|false</checkLatest> to en/disable the use of LATEST metadata when resolving plugin versions. The default value is false, or do not use LATEST.



git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@219089 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.settings.RuntimeInfo;
-        // determine the behavior WRT prompting the user and installing plugin updates.
-        Boolean pluginUpdateOverride = settings.getRuntimeInfo().getPluginUpdateOverride();
+        RuntimeInfo settingsRTInfo = settings.getRuntimeInfo();
-        // second pass...if the plugin is listed in the settings.xml, use the version from <useVersion/>.
-        if ( StringUtils.isEmpty( version ) )
+        // determine the behavior WRT prompting the user and installing plugin updates.
+        Boolean pluginUpdateOverride = settingsRTInfo.getPluginUpdateOverride();
+
+        // second pass...if we're using the plugin registry, and the plugin is listed in the plugin-registry.xml, use 
+        // the version from <useVersion/>.
+        if ( StringUtils.isEmpty( version ) && settings.isUsePluginRegistry() )
-                    updatedVersion = resolveMetaVersion( groupId, artifactId, project
-                        .getPluginArtifactRepositories(), localRepository, ReleaseArtifactTransformation.RELEASE_VERSION );
+                    updatedVersion = resolveMetaVersion( groupId, artifactId, project.getPluginArtifactRepositories(),
+                                                         localRepository, ReleaseArtifactTransformation.RELEASE_VERSION );
-                            getLogger()
-                                .info( "Plugin \'" + constructPluginKey( groupId, artifactId ) + "\' has updates." );
+                            getLogger().info(
+                                              "Plugin \'" + constructPluginKey( groupId, artifactId )
+                                                  + "\' has updates." );
-        
+
-        // third pass...retrieve the version for RELEASE and also set that resolved version as the <useVersion/> 
-        // in settings.xml.
-        if ( StringUtils.isEmpty( version ) )
+        // are we using the LATEST metadata to resolve plugin version?
+        Boolean rtCheckLatest = settingsRTInfo.getCheckLatestPluginVersion();
+
+        boolean checkLatestMetadata = Boolean.TRUE.equals( rtCheckLatest )
+            || ( !Boolean.FALSE.equals( rtCheckLatest ) && Boolean.valueOf( pluginRegistry.getCheckLatest() )
+                .booleanValue() );
+
+        // third pass...if we're checking for latest install/deploy, retrieve the version for LATEST metadata and also 
+        // set that resolved version as the <useVersion/> in settings.xml.
+        if ( StringUtils.isEmpty( version ) && checkLatestMetadata )
-                                             localRepository, ReleaseArtifactTransformation.RELEASE_VERSION );
+                                          localRepository, LatestArtifactTransformation.LATEST_VERSION );
-        // final pass...retrieve the version for LATEST and also set that resolved version as the <useVersion/> 
+        // final pass...retrieve the version for RELEASE and also set that resolved version as the <useVersion/> 
-                                             localRepository, LatestArtifactTransformation.LATEST_VERSION );
+                                          localRepository, ReleaseArtifactTransformation.RELEASE_VERSION );
-        // determine whether this build is running in interactive mode
-        // If it's not, then we'll defer to the autoUpdate setting from the registry 
-        // for a decision on updating the plugin in the registry...rather than prompting
-        // the user.
-        boolean inInteractiveMode = settings.isInteractiveMode();
-
-        // determines what should be done if we're in non-interactive mode.
-        // if true, then just update the registry with the new versions.
-        String s = getPluginRegistry( groupId, artifactId ).getAutoUpdate();
-        boolean autoUpdate = true;
-        if ( s != null )
+        // if the plugin registry is inactive, then the rest of this goop is useless...
+        if ( settings.isUsePluginRegistry() )
-            autoUpdate = Boolean.valueOf( s ).booleanValue();
-        }
+            // determine whether this build is running in interactive mode
+            // If it's not, then we'll defer to the autoUpdate setting from the registry 
+            // for a decision on updating the plugin in the registry...rather than prompting
+            // the user.
+            boolean inInteractiveMode = settings.isInteractiveMode();
-        // We should persist by default if:
-        //
-        // 0. RELEASE or LATEST was used to resolve the plugin version (it's not in the registry)
-        //
-        // -OR-
-        //
-        // 1. we detected a change in the plugin version from what was in the registry, or
-        //      a. the plugin is not registered
-        // 2. the pluginUpdateOverride flag has NOT been set to Boolean.FALSE (suppression mode)
-        // 3. we're in interactive mode, or
-        //      a. the registry is declared to be in autoUpdate mode
-        //
-        // NOTE: This is only the default value; it may be changed as the result of prompting the user.
-        boolean persistUpdate = forcePersist || ( promptToPersist && !Boolean.FALSE.equals( pluginUpdateOverride )
-            && ( inInteractiveMode || autoUpdate ) );
+            // determines what should be done if we're in non-interactive mode.
+            // if true, then just update the registry with the new versions.
+            String s = getPluginRegistry( groupId, artifactId ).getAutoUpdate();
+            boolean autoUpdate = true;
+            if ( s != null )
+            {
+                autoUpdate = Boolean.valueOf( s ).booleanValue();
+            }
-        // retrieve the apply-to-all flag, if it's been set previously.
-        Boolean applyToAll = settings.getRuntimeInfo().getApplyToAllPluginUpdates();
+            // We should persist by default if:
+            //
+            // 0. RELEASE or LATEST was used to resolve the plugin version (it's not in the registry)
+            //
+            // -OR-
+            //
+            // 1. we detected a change in the plugin version from what was in the registry, or
+            //      a. the plugin is not registered
+            // 2. the pluginUpdateOverride flag has NOT been set to Boolean.FALSE (suppression mode)
+            // 3. we're in interactive mode, or
+            //      a. the registry is declared to be in autoUpdate mode
+            //
+            // NOTE: This is only the default value; it may be changed as the result of prompting the user.
+            boolean persistUpdate = forcePersist
+                || ( promptToPersist && !Boolean.FALSE.equals( pluginUpdateOverride ) && ( inInteractiveMode || autoUpdate ) );
-        // Incorporate interactive-mode CLI overrides, and previous decisions on apply-to-all, if appropriate.
-        //
-        // don't prompt if RELEASE or LATEST was used to resolve the plugin version
-        // don't prompt if not in interactive mode.
-        // don't prompt if the CLI pluginUpdateOverride is set (either suppression or force mode will stop prompting)
-        // don't prompt if the user has selected ALL/NONE previously in this session
-        //
-        // NOTE: We're incorporating here, to make the usages of this check more consistent and 
-        // resistant to change.
-        promptToPersist = promptToPersist && pluginUpdateOverride == null && applyToAll == null && inInteractiveMode;
+            // retrieve the apply-to-all flag, if it's been set previously.
+            Boolean applyToAll = settings.getRuntimeInfo().getApplyToAllPluginUpdates();
-        if ( promptToPersist )
-        {
-            persistUpdate = promptToPersistPluginUpdate( version, updatedVersion, groupId, artifactId, settings );
-        }
+            // Incorporate interactive-mode CLI overrides, and previous decisions on apply-to-all, if appropriate.
+            //
+            // don't prompt if RELEASE or LATEST was used to resolve the plugin version
+            // don't prompt if not in interactive mode.
+            // don't prompt if the CLI pluginUpdateOverride is set (either suppression or force mode will stop prompting)
+            // don't prompt if the user has selected ALL/NONE previously in this session
+            //
+            // NOTE: We're incorporating here, to make the usages of this check more consistent and 
+            // resistant to change.
+            promptToPersist = promptToPersist && pluginUpdateOverride == null && applyToAll == null
+                && inInteractiveMode;
-        // if it is determined that we should use this version, persist it as useVersion.
-        // cases where this version will be persisted:
-        // 1. the user is prompted and answers yes or all
-        // 2. the user has previously answered all in this session
-        // 3. the build is running in non-interactive mode, and the registry setting is for auto-update
-        if ( !Boolean.FALSE.equals( applyToAll ) && persistUpdate )
-        {
-            updatePluginVersionInRegistry( groupId, artifactId, updatedVersion );
+            if ( promptToPersist )
+            {
+                persistUpdate = promptToPersistPluginUpdate( version, updatedVersion, groupId, artifactId, settings );
+            }
-            // we're using the updated version of the plugin in this session as well.
-            version = updatedVersion;
-        }
-        // otherwise, if we prompted the user to update, we should treat this as a rejectedVersion, and
-        // persist it iff the plugin pre-exists and is in the user-level registry.
-        else if ( promptToPersist )
-        {
-            addNewVersionToRejectedListInExisting( groupId, artifactId, updatedVersion );
+            // if it is determined that we should use this version, persist it as useVersion.
+            // cases where this version will be persisted:
+            // 1. the user is prompted and answers yes or all
+            // 2. the user has previously answered all in this session
+            // 3. the build is running in non-interactive mode, and the registry setting is for auto-update
+            if ( !Boolean.FALSE.equals( applyToAll ) && persistUpdate )
+            {
+                updatePluginVersionInRegistry( groupId, artifactId, updatedVersion );
+
+                // we're using the updated version of the plugin in this session as well.
+                version = updatedVersion;
+            }
+            // otherwise, if we prompted the user to update, we should treat this as a rejectedVersion, and
+            // persist it iff the plugin pre-exists and is in the user-level registry.
+            else if ( promptToPersist )
+            {
+                addNewVersionToRejectedListInExisting( groupId, artifactId, updatedVersion );
+            }
-                                         ArtifactRepository localRepository, String metaVersionId )
+                                      ArtifactRepository localRepository, String metaVersionId )
-        Artifact artifact = artifactFactory.createArtifact( groupId, artifactId, metaVersionId,
-                                                                   Artifact.SCOPE_RUNTIME, "pom" );
-        
+        Artifact artifact = artifactFactory.createArtifact( groupId, artifactId, metaVersionId, Artifact.SCOPE_RUNTIME,
+                                                            "pom" );
+
-        
+
-            version = artifact.getBaseVersion();
+            version = artifact.getVersion();
-        
+

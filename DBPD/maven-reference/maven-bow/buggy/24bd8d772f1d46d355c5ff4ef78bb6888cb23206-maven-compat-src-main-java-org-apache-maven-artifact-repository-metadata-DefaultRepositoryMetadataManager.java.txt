o Introduced RepositoryRequest to hold the bare minimum of items required for repo accesses
o Added cache for metadata.xml

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@803059 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Iterator;
+import org.apache.maven.artifact.repository.DefaultRepositoryRequest;
+import org.apache.maven.artifact.repository.RepositoryCache;
+import org.apache.maven.artifact.repository.RepositoryRequest;
-import org.codehaus.plexus.logging.Logger;
+        RepositoryRequest request = new DefaultRepositoryRequest();
+        request.setLocalRepository( localRepository );
+        request.setRemoteRepositories( remoteRepositories );
+        resolve( metadata, request );
+    }
+
+    public void resolve( RepositoryMetadata metadata, RepositoryRequest request )
+        throws RepositoryMetadataResolutionException
+    {
+        RepositoryCache cache = request.getCache();
+
+        CacheKey cacheKey = null;
+
+        if ( cache != null )
+        {
+            cacheKey = new CacheKey( metadata, request );
+
+            CacheRecord cacheRecord = (CacheRecord) cache.get( request, cacheKey );
+
+            if ( cacheRecord != null )
+            {
+                if ( getLogger().isDebugEnabled() )
+                {
+                    getLogger().debug( "Resolved metadata from cache: " + metadata );
+                }
+
+                metadata.setMetadata( MetadataUtils.cloneMetadata( cacheRecord.metadata ) );
+
+                if ( cacheRecord.repository != null )
+                {
+                    for ( ArtifactRepository repository : request.getRemoteRepositories() )
+                    {
+                        if ( cacheRecord.repository.equals( repository.getId() ) )
+                        {
+                            metadata.setRepository( repository );
+                            break;
+                        }
+                    }
+                }
+
+                return;
+            }
+        }
+
+        ArtifactRepository localRepository = request.getLocalRepository();
+        List<ArtifactRepository> remoteRepositories = request.getRemoteRepositories();
+
+
+        if ( cache != null )
+        {
+            cache.put( request, cacheKey, new CacheRecord( metadata ) );
+        }
+    }
+
+    private static final class CacheKey
+    {
+
+        final Object metadataKey;
+
+        final ArtifactRepository localRepository;
+
+        final List<ArtifactRepository> remoteRepositories;
+
+        final int hashCode;
+
+        CacheKey( RepositoryMetadata metadata, RepositoryRequest request )
+        {
+            metadataKey = metadata.getKey();
+            localRepository = request.getLocalRepository();
+            remoteRepositories = request.getRemoteRepositories();
+
+            int hash = 17;
+            hash = hash * 31 + metadata.getKey().hashCode();
+            hash = hash * 31 + repoHashCode( localRepository );
+            for ( ArtifactRepository remoteRepository : remoteRepositories )
+            {
+                hash = hash * 31 + repoHashCode( remoteRepository );
+            }
+            hashCode = hash;
+        }
+
+        int repoHashCode( ArtifactRepository repository )
+        {
+            return ( repository != null && repository.getUrl() != null ) ? repository.getUrl().hashCode() : 0;
+        }
+
+        boolean repoEquals( ArtifactRepository repo1, ArtifactRepository repo2 )
+        {
+            if ( repo1 == repo2 )
+            {
+                return true;
+            }
+
+            if ( repo1 == null || repo2 == null )
+            {
+                return false;
+            }
+
+            return equal( repo1.getUrl(), repo2.getUrl() ) && repo1.getClass() == repo2.getClass();
+        }
+
+        private static <T> boolean equal( T s1, T s2 )
+        {
+            return s1 != null ? s1.equals( s2 ) : s2 == null;
+        }
+
+        @Override
+        public boolean equals( Object obj )
+        {
+            if ( this == obj )
+            {
+                return true;
+            }
+
+            if ( !( obj instanceof CacheKey ) )
+            {
+                return false;
+            }
+
+            CacheKey that = (CacheKey) obj;
+
+            if ( !this.metadataKey.equals( that.metadataKey ) )
+            {
+                return false;
+            }
+
+            if ( !repoEquals( this.localRepository, that.localRepository ) )
+            {
+                return false;
+            }
+
+            for ( Iterator<ArtifactRepository> it1 = this.remoteRepositories.iterator(), it2 =
+                that.remoteRepositories.iterator();; )
+            {
+                if ( !it1.hasNext() || !it2.hasNext() )
+                {
+                    if ( it1.hasNext() != it2.hasNext() )
+                    {
+                        return false;
+                    }
+                    break;
+                }
+                ArtifactRepository repo1 = it1.next();
+                ArtifactRepository repo2 = it2.next();
+                if ( !repoEquals( repo1, repo2 ) )
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        @Override
+        public int hashCode()
+        {
+            return hashCode;
+        }
+
+    }
+
+    private static final class CacheRecord
+    {
+
+        final Metadata metadata;
+
+        final String repository;
+
+        CacheRecord( RepositoryMetadata metadata )
+        {
+            this.metadata = MetadataUtils.cloneMetadata( metadata.getMetadata() );
+            this.repository = ( metadata.getRepository() != null ) ? metadata.getRepository().getId() : null;
+        }
+
+

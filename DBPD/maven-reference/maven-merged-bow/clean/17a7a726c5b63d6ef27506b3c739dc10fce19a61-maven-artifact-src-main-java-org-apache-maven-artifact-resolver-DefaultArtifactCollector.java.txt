MNG-2868 The behavior in MNG-1577 is now available on the trunk                                                                   


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@520923 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.artifact.resolver.filter.AndArtifactFilter;
+import org.apache.maven.artifact.versioning.ManagedVersionMap;
-        recurse( root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,
+        ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ?
+            (ManagedVersionMap)managedVersions : new ManagedVersionMap(managedVersions);
+
+        recurse( root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter,
-    private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,
+    private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,
-        // TODO: use as a conflict resolver
-        if ( managedVersions.containsKey( key ) )
+        
+        // TODO: Does this check need to happen here?  Had to add the same call
+        // below when we iterate on child nodes -- will that suffice?
+        if ( managedVersions.containsKey( key ))
-            Artifact artifact = (Artifact) managedVersions.get( key );
-
-            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );
-
-            if ( artifact.getVersion() != null )
-            {
-                node.getArtifact().setVersion( artifact.getVersion() );
-            }
-            if ( artifact.getScope() != null )
-            {
-                node.getArtifact().setScope( artifact.getScope() );
-            }
+            manageArtifact( node, managedVersions, listeners );
+                        Object childKey = child.getKey();
+                        if ( managedVersions.containsKey( childKey ) )
+                        {
+                            // If this child node is a managed dependency, ensure
+                            // we are using the dependency management version
+                            // of this child if applicable b/c we want to use the
+                            // managed version's POM, *not* any other version's POM.
+                            // We retrieve the POM below in the retrieval step.
+                            manageArtifact( child, managedVersions, listeners );
+                            
+                            // Also, we need to ensure that any exclusions it presents are
+                            // added to the artifact before we retrive the metadata
+                            // for the artifact; otherwise we may end up with unwanted
+                            // dependencies.
+                            Artifact ma = (Artifact) managedVersions.get( childKey );
+                            ArtifactFilter managedExclusionFilter = ma.getDependencyFilter();
+                            if ( null != managedExclusionFilter )
+                            {
+                                if ( null != artifact.getDependencyFilter() )
+                                {
+                                    AndArtifactFilter aaf = new AndArtifactFilter();
+                                    aaf.add( artifact.getDependencyFilter() );
+                                    aaf.add( managedExclusionFilter );
+                                    artifact.setDependencyFilter( aaf );
+                                }
+                                else
+                                {
+                                    artifact.setDependencyFilter( managedExclusionFilter );
+                                }
+                            }
+                        }
+
+
+    private void manageArtifact( ResolutionNode node, ManagedVersionMap managedVersions, List listeners )
+    {
+        Artifact artifact = (Artifact) managedVersions.get( node.getKey() );
+
+        // Before we update the version of the artifact, we need to know
+        // whether we are working on a transitive dependency or not.  This
+        // allows depMgmt to always override transitive dependencies, while
+        // explicit child override depMgmt (viz. depMgmt should only
+        // provide defaults to children, but should override transitives).
+        // We can do this by calling isChildOfRootNode on the current node.
+
+        if ( artifact.getVersion() != null
+                        && ( node.isChildOfRootNode() ? node.getArtifact().getVersion() == null : true ) )
+        {
+            fireEvent( ResolutionListener.MANAGE_ARTIFACT_VERSION, listeners, node, artifact );
+            node.getArtifact().setVersion( artifact.getVersion() );
+        }
+
+        if ( artifact.getScope() != null
+                        && ( node.isChildOfRootNode() ? node.getArtifact().getScope() == null : true ) )
+        {
+            fireEvent( ResolutionListener.MANAGE_ARTIFACT_SCOPE, listeners, node, artifact );
+            node.getArtifact().setScope( artifact.getScope() );
+        }
+    }
+
-                case ResolutionListener.MANAGE_ARTIFACT:
-                    listener.manageArtifact( node.getArtifact(), replacement );
+                case ResolutionListener.MANAGE_ARTIFACT_VERSION:
+                    if (listener instanceof ResolutionListenerForDepMgmt) {
+                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
+                        asImpl.manageArtifactVersion( node.getArtifact(), replacement );
+                    } else {
+                        listener.manageArtifact( node.getArtifact(), replacement );
+                    }
+                    break;
+                case ResolutionListener.MANAGE_ARTIFACT_SCOPE:
+                    if (listener instanceof ResolutionListenerForDepMgmt) {
+                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
+                        asImpl.manageArtifactScope( node.getArtifact(), replacement );
+                    } else {
+                        listener.manageArtifact( node.getArtifact(), replacement );
+                    }

INS26 INS26 INS40 INS40 INS31 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS60 UPD43 INS43 INS42 INS43 INS42 INS43 INS42 INS60 MOV25 MOV25 INS43 INS59 UPD42 INS42 INS42 INS42 INS43 INS59 INS27 INS27 INS42 INS42 INS16 UPD42 INS42 INS42 INS11 MOV27 INS36 INS21 MOV27 INS36 INS21 INS36 INS11 INS14 INS43 INS32 INS16 INS32 INS16 INS32 INS49 INS25 INS10 INS25 INS27 INS43 INS42 INS43 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS32 INS32 INS27 INS9 INS42 INS40 INS42 INS42 INS42 INS32 INS27 INS9 INS42 INS40 INS42 INS42 INS42 INS40 INS62 INS8 INS8 UPD40 INS62 INS8 INS8 INS27 INS62 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS33 INS42 INS42 INS32 INS33 INS42 INS43 INS60 INS21 MOV21 INS42 INS43 INS60 INS21 INS21 INS42 INS33 INS42 INS43 INS32 INS42 INS32 INS42 INS42 INS43 INS59 INS32 INS42 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS60 INS25 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS60 INS60 INS25 INS42 INS42 INS32 MOV43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS33 INS42 INS25 MOV43 INS32 INS42 INS42 INS27 INS8 INS8 INS42 INS42 INS42 INS33 INS32 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS43 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL40 DEL42
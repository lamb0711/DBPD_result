Replaced old build-plan mess with a single recursive plan instance that tracks direct invocation forks as well as lifecycle forks. All unit tests run, and I'm running integration tests now, to see if this fixes it0013.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@541938 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.maven.lifecycle.LifecycleLoaderException;
-import org.apache.maven.lifecycle.LifecycleUtils;
-import org.apache.maven.lifecycle.binding.LifecycleBindingManager;
-import org.apache.maven.lifecycle.model.LifecycleBindings;
-import org.apache.maven.project.MavenProject;
+import java.util.Stack;
- * Collection of static utility methods used to work with LifecycleBindings and other collections
- * of MojoBinding instances that make up a build plan.
+ * Collection of static utility methods used to work with LifecycleBindings and other collections of MojoBinding
+ * instances that make up a build plan.
-     * Inject a set of {@link BuildPlanModifier} instances into an existing LifecycleBindings instance.
-     * This is a generalization of a piece of code present in almost all scenarios where a build
-     * plan contains modifiers and is asked to produce an effective list of MojoBinding instances
-     * that make up the build process. Simply iterate through the modifiers, and apply each one,
-     * replacing the previous LifecycleBindings instance with the result of the current modifier.
+     * Render an entire build plan to a String. If extendedInfo == true, include each MojoBinding's configuration in the
+     * output.
-    public static LifecycleBindings modifyPlanBindings( LifecycleBindings bindings, List planModifiers )
-        throws LifecyclePlannerException
+    public static String listBuildPlan( final BuildPlan plan, final boolean extendedInfo )
+        throws LifecycleSpecificationException, LifecyclePlannerException
-        LifecycleBindings result;
+        List mojos = plan.renderExecutionPlan( new Stack() );
+        plan.resetExecutionProgress();
-        // if the bindings are completely empty, passing in null avoids an extra instance creation 
-        // for the purposes of cloning...
-        if ( bindings != null )
-        {
-            result = LifecycleUtils.cloneBindings( bindings );
-        }
-        else
-        {
-            result = new LifecycleBindings();
-        }
-
-        for ( Iterator it = planModifiers.iterator(); it.hasNext(); )
-        {
-            BuildPlanModifier modifier = (BuildPlanModifier) it.next();
-
-            result = modifier.modifyBindings( result );
-        }
-
-        return result;
+        return listBuildPlan( mojos, extendedInfo );
-     * Render an entire build plan to a String.
-     * If extendedInfo == true, include each MojoBinding's configuration in the output.
+     * Render a list containing the MojoBinding instances for an entire build plan to a String. If extendedInfo == true,
+     * include each MojoBinding's configuration in the output.
-    public static String listBuildPlan( BuildPlan plan, MavenProject project, LifecycleBindingManager lifecycleBindingManager, boolean extendedInfo )
-        throws LifecycleSpecificationException, LifecyclePlannerException, LifecycleLoaderException
-    {
-        List mojoBindings = plan.getPlanMojoBindings( project, lifecycleBindingManager );
-
-        return listBuildPlan( mojoBindings, extendedInfo );
-    }
-
-    /**
-     * Render a list containing the MojoBinding instances for an entire build plan to a String.
-     * If extendedInfo == true, include each MojoBinding's configuration in the output.
-     */
-    public static String listBuildPlan( List mojoBindings, boolean extendedInfo )
+    public static String listBuildPlan( final List mojoBindings, final boolean extendedInfo )
-                
+
-     * Append a newline character, add the next line's number, and indent the new line to the
-     * appropriate level (which tracks separate forked executions).
+     * Append a newline character, add the next line's number, and indent the new line to the appropriate level (which
+     * tracks separate forked executions).
-    private static void newListingLine( StringBuffer listing, int indentLevel, int counter )
+    private static void newListingLine( final StringBuffer listing, final int indentLevel, final int counter )
-     * Format a single MojoBinding for inclusion in a build plan listing. If extendedInfo == true,
-     * include the MojoBinding's configuration in the output.
+     * Format a single MojoBinding for inclusion in a build plan listing. If extendedInfo == true, include the
+     * MojoBinding's configuration in the output.
-    public static String formatMojoListing( MojoBinding binding, int indentLevel, boolean extendedInfo )
+    public static String formatMojoListing( final MojoBinding binding, final int indentLevel, final boolean extendedInfo )
-                                                             String.valueOf( binding.getConfiguration() ).replaceAll( "\\n",
+                                                             String.valueOf( binding.getConfiguration() ).replaceAll(
+                                                                                                                      "\\n",

MOV26 UPD40 UPD66 UPD66 INS83 INS83 INS21 INS83 MOV43 INS83 INS83 INS83 INS83 INS83 INS83 INS83 UPD66 UPD66 MOV43 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 INS42 INS42 UPD42 UPD42 INS14 INS43 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43
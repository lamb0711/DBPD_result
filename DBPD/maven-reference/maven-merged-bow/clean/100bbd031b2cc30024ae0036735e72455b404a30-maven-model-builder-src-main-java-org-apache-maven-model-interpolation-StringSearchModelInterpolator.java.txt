o Optimized the cache around the hotspot in interpolation somewhat

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@1376085 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.model.building.ModelProblem.Version;
+import org.apache.maven.model.building.ModelProblemCollectorRequest;
-import org.apache.maven.model.building.ModelProblem;
-import org.apache.maven.model.building.ModelProblem.Version;
-import org.apache.maven.model.building.ModelProblemCollectorRequest;
-    private static final Map<Class<?>, Field[]> fieldsByClass =
-            new ConcurrentHashMap<Class<?>, Field[]>( 80, 0.75f, 2 );  // Empirical data from 3.x, actual =40
-    private static final Map<Class<?>, Boolean> fieldIsPrimitiveByClass =
-            new ConcurrentHashMap<Class<?>, Boolean>( 62, 0.75f, 2 ); // Empirical data from 3.x, actual 31
+    private static final Map<Class<?>, InterpolateObjectAction.CacheItem> cachedEntries =
+        new ConcurrentHashMap<Class<?>, InterpolateObjectAction.CacheItem>( 80, 0.75f, 2 );
+        // Empirical data from 3.x, actual =40
+
-            List<? extends InterpolationPostProcessor> postProcessors = createPostProcessors( model, projectDir,
-                                                                                              config );
+            List<? extends InterpolationPostProcessor> postProcessors =
+                createPostProcessors( model, projectDir, config );
+
+
+
+
+
+        private String interpolate( String value )
+        {
+            return modelInterpolator.interpolateInternal( value, valueSources, postProcessors, problems );
+        }
+
-            if ( cls.isArray() )
+            CacheItem cacheEntry = getCacheEntry( cls );
+            if ( cacheEntry.isArray() )
-                evaluateArray( target );
+                evaluateArray( target, this );
-            else if ( isQualifiedForInterpolation( cls ) )
+            else if ( cacheEntry.isQualifiedForInterpolation )
-                for ( Field currentField : getFields( cls ) )
-                {
-                    Class<?> type = currentField.getType();
-                    if ( isQualifiedForInterpolation( currentField, type ) )
-                    {
-                        synchronized ( currentField )
-                        {
-                            interpolateField( cls, target, currentField, type );
-                        }
-                    }
-                }
+                cacheEntry.interpolate( target, problems, this );
-        private void interpolateField( Class<?> cls, Object target, Field field, Class<?> type )
+
+        private CacheItem getCacheEntry( Class<?> cls )
-            boolean isAccessible = field.isAccessible();
-            field.setAccessible( true );
-            try
+            CacheItem cacheItem = cachedEntries.get( cls );
+            if ( cacheItem == null )
-                if ( String.class == type )
-                {
-                    interpolateStringField( target, field );
-                }
-                else if ( Collection.class.isAssignableFrom( type ) )
-                {
-                    interpolateCollectionField( target, field );
-                }
-                else if ( Map.class.isAssignableFrom( type ) )
-                {
-                    interpolateMapField( target, field );
-                }
-                else
-                {
-                    Object value = field.get( target );
-                    if ( value != null )
-                    {
-                        if ( field.getType().isArray() )
-                        {
-                            evaluateArray( value );
-                        }
-                        else
-                        {
-                            interpolationTargets.add( value );
-                        }
-                    }
-                }
+                cacheItem = new CacheItem( cls );
+                cachedEntries.put( cls, cacheItem );
-            catch ( IllegalArgumentException e )
-            {
-                problems.add( new ModelProblemCollectorRequest( Severity.ERROR, Version.BASE)
-                        .setMessage( "Failed to interpolate field3: " + field + " on class: " + cls.getName())
-                        .setException(e));
-            }
-            catch ( IllegalAccessException e )
-            {
-                problems.add( new ModelProblemCollectorRequest( Severity.ERROR, Version.BASE)
-                        .setMessage( "Failed to interpolate field4: " + field + " on class: " + cls.getName())
-                        .setException(e));
-            }
-            finally
-            {
-                field.setAccessible( isAccessible );
-            }
-        }
-
-        private void interpolateStringField( Object target, Field field )
-            throws IllegalAccessException
-        {
-            String value = (String) field.get( target );
-            if ( value == null || Modifier.isFinal( field.getModifiers() ) )
-            {
-                return;
-            }
-
-            String interpolated =
-                modelInterpolator.interpolateInternal( value, valueSources, postProcessors, problems );
-
-            if ( !interpolated.equals( value ) )
-            {
-                field.set( target, interpolated );
-            }
-        }
-
-        private void interpolateCollectionField( Object target, Field field )
-            throws IllegalAccessException
-        {
-            @SuppressWarnings( "unchecked" )
-            Collection<Object> c = (Collection<Object>) field.get( target );
-            if ( c == null || c.isEmpty() )
-            {
-                return;
-            }
-
-            List<Object> originalValues = new ArrayList<Object>( c );
-            try
-            {
-                c.clear();
-            }
-            catch ( UnsupportedOperationException e )
-            {
-                return;
-            }
-
-            for ( Object value : originalValues )
-            {
-                if ( value == null )
-                {
-                    // add the null back in...not sure what else to do...
-                    c.add( value );
-                }
-                else if ( String.class == value.getClass() )
-                {
-                    String interpolated =
-                        modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, problems );
-
-                    if ( !interpolated.equals( value ) )
-                    {
-                        c.add( interpolated );
-                    }
-                    else
-                    {
-                        c.add( value );
-                    }
-                }
-                else
-                {
-                    c.add( value );
-                    if ( value.getClass().isArray() )
-                    {
-                        evaluateArray( value );
-                    }
-                    else
-                    {
-                        interpolationTargets.add( value );
-                    }
-                }
-            }
-        }
-
-        private void interpolateMapField( Object target, Field field )
-            throws IllegalAccessException
-        {
-            @SuppressWarnings( "unchecked" )
-            Map<Object, Object> m = (Map<Object, Object>) field.get( target );
-            if ( m == null || m.isEmpty() )
-            {
-                return;
-            }
-
-            for ( Map.Entry<Object, Object> entry : m.entrySet() )
-            {
-                Object value = entry.getValue();
-
-                if ( value == null )
-                {
-                    continue;
-                }
-
-                if ( String.class == value.getClass() )
-                {
-                    String interpolated =
-                        modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, problems );
-
-                    if ( !interpolated.equals( value ) )
-                    {
-                        try
-                        {
-                            entry.setValue( interpolated );
-                        }
-                        catch ( UnsupportedOperationException e )
-                        {
-                            continue;
-                        }
-                    }
-                }
-                else if ( value.getClass().isArray() )
-                {
-                    evaluateArray( value );
-                }
-                else
-                {
-                    interpolationTargets.add( value );
-                }
-            }
-        }
-
-        private Field[] getFields( Class<?> cls )
-        {
-            Field[] fields = fieldsByClass.get( cls );
-            if ( fields == null )
-            {
-                fields = cls.getDeclaredFields();
-                fieldsByClass.put( cls, fields );
-            }
-            return fields;
+            return cacheItem;
-            Boolean primitive = fieldIsPrimitiveByClass.get( fieldType );
-            if ( primitive == null )
-            {
-                primitive = fieldType.isPrimitive();
-                fieldIsPrimitiveByClass.put( fieldType, primitive );
-            }
-
-            if ( primitive )
+            if ( fieldType.isPrimitive() )
-        private void evaluateArray( Object target )
+        private static void evaluateArray( Object target, InterpolateObjectAction ctx )
-                        String interpolated =
-                            modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors,
-                                                                   problems );
+                        String interpolated = ctx.interpolate( (String) value );
-                        interpolationTargets.add( value );
+                        ctx.interpolationTargets.add( value );
+
+        private static class CacheItem
+        {
+            private final boolean isArray;
+
+            private final boolean isQualifiedForInterpolation;
+
+            private final CacheField[] fields;
+
+            private boolean isQualifiedForInterpolation( Class<?> cls )
+            {
+                return !cls.getName().startsWith( "java" );
+            }
+
+            private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )
+            {
+                if ( Map.class.equals( fieldType ) && "locations".equals( field.getName() ) )
+                {
+                    return false;
+                }
+
+                if ( fieldType.isPrimitive() )
+                {
+                    return false;
+                }
+
+                return !"parent".equals( field.getName() );
+            }
+
+            CacheItem( Class clazz )
+            {
+                this.isQualifiedForInterpolation = isQualifiedForInterpolation( clazz );
+                this.isArray = clazz.isArray();
+                List<CacheField> fields = new ArrayList<CacheField>();
+                for ( Field currentField : clazz.getDeclaredFields() )
+                {
+                    Class<?> type = currentField.getType();
+                    if ( isQualifiedForInterpolation( currentField, type ) )
+                    {
+                        if ( String.class == type )
+                        {
+                            if ( !Modifier.isFinal( currentField.getModifiers() ) )
+                            {
+                                fields.add( new StringField( currentField ) );
+                            }
+                        }
+                        else if ( Collection.class.isAssignableFrom( type ) )
+                        {
+                            fields.add( new CollectionField( currentField ) );
+                        }
+                        else if ( Map.class.isAssignableFrom( type ) )
+                        {
+                            fields.add( new MapField( currentField ) );
+                        }
+                        else
+                        {
+                            fields.add( new ObjectField( currentField ) );
+                        }
+                    }
+
+                }
+                this.fields = fields.toArray( new CacheField[fields.size()] );
+
+            }
+
+            public void interpolate( Object target, ModelProblemCollector problems,
+                                     InterpolateObjectAction interpolateObjectAction )
+            {
+                for ( CacheField field : fields )
+                {
+                    field.interpolate( target, problems, interpolateObjectAction );
+                }
+            }
+
+            public boolean isArray()
+            {
+                return isArray;
+            }
+        }
+
+        static abstract class CacheField
+        {
+            protected final Field field;
+
+            CacheField( Field field )
+            {
+                this.field = field;
+            }
+
+            void interpolate( Object target, ModelProblemCollector problems,
+                              InterpolateObjectAction interpolateObjectAction )
+            {
+                synchronized ( field )
+                {
+                    boolean isAccessible = field.isAccessible();
+                    field.setAccessible( true );
+                    try
+                    {
+                        doInterpolate( target, interpolateObjectAction );
+                    }
+                    catch ( IllegalArgumentException e )
+                    {
+                        interpolateObjectAction.problems.add(
+                            new ModelProblemCollectorRequest( Severity.ERROR, Version.BASE ).setMessage(
+                                "Failed to interpolate field3: " + field + " on class: "
+                                    + field.getType().getName() ).setException(
+                                e ) ); // todo: Not entirely the same message
+                    }
+                    catch ( IllegalAccessException e )
+                    {
+                        interpolateObjectAction.problems.add(
+                            new ModelProblemCollectorRequest( Severity.ERROR, Version.BASE ).setMessage(
+                                "Failed to interpolate field4: " + field + " on class: "
+                                    + field.getType().getName() ).setException( e ) );
+                    }
+                    finally
+                    {
+                        field.setAccessible( isAccessible );
+                    }
+                }
+
+
+            }
+
+            abstract void doInterpolate( Object target, InterpolateObjectAction ctx )
+                throws IllegalAccessException;
+        }
+
+        static final class StringField
+            extends CacheField
+        {
+            StringField( Field field )
+            {
+                super( field );
+            }
+
+            @Override
+            void doInterpolate( Object target, InterpolateObjectAction ctx )
+                throws IllegalAccessException
+            {
+                String value = (String) field.get( target );
+                if ( value == null )
+                {
+                    return;
+                }
+
+                String interpolated = ctx.interpolate( value );
+
+                if ( !interpolated.equals( value ) )
+                {
+                    field.set( target, interpolated );
+                }
+            }
+        }
+
+        static final class CollectionField
+            extends CacheField
+        {
+            CollectionField( Field field )
+            {
+                super( field );
+            }
+
+            @Override
+            void doInterpolate( Object target, InterpolateObjectAction ctx )
+                throws IllegalAccessException
+            {
+                @SuppressWarnings( "unchecked" ) Collection<Object> c = (Collection<Object>) field.get( target );
+                if ( c == null || c.isEmpty() )
+                {
+                    return;
+                }
+
+                List<Object> originalValues = new ArrayList<Object>( c );
+                try
+                {
+                    c.clear();
+                }
+                catch ( UnsupportedOperationException e )
+                {
+                    return;
+                }
+
+                for ( Object value : originalValues )
+                {
+                    if ( value == null )
+                    {
+                        // add the null back in...not sure what else to do...
+                        c.add( value );
+                    }
+                    else if ( String.class == value.getClass() )
+                    {
+                        String interpolated = ctx.interpolate( (String) value );
+
+                        if ( !interpolated.equals( value ) )
+                        {
+                            c.add( interpolated );
+                        }
+                        else
+                        {
+                            c.add( value );
+                        }
+                    }
+                    else
+                    {
+                        c.add( value );
+                        if ( value.getClass().isArray() )
+                        {
+                            evaluateArray( value, ctx );
+                        }
+                        else
+                        {
+                            ctx.interpolationTargets.add( value );
+                        }
+                    }
+                }
+            }
+        }
+
+        static final class MapField
+            extends CacheField
+        {
+            MapField( Field field )
+            {
+                super( field );
+            }
+
+            @Override
+            void doInterpolate( Object target, InterpolateObjectAction ctx )
+                throws IllegalAccessException
+            {
+                @SuppressWarnings( "unchecked" ) Map<Object, Object> m = (Map<Object, Object>) field.get( target );
+                if ( m == null || m.isEmpty() )
+                {
+                    return;
+                }
+
+                for ( Map.Entry<Object, Object> entry : m.entrySet() )
+                {
+                    Object value = entry.getValue();
+
+                    if ( value == null )
+                    {
+                        continue;
+                    }
+
+                    if ( String.class == value.getClass() )
+                    {
+                        String interpolated = ctx.interpolate( (String) value );
+
+                        if ( !interpolated.equals( value ) )
+                        {
+                            try
+                            {
+                                entry.setValue( interpolated );
+                            }
+                            catch ( UnsupportedOperationException e )
+                            {
+                                continue;
+                            }
+                        }
+                    }
+                    else if ( value.getClass().isArray() )
+                    {
+                        evaluateArray( value, ctx );
+                    }
+                    else
+                    {
+                        ctx.interpolationTargets.add( value );
+                    }
+                }
+            }
+        }
+
+        static final class ObjectField
+            extends CacheField
+        {
+            private final boolean isArray;
+
+            ObjectField( Field field )
+            {
+                super( field );
+                this.isArray = field.getType().isArray();
+            }
+
+            @Override
+            void doInterpolate( Object target, InterpolateObjectAction ctx )
+                throws IllegalAccessException
+            {
+                Object value = field.get( target );
+                if ( value != null )
+                {
+                    if ( isArray )
+                    {
+                        evaluateArray( value, ctx );
+                    }
+                    else
+                    {
+                        ctx.interpolationTargets.add( value );
+                    }
+                }
+            }
+        }
+

MOV26 MOV26 UPD74 INS31 INS31 INS31 INS31 INS55 INS55 INS55 INS55 INS55 INS55 INS43 UPD42 MOV83 MOV43 INS42 INS44 INS8 INS83 MOV39 MOV42 MOV44 MOV44 INS8 INS83 INS43 INS42 MOV44 INS8 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 INS8 INS83 INS44 INS83 INS83 INS42 INS23 INS23 INS23 INS31 MOV31 INS31 INS31 INS31 INS83 INS83 INS42 INS23 INS31 INS31 INS31 INS83 INS83 INS42 INS43 INS31 MOV31 INS83 INS83 INS42 INS43 INS31 MOV31 INS83 INS83 INS42 INS43 INS31 MOV31 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS40 UPD74 INS43 INS42 INS41 MOV25 INS60 INS25 INS42 INS60 MOV25 INS41 UPD42 INS25 INS25 INS41 INS43 INS42 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS5 INS59 INS83 INS39 INS42 INS44 INS8 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS83 MOV43 INS59 INS42 MOV44 INS8 INS39 INS42 MOV44 INS44 INS44 INS8 UPD83 MOV83 INS39 INS42 INS44 MOV44 INS43 INS42 INS42 MOV44 INS8 INS78 UPD42 INS44 INS42 INS42 INS44 INS8 INS78 INS42 INS44 INS42 INS42 INS44 INS8 INS78 UPD42 INS44 INS42 INS83 INS83 INS39 INS59 INS42 MOV44 INS8 INS78 INS39 INS42 INS44 INS44 INS43 INS8 INS43 INS42 MOV32 INS43 INS59 MOV32 MOV8 INS25 INS43 INS59 INS27 INS42 INS27 INS8 INS32 INS8 INS38 INS42 INS42 INS42 INS43 INS85 INS42 INS74 INS42 INS41 INS43 INS42 INS21 INS21 INS60 INS70 INS21 INS43 INS42 INS43 INS42 INS43 INS42 INS70 INS41 INS42 INS21 INS43 INS42 INS43 INS42 INS51 INS43 INS42 INS43 UPD42 INS42 INS46 INS42 INS43 INS42 INS43 INS42 INS46 INS42 INS43 INS42 INS43 INS42 INS46 INS42 INS43 INS42 INS42 INS46 MOV21 INS42 INS43 INS42 INS43 INS42 INS42 MOV60 INS25 INS40 INS42 INS42 INS32 UPD42 INS40 INS8 INS42 INS42 INS32 INS42 INS33 INS21 MOV21 INS32 INS32 INS41 INS42 INS42 INS41 INS32 INS42 INS43 INS76 INS38 MOV32 INS42 INS7 INS7 INS74 INS59 MOV44 INS32 INS8 INS7 INS42 INS42 INS42 INS44 INS42 INS8 INS42 INS7 INS42 INS42 INS42 INS8 INS42 UPD42 MOV42 INS42 INS42 MOV27 INS43 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS8 INS42 INS42 INS21 MOV21 INS42 UPD42 MOV42 MOV42 INS7 INS57 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS32 INS9 INS9 INS45 INS42 INS32 INS42 INS32 INS22 INS32 INS22 INS32 INS43 INS43 INS42 INS14 INS42 INS42 MOV60 INS25 INS22 INS32 INS43 INS42 INS21 INS22 INS42 MOV60 MOV21 INS54 INS42 INS32 INS22 MOV32 INS25 INS52 INS32 INS42 INS14 UPD42 UPD42 UPD42 UPD42 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS74 MOV32 INS8 INS52 INS42 INS42 INS42 INS3 INS42 INS32 INS52 INS42 INS8 MOV12 MOV12 MOV8 INS42 INS42 INS42 INS52 INS42 INS42 INS8 INS8 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS52 INS43 INS42 INS42 INS42 INS42 INS43 INS43 INS25 INS5 INS32 INS42 INS42 INS42 INS42 INS42 INS21 MOV32 MOV21 INS21 INS42 MOV60 INS42 INS42 MOV27 INS8 MOV25 INS43 INS85 INS42 INS42 INS32 INS60 INS32 INS25 MOV32 INS25 INS42 INS42 INS42 INS42 MOV43 INS59 MOV32 UPD42 UPD42 UPD42 INS40 INS42 INS42 INS40 INS38 MOV8 MOV32 MOV8 MOV8 INS40 INS40 INS42 INS32 UPD42 UPD42 INS42 INS40 UPD42 UPD42 INS32 INS42 INS42 MOV11 INS42 INS42 INS32 UPD42 UPD42 INS14 MOV14 MOV14 INS42 INS40 INS42 INS42 UPD42 UPD42 INS14 INS43 INS42 UPD42 UPD42 INS14 UPD42 INS14 INS43 INS42 INS42 INS43 INS42 INS43 INS42 INS32 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 DEL40 DEL26 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL43 DEL74 DEL34 DEL34 DEL34 DEL14 DEL59 DEL23 DEL42 DEL42 DEL8 DEL51 DEL32 DEL32 DEL8 DEL70 DEL8 DEL25 DEL25 DEL8 DEL31 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL54 DEL8 DEL31 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL76 DEL74 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL83 DEL42 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42
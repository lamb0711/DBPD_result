o swapping the branch to trunk


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@779660 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.Reader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.Properties;
-
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
+import java.util.Map.Entry;
-import org.apache.maven.model.PomClassicDomainModel;
-import org.apache.maven.model.ProjectUri;
+import org.apache.maven.model.io.ModelReader;
+import org.apache.maven.model.io.ModelWriter;
+import org.codehaus.plexus.component.annotations.Requirement;
+import org.codehaus.plexus.util.IOUtil;
+import org.codehaus.plexus.util.ReaderFactory;
+import org.codehaus.plexus.util.xml.pull.MXParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParser;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
-@Component(role=Interpolator.class)
-public class DefaultInterpolator implements Interpolator {
-	
-	public String interpolateXmlString(String xml,
-			List<InterpolatorProperty> interpolatorProperties) throws IOException 
-	{
-        List<ModelProperty> modelProperties = marshallXmlToModelProperties( new ByteArrayInputStream( xml.getBytes() ), ProjectUri.baseUri, URIS );
+@Component(role = Interpolator.class)
+public class DefaultInterpolator
+    implements Interpolator
+{
-        Map<String, String> aliases = new HashMap<String, String>();
-        aliases.put( "project.", "pom." );
+    @Requirement
+    private ModelReader modelReader;
-        List<InterpolatorProperty> ips = new ArrayList<InterpolatorProperty>( interpolatorProperties );
-        ips.addAll( createInterpolatorProperties( modelProperties, ProjectUri.baseUri, aliases, PomInterpolatorTag.PROJECT_PROPERTIES.name()) );
+    @Requirement
+    private ModelWriter modelWriter;
+
+    public Model interpolateModel( Model model, Properties properties, File projectDirectory )
+        throws IOException
+    {
+        if ( model == null )
+        {
+            throw new IllegalArgumentException( "model: null" );
+        }
+        
+        if(properties == null)
+        {
+        	properties = new Properties();
+        }
+        
+        List<InterpolatorProperty>  interpolatorProperties = new ArrayList<InterpolatorProperty>();
+        for ( Entry<Object, Object> e : properties.entrySet() )
+        {
+            interpolatorProperties.add( new InterpolatorProperty( "${" + e.getKey() + "}", (String) e.getValue(),
+                                                                  PomInterpolatorTag.EXECUTION_PROPERTIES.toString() ) );
+        }
+
+        if ( !containsProjectVersion( interpolatorProperties ) )
+        {
+            aliases.put( "\\$\\{project.version\\}", "\\$\\{version\\}" );
+        }
+        //TODO: Insert customized logic for parsing
+        List<ModelProperty> modelProperties = getModelProperties( model );
+
+        if ( "jar".equals( model.getPackaging() ) )
+        {
+            modelProperties.add( new ModelProperty( ProjectUri.packaging, "jar" ) );
+        }
+
+        List<ModelProperty> firstPassModelProperties = new ArrayList<ModelProperty>();
+        List<ModelProperty> secondPassModelProperties = new ArrayList<ModelProperty>();
+
+        ModelProperty buildProperty = new ModelProperty( ProjectUri.Build.xUri, null );
+
+        for ( ModelProperty mp : modelProperties )
+        {
+            if ( mp.getValue() != null && !mp.getUri().contains( "#property" ) && !mp.getUri().contains( "#collection" ) )
+            {
+                if ( ( !buildProperty.isParentOf( mp ) && !mp.getUri().equals( ProjectUri.Reporting.outputDirectory ) || mp.getUri().equals( ProjectUri.Build.finalName ) ) )
+                {
+                    firstPassModelProperties.add( mp );
+                }
+                else
+                {
+                    secondPassModelProperties.add( mp );
+                }
+            }
+        }
+
+        List<InterpolatorProperty> standardInterpolatorProperties = new ArrayList<InterpolatorProperty>();
+
+        String basedir = null;
+        if ( projectDirectory != null )
+        {
+            basedir = projectDirectory.getAbsolutePath();
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${project.basedir}", basedir,
+                                                                          PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${basedir}", basedir,
+                                                                          PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${pom.basedir}", basedir,
+                                                                          PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+
+            String baseuri = projectDirectory.toURI().toString();
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${project.baseUri}", baseuri,
+                                                                          PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${pom.baseUri}", baseuri,
+                                                                          PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+        }
-                ips.add( new InterpolatorProperty( "${" + uri.substring( uri.lastIndexOf( "/" ) + 1, uri.length() ) + "}", mp.getValue() ) );
+                standardInterpolatorProperties.add( new InterpolatorProperty( "${" + uri.substring( uri.lastIndexOf( "/" ) + 1, uri.length() ) + "}", mp.getValue(),
+                                                                              PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
-        interpolateModelProperties( modelProperties, ips );
-        return unmarshalModelPropertiesToXml( modelProperties, ProjectUri.baseUri );
-	} 
-	
-    public PomClassicDomainModel interpolateDomainModel( PomClassicDomainModel dm, List<InterpolatorProperty> interpolatorProperties )
-		throws IOException {
-	
-		if (dm == null) {
-			throw new IllegalArgumentException("dm: null");
-		}
-		if (!containsProjectVersion(interpolatorProperties)) {
-			aliases.put("\\$\\{project.version\\}", "\\$\\{version\\}");
-		}
-		//TODO: Insert customized logic for parsing
-		List<ModelProperty> modelProperties = getModelProperties(dm.getInputStream());
-	
-		if ("jar".equals(dm.getModel().getPackaging())) {
-			modelProperties.add(new ModelProperty(ProjectUri.packaging, "jar"));
-		}
-	
-		List<ModelProperty> firstPassModelProperties = new ArrayList<ModelProperty>();
-		List<ModelProperty> secondPassModelProperties = new ArrayList<ModelProperty>();
-	
-		ModelProperty buildProperty = new ModelProperty(ProjectUri.Build.xUri,
-				null);
-	
-	    for ( ModelProperty mp : modelProperties )
-	    {
-	        if ( mp.getValue() != null && !mp.getUri().contains( "#property" ) && !mp.getUri().contains( "#collection" ) )
-	        {
-	            if ( ( !buildProperty.isParentOf( mp ) && !mp.getUri().equals( ProjectUri.Reporting.outputDirectory ) || mp.getUri().equals(
-	                                                                                                                                         ProjectUri.Build.finalName ) ) )
-	            {
-	                firstPassModelProperties.add( mp );
-	            }
-	            else
-	            {
-	                secondPassModelProperties.add( mp );
-	            }
-	        }
-	    }
-	
-		List<InterpolatorProperty> standardInterpolatorProperties = new ArrayList<InterpolatorProperty>();
-	
-		if (dm.isPomInBuild()) {
-			String basedir = dm.getProjectDirectory().getAbsolutePath();
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${project.basedir}", basedir,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${basedir}", basedir,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${pom.basedir}", basedir,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-	
-			String baseuri = dm.getProjectDirectory().toURI().toString();
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${project.baseUri}", baseuri,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${pom.baseUri}", baseuri,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-		}
-	
-		for (ModelProperty mp : modelProperties) {
-			if (mp.getUri().startsWith(ProjectUri.properties)
-					&& mp.getValue() != null) {
-				String uri = mp.getUri();
-				standardInterpolatorProperties.add(new InterpolatorProperty(
-						"${"
-								+ uri.substring(uri.lastIndexOf("/") + 1, uri
-										.length()) + "}", mp.getValue(),
-						PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			}
-		}
-	
-		// FIRST PASS - Withhold using build directories as interpolator
-		// properties
-		List<InterpolatorProperty> ips1 = new ArrayList<InterpolatorProperty>(
-				interpolatorProperties);
-		ips1.addAll(standardInterpolatorProperties);
-		ips1.addAll(createInterpolatorProperties(
-				firstPassModelProperties, ProjectUri.baseUri, aliases,
-				PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-		Collections.sort(ips1, new Comparator<InterpolatorProperty>() {
-			public int compare(InterpolatorProperty o, InterpolatorProperty o1) {
-				if (o.getTag() == null || o1.getTag() == null) {
-					return 0;
-				}
-				return PomInterpolatorTag.valueOf(o.getTag()).compareTo(
-						PomInterpolatorTag.valueOf(o1.getTag()));
-			}
-		});
-	
-		interpolateModelProperties(modelProperties, ips1);
-	
-		// SECOND PASS - Set absolute paths on build directories
-		if (dm.isPomInBuild()) {
-			String basedir = dm.getProjectDirectory().getAbsolutePath();
-			Map<ModelProperty, ModelProperty> buildDirectories = new HashMap<ModelProperty, ModelProperty>();
-			for (ModelProperty mp : secondPassModelProperties) {
-				if (mp.getUri().startsWith(ProjectUri.Build.xUri)
-						|| mp.getUri().equals(
-								ProjectUri.Reporting.outputDirectory)) {
-					File file = new File(mp.getResolvedValue());
-					if (!file.isAbsolute()
-							&& !mp.getResolvedValue().startsWith(
-									"${project.build.")
-							&& !mp.getResolvedValue().equals(
-									"${project.basedir}")) {
-						buildDirectories.put(mp, new ModelProperty(mp.getUri(),
-								new File(basedir, file.getPath())
-										.getAbsolutePath()));
-					}
-				}
-			}
-			for (Map.Entry<ModelProperty, ModelProperty> e : buildDirectories
-					.entrySet()) {
-				secondPassModelProperties.remove(e.getKey());
-				secondPassModelProperties.add(e.getValue());
-			}
-		}
-	
-		// THIRD PASS - Use build directories as interpolator properties
-		List<InterpolatorProperty> ips2 = new ArrayList<InterpolatorProperty>(
-				interpolatorProperties);
-		ips2.addAll(standardInterpolatorProperties);
-		ips2.addAll(createInterpolatorProperties(
-				secondPassModelProperties, ProjectUri.baseUri, aliases,
-				PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-		ips2.addAll(interpolatorProperties);
-		Collections.sort(ips2, new Comparator<InterpolatorProperty>() {
-			public int compare(InterpolatorProperty o, InterpolatorProperty o1) {
-				if (o.getTag() == null || o1.getTag() == null) {
-					return 0;
-				}
-	
-				return PomInterpolatorTag.valueOf(o.getTag()).compareTo(
-						PomInterpolatorTag.valueOf(o1.getTag()));
-			}
-		});
-	
-		interpolateModelProperties(modelProperties, ips2);
-		
-	    try
-	    {
-	        String xml = unmarshalModelPropertiesToXml( modelProperties, ProjectUri.baseUri );
-	        PomClassicDomainModel domainModel = new PomClassicDomainModel( new ByteArrayInputStream ( xml.getBytes( "UTF-8" )));
-	    	if ( dm.getProjectDirectory() != null )
-	    	{
-	    		alignPaths(domainModel.getModel(), dm.getProjectDirectory());
-	    	}
-	    	return domainModel;
-	    }
-	    catch ( IOException e )
-	    {
-	        throw new IllegalStateException( "Unmarshalling of model properties failed", e );
-	    }
-	    
-		
-		
-	    /*
-		for(ModelProperty mp : modelProperties)
-		{
-			if((mp.getValue() != null) && !mp.getValue().equals(mp.getResolvedValue()))
-			{
-				if(mp.getUri().equals(ProjectUri.version))
-				{
-					
-				}
-			}
-		}
-		*/
-	}
+        // FIRST PASS - Withhold using build directories as interpolator
+        // properties
+        List<InterpolatorProperty> ips1 = new ArrayList<InterpolatorProperty>( interpolatorProperties );
+        ips1.addAll( standardInterpolatorProperties );
+        ips1.addAll( createInterpolatorProperties( firstPassModelProperties, ProjectUri.baseUri, aliases, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+        Collections.sort( ips1, new Comparator<InterpolatorProperty>()
+        {
+            public int compare( InterpolatorProperty o, InterpolatorProperty o1 )
+            {
+                if ( o.getTag() == null || o1.getTag() == null )
+                {
+                    return 0;
+                }
+                return PomInterpolatorTag.valueOf( o.getTag() ).compareTo( PomInterpolatorTag.valueOf( o1.getTag() ) );
+            }
+        } );
+
+        interpolateModelProperties( modelProperties, ips1 );
+
+        Map<ModelProperty, ModelProperty> buildDirectories = new HashMap<ModelProperty, ModelProperty>();
+        for ( ModelProperty mp : secondPassModelProperties )
+        {
+        	if ( mp.getUri().startsWith( ProjectUri.Build.xUri ) || mp.getUri().equals( ProjectUri.Reporting.outputDirectory ) )
+        	{
+        		File file = new File( mp.getResolvedValue() );
+        		if ( !file.isAbsolute() && !mp.getResolvedValue().startsWith( "${project.build." )
+                    && !mp.getResolvedValue().equals( "${project.basedir}" ) && basedir != null )
+        		{
+        			buildDirectories.put( mp, new ModelProperty( mp.getUri(), new File( basedir, file.getPath() ).getAbsolutePath() ) );
+        		}
+        	}
+        }
+        for ( Map.Entry<ModelProperty, ModelProperty> e : buildDirectories.entrySet() )
+        {
+        	secondPassModelProperties.remove( e.getKey() );
+        	secondPassModelProperties.add( e.getValue() );
+        }
+
+
+        // THIRD PASS - Use build directories as interpolator properties
+        List<InterpolatorProperty> ips2 = new ArrayList<InterpolatorProperty>( interpolatorProperties );
+        ips2.addAll( standardInterpolatorProperties );
+        ips2.addAll( createInterpolatorProperties( secondPassModelProperties, ProjectUri.baseUri, aliases, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+        ips2.addAll( interpolatorProperties );
+        Collections.sort( ips2, new Comparator<InterpolatorProperty>()
+        {
+            public int compare( InterpolatorProperty o, InterpolatorProperty o1 )
+            {
+                if ( o.getTag() == null || o1.getTag() == null )
+                {
+                    return 0;
+                }
+
+                return PomInterpolatorTag.valueOf( o.getTag() ).compareTo( PomInterpolatorTag.valueOf( o1.getTag() ) );
+            }
+        } );
+
+        interpolateModelProperties( modelProperties, ips2 );
+
+        try
+        {
+            String xml = unmarshalModelPropertiesToXml( modelProperties, ProjectUri.baseUri );
+            Model m = modelReader.read( new StringReader( xml ), null );
+            if ( projectDirectory != null )
+            {
+                alignPaths( m, projectDirectory );
+            }
+            return m;
+        }
+        catch ( IOException e )
+        {
+            throw new IllegalStateException( "Unmarshalling of model properties failed", e );
+        }
+    }
+
-     * Post-processes the paths of build directories by aligning relative paths to the project directory and normalizing
-     * file separators to the platform-specific separator.
+     * Post-processes the paths of build directories by aligning relative paths to the project
+     * directory and normalizing file separators to the platform-specific separator.
-    
-    private static String getAlignedPathFor(String path, File basedir)
+
+    private static String getAlignedPathFor( String path, File basedir )
-        }   
+        }
-    }	
-	private static void interpolateModelProperties(List<ModelProperty> modelProperties, 
-	        List<InterpolatorProperty> interpolatorProperties )
-	{
-		if (modelProperties == null) {
-			throw new IllegalArgumentException("modelProperties: null");
-		}
-	
-		if (interpolatorProperties == null) {
-			throw new IllegalArgumentException("interpolatorProperties: null");
-		}
-	
-		List<ModelProperty> unresolvedProperties = new ArrayList<ModelProperty>();
-		for (ModelProperty mp : modelProperties) {
-			if (!mp.isResolved()) {
-				unresolvedProperties.add(mp);
-			}
-		}
-	
-		LinkedHashSet<InterpolatorProperty> ips = new LinkedHashSet<InterpolatorProperty>();
-		ips.addAll(interpolatorProperties);
-		boolean continueInterpolation = true;
-		while (continueInterpolation) {
-			continueInterpolation = false;
-			for (InterpolatorProperty ip : ips) {
-				for (ModelProperty mp : unresolvedProperties) {
-					if (mp.resolveWith(ip) && !continueInterpolation) {
-						continueInterpolation = true;
-						break;
-					}
-				}
-			}
-		}
-	}
-	
-	private static List<InterpolatorProperty> createInterpolatorProperties(List<ModelProperty> modelProperties,
-	        String baseUriForModel,
-	        Map<String, String> aliases,
-	        String interpolatorTag)
-	{
-		if (modelProperties == null) {
-			throw new IllegalArgumentException("modelProperties: null");
-		}
-	
-		if (baseUriForModel == null) {
-			throw new IllegalArgumentException("baseUriForModel: null");
-		}
-	
-		List<InterpolatorProperty> interpolatorProperties = new ArrayList<InterpolatorProperty>();
-	
-		for (ModelProperty mp : modelProperties) {
-			InterpolatorProperty ip = mp
-					.asInterpolatorProperty(baseUriForModel);
-			if (ip != null) {
-				ip.setTag(interpolatorTag);
-				interpolatorProperties.add(ip);
-				for (Map.Entry<String, String> a : aliases.entrySet()) {
-					interpolatorProperties.add(new InterpolatorProperty(ip
-							.getKey().replaceAll(a.getKey(), a.getValue()), ip
-							.getValue().replaceAll(a.getKey(), a.getValue()),
-							interpolatorTag));
-				}
-			}
-		}
-	
-		List<InterpolatorProperty> ips = new ArrayList<InterpolatorProperty>();
-		for (InterpolatorProperty ip : interpolatorProperties) {
-			if (!ips.contains(ip)) {
-				ips.add(ip);
-			}
-		}
-		return ips;
-	}
-	
-    private static List<ModelProperty> getModelProperties(InputStream is) throws IOException
+    }
+
+    private static void interpolateModelProperties( List<ModelProperty> modelProperties, List<InterpolatorProperty> interpolatorProperties )
-            Set<String> s = new HashSet<String>();
-            //TODO: Should add all collections from ProjectUri
-            s.addAll(URIS);
-            s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);
-            s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);
-            s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);
-            s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);
-            //TODO: More profile info
-            s.add(ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Profiles.Profile.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);
-            s.add(ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.xUri);
-            s.add(ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.configuration);
-            s.add(ProjectUri.Profiles.Profile.properties);
-            s.add(ProjectUri.Profiles.Profile.modules);
-            s.add(ProjectUri.Profiles.Profile.Dependencies.xUri);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.configuration);
-            
-        return new ArrayList<ModelProperty>(marshallXmlToModelProperties(is, ProjectUri.baseUri, s ));
-    }    
+        if ( modelProperties == null )
+        {
+            throw new IllegalArgumentException( "modelProperties: null" );
+        }
+
+        if ( interpolatorProperties == null )
+        {
+            throw new IllegalArgumentException( "interpolatorProperties: null" );
+        }
+
+        List<ModelProperty> unresolvedProperties = new ArrayList<ModelProperty>();
+        for ( ModelProperty mp : modelProperties )
+        {
+            if ( !mp.isResolved() )
+            {
+                unresolvedProperties.add( mp );
+            }
+        }
+
+        LinkedHashSet<InterpolatorProperty> ips = new LinkedHashSet<InterpolatorProperty>();
+        ips.addAll( interpolatorProperties );
+        boolean continueInterpolation = true;
+        while ( continueInterpolation )
+        {
+            continueInterpolation = false;
+            for ( InterpolatorProperty ip : ips )
+            {
+                for ( ModelProperty mp : unresolvedProperties )
+                {
+                    if ( mp.resolveWith( ip ) && !continueInterpolation )
+                    {
+                        continueInterpolation = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    private static List<InterpolatorProperty> createInterpolatorProperties( List<ModelProperty> modelProperties, String baseUriForModel, Map<String, String> aliases, String interpolatorTag )
+    {
+        if ( modelProperties == null )
+        {
+            throw new IllegalArgumentException( "modelProperties: null" );
+        }
+
+        if ( baseUriForModel == null )
+        {
+            throw new IllegalArgumentException( "baseUriForModel: null" );
+        }
+
+        List<InterpolatorProperty> interpolatorProperties = new ArrayList<InterpolatorProperty>();
+
+        for ( ModelProperty mp : modelProperties )
+        {
+            InterpolatorProperty ip = mp.asInterpolatorProperty( baseUriForModel );
+            if ( ip != null )
+            {
+                ip.setTag( interpolatorTag );
+                interpolatorProperties.add( ip );
+                for ( Map.Entry<String, String> a : aliases.entrySet() )
+                {
+                    interpolatorProperties.add( new InterpolatorProperty( ip.getKey().replaceAll( a.getKey(), a.getValue() ), ip.getValue().replaceAll( a.getKey(), a.getValue() ), interpolatorTag ) );
+                }
+            }
+        }
+
+        List<InterpolatorProperty> ips = new ArrayList<InterpolatorProperty>();
+        for ( InterpolatorProperty ip : interpolatorProperties )
+        {
+            if ( !ips.contains( ip ) )
+            {
+                ips.add( ip );
+            }
+        }
+        return ips;
+    }
+
+    private List<ModelProperty> getModelProperties( Model model )
+        throws IOException
+    {
+        StringWriter writer = new StringWriter();
+        modelWriter.write( writer, null, model );
+  	
+        Set<String> s = new HashSet<String>();
+        //TODO: Should add all collections from ProjectUri
+        s.addAll( URIS );
+        s.add( ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Build.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI );
+        s.add( ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri );
+        s.add( ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration );
+        s.add( ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration );
+        //TODO: More profile info
+        s.add( ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Profiles.Profile.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.Goals.xURI );
+        s.add( ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.xUri );
+        s.add( ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.configuration );
+        s.add( ProjectUri.Profiles.Profile.properties );
+        s.add( ProjectUri.Profiles.Profile.modules );
+        s.add( ProjectUri.Profiles.Profile.Dependencies.xUri );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.configuration );
+
+        return new ArrayList<ModelProperty>( marshallXmlToModelProperties( new ByteArrayInputStream(writer.toString().getBytes( "UTF-8" )), ProjectUri.baseUri, s ) );
+    }
+
-     *
+     * 
-     * @param baseUri         the base uri of every model property. May not be null or empty.
+     * @param baseUri the base uri of every model property. May not be null or empty.
-            //String val = (mp.getResolvedValue() != null) ? "\"" + mp.getResolvedValue() + "\"" : null;
-            //   System.out.println("new ModelProperty(\"" + mp.getUri() +"\" , " + val +"),");
-                throw new IllegalArgumentException(
-                    "Passed in model property that does not match baseUri: Property URI = " + uri + ", Base URI = " +
-                        baseUri );
+                throw new IllegalArgumentException( "Passed in model property that does not match baseUri: Property URI = " + uri + ", Base URI = " + baseUri );
-            for(int peekIndex = modelProperties.indexOf( mp ) + 1; peekIndex < modelProperties.size(); peekIndex++)
+            for ( int peekIndex = modelProperties.indexOf( mp ) + 1; peekIndex < modelProperties.size(); peekIndex++ )
-                        attributes.add(peekProperty);
+                        attributes.add( peekProperty );
-     * Returns list of tag names parsed from the specified uri. All #collection parts of the tag are removed from the
-     * tag names.
-     *
+     * Returns list of tag names parsed from the specified uri. All #collection parts of the tag are
+     * removed from the tag names.
+     * 
-     * @param uri          the uri to parse for tag names
+     * @param uri the uri to parse for tag names
-        return Arrays.asList( uri.substring( basePosition ).replaceAll( "#collection", "" )
-                .replaceAll("#set", "").split( "/" ) );
+        return Arrays.asList( uri.substring( basePosition ).replaceAll( "#collection", "" ).replaceAll( "#set", "" ).split( "/" ) );
-     *
-     * @param value     the value to use for the start tag
+     * 
+     * @param value the value to use for the start tag
-            for(ModelProperty attribute : attributes)
+            for ( ModelProperty attribute : attributes )
-                sb.append( " " ).append(
-                    attribute.getUri().substring( attribute.getUri().indexOf( "#property/" ) + 10 ) ).append( "=\"" )
-                    .append( attribute.getResolvedValue() ).append( "\" " );
+                sb.append( " " ).append( attribute.getUri().substring( attribute.getUri().indexOf( "#property/" ) + 10 ) ).append( "=\"" ).append( attribute.getResolvedValue() ).append( "\" " );
-     *
+     * 
-    }    
-    
+    }
-    private static final Set<String> URIS = Collections.unmodifiableSet(new HashSet<String>( Arrays.asList(  ProjectUri.Build.Extensions.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.configuration,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.Execution.Goals.xURI,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.Dependency.Exclusions.xUri,
-            ProjectUri.Build.Plugins.xUri,
-            ProjectUri.properties,
-            ProjectUri.Build.Plugins.Plugin.configuration,
-            ProjectUri.Reporting.Plugins.xUri,
-            ProjectUri.Reporting.Plugins.Plugin.configuration,
-            ProjectUri.Build.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Build.Resources.xUri,
-            ProjectUri.Build.Resources.Resource.includes,
-            ProjectUri.Build.Resources.Resource.excludes,
-            ProjectUri.Build.TestResources.xUri,
-            ProjectUri.Build.Filters.xUri,
-            ProjectUri.CiManagement.Notifiers.xUri,
-            ProjectUri.Contributors.xUri,
-            ProjectUri.Dependencies.xUri,
-            ProjectUri.DependencyManagement.Dependencies.xUri,
-            ProjectUri.Developers.xUri,
-            ProjectUri.Developers.Developer.roles,
-            ProjectUri.Licenses.xUri,
-            ProjectUri.MailingLists.xUri,
-            ProjectUri.Modules.xUri,
-            ProjectUri.PluginRepositories.xUri,
-            ProjectUri.Profiles.xUri,
-            ProjectUri.Profiles.Profile.Build.Plugins.xUri,
-            ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri,
-            ProjectUri.Profiles.Profile.Build.Resources.xUri,
-            ProjectUri.Profiles.Profile.Build.TestResources.xUri,
-            ProjectUri.Profiles.Profile.Dependencies.xUri,
-            ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.xUri,
-            ProjectUri.Profiles.Profile.PluginRepositories.xUri,
-            ProjectUri.Profiles.Profile.Reporting.Plugins.xUri,
-            ProjectUri.Profiles.Profile.Repositories.xUri,
-            ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.xUri,
-            ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Reporting.Plugins.xUri,
-            ProjectUri.Repositories.xUri) ));    
-    
-   /**
-    * Returns list of model properties transformed from the specified input stream.
-    *
-    * @param inputStream input stream containing the xml document. May not be null.
-    * @param baseUri     the base uri of every model property. May not be null or empty.
-    * @param collections set of uris that are to be treated as a collection (multiple entries). May be null.
-    * @return list of model properties transformed from the specified input stream.
-    * @throws IOException if there was a problem doing the transform
-    */
-    private static List<ModelProperty> marshallXmlToModelProperties( InputStream inputStream, String baseUri,
-            Set<String> collections )
-			throws IOException {
-		if (inputStream == null) {
-			throw new IllegalArgumentException("inputStream: null");
-		}
+    private static final Set<String> URIS = Collections.unmodifiableSet( new HashSet<String>( Arrays.asList( ProjectUri.Build.Extensions.xUri, ProjectUri.Build.PluginManagement.Plugins.xUri,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.configuration,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.Execution.Goals.xURI,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.Dependency.Exclusions.xUri,
+                                                                                                             ProjectUri.Build.Plugins.xUri, ProjectUri.properties,
+                                                                                                             ProjectUri.Build.Plugins.Plugin.configuration, ProjectUri.Reporting.Plugins.xUri,
+                                                                                                             ProjectUri.Reporting.Plugins.Plugin.configuration,
+                                                                                                             ProjectUri.Build.Plugins.Plugin.Dependencies.xUri, ProjectUri.Build.Resources.xUri,
+                                                                                                             ProjectUri.Build.Resources.Resource.includes,
+                                                                                                             ProjectUri.Build.Resources.Resource.excludes, ProjectUri.Build.TestResources.xUri,
+                                                                                                             ProjectUri.Build.Filters.xUri, ProjectUri.CiManagement.Notifiers.xUri,
+                                                                                                             ProjectUri.Contributors.xUri, ProjectUri.Dependencies.xUri,
+                                                                                                             ProjectUri.DependencyManagement.Dependencies.xUri, ProjectUri.Developers.xUri,
+                                                                                                             ProjectUri.Developers.Developer.roles, ProjectUri.Licenses.xUri,
+                                                                                                             ProjectUri.MailingLists.xUri, ProjectUri.Modules.xUri, ProjectUri.PluginRepositories.xUri,
+                                                                                                             ProjectUri.Profiles.xUri, ProjectUri.Profiles.Profile.Build.Plugins.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Dependencies.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.Resources.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.TestResources.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Dependencies.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.PluginRepositories.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Reporting.Plugins.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Repositories.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
+                                                                                                             ProjectUri.Reporting.Plugins.xUri, ProjectUri.Repositories.xUri ) ) );
-		if (baseUri == null || baseUri.trim().length() == 0) {
-			throw new IllegalArgumentException("baseUri: null");
-		}
+    /**
+     * Returns list of model properties transformed from the specified input stream.
+     * 
+     * @param inputStream input stream containing the xml document. May not be null.
+     * @param baseUri the base uri of every model property. May not be null or empty.
+     * @param collections set of uris that are to be treated as a collection (multiple entries). May
+     *            be null.
+     * @return list of model properties transformed from the specified input stream.
+     * @throws IOException if there was a problem doing the transform
+     */
+    private static List<ModelProperty> marshallXmlToModelProperties( InputStream inputStream, String baseUri, Set<String> collections )
+        throws IOException
+    {
+        if ( inputStream == null )
+        {
+            throw new IllegalArgumentException( "inputStream: null" );
+        }
-		if (collections == null) {
-			collections = Collections.emptySet();
-		}
+        if ( baseUri == null || baseUri.trim().length() == 0 )
+        {
+            throw new IllegalArgumentException( "baseUri: null" );
+        }
-		List<ModelProperty> modelProperties = new ArrayList<ModelProperty>();
-		XMLInputFactory xmlInputFactory = new com.ctc.wstx.stax.WstxInputFactory();
-		xmlInputFactory.setProperty(
-				XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE);
-		xmlInputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE,
-				Boolean.FALSE);
+        if ( collections == null )
+        {
+            collections = Collections.emptySet();
+        }
-		Uri uri = new Uri(baseUri);
-		String tagName = baseUri;
-		StringBuilder tagValue = new StringBuilder(256);
+        List<ModelProperty> modelProperties = new ArrayList<ModelProperty>();
-		int depth = 0;
-		int depthOfTagValue = depth;
-		XMLStreamReader xmlStreamReader = null;
-		try {
-			xmlStreamReader = xmlInputFactory
-					.createXMLStreamReader(inputStream);
+        Uri uri = new Uri( baseUri );
+        String tagName = baseUri;
+        StringBuilder tagValue = new StringBuilder( 256 );
-			Map<String, String> attributes = new HashMap<String, String>();
-			for (;; xmlStreamReader.next()) {
-				int type = xmlStreamReader.getEventType();
-				switch (type) {
+        int depth = 0;
+        int depthOfTagValue = depth;
+        Reader reader = null;
+        try
+        {
+            reader = ReaderFactory.newXmlReader( inputStream );
-				case XMLStreamConstants.CDATA:
-				case XMLStreamConstants.CHARACTERS: {
-					if (depth == depthOfTagValue) {
-						tagValue.append(xmlStreamReader.getTextCharacters(),
-								xmlStreamReader.getTextStart(), xmlStreamReader
-										.getTextLength());
-					}
-					break;
-				}
+            XmlPullParser parser = new MXParser();
+            parser.setInput( reader );
-				case XMLStreamConstants.START_ELEMENT: {
-					if (!tagName.equals(baseUri)) {
-						String value = null;
-						if (depth < depthOfTagValue) {
-							value = tagValue.toString().trim();
-						}
-						modelProperties.add(new ModelProperty(tagName, value));
-						if (!attributes.isEmpty()) {
-							for (Map.Entry<String, String> e : attributes
-									.entrySet()) {
-								modelProperties.add(new ModelProperty(e
-										.getKey(), e.getValue()));
-							}
-							attributes.clear();
-						}
-					}
+            Map<String, String> attributes = new HashMap<String, String>();
+            for ( int type = parser.getEventType();; type = parser.next() )
+            {
+                switch ( type )
+                {
+                    case XmlPullParser.TEXT:
+                    {
+                        if ( depth == depthOfTagValue )
+                        {
+                            tagValue.append( parser.getText() );
+                        }
+                        break;
+                    }
+                    case XmlPullParser.START_TAG:
+                    {
+                        if ( !tagName.equals( baseUri ) )
+                        {
+                            String value = null;
+                            if ( depth < depthOfTagValue )
+                            {
+                                value = tagValue.toString().trim();
+                            }
+                            modelProperties.add( new ModelProperty( tagName, value ) );
+                            if ( !attributes.isEmpty() )
+                            {
+                                for ( Map.Entry<String, String> e : attributes.entrySet() )
+                                {
+                                    modelProperties.add( new ModelProperty( e.getKey(), e.getValue() ) );
+                                }
+                                attributes.clear();
+                            }
+                        }
-					depth++;
-					tagName = uri.getUriFor(xmlStreamReader.getName()
-							.getLocalPart(), depth);
-					if (collections.contains(tagName + "#collection")) {
-						tagName = tagName + "#collection";
-						uri.addTag(xmlStreamReader.getName().getLocalPart()
-								+ "#collection");
-					} else if (collections.contains(tagName + "#set")) {
-						tagName = tagName + "#set";
-						uri.addTag(xmlStreamReader.getName().getLocalPart()
-								+ "#set");
-					} else {
-						uri.addTag(xmlStreamReader.getName().getLocalPart());
-					}
-					tagValue.setLength(0);
-					depthOfTagValue = depth;
-				}
-				case XMLStreamConstants.ATTRIBUTE: {
-					for (int i = 0; i < xmlStreamReader.getAttributeCount(); i++) {
+                        depth++;
+                        tagName = uri.getUriFor( parser.getName(), depth );
+                        if ( collections.contains( tagName + "#collection" ) )
+                        {
+                            tagName = tagName + "#collection";
+                            uri.addTag( parser.getName() + "#collection" );
+                        }
+                        else if ( collections.contains( tagName + "#set" ) )
+                        {
+                            tagName = tagName + "#set";
+                            uri.addTag( parser.getName() + "#set" );
+                        }
+                        else
+                        {
+                            uri.addTag( parser.getName() );
+                        }
+                        tagValue.setLength( 0 );
+                        depthOfTagValue = depth;
-						attributes.put(tagName
-								+ "#property/"
-								+ xmlStreamReader.getAttributeName(i)
-										.getLocalPart(), xmlStreamReader
-								.getAttributeValue(i));
-					}
-					break;
-				}
-				case XMLStreamConstants.END_ELEMENT: {
-					depth--;
-					break;
-				}
-				case XMLStreamConstants.END_DOCUMENT: {
-					modelProperties.add(new ModelProperty(tagName, tagValue
-							.toString().trim()));
-					if (!attributes.isEmpty()) {
-						for (Map.Entry<String, String> e : attributes
-								.entrySet()) {
-							modelProperties.add(new ModelProperty(e.getKey(), e
-									.getValue()));
-						}
-						attributes.clear();
-					}
-					return modelProperties;
-				}
-				}
-			}
-		} catch (XMLStreamException e) {
-			throw new IOException(":" + e.toString());
-		} finally {
-			if (xmlStreamReader != null) {
-				try {
-					xmlStreamReader.close();
-				} catch (XMLStreamException e) {
-					e.printStackTrace();
-				}
-			}
-			try {
-				inputStream.close();
-			} catch (IOException e) {
+                        for ( int i = 0; i < parser.getAttributeCount(); i++ )
+                        {
-			}
-		}
-	}
-    
+                            attributes.put( tagName + "#property/" + parser.getAttributeName( i ),
+                                            parser.getAttributeValue( i ) );
+                        }
+                        break;
+                    }
+                    case XmlPullParser.END_TAG:
+                    {
+                        depth--;
+                        break;
+                    }
+                    case XmlPullParser.END_DOCUMENT:
+                    {
+                        modelProperties.add( new ModelProperty( tagName, tagValue.toString().trim() ) );
+                        if ( !attributes.isEmpty() )
+                        {
+                            for ( Map.Entry<String, String> e : attributes.entrySet() )
+                            {
+                                modelProperties.add( new ModelProperty( e.getKey(), e.getValue() ) );
+                            }
+                        }
+                        return modelProperties;
+                    }
+                }
+
+            }
+        }
+        catch ( XmlPullParserException e )
+        {
+            throw (IOException) new IOException( "Failed to parser POM:" + e.toString() ).initCause( e );
+        }
+        finally
+        {
+            IOUtil.close( reader );
+        }
+    }
+
-        InterpolatorProperty versionInterpolatorProperty =
-            new ModelProperty( ProjectUri.version, "" ).asInterpolatorProperty( ProjectUri.baseUri );
+        InterpolatorProperty versionInterpolatorProperty = new ModelProperty( ProjectUri.version, "" ).asInterpolatorProperty( ProjectUri.baseUri );
-    }    
-   /**
-    * Class for storing information about URIs.
-    */
-   private static class Uri
-   {
+    }
-       List<String> uris;
+    /**
+     * Class for storing information about URIs.
+     */
+    private static class Uri
+    {
-       Uri( String baseUri )
-       {
-           uris = new LinkedList<String>();
-           uris.add( baseUri );
-       }
+        List<String> uris;
-       String getUriFor( String tag, int depth )
-       {
-           setUrisToDepth( depth );
-           StringBuffer sb = new StringBuffer();
-           for ( String tagName : uris )
-           {
-               sb.append( tagName ).append( "/" );
-           }
-           sb.append( tag );
-           return sb.toString();
-       }
+        Uri( String baseUri )
+        {
+            uris = new LinkedList<String>();
+            uris.add( baseUri );
+        }
-       void addTag( String tag )
-       {
-           uris.add( tag );
-       }
+        String getUriFor( String tag, int depth )
+        {
+            setUrisToDepth( depth );
+            StringBuffer sb = new StringBuffer();
+            for ( String tagName : uris )
+            {
+                sb.append( tagName ).append( "/" );
+            }
+            sb.append( tag );
+            return sb.toString();
+        }
-       void setUrisToDepth( int depth )
-       {
-           uris = new LinkedList<String>( uris.subList( 0, depth ) );
-       }
-   }
-       
+        void addTag( String tag )
+        {
+            uris.add( tag );
+        }
+
+        void setUrisToDepth( int depth )
+        {
+            uris = new LinkedList<String>( uris.subList( 0, depth ) );
+        }
+    }
+    
+    private static enum PomInterpolatorTag
+    {
+        PROJECT_PROPERTIES,
+
+        EXECUTION_PROPERTIES
+    }

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 UPD40 UPD40 INS40 UPD40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS71 INS78 INS83 INS43 INS59 INS78 INS83 INS43 INS59 UPD43 UPD42 INS44 INS83 INS83 INS42 INS72 INS72 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 UPD43 UPD42 INS43 UPD42 INS43 INS42 INS25 MOV60 INS70 INS60 INS60 MOV60 MOV70 MOV70 UPD43 UPD42 INS60 INS21 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS27 INS8 INS44 INS32 INS8 MOV74 MOV59 MOV43 INS59 INS27 UPD66 UPD66 UPD42 INS43 INS59 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD43 MOV8 UPD42 INS42 INS33 INS21 UPD42 INS74 INS42 UPD42 MOV42 INS42 INS21 UPD42 INS42 INS33 INS42 INS33 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS33 INS42 UPD42 UPD42 INS60 INS21 INS7 INS43 INS43 INS43 INS32 UPD42 MOV42 UPD42 UPD42 MOV42 INS7 MOV43 UPD43 UPD42 INS43 INS14 INS43 INS59 INS32 INS58 INS7 UPD43 UPD45 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 UPD42 INS42 INS32 INS42 INS42 MOV43 INS32 UPD42 INS42 INS42 INS14 INS42 INS42 INS42 INS39 INS59 INS42 INS32 UPD42 INS11 UPD42 INS42 INS43 MOV43 INS27 INS11 INS32 UPD42 MOV42 MOV42 INS42 INS42 INS14 INS33 INS32 UPD42 MOV42 INS45 UPD42 UPD42 INS43 INS42 INS32 UPD42 MOV42 MOV42 MOV43 INS32 INS42 INS45 INS32 INS45 MOV43 INS32 INS40 INS42 UPD42 MOV42 INS27 UPD43 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD40 UPD40 INS24 INS10 UPD40 UPD40 MOV14 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 UPD42 MOV58 INS27 MOV37 INS8 INS42 INS32 INS21 UPD45 MOV32 INS42 INS42 INS32 UPD42 INS42 INS42 INS27 INS32 UPD42 UPD42 INS32 MOV32 INS42 INS45 INS32 INS42 INS42 INS42 UPD42 MOV42 MOV42 INS32 UPD42 INS42 INS42 INS42 UPD42 MOV42 MOV42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL40 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL45 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL40 DEL42 DEL32 DEL32 DEL32 DEL21 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL32 DEL45 DEL27 DEL42 DEL42 DEL32 DEL14 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL32 DEL32 DEL42 DEL43 DEL60 DEL8 DEL25 DEL42 DEL42 DEL42 DEL45 DEL32 DEL14 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL83 DEL42 DEL43 DEL42 DEL40 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL40 DEL32 DEL21 DEL32 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL49 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL10 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8
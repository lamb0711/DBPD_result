Applying patch from Jason Grant for unpacking assemblies and for attaching assemblies as attached artifacts - Thanks, Jason

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@233012 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.artifact.factory.ArtifactFactory;
-import org.apache.maven.plugin.AbstractMojo;
+import org.apache.maven.project.MavenProject;
-import java.io.FileOutputStream;
-import java.util.Enumeration;
-import java.util.Set;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-    extends AbstractMojo
+    extends AbstractUnpackingMojo
-    private static final String[] EMPTY_STRING_ARRAY = {};
+	/**
+	 * @parameter expression="${maven.assembly.descriptorId}"
+	 */
+	protected String descriptorId;
+	/**
+	 * @parameter expression="${maven.assembly.descriptor}"
+	 */
+	protected File descriptor;
+	/**
+	 * @parameter expression="${basedir}"
+	 * @required
+	 * @readonly
+	 */
+	private String basedir;
+	
-     * @parameter expression="${basedir}"
+     * @parameter expression="${project}"
-    private String basedir;
+    private MavenProject project;
-     * @parameter expression="${project.build.directory}"
+     * @parameter expression="${component.org.apache.maven.artifact.factory.ArtifactFactory}"
-     */
-    private File outputDirectory;
-
-    /**
-     * @parameter expression="${maven.assembly.descriptor}"
-     */
-    private File descriptor;
-
-    /**
-     * @parameter expression="${maven.assembly.descriptorId}"
-     */
-    private String descriptorId;
-
-    /**
-     * @parameter expression="${project.build.finalName}"
-     * @required
-     */
-    private String finalName;
-
-    /**
-     * @parameter expression="${project.artifacts}"
-    private Set dependencies;
+    private ArtifactFactory artifactFactory;
-    /**
-     * Directory to unpack JARs into if needed
-     *
-     * @parameter expression="${project.build.directory}/assembly/work"
-     * @required
-     */
-    private File workDirectory;
+	
-    public void execute()
-        throws MojoExecutionException
-    {
-        try
-        {
-            doExecute();
-        }
-        catch ( Exception e )
-        {
-            // TODO: don't catch exception
-            throw new MojoExecutionException( "Error creating assembly", e );
-        }
-    }
+	public void execute() throws MojoExecutionException {
+	    try
+	    {
+	        doExecute();
+	    }
+	    catch ( Exception e )
+	    {
+	        // TODO: don't catch exception
+	        throw new MojoExecutionException( "Error creating assembly", e );
+	    }
+	}
-    private void doExecute()
-        throws Exception
-    {
-        Reader r = null;
+	private void doExecute() throws Exception {
+	    Reader r = null;
+	
+	    if ( descriptor != null )
+	    {
+	        r = new FileReader( descriptor );
+	    }
+	    else if ( descriptorId != null )
+	    {
+	        InputStream resourceAsStream = getClass().getResourceAsStream( "/assemblies/" + descriptorId + ".xml" );
+	        if ( resourceAsStream == null )
+	        {
+	            throw new MojoExecutionException( "Descriptor with ID '" + descriptorId + "' not found" );
+	        }
+	        r = new InputStreamReader( resourceAsStream );
+	    }
+	    else
+	    {
+	        // TODO: better exception
+	        throw new MojoExecutionException( "You must specify descriptor or descriptorId" );
+	    }
+	
+	    try
+	    {
+	        AssemblyXpp3Reader reader = new AssemblyXpp3Reader();
+	        Assembly assembly = reader.read( r );
+	
+	        // TODO: include dependencies marked for distribution under certain formats
+	        // TODO: how, might we plug this into an installer, such as NSIS?
+	        // TODO: allow file mode specifications?
+	
+	        String fullName = finalName + "-" + assembly.getId();
+	
+	        for ( Iterator i = assembly.getFormats().iterator(); i.hasNext(); )
+	        {
+	            String format = (String) i.next();
+	
+	            String filename = fullName + "." + format;
+	
+	            // TODO: use component roles? Can we do that in a mojo?
+	            Archiver archiver = createArchiver( format );
+	
+	            processFileSets( archiver, assembly.getFileSets(), assembly.isIncludeBaseDirectory() );
+	            processDependencySets( archiver, assembly.getDependencySets(), assembly.isIncludeBaseDirectory() );
+	
+	            File destFile = new File( outputDirectory, filename );
+	            archiver.setDestFile( destFile );
+	            archiver.createArchive();
+	            
+	            addAttachedArtifact( destFile , format);
+	        }
+	    }
+	    finally
+	    {
+	        IOUtil.close( r );
+	    }
+	}
-        if ( descriptor != null )
-        {
-            r = new FileReader( descriptor );
-        }
-        else if ( descriptorId != null )
-        {
-            InputStream resourceAsStream = getClass().getResourceAsStream( "/assemblies/" + descriptorId + ".xml" );
-            if ( resourceAsStream == null )
-            {
-                throw new MojoExecutionException( "Descriptor with ID '" + descriptorId + "' not found" );
-            }
-            r = new InputStreamReader( resourceAsStream );
-        }
-        else
-        {
-            // TODO: better exception
-            throw new MojoExecutionException( "You must specify descriptor or descriptorId" );
-        }
+	private void addAttachedArtifact(File destFile, String format) {
+		
+        Artifact artifact = artifactFactory.createArtifactWithClassifier( 
+        		project.getGroupId(),
+                project.getArtifactId(),
+                project.getVersion(), 
+                format,
+                null );
+                
+        artifact.setFile( destFile );
-        try
-        {
-            AssemblyXpp3Reader reader = new AssemblyXpp3Reader();
-            Assembly assembly = reader.read( r );
+        project.addAttachedArtifact( artifact );		
+		
+	}
-            // TODO: include dependencies marked for distribution under certain formats
-            // TODO: how, might we plug this into an installer, such as NSIS?
-            // TODO: allow file mode specifications?
+	private void processDependencySets(Archiver archiver, List dependencySets, boolean includeBaseDirectory) throws ArchiverException, IOException, Exception {
+	        for ( Iterator i = dependencySets.iterator(); i.hasNext(); )
+	        {
+	            DependencySet dependencySet = (DependencySet) i.next();
+	            String output = dependencySet.getOutputDirectory();
+	            output = getOutputDirectory( output, includeBaseDirectory );
+	
+	            AndArtifactFilter filter = new AndArtifactFilter();
+	            filter.add( new ScopeArtifactFilter( dependencySet.getScope() ) );
+	            if ( !dependencySet.getIncludes().isEmpty() )
+	            {
+	                filter.add( new IncludesArtifactFilter( dependencySet.getIncludes() ) );
+	            }
+	            if ( !dependencySet.getExcludes().isEmpty() )
+	            {
+	                filter.add( new ExcludesArtifactFilter( dependencySet.getExcludes() ) );
+	            }
+	
+	            // TODO: includes and excludes
+	            for ( Iterator j = dependencies.iterator(); j.hasNext(); )
+	            {
+	                Artifact artifact = (Artifact) j.next();
+	
+	                if ( filter.include( artifact ) )
+	                {
+	                    String name = artifact.getFile().getName();
+	                    if ( dependencySet.isUnpack() )
+	                    {
+	                        // TODO: something like zipfileset in plexus-archiver
+	//                        archiver.addJar(  )
+	
+	                        File tempLocation = new File( workDirectory, name.substring( 0, name.length() - 4 ) );
+	                        boolean process = false;
+	                        if ( !tempLocation.exists() )
+	                        {
+	                            tempLocation.mkdirs();
+	                            process = true;
+	                        }
+	                        else if ( artifact.getFile().lastModified() > tempLocation.lastModified() )
+	                        {
+	                            process = true;
+	                        }
+	
+	                        if ( process )
+	                        {
+	                            unpack( artifact.getFile(), tempLocation );
+	                        }
+	                        archiver.addDirectory( tempLocation, null,
+	                                               (String[]) getJarExcludes().toArray( EMPTY_STRING_ARRAY ) );
+	                    }
+	                    else
+	                    {
+	                        archiver.addFile( artifact.getFile(), output +
+	                            evaluateFileNameMapping( dependencySet.getOutputFileNameMapping(), artifact ) );
+	                    }
+	                }
+	            }
+	        }
+	    }
-            String fullName = finalName + "-" + assembly.getId();
-
-            for ( Iterator i = assembly.getFormats().iterator(); i.hasNext(); )
-            {
-                String format = (String) i.next();
-
-                String filename = fullName + "." + format;
-
-                // TODO: use component roles? Can we do that in a mojo?
-                Archiver archiver = createArchiver( format );
-
-                processFileSets( archiver, assembly.getFileSets(), assembly.isIncludeBaseDirectory() );
-                processDependencySets( archiver, assembly.getDependencySets(), assembly.isIncludeBaseDirectory() );
-
-                archiver.setDestFile( new File( outputDirectory, filename ) );
-                archiver.createArchive();
-            }
-        }
-        finally
-        {
-            IOUtil.close( r );
-        }
-    }
-
-    private void processDependencySets( Archiver archiver, List dependencySets, boolean includeBaseDirectory )
-        throws ArchiverException, IOException, Exception
-    {
-        for ( Iterator i = dependencySets.iterator(); i.hasNext(); )
-        {
-            DependencySet dependencySet = (DependencySet) i.next();
-            String output = dependencySet.getOutputDirectory();
-            output = getOutputDirectory( output, includeBaseDirectory );
-
-            AndArtifactFilter filter = new AndArtifactFilter();
-            filter.add( new ScopeArtifactFilter( dependencySet.getScope() ) );
-            if ( !dependencySet.getIncludes().isEmpty() )
-            {
-                filter.add( new IncludesArtifactFilter( dependencySet.getIncludes() ) );
-            }
-            if ( !dependencySet.getExcludes().isEmpty() )
-            {
-                filter.add( new ExcludesArtifactFilter( dependencySet.getExcludes() ) );
-            }
-
-            // TODO: includes and excludes
-            for ( Iterator j = dependencies.iterator(); j.hasNext(); )
-            {
-                Artifact artifact = (Artifact) j.next();
-
-                if ( filter.include( artifact ) )
-                {
-                    String name = artifact.getFile().getName();
-                    if ( dependencySet.isUnpack() )
-                    {
-                        // TODO: something like zipfileset in plexus-archiver
-//                        archiver.addJar(  )
-
-                        File tempLocation = new File( workDirectory, name.substring( 0, name.length() - 4 ) );
-                        boolean process = false;
-                        if ( !tempLocation.exists() )
-                        {
-                            tempLocation.mkdirs();
-                            process = true;
-                        }
-                        else if ( artifact.getFile().lastModified() > tempLocation.lastModified() )
-                        {
-                            process = true;
-                        }
-
-                        if ( process )
-                        {
-                            unpackJar( artifact.getFile(), tempLocation );
-                        }
-                        archiver.addDirectory( tempLocation, null,
-                                               (String[]) getJarExcludes().toArray( EMPTY_STRING_ARRAY ) );
-                    }
-                    else
-                    {
-                        archiver.addFile( artifact.getFile(), output +
-                            evaluateFileNameMapping( dependencySet.getOutputFileNameMapping(), artifact ) );
-                    }
-                }
-            }
-        }
-    }
-
-    private String evaluateFileNameMapping( String expression, Artifact artifact )
-        throws Exception
-    {
-        // this matches the last ${...} string
-        Pattern pat = Pattern.compile( "^(.*)\\$\\{([^\\}]+)\\}(.*)$" );
-        Matcher mat = pat.matcher( expression );
-
-        String left,right;
-        Object middle;
-
-        if ( mat.matches() )
-        {
-            left = evaluateFileNameMapping( mat.group( 1 ), artifact );
-            middle = ReflectionValueExtractor.evaluate( "dep." + mat.group( 2 ), artifact );
-            right = mat.group( 3 );
-
-            if ( middle == null )
-            {
-                // TODO: There should be a more generic way dealing with that. Having magic words is not good at all.
-                // probe for magic word
-                if ( mat.group( 2 ).trim().equals( "extension" ) )
-                {
-                    ArtifactHandler artifactHandler = artifact.getArtifactHandler();
-                    middle = artifactHandler.getExtension();
-                }
-                else
-                {
-                    middle = "${" + mat.group( 2 ) + "}";
-                }
-            }
-
-            return left + middle + right;
-        }
-
-        return expression;
-    }
-
-    private void unpackJar( File file, File tempLocation )
-        throws IOException
-    {
-        if ( !file.getAbsolutePath().toLowerCase().trim().endsWith( "jar" ) )
-        {
-            getLog().warn( "Trying to unpack a none jar file " + file.getAbsolutePath() + " - IGNORING" );
-            return;
-        }
-
-        JarFile jar = new JarFile( file );
-        for ( Enumeration e = jar.entries(); e.hasMoreElements(); )
-        {
-            JarEntry entry = (JarEntry) e.nextElement();
-
-            if ( !entry.isDirectory() )
-            {
-                File outFile = new File( tempLocation, entry.getName() );
-                outFile.getParentFile().mkdirs();
-                IOUtil.copy( jar.getInputStream( entry ), new FileOutputStream( outFile ) );
-            }
-        }
-    }
-
-    private List getJarExcludes()
-    {
-        List l = new ArrayList( getDefaultExcludes() );
-        l.add( "META-INF/**" );
-        return l;
-    }
-
-    private String getOutputDirectory( String output, boolean includeBaseDirectory )
-    {
-        if ( output == null )
-        {
-            output = "";
-        }
-        if ( !output.endsWith( "/" ) && !output.endsWith( "\\" ) )
-        {
-            // TODO: shouldn't archiver do this?
-            output += '/';
-        }
-
-        if ( includeBaseDirectory )
-        {
-            if ( output.startsWith( "/" ) )
-            {
-                output = finalName + output;
-            }
-            else
-            {
-                output = finalName + "/" + output;
-            }
-        }
-        else
-        {
-            if ( output.startsWith( "/" ) )
-            {
-                output = output.substring( 1 );
-            }
-        }
-        return output;
-    }
-
-    private Archiver createArchiver( String format )
-        throws ArchiverException
-    {
-        Archiver archiver;
-        if ( format.startsWith( "tar" ) )
-        {
-            TarArchiver tarArchiver = new TarArchiver();
-            archiver = tarArchiver;
-            int index = format.indexOf( '.' );
-            if ( index >= 0 )
-            {
-                // TODO: this needs a cleanup in plexus archiver - use a real typesafe enum
-                TarArchiver.TarCompressionMethod tarCompressionMethod = new TarArchiver.TarCompressionMethod();
-                // TODO: this should accept gz and bz2 as well so we can skip over the switch
-                String compression = format.substring( index + 1 );
-                if ( compression.equals( "gz" ) )
-                {
-                    tarCompressionMethod.setValue( "gzip" );
-                }
-                else if ( compression.equals( "bz2" ) )
-                {
-                    tarCompressionMethod.setValue( "bzip2" );
-                }
-                else
-                {
-                    // TODO: better handling
-                    throw new IllegalArgumentException( "Unknown compression format: " + compression );
-                }
-                tarArchiver.setCompression( tarCompressionMethod );
-            }
-
-            // TODO: should be able to do this on a file/dir basis
-            tarArchiver.getOptions().setDirMode( "0700" );
-            tarArchiver.getOptions().setMode( "0700" );
-        }
-        else if ( format.startsWith( "zip" ) )
-        {
-            archiver = new ZipArchiver();
-        }
-        else if ( format.startsWith( "jar" ) )
-        {
-            // TODO: use MavenArchiver for manifest?
-            JarArchiver jarArchiver = new JarArchiver();
-            jarArchiver.setCompress( true );
-            archiver = jarArchiver;
-
-        }
-        else
-        {
-            // TODO: better handling
-            throw new IllegalArgumentException( "Unknown format: " + format );
-        }
-        return archiver;
-    }
-
-    private void processFileSets( Archiver archiver, List fileSets, boolean includeBaseDirecetory )
-        throws ArchiverException
-    {
-        for ( Iterator i = fileSets.iterator(); i.hasNext(); )
-        {
-            FileSet fileSet = (FileSet) i.next();
-            String directory = fileSet.getDirectory();
-            String output = fileSet.getOutputDirectory();
-            if ( directory == null )
-            {
-                directory = basedir;
-                if ( output == null )
-                {
-                    output = "";
-                }
-            }
-            else
-            {
-                if ( output == null )
-                {
-                    output = directory;
-                }
-            }
-            output = getOutputDirectory( output, includeBaseDirecetory );
-
-            String[] includes = (String[]) fileSet.getIncludes().toArray( EMPTY_STRING_ARRAY );
-            if ( includes.length == 0 )
-            {
-                includes = null;
-            }
-
-            List excludesList = fileSet.getExcludes();
-            excludesList.addAll( getDefaultExcludes() );
-            String[] excludes = (String[]) excludesList.toArray( EMPTY_STRING_ARRAY );
-
-            // TODO: default excludes should be in the archiver?
-            archiver.addDirectory( new File( directory ), output, includes, excludes );
-        }
-    }
-
-    public List getDefaultExcludes()
-    {
-        List defaultExcludes = new ArrayList();
-        defaultExcludes.add( "**/*~" );
-        defaultExcludes.add( "**/#*#" );
-        defaultExcludes.add( "**/.#*" );
-        defaultExcludes.add( "**/%*%" );
-        defaultExcludes.add( "**/._*" );
-
-        // CVS
-        defaultExcludes.add( "**/CVS" );
-        defaultExcludes.add( "**/CVS/**" );
-        defaultExcludes.add( "**/.cvsignore" );
-
-        // SCCS
-        defaultExcludes.add( "**/SCCS" );
-        defaultExcludes.add( "**/SCCS/**" );
-
-        // Visual SourceSafe
-        defaultExcludes.add( "**/vssver.scc" );
-
-        // Subversion
-        defaultExcludes.add( "**/.svn" );
-        defaultExcludes.add( "**/.svn/**" );
-
-        // Mac
-        defaultExcludes.add( "**/.DS_Store" );
-
-        return defaultExcludes;
-    }
-
+	private void processFileSets(Archiver archiver, List fileSets, boolean includeBaseDirecetory) throws ArchiverException {
+	    for ( Iterator i = fileSets.iterator(); i.hasNext(); )
+	    {
+	        FileSet fileSet = (FileSet) i.next();
+	        String directory = fileSet.getDirectory();
+	        String output = fileSet.getOutputDirectory();
+	        if ( directory == null )
+	        {
+	            directory = basedir;
+	            if ( output == null )
+	            {
+	                output = "";
+	            }
+	        }
+	        else
+	        {
+	            if ( output == null )
+	            {
+	                output = directory;
+	            }
+	        }
+	        output = getOutputDirectory( output, includeBaseDirecetory );
+	
+	        String[] includes = (String[]) fileSet.getIncludes().toArray( EMPTY_STRING_ARRAY );
+	        if ( includes.length == 0 )
+	        {
+	            includes = null;
+	        }
+	
+	        List excludesList = fileSet.getExcludes();
+	        excludesList.addAll( getDefaultExcludes() );
+	        String[] excludes = (String[]) excludesList.toArray( EMPTY_STRING_ARRAY );
+	
+	        // TODO: default excludes should be in the archiver?
+	        archiver.addDirectory( new File( directory ), output, includes, excludes );
+	    }
+	}
+	
+	private String evaluateFileNameMapping( String expression, Artifact artifact )
+    throws Exception
+	{
+	    // this matches the last ${...} string
+	    Pattern pat = Pattern.compile( "^(.*)\\$\\{([^\\}]+)\\}(.*)$" );
+	    Matcher mat = pat.matcher( expression );
+	
+	    String left,right;
+	    Object middle;
+	
+	    if ( mat.matches() )
+	    {
+	        left = evaluateFileNameMapping( mat.group( 1 ), artifact );
+	        middle = ReflectionValueExtractor.evaluate( "dep." + mat.group( 2 ), artifact );
+	        right = mat.group( 3 );
+	
+	        if ( middle == null )
+	        {
+	            // TODO: There should be a more generic way dealing with that. Having magic words is not good at all.
+	            // probe for magic word
+	            if ( mat.group( 2 ).trim().equals( "extension" ) )
+	            {
+	                ArtifactHandler artifactHandler = artifact.getArtifactHandler();
+	                middle = artifactHandler.getExtension();
+	            }
+	            else
+	            {
+	                middle = "${" + mat.group( 2 ) + "}";
+	            }
+	        }
+	
+	        return left + middle + right;
+	    }
+	
+	    return expression;
+	}
+	
+	private List getJarExcludes()
+	{
+	    List l = new ArrayList( getDefaultExcludes() );
+	    l.add( "META-INF/**" );
+	    return l;
+	}
+	
+	private String getOutputDirectory( String output, boolean includeBaseDirectory )
+	{
+	    if ( output == null )
+	    {
+	        output = "";
+	    }
+	    if ( !output.endsWith( "/" ) && !output.endsWith( "\\" ) )
+	    {
+	        // TODO: shouldn't archiver do this?
+	        output += '/';
+	    }
+	
+	    if ( includeBaseDirectory )
+	    {
+	        if ( output.startsWith( "/" ) )
+	        {
+	            output = finalName + output;
+	        }
+	        else
+	        {
+	            output = finalName + "/" + output;
+	        }
+	    }
+	    else
+	    {
+	        if ( output.startsWith( "/" ) )
+	        {
+	            output = output.substring( 1 );
+	        }
+	    }
+	    return output;
+	}
+	
+	private Archiver createArchiver( String format )
+	    throws ArchiverException
+	{
+	    Archiver archiver;
+	    if ( format.startsWith( "tar" ) )
+	    {
+	        TarArchiver tarArchiver = new TarArchiver();
+	        archiver = tarArchiver;
+	        int index = format.indexOf( '.' );
+	        if ( index >= 0 )
+	        {
+	            // TODO: this needs a cleanup in plexus archiver - use a real typesafe enum
+	            TarArchiver.TarCompressionMethod tarCompressionMethod = new TarArchiver.TarCompressionMethod();
+	            // TODO: this should accept gz and bz2 as well so we can skip over the switch
+	            String compression = format.substring( index + 1 );
+	            if ( compression.equals( "gz" ) )
+	            {
+	                tarCompressionMethod.setValue( "gzip" );
+	            }
+	            else if ( compression.equals( "bz2" ) )
+	            {
+	                tarCompressionMethod.setValue( "bzip2" );
+	            }
+	            else
+	            {
+	                // TODO: better handling
+	                throw new IllegalArgumentException( "Unknown compression format: " + compression );
+	            }
+	            tarArchiver.setCompression( tarCompressionMethod );
+	        }
+	
+	        // TODO: should be able to do this on a file/dir basis
+	        tarArchiver.getOptions().setDirMode( "0700" );
+	        tarArchiver.getOptions().setMode( "0700" );
+	    }
+	    else if ( format.startsWith( "zip" ) )
+	    {
+	        archiver = new ZipArchiver();
+	    }
+	    else if ( format.startsWith( "jar" ) )
+	    {
+	        // TODO: use MavenArchiver for manifest?
+	        JarArchiver jarArchiver = new JarArchiver();
+	        jarArchiver.setCompress( true );
+	        archiver = jarArchiver;
+	
+	    }
+	    else
+	    {
+	        // TODO: better handling
+	        throw new IllegalArgumentException( "Unknown format: " + format );
+	    }
+	    return archiver;
+	}
+	
+	public List getDefaultExcludes()
+	{
+	    List defaultExcludes = new ArrayList();
+	    defaultExcludes.add( "**/*~" );
+	    defaultExcludes.add( "**/#*#" );
+	    defaultExcludes.add( "**/.#*" );
+	    defaultExcludes.add( "**/%*%" );
+	    defaultExcludes.add( "**/._*" );
+	
+	    // CVS
+	    defaultExcludes.add( "**/CVS" );
+	    defaultExcludes.add( "**/CVS/**" );
+	    defaultExcludes.add( "**/.cvsignore" );
+	
+	    // SCCS
+	    defaultExcludes.add( "**/SCCS" );
+	    defaultExcludes.add( "**/SCCS/**" );
+	
+	    // Visual SourceSafe
+	    defaultExcludes.add( "**/vssver.scc" );
+	
+	    // Subversion
+	    defaultExcludes.add( "**/.svn" );
+	    defaultExcludes.add( "**/.svn/**" );
+	
+	    // Mac
+	    defaultExcludes.add( "**/.DS_Store" );
+	
+	    return defaultExcludes;
+	}
+	

MOV26 MOV26 MOV23 MOV23 MOV31 MOV31 UPD40 UPD40 UPD43 UPD42 UPD83 UPD83 UPD43 UPD43 UPD42 INS65 UPD42 UPD42 INS65 UPD42 UPD42 UPD42 MOV43 INS42 INS60 MOV21 MOV21 UPD66 UPD66 UPD43 MOV43 INS59 INS32 UPD42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS32 INS32 INS32 INS42 INS33 INS60 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 INS32 INS42 MOV14 INS42 INS42 INS42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL83 DEL85 DEL5 DEL42 DEL4 DEL59 DEL23 DEL66 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL42 DEL43 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL14 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL38 DEL42 DEL32 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL8 DEL25 DEL8 DEL24
OPEN - issue MNG-3027: forked execution does not get configuration from the POM 
http://jira.codehaus.org/browse/MNG-3027

Adding reporting section to sources of plugin configuration when mojos are forked from a report mojo. Also, improving detection/addition of report mojos from a plugin, when no report-set is defined.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@543308 13f79535-47bb-0310-9956-ffa450edef68

-    private final Map forks;
+    private final Map forkedDirectInvocations;
+
+    private final Map forkedPhases;
-        forks = new HashMap();
+        forkedDirectInvocations = new HashMap();
+        forkedPhases = new HashMap();
-    private BuildPlan( final LifecycleBindings bindings, final Map forks, final List lateBoundMojos,
+    private BuildPlan( final LifecycleBindings bindings, final Map forkedDirectInvocations, final Map forkedPhases, final List lateBoundMojos,
-        this.forks = new HashMap( forks );
+        this.forkedDirectInvocations = new HashMap( forkedDirectInvocations );
+        this.forkedPhases = new HashMap( forkedPhases );
-    public Map getForks()
+    public Map getForkedDirectInvocations()
-        return forks;
+        return forkedDirectInvocations;
+    }
+
+    public Map getForkedPhases()
+    {
+        return forkedPhases;
-        forks.put( key, plan );
+        forkedPhases.put( key, plan );
-        forks.put( key, forkedInvocations );
+        List invoke = (List) forkedDirectInvocations.get( key );
+
+        if ( invoke == null )
+        {
+            invoke = new ArrayList();
+            forkedDirectInvocations.put( key, invoke );
+        }
+
+        invoke.addAll( forkedInvocations );
-        return new BuildPlan( bindings, forks, lateBoundMojos, directInvocationBindings, newTasks );
+        return new BuildPlan( bindings, forkedDirectInvocations, forkedPhases, lateBoundMojos, directInvocationBindings, newTasks );
+        for ( Iterator it = forkedPhases.values().iterator(); it.hasNext(); )
+        {
+            BuildPlan plan = (BuildPlan) it.next();
+            plan.resetExecutionProgress();
+        }
-        // let's see if we have any forks...
-        Object fork = forks.get( key );
-
-            if ( fork != null )
+            List forkedBindings = new ArrayList();
+
+            BuildPlan forkedPlan = (BuildPlan) forkedPhases.get( key );
+
+            // if we have a forked build plan, recurse into it and retrieve the execution plan.
+            if ( forkedPlan != null )
-                List forkedBindings = new ArrayList();
+                forkedBindings = forkedPlan.renderExecutionPlan( executionStack );
+            }
-                // if the fork is a build plan, recurse into it and retrieve the execution plan.
-                if ( fork instanceof BuildPlan )
+            List directInvocations = (List) forkedDirectInvocations.get( key );
+
+            // leave room for new kinds of forks, and do some extra validation...
+            // if this is a list, it's a list of direct mojo invocations...we have to see if they have their own
+            // forks.
+            if ( directInvocations != null )
+            {
+                for ( Iterator it = directInvocations.iterator(); it.hasNext(); )
-                    forkedBindings = ( (BuildPlan) fork ).renderExecutionPlan( executionStack );
-                }
-                // leave room for new kinds of forks, and do some extra validation...
-                // if this is a list, it's a list of direct mojo invocations...we have to see if they have their own
-                // forks.
-                else if ( fork instanceof List )
-                {
-                    List directInvocations = (List) fork;
-                    for ( Iterator it = directInvocations.iterator(); it.hasNext(); )
+                    MojoBinding invocation = (MojoBinding) it.next();
+
+                    String invocationKey = MojoBindingUtils.createMojoBindingKey( invocation, false );
+
+                    if ( executionStack.contains( invocationKey ) )
-                        MojoBinding invocation = (MojoBinding) it.next();
-
-                        String invocationKey = MojoBindingUtils.createMojoBindingKey( invocation, false );
-
-                        if ( executionStack.contains( invocationKey ) )
-                        {
-                            continue;
-                        }
-
-                        executionStack.push( MojoBindingUtils.createMojoBindingKey( mojoBinding, false ) );
-
-                        try
-                        {
-                            addResolverIfLateBound( invocation, forkedBindings );
-                            forkedBindings.addAll( findForkedBindings( invocation, executionStack ) );
-                        }
-                        finally
-                        {
-                            executionStack.pop();
-                        }
+                        continue;
-                }
-                if ( !forkedBindings.isEmpty() )
-                {
-                    bindings.add( StateManagementUtils.createStartForkedExecutionMojoBinding() );
-                    bindings.addAll( forkedBindings );
-                    bindings.add( StateManagementUtils.createEndForkedExecutionMojoBinding() );
-                }
-
-                bindings.add( mojoBinding );
-
-                if ( !forkedBindings.isEmpty() )
-                {
-                    bindings.add( StateManagementUtils.createClearForkedExecutionMojoBinding() );
+                    addResolverIfLateBound( invocation, forkedBindings );
+                    forkedBindings.addAll( findForkedBindings( invocation, executionStack ) );
-            else
+
+            if ( !forkedBindings.isEmpty() )
-                bindings.add( mojoBinding );
+                bindings.add( StateManagementUtils.createStartForkedExecutionMojoBinding() );
+                bindings.addAll( forkedBindings );
+                bindings.add( StateManagementUtils.createEndForkedExecutionMojoBinding() );
+            }
+
+            bindings.add( mojoBinding );
+
+            if ( !forkedBindings.isEmpty() )
+            {
+                bindings.add( StateManagementUtils.createClearForkedExecutionMojoBinding() );

MOV31 INS23 INS31 INS83 INS83 MOV43 INS59 INS43 INS44 INS83 MOV43 INS42 INS8 INS43 UPD42 MOV44 MOV44 MOV44 MOV44 INS8 INS8 MOV8 INS42 INS42 UPD42 INS21 UPD42 INS83 INS43 INS42 INS21 INS41 INS42 MOV60 INS60 INS25 INS21 MOV21 INS24 MOV60 MOV60 MOV21 INS54 MOV41 INS7 INS42 INS7 INS42 UPD42 INS43 INS59 INS27 INS8 INS32 INS58 INS32 INS8 MOV8 MOV8 UPD42 INS42 INS14 INS22 INS14 UPD42 UPD42 INS42 INS42 INS11 INS42 INS33 INS21 MOV21 INS42 INS42 INS42 INS42 UPD42 INS43 INS59 INS42 INS42 INS60 INS21 MOV60 INS60 INS25 INS25 MOV25 MOV21 MOV25 MOV21 INS43 UPD42 UPD42 INS52 INS42 INS43 INS42 MOV43 INS32 INS7 INS42 INS42 INS32 INS43 INS59 INS32 MOV43 INS59 INS27 INS8 MOV43 INS27 MOV8 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 UPD42 UPD42 INS32 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS11 INS42 INS33 INS21 INS42 INS33 INS24 INS43 INS42 INS42 INS43 INS32 MOV43 INS32 INS7 MOV43 INS32 MOV58 MOV32 MOV8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 MOV60 MOV60 MOV25 INS42 INS42 INS42 DEL8 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL24 DEL42 DEL42 DEL11 DEL36 DEL32 DEL7 DEL42 DEL62 DEL8 DEL42 DEL62 DEL25 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8
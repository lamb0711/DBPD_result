snapshot resolution. commented out due to issues surrounding pom/artifact pairing


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@163692 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+import java.util.Set;
-/* TODO: use and remove
-    public Artifact transform( Artifact artifact, ArtifactRepository localRepository, List repositories,
-                               Map parameters )
-        throws Exception
+    /**
+     * @todo very primitve. Probably we can resolvedArtifactCache artifacts themselves in a central location, as well as reset the flag over time in a long running process.
+     */
+    private static Set resolvedArtifactCache = new HashSet();
+
+    public Artifact transformForResolve( Artifact artifact, List remoteRepositories,
+                                         ArtifactRepository localRepository )
+        throws ArtifactMetadataRetrievalException
-        Date localVersion = getLocalVersion( artifact, localRepository );
-
-        Date remoteVersion = getRemoteVersion( artifact, repositories, localRepository );
-
-        if ( remoteVersion != null )
+        if ( isSnapshot( artifact ) && !alreadyResolved( artifact ) )
-            //if local version is unknown (null) it means that
-            //we don't have this file locally. so we will be happy
-            // to have any snapshot.
-            // we wil download in two cases:
-            //  a) we don't have any snapot in local repo
-            //  b) we have found newer version in remote repository
-            if ( localVersion == null || localVersion.before( remoteVersion ) )
+            // TODO: this mostly works, however...
+            //  - poms and jars are different, so both are checked individually
+            //  - when a pom is downloaded, it prevents the JAR getting downloaded because of the timestamp
+            //  - need to gather first, group them all up by groupId/artifactId, then go after them
+/*
+            SnapshotArtifactMetadata localMetadata;
+            try
-                // here we know that we have artifact like foo-1.2-SNAPSHOT.jar
-                // and the remote timestamp is something like 20010304.121212
-                // so we might as well fetch foo-1.2-20010304.121212.jar
-                // but we are just going to fetch foo-1.2-SNAPSHOT.jar.
-                // We can change the strategy which is used here later on
+                localMetadata = SnapshotArtifactMetadata.readLocalSnapshotMetadata( artifact, localRepository );
+            }
+            catch ( ArtifactPathFormatException e )
+            {
+                throw new ArtifactMetadataRetrievalException( "Error reading local metadata", e );
+            }
+            catch ( IOException e )
+            {
+                throw new ArtifactMetadataRetrievalException( "Error reading local metadata", e );
+            }
-                // @todo we will delete old file first.
-                //it is not really a right thing to do. Artifact Dowloader
-                // should
-                // fetch to temprary file and replace the old file with the new
-                // one once download was finished
+            boolean foundRemote = false;
+            for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
+            {
+                ArtifactRepository remoteRepository = (ArtifactRepository) i.next();
-                artifact.getFile().delete();
+                SnapshotArtifactMetadata remoteMetadata = SnapshotArtifactMetadata.createRemoteSnapshotMetadata(
+                    artifact );
+                remoteMetadata.retrieveFromRemoteRepository( remoteRepository, wagonManager );
-                artifactResolver.resolve( artifact, repositories, localRepository );
-
-                File snapshotVersionFile = getSnapshotVersionFile( artifact, localRepository );
-
-                String timestamp = getTimestamp( remoteVersion );
-
-                // delete old one
-                if ( snapshotVersionFile.exists() )
+                if ( remoteMetadata.compareTo( localMetadata ) > 0 )
-                    snapshotVersionFile.delete();
+                    // TODO: investigate transforming this in place, in which case resolve can return void
+                    artifact = createArtifactCopy( artifact, remoteMetadata );
+                    artifact.setRepository( remoteRepository );
+
+                    localMetadata = remoteMetadata;
+                    foundRemote = true;
-
-                FileUtils.fileWrite( snapshotVersionFile.getPath(), timestamp );
-        }
+            if ( foundRemote )
+            {
+                artifact.addMetadata( localMetadata );
+            }
+*/
+            resolvedArtifactCache.add( getCacheKey( artifact ) );
+        }
-    private File getSnapshotVersionFile( Artifact artifact, ArtifactRepository localRepository )
+    private boolean alreadyResolved( Artifact artifact )
-        return null;
-        //return new File( localRepository.fullArtifactPath( artifact ) );
+        return resolvedArtifactCache.contains( getCacheKey( artifact ) );
-    private Date getRemoteVersion( Artifact artifact, List remoteRepositories, ArtifactRepository localRepository )
-        throws Exception
+    private static String getCacheKey( Artifact artifact )
-        Date retValue = null;
-
-        artifactResolver.resolve( artifact, remoteRepositories, localRepository );
-
-        String timestamp = FileUtils.fileRead( artifact.getPath() );
-
-        retValue = parseTimestamp( timestamp );
-
-        return retValue;
-    }
-
-    private Date getLocalVersion( Artifact artifact, ArtifactRepository localRepository )
-    {
-        //assert artifact.exists();
-
-        Date retValue = null;
-
-        try
-        {
-            File file = getSnapshotVersionFile( artifact, localRepository );
-
-            if ( file.exists() )
-            {
-                String timestamp = FileUtils.fileRead( file );
-
-                retValue = parseTimestamp( timestamp );
-
-            }
-        }
-        catch ( Exception e )
-        {
-            // ignore
-        }
-
-        if ( retValue == null )
-        {
-            //try "traditional method" used in maven1 for obtaining snapshot
-            // version
-
-            File file = artifact.getFile();
-
-            if ( file.exists() )
-            {
-                retValue = new Date( file.lastModified() );
-
-                //@todo we should "normalize" the time.
-
-                //
-                // TimeZone gmtTimeZone = TimeZone.getTimeZone( "GMT" );
-                // TimeZone userTimeZone = TimeZone.getDefault(); long diff =
-                //
-            }
-        }
-
-        return retValue;
-    }
-
-    private final static String DATE_FORMAT = "yyyyMMdd.HHmmss";
-
-    private static SimpleDateFormat getFormatter()
-    {
-        SimpleDateFormat formatter = new SimpleDateFormat( DATE_FORMAT );
-
-        formatter.setTimeZone( TimeZone.getTimeZone( "GMT" ) );
-
-        return formatter;
-    }
-
-    public static String getTimestamp()
-    {
-        Date now = new Date();
-
-        SimpleDateFormat formatter = getFormatter();
-
-        String retValue = formatter.format( now );
-
-        return retValue;
-    }
-
-    public static Date parseTimestamp( String timestamp )
-        throws ParseException
-    {
-        Date retValue = getFormatter().parse( timestamp );
-
-        return retValue;
-    }
-
-    public static String getTimestamp( Date snapshotVersion )
-    {
-        String retValue = getFormatter().format( snapshotVersion );
-
-        return retValue;
-    }
-    */
-    public Artifact transformForResolve( Artifact artifact )
-    {
-        // TODO: implement
-        return artifact;
+        return artifact.getConflictId();
-            List list = artifact.getMetadataList();
-            artifact = new DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(), metadata.getVersion(),
-                                            artifact.getScope(), artifact.getType(), artifact.getClassifier() );
-            for ( Iterator i = list.iterator(); i.hasNext(); )
-            {
-                ArtifactMetadata m = (ArtifactMetadata) i.next();
-                m.setArtifact( artifact );
-                artifact.addMetadata( m );
-            }
+            artifact = createArtifactCopy( artifact, metadata );
+    private Artifact createArtifactCopy( Artifact artifact, SnapshotArtifactMetadata metadata )
+    {
+        List list = artifact.getMetadataList();
+        artifact = new DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(), metadata.getVersion(),
+                                        artifact.getScope(), artifact.getType(), artifact.getClassifier() );
+        for ( Iterator i = list.iterator(); i.hasNext(); )
+        {
+            ArtifactMetadata m = (ArtifactMetadata) i.next();
+            m.setArtifact( artifact );
+            artifact.addMetadata( m );
+        }
+        return artifact;
+    }
+

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS44 MOV44 MOV43 INS8 UPD83 UPD42 INS44 MOV8 INS65 INS42 INS42 INS14 INS43 INS42 INS43 INS42 INS42 INS25 MOV41 INS43 INS42 INS41 INS42 INS43 INS42 INS41 INS42 INS43 INS42 INS25 INS41 INS43 INS42 MOV41 INS66 INS43 INS42 INS42 INS27 INS8 INS42 INS32 INS42 INS32 INS42 MOV32 INS8 INS42 INS42 INS42 INS32 INS38 INS21 INS42 INS42 INS32 INS42 INS42 MOV60 MOV21 MOV21 INS21 MOV21 INS42 INS42 INS32 INS32 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 DEL8 DEL25 DEL8
Fixing infinite recursion when a mojo bound to the lifecycle forks a new phase that contains implies another phase that contains the bound mojo. This was triggered by the assembly:assembly mojo, and should look familiar.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@551696 13f79535-47bb-0310-9956-ffa450edef68

-        addForkedLifecycleModifiers( plan, project );
-        addReportingLifecycleModifiers( plan, project );
+        addForkedLifecycleModifiers( plan, project, new LinkedList() );
+        addReportingLifecycleModifiers( plan, project, new LinkedList() );
+     * @param callStack
-    private void addForkedLifecycleModifiers( final BuildPlan plan, final MavenProject project )
+    private void addForkedLifecycleModifiers( final BuildPlan plan, final MavenProject project, LinkedList callStack )
-            findForkModifiers( mojoBinding, plan, project );
+            findForkModifiers( mojoBinding, plan, project, callStack );
-    private void findForkModifiers( final MojoBinding mojoBinding, final BuildPlan plan, final MavenProject project )
+    private void findForkModifiers( final MojoBinding mojoBinding, final BuildPlan plan, final MavenProject project, LinkedList callStack )
-        findForkModifiers( mojoBinding, pluginDescriptor, plan, project, false );
+        findForkModifiers( mojoBinding, pluginDescriptor, plan, project, false, callStack );
+     * @param callStack
-    private void addReportingLifecycleModifiers( final BuildPlan plan, final MavenProject project )
+    private void addReportingLifecycleModifiers( final BuildPlan plan, final MavenProject project, LinkedList callStack )
-                            findForkModifiers( reportBinding, pd, plan, project, true );
+                            findForkModifiers( reportBinding, pd, plan, project, true, callStack );
+     * @param callStack
-                                    final BuildPlan plan, final MavenProject project, final boolean includeReportConfig )
+                                    final BuildPlan plan, final MavenProject project, final boolean includeReportConfig, LinkedList callStack )
-            recursePhaseMojoFork( mojoBinding, pluginDescriptor, plan, project, includeReportConfig );
+            recursePhaseMojoFork( mojoBinding, pluginDescriptor, plan, project, includeReportConfig, callStack );
-                                       final boolean includeReportConfig )
+                                       final boolean includeReportConfig, LinkedList callStack )
-        String referencingGoal = mojoBinding.getGoal();
+        callStack.addFirst( mojoBinding );
-        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( referencingGoal );
-
-        String phase = mojoDescriptor.getExecutePhase();
-
-        if ( phase == null )
+        try
-            return;
-        }
+            String referencingGoal = mojoBinding.getGoal();
-        if ( !LifecycleUtils.isValidPhaseName( phase ) )
-        {
-            throw new LifecyclePlannerException( "Cannot find lifecycle for phase: " + phase );
-        }
+            MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( referencingGoal );
-        BuildPlan clonedPlan = plan.copy( Collections.singletonList( phase ) );
+            String phase = mojoDescriptor.getExecutePhase();
-        String executeLifecycle = mojoDescriptor.getExecuteLifecycle();
-        if ( executeLifecycle != null )
-        {
-            LifecycleBindings overlayBindings;
-            try
+            if ( phase == null )
-                overlayBindings =
-                    lifecycleBindingManager.getPluginLifecycleOverlay( pluginDescriptor, executeLifecycle, project, includeReportConfig );
-            }
-            catch ( LifecycleLoaderException e )
-            {
-                throw new LifecyclePlannerException( "Failed to load overlay lifecycle: " + executeLifecycle
-                                                     + ". Reason: " + e.getMessage(), e );
+                return;
-            clonedPlan.addLifecycleOverlay( overlayBindings );
+            if ( !LifecycleUtils.isValidPhaseName( phase ) )
+            {
+                throw new LifecyclePlannerException( "Cannot find lifecycle for phase: " + phase );
+            }
+
+            BuildPlan clonedPlan = plan.copy( phase );
+            clonedPlan.removeAll( callStack );
+
+            String executeLifecycle = mojoDescriptor.getExecuteLifecycle();
+            if ( executeLifecycle != null )
+            {
+                LifecycleBindings overlayBindings;
+                try
+                {
+                    overlayBindings =
+                        lifecycleBindingManager.getPluginLifecycleOverlay( pluginDescriptor, executeLifecycle, project, includeReportConfig );
+                }
+                catch ( LifecycleLoaderException e )
+                {
+                    throw new LifecyclePlannerException( "Failed to load overlay lifecycle: " + executeLifecycle
+                                                         + ". Reason: " + e.getMessage(), e );
+                }
+
+                clonedPlan.addLifecycleOverlay( overlayBindings );
+            }
+
+            plan.addForkedExecution( mojoBinding, clonedPlan );
+
+            addForkedLifecycleModifiers( clonedPlan, project, callStack );
+        }
+        finally
+        {
+            callStack.removeFirst();
-        plan.addForkedExecution( mojoBinding, clonedPlan );
-
-        addForkedLifecycleModifiers( clonedPlan, project );
+     * @param callStack

INS44 INS44 INS44 INS44 INS44 INS8 INS65 INS43 INS42 INS43 INS42 INS65 INS43 INS42 INS65 INS43 INS42 INS43 INS42 INS21 INS54 INS65 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV8 INS8 INS42 INS14 INS14 INS42 INS42 INS42 INS42 INS21 INS21 INS43 INS43 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 DEL42 DEL42 DEL32
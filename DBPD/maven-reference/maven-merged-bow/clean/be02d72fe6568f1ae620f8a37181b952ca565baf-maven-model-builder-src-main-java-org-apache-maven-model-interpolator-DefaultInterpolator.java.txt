o only one used interpolator method now, and it's generalized to taking the model and passing in properties so we can make different implementations


git-svn-id: https://svn.apache.org/repos/asf/maven/components/branches/MNG-2766@769682 13f79535-47bb-0310-9956-ffa450edef68

-@Component(role=Interpolator.class)
-public class DefaultInterpolator implements Interpolator {
-	
-	public String interpolateXmlString(String xml,
-			List<InterpolatorProperty> interpolatorProperties) throws IOException 
-	{
-        List<ModelProperty> modelProperties = marshallXmlToModelProperties( new ByteArrayInputStream( xml.getBytes() ), ProjectUri.baseUri, URIS );
+@Component(role = Interpolator.class)
+public class DefaultInterpolator
+    implements Interpolator
+{
+    public PomClassicDomainModel interpolateDomainModel( PomClassicDomainModel dm, Properties properties )
+        throws IOException
+    {
+        List<InterpolatorProperty> props = new ArrayList<InterpolatorProperty>();
+        for ( Entry<Object, Object> e : properties.entrySet() )
+        {
+            props.add( new InterpolatorProperty( (String) e.getKey(), (String) e.getValue(), PomInterpolatorTag.EXECUTION_PROPERTIES.toString() ) );
+        }
+        return interpolateDomainModel( dm, props );
+    }
-        Map<String, String> aliases = new HashMap<String, String>();
-        aliases.put( "project.", "pom." );
+    public PomClassicDomainModel interpolateDomainModel( PomClassicDomainModel dm, List<InterpolatorProperty> interpolatorProperties )
+        throws IOException
+    {
-        List<InterpolatorProperty> ips = new ArrayList<InterpolatorProperty>( interpolatorProperties );
-        ips.addAll( createInterpolatorProperties( modelProperties, ProjectUri.baseUri, aliases, PomInterpolatorTag.PROJECT_PROPERTIES.name()) );
+        if ( dm == null )
+        {
+            throw new IllegalArgumentException( "dm: null" );
+        }
+        if ( !containsProjectVersion( interpolatorProperties ) )
+        {
+            aliases.put( "\\$\\{project.version\\}", "\\$\\{version\\}" );
+        }
+        //TODO: Insert customized logic for parsing
+        List<ModelProperty> modelProperties = getModelProperties( dm.getInputStream() );
+
+        if ( "jar".equals( dm.getModel().getPackaging() ) )
+        {
+            modelProperties.add( new ModelProperty( ProjectUri.packaging, "jar" ) );
+        }
+
+        List<ModelProperty> firstPassModelProperties = new ArrayList<ModelProperty>();
+        List<ModelProperty> secondPassModelProperties = new ArrayList<ModelProperty>();
+
+        ModelProperty buildProperty = new ModelProperty( ProjectUri.Build.xUri, null );
+
+        for ( ModelProperty mp : modelProperties )
+        {
+            if ( mp.getValue() != null && !mp.getUri().contains( "#property" ) && !mp.getUri().contains( "#collection" ) )
+            {
+                if ( ( !buildProperty.isParentOf( mp ) && !mp.getUri().equals( ProjectUri.Reporting.outputDirectory ) || mp.getUri().equals( ProjectUri.Build.finalName ) ) )
+                {
+                    firstPassModelProperties.add( mp );
+                }
+                else
+                {
+                    secondPassModelProperties.add( mp );
+                }
+            }
+        }
+
+        List<InterpolatorProperty> standardInterpolatorProperties = new ArrayList<InterpolatorProperty>();
+
+        if ( dm.isPomInBuild() )
+        {
+            String basedir = dm.getProjectDirectory().getAbsolutePath();
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${project.basedir}", basedir, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${basedir}", basedir, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${pom.basedir}", basedir, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+
+            String baseuri = dm.getProjectDirectory().toURI().toString();
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${project.baseUri}", baseuri, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+            standardInterpolatorProperties.add( new InterpolatorProperty( "${pom.baseUri}", baseuri, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+        }
-                ips.add( new InterpolatorProperty( "${" + uri.substring( uri.lastIndexOf( "/" ) + 1, uri.length() ) + "}", mp.getValue() ) );
+                standardInterpolatorProperties.add( new InterpolatorProperty( "${" + uri.substring( uri.lastIndexOf( "/" ) + 1, uri.length() ) + "}", mp.getValue(),
+                                                                              PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
-        interpolateModelProperties( modelProperties, ips );
-        return unmarshalModelPropertiesToXml( modelProperties, ProjectUri.baseUri );
-	} 
+        // FIRST PASS - Withhold using build directories as interpolator
+        // properties
+        List<InterpolatorProperty> ips1 = new ArrayList<InterpolatorProperty>( interpolatorProperties );
+        ips1.addAll( standardInterpolatorProperties );
+        ips1.addAll( createInterpolatorProperties( firstPassModelProperties, ProjectUri.baseUri, aliases, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+        Collections.sort( ips1, new Comparator<InterpolatorProperty>()
+        {
+            public int compare( InterpolatorProperty o, InterpolatorProperty o1 )
+            {
+                if ( o.getTag() == null || o1.getTag() == null )
+                {
+                    return 0;
+                }
+                return PomInterpolatorTag.valueOf( o.getTag() ).compareTo( PomInterpolatorTag.valueOf( o1.getTag() ) );
+            }
+        } );
-    public PomClassicDomainModel interpolateDomainModel( PomClassicDomainModel dm, Properties properties  )
-		throws IOException 
-	{
-    	List<InterpolatorProperty> props = new ArrayList<InterpolatorProperty>();
-    	for(Entry<Object, Object> e : properties
-					.entrySet())
-    	{
-    		props.add(new InterpolatorProperty((String) e.getKey(), (String) e.getValue(), PomInterpolatorTag.EXECUTION_PROPERTIES.toString()));
-    	}
-    	return interpolateDomainModel(dm, props);
+        interpolateModelProperties( modelProperties, ips1 );
+
+        // SECOND PASS - Set absolute paths on build directories
+        if ( dm.isPomInBuild() )
+        {
+            String basedir = dm.getProjectDirectory().getAbsolutePath();
+            Map<ModelProperty, ModelProperty> buildDirectories = new HashMap<ModelProperty, ModelProperty>();
+            for ( ModelProperty mp : secondPassModelProperties )
+            {
+                if ( mp.getUri().startsWith( ProjectUri.Build.xUri ) || mp.getUri().equals( ProjectUri.Reporting.outputDirectory ) )
+                {
+                    File file = new File( mp.getResolvedValue() );
+                    if ( !file.isAbsolute() && !mp.getResolvedValue().startsWith( "${project.build." ) && !mp.getResolvedValue().equals( "${project.basedir}" ) )
+                    {
+                        buildDirectories.put( mp, new ModelProperty( mp.getUri(), new File( basedir, file.getPath() ).getAbsolutePath() ) );
+                    }
+                }
+            }
+            for ( Map.Entry<ModelProperty, ModelProperty> e : buildDirectories.entrySet() )
+            {
+                secondPassModelProperties.remove( e.getKey() );
+                secondPassModelProperties.add( e.getValue() );
+            }
+        }
+
+        // THIRD PASS - Use build directories as interpolator properties
+        List<InterpolatorProperty> ips2 = new ArrayList<InterpolatorProperty>( interpolatorProperties );
+        ips2.addAll( standardInterpolatorProperties );
+        ips2.addAll( createInterpolatorProperties( secondPassModelProperties, ProjectUri.baseUri, aliases, PomInterpolatorTag.PROJECT_PROPERTIES.name() ) );
+        ips2.addAll( interpolatorProperties );
+        Collections.sort( ips2, new Comparator<InterpolatorProperty>()
+        {
+            public int compare( InterpolatorProperty o, InterpolatorProperty o1 )
+            {
+                if ( o.getTag() == null || o1.getTag() == null )
+                {
+                    return 0;
+                }
+
+                return PomInterpolatorTag.valueOf( o.getTag() ).compareTo( PomInterpolatorTag.valueOf( o1.getTag() ) );
+            }
+        } );
+
+        interpolateModelProperties( modelProperties, ips2 );
+
+        try
+        {
+            String xml = unmarshalModelPropertiesToXml( modelProperties, ProjectUri.baseUri );
+            PomClassicDomainModel domainModel = new PomClassicDomainModel( new ByteArrayInputStream( xml.getBytes( "UTF-8" ) ) );
+            if ( dm.getProjectDirectory() != null )
+            {
+                alignPaths( domainModel.getModel(), dm.getProjectDirectory() );
+            }
+            return domainModel;
+        }
+        catch ( IOException e )
+        {
+            throw new IllegalStateException( "Unmarshalling of model properties failed", e );
+        }
+
+        /*
+        for(ModelProperty mp : modelProperties)
+        {
+        	if((mp.getValue() != null) && !mp.getValue().equals(mp.getResolvedValue()))
+        	{
+        		if(mp.getUri().equals(ProjectUri.version))
+        		{
+        			
+        		}
+        	}
+        }
+        */
-    
-    public PomClassicDomainModel interpolateDomainModel( PomClassicDomainModel dm, List<InterpolatorProperty> interpolatorProperties )
-		throws IOException {
-	
-		if (dm == null) {
-			throw new IllegalArgumentException("dm: null");
-		}
-		if (!containsProjectVersion(interpolatorProperties)) {
-			aliases.put("\\$\\{project.version\\}", "\\$\\{version\\}");
-		}
-		//TODO: Insert customized logic for parsing
-		List<ModelProperty> modelProperties = getModelProperties(dm.getInputStream());
-	
-		if ("jar".equals(dm.getModel().getPackaging())) {
-			modelProperties.add(new ModelProperty(ProjectUri.packaging, "jar"));
-		}
-	
-		List<ModelProperty> firstPassModelProperties = new ArrayList<ModelProperty>();
-		List<ModelProperty> secondPassModelProperties = new ArrayList<ModelProperty>();
-	
-		ModelProperty buildProperty = new ModelProperty(ProjectUri.Build.xUri,
-				null);
-	
-	    for ( ModelProperty mp : modelProperties )
-	    {
-	        if ( mp.getValue() != null && !mp.getUri().contains( "#property" ) && !mp.getUri().contains( "#collection" ) )
-	        {
-	            if ( ( !buildProperty.isParentOf( mp ) && !mp.getUri().equals( ProjectUri.Reporting.outputDirectory ) || mp.getUri().equals(
-	                                                                                                                                         ProjectUri.Build.finalName ) ) )
-	            {
-	                firstPassModelProperties.add( mp );
-	            }
-	            else
-	            {
-	                secondPassModelProperties.add( mp );
-	            }
-	        }
-	    }
-	
-		List<InterpolatorProperty> standardInterpolatorProperties = new ArrayList<InterpolatorProperty>();
-	
-		if (dm.isPomInBuild()) {
-			String basedir = dm.getProjectDirectory().getAbsolutePath();
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${project.basedir}", basedir,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${basedir}", basedir,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${pom.basedir}", basedir,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-	
-			String baseuri = dm.getProjectDirectory().toURI().toString();
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${project.baseUri}", baseuri,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			standardInterpolatorProperties.add(new InterpolatorProperty(
-					"${pom.baseUri}", baseuri,
-					PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-		}
-	
-		for (ModelProperty mp : modelProperties) {
-			if (mp.getUri().startsWith(ProjectUri.properties)
-					&& mp.getValue() != null) {
-				String uri = mp.getUri();
-				standardInterpolatorProperties.add(new InterpolatorProperty(
-						"${"
-								+ uri.substring(uri.lastIndexOf("/") + 1, uri
-										.length()) + "}", mp.getValue(),
-						PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-			}
-		}
-	
-		// FIRST PASS - Withhold using build directories as interpolator
-		// properties
-		List<InterpolatorProperty> ips1 = new ArrayList<InterpolatorProperty>(
-				interpolatorProperties);
-		ips1.addAll(standardInterpolatorProperties);
-		ips1.addAll(createInterpolatorProperties(
-				firstPassModelProperties, ProjectUri.baseUri, aliases,
-				PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-		Collections.sort(ips1, new Comparator<InterpolatorProperty>() {
-			public int compare(InterpolatorProperty o, InterpolatorProperty o1) {
-				if (o.getTag() == null || o1.getTag() == null) {
-					return 0;
-				}
-				return PomInterpolatorTag.valueOf(o.getTag()).compareTo(
-						PomInterpolatorTag.valueOf(o1.getTag()));
-			}
-		});
-	
-		interpolateModelProperties(modelProperties, ips1);
-	
-		// SECOND PASS - Set absolute paths on build directories
-		if (dm.isPomInBuild()) {
-			String basedir = dm.getProjectDirectory().getAbsolutePath();
-			Map<ModelProperty, ModelProperty> buildDirectories = new HashMap<ModelProperty, ModelProperty>();
-			for (ModelProperty mp : secondPassModelProperties) {
-				if (mp.getUri().startsWith(ProjectUri.Build.xUri)
-						|| mp.getUri().equals(
-								ProjectUri.Reporting.outputDirectory)) {
-					File file = new File(mp.getResolvedValue());
-					if (!file.isAbsolute()
-							&& !mp.getResolvedValue().startsWith(
-									"${project.build.")
-							&& !mp.getResolvedValue().equals(
-									"${project.basedir}")) {
-						buildDirectories.put(mp, new ModelProperty(mp.getUri(),
-								new File(basedir, file.getPath())
-										.getAbsolutePath()));
-					}
-				}
-			}
-			for (Map.Entry<ModelProperty, ModelProperty> e : buildDirectories
-					.entrySet()) {
-				secondPassModelProperties.remove(e.getKey());
-				secondPassModelProperties.add(e.getValue());
-			}
-		}
-	
-		// THIRD PASS - Use build directories as interpolator properties
-		List<InterpolatorProperty> ips2 = new ArrayList<InterpolatorProperty>(
-				interpolatorProperties);
-		ips2.addAll(standardInterpolatorProperties);
-		ips2.addAll(createInterpolatorProperties(
-				secondPassModelProperties, ProjectUri.baseUri, aliases,
-				PomInterpolatorTag.PROJECT_PROPERTIES.name()));
-		ips2.addAll(interpolatorProperties);
-		Collections.sort(ips2, new Comparator<InterpolatorProperty>() {
-			public int compare(InterpolatorProperty o, InterpolatorProperty o1) {
-				if (o.getTag() == null || o1.getTag() == null) {
-					return 0;
-				}
-	
-				return PomInterpolatorTag.valueOf(o.getTag()).compareTo(
-						PomInterpolatorTag.valueOf(o1.getTag()));
-			}
-		});
-	
-		interpolateModelProperties(modelProperties, ips2);
-		
-	    try
-	    {
-	        String xml = unmarshalModelPropertiesToXml( modelProperties, ProjectUri.baseUri );
-	        PomClassicDomainModel domainModel = new PomClassicDomainModel( new ByteArrayInputStream ( xml.getBytes( "UTF-8" )));
-	    	if ( dm.getProjectDirectory() != null )
-	    	{
-	    		alignPaths(domainModel.getModel(), dm.getProjectDirectory());
-	    	}
-	    	return domainModel;
-	    }
-	    catch ( IOException e )
-	    {
-	        throw new IllegalStateException( "Unmarshalling of model properties failed", e );
-	    }
-	    
-		
-		
-	    /*
-		for(ModelProperty mp : modelProperties)
-		{
-			if((mp.getValue() != null) && !mp.getValue().equals(mp.getResolvedValue()))
-			{
-				if(mp.getUri().equals(ProjectUri.version))
-				{
-					
-				}
-			}
-		}
-		*/
-	}
+
-     * Post-processes the paths of build directories by aligning relative paths to the project directory and normalizing
-     * file separators to the platform-specific separator.
+     * Post-processes the paths of build directories by aligning relative paths to the project
+     * directory and normalizing file separators to the platform-specific separator.
-    
-    private static String getAlignedPathFor(String path, File basedir)
+
+    private static String getAlignedPathFor( String path, File basedir )
-        }   
+        }
-    }	
-	private static void interpolateModelProperties(List<ModelProperty> modelProperties, 
-	        List<InterpolatorProperty> interpolatorProperties )
-	{
-		if (modelProperties == null) {
-			throw new IllegalArgumentException("modelProperties: null");
-		}
-	
-		if (interpolatorProperties == null) {
-			throw new IllegalArgumentException("interpolatorProperties: null");
-		}
-	
-		List<ModelProperty> unresolvedProperties = new ArrayList<ModelProperty>();
-		for (ModelProperty mp : modelProperties) {
-			if (!mp.isResolved()) {
-				unresolvedProperties.add(mp);
-			}
-		}
-	
-		LinkedHashSet<InterpolatorProperty> ips = new LinkedHashSet<InterpolatorProperty>();
-		ips.addAll(interpolatorProperties);
-		boolean continueInterpolation = true;
-		while (continueInterpolation) {
-			continueInterpolation = false;
-			for (InterpolatorProperty ip : ips) {
-				for (ModelProperty mp : unresolvedProperties) {
-					if (mp.resolveWith(ip) && !continueInterpolation) {
-						continueInterpolation = true;
-						break;
-					}
-				}
-			}
-		}
-	}
-	
-	private static List<InterpolatorProperty> createInterpolatorProperties(List<ModelProperty> modelProperties,
-	        String baseUriForModel,
-	        Map<String, String> aliases,
-	        String interpolatorTag)
-	{
-		if (modelProperties == null) {
-			throw new IllegalArgumentException("modelProperties: null");
-		}
-	
-		if (baseUriForModel == null) {
-			throw new IllegalArgumentException("baseUriForModel: null");
-		}
-	
-		List<InterpolatorProperty> interpolatorProperties = new ArrayList<InterpolatorProperty>();
-	
-		for (ModelProperty mp : modelProperties) {
-			InterpolatorProperty ip = mp
-					.asInterpolatorProperty(baseUriForModel);
-			if (ip != null) {
-				ip.setTag(interpolatorTag);
-				interpolatorProperties.add(ip);
-				for (Map.Entry<String, String> a : aliases.entrySet()) {
-					interpolatorProperties.add(new InterpolatorProperty(ip
-							.getKey().replaceAll(a.getKey(), a.getValue()), ip
-							.getValue().replaceAll(a.getKey(), a.getValue()),
-							interpolatorTag));
-				}
-			}
-		}
-	
-		List<InterpolatorProperty> ips = new ArrayList<InterpolatorProperty>();
-		for (InterpolatorProperty ip : interpolatorProperties) {
-			if (!ips.contains(ip)) {
-				ips.add(ip);
-			}
-		}
-		return ips;
-	}
-	
-    private static List<ModelProperty> getModelProperties(InputStream is) throws IOException
+    }
+
+    private static void interpolateModelProperties( List<ModelProperty> modelProperties, List<InterpolatorProperty> interpolatorProperties )
-            Set<String> s = new HashSet<String>();
-            //TODO: Should add all collections from ProjectUri
-            s.addAll(URIS);
-            s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);
-            s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);
-            s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);
-            s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);
-            //TODO: More profile info
-            s.add(ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Profiles.Profile.Dependencies.Dependency.Exclusions.xUri);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);
-            s.add(ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.xUri);
-            s.add(ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.configuration);
-            s.add(ProjectUri.Profiles.Profile.properties);
-            s.add(ProjectUri.Profiles.Profile.modules);
-            s.add(ProjectUri.Profiles.Profile.Dependencies.xUri);
-            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.configuration);
-            
-        return new ArrayList<ModelProperty>(marshallXmlToModelProperties(is, ProjectUri.baseUri, s ));
-    }    
-    
+        if ( modelProperties == null )
+        {
+            throw new IllegalArgumentException( "modelProperties: null" );
+        }
+
+        if ( interpolatorProperties == null )
+        {
+            throw new IllegalArgumentException( "interpolatorProperties: null" );
+        }
+
+        List<ModelProperty> unresolvedProperties = new ArrayList<ModelProperty>();
+        for ( ModelProperty mp : modelProperties )
+        {
+            if ( !mp.isResolved() )
+            {
+                unresolvedProperties.add( mp );
+            }
+        }
+
+        LinkedHashSet<InterpolatorProperty> ips = new LinkedHashSet<InterpolatorProperty>();
+        ips.addAll( interpolatorProperties );
+        boolean continueInterpolation = true;
+        while ( continueInterpolation )
+        {
+            continueInterpolation = false;
+            for ( InterpolatorProperty ip : ips )
+            {
+                for ( ModelProperty mp : unresolvedProperties )
+                {
+                    if ( mp.resolveWith( ip ) && !continueInterpolation )
+                    {
+                        continueInterpolation = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    private static List<InterpolatorProperty> createInterpolatorProperties( List<ModelProperty> modelProperties, String baseUriForModel, Map<String, String> aliases, String interpolatorTag )
+    {
+        if ( modelProperties == null )
+        {
+            throw new IllegalArgumentException( "modelProperties: null" );
+        }
+
+        if ( baseUriForModel == null )
+        {
+            throw new IllegalArgumentException( "baseUriForModel: null" );
+        }
+
+        List<InterpolatorProperty> interpolatorProperties = new ArrayList<InterpolatorProperty>();
+
+        for ( ModelProperty mp : modelProperties )
+        {
+            InterpolatorProperty ip = mp.asInterpolatorProperty( baseUriForModel );
+            if ( ip != null )
+            {
+                ip.setTag( interpolatorTag );
+                interpolatorProperties.add( ip );
+                for ( Map.Entry<String, String> a : aliases.entrySet() )
+                {
+                    interpolatorProperties.add( new InterpolatorProperty( ip.getKey().replaceAll( a.getKey(), a.getValue() ), ip.getValue().replaceAll( a.getKey(), a.getValue() ), interpolatorTag ) );
+                }
+            }
+        }
+
+        List<InterpolatorProperty> ips = new ArrayList<InterpolatorProperty>();
+        for ( InterpolatorProperty ip : interpolatorProperties )
+        {
+            if ( !ips.contains( ip ) )
+            {
+                ips.add( ip );
+            }
+        }
+        return ips;
+    }
+
+    private static List<ModelProperty> getModelProperties( InputStream is )
+        throws IOException
+    {
+        Set<String> s = new HashSet<String>();
+        //TODO: Should add all collections from ProjectUri
+        s.addAll( URIS );
+        s.add( ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Build.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI );
+        s.add( ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri );
+        s.add( ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration );
+        s.add( ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration );
+        //TODO: More profile info
+        s.add( ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Profiles.Profile.Dependencies.Dependency.Exclusions.xUri );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.Goals.xURI );
+        s.add( ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.xUri );
+        s.add( ProjectUri.Profiles.Profile.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.Execution.configuration );
+        s.add( ProjectUri.Profiles.Profile.properties );
+        s.add( ProjectUri.Profiles.Profile.modules );
+        s.add( ProjectUri.Profiles.Profile.Dependencies.xUri );
+        s.add( ProjectUri.Profiles.Profile.Build.Plugins.Plugin.configuration );
+
+        return new ArrayList<ModelProperty>( marshallXmlToModelProperties( is, ProjectUri.baseUri, s ) );
+    }
+
-     *
+     * 
-     * @param baseUri         the base uri of every model property. May not be null or empty.
+     * @param baseUri the base uri of every model property. May not be null or empty.
-                throw new IllegalArgumentException(
-                    "Passed in model property that does not match baseUri: Property URI = " + uri + ", Base URI = " +
-                        baseUri );
+                throw new IllegalArgumentException( "Passed in model property that does not match baseUri: Property URI = " + uri + ", Base URI = " + baseUri );
-            for(int peekIndex = modelProperties.indexOf( mp ) + 1; peekIndex < modelProperties.size(); peekIndex++)
+            for ( int peekIndex = modelProperties.indexOf( mp ) + 1; peekIndex < modelProperties.size(); peekIndex++ )
-                        attributes.add(peekProperty);
+                        attributes.add( peekProperty );
-     * Returns list of tag names parsed from the specified uri. All #collection parts of the tag are removed from the
-     * tag names.
-     *
+     * Returns list of tag names parsed from the specified uri. All #collection parts of the tag are
+     * removed from the tag names.
+     * 
-     * @param uri          the uri to parse for tag names
+     * @param uri the uri to parse for tag names
-        return Arrays.asList( uri.substring( basePosition ).replaceAll( "#collection", "" )
-                .replaceAll("#set", "").split( "/" ) );
+        return Arrays.asList( uri.substring( basePosition ).replaceAll( "#collection", "" ).replaceAll( "#set", "" ).split( "/" ) );
-     *
-     * @param value     the value to use for the start tag
+     * 
+     * @param value the value to use for the start tag
-            for(ModelProperty attribute : attributes)
+            for ( ModelProperty attribute : attributes )
-                sb.append( " " ).append(
-                    attribute.getUri().substring( attribute.getUri().indexOf( "#property/" ) + 10 ) ).append( "=\"" )
-                    .append( attribute.getResolvedValue() ).append( "\" " );
+                sb.append( " " ).append( attribute.getUri().substring( attribute.getUri().indexOf( "#property/" ) + 10 ) ).append( "=\"" ).append( attribute.getResolvedValue() ).append( "\" " );
-     *
+     * 
-    }    
-    
+    }
-    private static final Set<String> URIS = Collections.unmodifiableSet(new HashSet<String>( Arrays.asList(  ProjectUri.Build.Extensions.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.configuration,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.Execution.Goals.xURI,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.Dependency.Exclusions.xUri,
-            ProjectUri.Build.Plugins.xUri,
-            ProjectUri.properties,
-            ProjectUri.Build.Plugins.Plugin.configuration,
-            ProjectUri.Reporting.Plugins.xUri,
-            ProjectUri.Reporting.Plugins.Plugin.configuration,
-            ProjectUri.Build.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Build.Resources.xUri,
-            ProjectUri.Build.Resources.Resource.includes,
-            ProjectUri.Build.Resources.Resource.excludes,
-            ProjectUri.Build.TestResources.xUri,
-            ProjectUri.Build.Filters.xUri,
-            ProjectUri.CiManagement.Notifiers.xUri,
-            ProjectUri.Contributors.xUri,
-            ProjectUri.Dependencies.xUri,
-            ProjectUri.DependencyManagement.Dependencies.xUri,
-            ProjectUri.Developers.xUri,
-            ProjectUri.Developers.Developer.roles,
-            ProjectUri.Licenses.xUri,
-            ProjectUri.MailingLists.xUri,
-            ProjectUri.Modules.xUri,
-            ProjectUri.PluginRepositories.xUri,
-            ProjectUri.Profiles.xUri,
-            ProjectUri.Profiles.Profile.Build.Plugins.xUri,
-            ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri,
-            ProjectUri.Profiles.Profile.Build.Resources.xUri,
-            ProjectUri.Profiles.Profile.Build.TestResources.xUri,
-            ProjectUri.Profiles.Profile.Dependencies.xUri,
-            ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.xUri,
-            ProjectUri.Profiles.Profile.PluginRepositories.xUri,
-            ProjectUri.Profiles.Profile.Reporting.Plugins.xUri,
-            ProjectUri.Profiles.Profile.Repositories.xUri,
-            ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.xUri,
-            ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
-            ProjectUri.Reporting.Plugins.xUri,
-            ProjectUri.Repositories.xUri) ));    
-    
-   /**
-    * Returns list of model properties transformed from the specified input stream.
-    *
-    * @param inputStream input stream containing the xml document. May not be null.
-    * @param baseUri     the base uri of every model property. May not be null or empty.
-    * @param collections set of uris that are to be treated as a collection (multiple entries). May be null.
-    * @return list of model properties transformed from the specified input stream.
-    * @throws IOException if there was a problem doing the transform
-    */
-    private static List<ModelProperty> marshallXmlToModelProperties( InputStream inputStream, String baseUri,
-            Set<String> collections )
-			throws IOException {
-		if (inputStream == null) {
-			throw new IllegalArgumentException("inputStream: null");
-		}
+    private static final Set<String> URIS = Collections.unmodifiableSet( new HashSet<String>( Arrays.asList( ProjectUri.Build.Extensions.xUri, ProjectUri.Build.PluginManagement.Plugins.xUri,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.configuration,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.Execution.Goals.xURI,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
+                                                                                                             ProjectUri.Build.PluginManagement.Plugins.Plugin.Dependencies.Dependency.Exclusions.xUri,
+                                                                                                             ProjectUri.Build.Plugins.xUri, ProjectUri.properties,
+                                                                                                             ProjectUri.Build.Plugins.Plugin.configuration, ProjectUri.Reporting.Plugins.xUri,
+                                                                                                             ProjectUri.Reporting.Plugins.Plugin.configuration,
+                                                                                                             ProjectUri.Build.Plugins.Plugin.Dependencies.xUri, ProjectUri.Build.Resources.xUri,
+                                                                                                             ProjectUri.Build.Resources.Resource.includes,
+                                                                                                             ProjectUri.Build.Resources.Resource.excludes, ProjectUri.Build.TestResources.xUri,
+                                                                                                             ProjectUri.Build.Filters.xUri, ProjectUri.CiManagement.Notifiers.xUri,
+                                                                                                             ProjectUri.Contributors.xUri, ProjectUri.Dependencies.xUri,
+                                                                                                             ProjectUri.DependencyManagement.Dependencies.xUri, ProjectUri.Developers.xUri,
+                                                                                                             ProjectUri.Developers.Developer.roles, ProjectUri.Licenses.xUri,
+                                                                                                             ProjectUri.MailingLists.xUri, ProjectUri.Modules.xUri, ProjectUri.PluginRepositories.xUri,
+                                                                                                             ProjectUri.Profiles.xUri, ProjectUri.Profiles.Profile.Build.Plugins.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Dependencies.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.Plugins.Plugin.Executions.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.Resources.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.TestResources.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Dependencies.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.DependencyManagement.Dependencies.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.PluginRepositories.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Reporting.Plugins.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Repositories.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.xUri,
+                                                                                                             ProjectUri.Profiles.Profile.Build.PluginManagement.Plugins.Plugin.Dependencies.xUri,
+                                                                                                             ProjectUri.Reporting.Plugins.xUri, ProjectUri.Repositories.xUri ) ) );
-		if (baseUri == null || baseUri.trim().length() == 0) {
-			throw new IllegalArgumentException("baseUri: null");
-		}
+    /**
+     * Returns list of model properties transformed from the specified input stream.
+     * 
+     * @param inputStream input stream containing the xml document. May not be null.
+     * @param baseUri the base uri of every model property. May not be null or empty.
+     * @param collections set of uris that are to be treated as a collection (multiple entries). May
+     *            be null.
+     * @return list of model properties transformed from the specified input stream.
+     * @throws IOException if there was a problem doing the transform
+     */
+    private static List<ModelProperty> marshallXmlToModelProperties( InputStream inputStream, String baseUri, Set<String> collections )
+        throws IOException
+    {
+        if ( inputStream == null )
+        {
+            throw new IllegalArgumentException( "inputStream: null" );
+        }
-		if (collections == null) {
-			collections = Collections.emptySet();
-		}
+        if ( baseUri == null || baseUri.trim().length() == 0 )
+        {
+            throw new IllegalArgumentException( "baseUri: null" );
+        }
-		List<ModelProperty> modelProperties = new ArrayList<ModelProperty>();
-		XMLInputFactory xmlInputFactory = new com.ctc.wstx.stax.WstxInputFactory();
-		xmlInputFactory.setProperty(
-				XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE);
-		xmlInputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE,
-				Boolean.FALSE);
+        if ( collections == null )
+        {
+            collections = Collections.emptySet();
+        }
-		Uri uri = new Uri(baseUri);
-		String tagName = baseUri;
-		StringBuilder tagValue = new StringBuilder(256);
+        List<ModelProperty> modelProperties = new ArrayList<ModelProperty>();
+        XMLInputFactory xmlInputFactory = new com.ctc.wstx.stax.WstxInputFactory();
+        xmlInputFactory.setProperty( XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE );
+        xmlInputFactory.setProperty( XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE );
-		int depth = 0;
-		int depthOfTagValue = depth;
-		XMLStreamReader xmlStreamReader = null;
-		try {
-			xmlStreamReader = xmlInputFactory
-					.createXMLStreamReader(inputStream);
+        Uri uri = new Uri( baseUri );
+        String tagName = baseUri;
+        StringBuilder tagValue = new StringBuilder( 256 );
-			Map<String, String> attributes = new HashMap<String, String>();
-			for (;; xmlStreamReader.next()) {
-				int type = xmlStreamReader.getEventType();
-				switch (type) {
+        int depth = 0;
+        int depthOfTagValue = depth;
+        XMLStreamReader xmlStreamReader = null;
+        try
+        {
+            xmlStreamReader = xmlInputFactory.createXMLStreamReader( inputStream );
-				case XMLStreamConstants.CDATA:
-				case XMLStreamConstants.CHARACTERS: {
-					if (depth == depthOfTagValue) {
-						tagValue.append(xmlStreamReader.getTextCharacters(),
-								xmlStreamReader.getTextStart(), xmlStreamReader
-										.getTextLength());
-					}
-					break;
-				}
+            Map<String, String> attributes = new HashMap<String, String>();
+            for ( ;; xmlStreamReader.next() )
+            {
+                int type = xmlStreamReader.getEventType();
+                switch ( type )
+                {
-				case XMLStreamConstants.START_ELEMENT: {
-					if (!tagName.equals(baseUri)) {
-						String value = null;
-						if (depth < depthOfTagValue) {
-							value = tagValue.toString().trim();
-						}
-						modelProperties.add(new ModelProperty(tagName, value));
-						if (!attributes.isEmpty()) {
-							for (Map.Entry<String, String> e : attributes
-									.entrySet()) {
-								modelProperties.add(new ModelProperty(e
-										.getKey(), e.getValue()));
-							}
-							attributes.clear();
-						}
-					}
+                    case XMLStreamConstants.CDATA:
+                    case XMLStreamConstants.CHARACTERS:
+                    {
+                        if ( depth == depthOfTagValue )
+                        {
+                            tagValue.append( xmlStreamReader.getTextCharacters(), xmlStreamReader.getTextStart(), xmlStreamReader.getTextLength() );
+                        }
+                        break;
+                    }
-					depth++;
-					tagName = uri.getUriFor(xmlStreamReader.getName()
-							.getLocalPart(), depth);
-					if (collections.contains(tagName + "#collection")) {
-						tagName = tagName + "#collection";
-						uri.addTag(xmlStreamReader.getName().getLocalPart()
-								+ "#collection");
-					} else if (collections.contains(tagName + "#set")) {
-						tagName = tagName + "#set";
-						uri.addTag(xmlStreamReader.getName().getLocalPart()
-								+ "#set");
-					} else {
-						uri.addTag(xmlStreamReader.getName().getLocalPart());
-					}
-					tagValue.setLength(0);
-					depthOfTagValue = depth;
-				}
-				case XMLStreamConstants.ATTRIBUTE: {
-					for (int i = 0; i < xmlStreamReader.getAttributeCount(); i++) {
+                    case XMLStreamConstants.START_ELEMENT:
+                    {
+                        if ( !tagName.equals( baseUri ) )
+                        {
+                            String value = null;
+                            if ( depth < depthOfTagValue )
+                            {
+                                value = tagValue.toString().trim();
+                            }
+                            modelProperties.add( new ModelProperty( tagName, value ) );
+                            if ( !attributes.isEmpty() )
+                            {
+                                for ( Map.Entry<String, String> e : attributes.entrySet() )
+                                {
+                                    modelProperties.add( new ModelProperty( e.getKey(), e.getValue() ) );
+                                }
+                                attributes.clear();
+                            }
+                        }
-						attributes.put(tagName
-								+ "#property/"
-								+ xmlStreamReader.getAttributeName(i)
-										.getLocalPart(), xmlStreamReader
-								.getAttributeValue(i));
-					}
-					break;
-				}
-				case XMLStreamConstants.END_ELEMENT: {
-					depth--;
-					break;
-				}
-				case XMLStreamConstants.END_DOCUMENT: {
-					modelProperties.add(new ModelProperty(tagName, tagValue
-							.toString().trim()));
-					if (!attributes.isEmpty()) {
-						for (Map.Entry<String, String> e : attributes
-								.entrySet()) {
-							modelProperties.add(new ModelProperty(e.getKey(), e
-									.getValue()));
-						}
-						attributes.clear();
-					}
-					return modelProperties;
-				}
-				}
-			}
-		} catch (XMLStreamException e) {
-			throw new IOException(":" + e.toString());
-		} finally {
-			if (xmlStreamReader != null) {
-				try {
-					xmlStreamReader.close();
-				} catch (XMLStreamException e) {
-					e.printStackTrace();
-				}
-			}
-			try {
-				inputStream.close();
-			} catch (IOException e) {
+                        depth++;
+                        tagName = uri.getUriFor( xmlStreamReader.getName().getLocalPart(), depth );
+                        if ( collections.contains( tagName + "#collection" ) )
+                        {
+                            tagName = tagName + "#collection";
+                            uri.addTag( xmlStreamReader.getName().getLocalPart() + "#collection" );
+                        }
+                        else if ( collections.contains( tagName + "#set" ) )
+                        {
+                            tagName = tagName + "#set";
+                            uri.addTag( xmlStreamReader.getName().getLocalPart() + "#set" );
+                        }
+                        else
+                        {
+                            uri.addTag( xmlStreamReader.getName().getLocalPart() );
+                        }
+                        tagValue.setLength( 0 );
+                        depthOfTagValue = depth;
+                    }
+                    case XMLStreamConstants.ATTRIBUTE:
+                    {
+                        for ( int i = 0; i < xmlStreamReader.getAttributeCount(); i++ )
+                        {
-			}
-		}
-	}
-    
+                            attributes.put( tagName + "#property/" + xmlStreamReader.getAttributeName( i ).getLocalPart(), xmlStreamReader.getAttributeValue( i ) );
+                        }
+                        break;
+                    }
+                    case XMLStreamConstants.END_ELEMENT:
+                    {
+                        depth--;
+                        break;
+                    }
+                    case XMLStreamConstants.END_DOCUMENT:
+                    {
+                        modelProperties.add( new ModelProperty( tagName, tagValue.toString().trim() ) );
+                        if ( !attributes.isEmpty() )
+                        {
+                            for ( Map.Entry<String, String> e : attributes.entrySet() )
+                            {
+                                modelProperties.add( new ModelProperty( e.getKey(), e.getValue() ) );
+                            }
+                            attributes.clear();
+                        }
+                        return modelProperties;
+                    }
+                }
+            }
+        }
+        catch ( XMLStreamException e )
+        {
+            throw new IOException( ":" + e.toString() );
+        }
+        finally
+        {
+            if ( xmlStreamReader != null )
+            {
+                try
+                {
+                    xmlStreamReader.close();
+                }
+                catch ( XMLStreamException e )
+                {
+                    e.printStackTrace();
+                }
+            }
+            try
+            {
+                inputStream.close();
+            }
+            catch ( IOException e )
+            {
+
+            }
+        }
+    }
+
-        InterpolatorProperty versionInterpolatorProperty =
-            new ModelProperty( ProjectUri.version, "" ).asInterpolatorProperty( ProjectUri.baseUri );
+        InterpolatorProperty versionInterpolatorProperty = new ModelProperty( ProjectUri.version, "" ).asInterpolatorProperty( ProjectUri.baseUri );
-    }    
-   /**
-    * Class for storing information about URIs.
-    */
-   private static class Uri
-   {
+    }
-       List<String> uris;
+    /**
+     * Class for storing information about URIs.
+     */
+    private static class Uri
+    {
-       Uri( String baseUri )
-       {
-           uris = new LinkedList<String>();
-           uris.add( baseUri );
-       }
+        List<String> uris;
-       String getUriFor( String tag, int depth )
-       {
-           setUrisToDepth( depth );
-           StringBuffer sb = new StringBuffer();
-           for ( String tagName : uris )
-           {
-               sb.append( tagName ).append( "/" );
-           }
-           sb.append( tag );
-           return sb.toString();
-       }
+        Uri( String baseUri )
+        {
+            uris = new LinkedList<String>();
+            uris.add( baseUri );
+        }
-       void addTag( String tag )
-       {
-           uris.add( tag );
-       }
+        String getUriFor( String tag, int depth )
+        {
+            setUrisToDepth( depth );
+            StringBuffer sb = new StringBuffer();
+            for ( String tagName : uris )
+            {
+                sb.append( tagName ).append( "/" );
+            }
+            sb.append( tag );
+            return sb.toString();
+        }
-       void setUrisToDepth( int depth )
-       {
-           uris = new LinkedList<String>( uris.subList( 0, depth ) );
-       }
-   }
-       
+        void addTag( String tag )
+        {
+            uris.add( tag );
+        }
+
+        void setUrisToDepth( int depth )
+        {
+            uris = new LinkedList<String>( uris.subList( 0, depth ) );
+        }
+    }
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL40 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL45 DEL45 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL40 DEL42 DEL32 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL45 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL32 DEL45 DEL27 DEL42 DEL42 DEL32 DEL14 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL41 DEL8 DEL31
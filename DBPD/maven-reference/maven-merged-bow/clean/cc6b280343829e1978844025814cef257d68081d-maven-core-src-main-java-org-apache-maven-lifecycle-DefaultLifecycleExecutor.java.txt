Add warnings for deprecation of aggregator-mojos bound to the lifecycle, and add error/error-logging (error when directly in the pom, error-logging when brought in via lifecycle mapping, etc.) when a direct-invocation mojo (@requiresDirectInvocation) is bound to the lifecycle.

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@619711 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.maven.execution.MavenExecutionRequest;
+ * Responsible for orchestrating the process of building the ordered list of
+ * steps required to achieve the specified set of tasks passed into Maven, then
+ * executing these mojos in order. This class also manages the various error messages
+ * that may occur during this process, and directing the behavior of the build
+ * according to what's specified in {@link MavenExecutionRequest#getReactorFailureBehavior()}.
+ *
+ * @author jdcasey
-     * Execute a task. Each task may be a phase in the lifecycle or the execution of a mojo.
-     *
-     * @param session
-     * @param reactorManager
-     * @param dispatcher
-     * @throws MojoFailureException
+     * {@inheritDoc}
+    /**
+     * After the list of goals from {@link MavenSession#getGoals()} is segmented into
+     * contiguous sets of aggregated and non-aggregated mojos and lifecycle phases,
+     * this method is used to execute each task-segment. Its logic has a top-level fork
+     * for each segment, which basically varies the project used to run the execution
+     * according to aggregation needs. If the segment is aggregated, the root project
+     * will be used to construct and execute the mojo bindings. Otherwise, this
+     * method will iterate through each project, and execute all the goals implied
+     * by the current task segment.
+     */
-                                    target );
+                                    target,
+                                    true );
-                                                                  buildStartTime, target );
+                                                                  buildStartTime, target,
+                                                                  false);
+    /**
+     * Since each project can have its own {@link ClassRealm} instance that inherits
+     * from the core Maven realm, and contains the specific build-extension
+     * components referenced in that project, the lookup realms must be managed for
+     * each project that's used to fire off a mojo execution. This helps ensure
+     * that unsafe {@link PlexusContainer#lookup(String)} and related calls will
+     * have access to these build-extension components.
+     * <br />
+     * This method simply restores the original Maven-core lookup realm when a
+     * project-specific realm is in use.
+     */
+    /**
+     * Since each project can have its own {@link ClassRealm} instance that inherits
+     * from the core Maven realm, and contains the specific build-extension
+     * components referenced in that project, the lookup realms must be managed for
+     * each project that's used to fire off a mojo execution. This helps ensure
+     * that unsafe {@link PlexusContainer#lookup(String)} and related calls will
+     * have access to these build-extension components.
+     * <br />
+     * This method is meant to find a project-specific realm, if one exists, for
+     * use as the lookup realm for unsafe component lookups, using {@link PlexusContainer#setLookupRealm(ClassRealm)}.
+     */
-//        MavenProjectSession projectSession;
-//        try
-//        {
-//            projectSession = session.getProjectSession( rootProject );
-//        }
-//        catch ( PlexusContainerException e )
-//        {
-//            throw new LifecycleExecutionException(
-//                                                   "Failed to create project-specific session for: "
-//                                                                   + rootProject.getId(),
-//                                                   rootProject, e );
-//        }
-//        if ( projectSession != null )
-//        {
-//            return container.setLookupRealm( projectSession.getProjectRealm() );
-//        }
-//        else
-//        {
-//            return null;
-//        }
+        ClassRealm projectRealm = session.getRealmManager().getProjectRealm( rootProject.getGroupId(), rootProject.getArtifactId(), rootProject.getVersion() );
-        // TODO: Fix this to use project-level realm!
+        if ( projectRealm != null )
+        {
+            return container.setLookupRealm( projectRealm );
+        }
+
+    /**
+     * Lookup the plugin containing the referenced mojo, validate that it is
+     * allowed to execute in the current environment (according to whether
+     * it's a direct-invocation-only or aggregator mojo, and the allowAggregators
+     * flag), and execute the mojo. If any of these steps fails, this method will
+     * consult with the {@link ReactorManager} to determine whether the build
+     * should be stopped.
+     */
-                                               final String target )
+                                               final String target,
+                                               boolean allowAggregators )
+
+            validateMojoExecution( mojoBinding, mojoDescriptor, project, allowAggregators );
+
+    /**
+     * Verify that the specified {@link MojoBinding} is legal for execution under
+     * the current circumstances. Currently, this mainly checks that aggregator
+     * mojos and direct-invocation-only mojos are not bound to lifecycle phases.
+     * <br/>
+     * If an invalid mojo is detected, and it is brought in via the user's POM
+     * (this will be checked using {@link MojoBinding#POM_ORIGIN} and {@link MojoBinding#getOrigin()}),
+     * then a {@link LifecycleExecutionException} will be thrown. Otherwise, the mojo
+     * was brought in via a lifecycle mapping or overlay, or as part of a forked execution.
+     * In these cases, the error will be logged to the console, using the ERROR log-level (since the
+     * user cannot fix this sort of problem easily).
+     */
+    private void validateMojoExecution( MojoBinding mojoBinding,
+                                        MojoDescriptor mojoDescriptor,
+                                        MavenProject project,
+                                        boolean allowAggregators )
+        throws LifecycleExecutionException
+    {
+        if ( mojoDescriptor.isAggregator() && !allowAggregators )
+        {
+            if ( MojoBinding.POM_ORIGIN.equals( mojoBinding.getOrigin() ) )
+            {
+                StringBuffer buffer = new StringBuffer();
+                buffer.append( "\n\nDEPRECATED: Binding aggregator mojos to lifecycle phases in the POM is considered dangerous." );
+                buffer.append( "\nThis feature has been deprecated. Please adjust your POM files accordingly." );
+                buffer.append( "\n\nOffending mojo:\n\n" );
+                buffer.append( MojoBindingUtils.toString( mojoBinding ) );
+                buffer.append( "\n\nProject: " ).append( project.getId() );
+                buffer.append( "\nPOM File: " ).append( String.valueOf( project.getFile() ) );
+                buffer.append( "\n" );
+
+                getLogger().warn( buffer.toString() );
+            }
+            else
+            {
+                StringBuffer buffer = new StringBuffer();
+                buffer.append( "\n\nDEPRECATED: An aggregator mojo has been bound to your project's build lifecycle." );
+                buffer.append( "\nThis feature is dangerous, and has been deprecated." );
+                buffer.append( "\n\nOffending mojo:\n\n" );
+                buffer.append( MojoBindingUtils.toString( mojoBinding ) );
+                buffer.append( "\n\nDirect binding of aggregator mojos to the lifecycle is not allowed, but this binding was not configured from within in your POM." );
+                buffer.append( "\n\nIts origin was: " ).append( mojoBinding.getOrigin() );
+                if ( mojoBinding.getOriginDescription() != null )
+                {
+                    buffer.append( " (" ).append( mojoBinding.getOriginDescription() ).append( ")" );
+                }
+
+                buffer.append( "\n" );
+
+                getLogger().warn( buffer.toString() );
+            }
+        }
+        else if ( mojoDescriptor.isDirectInvocationOnly() && !MojoBinding.DIRECT_INVOCATION_ORIGIN.equals( mojoBinding.getOrigin() ) )
+        {
+            if ( MojoBinding.POM_ORIGIN.equals( mojoBinding.getOrigin() ) )
+            {
+                throw new LifecycleExecutionException( "Mojo:\n\n" + MojoBindingUtils.toString( mojoBinding ) + "\n\ncan only be invoked directly by the user. Binding it to lifecycle phases in the POM is not allowed.", project );
+            }
+            else
+            {
+                StringBuffer buffer = new StringBuffer();
+                buffer.append( "\n\nSKIPPING execution of mojo:\n\n" ).append( MojoBindingUtils.toString( mojoBinding ) );
+                buffer.append( "\n\nIt specifies direct-invocation only, but has been bound to the build lifecycle." );
+                buffer.append( "\n\nDirect-invocation mojos can only be called by the user. This binding was not configured from within in your POM." );
+                buffer.append( "\n\nIts origin was: " ).append( mojoBinding.getOrigin() );
+                if ( mojoBinding.getOriginDescription() != null )
+                {
+                    buffer.append( " (" ).append( mojoBinding.getOriginDescription() ).append( ")" );
+                }
+
+                buffer.append( "\n" );
+
+                getLogger().error( buffer.toString() );
+            }
+        }
+    }
+
+    /**
+     * In the event that an error occurs during executeGoalAndHandleFailure(..),
+     * this method is called to handle logging the error in the {@link ReactorManager},
+     * then determining (again, from the reactor-manager) whether to stop the build.
+     *
+     * @return true if the build should stop, false otherwise.
+     */
+    /**
+     * {@inheritDoc}
+     */
+    /**
+     * Split up the list of goals from {@link MavenSession#getGoals()} according
+     * to aggregation needs. Each adjacent goal in the list is included in a single
+     * task segment. When the next goal references a different type of mojo or
+     * lifecycle phase (eg. previous goal wasn't an aggregator, but next one is...or the reverse),
+     * a new task segment is started and the new goal is added to that.
+     *
+     * @return the list of task-segments, each flagged according to aggregation needs.
+     */
+    /**
+     * Retrieve the {@link MojoDescriptor} that corresponds to a given direct mojo
+     * invocation. This is used during the fail-fast method isTaskValid(..), and also
+     * during task-segmentation, to allow the lifecycle executor to determine whether
+     * the mojo is an aggregator.
+     */

INS26 INS40 INS31 INS65 INS65 INS29 INS29 INS29 INS8 INS29 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS29 INS29 INS29 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS65 INS65 INS65 INS60 INS25 MOV41 INS65 INS39 INS42 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS68 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS27 INS8 INS25 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS42 INS68 INS42 INS68 INS42 INS68 INS68 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS21 INS42 INS67 INS68 INS42 INS32 INS38 INS25 INS27 INS8 INS42 INS68 INS42 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS32 INS42 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS32 INS38 INS25 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS25 INS21 INS21 INS42 INS42 INS32 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS27 INS8 INS32 INS32 INS40 INS42 INS32 INS40 INS42 INS32 INS53 INS60 INS21 INS21 INS21 INS21 INS25 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS32 INS32 INS33 INS21 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS14 INS43 INS59 INS32 INS32 INS32 INS32 INS27 INS8 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS14 INS32 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS45 INS32 INS42 INS32 INS32 INS33 INS21 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS42 INS45 INS32 INS45 INS43 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS9 INS9 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL8
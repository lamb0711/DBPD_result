[MNG-4343] maven always checks missing release artifacts

git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@816563 13f79535-47bb-0310-9956-ffa450edef68

-    public void getArtifact( Artifact artifact, ArtifactRepository repository, TransferListener downloadMonitor )
+    public void getArtifact( Artifact artifact, ArtifactRepository repository, TransferListener downloadMonitor, boolean force )
-        boolean updateCheckIsRequired = updateCheckManager.isUpdateRequired( artifact, repository );
-
-
-        // If the artifact is a snapshot, we need to determine whether it's time to check this repository for an update:
-        // 1. If it's forced, then check
-        // 2. If the updateInterval has been exceeded since the last check for this artifact on this repository, then check.        
-        else if ( artifact.isSnapshot() && updateCheckIsRequired )
+        else if ( artifact.isSnapshot() || !artifact.getFile().exists() )
-            logger.debug( "Trying repository " + repository.getId() + " for resolution of " + artifact.getId()
-                + " from " + remotePath );
-
-            try
-            {
-                getRemoteFile( repository, artifact.getFile(), remotePath, downloadMonitor, policy.getChecksumPolicy(), false );
-            }
-            finally
-            {
-                updateCheckManager.touch( artifact, repository );
-            }
-
-            logger.debug( "  Artifact " + artifact.getId() + " resolved to " + artifact.getFile() );
-
-            artifact.setResolved( true );
-        }
-
-        // XXX: This is not really intended for the long term - unspecified POMs should be converted to failures
-        //      meaning caching would be unnecessary. The code for this is here instead of the MavenMetadataSource
-        //      to keep the logic related to update checks enclosed, and so to keep the rules reasonably consistent
-        //      with release metadata
-        else if ( "pom".equals( artifact.getType() ) && !artifact.getFile().exists() )
-        {
-            // if POM is not present locally, try and get it if it's forced, out of date, or has not been attempted yet  
-            if ( updateCheckManager.isPomUpdateRequired( artifact, repository ) )
+            if ( force || updateCheckManager.isUpdateRequired( artifact, repository ) )
-                    getRemoteFile( repository, artifact.getFile(), remotePath, downloadMonitor, policy.getChecksumPolicy(), false );
+                    getRemoteFile( repository, artifact.getFile(), remotePath, downloadMonitor,
+                                   policy.getChecksumPolicy(), false );
-                catch ( ResourceDoesNotExistException e )
+                finally
-                    // cache the POM failure
-
-                    throw e;
-            else
+            else if ( !artifact.getFile().exists() )
-                // cached failure - pass on the failure
-                throw new ResourceDoesNotExistException( "Failure was cached in the local repository" );
+                throw new ResourceDoesNotExistException( "Failure to resolve " + remotePath + " from "
+                    + repository.getUrl() + " was cached in the local repository. "
+                    + "Resolution will not be reattempted until the update interval of " + repository.getId()
+                    + " has elapsed or updates are forced." );
-
-        // If it's not a snapshot artifact, then we don't care what the force flag says. If it's on the local
-        // system, it's resolved. Releases are presumed to be immutable, so release artifacts are not ever updated.
-        // NOTE: This is NOT the case for metadata files on relese-only repositories. This metadata may contain information
-        // about successive releases, so it should be checked using the same updateInterval/force characteristics as snapshot
-        // artifacts, above.
-
-        // don't write touch-file for release artifacts.
-        else if ( !artifact.isSnapshot() )
-        {
-            logger.debug( "Trying repository " + repository.getId() + " for resolution of " + artifact.getId()
-                + " from " + remotePath );
-
-            getRemoteFile( repository, artifact.getFile(), remotePath, downloadMonitor, policy.getChecksumPolicy(), false );
-
-            logger.debug( "  Artifact " + artifact.getId() + " resolved to " + artifact.getFile() );
-
-            artifact.setResolved( true );
-        }
-    public void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories, TransferListener downloadMonitor )
+    public void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories, TransferListener downloadMonitor, boolean force )
-                getArtifact( artifact, repository, downloadMonitor );
+                getArtifact( artifact, repository, downloadMonitor, force );

INS44 INS44 INS39 INS42 INS39 INS42 UPD27 INS8 MOV38 INS25 INS32 INS27 MOV8 INS25 INS32 INS42 INS42 MOV32 INS38 MOV8 INS42 INS42 MOV32 INS53 INS42 INS14 MOV43 INS27 UPD45 MOV45 INS42 MOV45 INS32 UPD45 MOV45 UPD45 MOV45 MOV32 INS45 MOV42 UPD42 MOV42 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL32 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL25
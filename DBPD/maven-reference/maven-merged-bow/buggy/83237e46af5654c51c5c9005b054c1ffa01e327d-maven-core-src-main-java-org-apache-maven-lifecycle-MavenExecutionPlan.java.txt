[MNG-3004] Concurrent building of multimodule projects

This commit consists of a modularization of the DefaultLifecycleExecutor into smaller
components. This is primarily done with the intention of extracting execution strategy 
somewhat from the rest of the logic.

It also contains three differenent execution strategies:
A) Linear ("Classic")
B) Parallel (Based on Dan's original implemementation)
C) Weave (Still experimental) 

 
The command line -T option activates parallel running, and the argument
is in the form -T <[nThreads, a float][C][W]|auto>

Notes:
* The output demultiplexer is disabled in this commit, and output will appear intermingled.
* The modello plugin has known problems
* Surefire must be run in forkmode at least once.


git-svn-id: https://svn.apache.org/repos/asf/maven/maven-3/trunk@931884 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.List;
-import java.util.Set;
+import java.util.*;
+import org.apache.maven.lifecycle.internal.ExecutionPlanItem;
+import org.apache.maven.plugin.descriptor.MojoDescriptor;
-public class MavenExecutionPlan
+public class MavenExecutionPlan  implements Iterable<ExecutionPlanItem>
-    /** Individual executions that must be performed. */
-    private List<MojoExecution> executions;
-    
+
+    /*
+       At the moment, this class is totally immutable, and this is in line with thoughts about the
+       pre-calculated execution plan that stays the same during the execution.
+
+       If deciding to add mutable state to this class, it should be at least considered to
+       separate this into a separate mutable structure.
+
+     */
-    private Set<String> requiredDependencyResolutionScopes;
+    private final Set<String> requiredDependencyResolutionScopes;
-    private Set<String> requiredDependencyCollectionScopes;
+    private final Set<String> requiredDependencyCollectionScopes;
-    public MavenExecutionPlan( List<MojoExecution> executions, Set<String> requiredDependencyResolutionScopes,
-                               Set<String> requiredDependencyCollectionScopes )
-    {
-        this.executions = executions;
+    private final List<ExecutionPlanItem> planItem;
+
+    private final Map<String, ExecutionPlanItem> lastInPhase;
+    private final List<String> phasesInOrder;
+
+    public MavenExecutionPlan(Set<String> requiredDependencyResolutionScopes, Set<String> requiredDependencyCollectionScopes, List<ExecutionPlanItem> planItem) {
+        this.planItem = planItem;
+        lastInPhase = new HashMap<String, ExecutionPlanItem>();
+        phasesInOrder = new ArrayList<String>();
+        for (ExecutionPlanItem executionPlanItem : getExecutionPlanItems()) {
+            final String phaseName = getPhase( executionPlanItem );
+            if (!lastInPhase.containsKey(  phaseName )){
+                phasesInOrder.add( phaseName );
+            }
+            lastInPhase.put( phaseName, executionPlanItem );
+        }
+
+
-    public List<MojoExecution> getExecutions()
-    {
-        return executions;
+    private String getPhase( ExecutionPlanItem executionPlanItem){
+        final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();
+        final MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();
+        return mojoDescriptor.getPhase();
+
+    public Iterator<ExecutionPlanItem> iterator() {
+        return getExecutionPlanItems().iterator();
+    }
+
+    /**
+     * Returns the last ExecutionPlanItem in the supplied phase. If no items are in the specified phase,
+     * the closest upstream item will be returned.
+     * @param executionPlanItem The execution plan item
+     * @return The ExecutionPlanItem or null if none can be found
+     */
+    public ExecutionPlanItem findLastInPhase( ExecutionPlanItem executionPlanItem){
+        ExecutionPlanItem executionPlanItem1 = lastInPhase.get( getPhase( executionPlanItem ) );
+        return executionPlanItem1;
+    }
+
+    private List<ExecutionPlanItem> getExecutionPlanItems()
+     {
+         return planItem;
+     }
+
+    public void forceAllComplete(){
+        for (ExecutionPlanItem executionPlanItem : getExecutionPlanItems()) {
+             executionPlanItem.forceComplete();
+        }
+    }
+
+
+    public List<MojoExecution> getMojoExecutions(){
+        List<MojoExecution> result = new ArrayList<MojoExecution>();
+        for ( ExecutionPlanItem executionPlanItem : planItem )
+        {
+            result.add( executionPlanItem.getMojoExecution());
+        }
+        return result;
+    }
+
+    public int size() {
+        return planItem.size();
+    }

INS26 MOV23 UPD40 UPD40 INS40 INS74 INS23 INS23 MOV44 INS31 INS31 INS31 INS31 INS31 INS31 INS43 INS43 INS83 INS83 INS83 UPD74 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS59 MOV21 INS83 INS43 INS42 INS44 INS8 INS83 INS74 INS42 INS8 INS29 INS43 INS42 INS44 INS83 INS74 INS42 INS8 INS83 INS39 INS42 INS8 INS83 MOV74 INS42 INS8 INS83 INS39 INS42 INS8 INS42 INS42 UPD43 UPD42 INS43 INS43 INS43 INS42 INS43 INS43 INS42 INS74 INS42 INS21 INS21 INS70 INS42 INS43 INS42 INS60 INS60 INS41 INS43 INS43 INS41 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS43 INS43 INS41 INS70 INS60 INS70 INS41 INS41 UPD42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS7 INS7 INS44 INS32 INS8 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS32 INS42 INS42 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS59 UPD42 INS42 INS42 INS42 INS44 INS32 INS8 MOV74 INS59 INS44 INS42 INS8 INS42 INS32 INS42 INS42 UPD42 INS42 INS14 INS42 INS14 INS43 INS42 INS42 INS60 INS25 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS21 INS42 INS14 INS43 INS42 INS21 INS42 INS42 UPD42 INS74 INS74 INS42 INS83 INS43 INS59 INS38 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS74 INS42 INS32 INS43 INS43 INS43 INS43 INS43 INS42 INS42 INS32 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL66 DEL65 DEL29 DEL42 DEL42
[MNG-1908] force an update check if there are legacy snapshots within the updatePolicy window

git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@375485 13f79535-47bb-0310-9956-ffa450edef68

-    
+
-            
+
-        
+
+        boolean downloaded = false;
+
-                wagon.get( remotePath, temp );
-
-                // keep the checksum files from showing up on the download monitor...
-                if ( downloadMonitor != null )
+                if ( destination.exists() )
-                    wagon.removeTransferListener( downloadMonitor );
+                    downloaded = wagon.getIfNewer( remotePath, temp, destination.lastModified() );
+                }
+                else
+                {
+                    wagon.get( remotePath, temp );
+                    downloaded = true;
-                // try to verify the SHA-1 checksum for this file.
-                try
+                if ( downloaded )
-                    verifyChecksum( sha1ChecksumObserver, destination, temp, remotePath, ".sha1", wagon );
-                }
-                catch ( ChecksumFailedException e )
-                {
-                    // if we catch a ChecksumFailedException, it means the transfer/read succeeded, but the checksum
-                    // doesn't match. This could be a problem with the server (ibiblio HTTP-200 error page), so we'll
-                    // try this up to two times. On the second try, we'll handle it as a bona-fide error, based on the
-                    // repository's checksum checking policy.
-                    if ( firstRun )
+                    // keep the checksum files from showing up on the download monitor...
+                    if ( downloadMonitor != null )
-                        getLogger().warn( "*** CHECKSUM FAILED - " + e.getMessage() + " - RETRYING" );
-                        retry = true;
+                        wagon.removeTransferListener( downloadMonitor );
-                    else
-                    {
-                        handleChecksumFailure( checksumPolicy, e.getMessage(), e.getCause() );
-                    }
-                }
-                catch ( ResourceDoesNotExistException sha1TryException )
-                {
-                    getLogger().debug( "SHA1 not found, trying MD5", sha1TryException );
-                    // if this IS NOT a ChecksumFailedException, it was a problem with transfer/read of the checksum
-                    // file...we'll try again with the MD5 checksum.
+                    // try to verify the SHA-1 checksum for this file.
-                        verifyChecksum( md5ChecksumObserver, destination, temp, remotePath, ".md5", wagon );
+                        verifyChecksum( sha1ChecksumObserver, destination, temp, remotePath, ".sha1", wagon );
-                        // if we also fail to verify based on the MD5 checksum, and the checksum transfer/read
-                        // succeeded, then we need to determine whether to retry or handle it as a failure.
+                        // if we catch a ChecksumFailedException, it means the transfer/read succeeded, but the checksum
+                        // doesn't match. This could be a problem with the server (ibiblio HTTP-200 error page), so we'll
+                        // try this up to two times. On the second try, we'll handle it as a bona-fide error, based on the
+                        // repository's checksum checking policy.
+                            getLogger().warn( "*** CHECKSUM FAILED - " + e.getMessage() + " - RETRYING" );
-                    catch ( ResourceDoesNotExistException md5TryException )
+                    catch ( ResourceDoesNotExistException sha1TryException )
-                        // this was a failed transfer, and we don't want to retry.
-                        handleChecksumFailure( checksumPolicy, "Error retrieving checksum file for " + remotePath,
-                                               md5TryException );
-                    }
-                }
+                        getLogger().debug( "SHA1 not found, trying MD5", sha1TryException );
-                // reinstate the download monitor...
-                if ( downloadMonitor != null )
-                {
-                    wagon.addTransferListener( downloadMonitor );
+                        // if this IS NOT a ChecksumFailedException, it was a problem with transfer/read of the checksum
+                        // file...we'll try again with the MD5 checksum.
+                        try
+                        {
+                            verifyChecksum( md5ChecksumObserver, destination, temp, remotePath, ".md5", wagon );
+                        }
+                        catch ( ChecksumFailedException e )
+                        {
+                            // if we also fail to verify based on the MD5 checksum, and the checksum transfer/read
+                            // succeeded, then we need to determine whether to retry or handle it as a failure.
+                            if ( firstRun )
+                            {
+                                retry = true;
+                            }
+                            else
+                            {
+                                handleChecksumFailure( checksumPolicy, e.getMessage(), e.getCause() );
+                            }
+                        }
+                        catch ( ResourceDoesNotExistException md5TryException )
+                        {
+                            // this was a failed transfer, and we don't want to retry.
+                            handleChecksumFailure( checksumPolicy, "Error retrieving checksum file for " + remotePath,
+                                                   md5TryException );
+                        }
+                    }
+
+                    // reinstate the download monitor...
+                    if ( downloadMonitor != null )
+                    {
+                        wagon.addTransferListener( downloadMonitor );
+                    }
-        if ( !temp.exists() )
+        if ( downloaded )
-            throw new ResourceDoesNotExistException( "Downloaded file does not exist: " + temp );
-        }
-
-        // The temporary file is named destination + ".tmp" and is done this way to ensure
-        // that the temporary file is in the same file system as the destination because the
-        // File.renameTo operation doesn't really work across file systems.
-        // So we will attempt to do a File.renameTo for efficiency and atomicity, if this fails
-        // then we will use a brute force copy and delete the temporary file.
-
-        if ( !temp.renameTo( destination ) )
-        {
-            try
+            if ( !temp.exists() )
-                FileUtils.copyFile( temp, destination );
-
-                temp.delete();
+                throw new ResourceDoesNotExistException( "Downloaded file does not exist: " + temp );
-            catch ( IOException e )
+
+            // The temporary file is named destination + ".tmp" and is done this way to ensure
+            // that the temporary file is in the same file system as the destination because the
+            // File.renameTo operation doesn't really work across file systems.
+            // So we will attempt to do a File.renameTo for efficiency and atomicity, if this fails
+            // then we will use a brute force copy and delete the temporary file.
+
+            if ( !temp.renameTo( destination ) )
-                throw new TransferFailedException(
-                    "Error copying temporary file to the final destination: " + e.getMessage(), e );
+                try
+                {
+                    FileUtils.copyFile( temp, destination );
+
+                    temp.delete();
+                }
+                catch ( IOException e )
+                {
+                    throw new TransferFailedException(
+                        "Error copying temporary file to the final destination: " + e.getMessage(), e );
+                }
-    private void verifyChecksum( ChecksumObserver checksumObserver, File destination, File tempDestination, String remotePath,
-                                 String checksumFileExtension, Wagon wagon )
+    private void verifyChecksum( ChecksumObserver checksumObserver, File destination, File tempDestination,
+                                 String remotePath, String checksumFileExtension, Wagon wagon )
-                if ( checksumFile.exists() ) checksumFile.delete();
+                if ( checksumFile.exists() )
+                {
+                    checksumFile.delete();
+                }
-     * @param protocol the protocol (required)
-     * @param host the proxy host name (required)
-     * @param port the proxy port (required)
-     * @param username the username for the proxy, or null if there is none
-     * @param password the password for the proxy, or null if there is none
+     * @param protocol      the protocol (required)
+     * @param host          the proxy host name (required)
+     * @param port          the proxy port (required)
+     * @param username      the username for the proxy, or null if there is none
+     * @param password      the password for the proxy, or null if there is none
-     * property format: <code>*.foo.com|localhost</code>.
+     *                      property format: <code>*.foo.com|localhost</code>.
-    
+
-     * 
-     * @param wagon the wagon to configure
+     *
+     * @param wagon      the wagon to configure
-                throw new WagonConfigurationException( repositoryId, "Unable to lookup wagon configurator. Wagon configuration cannot be applied.", e );
+                throw new WagonConfigurationException( repositoryId,
+                                                       "Unable to lookup wagon configurator. Wagon configuration cannot be applied.",
+                                                       e );
-    
+

INS60 INS25 INS39 INS59 INS42 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS9 MOV25 MOV25 INS8 MOV21 INS25 INS25 MOV21 INS32 INS8 INS8 INS42 MOV8 INS8 INS42 INS42 INS21 MOV21 INS21 MOV21 INS7 INS7 INS42 INS32 INS42 INS9 INS42 INS42 INS42 INS42 INS32 INS42 INS42
o Improved support for classifier parsing and added test artifact to the test repository for this.

o Fixed issue in createXXX(..) method for constructing an artifact with a classifier...it was not actually calling the constructor that passes in the classifier.

PR: MNG-312


git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@163989 13f79535-47bb-0310-9956-ffa450edef68

-        String classifier = null;
+        StringBuffer classifierBuffer = new StringBuffer();
-        boolean inFirstToken = true;
+        boolean firstVersionTokenEncountered = false;
+        boolean firstToken = true;
+
+        int tokensIterated = 0;
-            if ( inFirstToken && !tokenIsVersionPart )
-            {
-                classifier = token;
-            }
-            else if ( tokenIsVersionPart )
-            {
-                if ( !inFirstToken )
-                {
-                    versionBuffer.insert( 0, '-' );
-                }
-                versionBuffer.insert( 0, token );
+            StringBuffer bufferToUpdate = null;
+
+            // NOTE: logic in code is reversed, since we're peeling off the back
+            // Any token after the last versionPart will be in the classifier.
+            // Any token UP TO first non-versionPart is part of the version.
+            if ( !tokenIsVersionPart )
+            {
+                if ( firstVersionTokenEncountered )
+                {
+                    break;
+                }
+                else
+                {
+                    bufferToUpdate = classifierBuffer;
+                }
-                // if we didn't find a version, but we did find a 'classifier', 
-                // then push that classifier back onto the list...chances are, 
-                // it doesn't have a version or a classifier if this is the case.
-                if ( versionBuffer.length() < 1 && classifier != null )
-                {
-                    avceTokenList.addFirst( classifier );
-                }
+                firstVersionTokenEncountered = true;
-                // we've discovered all the version parts. break the loop.
-                break;
+                bufferToUpdate = versionBuffer;
-            if ( inFirstToken )
+            if ( firstToken )
-                inFirstToken = false;
+                firstToken = false;
+            }
+            else
+            {
+                bufferToUpdate.insert( 0, '-' );
-            // pop the token off the list so it doesn't appear in the
-            // artifactId.
-            it.remove();
+            bufferToUpdate.insert( 0, token );
+
+            tokensIterated++;
+        
+        getLogger().debug("After parsing loop, state of buffers:\no  Version Buffer: \'" + versionBuffer + "\'\no  Classifier Buffer: \'" + classifierBuffer + "\'\no Number of Tokens Iterated: " + tokensIterated);
+        
+        getLogger().debug("Before repairing bad version and/or cleaning up used tokens, avce token list is:\n" + avceTokenList);
+        
+        // if we didn't find a version, then punt. Use the last token
+        // as the version, and set the classifier empty.
+        if ( versionBuffer.length() < 1 )
+        {
+            int lastIdx = avceTokenList.size() - 1;
+            
+            versionBuffer.append( avceTokenList.get( lastIdx ) );
+            avceTokenList.remove( lastIdx );
+
+            classifierBuffer.setLength( 0 );
+        }
+        else
+        {
+            getLogger().debug("Removing " + tokensIterated + " tokens from avce token list.");
+            
+            // if everything is kosher, then pop off all the classifier and
+            // version tokens, leaving the naked artifact id in the list.
+            avceTokenList = new LinkedList( avceTokenList.subList( 0, avceTokenList.size() - ( tokensIterated ) ) );
+        }
+        
+        getLogger().debug("Now, remainder of avce token list is:\n" + avceTokenList);
-        inFirstToken = true;
+        firstToken = true;
-            if ( inFirstToken )
+            if ( firstToken )
-                inFirstToken = false;
+                firstToken = false;
-                           "Extracted artifact information from path:\n" + "groupId: \'" + groupId + "\'\n"
-                               + "artifactId: \'" + artifactId + "\'\n" + "type: \'" + type + "\'\n" + "version: \'"
-                               + version + "\'\n" + "classifier: \'" + classifier + "\'" );
+                          "Extracted artifact information from path:\n" + "groupId: \'" + groupId + "\'\n"
+                              + "artifactId: \'" + artifactId + "\'\n" + "type: \'" + type + "\'\n" + "version: \'"
+                              + version + "\'\n" + "classifier: \'" + classifierBuffer.toString() + "\'" );
-        if ( classifier != null )
+        Artifact result = null;
+
+        if ( classifierBuffer.length() > 0 )
-            return artifactConstructionSupport.createArtifactWithClassifier( groupId, artifactId, version,
-                                                                             Artifact.SCOPE_RUNTIME, type, classifier );
+            getLogger().debug("Creating artifact with classifier.");
+            
+            result = artifactConstructionSupport.createArtifactWithClassifier( groupId, artifactId, version,
+                                                                               Artifact.SCOPE_RUNTIME, type,
+                                                                               classifierBuffer.toString() );
-            return artifactConstructionSupport.createArtifact( groupId, artifactId, version, Artifact.SCOPE_RUNTIME,
-                                                               type );
+            result = artifactConstructionSupport.createArtifact( groupId, artifactId, version, Artifact.SCOPE_RUNTIME,
+                                                                 type );
+
+        getLogger().debug( "Resulting artifact is: " + result.getId() + " and has classifier of: " + result.getClassifier() + "\n\n" );
+
+        return result;

INS60 INS60 INS24 INS21 INS21 INS25 MOV21 INS60 INS21 INS41 UPD43 INS39 INS59 INS39 INS59 MOV58 MOV32 INS8 INS32 INS32 MOV27 INS8 MOV8 INS43 INS59 UPD27 INS32 INS42 UPD42 UPD42 INS14 INS42 INS9 UPD42 INS42 INS34 MOV60 MOV60 INS60 INS25 MOV25 MOV21 INS21 INS32 INS42 INS27 INS32 INS42 INS27 INS60 MOV21 INS21 INS21 INS21 INS32 UPD42 INS27 UPD42 INS42 INS42 INS33 INS32 INS34 INS21 INS21 INS21 INS32 INS42 INS27 INS43 INS43 INS59 MOV38 INS8 INS8 INS42 INS8 INS37 INS42 INS45 INS42 INS45 UPD42 MOV42 INS45 INS42 INS42 INS45 INS42 INS39 INS59 INS32 INS32 INS32 INS32 UPD42 MOV42 INS45 INS42 UPD42 INS32 INS42 INS42 INS32 INS7 INS7 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS33 INS25 INS21 INS21 INS21 UPD42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS42 INS27 UPD42 INS14 INS42 INS42 INS32 INS42 INS45 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS8 MOV8 INS7 INS7 INS7 INS32 INS34 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS42 INS45 INS43 INS32 INS42 MOV42 MOV42 MOV42 MOV42 MOV42 MOV40 MOV42 INS32 INS10 INS42 INS9 INS42 INS42 INS42 INS9 UPD42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 UPD42 UPD42 MOV42 INS42 INS32 INS36 UPD42 UPD42 INS42 INS42 INS42 DEL33 DEL42 DEL38 DEL42 DEL27 DEL42 DEL8 DEL33 DEL27 DEL27 DEL8 DEL25 DEL10 DEL8 DEL25 DEL25 DEL42 DEL25 DEL8 DEL24 DEL32 DEL9 DEL42 DEL42 DEL33 DEL32 DEL41 DEL41
o refactoring the way plugin prefix metadata is found. the lifecycle executor is not the right place for this and the plugin manager is now strictly for already fully configured executions. so it belongs somewhere specific to augmenting the base set of information in order to make it complete but this first pass will do here. i just want to check it in as well because i'm traveling.



git-svn-id: https://svn.apache.org/repos/asf/maven/components/trunk@783361 13f79535-47bb-0310-9956-ffa450edef68

-//TODO: The configuration for the lifecycle needs to be externalized so that I can use the annotations
-//      properly for the wiring and reference and external source for the lifecycle configuration.
+//TODO: The configuration for the lifecycle needs to be externalized so that I can use the annotations properly for the wiring and reference and external source for the lifecycle configuration.
-//TODO if ( mojoDescriptor.isProjectRequired() && !session.isUsingPOMsFromFilesystem() )
-//{
-//    throw new PluginExecutionException( mojoExecution, project, "Cannot execute mojo: " + mojoDescriptor.getGoal()
-//        + ". It requires a project with an existing pom.xml, but the build is not using one." );
-//}
+    @Requirement
+    private ProjectDependenciesResolver projectDependenciesResolver;
+            
+    // @Configuration(source="org/apache/maven/lifecycle/lifecycles.xml")    
+    private List<Lifecycle> lifecycles;
+
+    /**
+     * We use this to display all the lifecycles available and their phases to users. Currently this is primarily
+     * used in the IDE integrations where a UI is presented to the user and they can select the lifecycle phase
+     * they would like to execute.
+     */
+    private Map<String,Lifecycle> lifecycleMap;
+    
+    /**
+     * We use this to map all phases to the lifecycle that contains it. This is used so that a user can specify the 
+     * phase they want to execute and we can easily determine what lifecycle we need to run.
+     */
+    private Map<String, Lifecycle> phaseToLifecycleMap;
+
-    @Requirement
-    private ProjectDependenciesResolver projectDependenciesResolver;
-    
-    // @Configuration(source="org/apache/maven/lifecycle/lifecycles.xml")    
-    private List<Lifecycle> lifecycles;
-
-    private Map<String,Lifecycle> lifecycleMap;
-    
-    private Map<String, Lifecycle> phaseToLifecycleMap;
-
-               
-    // 1. Find the lifecycle given the phase (default lifecycle when given install)
-    // 2. Find the lifecycle mapping that corresponds to the project packaging (jar lifecycle mapping given the jar packaging)
-    // 3. Find the mojos associated with the lifecycle given the project packaging (jar lifecycle mapping for the default lifecycle)
-    // 4. Bind those mojos found in the lifecycle mapping for the packaging to the lifecycle
-    // 5. Bind mojos specified in the project itself to the lifecycle
+        
-    {        
+    {
-                
-        List<MojoExecution> phasesWithMojosToExecute = new ArrayList<MojoExecution>();
-        
+
-                
+
-        
+
-
-                // If this is a goal like "mvn modello:java" and the POM looks like the following:
-                
-                // <project>
-                //   <modelVersion>4.0.0</modelVersion>
-                //   <groupId>org.apache.maven.plugins</groupId>
-                //   <artifactId>project-plugin-level-configuration-only</artifactId>
-                //   <version>1.0.1</version>
-                //   <build>
-                //     <plugins>
-                //       <plugin>
-                //         <groupId>org.codehaus.modello</groupId>
-                //         <artifactId>modello-maven-plugin</artifactId>
-                //         <version>1.0.1</version>
-                //         <configuration>
-                //           <version>1.1.0</version>
-                //           <models>
-                //             <model>src/main/mdo/remote-resources.mdo</model>
-                //           </models>
-                //         </configuration>
-                //       </plugin>
-                //     </plugins>
-                //   </build>
-                // </project>                
-                //
-                // We want to 
-                //
-                // - take the plugin/configuration in the POM and merge it with the plugin's default configuration found in its plugin.xml
-                // - attach that to the MojoExecution for its configuration
-                // - give the MojoExecution an id of default-<goal>.
-                
-                MojoDescriptor mojoDescriptor = getMojoDescriptor( task, session );
-
-                requiredDependencyResolutionScope = mojoDescriptor.isDependencyResolutionRequired();
-
-                MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, "default-" + mojoDescriptor.getGoal() );
-                
-                populateMojoExecutionConfiguration( project, mojoExecution, true );
-
-                lifecyclePlan.add( mojoExecution );
+                calculateExecutionForIndividualGoal( session, lifecyclePlan, task );
-                // 1.
-                //
-                // Based on the lifecycle phase we are given, let's find the corresponding lifecycle.
-                //
-                Lifecycle lifecycle = phaseToLifecycleMap.get( task );
-
-                // 2. 
-                //
-                // If we are dealing with the "clean" or "site" lifecycle then there are currently no lifecycle mappings but there are default phases
-                // that need to be run instead.
-                //
-                // Now we need to take into account the packaging type of the project. For a project of type WAR, the lifecycle where mojos are mapped
-                // on to the given phases in the lifecycle are going to be a little different then, say, a project of type JAR.
-                //
-
-                // 3.
-                //
-                // Once we have the lifecycle mapping for the given packaging, we need to know whats phases we need to worry about executing.
-                //
-
-                // Create an ordered Map of the phases in the lifecycle to a list of mojos to execute.
-                Map<String, List<MojoExecution>> phaseToMojoMapping = new LinkedHashMap<String, List<MojoExecution>>();
-
-                // 4.
-
-                //TODO: need to separate the lifecycles
-
-                for ( String phase : lifecycle.getPhases() )
-                {
-                    List<MojoExecution> mojos = new ArrayList<MojoExecution>();
-
-                    //TODO: remove hard coding
-                    if ( phase.equals( "clean" ) )
-                    {
-                        Plugin plugin = new Plugin();
-                        plugin.setGroupId( "org.apache.maven.plugins" );
-                        plugin.setArtifactId( "maven-clean-plugin" );
-                        plugin.setVersion( "2.3" );
-                        mojos.add( new MojoExecution( plugin, "clean", "default-clean" ) );
-                    }
-
-                    // This is just just laying out the initial structure of the mojos to run in each phase of the
-                    // lifecycle. Everything is now done in the project builder correctly so this could likely
-                    // go away shortly. We no longer need to pull out bits from the default lifecycle. The MavenProject
-                    // comes to us intact as it should.
-
-                    phaseToMojoMapping.put( phase, mojos );
-                }
-
-                // 5. Just build up the list of mojos that will execute for every phase.
-                //
-                // This will be useful for having the complete build plan and then we can filter/optimize later.
-                //
-                for ( Plugin plugin : project.getBuild().getPlugins() )
-                {
-                    for ( PluginExecution execution : plugin.getExecutions() )
-                    {
-                        // if the phase is specified then I don't have to go fetch the plugin yet and pull it down
-                        // to examine the phase it is associated to.                
-                        if ( execution.getPhase() != null )
-                        {
-                            for ( String goal : execution.getGoals() )
-                            {
-                                if ( phaseToMojoMapping.get( execution.getPhase() ) == null )
-                                {
-                                    // This is happening because executions in the POM are getting mixed into the clean lifecycle
-                                    // So for the lifecycle mapping we need a map with the phases as keys so we can easily check
-                                    // if this phase belongs to the given lifecycle. this shows the system is messed up. this
-                                    // shouldn't happen.
-                                    phaseToMojoMapping.put( execution.getPhase(), new ArrayList<MojoExecution>() );
-                                }
-
-                                MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
-                                phaseToMojoMapping.get( execution.getPhase() ).add( mojoExecution );
-                            }
-                        }
-                        // if not then i need to grab the mojo descriptor and look at the phase that is specified
-                        else
-                        {
-                            for ( String goal : execution.getGoals() )
-                            {
-                                MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), project.getRemoteArtifactRepositories() );
-
-                                if ( mojoDescriptor.getPhase() != null && phaseToMojoMapping.get( mojoDescriptor.getPhase() ) != null )
-                                {
-                                    MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
-                                    phaseToMojoMapping.get( mojoDescriptor.getPhase() ).add( mojoExecution );
-                                }
-                            }
-                        }
-                    }
-                }
-
-                // 6. 
-                //
-                // We are only interested in the phases that correspond to the lifecycle we are trying to run. If we are running the "clean"
-                // lifecycle we are not interested in goals -- like "generate-sources -- that belong to the default lifecycle.
-                //        
-                for ( String phase : phaseToMojoMapping.keySet() )
-                {
-                    phasesWithMojosToExecute.addAll( phaseToMojoMapping.get( phase ) );
-
-                    if ( phase.equals( task ) )
-                    {
-                        break;
-                    }
-                }
+                calculateExecutionForLifecyclePhase( session, lifecyclePlan, task );
-              
+
-        //TODO: this needs to go to the model builder.
-        //TODO: just used a hollowed out MojoExecution
-        for ( MojoExecution mojoExecution : phasesWithMojosToExecute )
+        // 
+        for ( MojoExecution mojoExecution : lifecyclePlan )
-            MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( 
-                mojoExecution.getPlugin(), mojoExecution.getGoal(), session.getLocalRepository(), project.getPluginArtifactRepositories() );
+            MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( mojoExecution.getGroupId(), mojoExecution.getArtifactId(), mojoExecution.getVersion(), mojoExecution.getGoal(), session
+                .getLocalRepository(), project.getRemoteArtifactRepositories() );
-            requiredDependencyResolutionScope = calculateRequiredDependencyResolutionScope( requiredDependencyResolutionScope, mojoDescriptor.isDependencyResolutionRequired() );          
-            
+            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();
+            if ( pluginDescriptor.getPlugin().isExtensions() )
+            {
+                pluginDescriptor.setClassRealm( pluginManager.getPluginRealm( session, pluginDescriptor ) );
+            }
+
+            requiredDependencyResolutionScope = calculateRequiredDependencyResolutionScope( requiredDependencyResolutionScope, mojoDescriptor.isDependencyResolutionRequired() );
+
-            
-            populateMojoExecutionConfiguration( project, mojoExecution, false );
-            lifecyclePlan.add( mojoExecution );
-        }        
+            populateMojoExecutionConfiguration( project, mojoExecution, false );
+        }
+
+        return new MavenExecutionPlan( lifecyclePlan, requiredDependencyResolutionScope );
+    }      
+    
+    private void calculateExecutionForIndividualGoal( MavenSession session, List<MojoExecution> lifecyclePlan, String goal ) 
+        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException
+    {
+        MavenProject project = session.getCurrentProject();
-        return new MavenExecutionPlan( lifecyclePlan, requiredDependencyResolutionScope );        
-    }  
+        // If this is a goal like "mvn modello:java" and the POM looks like the following:
+        //
+        // <project>
+        //   <modelVersion>4.0.0</modelVersion>
+        //   <groupId>org.apache.maven.plugins</groupId>
+        //   <artifactId>project-plugin-level-configuration-only</artifactId>
+        //   <version>1.0.1</version>
+        //   <build>
+        //     <plugins>
+        //       <plugin>
+        //         <groupId>org.codehaus.modello</groupId>
+        //         <artifactId>modello-maven-plugin</artifactId>
+        //         <version>1.0.1</version>
+        //         <configuration>
+        //           <version>1.1.0</version>
+        //           <models>
+        //             <model>src/main/mdo/remote-resources.mdo</model>
+        //           </models>
+        //         </configuration>
+        //       </plugin>
+        //     </plugins>
+        //   </build>
+        // </project>                
+        //
+        // We want to 
+        //
+        // - take the plugin/configuration in the POM and merge it with the plugin's default configuration found in its plugin.xml
+        // - attach that to the MojoExecution for its configuration
+        // - give the MojoExecution an id of default-<goal>.
+        
+        MojoDescriptor mojoDescriptor = getMojoDescriptor( goal, session );
+
+        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, "default-" + mojoDescriptor.getGoal() );
+        
+        populateMojoExecutionConfiguration( project, mojoExecution, true );
+
+        lifecyclePlan.add( mojoExecution );        
+    }
+    
+    // 1. Find the lifecycle given the phase (default lifecycle when given install)
+    // 2. Find the lifecycle mapping that corresponds to the project packaging (jar lifecycle mapping given the jar packaging)
+    // 3. Find the mojos associated with the lifecycle given the project packaging (jar lifecycle mapping for the default lifecycle)
+    // 4. Bind those mojos found in the lifecycle mapping for the packaging to the lifecycle
+    // 5. Bind mojos specified in the project itself to the lifecycle    
+    private void calculateExecutionForLifecyclePhase( MavenSession session, List<MojoExecution> lifecyclePlan, String lifecyclePhase ) 
+        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException        
+    {        
+        MavenProject project = session.getCurrentProject();
+        
+        // 1.
+        //
+        // Based on the lifecycle phase we are given, let's find the corresponding lifecycle.
+        //
+        Lifecycle lifecycle = phaseToLifecycleMap.get( lifecyclePhase );
+
+        // 2. 
+        //
+        // If we are dealing with the "clean" or "site" lifecycle then there are currently no lifecycle mappings but there are default phases
+        // that need to be run instead.
+        //
+        // Now we need to take into account the packaging type of the project. For a project of type WAR, the lifecycle where mojos are mapped
+        // on to the given phases in the lifecycle are going to be a little different then, say, a project of type JAR.
+        //
+
+        // 3.
+        //
+        // Once we have the lifecycle mapping for the given packaging, we need to know whats phases we need to worry about executing.
+        //
+
+        // Create an ordered Map of the phases in the lifecycle to a list of mojos to execute.
+        Map<String, List<MojoExecution>> phaseToMojoMapping = new LinkedHashMap<String, List<MojoExecution>>();
+
+        // 4.
+
+        //TODO: need to separate the lifecycles
+
+        for ( String phase : lifecycle.getPhases() )
+        {
+            List<MojoExecution> mojos = new ArrayList<MojoExecution>();
+
+            //TODO: remove hard coding
+            if ( phase.equals( "clean" ) )
+            {
+                Plugin plugin = new Plugin();
+                plugin.setGroupId( "org.apache.maven.plugins" );
+                plugin.setArtifactId( "maven-clean-plugin" );
+                plugin.setVersion( "2.3" );
+                mojos.add( new MojoExecution( plugin, "clean", "default-clean" ) );                
+            }
+
+            // This is just just laying out the initial structure of the mojos to run in each phase of the
+            // lifecycle. Everything is now done in the project builder correctly so this could likely
+            // go away shortly. We no longer need to pull out bits from the default lifecycle. The MavenProject
+            // comes to us intact as it should.
+
+            phaseToMojoMapping.put( phase, mojos );
+        }
+
+        // 5. Just build up the list of mojos that will execute for every phase.
+        //
+        // This will be useful for having the complete build plan and then we can filter/optimize later.
+        //
+        for ( Plugin plugin : project.getBuild().getPlugins() )
+        {
+            for ( PluginExecution execution : plugin.getExecutions() )
+            {
+                // if the phase is specified then I don't have to go fetch the plugin yet and pull it down
+                // to examine the phase it is associated to.                
+                if ( execution.getPhase() != null )
+                {
+                    for ( String goal : execution.getGoals() )
+                    {
+                        if ( phaseToMojoMapping.get( execution.getPhase() ) == null )
+                        {
+                            // This is happening because executions in the POM are getting mixed into the clean lifecycle
+                            // So for the lifecycle mapping we need a map with the phases as keys so we can easily check
+                            // if this phase belongs to the given lifecycle. this shows the system is messed up. this
+                            // shouldn't happen.
+                            phaseToMojoMapping.put( execution.getPhase(), new ArrayList<MojoExecution>() );
+                        }
+
+                        MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
+                        phaseToMojoMapping.get( execution.getPhase() ).add( mojoExecution );
+                    }
+                }
+                // if not then i need to grab the mojo descriptor and look at the phase that is specified
+                else
+                {
+                    for ( String goal : execution.getGoals() )
+                    {
+                        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), project.getRemoteArtifactRepositories() );
+
+                        if ( mojoDescriptor.getPhase() != null && phaseToMojoMapping.get( mojoDescriptor.getPhase() ) != null )
+                        {
+                            MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
+                            phaseToMojoMapping.get( mojoDescriptor.getPhase() ).add( mojoExecution );
+                        }
+                    }
+                }
+            }
+        }
+
+        // 6. 
+        //
+        // We are only interested in the phases that correspond to the lifecycle we are trying to run. If we are running the "clean"
+        // lifecycle we are not interested in goals -- like "generate-sources -- that belong to the default lifecycle.
+        //        
+        for ( String phase : phaseToMojoMapping.keySet() )
+        {
+            lifecyclePlan.addAll( phaseToMojoMapping.get( phase ) );
+
+            if ( phase.equals( lifecyclePhase ) )
+            {
+                break;
+            }
+        }
+    }   
+        
+        if ( numTokens == 4 )
+        {
+            // We have everything that we need
+            //
+            // org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process
+            //
+            // groupId
+            // artifactId
+            // version
+            // goal
+            //
+            plugin = new Plugin();
+            plugin.setGroupId( tok.nextToken() );
+            plugin.setArtifactId( tok.nextToken() );
+            plugin.setVersion( tok.nextToken() );
+            goal = tok.nextToken();
+            
+        }
+        else if ( numTokens == 3 )
+        {
+            // We have everything that we need except the version
+            //
+            // org.apache.maven.plugins:maven-remote-resources-plugin:???:process
+            //
+            // groupId
+            // artifactId
+            // ???
+            // goal
+            //
+            plugin = new Plugin();
+            plugin.setGroupId( tok.nextToken() );
+            plugin.setArtifactId( tok.nextToken() );
+            goal = tok.nextToken();
+        }
+            // We have a prefix and goal
+            //
+            // idea:idea
+            //
-        else if ( numTokens == 3 || numTokens == 4 )
-        {
-            plugin = new Plugin();
-            plugin.setGroupId( tok.nextToken() );
-            plugin.setArtifactId( tok.nextToken() );
-
-            if ( numTokens == 4 )
-            {
-                plugin.setVersion( tok.nextToken() );
-            }
-
-            goal = tok.nextToken();
-        }
-            for ( Plugin pluginInPom : project.getBuildPlugins() )
-            {
-                if ( pluginInPom.getArtifactId().equals( plugin.getArtifactId() ) )
-                {
-                    plugin.setVersion( pluginInPom.getVersion() );
-                    break;
-                }
-            }
-
-            if ( plugin.getVersion() == null && project.getPluginManagement() != null )
-            {
-                for ( Plugin pluginInPom : project.getPluginManagement().getPlugins() )
-                {
-                    if ( pluginInPom.getArtifactId().equals( plugin.getArtifactId() ) )
-                    {
-                        plugin.setVersion( pluginInPom.getVersion() );
-                        break;
-                    }
-                }
-            }
+            plugin.setVersion( attemptToGetPluginVersionFromProject( plugin, project ) );
-                for ( ArtifactRepository repository : session.getCurrentProject().getRemoteArtifactRepositories() )
-                {
-                    String localPath = plugin.getGroupId().replace( '.', '/' ) + "/" + plugin.getArtifactId() + "/maven-metadata-" + repository.getId() + ".xml";
+                File artifactMetadataFile;
+                
+                String localPath; 
+                
+                // Search in the local repositiory for a version
+                //
+                // maven-metadata-local.xml
+                //
+                localPath = plugin.getGroupId().replace( '.', '/' ) + "/" + plugin.getArtifactId() + "/maven-metadata-" + session.getLocalRepository().getId() + ".xml";
-                    File destination = new File( session.getLocalRepository().getBasedir(), localPath );
-
-                    if ( !destination.exists() )
+                artifactMetadataFile = new File( session.getLocalRepository().getBasedir(), localPath );
+                
+                if ( !artifactMetadataFile.exists() /* || user requests snapshot updates */ )
+                {                
+                    // Search in remote repositories for a version.
+                    //
+                    // maven-metadata-{central|nexus|...}.xml 
+                    //
+                    //TODO: we should cycle through the repositories but take the repository which actually
+                    // satisfied the prefix.
+                    for ( ArtifactRepository repository : project.getRemoteArtifactRepositories() )
-                        try
-                        {
-                            String remotePath = plugin.getGroupId().replace( '.', '/' ) + "/" + plugin.getArtifactId() + "/maven-metadata.xml";
+                        localPath = plugin.getGroupId().replace( '.', '/' ) + "/" + plugin.getArtifactId() + "/maven-metadata-" + repository.getId() + ".xml";
-                            repositorySystem.retrieve( repository, destination, remotePath, session.getRequest().getTransferListener() );
-                        }
-                        catch ( TransferFailedException e )
+                        artifactMetadataFile = new File( session.getLocalRepository().getBasedir(), localPath );
+
+                        if ( !artifactMetadataFile.exists() )
-                            continue;
-                        }
-                        catch ( ResourceDoesNotExistException e )
-                        {
-                            continue;
+                            try
+                            {
+                                String remotePath = plugin.getGroupId().replace( '.', '/' ) + "/" + plugin.getArtifactId() + "/maven-metadata.xml";
+
+                                repositorySystem.retrieve( repository, artifactMetadataFile, remotePath, session.getRequest().getTransferListener() );
+                            }
+                            catch ( TransferFailedException e )
+                            {
+                                continue;
+                            }
+                            catch ( ResourceDoesNotExistException e )
+                            {
+                                continue;
+                            }
+                }
-                    // We have retrieved the metadata
+                if ( artifactMetadataFile.exists() )
+                {                    
-                        Metadata pluginMetadata = readMetadata( destination );
+                        Metadata pluginMetadata = readMetadata( artifactMetadataFile );
+                        else
+                        {
+                            String latest = pluginMetadata.getVersioning().getLatest();
+                            
+                            if ( latest != null )
+                            {
+                                plugin.setVersion( latest );
+                            }
+                        }
+                else
+                {
+                    throw new PluginNotFoundException( plugin, null );
+                }
+    private String attemptToGetPluginVersionFromProject( Plugin plugin, MavenProject project )
+    {
+        for ( Plugin pluginInPom : project.getBuildPlugins() )
+        {
+            if ( pluginInPom.getArtifactId().equals( plugin.getArtifactId() ) )
+            {
+                return pluginInPom.getVersion();
+            }
+        }
+
+        if ( plugin.getVersion() == null && project.getPluginManagement() != null )
+        {
+            for ( Plugin pluginInPom : project.getPluginManagement().getPlugins() )
+            {
+                if ( pluginInPom.getArtifactId().equals( plugin.getArtifactId() ) )
+                {
+                    return pluginInPom.getVersion();
+                }
+            }
+        }
+        
+        return null;
+    }
+    
-    
-    public List<String> getLifecyclePhases()
-    {
-        for ( Lifecycle lifecycle : lifecycles )
-        {
-            if ( lifecycle.getId().equals( "default" ) )
-            {
-                return lifecycle.getPhases();
-            }
-        }
-
-        return null;
-    }   
-    
+        
-                Xpp3Dom dom = getDefaultPluginConfiguration( plugin, goal, localRepository, remoteRepositories );
+                Xpp3Dom dom = getDefaultPluginConfiguration( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), goal, localRepository, remoteRepositories );
-    private Xpp3Dom getDefaultPluginConfiguration( Plugin plugin, String goal, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories ) 
+    private Xpp3Dom getDefaultPluginConfiguration( String groupId, String artifactId, String version, String goal, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories ) 
-            mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, localRepository, remoteRepositories );
+            mojoDescriptor = pluginManager.getMojoDescriptor( groupId, artifactId, version, goal, localRepository, remoteRepositories );
-    {
+    {        
-                        
-        for ( ArtifactRepository repository : session.getCurrentProject().getRemoteArtifactRepositories() )
+                             
+        // Process all plugin groups in the local repository first to see if we get a hit. A developer may have been 
+        // developing a plugin locally and installing.
+        //
+        for ( String pluginGroup : session.getPluginGroups() )
-            for ( String pluginGroup : session.getPluginGroups() )
-            {
-                // org.apache.maven.plugins
-                // org/apache/maven/plugins/maven-metadata.xml
-                
-                String localPath = pluginGroup.replace( '.', '/' ) + "/" + "maven-metadata-" + repository.getId() + ".xml";
-                                
-                File destination = new File( session.getLocalRepository().getBasedir(), localPath );                
-                                
-                if ( !destination.exists() )
-                {
-                    try
-                    {                        
-                        String remotePath = pluginGroup.replace( '.', '/' ) + "/" + "maven-metadata.xml";
-                        
-                        repositorySystem.retrieve( repository, destination, remotePath, session.getRequest().getTransferListener() );
-                    }
-                    catch ( TransferFailedException e )
-                    {
-                        continue;
-                    }
-                    catch ( ResourceDoesNotExistException e )
-                    {
-                        continue;
-                    }
-                }
+            String localPath = pluginGroup.replace( '.', '/' ) + "/" + "maven-metadata-" + session.getLocalRepository().getId() + ".xml";
-                // We have retrieved the metadata
-                try
-                {                    
-                    Metadata pluginGroupMetadata = readMetadata( destination );
-                    
-                    List<org.apache.maven.artifact.repository.metadata.Plugin> plugins = pluginGroupMetadata.getPlugins();
-                                        
-                    if ( plugins != null )
-                    {
-                        for ( org.apache.maven.artifact.repository.metadata.Plugin metadataPlugin : plugins )
-                        {
-                            Plugin p = new Plugin();
-                            p.setGroupId(  pluginGroup );
-                            p.setArtifactId( metadataPlugin.getArtifactId() );                            
-                            pluginPrefixes.put( metadataPlugin.getPrefix(), p );
-                        }
-                    }                    
-                }
-                catch ( RepositoryMetadataReadException e )
+            File destination = new File( session.getLocalRepository().getBasedir(), localPath );
+
+            if ( destination.exists() )
+            {                
+                processPluginGroupMetadata( pluginGroup, destination, pluginPrefixes );    
+                
+                plugin = pluginPrefixes.get( prefix );
+                
+                if ( plugin != null )
-                    logger.warn( "Error reading plugin group metadata: ", e );
-                }
-            }            
+                    return plugin;
+                }                
+            }
+        
+        // Process all the remote repositories.
+        //
+        for ( String pluginGroup : session.getPluginGroups() )
+        {                
+            for ( ArtifactRepository repository : session.getCurrentProject().getRemoteArtifactRepositories() )
+            {
+                try
+                {
+                    String localPath = pluginGroup.replace( '.', '/' ) + "/" + "maven-metadata-" + repository.getId() + ".xml";
-        plugin = pluginPrefixes.get( prefix );
-        
-        if ( plugin != null )
-        {
-            return plugin;
-        }
-        
-        throw new NoPluginFoundForPrefixException( prefix );
+                    File destination = new File( session.getLocalRepository().getBasedir(), localPath );
+                    
+                    String remotePath = pluginGroup.replace( '.', '/' ) + "/" + "maven-metadata.xml";
+
+                    repositorySystem.retrieve( repository, destination, remotePath, session.getRequest().getTransferListener() );
+                    
+                    processPluginGroupMetadata( pluginGroup, destination, pluginPrefixes );
+                    
+                    plugin = pluginPrefixes.get( prefix );
+                    
+                    if ( plugin != null )
+                    {
+                        return plugin;
+                    }                                        
+                }
+                catch ( TransferFailedException e )
+                {
+                    continue;
+                }
+                catch ( ResourceDoesNotExistException e )
+                {
+                    continue;
+                }
+            }
+
+        }            
+                            
+        throw new NoPluginFoundForPrefixException( prefix, session.getLocalRepository(), session.getCurrentProject().getRemoteArtifactRepositories() );
+    // Keep track of the repository that provided the prefix mapping
+    //
+    private class PluginPrefix
+    {
+        private Plugin plugin;
+        
+        private ArtifactRepository repository;
+
+        public PluginPrefix( Plugin plugin, ArtifactRepository repository )
+        {
+            this.plugin = plugin;
+            this.repository = repository;
+        }
+    }
+    
+    
+    private void processPluginGroupMetadata( String pluginGroup, File pluginGroupMetadataFile, Map<String,Plugin> pluginPrefixes )
+    {
+        try
+        {
+            Metadata pluginGroupMetadata = readMetadata( pluginGroupMetadataFile );
+
+            List<org.apache.maven.artifact.repository.metadata.Plugin> plugins = pluginGroupMetadata.getPlugins();
+
+            if ( plugins != null )
+            {
+                for ( org.apache.maven.artifact.repository.metadata.Plugin metadataPlugin : plugins )
+                {
+                    Plugin p = new Plugin();
+                    p.setGroupId( pluginGroup );
+                    p.setArtifactId( metadataPlugin.getArtifactId() );
+                    pluginPrefixes.put( metadataPlugin.getPrefix(), p );
+                }
+            }
+        }
+        catch ( RepositoryMetadataReadException e )
+        {
+            logger.warn( "Error reading plugin group metadata: ", e );
+        }
+    }
+    

MOV23 MOV31 INS31 INS31 INS55 INS31 INS29 INS29 MOV43 INS42 INS44 MOV44 INS43 INS43 INS43 INS43 INS43 INS43 INS43 MOV43 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS43 INS43 INS43 INS43 MOV8 UPD83 INS39 UPD42 INS44 INS44 MOV8 INS83 MOV43 INS42 MOV44 INS44 MOV8 INS44 INS44 INS44 INS83 INS42 INS23 INS23 INS31 INS83 INS39 INS42 MOV44 INS44 INS44 MOV8 INS65 INS65 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 MOV60 MOV60 INS70 MOV70 MOV41 INS43 INS42 MOV74 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS74 INS42 INS43 INS42 MOV60 MOV25 MOV25 INS43 INS42 INS25 MOV41 INS43 INS42 INS43 INS42 INS43 INS42 INS70 MOV70 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS8 INS43 INS42 INS74 INS42 INS66 INS66 INS66 INS66 INS66 UPD42 MOV42 INS43 INS59 MOV44 UPD42 MOV42 MOV8 UPD42 INS42 INS42 INS43 MOV43 INS59 UPD43 MOV43 MOV43 INS42 MOV27 INS25 MOV27 INS42 MOV44 MOV32 MOV27 INS8 INS42 INS42 INS42 INS44 INS32 INS8 INS44 INS8 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS42 INS43 INS43 INS43 UPD42 MOV42 INS42 INS32 INS60 INS25 INS42 UPD42 INS42 INS32 UPD42 MOV21 MOV27 INS8 INS21 INS25 MOV70 INS43 INS42 INS42 INS42 INS60 MOV60 INS25 INS43 INS42 INS70 INS32 MOV32 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 MOV27 INS8 INS43 INS59 INS32 INS8 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 INS21 INS21 INS21 INS21 INS32 MOV27 MOV8 MOV44 MOV32 INS42 INS43 INS59 MOV32 INS8 INS42 MOV44 MOV32 MOV8 INS42 INS42 INS22 INS42 INS22 INS42 INS21 INS21 INS42 INS42 INS32 INS32 INS42 MOV21 UPD42 UPD42 INS7 INS32 INS32 INS7 INS42 INS42 INS32 INS60 INS21 INS21 INS25 INS25 INS41 INS42 INS42 INS27 INS21 MOV21 MOV25 INS52 INS42 INS52 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS7 INS7 INS38 INS8 INS32 INS8 INS8 MOV32 INS42 INS42 UPD42 INS32 INS45 INS45 INS32 INS45 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS14 INS32 INS70 INS42 INS42 MOV54 INS53 INS41 INS42 INS42 INS13 INS13 INS32 INS42 INS42 INS42 INS42 INS42 MOV60 MOV60 INS21 INS21 INS25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS45 INS32 INS45 INS32 INS45 INS43 INS32 INS42 INS42 INS42 MOV44 INS32 INS8 INS14 MOV32 INS32 INS32 INS32 INS42 INS42 INS32 INS7 INS27 INS8 INS32 INS42 INS13 INS13 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS21 MOV25 INS43 INS42 INS33 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS8 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS42 INS14 INS60 INS25 INS43 INS32 INS42 UPD42 UPD42 INS43 INS59 INS27 INS8 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 DEL43 DEL74 DEL42 DEL32 DEL45 DEL32 DEL32 DEL41 DEL32 DEL43 DEL42 DEL44 DEL70 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL74 DEL14 DEL59 DEL60 DEL42 DEL25 DEL8 DEL70 DEL8 DEL42 DEL34 DEL27 DEL27 DEL8 DEL25 DEL70 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL10 DEL42 DEL42 DEL32 DEL21 DEL10 DEL8 DEL70 DEL38 DEL25
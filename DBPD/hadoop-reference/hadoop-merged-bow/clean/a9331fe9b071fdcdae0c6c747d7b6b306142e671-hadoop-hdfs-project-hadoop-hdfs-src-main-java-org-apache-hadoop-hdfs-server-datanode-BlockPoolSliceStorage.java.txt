HDFS-7035. Make adding a new data directory to the DataNode an atomic operation and improve error handling (Lei Xu via Colin P. McCabe)

+import com.google.common.collect.Lists;
-import java.util.ArrayList;
-import java.util.HashSet;
+  // Expose visibility for VolumeBuilder#commit().
+  public void addStorageDir(StorageDirectory sd) {
+    super.addStorageDir(sd);
+  }
+
+  /**
+   * Load one storage directory. Recover from previous transitions if required.
+   *
+   * @param datanode datanode instance
+   * @param nsInfo namespace information
+   * @param dataDir the root path of the storage directory
+   * @param startOpt startup option
+   * @return the StorageDirectory successfully loaded.
+   * @throws IOException
+   */
+  private StorageDirectory loadStorageDirectory(DataNode datanode,
+      NamespaceInfo nsInfo, File dataDir, StartupOption startOpt) throws IOException {
+    StorageDirectory sd = new StorageDirectory(dataDir, null, true);
+    try {
+      StorageState curState = sd.analyzeStorage(startOpt, this);
+      // sd is locked but not opened
+      switch (curState) {
+      case NORMAL:
+        break;
+      case NON_EXISTENT:
+        LOG.info("Block pool storage directory " + dataDir + " does not exist");
+        throw new IOException("Storage directory " + dataDir
+            + " does not exist");
+      case NOT_FORMATTED: // format
+        LOG.info("Block pool storage directory " + dataDir
+            + " is not formatted for " + nsInfo.getBlockPoolID());
+        LOG.info("Formatting ...");
+        format(sd, nsInfo);
+        break;
+      default:  // recovery part is common
+        sd.doRecover(curState);
+      }
+
+      // 2. Do transitions
+      // Each storage directory is treated individually.
+      // During startup some of them can upgrade or roll back
+      // while others could be up-to-date for the regular startup.
+      doTransition(datanode, sd, nsInfo, startOpt);
+      if (getCTime() != nsInfo.getCTime()) {
+        throw new IOException(
+            "Data-node and name-node CTimes must be the same.");
+      }
+
+      // 3. Update successfully loaded storage.
+      setServiceLayoutVersion(getServiceLayoutVersion());
+      writeProperties(sd);
+
+      return sd;
+    } catch (IOException ioe) {
+      sd.unlock();
+      throw ioe;
+    }
+  }
+
+  /**
+   * Analyze and load storage directories. Recover from previous transitions if
+   * required.
+   *
+   * The block pool storages are either all analyzed or none of them is loaded.
+   * Therefore, a failure on loading any block pool storage results a faulty
+   * data volume.
+   *
+   * @param datanode Datanode to which this storage belongs to
+   * @param nsInfo namespace information
+   * @param dataDirs storage directories of block pool
+   * @param startOpt startup option
+   * @return an array of loaded block pool directories.
+   * @throws IOException on error
+   */
+  List<StorageDirectory> loadBpStorageDirectories(
+      DataNode datanode, NamespaceInfo nsInfo,
+      Collection<File> dataDirs, StartupOption startOpt) throws IOException {
+    List<StorageDirectory> succeedDirs = Lists.newArrayList();
+    try {
+      for (File dataDir : dataDirs) {
+        if (containsStorageDir(dataDir)) {
+          throw new IOException(
+              "BlockPoolSliceStorage.recoverTransitionRead: " +
+                  "attempt to load an used block storage: " + dataDir);
+        }
+        StorageDirectory sd =
+            loadStorageDirectory(datanode, nsInfo, dataDir, startOpt);
+        succeedDirs.add(sd);
+      }
+    } catch (IOException e) {
+      LOG.warn("Failed to analyze storage directories for block pool "
+          + nsInfo.getBlockPoolID(), e);
+      throw e;
+    }
+    return succeedDirs;
+  }
+
-   * 
+   *
+   * The block pool storages are either all analyzed or none of them is loaded.
+   * Therefore, a failure on loading any block pool storage results a faulty
+   * data volume.
+   *
-    Set<String> existingStorageDirs = new HashSet<String>();
-    for (int i = 0; i < getNumStorageDirs(); i++) {
-      existingStorageDirs.add(getStorageDir(i).getRoot().getAbsolutePath());
-    }
-
-    // 1. For each BP data directory analyze the state and
-    // check whether all is consistent before transitioning.
-    ArrayList<StorageState> dataDirStates = new ArrayList<StorageState>(
-        dataDirs.size());
-    for (Iterator<File> it = dataDirs.iterator(); it.hasNext();) {
-      File dataDir = it.next();
-      if (existingStorageDirs.contains(dataDir.getAbsolutePath())) {
-        LOG.info("Storage directory " + dataDir + " has already been used.");
-        it.remove();
-        continue;
-      }
-      StorageDirectory sd = new StorageDirectory(dataDir, null, true);
-      StorageState curState;
-      try {
-        curState = sd.analyzeStorage(startOpt, this);
-        // sd is locked but not opened
-        switch (curState) {
-        case NORMAL:
-          break;
-        case NON_EXISTENT:
-          // ignore this storage
-          LOG.info("Storage directory " + dataDir + " does not exist.");
-          it.remove();
-          continue;
-        case NOT_FORMATTED: // format
-          LOG.info("Storage directory " + dataDir + " is not formatted.");
-          LOG.info("Formatting ...");
-          format(sd, nsInfo);
-          break;
-        default: // recovery part is common
-          sd.doRecover(curState);
-        }
-      } catch (IOException ioe) {
-        sd.unlock();
-        throw ioe;
-      }
-      // add to the storage list. This is inherited from parent class, Storage.
+    for (StorageDirectory sd : loadBpStorageDirectories(
+        datanode, nsInfo, dataDirs, startOpt)) {
-      dataDirStates.add(curState);
-
-    if (dataDirs.size() == 0) // none of the data dirs exist
-      throw new IOException(
-          "All specified directories are not accessible or do not exist.");
-
-    // 2. Do transitions
-    // Each storage directory is treated individually.
-    // During startup some of them can upgrade or roll back
-    // while others could be up-to-date for the regular startup.
-    for (int idx = 0; idx < getNumStorageDirs(); idx++) {
-      doTransition(datanode, getStorageDir(idx), nsInfo, startOpt);
-      assert getCTime() == nsInfo.getCTime() 
-          : "Data-node and name-node CTimes must be the same.";
-    }
-
-    // 3. Update all storages. Some of them might have just been formatted.
-    this.writeAll();

MOV26 UPD40 INS31 INS31 INS31 INS31 INS83 MOV39 UPD42 MOV42 INS44 INS8 INS29 INS83 INS43 INS42 MOV44 MOV44 INS44 MOV44 MOV43 INS8 INS29 INS74 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS39 INS42 INS44 INS44 MOV44 INS44 INS43 INS8 INS43 INS42 INS21 INS65 INS65 MOV65 INS65 MOV65 INS65 INS65 UPD42 MOV42 MOV43 INS42 MOV60 INS54 INS65 MOV65 INS65 MOV65 INS65 INS65 INS65 UPD43 MOV43 UPD43 MOV43 INS43 INS42 INS43 INS42 INS74 INS42 INS43 INS42 UPD42 MOV42 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 MOV65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 MOV21 INS70 UPD42 MOV42 INS48 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS8 MOV12 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 UPD42 UPD42 INS42 INS42 UPD43 MOV43 UPD43 MOV43 INS42 INS74 INS59 INS8 INS12 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS44 INS32 INS8 INS42 INS42 INS60 INS50 INS21 INS25 INS21 INS21 INS41 UPD42 UPD42 INS43 INS43 INS42 INS32 INS70 INS44 INS8 INS43 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 MOV42 MOV21 MOV43 INS59 INS42 MOV49 INS10 MOV49 INS21 INS53 MOV49 INS21 MOV21 MOV21 INS10 INS49 MOV21 INS32 UPD27 MOV27 INS8 INS32 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS44 INS42 INS8 INS43 INS42 INS21 INS53 INS42 INS42 MOV32 INS32 INS14 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS53 UPD42 MOV42 INS32 INS42 INS42 MOV43 INS42 MOV25 INS60 INS21 INS42 MOV32 INS42 INS42 INS42 INS27 INS43 INS27 INS42 INS42 INS27 INS14 UPD42 MOV42 INS43 INS59 MOV32 UPD42 INS42 INS45 INS42 INS45 UPD42 MOV42 INS45 INS42 INS45 INS45 UPD42 MOV42 INS45 MOV32 INS43 INS45 UPD42 MOV42 INS53 INS42 INS42 INS32 UPD42 UPD42 INS42 UPD45 INS32 INS42 UPD42 INS42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 MOV43 INS27 UPD45 MOV45 INS45 MOV42 DEL40 DEL26 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL18 DEL42 DEL45 DEL66 DEL65 DEL29 DEL43 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL27 DEL42 DEL37 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL74 DEL42 DEL74 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL10 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL21 DEL18 DEL21 DEL10 DEL49 DEL50 DEL8 DEL54 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL32 DEL34 DEL27 DEL45 DEL14 DEL53 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL32 DEL32 DEL21 DEL45 DEL6 DEL8 DEL24 DEL52 DEL42 DEL32 DEL21 DEL8 DEL31
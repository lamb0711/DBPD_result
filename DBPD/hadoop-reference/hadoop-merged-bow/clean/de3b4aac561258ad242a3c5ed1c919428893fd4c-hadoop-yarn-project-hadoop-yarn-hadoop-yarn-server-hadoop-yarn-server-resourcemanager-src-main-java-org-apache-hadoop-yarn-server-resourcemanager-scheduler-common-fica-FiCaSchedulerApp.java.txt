YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan

-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainerState;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.NodeType;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedContainerChangeRequest;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.common.ContainerAllocationProposal;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.common.ResourceCommitRequest;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.common.SchedulerContainer;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.PlacementSet;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.SchedulingPlacementSet;
+import org.apache.hadoop.yarn.server.utils.BuilderUtils;
-import com.google.common.annotations.VisibleForTesting;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+  private Map<ContainerId, SchedContainerChangeRequest> toBeRemovedIncRequests =
+      new ConcurrentHashMap<>();
+
-  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,
+  public RMContainer allocate(FiCaSchedulerNode node,
-      writeLock.lock();
+      readLock.lock();
+      // FIXME, should set when confirmed
-      // Add it to allContainers list.
-      newlyAllocatedContainers.add(rmContainer);
-
-      ContainerId containerId = container.getId();
-      liveContainers.put(containerId, rmContainer);
-
-      // Update consumption and track allocations
-      List<ResourceRequest> resourceRequestList = appSchedulingInfo.allocate(
-          type, node, schedulerKey, request, container);
-
-      attemptResourceUsage.incUsed(node.getPartition(),
-          container.getResource());
-
-      // Update resource requests related to "request" and store in RMContainer
-      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);
-
-      // Inform the container
-      rmContainer.handle(
-          new RMContainerEvent(containerId, RMContainerEventType.START));
-
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("allocate: applicationAttemptId=" + containerId
-            .getApplicationAttemptId() + " container=" + containerId + " host="
-            + container.getNodeId().getHost() + " type=" + type);
-      }
-      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,
-          "SchedulerApp", getApplicationId(), containerId,
-          container.getResource());
-
+      readLock.unlock();
+    }
+  }
+
+  private boolean rmContainerInFinalState(RMContainer rmContainer) {
+    if (null == rmContainer) {
+      return false;
+    }
+
+    return rmContainer.completed();
+  }
+
+  private boolean anyContainerInFinalState(
+      ResourceCommitRequest<FiCaSchedulerApp, FiCaSchedulerNode> request) {
+    for (SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode> c : request
+        .getContainersToRelease()) {
+      if (rmContainerInFinalState(c.getRmContainer())) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("To-release container=" + c.getRmContainer()
+              + " is in final state");
+        }
+        return true;
+      }
+    }
+
+    for (ContainerAllocationProposal<FiCaSchedulerApp, FiCaSchedulerNode> c : request
+        .getContainersToAllocate()) {
+      for (SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode> r : c
+          .getToRelease()) {
+        if (rmContainerInFinalState(r.getRmContainer())) {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("To-release container=" + r.getRmContainer()
+                + ", for to a new allocated container, is in final state");
+          }
+          return true;
+        }
+      }
+
+      if (null != c.getAllocateFromReservedContainer()) {
+        if (rmContainerInFinalState(
+            c.getAllocateFromReservedContainer().getRmContainer())) {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Allocate from reserved container" + c
+                .getAllocateFromReservedContainer().getRmContainer()
+                + " is in final state");
+          }
+          return true;
+        }
+      }
+    }
+
+    for (ContainerAllocationProposal<FiCaSchedulerApp, FiCaSchedulerNode> c : request
+        .getContainersToReserve()) {
+      for (SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode> r : c
+          .getToRelease()) {
+        if (rmContainerInFinalState(r.getRmContainer())) {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("To-release container=" + r.getRmContainer()
+                + ", for a reserved container, is in final state");
+          }
+          return true;
+        }
+      }
+    }
+
+    return false;
+  }
+
+  private SchedContainerChangeRequest getResourceChangeRequest(
+      SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode> schedulerContainer) {
+    return appSchedulingInfo.getIncreaseRequest(
+        schedulerContainer.getSchedulerNode().getNodeID(),
+        schedulerContainer.getSchedulerRequestKey(),
+        schedulerContainer.getRmContainer().getContainerId());
+  }
+
+  private boolean checkIncreaseContainerAllocation(
+      ContainerAllocationProposal<FiCaSchedulerApp, FiCaSchedulerNode> allocation,
+      SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode> schedulerContainer) {
+    // When increase a container
+    if (schedulerContainer.getRmContainer().getState()
+        != RMContainerState.RUNNING) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Trying to increase a container, but container="
+            + schedulerContainer.getRmContainer().getContainerId()
+            + " is not in running state.");
+      }
+      return false;
+    }
+
+    // Check if increase request is still valid
+    SchedContainerChangeRequest increaseRequest = getResourceChangeRequest(
+        schedulerContainer);
+
+    if (null == increaseRequest || !Resources.equals(
+        increaseRequest.getDeltaCapacity(),
+        allocation.getAllocatedOrReservedResource())) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Increase request has been changed, reject this proposal");
+      }
+      return false;
+    }
+
+    if (allocation.getAllocateFromReservedContainer() != null) {
+      // In addition, if allocation is from a reserved container, check
+      // if the reserved container has enough reserved space
+      if (!Resources.equals(
+          allocation.getAllocateFromReservedContainer().getRmContainer()
+              .getReservedResource(), increaseRequest.getDeltaCapacity())) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  private boolean commonCheckContainerAllocation(
+      Resource cluster,
+      ContainerAllocationProposal<FiCaSchedulerApp, FiCaSchedulerNode> allocation,
+      SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode> schedulerContainer) {
+    // Make sure node is not reserved by anyone else
+    RMContainer reservedContainerOnNode =
+        schedulerContainer.getSchedulerNode().getReservedContainer();
+    if (reservedContainerOnNode != null) {
+      RMContainer fromReservedContainer =
+          allocation.getAllocateFromReservedContainer().getRmContainer();
+
+      if (fromReservedContainer != reservedContainerOnNode) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(
+              "Try to allocate from a non-existed reserved container");
+        }
+        return false;
+      }
+    }
+
+    // Do we have enough space on this node?
+    Resource availableResource = Resources.clone(
+        schedulerContainer.getSchedulerNode().getUnallocatedResource());
+
+    // If we have any to-release container in non-reserved state, they are
+    // from lazy-preemption, add their consumption to available resource
+    // of this node
+    if (allocation.getToRelease() != null && !allocation.getToRelease()
+        .isEmpty()) {
+      for (SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode>
+          releaseContainer : allocation.getToRelease()) {
+        // Only consider non-reserved container (reserved container will
+        // not affect available resource of node) on the same node
+        if (releaseContainer.getRmContainer().getState()
+            != RMContainerState.RESERVED
+            && releaseContainer.getSchedulerNode() == schedulerContainer
+            .getSchedulerNode()) {
+          Resources.addTo(availableResource,
+              releaseContainer.getRmContainer().getAllocatedResource());
+        }
+      }
+    }
+    if (!Resources.fitsIn(rc, cluster,
+        allocation.getAllocatedOrReservedResource(),
+        availableResource)) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Node doesn't have enough available resource, asked="
+            + allocation.getAllocatedOrReservedResource() + " available="
+            + availableResource);
+      }
+      return false;
+    }
+
+    return true;
+  }
+
+  public boolean accept(Resource cluster,
+      ResourceCommitRequest<FiCaSchedulerApp, FiCaSchedulerNode> request) {
+    List<ResourceRequest> resourceRequests = null;
+    boolean reReservation = false;
+
+    try {
+      readLock.lock();
+
+      // First make sure no container in release list in final state
+      if (anyContainerInFinalState(request)) {
+        return false;
+      }
+
+      // TODO, make sure all scheduler nodes are existed
+      // TODO, make sure all node labels are not changed
+
+      if (request.anythingAllocatedOrReserved()) {
+        /*
+         * 1) If this is a newly allocated container, check if the node is reserved
+         *    / not-reserved by any other application
+         * 2) If this is a newly reserved container, check if the node is reserved or not
+         */
+        // Assume we have only one container allocated or reserved
+        ContainerAllocationProposal<FiCaSchedulerApp, FiCaSchedulerNode>
+            allocation = request.getFirstAllocatedOrReservedContainer();
+        SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode>
+            schedulerContainer = allocation.getAllocatedOrReservedContainer();
+
+        if (schedulerContainer.isAllocated()) {
+          if (!allocation.isIncreasedAllocation()) {
+            // When allocate a new container
+            resourceRequests =
+                schedulerContainer.getRmContainer().getResourceRequests();
+
+            // Check pending resource request
+            if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),
+                schedulerContainer.getSchedulerNode(),
+                schedulerContainer.getSchedulerRequestKey())) {
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("No pending resource for: nodeType=" + allocation
+                    .getAllocationLocalityType() + ", node=" + schedulerContainer
+                    .getSchedulerNode() + ", requestKey=" + schedulerContainer
+                    .getSchedulerRequestKey() + ", application="
+                    + getApplicationAttemptId());
+              }
+
+              return false;
+            }
+          } else {
+            if (!checkIncreaseContainerAllocation(allocation,
+                schedulerContainer)) {
+              return false;
+            }
+          }
+
+          // Common part of check container allocation regardless if it is a
+          // increase container or regular container
+          commonCheckContainerAllocation(cluster, allocation,
+              schedulerContainer);
+        } else {
+          // Container reserved first time will be NEW, after the container
+          // accepted & confirmed, it will become RESERVED state
+          if (schedulerContainer.getRmContainer().getState()
+              == RMContainerState.RESERVED) {
+            // Set reReservation == true
+            reReservation = true;
+          } else {
+            // When reserve a resource (state == NEW is for new container,
+            // state == RUNNING is for increase container).
+            // Just check if the node is not already reserved by someone
+            if (schedulerContainer.getSchedulerNode().getReservedContainer()
+                != null) {
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("Try to reserve a container, but the node is "
+                    + "already reserved by another container="
+                    + schedulerContainer.getSchedulerNode()
+                    .getReservedContainer().getContainerId());
+              }
+              return false;
+            }
+          }
+        }
+      }
+    } finally {
+      readLock.unlock();
+    }
+
+    // Skip check parent if this is a re-reservation container
+    boolean accepted = true;
+    if (!reReservation) {
+      // Check parent if anything allocated or reserved
+      if (request.anythingAllocatedOrReserved()) {
+        accepted = getCSLeafQueue().accept(cluster, request);
+      }
+    }
+
+    // When rejected, recover resource requests for this app
+    if (!accepted && resourceRequests != null) {
+      recoverResourceRequestsForContainer(resourceRequests);
+    }
+
+    return accepted;
+  }
+
+  public void apply(Resource cluster,
+      ResourceCommitRequest<FiCaSchedulerApp, FiCaSchedulerNode> request) {
+    boolean reReservation = false;
+
+    try {
+      writeLock.lock();
+
+      // If we allocated something
+      if (request.anythingAllocatedOrReserved()) {
+        ContainerAllocationProposal<FiCaSchedulerApp, FiCaSchedulerNode>
+            allocation = request.getFirstAllocatedOrReservedContainer();
+        SchedulerContainer<FiCaSchedulerApp, FiCaSchedulerNode>
+            schedulerContainer = allocation.getAllocatedOrReservedContainer();
+        RMContainer rmContainer = schedulerContainer.getRmContainer();
+
+        reReservation =
+            (!schedulerContainer.isAllocated()) && (rmContainer.getState()
+                == RMContainerState.RESERVED);
+
+        // Generate new containerId if it is not an allocation for increasing
+        // Or re-reservation
+        if (!allocation.isIncreasedAllocation()) {
+          if (rmContainer.getContainer().getId() == null) {
+            rmContainer.setContainerId(BuilderUtils
+                .newContainerId(getApplicationAttemptId(),
+                    getNewContainerId()));
+          }
+        }
+        ContainerId containerId = rmContainer.getContainerId();
+
+        if (schedulerContainer.isAllocated()) {
+          // This allocation is from a reserved container
+          // Unreserve it first
+          if (allocation.getAllocateFromReservedContainer() != null) {
+            RMContainer reservedContainer =
+                allocation.getAllocateFromReservedContainer().getRmContainer();
+            // Handling container allocation
+            // Did we previously reserve containers at this 'priority'?
+            unreserve(schedulerContainer.getSchedulerRequestKey(),
+                schedulerContainer.getSchedulerNode(), reservedContainer);
+          }
+
+          // Update this application for the allocated container
+          if (!allocation.isIncreasedAllocation()) {
+            // Allocate a new container
+            newlyAllocatedContainers.add(rmContainer);
+            liveContainers.put(containerId, rmContainer);
+
+            // Deduct pending resource requests
+            List<ResourceRequest> requests = appSchedulingInfo.allocate(
+                allocation.getAllocationLocalityType(), schedulerContainer.getSchedulerNode(),
+                schedulerContainer.getSchedulerRequestKey(),
+                schedulerContainer.getRmContainer().getContainer());
+            ((RMContainerImpl) rmContainer).setResourceRequests(requests);
+
+            attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),
+                allocation.getAllocatedOrReservedResource());
+
+            rmContainer.handle(
+                new RMContainerEvent(containerId, RMContainerEventType.START));
+
+            // Inform the node
+            schedulerContainer.getSchedulerNode().allocateContainer(
+                rmContainer);
+
+            // update locality statistics,
+            incNumAllocatedContainers(allocation.getAllocationLocalityType(),
+                allocation.getRequestLocalityType());
+
+            if (LOG.isDebugEnabled()) {
+              LOG.debug("allocate: applicationAttemptId=" + containerId
+                  .getApplicationAttemptId() + " container=" + containerId
+                  + " host=" + rmContainer.getAllocatedNode().getHost()
+                  + " type=" + allocation.getAllocationLocalityType());
+            }
+            RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,
+                "SchedulerApp", getApplicationId(), containerId,
+                allocation.getAllocatedOrReservedResource());
+          } else{
+            SchedContainerChangeRequest increaseRequest =
+                getResourceChangeRequest(schedulerContainer);
+
+            // allocate resource for an increase request
+            // Notify node
+            schedulerContainer.getSchedulerNode().increaseContainer(
+                increaseRequest.getContainerId(),
+                increaseRequest.getDeltaCapacity());
+
+            // OK, we can allocate this increase request
+            // Notify application
+            increaseContainer(increaseRequest);
+          }
+        } else {
+          if (!allocation.isIncreasedAllocation()) {
+            // If the rmContainer's state is already updated to RESERVED, this is
+            // a reReservation
+            reserve(schedulerContainer.getSchedulerRequestKey(),
+                schedulerContainer.getSchedulerNode(),
+                schedulerContainer.getRmContainer(),
+                schedulerContainer.getRmContainer().getContainer(),
+                reReservation);
+          } else{
+            SchedContainerChangeRequest increaseRequest =
+                getResourceChangeRequest(schedulerContainer);
+
+            reserveIncreasedContainer(
+                schedulerContainer.getSchedulerRequestKey(),
+                schedulerContainer.getSchedulerNode(),
+                increaseRequest.getRMContainer(),
+                increaseRequest.getDeltaCapacity());
+          }
+        }
+      }
+    } finally {
+
+    // Don't bother CS leaf queue if it is a re-reservation
+    if (!reReservation) {
+      getCSLeafQueue().apply(cluster, request);
+    }
-   * @param resourceCalculator
-   * @param clusterResource
-   * @param minimumAllocation
+   * @param resourceCalculator resourceCalculator
+   * @param clusterResource clusterResource
+   * @param minimumAllocation minimumAllocation
-    try {
-      writeLock.lock();
-      // first go around make this algorithm simple and just grab first
-      // reservation that has enough resources
-      Map<NodeId, RMContainer> reservedContainers = this.reservedContainers.get(
-          schedulerKey);
+    // first go around make this algorithm simple and just grab first
+    // reservation that has enough resources
+    Map<NodeId, RMContainer> reservedContainers = this.reservedContainers.get(
+        schedulerKey);
-      if ((reservedContainers != null) && (!reservedContainers.isEmpty())) {
-        for (Map.Entry<NodeId, RMContainer> entry : reservedContainers
-            .entrySet()) {
-          NodeId nodeId = entry.getKey();
-          RMContainer reservedContainer = entry.getValue();
-          if (reservedContainer.hasIncreaseReservation()) {
-            // Currently, only regular container allocation supports continuous
-            // reservation looking, we don't support canceling increase request
-            // reservation when allocating regular container.
-            continue;
+    if ((reservedContainers != null) && (!reservedContainers.isEmpty())) {
+      for (Map.Entry<NodeId, RMContainer> entry : reservedContainers
+          .entrySet()) {
+        NodeId nodeId = entry.getKey();
+        RMContainer reservedContainer = entry.getValue();
+        if (reservedContainer.hasIncreaseReservation()) {
+          // Currently, only regular container allocation supports continuous
+          // reservation looking, we don't support canceling increase request
+          // reservation when allocating regular container.
+          continue;
+        }
+
+        Resource reservedResource = reservedContainer.getReservedResource();
+
+        // make sure we unreserve one with at least the same amount of
+        // resources, otherwise could affect capacity limits
+        if (Resources.fitsIn(rc, clusterResource, resourceNeedUnreserve,
+            reservedResource)) {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug(
+                "unreserving node with reservation size: " + reservedResource
+                    + " in order to allocate container with size: "
+                    + resourceNeedUnreserve);
-
-          Resource reservedResource = reservedContainer.getReservedResource();
-
-          // make sure we unreserve one with at least the same amount of
-          // resources, otherwise could affect capacity limits
-          if (Resources.fitsIn(rc, clusterResource, resourceNeedUnreserve,
-              reservedResource)) {
-            if (LOG.isDebugEnabled()) {
-              LOG.debug(
-                  "unreserving node with reservation size: " + reservedResource
-                      + " in order to allocate container with size: "
-                      + resourceNeedUnreserve);
-            }
-            return nodeId;
-          }
+          return nodeId;
-      return null;
-    } finally {
-      writeLock.unlock();
+    return null;
-  public void reserve(SchedulerRequestKey schedulerKey,
-      FiCaSchedulerNode node, RMContainer rmContainer, Container container) {
+  public void reserve(SchedulerRequestKey schedulerKey, FiCaSchedulerNode node,
+      RMContainer rmContainer, Container container, boolean reReservation) {
-    if (rmContainer == null) {
+    // rmContainer will be moved to reserved in the super.reserve
+    if (!reReservation) {
-    // need to unreserve some other container first
-    NodeId idToUnreserve =
-        getNodeIdToUnreserve(schedulerKey, minimumUnreservedResource,
-            rc, clusterResource);
-    if (idToUnreserve == null) {
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("checked to see if could unreserve for app but nothing "
-            + "reserved that matches for this app");
+    try {
+      readLock.lock();
+      // need to unreserve some other container first
+      NodeId idToUnreserve = getNodeIdToUnreserve(schedulerKey,
+          minimumUnreservedResource, rc, clusterResource);
+      if (idToUnreserve == null) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("checked to see if could unreserve for app but nothing "
+              + "reserved that matches for this app");
+        }
+        return null;
-      return null;
-    }
-    FiCaSchedulerNode nodeToUnreserve =
-        ((CapacityScheduler) scheduler).getNode(idToUnreserve);
-    if (nodeToUnreserve == null) {
-      LOG.error("node to unreserve doesn't exist, nodeid: " + idToUnreserve);
-      return null;
-    }
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("unreserving for app: " + getApplicationId()
-        + " on nodeId: " + idToUnreserve
-        + " in order to replace reserved application and place it on node: "
-        + node.getNodeID() + " needing: " + minimumUnreservedResource);
-    }
+      FiCaSchedulerNode nodeToUnreserve =
+          ((CapacityScheduler) scheduler).getNode(idToUnreserve);
+      if (nodeToUnreserve == null) {
+        LOG.error("node to unreserve doesn't exist, nodeid: " + idToUnreserve);
+        return null;
+      }
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("unreserving for app: " + getApplicationId() + " on nodeId: "
+            + idToUnreserve
+            + " in order to replace reserved application and place it on node: "
+            + node.getNodeID() + " needing: " + minimumUnreservedResource);
+      }
-    // headroom
-    Resources.addTo(getHeadroom(), nodeToUnreserve
-        .getReservedContainer().getReservedResource());
+      // headroom
+      Resources.addTo(getHeadroom(),
+          nodeToUnreserve.getReservedContainer().getReservedResource());
-    return nodeToUnreserve.getReservedContainer();
+      return nodeToUnreserve.getReservedContainer();
+    } finally {
+      readLock.unlock();
+    }
-      FiCaSchedulerNode node, ResourceLimits currentResourceLimits,
+      PlacementSet<FiCaSchedulerNode> ps, ResourceLimits currentResourceLimits,
-    try {
-      writeLock.lock();
-      return containerAllocator.assignContainers(clusterResource, node,
-          schedulingMode, currentResourceLimits, reservedContainer);
-    } finally {
-      writeLock.unlock();
-    }
+    return containerAllocator.assignContainers(clusterResource, ps,
+        schedulingMode, currentResourceLimits, reservedContainer);
-   * @param message
+   * @param message Message of app skip diagnostics
+    // FIXME, update AM diagnostics when global scheduling is enabled
+    if (null == node) {
+      return;
+    }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public SchedulingPlacementSet<FiCaSchedulerNode> getSchedulingPlacementSet(
+      SchedulerRequestKey schedulerRequestKey) {
+    return super.getSchedulingPlacementSet(schedulerRequestKey);
+  }
+
+
+  public void addToBeRemovedIncreaseRequest(
+      SchedContainerChangeRequest request) {
+    toBeRemovedIncRequests.put(request.getContainerId(), request);
+  }
+
+  public void removedToBeRemovedIncreaseRequests() {
+    // Remove invalid in request requests
+    if (!toBeRemovedIncRequests.isEmpty()) {
+      try {
+        writeLock.lock();
+        Iterator<Map.Entry<ContainerId, SchedContainerChangeRequest>> iter =
+            toBeRemovedIncRequests.entrySet().iterator();
+        while (iter.hasNext()) {
+          SchedContainerChangeRequest req = iter.next().getValue();
+          appSchedulingInfo.removeIncreaseRequest(req.getNodeId(),
+              req.getRMContainer().getAllocatedSchedulerKey(),
+              req.getContainerId());
+          iter.remove();
+        }
+      } finally {
+        writeLock.unlock();
+      }
+    }
+  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS74 INS59 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 MOV8 INS44 INS8 INS78 INS79 INS83 INS74 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS43 INS43 INS43 INS42 INS14 INS43 INS42 INS25 INS41 INS74 INS42 INS70 INS70 INS70 INS41 INS42 INS74 INS42 INS41 INS74 INS42 INS74 INS42 INS25 INS60 INS25 INS25 INS41 INS43 INS42 INS74 INS42 INS74 INS42 INS60 INS25 INS60 INS25 INS25 INS41 INS43 INS42 INS74 INS42 INS60 INS60 INS54 INS60 INS25 INS25 INS41 INS43 INS42 INS74 INS42 INS60 INS54 INS25 INS39 INS42 INS54 INS74 UPD42 MOV41 INS25 INS42 INS42 INS45 INS43 INS43 INS43 INS42 INS41 INS43 INS42 INS21 INS25 INS42 INS42 INS42 INS74 MOV21 INS8 INS42 INS27 INS8 INS32 INS43 INS43 INS43 INS44 INS32 INS8 INS44 INS32 INS8 INS44 INS32 INS8 INS9 INS43 INS43 INS43 INS32 INS43 INS43 INS43 INS43 INS43 INS43 INS27 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS9 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS38 INS8 INS9 INS42 INS43 INS43 INS43 MOV74 INS59 INS39 INS59 INS8 INS8 INS39 INS59 INS38 INS8 INS27 INS8 INS42 INS42 INS43 INS43 INS43 INS39 INS59 INS8 MOV8 INS38 INS8 INS66 INS66 INS66 INS38 MOV8 INS8 INS43 INS43 INS66 INS27 INS8 INS42 INS42 INS42 INS48 INS42 INS32 INS38 INS8 INS43 INS21 INS33 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS42 INS42 INS25 INS74 INS42 INS42 INS42 INS70 INS25 INS74 INS42 INS42 INS42 INS70 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS25 INS41 INS42 INS42 INS32 INS27 INS38 INS25 INS41 INS32 INS33 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS42 INS42 INS32 INS27 INS38 INS70 INS32 INS25 INS41 INS42 INS42 INS42 INS42 INS33 INS42 INS9 INS21 INS25 INS25 INS21 INS42 INS9 INS42 INS25 INS38 INS27 INS21 INS42 INS42 INS42 INS42 INS9 MOV21 INS25 INS42 INS21 INS42 INS21 INS21 INS42 MOV42 UPD42 INS33 INS42 INS41 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS54 INS42 INS32 INS9 INS43 INS43 INS43 INS32 INS8 INS43 INS43 INS43 INS44 INS32 INS8 INS27 INS8 INS43 INS43 INS43 INS44 INS32 INS8 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS8 INS9 INS42 INS42 INS33 INS42 INS32 INS32 INS8 INS9 INS42 INS42 INS38 INS8 INS32 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS32 INS33 INS32 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS8 INS9 INS32 INS32 INS8 INS32 INS8 INS32 INS32 INS8 INS42 INS42 INS33 INS32 INS32 INS8 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS8 MOV8 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS25 INS41 INS42 INS42 INS42 INS74 INS42 INS42 INS42 INS25 INS33 INS32 INS25 INS42 INS42 INS42 INS74 INS42 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS32 INS32 INS42 INS42 INS21 INS32 INS41 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS25 INS41 INS32 INS42 INS42 INS42 INS32 INS42 INS74 INS42 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS60 INS60 INS25 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS60 INS60 INS60 INS21 INS25 INS60 INS25 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 INS60 INS61 INS42 INS42 INS32 INS8 INS9 INS43 INS43 INS43 INS32 INS8 INS42 INS42 INS32 INS8 INS43 INS43 INS43 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS9 INS32 INS42 INS32 INS8 INS9 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS27 INS8 INS32 INS9 INS74 INS59 INS74 INS59 INS32 INS8 INS8 INS7 INS74 INS59 INS74 INS59 INS43 INS59 INS7 INS38 INS8 MOV43 INS59 INS32 INS8 INS8 INS42 INS74 INS59 INS32 INS8 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS32 INS25 INS41 INS42 INS32 INS25 INS41 INS42 INS42 INS42 INS42 INS32 INS25 INS41 INS42 INS42 INS27 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS27 INS27 INS21 INS42 INS42 INS27 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS25 INS21 INS25 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS27 INS32 INS25 INS42 INS32 INS42 INS42 INS25 INS25 INS25 INS43 INS74 INS42 INS32 INS42 INS42 INS60 INS21 INS21 INS32 INS42 INS42 INS32 INS8 INS9 INS32 INS42 INS32 INS8 INS9 INS42 INS42 INS32 INS8 INS9 INS45 INS32 INS45 INS32 INS42 INS32 INS32 INS40 INS32 INS32 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS8 INS8 INS32 INS27 INS8 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS36 INS42 INS42 INS27 INS8 INS42 INS42 INS27 INS8 INS38 INS8 INS8 INS38 INS8 INS8 INS42 INS43 INS43 INS43 INS32 INS42 INS43 INS59 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS21 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS21 INS25 INS25 INS42 INS42 INS42 INS42 INS32 INS40 INS21 INS25 INS42 INS38 INS27 INS32 INS33 INS21 INS32 INS33 INS60 INS21 INS32 MOV21 MOV21 INS60 MOV21 INS21 MOV21 INS21 INS21 INS25 INS21 INS60 INS21 INS21 INS32 INS21 INS60 INS21 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS45 INS32 INS45 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS7 INS38 INS8 INS38 INS8 INS32 INS42 INS7 INS27 INS8 INS32 INS32 INS40 INS32 INS42 INS32 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS74 INS59 INS32 INS32 INS32 MOV32 INS8 INS32 INS43 INS59 INS32 INS32 INS42 INS42 INS32 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS32 INS25 INS41 INS32 INS41 INS42 INS42 INS42 INS9 INS32 INS33 INS25 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS43 INS43 INS42 INS32 UPD42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS21 INS42 INS42 MOV32 INS40 INS45 MOV32 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS45 INS32 INS45 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS8 INS9 INS42 INS42 INS42 INS9 INS32 INS42 INS32 INS8 INS9 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS45 MOV32 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 DEL42 DEL43 DEL42 DEL44 DEL40 DEL45 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL45 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL33 DEL27 DEL43 DEL8 DEL54
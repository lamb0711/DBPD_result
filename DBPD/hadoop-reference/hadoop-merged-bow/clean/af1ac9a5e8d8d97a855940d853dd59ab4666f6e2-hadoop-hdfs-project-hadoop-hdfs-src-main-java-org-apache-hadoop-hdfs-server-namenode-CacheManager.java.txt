HDFS-5119. Persist CacheManager state in the edit log. (Contributed by Andrew Wang)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1529238 13f79535-47bb-0310-9956-ffa450edef68

-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES_DEFAULT;
+import java.io.DataInput;
+import java.io.DataOutput;
-import org.apache.hadoop.hdfs.protocol.CachePoolInfo;
-import org.apache.hadoop.hdfs.protocol.PathBasedCacheDirective;
-import org.apache.hadoop.hdfs.protocol.PathBasedCacheDescriptor;
-import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.UnexpectedAddPathBasedCacheDirectiveException;
+import org.apache.hadoop.hdfs.protocol.CachePoolInfo;
+import org.apache.hadoop.hdfs.protocol.PathBasedCacheDescriptor;
+import org.apache.hadoop.hdfs.protocol.PathBasedCacheDirective;
-import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheDescriptorException.UnexpectedRemovePathBasedCacheDescriptorException;
+import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheDescriptorException.UnexpectedRemovePathBasedCacheDescriptorException;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.Phase;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.StartupProgress;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.StartupProgress.Counter;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.Step;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.StepType;
+import org.apache.hadoop.io.Text;
+
+import com.google.common.base.Preconditions;
-    // TODO: support loading and storing of the CacheManager state
-  synchronized long getNextEntryId() throws IOException {
-    if (nextEntryId == Long.MAX_VALUE) {
-      throw new IOException("no more available IDs");
-    }
+  /**
+   * Returns the next entry ID to be used for a PathBasedCacheEntry
+   */
+  synchronized long getNextEntryId() {
+    Preconditions.checkArgument(nextEntryId != Long.MAX_VALUE);
+  /**
+   * Returns the PathBasedCacheEntry corresponding to a PathBasedCacheEntry.
+   * 
+   * @param directive Lookup directive
+   * @return Corresponding PathBasedCacheEntry, or null if not present.
+   */
-      if (entry.getPool().getName().equals(directive.getPool())) {
+      if (entry.getPool().getPoolName().equals(directive.getPool())) {
+  /**
+   * Add a new PathBasedCacheEntry, skipping any validation checks. Called
+   * directly when reloading CacheManager state from FSImage.
+   * 
+   * @throws IOException if unable to cache the entry
+   */
+  private void unprotectedAddEntry(PathBasedCacheEntry entry)
+      throws IOException {
+    assert namesystem.hasWriteLock();
+    // Add it to the various maps
+    entriesById.put(entry.getEntryId(), entry);
+    String path = entry.getPath();
+    List<PathBasedCacheEntry> entryList = entriesByPath.get(path);
+    if (entryList == null) {
+      entryList = new ArrayList<PathBasedCacheEntry>(1);
+      entriesByPath.put(path, entryList);
+    }
+    entryList.add(entry);
+    // Set the path as cached in the namesystem
+    try {
+      INode node = dir.getINode(entry.getPath());
+      if (node != null && node.isFile()) {
+        INodeFile file = node.asFile();
+        // TODO: adjustable cache replication factor
+        namesystem.setCacheReplicationInt(entry.getPath(),
+            file.getBlockReplication());
+      } else {
+        LOG.warn("Path " + entry.getPath() + " is not a file");
+      }
+    } catch (IOException ioe) {
+      LOG.info("unprotectedAddEntry " + entry +": failed to cache file: " +
+          ioe.getClass().getName() +": " + ioe.getMessage());
+      throw ioe;
+    }
+  }
+
+  /**
+   * Add a new PathBasedCacheDirective if valid, returning a corresponding
+   * PathBasedCacheDescriptor to the user.
+   * 
+   * @param directive Directive describing the cache entry being added
+   * @param pc Permission checker used to validate that the calling user has
+   *          access to the destination cache pool
+   * @return Corresponding PathBasedCacheDescriptor for the new cache entry
+   * @throws IOException if the directive is invalid or was otherwise
+   *           unsuccessful
+   */
-    // Add a new entry with the next available ID.
-    PathBasedCacheEntry entry;
-    try {
-      entry = new PathBasedCacheEntry(getNextEntryId(),
-          directive.getPath(), pool);
-    } catch (IOException ioe) {
-      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);
-    }
-    LOG.info("addDirective " + directive + ": added cache directive "
-        + directive);
-    // First, add it to the various maps
-    entriesById.put(entry.getEntryId(), entry);
-    String path = directive.getPath();
-    List<PathBasedCacheEntry> entryList = entriesByPath.get(path);
-    if (entryList == null) {
-      entryList = new ArrayList<PathBasedCacheEntry>(1);
-      entriesByPath.put(path, entryList);
-    }
-    entryList.add(entry);
+    PathBasedCacheDescriptor d = unprotectedAddDirective(directive);
+    LOG.info("addDirective " + directive + ": added cache directive "
+        + directive);
+    return d;
+  }
-    // Next, set the path as cached in the namesystem
-    try {
-      INode node = dir.getINode(directive.getPath());
-      if (node != null && node.isFile()) {
-        INodeFile file = node.asFile();
-        // TODO: adjustable cache replication factor
-        namesystem.setCacheReplicationInt(directive.getPath(),
-            file.getBlockReplication());
-      } else {
-        LOG.warn("Path " + directive.getPath() + " is not a file");
-      }
-    } catch (IOException ioe) {
-      LOG.info("addDirective " + directive +": failed to cache file: " +
-          ioe.getClass().getName() +": " + ioe.getMessage());
-      throw ioe;
-    }
+  /**
+   * Assigns a new entry ID to a validated PathBasedCacheDirective and adds
+   * it to the CacheManager. Called directly when replaying the edit log.
+   * 
+   * @param directive Directive being added
+   * @return PathBasedCacheDescriptor for the directive
+   * @throws IOException
+   */
+  PathBasedCacheDescriptor unprotectedAddDirective(
+      PathBasedCacheDirective directive) throws IOException {
+    assert namesystem.hasWriteLock();
+    CachePool pool = cachePools.get(directive.getPool());
+    // Add a new entry with the next available ID.
+    PathBasedCacheEntry entry;
+    entry = new PathBasedCacheEntry(getNextEntryId(), directive.getPath(),
+        pool);
+
+    unprotectedAddEntry(entry);
+
+  /**
+   * Remove the PathBasedCacheEntry corresponding to a descriptor ID from
+   * the CacheManager.
+   * 
+   * @param id of the PathBasedCacheDescriptor
+   * @param pc Permissions checker used to validated the request
+   * @throws IOException
+   */
+    unprotectedRemoveDescriptor(id);
+  }
+
+  /**
+   * Unchecked internal method used to remove a PathBasedCacheEntry from the
+   * CacheManager. Called directly when replaying the edit log.
+   * 
+   * @param id of the PathBasedCacheDescriptor corresponding to the entry that
+   *          is being removed
+   * @throws IOException
+   */
+  void unprotectedRemoveDescriptor(long id) throws IOException {
+    assert namesystem.hasWriteLock();
+    PathBasedCacheEntry existing = entriesById.get(id);
-   *
-   * @param info
-   *          The info for the cache pool to create.
+   * 
+   * @param info The info for the cache pool to create.
+   * @return the created CachePool
-  public synchronized void addCachePool(CachePoolInfo info)
+  public synchronized CachePool addCachePool(CachePoolInfo info)
-    cachePools.put(poolName, cachePool);
-    LOG.info("created new cache pool " + cachePool);
+    unprotectedAddCachePool(cachePool);
+    return cachePool;
+  }
+
+  /**
+   * Internal unchecked method used to add a CachePool. Called directly when
+   * reloading CacheManager state from the FSImage or edit log.
+   * 
+   * @param pool to be added
+   */
+  void unprotectedAddCachePool(CachePool pool) {
+    assert namesystem.hasWriteLock();
+    cachePools.put(pool.getPoolName(), pool);
+    LOG.info("created new cache pool " + pool);
+
+  /*
+   * FSImage related serialization and deserialization code
+   */
+
+  /**
+   * Saves the current state of the CacheManager to the DataOutput. Used
+   * to persist CacheManager state in the FSImage.
+   * @param out DataOutput to persist state
+   * @param sdPath path of the storage directory
+   * @throws IOException
+   */
+  public synchronized void saveState(DataOutput out, String sdPath)
+      throws IOException {
+    out.writeLong(nextEntryId);
+    savePools(out, sdPath);
+    saveEntries(out, sdPath);
+  }
+
+  /**
+   * Reloads CacheManager state from the passed DataInput. Used during namenode
+   * startup to restore CacheManager state from an FSImage.
+   * @param in DataInput from which to restore state
+   * @throws IOException
+   */
+  public synchronized void loadState(DataInput in) throws IOException {
+    nextEntryId = in.readLong();
+    // pools need to be loaded first since entries point to their parent pool
+    loadPools(in);
+    loadEntries(in);
+  }
+
+  /**
+   * Save cache pools to fsimage
+   */
+  private synchronized void savePools(DataOutput out,
+      String sdPath) throws IOException {
+    StartupProgress prog = NameNode.getStartupProgress();
+    Step step = new Step(StepType.CACHE_POOLS, sdPath);
+    prog.beginStep(Phase.SAVING_CHECKPOINT, step);
+    prog.setTotal(Phase.SAVING_CHECKPOINT, step, cachePools.size());
+    Counter counter = prog.getCounter(Phase.SAVING_CHECKPOINT, step);
+    out.writeInt(cachePools.size());
+    for (CachePool pool: cachePools.values()) {
+      pool.writeTo(out);
+      counter.increment();
+    }
+    prog.endStep(Phase.SAVING_CHECKPOINT, step);
+  }
+
+  /*
+   * Save cache entries to fsimage
+   */
+  private synchronized void saveEntries(DataOutput out, String sdPath)
+      throws IOException {
+    StartupProgress prog = NameNode.getStartupProgress();
+    Step step = new Step(StepType.CACHE_ENTRIES, sdPath);
+    prog.beginStep(Phase.SAVING_CHECKPOINT, step);
+    prog.setTotal(Phase.SAVING_CHECKPOINT, step, entriesById.size());
+    Counter counter = prog.getCounter(Phase.SAVING_CHECKPOINT, step);
+    out.writeInt(entriesById.size());
+    for (PathBasedCacheEntry entry: entriesById.values()) {
+      out.writeLong(entry.getEntryId());
+      Text.writeString(out, entry.getPath());
+      Text.writeString(out, entry.getPool().getPoolName());
+      counter.increment();
+    }
+    prog.endStep(Phase.SAVING_CHECKPOINT, step);
+  }
+
+  /**
+   * Load cache pools from fsimage
+   */
+  private synchronized void loadPools(DataInput in)
+      throws IOException {
+    StartupProgress prog = NameNode.getStartupProgress();
+    Step step = new Step(StepType.CACHE_POOLS);
+    prog.beginStep(Phase.LOADING_FSIMAGE, step);
+    int numberOfPools = in.readInt();
+    prog.setTotal(Phase.LOADING_FSIMAGE, step, numberOfPools);
+    Counter counter = prog.getCounter(Phase.LOADING_FSIMAGE, step);
+    for (int i = 0; i < numberOfPools; i++) {
+      CachePool pool = CachePool.readFrom(in);
+      unprotectedAddCachePool(pool);
+      counter.increment();
+    }
+    prog.endStep(Phase.LOADING_FSIMAGE, step);
+  }
+
+  /**
+   * Load cache entries from the fsimage
+   */
+  private synchronized void loadEntries(DataInput in) throws IOException {
+    StartupProgress prog = NameNode.getStartupProgress();
+    Step step = new Step(StepType.CACHE_ENTRIES);
+    prog.beginStep(Phase.LOADING_FSIMAGE, step);
+    int numberOfEntries = in.readInt();
+    prog.setTotal(Phase.LOADING_FSIMAGE, step, numberOfEntries);
+    Counter counter = prog.getCounter(Phase.LOADING_FSIMAGE, step);
+    for (int i = 0; i < numberOfEntries; i++) {
+      long entryId = in.readLong();
+      String path = Text.readString(in);
+      String poolName = Text.readString(in);
+      // Get pool reference by looking it up in the map
+      CachePool pool = cachePools.get(poolName);
+      PathBasedCacheEntry entry = new PathBasedCacheEntry(entryId, path, pool);
+      unprotectedAddEntry(entry);
+      counter.increment();
+    }
+    prog.endStep(Phase.LOADING_FSIMAGE, step);
+  }
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 MOV83 MOV39 MOV42 INS8 INS29 INS29 INS83 INS39 INS42 INS44 MOV43 INS8 INS29 INS29 INS43 INS42 INS44 MOV43 MOV8 INS29 INS83 INS83 INS39 INS42 INS44 MOV44 INS43 INS8 INS29 UPD42 INS43 INS29 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS65 INS21 MOV41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS6 MOV21 INS60 MOV60 MOV25 MOV21 MOV54 INS65 INS65 INS65 INS65 INS65 INS60 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS6 INS60 MOV60 INS21 INS41 INS65 INS65 INS65 INS65 INS39 INS42 INS42 MOV25 INS60 MOV25 MOV60 MOV25 MOV25 INS21 INS65 INS65 INS65 INS6 INS65 INS42 INS41 INS65 INS65 INS43 INS42 INS6 INS21 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS21 INS21 INS65 INS65 INS65 INS43 INS42 INS42 INS21 INS21 INS21 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS21 INS21 INS60 INS21 INS70 INS21 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS21 INS21 INS60 INS21 INS70 INS21 INS65 INS43 INS42 INS42 INS60 INS60 INS21 INS60 INS21 INS60 INS24 INS21 INS65 INS43 INS42 INS42 INS60 INS60 INS21 INS60 INS21 INS60 INS24 INS21 INS66 INS32 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS32 MOV43 INS59 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS43 MOV59 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS43 INS59 INS32 MOV32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS32 UPD66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS32 INS32 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS32 INS32 INS32 INS66 INS66 INS42 INS66 INS42 INS42 INS7 INS32 INS32 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS43 INS59 INS32 INS44 INS32 INS8 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS43 INS59 INS32 INS44 INS32 INS8 INS32 INS66 INS42 INS43 INS59 INS43 INS59 INS32 INS39 INS59 INS32 INS43 INS59 INS58 INS27 INS37 INS8 INS32 INS66 INS42 INS43 INS59 INS43 INS59 INS32 INS39 INS59 INS32 INS43 INS59 INS58 INS27 INS37 INS8 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS60 INS21 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS21 INS42 INS42 INS40 INS42 MOV42 MOV40 INS42 INS42 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS34 INS43 INS59 INS32 INS32 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS34 INS39 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 UPD45 UPD42 INS42 INS42 INS42 UPD42 UPD42 DEL27 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL60 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21
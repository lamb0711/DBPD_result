Merge trunk into HA branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1210547 13f79535-47bb-0310-9956-ffa450edef68

+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.apache.hadoop.ipc.RpcPayloadHeader.RpcKind;
+  
+  interface RpcInvoker {   
+    /**
+     * Process a client call on the server side
+     * @param server the server within whose context this rpc call is made
+     * @param protocol - the protocol name (the class of the client proxy
+     *      used to make calls to the rpc server.
+     * @param rpcRequest  - deserialized
+     * @param receiveTime time at which the call received (for metrics)
+     * @return the call's return
+     * @throws IOException
+     **/
+    public Writable call(Server server, String protocol,
+        Writable rpcRequest, long receiveTime) throws IOException ;
+  }
+  
+  /**
+   * Get all superInterfaces that extend VersionedProtocol
+   * @param childInterfaces
+   * @return the super interfaces that extend VersionedProtocol
+   */
+  static Class<?>[] getSuperInterfaces(Class<?>[] childInterfaces) {
+    List<Class<?>> allInterfaces = new ArrayList<Class<?>>();
+
+    for (Class<?> childInterface : childInterfaces) {
+      if (VersionedProtocol.class.isAssignableFrom(childInterface)) {
+          allInterfaces.add(childInterface);
+          allInterfaces.addAll(
+              Arrays.asList(
+                  getSuperInterfaces(childInterface.getInterfaces())));
+      } else {
+        LOG.warn("Interface " + childInterface +
+              " ignored because it does not extend VersionedProtocol");
+      }
+    }
+    return allInterfaces.toArray(new Class[allInterfaces.size()]);
+  }
+  
+  /**
+   * Get all interfaces that the given protocol implements or extends
+   * which are assignable from VersionedProtocol.
+   */
+  static Class<?>[] getProtocolInterfaces(Class<?> protocol) {
+    Class<?>[] interfaces  = protocol.getInterfaces();
+    return getSuperInterfaces(interfaces);
+  }
-    ProtocolInfo anno = (ProtocolInfo) protocol.getAnnotation(ProtocolInfo.class);
+    ProtocolInfo anno = protocol.getAnnotation(ProtocolInfo.class);
+  
+  /**
+   * Get the protocol version from protocol class.
+   * If the protocol class has a ProtocolAnnotation, then get the protocol
+   * name from the annotation; otherwise the class name is the protocol name.
+   */
+  static public long getProtocolVersion(Class<?> protocol) {
+    if (protocol == null) {
+      throw new IllegalArgumentException("Null protocol");
+    }
+    long version;
+    ProtocolInfo anno = protocol.getAnnotation(ProtocolInfo.class);
+    if (anno != null) {
+      version = anno.protocolVersion();
+      if (version != -1)
+        return version;
+    }
+    try {
+      Field versionField = protocol.getField("versionID");
+      versionField.setAccessible(true);
+      return versionField.getLong(protocol);
+    } catch (NoSuchFieldException ex) {
+      throw new RuntimeException(ex);
+    } catch (IllegalAccessException ex) {
+      throw new RuntimeException(ex);
+    }
+  }
+   boolean verbose;
+   static String classNameBase(String className) {
+      String[] names = className.split("\\.", -1);
+      if (names == null || names.length == 0) {
+        return className;
+      }
+      return names[names.length-1];
+    }
+   
+   /**
+    * Store a map of protocol and version to its implementation
+    */
+   /**
+    *  The key in Map
+    */
+   static class ProtoNameVer {
+     final String protocol;
+     final long   version;
+     ProtoNameVer(String protocol, long ver) {
+       this.protocol = protocol;
+       this.version = ver;
+     }
+     @Override
+     public boolean equals(Object o) {
+       if (o == null) 
+         return false;
+       if (this == o) 
+         return true;
+       if (! (o instanceof ProtoNameVer))
+         return false;
+       ProtoNameVer pv = (ProtoNameVer) o;
+       return ((pv.protocol.equals(this.protocol)) && 
+           (pv.version == this.version));     
+     }
+     @Override
+     public int hashCode() {
+       return protocol.hashCode() * 37 + (int) version;    
+     }
+   }
+   
+   /**
+    * The value in map
+    */
+   static class ProtoClassProtoImpl {
+     final Class<?> protocolClass;
+     final Object protocolImpl; 
+     ProtoClassProtoImpl(Class<?> protocolClass, Object protocolImpl) {
+       this.protocolClass = protocolClass;
+       this.protocolImpl = protocolImpl;
+     }
+   }
+
+   ArrayList<Map<ProtoNameVer, ProtoClassProtoImpl>> protocolImplMapArray = 
+       new ArrayList<Map<ProtoNameVer, ProtoClassProtoImpl>>(RpcKind.MAX_INDEX);
+   
+   Map<ProtoNameVer, ProtoClassProtoImpl> getProtocolImplMap(RpcKind rpcKind) {
+     if (protocolImplMapArray.size() == 0) {// initialize for all rpc kinds
+       for (int i=0; i <= RpcKind.MAX_INDEX; ++i) {
+         protocolImplMapArray.add(
+             new HashMap<ProtoNameVer, ProtoClassProtoImpl>(10));
+       }
+     }
+     return protocolImplMapArray.get(rpcKind.ordinal());   
+   }
+   
+   // Register  protocol and its impl for rpc calls
+   void registerProtocolAndImpl(RpcKind rpcKind, Class<?> protocolClass, 
+       Object protocolImpl) throws IOException {
+     String protocolName = RPC.getProtocolName(protocolClass);
+     long version;
+     
+
+     try {
+       version = RPC.getProtocolVersion(protocolClass);
+     } catch (Exception ex) {
+       LOG.warn("Protocol "  + protocolClass + 
+            " NOT registered as cannot get protocol version ");
+       return;
+     }
+
+
+     getProtocolImplMap(rpcKind).put(new ProtoNameVer(protocolName, version),
+         new ProtoClassProtoImpl(protocolClass, protocolImpl)); 
+     LOG.debug("RpcKind = " + rpcKind + " Protocol Name = " + protocolName +  " version=" + version +
+         " ProtocolImpl=" + protocolImpl.getClass().getName() + 
+         " protocolClass=" + protocolClass.getName());
+   }
+   
+   static class VerProtocolImpl {
+     final long version;
+     final ProtoClassProtoImpl protocolTarget;
+     VerProtocolImpl(long ver, ProtoClassProtoImpl protocolTarget) {
+       this.version = ver;
+       this.protocolTarget = protocolTarget;
+     }
+   }
+   
+   
+   @SuppressWarnings("unused") // will be useful later.
+   VerProtocolImpl[] getSupportedProtocolVersions(RpcKind rpcKind,
+       String protocolName) {
+     VerProtocolImpl[] resultk = 
+         new  VerProtocolImpl[getProtocolImplMap(rpcKind).size()];
+     int i = 0;
+     for (Map.Entry<ProtoNameVer, ProtoClassProtoImpl> pv :
+                                       getProtocolImplMap(rpcKind).entrySet()) {
+       if (pv.getKey().protocol.equals(protocolName)) {
+         resultk[i++] = 
+             new VerProtocolImpl(pv.getKey().version, pv.getValue());
+       }
+     }
+     if (i == 0) {
+       return null;
+     }
+     VerProtocolImpl[] result = new VerProtocolImpl[i];
+     System.arraycopy(resultk, 0, result, 0, i);
+     return result;
+   }
+   
+   VerProtocolImpl getHighestSupportedProtocol(RpcKind rpcKind, 
+       String protocolName) {    
+     Long highestVersion = 0L;
+     ProtoClassProtoImpl highest = null;
+ System.out.println("Size of protoMap for " + rpcKind + " =" + getProtocolImplMap(rpcKind).size());
+     for (Map.Entry<ProtoNameVer, ProtoClassProtoImpl> pv : 
+           getProtocolImplMap(rpcKind).entrySet()) {
+       if (pv.getKey().protocol.equals(protocolName)) {
+         if ((highest == null) || (pv.getKey().version > highestVersion)) {
+           highest = pv.getValue();
+           highestVersion = pv.getKey().version;
+         } 
+       }
+     }
+     if (highest == null) {
+       return null;
+     }
+     return new VerProtocolImpl(highestVersion,  highest);   
+   }
-    public <PROTO, IMPL extends PROTO>
-      Server addProtocol(Class<PROTO> protocolClass, IMPL protocolImpl
-    ) throws IOException {
-      throw new IOException("addProtocol Not Implemented");
+    public Server addProtocol(RpcKind rpcKind, Class<?> protocolClass,
+        Object protocolImpl) throws IOException {
+      registerProtocolAndImpl(rpcKind, protocolClass, protocolImpl);
+      return this;
+    }
+    
+    @Override
+    public Writable call(RpcKind rpcKind, String protocol,
+        Writable rpcRequest, long receiveTime) throws IOException {
+      return getRpcInvoker(rpcKind).call(this, protocol, rpcRequest,
+          receiveTime);
-

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS55 INS31 INS31 INS31 INS42 INS31 INS29 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS23 INS31 INS55 INS55 INS23 INS31 INS31 INS55 INS31 INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS65 INS65 INS65 INS74 INS85 INS5 INS42 INS60 INS70 INS41 INS65 INS74 INS85 INS74 INS42 INS60 INS41 INS65 INS74 INS42 INS25 INS60 INS60 INS25 INS54 INS39 INS59 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS42 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS42 INS23 INS23 INS31 INS74 INS59 INS74 INS42 INS44 INS8 INS39 INS42 INS44 INS44 INS44 MOV43 INS8 INS83 INS42 INS23 INS23 INS31 INS79 INS5 INS42 INS44 INS44 INS8 INS43 INS42 INS44 INS44 INS8 MOV29 INS83 MOV43 INS42 INS44 INS44 INS44 MOV43 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS66 INS42 INS66 INS43 INS76 INS74 INS85 INS74 INS59 INS44 INS42 INS8 INS32 INS66 INS66 INS43 INS76 INS43 INS76 INS5 INS59 INS32 MOV43 INS66 INS66 INS66 INS43 INS76 INS27 INS8 INS39 INS59 MOV43 INS59 INS27 INS8 INS8 INS12 INS12 INS42 INS42 INS43 INS42 INS60 INS25 INS41 INS65 INS83 INS43 INS59 INS83 INS39 INS59 INS42 INS44 INS44 INS8 INS78 MOV83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS65 INS83 UPD74 MOV74 INS59 INS83 INS43 INS59 INS42 MOV44 MOV44 INS8 INS43 INS74 INS42 INS14 INS43 INS43 INS43 INS43 INS42 INS25 INS41 INS43 INS42 INS74 INS42 INS43 INS42 INS60 INS60 INS54 INS21 INS21 INS83 INS39 INS59 INS83 INS43 INS59 INS42 INS44 INS44 INS8 INS42 INS45 INS43 INS85 INS43 INS42 INS43 INS42 INS60 INS60 INS70 INS25 INS60 INS21 INS41 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS21 INS70 INS25 INS41 INS43 INS42 INS74 INS42 INS43 INS42 INS21 INS41 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS41 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS43 INS76 INS43 INS74 INS42 INS14 INS74 INS42 INS25 INS42 INS42 INS3 INS42 INS42 INS74 INS85 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS33 INS53 INS42 INS42 INS32 INS42 INS33 INS21 INS25 INS60 INS21 INS41 INS44 INS8 INS44 INS8 INS42 INS5 INS59 INS27 INS8 INS2 INS66 INS42 INS42 INS42 INS43 INS42 INS39 INS42 INS21 INS21 INS42 INS43 INS42 INS25 INS25 INS25 INS60 INS41 INS42 INS41 INS66 INS76 INS42 INS42 INS42 INS74 UPD43 INS21 INS21 INS42 INS43 INS43 INS43 INS74 INS40 INS42 INS42 INS42 INS42 INS27 INS8 INS32 INS42 INS43 INS76 INS42 INS43 INS59 INS39 INS59 INS8 INS12 INS32 INS32 INS42 INS42 INS42 INS39 INS42 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS5 INS59 INS39 INS59 INS44 INS32 INS8 INS27 INS8 INS5 INS59 INS32 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS44 INS32 INS8 INS27 INS8 INS14 INS42 INS43 INS76 INS42 INS32 INS52 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS76 INS74 INS43 INS76 INS32 INS8 INS8 INS5 INS32 INS43 INS76 INS42 INS42 INS14 INS42 INS42 INS57 INS7 INS27 INS41 INS43 INS59 INS32 INS32 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS85 INS42 INS32 INS27 INS27 INS41 INS42 INS27 INS42 INS7 INS7 INS42 INS27 INS41 INS27 INS41 INS38 INS41 INS43 INS59 INS36 INS27 INS43 INS76 UPD42 INS7 INS7 INS42 INS42 INS42 INS43 INS74 INS32 INS34 INS24 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS21 INS44 INS8 INS32 INS42 INS14 INS14 INS42 INS42 INS27 INS42 INS7 INS7 INS43 INS85 INS42 INS3 INS42 INS34 INS74 INS42 INS32 INS42 INS25 INS42 INS34 INS41 INS43 INS85 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS34 INS42 INS42 INS33 INS40 INS42 INS27 INS74 INS42 INS32 INS42 INS25 INS42 INS33 INS41 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS42 INS43 INS74 INS42 INS57 INS42 INS42 INS21 INS21 INS21 INS43 INS85 INS42 INS42 INS42 INS43 INS45 INS43 INS42 INS32 INS42 INS38 INS42 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS45 INS38 INS42 INS33 INS40 INS34 INS42 INS40 INS34 INS22 INS42 INS22 INS42 INS42 INS33 INS9 INS52 INS42 INS9 INS36 INS9 INS42 INS42 INS11 INS27 INS27 INS11 INS42 INS22 INS42 INS22 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS58 INS27 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS42 INS21 INS41 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS22 INS42 INS22 INS42 INS42 INS5 INS32 INS43 INS43 INS43 INS42 INS42 INS32 INS8 INS33 INS42 INS5 INS42 INS45 INS42 INS45 INS32 INS43 INS43 INS43 INS42 INS42 INS32 INS8 INS33 INS42 INS42 INS42 INS42 INS43 INS76 INS43 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS45 INS43 INS42 INS43 INS42 INS34 INS52 INS42 INS52 INS42 INS62 INS43 INS42 INS36 INS36 INS32 INS34 INS39 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS43 INS85 INS32 INS42 INS40 INS42 INS42 INS22 INS42 INS42 INS21 INS43 INS85 INS32 INS42 INS40 INS42 INS42 INS22 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 UPD42 MOV42 INS32 INS27 INS42 INS42 INS42 INS34 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS7 INS42 INS42 INS42 INS32 INS42 INS27 INS8 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS40 INS42 INS22 INS40 INS22 INS42 INS42 INS14 INS45 INS42 INS45 INS42 INS42 INS2 INS14 INS42 INS42 INS36 INS36 INS21 INS21 INS42 INS32 INS52 INS42 INS52 INS42 INS74 INS34 INS42 INS37 INS43 INS22 INS32 INS27 INS27 INS7 INS7 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS33 INS22 INS42 INS42 INS32 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 DEL11 DEL42 DEL43 DEL42 DEL73 DEL42 DEL43 DEL73 DEL42 DEL45 DEL14 DEL53 DEL8 DEL31
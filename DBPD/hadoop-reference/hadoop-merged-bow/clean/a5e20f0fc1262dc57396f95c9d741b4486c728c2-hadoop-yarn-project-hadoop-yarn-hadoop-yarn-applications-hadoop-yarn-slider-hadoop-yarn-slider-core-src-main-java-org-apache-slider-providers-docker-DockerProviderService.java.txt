YARN-5993. Allow native services quicklinks to be exported for each component. Contributed by Billie Rinaldi

-import org.apache.slider.server.appmaster.state.StateAccessForProviders;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
-import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
-import static org.apache.slider.api.RoleKeys.ROLE_PREFIX;
-
+  private static final String HOST_KEY_FORMAT = "${%s_HOST}";
+  private static final String IP_KEY_FORMAT = "${%s_IP}";
+  private static final String VARIABLE_INDICATOR = "${";
+  private final Map<String, Set<ExportEntry>> exportMap =
+      new ConcurrentHashMap<>();
+
-    initializeApplicationConfiguration(instanceDefinition, fileSystem,
-        roleGroup);
-
+  public void notifyContainerCompleted(ContainerId containerId) {
+    if (containerId != null) {
+      String containerIdStr = containerId.toString();
+      log.info("Removing container exports for {}", containerIdStr);
+      for (Set<ExportEntry> exportEntries : exportMap.values()) {
+        for (Iterator<ExportEntry> iter = exportEntries.iterator();
+            iter.hasNext();) {
+          ExportEntry entry = iter.next();
+          if (containerIdStr.equals(entry.getContainerId())) {
+            iter.remove();
+          }
+        }
+      }
+    }
+  }
+
+  @Override
-        status.getHost());
+        status.getHost(), status.getIPs());
-      String roleName, String roleGroup, String thisHost) {
+      String roleName, String roleGroup, String thisHost, List<String> ips) {
-    String hostKeyFormat = "${%s_HOST}";
-    String hostNameKeyFormat = "${%s_HOSTNAME}";
-    String ipKeyFormat = "${%s_IP}";
-
-    String rolePrefix = appConf.getComponentOpt(roleGroup, ROLE_PREFIX, "");
-    for (Map.Entry<String, Map<String, ClusterNode>> entry :
-        getAmState().getRoleClusterNodeMapping().entrySet()) {
-      String otherRolePrefix = appConf.getComponentOpt(entry.getKey(),
-          ROLE_PREFIX, "");
-      if (!otherRolePrefix.equals(rolePrefix)) {
-        // hostname replacements are only made within role prefix groups
-        continue;
+    String roleNameKey = providerUtils.getNameKey(roleName, roleGroup,
+        appConf);
+    String roleNameIPKey = null;
+    if (roleNameKey != null) {
+      replaceTokens.put(String.format(HOST_KEY_FORMAT, roleNameKey), thisHost);
+      roleNameIPKey = Pattern.quote(String.format(IP_KEY_FORMAT, roleNameKey));
+    } else {
+      // should not happen, but log if it does
+      log.info("Not replacing HOST or IP tokens because key was null for {}",
+          roleName);
+    }
+    String roleGroupKey = providerUtils.getGroupKey(roleGroup, appConf);
+    String roleGroupIPKey = null;
+    if (roleGroupKey != null) {
+      if (roleNameKey == null || !roleGroupKey.equals(roleNameKey)) {
+        replaceTokens.put(String.format(HOST_KEY_FORMAT, roleGroupKey),
+            thisHost);
+        roleGroupIPKey = Pattern.quote(String.format(IP_KEY_FORMAT,
+            roleGroupKey));
-      String key = entry.getKey();
-      if (!rolePrefix.isEmpty()) {
-        if (!key.startsWith(rolePrefix)) {
-          log.warn("Something went wrong, {} doesn't start with {}", key,
-              rolePrefix);
-          continue;
-        }
-        key = key.substring(rolePrefix.length());
-      }
-      key = key.toUpperCase(Locale.ENGLISH);
-      String host = providerUtils.getHostsList(
-          entry.getValue().values(), true).iterator().next();
-      replaceTokens.put(String.format(hostKeyFormat, key), host);
-      String hostName = providerUtils.getHostNamesList(
-          entry.getValue().values()).iterator().next();
-      replaceTokens.put(String.format(hostNameKeyFormat, key), hostName);
-      String ip = providerUtils.getIPsList(
-          entry.getValue().values()).iterator().next();
-      replaceTokens.put(String.format(ipKeyFormat, key), ip);
+    } else {
+      // should not happen, but log if it does
+      log.info("Not replacing HOST or IP tokens because key was null for {}",
+          roleGroup);
-    Map<String, List<ExportEntry>> entries = new HashMap<>();
-      ExportEntry entry = new ExportEntry();
-      entry.setLevel(APPLICATION_TAG);
-      entry.setValue(value);
-      entry.setUpdatedTime(new Date().toString());
-      // over-write, app exports are singletons
-      entries.put(export.getKey(), new ArrayList(Arrays.asList(entry)));
-      log.info("Preparing to publish. Key {} and Value {}",
-          export.getKey(), value);
+      Set<String> values = new HashSet<>();
+      for (String ip : ips) {
+        values.add(substituteIP(roleNameIPKey, roleGroupIPKey, ip, value));
+      }
+      for (String exportValue : values) {
+        if (exportValue.contains(VARIABLE_INDICATOR)) {
+          // not all variables have been substituted, so do not export
+          continue;
+        }
+        ExportEntry entry = new ExportEntry();
+        entry.setContainerId(containerId);
+        entry.setLevel(APPLICATION_TAG);
+        entry.setValue(exportValue);
+        entry.setUpdatedTime(new Date().toString());
+        Set<ExportEntry> exportEntries = getExportEntries(export.getKey());
+        exportEntries.add(entry);
+        log.info("Preparing to publish for {}. Key {} and Value {}",
+            roleName, export.getKey(), entry);
+      }
-    if (!entries.isEmpty()) {
-      providerUtils.publishExportGroup(entries, getAmState(), EXPORT_GROUP);
+    if (!exportMap.isEmpty()) {
+      providerUtils.publishExportGroup(exportMap, getAmState(), EXPORT_GROUP);
+  protected String substituteIP(String roleNameIPKey, String roleGroupIPKey,
+      String ip, String value) {
+    if (roleNameIPKey != null) {
+      value = value.replaceAll(roleNameIPKey, ip);
+    }
+    if (roleGroupIPKey != null) {
+      value = value.replaceAll(roleGroupIPKey, ip);
+    }
+    return value;
+  }
+
+  protected Set<ExportEntry> getExportEntries(String key) {
+    if (!this.exportMap.containsKey(key)) {
+      synchronized (this.exportMap) {
+        if (!this.exportMap.containsKey(key)) {
+          this.exportMap.put(key, Collections.newSetFromMap(
+              new ConcurrentHashMap<>()));
+        }
+      }
+    }
+
+    return this.exportMap.get(key);
+  }
+

MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS74 INS59 INS78 INS83 INS39 INS42 INS44 INS8 INS44 INS83 MOV43 INS42 INS44 INS44 INS44 INS44 INS8 INS83 INS74 INS42 INS44 INS8 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 MOV43 INS43 INS74 INS42 INS14 INS42 INS43 INS42 INS25 UPD74 MOV74 INS42 MOV60 INS25 MOV60 INS60 INS25 MOV43 INS42 MOV43 INS42 MOV43 INS42 INS43 INS42 INS25 INS25 INS41 INS43 INS43 INS43 INS42 INS25 INS41 INS42 INS43 INS43 INS74 INS42 INS27 INS8 MOV43 MOV43 MOV43 INS27 MOV8 INS8 MOV43 MOV43 INS59 INS27 INS8 INS8 INS42 INS27 INS8 INS27 INS8 INS42 INS42 INS42 INS42 INS38 INS8 INS32 INS42 INS42 INS43 INS42 INS33 INS60 INS21 INS70 INS32 UPD42 INS42 INS33 INS42 INS33 INS21 MOV21 UPD42 INS32 INS42 INS33 INS42 INS33 INS25 INS21 INS60 INS70 INS70 INS42 INS33 INS21 INS42 INS33 INS21 INS32 INS51 INS22 INS42 INS42 INS42 INS43 INS59 INS32 INS44 INS32 INS8 INS42 INS42 UPD42 UPD42 INS42 UPD42 INS32 INS32 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS8 INS32 INS74 INS59 INS44 INS42 INS8 INS44 INS42 INS8 UPD42 INS7 INS7 INS22 INS42 INS42 INS22 INS8 INS52 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS74 INS42 INS42 INS42 INS24 UPD42 MOV42 UPD42 MOV42 INS32 INS42 UPD42 INS42 UPD42 MOV42 INS45 UPD42 MOV42 INS27 INS38 MOV21 INS21 INS42 INS42 INS45 INS42 INS43 MOV43 INS42 INS14 MOV43 INS42 INS21 MOV43 INS42 INS25 MOV60 MOV21 MOV21 INS21 MOV21 INS60 INS21 MOV21 UPD42 INS42 INS32 INS42 INS32 INS52 INS42 INS52 INS42 INS25 INS42 INS42 INS43 INS43 INS58 INS32 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS33 INS32 INS7 INS42 INS74 INS32 INS32 MOV8 INS32 INS74 INS59 INS32 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS8 INS42 INS42 INS74 INS59 INS42 INS42 INS60 INS25 UPD42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS32 INS43 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS43 MOV43 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 UPD45 UPD42 INS42 INS32 INS21 INS43 INS43 INS42 INS32 INS43 INS59 INS32 INS8 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV32 INS22 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS21 UPD42 UPD42 INS52 INS42 INS22 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS42 INS42 INS14 INS42 INS42 INS74 INS43 INS42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL45 DEL59 DEL60 DEL42 DEL45 DEL59 DEL60 DEL42 DEL45 DEL59 DEL60 DEL45 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL32 DEL38 DEL45 DEL32 DEL21 DEL18 DEL8 DEL25 DEL42 DEL40 DEL32 DEL7 DEL42 DEL42 DEL32 DEL32 DEL9 DEL32 DEL32 DEL42 DEL32 DEL40 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL38 DEL25 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL43 DEL32 DEL14 DEL32 DEL21
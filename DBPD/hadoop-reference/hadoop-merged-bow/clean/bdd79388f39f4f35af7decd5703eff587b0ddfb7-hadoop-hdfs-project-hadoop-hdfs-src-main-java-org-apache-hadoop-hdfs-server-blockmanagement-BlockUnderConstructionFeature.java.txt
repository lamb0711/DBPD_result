HDFS-8928. Improvements for BlockUnderConstructionFeature: ReplicaUnderConstruction as a separate class and replicas as an array. Contributed by Jing Zhao.

-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.apache.hadoop.hdfs.server.common.HdfsServerConstants.BlockUCState.COMPLETE;
+
- * Represents a block that is currently being constructed.<br>
+ * Represents the under construction feature of a Block.
-  /** Block state. See {@link BlockUCState} */
-   * This defines the pipeline order.
-  private List<ReplicaUnderConstruction> replicas;
+  private ReplicaUnderConstruction[] replicas;
-  /**
-   * ReplicaUnderConstruction contains information about replicas while
-   * they are under construction.
-   * The GS, the length and the state of the replica is as reported by
-   * the data-node.
-   * It is not guaranteed, but expected, that data-nodes actually have
-   * corresponding replicas.
-   */
-  static class ReplicaUnderConstruction {
-    private long generationStamp;
-    private final DatanodeStorageInfo expectedLocation;
-    private ReplicaState state;
-    private boolean chosenAsPrimary;
-
-    ReplicaUnderConstruction(long generationStamp, DatanodeStorageInfo target,
-        ReplicaState state) {
-      this.generationStamp = generationStamp;
-      this.expectedLocation = target;
-      this.state = state;
-      this.chosenAsPrimary = false;
-    }
-
-    long getGenerationStamp() {
-      return this.generationStamp;
-    }
-
-    void setGenerationStamp(long generationStamp) {
-      this.generationStamp = generationStamp;
-    }
-
-    /**
-     * Expected block replica location as assigned when the block was allocated.
-     * This defines the pipeline order.
-     * It is not guaranteed, but expected, that the data-node actually has
-     * the replica.
-     */
-    DatanodeStorageInfo getExpectedStorageLocation() {
-      return expectedLocation;
-    }
-
-    /**
-     * Get replica state as reported by the data-node.
-     */
-    ReplicaState getState() {
-      return state;
-    }
-
-    /**
-     * Whether the replica was chosen for recovery.
-     */
-    boolean getChosenAsPrimary() {
-      return chosenAsPrimary;
-    }
-
-    /**
-     * Set replica state.
-     */
-    void setState(ReplicaState s) {
-      state = s;
-    }
-
-    /**
-     * Set whether this replica was chosen for recovery.
-     */
-    void setChosenAsPrimary(boolean chosenAsPrimary) {
-      this.chosenAsPrimary = chosenAsPrimary;
-    }
-
-    /**
-     * Is data-node the replica belongs to alive.
-     */
-    boolean isAlive() {
-      return expectedLocation.getDatanodeDescriptor().isAlive;
-    }
-
-    @Override
-    public String toString() {
-      final StringBuilder b = new StringBuilder(50)
-          .append("ReplicaUC[")
-          .append(expectedLocation)
-          .append("|")
-          .append(state)
-          .append("]");
-      return b.toString();
-    }
-  }
-
-  /**
-   * Create a block that is currently being constructed.
-   */
-  public BlockUnderConstructionFeature(Block block, BlockUCState state,
-      DatanodeStorageInfo[] targets) {
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "BlockUnderConstructionFeature cannot be in COMPLETE state";
+  public BlockUnderConstructionFeature(Block blk,
+      BlockUCState state, DatanodeStorageInfo[] targets) {
+    assert getBlockUCState() != COMPLETE :
+        "BlockUnderConstructionFeature cannot be in COMPLETE state";
-    setExpectedLocations(block.getGenerationStamp(), targets);
+    setExpectedLocations(blk, targets);
-  public void setExpectedLocations(long generationStamp,
-      DatanodeStorageInfo[] targets) {
+  public void setExpectedLocations(Block block, DatanodeStorageInfo[] targets) {
-    this.replicas = new ArrayList<>(numLocations);
+    this.replicas = new ReplicaUnderConstruction[numLocations];
-      replicas.add(new ReplicaUnderConstruction(generationStamp, targets[i],
-          ReplicaState.RBW));
+      replicas[i] = new ReplicaUnderConstruction(block, targets[i],
+          ReplicaState.RBW);
-    int numLocations = replicas == null ? 0 : replicas.size();
+    int numLocations = getNumExpectedLocations();
-      storages[i] = replicas.get(i).getExpectedStorageLocation();
+      storages[i] = replicas[i].getExpectedStorageLocation();
-    return replicas == null ? 0 : replicas.size();
+    return replicas == null ? 0 : replicas.length;
-  /** Get block recovery ID */
-  public void initializeBlockRecovery(BlockInfo block, long recoveryId) {
+  public void initializeBlockRecovery(BlockInfo blockInfo, long recoveryId) {
-    if (replicas.size() == 0) {
-      NameNode.blockStateChangeLog.warn("BLOCK*"
-        + " BlockUnderConstructionFeature.initLeaseRecovery:"
-        + " No blocks found, lease removed.");
+    if (replicas == null || replicas.length == 0) {
+      NameNode.blockStateChangeLog.warn("BLOCK*" +
+          " BlockUnderConstructionFeature.initializeBlockRecovery:" +
+          " No blocks found, lease removed.");
+      // sets primary node index and return.
+      primaryNodeIndex = -1;
+      return;
-    for(int i = 0; i < replicas.size(); i++) {
+    for (int i = 0; i < replicas.length; i++) {
-      if (!(replicas.get(i).isAlive() && !replicas.get(i).getChosenAsPrimary())) {
+      if (!(replicas[i].isAlive() && !replicas[i].getChosenAsPrimary())) {
-      final ReplicaUnderConstruction ruc = replicas.get(i);
+      final ReplicaUnderConstruction ruc = replicas[i];
-          .addBlockToBeRecovered(block);
+          .addBlockToBeRecovered(blockInfo);
-  void addReplicaIfNotPresent(DatanodeStorageInfo storage, Block block,
-      ReplicaState rState) {
-    Iterator<ReplicaUnderConstruction> it = replicas.iterator();
-    while (it.hasNext()) {
-      ReplicaUnderConstruction r = it.next();
-      DatanodeStorageInfo expectedLocation = r.getExpectedStorageLocation();
-      if (expectedLocation == storage) {
-        // Record the gen stamp from the report
-        r.setGenerationStamp(block.getGenerationStamp());
-        return;
-      } else if (expectedLocation != null &&
-                 expectedLocation.getDatanodeDescriptor() ==
-                     storage.getDatanodeDescriptor()) {
-        // The Datanode reported that the block is on a different storage
-        // than the one chosen by BlockPlacementPolicy. This can occur as
-        // we allow Datanodes to choose the target storage. Update our
-        // state by removing the stale entry and adding a new one.
-        it.remove();
-        break;
+  /** Add the reported replica if it is not already in the replica list. */
+  void addReplicaIfNotPresent(DatanodeStorageInfo storage,
+      Block reportedBlock, ReplicaState rState) {
+    if (replicas == null) {
+      replicas = new ReplicaUnderConstruction[1];
+      replicas[0] = new ReplicaUnderConstruction(reportedBlock, storage,
+          rState);
+    } else {
+      for (int i = 0; i < replicas.length; i++) {
+        DatanodeStorageInfo expected =
+            replicas[i].getExpectedStorageLocation();
+        if (expected == storage) {
+          replicas[i].setGenerationStamp(reportedBlock.getGenerationStamp());
+          return;
+        } else if (expected != null && expected.getDatanodeDescriptor() ==
+            storage.getDatanodeDescriptor()) {
+          // The Datanode reported that the block is on a different storage
+          // than the one chosen by BlockPlacementPolicy. This can occur as
+          // we allow Datanodes to choose the target storage. Update our
+          // state by removing the stale entry and adding a new one.
+          replicas[i] = new ReplicaUnderConstruction(reportedBlock, storage,
+              rState);
+          return;
+        }
+      ReplicaUnderConstruction[] newReplicas =
+          new ReplicaUnderConstruction[replicas.length + 1];
+      System.arraycopy(replicas, 0, newReplicas, 0, replicas.length);
+      newReplicas[newReplicas.length - 1] = new ReplicaUnderConstruction(
+          reportedBlock, storage, rState);
+      replicas = newReplicas;
-    replicas.add(new ReplicaUnderConstruction(block.getGenerationStamp(), storage, rState));
-      Iterator<ReplicaUnderConstruction> iter = replicas.iterator();
-      if (iter.hasNext()) {
-        sb.append(iter.next());
-        while (iter.hasNext()) {
+      int i = 0;
+      for (ReplicaUnderConstruction r : replicas) {
+        r.appendStringTo(sb);
+        if (++i < replicas.length) {
-          sb.append(iter.next());

MOV26 MOV26 MOV26 UPD40 INS5 INS44 MOV44 INS29 UPD66 MOV43 INS85 INS43 INS42 UPD42 INS65 UPD42 INS25 INS42 INS27 INS66 MOV27 INS8 INS8 INS42 UPD42 MOV42 INS3 INS32 INS27 INS40 MOV27 INS27 INS21 INS41 INS40 INS21 INS21 INS24 INS60 INS21 INS21 INS21 INS70 INS5 INS42 INS7 UPD42 MOV42 INS42 INS33 INS40 MOV34 INS7 INS7 INS7 INS58 INS27 INS37 INS8 INS5 INS59 INS32 INS7 INS7 INS39 INS44 INS42 INS8 INS43 INS85 INS2 MOV14 INS42 INS38 INS2 UPD42 INS42 INS3 INS2 INS14 INS39 INS59 INS42 INS40 INS42 MOV60 MOV25 INS43 INS85 INS42 INS3 UPD42 MOV42 UPD42 MOV42 INS42 INS34 INS42 INS34 INS40 INS2 INS14 INS42 INS42 UPD42 INS34 MOV43 INS42 MOV21 INS25 UPD42 MOV42 INS42 INS42 UPD42 INS2 UPD45 INS34 INS42 INS42 INS5 INS34 INS42 INS34 MOV43 INS42 INS42 INS42 UPD42 MOV42 INS34 INS42 INS5 INS27 INS42 INS27 MOV43 INS42 MOV42 MOV42 INS27 MOV8 INS42 INS42 INS43 INS85 UPD42 UPD42 INS43 INS85 INS40 INS34 INS40 INS34 UPD42 UPD42 UPD42 MOV42 INS38 INS40 INS2 UPD42 MOV42 INS2 INS41 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS2 UPD42 INS7 INS42 INS42 INS42 INS42 UPD42 UPD42 INS2 INS14 INS42 INS42 MOV43 INS42 INS42 INS42 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL66 DEL42 DEL43 DEL74 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL31 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL34 DEL14 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL55 DEL66 DEL65 DEL29 DEL40 DEL42 DEL32 DEL39 DEL42 DEL44 DEL43 DEL74 DEL42 DEL14 DEL42 DEL42 DEL32 DEL34 DEL42 DEL32 DEL16 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL66 DEL65 DEL29 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL10 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL42 DEL42 DEL32 DEL14 DEL32 DEL21 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL61 DEL8 DEL25
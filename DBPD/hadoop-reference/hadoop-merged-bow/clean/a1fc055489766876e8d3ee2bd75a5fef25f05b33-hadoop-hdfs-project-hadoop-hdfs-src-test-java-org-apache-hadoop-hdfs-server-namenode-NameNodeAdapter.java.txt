HDFS-1623. High Availability Framework for HDFS NN. Contributed by Todd Lipcon, Aaron T. Myers, Eli Collins, Uma Maheswara Rao G, Bikas Saha, Suresh Srinivas, Jitendra Nath Pandey, Hari Mankude, Brandon Li, Sanjay Radia, Mingjie Lai, and Gregory Chanan


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296534 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.File;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import org.apache.hadoop.fs.UnresolvedLinkException;
+import org.apache.hadoop.fs.permission.PermissionStatus;
+import org.apache.hadoop.hdfs.protocol.HdfsFileStatus;
-import org.apache.hadoop.hdfs.server.protocol.DatanodeCommand;
+import org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory;
+import org.apache.hadoop.hdfs.server.namenode.FSEditLogOp.MkdirOp;
+import org.apache.hadoop.hdfs.server.namenode.LeaseManager.Lease;
+import org.apache.hadoop.hdfs.server.protocol.HeartbeatResponse;
+import org.apache.hadoop.ipc.StandbyException;
+import org.apache.hadoop.security.AccessControlException;
+import org.mockito.Mockito;
+  public static HdfsFileStatus getFileInfo(NameNode namenode, String src,
+      boolean resolveLink) throws AccessControlException, UnresolvedLinkException,
+        StandbyException {
+    return namenode.getNamesystem().getFileInfo(src, resolveLink);
+  }
+  
+  public static boolean mkdirs(NameNode namenode, String src,
+      PermissionStatus permissions, boolean createParent)
+      throws UnresolvedLinkException, IOException {
+    return namenode.getNamesystem().mkdirs(src, permissions, createParent);
+  }
+  
+  public static void saveNamespace(NameNode namenode)
+      throws AccessControlException, IOException {
+    namenode.getNamesystem().saveNamespace();
+  }
+  
+  public static void enterSafeMode(NameNode namenode, boolean resourcesLow)
+      throws IOException {
+    namenode.getNamesystem().enterSafeMode(resourcesLow);
+  }
+  
+  public static void leaveSafeMode(NameNode namenode, boolean checkForUpgrades)
+      throws SafeModeException {
+    namenode.getNamesystem().leaveSafeMode(checkForUpgrades);
+  }
+  
+  public static void abortEditLogs(NameNode nn) {
+    FSEditLog el = nn.getFSImage().getEditLog();
+    el.abortCurrentLogSegment();
+  }
+  
-  public static DatanodeCommand[] sendHeartBeat(DatanodeRegistration nodeReg,
+  public static HeartbeatResponse sendHeartBeat(DatanodeRegistration nodeReg,
-    namesystem.lmthread.interrupt();
+    namesystem.leaseManager.triggerMonitorCheckNow();
+   * @return the timestamp of the last renewal of the given lease,
+   *   or -1 in the case that the lease doesn't exist.
+   */
+  public static long getLeaseRenewalTime(NameNode nn, String path) {
+    LeaseManager lm = nn.getNamesystem().leaseManager;
+    Lease l = lm.getLeaseByPath(path);
+    if (l == null) {
+      return -1;
+    }
+    return l.getLastUpdate();
+  }
+
+  /**
+   * Return the FSNamesystem stats
+   */
+  public static long[] getStats(final FSNamesystem fsn) {
+    return fsn.getStats();
+  }
+  
+  public static ReentrantReadWriteLock spyOnFsLock(FSNamesystem fsn) {
+    ReentrantReadWriteLock spy = Mockito.spy(fsn.getFsLockForTests());
+    fsn.setFsLockForTests(spy);
+    return spy;
+  }
+
+  public static FSImage spyOnFsImage(NameNode nn1) {
+    FSImage spy = Mockito.spy(nn1.getNamesystem().dir.fsImage);
+    nn1.getNamesystem().dir.fsImage = spy;
+    return spy;
+  }
+  
+  public static String getMkdirOpPath(FSEditLogOp op) {
+    if (op.opCode == FSEditLogOpCodes.OP_MKDIR) {
+      return ((MkdirOp) op).path;
+    } else {
+      return null;
+    }
+  }
+  
+  /**
+  
+  public static File getInProgressEditsFile(StorageDirectory sd, long startTxId) {
+    return NNStorage.getInProgressEditsFile(sd, startTxId);
+  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS43 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS42 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS41 INS43 INS42 INS42 INS42 INS21 INS43 INS42 INS39 INS42 INS42 INS21 INS43 INS42 INS39 INS42 INS42 INS21 INS43 INS42 INS60 INS21 UPD42 MOV42 INS65 INS43 INS42 INS43 INS42 INS60 INS60 INS25 INS41 INS65 INS39 INS85 INS83 INS43 INS42 INS41 INS42 INS43 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS25 INS42 INS43 INS42 INS39 INS42 INS41 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS43 INS59 INS32 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS32 INS66 INS42 INS32 INS42 INS43 INS59 INS32 INS42 INS42 INS43 INS59 INS7 INS42 INS42 INS27 INS8 INS8 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 UPD40 UPD42 INS42 INS42 INS22 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS22 INS42 INS40 INS40 INS41 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS38 INS42 INS42 INS32 INS42 INS42 INS22 INS22 INS42 INS22 INS33 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS22 INS42 INS32 INS42 INS36 INS42 INS32 INS42 INS42 INS42 INS11 INS42 INS42 INS43 INS42 INS42 DEL43 DEL85 DEL5
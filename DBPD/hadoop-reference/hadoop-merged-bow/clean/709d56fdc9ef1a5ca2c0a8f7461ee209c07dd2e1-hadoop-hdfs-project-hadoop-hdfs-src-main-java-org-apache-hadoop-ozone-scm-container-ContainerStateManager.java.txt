HDFS-12474. Ozone: SCM: Handling container report with key count and container usage. Contributed by Nanda kumar.

-import org.apache.hadoop.scm.container.common.helpers.BlockContainerInfo;
+import java.io.Closeable;
-import static org.apache.hadoop.ozone.scm.exceptions.SCMException.ResultCodes.FAILED_TO_CHANGE_CONTAINER_STATE;
+import static org.apache.hadoop.ozone.scm.exceptions
+    .SCMException.ResultCodes.FAILED_TO_CHANGE_CONTAINER_STATE;
-public class ContainerStateManager {
+public class ContainerStateManager implements Closeable {
-  private final Queue<BlockContainerInfo> containerCloseQueue;
-  private Map<ContainerKey, PriorityQueue<BlockContainerInfo>> containers;
+  private final Queue<ContainerInfo> containerCloseQueue;
+  private Map<ContainerKey, PriorityQueue<ContainerInfo>> containers;
-    containerCloseQueue = new ConcurrentLinkedQueue<BlockContainerInfo>();
+    containerCloseQueue = new ConcurrentLinkedQueue<>();
-            PriorityQueue<BlockContainerInfo> queue = new PriorityQueue<>();
+            PriorityQueue<ContainerInfo> queue = new PriorityQueue<>();
-        BlockContainerInfo blockContainerInfo =
-            new BlockContainerInfo(container, 0);
-        ((PriorityQueue) containers.get(key)).add(blockContainerInfo);
+        containers.get(key).add(container);
-    ContainerInfo info = new ContainerInfo.Builder()
+    ContainerInfo containerInfo = new ContainerInfo.Builder()
+        // This is bytes allocated for blocks inside container, not the
+        // container size
+        .setAllocatedBytes(0)
+        .setUsedBytes(0)
+        .setNumberOfKeys(0)
-    Preconditions.checkNotNull(info);
-    BlockContainerInfo blockInfo = new BlockContainerInfo(info, 0);
-    blockInfo.setLastUsed(Time.monotonicNow());
+    Preconditions.checkNotNull(containerInfo);
-          blockInfo.getState());
-      PriorityQueue<BlockContainerInfo> queue = containers.get(key);
+          containerInfo.getState());
+      PriorityQueue<ContainerInfo> queue = containers.get(key);
-      queue.add(blockInfo);
-      LOG.trace("New container allocated: {}", blockInfo);
+      queue.add(containerInfo);
+      LOG.trace("New container allocated: {}", containerInfo);
-    return info;
+    return containerInfo;
-   * @return New state of the container.
+   * @return Updated ContainerInfo.
-  public OzoneProtos.LifeCycleState updateContainerState(BlockContainerInfo
+  public ContainerInfo updateContainerState(ContainerInfo
-    LifeCycleState newState = null;
-    boolean shouldLease = false;
+    LifeCycleState newState;
-      if(newState == LifeCycleState.CREATING) {
-        // if we are moving into a Creating State, it is possible that clients
-        // could timeout therefore we need to use a lease.
-        shouldLease = true;
-      }
-      PriorityQueue<BlockContainerInfo> currentQueue = containers.get(oldKey);
+      PriorityQueue<ContainerInfo> currentQueue = containers.get(oldKey);
-      info.setState(newState);
-      PriorityQueue<BlockContainerInfo> nextQueue = containers.get(newKey);
+      PriorityQueue<ContainerInfo> nextQueue = containers.get(newKey);
-      info.setLastUsed(Time.monotonicNow());
-      nextQueue.add(info);
+      ContainerInfo containerInfo = new ContainerInfo.Builder()
+          .setContainerName(info.getContainerName())
+          .setState(newState)
+          .setPipeline(info.getPipeline())
+          .setAllocatedBytes(info.getAllocatedBytes())
+          .setUsedBytes(info.getUsedBytes())
+          .setNumberOfKeys(info.getNumberOfKeys())
+          .setStateEnterTime(Time.monotonicNow())
+          .setOwner(info.getOwner())
+          .build();
+      Preconditions.checkNotNull(containerInfo);
+      nextQueue.add(containerInfo);
-      return newState;
+      return containerInfo;
-   * @return BlockContainerInfo
+   * @return ContainerInfo
-  public BlockContainerInfo getMatchingContainer(final long size,
+  public ContainerInfo getMatchingContainer(final long size,
-      PriorityQueue<BlockContainerInfo> queue = containers.get(key);
+      PriorityQueue<ContainerInfo> queue = containers.get(key);
-      Iterator<BlockContainerInfo> iter = queue.iterator();
+      Iterator<ContainerInfo> iter = queue.iterator();
-        BlockContainerInfo info = iter.next();
-        if (info.canAllocate(size, this.containerSize)) {
+        ContainerInfo info = iter.next();
+        if (info.getAllocatedBytes() + size <= this.containerSize) {
-          info.addAllocated(size);
-          info.setLastUsed(Time.monotonicNow());
+          info.allocate(size);
+          info.updateLastUsedTime();
-        } else {
-          if (info.getState() != LifeCycleState.CLOSED) {
-            // We should close this container.
-            LOG.info("Moving {} to containerCloseQueue.", info.toString());
-            info.setState(LifeCycleState.CLOSED);
-            containerCloseQueue.add(info);
-            //TODO: Next JIRA will handle these containers to close.
-            //TODO: move container to right queue
-          }
-  public List<BlockContainerInfo> getMatchingContainers(Owner owner,
+  public List<ContainerInfo> getMatchingContainers(Owner owner,
-      return Arrays.asList((BlockContainerInfo[]) containers.get(key)
-          .toArray(new BlockContainerInfo[0]));
+      return Arrays.asList((ContainerInfo[]) containers.get(key)
+          .toArray(new ContainerInfo[0]));
+  @Override
+  public void close() throws IOException {
+    //TODO: update container metadata db with actual allocated bytes values.
+  }
+

MOV26 UPD40 INS43 INS31 INS42 UPD74 UPD74 UPD43 UPD43 UPD74 INS78 INS83 INS39 INS42 INS43 INS8 UPD43 UPD74 INS42 UPD43 UPD42 UPD43 INS42 INS42 UPD42 UPD43 UPD42 UPD66 UPD42 UPD66 UPD42 UPD42 UPD42 INS32 UPD42 INS60 INS21 UPD74 INS32 INS42 MOV43 UPD74 INS74 UPD74 MOV74 INS43 INS59 INS32 UPD42 UPD74 UPD74 MOV32 INS42 INS42 UPD43 UPD42 UPD42 MOV43 INS43 UPD43 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD43 UPD43 INS32 INS42 MOV32 MOV43 UPD42 INS42 UPD42 INS32 INS42 UPD42 UPD42 UPD43 INS27 UPD5 MOV32 UPD42 MOV32 UPD42 MOV42 INS34 UPD42 INS32 INS42 INS32 UPD42 INS27 MOV22 UPD43 UPD42 INS34 INS32 INS42 MOV32 INS42 INS42 INS32 INS42 UPD42 UPD5 UPD42 INS34 INS32 INS42 INS32 MOV42 UPD42 MOV42 UPD42 UPD42 UPD43 UPD74 INS32 INS42 INS32 INS42 INS42 UPD42 UPD43 INS32 INS42 INS32 MOV42 UPD42 MOV42 UPD42 INS32 INS42 INS32 INS42 INS42 INS32 MOV42 MOV42 INS42 INS42 INS14 INS42 INS32 INS43 MOV42 INS42 INS40 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL34 DEL14 DEL59 DEL60 DEL42 DEL43 DEL11 DEL36 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL40 DEL33 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL32 DEL21 DEL42 DEL43 DEL74 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8
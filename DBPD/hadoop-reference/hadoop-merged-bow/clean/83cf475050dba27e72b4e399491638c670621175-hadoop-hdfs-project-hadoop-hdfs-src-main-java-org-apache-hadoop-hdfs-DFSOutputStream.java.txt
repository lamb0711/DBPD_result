HDFS-744. Support hsync in HDFS. Contributed by Lars Hofhans


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1344419 13f79535-47bb-0310-9956-ffa450edef68

+  private boolean shouldSyncBlock = false; // force blocks to disk upon close
-    boolean lastPacketInBlock;   // is this the last packet in block?
+    private boolean lastPacketInBlock;   // is this the last packet in block?
+    boolean syncBlock;          // this packet forces the current block to disk
-        pktLen, offsetInBlock, seqno, lastPacketInBlock, dataLen);
+        pktLen, offsetInBlock, seqno, lastPacketInBlock, dataLen, syncBlock);
+    this.shouldSyncBlock = flag.contains(CreateFlag.SYNC_BLOCK);
+        currentPacket.syncBlock = shouldSyncBlock;
+    flushOrSync(false);
+  }
+
+  /**
+   * The expected semantics is all data have flushed out to all replicas 
+   * and all replicas have done posix fsync equivalent - ie the OS has 
+   * flushed it to the disk device (but the disk may have it in its cache).
+   * 
+   * Note that only the current block is flushed to the disk device.
+   * To guarantee durable sync across block boundaries the stream should
+   * be created with {@link CreateFlag#SYNC_BLOCK}.
+   */
+  @Override
+  public void hsync() throws IOException {
+    flushOrSync(true);
+  }
+
+  private void flushOrSync(boolean isSync) throws IOException {
-          waitAndQueueCurrentPacket();
+          if (isSync && currentPacket == null) {
+            // Nothing to send right now,
+            // but sync was requested.
+            // Send an empty packet
+            currentPacket = new Packet(packetSize, chunksPerPacket,
+                bytesCurBlock);
+          }
-          // just discard the current packet since it is already been sent.
-          currentPacket = null;
+          if (isSync && bytesCurBlock > 0) {
+            // Nothing to send right now,
+            // and the block was partially written,
+            // and sync was requested.
+            // So send an empty sync packet.
+            currentPacket = new Packet(packetSize, chunksPerPacket,
+                bytesCurBlock);
+          } else {
+            // just discard the current packet since it is already been sent.
+            currentPacket = null;
+          }
+        }
+        if (currentPacket != null) {
+          currentPacket.syncBlock = isSync;
+          waitAndQueueCurrentPacket();          
-   * The expected semantics is all data have flushed out to all replicas 
-   * and all replicas have done posix fsync equivalent - ie the OS has 
-   * flushed it to the disk device (but the disk may have it in its cache).
-   * 
-   * Right now by default it is implemented as hflush
-   */
-  @Override
-  public synchronized void hsync() throws IOException {
-    hflush();
-  }
-
-  /**
+        currentPacket.syncBlock = shouldSyncBlock;

MOV31 INS23 INS31 INS83 INS39 INS59 INS23 MOV29 MOV78 INS83 INS39 INS42 INS43 INS8 UPD83 UPD42 INS44 INS42 INS9 INS83 INS39 INS59 INS21 INS42 INS21 INS39 INS42 INS42 INS7 INS32 UPD66 INS66 INS66 INS65 INS66 MOV43 INS22 INS32 INS42 INS9 INS67 UPD42 INS9 INS52 INS42 INS42 INS42 INS40 INS42 INS42 MOV43 INS42 INS21 INS25 INS21 INS7 INS8 INS8 INS27 INS8 INS7 INS40 INS42 MOV6 MOV21 INS25 MOV6 INS25 INS42 INS33 INS21 MOV21 INS40 INS42 INS27 MOV8 INS27 INS8 MOV8 INS7 INS42 INS27 INS21 INS42 INS27 INS21 INS40 INS42 INS42 INS33 INS7 INS42 INS34 INS7 INS42 INS14 INS42 INS14 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 DEL83
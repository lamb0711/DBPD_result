Merge trunk to HDFS-4685.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1549699 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.INode.BlocksMapUpdateInfo;
-import org.apache.hadoop.hdfs.server.namenode.INodeMap;
- * Represent an {@link INodeFile} that is snapshotted.
+ * Feature for file with snapshot-related information.
-public class INodeFileWithSnapshot extends INodeFile {
+public class FileWithSnapshotFeature extends INodeFile.Feature {
-
-  public INodeFileWithSnapshot(INodeFile f) {
-    this(f, f instanceof INodeFileWithSnapshot ? 
-        ((INodeFileWithSnapshot) f).getDiffs() : null);
-  }
-
-  public INodeFileWithSnapshot(INodeFile f, FileDiffList diffs) {
-    super(f);
+  
+  public FileWithSnapshotFeature(FileDiffList diffs) {
-  /** Is the current file deleted? */
-  /** Delete the file from the current tree */
+  /** 
+   * We need to distinguish two scenarios:
+   * 1) the file is still in the current file directory, it has been modified 
+   *    before while it is included in some snapshot
+   * 2) the file is not in the current file directory (deleted), but it is in
+   *    some snapshot, thus we still keep this inode
+   * For both scenarios the file has snapshot feature. We set 
+   * {@link #isCurrentFileDeleted} to true for 2).
+   */
-  @Override
-  public INodeFileAttributes getSnapshotINode(Snapshot snapshot) {
-    return diffs.getSnapshotINode(snapshot, this);
+  public INodeFileAttributes getSnapshotINode(INodeFile f, Snapshot snapshot) {
+    return diffs.getSnapshotINode(snapshot, f);
-  @Override
-  public INodeFileWithSnapshot recordModification(final Snapshot latest,
-      final INodeMap inodeMap) throws QuotaExceededException {
-    if (isInLatestSnapshot(latest) && !shouldRecordInSrcSnapshot(latest)) {
-      diffs.saveSelf2Snapshot(latest, this, null);
-    }
-    return this;
-  }
-
-  /** @return the file diff list. */
-
-  @Override
-  public Quota.Counts cleanSubtree(final Snapshot snapshot, Snapshot prior,
-      final BlocksMapUpdateInfo collectedBlocks,
-      final List<INode> removedINodes, final boolean countDiffChange) 
-      throws QuotaExceededException {
-    if (snapshot == null) { // delete the current file
-      if (!isCurrentFileDeleted()) {
-        recordModification(prior, null);
-        deleteCurrentFile();
-      }
-      this.collectBlocksAndClear(collectedBlocks, removedINodes);
-      return Quota.Counts.newInstance();
-    } else { // delete a snapshot
-      prior = getDiffs().updatePrior(snapshot, prior);
-      return diffs.deleteSnapshotDiff(snapshot, prior, this, collectedBlocks,
-          removedINodes, countDiffChange);
-    }
-  }
-
-  @Override
-  public String toDetailString() {
-    return super.toDetailString()
-        + (isCurrentFileDeleted()? "(DELETED), ": ", ") + diffs;
-  }
-  /** 
-   * @return block replication, which is the max file replication among
-   *         the file and the diff list.
-   */
-  @Override
-  public short getBlockReplication() {
-    short max = isCurrentFileDeleted() ? 0 : getFileReplication();
+  /** @return the max replication factor in diffs */
+  public short getMaxBlockRepInDiffs() {
+    short max = 0;
+  public String getDetailedString() {
+    return (isCurrentFileDeleted()? "(DELETED), ": ", ") + diffs;
+  }
+  
+  public Quota.Counts cleanFile(final INodeFile file, final Snapshot snapshot,
+      Snapshot prior, final BlocksMapUpdateInfo collectedBlocks,
+      final List<INode> removedINodes, final boolean countDiffChange)
+      throws QuotaExceededException {
+    if (snapshot == null) {
+      // delete the current file while the file has snapshot feature
+      if (!isCurrentFileDeleted()) {
+        file.recordModification(prior, null);
+        deleteCurrentFile();
+      }
+      collectBlocksAndClear(file, collectedBlocks, removedINodes);
+      return Quota.Counts.newInstance();
+    } else { // delete the snapshot
+      prior = getDiffs().updatePrior(snapshot, prior);
+      return diffs.deleteSnapshotDiff(snapshot, prior, file, collectedBlocks,
+          removedINodes, countDiffChange);
+    }
+  }
+  
+  public void clearDiffs() {
+    this.diffs.clear();
+  }
+  
+  public Quota.Counts updateQuotaAndCollectBlocks(INodeFile file,
+      FileDiff removed, BlocksMapUpdateInfo collectedBlocks,
+      final List<INode> removedINodes) {
+    long oldDiskspace = file.diskspaceConsumed();
+    if (removed.snapshotINode != null) {
+      short replication = removed.snapshotINode.getFileReplication();
+      short currentRepl = file.getBlockReplication();
+      if (currentRepl == 0) {
+        oldDiskspace = file.computeFileSize(true, true) * replication;
+      } else if (replication > currentRepl) {  
+        oldDiskspace = oldDiskspace / file.getBlockReplication() * replication;
+      }
+    }
+    
+    collectBlocksAndClear(file, collectedBlocks, removedINodes);
+    
+    long dsDelta = oldDiskspace - file.diskspaceConsumed();
+    return Quota.Counts.newInstance(0, dsDelta);
+  }
+  
-  void collectBlocksAndClear(final BlocksMapUpdateInfo info,
-      final List<INode> removedINodes) {
+  private void collectBlocksAndClear(final INodeFile file,
+      final BlocksMapUpdateInfo info, final List<INode> removedINodes) {
-      destroyAndCollectBlocks(info, removedINodes);
+      file.destroyAndCollectBlocks(info, removedINodes);
-
-      max = computeFileSize();
+      max = file.computeFileSize();
-    collectBlocksBeyondMax(max, info);
+    collectBlocksBeyondMax(file, max, info);
-  private void collectBlocksBeyondMax(final long max,
+  private void collectBlocksBeyondMax(final INodeFile file, final long max,
-    final BlockInfo[] oldBlocks = getBlocks();
+    final BlockInfo[] oldBlocks = file.getBlocks();
-        setBlocks(newBlocks);
+        file.setBlocks(newBlocks);
-  
-  Quota.Counts updateQuotaAndCollectBlocks(FileDiff removed,
-      BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes) {
-    long oldDiskspace = this.diskspaceConsumed();
-    if (removed.snapshotINode != null) {
-      short replication = removed.snapshotINode.getFileReplication();
-      short currentRepl = getBlockReplication();
-      if (currentRepl == 0) {
-        oldDiskspace = computeFileSize(true, true) * replication;
-      } else if (replication > currentRepl) {  
-        oldDiskspace = oldDiskspace / getBlockReplication()
-            * replication;
-      }
-    }
-    
-    this.collectBlocksAndClear(collectedBlocks, removedINodes);
-    
-    long dsDelta = oldDiskspace - diskspaceConsumed();
-    return Quota.Counts.newInstance(0, dsDelta);
-  }

MOV26 MOV31 MOV31 MOV31 MOV31 UPD40 UPD42 INS43 INS40 UPD42 MOV44 UPD42 UPD42 UPD42 INS44 INS39 INS42 INS8 INS83 INS44 INS83 INS44 INS44 UPD66 INS83 MOV43 INS42 MOV21 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS66 INS66 INS66 UPD66 INS66 INS66 INS65 INS66 UPD66 INS42 INS42 INS42 INS67 INS42 INS34 INS22 UPD42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL66 DEL42 DEL65 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL33 DEL16 DEL17 DEL8 DEL31 DEL42 DEL46 DEL66 DEL65 DEL29 DEL42 DEL78 DEL52 DEL66 DEL65 DEL29 DEL66 DEL42 DEL78 DEL42 DEL32 DEL34 DEL42 DEL32 DEL16 DEL42 DEL78 DEL42 DEL48 DEL42 DEL78 DEL52 DEL52 DEL42 DEL78 DEL42 DEL42 DEL52 DEL33 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL8 DEL25 DEL52 DEL41 DEL8 DEL52 DEL52
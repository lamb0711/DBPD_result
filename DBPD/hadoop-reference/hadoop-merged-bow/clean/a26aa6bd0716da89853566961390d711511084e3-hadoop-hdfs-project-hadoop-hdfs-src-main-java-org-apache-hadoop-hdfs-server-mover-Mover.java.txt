HDFS-6944. Archival Storage: add retry and termination logic for Mover. Contributed by Jing Zhao.

+import com.google.common.annotations.VisibleForTesting;
-      new Processor().processNamespace();
-
-      return ExitStatus.IN_PROGRESS;
+      boolean hasRemaining = new Processor().processNamespace();
+      return hasRemaining ? ExitStatus.IN_PROGRESS : ExitStatus.SUCCESS;
-    private void processNamespace() {
+    /**
+     * @return whether there is still remaining migration work for the next
+     *         round
+     */
+    private boolean processNamespace() {
+      boolean hasRemaining = true;
-        processDirRecursively("", dfs.getFileInfo("/"));
+        hasRemaining = processDirRecursively("", dfs.getFileInfo("/"));
+      // wait for pending move to finish and retry the failed migration
+      hasRemaining |= Dispatcher.waitForMoveCompletion(storages.targets.values());
+      return hasRemaining;
-    private void processChildrenList(String fullPath) {
+    /**
+     * @return whether there is still remaing migration work for the next
+     *         round
+     */
+    private boolean processChildrenList(String fullPath) {
+      boolean hasRemaining = false;
-          return;
+          return hasRemaining;
-          return;
+          return hasRemaining;
-          processDirRecursively(fullPath, child);
+          hasRemaining |= processDirRecursively(fullPath, child);
-        if (!children.hasMore()) {
+        if (children.hasMore()) {
-          return;
+          return hasRemaining;
-    private void processDirRecursively(String parent, HdfsFileStatus status) {
+    /** @return whether the migration requires next round */
+    private boolean processDirRecursively(String parent,
+                                          HdfsFileStatus status) {
-      if (status.isSymlink()) {
-        return; //ignore symlinks
-      } else if (status.isDir()) {
+      boolean hasRemaining = false;
+      if (status.isDir()) {
-          fullPath = fullPath + Path.SEPARATOR; 
+          fullPath = fullPath + Path.SEPARATOR;
-        processChildrenList(fullPath);
+        hasRemaining = processChildrenList(fullPath);
-          processChildrenList(dirSnapshot);
+          hasRemaining |= processChildrenList(dirSnapshot);
-      } else { // file
+      } else if (!status.isSymlink()) { // file
-          if (isSnapshotPathInCurrent(fullPath)) {
+          if (!isSnapshotPathInCurrent(fullPath)) {
-            return;
+            hasRemaining = processFile((HdfsLocatedFileStatus)status);
-          return;
+          return false;
-        processFile(parent, (HdfsLocatedFileStatus)status);
+      return hasRemaining;
-    private void processFile(String parent, HdfsLocatedFileStatus status) { 
+    /** @return true if it is necessary to run another round of migration */
+    private boolean processFile(HdfsLocatedFileStatus status) {
-      final LocatedBlocks locations = status.getBlockLocations();
-      for(LocatedBlock lb : locations.getLocatedBlocks()) {
-        final StorageTypeDiff diff = new StorageTypeDiff(types, lb.getStorageTypes());
+      final LocatedBlocks locatedBlocks = status.getBlockLocations();
+      boolean hasRemaining = false;
+      for(LocatedBlock lb : locatedBlocks.getLocatedBlocks()) {
+        final StorageTypeDiff diff = new StorageTypeDiff(types,
+            lb.getStorageTypes());
-          scheduleMoves4Block(diff, lb);
+          if (scheduleMoves4Block(diff, lb)) {
+            hasRemaining |= (diff.existing.size() > 1 &&
+                diff.expected.size() > 1);
+          } else {
+            hasRemaining = true;
+          }
+      return hasRemaining;
-    void scheduleMoves4Block(StorageTypeDiff diff, LocatedBlock lb) {
+    boolean scheduleMoves4Block(StorageTypeDiff diff, LocatedBlock lb) {
-      for(final Iterator<StorageType> i = diff.existing.iterator(); i.hasNext(); ) {
-        final StorageType t = i.next();
-        for(final Iterator<MLocation> j = locations.iterator(); j.hasNext(); ) {
-          final MLocation ml = j.next();
-          final Source source = storages.getSource(ml); 
+      for (final StorageType t : diff.existing) {
+        for (final MLocation ml : locations) {
+          final Source source = storages.getSource(ml);
-            // try to schedule replica move.
-            if (scheduleMoveReplica(db, ml, source, diff.expected)) {
-              i.remove();
-              j.remove();
-              return;
+            // try to schedule one replica move.
+            if (scheduleMoveReplica(db, source, diff.expected)) {
+              return true;
+      return false;
+    @VisibleForTesting
-        List<StorageType> targetTypes) {
-      return scheduleMoveReplica(db, ml, storages.getSource(ml), targetTypes);
+                                List<StorageType> targetTypes) {
+      return scheduleMoveReplica(db, storages.getSource(ml), targetTypes);
-    boolean scheduleMoveReplica(DBlock db, MLocation ml, Source source,
+    boolean scheduleMoveReplica(DBlock db, Source source,
-        if (chooseTarget(db, ml, source, targetTypes, Matcher.SAME_NODE_GROUP)) {
+        if (chooseTarget(db, source, targetTypes, Matcher.SAME_NODE_GROUP)) {
-      if (chooseTarget(db, ml, source, targetTypes, Matcher.SAME_RACK)) {
+      if (chooseTarget(db, source, targetTypes, Matcher.SAME_RACK)) {
-      if (chooseTarget(db, ml, source, targetTypes, Matcher.ANY_OTHER)) {
-        return true;
-      }
-      return false;
+      return chooseTarget(db, source, targetTypes, Matcher.ANY_OTHER);
-    boolean chooseTarget(DBlock db, MLocation ml, Source source,
+    boolean chooseTarget(DBlock db, Source source,
-      for(final Iterator<StorageType> i = targetTypes.iterator(); i.hasNext(); ) {
-        final StorageType t = i.next();
+      for (StorageType t : targetTypes) {
-          if (matcher.match(cluster, ml.datanode, target.getDatanodeInfo())) {
+          if (matcher.match(cluster, source.getDatanodeInfo(),
+              target.getDatanodeInfo())) {
-              i.remove();
-  
-  private static class StorageTypeDiff {
+  @VisibleForTesting
+  static class StorageTypeDiff {
-     * @return if the existing types is empty after removed the overlap.
+     * @return if the existing types or the expected types is empty after
+     *         removing the overlap.
-      return existing.isEmpty();
+      return expected.isEmpty() || existing.isEmpty();
-    final long sleeptime = 2000*conf.getLong(
+    final long sleeptime = 2000 * conf.getLong(
-      connectors = NameNodeConnector.newNameNodeConnectors(namenodes, 
+      connectors = NameNodeConnector.newNameNodeConnectors(namenodes,
-      while (true) {
+      while (connectors.size() > 0) {
-        for(NameNodeConnector nnc : connectors) {
+        Iterator<NameNodeConnector> iter = connectors.iterator();
+        while (iter.hasNext()) {
+          NameNodeConnector nnc = iter.next();
-          if (r != ExitStatus.IN_PROGRESS) {
-            //must be an error statue, return.
+          if (r == ExitStatus.SUCCESS) {
+            iter.remove();
+          } else if (r != ExitStatus.IN_PROGRESS) {
+            // must be an error statue, return
-
+      return ExitStatus.SUCCESS.getExitCode();
-      for(NameNodeConnector nnc : connectors) {
+      for (NameNodeConnector nnc : connectors) {

MOV26 INS26 INS40 INS78 INS29 UPD39 INS29 UPD39 INS29 UPD39 INS29 UPD39 UPD39 INS78 INS42 INS65 INS60 INS21 INS41 INS65 INS60 INS65 INS60 MOV25 MOV41 INS65 INS60 INS41 INS70 MOV41 INS42 INS41 INS70 INS60 INS66 INS66 INS39 INS59 INS7 INS42 INS66 INS66 INS39 INS59 INS66 INS39 INS59 INS25 INS42 INS66 INS39 INS59 INS42 INS44 INS40 INS8 INS32 INS44 INS42 MOV8 UPD66 INS66 INS27 INS41 INS39 INS59 INS16 INS42 INS9 INS42 INS32 INS42 INS9 INS42 INS9 INS38 MOV8 UPD42 INS42 INS9 UPD42 INS25 INS83 MOV43 INS42 INS70 MOV42 MOV42 MOV42 MOV42 MOV40 MOV43 INS42 INS32 MOV32 INS27 INS32 INS42 MOV32 INS42 INS40 INS40 INS7 INS42 INS42 INS32 MOV32 INS7 MOV32 MOV38 INS8 INS44 INS42 INS8 MOV8 INS42 INS42 INS32 INS34 INS60 INS61 INS40 INS42 INS42 MOV32 INS40 INS42 INS42 MOV32 MOV25 INS83 MOV43 INS42 MOV60 MOV25 INS42 INS42 UPD74 MOV74 INS59 INS32 MOV8 INS42 INS7 INS42 INS7 MOV32 INS8 UPD43 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS42 MOV32 INS42 MOV32 INS38 INS21 INS32 UPD42 INS42 INS42 MOV43 INS59 INS27 INS8 MOV25 MOV32 INS21 INS9 INS7 INS7 MOV8 INS42 INS42 INS42 INS32 INS42 INS40 INS21 INS7 INS42 INS36 INS42 INS9 MOV41 INS42 INS42 INS32 INS42 INS32 INS27 MOV9 INS42 INS42 INS42 MOV11 INS27 INS27 INS32 INS34 INS32 INS34 INS40 INS42 INS40 INS42 DEL21 DEL40 DEL38 DEL41 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL40 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL24 DEL8 DEL24 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL25 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL83 DEL9 DEL42 DEL44 DEL42 DEL70
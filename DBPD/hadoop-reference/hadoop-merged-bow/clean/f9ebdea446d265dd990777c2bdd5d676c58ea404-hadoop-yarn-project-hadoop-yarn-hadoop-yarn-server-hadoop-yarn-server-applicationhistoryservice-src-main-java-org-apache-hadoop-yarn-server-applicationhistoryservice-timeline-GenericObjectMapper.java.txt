Merging r1573814 through r1574170 from trunk.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1574171 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.apache.hadoop.io.WritableUtils;
+import org.codehaus.jackson.map.ObjectReader;
+import org.codehaus.jackson.map.ObjectWriter;
- * objects. The {@link #write(Object)}, {@link #read(byte[])} and {@link
- * #write(java.io.DataOutputStream, Object)}, {@link
- * #read(java.io.DataInputStream)} methods are used by the
- * {@link LeveldbTimelineStore} to store and retrieve arbitrary
+ * objects. The {@link #write(Object)} and {@link #read(byte[])} methods are
+ * used by the {@link LeveldbTimelineStore} to store and retrieve arbitrary
-  private static final byte LONG = 0x1;
-  private static final byte INTEGER = 0x2;
-  private static final byte DOUBLE = 0x3;
-  private static final byte STRING = 0x4;
-  private static final byte BOOLEAN = 0x5;
-  private static final byte LIST = 0x6;
-  private static final byte MAP = 0x7;
+  public static final ObjectReader OBJECT_READER;
+  public static final ObjectWriter OBJECT_WRITER;
+
+  static {
+    ObjectMapper mapper = new ObjectMapper();
+    OBJECT_READER = mapper.reader(Object.class);
+    OBJECT_WRITER = mapper.writer();
+  }
-   * Serializes an Object into a byte array. Along with {@link #read(byte[]) },
+   * Serializes an Object into a byte array. Along with {@link #read(byte[])},
-   * as long as it is one of the JSON-compatible objects Long, Integer,
-   * Double, String, Boolean, List, or Map.  The current implementation uses
-   * ObjectMapper to serialize complex objects (List and Map) while using
-   * Writable to serialize simpler objects, to produce fewer bytes.
+   * as long as it is one of the JSON-compatible objects understood by
+   * ObjectMapper.
-    if (o == null)
+    if (o == null) {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    write(new DataOutputStream(baos), o);
-    return baos.toByteArray();
-  }
-
-  /**
-   * Serializes an Object and writes it to a DataOutputStream. Along with
-   * {@link #read(java.io.DataInputStream)}, can be used to serialize an Object
-   * and deserialize it into an Object of the same type without needing to
-   * specify the Object's type, as long as it is one of the JSON-compatible
-   * objects Long, Integer, Double, String, Boolean, List, or Map. The current
-   * implementation uses ObjectMapper to serialize complex objects (List and
-   * Map) while using Writable to serialize simpler objects, to produce fewer
-   * bytes.
-   *
-   * @param dos A DataOutputStream
-   * @param o An Object
-   * @throws IOException
-   */
-  public static void write(DataOutputStream dos, Object o)
-      throws IOException {
-    if (o == null)
-      return;
-    if (o instanceof Long) {
-      dos.write(LONG);
-      WritableUtils.writeVLong(dos, (Long) o);
-    } else if(o instanceof Integer) {
-      dos.write(INTEGER);
-      WritableUtils.writeVInt(dos, (Integer) o);
-    } else if(o instanceof Double) {
-      dos.write(DOUBLE);
-      dos.writeDouble((Double) o);
-    } else if (o instanceof String) {
-      dos.write(STRING);
-      WritableUtils.writeString(dos, (String) o);
-    } else if (o instanceof Boolean) {
-      dos.write(BOOLEAN);
-      dos.writeBoolean((Boolean) o);
-    } else if (o instanceof List) {
-      dos.write(LIST);
-      ObjectMapper mapper = new ObjectMapper();
-      mapper.writeValue(dos, o);
-    } else if (o instanceof Map) {
-      dos.write(MAP);
-      ObjectMapper mapper = new ObjectMapper();
-      mapper.writeValue(dos, o);
-    } else {
-      throw new IOException("Couldn't serialize object");
+    return OBJECT_WRITER.writeValueAsBytes(o);
-    ByteArrayInputStream bais = new ByteArrayInputStream(b, offset,
-        b.length - offset);
-    return read(new DataInputStream(bais));
-  }
-
-  /**
-   * Reads an Object from a DataInputStream whose data has been written with
-   * {@link #write(java.io.DataOutputStream, Object)}.
-   *
-   * @param dis A DataInputStream
-   * @return An Object, null if an unrecognized type
-   * @throws IOException
-   */
-  public static Object read(DataInputStream dis) throws IOException {
-    byte code = (byte)dis.read();
-    ObjectMapper mapper;
-    switch (code) {
-      case LONG:
-        return WritableUtils.readVLong(dis);
-      case INTEGER:
-        return WritableUtils.readVInt(dis);
-      case DOUBLE:
-        return dis.readDouble();
-      case STRING:
-        return WritableUtils.readString(dis);
-      case BOOLEAN:
-        return dis.readBoolean();
-      case LIST:
-        mapper = new ObjectMapper();
-        return mapper.readValue(dis, ArrayList.class);
-      case MAP:
-        mapper = new ObjectMapper();
-        return mapper.readValue(dis, HashMap.class);
-      default:
-        return null;
-    }
+    return OBJECT_READER.readValue(b, offset, b.length - offset);
-    for (int i = 1; i < 7; i++)
+    for (int i = 1; i < 7; i++) {
+    }

MOV26 MOV26 UPD40 UPD40 INS28 MOV65 UPD83 INS43 UPD83 INS43 INS83 INS8 UPD66 UPD66 INS42 UPD42 INS42 UPD42 MOV60 INS21 INS21 INS41 INS41 INS7 INS7 UPD66 UPD66 INS8 INS32 INS32 INS8 INS42 INS32 INS42 INS32 MOV41 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS42 MOV27 MOV21 INS42 INS42 INS57 INS42 INS42 MOV43 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL42 DEL40 DEL43 DEL69 DEL69 DEL68 DEL65 DEL42 DEL40 DEL43 DEL69 DEL68 DEL65 DEL39 DEL34 DEL39 DEL34 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL14 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL66 DEL42 DEL40 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL41 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL25 DEL25 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL14 DEL32 DEL41 DEL66 DEL42 DEL40 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL39 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL49 DEL42 DEL42 DEL42 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL42 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL42 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL41 DEL49 DEL33 DEL41 DEL50 DEL8 DEL31
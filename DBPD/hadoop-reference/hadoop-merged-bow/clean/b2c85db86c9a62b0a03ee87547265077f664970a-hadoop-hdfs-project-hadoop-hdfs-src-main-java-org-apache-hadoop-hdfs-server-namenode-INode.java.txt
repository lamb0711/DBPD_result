HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.

+import java.util.Map;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
-    if (latestSnapshotId == Snapshot.CURRENT_STATE_ID || latestSnapshotId == Snapshot.NO_SNAPSHOT_ID) {
+    if (latestSnapshotId == Snapshot.CURRENT_STATE_ID ||
+        latestSnapshotId == Snapshot.NO_SNAPSHOT_ID) {
-   * @return quota usage delta when deleting a snapshot
-  public abstract QuotaCounts cleanSubtree(
-      ReclaimContext reclaimContext, final int snapshotId, int priorSnapshotId);
-  
+  public abstract void cleanSubtree(ReclaimContext reclaimContext,
+      final int snapshotId, int priorSnapshotId);
+
-    return computeQuotaUsage(bsps, storagePolicyId,
-        new QuotaCounts.Builder().build(), true, Snapshot.CURRENT_STATE_ID);
+    return computeQuotaUsage(bsps, storagePolicyId, true,
+        Snapshot.CURRENT_STATE_ID);
-   * @param counts The subtree counts for returning.
-   * @return The same objects as the counts parameter.
+   * @return The subtree quota counts.
-  public abstract QuotaCounts computeQuotaUsage(
-    BlockStoragePolicySuite bsps, byte blockStoragePolicyId,
-    QuotaCounts counts, boolean useCache, int lastSnapshotId);
+  public abstract QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,
+      byte blockStoragePolicyId, boolean useCache, int lastSnapshotId);
-  public final QuotaCounts computeQuotaUsage(
-    BlockStoragePolicySuite bsps, QuotaCounts counts, boolean useCache) {
+  public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,
+      boolean useCache) {
-    return computeQuotaUsage(bsps, storagePolicyId, counts,
-        useCache, Snapshot.CURRENT_STATE_ID);
+    return computeQuotaUsage(bsps, storagePolicyId, useCache,
+        Snapshot.CURRENT_STATE_ID);
+   * Information used to record quota usage delta. This data structure is
+   * usually passed along with an operation like {@link #cleanSubtree}. Note
+   * that after the operation the delta counts should be decremented from the
+   * ancestral directories' quota usage.
+   */
+  public static class QuotaDelta {
+    private final QuotaCounts counts;
+    /**
+     * The main usage of this map is to track the quota delta that should be
+     * applied to another path. This usually happens when we reclaim INodes and
+     * blocks while deleting snapshots, and hit an INodeReference. Because the
+     * quota usage for a renamed+snapshotted file/directory is counted in both
+     * the current and historical parents, any change of its quota usage may
+     * need to be propagated along its parent paths both before and after the
+     * rename.
+     */
+    private final Map<INode, QuotaCounts> updateMap;
+
+    /**
+     * When deleting a snapshot we may need to update the quota for directories
+     * with quota feature. This map is used to capture these directories and
+     * their quota usage updates.
+     */
+    private final Map<INodeDirectory, QuotaCounts> quotaDirMap;
+
+    public QuotaDelta() {
+      counts = new QuotaCounts.Builder().build();
+      updateMap = Maps.newHashMap();
+      quotaDirMap = Maps.newHashMap();
+    }
+
+    public void add(QuotaCounts update) {
+      counts.add(update);
+    }
+
+    public void addUpdatePath(INodeReference inode, QuotaCounts update) {
+      QuotaCounts c = updateMap.get(inode);
+      if (c == null) {
+        c = new QuotaCounts.Builder().build();
+        updateMap.put(inode, c);
+      }
+      c.add(update);
+    }
+
+    public void addQuotaDirUpdate(INodeDirectory dir, QuotaCounts update) {
+      Preconditions.checkState(dir.isQuotaSet());
+      QuotaCounts c = quotaDirMap.get(dir);
+      if (c == null) {
+        quotaDirMap.put(dir, update);
+      } else {
+        c.add(update);
+      }
+    }
+
+    public QuotaCounts getCountsCopy() {
+      final QuotaCounts copy = new QuotaCounts.Builder().build();
+      copy.add(counts);
+      return copy;
+    }
+
+    public void setCounts(QuotaCounts c) {
+      this.counts.setNameSpace(c.getNameSpace());
+      this.counts.setStorageSpace(c.getStorageSpace());
+      this.counts.setTypeSpaces(c.getTypeSpaces());
+    }
+
+    public long getNsDelta() {
+      long nsDelta = counts.getNameSpace();
+      for (Map.Entry<INode, QuotaCounts> entry : updateMap.entrySet()) {
+        nsDelta += entry.getValue().getNameSpace();
+      }
+      return nsDelta;
+    }
+
+    public Map<INode, QuotaCounts> getUpdateMap() {
+      return ImmutableMap.copyOf(updateMap);
+    }
+
+    public Map<INodeDirectory, QuotaCounts> getQuotaDirMap() {
+      return ImmutableMap.copyOf(quotaDirMap);
+    }
+  }
+
+  /**
+    /** Used to collect quota usage delta */
+    private final QuotaDelta quotaDelta;
+
+      this.quotaDelta = new QuotaDelta();
+
+    public QuotaDelta quotaDelta() {
+      return quotaDelta;
+    }
+
+    /**
+     * make a copy with the same collectedBlocks, removedINodes, and
+     * removedUCFiles but a new quotaDelta.
+     */
+    public ReclaimContext getCopy() {
+      return new ReclaimContext(bsps, collectedBlocks, removedINodes,
+          removedUCFiles);
+    }
-      toDeleteList = new ChunkedArrayList<Block>();
+      toDeleteList = new ChunkedArrayList<>();

INS26 INS26 INS26 INS40 INS40 INS40 INS55 INS39 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS65 INS83 INS83 MOV43 INS59 INS29 INS83 INS83 INS74 INS59 INS29 INS83 INS83 INS74 INS59 INS83 INS42 INS8 INS83 INS39 INS42 MOV44 INS8 INS83 INS39 INS42 INS44 MOV44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS74 INS42 INS8 INS83 INS74 INS42 INS8 INS29 INS83 INS83 INS43 INS59 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 INS42 INS65 INS43 INS43 INS43 INS42 INS65 INS43 INS43 INS43 INS42 INS21 INS21 INS21 UPD42 INS21 INS43 INS42 UPD42 INS60 INS25 INS21 INS43 INS42 INS43 INS42 INS21 INS60 INS25 INS42 INS60 INS21 INS41 INS43 INS42 INS21 INS21 INS21 INS60 INS70 INS41 INS43 INS43 INS43 INS41 INS43 INS43 INS43 INS41 INS65 INS42 INS42 INS21 INS42 INS41 INS65 INS42 INS41 INS67 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS66 INS66 INS66 INS42 INS42 INS42 INS7 INS7 INS7 INS32 INS42 INS43 INS59 INS27 INS8 INS32 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS8 INS83 INS43 INS59 INS32 INS42 INS42 INS32 INS32 INS32 INS39 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS66 INS7 INS42 INS66 INS66 INS14 INS42 INS42 MOV32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS22 INS42 INS32 INS22 INS42 INS32 INS22 INS42 INS32 INS42 INS32 INS74 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS14 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS14 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS7 INS52 INS42 INS43 INS42 UPD74 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS40 INS32 INS42 INS43 INS42 INS42 INS40 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL42 DEL43
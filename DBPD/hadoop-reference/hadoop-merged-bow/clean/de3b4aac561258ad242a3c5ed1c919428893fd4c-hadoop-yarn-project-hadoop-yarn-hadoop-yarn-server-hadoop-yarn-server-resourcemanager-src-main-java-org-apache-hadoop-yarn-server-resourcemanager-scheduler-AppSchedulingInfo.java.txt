YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan

+import java.util.Iterator;
+import org.apache.commons.collections.IteratorUtils;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.PlacementSet;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.ResourceRequestUpdateResult;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.SchedulingPlacementSet;
+  public List<ResourceRequest> allocate(NodeType type,
+      SchedulerNode node, SchedulerRequestKey schedulerKey,
+      Container containerAllocated) {
+    try {
+      writeLock.lock();
+      ResourceRequest request;
+      if (type == NodeType.NODE_LOCAL) {
+        request = resourceRequestMap.get(schedulerKey).get(node.getNodeName());
+      } else if (type == NodeType.RACK_LOCAL) {
+        request = resourceRequestMap.get(schedulerKey).get(node.getRackName());
+      } else{
+        request = resourceRequestMap.get(schedulerKey).get(ResourceRequest.ANY);
+      }
+      return allocate(type, node, schedulerKey, request, containerAllocated);
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
-  public List<ResourceRequest> allocate(NodeType type, SchedulerNode node,
-      SchedulerRequestKey schedulerKey, ResourceRequest request,
-      Container containerAllocated) {
-    List<ResourceRequest> resourceRequests = new ArrayList<>();
+  public List<ResourceRequest> allocate(NodeType type,
+      SchedulerNode node, SchedulerRequestKey schedulerKey,
+      ResourceRequest request, Container containerAllocated) {
-      this.writeLock.lock();
+      writeLock.lock();
+      List<ResourceRequest> resourceRequests = new ArrayList<>();
-      } else {
+      } else{
-      QueueMetrics metrics = queue.getMetrics();
-      if (pending) {
-        // once an allocation is done we assume the application is
-        // running from scheduler's POV.
-        pending = false;
-        metrics.runAppAttempt(applicationId, user);
-      }
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("allocate: applicationId=" + applicationId
-            + " container=" + containerAllocated.getId()
-            + " host=" + containerAllocated.getNodeId().toString()
-            + " user=" + user
-            + " resource=" + request.getCapability()
-            + " type=" + type);
+      if (null != containerAllocated) {
+        updateMetricsForAllocatedContainer(request, type, containerAllocated);
-      metrics.allocateResources(user, 1, request.getCapability(), true);
-      metrics.incrNodeTypeAggregations(user, type);
-      this.writeLock.unlock();
+      writeLock.unlock();
+
+  /*
+   * In async environment, pending resource request could be updated during
+   * scheduling, this method checks pending request before allocating
+   */
+  public boolean checkAllocation(NodeType type, SchedulerNode node,
+      SchedulerRequestKey schedulerKey) {
+    try {
+      readLock.lock();
+      ResourceRequest r = resourceRequestMap.get(schedulerKey).get(
+          ResourceRequest.ANY);
+      if (r == null || r.getNumContainers() <= 0) {
+        return false;
+      }
+      if (type == NodeType.RACK_LOCAL || type == NodeType.NODE_LOCAL) {
+        r = resourceRequestMap.get(schedulerKey).get(node.getRackName());
+        if (r == null || r.getNumContainers() <= 0) {
+          return false;
+        }
+        if (type == NodeType.NODE_LOCAL) {
+          r = resourceRequestMap.get(schedulerKey).get(node.getNodeName());
+          if (r == null || r.getNumContainers() <= 0) {
+            return false;
+          }
+        }
+      }
+
+      return true;
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  public void updateMetricsForAllocatedContainer(
+      ResourceRequest request, NodeType type, Container containerAllocated) {
+    try {
+      writeLock.lock();
+      QueueMetrics metrics = queue.getMetrics();
+      if (pending) {
+        // once an allocation is done we assume the application is
+        // running from scheduler's POV.
+        pending = false;
+        metrics.runAppAttempt(applicationId, user);
+      }
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("allocate: applicationId=" + applicationId + " container="
+            + containerAllocated.getId() + " host=" + containerAllocated
+            .getNodeId().toString() + " user=" + user + " resource=" + request
+            .getCapability() + " type=" + type);
+      }
+      metrics.allocateResources(user, 1, request.getCapability(), true);
+      metrics.incrNodeTypeAggregations(user, type);
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
+  // Get placement-set by specified schedulerKey
+  // Now simply return all node of the input clusterPlacementSet
+  // TODO, need update this when we support global scheduling
+  public <N extends SchedulerNode> SchedulingPlacementSet<N> getSchedulingPlacementSet(
+      SchedulerRequestKey schedulerkey) {
+    return new SchedulingPlacementSet<N>() {
+      @Override
+      @SuppressWarnings("unchecked")
+      public Iterator<N> getPreferredNodeIterator(
+          PlacementSet<N> clusterPlacementSet) {
+        return IteratorUtils.singletonIterator(
+            clusterPlacementSet.getAllNodes().values().iterator().next());
+      }
+
+      @Override
+      public ResourceRequestUpdateResult updateResourceRequests(
+          List<ResourceRequest> requests,
+          boolean recoverPreemptedRequestForAContainer) {
+        return null;
+      }
+
+      @Override
+      public Map<String, ResourceRequest> getResourceRequests() {
+        return null;
+      }
+
+      @Override
+      public ResourceRequest getResourceRequest(String resourceName,
+          SchedulerRequestKey requestKey) {
+        return null;
+      }
+
+      @Override
+      public List<ResourceRequest> allocate(NodeType type, SchedulerNode node,
+          ResourceRequest request) {
+        return null;
+      }
+
+      @Override
+      public Map<NodeId, N> getAllNodes() {
+        return null;
+      }
+
+      @Override
+      public long getVersion() {
+        return 0;
+      }
+
+      @Override
+      public String getPartition() {
+        return null;
+      }
+    };
+  }

INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS8 MOV29 INS83 MOV74 INS42 INS44 MOV44 MOV44 MOV44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS39 UPD42 INS44 INS83 INS73 INS74 INS42 INS44 INS8 INS43 INS43 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS54 INS43 INS42 INS43 INS42 INS54 INS43 INS42 INS43 INS42 INS43 INS42 INS54 INS43 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS8 INS8 INS42 INS42 INS8 INS8 INS42 INS42 INS42 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS14 INS21 INS60 INS25 INS41 INS21 INS21 MOV60 MOV25 INS25 MOV41 INS21 INS21 INS60 INS25 INS25 INS41 INS21 INS74 INS1 INS32 INS43 INS59 INS27 INS8 INS25 INS32 INS32 INS32 INS27 INS8 INS32 INS32 INS43 INS59 INS27 INS8 INS27 INS8 INS9 INS32 INS43 INS43 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS42 INS42 INS42 INS42 INS40 INS21 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS41 INS27 INS27 INS21 INS25 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS78 INS79 INS83 INS74 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS78 INS83 INS74 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS7 INS42 INS40 INS21 INS21 INS32 INS32 INS42 INS40 INS42 INS33 INS32 INS34 INS9 INS42 INS40 INS42 INS40 INS7 INS27 INS8 INS27 INS8 INS42 INS42 INS45 INS43 INS43 INS74 INS42 INS41 INS42 INS42 INS74 INS42 INS39 INS42 INS41 INS42 INS43 INS43 INS43 INS41 INS42 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS43 INS43 INS43 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS43 INS43 INS43 INS41 INS42 INS41 INS42 INS42 INS41 INS42 INS32 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS41 INS42 INS40 INS21 INS25 INS42 INS42 INS43 INS43 INS32 INS43 INS43 INS33 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS33 INS34 INS33 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS33 INS32 INS34 INS9 INS7 INS27 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS41 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS32 INS34 INS9 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
HDFS-12359. Re-encryption should operate with minimum KMS ACL requirements.

-import java.io.FileNotFoundException;
-import org.apache.hadoop.crypto.key.KeyProvider.KeyVersion;
+import org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.CryptoExtension;
-  static void reencryptEncryptionZone(final FSDirectory fsd,
-      final String zone, final String keyVersionName,
-      final boolean logRetryCache) throws IOException {
-    final List<XAttr> xAttrs = Lists.newArrayListWithCapacity(1);
-    final FSPermissionChecker pc = fsd.getPermissionChecker();
-    fsd.writeLock();
-    try {
-      final INodesInPath iip = fsd.resolvePath(pc, zone, DirOp.WRITE);
-      final XAttr xattr = fsd.ezManager
-          .reencryptEncryptionZone(iip, keyVersionName);
-      xAttrs.add(xattr);
-    } finally {
-      fsd.writeUnlock();
-    }
-    fsd.getEditLog().logSetXAttrs(zone, xAttrs, logRetryCache);
+  static List<XAttr> reencryptEncryptionZone(final FSDirectory fsd,
+      final INodesInPath iip, final String keyVersionName) throws IOException {
+    assert keyVersionName != null;
+    return fsd.ezManager.reencryptEncryptionZone(iip, keyVersionName);
-  static void cancelReencryptEncryptionZone(final FSDirectory fsd,
-      final String zone, final boolean logRetryCache) throws IOException {
-    final List<XAttr> xattrs;
-    final FSPermissionChecker pc = fsd.getPermissionChecker();
-    fsd.writeLock();
-    try {
-      final INodesInPath iip = fsd.resolvePath(pc, zone, DirOp.WRITE);
-      xattrs = fsd.ezManager.cancelReencryptEncryptionZone(iip);
-    } finally {
-      fsd.writeUnlock();
-    }
-    if (xattrs != null && !xattrs.isEmpty()) {
-      fsd.getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);
-    }
+  static List<XAttr> cancelReencryptEncryptionZone(final FSDirectory fsd,
+      final INodesInPath iip) throws IOException {
+    return fsd.ezManager.cancelReencryptEncryptionZone(iip);
-   * Get the last key version name for the given EZ. This will contact
-   * the KMS to getKeyVersions.
-   * @param zone the encryption zone
-   * @param pc the permission checker
-   * @return the last element from the list of keyVersionNames returned by KMS.
-   * @throws IOException
+   * Get the current key version name for the given EZ. This will first drain
+   * the provider's local cache, then generate a new edek.
+   * <p>
+   * The encryption key version of the newly generated edek will be used as
+   * the target key version of this re-encryption - meaning all edeks'
+   * keyVersion are compared with it, and only sent to the KMS for re-encryption
+   * when the version is different.
+   * <p>
+   * Note: KeyProvider has a getCurrentKey interface, but that is under
+   * a different ACL. HDFS should not try to operate on additional ACLs, but
+   * rather use the generate ACL it already has.
-  static KeyVersion getLatestKeyVersion(final FSDirectory dir,
-      final String zone, final FSPermissionChecker pc) throws IOException {
-    final EncryptionZone ez;
+  static String getCurrentKeyVersion(final FSDirectory dir, final String zone)
+      throws IOException {
+    assert !dir.hasReadLock();
+    final String keyName = FSDirEncryptionZoneOp.getKeyNameForZone(dir, zone);
+    if (keyName == null) {
+      throw new IOException(zone + " is not an encryption zone.");
+    }
+    // drain the local cache of the key provider.
+    // Do not invalidateCache on the server, since that's the responsibility
+    // when rolling the key version.
+    if (dir.getProvider() instanceof CryptoExtension) {
+      ((CryptoExtension) dir.getProvider()).drain(keyName);
+    }
+    final EncryptedKeyVersion edek;
+    try {
+      edek = dir.getProvider().generateEncryptedKey(keyName);
+    } catch (GeneralSecurityException gse) {
+      throw new IOException(gse);
+    }
+    Preconditions.checkNotNull(edek);
+    return edek.getEncryptionKeyVersionName();
+  }
+
+  /**
+   * Resolve the zone to an inode, find the encryption zone info associated with
+   * that inode, and return the key name. Does not contact the KMS.
+   */
+  static String getKeyNameForZone(final FSDirectory dir, final String zone)
+      throws IOException {
+    assert dir.getProvider() != null;
+    final INodesInPath iip;
+    final FSPermissionChecker pc = dir.getPermissionChecker();
-      final INodesInPath iip = dir.resolvePath(pc, zone, DirOp.READ);
-      if (iip.getLastINode() == null) {
-        throw new FileNotFoundException(zone + " does not exist.");
-      }
-      dir.ezManager.checkEncryptionZoneRoot(iip.getLastINode(), iip.getPath());
-      ez = FSDirEncryptionZoneOp.getEZForPath(dir, iip);
+      iip = dir.resolvePath(pc, zone, DirOp.READ);
+      dir.ezManager.checkEncryptionZoneRoot(iip.getLastINode(), zone);
+      return dir.ezManager.getKeyName(iip);
-    // Contact KMS out of locks.
-    KeyVersion currKv = dir.getProvider().getCurrentKey(ez.getKeyName());
-    Preconditions.checkNotNull(currKv,
-        "No current key versions for key name " + ez.getKeyName());
-    return currKv;

MOV26 UPD40 INS31 INS31 INS31 MOV83 MOV74 MOV42 MOV44 MOV44 MOV44 MOV43 INS8 INS83 MOV74 INS42 MOV44 INS44 MOV43 INS8 INS29 INS83 INS43 INS42 INS44 MOV44 INS43 INS8 UPD43 UPD42 MOV60 MOV43 UPD42 INS6 INS41 INS83 MOV43 INS42 INS41 INS65 INS42 INS83 INS43 INS42 INS42 INS6 INS6 MOV60 INS25 INS25 MOV60 MOV54 INS21 INS41 UPD42 INS60 INS54 INS27 MOV32 MOV32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 MOV42 INS27 INS38 INS43 INS27 INS8 INS62 INS8 UPD43 INS12 INS32 INS32 UPD66 UPD66 MOV43 MOV83 MOV43 INS59 INS8 MOV8 INS42 INS33 INS32 INS33 INS32 INS42 UPD42 INS42 INS33 INS53 INS32 INS43 MOV21 UPD42 UPD42 INS44 INS8 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 INS32 INS21 MOV21 INS41 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 INS14 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS42 INS53 UPD42 MOV42 UPD42 MOV42 INS7 INS32 INS43 INS27 INS36 UPD42 UPD42 UPD42 MOV32 INS42 INS14 INS42 MOV32 UPD42 MOV42 INS40 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS45 INS11 UPD42 UPD42 MOV42 INS43 INS42 INS43 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 DEL40 DEL26 DEL39 DEL39 DEL83 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL43 DEL42 DEL32 DEL59 DEL60 DEL32 DEL21 DEL83 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL32 DEL38 DEL27 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL40 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL83 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL54 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL41
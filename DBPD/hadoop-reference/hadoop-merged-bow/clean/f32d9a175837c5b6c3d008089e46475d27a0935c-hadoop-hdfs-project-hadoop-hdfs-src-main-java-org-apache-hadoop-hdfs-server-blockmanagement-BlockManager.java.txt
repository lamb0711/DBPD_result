HDFS-8619. Erasure Coding: revisit replica counting for striped blocks. (Jing Zhao via yliu)

-   * 
-   * @param b
+   * Mark a replica (of a contiguous block) or an internal block (of a striped
+   * block group) as corrupt.
+   * @param b Indicating the reported bad block and the corresponding BlockInfo
+   *          stored in blocksMap.
-   * @throws IOException
-    // Add this replica to corruptReplicas Map
-    corruptReplicas.addToCorruptReplicasMap(b.corrupted, node, b.reason,
+    // Add this replica to corruptReplicas Map. For striped blocks, we always
+    // use the id of whole striped block group when adding to corruptReplicas
+    Block corrupted = new Block(b.corrupted);
+    if (b.stored.isStriped()) {
+      corrupted.setBlockId(b.stored.getBlockId());
+    }
+    corruptReplicas.addToCorruptReplicasMap(corrupted, node, b.reason,
-      invalidateBlock(b, node);
+      invalidateBlock(b, node, numberOfReplicas);
-  private boolean invalidateBlock(BlockToMarkCorrupt b, DatanodeInfo dn
-      ) throws IOException {
+  private boolean invalidateBlock(BlockToMarkCorrupt b, DatanodeInfo dn,
+      NumberReplicas nr) throws IOException {
-    NumberReplicas nr = countNodes(b.stored);
-    } else if (nr.liveReplicas() >= 1) {
-      // If we have at least one copy on a live node, then we can delete it.
+    } else {
+      // we already checked the number of replicas in the caller of this
+      // function and know there are enough live replicas, so we can delete it.
-    } else {
-      blockLog.info("BLOCK* invalidateBlocks: {} on {} is the only copy and" +
-          " was not deleted", b, dn);
-      return false;
-      invalidateCorruptReplicas(storedBlock, reportedBlock);
+      invalidateCorruptReplicas(storedBlock, reportedBlock, num);
-  private void invalidateCorruptReplicas(BlockInfo blk, Block reported) {
+  private void invalidateCorruptReplicas(BlockInfo blk, Block reported,
+      NumberReplicas numberReplicas) {
-    DatanodeDescriptor[] nodesCopy = nodes.toArray(new DatanodeDescriptor[0]);
+    DatanodeDescriptor[] nodesCopy =
+        nodes.toArray(new DatanodeDescriptor[nodes.size()]);
-              Reason.ANY), node)) {
+            Reason.ANY), node, numberReplicas)) {

INS44 INS44 INS65 INS60 INS25 MOV43 INS42 MOV25 INS43 INS42 INS66 INS66 INS66 INS66 INS43 INS59 INS32 INS8 MOV27 MOV8 INS42 MOV5 INS42 INS42 INS14 INS40 INS42 INS21 INS42 INS43 INS40 INS32 INS42 INS42 INS42 INS32 INS42 INS42 MOV5 INS32 INS40 INS42 INS42 INS42 INS42 DEL42 DEL65 DEL40 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL25 DEL34
YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.

-      if (mapping.getType() == MappingType.USER) {
+      if (mapping.getType().equals(MappingType.USER)) {
-      if (mapping.getType() == MappingType.GROUP) {
+      if (mapping.getType().equals(MappingType.GROUP)) {
-    String group = getPrimaryGroup(user);
+    String group =
+        CapacitySchedulerConfiguration.ROOT + "." + getPrimaryGroup(user);
-      if (this.queueManager.getQueue(group) != null) {
-        return getPlacementContext(mapping, group);
+      CSQueue queue = this.queueManager.getQueue(group);
+      if ( queue != null) {
+        return getPlacementContext(mapping, queue.getQueuePath());
-      if (this.queueManager.getQueue(secondaryGroup) != null) {
-        return getPlacementContext(mapping, secondaryGroup);
+      CSQueue queue = this.queueManager.getQueue(secondaryGroup);
+      if ( queue != null) {
+        return getPlacementContext(mapping, queue.getQueuePath());
-                            .parentQueue(group)
+                            .parentQueue(
+                                CapacitySchedulerConfiguration.ROOT + "." +
+                                group)
-      QueueMapping mapping) {
+      QueueMapping mapping) throws IOException {
-      String leafQueueName) {
+      String leafQueueName) throws IOException {
+
+    //leafQueue name no longer identifies a queue uniquely checking ambiguity
+    if (!mapping.hasParentQueue() && queueManager.isAmbiguous(leafQueueName)) {
+      throw new IOException("mapping contains ambiguous leaf queue reference " +
+          leafQueueName);
+    }
+
+      //at this point mapping.getQueueName() return only the queue name, since
+      //the config parsing have been changed making QueueMapping more consistent
-      QueuePath queuePath = QueuePlacementRuleUtils
-              .extractQueuePath(mapping.getQueue());
+      QueuePath queuePath = mapping.getQueuePath();
-        //Try getting queue by its leaf queue name
-        // without splitting into parent/leaf queues
-        CSQueue queue = queueManager.getQueue(mapping.getQueue());
+        //Try getting queue by its full path name, if it exists it is a static
+        //leaf queue indeed, without any auto creation magic
+        CSQueue queue = queueManager.getQueue(mapping.getFullPath());
-          //Try getting the queue by extracting leaf and parent queue names
-          //Assuming its a potential auto created leaf queue
-          queue = queueManager.getQueue(queuePath.getLeafQueue());
-
-          if (ifQueueDoesNotExist(queue)) {
-            //if leaf queue does not exist,
-            // this could be a potential auto created leaf queue
-            //validate if parent queue is specified,
-            // then it should exist and
-            // be an instance of AutoCreateEnabledParentQueue
-            QueueMapping newMapping = validateAndGetAutoCreatedQueueMapping(
-                queueManager, mapping, queuePath);
-            if (newMapping == null) {
-              throw new IOException(
-                  "mapping contains invalid or non-leaf queue " + mapping
-                      .getQueue());
-            }
-            newMappings.add(newMapping);
-          } else{
-            QueueMapping newMapping = validateAndGetQueueMapping(queueManager,
-                queue, mapping, queuePath);
-            newMappings.add(newMapping);
+          //We might not be able to find the queue, because the reference was
+          // ambiguous this should only happen if the queue was referenced by
+          // leaf name only
+          if (queueManager.isAmbiguous(mapping.getFullPath())) {
+            throw new IOException(
+              "mapping contains ambiguous leaf queue reference " + mapping
+                .getFullPath());
-        } else{
+
+          //if leaf queue does not exist,
+          // this could be a potential auto created leaf queue
+          //validate if parent queue is specified,
+          // then it should exist and
+          // be an instance of AutoCreateEnabledParentQueue
+          QueueMapping newMapping = validateAndGetAutoCreatedQueueMapping(
+              queueManager, mapping, queuePath);
+          if (newMapping == null) {
+            throw new IOException(
+                "mapping contains invalid or non-leaf queue " + mapping
+                    .getQueue());
+          }
+          newMappings.add(newMapping);
+        } else {
-          "mapping contains invalid or non-leaf queue : " + mapping.getQueue());
+          "mapping contains invalid or non-leaf queue : " +
+          mapping.getFullPath());
-            "mapping contains invalid or non-leaf queue " + mapping.getQueue());
+            "mapping contains invalid or non-leaf queue "
+            + mapping.getFullPath());
-    String leafQueueName = queueMapping.getQueue();
-    CSQueue parentQueue = queueManager.getQueue(parentQueueName);
-    CSQueue leafQueue = queueManager.getQueue(leafQueueName);
+    String leafQueueFullName = queueMapping.getFullPath();
+    CSQueue parentQueue = queueManager.getQueueByFullName(parentQueueName);
+    CSQueue leafQueue = queueManager.getQueue(leafQueueFullName);
-      throw new IOException("mapping contains invalid or non-leaf queue : "
-          + leafQueueName);
+      //this might be confusing, but a mapping is not guaranteed to provide the
+      //parent queue's name, which can result in ambiguous queue references
+      //if no parent queueName is provided mapping.getFullPath() is the same
+      //as mapping.getQueue()
+      if (leafQueue == null && queueManager.isAmbiguous(leafQueueFullName)) {
+        throw new IOException("mapping contains ambiguous leaf queue name: "
+          + leafQueueFullName);
+      } else {
+        throw new IOException("mapping contains invalid or non-leaf queue : "
+          + leafQueueFullName);
+      }
-    } else if (!parentQueue.getQueueName()
-        .equals(leafQueue.getParent().getQueueName())) {
+    } else if (!parentQueue.getQueuePath()
+        .equals(leafQueue.getParent().getQueuePath())) {
-          + parentQueue.getQueueName() + "] does not match [ "
-          + leafQueue.getParent().getQueueName() + "]");
+          + parentQueue.getQueuePath() + "] does not match [ "
+          + leafQueue.getParent().getQueuePath() + "]");

INS43 INS43 MOV8 INS42 INS42 INS25 MOV25 MOV60 MOV60 MOV60 MOV21 MOV60 MOV60 MOV21 INS70 MOV25 MOV41 INS27 INS8 MOV44 INS42 MOV8 MOV43 MOV43 INS8 INS27 INS60 INS25 INS60 INS38 INS32 INS53 MOV21 UPD42 INS25 INS32 INS32 INS40 INS45 MOV32 INS43 INS59 INS27 MOV8 MOV8 INS43 INS59 INS32 INS42 INS42 INS42 INS14 MOV43 MOV32 MOV7 UPD42 UPD42 UPD42 INS27 INS8 MOV8 MOV32 INS42 INS40 MOV32 INS42 INS40 INS42 INS42 INS32 INS42 MOV33 INS42 INS42 MOV32 INS42 INS42 INS42 INS43 INS27 UPD42 INS32 INS60 MOV25 INS27 INS32 INS53 MOV22 MOV42 MOV42 INS42 INS45 INS42 MOV42 UPD42 MOV42 MOV43 INS59 MOV59 UPD42 MOV42 INS42 INS33 INS42 INS42 INS42 INS14 MOV32 INS32 INS32 INS27 INS42 INS32 INS25 INS21 UPD42 MOV42 UPD42 MOV43 INS27 INS43 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS45 INS42 MOV42 MOV42 MOV32 INS32 INS8 UPD42 MOV42 MOV42 MOV32 MOV32 INS45 INS42 INS42 UPD42 MOV32 UPD42 UPD42 INS42 INS42 INS32 INS53 MOV42 UPD42 UPD42 UPD42 INS42 INS42 INS14 INS43 INS27 INS42 INS45 INS32 INS42 INS42 DEL40 DEL27 DEL40 DEL27 DEL32 DEL27 DEL25 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL25 DEL42 DEL70 DEL8
HDFS-2273.  Refactor BlockManager.recentInvalidateSets to a new class.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1160475 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-  private volatile long pendingDeletionBlocksCount = 0L;
-    return pendingDeletionBlocksCount;
+    return invalidateBlocks.numBlocks();
-  //
-  // Keeps a Collection for every named machine containing
-  // blocks that have recently been invalidated and are thought to live
-  // on the machine in question.
-  // Mapping: StorageID -> ArrayList<Block>
-  //
-  private final Map<String, Collection<Block>> recentInvalidateSets =
-    new TreeMap<String, Collection<Block>>();
+  /** Blocks to be invalidated. */
+  private final InvalidateBlocks invalidateBlocks;
+    invalidateBlocks = new InvalidateBlocks(datanodeManager);
+  /** Dump meta data to out. */
+    assert namesystem.hasWriteLock();
-    dumpRecentInvalidateSets(out);
+    invalidateBlocks.dump(out);
-      removeFromInvalidates(datanodeId, oldBlock);
+      invalidateBlocks.remove(datanodeId, oldBlock);
-      if( ! belongsToInvalidates(storageID, block)) {
+      if(!invalidateBlocks.contains(storageID, block)) {
-    removeFromInvalidates(node.getStorageID());
-  }
-  
-  private void removeFromInvalidates(String storageID, Block block) {
-    synchronized(recentInvalidateSets) {
-      Collection<Block> v = recentInvalidateSets.get(storageID);
-      if (v != null && v.remove(block)) {
-        pendingDeletionBlocksCount--;
-        if (v.isEmpty()) {
-          recentInvalidateSets.remove(storageID);
-        }
-      }
-    }
-  }
-
-  boolean belongsToInvalidates(String storageID, Block block) {
-    Collection<Block> invalidateSet;
-    synchronized(recentInvalidateSets) {
-      invalidateSet = recentInvalidateSets.get(storageID);
-      return invalidateSet != null && invalidateSet.contains(block);
-    }
-  }
-
-  /**
-   * Adds block to list of blocks which will be invalidated on specified
-   * datanode
-   *
-   * @param b block
-   * @param dn datanode
-   * @param log true to create an entry in the log 
-   */
-  private void addToInvalidates(Block b, DatanodeInfo dn, boolean log) {
-    synchronized(recentInvalidateSets) {
-      Collection<Block> invalidateSet = recentInvalidateSets
-          .get(dn.getStorageID());
-      if (invalidateSet == null) {
-        invalidateSet = new HashSet<Block>();
-        recentInvalidateSets.put(dn.getStorageID(), invalidateSet);
-      }
-      if (invalidateSet.add(b)) {
-        pendingDeletionBlocksCount++;
-        if (log) {
-          NameNode.stateChangeLog.info("BLOCK* addToInvalidates: "
-              + b + " to " + dn.getName());
-        }
-      }
-    }
+    invalidateBlocks.remove(node.getStorageID());
-   *
-   * @param b block
-   * @param dn datanode
-  void addToInvalidates(Block b, DatanodeInfo dn) {
-    addToInvalidates(b, dn, true);
+  void addToInvalidates(final Block block, final DatanodeInfo datanode) {
+    invalidateBlocks.add(block, datanode, true);
-      addToInvalidates(b, node, false);
+      invalidateBlocks.add(b, node, false);
-   * dumps the contents of recentInvalidateSets
-   */
-  private void dumpRecentInvalidateSets(PrintWriter out) {
-    assert namesystem.hasWriteLock();
-    int size;
-    synchronized(recentInvalidateSets) {
-      size = recentInvalidateSets.values().size();
-    }
-    out.println("Metasave: Blocks " + pendingDeletionBlocksCount 
-        + " waiting deletion from " + size + " datanodes.");
-    if (size == 0) {
-      return;
-    }
-    synchronized(recentInvalidateSets) {
-      for(Map.Entry<String,Collection<Block>> entry : recentInvalidateSets.entrySet()) {
-        Collection<Block> blocks = entry.getValue();
-        if (blocks.size() > 0) {
-          out.println(datanodeManager.getDatanode(entry.getKey()).getName() + blocks);
-        }
-      }
-    }
-  }
-
-  /**
-    int numOfNodes;
-    ArrayList<String> keyArray;
+    final List<String> nodes = invalidateBlocks.getStorageIDs();
+    Collections.shuffle(nodes);
-    synchronized(recentInvalidateSets) {
-      numOfNodes = recentInvalidateSets.size();
-      // get an array of the keys
-      keyArray = new ArrayList<String>(recentInvalidateSets.keySet());
-    }
-
-    nodesToProcess = Math.min(numOfNodes, nodesToProcess);
-
-    // randomly pick up <i>nodesToProcess</i> nodes
-    // and put them at [0, nodesToProcess)
-    int remainingNodes = numOfNodes - nodesToProcess;
-    if (nodesToProcess < remainingNodes) {
-      for(int i=0; i<nodesToProcess; i++) {
-        int keyIndex = DFSUtil.getRandom().nextInt(numOfNodes-i)+i;
-        Collections.swap(keyArray, keyIndex, i); // swap to front
-      }
-    } else {
-      for(int i=0; i<remainingNodes; i++) {
-        int keyIndex = DFSUtil.getRandom().nextInt(numOfNodes-i);
-        Collections.swap(keyArray, keyIndex, numOfNodes-i-1); // swap to end
-      }
-    }
+    nodesToProcess = Math.min(nodes.size(), nodesToProcess);
-      blockCnt += invalidateWorkForOneNode(keyArray.get(nodeCnt));
+      blockCnt += invalidateWorkForOneNode(nodes.get(nodeCnt));
-    if(belongsToInvalidates(dn.getStorageID(), block)) {
+    if(invalidateBlocks.contains(dn.getStorageID(), block)) {
-    return blocksMap.size() - (int)pendingDeletionBlocksCount;
+    return blocksMap.size() - (int)invalidateBlocks.numBlocks();
-  /** Remove a datanode from the invalidatesSet */
-  private void removeFromInvalidates(String storageID) {
-    Collection<Block> blocks;
-    synchronized(recentInvalidateSets) {
-      blocks = recentInvalidateSets.remove(storageID);
-    }
-    if (blocks != null) {
-      pendingDeletionBlocksCount -= blocks.size();
-    }
-  }
-      final DatanodeDescriptor dn = datanodeManager.getDatanode(nodeId);
-      if (dn == null) {
-        removeFromInvalidates(nodeId);
-        return 0;
-      }
-
-      Collection<Block> invalidateSet;
-      ArrayList<Block> blocksToInvalidate;
-      synchronized(recentInvalidateSets) {
-        invalidateSet = recentInvalidateSets.get(nodeId);
-        if (invalidateSet == null)
-          return 0;
-
-        blocksToInvalidate = new ArrayList<Block>(
-          getDatanodeManager().blockInvalidateLimit);
-
-        // # blocks that can be sent in one message is limited
-        Iterator<Block> it = invalidateSet.iterator();
-        for (int blkCount = 0; blkCount < getDatanodeManager().blockInvalidateLimit
-            && it.hasNext(); blkCount++) {
-          blocksToInvalidate.add(it.next());
-          it.remove();
-        }
-
-        // If we send everything in this message, remove this node entry
-        if (!it.hasNext()) {
-          removeFromInvalidates(nodeId);
-        }
-
-        dn.addBlocksToBeInvalidated(blocksToInvalidate);
-
-        if (NameNode.stateChangeLog.isInfoEnabled()) {
-          StringBuilder blockList = new StringBuilder();
-          for (Block blk : blocksToInvalidate) {
-            blockList.append(' ');
-            blockList.append(blk);
-          }
-          NameNode.stateChangeLog.info("BLOCK* ask " + dn.getName()
-              + " to delete " + blockList);
-        }
-        pendingDeletionBlocksCount -= blocksToInvalidate.size();
-        return blocksToInvalidate.size();
-      }
+      return invalidateBlocks.invalidateWork(nodeId);

INS31 INS23 MOV29 MOV83 MOV39 MOV42 INS8 INS29 INS83 INS83 INS43 INS59 INS29 MOV44 MOV41 MOV65 UPD42 MOV42 UPD42 MOV42 INS21 INS65 MOV6 INS83 UPD42 INS83 UPD42 INS60 MOV21 INS32 UPD66 INS7 INS66 INS83 UPD74 MOV74 INS59 INS32 MOV32 INS8 UPD42 MOV42 UPD42 MOV42 INS42 INS14 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 UPD42 UPD43 INS42 INS32 INS42 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV25 MOV6 INS41 INS43 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS32 INS42 UPD42 INS42 UPD42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 INS42 UPD42 DEL40 DEL26 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL42 DEL33 DEL27 DEL42 DEL32 DEL27 DEL42 DEL41 DEL8 DEL31 DEL66 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL14 DEL59 DEL23 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL37 DEL21 DEL42 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL51 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL34 DEL27 DEL41 DEL8 DEL25 DEL42 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL14 DEL7 DEL39 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL51 DEL39 DEL42 DEL42 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL27 DEL32 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL27 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL51 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL34 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL34 DEL41 DEL25 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL42 DEL22 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL22 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL40 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8
YARN-8018.  Added support for initiating yarn service upgrade.
            Contributed by Chandni Singh

+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.yarn.proto.ClientAMProtocol.RestartServiceRequestProto;
+import org.apache.hadoop.yarn.proto.ClientAMProtocol.UpgradeServiceRequestProto;
-import org.apache.hadoop.yarn.service.utils.SliderFileSystem;
+import org.apache.hadoop.yarn.service.utils.SliderFileSystem;
+  @Override
-    Path appDir = checkAppNotExistOnHdfs(service);
-    createDirAndPersistApp(appDir, service);
+    Path appDir = checkAppNotExistOnHdfs(service, false);
+    ServiceApiUtil.createDirAndPersistApp(fs, appDir, service);
+    return EXIT_SUCCESS;
+  }
+
+  @Override
+  public int actionUpgrade(String appName, String fileName)
+      throws IOException, YarnException {
+    checkAppExistOnHdfs(appName);
+    Service upgradeService = loadAppJsonFromLocalFS(fileName, appName,
+        null, null);
+    return actionUpgrade(upgradeService);
+  }
+
+  public int actionUpgrade(Service service) throws YarnException, IOException {
+    Service persistedService =
+        ServiceApiUtil.loadService(fs, service.getName());
+    if (!StringUtils.isEmpty(persistedService.getId())) {
+      cachedAppInfo.put(persistedService.getName(), new AppInfo(
+          ApplicationId.fromString(persistedService.getId()),
+          persistedService.getKerberosPrincipal().getPrincipalName()));
+    }
+
+    if (persistedService.getVersion().equals(service.getVersion())) {
+      String message =
+          service.getName() + " is already at version " + service.getVersion()
+              + ". There is nothing to upgrade.";
+      LOG.error(message);
+      throw new YarnException(message);
+    }
+
+    Path serviceUpgradeDir = checkAppNotExistOnHdfs(service, true);
+    ServiceApiUtil.validateAndResolveService(service, fs, getConfig());
+    ServiceApiUtil.createDirAndPersistApp(fs, serviceUpgradeDir, service);
+
+    ApplicationReport appReport =
+        yarnClient.getApplicationReport(getAppId(service.getName()));
+    if (StringUtils.isEmpty(appReport.getHost())) {
+      throw new YarnException(service.getName() + " AM hostname is empty");
+    }
+    ClientAMProtocol proxy = createAMProxy(service.getName(), appReport);
+
+    UpgradeServiceRequestProto.Builder requestBuilder =
+        UpgradeServiceRequestProto.newBuilder();
+    requestBuilder.setVersion(service.getVersion());
+
+    proxy.upgrade(requestBuilder.build());
-    Path appDir = checkAppNotExistOnHdfs(service);
+    Path appDir = checkAppNotExistOnHdfs(service, false);
-    createDirAndPersistApp(appDir, service);
+    ServiceApiUtil.createDirAndPersistApp(fs, appDir, service);
-    persistAppDef(appDir, service);
+    ServiceApiUtil.writeAppDefinition(fs, appDir, service);
+  @Override
+  @Override
-  private ApplicationId submitApp(Service app)
-      throws IOException, YarnException {
+  @VisibleForTesting
+  ApplicationId submitApp(Service app) throws IOException, YarnException {
+  @Override
-    Path appDir = checkAppExistOnHdfs(serviceName);
-    Service service = ServiceApiUtil.loadService(fs, serviceName);
-    ServiceApiUtil.validateAndResolveService(service, fs, getConfig());
-    // see if it is actually running and bail out;
-    verifyNoLiveAppInRM(serviceName, "start");
-    ApplicationId appId = submitApp(service);
-    service.setId(appId.toString());
-    // write app definition on to hdfs
-    Path appJson = persistAppDef(appDir, service);
-    LOG.info("Persisted service " + service.getName() + " at " + appJson);
-    return 0;
+    Service liveService = getStatus(serviceName);
+    if (liveService == null ||
+        !liveService.getState().equals(ServiceState.UPGRADING)) {
+      Path appDir = checkAppExistOnHdfs(serviceName);
+      Service service = ServiceApiUtil.loadService(fs, serviceName);
+      ServiceApiUtil.validateAndResolveService(service, fs, getConfig());
+      // see if it is actually running and bail out;
+      verifyNoLiveAppInRM(serviceName, "start");
+      ApplicationId appId = submitApp(service);
+      service.setId(appId.toString());
+      // write app definition on to hdfs
+      Path appJson = ServiceApiUtil.writeAppDefinition(fs, appDir, service);
+      LOG.info("Persisted service " + service.getName() + " at " + appJson);
+      return 0;
+    } else {
+      LOG.info("Finalize service {} upgrade");
+      ApplicationReport appReport =
+          yarnClient.getApplicationReport(getAppId(serviceName));
+      if (StringUtils.isEmpty(appReport.getHost())) {
+        throw new YarnException(serviceName + " AM hostname is empty");
+      }
+      ClientAMProtocol proxy = createAMProxy(serviceName, appReport);
+
+      RestartServiceRequestProto.Builder requestBuilder =
+          RestartServiceRequestProto.newBuilder();
+      proxy.restart(requestBuilder.build());
+      return 0;
+    }
-  private Path checkAppNotExistOnHdfs(Service service)
+  /**
+   * Verifies that the service definition does not exist on hdfs.
+   *
+   * @param service   service
+   * @param isUpgrade true for upgrades; false otherwise
+   * @return path to the service definition..
+   * @throws IOException
+   * @throws SliderException
+   */
+  private Path checkAppNotExistOnHdfs(Service service, boolean isUpgrade)
-    Path appDir = fs.buildClusterDirPath(service.getName());
+    Path appDir = !isUpgrade ? fs.buildClusterDirPath(service.getName()) :
+        fs.buildClusterUpgradeDirPath(service.getName(), service.getVersion());
+  /**
+   * Verifies that the service exists on hdfs.
+   * @param serviceName service name
+   * @return path to the service definition.
+   * @throws IOException
+   * @throws SliderException
+   */
-  private void createDirAndPersistApp(Path appDir, Service service)
-      throws IOException, SliderException {
-    FsPermission appDirPermission = new FsPermission("750");
-    fs.createWithPermissions(appDir, appDirPermission);
-    Path appJson = persistAppDef(appDir, service);
-    LOG.info("Persisted service " + service.getName() + " at " + appJson);
-  }
-
-  private Path persistAppDef(Path appDir, Service service) throws IOException {
-    Path appJson = new Path(appDir, service.getName() + ".json");
-    jsonSerDeser.save(fs.getFileSystem(), appJson, service, true);
-    return appJson;
-  }
-
+  @VisibleForTesting
+  void setFileSystem(SliderFileSystem fileSystem)
+      throws IOException {
+    this.fs = fileSystem;
+  }
+
+  @VisibleForTesting
+  void setYarnClient(YarnClient yarnClient) {
+    this.yarnClient = yarnClient;
+  }
+

MOV26 INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS78 INS78 UPD83 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 INS44 MOV43 UPD43 MOV43 INS8 INS83 INS39 INS42 MOV44 INS43 MOV43 INS8 INS78 INS78 INS78 INS78 INS8 INS29 INS44 INS29 INS78 INS39 INS42 INS44 INS43 INS8 INS78 INS39 INS42 INS44 INS8 INS42 INS21 INS42 UPD43 UPD42 INS43 INS42 UPD42 INS21 MOV60 INS41 INS42 MOV60 INS25 INS25 INS60 MOV21 INS21 MOV60 INS25 INS60 INS60 INS21 INS21 MOV41 INS42 INS42 INS42 INS42 MOV21 INS60 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS21 INS42 INS43 INS42 INS21 INS32 UPD42 INS42 INS32 UPD43 INS32 UPD43 INS38 INS8 INS32 INS8 MOV43 INS59 INS32 UPD43 INS32 INS8 INS43 INS59 INS43 INS59 INS32 INS32 UPD42 INS43 INS43 INS59 INS27 MOV8 INS8 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS7 INS42 INS7 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS32 INS21 INS32 INS42 INS32 INS60 INS21 INS53 INS42 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 MOV32 INS53 INS42 INS42 INS32 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS32 INS27 INS38 INS21 INS60 INS25 INS60 INS60 INS21 INS41 INS16 INS22 INS42 INS22 INS42 INS42 INS9 INS42 INS42 INS42 INS33 INS33 UPD42 UPD42 INS42 INS32 UPD42 MOV42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS9 INS42 INS42 INS32 UPD42 UPD42 MOV14 INS42 INS32 UPD42 MOV42 INS42 INS42 MOV42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS33 INS32 INS32 INS43 INS59 INS32 INS8 INS43 INS59 INS43 INS59 INS32 INS34 INS38 MOV32 INS32 INS52 INS42 INS52 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS32 UPD43 INS42 INS42 INS32 INS42 INS40 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS53 INS42 INS42 INS32 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS43 INS32 INS32 MOV32 UPD45 MOV45 INS32 INS45 UPD42 MOV42 INS42 INS42 UPD42 UPD45 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS45 DEL42 DEL43 DEL45 DEL14 DEL42 DEL83 DEL42 DEL42 DEL32 DEL21 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL9 DEL32 DEL21 DEL8 DEL31
Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
+import org.apache.hadoop.yarn.api.records.ApplicationAccessType;
+import org.apache.hadoop.yarn.server.nodemanager.Context;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.AuxServicesEvent;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.AuxServicesEventType;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.ResourceLocalizationService;
-import org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.event.LogAggregatorAppFinishedEvent;
-import org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.event.LogAggregatorAppStartedEvent;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.loghandler.event.LogHandlerAppFinishedEvent;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.loghandler.event.LogHandlerAppStartedEvent;
+import org.apache.hadoop.yarn.server.security.ApplicationACLsManager;
-import org.apache.hadoop.yarn.util.ConverterUtils;
+/**
+ * The state machine for the representation of an Application
+ * within the NodeManager.
+ */
+  Map<ApplicationAccessType, String> applicationACLs;
+  final ApplicationACLsManager aclsManager;
+  private final ReadLock readLock;
+  private final WriteLock writeLock;
+  private final Context context;
-  public ApplicationImpl(Dispatcher dispatcher, String user,
-      ApplicationId appId, Credentials credentials) {
+  public ApplicationImpl(Dispatcher dispatcher,
+      ApplicationACLsManager aclsManager, String user, ApplicationId appId,
+      Credentials credentials, Context context) {
+    this.aclsManager = aclsManager;
+    this.context = context;
+    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+    readLock = lock.readLock();
+    writeLock = lock.writeLock();
-  public synchronized ApplicationState getApplicationState() {
-    // TODO: Synchro should be at statemachine level.
-    // This is only for tests?
-    return this.stateMachine.getCurrentState();
+  public ApplicationState getApplicationState() {
+    this.readLock.lock();
+    try {
+      return this.stateMachine.getCurrentState();
+    } finally {
+      this.readLock.unlock();
+    }
-    return this.containers;
+    this.readLock.lock();
+    try {
+      return this.containers;
+    } finally {
+      this.readLock.unlock();
+    }
+           .addTransition(ApplicationState.NEW, ApplicationState.NEW,
+               ApplicationEventType.INIT_CONTAINER,
+               new InitContainerTransition())
-               ApplicationEventType.INIT_APPLICATION,
-               new AppIsInitingTransition())
+               ApplicationEventType.INIT_CONTAINER,
+               new InitContainerTransition())
-               ApplicationEventType.INIT_APPLICATION,
-               new DuplicateAppInitTransition())
+               ApplicationEventType.INIT_CONTAINER,
+               new InitContainerTransition())
-
+           
+           // Transitions from FINISHED state
+           .addTransition(ApplicationState.FINISHED,
+               ApplicationState.FINISHED,
+               ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED,
+               new AppLogsAggregatedTransition())
+               
+   * 
+   * In particular, this requests that the {@link ResourceLocalizationService}
+   * localize the application-scoped resources.
+  @SuppressWarnings("unchecked")
-      ApplicationInitEvent initEvent = (ApplicationInitEvent) event;
-      Container container = initEvent.getContainer();
-      app.containers.put(container.getContainerID(), container);
+      ApplicationInitEvent initEvent = (ApplicationInitEvent)event;
+      app.applicationACLs = initEvent.getApplicationACLs();
+      app.aclsManager.addApplication(app.getAppId(), app.applicationACLs);
-   * Absorb initialization events while the application initializes.
+   * Handles INIT_CONTAINER events which request that we launch a new
+   * container. When we're still in the INITTING state, we simply
+   * queue these up. When we're in the RUNNING state, we pass along
+   * an ContainerInitEvent to the appropriate ContainerImpl.
-  static class AppIsInitingTransition implements
+  @SuppressWarnings("unchecked")
+  static class InitContainerTransition implements
-      ApplicationInitEvent initEvent = (ApplicationInitEvent) event;
+      ApplicationContainerInitEvent initEvent =
+        (ApplicationContainerInitEvent) event;
+      
+      switch (app.getApplicationState()) {
+      case RUNNING:
+        app.dispatcher.getEventHandler().handle(new ContainerInitEvent(
+            container.getContainerID()));
+        break;
+      case INITING:
+      case NEW:
+        // these get queued up and sent out in AppInitDoneTransition
+        break;
+      default:
+        assert false : "Invalid state for InitContainerTransition: " +
+            app.getApplicationState();
+      }
+  @SuppressWarnings("unchecked")
-            new LogAggregatorAppStartedEvent(app.appId, app.user,
-                app.credentials,
-                ContainerLogsRetentionPolicy.ALL_CONTAINERS)); // TODO: Fix
+          new LogHandlerAppStartedEvent(app.appId, app.user,
+              app.credentials, ContainerLogsRetentionPolicy.ALL_CONTAINERS,
+              app.applicationACLs)); 
-  static class DuplicateAppInitTransition implements
-      SingleArcTransition<ApplicationImpl, ApplicationEvent> {
-    @Override
-    public void transition(ApplicationImpl app, ApplicationEvent event) {
-      ApplicationInitEvent initEvent = (ApplicationInitEvent) event;
-      Container container = initEvent.getContainer();
-      app.containers.put(container.getContainerID(), container);
-      LOG.info("Adding " + container.getContainerID()
-          + " to application " + app.toString());
-      app.dispatcher.getEventHandler().handle(new ContainerInitEvent(
-            container.getContainerID()));
-    }
-  }
+  @SuppressWarnings("unchecked")
+    // tell any auxiliary services that the app is done 
+    this.dispatcher.getEventHandler().handle(
+        new AuxServicesEvent(AuxServicesEventType.APPLICATION_STOP, appId));
+
+  @SuppressWarnings("unchecked")
+  @SuppressWarnings("unchecked")
+
-          new LogAggregatorAppFinishedEvent(app.appId));
+          new LogHandlerAppFinishedEvent(app.appId));
+
+    }
+  }
+
+  static class AppLogsAggregatedTransition implements
+      SingleArcTransition<ApplicationImpl, ApplicationEvent> {
+    @Override
+    public void transition(ApplicationImpl app, ApplicationEvent event) {
+      ApplicationId appId = event.getApplicationID();
+      app.context.getApplications().remove(appId);
+      app.aclsManager.removeApplication(appId);
-  public synchronized void handle(ApplicationEvent event) {
+  public void handle(ApplicationEvent event) {
-    ApplicationId applicationID = event.getApplicationID();
-    LOG.info("Processing " + applicationID + " of type " + event.getType());
+    this.writeLock.lock();
-    ApplicationState oldState = stateMachine.getCurrentState();
-    ApplicationState newState = null;
-      // queue event requesting init of the same app
-      newState = stateMachine.doTransition(event.getType(), event);
-    } catch (InvalidStateTransitonException e) {
-      LOG.warn("Can't handle this event at current state", e);
-    }
-    if (oldState != newState) {
-      LOG.info("Application " + applicationID + " transitioned from "
-          + oldState + " to " + newState);
+      ApplicationId applicationID = event.getApplicationID();
+      LOG.info("Processing " + applicationID + " of type " + event.getType());
+
+      ApplicationState oldState = stateMachine.getCurrentState();
+      ApplicationState newState = null;
+      try {
+        // queue event requesting init of the same app
+        newState = stateMachine.doTransition(event.getType(), event);
+      } catch (InvalidStateTransitonException e) {
+        LOG.warn("Can't handle this event at current state", e);
+      }
+      if (oldState != newState) {
+        LOG.info("Application " + applicationID + " transitioned from "
+            + oldState + " to " + newState);
+      }
+    } finally {
+      this.writeLock.unlock();
-    return ConverterUtils.toString(appId);
+    return appId.toString();

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV55 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 UPD40 MOV29 UPD83 MOV83 UPD42 MOV42 INS23 INS23 INS23 INS23 INS23 INS55 INS55 INS74 INS59 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS44 INS44 INS8 INS8 INS79 INS29 INS79 UPD42 INS79 INS79 INS79 INS79 MOV83 MOV42 MOV74 MOV31 INS83 INS42 MOV74 INS31 INS8 MOV78 UPD66 INS66 INS43 INS43 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS60 INS21 INS21 INS21 INS54 INS21 INS54 INS32 INS42 INS45 INS65 INS42 INS45 INS42 INS45 INS42 INS45 INS21 INS42 INS45 INS42 INS45 MOV78 MOV78 INS83 INS39 INS42 MOV44 MOV44 INS8 INS21 INS54 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS7 INS7 INS43 INS59 INS7 INS7 INS32 MOV8 INS8 INS32 MOV8 INS8 MOV32 INS42 INS66 INS65 INS66 INS21 INS66 INS66 INS66 INS66 INS50 INS32 INS60 INS21 INS21 INS32 MOV8 INS8 INS22 INS42 INS22 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS32 INS22 INS42 INS21 INS22 INS42 INS21 UPD42 INS40 INS40 INS40 INS14 INS42 INS7 UPD43 INS32 INS49 MOV21 INS10 INS49 INS49 INS10 INS49 INS6 INS32 INS42 INS14 INS43 INS59 INS32 INS32 INS22 INS42 INS21 UPD42 INS52 INS42 INS52 INS42 INS43 INS42 INS42 INS42 INS42 INS52 INS42 INS32 INS52 INS42 INS32 INS43 INS40 INS32 UPD40 UPD42 INS40 UPD42 INS42 INS42 INS42 INS42 INS42 INS9 INS27 INS22 INS42 INS43 INS40 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS40 INS42 INS42 INS52 INS42 INS32 INS42 INS22 INS42 INS22 INS42 INS42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD43 INS45 INS32 UPD43 INS40 INS52 INS42 INS42 UPD43 INS42 INS42 INS40 INS42 INS22 INS42 INS52 INS42 INS52 INS42 UPD42 INS42 INS42 UPD42 UPD42 INS52 INS42 UPD40 UPD43 INS32 INS42 INS40 UPD42 MOV32 MOV42 MOV40 INS40 INS40 INS14 UPD40 UPD40 UPD40 INS43 UPD43 INS42 UPD42 DEL83 DEL42 DEL83 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL83 DEL39 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL31 DEL55 DEL55 DEL83 DEL42
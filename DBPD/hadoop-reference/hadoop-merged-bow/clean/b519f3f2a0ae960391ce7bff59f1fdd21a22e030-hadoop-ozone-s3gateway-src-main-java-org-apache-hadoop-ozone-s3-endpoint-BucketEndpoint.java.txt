HDDS-659. Implement pagination in GET bucket (object list) endpoint. Contributed by Bharat Viswanadham.

-import javax.ws.rs.core.Response.ResponseBuilder;
+import org.apache.hadoop.ozone.s3.util.S3utils;
+import static org.apache.hadoop.ozone.s3.util.S3Consts.ENCODING_TYPE;
+
+      @QueryParam("continuation-token") String continueToken,
+      @QueryParam("start-after") String startAfter,
-    if (delimiter == null) {
-      delimiter = "/";
-    }
-    Iterator<? extends OzoneKey> ozoneKeyIterator = bucket.listKeys(prefix);
+    Iterator<? extends OzoneKey> ozoneKeyIterator;
+
+    String decodedToken = S3utils.decodeContinueToken(continueToken);
+
+    if (startAfter != null && continueToken != null) {
+      // If continuation token and start after both are provided, then we
+      // ignore start After
+      ozoneKeyIterator = bucket.listKeys(prefix, decodedToken);
+    } else if (startAfter != null && continueToken == null) {
+      ozoneKeyIterator = bucket.listKeys(prefix, startAfter);
+    } else if (startAfter == null && continueToken != null){
+      ozoneKeyIterator = bucket.listKeys(prefix, decodedToken);
+    } else {
+      ozoneKeyIterator = bucket.listKeys(prefix);
+    }
+
-    response.setMaxKeys(1000);
-    response.setEncodingType("url");
+    response.setMaxKeys(maxKeys);
+    response.setEncodingType(ENCODING_TYPE);
+    response.setContinueToken(continueToken);
+    String lastKey = null;
+    int count = 0;
-      int depth =
-          StringUtils.countMatches(relativeKeyName, delimiter);
+      int depth = StringUtils.countMatches(relativeKeyName, delimiter);
+      if (delimiter != null) {
+        if (depth > 0) {
+          // means key has multiple delimiters in its value.
+          // ex: dir/dir1/dir2, where delimiter is "/" and prefix is dir/
+          String dirName = relativeKeyName.substring(0, relativeKeyName
+              .indexOf(delimiter));
+          if (!dirName.equals(prevDir)) {
+            response.addPrefix(prefix + dirName + delimiter);
+            prevDir = dirName;
+            count++;
+          }
+        } else if (relativeKeyName.endsWith(delimiter)) {
+          // means or key is same as prefix with delimiter at end and ends with
+          // delimiter. ex: dir/, where prefix is dir and delimiter is /
+          response.addPrefix(relativeKeyName);
+          count++;
+        } else {
+          // means our key is matched with prefix if prefix is given and it
+          // does not have any common prefix.
+          addKey(response, next);
+          count++;
+        }
+      } else {
+        addKey(response, next);
+        count++;
+      }
-      if (prefix.length() > 0 && !prefix.endsWith(delimiter)
-          && relativeKeyName.length() > 0) {
-        response.addPrefix(prefix + "/");
+      if (count == maxKeys) {
+        lastKey = next.getName();
-      if (depth > 0) {
-        String dirName = relativeKeyName
-            .substring(0, relativeKeyName.indexOf(delimiter));
-        if (!dirName.equals(prevDir)) {
-          response.addPrefix(
-              prefix + dirName + delimiter);
-          prevDir = dirName;
-        }
-      } else if (relativeKeyName.endsWith(delimiter)) {
-        response.addPrefix(relativeKeyName);
-      } else if (relativeKeyName.length() > 0) {
-        KeyMetadata keyMetadata = new KeyMetadata();
-        keyMetadata.setKey(next.getName());
-        keyMetadata.setSize(next.getDataSize());
-        keyMetadata.setETag("" + next.getModificationTime());
-        keyMetadata.setStorageClass("STANDARD");
-        keyMetadata
-            .setLastModified(Instant.ofEpochMilli(next.getModificationTime()));
-        response.addKey(keyMetadata);
-      }
+
+    response.setKeyCount(count);
+
+    if (count < maxKeys) {
+      response.setTruncated(false);
+    } else if(ozoneKeyIterator.hasNext()) {
+      response.setTruncated(true);
+      response.setNextToken(S3utils.generateContinueToken(lastKey));
+    } else {
+      response.setTruncated(false);
+    }
+
+
+  private void addKey(ListObjectResponse response, OzoneKey next) {
+    KeyMetadata keyMetadata = new KeyMetadata();
+    keyMetadata.setKey(next.getName());
+    keyMetadata.setSize(next.getDataSize());
+    keyMetadata.setETag("" + next.getModificationTime());
+    keyMetadata.setStorageClass("STANDARD");
+    keyMetadata.setLastModified(Instant.ofEpochMilli(next.getModificationTime()));
+    response.addKey(keyMetadata);
+  }

MOV26 INS26 INS40 UPD40 INS31 INS44 INS44 INS83 INS39 INS42 INS44 INS44 MOV8 INS79 INS43 INS42 INS79 INS43 INS42 INS60 INS25 INS21 INS60 INS60 INS21 INS25 INS43 INS42 INS43 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS43 INS59 INS27 INS8 INS25 INS32 INS43 INS59 INS39 INS59 INS32 INS27 INS8 INS25 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS21 INS27 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS34 INS25 INS25 INS42 INS42 INS42 INS42 INS42 INS21 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS33 INS42 INS33 INS7 INS27 INS27 INS21 INS27 MOV8 INS8 INS27 INS8 INS8 INS27 MOV8 INS32 INS42 INS42 INS21 INS21 INS21 INS42 INS32 INS42 INS33 INS42 INS33 INS7 INS27 INS27 INS21 INS42 INS33 MOV25 INS21 INS21 INS42 INS42 INS42 INS42 INS9 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 MOV33 INS42 INS33 INS7 MOV25 INS32 INS37 INS7 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV32 MOV32 MOV8 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS21 UPD42 MOV42 INS42 INS21 INS37 INS32 INS37 INS37 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 DEL27 DEL25 DEL42 DEL45 DEL34 DEL45 DEL32 DEL34 DEL27 DEL25 DEL42 DEL42 DEL45 DEL27 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL25
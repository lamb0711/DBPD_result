Merge remote-tracking branch 'origin/trunk' into MR-2841

Conflicts:
	hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java

-public enum ReplaceDatanodeOnFailure {
-  /** The feature is disabled in the entire site. */
-  DISABLE,
-  /** Never add a new datanode. */
-  NEVER,
-  /**
-   * DEFAULT policy:
-   *   Let r be the replication number.
-   *   Let n be the number of existing datanodes.
-   *   Add a new datanode only if r >= 3 and either
-   *   (1) floor(r/2) >= n; or
-   *   (2) r > n and the block is hflushed/appended.
-   */
-  DEFAULT,
-  /** Always add a new datanode when an existing datanode is removed. */
-  ALWAYS;
+public class ReplaceDatanodeOnFailure {
+  /** The replacement policies */
+  public enum Policy {
+    /** The feature is disabled in the entire site. */
+    DISABLE(Condition.FALSE),
+    /** Never add a new datanode. */
+    NEVER(Condition.FALSE),
+    /** @see ReplaceDatanodeOnFailure.Condition#DEFAULT */
+    DEFAULT(Condition.DEFAULT),
+    /** Always add a new datanode when an existing datanode is removed. */
+    ALWAYS(Condition.TRUE);
+
+    private final Condition condition;
+
+    private Policy(Condition condition) {
+      this.condition = condition;
+    }
+    
+    Condition getCondition() {
+      return condition;
+    }
+  }
+
+  /** Datanode replacement condition */
+  private static interface Condition {
+    /** Return true unconditionally. */
+    static final Condition TRUE = new Condition() {
+      @Override
+      public boolean satisfy(short replication, DatanodeInfo[] existings,
+          int nExistings, boolean isAppend, boolean isHflushed) {
+        return true;
+      }
+    };
+
+    /** Return false unconditionally. */
+    static final Condition FALSE = new Condition() {
+      @Override
+      public boolean satisfy(short replication, DatanodeInfo[] existings,
+          int nExistings, boolean isAppend, boolean isHflushed) {
+        return false;
+      }
+    };
+
+    /**
+     * DEFAULT condition:
+     *   Let r be the replication number.
+     *   Let n be the number of existing datanodes.
+     *   Add a new datanode only if r >= 3 and either
+     *   (1) floor(r/2) >= n; or
+     *   (2) r > n and the block is hflushed/appended.
+     */
+    static final Condition DEFAULT = new Condition() {
+      @Override
+      public boolean satisfy(final short replication,
+          final DatanodeInfo[] existings, final int n, final boolean isAppend,
+          final boolean isHflushed) {
+        if (replication < 3) {
+          return false;
+        } else {
+          if (n <= (replication/2)) {
+            return true;
+          } else {
+            return isAppend || isHflushed;
+          }
+        }
+      }
+    };
+
+    /** Is the condition satisfied? */
+    public boolean satisfy(short replication, DatanodeInfo[] existings,
+        int nExistings, boolean isAppend, boolean isHflushed);
+  }
+
+  private final Policy policy;
+  private final boolean bestEffort;
+  
+  public ReplaceDatanodeOnFailure(Policy policy, boolean bestEffort) {
+    this.policy = policy;
+    this.bestEffort = bestEffort;
+  }
-    if (this == DISABLE) {
+    if (policy == Policy.DISABLE) {
-  /** Is the policy satisfied? */
+  /**
+   * Best effort means that the client will try to replace the failed datanode
+   * (provided that the policy is satisfied), however, it will continue the
+   * write operation in case that the datanode replacement also fails.
+   * 
+   * @return Suppose the datanode replacement fails.
+   *     false: An exception should be thrown so that the write will fail.
+   *     true : The write should be resumed with the remaining datandoes.
+   */
+  public boolean isBestEffort() {
+    return bestEffort;
+  }
+
+  /** Does it need a replacement according to the policy? */
-    } else if (this == DISABLE || this == NEVER) {
-      return false;
-    } else if (this == ALWAYS) {
-      return true;
-      //DEFAULT
-      if (replication < 3) {
-        return false;
-      } else {
-        if (n <= (replication/2)) {
-          return true;
-        } else {
-          return isAppend || isHflushed;
-        }
-      }
+      return policy.getCondition().satisfy(
+          replication, existings, n, isAppend, isHflushed);
+  
+  @Override
+  public String toString() {
+    return policy.toString();
+  }
+    final Policy policy = getPolicy(conf);
+    final boolean bestEffort = conf.getBoolean(
+        DFSConfigKeys.DFS_CLIENT_WRITE_REPLACE_DATANODE_ON_FAILURE_BEST_EFFORT_KEY,
+        DFSConfigKeys.DFS_CLIENT_WRITE_REPLACE_DATANODE_ON_FAILURE_BEST_EFFORT_DEFAULT);
+    
+    return new ReplaceDatanodeOnFailure(policy, bestEffort);
+  }
+
+  private static Policy getPolicy(final Configuration conf) {
-      return DISABLE;
+      return Policy.DISABLE;
-    for(int i = 1; i < values().length; i++) {
-      final ReplaceDatanodeOnFailure rdof = values()[i];
-      if (rdof.name().equalsIgnoreCase(policy)) {
-        return rdof;
+    for(int i = 1; i < Policy.values().length; i++) {
+      final Policy p = Policy.values()[i];
+      if (p.name().equalsIgnoreCase(policy)) {
+        return p;
-  public void write(final Configuration conf) {
+  public static void write(final Policy policy,
+      final boolean bestEffort, final Configuration conf) {
-        this != DISABLE);
+        policy != Policy.DISABLE);
-        name());
+        policy.name());
+    conf.setBoolean(
+        DFSConfigKeys.DFS_CLIENT_WRITE_REPLACE_DATANODE_ON_FAILURE_BEST_EFFORT_KEY,
+        bestEffort);

INS55 MOV29 MOV78 MOV78 INS83 INS42 INS71 INS55 INS23 INS23 INS31 MOV31 INS31 INS31 INS31 INS31 MOV31 INS31 INS29 INS83 INS42 MOV72 MOV72 INS72 MOV72 INS23 INS31 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS8 MOV29 INS83 INS83 MOV43 INS42 INS44 INS8 UPD83 INS43 UPD42 MOV29 MOV83 INS83 MOV39 MOV42 INS44 INS44 MOV44 MOV8 INS65 INS40 INS40 INS29 INS42 INS40 INS40 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS43 INS42 INS8 INS65 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS42 INS42 INS42 INS43 INS42 INS39 INS42 INS21 INS21 INS65 INS65 INS41 INS65 INS83 INS39 INS42 INS83 INS5 INS42 INS83 INS39 INS42 INS83 INS39 INS42 MOV60 INS25 INS42 INS42 INS41 INS83 INS43 INS42 INS60 INS60 INS41 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS21 INS66 INS65 INS42 INS42 INS43 INS42 INS21 INS42 INS41 INS66 INS65 INS42 INS42 INS14 INS65 INS42 INS42 INS14 MOV65 INS42 INS42 INS14 INS65 INS39 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS42 INS7 INS7 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS43 INS85 MOV27 MOV8 INS8 INS32 INS42 INS83 INS43 INS59 INS83 INS39 INS59 INS14 INS42 INS32 INS67 INS66 INS42 INS7 INS42 INS66 INS43 INS1 INS66 INS43 INS1 UPD66 INS43 INS1 INS66 INS43 INS85 INS22 INS42 INS22 INS42 UPD42 INS40 INS42 INS41 INS42 INS42 INS42 INS42 INS32 INS42 INS32 MOV43 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS42 INS22 INS42 INS42 INS31 INS42 INS31 INS42 MOV31 INS42 INS52 INS42 INS52 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS40 INS40 INS43 UPD42 INS40 INS42 INS52 INS42 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 MOV8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 MOV8 INS78 INS44 MOV8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS39 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS42 INS39 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS42 INS83 INS39 INS42 INS42 INS42 UPD42 UPD42 INS43 INS85 INS43 INS85 INS42 INS42 INS42 DEL66 DEL65 DEL29 DEL52 DEL42 DEL27 DEL52 DEL42 DEL27 DEL27 DEL52 DEL42 DEL27 DEL25 DEL25 DEL25 DEL8 DEL52 DEL42 DEL52 DEL83 DEL42 DEL29 DEL42 DEL72 DEL31 DEL71
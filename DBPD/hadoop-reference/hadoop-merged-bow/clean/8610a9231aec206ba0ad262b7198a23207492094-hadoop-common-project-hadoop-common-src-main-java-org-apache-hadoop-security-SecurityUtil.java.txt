Merge trunk into HA branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1230696 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import java.util.List;
+import com.google.common.annotations.VisibleForTesting;
+
+//this will need to be replaced someday when there is a suitable replacement
+import sun.net.dns.ResolverConfiguration;
+import sun.net.util.IPAddressUtil;
-  private static boolean useIpForTokenService;
+  @VisibleForTesting
+  static boolean useIpForTokenService;
+  @VisibleForTesting
+  static HostResolver hostResolver;
-    NetUtils.setUseQualifiedHostResolver(!flag);
-  }
-  
-  /**
-   * Intended only for temporary use by NetUtils.  Do not use.
-   * @return whether tokens use an IP address
-   */
-  @InterfaceAudience.Private
-  public static boolean getTokenServiceUseIp() {
-    return useIpForTokenService;
+    hostResolver = !useIpForTokenService
+        ? new QualifiedHostResolver()
+        : new StandardHostResolver();
-   * @throws IOException
+   * @throws IOException if the service ticket cannot be retrieved
-   * @throws IOException
+   * @throws IOException if the client address cannot be determined
-   * @throws IOException
+   * @throws IOException if the client address cannot be determined
-   * @throws IOException
+   * @throws IOException if login fails
-   * @throws IOException
+   * @throws IOException if the config doesn't specify a keytab
-   * @conf conf Configuration object
+   * @param conf Configuration object
+  
+  /**
+   * Resolves a host subject to the security requirements determined by
+   * hadoop.security.token.service.use_ip.
+   * 
+   * @param hostname host or ip to resolve
+   * @return a resolved host
+   * @throws UnknownHostException if the host doesn't exist
+   */
+  @InterfaceAudience.Private
+  public static
+  InetAddress getByName(String hostname) throws UnknownHostException {
+    return hostResolver.getByName(hostname);
+  }
+  
+  interface HostResolver {
+    InetAddress getByName(String host) throws UnknownHostException;    
+  }
+  
+  /**
+   * Uses standard java host resolution
+   */
+  static class StandardHostResolver implements HostResolver {
+    public InetAddress getByName(String host) throws UnknownHostException {
+      return InetAddress.getByName(host);
+    }
+  }
+  
+  /**
+   * This an alternate resolver with important properties that the standard
+   * java resolver lacks:
+   * 1) The hostname is fully qualified.  This avoids security issues if not
+   *    all hosts in the cluster do not share the same search domains.  It
+   *    also prevents other hosts from performing unnecessary dns searches.
+   *    In contrast, InetAddress simply returns the host as given.
+   * 2) The InetAddress is instantiated with an exact host and IP to prevent
+   *    further unnecessary lookups.  InetAddress may perform an unnecessary
+   *    reverse lookup for an IP.
+   * 3) A call to getHostName() will always return the qualified hostname, or
+   *    more importantly, the IP if instantiated with an IP.  This avoids
+   *    unnecessary dns timeouts if the host is not resolvable.
+   * 4) Point 3 also ensures that if the host is re-resolved, ex. during a
+   *    connection re-attempt, that a reverse lookup to host and forward
+   *    lookup to IP is not performed since the reverse/forward mappings may
+   *    not always return the same IP.  If the client initiated a connection
+   *    with an IP, then that IP is all that should ever be contacted.
+   *    
+   * NOTE: this resolver is only used if:
+   *       hadoop.security.token.service.use_ip=false 
+   */
+  protected static class QualifiedHostResolver implements HostResolver {
+    @SuppressWarnings("unchecked")
+    private List<String> searchDomains =
+        ResolverConfiguration.open().searchlist();
+    
+    /**
+     * Create an InetAddress with a fully qualified hostname of the given
+     * hostname.  InetAddress does not qualify an incomplete hostname that
+     * is resolved via the domain search list.
+     * {@link InetAddress#getCanonicalHostName()} will fully qualify the
+     * hostname, but it always return the A record whereas the given hostname
+     * may be a CNAME.
+     * 
+     * @param host a hostname or ip address
+     * @return InetAddress with the fully qualified hostname or ip
+     * @throws UnknownHostException if host does not exist
+     */
+    public InetAddress getByName(String host) throws UnknownHostException {
+      InetAddress addr = null;
+
+      if (IPAddressUtil.isIPv4LiteralAddress(host)) {
+        // use ipv4 address as-is
+        byte[] ip = IPAddressUtil.textToNumericFormatV4(host);
+        addr = InetAddress.getByAddress(host, ip);
+      } else if (IPAddressUtil.isIPv6LiteralAddress(host)) {
+        // use ipv6 address as-is
+        byte[] ip = IPAddressUtil.textToNumericFormatV6(host);
+        addr = InetAddress.getByAddress(host, ip);
+      } else if (host.endsWith(".")) {
+        // a rooted host ends with a dot, ex. "host."
+        // rooted hosts never use the search path, so only try an exact lookup
+        addr = getByExactName(host);
+      } else if (host.contains(".")) {
+        // the host contains a dot (domain), ex. "host.domain"
+        // try an exact host lookup, then fallback to search list
+        addr = getByExactName(host);
+        if (addr == null) {
+          addr = getByNameWithSearch(host);
+        }
+      } else {
+        // it's a simple host with no dots, ex. "host"
+        // try the search list, then fallback to exact host
+        InetAddress loopback = InetAddress.getByName(null);
+        if (host.equalsIgnoreCase(loopback.getHostName())) {
+          addr = InetAddress.getByAddress(host, loopback.getAddress());
+        } else {
+          addr = getByNameWithSearch(host);
+          if (addr == null) {
+            addr = getByExactName(host);
+          }
+        }
+      }
+      // unresolvable!
+      if (addr == null) {
+        throw new UnknownHostException(host);
+      }
+      return addr;
+    }
+
+    InetAddress getByExactName(String host) {
+      InetAddress addr = null;
+      // InetAddress will use the search list unless the host is rooted
+      // with a trailing dot.  The trailing dot will disable any use of the
+      // search path in a lower level resolver.  See RFC 1535.
+      String fqHost = host;
+      if (!fqHost.endsWith(".")) fqHost += ".";
+      try {
+        addr = getInetAddressByName(fqHost);
+        // can't leave the hostname as rooted or other parts of the system
+        // malfunction, ex. kerberos principals are lacking proper host
+        // equivalence for rooted/non-rooted hostnames
+        addr = InetAddress.getByAddress(host, addr.getAddress());
+      } catch (UnknownHostException e) {
+        // ignore, caller will throw if necessary
+      }
+      return addr;
+    }
+
+    InetAddress getByNameWithSearch(String host) {
+      InetAddress addr = null;
+      if (host.endsWith(".")) { // already qualified?
+        addr = getByExactName(host); 
+      } else {
+        for (String domain : searchDomains) {
+          String dot = !domain.startsWith(".") ? "." : "";
+          addr = getByExactName(host + dot + domain);
+          if (addr != null) break;
+        }
+      }
+      return addr;
+    }
+
+    // implemented as a separate method to facilitate unit testing
+    InetAddress getInetAddressByName(String host) throws UnknownHostException {
+      return InetAddress.getByName(host);
+    }
+
+    void setSearchDomains(String ... domains) {
+      searchDomains = Arrays.asList(domains);
+    }
+  }  

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS55 INS55 INS55 INS78 INS78 INS83 INS43 INS59 MOV29 MOV78 MOV83 MOV83 INS43 INS42 INS44 INS43 INS8 INS42 INS31 INS29 INS83 INS42 INS43 INS31 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS31 INS31 INS42 INS42 INS42 INS42 UPD65 INS65 INS65 INS42 INS43 INS42 INS42 INS41 INS43 INS42 INS44 INS43 INS65 INS42 INS83 INS43 INS42 INS44 INS43 INS8 INS65 INS42 INS79 INS83 INS74 INS59 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS43 INS42 INS44 INS8 INS43 INS42 INS44 INS8 INS43 INS42 INS44 INS43 MOV8 INS39 INS42 INS44 INS8 INS7 INS66 INS66 INS66 INS66 INS66 INS42 UPD66 INS66 UPD66 INS42 INS66 UPD66 INS42 INS66 INS42 INS32 INS42 INS43 INS42 INS42 INS66 INS42 INS43 INS42 INS42 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS45 INS43 INS43 INS42 INS32 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS60 INS25 INS25 INS41 INS42 INS43 INS42 INS60 INS60 INS25 INS54 INS41 INS42 INS43 INS42 INS60 INS25 INS41 INS42 INS43 INS42 INS42 INS43 INS42 INS21 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS32 INS8 INS25 INS27 INS8 INS42 INS42 INS43 INS59 INS43 INS59 INS38 INS21 INS8 INS12 INS42 INS42 INS43 INS59 INS32 INS8 INS8 INS42 INS42 INS32 INS42 INS7 INS38 INS14 INS14 INS42 INS42 INS42 INS42 INS42 INS68 INS42 INS42 INS33 INS42 INS42 INS42 INS60 INS21 INS32 INS8 INS25 INS42 INS33 INS53 INS42 INS42 INS33 INS42 INS42 INS42 INS32 INS7 INS21 INS21 INS44 INS8 INS42 INS42 INS33 INS42 INS42 INS45 INS21 INS70 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 INS43 INS43 INS42 INS42 INS5 INS59 INS7 INS42 INS42 INS42 INS60 INS21 INS32 INS8 INS25 INS14 INS42 INS42 INS45 INS42 INS45 INS7 INS7 INS43 INS42 INS7 INS44 INS42 INS8 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS32 INS5 INS59 INS7 INS42 INS42 INS45 INS21 INS32 INS8 INS8 INS43 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS60 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS32 INS7 INS42 INS42 INS45 INS21 INS25 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS7 INS27 INS10 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS27 INS8 INS43 INS59 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS16 INS42 INS32 INS42 INS33 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS21 INS21 INS25 INS38 INS45 INS45 INS42 INS27 INS42 INS42 INS7 INS42 INS42 INS33 INS42 INS42 INS7 INS7 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS7 INS42 INS42 INS42 INS32 INS42 INS42 DEL83 DEL42 DEL42 DEL38 DEL32 DEL39 DEL42 DEL31 DEL42
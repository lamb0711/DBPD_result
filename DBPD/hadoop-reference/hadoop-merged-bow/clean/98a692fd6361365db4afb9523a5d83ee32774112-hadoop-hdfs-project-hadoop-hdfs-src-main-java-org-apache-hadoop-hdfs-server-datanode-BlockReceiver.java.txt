HDFS-3875. Issue handling checksum errors in write pipeline. Contributed by Kihwal Lee.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1484808 13f79535-47bb-0310-9956-ffa450edef68

-      if (srcDataNode != null) {
+      // No need to report to namenode when client is writing.
+      if (srcDataNode != null && isDatanode) {
+  /** 
+   * Check whether checksum needs to be verified.
+   * Skip verifying checksum iff this is not the last one in the 
+   * pipeline and clientName is non-null. i.e. Checksum is verified
+   * on all the datanodes when the data is being written by a 
+   * datanode rather than a client. Whe client is writing the data, 
+   * protocol includes acks and only the last datanode needs to verify 
+   * checksum.
+   * @return true if checksum verification is needed, otherwise false.
+   */
+  private boolean shouldVerifyChecksum() {
+    return (mirrorOut == null || isDatanode || needsChecksumTranslation);
+  }
-    if (responder != null && !syncBlock) {
+    if (responder != null && !syncBlock && !shouldVerifyChecksum()) {
-          lastPacketInBlock, offsetInBlock);
+          lastPacketInBlock, offsetInBlock, Status.SUCCESS);
-     }
+      }
-      /* skip verifying checksum iff this is not the last one in the 
-       * pipeline and clientName is non-null. i.e. Checksum is verified
-       * on all the datanodes when the data is being written by a 
-       * datanode rather than a client. Whe client is writing the data, 
-       * protocol includes acks and only the last datanode needs to verify 
-       * checksum.
-       */
-      if (mirrorOut == null || isDatanode || needsChecksumTranslation) {
-        verifyChunks(dataBuf, checksumBuf);
+      if (shouldVerifyChecksum()) {
+        try {
+          verifyChunks(dataBuf, checksumBuf);
+        } catch (IOException ioe) {
+          // checksum error detected locally. there is no reason to continue.
+          if (responder != null) {
+            try {
+              ((PacketResponder) responder.getRunnable()).enqueue(seqno,
+                  lastPacketInBlock, offsetInBlock,
+                  Status.ERROR_CHECKSUM);
+              // Wait until the responder sends back the response
+              // and interrupt this thread.
+              Thread.sleep(3000);
+            } catch (InterruptedException e) { }
+          }
+          throw new IOException("Terminating due to a checksum error." + ioe);
+        }
+ 
-    if (responder != null && syncBlock) {
+    if (responder != null && (syncBlock || shouldVerifyChecksum())) {
-          lastPacketInBlock, offsetInBlock);
+          lastPacketInBlock, offsetInBlock, Status.SUCCESS);
-   * Processed responses from downstream datanodes in the pipeline
+   * Processes responses from downstream datanodes in the pipeline
-        final long offsetInBlock) {
+        final long offsetInBlock, final Status ackStatus) {
-          System.nanoTime());
+          System.nanoTime(), ackStatus);
-              (pkt != null ? pkt.offsetInBlock : 0));
+              (pkt != null ? pkt.offsetInBlock : 0), 
+              (pkt != null ? pkt.ackStatus : Status.SUCCESS));
-        long totalAckTimeNanos, long offsetInBlock) throws IOException {
+        long totalAckTimeNanos, long offsetInBlock,
+        Status myStatus) throws IOException {
-        replies[0] = Status.SUCCESS;
+        replies[0] = myStatus;
+        // If the mirror has reported that it received a corrupt packet,
+        // do self-destruct to mark myself bad, instead of making the 
+        // mirror node bad. The mirror is guaranteed to be good without
+        // corrupt data on disk.
+        if (ackLen > 0 && replies[1] == Status.ERROR_CHECKSUM) {
+          throw new IOException("Shutting down writer and responder "
+              + "since the down streams reported the data sent by this "
+              + "thread is corrupt");
+        }
+
+      // If a corruption was detected in the received data, terminate after
+      // sending ERROR_CHECKSUM back. 
+      if (myStatus == Status.ERROR_CHECKSUM) {
+        throw new IOException("Shutting down writer and responder "
+            + "due to a checksum error in received data. The error "
+            + "response has been sent upstream.");
+      }
+    final Status ackStatus;
-        long ackEnqueueNanoTime) {
+        long ackEnqueueNanoTime, Status ackStatus) {
+      this.ackStatus = ackStatus;
+        + ", ackStatus=" + ackStatus

INS31 INS29 INS83 INS39 INS42 INS8 INS23 INS65 INS65 INS41 INS44 INS44 INS83 INS43 INS59 INS44 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS36 INS27 UPD66 INS83 INS43 INS42 INS43 INS42 INS25 INS42 INS42 INS43 INS42 INS21 MOV27 MOV27 INS38 INS25 INS36 INS42 INS42 INS27 INS8 INS42 INS7 INS32 INS32 INS8 INS27 INS25 INS42 INS40 INS53 INS22 INS42 INS45 INS42 INS27 INS42 INS40 INS42 INS54 MOV25 MOV42 INS32 INS40 INS42 INS27 INS8 INS14 INS52 INS42 MOV27 INS42 MOV8 INS12 INS42 INS42 INS27 INS27 INS53 INS43 INS27 INS44 INS8 INS42 INS34 INS2 INS40 INS14 INS42 INS45 INS45 INS45 INS43 INS42 MOV25 INS53 INS36 INS42 INS34 INS43 INS27 INS42 INS27 INS8 INS14 INS16 INS42 INS45 INS45 INS45 INS42 INS33 INS54 INS43 INS27 INS27 INS40 INS40 INS8 INS12 INS42 INS45 INS42 INS42 INS33 INS21 INS21 INS44 INS8 INS32 INS32 INS43 INS42 INS36 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS34 INS42 INS11 INS43 INS32 INS42 INS42 INS42 DEL40
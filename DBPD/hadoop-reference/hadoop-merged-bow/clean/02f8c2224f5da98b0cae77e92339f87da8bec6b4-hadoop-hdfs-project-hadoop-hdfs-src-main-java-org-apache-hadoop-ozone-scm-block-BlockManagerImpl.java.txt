HDFS-11888. Ozone: SCM: use state machine for open containers allocated for key/blocks. Contributed by Xiaoyu Yao.

+import com.google.common.base.Preconditions;
+import org.apache.hadoop.scm.container.common.helpers.ContainerInfo;
+import org.apache.hadoop.scm.container.common.helpers.BlockContainerInfo;
-  private final MetadataStore openContainerStore;
-  private Map<String, Long> openContainers;
+  // Track all containers owned by block service.
+  private final MetadataStore containerStore;
+
+  private Map<OzoneProtos.LifeCycleState,
+      Map<String, BlockContainerInfo>> containers;
-    openContainerStore = MetadataStoreBuilder.newBuilder()
+    containerStore = MetadataStoreBuilder.newBuilder()
-    openContainers = new ConcurrentHashMap<>();
-    loadOpenContainers();
+    loadAllocatedContainers();
-   * Load open containers from persistent store.
+   * Load allocated containers from persistent store.
-  private void loadOpenContainers() throws IOException {
+  private void loadAllocatedContainers() throws IOException {
+    // Pre-allocate empty map entry by state to avoid null check
+    containers = new ConcurrentHashMap<>();
+    for (OzoneProtos.LifeCycleState state :
+        OzoneProtos.LifeCycleState.values()) {
+      containers.put(state, new ConcurrentHashMap());
+    }
-      openContainerStore.iterate(null, (key, value) -> {
+      containerStore.iterate(null, (key, value) -> {
-          openContainers.put(containerName, containerUsed);
-          LOG.debug("Loading open container: {} used : {}", containerName,
-              containerUsed);
+          ContainerInfo containerInfo =
+              containerManager.getContainer(containerName);
+          // TODO: remove the container from block manager's container DB
+          // Most likely the allocated container is timeout and cleaned up
+          // by SCM, we should clean up correspondingly instead of just skip it.
+          if (containerInfo == null) {
+            LOG.warn("Container {} allocated by block service" +
+                "can't be found in SCM", containerName);
+            return true;
+          }
+          Map<String, BlockContainerInfo> containersByState =
+              containers.get(containerInfo.getState());
+          containersByState.put(containerName,
+              new BlockContainerInfo(containerInfo, containerUsed));
+          LOG.debug("Loading allocated container: {} used : {} state: {}",
+              containerName, containerUsed, containerInfo.getState());
-          LOG.warn("Failed loading open container, continue next...");
+          LOG.warn("Failed loading allocated container, continue next...");
-   * Pre-provision specified count of containers for block creation.
-   * @param count - number of containers to create.
-   * @return list of container names created.
+   * Pre allocate specified count of containers for block creation.
+   * @param count - number of containers to allocate.
+   * @return list of container names allocated.
-  private List<String> provisionContainers(int count) throws IOException {
+  private List<String> allocateContainers(int count) throws IOException {
+        ContainerInfo containerInfo = null;
-          Pipeline pipeline = containerManager.allocateContainer(
+          containerInfo = containerManager.allocateContainer(
-          if (pipeline == null) {
+          if (containerInfo == null) {
-        openContainers.put(containerName, 0L);
-        openContainerStore.put(DFSUtil.string2Bytes(containerName),
+        Map<String, BlockContainerInfo> containersByState =
+            containers.get(OzoneProtos.LifeCycleState.ALLOCATED);
+        Preconditions.checkNotNull(containersByState);
+        containersByState.put(containerName,
+            new BlockContainerInfo(containerInfo, 0));
+        containerStore.put(DFSUtil.string2Bytes(containerName),
+   * Filter container by states and size.
+   * @param state the state of the container.
+   * @param size the minimal available size of the container
+   * @return allocated containers satisfy both state and size.
+   */
+  private List <String> filterContainers(OzoneProtos.LifeCycleState state,
+      long size) {
+    Map<String, BlockContainerInfo> containersByState =
+        this.containers.get(state);
+    return containersByState.entrySet().parallelStream()
+        .filter(e -> ((e.getValue().getAllocated() + size < containerSize)))
+        .map(e -> e.getKey())
+        .collect(Collectors.toList());
+  }
+
+  private BlockContainerInfo getContainer(OzoneProtos.LifeCycleState state,
+      String name) {
+    Map<String, BlockContainerInfo> containersByState = this.containers.get(state);
+    return containersByState.get(name);
+  }
+
+  // Relies on the caller such as allocateBlock() to hold the lock
+  // to ensure containers map consistent.
+  private void updateContainer(OzoneProtos.LifeCycleState oldState, String name,
+      OzoneProtos.LifeCycleState newState) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Update container {} from state {} to state {}",
+          name, oldState, newState);
+    }
+    Map<String, BlockContainerInfo> containersInOldState =
+        this.containers.get(oldState);
+    BlockContainerInfo containerInfo = containersInOldState.get(name);
+    Preconditions.checkNotNull(containerInfo);
+    containersInOldState.remove(name);
+    Map<String, BlockContainerInfo> containersInNewState =
+        this.containers.get(newState);
+    containersInNewState.put(name, containerInfo);
+  }
+
+  // Refresh containers that have been allocated.
+  // We may not need to track all the states, just the creating/open/close
+  // should be enough for now.
+  private void refreshContainers() {
+    Map<String, BlockContainerInfo> containersByState =
+        this.containers.get(OzoneProtos.LifeCycleState.ALLOCATED);
+    for (String containerName: containersByState.keySet()) {
+      try {
+        ContainerInfo containerInfo =
+            containerManager.getContainer(containerName);
+        if (containerInfo == null) {
+          // TODO: clean up containers that has been deleted on SCM but
+          // TODO: still in ALLOCATED state in block manager.
+          LOG.debug("Container {} allocated by block service" +
+              "can't be found in SCM", containerName);
+          continue;
+        }
+        if (containerInfo.getState() == OzoneProtos.LifeCycleState.OPEN) {
+          updateContainer(OzoneProtos.LifeCycleState.ALLOCATED, containerName,
+              containerInfo.getState());
+        }
+        // TODO: check containers in other state and refresh as needed.
+        // TODO: ALLOCATED container that is timeout and DELETED. (unit test)
+        // TODO: OPEN container that is CLOSE.
+      } catch (IOException ex) {
+        LOG.debug("Failed to get container info for: {}", containerName);
+      }
+    }
+   }
+
+  /**
-    boolean createContainer;
-    Pipeline pipeline;
+    boolean createContainer = false;
+      refreshContainers();
-      if (openContainers.size() == 0) {
-        try {
-          candidates = provisionContainers(containerProvisionBatchSize);
-        } catch (IOException ex) {
-          throw new SCMException("Unable to allocate container for the block",
-              FAILED_TO_ALLOCATE_CONTAINER);
-        }
-          createContainer = true;
-      } else {
-        candidates = openContainers.entrySet().parallelStream()
-            .filter(e -> (e.getValue() + size < containerSize))
-            .map(e -> e.getKey())
-            .collect(Collectors.toList());
-        createContainer = false;
-      }
-
+      candidates = filterContainers(OzoneProtos.LifeCycleState.OPEN, size);
-        try {
-          candidates = provisionContainers(containerProvisionBatchSize);
-        } catch (IOException ex) {
-          throw new SCMException("Unable to allocate container for the block",
-              FAILED_TO_ALLOCATE_CONTAINER);
+        candidates = filterContainers(OzoneProtos.LifeCycleState.ALLOCATED,
+            size);
+        if (candidates.size() == 0) {
+          try {
+            candidates = allocateContainers(containerProvisionBatchSize);
+          } catch (IOException ex) {
+            LOG.error("Unable to allocate container for the block.");
+            throw new SCMException("Unable to allocate container for the block",
+                FAILED_TO_ALLOCATE_CONTAINER);
+          }
+        }
+        // now we should have some candidates in ALLOCATE state
+        if (candidates.size() == 0) {
+          throw new SCMException("Fail to find any container to allocate block " +
+              "of size " + size + ".", FAILED_TO_FIND_CONTAINER_WITH_SAPCE);
-      if (candidates.size() == 0) {
-        throw new SCMException("Fail to find any container to allocate block " +
-            "of size " + size + ".", FAILED_TO_FIND_CONTAINER_WITH_SAPCE);
-      }
-
+      // Candidates list now should include only ALLOCATE or OPEN containers
-      pipeline = containerManager.getContainer(containerName);
-      if (pipeline == null) {
+      ContainerInfo containerInfo =
+          containerManager.getContainer(containerName);
+      if (containerInfo == null) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Candidate {} state {}", containerName,
+            containerInfo.getState());
+      }
+      // Container must be either OPEN or ALLOCATE state
+      if (containerInfo.getState() == OzoneProtos.LifeCycleState.ALLOCATED) {
+        createContainer = true;
+      }
+
-          .setKey(blockKey).setPipeline(pipeline)
+          .setKey(blockKey).setPipeline(containerInfo.getPipeline())
-      if (pipeline.getMachines().size() > 0) {
+      if (containerInfo.getPipeline().getMachines().size() > 0) {
-        Long newUsed = openContainers.get(containerName) + size;
-        openContainers.put(containerName, newUsed);
-        openContainerStore.put(DFSUtil.string2Bytes(containerName),
-            DFSUtil.string2Bytes(Long.toString(newUsed)));
+        BlockContainerInfo containerInfoUpdate =
+            getContainer(containerInfo.getState(), containerName);
+        Preconditions.checkNotNull(containerInfoUpdate);
+        containerInfoUpdate.addAllocated(size);
+        containerStore.put(DFSUtil.string2Bytes(containerName),
+            DFSUtil.string2Bytes(Long.toString(containerInfoUpdate.getAllocated())));
+        if (createContainer) {
+          OzoneProtos.LifeCycleState newState =
+              containerManager.updateContainerState(containerName,
+              OzoneProtos.LifeCycleEvent.BEGIN_CREATE);
+          updateContainer(containerInfo.getState(), containerName, newState);
+        }
-      return containerManager.getContainer(
-          DFSUtil.bytes2String(containerBytes));
+      String containerName = DFSUtil.bytes2String(containerBytes);
+      ContainerInfo containerInfo = containerManager.getContainer(
+          containerName);
+      if (containerInfo == null) {
+          LOG.debug("Container {} allocated by block service" +
+              "can't be found in SCM", containerName);
+          throw new SCMException("Unable to find container for the block",
+              SCMException.ResultCodes.FAILED_TO_FIND_CONTAINER);
+      }
+      return containerInfo.getPipeline();
+      // TODO: track the block size info so that we can reclaim the container
+      // TODO: used space when the block is deleted.
-      containerManager.getContainer(DFSUtil.bytes2String(containerBytes));
-    if (openContainerStore != null) {
-      openContainerStore.close();
+    if (containerStore != null) {
+      containerStore.close();
-    return openContainers.size();
+    return containers.get(OzoneProtos.LifeCycleState.OPEN).size();

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS31 INS31 UPD74 UPD42 UPD42 INS29 INS83 INS74 INS42 INS44 INS44 MOV8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS8 UPD42 INS43 INS74 UPD42 MOV21 INS70 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS39 INS42 INS60 INS41 INS42 INS43 INS42 INS43 INS42 INS60 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS60 INS60 INS21 INS21 INS60 INS21 INS60 INS70 INS40 UPD43 MOV43 MOV43 INS43 UPD66 INS44 INS32 INS8 UPD66 UPD66 UPD66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS40 INS74 INS59 MOV32 INS40 INS42 INS74 INS59 INS32 INS40 INS42 INS40 INS32 INS8 INS74 INS59 INS43 INS59 INS32 INS32 INS74 INS59 INS32 INS74 INS59 INS44 INS32 INS8 MOV25 UPD42 INS42 UPD42 UPD42 UPD42 INS43 INS42 INS40 INS42 INS21 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS21 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS32 INS43 INS42 INS42 INS42 INS54 INS9 INS21 INS21 INS25 INS60 INS25 INS60 INS60 INS25 INS41 UPD42 INS32 INS40 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS40 INS42 INS8 INS12 INS32 INS7 MOV27 INS8 INS43 INS59 INS32 INS8 INS27 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS32 UPD42 MOV42 INS42 INS40 INS42 INS42 INS42 INS14 UPD42 INS60 INS60 INS21 INS52 INS42 INS52 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS60 INS25 INS25 MOV44 INS8 INS42 INS42 INS32 INS21 INS25 MOV25 UPD42 MOV42 INS42 INS32 UPD42 INS42 INS42 MOV21 INS32 INS40 MOV21 INS21 INS25 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS33 INS21 INS53 INS42 INS42 UPD42 INS43 INS43 INS59 INS74 INS59 INS32 INS36 INS43 INS59 INS27 INS8 INS27 INS8 INS21 INS42 INS40 INS42 INS7 MOV27 INS8 INS42 INS42 INS42 INS32 INS42 INS42 UPD43 INS32 INS42 INS8 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS42 INS33 INS21 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS42 UPD42 INS14 UPD42 UPD42 MOV36 INS42 INS42 MOV32 INS42 INS33 INS21 INS18 INS32 INS40 INS21 INS32 INS42 INS32 INS54 INS42 INS42 INS45 INS42 INS32 INS32 INS32 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 INS42 INS42 INS42 UPD42 INS60 INS21 INS42 INS42 INS27 INS42 INS43 INS45 INS40 INS7 INS42 INS42 INS42 INS42 INS42 INS40 INS43 INS42 INS34 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS40 INS42 UPD42 MOV8 MOV12 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 MOV42 INS43 INS59 INS32 INS45 INS45 INS42 INS60 INS25 INS60 INS42 MOV32 UPD42 INS42 INS42 INS42 INS27 INS42 INS42 INS40 INS42 INS32 MOV44 INS42 UPD42 MOV42 INS32 INS40 INS42 INS32 INS42 INS32 INS42 INS42 INS43 INS59 INS27 INS8 INS74 INS59 INS32 INS45 INS45 INS42 INS42 INS21 INS42 UPD42 MOV42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS41 INS43 INS43 INS43 INS42 INS32 UPD42 INS14 UPD45 INS32 MOV32 INS42 INS32 INS42 INS42 INS42 INS32 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS42 UPD45 UPD42 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS45 INS45 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL34 DEL42 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL7 DEL21 DEL42 DEL32 DEL7 DEL8 DEL54 DEL8 DEL32 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL42 DEL42 DEL32 DEL21
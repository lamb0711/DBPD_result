HDFS-1623. High Availability Framework for HDFS NN. Contributed by Todd Lipcon, Aaron T. Myers, Eli Collins, Uma Maheswara Rao G, Bikas Saha, Suresh Srinivas, Jitendra Nath Pandey, Hari Mankude, Brandon Li, Sanjay Radia, Mingjie Lai, and Gregory Chanan


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296534 13f79535-47bb-0310-9956-ffa450edef68

-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_FEDERATION_NAMESERVICES;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_FEDERATION_NAMESERVICE_ID;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_BACKUP_ADDRESS_KEY;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_RPC_ADDRESS_KEY;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY;
-
+import static org.apache.hadoop.hdfs.DFSConfigKeys.*;
-import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
-import org.apache.hadoop.hdfs.protocol.ClientProtocol;
+import org.apache.hadoop.hdfs.protocol.HdfsConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import com.google.common.base.Joiner;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+  public static final Log LOG = LogFactory.getLog(DFSUtil.class.getName());
+  
+  private DFSUtil() { /* Hidden constructor */ }
+  /**
+   * Address matcher for matching an address to local address
+   */
+  static final AddressMatcher LOCAL_ADDRESS_MATCHER = new AddressMatcher() {
+    public boolean match(InetSocketAddress s) {
+      return NetUtils.isLocalAddress(s.getAddress());
+    };
+  };
-      
-   * @return collection of nameservice Ids
+   * @return collection of nameservice Ids, or null if not specified
-    return conf.getStringCollection(DFS_FEDERATION_NAMESERVICES);
+    return conf.getTrimmedStringCollection(DFS_FEDERATION_NAMESERVICES);
+   * @return <code>coll</code> if it is non-null and non-empty. Otherwise,
+   * returns a list with a single null value.
+   */
+  private static Collection<String> emptyAsSingletonNull(Collection<String> coll) {
+    if (coll == null || coll.isEmpty()) {
+      return Collections.singletonList(null);
+    } else {
+      return coll;
+    }
+  }
+  
+  /**
+   * Namenode HighAvailability related configuration.
+   * Returns collection of namenode Ids from the configuration. One logical id
+   * for each namenode in the in the HA setup.
+   * 
+   * @param conf configuration
+   * @param nsId the nameservice ID to look at, or null for non-federated 
+   * @return collection of namenode Ids
+   */
+  public static Collection<String> getNameNodeIds(Configuration conf, String nsId) {
+    String key = addSuffix(DFS_HA_NAMENODES_KEY_PREFIX, nsId);
+    return conf.getTrimmedStringCollection(key);
+  }
+  
+  /**
-      if (keySuffix != null) {
-        key += "." + keySuffix;
-      }
+      key = addSuffix(key, keySuffix);
+  /** Add non empty and non null suffix to a key */
+  private static String addSuffix(String key, String suffix) {
+    if (suffix == null || suffix.isEmpty()) {
+      return key;
+    }
+    assert !suffix.startsWith(".") :
+      "suffix '" + suffix + "' should not already have '.' prepended.";
+    return key + "." + suffix;
+  }
+  
+  /** Concatenate list of suffix strings '.' separated */
+  private static String concatSuffixes(String... suffixes) {
+    if (suffixes == null) {
+      return null;
+    }
+    return Joiner.on(".").skipNulls().join(suffixes);
+  }
+  
-   * Returns list of InetSocketAddress for a given set of keys.
-   * @param conf configuration
-   * @param defaultAddress default address to return in case key is not found
-   * @param keys Set of keys to look for in the order of preference
-   * @return list of InetSocketAddress corresponding to the key
+   * Return configuration key of format key.suffix1.suffix2...suffixN
-  private static List<InetSocketAddress> getAddresses(Configuration conf,
+  public static String addKeySuffixes(String key, String... suffixes) {
+    String keySuffix = concatSuffixes(suffixes);
+    return addSuffix(key, keySuffix);
+  }
+  
+  /**
+   * Returns the configured address for all NameNodes in the cluster.
+   * @param conf configuration
+   * @param defaultAddress default address to return in case key is not found.
+   * @param keys Set of keys to look for in the order of preference
+   * @return a map(nameserviceId to map(namenodeId to InetSocketAddress))
+   */
+  private static Map<String, Map<String, InetSocketAddress>>
+    getAddresses(Configuration conf,
-    List<InetSocketAddress> isas = new ArrayList<InetSocketAddress>();
-
-    // Configuration with a single namenode
-    if (nameserviceIds == null || nameserviceIds.isEmpty()) {
-      String address = getConfValue(defaultAddress, null, conf, keys);
-      if (address == null) {
-        return null;
-      }
-      isas.add(NetUtils.createSocketAddr(address));
-    } else {
-      // Get the namenodes for all the configured nameServiceIds
-      for (String nameserviceId : nameserviceIds) {
-        String address = getConfValue(null, nameserviceId, conf, keys);
-        if (address == null) {
-          return null;
-        }
-        isas.add(NetUtils.createSocketAddr(address));
+    
+    // Look for configurations of the form <key>[.<nameserviceId>][.<namenodeId>]
+    // across all of the configured nameservices and namenodes.
+    Map<String, Map<String, InetSocketAddress>> ret = Maps.newHashMap();
+    for (String nsId : emptyAsSingletonNull(nameserviceIds)) {
+      Map<String, InetSocketAddress> isas =
+        getAddressesForNameserviceId(conf, nsId, defaultAddress, keys);
+      if (!isas.isEmpty()) {
+        ret.put(nsId, isas);
-    return isas;
+    return ret;
+  }
+
+  private static Map<String, InetSocketAddress> getAddressesForNameserviceId(
+      Configuration conf, String nsId, String defaultValue,
+      String[] keys) {
+    Collection<String> nnIds = getNameNodeIds(conf, nsId);
+    Map<String, InetSocketAddress> ret = Maps.newHashMap();
+    for (String nnId : emptyAsSingletonNull(nnIds)) {
+      String suffix = concatSuffixes(nsId, nnId);
+      String address = getConfValue(defaultValue, suffix, conf, keys);
+      if (address != null) {
+        InetSocketAddress isa = NetUtils.createSocketAddr(address);
+        ret.put(nnId, isa);
+      }
+    }
+    return ret;
+  }
+
+  /**
+   * Returns list of InetSocketAddress corresponding to HA NN RPC addresses from
+   * the configuration.
+   * 
+   * @param conf configuration
+   * @return list of InetSocketAddresses
+   * @throws IOException if no addresses are configured
+   */
+  public static Map<String, Map<String, InetSocketAddress>> getHaNnRpcAddresses(
+      Configuration conf) {
+    return getAddresses(conf, null, DFSConfigKeys.DFS_NAMENODE_RPC_ADDRESS_KEY);
-  public static List<InetSocketAddress> getBackupNodeAddresses(
+  public static Map<String, Map<String, InetSocketAddress>> getBackupNodeAddresses(
-    List<InetSocketAddress> addressList = getAddresses(conf,
+    Map<String, Map<String, InetSocketAddress>> addressList = getAddresses(conf,
-    if (addressList == null) {
+    if (addressList.isEmpty()) {
-  public static List<InetSocketAddress> getSecondaryNameNodeAddresses(
+  public static Map<String, Map<String, InetSocketAddress>> getSecondaryNameNodeAddresses(
-    List<InetSocketAddress> addressList = getAddresses(conf, null,
+    Map<String, Map<String, InetSocketAddress>> addressList = getAddresses(conf, null,
-    if (addressList == null) {
+    if (addressList.isEmpty()) {
-  public static List<InetSocketAddress> getNNServiceRpcAddresses(
+  public static Map<String, Map<String, InetSocketAddress>> getNNServiceRpcAddresses(
-    List<InetSocketAddress> addressList = getAddresses(conf, defaultAddress,
+    Map<String, Map<String, InetSocketAddress>> addressList =
+      getAddresses(conf, defaultAddress,
-    if (addressList == null) {
+    if (addressList.isEmpty()) {
-   * Given the InetSocketAddress for any configured communication with a 
-   * namenode, this method returns the corresponding nameservice ID,
-   * by doing a reverse lookup on the list of nameservices until it
-   * finds a match.
+   * Flatten the given map, as returned by other functions in this class,
+   * into a flat list of {@link ConfiguredNNAddress} instances.
+   */
+  public static List<ConfiguredNNAddress> flattenAddressMap(
+      Map<String, Map<String, InetSocketAddress>> map) {
+    List<ConfiguredNNAddress> ret = Lists.newArrayList();
+    
+    for (Map.Entry<String, Map<String, InetSocketAddress>> entry :
+      map.entrySet()) {
+      String nsId = entry.getKey();
+      Map<String, InetSocketAddress> nnMap = entry.getValue();
+      for (Map.Entry<String, InetSocketAddress> e2 : nnMap.entrySet()) {
+        String nnId = e2.getKey();
+        InetSocketAddress addr = e2.getValue();
+        
+        ret.add(new ConfiguredNNAddress(nsId, nnId, addr));
+      }
+    }
+    return ret;
+  }
+
+  /**
+   * Format the given map, as returned by other functions in this class,
+   * into a string suitable for debugging display. The format of this string
+   * should not be considered an interface, and is liable to change.
+   */
+  public static String addressMapToString(
+      Map<String, Map<String, InetSocketAddress>> map) {
+    StringBuilder b = new StringBuilder();
+    for (Map.Entry<String, Map<String, InetSocketAddress>> entry :
+         map.entrySet()) {
+      String nsId = entry.getKey();
+      Map<String, InetSocketAddress> nnMap = entry.getValue();
+      b.append("Nameservice <").append(nsId).append(">:").append("\n");
+      for (Map.Entry<String, InetSocketAddress> e2 : nnMap.entrySet()) {
+        b.append("  NN ID ").append(e2.getKey())
+          .append(" => ").append(e2.getValue()).append("\n");
+      }
+    }
+    return b.toString();
+  }
+  
+  public static String nnAddressesAsString(Configuration conf) {
+    Map<String, Map<String, InetSocketAddress>> addresses =
+      getHaNnRpcAddresses(conf);
+    return addressMapToString(addresses);
+  }
+
+  /**
+   * Represent one of the NameNodes configured in the cluster.
+   */
+  public static class ConfiguredNNAddress {
+    private final String nameserviceId;
+    private final String namenodeId;
+    private final InetSocketAddress addr;
+
+    private ConfiguredNNAddress(String nameserviceId, String namenodeId,
+        InetSocketAddress addr) {
+      this.nameserviceId = nameserviceId;
+      this.namenodeId = namenodeId;
+      this.addr = addr;
+    }
+
+    public String getNameserviceId() {
+      return nameserviceId;
+    }
+
+    public String getNamenodeId() {
+      return namenodeId;
+    }
+
+    public InetSocketAddress getAddress() {
+      return addr;
+    }
+    
+    @Override
+    public String toString() {
+      return "ConfiguredNNAddress[nsId=" + nameserviceId + ";" +
+        "nnId=" + namenodeId + ";addr=" + addr + "]";
+    }
+  }
+  
+  /**
+   * Get a URI for each configured nameservice. If a nameservice is
+   * HA-enabled, then the logical URI of the nameservice is returned. If the
+   * nameservice is not HA-enabled, then a URI corresponding to an RPC address
+   * of the single NN for that nameservice is returned, preferring the service
+   * RPC address over the client RPC address.
+   * 
+   * @param conf configuration
+   * @return a collection of all configured NN URIs, preferring service
+   *         addresses
+   */
+  public static Collection<URI> getNsServiceRpcUris(Configuration conf) {
+    return getNameServiceUris(conf,
+        DFSConfigKeys.DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY,
+        DFSConfigKeys.DFS_NAMENODE_RPC_ADDRESS_KEY);
+  }
+
+  /**
+   * Get a URI for each configured nameservice. If a nameservice is
+   * HA-enabled, then the logical URI of the nameservice is returned. If the
+   * nameservice is not HA-enabled, then a URI corresponding to the address of
+   * the single NN for that nameservice is returned.
+   * 
+   * @param conf configuration
+   * @param keys configuration keys to try in order to get the URI for non-HA
+   *        nameservices
+   * @return a collection of all configured NN URIs
+   */
+  public static Collection<URI> getNameServiceUris(Configuration conf,
+      String... keys) {
+    Set<URI> ret = new HashSet<URI>();
+    for (String nsId : getNameServiceIds(conf)) {
+      if (HAUtil.isHAEnabled(conf, nsId)) {
+        // Add the logical URI of the nameservice.
+        try {
+          ret.add(new URI(HdfsConstants.HDFS_URI_SCHEME + "://" + nsId));
+        } catch (URISyntaxException ue) {
+          throw new IllegalArgumentException(ue);
+        }
+      } else {
+        // Add the URI corresponding to the address of the NN.
+        for (String key : keys) {
+          String addr = conf.get(concatSuffixes(key, nsId));
+          if (addr != null) {
+            ret.add(createUri(HdfsConstants.HDFS_URI_SCHEME,
+                NetUtils.createSocketAddr(addr)));
+            break;
+          }
+        }
+      }
+    }
+    // Add the generic configuration keys.
+    for (String key : keys) {
+      String addr = conf.get(key);
+      if (addr != null) {
+        ret.add(createUri("hdfs", NetUtils.createSocketAddr(addr)));
+        break;
+      }
+    }
+    return ret;
+  }
+
+  /**
+   * Given the InetSocketAddress this method returns the nameservice Id
+   * corresponding to the key with matching address, by doing a reverse 
+   * lookup on the list of nameservices until it finds a match.
-  public static String getNameServiceIdFromAddress(Configuration conf, 
-      InetSocketAddress address, String... keys) {
-    Collection<String> nameserviceIds = getNameServiceIds(conf);
-
+  public static String getNameServiceIdFromAddress(final Configuration conf, 
+      final InetSocketAddress address, String... keys) {
-    if (nameserviceIds == null || nameserviceIds.isEmpty()) {
-      return null;
-    }
-    // Get the candidateAddresses for all the configured nameServiceIds
-    for (String nameserviceId : nameserviceIds) {
-      for (String key : keys) {
-        String candidateAddress = conf.get(
-            getNameServiceIdKey(key, nameserviceId));
-        if (candidateAddress != null
-            && address.equals(NetUtils.createSocketAddr(candidateAddress)))
-          return nameserviceId;
-      }
-    }
-    // didn't find a match
-    return null;
+    String[] ids = getSuffixIDs(conf, address, keys);
+    return (ids != null) ? ids[0] : null;
-
+  
-   * return server http or https address from the configuration
+   * return server http or https address from the configuration for a
+   * given namenode rpc address.
-   * @param namenode - namenode address
+   * @param namenodeAddr - namenode RPC address
-      InetSocketAddress namenode, Configuration conf, boolean httpsAddress) {
-    String httpAddress = null;
-    
-    String httpAddressKey = (UserGroupInformation.isSecurityEnabled() 
-        && httpsAddress) ? DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY
-        : DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY;
-    String httpAddressDefault = (UserGroupInformation.isSecurityEnabled() 
-        && httpsAddress) ? DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT
-        : DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_DEFAULT;
-    if(namenode != null) {
+      InetSocketAddress namenodeAddr, Configuration conf, boolean httpsAddress) {
+    boolean securityOn = UserGroupInformation.isSecurityEnabled();
+    String httpAddressKey = (securityOn && httpsAddress) ? 
+        DFS_NAMENODE_HTTPS_ADDRESS_KEY : DFS_NAMENODE_HTTP_ADDRESS_KEY;
+    String httpAddressDefault = (securityOn && httpsAddress) ? 
+        DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT : DFS_NAMENODE_HTTP_ADDRESS_DEFAULT;
+      
+    String suffixes[];
+    if (namenodeAddr != null) {
-      String nameServiceId = DFSUtil.getNameServiceIdFromAddress(
-          conf, namenode,
+      suffixes = getSuffixIDs(conf, namenodeAddr,
-
-      if (nameServiceId != null) {
-        httpAddress = conf.get(DFSUtil.getNameServiceIdKey(
-            httpAddressKey, nameServiceId));
-      }
-    }
-    // else - Use non-federation style configuration
-    if (httpAddress == null) {
-      httpAddress = conf.get(httpAddressKey, httpAddressDefault);
+    } else {
+      suffixes = new String[2];
-    return httpAddress;
+    return getSuffixedConf(conf, httpAddressKey, httpAddressDefault, suffixes);
+
-   * @return key specific to a nameserviceId from a generic key
+   * Substitute a default host in the case that an address has been configured
+   * with a wildcard. This is used, for example, when determining the HTTP
+   * address of the NN -- if it's configured to bind to 0.0.0.0, we want to
+   * substitute the hostname from the filesystem URI rather than trying to
+   * connect to 0.0.0.0.
+   * @param configuredAddress the address found in the configuration
+   * @param defaultHost the host to substitute with, if configuredAddress
+   * is a local/wildcard address.
+   * @return the substituted address
+   * @throws IOException if it is a wildcard address and security is enabled
-  public static String getNameServiceIdKey(String key, String nameserviceId) {
-    return key + "." + nameserviceId;
+  public static String substituteForWildcardAddress(String configuredAddress,
+      String defaultHost) throws IOException {
+    InetSocketAddress sockAddr = NetUtils.createSocketAddr(configuredAddress);
+    if (sockAddr.getAddress().isAnyLocalAddress()) {
+      if(UserGroupInformation.isSecurityEnabled()) {
+        throw new IOException("Cannot use a wildcard address with security. " +
+                              "Must explicitly set bind address for Kerberos");
+      }
+      return defaultHost + ":" + sockAddr.getPort();
+    } else {
+      return configuredAddress;
+    }
+  }
+  
+  private static String getSuffixedConf(Configuration conf,
+      String key, String defaultVal, String[] suffixes) {
+    String ret = conf.get(DFSUtil.addKeySuffixes(key, suffixes));
+    if (ret != null) {
+      return ret;
+    }
+    return conf.get(key, defaultVal);
-   * value of "key.nameserviceId" and if found sets that value into generic key 
-   * in the conf. Note that this only modifies the runtime conf.
+   * value of "key.nameserviceId.namenodeId" and if found sets that value into 
+   * generic key in the conf. If this is not found, falls back to
+   * "key.nameserviceId" and then the unmodified key.
+   *
+   * Note that this only modifies the runtime conf.
-   *          nameservice Id to construct the node specific key.
+   *          nameservice Id to construct the node specific key. Pass null if
+   *          federation is not configuration.
+   * @param nnId
+   *          namenode Id to construct the node specific key. Pass null if
+   *          HA is not configured.
-      String nameserviceId, String... keys) {
+      String nameserviceId, String nnId, String... keys) {
-      String value = conf.get(getNameServiceIdKey(key, nameserviceId));
+      String value = conf.get(addKeySuffixes(key, nameserviceId, nnId));
+      if (value != null) {
+        conf.set(key, value);
+        continue;
+      }
+      value = conf.get(addKeySuffixes(key, nameserviceId));
-
-
-  /** Create a {@link NameNode} proxy */
-  public static ClientProtocol createNamenode(Configuration conf)
-      throws IOException {
-    return createNamenode(NameNode.getAddress(conf), conf);
-  }
-
-  /** Create a {@link NameNode} proxy */
-  public static ClientProtocol createNamenode( InetSocketAddress nameNodeAddr,
-      Configuration conf) throws IOException {   
-    return createNamenode(nameNodeAddr, conf,
-        UserGroupInformation.getCurrentUser());
-  }
-    
-  /** Create a {@link NameNode} proxy */
-  public static ClientProtocol createNamenode( InetSocketAddress nameNodeAddr,
-      Configuration conf, UserGroupInformation ugi) throws IOException {
-    /** 
-     * Currently we have simply burnt-in support for a SINGLE
-     * protocol - protocolPB. This will be replaced
-     * by a way to pick the right protocol based on the 
-     * version of the target server.  
-     */
-    return new org.apache.hadoop.hdfs.protocolPB.
-        ClientNamenodeProtocolTranslatorPB(nameNodeAddr, conf, ugi);
-  }
-
+  
-  
+
-   * Get name service Id for the {@link NameNode} based on namenode RPC address
+   * Get nameservice Id for the {@link NameNode} based on namenode RPC address
-   * Get name service Id for the BackupNode based on backup node RPC address
+   * Get nameservice Id for the BackupNode based on backup node RPC address
-   * Get name service Id for the secondary node based on secondary http address
+   * Get nameservice Id for the secondary node based on secondary http address
-   * configured, this method determines the nameservice Id by matching the local
-   * nodes address with the configured addresses. When a match is found, it
-   * returns the nameservice Id from the corresponding configuration key.
+   * configured, and more than one nameservice Id is configured, this method 
+   * determines the nameservice Id by matching the local node's address with the
+   * configured addresses. When a match is found, it returns the nameservice Id
+   * from the corresponding configuration key.
-   * @return name service Id on success, null on failure.
+   * @return nameservice Id on success, null if federation is not configured.
-    
-    Collection<String> ids = getNameServiceIds(conf);
-    if (ids == null || ids.size() == 0) {
-      // Not federation configuration, hence no nameservice Id
-      return null;
+    Collection<String> nsIds = getNameServiceIds(conf);
+    if (1 == nsIds.size()) {
+      return nsIds.toArray(new String[1])[0];
+    String nnId = conf.get(DFS_HA_NAMENODE_ID_KEY);
-    // Match the rpc address with that of local address
+    return getSuffixIDs(conf, addressKey, null, nnId, LOCAL_ADDRESS_MATCHER)[0];
+  }
+  
+  /**
+   * Returns nameservice Id and namenode Id when the local host matches the
+   * configuration parameter {@code addressKey}.<nameservice Id>.<namenode Id>
+   * 
+   * @param conf Configuration
+   * @param addressKey configuration key corresponding to the address.
+   * @param knownNsId only look at configs for the given nameservice, if not-null
+   * @param knownNNId only look at configs for the given namenode, if not null
+   * @param matcher matching criteria for matching the address
+   * @return Array with nameservice Id and namenode Id on success. First element
+   *         in the array is nameservice Id and second element is namenode Id.
+   *         Null value indicates that the configuration does not have the the
+   *         Id.
+   * @throws HadoopIllegalArgumentException on error
+   */
+  static String[] getSuffixIDs(final Configuration conf, final String addressKey,
+      String knownNsId, String knownNNId,
+      final AddressMatcher matcher) {
+    String nameserviceId = null;
+    String namenodeId = null;
-    for (String id : ids) {
-      String addr = conf.get(getNameServiceIdKey(addressKey, id));
-      InetSocketAddress s = NetUtils.createSocketAddr(addr);
-      if (NetUtils.isLocalAddress(s.getAddress())) {
-        nameserviceId = id;
-        found++;
+    
+    Collection<String> nsIds = getNameServiceIds(conf);
+    for (String nsId : emptyAsSingletonNull(nsIds)) {
+      if (knownNsId != null && !knownNsId.equals(nsId)) {
+        continue;
+      }
+      
+      Collection<String> nnIds = getNameNodeIds(conf, nsId);
+      for (String nnId : emptyAsSingletonNull(nnIds)) {
+        if (LOG.isTraceEnabled()) {
+          LOG.trace(String.format("addressKey: %s nsId: %s nnId: %s",
+              addressKey, nsId, nnId));
+        }
+        if (knownNNId != null && !knownNNId.equals(nnId)) {
+          continue;
+        }
+        String key = addKeySuffixes(addressKey, nsId, nnId);
+        String addr = conf.get(key);
+        if (addr == null) {
+          continue;
+        }
+        InetSocketAddress s = null;
+        try {
+          s = NetUtils.createSocketAddr(addr);
+        } catch (Exception e) {
+          LOG.warn("Exception in creating socket address " + addr, e);
+          continue;
+        }
+        if (!s.isUnresolved() && matcher.match(s)) {
+          nameserviceId = nsId;
+          namenodeId = nnId;
+          found++;
+        }
-      throw new HadoopIllegalArgumentException(
-          "Configuration has multiple RPC addresses that matches "
-              + "the local node's address. Please configure the system with "
-              + "the parameter " + DFS_FEDERATION_NAMESERVICE_ID);
+      String msg = "Configuration has multiple addresses that match "
+          + "local node's address. Please configure the system with "
+          + DFS_FEDERATION_NAMESERVICE_ID + " and "
+          + DFS_HA_NAMENODE_ID_KEY;
+      throw new HadoopIllegalArgumentException(msg);
-    if (found == 0) {
-      throw new HadoopIllegalArgumentException("Configuration address "
-          + addressKey + " is missing in configuration with name service Id");
+    return new String[] { nameserviceId, namenodeId };
+  }
+  
+  /**
+   * For given set of {@code keys} adds nameservice Id and or namenode Id
+   * and returns {nameserviceId, namenodeId} when address match is found.
+   * @see #getSuffixIDs(Configuration, String, AddressMatcher)
+   */
+  static String[] getSuffixIDs(final Configuration conf,
+      final InetSocketAddress address, final String... keys) {
+    AddressMatcher matcher = new AddressMatcher() {
+     @Override
+      public boolean match(InetSocketAddress s) {
+        return address.equals(s);
+      } 
+    };
+    
+    for (String key : keys) {
+      String[] ids = getSuffixIDs(conf, key, null, null, matcher);
+      if (ids != null && (ids [0] != null || ids[1] != null)) {
+        return ids;
+      }
-    return nameserviceId;
+    return null;
+  }
+  
+  private interface AddressMatcher {
+    public boolean match(InetSocketAddress s);
+
+  /**
+   * Map a logical namenode ID to its service address. Use the given
+   * nameservice if specified, or the configured one if none is given.
+   *
+   * @param conf Configuration
+   * @param nsId which nameservice nnId is a part of, optional
+   * @param nnId the namenode ID to get the service addr for
+   * @return the service addr, null if it could not be determined
+   */
+  public static String getNamenodeServiceAddr(final Configuration conf,
+      String nsId, String nnId) {
+
+    if (nsId == null) {
+      Collection<String> nsIds = getNameServiceIds(conf);
+      if (1 == nsIds.size()) {
+        nsId = nsIds.toArray(new String[1])[0];
+      } else {
+        // No nameservice ID was given and more than one is configured
+        return null;
+      }
+    }
+
+    String serviceAddrKey = concatSuffixes(
+        DFSConfigKeys.DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, nsId, nnId);
+
+    String addrKey = concatSuffixes(
+        DFSConfigKeys.DFS_NAMENODE_RPC_ADDRESS_KEY, nsId, nnId);
+
+    String serviceRpcAddr = conf.get(serviceAddrKey);
+    if (serviceRpcAddr == null) {
+      serviceRpcAddr = conf.get(addrKey);
+    }
+    return serviceRpcAddr;
+  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 UPD40 UPD40 INS40 INS40 INS40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS23 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS31 INS83 INS83 INS83 INS43 INS59 MOV83 INS42 INS8 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 UPD74 MOV74 UPD42 MOV42 INS44 INS8 INS29 INS83 INS83 INS74 INS42 MOV44 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 MOV44 INS44 INS8 MOV29 INS83 INS83 INS74 INS42 MOV44 MOV44 MOV44 INS8 INS83 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS74 INS42 MOV44 INS8 INS74 INS74 INS74 INS29 INS83 INS83 UPD74 MOV74 INS42 INS44 INS8 INS29 INS83 INS83 MOV43 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS74 INS42 MOV44 INS8 INS29 INS83 INS83 INS74 INS42 MOV44 INS44 INS8 MOV29 MOV83 MOV83 MOV43 UPD42 MOV42 MOV44 INS44 MOV44 INS8 MOV29 INS83 INS83 MOV43 INS42 MOV44 MOV44 MOV44 MOV8 INS43 INS42 INS44 MOV43 INS8 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS44 MOV29 UPD83 MOV83 MOV83 MOV43 INS42 MOV44 MOV44 INS8 MOV29 UPD83 MOV83 INS5 INS42 INS44 MOV44 MOV44 INS44 INS44 INS8 INS29 INS83 INS5 INS42 INS44 INS44 INS44 INS8 INS83 INS42 INS31 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS42 INS42 INS32 INS65 INS42 INS42 INS14 INS65 UPD43 INS43 INS74 INS42 INS25 INS65 INS65 INS65 INS65 UPD43 MOV43 INS43 INS43 INS42 INS60 INS41 INS65 INS42 INS43 INS42 MOV43 INS42 INS25 INS6 INS41 INS65 INS42 INS43 INS42 MOV25 INS41 INS65 INS42 INS43 INS42 INS60 INS41 INS43 INS43 INS74 MOV60 INS60 INS70 INS41 INS43 INS43 MOV43 INS43 INS42 MOV43 INS42 INS43 INS42 INS5 INS42 MOV60 INS60 INS70 INS41 INS65 INS65 INS65 INS65 INS43 INS43 INS74 MOV41 INS43 INS43 INS74 INS43 INS43 INS74 INS43 INS43 INS74 INS65 INS43 INS74 INS42 INS60 INS70 INS41 INS65 INS74 INS42 INS60 MOV70 INS41 INS42 INS43 INS42 INS60 MOV41 INS65 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 MOV43 INS59 INS83 INS42 MOV44 MOV44 MOV44 INS8 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS8 INS83 MOV43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS65 INS65 INS65 INS43 INS43 MOV41 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS60 MOV70 INS70 INS41 INS83 INS43 INS42 INS83 MOV43 INS42 INS60 INS41 UPD42 INS60 INS41 INS65 INS65 INS65 INS65 INS42 UPD42 INS43 INS42 INS60 INS25 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS5 INS42 INS60 INS25 INS41 INS65 INS43 INS42 MOV60 MOV25 INS60 INS25 INS60 MOV41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS83 INS43 INS42 INS83 INS43 UPD42 UPD43 UPD42 INS43 INS42 INS83 INS43 INS42 INS60 INS60 MOV60 INS60 INS70 MOV25 INS41 INS65 INS65 INS43 INS85 INS83 INS43 INS42 INS83 MOV43 INS42 INS83 INS43 INS42 INS60 INS70 MOV41 INS83 INS39 INS42 INS44 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS60 INS60 INS60 INS25 MOV41 INS42 INS42 INS32 INS66 INS43 INS1 UPD66 INS66 INS66 UPD42 INS42 MOV43 MOV43 INS27 INS8 INS8 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 UPD42 INS42 UPD42 MOV42 MOV43 INS59 INS32 INS66 INS42 MOV27 INS8 INS38 INS27 INS27 INS66 INS42 INS32 INS66 INS42 INS43 INS59 INS32 UPD66 UPD66 UPD66 INS42 INS42 INS43 INS43 MOV43 INS74 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS42 MOV43 INS85 INS74 INS59 INS44 INS32 INS8 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS43 INS43 INS43 INS32 INS42 INS42 UPD43 MOV43 INS43 INS43 INS74 INS32 INS42 INS42 UPD43 MOV43 INS43 INS43 INS74 INS32 INS42 INS42 INS43 INS43 INS43 INS74 INS32 INS66 INS66 INS65 INS66 INS42 INS43 INS43 INS74 UPD74 MOV74 INS59 INS44 INS32 INS8 INS42 INS66 INS66 INS66 INS43 INS43 INS74 INS43 INS59 INS32 INS32 INS42 INS74 INS59 INS32 INS66 INS42 INS42 INS42 INS42 INS42 UPD42 MOV43 UPD42 INS21 INS21 INS21 INS42 MOV41 INS42 INS41 INS41 INS42 INS42 INS41 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS42 INS74 INS59 INS44 MOV32 INS8 INS44 INS42 INS8 INS42 UPD66 UPD66 UPD66 INS42 INS5 INS59 INS16 UPD66 INS66 UPD42 UPD66 INS39 INS43 INS43 INS43 INS59 INS8 MOV8 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 UPD66 INS42 INS66 INS42 MOV43 INS59 INS32 INS8 INS8 INS42 INS42 INS42 INS43 INS85 INS43 INS59 INS27 INS8 INS32 UPD66 INS66 INS66 UPD66 UPD66 INS66 INS42 INS66 INS66 INS42 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS74 INS59 INS27 INS8 INS43 INS59 INS2 INS66 UPD66 MOV66 INS65 INS66 UPD42 MOV42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS42 UPD66 MOV66 INS42 UPD42 MOV42 INS42 UPD42 INS42 INS42 INS43 INS59 INS43 INS59 INS74 INS59 INS44 INS32 INS8 INS3 INS66 INS65 INS66 INS66 INS68 INS42 INS42 INS42 INS43 INS59 INS44 INS42 INS8 INS43 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS27 MOV8 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 UPD42 INS57 INS42 INS42 INS31 UPD42 INS27 INS32 INS41 INS41 INS42 INS32 INS42 INS42 INS42 MOV21 INS41 INS32 INS45 INS42 INS45 INS42 INS45 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS74 INS42 INS32 INS43 INS42 INS42 INS42 INS60 INS25 UPD42 INS32 INS43 INS43 MOV43 INS42 INS32 MOV43 INS42 INS42 INS42 INS60 MOV60 INS25 INS42 INS42 INS42 INS42 INS42 INS33 INS40 UPD42 INS42 INS42 INS43 INS43 INS74 INS42 INS42 UPD42 INS42 INS42 INS43 INS43 INS74 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS74 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS60 INS70 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS14 INS74 INS42 INS42 INS42 INS60 INS60 INS21 INS70 INS42 INS42 INS43 INS43 INS74 INS42 INS32 INS42 INS42 INS7 INS7 INS7 INS42 INS42 INS27 INS42 INS42 INS40 INS40 INS43 INS43 INS42 INS14 MOV43 INS42 INS25 INS43 INS42 INS60 INS25 INS43 INS85 INS42 INS32 INS36 INS2 INS33 UPD42 MOV32 INS42 INS42 INS42 INS42 INS85 UPD42 INS21 INS42 MOV42 MOV42 MOV42 INS42 INS42 INS32 INS32 INS42 INS25 MOV41 INS41 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS25 INS21 INS43 INS43 INS42 INS32 INS34 INS32 INS41 INS42 INS42 INS32 INS32 INS34 INS66 INS42 INS42 INS33 INS42 INS42 INS33 INS43 INS43 INS42 INS32 INS43 INS42 INS42 INS42 MOV25 INS60 MOV70 INS60 INS53 INS5 INS4 INS66 INS42 INS69 INS69 INS69 INS42 INS42 INS14 INS43 INS42 INS60 INS25 INS42 INS42 INS33 INS60 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS43 INS83 INS39 INS42 INS44 INS8 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD7 UPD42 UPD42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 MOV43 INS42 INS42 INS42 INS74 INS59 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS59 MOV43 UPD27 MOV27 INS8 INS42 INS42 UPD43 MOV43 INS43 INS43 INS42 INS42 UPD43 MOV43 INS43 INS43 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS74 MOV43 INS59 INS74 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS43 INS43 INS43 INS74 INS43 INS59 INS74 INS59 INS32 INS44 INS32 INS8 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS45 UPD42 MOV42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS74 INS32 INS8 INS8 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS34 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 MOV32 INS8 INS42 INS42 INS42 INS32 INS42 INS43 INS27 INS8 INS7 UPD42 MOV42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS2 INS42 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS33 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD27 INS8 INS74 INS59 INS44 INS32 INS43 INS59 INS14 INS43 INS85 INS42 INS42 INS43 INS43 INS43 INS43 INS1 INS42 INS5 INS59 INS27 INS8 INS74 INS59 INS27 INS8 MOV8 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS43 INS42 INS41 INS42 UPD42 MOV42 INS33 INS32 INS42 INS42 INS45 INS42 INS42 INS43 INS43 MOV43 INS42 INS32 INS32 INS21 INS42 INS32 INS60 INS21 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS60 MOV21 INS42 INS40 MOV42 INS43 INS43 INS43 INS42 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS32 UPD42 MOV42 INS45 INS74 INS42 INS42 INS42 MOV21 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS54 MOV70 INS42 INS42 INS32 INS42 INS33 INS21 INS10 INS42 INS33 INS42 INS32 UPD42 INS3 INS53 UPD42 UPD45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS18 INS42 INS32 INS32 INS34 UPD27 INS38 INS18 INS43 INS43 INS42 INS32 INS43 INS42 INS42 INS42 INS25 INS25 INS60 INS25 INS54 UPD42 MOV42 INS42 INS27 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS31 INS43 INS85 INS42 INS32 INS27 INS36 INS41 INS43 INS43 INS42 INS32 INS34 INS32 INS21 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS42 MOV43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS59 MOV43 INS59 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 INS45 INS43 INS43 INS43 INS32 INS42 INS42 INS8 INS12 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV40 MOV40 INS5 INS34 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS3 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS27 INS8 INS43 INS59 INS43 INS27 INS8 INS43 INS8 INS12 INS27 INS27 INS42 UPD45 MOV45 UPD42 MOV42 INS78 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS42 INS42 INS33 INS33 INS42 INS42 INS33 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS32 UPD42 INS14 INS32 INS42 UPD42 MOV42 INS40 INS42 INS42 INS32 INS42 INS45 INS21 INS44 INS8 INS42 INS42 INS32 INS43 INS85 MOV43 INS27 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS34 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS21 INS27 INS38 INS18 INS42 INS42 INS32 INS42 INS42 INS33 INS18 INS42 INS33 INS21 INS44 INS8 INS38 INS32 INS21 UPD45 MOV45 UPD45 MOV45 INS42 INS43 INS42 INS41 INS27 INS27 INS42 INS2 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 INS45 INS32 INS42 INS32 INS32 INS43 INS42 INS53 INS43 INS27 INS8 INS42 INS45 INS32 INS42 INS45 INS45 INS43 INS85 INS32 INS42 INS33 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS7 INS43 INS42 INS21 INS18 INS32 INS42 INS42 INS42 INS7 INS42 INS32 INS2 INS33 INS2 INS33 INS32 INS34 INS42 INS32 INS42 INS45 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 UPD42 UPD42 MOV42 MOV33 INS21 INS10 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV32 INS42 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS3 INS32 INS42 INS32 INS43 INS27 INS43 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS5 INS34 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS42 INS40 INS45 INS42 INS42 UPD42 UPD42 INS42 UPD42 MOV42 INS32 INS45 INS42 INS43 INS85 UPD42 MOV42 INS40 MOV32 INS42 UPD42 DEL45 DEL42 DEL27 DEL42 DEL33 DEL27 DEL8 DEL25 DEL33 DEL33 DEL83 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL74 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL8 DEL25 DEL8 DEL8 DEL25 DEL8 DEL31 DEL74 DEL74 DEL42 DEL33 DEL27 DEL74 DEL74 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL32 DEL27 DEL42 DEL8 DEL66 DEL42 DEL33 DEL40 DEL40 DEL40 DEL40 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL83 DEL83 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL8 DEL25 DEL8 DEL31 DEL31 DEL42 DEL42 DEL8 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL43 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL43 DEL42 DEL8 DEL31 DEL83 DEL43 DEL42 DEL43 DEL40 DEL43 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL32 DEL32 DEL65 DEL65 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL43 DEL27 DEL14 DEL53 DEL83 DEL83 DEL42 DEL42 DEL34 DEL27 DEL25 DEL8 DEL31 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53
HDFS-9799. Reimplement getCurrentTrashDir to remove incompatibility. (zhz)

Change-Id: I7834bcebffed38cb384db5395ddb8b6dd9e79a0b

-   * 2. File not in encryption zone returns /users/username/.Trash
+   * 2. File not in encryption zone, or encountered exception when checking
+   *    the encryption zone of the path, returns /users/username/.Trash
-   * @throws IOException
-  public Path getTrashRoot(Path path) throws IOException {
+  public Path getTrashRoot(Path path) {
-    EncryptionZone ez = dfs.getEZForPath(parentSrc);
-    if ((ez != null)) {
-      return this.makeQualified(
-          new Path(ez.getPath() + "/" + FileSystem.TRASH_PREFIX +
-              dfs.ugi.getShortUserName()));
-    } else {
-      return super.getTrashRoot(path);
+    try {
+      EncryptionZone ez = dfs.getEZForPath(parentSrc);
+      if ((ez != null)) {
+        return this.makeQualified(
+            new Path(ez.getPath() + "/" + FileSystem.TRASH_PREFIX +
+                dfs.ugi.getShortUserName()));
+      }
+    } catch (IOException e) {
+      DFSClient.LOG.warn("Exception in checking the encryption zone for the " +
+          "path " + parentSrc + ". " + e.getMessage());
+    return super.getTrashRoot(path);
-   * @allUsers return trashRoots of all users if true, used by emptier
+   * @param allUsers return trashRoots of all users if true, used by emptier
-   * @throws IOException
-  public Collection<FileStatus> getTrashRoots(boolean allUsers) throws IOException {
-    List<FileStatus> ret = new ArrayList<FileStatus>();
+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {
+    List<FileStatus> ret = new ArrayList<>();
-    // Get EZ Trash roots
-    final RemoteIterator<EncryptionZone> it = dfs.listEncryptionZones();
-    while (it.hasNext()) {
-      Path ezTrashRoot = new Path(it.next().getPath(), FileSystem.TRASH_PREFIX);
-      if (allUsers) {
-        for (FileStatus candidate : listStatus(ezTrashRoot)) {
-          if (exists(candidate.getPath())) {
-            ret.add(candidate);
+    try {
+      // Get EZ Trash roots
+      final RemoteIterator<EncryptionZone> it = dfs.listEncryptionZones();
+      while (it.hasNext()) {
+        Path ezTrashRoot = new Path(it.next().getPath(),
+            FileSystem.TRASH_PREFIX);
+        if (allUsers) {
+          for (FileStatus candidate : listStatus(ezTrashRoot)) {
+            if (exists(candidate.getPath())) {
+              ret.add(candidate);
+            }
+          }
+        } else {
+          Path userTrash = new Path(ezTrashRoot, System.getProperty(
+              "user.name"));
+          if (exists(userTrash)) {
+            ret.add(getFileStatus(userTrash));
-      } else {
-        Path userTrash = new Path(ezTrashRoot, System.getProperty("user.name"));
-        if (exists(userTrash)) {
-          ret.add(getFileStatus(userTrash));
-        }
+    } catch (IOException e){
+      DFSClient.LOG.warn("Cannot get all encrypted trash roots", e);

INS54 MOV41 UPD65 INS54 INS66 UPD66 INS8 INS12 INS42 INS8 INS12 MOV60 MOV25 INS44 INS8 MOV60 MOV61 INS44 INS8 MOV43 INS42 INS21 UPD74 MOV43 INS42 INS21 INS32 INS32 INS40 INS42 INS27 INS40 INS42 INS45 INS42 INS27 INS42 INS45 INS32 INS45 INS45 INS42 INS42 DEL42 DEL65 DEL8 DEL42 DEL65 DEL42 DEL43
HDDS-1638.  Implement Key Write Requests to use Cache and DoubleBuffer. (#956)



-      // During iteration from DB, check in mean time if this bucket is not
-      // marked for delete.
-      if (kv != null && kv.getKey().startsWith(volumePrefix) &&
-          bucketTable.get(kv.getKey()) != null) {
-        return false; // we found at least one bucket with this volume prefix.
+
+      if (kv != null) {
+        // Check the entry in db is not marked for delete. This can happen
+        // while entry is marked for delete, but it is not flushed to DB.
+        CacheValue<OmBucketInfo> cacheValue =
+            bucketTable.getCacheValue(new CacheKey(kv.getKey()));
+        if (cacheValue != null) {
+          if (kv.getKey().startsWith(volumePrefix)
+              && cacheValue.getCacheValue() != null) {
+            return false; // we found at least one bucket with this volume
+            // prefix.
+          }
+        } else {
+          if (kv.getKey().startsWith(volumePrefix)) {
+            return false; // we found at least one bucket with this volume
+            // prefix.
+          }
+        }
+
-    //TODO: When Key ops are converted in to HA model, use cache also to
-    // determine bucket is empty or not.
+
+    // First check in key table cache.
+    Iterator<Map.Entry<CacheKey<String>, CacheValue<OmKeyInfo>>> iterator =
+        ((TypedTable< String, OmKeyInfo>) keyTable).cacheIterator();
+    while (iterator.hasNext()) {
+      Map.Entry< CacheKey<String>, CacheValue<OmKeyInfo>> entry =
+          iterator.next();
+      String key = entry.getKey().getCacheKey();
+      OmKeyInfo omKeyInfo = entry.getValue().getCacheValue();
+      // Making sure that entry is not for delete key request.
+      if (key.startsWith(keyPrefix) && omKeyInfo != null) {
+        return false;
+      }
+    }
-      if (kv != null && kv.getKey().startsWith(keyPrefix)) {
-        return false; // we found at least one key with this vol/bucket prefix.
+
+      if (kv != null) {
+        // Check the entry in db is not marked for delete. This can happen
+        // while entry is marked for delete, but it is not flushed to DB.
+        CacheValue<OmKeyInfo> cacheValue =
+            keyTable.getCacheValue(new CacheKey(kv.getKey()));
+        if (cacheValue != null) {
+          if (kv.getKey().startsWith(keyPrefix)
+              && cacheValue.getCacheValue() != null) {
+            return false; // we found at least one key with this vol/bucket
+            // prefix.
+          }
+        } else {
+          if (kv.getKey().startsWith(keyPrefix)) {
+            return false; // we found at least one key with this vol/bucket
+            // prefix.
+          }
+        }
+

INS60 INS61 INS74 INS59 INS32 INS8 INS25 INS43 INS74 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS25 INS25 MOV27 INS8 INS42 INS43 INS74 INS74 INS36 INS42 INS74 INS59 INS43 INS59 INS43 INS59 INS27 INS8 MOV27 INS8 INS60 INS25 INS40 INS43 INS43 INS43 INS43 INS11 INS43 INS74 INS74 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS27 INS41 INS60 INS25 INS74 INS59 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS74 INS42 INS40 INS43 INS43 INS43 INS43 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS33 INS9 INS74 INS59 INS27 INS8 INS8 INS43 INS43 INS42 MOV32 INS42 INS33 MOV25 INS25 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS33 MOV25 INS25 INS42 INS42 UPD42 INS14 MOV27 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS32 INS8 INS43 MOV32 INS27 INS32 INS42 INS42 INS41 INS43 INS32 INS27 INS32 INS42 INS42 INS41 INS42 INS32 INS33 INS42 INS42 INS9 INS42 INS42 INS42 INS32 INS33 INS42 INS42 INS9 INS42 INS42 INS42 INS42 DEL33 DEL27 DEL27
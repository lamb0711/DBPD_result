HDFS-4103. Support O(1) snapshot creation.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68

-  @Override
-  public Pair<INodeDirectory, INodeDirectory> createSnapshotCopy() {
-    return new Pair<INodeDirectory, INodeDirectory>(this,
-        new INodeDirectory(this, false));
-  }
-  
-  protected int searchChildrenForExistingINode(byte[] name) {
+  protected int searchChildrenForExistingINode(final INode inode) {
+    final byte[] name = inode.getLocalNameBytes();
-  /** Replace a child that has the same name as newChild by newChild.
+  /**
+   * Remove the specified child from this directory.
-   * @param newChild Child node to be added
+   * @param child the child inode to be removed
+   * @param latest See {@link INode#recordModification(Snapshot)}.
+   * @return the removed child inode.
-  void replaceChild(INode newChild) {
+  public INode removeChild(INode child, Snapshot latest) {
-    final int low = searchChildren(newChild.getLocalNameBytes());
-    if (low>=0) { // an old child exists so replace by the newChild
-      children.get(low).parent = null;
-      children.set(low, newChild);
-    } else {
-      throw new IllegalArgumentException("No child exists to be replaced");
+    if (latest != null) {
+      final INodeDirectoryWithSnapshot dir = replaceSelf4INodeDirectoryWithSnapshot(latest);
+      return dir.removeChild(child, latest);
+
+    final int i = searchChildren(child.getLocalNameBytes());
+    return i >= 0? children.remove(i): null;
+  }
+
+  /**
+   * Replace itself with {@link INodeDirectoryWithQuota} or
+   * {@link INodeDirectoryWithSnapshot} depending on the latest snapshot.
+   */
+  INodeDirectoryWithQuota replaceSelf4Quota(final Snapshot latest,
+      final long nsQuota, final long dsQuota) {
+    Preconditions.checkState(!(this instanceof INodeDirectoryWithQuota),
+        "this is already an INodeDirectoryWithQuota, this=%s", this);
+
+    if (latest == null) {
+      final INodeDirectoryWithQuota q = new INodeDirectoryWithQuota(
+          this, true, nsQuota, dsQuota);
+      replaceSelf(q);
+      return q;
+    } else {
+      final INodeDirectoryWithSnapshot s
+          = INodeDirectoryWithSnapshot.newInstance(this, null);
+      s.setQuota(nsQuota, dsQuota, null);
+      replaceSelf(s);
+      s.save2Snapshot(latest, this);
+      return s;
+    }
+  }
+  /** Replace itself with an {@link INodeDirectorySnapshottable}. */
+  public INodeDirectorySnapshottable replaceSelf4INodeDirectorySnapshottable(
+      Snapshot latest) {
+    final INodeDirectorySnapshottable s = new INodeDirectorySnapshottable(this);
+    replaceSelf(s);
+    s.save2Snapshot(latest, this);
+    return s;
+  }
+
+  /** Replace itself with an {@link INodeDirectoryWithSnapshot}. */
+  public INodeDirectoryWithSnapshot replaceSelf4INodeDirectoryWithSnapshot(
+      Snapshot latest) {
+    Preconditions.checkState(!(this instanceof INodeDirectoryWithSnapshot),
+        "this is already an INodeDirectoryWithSnapshot, this=%s", this);
+
+    final INodeDirectoryWithSnapshot withSnapshot
+        = INodeDirectoryWithSnapshot.newInstance(this, latest);
+    replaceSelf(withSnapshot);
+    return withSnapshot;
+  }
+
+  /** Replace itself with {@link INodeDirectory}. */
+  public INodeDirectory replaceSelf4INodeDirectory() {
+    Preconditions.checkState(getClass() != INodeDirectory.class,
+        "the class is already INodeDirectory, this=%s", this);
+
+    final INodeDirectory newNode = new INodeDirectory(this, true);
+    replaceSelf(newNode);
+    return newNode;
+  }
+
+  /** Replace itself with the given directory. */
+  private final void replaceSelf(INodeDirectory newDir) {
+    final INodeDirectory parent = getParent();
+    Preconditions.checkArgument(parent != null, "parent is null, this=%s", this);
+
+    final int i = parent.searchChildrenForExistingINode(newDir);
+    final INode oldDir = parent.children.set(i, newDir);
+    oldDir.setParent(null);
-    final int i = searchChildrenForExistingINode(newChild.getLocalNameBytes());
+    final int i = searchChildrenForExistingINode(newChild);
-  private INode getChild(byte[] name, Snapshot snapshot) {
+  @Override
+  public Pair<? extends INode, ? extends INode> recordModification(Snapshot latest) {
+    if (latest == null) {
+      return null;
+    }
+    return replaceSelf4INodeDirectoryWithSnapshot(latest)
+        .save2Snapshot(latest, this);
+  }
+
+  /**
+   * Save the child to the latest snapshot.
+   * 
+   * @return a pair of inodes, where the left inode is the original child and
+   *         the right inode is the snapshot copy of the child; see also
+   *         {@link INode#createSnapshotCopy()}.
+   */
+  public Pair<? extends INode, ? extends INode> saveChild2Snapshot(
+      INode child, Snapshot latest) {
+    if (latest == null) {
+      return null;
+    }
+    return replaceSelf4INodeDirectoryWithSnapshot(latest)
+        .saveChild2Snapshot(child, latest);
+  }
+
+  /**
+   * @param name the name of the child
+   * @param snapshot
+   *          if it is not null, get the result from the given snapshot;
+   *          otherwise, get the result from the current directory.
+   * @return the child inode.
+   */
+  public INode getChild(byte[] name, Snapshot snapshot) {
-      INodeDirectory parentDir = (INodeDirectory)curNode;
+      final INodeDirectory parentDir = (INodeDirectory)curNode;
+      final byte[] childName = components[count + 1];
-      if (isDotSnapshotDir(components[count + 1])
+      if (isDotSnapshotDir(childName)
-          return existing;
+          break;
-        curNode = parentDir.getChild(components[count + 1],
-            existing.getPathSnapshot());
+        curNode = parentDir.getChild(childName, existing.getPathSnapshot());
-  int nextChild(byte[] name) {
+  static int nextChild(ReadOnlyList<INode> children, byte[] name) {
-    int nextPos = Collections.binarySearch(children, name) + 1;
+    int nextPos = ReadOnlyList.Util.binarySearch(children, name) + 1;
-  public boolean addChild(final INode node, final boolean setModTime) {
+  public boolean addChild(final INode node, final boolean setModTime,
+      final Snapshot latest) {
+    if (latest != null) {
+      final INodeDirectoryWithSnapshot dir = replaceSelf4INodeDirectoryWithSnapshot(latest);
+      return dir.addChild(node, setModTime, latest);
+    }
+
-    if (setModTime)
-      updateModificationTime(node.getModificationTime());
+    if (setModTime) {
+      updateModificationTime(node.getModificationTime(), latest);
+    }
-      node.setGroup(getGroupName());
+      node.setGroup(getGroupName(), latest);
-    return parent.addChild(newNode, true);
+    return parent.addChild(newNode, true, iip.getLatestSnapshot());
+
-  static class INodesInPath {
+  public static class INodesInPath {
-  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix) {
-    super.dumpTreeRecursively(out, prefix);
+  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix,
+      final Snapshot snapshot) {
+    super.dumpTreeRecursively(out, prefix, snapshot);
-    dumpTreeRecursively(out, prefix, children);
+    dumpTreeRecursively(out, prefix,
+        new Iterable<Pair<? extends INode, Snapshot>>() {
+      final Iterator<INode> i = getChildrenList(snapshot).iterator();
+      
+      @Override
+      public Iterator<Pair<? extends INode, Snapshot>> iterator() {
+        return new Iterator<Pair<? extends INode, Snapshot>>() {
+          @Override
+          public boolean hasNext() {
+            return i.hasNext();
+          }
+
+          @Override
+          public Pair<INode, Snapshot> next() {
+            return new Pair<INode, Snapshot>(i.next(), snapshot);
+          }
+
+          @Override
+          public void remove() {
+            throw new UnsupportedOperationException();
+          }
+        };
+      }
+    });
-      StringBuilder prefix, Iterable<? extends INode> subs) {
+      StringBuilder prefix, Iterable<Pair<? extends INode, Snapshot>> subs) {
-      for(final Iterator<? extends INode> i = subs.iterator(); i.hasNext();) {
-        final INode inode = i.next();
+      for(final Iterator<Pair<? extends INode, Snapshot>> i = subs.iterator(); i.hasNext();) {
+        final Pair<? extends INode, Snapshot> pair = i.next();
-        inode.dumpTreeRecursively(out, prefix);
+        pair.left.dumpTreeRecursively(out, prefix, pair.right);

INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV29 INS83 INS43 UPD42 MOV42 MOV44 INS44 INS8 INS29 INS43 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 MOV43 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 MOV78 INS83 INS74 INS42 INS44 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS8 INS29 UPD83 INS83 INS44 INS44 INS83 INS44 INS83 INS43 INS42 INS60 INS65 INS65 INS42 UPD42 INS43 INS42 MOV21 INS25 MOV60 INS41 INS65 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS21 INS25 INS65 INS42 INS43 INS42 INS60 INS21 INS21 INS41 INS65 INS42 INS43 INS42 INS21 INS60 INS21 INS41 INS65 INS21 INS60 INS21 INS41 INS65 INS43 INS42 INS60 INS21 INS60 INS60 INS21 MOV43 INS76 INS76 INS43 INS42 INS25 INS41 INS65 INS65 MOV43 INS76 INS76 INS43 INS42 INS43 INS42 INS25 INS41 INS65 INS65 INS65 INS74 INS42 INS83 INS43 INS42 INS25 INS83 INS43 INS42 INS74 INS42 INS83 INS5 INS59 UPD66 UPD42 UPD66 INS42 INS66 INS65 INS66 INS66 INS42 INS27 INS8 INS16 INS66 INS65 INS66 INS65 INS66 INS42 INS32 INS27 INS8 INS8 INS66 INS65 INS66 INS42 INS83 INS43 INS59 INS32 INS32 INS42 INS66 INS65 INS66 INS42 INS32 INS83 INS43 INS59 INS32 INS42 INS66 INS65 INS66 INS32 INS83 MOV43 INS59 INS32 INS42 INS66 INS42 INS83 MOV43 INS59 INS32 INS83 INS39 INS59 INS83 INS43 INS59 INS32 INS43 INS43 INS42 INS27 INS8 INS32 INS66 INS66 INS66 INS65 INS66 INS43 INS43 INS42 INS42 INS27 INS8 INS32 INS42 INS66 INS42 INS66 INS66 INS66 INS43 INS43 INS42 INS27 INS8 INS8 INS42 INS43 INS74 INS39 INS85 INS42 INS32 INS68 INS42 INS33 INS60 INS41 UPD42 INS27 INS32 INS33 INS42 INS42 INS42 INS42 INS38 INS45 INS52 INS42 INS33 INS60 INS21 INS41 INS60 MOV21 INS21 INS21 INS41 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS38 INS45 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS45 INS52 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS45 INS52 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS42 INS33 INS41 INS32 INS42 INS42 INS52 INS68 INS42 INS42 INS42 INS33 INS41 INS32 INS42 INS42 INS42 INS60 INS42 INS42 INS42 INS33 INS60 INS41 MOV21 INS32 INS42 INS14 INS42 INS43 INS76 INS43 INS42 INS42 INS42 INS42 INS69 INS83 INS43 INS59 INS32 UPD42 MOV42 MOV34 MOV42 UPD42 MOV42 UPD42 MOV42 INS36 INS83 INS43 INS59 INS32 INS42 INS83 INS43 INS59 INS32 INS32 INS42 INS43 INS52 INS36 INS42 INS42 INS52 INS42 INS32 INS57 MOV43 INS52 INS9 INS42 INS42 INS33 INS42 INS42 INS42 INS40 INS42 INS42 INS42 MOV42 INS33 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS83 INS83 INS5 INS59 INS83 INS43 INS59 INS32 INS42 INS42 INS74 INS1 INS42 INS43 INS42 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS62 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS33 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS62 INS42 MOV43 INS39 INS85 INS42 MOV2 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 UPD74 MOV74 INS23 INS31 INS42 INS74 INS42 INS42 INS42 INS52 INS43 INS43 INS52 INS9 INS42 INS42 INS42 INS42 INS52 INS33 INS52 INS43 INS42 INS42 INS42 INS43 INS43 INS83 INS74 INS59 INS78 INS83 INS74 INS42 INS8 INS43 INS74 INS74 INS42 INS42 UPD42 MOV42 INS10 INS42 INS42 MOV43 MOV43 INS42 INS32 INS42 INS43 UPD74 MOV74 INS41 INS42 INS43 INS76 INS43 INS43 INS76 INS43 INS42 INS32 INS40 INS40 INS42 INS32 INS42 INS42 INS43 INS43 INS14 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS74 INS1 INS42 INS42 INS43 INS74 INS31 INS31 INS31 INS42 INS43 INS76 INS43 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS42 INS43 INS42 INS42 INS41 INS42 INS43 INS43 INS43 INS41 INS42 INS53 INS42 INS32 INS42 INS42 INS42 INS14 INS14 INS42 INS42 INS74 MOV32 INS42 INS43 INS43 INS43 INS43 INS42 INS42 INS42 INS42 DEL83 DEL74 DEL42 DEL74 DEL52 DEL52 DEL9 DEL14 DEL14 DEL41 DEL8 DEL31 DEL39 DEL85 DEL5 DEL42 DEL39 DEL27 DEL32 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL42 DEL32 DEL42 DEL41 DEL42 DEL42 DEL34 DEL27 DEL2 DEL42 DEL42 DEL42
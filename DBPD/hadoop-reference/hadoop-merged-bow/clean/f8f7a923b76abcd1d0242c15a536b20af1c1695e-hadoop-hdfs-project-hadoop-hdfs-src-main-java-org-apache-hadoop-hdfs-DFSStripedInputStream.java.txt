HDFS-8760. Erasure Coding: reuse BlockReader when reading the same block in pread. Contributed by Jing Zhao.

-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.convertIndex4Decode;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.divideByteRangeIntoStripes;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.finalizeDecodeInputs;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.decodeAndFillBuffer;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.getNextCompletedStripedRead;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.getStartOffsetsForInternalBlocks;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.initDecodeInputs;
-import static org.apache.hadoop.hdfs.util.StripedBlockUtil.parseStripedBlockGroup;
-import org.apache.hadoop.net.NetUtils;
-import org.apache.htrace.Span;
-import org.apache.htrace.Trace;
-import org.apache.htrace.TraceScope;
-  private ReaderRetryPolicy retry;
-  @Override
-  public synchronized int read(final ByteBuffer buf) throws IOException {
-    ReaderStrategy byteBufferReader = new ByteBufferStrategy(buf);
-    TraceScope scope =
-        dfsClient.getPathTraceScope("DFSInputStream#byteBufferRead", src);
-    try {
-      return readWithStrategy(byteBufferReader, 0, buf.remaining());
-    } finally {
-      scope.close();
-    }
-  }
-
-
-    final long offsetIntoBlockGroup = getOffsetInBlockGroup();
-    LocatedBlock[] targetBlocks = parseStripedBlockGroup(
-        targetBlockGroup, cellSize, dataBlkNum, parityBlkNum);
-    // The purpose is to get start offset into each block.
-    long[] offsetsForInternalBlocks = getStartOffsetsForInternalBlocks(schema,
-        cellSize, targetBlockGroup, offsetIntoBlockGroup);
-    Preconditions.checkState(offsetsForInternalBlocks.length ==
-        dataBlkNum + parityBlkNum);
-    long minOffset = offsetsForInternalBlocks[dataBlkNum];
-
-    retry = new ReaderRetryPolicy();
-    for (int i = 0; i < dataBlkNum; i++) {
-      LocatedBlock targetBlock = targetBlocks[i];
-      if (targetBlock != null) {
-        DNAddrPair dnInfo = getBestNodeDNAddrPair(targetBlock, null);
-        if (dnInfo != null) {
-          BlockReader reader = getBlockReaderWithRetry(targetBlock,
-              minOffset, targetBlock.getBlockSize() - minOffset,
-              dnInfo.addr, dnInfo.storageType, dnInfo.info, target, retry);
-          if (reader != null) {
-            blockReaders[i] = new BlockReaderInfo(reader, targetBlock,
-                dnInfo.info, minOffset);
-          }
-        }
-      }
-    }
-      closeReader(i);
+      closeReader(blockReaders[i]);
-  private void closeReader(int index) {
-    if (blockReaders[index] != null) {
-      IOUtils.cleanup(DFSClient.LOG, blockReaders[index].reader);
-      blockReaders[index].skip();
+  private void closeReader(BlockReaderInfo readerInfo) {
+    if (readerInfo != null) {
+      IOUtils.cleanup(DFSClient.LOG, readerInfo.reader);
+      readerInfo.skip();
-          blks, corruptedBlockMap);
+          blks, blockReaders, corruptedBlockMap);
-  private Callable<Void> readCell(final BlockReader reader,
+  private Callable<Void> readCells(final BlockReader reader,
-      final long targetReaderOffset, final ByteBufferStrategy strategy,
-      final int targetLength, final ExtendedBlock currentBlock,
+      final long targetReaderOffset, final ByteBufferStrategy[] strategies,
+      final ExtendedBlock currentBlock,
-        while (result < targetLength) {
-          int ret = readToBuffer(reader, datanode, strategy, currentBlock,
+        for (ByteBufferStrategy strategy : strategies) {
+          result += readToBuffer(reader, datanode, strategy, currentBlock,
-          if (ret < 0) {
-            throw new IOException("Unexpected EOS from the reader");
-          }
-          result += ret;
-        updateReadStatistics(readStatistics, targetLength, reader);
-      DatanodeInfo currentNode, ByteBufferStrategy readerStrategy,
+      DatanodeInfo currentNode, ByteBufferStrategy strategy,
+    final int targetLength = strategy.buf.remaining();
+    int length = 0;
-      return readerStrategy.doRead(blockReader, 0, 0);
+      while (length < targetLength) {
+        int ret = strategy.doRead(blockReader, 0, 0);
+        if (ret < 0) {
+          throw new IOException("Unexpected EOS from the reader");
+        }
+        length += ret;
+      }
+      return length;
-    AlignedStripe[] stripes = divideByteRangeIntoStripes(schema, cellSize,
-        blockGroup, start, end, buf, offset);
+    AlignedStripe[] stripes = StripedBlockUtil.divideByteRangeIntoStripes(
+        schema, cellSize, blockGroup, start, end, buf, offset);
-    for (AlignedStripe stripe : stripes) {
-      // Parse group to get chosen DN location
-      StripeReader preader = new PositionStripeReader(readService, stripe,
-          blks, corruptedBlockMap);
-      preader.readStripe();
+    final BlockReaderInfo[] preaderInfos = new BlockReaderInfo[groupSize];
+    try {
+      for (AlignedStripe stripe : stripes) {
+        // Parse group to get chosen DN location
+        StripeReader preader = new PositionStripeReader(readService, stripe,
+            blks, preaderInfos, corruptedBlockMap);
+        preader.readStripe();
+      }
+    } finally {
+      for (BlockReaderInfo preaderInfo : preaderInfos) {
+        closeReader(preaderInfo);
+      }
-  private Callable<Void> getFromOneDataNode(final DNAddrPair datanode,
-      final LocatedBlock block, final long start, final long end,
-      final byte[] buf, final int[] offsets, final int[] lengths,
-      final Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap,
-      final int hedgedReadId) {
-    final Span parentSpan = Trace.currentSpan();
-    return new Callable<Void>() {
-      @Override
-      public Void call() throws Exception {
-        TraceScope scope =
-            Trace.startSpan("Parallel reading " + hedgedReadId, parentSpan);
-        try {
-          actualGetFromOneDataNode(datanode, block, start,
-              end, buf, offsets, lengths, corruptedBlockMap);
-        } finally {
-          scope.close();
-        }
-        return null;
-      }
-    };
-  }
-
+  /**
+   * The reader for reading a complete {@link AlignedStripe}. Note that an
+   * {@link AlignedStripe} may cross multiple stripes with cellSize width.
+   */
+    final BlockReaderInfo[] readerInfos;
-        LocatedBlock[] targetBlocks,
+        LocatedBlock[] targetBlocks, BlockReaderInfo[] readerInfos,
+      this.readerInfos = readerInfos;
-    abstract boolean readChunk(final CompletionService<Void> service,
-        final LocatedBlock block, int chunkIndex);
-
-    abstract void updateState4SuccessRead(StripingChunkReadResult result);
+    void updateState4SuccessRead(StripingChunkReadResult result) {
+      Preconditions.checkArgument(
+          result.state == StripingChunkReadResult.SUCCESSFUL);
+      readerInfos[result.index].setOffset(alignedStripe.getOffsetInBlock()
+          + alignedStripe.getSpanInBlock());
+    }
-          if (!readChunk(service, targetBlocks[i], i)) {
+          if (!readChunk(targetBlocks[i], i)) {
-          if (prepareParityChunk(i) && readChunk(service, targetBlocks[i], i)) {
+          if (prepareParityChunk(i) && readChunk(targetBlocks[i], i)) {
+    boolean createBlockReader(LocatedBlock block, int chunkIndex)
+        throws IOException {
+      DNAddrPair dnInfo = getBestNodeDNAddrPair(block, null);
+      if (dnInfo != null) {
+        BlockReader reader = getBlockReaderWithRetry(block,
+            alignedStripe.getOffsetInBlock(),
+            block.getBlockSize() - alignedStripe.getOffsetInBlock(),
+            dnInfo.addr, dnInfo.storageType, dnInfo.info,
+            block.getStartOffset(), new ReaderRetryPolicy());
+        if (reader != null) {
+          readerInfos[chunkIndex] = new BlockReaderInfo(reader, block,
+              dnInfo.info, alignedStripe.getOffsetInBlock());
+          return true;
+        }
+      }
+      return false;
+    }
+
+    private ByteBufferStrategy[] getReadStrategies(StripingChunk chunk) {
+      if (chunk.byteBuffer != null) {
+        ByteBufferStrategy strategy = new ByteBufferStrategy(chunk.byteBuffer);
+        return new ByteBufferStrategy[]{strategy};
+      } else {
+        ByteBufferStrategy[] strategies =
+            new ByteBufferStrategy[chunk.byteArray.getOffsets().length];
+        for (int i = 0; i < strategies.length; i++) {
+          ByteBuffer buffer = ByteBuffer.wrap(chunk.byteArray.buf(),
+              chunk.byteArray.getOffsets()[i], chunk.byteArray.getLengths()[i]);
+          strategies[i] = new ByteBufferStrategy(buffer);
+        }
+        return strategies;
+      }
+    }
+
+    boolean readChunk(final LocatedBlock block, int chunkIndex)
+        throws IOException {
+      final StripingChunk chunk = alignedStripe.chunks[chunkIndex];
+      if (block == null) {
+        chunk.state = StripingChunk.MISSING;
+        return false;
+      }
+      if (readerInfos[chunkIndex] == null) {
+        if (!createBlockReader(block, chunkIndex)) {
+          chunk.state = StripingChunk.MISSING;
+          return false;
+        }
+      } else if (readerInfos[chunkIndex].shouldSkip) {
+        chunk.state = StripingChunk.MISSING;
+        return false;
+      }
+
+      chunk.state = StripingChunk.PENDING;
+      Callable<Void> readCallable = readCells(readerInfos[chunkIndex].reader,
+          readerInfos[chunkIndex].datanode,
+          readerInfos[chunkIndex].blockReaderOffset,
+          alignedStripe.getOffsetInBlock(), getReadStrategies(chunk),
+          block.getBlock(), corruptedBlockMap);
+
+      Future<Void> request = service.submit(readCallable);
+      futures.put(request, chunkIndex);
+      return true;
+    }
+
-          if (!readChunk(service, targetBlocks[i], i)) {
+          if (!readChunk(targetBlocks[i], i)) {
-          StripingChunkReadResult r = getNextCompletedStripedRead(service,
-              futures, 0);
+          StripingChunkReadResult r = StripedBlockUtil
+              .getNextCompletedStripedRead(service, futures, 0);
-            closeReader(r.index);
+            closeReader(readerInfos[r.index]);
+        BlockReaderInfo[] readerInfos,
-      super(service, alignedStripe, targetBlocks, corruptedBlockMap);
+      super(service, alignedStripe, targetBlocks, readerInfos,
+          corruptedBlockMap);
-    boolean readChunk(final CompletionService<Void> service,
-        final LocatedBlock block, int chunkIndex) {
-      final StripingChunk chunk = alignedStripe.chunks[chunkIndex];
-      if (block == null) {
-        chunk.state = StripingChunk.MISSING;
-        return false;
-      }
-      DatanodeInfo loc = block.getLocations()[0];
-      StorageType type = block.getStorageTypes()[0];
-      DNAddrPair dnAddr = new DNAddrPair(loc, NetUtils.createSocketAddr(
-          loc.getXferAddr(dfsClient.getConf().isConnectToDnViaHostname())),
-          type);
-      chunk.state = StripingChunk.PENDING;
-      Callable<Void> readCallable = getFromOneDataNode(dnAddr,
-          block, alignedStripe.getOffsetInBlock(),
-          alignedStripe.getOffsetInBlock() + alignedStripe.getSpanInBlock() - 1,
-          chunk.byteArray.buf(), chunk.byteArray.getOffsets(),
-          chunk.byteArray.getLengths(), corruptedBlockMap, chunkIndex);
-      Future<Void> getFromDNRequest = service.submit(readCallable);
-      if (DFSClient.LOG.isDebugEnabled()) {
-        DFSClient.LOG.debug("Submitting striped read request for " + chunkIndex
-            + ". Info of the block: " + block + ", offset in block is "
-            + alignedStripe.getOffsetInBlock() + ", end is "
-            + (alignedStripe.getOffsetInBlock()
-            + alignedStripe.getSpanInBlock() - 1));
-      }
-      futures.put(getFromDNRequest, chunkIndex);
-      return true;
-    }
-
-    @Override
-    void updateState4SuccessRead(StripingChunkReadResult r) {}
-
-    @Override
-        decodeInputs = initDecodeInputs(alignedStripe, dataBlkNum, parityBlkNum);
+        decodeInputs = StripedBlockUtil.initDecodeInputs(alignedStripe,
+            dataBlkNum, parityBlkNum);
-      final int decodeIndex = convertIndex4Decode(index, dataBlkNum,
-          parityBlkNum);
+      final int decodeIndex = StripedBlockUtil.convertIndex4Decode(index,
+          dataBlkNum, parityBlkNum);
-      finalizeDecodeInputs(decodeInputs, dataBlkNum, parityBlkNum,
-          alignedStripe);
-      decodeAndFillBuffer(decodeInputs, alignedStripe, dataBlkNum,
-          parityBlkNum, decoder);
+      StripedBlockUtil.finalizeDecodeInputs(decodeInputs, dataBlkNum,
+          parityBlkNum, alignedStripe);
+      StripedBlockUtil.decodeAndFillBuffer(decodeInputs, alignedStripe,
+          dataBlkNum, parityBlkNum, decoder);
+        BlockReaderInfo[] readerInfos,
-      super(service, alignedStripe, targetBlocks, corruptedBlockMap);
-    }
-
-    @Override
-    boolean readChunk(final CompletionService<Void> service,
-        final LocatedBlock block, int chunkIndex) {
-      final StripingChunk chunk = alignedStripe.chunks[chunkIndex];
-      final BlockReaderInfo readerInfo = blockReaders[chunkIndex];
-      if (readerInfo == null || block == null || readerInfo.shouldSkip) {
-        chunk.state = StripingChunk.MISSING;
-        return false;
-      }
-      chunk.state = StripingChunk.PENDING;
-      ByteBufferStrategy strategy = new ByteBufferStrategy(chunk.byteBuffer);
-      Callable<Void> readCallable = readCell(readerInfo.reader,
-          readerInfo.datanode, readerInfo.blockReaderOffset,
-          alignedStripe.getOffsetInBlock(), strategy,
-          chunk.byteBuffer.remaining(), block.getBlock(), corruptedBlockMap);
-      Future<Void> request = readingService.submit(readCallable);
-      futures.put(request, chunkIndex);
-      return true;
-    }
-
-    @Override
-    void updateState4SuccessRead(StripingChunkReadResult result) {
-      Preconditions.checkArgument(
-          result.state == StripingChunkReadResult.SUCCESSFUL);
-      blockReaders[result.index].setOffset(alignedStripe.getOffsetInBlock()
-          + alignedStripe.getSpanInBlock());
+      super(service, alignedStripe, targetBlocks, readerInfos,
+          corruptedBlockMap);
-          final int decodeIndex = convertIndex4Decode(i, dataBlkNum,
-              parityBlkNum);
+          final int decodeIndex = StripedBlockUtil.convertIndex4Decode(i,
+              dataBlkNum, parityBlkNum);
-      final int decodeIndex = convertIndex4Decode(index, dataBlkNum,
-          parityBlkNum);
+      final int decodeIndex = StripedBlockUtil.convertIndex4Decode(index,
+          dataBlkNum, parityBlkNum);
-      if (blockReaders[index] == null && !prepareParityBlockReader(index)) {
-        alignedStripe.chunks[index] = new StripingChunk(StripingChunk.MISSING);
-        return false;
-      }
-    private boolean prepareParityBlockReader(int i) throws IOException {
-      // prepare the block reader for the parity chunk
-      LocatedBlock targetBlock = targetBlocks[i];
-      if (targetBlock != null) {
-        final long offsetInBlock = alignedStripe.getOffsetInBlock();
-        DNAddrPair dnInfo = getBestNodeDNAddrPair(targetBlock, null);
-        if (dnInfo != null) {
-          BlockReader reader = getBlockReaderWithRetry(targetBlock,
-              offsetInBlock, targetBlock.getBlockSize() - offsetInBlock,
-              dnInfo.addr, dnInfo.storageType, dnInfo.info,
-              DFSStripedInputStream.this.getPos(), retry);
-          if (reader != null) {
-            blockReaders[i] = new BlockReaderInfo(reader, targetBlock,
-                dnInfo.info, offsetInBlock);
-            return true;
-          }
-        }
-      }
-      return false;
-    }
-
-        final int decodeIndex = convertIndex4Decode(i,
+        final int decodeIndex = StripedBlockUtil.convertIndex4Decode(i,
-          decodeIndices[pos++] = convertIndex4Decode(i,
+          decodeIndices[pos++] = StripedBlockUtil.convertIndex4Decode(i,

INS8 UPD42 INS29 INS23 INS31 INS31 INS31 INS31 MOV25 MOV21 MOV60 MOV21 MOV21 MOV21 MOV43 UPD42 INS5 UPD42 UPD42 INS60 INS60 INS60 INS54 INS65 INS83 INS5 INS59 INS44 INS39 INS42 MOV44 INS8 MOV39 INS42 INS44 MOV44 MOV43 INS8 INS83 INS5 INS42 INS44 INS8 INS39 INS42 MOV44 MOV44 MOV43 INS8 INS44 MOV78 MOV78 INS44 MOV43 INS85 INS83 INS39 INS59 INS39 INS59 INS8 INS83 INS5 INS59 INS8 INS8 INS66 INS65 INS66 INS65 INS66 INS43 INS85 INS42 INS5 INS42 INS21 MOV21 INS21 INS43 INS42 INS60 INS25 MOV41 INS43 INS85 MOV43 INS42 INS25 MOV83 MOV43 MOV42 MOV60 MOV25 INS25 MOV21 INS60 INS60 MOV21 MOV41 INS5 INS42 INS5 INS42 INS42 INS42 INS32 INS42 INS34 INS61 INS41 INS43 INS85 INS42 INS3 MOV70 INS70 INS42 INS42 INS42 INS43 INS85 INS7 INS32 INS42 MOV43 INS59 MOV27 INS8 UPD42 MOV42 INS27 INS8 INS8 MOV42 INS27 INS8 INS25 MOV74 INS59 MOV74 INS59 INS43 INS85 INS42 MOV43 INS85 INS42 INS40 INS42 INS27 INS8 INS42 INS42 INS42 INS5 INS42 INS44 INS42 INS8 INS42 INS22 INS42 INS2 INS42 MOV27 INS42 INS32 INS60 INS25 INS40 INS33 MOV60 INS41 INS60 INS24 INS41 INS2 INS33 INS25 INS22 MOV8 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 MOV2 INS40 INS42 INS42 INS42 INS60 MOV25 INS21 INS43 INS85 INS43 INS42 INS21 INS52 INS42 INS42 INS40 INS42 INS42 INS33 MOV43 INS59 MOV27 INS8 INS3 INS5 INS59 MOV58 INS27 MOV37 INS8 INS42 INS42 INS42 INS38 INS8 INS2 INS42 INS42 INS22 INS22 INS22 MOV32 INS32 MOV32 INS42 INS42 INS42 INS42 INS70 INS39 INS59 INS7 INS42 INS42 INS32 INS42 INS32 INS21 MOV41 INS5 INS4 INS43 INS85 INS42 INS3 INS42 INS40 INS60 INS21 INS32 INS21 INS41 INS42 INS42 INS2 INS42 INS2 INS42 INS2 INS42 INS42 INS42 MOV44 INS42 INS8 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS27 INS40 INS40 INS40 INS32 MOV14 INS7 INS43 INS85 INS42 INS42 INS5 INS22 MOV43 INS59 INS7 INS42 INS42 INS42 INS7 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 UPD42 MOV42 MOV42 MOV42 MOV34 MOV34 INS42 INS32 MOV32 INS32 MOV32 INS42 INS42 INS2 INS14 INS42 INS43 INS85 INS32 INS42 INS42 INS32 INS2 INS14 INS40 INS40 INS42 MOV2 INS42 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS40 MOV32 INS42 INS40 INS42 INS42 INS42 MOV32 INS2 INS2 INS42 INS42 INS43 INS42 INS42 INS42 INS42 MOV32 MOV32 INS42 MOV32 INS42 INS42 INS2 INS42 INS40 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL83 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL34 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL42 DEL42 DEL27 DEL27 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL42 DEL27 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL24 DEL8 DEL42 DEL39 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL22 DEL42 DEL42 DEL2 DEL39 DEL83 DEL42 DEL42 DEL42 DEL27 DEL39 DEL42 DEL59 DEL60 DEL8 DEL61 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL32 DEL41 DEL8 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL39 DEL85 DEL5 DEL42 DEL44 DEL83 DEL39 DEL85 DEL5 DEL42 DEL44 DEL83 DEL39 DEL85 DEL5 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL27 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL33 DEL41 DEL8 DEL31 DEL1 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL83 DEL43 DEL43 DEL74 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL40 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL34 DEL2 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL34 DEL2 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL42 DEL14 DEL59 DEL60 DEL40 DEL40 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL34 DEL27 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL40 DEL42 DEL32 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL34 DEL27 DEL36 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL42 DEL78 DEL42 DEL78 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL40 DEL42 DEL2 DEL59 DEL60 DEL83 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL40 DEL27 DEL25 DEL42 DEL42 DEL40 DEL40 DEL40 DEL42 DEL40 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL42 DEL78 DEL39 DEL42 DEL42 DEL40 DEL2 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL2 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL40 DEL42 DEL2 DEL40 DEL14 DEL7 DEL21 DEL9 DEL41 DEL8 DEL25 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL83 DEL39 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL40 DEL40 DEL40 DEL42 DEL52 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL2 DEL42 DEL42 DEL40 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31
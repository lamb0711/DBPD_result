YARN-6735. Have a way to turn off container metrics from NMs. Contributed by Abhishek Modi.

+import org.apache.hadoop.yarn.conf.YarnConfiguration;
+  private boolean publishNMContainerEvents = true;
+
+
+    publishNMContainerEvents = conf.getBoolean(
+        YarnConfiguration.NM_PUBLISH_CONTAINER_EVENTS_ENABLED,
+        YarnConfiguration.DEFAULT_NM_PUBLISH_CONTAINER_EVENTS_ENABLED);
-    if (pmemUsage != ResourceCalculatorProcessTree.UNAVAILABLE ||
-        cpuUsagePercentPerCore != ResourceCalculatorProcessTree.UNAVAILABLE) {
-      ContainerEntity entity =
-          createContainerEntity(container.getContainerId());
-      long currentTimeMillis = System.currentTimeMillis();
-      if (pmemUsage != ResourceCalculatorProcessTree.UNAVAILABLE) {
-        TimelineMetric memoryMetric = new TimelineMetric();
-        memoryMetric.setId(ContainerMetric.MEMORY.toString());
-        memoryMetric.setRealtimeAggregationOp(TimelineMetricOperation.SUM);
-        memoryMetric.addValue(currentTimeMillis, pmemUsage);
-        entity.addMetric(memoryMetric);
+    if (publishNMContainerEvents) {
+      if (pmemUsage != ResourceCalculatorProcessTree.UNAVAILABLE
+          || cpuUsagePercentPerCore !=
+          ResourceCalculatorProcessTree.UNAVAILABLE) {
+        ContainerEntity entity =
+            createContainerEntity(container.getContainerId());
+        long currentTimeMillis = System.currentTimeMillis();
+        if (pmemUsage != ResourceCalculatorProcessTree.UNAVAILABLE) {
+          TimelineMetric memoryMetric = new TimelineMetric();
+          memoryMetric.setId(ContainerMetric.MEMORY.toString());
+          memoryMetric.setRealtimeAggregationOp(TimelineMetricOperation.SUM);
+          memoryMetric.addValue(currentTimeMillis, pmemUsage);
+          entity.addMetric(memoryMetric);
+        }
+        if (cpuUsagePercentPerCore !=
+            ResourceCalculatorProcessTree.UNAVAILABLE) {
+          TimelineMetric cpuMetric = new TimelineMetric();
+          cpuMetric.setId(ContainerMetric.CPU.toString());
+          // TODO: support average
+          cpuMetric.setRealtimeAggregationOp(TimelineMetricOperation.SUM);
+          cpuMetric.addValue(currentTimeMillis,
+              Math.round(cpuUsagePercentPerCore));
+          entity.addMetric(cpuMetric);
+        }
+        entity.setIdPrefix(TimelineServiceHelper.
+            invertLong(container.getContainerStartTime()));
+        ApplicationId appId = container.getContainerId().
+            getApplicationAttemptId().getApplicationId();
+        try {
+          // no need to put it as part of publisher as timeline client
+          // already has Queuing concept
+          TimelineV2Client timelineClient = getTimelineClient(appId);
+          if (timelineClient != null) {
+            timelineClient.putEntitiesAsync(entity);
+          } else {
+            LOG.error("Seems like client has been removed before the container"
+                + " metric could be published for " +
+                container.getContainerId());
+          }
+        } catch (IOException e) {
+          LOG.error(
+              "Failed to publish Container metrics for container " +
+                  container.getContainerId());
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Failed to publish Container metrics for container " +
+                container.getContainerId(), e);
+          }
+        } catch (YarnException e) {
+          LOG.error(
+              "Failed to publish Container metrics for container " +
+                  container.getContainerId(), e.getMessage());
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Failed to publish Container metrics for container " +
+                container.getContainerId(), e);
+          }
+        }
-      if (cpuUsagePercentPerCore != ResourceCalculatorProcessTree.UNAVAILABLE) {
-        TimelineMetric cpuMetric = new TimelineMetric();
-        cpuMetric.setId(ContainerMetric.CPU.toString());
-        // TODO: support average
-        cpuMetric.setRealtimeAggregationOp(TimelineMetricOperation.SUM);
-        cpuMetric.addValue(currentTimeMillis,
-            Math.round(cpuUsagePercentPerCore));
-        entity.addMetric(cpuMetric);
-      }
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private void publishContainerCreatedEvent(ContainerEvent event) {
+    if (publishNMContainerEvents) {
+      ContainerId containerId = event.getContainerID();
+      ContainerEntity entity = createContainerEntity(containerId);
+      Container container = context.getContainers().get(containerId);
+      Resource resource = container.getResource();
+
+      Map<String, Object> entityInfo = new HashMap<String, Object>();
+      entityInfo.put(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO,
+          resource.getMemorySize());
+      entityInfo.put(ContainerMetricsConstants.ALLOCATED_VCORE_INFO,
+          resource.getVirtualCores());
+      entityInfo.put(ContainerMetricsConstants.ALLOCATED_HOST_INFO,
+          nodeId.getHost());
+      entityInfo.put(ContainerMetricsConstants.ALLOCATED_PORT_INFO,
+          nodeId.getPort());
+      entityInfo.put(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO,
+          container.getPriority().toString());
+      entityInfo.put(
+          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO,
+          httpAddress);
+      entity.setInfo(entityInfo);
+
+      TimelineEvent tEvent = new TimelineEvent();
+      tEvent.setId(ContainerMetricsConstants.CREATED_EVENT_TYPE);
+      tEvent.setTimestamp(event.getTimestamp());
+
+      long containerStartTime = container.getContainerStartTime();
+      entity.addEvent(tEvent);
+      entity.setCreatedTime(containerStartTime);
+      entity.setIdPrefix(TimelineServiceHelper.invertLong(containerStartTime));
+      dispatcher.getEventHandler().handle(new TimelinePublishEvent(entity,
+          containerId.getApplicationAttemptId().getApplicationId()));
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private void publishContainerFinishedEvent(ContainerStatus containerStatus,
+      long containerFinishTime, long containerStartTime) {
+    if (publishNMContainerEvents) {
+      ContainerId containerId = containerStatus.getContainerId();
+      TimelineEntity entity = createContainerEntity(containerId);
+
+      Map<String, Object> entityInfo = new HashMap<String, Object>();
+      entityInfo.put(ContainerMetricsConstants.DIAGNOSTICS_INFO,
+          containerStatus.getDiagnostics());
+      entityInfo.put(ContainerMetricsConstants.EXIT_STATUS_INFO,
+          containerStatus.getExitStatus());
+      entityInfo.put(ContainerMetricsConstants.STATE_INFO,
+          ContainerState.COMPLETE.toString());
+      entityInfo.put(ContainerMetricsConstants.CONTAINER_FINISHED_TIME,
+          containerFinishTime);
+      entity.setInfo(entityInfo);
+
+      TimelineEvent tEvent = new TimelineEvent();
+      tEvent.setId(ContainerMetricsConstants.FINISHED_EVENT_TYPE);
+      tEvent.setTimestamp(containerFinishTime);
+      entity.addEvent(tEvent);
+      entity.setIdPrefix(TimelineServiceHelper.invertLong(containerStartTime));
+
+      dispatcher.getEventHandler().handle(new TimelinePublishEvent(entity,
+          containerId.getApplicationAttemptId().getApplicationId()));
+    }
+  }
+
+  private void publishContainerLocalizationEvent(
+      ContainerLocalizationEvent event, String eventType) {
+    if (publishNMContainerEvents) {
+      Container container = event.getContainer();
+      ContainerId containerId = container.getContainerId();
+      TimelineEntity entity = createContainerEntity(containerId);
+
+      TimelineEvent tEvent = new TimelineEvent();
+      tEvent.setId(eventType);
+      tEvent.setTimestamp(event.getTimestamp());
+      entity.addEvent(tEvent);
-      ApplicationId appId = container.getContainerId().getApplicationAttemptId()
-          .getApplicationId();
+
+      ApplicationId appId = container.getContainerId().
+          getApplicationAttemptId().getApplicationId();
-          LOG.error("Seems like client has been removed before the container"
-              + " metric could be published for " + container.getContainerId());
+          LOG.error("Seems like client has been removed before the event"
+              + " could be published for " + container.getContainerId());
-  @SuppressWarnings("unchecked")
-  private void publishContainerCreatedEvent(ContainerEvent event) {
-    ContainerId containerId = event.getContainerID();
-    ContainerEntity entity = createContainerEntity(containerId);
-    Container container = context.getContainers().get(containerId);
-    Resource resource = container.getResource();
-
-    Map<String, Object> entityInfo = new HashMap<String, Object>();
-    entityInfo.put(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO,
-        resource.getMemorySize());
-    entityInfo.put(ContainerMetricsConstants.ALLOCATED_VCORE_INFO,
-        resource.getVirtualCores());
-    entityInfo.put(ContainerMetricsConstants.ALLOCATED_HOST_INFO,
-        nodeId.getHost());
-    entityInfo.put(ContainerMetricsConstants.ALLOCATED_PORT_INFO,
-        nodeId.getPort());
-    entityInfo.put(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO,
-        container.getPriority().toString());
-    entityInfo.put(
-        ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO,
-        httpAddress);
-    entity.setInfo(entityInfo);
-
-    TimelineEvent tEvent = new TimelineEvent();
-    tEvent.setId(ContainerMetricsConstants.CREATED_EVENT_TYPE);
-    tEvent.setTimestamp(event.getTimestamp());
-
-    long containerStartTime = container.getContainerStartTime();
-    entity.addEvent(tEvent);
-    entity.setCreatedTime(containerStartTime);
-    entity.setIdPrefix(TimelineServiceHelper.invertLong(containerStartTime));
-    dispatcher.getEventHandler().handle(new TimelinePublishEvent(entity,
-        containerId.getApplicationAttemptId().getApplicationId()));
-  }
-
-  @SuppressWarnings("unchecked")
-  private void publishContainerFinishedEvent(ContainerStatus containerStatus,
-      long containerFinishTime, long containerStartTime) {
-    ContainerId containerId = containerStatus.getContainerId();
-    TimelineEntity entity = createContainerEntity(containerId);
-
-    Map<String, Object> entityInfo = new HashMap<String, Object>();
-    entityInfo.put(ContainerMetricsConstants.DIAGNOSTICS_INFO,
-        containerStatus.getDiagnostics());
-    entityInfo.put(ContainerMetricsConstants.EXIT_STATUS_INFO,
-        containerStatus.getExitStatus());
-    entityInfo.put(ContainerMetricsConstants.STATE_INFO,
-        ContainerState.COMPLETE.toString());
-    entityInfo.put(ContainerMetricsConstants.CONTAINER_FINISHED_TIME,
-        containerFinishTime);
-    entity.setInfo(entityInfo);
-
-    TimelineEvent tEvent = new TimelineEvent();
-    tEvent.setId(ContainerMetricsConstants.FINISHED_EVENT_TYPE);
-    tEvent.setTimestamp(containerFinishTime);
-    entity.addEvent(tEvent);
-    entity.setIdPrefix(TimelineServiceHelper.invertLong(containerStartTime));
-
-    dispatcher.getEventHandler().handle(new TimelinePublishEvent(entity,
-        containerId.getApplicationAttemptId().getApplicationId()));
-  }
-
-  private void publishContainerLocalizationEvent(
-      ContainerLocalizationEvent event, String eventType) {
-    Container container = event.getContainer();
-    ContainerId containerId = container.getContainerId();
-    TimelineEntity entity = createContainerEntity(containerId);
-
-    TimelineEvent tEvent = new TimelineEvent();
-    tEvent.setId(eventType);
-    tEvent.setTimestamp(event.getTimestamp());
-    entity.addEvent(tEvent);
-    entity.setIdPrefix(TimelineServiceHelper.
-        invertLong(container.getContainerStartTime()));
-
-    ApplicationId appId =
-        container.getContainerId().getApplicationAttemptId().getApplicationId();
-    try {
-      // no need to put it as part of publisher as timeline client already has
-      // Queuing concept
-      TimelineV2Client timelineClient = getTimelineClient(appId);
-      if (timelineClient != null) {
-        timelineClient.putEntitiesAsync(entity);
-      } else {
-        LOG.error("Seems like client has been removed before the event could be"
-            + " published for " + container.getContainerId());
-      }
-    } catch (IOException e) {
-      LOG.error("Failed to publish Container metrics for container "
-          + container.getContainerId());
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Failed to publish Container metrics for container "
-            + container.getContainerId(), e);
-      }
-    } catch (YarnException e) {
-      LOG.error("Failed to publish Container metrics for container "
-          + container.getContainerId(), e.getMessage());
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Failed to publish Container metrics for container "
-            + container.getContainerId(), e);
-      }
-    }
-  }
-

INS26 INS40 INS23 INS83 INS39 INS59 INS8 INS8 INS8 INS8 INS42 INS9 INS21 INS25 INS25 INS25 INS25 INS7 INS42 MOV8 INS42 MOV8 INS42 MOV8 INS42 MOV8 INS42 INS32 INS42 INS42 INS40 INS40 UPD45 UPD45
YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)

-import java.util.Set;
-import java.util.SortedMap;
+import org.apache.hadoop.yarn.server.resourcemanager.reservation.exceptions.PlanningException;
-  private static final Resource ZERO_RESOURCE = Resource.newInstance(0, 0);
+  private static final Resource ZERO_RESOURCE = Resources.none();
-  private TreeMap<Long, Resource> cumulativeCapacity =
+  private NavigableMap<Long, Resource> cumulativeCapacity =
-  private final Resource minAlloc;
-  public RLESparseResourceAllocation(ResourceCalculator resourceCalculator,
-      Resource minAlloc) {
+  public RLESparseResourceAllocation(ResourceCalculator resourceCalculator) {
-    this.minAlloc = minAlloc;
-  private boolean isSameAsPrevious(Long key, Resource capacity) {
-    Entry<Long, Resource> previous = cumulativeCapacity.lowerEntry(key);
-    return (previous != null && previous.getValue().equals(capacity));
-  }
-
-  private boolean isSameAsNext(Long key, Resource capacity) {
-    Entry<Long, Resource> next = cumulativeCapacity.higherEntry(key);
-    return (next != null && next.getValue().equals(capacity));
+  public RLESparseResourceAllocation(NavigableMap<Long, Resource> out,
+      ResourceCalculator resourceCalculator) {
+    // miss check for repeated entries
+    this.cumulativeCapacity = out;
+    this.resourceCalculator = resourceCalculator;
-   * Add a resource for the specified interval
+   * Add a resource for the specified interval.
-      long startKey = reservationInterval.getStartTime();
-      long endKey = reservationInterval.getEndTime();
-      NavigableMap<Long, Resource> ticks =
-          cumulativeCapacity.headMap(endKey, false);
-      if (ticks != null && !ticks.isEmpty()) {
-        Resource updatedCapacity = Resource.newInstance(0, 0);
-        Entry<Long, Resource> lowEntry = ticks.floorEntry(startKey);
-        if (lowEntry == null) {
-          // This is the earliest starting interval
-          cumulativeCapacity.put(startKey, totCap);
-        } else {
-          updatedCapacity = Resources.add(lowEntry.getValue(), totCap);
-          // Add a new tick only if the updated value is different
-          // from the previous tick
-          if ((startKey == lowEntry.getKey())
-              && (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) {
-            cumulativeCapacity.remove(lowEntry.getKey());
-          } else {
-            cumulativeCapacity.put(startKey, updatedCapacity);
-          }
-        }
-        // Increase all the capacities of overlapping intervals
-        Set<Entry<Long, Resource>> overlapSet =
-            ticks.tailMap(startKey, false).entrySet();
-        for (Entry<Long, Resource> entry : overlapSet) {
-          updatedCapacity = Resources.add(entry.getValue(), totCap);
-          entry.setValue(updatedCapacity);
-        }
-      } else {
-        // This is the first interval to be added
-        cumulativeCapacity.put(startKey, totCap);
-      }
-      Resource nextTick = cumulativeCapacity.get(endKey);
-      if (nextTick != null) {
-        // If there is overlap, remove the duplicate entry
-        if (isSameAsPrevious(endKey, nextTick)) {
-          cumulativeCapacity.remove(endKey);
-        }
-      } else {
-        // Decrease capacity as this is end of the interval
-        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity
-            .floorEntry(endKey).getValue(), totCap));
+      NavigableMap<Long, Resource> addInt = new TreeMap<Long, Resource>();
+      addInt.put(reservationInterval.getStartTime(), totCap);
+      addInt.put(reservationInterval.getEndTime(), ZERO_RESOURCE);
+      try {
+        cumulativeCapacity =
+            merge(resourceCalculator, totCap, cumulativeCapacity, addInt,
+                Long.MIN_VALUE, Long.MAX_VALUE, RLEOperator.add);
+      } catch (PlanningException e) {
+        // never happens for add
-   * Removes a resource for the specified interval
+   * Removes a resource for the specified interval.
-      long startKey = reservationInterval.getStartTime();
-      long endKey = reservationInterval.getEndTime();
-      // update the start key
-      NavigableMap<Long, Resource> ticks =
-          cumulativeCapacity.headMap(endKey, false);
-      // Decrease all the capacities of overlapping intervals
-      SortedMap<Long, Resource> overlapSet = ticks.tailMap(startKey);
-      if (overlapSet != null && !overlapSet.isEmpty()) {
-        Resource updatedCapacity = Resource.newInstance(0, 0);
-        long currentKey = -1;
-        for (Iterator<Entry<Long, Resource>> overlapEntries =
-            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {
-          Entry<Long, Resource> entry = overlapEntries.next();
-          currentKey = entry.getKey();
-          updatedCapacity = Resources.subtract(entry.getValue(), totCap);
-          // update each entry between start and end key
-          cumulativeCapacity.put(currentKey, updatedCapacity);
-        }
-        // Remove the first overlap entry if it is same as previous after
-        // updation
-        Long firstKey = overlapSet.firstKey();
-        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {
-          cumulativeCapacity.remove(firstKey);
-        }
-        // Remove the next entry if it is same as end entry after updation
-        if ((currentKey != -1) && (isSameAsNext(currentKey, updatedCapacity))) {
-          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));
-        }
+
+      NavigableMap<Long, Resource> removeInt = new TreeMap<Long, Resource>();
+      removeInt.put(reservationInterval.getStartTime(), totCap);
+      removeInt.put(reservationInterval.getEndTime(), ZERO_RESOURCE);
+      try {
+        cumulativeCapacity =
+            merge(resourceCalculator, totCap, cumulativeCapacity, removeInt,
+                Long.MIN_VALUE, Long.MAX_VALUE, RLEOperator.subtract);
+      } catch (PlanningException e) {
+        // never happens for subtract
-   * of time
+   * of time.
-   * @param tick the time (UTC in ms) at which the capacity is requested
-   * Get the timestamp of the earliest resource allocation
+   * Get the timestamp of the earliest resource allocation.
-   * Get the timestamp of the latest resource allocation
+   * Get the timestamp of the latest non-null resource allocation.
-  public long getLatestEndTime() {
+  public long getLatestNonNullTime() {
-        return cumulativeCapacity.lastKey();
+        // the last entry might contain null (to terminate
+        // the sequence)... return previous one.
+        Entry<Long, Resource> last = cumulativeCapacity.lastEntry();
+        if (last.getValue() == null) {
+          return cumulativeCapacity.floorKey(last.getKey() - 1);
+        } else {
+          return last.getKey();
+        }
-   * Returns true if there are no non-zero entries
+   * Returns true if there are no non-zero entries.
-      // Deletion leaves a single zero entry so check for that
-      if (cumulativeCapacity.size() == 1) {
-        return cumulativeCapacity.firstEntry().getValue().equals(ZERO_RESOURCE);
+      // Deletion leaves a single zero entry with a null at the end so check for
+      // that
+      if (cumulativeCapacity.size() == 2) {
+        return cumulativeCapacity.firstEntry().getValue().equals(ZERO_RESOURCE)
+            && cumulativeCapacity.lastEntry().getValue() == null;
-   * over time
+   * over time.
-   * an interval map.
+   * an interval map (in the defined non-null range).
-        if (lastEntry != null) {
+        if (lastEntry != null && entry.getValue() != null) {
+  }
+  public NavigableMap<Long, Resource> getCumulative() {
+    readLock.lock();
+    try {
+      return cumulativeCapacity;
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  /**
+   * Merges the range start to end of two {@code RLESparseResourceAllocation}
+   * using a given {@code RLEOperator}.
+   *
+   * @param resCalc the resource calculator
+   * @param clusterResource the total cluster resources (for DRF)
+   * @param a the left operand
+   * @param b the right operand
+   * @param operator the operator to be applied during merge
+   * @param start the start-time of the range to be considered
+   * @param end the end-time of the range to be considered
+   * @return the a merged RLESparseResourceAllocation, produced by applying
+   *         "operator" to "a" and "b"
+   * @throws PlanningException in case the operator is subtractTestPositive and
+   *           the result would contain a negative value
+   */
+  public static RLESparseResourceAllocation merge(ResourceCalculator resCalc,
+      Resource clusterResource, RLESparseResourceAllocation a,
+      RLESparseResourceAllocation b, RLEOperator operator, long start, long end)
+      throws PlanningException {
+    NavigableMap<Long, Resource> cumA =
+        a.getRangeOverlapping(start, end).getCumulative();
+    NavigableMap<Long, Resource> cumB =
+        b.getRangeOverlapping(start, end).getCumulative();
+    NavigableMap<Long, Resource> out =
+        merge(resCalc, clusterResource, cumA, cumB, start, end, operator);
+    return new RLESparseResourceAllocation(out, resCalc);
+  }
+
+  private static NavigableMap<Long, Resource> merge(ResourceCalculator resCalc,
+      Resource clusterResource, NavigableMap<Long, Resource> a,
+      NavigableMap<Long, Resource> b, long start, long end,
+      RLEOperator operator) throws PlanningException {
+
+    // handle special cases of empty input
+    if (a == null || a.isEmpty()) {
+      if (operator == RLEOperator.subtract
+          || operator == RLEOperator.subtractTestNonNegative) {
+        return negate(operator, b);
+      } else {
+        return b;
+      }
+    }
+    if (b == null || b.isEmpty()) {
+      return a;
+    }
+
+    // define iterators and support variables
+    Iterator<Entry<Long, Resource>> aIt = a.entrySet().iterator();
+    Iterator<Entry<Long, Resource>> bIt = b.entrySet().iterator();
+    Entry<Long, Resource> curA = aIt.next();
+    Entry<Long, Resource> curB = bIt.next();
+    Entry<Long, Resource> lastA = null;
+    Entry<Long, Resource> lastB = null;
+    boolean aIsDone = false;
+    boolean bIsDone = false;
+
+    TreeMap<Long, Resource> out = new TreeMap<Long, Resource>();
+
+    while (!(curA.equals(lastA) && curB.equals(lastB))) {
+
+      Resource outRes;
+      long time = -1;
+
+      // curA is smaller than curB
+      if (bIsDone || (curA.getKey() < curB.getKey() && !aIsDone)) {
+        outRes = combineValue(operator, resCalc, clusterResource, curA, lastB);
+        time = (curA.getKey() < start) ? start : curA.getKey();
+        lastA = curA;
+        if (aIt.hasNext()) {
+          curA = aIt.next();
+        } else {
+          aIsDone = true;
+        }
+
+      } else {
+        // curB is smaller than curA
+        if (aIsDone || (curA.getKey() > curB.getKey() && !bIsDone)) {
+          outRes =
+              combineValue(operator, resCalc, clusterResource, lastA, curB);
+          time = (curB.getKey() < start) ? start : curB.getKey();
+          lastB = curB;
+          if (bIt.hasNext()) {
+            curB = bIt.next();
+          } else {
+            bIsDone = true;
+          }
+
+        } else {
+          // curA is equal to curB
+          outRes = combineValue(operator, resCalc, clusterResource, curA, curB);
+          time = (curA.getKey() < start) ? start : curA.getKey();
+          lastA = curA;
+          if (aIt.hasNext()) {
+            curA = aIt.next();
+          } else {
+            aIsDone = true;
+          }
+          lastB = curB;
+          if (bIt.hasNext()) {
+            curB = bIt.next();
+          } else {
+            bIsDone = true;
+          }
+        }
+      }
+
+      // add to out if not redundant
+      addIfNeeded(out, time, outRes);
+    }
+    addIfNeeded(out, end, null);
+
+    return out;
+  }
+
+  private static NavigableMap<Long, Resource> negate(RLEOperator operator,
+      NavigableMap<Long, Resource> a) throws PlanningException {
+
+    TreeMap<Long, Resource> out = new TreeMap<Long, Resource>();
+    for (Entry<Long, Resource> e : a.entrySet()) {
+      Resource val = Resources.negate(e.getValue());
+      // test for negative value and throws
+      if (operator == RLEOperator.subtractTestNonNegative
+          && (Resources.fitsIn(val, ZERO_RESOURCE) &&
+              !Resources.equals(val, ZERO_RESOURCE))) {
+        throw new PlanningException(
+            "RLESparseResourceAllocation: merge failed as the "
+                + "resulting RLESparseResourceAllocation would be negative");
+      }
+      out.put(e.getKey(), val);
+    }
+
+    return out;
+  }
+
+  private static void addIfNeeded(TreeMap<Long, Resource> out, long time,
+      Resource outRes) {
+
+    if (out.isEmpty() || (out.lastEntry() != null && outRes == null)
+        || !Resources.equals(out.lastEntry().getValue(), outRes)) {
+      out.put(time, outRes);
+    }
+
+  }
+
+  private static Resource combineValue(RLEOperator op,
+      ResourceCalculator resCalc, Resource clusterResource,
+      Entry<Long, Resource> eA, Entry<Long, Resource> eB)
+      throws PlanningException {
+
+    // deal with nulls
+    if (eA == null || eA.getValue() == null) {
+      if (eB == null || eB.getValue() == null) {
+        return null;
+      }
+      if (op == RLEOperator.subtract) {
+        return Resources.negate(eB.getValue());
+      } else {
+        return eB.getValue();
+      }
+    }
+    if (eB == null || eB.getValue() == null) {
+      return eA.getValue();
+    }
+
+    Resource a = eA.getValue();
+    Resource b = eB.getValue();
+    switch (op) {
+    case add:
+      return Resources.add(a, b);
+    case subtract:
+      return Resources.subtract(a, b);
+    case subtractTestNonNegative:
+      if (!Resources.fitsIn(b, a)) {
+        throw new PlanningException(
+            "RLESparseResourceAllocation: merge failed as the "
+                + "resulting RLESparseResourceAllocation would be negative");
+      } else {
+        return Resources.subtract(a, b);
+      }
+    case min:
+      return Resources.min(resCalc, clusterResource, a, b);
+    case max:
+      return Resources.max(resCalc, clusterResource, a, b);
+    default:
+      return null;
+    }
+
+  }
+
+  public RLESparseResourceAllocation getRangeOverlapping(long start, long end) {
+    readLock.lock();
+    try {
+      NavigableMap<Long, Resource> a = this.getCumulative();
+
+      if (a != null && !a.isEmpty()) {
+        // include the portion of previous entry that overlaps start
+        if (start > a.firstKey()) {
+          long previous = a.floorKey(start);
+          a = a.tailMap(previous, true);
+        }
+        a = a.headMap(end, true);
+      }
+      RLESparseResourceAllocation ret =
+          new RLESparseResourceAllocation(a, resourceCalculator);
+      return ret;
+    } finally {
+      readLock.unlock();
+    }
+
+  }
+
+  /**
+   * The set of operators that can be applied to two
+   * {@code RLESparseResourceAllocation} during a merge operation.
+   */
+  public enum RLEOperator {
+    add, subtract, min, max, subtractTestNonNegative

MOV26 UPD40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS71 INS74 INS83 INS42 INS44 INS44 INS8 MOV29 UPD83 UPD42 MOV44 MOV44 INS8 MOV29 UPD83 MOV83 MOV39 INS42 MOV44 MOV44 INS8 MOV29 INS83 INS39 INS42 INS8 MOV83 INS74 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS83 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS83 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 MOV44 INS8 INS83 UPD83 MOV83 MOV43 UPD42 MOV42 INS44 INS44 MOV44 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS42 INS72 INS72 INS72 INS72 INS72 INS43 INS43 INS43 INS74 INS42 INS43 INS42 INS21 INS21 MOV25 MOV21 INS54 MOV25 MOV21 INS54 MOV21 INS54 INS43 INS43 INS43 INS21 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 MOV43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS60 MOV60 MOV60 INS41 INS43 INS43 INS43 INS43 INS42 MOV43 INS42 INS74 INS42 INS74 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS25 INS25 INS60 INS60 MOV60 MOV60 MOV60 MOV60 INS60 INS60 INS60 INS61 INS21 INS41 INS43 INS43 INS43 INS43 INS42 INS74 INS42 INS42 INS60 INS70 INS41 INS74 INS42 INS39 INS42 UPD42 INS25 INS43 INS42 INS43 INS42 UPD42 INS74 INS42 INS74 INS42 INS42 INS25 INS25 MOV60 MOV60 INS50 INS42 INS39 INS42 INS39 INS42 INS21 INS54 INS65 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS7 INS7 UPD66 INS8 MOV8 UPD66 INS8 MOV8 UPD66 UPD66 UPD66 INS8 MOV8 UPD66 UPD66 UPD66 INS42 INS42 INS42 INS32 INS8 INS8 INS66 INS65 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS74 MOV59 INS74 INS74 INS14 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS42 UPD27 MOV27 INS8 INS27 INS8 MOV74 INS59 INS74 INS59 INS39 INS59 INS39 INS59 INS74 INS59 INS38 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS74 INS59 INS44 INS32 INS8 INS42 INS43 INS43 INS43 INS27 INS8 INS42 INS42 INS43 INS43 INS43 UPD43 MOV43 MOV43 INS43 INS27 INS8 UPD27 MOV27 INS8 MOV43 INS43 INS42 INS49 INS41 INS49 INS41 INS49 INS25 INS49 INS41 INS49 INS41 INS49 INS41 INS32 INS8 INS8 INS66 INS65 INS66 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS60 INS21 INS21 INS54 MOV41 INS60 INS21 INS21 INS54 MOV41 INS25 INS42 INS42 INS41 INS21 INS66 INS66 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 UPD42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD27 INS32 INS25 INS27 INS32 INS41 INS42 INS32 INS43 INS74 INS42 INS32 UPD42 UPD42 UPD42 INS33 INS42 INS33 INS42 INS9 INS42 INS9 INS43 INS43 INS43 INS42 INS14 INS36 INS60 INS60 INS25 MOV21 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS14 MOV74 INS42 INS42 INS42 MOV60 INS25 MOV21 INS42 INS42 INS42 INS32 INS36 INS38 INS21 INS42 INS42 INS42 UPD42 INS42 INS27 INS27 INS25 INS25 UPD27 INS27 INS41 UPD42 INS42 UPD42 INS32 INS42 INS32 INS42 INS32 INS42 INS38 INS8 INS8 INS42 INS32 INS42 INS32 INS33 INS42 INS42 MOV60 INS25 INS60 INS41 INS21 INS66 INS52 INS42 INS52 INS42 MOV74 INS59 INS32 INS32 INS8 INS12 MOV74 INS59 INS32 INS32 INS8 INS12 MOV32 MOV8 INS8 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 UPD42 INS42 INS42 UPD42 UPD42 MOV42 MOV42 INS27 INS8 INS8 UPD42 MOV42 MOV33 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS43 INS43 INS43 INS32 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS74 UPD27 MOV27 MOV43 INS59 INS39 INS59 INS27 MOV8 INS8 INS42 INS42 INS42 INS74 MOV43 INS27 INS8 INS42 UPD42 MOV42 INS27 INS32 INS32 INS42 INS33 INS32 INS33 INS27 INS8 INS27 INS8 INS8 UPD42 INS32 INS33 INS32 UPD42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS53 INS41 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS27 INS8 INS43 INS59 INS42 INS32 INS42 INS14 INS42 INS42 MOV32 INS42 INS42 INS42 MOV32 INS42 INS21 INS44 INS8 INS42 INS14 INS42 INS42 MOV32 INS42 INS42 INS42 MOV32 INS42 INS21 INS44 INS8 INS60 INS25 UPD34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS41 INS41 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS43 INS43 INS43 INS32 INS42 INS42 MOV38 INS42 MOV36 INS21 INS21 INS25 INS25 UPD42 UPD42 UPD42 UPD42 INS43 INS43 INS43 UPD42 INS27 INS36 INS53 UPD42 INS42 INS32 INS42 INS27 INS27 MOV42 UPD42 MOV42 MOV32 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS41 INS42 INS40 INS41 INS41 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS14 INS32 INS43 INS43 INS43 UPD42 INS27 INS38 MOV25 INS21 INS42 INS42 INS14 UPD42 MOV42 INS42 MOV74 INS7 INS43 INS42 INS74 INS7 INS43 INS42 MOV74 INS59 INS27 INS8 INS8 INS27 INS27 INS42 INS40 INS42 INS40 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS27 INS7 INS7 INS7 INS32 INS8 INS8 INS27 INS8 INS8 INS42 INS42 INS42 UPD42 UPD42 INS32 UPD42 MOV42 INS40 INS27 INS14 UPD42 MOV42 UPD42 MOV42 INS32 INS33 INS42 INS33 INS42 INS33 INS32 INS33 INS33 INS32 INS32 INS43 INS27 MOV42 MOV42 UPD42 MOV42 INS42 INS42 MOV42 INS42 INS52 UPD42 INS42 INS33 INS32 INS27 INS8 INS7 INS43 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS32 MOV33 INS41 INS41 MOV32 INS27 MOV27 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS27 INS38 INS42 INS32 INS42 INS16 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS36 MOV21 INS21 INS21 INS25 MOV21 MOV21 INS21 INS25 INS21 INS25 UPD42 MOV42 INS42 INS32 INS38 INS43 INS27 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS32 INS60 MOV21 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS40 INS40 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS33 MOV32 INS33 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS32 INS7 INS7 INS27 INS7 INS7 INS7 INS32 INS8 INS8 INS7 INS7 INS32 INS8 INS8 INS7 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS45 UPD42 MOV42 INS42 INS42 MOV42 INS39 INS59 INS7 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 INS42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 MOV42 INS27 UPD42 MOV42 MOV42 INS42 INS32 INS42 INS9 INS27 INS38 INS42 INS32 INS42 INS16 INS42 INS42 UPD42 MOV42 INS42 INS21 INS21 UPD42 INS42 INS16 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS21 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS32 INS32 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS36 INS42 INS32 INS7 INS7 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS36 INS42 INS32 INS7 INS7 INS7 INS7 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS9 INS27 INS42 UPD42 MOV42 INS42 INS32 INS42 INS9 INS42 INS32 INS42 INS9 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 DEL40 DEL26 DEL34 DEL34 DEL83 DEL83 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL32 DEL32 DEL27 DEL36 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL27 DEL32 DEL32 DEL27 DEL36 DEL41 DEL8 DEL31 DEL39 DEL42 DEL39 DEL60 DEL42 DEL34 DEL34 DEL32 DEL59 DEL60 DEL27 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL36 DEL27 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL32 DEL59 DEL60 DEL42 DEL44 DEL42 DEL8 DEL70 DEL8 DEL8 DEL25 DEL33 DEL27 DEL32 DEL8 DEL25 DEL8 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL39 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL32 DEL7 DEL21 DEL32 DEL21 DEL8 DEL24 DEL42 DEL27 DEL36 DEL32 DEL36 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL42 DEL66 DEL65 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL42 DEL39 DEL42 DEL9 DEL32 DEL38 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL38 DEL34 DEL34 DEL39 DEL34 DEL38 DEL43 DEL42 DEL32 DEL42 DEL32 DEL32 DEL8
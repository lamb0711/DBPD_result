YARN-8586. Extract log aggregation related fields and methods from RMAppImpl. Contributed by Peter Bacsko

-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.Map.Entry;
-import java.util.concurrent.ConcurrentHashMap;
-import org.apache.commons.lang3.StringUtils;
-  private final boolean logAggregationEnabled;
-  private long logAggregationStartTime = 0;
-  private final long logAggregationStatusTimeout;
-  private final Map<NodeId, LogAggregationReport> logAggregationStatus =
-      new ConcurrentHashMap<NodeId, LogAggregationReport>();
-  private volatile LogAggregationStatus logAggregationStatusForAppReport;
-  private int logAggregationSucceed = 0;
-  private int logAggregationFailed = 0;
-  private Map<NodeId, List<String>> logAggregationDiagnosticsForNMs =
-      new HashMap<NodeId, List<String>>();
-  private Map<NodeId, List<String>> logAggregationFailureMessagesForNMs =
-      new HashMap<NodeId, List<String>>();
-  private final int maxLogAggregationDiagnosticsInMemory;
+  private final RMAppLogAggregation logAggregation;
-    long localLogAggregationStatusTimeout =
-        conf.getLong(YarnConfiguration.LOG_AGGREGATION_STATUS_TIME_OUT_MS,
-          YarnConfiguration.DEFAULT_LOG_AGGREGATION_STATUS_TIME_OUT_MS);
-    if (localLogAggregationStatusTimeout <= 0) {
-      this.logAggregationStatusTimeout =
-          YarnConfiguration.DEFAULT_LOG_AGGREGATION_STATUS_TIME_OUT_MS;
-    } else {
-      this.logAggregationStatusTimeout = localLogAggregationStatusTimeout;
-    }
-    this.logAggregationEnabled =
-        conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,
-          YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED);
-    if (this.logAggregationEnabled) {
-      this.logAggregationStatusForAppReport = LogAggregationStatus.NOT_START;
-    } else {
-      this.logAggregationStatusForAppReport = LogAggregationStatus.DISABLED;
-    }
-    maxLogAggregationDiagnosticsInMemory = conf.getInt(
-        YarnConfiguration.RM_MAX_LOG_AGGREGATION_DIAGNOSTICS_IN_MEMORY,
-        YarnConfiguration.DEFAULT_RM_MAX_LOG_AGGREGATION_DIAGNOSTICS_IN_MEMORY);
+    this.logAggregation = new RMAppLogAggregation(conf, readLock, writeLock);
-      if (!app.logAggregationStatus.containsKey(nodeAddedEvent.getNodeId())) {
-        app.logAggregationStatus.put(nodeAddedEvent.getNodeId(),
-          LogAggregationReport.newInstance(app.applicationId,
-            app.logAggregationEnabled ? LogAggregationStatus.NOT_START
-                : LogAggregationStatus.DISABLED, ""));
-      }
-    };
+      app.logAggregation.addReportIfNecessary(
+          nodeAddedEvent.getNodeId(), app.getApplicationId());
+    }
-      // Send app completed event to AppManager
-      app.logAggregationStartTime = app.systemClock.getTime();
+      app.logAggregation
+          .recordLogAggregationStartTime(app.systemClock.getTime());
-    this.readLock.lock();
-    try {
-      if (!isLogAggregationFinished() && isAppInFinalState(this) &&
-          systemClock.getTime() > this.logAggregationStartTime
-          + this.logAggregationStatusTimeout) {
-        for (Entry<NodeId, LogAggregationReport> output :
-            logAggregationStatus.entrySet()) {
-          if (!output.getValue().getLogAggregationStatus()
-            .equals(LogAggregationStatus.TIME_OUT)
-              && !output.getValue().getLogAggregationStatus()
-                .equals(LogAggregationStatus.SUCCEEDED)
-              && !output.getValue().getLogAggregationStatus()
-                .equals(LogAggregationStatus.FAILED)) {
-            output.getValue().setLogAggregationStatus(
-              LogAggregationStatus.TIME_OUT);
-          }
-        }
-      }
-      return Collections.unmodifiableMap(logAggregationStatus);
-    } finally {
-      this.readLock.unlock();
-    }
+    return logAggregation.getLogAggregationReportsForApp(this);
-    this.writeLock.lock();
-    try {
-      if (this.logAggregationEnabled && !isLogAggregationFinished()) {
-        LogAggregationReport curReport = this.logAggregationStatus.get(nodeId);
-        boolean stateChangedToFinal = false;
-        if (curReport == null) {
-          this.logAggregationStatus.put(nodeId, report);
-          if (isLogAggregationFinishedForNM(report)) {
-            stateChangedToFinal = true;
-          }
-        } else {
-          if (isLogAggregationFinishedForNM(report)) {
-            if (!isLogAggregationFinishedForNM(curReport)) {
-              stateChangedToFinal = true;
-            }
-          }
-          if (report.getLogAggregationStatus() != LogAggregationStatus.RUNNING
-              || curReport.getLogAggregationStatus() !=
-                  LogAggregationStatus.RUNNING_WITH_FAILURE) {
-            if (curReport.getLogAggregationStatus()
-                == LogAggregationStatus.TIME_OUT
-                && report.getLogAggregationStatus()
-                    == LogAggregationStatus.RUNNING) {
-            // If the log aggregation status got from latest NM heartbeat
-            // is RUNNING, and current log aggregation status is TIME_OUT,
-            // based on whether there are any failure messages for this NM,
-            // we will reset the log aggregation status as RUNNING or
-            // RUNNING_WITH_FAILURE
-              if (logAggregationFailureMessagesForNMs.get(nodeId) != null &&
-                  !logAggregationFailureMessagesForNMs.get(nodeId).isEmpty()) {
-                report.setLogAggregationStatus(
-                    LogAggregationStatus.RUNNING_WITH_FAILURE);
-              }
-            }
-            curReport.setLogAggregationStatus(report
-              .getLogAggregationStatus());
-          }
-        }
-        updateLogAggregationDiagnosticMessages(nodeId, report);
-        if (isAppInFinalState(this) && stateChangedToFinal) {
-          updateLogAggregationStatus(nodeId);
-        }
-      }
-    } finally {
-      this.writeLock.unlock();
-    }
-  }
-
-  @Override
-  public LogAggregationStatus getLogAggregationStatusForAppReport() {
-    this.readLock.lock();
-    try {
-      if (! logAggregationEnabled) {
-        return LogAggregationStatus.DISABLED;
-      }
-      if (isLogAggregationFinished()) {
-        return this.logAggregationStatusForAppReport;
-      }
-      Map<NodeId, LogAggregationReport> reports =
-          getLogAggregationReportsForApp();
-      if (reports.size() == 0) {
-        return this.logAggregationStatusForAppReport;
-      }
-      int logNotStartCount = 0;
-      int logCompletedCount = 0;
-      int logTimeOutCount = 0;
-      int logFailedCount = 0;
-      int logRunningWithFailure = 0;
-      for (Entry<NodeId, LogAggregationReport> report : reports.entrySet()) {
-        switch (report.getValue().getLogAggregationStatus()) {
-          case NOT_START:
-            logNotStartCount++;
-            break;
-          case RUNNING_WITH_FAILURE:
-            logRunningWithFailure ++;
-            break;
-          case SUCCEEDED:
-            logCompletedCount++;
-            break;
-          case FAILED:
-            logFailedCount++;
-            logCompletedCount++;
-            break;
-          case TIME_OUT:
-            logTimeOutCount++;
-            logCompletedCount++;
-            break;
-          default:
-            break;
-        }
-      }
-      if (logNotStartCount == reports.size()) {
-        return LogAggregationStatus.NOT_START;
-      } else if (logCompletedCount == reports.size()) {
-        // We should satisfy two condition in order to return SUCCEEDED or FAILED
-        // 1) make sure the application is in final state
-        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT
-        // The SUCCEEDED/FAILED status is the final status which means
-        // the log aggregation is finished. And the log aggregation status will
-        // not be updated anymore.
-        if (logFailedCount > 0 && isAppInFinalState(this)) {
-          this.logAggregationStatusForAppReport =
-              LogAggregationStatus.FAILED;
-          return LogAggregationStatus.FAILED;
-        } else if (logTimeOutCount > 0) {
-          this.logAggregationStatusForAppReport =
-              LogAggregationStatus.TIME_OUT;
-          return LogAggregationStatus.TIME_OUT;
-        }
-        if (isAppInFinalState(this)) {
-          this.logAggregationStatusForAppReport =
-              LogAggregationStatus.SUCCEEDED;
-          return LogAggregationStatus.SUCCEEDED;
-        }
-      } else if (logRunningWithFailure > 0) {
-        return LogAggregationStatus.RUNNING_WITH_FAILURE;
-      }
-      return LogAggregationStatus.RUNNING;
-    } finally {
-      this.readLock.unlock();
-    }
-  }
-
-  @Override
-  public boolean isLogAggregationEnabled() {
-    return logAggregationEnabled;
+    logAggregation.aggregateLogReport(nodeId, report, this);
-    return this.logAggregationStatusForAppReport
-      .equals(LogAggregationStatus.SUCCEEDED)
-        || this.logAggregationStatusForAppReport
-          .equals(LogAggregationStatus.FAILED)
-        || this.logAggregationStatusForAppReport
-          .equals(LogAggregationStatus.TIME_OUT);
-
+    return logAggregation.isFinished();
-  private boolean isLogAggregationFinishedForNM(LogAggregationReport report) {
-    return report.getLogAggregationStatus() == LogAggregationStatus.SUCCEEDED
-        || report.getLogAggregationStatus() == LogAggregationStatus.FAILED;
-  }
-
-  private void updateLogAggregationDiagnosticMessages(NodeId nodeId,
-      LogAggregationReport report) {
-    if (report.getDiagnosticMessage() != null
-        && !report.getDiagnosticMessage().isEmpty()) {
-      if (report.getLogAggregationStatus()
-          == LogAggregationStatus.RUNNING ) {
-        List<String> diagnostics = logAggregationDiagnosticsForNMs.get(nodeId);
-        if (diagnostics == null) {
-          diagnostics = new ArrayList<String>();
-          logAggregationDiagnosticsForNMs.put(nodeId, diagnostics);
-        } else {
-          if (diagnostics.size()
-              == maxLogAggregationDiagnosticsInMemory) {
-            diagnostics.remove(0);
-          }
-        }
-        diagnostics.add(report.getDiagnosticMessage());
-        this.logAggregationStatus.get(nodeId).setDiagnosticMessage(
-          StringUtils.join(diagnostics, "\n"));
-      } else if (report.getLogAggregationStatus()
-          == LogAggregationStatus.RUNNING_WITH_FAILURE) {
-        List<String> failureMessages =
-            logAggregationFailureMessagesForNMs.get(nodeId);
-        if (failureMessages == null) {
-          failureMessages = new ArrayList<String>();
-          logAggregationFailureMessagesForNMs.put(nodeId, failureMessages);
-        } else {
-          if (failureMessages.size()
-              == maxLogAggregationDiagnosticsInMemory) {
-            failureMessages.remove(0);
-          }
-        }
-        failureMessages.add(report.getDiagnosticMessage());
-      }
-    }
-  }
-
-  private void updateLogAggregationStatus(NodeId nodeId) {
-    LogAggregationStatus status =
-        this.logAggregationStatus.get(nodeId).getLogAggregationStatus();
-    if (status.equals(LogAggregationStatus.SUCCEEDED)) {
-      this.logAggregationSucceed++;
-    } else if (status.equals(LogAggregationStatus.FAILED)) {
-      this.logAggregationFailed++;
-    }
-    if (this.logAggregationSucceed == this.logAggregationStatus.size()) {
-      this.logAggregationStatusForAppReport =
-          LogAggregationStatus.SUCCEEDED;
-      // Since the log aggregation status for this application for all NMs
-      // is SUCCEEDED, it means all logs are aggregated successfully.
-      // We could remove all the cached log aggregation reports
-      this.logAggregationStatus.clear();
-      this.logAggregationDiagnosticsForNMs.clear();
-      this.logAggregationFailureMessagesForNMs.clear();
-    } else if (this.logAggregationSucceed + this.logAggregationFailed
-        == this.logAggregationStatus.size()) {
-      this.logAggregationStatusForAppReport = LogAggregationStatus.FAILED;
-      // We have collected the log aggregation status for all NMs.
-      // The log aggregation status is FAILED which means the log
-      // aggregation fails in some NMs. We are only interested in the
-      // nodes where the log aggregation is failed. So we could remove
-      // the log aggregation details for those succeeded NMs
-      for (Iterator<Map.Entry<NodeId, LogAggregationReport>> it =
-          this.logAggregationStatus.entrySet().iterator(); it.hasNext();) {
-        Map.Entry<NodeId, LogAggregationReport> entry = it.next();
-        if (entry.getValue().getLogAggregationStatus()
-          .equals(LogAggregationStatus.SUCCEEDED)) {
-          it.remove();
-        }
-      }
-      // the log aggregation has finished/failed.
-      // and the status will not be updated anymore.
-      this.logAggregationDiagnosticsForNMs.clear();
-    }
+  @Override
+  public boolean isLogAggregationEnabled() {
+    return logAggregation.isEnabled();
-    this.readLock.lock();
-    try {
-      List<String> failureMessages =
-          this.logAggregationFailureMessagesForNMs.get(nodeId);
-      if (failureMessages == null || failureMessages.isEmpty()) {
-        return StringUtils.EMPTY;
-      }
-      return StringUtils.join(failureMessages, "\n");
-    } finally {
-      this.readLock.unlock();
-    }
+    return logAggregation.getLogAggregationFailureMessagesForNM(nodeId);
+  }
+
+  @Override
+  public LogAggregationStatus getLogAggregationStatusForAppReport() {
+    return logAggregation
+        .getLogAggregationStatusForAppReport(this);
-  public long getLogAggregationStartTime() {
-    return logAggregationStartTime;
+  long getLogAggregationStartTime() {
+    return logAggregation.getLogAggregationStartTime();
+  Clock getSystemClock() {
+    return systemClock;
+  }

MOV31 MOV31 INS43 MOV78 INS8 MOV44 INS8 UPD42 MOV78 UPD42 UPD83 MOV43 UPD42 MOV44 MOV78 UPD83 MOV43 INS42 INS8 MOV78 UPD39 UPD42 UPD43 INS42 INS8 UPD42 MOV42 UPD42 MOV41 MOV21 INS41 INS41 UPD42 MOV41 MOV21 INS32 INS32 INS32 INS32 INS32 INS42 INS14 MOV32 INS32 UPD42 UPD42 INS52 INS42 UPD42 INS52 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS52 INS42 UPD42 MOV42 UPD42 INS43 INS42 INS42 INS42 UPD40 UPD42 INS32 INS40 INS42 MOV32 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL14 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL39 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL40 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL7 DEL21 DEL40 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL40 DEL40 DEL40 DEL16 DEL45 DEL32 DEL32 DEL38 DEL8 DEL25 DEL40 DEL7 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL32 DEL38 DEL42 DEL52 DEL32 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL27 DEL27 DEL27 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL40 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL32 DEL42 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL38 DEL40 DEL41 DEL8 DEL25 DEL42 DEL32 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL49 DEL42 DEL37 DEL21 DEL10 DEL42 DEL49 DEL42 DEL37 DEL21 DEL10 DEL42 DEL49 DEL42 DEL37 DEL21 DEL10 DEL42 DEL49 DEL42 DEL37 DEL21 DEL42 DEL37 DEL21 DEL10 DEL42 DEL49 DEL42 DEL37 DEL21 DEL42 DEL37 DEL21 DEL10 DEL49 DEL10 DEL50 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL27 DEL40 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL34 DEL27 DEL42 DEL52 DEL32 DEL27 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL40 DEL41 DEL8 DEL42 DEL34 DEL27 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL40 DEL41 DEL8 DEL25 DEL25 DEL42 DEL52 DEL32 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL40 DEL41 DEL8 DEL25 DEL8 DEL42 DEL34 DEL27 DEL40 DEL41 DEL8 DEL25 DEL25 DEL25 DEL40 DEL41 DEL8 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL42 DEL52 DEL42 DEL22 DEL40 DEL32 DEL52 DEL42 DEL22 DEL42 DEL40 DEL32 DEL52 DEL42 DEL22 DEL42 DEL40 DEL32 DEL27 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL40 DEL27 DEL32 DEL40 DEL27 DEL27 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL52 DEL42 DEL22 DEL37 DEL21 DEL8 DEL42 DEL42 DEL40 DEL32 DEL52 DEL42 DEL22 DEL37 DEL21 DEL8 DEL25 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL27 DEL52 DEL42 DEL22 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL42 DEL43 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL83 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL40 DEL41 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31
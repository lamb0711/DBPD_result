HDFS-11699. Ozone:SCM: Add support for close containers in SCM. Contributed by Anu Engineer.

-import org.apache.hadoop.ozone.protocol.proto.StorageContainerDatanodeProtocolProtos;
+import org.apache.hadoop.ozone.protocol.proto
+    .StorageContainerDatanodeProtocolProtos;
+import org.apache.hadoop.ozone.scm.container.closer.ContainerCloser;
+import static org.apache.hadoop.scm.ScmConfigKeys
+    .OZONE_SCM_CONTAINER_SIZE_DEFAULT;
+import static org.apache.hadoop.scm.ScmConfigKeys.OZONE_SCM_CONTAINER_SIZE_GB;
+  private final ContainerCloser closer;
+  private final long size;
+    this.closer = new ContainerCloser(nodeManager, conf);
+
+    // To be replaced with code getStorageSize once it is committed.
+    size = conf.getLong(OZONE_SCM_CONTAINER_SIZE_GB,
+        OZONE_SCM_CONTAINER_SIZE_DEFAULT) * 1024 * 1024 * 1024;
+   *
+   * <p>
+   * Processing follows a very simple logic for time being.
+   * <p>
+   * 1. Datanodes report the current State -- denoted by the datanodeState
+   * <p>
+   * 2. We are the older SCM state from the Database -- denoted by
+   * the knownState.
+   * <p>
+   * 3. We copy the usage etc. from currentState to newState and log that
+   * newState to the DB. This allows us SCM to bootup again and read the
+   * state of the world from the DB, and then reconcile the state from
+   * container reports, when they arrive.
-    for (StorageContainerDatanodeProtocolProtos.ContainerInfo containerInfo :
+    for (StorageContainerDatanodeProtocolProtos.ContainerInfo datanodeState :
-      byte[] dbKey = containerInfo.getContainerNameBytes().toByteArray();
+      byte[] dbKey = datanodeState.getContainerNameBytes().toByteArray();
-          OzoneProtos.SCMContainerInfo oldInfo =
+          OzoneProtos.SCMContainerInfo knownState =
-          OzoneProtos.SCMContainerInfo.Builder builder =
-              OzoneProtos.SCMContainerInfo.newBuilder();
-          builder.setContainerName(oldInfo.getContainerName());
-          builder.setPipeline(oldInfo.getPipeline());
-          // If used size is greater than allocated size, we will be updating
-          // allocated size with used size. This update is done as a fallback
-          // mechanism in case SCM crashes without properly updating allocated
-          // size. Correct allocated value will be updated by
-          // ContainerStateManager during SCM shutdown.
-          long usedSize = containerInfo.getUsed();
-          long allocated = oldInfo.getAllocatedBytes() > usedSize ?
-              oldInfo.getAllocatedBytes() : usedSize;
-          builder.setAllocatedBytes(allocated);
-          builder.setUsedBytes(containerInfo.getUsed());
-          builder.setNumberOfKeys(containerInfo.getKeyCount());
-          builder.setState(oldInfo.getState());
-          builder.setStateEnterTime(oldInfo.getStateEnterTime());
-          builder.setContainerID(oldInfo.getContainerID());
-          if (oldInfo.getOwner() != null) {
-            builder.setOwner(oldInfo.getOwner());
-          }
-          OzoneProtos.SCMContainerInfo newContainerInfo = builder.build();
-          containerStore.put(dbKey, newContainerInfo.toByteArray());
-          float containerUsedPercentage = 1.0f *
-              containerInfo.getUsed() / containerInfo.getSize();
-          // TODO: Handling of containers which are already in close queue.
-          if (containerUsedPercentage >= containerCloseThreshold) {
-            // TODO: The container has to be moved to close container queue.
-            // For now, we are just updating the container state to CLOSING.
-            // Close container implementation can decide on how to maintain
-            // list of containers to be closed, this is the place where we
-            // have to add the containers to that list.
-            OzoneProtos.LifeCycleState state = updateContainerState(
-                ContainerInfo.fromProtobuf(newContainerInfo).getContainerName(),
-                OzoneProtos.LifeCycleEvent.FINALIZE);
-            if (state != OzoneProtos.LifeCycleState.CLOSING) {
-              LOG.error("Failed to close container {}, reason : Not able to " +
-                  "update container state, current container state: {}.",
-                  containerInfo.getContainerName(), state);
-            }
+          OzoneProtos.SCMContainerInfo newState =
+              reconcileState(datanodeState, knownState);
+
+          // FIX ME: This can be optimized, we write twice to memory, where a
+          // single write would work well.
+          //
+          // We need to write this to DB again since the closed only write
+          // the updated State.
+          containerStore.put(dbKey, newState.toByteArray());
+
+          // If the container is closed, then state is already written to SCM
+          // DB.TODO: So can we can write only once to DB.
+          if (closeContainerIfNeeded(newState)) {
+            LOG.info("Closing the Container: {}", newState.getContainerName());
-              " {}, for container: {}, reason: container doesn't exist in" +
-              "container database.", reports.getDatanodeID(),
-              containerInfo.getContainerName());
+                  " {}, for container: {}, reason: container doesn't exist in" +
+                  "container database.", reports.getDatanodeID(),
+              datanodeState.getContainerName());
+   * Reconciles the state from Datanode with the state in SCM.
+   *
+   * @param datanodeState - State from the Datanode.
+   * @param knownState - State inside SCM.
+   * @return new SCM State for this container.
+   */
+  private OzoneProtos.SCMContainerInfo reconcileState(
+      StorageContainerDatanodeProtocolProtos.ContainerInfo datanodeState,
+      OzoneProtos.SCMContainerInfo knownState) {
+    OzoneProtos.SCMContainerInfo.Builder builder =
+        OzoneProtos.SCMContainerInfo.newBuilder();
+    builder.setContainerName(knownState.getContainerName());
+    builder.setPipeline(knownState.getPipeline());
+    // If used size is greater than allocated size, we will be updating
+    // allocated size with used size. This update is done as a fallback
+    // mechanism in case SCM crashes without properly updating allocated
+    // size. Correct allocated value will be updated by
+    // ContainerStateManager during SCM shutdown.
+    long usedSize = datanodeState.getUsed();
+    long allocated = knownState.getAllocatedBytes() > usedSize ?
+        knownState.getAllocatedBytes() : usedSize;
+    builder.setAllocatedBytes(allocated);
+    builder.setUsedBytes(usedSize);
+    builder.setNumberOfKeys(datanodeState.getKeyCount());
+    builder.setState(knownState.getState());
+    builder.setStateEnterTime(knownState.getStateEnterTime());
+    builder.setContainerID(knownState.getContainerID());
+    if (knownState.getOwner() != null) {
+      builder.setOwner(knownState.getOwner());
+    }
+    return builder.build();
+  }
+
+  /**
+   * Queues the close container command, to datanode and writes the new state
+   * to container DB.
+   * <p>
+   * TODO : Remove this 2 ContainerInfo definitions. It is brain dead to have
+   * one protobuf in one file and another definition in another file.
+   *
+   * @param newState - This is the state we maintain in SCM.
+   * @throws IOException
+   */
+  private boolean closeContainerIfNeeded(OzoneProtos.SCMContainerInfo newState)
+      throws IOException {
+    float containerUsedPercentage = 1.0f *
+        newState.getUsedBytes() / this.size;
+
+    ContainerInfo scmInfo = getContainer(newState.getContainerName());
+    if (containerUsedPercentage >= containerCloseThreshold
+        && !isClosed(scmInfo)) {
+      // We will call closer till get to the closed state.
+      // That is SCM will make this call repeatedly until we reach the closed
+      // state.
+      closer.close(newState);
+
+      if (shouldClose(scmInfo)) {
+        // This event moves the Container from Open to Closing State, this is
+        // a state inside SCM. This is the desired state that SCM wants this
+        // container to reach. We will know that a container has reached the
+        // closed state from container reports. This state change should be
+        // invoked once and only once.
+        OzoneProtos.LifeCycleState state = updateContainerState(
+            scmInfo.getContainerName(),
+            OzoneProtos.LifeCycleEvent.FINALIZE);
+        if (state != OzoneProtos.LifeCycleState.CLOSING) {
+          LOG.error("Failed to close container {}, reason : Not able " +
+                  "to " +
+                  "update container state, current container state: {}.",
+              newState.getContainerName(), state);
+          return false;
+        }
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * In Container is in closed state, if it is in closed, Deleting or Deleted
+   * State.
+   *
+   * @param info - ContainerInfo.
+   * @return true if is in open state, false otherwise
+   */
+  private boolean shouldClose(ContainerInfo info) {
+    return info.getState() == OzoneProtos.LifeCycleState.OPEN;
+  }
+
+  private boolean isClosed(ContainerInfo info) {
+    return info.getState() == OzoneProtos.LifeCycleState.CLOSED;
+  }
+
+  @VisibleForTesting
+  public ContainerCloser getCloser() {
+    return closer;
+  }
+
+  /**
-   *
+   * <p>
-   * @throws IOException  on failure.
+   * @throws IOException on failure.

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 MOV29 MOV78 MOV83 MOV39 MOV42 MOV44 MOV43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS42 INS42 INS42 INS21 INS21 MOV60 MOV21 INS70 INS65 INS65 INS65 INS65 INS40 INS43 INS42 MOV43 INS42 MOV60 MOV21 MOV21 MOV60 MOV60 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV25 INS41 INS65 INS65 INS65 INS43 INS42 INS42 MOV60 INS60 INS25 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS43 INS42 INS41 INS42 INS42 INS41 INS7 INS7 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 MOV44 MOV42 INS8 INS66 INS42 INS66 INS42 INS66 INS66 INS40 MOV32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS40 INS43 INS59 INS27 INS8 INS9 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS42 INS27 INS42 INS66 UPD66 INS22 INS14 INS42 INS27 UPD42 MOV60 MOV21 INS54 UPD42 MOV42 INS42 INS42 INS32 MOV27 INS38 INS21 MOV25 INS32 INS40 INS32 INS40 INS52 INS42 INS43 INS42 INS42 INS32 INS34 INS34 INS34 INS8 MOV8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV60 INS25 UPD42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 MOV27 INS8 MOV8 UPD42 UPD42 UPD42 UPD42 INS9 UPD42 MOV60 INS60 INS21 INS25 INS41 INS43 INS59 INS32 INS32 INS8 INS9 UPD42 INS40 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS21 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD45 INS45 UPD42 INS42 INS42 INS45 INS32 INS42 INS42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL70 DEL8 DEL31
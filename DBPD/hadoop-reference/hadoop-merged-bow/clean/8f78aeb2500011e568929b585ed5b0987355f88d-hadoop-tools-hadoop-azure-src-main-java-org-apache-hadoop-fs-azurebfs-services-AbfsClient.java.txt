Hadoop-17015. ABFS: Handling Rename and Delete idempotency 

Contributed by Sneha Vijayarajan.
+import java.net.HttpURLConnection;
+import java.time.Instant;
+import org.apache.hadoop.fs.azurebfs.utils.DateTimeUtils;
+import static org.apache.hadoop.fs.azurebfs.constants.FileSystemConfigurations.DEFAULT_DELETE_CONSIDERED_IDEMPOTENT;
+    Instant renameRequestStartTime = Instant.now();
+
+    if (op.getResult().getStatusCode() != HttpURLConnection.HTTP_OK) {
+      return renameIdempotencyCheckOp(renameRequestStartTime, op, destination);
+    }
+
+    return op;
+  }
+
+  /**
+   * Check if the rename request failure is post a retry and if earlier rename
+   * request might have succeeded at back-end.
+   *
+   * If there is a parallel rename activity happening from any other store
+   * interface, the logic here will detect the rename to have happened due to
+   * the one initiated from this ABFS filesytem instance as it was retried. This
+   * should be a corner case hence going ahead with LMT check.
+   * @param renameRequestStartTime startTime for the rename request
+   * @param op Rename request REST operation response
+   * @param destination rename destination path
+   * @return REST operation response post idempotency check
+   * @throws AzureBlobFileSystemException if GetFileStatus hits any exception
+   */
+  public AbfsRestOperation renameIdempotencyCheckOp(
+      final Instant renameRequestStartTime,
+      final AbfsRestOperation op,
+      final String destination) throws AzureBlobFileSystemException {
+    if ((op.isARetriedRequest())
+        && (op.getResult().getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND)) {
+      // Server has returned HTTP 404, which means rename source no longer
+      // exists. Check on destination status and if it has a recent LMT timestamp.
+      // If yes, return success, else fall back to original rename request failure response.
+
+      final AbfsRestOperation destStatusOp = getPathStatus(destination, false);
+      if (destStatusOp.getResult().getStatusCode() == HttpURLConnection.HTTP_OK) {
+        String lmt = destStatusOp.getResult().getResponseHeader(
+            HttpHeaderConfigurations.LAST_MODIFIED);
+
+        if (DateTimeUtils.isRecentlyModified(lmt, renameRequestStartTime)) {
+          return destStatusOp;
+        }
+      }
+    }
+
+
+    if (op.getResult().getStatusCode() != HttpURLConnection.HTTP_OK) {
+      return deleteIdempotencyCheckOp(op);
+    }
+
+    return op;
+  }
+
+  /**
+   * Check if the delete request failure is post a retry and if delete failure
+   * qualifies to be a success response assuming idempotency.
+   *
+   * There are below scenarios where delete could be incorrectly deducted as
+   * success post request retry:
+   * 1. Target was originally not existing and initial delete request had to be
+   * re-tried.
+   * 2. Parallel delete issued from any other store interface rather than
+   * delete issued from this filesystem instance.
+   * These are few corner cases and usually returning a success at this stage
+   * should help the job to continue.
+   * @param op Delete request REST operation response
+   * @return REST operation response post idempotency check
+   */
+  public AbfsRestOperation deleteIdempotencyCheckOp(final AbfsRestOperation op) {
+    if ((op.isARetriedRequest())
+        && (op.getResult().getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND)
+        && DEFAULT_DELETE_CONSIDERED_IDEMPOTENT) {
+      // Server has returned HTTP 404, which means path no longer
+      // exists. Assuming delete result to be idempotent, return success.
+      final AbfsRestOperation successOp = new AbfsRestOperation(
+          AbfsRestOperationType.DeletePath,
+          this,
+          HTTP_METHOD_DELETE,
+          op.getUrl(),
+          op.getRequestHeaders());
+      successOp.hardSetResult(HttpURLConnection.HTTP_OK);
+      return successOp;
+    }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS60 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS42 INS25 INS41 INS25 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS25 INS41 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS27 INS8 INS42 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS42 INS42 INS42 INS32 INS32 INS40 INS41 INS36 INS36 INS60 INS25 INS32 INS40 INS41 INS36 INS36 INS42 INS60 INS21 INS41 INS42 INS42 INS32 INS42 INS32 INS32 INS27 INS83 INS43 INS59 INS27 INS8 INS32 INS42 INS32 INS32 INS27 INS83 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS32 INS32 INS40 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS14 INS42 INS42 INS40 INS32 INS42 INS42 INS42 INS9 INS32 INS42 INS43 INS59 INS32 INS8 INS32 INS42 INS43 INS40 INS52 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS40 INS42 INS42 INS42
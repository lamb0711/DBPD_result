HDFS-4721. Speed up lease recovery by avoiding stale datanodes and choosing the datanode with the most recent heartbeat as the primary.  Contributed by Varun Sharma


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476399 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
-  /** A data-node responsible for block recovery. */
+  /**
+   * Index of the primary data node doing the recovery. Useful for log
+   * messages.
+   */
+    private boolean chosenAsPrimary;
+      this.chosenAsPrimary = false;
+     * Whether the replica was chosen for recovery.
+     */
+    boolean getChosenAsPrimary() {
+      return chosenAsPrimary;
+    }
+
+    /**
+     * Set whether this replica was chosen for recovery.
+     */
+    void setChosenAsPrimary(boolean chosenAsPrimary) {
+      this.chosenAsPrimary = chosenAsPrimary;
+    }
+
+    /**
-
-    int previous = primaryNodeIndex;
-    for(int i = 1; i <= replicas.size(); i++) {
-      int j = (previous + i)%replicas.size();
-      if (replicas.get(j).isAlive()) {
-        primaryNodeIndex = j;
-        DatanodeDescriptor primary = replicas.get(j).getExpectedLocation(); 
-        primary.addBlockToBeRecovered(this);
-        NameNode.blockStateChangeLog.info("BLOCK* " + this
-          + " recovery started, primary=" + primary);
-        return;
+    boolean allLiveReplicasTriedAsPrimary = true;
+    for (int i = 0; i < replicas.size(); i++) {
+      // Check if all replicas have been tried or not.
+      if (replicas.get(i).isAlive()) {
+        allLiveReplicasTriedAsPrimary =
+            (allLiveReplicasTriedAsPrimary && replicas.get(i).getChosenAsPrimary());
+    if (allLiveReplicasTriedAsPrimary) {
+      // Just set all the replicas to be chosen whether they are alive or not.
+      for (int i = 0; i < replicas.size(); i++) {
+        replicas.get(i).setChosenAsPrimary(false);
+      }
+    }
+    long mostRecentLastUpdate = 0;
+    ReplicaUnderConstruction primary = null;
+    primaryNodeIndex = -1;
+    for(int i = 0; i < replicas.size(); i++) {
+      // Skip alive replicas which have been chosen for recovery.
+      if (!(replicas.get(i).isAlive() && !replicas.get(i).getChosenAsPrimary())) {
+        continue;
+      }
+      if (replicas.get(i).getExpectedLocation().getLastUpdate() > mostRecentLastUpdate) {
+        primary = replicas.get(i);
+        primaryNodeIndex = i;
+        mostRecentLastUpdate = primary.getExpectedLocation().getLastUpdate();
+      }
+    }
+    if (primary != null) {
+      primary.getExpectedLocation().addBlockToBeRecovered(this);
+      primary.setChosenAsPrimary(true);
+      NameNode.blockStateChangeLog.info("BLOCK* " + this
+        + " recovery started, primary=" + primary);
+    }

INS26 INS40 INS23 INS31 INS31 INS83 INS39 INS59 INS29 INS39 INS42 INS8 INS29 INS39 INS42 INS44 INS8 INS24 INS25 INS60 INS60 MOV21 INS24 INS25 UPD66 INS66 INS42 INS21 INS65 INS41 INS65 INS39 INS42 INS21 UPD39 MOV58 UPD27 MOV27 MOV37 INS8 INS42 INS8 INS39 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS7 INS66 INS42 INS66 INS7 UPD42 INS9 MOV42 INS25 INS24 INS42 INS34 INS42 INS42 INS33 INS38 INS39 INS59 INS42 INS32 INS42 INS25 INS25 INS42 INS33 MOV21 INS21 MOV21 INS22 INS9 INS22 INS42 UPD34 INS32 INS8 INS58 UPD27 MOV27 INS37 INS8 INS34 INS42 INS34 INS42 INS42 INS38 INS8 INS27 INS8 INS32 INS52 INS42 INS52 INS42 INS32 INS42 INS21 INS39 INS59 INS42 INS21 INS36 INS18 INS32 INS42 INS21 INS21 INS21 INS32 INS42 INS42 INS9 INS42 INS42 INS42 INS7 UPD42 MOV42 INS34 INS32 INS27 INS32 INS42 INS7 INS7 INS7 MOV42 INS42 INS42 INS36 MOV32 UPD42 MOV42 INS9 INS32 INS38 MOV32 MOV42 INS42 INS32 INS42 INS42 INS42 INS32 INS27 UPD42 INS32 INS42 INS32 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL27 DEL36 DEL42 DEL39 DEL59 DEL60 DEL32 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL41 DEL8 DEL25 DEL8 DEL24
Merge branch 'trunk' into HADOOP-12756

-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.Condition;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.util.StringUtils;
+import org.apache.hadoop.util.Timer;
+
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_LOCK_SUPPRESS_WARNING_INTERVAL_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_LOCK_SUPPRESS_WARNING_INTERVAL_KEY;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_READ_LOCK_REPORTING_THRESHOLD_MS_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_READ_LOCK_REPORTING_THRESHOLD_MS_KEY;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_WRITE_LOCK_REPORTING_THRESHOLD_MS_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_WRITE_LOCK_REPORTING_THRESHOLD_MS_KEY;
- * Mimics a ReentrantReadWriteLock so more sophisticated locking capabilities
- * are possible.
+ * Mimics a ReentrantReadWriteLock but does not directly implement the interface
+ * so more sophisticated locking capabilities and logging/metrics are possible.
-class FSNamesystemLock implements ReadWriteLock {
+class FSNamesystemLock {
-  
-  FSNamesystemLock(boolean fair) {
+
+  private final Timer timer;
+
+  /**
+   * Log statements about long lock hold times will not be produced more
+   * frequently than this interval.
+   */
+  private final long lockSuppressWarningInterval;
+
+  /** Threshold (ms) for long holding write lock report. */
+  private final long writeLockReportingThreshold;
+  /** Last time stamp for write lock. Keep the longest one for multi-entrance.*/
+  private long writeLockHeldTimeStamp;
+  private int numWriteLockWarningsSuppressed = 0;
+  private long timeStampOfLastWriteLockReport = 0;
+  private long longestWriteLockHeldInterval = 0;
+
+  /** Threshold (ms) for long holding read lock report. */
+  private final long readLockReportingThreshold;
+  /**
+   * Last time stamp for read lock. Keep the longest one for
+   * multi-entrance. This is ThreadLocal since there could be
+   * many read locks held simultaneously.
+   */
+  private final ThreadLocal<Long> readLockHeldTimeStamp =
+      new ThreadLocal<Long>() {
+        @Override
+        public Long initialValue() {
+          return Long.MAX_VALUE;
+        }
+      };
+  private final AtomicInteger numReadLockWarningsSuppressed =
+      new AtomicInteger(0);
+  private final AtomicLong timeStampOfLastReadLockReport = new AtomicLong(0);
+  private final AtomicLong longestReadLockHeldInterval = new AtomicLong(0);
+
+  FSNamesystemLock(Configuration conf) {
+    this(conf, new Timer());
+  }
+
+  @VisibleForTesting
+  FSNamesystemLock(Configuration conf, Timer timer) {
+    boolean fair = conf.getBoolean("dfs.namenode.fslock.fair", true);
+    FSNamesystem.LOG.info("fsLock is fair: " + fair);
+    this.timer = timer;
+
+    this.writeLockReportingThreshold = conf.getLong(
+        DFS_NAMENODE_WRITE_LOCK_REPORTING_THRESHOLD_MS_KEY,
+        DFS_NAMENODE_WRITE_LOCK_REPORTING_THRESHOLD_MS_DEFAULT);
+    this.readLockReportingThreshold = conf.getLong(
+        DFS_NAMENODE_READ_LOCK_REPORTING_THRESHOLD_MS_KEY,
+        DFS_NAMENODE_READ_LOCK_REPORTING_THRESHOLD_MS_DEFAULT);
+    this.lockSuppressWarningInterval = conf.getTimeDuration(
+        DFS_LOCK_SUPPRESS_WARNING_INTERVAL_KEY,
+        DFS_LOCK_SUPPRESS_WARNING_INTERVAL_DEFAULT, TimeUnit.MILLISECONDS);
+  }
+
+  public void readLock() {
+    coarseLock.readLock().lock();
+    if (coarseLock.getReadHoldCount() == 1) {
+      readLockHeldTimeStamp.set(timer.monotonicNow());
+    }
+  }
+
+  public void readUnlock() {
+    final boolean needReport = coarseLock.getReadHoldCount() == 1;
+    final long readLockInterval =
+        timer.monotonicNow() - readLockHeldTimeStamp.get();
+    coarseLock.readLock().unlock();
+
+    if (needReport) {
+      readLockHeldTimeStamp.remove();
+    }
+    if (needReport && readLockInterval >= this.readLockReportingThreshold) {
+      long localLongestReadLock;
+      do {
+        localLongestReadLock = longestReadLockHeldInterval.get();
+      } while (localLongestReadLock - readLockInterval < 0 &&
+          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,
+              readLockInterval));
+
+      long localTimeStampOfLastReadLockReport;
+      long now;
+      do {
+        now = timer.monotonicNow();
+        localTimeStampOfLastReadLockReport =
+            timeStampOfLastReadLockReport.get();
+        if (now - localTimeStampOfLastReadLockReport <
+            lockSuppressWarningInterval) {
+          numReadLockWarningsSuppressed.incrementAndGet();
+          return;
+        }
+      } while (!timeStampOfLastReadLockReport.compareAndSet(
+          localTimeStampOfLastReadLockReport, now));
+      int numSuppressedWarnings = numReadLockWarningsSuppressed.getAndSet(0);
+      long longestLockHeldInterval = longestReadLockHeldInterval.getAndSet(0);
+      FSNamesystem.LOG.info("FSNamesystem read lock held for " +
+          readLockInterval + " ms via\n" +
+          StringUtils.getStackTrace(Thread.currentThread()) +
+          "\tNumber of suppressed read-lock reports: " + numSuppressedWarnings +
+          "\n\tLongest read-lock held interval: " + longestLockHeldInterval);
+    }
-  @Override
-  public Lock readLock() {
-    return coarseLock.readLock();
+  public void writeLock() {
+    coarseLock.writeLock().lock();
+    if (coarseLock.getWriteHoldCount() == 1) {
+      writeLockHeldTimeStamp = timer.monotonicNow();
+    }
-  
-  @Override
-  public Lock writeLock() {
-    return coarseLock.writeLock();
+
+  public void writeLockInterruptibly() throws InterruptedException {
+    coarseLock.writeLock().lockInterruptibly();
+    if (coarseLock.getWriteHoldCount() == 1) {
+      writeLockHeldTimeStamp = timer.monotonicNow();
+    }
+  }
+
+  public void writeUnlock() {
+    final boolean needReport = coarseLock.getWriteHoldCount() == 1 &&
+        coarseLock.isWriteLockedByCurrentThread();
+    final long currentTime = timer.monotonicNow();
+    final long writeLockInterval = currentTime - writeLockHeldTimeStamp;
+
+    boolean logReport = false;
+    int numSuppressedWarnings = 0;
+    long longestLockHeldInterval = 0;
+    if (needReport && writeLockInterval >= this.writeLockReportingThreshold) {
+      if (writeLockInterval > longestWriteLockHeldInterval) {
+        longestWriteLockHeldInterval = writeLockInterval;
+      }
+      if (currentTime - timeStampOfLastWriteLockReport >
+          this.lockSuppressWarningInterval) {
+        logReport = true;
+        numSuppressedWarnings = numWriteLockWarningsSuppressed;
+        numWriteLockWarningsSuppressed = 0;
+        longestLockHeldInterval = longestWriteLockHeldInterval;
+        longestWriteLockHeldInterval = 0;
+        timeStampOfLastWriteLockReport = currentTime;
+      } else {
+        numWriteLockWarningsSuppressed++;
+      }
+    }
+
+    coarseLock.writeLock().unlock();
+
+    if (logReport) {
+      FSNamesystem.LOG.info("FSNamesystem write lock held for " +
+          writeLockInterval + " ms via\n" +
+          StringUtils.getStackTrace(Thread.currentThread()) +
+          "\tNumber of suppressed write-lock reports: " +
+          numSuppressedWarnings + "\n\tLongest write-lock held interval: " +
+          longestLockHeldInterval);
+    }
+  public Condition newWriteLockCondition() {
+    return coarseLock.writeLock().newCondition();
+  }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 UPD40 INS40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS74 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 MOV78 INS42 INS44 INS44 INS8 MOV83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS8 UPD43 UPD42 UPD66 UPD66 INS42 INS42 INS65 INS42 INS65 INS42 INS65 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS65 INS42 INS65 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS42 INS17 UPD42 INS43 INS42 INS43 INS42 INS60 INS21 MOV21 INS21 INS21 INS21 INS21 INS21 INS25 INS60 INS60 INS21 INS25 INS25 INS21 INS25 INS42 INS21 INS25 INS60 INS60 INS60 INS60 INS60 INS60 INS25 INS21 INS25 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 MOV42 INS42 INS74 INS1 INS43 INS34 INS43 INS34 INS43 INS34 INS42 INS42 INS14 INS42 INS42 INS39 INS59 INS32 INS7 INS7 INS7 INS7 INS32 INS27 INS8 INS83 INS39 INS59 INS83 INS39 INS59 INS32 INS42 INS8 INS27 INS8 INS32 INS27 INS8 INS32 INS27 INS8 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS32 INS42 INS8 INS32 INS43 INS43 INS31 INS42 INS42 INS42 INS43 INS42 INS32 INS40 INS42 INS27 INS22 INS42 INS22 INS32 INS22 INS32 INS22 INS32 MOV32 INS42 INS32 INS34 INS21 INS42 INS27 INS42 INS27 INS32 INS42 INS21 INS42 INS27 INS60 INS19 INS60 INS60 INS19 INS60 INS60 INS21 MOV32 INS42 INS32 INS34 INS21 INS32 INS42 INS32 INS34 INS21 INS42 INS27 INS42 INS32 INS42 INS27 INS42 INS9 INS42 INS34 INS42 INS34 INS42 INS27 INS25 INS25 INS32 INS42 INS21 INS32 INS42 INS42 INS42 MOV78 INS83 INS43 INS42 INS8 INS42 INS42 INS42 INS45 INS9 INS45 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS32 INS34 INS32 INS32 INS42 INS42 INS32 INS42 INS22 INS39 INS59 INS8 INS27 INS39 INS59 INS39 INS59 INS8 INS38 INS39 INS59 INS39 INS59 INS32 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS7 INS27 INS32 INS42 INS42 INS42 INS42 INS42 INS22 INS27 INS8 INS27 INS8 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS41 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS21 INS27 INS38 INS42 INS42 INS21 INS21 INS25 INS32 INS42 INS32 INS42 INS32 INS40 INS42 INS27 INS42 INS32 INS42 INS32 INS32 INS34 INS42 INS42 INS52 INS42 INS42 INS42 INS21 INS27 INS22 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS40 INS42 INS27 INS40 INS42 INS42 INS7 INS27 INS34 INS32 INS7 INS7 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS34 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS52 INS42 INS7 INS7 INS7 INS7 INS7 INS7 INS37 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS27 INS42 INS21 MOV41 INS42 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL43 DEL39 DEL42 DEL42 DEL43 DEL42 DEL8 DEL31
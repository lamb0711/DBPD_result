YARN-7119. Support multiple resource types in rmadmin updateNodeResource command. Contributed by Manikandan R.

+import java.util.regex.Pattern;
+import org.apache.commons.lang.StringUtils;
+import org.apache.hadoop.yarn.api.records.ResourceInformation;
+import org.apache.hadoop.yarn.util.resource.ResourceUtils;
+  private static final Pattern RESOURCE_TYPES_ARGS_PATTERN =
+      Pattern.compile("^[0-9]*$");
-              new UsageInfo("[NodeID] [MemSize] [vCores] ([OvercommitTimeout])",
+              new UsageInfo("[NodeID] [MemSize] [vCores] ([OvercommitTimeout])"
+                  + " \n\t\tor\n\t\t[NodeID] [resourcetypes] "
+                  + "([OvercommitTimeout]). ",
-    summary.append("The full syntax is: \n\n" +
-        "yarn rmadmin" +
-        " [-refreshQueues]" +
-        " [-refreshNodes [-g|graceful [timeout in seconds] -client|server]]" +
-        " [-refreshNodesResources]" +
-        " [-refreshSuperUserGroupsConfiguration]" +
-        " [-refreshUserToGroupsMappings]" +
-        " [-refreshAdminAcls]" +
-        " [-refreshServiceAcl]" +
-        " [-getGroup [username]]" +
-        " [-addToClusterNodeLabels <\"label1(exclusive=true),"
-            + "label2(exclusive=false),label3\">]" +
-        " [-removeFromClusterNodeLabels <label1,label2,label3>]" +
-        " [-replaceLabelsOnNode " +
-            "<\"node1[:port]=label1,label2 node2[:port]=label1\"> " +
-            "[-failOnUnknownNodes]]" +
-        " [-directlyAccessNodeLabelStore]" +
-        " [-refreshClusterMaxPriority]" +
-        " [-updateNodeResource [NodeID] [MemSize] [vCores]" +
-        " ([OvercommitTimeout])");
+    summary.append("The full syntax is: \n\n"
+        + "yarn rmadmin"
+        + " [-refreshQueues]"
+        + " [-refreshNodes [-g|graceful [timeout in seconds] -client|server]]"
+        + " [-refreshNodesResources]"
+        + " [-refreshSuperUserGroupsConfiguration]"
+        + " [-refreshUserToGroupsMappings]"
+        + " [-refreshAdminAcls]"
+        + " [-refreshServiceAcl]"
+        + " [-getGroup [username]]"
+        + " [-addToClusterNodeLabels <\"label1(exclusive=true),"
+        + "label2(exclusive=false),label3\">]"
+        + " [-removeFromClusterNodeLabels <label1,label2,label3>]"
+        + " [-replaceLabelsOnNode "
+        + "<\"node1[:port]=label1,label2 node2[:port]=label1\"> "
+        + "[-failOnUnknownNodes]]"
+        + " [-directlyAccessNodeLabelStore]"
+        + " [-refreshClusterMaxPriority]"
+        + " [-updateNodeResource [NodeID] [MemSize] [vCores]"
+        + " ([OvercommitTimeout]) or -updateNodeResource [NodeID] "
+        + "[ResourceTypes] ([OvercommitTimeout])]");
-  private int updateNodeResource(String nodeIdStr, int memSize,
-      int cores, int overCommitTimeout) throws IOException, YarnException {
-    // check resource value first
-    if (invalidResourceValue(memSize, cores)) {
-      throw new IllegalArgumentException("Invalid resource value: " + "(" +
-          memSize + "," + cores + ") for updateNodeResource.");
-    }
-    // Refresh the nodes
+  private int updateNodeResource(String nodeIdStr, Resource resource,
+      int overCommitTimeout) throws YarnException, IOException {
+
-    
-    Resource resource = Resources.createResource(memSize, cores);
+
+  /**
+   * Handle resources of two different formats:
+   *
+   * 1. -updateNodeResource [NodeID] [MemSize] [vCores] ([overCommitTimeout])
+   * 2. -updateNodeResource [NodeID] [ResourceTypes] ([overCommitTimeout])
+   *
+   * Incase of No. of args is 4 or 5, 2nd arg should contain only numbers to
+   * satisfy the 1st format. Otherwise, 2nd format flow continues.
+   * @param args arguments of the command
+   * @param cmd whole command to be parsed
+   * @param isHAEnabled Is HA enabled or not?
+   * @return 1 on success, -1 on errors
+   * @throws IOException if any issues thrown from RPC layer
+   * @throws YarnException if any issues thrown from server
+   */
-          throws NumberFormatException, IOException, YarnException {
+          throws YarnException, IOException {
-    if (args.length < 4 || args.length > 5) {
+    int overCommitTimeout = ResourceOption.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT;
+    String nodeID = args[i++];
+    Resource resource = Resource.newInstance(0, 0);
+    if (args.length < 3 || args.length > 5) {
-    } else {
-      String nodeID = args[i++];
-      String memSize = args[i++];
-      String cores = args[i++];
-      int overCommitTimeout = ResourceOption.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT;
-      if (i == args.length - 1) {
-        overCommitTimeout = Integer.parseInt(args[i]);
+    } else if ((args.length == 4 || args.length == 5) &&
+        RESOURCE_TYPES_ARGS_PATTERN.matcher(args[2]).matches()) {
+      int memSize = Integer.parseInt(args[i++]);
+      int cores = Integer.parseInt(args[i++]);
+
+      // check resource value first
+      if (invalidResourceValue(memSize, cores)) {
+        throw new IllegalArgumentException("Invalid resource value: " + "(" +
+            memSize + "," + cores + ") for updateNodeResource.");
-      return updateNodeResource(nodeID, Integer.parseInt(memSize),
-          Integer.parseInt(cores), overCommitTimeout);
+      resource = Resources.createResource(memSize, cores);
+    } else {
+      String resourceTypes = args[i++];
+      if (!resourceTypes.contains("=")) {
+        System.err.println("Resource Types parameter specified for "
+            + "updateNodeResource is wrong. It should be comma-delimited "
+            + "key value pairs. For example, memory-mb=1024Mi,"
+            + "vcores=1,resource1=3Gi,resource2=2");
+        printUsage(cmd, isHAEnabled);
+        return -1;
+      }
+      resource = parseCommandAndCreateResource(resourceTypes);
+      ResourceUtils.areMandatoryResourcesAvailable(resource);
+    if (i == args.length - 1) {
+      overCommitTimeout = Integer.parseInt(args[i]);
+    }
+    return updateNodeResource(nodeID, resource, overCommitTimeout);
+  }
+
+  private Resource parseCommandAndCreateResource(String resourceTypes) {
+    Resource resource = Resource.newInstance(0, 0);
+    Map<String, ResourceInformation> resourceTypesFromRM =
+        ResourceUtils.getResourceTypes();
+    String[] resourceTypesArr = resourceTypes.split(",");
+    for (int k = 0; k < resourceTypesArr.length; k++) {
+      String resourceType = resourceTypesArr[k];
+      String[] resourceTypeArray = resourceType.split("=");
+      if (resourceTypeArray.length == 2) {
+        String resName = StringUtils.trim(resourceTypeArray[0]);
+        String resValue = StringUtils.trim(resourceTypeArray[1]);
+        if (resourceTypesFromRM.containsKey(resName)) {
+          String[] resourceValue = ResourceUtils.parseResourceValue(resValue);
+          if (resourceValue.length == 2) {
+            ResourceInformation ri = ResourceInformation.newInstance(resName,
+                resourceValue[0], Long.parseLong(resourceValue[1]));
+            resource.setResourceInformation(resName, ri);
+          } else {
+            throw new IllegalArgumentException("Invalid resource value: " +
+                resValue + ". Unable to extract unit and actual value.");
+          }
+        } else {
+          throw new IllegalArgumentException("Invalid resource type: " +
+              resName + ". Not allowed.");
+        }
+      } else {
+        throw new IllegalArgumentException("Invalid resource type value: " +
+            "("+ resourceType + ") for updateNodeResource. "
+                + "It should be key value pairs separated using '=' symbol.");
+      }
+    }
+    return resource;

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS23 MOV43 MOV43 INS31 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS44 INS8 INS42 INS42 INS32 MOV43 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 MOV60 MOV60 INS60 INS25 MOV25 INS41 INS42 MOV43 INS42 INS60 INS60 INS60 INS24 INS41 INS42 INS42 INS45 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS43 INS59 MOV27 MOV8 INS25 INS32 INS43 INS59 INS74 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS32 INS27 INS8 INS8 INS42 INS42 INS42 MOV42 INS42 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS25 INS27 INS45 UPD45 INS42 UPD42 MOV42 INS34 INS34 UPD34 INS36 INS32 MOV60 INS60 MOV25 INS21 MOV60 INS25 INS21 INS21 INS42 INS42 INS34 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS34 INS43 INS59 INS5 INS59 INS27 INS8 INS8 INS45 INS45 INS45 INS27 INS32 UPD42 MOV42 INS39 INS39 INS59 INS7 INS38 INS8 INS7 INS32 INS42 INS42 INS2 INS43 INS85 INS42 INS32 INS40 INS34 INS60 INS60 INS25 INS53 INS27 INS27 INS42 UPD42 MOV42 INS2 INS32 INS42 INS32 INS42 MOV32 UPD42 INS32 INS21 INS21 INS41 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS43 INS59 INS43 INS59 INS32 INS8 INS8 INS14 INS40 INS34 INS40 INS34 INS42 INS34 INS42 INS42 MOV2 MOV42 MOV42 INS2 INS42 INS42 INS45 INS32 INS32 INS38 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS60 INS25 INS53 INS43 INS27 INS42 INS37 INS40 INS42 INS27 INS42 INS42 INS42 INS34 INS42 INS42 INS2 INS42 INS42 INS2 INS5 INS59 INS27 INS8 INS8 INS14 INS42 INS27 INS42 INS45 INS45 INS42 INS45 INS45 INS45 INS45 INS42 INS34 INS42 INS34 INS43 INS85 INS42 INS32 INS40 INS34 INS60 INS21 INS53 INS43 INS27 INS45 INS45 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS45 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS2 INS32 INS42 INS45 INS42 INS45 INS42 INS34 INS42 INS42 INS2 INS42 INS34 DEL45 DEL39 DEL42 DEL44 DEL39 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL41 DEL8 DEL25
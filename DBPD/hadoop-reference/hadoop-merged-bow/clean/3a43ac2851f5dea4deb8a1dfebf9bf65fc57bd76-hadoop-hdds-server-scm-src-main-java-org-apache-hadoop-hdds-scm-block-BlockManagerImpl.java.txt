HDDS-1. Remove SCM Block DB. Contributed by Xiaoyu Yao.

-import com.google.common.annotations.VisibleForTesting;
-import org.apache.hadoop.hdds.scm.container.common.helpers.Pipeline;
-import org.apache.hadoop.hdfs.DFSUtil;
+import org.apache.hadoop.hdds.client.BlockID;
-import org.apache.hadoop.utils.BatchOperation;
-import org.apache.hadoop.utils.MetadataStore;
-import org.apache.hadoop.utils.MetadataStoreBuilder;
+import org.apache.hadoop.util.Time;
-import java.io.File;
-    .FAILED_TO_FIND_BLOCK;
-import static org.apache.hadoop.hdds.scm.exceptions.SCMException.ResultCodes
-import static org.apache.hadoop.hdds.server.ServerUtils.getOzoneMetaDirPath;
-import static org.apache.hadoop.ozone.OzoneConsts.BLOCK_DB;
-  private final MetadataStore blockStore;
-  private final long cacheSize;
-   * @param cacheSizeMB - cache size for level db store.
-      final NodeManager nodeManager, final Mapping containerManager,
-      final int cacheSizeMB) throws IOException {
+      final NodeManager nodeManager, final Mapping containerManager)
+      throws IOException {
-    this.cacheSize = cacheSizeMB;
-    File metaDir = getOzoneMetaDirPath(conf);
-    String scmMetaDataDir = metaDir.getPath();
-
-    // Write the block key to container name mapping.
-    File blockContainerDbPath = new File(scmMetaDataDir, BLOCK_DB);
-    blockStore =
-        MetadataStoreBuilder.newBuilder()
-            .setConf(conf)
-            .setDbFile(blockContainerDbPath)
-            .setCacheSize(this.cacheSize * OzoneConsts.MB)
-            .build();
-        String containerName = UUID.randomUUID().toString();
-              containerName, owner);
+              owner);
-        containerManager.updateContainerState(containerInfo.getContainerName(),
+        containerManager.updateContainerState(containerInfo.getContainerID(),
-        containerManager.updateContainerState(containerInfo.getContainerName(),
+        containerManager.updateContainerState(containerInfo.getContainerID(),
-    // TODO : Replace this with Block ID.
-    String blockKey = UUID.randomUUID().toString();
-    boolean createContainer = (state == HddsProtos.LifeCycleState.ALLOCATED);
-
-    AllocatedBlock.Builder abb =
-        new AllocatedBlock.Builder()
-            .setKey(blockKey)
-            // TODO : Use containerinfo instead of pipeline.
-            .setPipeline(containerInfo.getPipeline())
-            .setShouldCreateContainer(createContainer);
-    LOG.trace("New block allocated : {} Container ID: {}", blockKey,
-        containerInfo.toString());
-
-    // Persist this block info to the blockStore DB, so getBlock(key) can
-    // find which container the block lives.
-    // TODO : Remove this DB in future
-    // and make this a KSM operation. Category: SCALABILITY.
-    if (containerInfo.getPipeline().getMachines().size() > 0) {
-      blockStore.put(
-          DFSUtil.string2Bytes(blockKey),
-          DFSUtil.string2Bytes(containerInfo.getPipeline().getContainerName()));
-    }
+    // TODO : Revisit this local ID allocation when HA is added.
+    // TODO: this does not work well if multiple allocation kicks in a tight
+    // loop.
+    long localID = Time.getUtcTime();
+    long containerID = containerInfo.getContainerID();
+
+    boolean createContainer = (state == HddsProtos.LifeCycleState.ALLOCATED);
+
+    AllocatedBlock.Builder abb =
+        new AllocatedBlock.Builder()
+            .setBlockID(new BlockID(containerID, localID))
+            .setPipeline(containerInfo.getPipeline())
+            .setShouldCreateContainer(createContainer);
+    LOG.trace("New block allocated : {} Container ID: {}", localID,
+        containerID);
-   * Given a block key, return the Pipeline information.
-   *
-   * @param key - block key assigned by SCM.
-   * @return Pipeline (list of DNs and leader) to access the block.
-   * @throws IOException
-   */
-  @Override
-  public Pipeline getBlock(final String key) throws IOException {
-    lock.lock();
-    try {
-      byte[] containerBytes = blockStore.get(DFSUtil.string2Bytes(key));
-      if (containerBytes == null) {
-        throw new SCMException(
-            "Specified block key does not exist. key : " + key,
-            FAILED_TO_FIND_BLOCK);
-      }
-
-      String containerName = DFSUtil.bytes2String(containerBytes);
-      ContainerInfo containerInfo = containerManager.getContainer(
-          containerName);
-      if (containerInfo == null) {
-        LOG.debug("Container {} allocated by block service"
-            + "can't be found in SCM", containerName);
-        throw new SCMException(
-            "Unable to find container for the block",
-            SCMException.ResultCodes.FAILED_TO_FIND_CONTAINER);
-      }
-      return containerInfo.getPipeline();
-    } finally {
-      lock.unlock();
-    }
-  }
-
-  /**
-  public void deleteBlocks(List<String> blockIDs) throws IOException {
+  public void deleteBlocks(List<BlockID> blockIDs) throws IOException {
-    LOG.info("Deleting blocks {}", String.join(",", blockIDs));
-    Map<String, List<String>> containerBlocks = new HashMap<>();
-    BatchOperation batch = new BatchOperation();
-    BatchOperation rollbackBatch = new BatchOperation();
+    LOG.info("Deleting blocks {}", StringUtils.join(",", blockIDs));
+    Map<Long, List<Long>> containerBlocks = new HashMap<>();
-      for (String blockKey : blockIDs) {
-        byte[] blockKeyBytes = DFSUtil.string2Bytes(blockKey);
-        byte[] containerBytes = blockStore.get(blockKeyBytes);
-        if (containerBytes == null) {
-          throw new SCMException(
-              "Specified block key does not exist. key : " + blockKey,
-              FAILED_TO_FIND_BLOCK);
-        }
-        batch.delete(blockKeyBytes);
-        rollbackBatch.put(blockKeyBytes, containerBytes);
-
+      for (BlockID block : blockIDs) {
-        String containerName = DFSUtil.bytes2String(containerBytes);
-        if (containerBlocks.containsKey(containerName)) {
-          containerBlocks.get(containerName).add(blockKey);
+        long containerID = block.getContainerID();
+        if (containerBlocks.containsKey(containerID)) {
+          containerBlocks.get(containerID).add(block.getLocalID());
-          List<String> item = new ArrayList<>();
-          item.add(blockKey);
-          containerBlocks.put(containerName, item);
+          List<Long> item = new ArrayList<>();
+          item.add(block.getLocalID());
+          containerBlocks.put(containerID, item);
-      blockStore.writeBatch(batch);
-        try {
-          // If delLog update is failed, we need to rollback the changes.
-          blockStore.writeBatch(rollbackBatch);
-        } catch (IOException rollbackException) {
-          // This is a corner case. AddTX fails and rollback also fails,
-          // this will leave these blocks in inconsistent state. They were
-          // moved to pending deletion state in SCM DB but were not written
-          // into delLog so real deletions would not be done. Blocks become
-          // to be invisible from namespace but actual data are not removed.
-          // We log an error here so admin can manually check and fix such
-          // errors.
-          LOG.error(
-              "Blocks might be in inconsistent state because"
-                  + " they were moved to pending deletion state in SCM DB but"
-                  + " not written into delLog. Admin can manually add them"
-                  + " into delLog for deletions. Inconsistent block list: {}",
-              String.join(",", blockIDs),
-              e);
-          throw rollbackException;
-        }
-                + String.join(",", blockIDs),
+                + StringUtils.join(",", blockIDs),
-  @VisibleForTesting
-  public String getDeletedKeyName(String key) {
-    return StringUtils.format(".Deleted/%s", key);
-  }
-
-    if (blockStore != null) {
-      blockStore.close();
-    }

MOV26 UPD40 UPD40 MOV25 INS60 MOV21 UPD74 MOV74 MOV25 MOV25 INS39 INS39 INS59 UPD43 UPD74 UPD42 INS32 INS42 INS32 UPD42 UPD42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 UPD43 UPD74 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 INS14 UPD42 INS39 INS43 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD74 MOV74 MOV43 INS32 UPD43 INS32 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 UPD42 MOV42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL83 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL52 DEL42 DEL22 DEL40 DEL27 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL32 DEL42 DEL32 DEL42 DEL32 DEL34 DEL27 DEL8 DEL25 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL21 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL32 DEL21 DEL42 DEL43 DEL45 DEL40 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL45 DEL45 DEL45 DEL45 DEL27 DEL42 DEL42 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25
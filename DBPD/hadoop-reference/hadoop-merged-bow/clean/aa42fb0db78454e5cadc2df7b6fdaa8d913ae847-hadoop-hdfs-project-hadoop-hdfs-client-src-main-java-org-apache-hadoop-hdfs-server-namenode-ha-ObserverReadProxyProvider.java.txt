HDFS-13779. [SBN read] Implement proper failover and observer failure handling logic for for ObserverReadProxyProvider. Contributed by Erik Krogen.

+import java.lang.reflect.InvocationTargetException;
-import java.util.ArrayList;
+import org.apache.hadoop.ha.HAServiceProtocol.HAServiceState;
+import org.apache.hadoop.io.retry.AtMostOnce;
+import org.apache.hadoop.io.retry.Idempotent;
+import org.apache.hadoop.io.retry.RetryPolicies;
+import org.apache.hadoop.io.retry.RetryPolicy;
+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;
-  /** Client-side context for syncing with the NameNode server side */
-  private AlignmentContext alignmentContext;
+  /** Client-side context for syncing with the NameNode server side. */
+  private final AlignmentContext alignmentContext;
-  private AbstractNNFailoverProxyProvider<T> failoverProxy;
-  /** All NameNdoe proxies */
-  private List<NNProxyInfo<T>> nameNodeProxies =
-      new ArrayList<NNProxyInfo<T>>();
-  /** Proxies for the observer namenodes */
-  private final List<NNProxyInfo<T>> observerProxies =
-      new ArrayList<NNProxyInfo<T>>();
+  /** The inner proxy provider used for active/standby failover. */
+  private final AbstractNNFailoverProxyProvider<T> failoverProxy;
+  /** List of all NameNode proxies. */
+  private final List<NNProxyInfo<T>> nameNodeProxies;
+
+  /** The policy used to determine if an exception is fatal or retriable. */
+  private final RetryPolicy observerRetryPolicy;
+  /** The combined proxy which redirects to other proxies as necessary. */
+  private final ProxyInfo<T> combinedProxy;
-   * Thread-local index to record the current index in the observer list.
+   * The index into the nameNodeProxies list currently being used. Should only
+   * be accessed in synchronized methods.
-  private static final ThreadLocal<Integer> currentIndex =
-      ThreadLocal.withInitial(() -> 0);
+  private int currentIndex = -1;
+  /**
+   * The proxy being used currently; this will match with currentIndex above.
+   * This field is volatile to allow reads without synchronization; updates
+   * should still be performed synchronously to maintain consistency between
+   * currentIndex and this field.
+   */
+  private volatile NNProxyInfo<T> currentProxy;
-  /** The last proxy that has been used. Only used for testing */
+  /** The last proxy that has been used. Only used for testing. */
-      Configuration conf, URI uri, Class<T> xface, HAProxyFactory<T> factory)
-      throws IOException {
+      Configuration conf, URI uri, Class<T> xface, HAProxyFactory<T> factory) {
-        new ConfiguredFailoverProxyProvider<T>(conf, uri, xface,factory));
+        new ConfiguredFailoverProxyProvider<>(conf, uri, xface,factory));
+  @SuppressWarnings("unchecked")
-      AbstractNNFailoverProxyProvider<T> failoverProxy)
-      throws IOException {
+      AbstractNNFailoverProxyProvider<T> failoverProxy) {
+    // Don't bother configuring the number of retries and such on the retry
+    // policy since it is mainly only used for determining whether or not an
+    // exception is retriable or fatal
+    observerRetryPolicy = RetryPolicies.failoverOnNetworkException(
+        RetryPolicies.TRY_ONCE_THEN_FAIL, 1);
+
-    // Find out all the observer proxies
-    for (NNProxyInfo<T> pi : nameNodeProxies) {
-      createProxyIfNeeded(pi);
-      if (isObserverState(pi)) {
-        observerProxies.add(pi);
-      }
-    }
-    // TODO: No observers is not an error
-    // Just direct all reads go to the active NameNode
-    if (observerProxies.isEmpty()) {
-      throw new RuntimeException("Couldn't find any namenode proxy in " +
-          "OBSERVER state");
-    }
-  }
-
-  public synchronized AlignmentContext getAlignmentContext() {
-    return alignmentContext;
-  }
-
-  @SuppressWarnings("unchecked")
-  @Override
-  public synchronized ProxyInfo<T> getProxy() {
-    // We just create a wrapped proxy containing all the proxies
+    // Create a wrapped proxy containing all the proxies. Since this combined
+    // proxy is just redirecting to other proxies, all invocations can share it.
-
-    for (int i = 0; i < this.observerProxies.size(); i++) {
+    for (int i = 0; i < nameNodeProxies.size(); i++) {
-      combinedInfo.append(observerProxies.get(i).proxyInfo);
+      combinedInfo.append(nameNodeProxies.get(i).proxyInfo);
-
-        new Class<?>[]{xface},
-        new ObserverReadInvocationHandler(observerProxies));
-    return new ProxyInfo<>(wrappedProxy, combinedInfo.toString());
+        new Class<?>[] { xface }, new ObserverReadInvocationHandler());
+    combinedProxy = new ProxyInfo<>(wrappedProxy, combinedInfo.toString());
+  }
+
+  public AlignmentContext getAlignmentContext() {
+    return alignmentContext;
+  }
+
+  @Override
+  public ProxyInfo<T> getProxy() {
+    return combinedProxy;
-  private boolean isRead(Method method) {
-    return method.isAnnotationPresent(ReadOnly.class);
+  private static boolean isRead(Method method) {
+    if (!method.isAnnotationPresent(ReadOnly.class)) {
+      return false;
+    }
+    return !method.getAnnotationsByType(ReadOnly.class)[0].activeOnly();
-  /**
-   * After getting exception 'ex', whether we should retry the current request
-   * on a different observer.
-   */
-  private boolean shouldRetry(Exception ex) throws Exception {
-    // TODO: implement retry policy
-    return true;
-  }
-
-  boolean isObserverState(NNProxyInfo<T> pi) {
+  private static <T extends ClientProtocol> HAServiceState getServiceState(
+      NNProxyInfo<T> pi) {
-      return false; // Only active NameNode allows write
+      return HAServiceState.ACTIVE; // Only active NameNode allows write
-      LOG.error("Failed to connect to {}", pi.getAddress(), ioe);
-      return false;
+      LOG.warn("Failed to connect to {}", pi.getAddress(), ioe);
+      return HAServiceState.STANDBY; // Just assume standby in this case
+                                     // Anything besides observer is fine
-      return true;
+      return HAServiceState.OBSERVER;
-      LOG.error("Failed to connect to {}", pi.getAddress(), ioe);
+      LOG.warn("Failed to connect to {}", pi.getAddress(), ioe);
-    return false;
+    return HAServiceState.STANDBY;
-
-  class ObserverReadInvocationHandler implements InvocationHandler {
-    final List<NNProxyInfo<T>> observerProxies;
-    final ProxyInfo<T> activeProxy;
-
-    ObserverReadInvocationHandler(List<NNProxyInfo<T>> observerProxies) {
-      this.observerProxies = observerProxies;
-      this.activeProxy = failoverProxy.getProxy();
+  /**
+   * Return the currently used proxy. If there is none, first calls
+   * {@link #changeProxy(NNProxyInfo)} to initialize one.
+   */
+  private NNProxyInfo<T> getCurrentProxy() {
+    if (currentProxy == null) {
+      changeProxy(null);
+    return currentProxy;
+  }
-    /**
-     * Sends read operations to the observer (if enabled) specified by the
-     * current index, and send write operations to the active. If a observer
-     * fails, we increment the index and retry the next one. If all observers
-     * fail, the request is forwarded to the active.
-     *
-     * Write requests are always forwarded to the active.
-     */
+  /**
+   * Move to the next proxy in the proxy list. If the NNProxyInfo supplied by
+   * the caller does not match the current proxy, the call is ignored; this is
+   * to handle concurrent calls (to avoid changing the proxy multiple times).
+   * The service state of the newly selected proxy will be updated before
+   * returning.
+   *
+   * @param initial The expected current proxy
+   */
+  private synchronized void changeProxy(NNProxyInfo<T> initial) {
+    if (currentProxy != initial) {
+      // Must have been a concurrent modification; ignore the move request
+      return;
+    }
+    // Attempt to force concurrent callers of getCurrentProxy to wait for the
+    // new proxy; best-effort by setting currentProxy to null
+    currentProxy = null;
+    currentIndex = (currentIndex + 1) % nameNodeProxies.size();
+    currentProxy = createProxyIfNeeded(nameNodeProxies.get(currentIndex));
+    currentProxy.setCachedState(getServiceState(currentProxy));
+    LOG.debug("Changed current proxy from {} to {}",
+        initial == null ? "none" : initial.proxyInfo,
+        currentProxy.proxyInfo);
+  }
+
+  /**
+   * An InvocationHandler to handle incoming requests. This class's invoke
+   * method contains the primary logic for redirecting to observers.
+   * 
+   * If observer reads are enabled, attempt to send read operations to the
+   * current proxy. If it is not an observer, or the observer fails, adjust
+   * the current proxy and retry on the next one. If all proxies are tried
+   * without success, the request is forwarded to the active.
+   *
+   * Write requests are always forwarded to the active.
+   */
+  private class ObserverReadInvocationHandler implements InvocationHandler {
+
-        // Loop through all the proxies, starting from the current index.
-        for (int i = 0; i < observerProxies.size(); i++) {
-          NNProxyInfo<T> current = observerProxies.get(currentIndex.get());
+        int failedObserverCount = 0;
+        int activeCount = 0;
+        int standbyCount = 0;
+        for (int i = 0; i < nameNodeProxies.size(); i++) {
+          NNProxyInfo<T> current = getCurrentProxy();
+          HAServiceState currState = current.getCachedState();
+          if (currState != HAServiceState.OBSERVER) {
+            if (currState == HAServiceState.ACTIVE) {
+              activeCount++;
+            } else if (currState == HAServiceState.STANDBY) {
+              standbyCount++;
+            }
+            LOG.debug("Skipping proxy {} for {} because it is in state {}",
+                current.proxyInfo, method.getName(), currState);
+            changeProxy(current);
+            continue;
+          }
+          LOG.debug("Attempting to service {} using proxy {}",
+              method.getName(), current.proxyInfo);
+            LOG.debug("Invocation of {} using {} was successful",
+                method.getName(), current.proxyInfo);
-          } catch (Exception e) {
-            if (!shouldRetry(e)) {
-              throw e;
+          } catch (InvocationTargetException ite) {
+            if (!(ite.getCause() instanceof Exception)) {
+              throw ite.getCause();
-            currentIndex.set((currentIndex.get() + 1) % observerProxies.size());
-            LOG.warn("Invocation returned exception on [{}]",
-                current.proxyInfo, e.getCause());
+            Exception e = (Exception) ite.getCause();
+            RetryAction retryInfo = observerRetryPolicy.shouldRetry(e, 0, 0,
+                method.isAnnotationPresent(Idempotent.class)
+                    || method.isAnnotationPresent(AtMostOnce.class));
+            if (retryInfo.action == RetryAction.RetryDecision.FAIL) {
+              throw e;
+            } else {
+              failedObserverCount++;
+              LOG.warn(
+                  "Invocation returned exception on [{}]; {} failure(s) so far",
+                  current.proxyInfo, failedObserverCount, e);
+              changeProxy(current);
+            }
-        LOG.warn("All observers have failed for read request {}. " +
-            "Fall back on active: {}", method.getName(), activeProxy);
+        LOG.warn("{} observers have failed for read request {}; also found " +
+            "{} standby and {} active. Falling back to active.",
+            failedObserverCount, standbyCount, activeCount, method.getName());
+      LOG.debug("Using failoverProxy to service {}", method.getName());
+      ProxyInfo<T> activeProxy = failoverProxy.getProxy();
-      } catch (Exception e) {
+      } catch (InvocationTargetException e) {
+        // This exception will be handled by higher layers
-    failoverProxy.close();
+        // Set to null to avoid the failoverProxy having to re-do the close
+        // if it is sharing a proxy instance
+        pi.proxy = null;
+    failoverProxy.close();

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS55 INS83 INS29 INS83 INS83 MOV74 INS43 MOV29 MOV83 MOV83 MOV74 INS59 INS29 INS83 INS39 MOV59 INS29 INS83 INS83 MOV74 INS59 MOV79 INS8 MOV78 MOV83 MOV74 MOV42 INS8 INS83 INS8 INS83 INS83 INS73 INS43 INS42 INS29 INS83 MOV74 INS42 INS8 MOV29 MOV83 INS83 UPD39 MOV39 UPD42 MOV42 INS44 INS8 INS29 INS83 INS42 MOV43 INS31 MOV21 INS65 INS42 UPD42 INS42 INS65 INS38 INS65 INS42 MOV46 MOV21 MOV21 MOV21 INS21 MOV21 MOV60 INS24 MOV21 INS60 INS21 INS41 INS25 INS41 INS42 INS43 INS42 INS65 MOV25 MOV41 INS65 INS74 INS42 INS25 INS21 INS21 MOV21 MOV21 INS21 MOV65 MOV78 MOV83 MOV43 MOV42 MOV44 MOV44 MOV44 MOV43 MOV8 UPD66 INS66 UPD66 UPD66 UPD66 INS66 INS66 INS34 INS66 INS66 INS66 INS66 UPD66 INS7 MOV58 INS27 MOV37 INS8 MOV43 INS59 INS7 INS42 INS38 INS8 INS38 INS42 INS40 INS66 INS65 INS66 UPD27 INS42 INS66 UPD66 UPD66 INS66 INS66 INS42 INS66 MOV43 MOV43 INS27 INS8 INS7 INS7 INS32 INS32 INS66 INS66 UPD66 UPD66 UPD66 UPD66 INS21 INS60 UPD74 INS42 INS32 INS42 INS32 INS25 INS21 INS42 INS11 INS42 MOV14 MOV32 MOV41 INS32 INS68 UPD42 INS33 INS42 INS42 INS41 INS42 INS33 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS16 INS40 INS32 INS74 INS59 INS42 INS42 INS40 INS34 INS42 INS42 INS27 INS8 INS32 MOV43 INS32 MOV9 INS2 INS42 INS40 INS40 INS40 INS42 INS69 INS36 INS32 INS42 INS32 INS42 INS42 INS27 INS45 INS40 INS60 INS60 INS60 INS42 INS42 INS45 INS32 INS43 INS43 INS42 MOV32 UPD42 MOV42 INS42 MOV34 MOV21 UPD42 MOV42 UPD42 MOV42 INS22 INS42 INS42 MOV32 MOV3 INS14 INS32 INS34 UPD42 UPD42 INS43 UPD42 INS33 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS39 INS59 INS39 INS59 INS39 INS59 INS42 INS42 INS42 INS42 INS43 INS21 INS32 INS42 UPD42 MOV42 UPD43 MOV43 INS42 INS42 INS57 UPD42 MOV42 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS60 INS60 INS25 INS21 INS42 INS42 UPD42 INS32 INS42 INS7 UPD42 UPD42 MOV45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS43 UPD42 MOV74 INS59 INS43 INS59 INS27 INS8 INS32 UPD45 UPD45 INS42 INS42 INS40 INS33 INS42 MOV42 INS32 INS42 INS42 INS32 INS42 INS40 INS25 INS21 INS21 INS18 INS42 INS42 INS45 MOV32 INS40 INS21 INS42 INS42 INS42 INS27 INS8 INS25 INS32 INS32 INS32 INS43 UPD42 INS60 INS60 INS25 INS42 INS40 INS21 INS27 INS8 UPD42 MOV42 UPD42 MOV42 INS45 INS40 MOV32 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS40 INS42 INS8 MOV43 INS59 INS43 INS59 INS27 MOV8 INS8 INS37 INS42 INS40 INS21 UPD42 UPD42 INS42 INS42 INS36 INS53 INS42 INS11 INS42 INS42 INS32 INS40 INS40 INS21 MOV21 INS21 INS42 INS37 INS62 INS32 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS34 INS34 UPD27 MOV27 INS37 INS32 INS42 INS32 MOV43 INS42 INS42 INS42 INS42 MOV32 INS42 UPD45 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS57 UPD42 INS42 INS57 INS43 INS43 INS42 INS42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL74 DEL14 DEL42 DEL42 DEL34 DEL86 DEL32 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL23 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL43 DEL43 DEL74 DEL42 DEL44 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL32 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL83 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL22 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL11 DEL59 DEL60 DEL8 DEL31 DEL8 DEL42 DEL44 DEL42 DEL43 DEL9 DEL41 DEL8 DEL31 DEL39 DEL42 DEL9 DEL9 DEL9 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL7 DEL32 DEL59 DEL60 DEL32 DEL42 DEL34 DEL27 DEL36 DEL42 DEL32 DEL32 DEL21 DEL42 DEL83 DEL42 DEL43 DEL74 DEL74 DEL42 DEL59 DEL23 DEL83 DEL42 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL8 DEL31 DEL29 DEL31 DEL55
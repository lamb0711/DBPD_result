Merge trunk into auto-failover branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1308260 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.annotations.VisibleForTesting;
-
-  private InetSocketAddress selfAddr;
+  private InetSocketAddress streamingAddr;
-  private volatile String hostName; // Host name of this datanode
+  private String hostName;
+  private DatanodeID id;
+      LOG.info("Configured hostname is " + hostName);
+  /**
+   * Returns the hostname for this datanode. If the hostname is not
+   * explicitly configured in the given config, then it is determined
+   * via the DNS class.
+   *
+   * @param config
+   * @return the hostname (NB: may not be a FQDN)
+   * @throws UnknownHostException if the dfs.datanode.dns.interface
+   *    option is used and the hostname can not be determined
+   */
-    // use configured nameserver & interface to get local hostname
-      name = DNS
-          .getDefaultHost(config.get(DFS_DATANODE_DNS_INTERFACE_KEY,
-              DFS_DATANODE_DNS_INTERFACE_DEFAULT), config.get(
-              DFS_DATANODE_DNS_NAMESERVER_KEY,
-              DFS_DATANODE_DNS_NAMESERVER_DEFAULT));
+      name = DNS.getDefaultHost(
+          config.get(DFS_DATANODE_DNS_INTERFACE_KEY,
+                     DFS_DATANODE_DNS_INTERFACE_DEFAULT),
+          config.get(DFS_DATANODE_DNS_NAMESERVER_KEY,
+                     DFS_DATANODE_DNS_NAMESERVER_DEFAULT));
-    InetSocketAddress streamingAddr = DataNode.getStreamingAddr(conf);
-
-    if(secureResources == null) {
+    if (secureResources == null) {
+      InetSocketAddress addr = DataNode.getStreamingAddr(conf);
-          Server.bind(ss, streamingAddr, 0);
+          Server.bind(ss, addr, 0);
-    // adjust machine name with the actual port
-    int tmpPort = ss.getLocalPort();
-    selfAddr = new InetSocketAddress(ss.getInetAddress().getHostAddress(),
-                                     tmpPort);
-    LOG.info("Opened streaming server at " + selfAddr);
+
+    streamingAddr = new InetSocketAddress(ss.getInetAddress().getHostAddress(),
+                                     ss.getLocalPort());
+
+    LOG.info("Opened streaming server at " + streamingAddr);
-    metrics = DataNodeMetrics.create(conf, getMachineName());
+    metrics = DataNodeMetrics.create(conf, getDisplayName());
-    DatanodeRegistration bpRegistration = createUnknownBPRegistration();
-    String blockPoolId = nsInfo.getBlockPoolID();
-    
+    final String xferIp = streamingAddr.getAddress().getHostAddress();
+    DatanodeRegistration bpRegistration = new DatanodeRegistration(xferIp);
+    bpRegistration.setXferPort(getXferPort());
+    bpRegistration.setInfoPort(getInfoPort());
+    bpRegistration.setIpcPort(getIpcPort());
+    bpRegistration.setHostName(hostName);
-    StorageInfo storageInfo = storage.getBPStorage(blockPoolId);
+
+    StorageInfo storageInfo = storage.getBPStorage(nsInfo.getBlockPoolID());
-      bpRegistration.storageInfo.layoutVersion = HdfsConstants.LAYOUT_VERSION;
+      bpRegistration.getStorageInfo().layoutVersion = HdfsConstants.LAYOUT_VERSION;
-      String blockPoolId)
-      throws IOException {
-    hostName = bpRegistration.getHost();
+      String blockPoolId) throws IOException {
+    // Set the ID if we haven't already
+    if (null == id) {
+      id = bpRegistration;
+    }
-      // This is a fresh datanode -- take the storage ID provided by the
-      // NN and persist it.
+      // This is a fresh datanode, persist the NN-provided storage ID
-          + " is assigned to data-node " + bpRegistration.getName());
+          + " is assigned to data-node " + bpRegistration);
-    ExportedBlockKeys keys = bpRegistration.exportedKeys;
+    ExportedBlockKeys keys = bpRegistration.getExportedKeys();
-        bpRegistration.exportedKeys);
-    bpRegistration.exportedKeys = ExportedBlockKeys.DUMMY_KEYS;
+        bpRegistration.getExportedKeys());
+    bpRegistration.setExportedKeys(ExportedBlockKeys.DUMMY_KEYS);
-  /**
-   * Create a DatanodeRegistration object with no valid StorageInfo.
-   * This is used when reporting an error during handshake - ie
-   * before we can load any specific block pool.
-   */
-  private DatanodeRegistration createUnknownBPRegistration() {
-    DatanodeRegistration reg = new DatanodeRegistration(getMachineName());
-    reg.setInfoPort(infoServer.getPort());
-    reg.setIpcPort(getIpcPort());
-    return reg;
-  }
-
-  int getPort() {
-    return selfAddr.getPort();
+  int getXferPort() {
+    return streamingAddr.getPort();
-  
-  /** 
-   * Get host:port with host set to Datanode host and port set to the
-   * port {@link DataXceiver} is serving.
-   * @return host:port string
+
+  /**
+   * @return name useful for logging
-  public String getMachineName() {
-    return hostName + ":" + getPort();
+  public String getDisplayName() {
+    // NB: our DatanodeID may not be set yet
+    return hostName + ":" + getIpcPort();
-  
+
+  /**
+   * NB: The datanode can perform data transfer on the streaming
+   * address however clients are given the IPC IP address for data
+   * transfer, and that may be be a different address.
+   * 
+   * @return socket address for data transfer
+   */
+  public InetSocketAddress getXferAddress() {
+    return streamingAddr;
+  }
+
+  /**
+   * @return the datanode's IPC port
+   */
+  @VisibleForTesting
-   * get BP registration by machine and port name (host:port)
-   * @param mName - the name that the NN used
-   * @return BP registration 
-   * @throws IOException 
-   */
-  DatanodeRegistration getDNRegistrationByMachineName(String mName) {
-    // TODO: all the BPs should have the same name as each other, they all come
-    // from getName() here! and the use cases only are in tests where they just
-    // call with getName(). So we could probably just make this method return
-    // the first BPOS's registration. See HDFS-2609.
-    BPOfferService [] bposArray = blockPoolManager.getAllNamenodeThreads();
-    for (BPOfferService bpos : bposArray) {
-      if(bpos.bpRegistration.getName().equals(mName))
-        return bpos.bpRegistration;
-    }
-    return null;
-  }
-  
-  /**
-    final InetSocketAddress addr = NetUtils.createSocketAddr(
-        datanodeid.getHost() + ":" + datanodeid.getIpcPort());
+    final InetSocketAddress addr =
+      NetUtils.createSocketAddr(datanodeid.getIpcAddr());
-  
-  public InetSocketAddress getSelfAddr() {
-    return selfAddr;
-  }
-    dnId.storageID = createNewStorageId(dnId.getPort());
+    dnId.setStorageID(createNewStorageId(dnId.getXferPort()));
-          xfersBuilder.append(xferTargets[i].getName());
+          xfersBuilder.append(xferTargets[i]);
-          NetUtils.createSocketAddr(targets[0].getName());
+          NetUtils.createSocketAddr(targets[0].getXferAddr());
-        LOG.warn(
-            bpReg + ":Failed to transfer " + b + " to " + targets[0].getName()
-                + " got ", ie);
+        LOG.warn(bpReg + ":Failed to transfer " + b + " to " +
+            targets[0] + " got ", ie);
-    return "DataNode{data=" + data + ", localName='" + getMachineName()
+    return "DataNode{data=" + data + ", localName='" + getDisplayName()
-    StringBuilder msg = new StringBuilder(targets[0].getName());
+    StringBuilder msg = new StringBuilder(targets[0].toString());
-      msg.append(", " + targets[i].getName());
+      msg.append(", " + targets[i]);
-  // ClientDataNodeProtocol implementation
-  // Determine a Datanode's streaming address
-  public static InetSocketAddress getStreamingAddr(Configuration conf) {
+  static InetSocketAddress getStreamingAddr(Configuration conf) {
-  public int getInfoPort(){
-    return this.infoServer.getPort();
+  /**
+   * @return the datanode's http port
+   */
+  public int getInfoPort() {
+    return infoServer.getPort();
-  @Override //ClientDatanodeProtocol
+  @Override // ClientDatanodeProtocol
-  /** Methods used by fault injection tests */
+  @VisibleForTesting
-    return new DatanodeID(getMachineName(), getStorageId(),
-        infoServer.getPort(), getIpcPort());
+    return id;

INS26 INS40 INS23 INS31 INS83 MOV43 INS59 INS29 MOV60 UPD42 UPD42 MOV29 MOV83 MOV43 UPD42 MOV42 MOV8 INS29 INS78 INS29 INS78 UPD42 UPD42 MOV42 INS65 INS65 INS65 INS65 INS60 INS21 INS21 INS21 INS21 INS25 INS65 UPD65 INS65 INS42 INS65 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS83 MOV43 MOV43 INS59 INS32 INS32 INS32 INS32 MOV43 INS27 INS8 INS32 UPD66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 UPD42 INS66 INS32 MOV43 INS66 MOV32 INS42 INS21 MOV60 UPD42 UPD42 INS32 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS32 INS33 INS42 MOV21 INS32 INS32 INS42 INS42 INS40 UPD42 MOV32 INS42 INS42 INS32 INS32 MOV32 UPD42 INS32 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS32 MOV42 MOV32 UPD42 MOV43 MOV32 INS42 INS42 INS27 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 INS22 UPD42 INS42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS27 INS45 INS42 INS32 INS42 INS42 INS45 MOV2 INS42 INS42 MOV32 MOV2 UPD42 MOV2 UPD42 INS42 DEL83 DEL39 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL7 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL42 DEL65 DEL66 DEL65 DEL42 DEL32 DEL65 DEL42 DEL65 DEL65 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL40 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL41 DEL25 DEL8 DEL70 DEL33 DEL41 DEL8 DEL31 DEL42 DEL42 DEL32 DEL45 DEL32 DEL27 DEL31 DEL40 DEL32 DEL7 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL45 DEL27 DEL32 DEL83 DEL52 DEL42 DEL22 DEL42 DEL32 DEL66 DEL65 DEL29 DEL42 DEL32 DEL42 DEL32 DEL14
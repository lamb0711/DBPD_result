HDFS-10268. Ozone: end-to-end integration for create/get volumes, buckets and keys. Contributed by Chris Nauroth.

-import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos.ContainerCommandRequestProto;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos.ContainerCommandResponseProto;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos.ContainerData;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos.CreateContainerRequestProto;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos.Result;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos.Type;
+import org.apache.hadoop.ozone.OzoneConfiguration;
+import org.apache.hadoop.ozone.container.common.helpers.Pipeline;
+import org.apache.hadoop.ozone.container.common.transport.client.XceiverClient;
+import org.apache.hadoop.ozone.container.common.transport.client.XceiverClientManager;
- * using the existing heartbeat messages.  StorageContainerManager tells clients
- * container locations by reporting that all registered nodes are a viable
- * location.  This will evolve from a stub to a full-fledged implementation
- * capable of partitioning the keyspace across multiple containers, with
- * appropriate distribution across nodes.
+ * using the existing heartbeat messages.  StorageContainerManager lazily
+ * initializes a single storage container to be served by those DataNodes.
+ * All subsequent requests for container locations will reply with that single
+ * pipeline, using all registered nodes.
+ *
+ * This will evolve from a stub to a full-fledged implementation capable of
+ * partitioning the keyspace across multiple containers, with appropriate
+ * distribution across nodes.
+  private final XceiverClientManager xceiverClientManager;
+  private Pipeline singlePipeline;
-  public StorageContainerManager(Configuration conf)
+  public StorageContainerManager(OzoneConfiguration conf)
+    xceiverClientManager = new XceiverClientManager(conf);
+    Pipeline pipeline = initSingleContainerPipeline();
-    String containerName = UUID.randomUUID().toString();
-      locatedContainers.add(new LocatedContainer(key, key, containerName,
-          locations, leader));
+      locatedContainers.add(new LocatedContainer(key, key,
+          pipeline.getContainerName(), locations, leader));
+   * Lazily initializes a single container pipeline using all registered
+   * DataNodes via a synchronous call to the container protocol.  This single
+   * container pipeline will be reused for container requests for the lifetime
+   * of this StorageContainerManager.
+   *
+   * @throws IOException if there is an I/O error
+   */
+  private synchronized Pipeline initSingleContainerPipeline()
+      throws IOException {
+    if (singlePipeline == null) {
+      List<DatanodeDescriptor> liveNodes = new ArrayList<DatanodeDescriptor>();
+      blockManager.getDatanodeManager().fetchDatanodes(liveNodes, null, false);
+      if (liveNodes.isEmpty()) {
+        throw new IOException("Storage container locations not found.");
+      }
+      Pipeline newPipeline = newPipelineFromNodes(liveNodes,
+          UUID.randomUUID().toString());
+      XceiverClient xceiverClient =
+          xceiverClientManager.acquireClient(newPipeline);
+      try {
+        ContainerData containerData = ContainerData
+            .newBuilder()
+            .setName(newPipeline.getContainerName())
+            .build();
+        CreateContainerRequestProto createContainerRequest =
+            CreateContainerRequestProto.newBuilder()
+            .setPipeline(newPipeline.getProtobufMessage())
+            .setContainerData(containerData)
+            .build();
+        ContainerCommandRequestProto request = ContainerCommandRequestProto
+            .newBuilder()
+            .setCmdType(Type.CreateContainer)
+            .setCreateContainer(createContainerRequest)
+            .build();
+        ContainerCommandResponseProto response = xceiverClient.sendCommand(
+            request);
+        Result result = response.getResult();
+        if (result != Result.SUCCESS) {
+          throw new IOException(
+              "Failed to initialize container due to result code: " + result);
+        }
+        singlePipeline = newPipeline;
+      } finally {
+        xceiverClientManager.releaseClient(xceiverClient);
+      }
+    }
+    return singlePipeline;
+  }
+
+  /**
+   * Translates a list of nodes, ordered such that the first is the leader, into
+   * a corresponding {@link Pipeline} object.
+   *
+   * @param nodes list of nodes
+   * @param containerName container name
+   * @return pipeline corresponding to nodes
+   */
+  private static Pipeline newPipelineFromNodes(List<DatanodeDescriptor> nodes,
+      String containerName) {
+    String leaderId = nodes.get(0).getDatanodeUuid();
+    Pipeline pipeline = new Pipeline(leaderId);
+    for (DatanodeDescriptor node : nodes) {
+      pipeline.addMember(node);
+    }
+    pipeline.setContainerName(containerName);
+    return pipeline;
+  }
+
+  /**
-  private static RPC.Server startRpcServer(Configuration conf,
+  private static RPC.Server startRpcServer(OzoneConfiguration conf,
-  private static InetSocketAddress updateListenAddress(Configuration conf,
+  private static InetSocketAddress updateListenAddress(OzoneConfiguration conf,
-        new Configuration());
+        new OzoneConfiguration());

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 INS42 INS42 INS42 INS42 UPD43 INS21 INS60 INS65 INS65 INS42 INS42 INS25 INS41 INS65 INS65 INS65 INS65 INS42 INS74 INS42 MOV43 INS42 INS60 INS60 INS70 INS21 INS41 UPD43 UPD43 UPD42 INS7 INS43 INS59 INS66 INS66 INS66 INS66 INS42 INS66 INS27 INS8 INS42 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS43 INS43 INS59 INS43 INS59 INS44 INS42 INS8 INS32 INS42 UPD42 UPD42 MOV43 INS42 INS14 INS42 INS42 INS32 INS42 INS33 INS60 INS21 INS25 MOV60 INS60 INS54 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS42 INS43 INS42 INS42 INS74 INS59 INS32 INS32 INS8 INS43 INS43 INS59 INS8 INS8 INS32 INS42 INS43 INS42 INS42 INS32 MOV43 INS42 INS43 INS43 INS42 INS14 INS32 INS42 INS42 INS33 INS9 INS42 INS42 INS53 INS42 UPD42 INS32 INS42 INS42 INS32 INS60 INS60 INS60 INS60 INS60 INS25 INS21 INS21 INS42 INS42 INS34 INS42 INS42 INS42 INS42 UPD43 INS32 INS42 INS42 INS74 INS42 INS42 INS14 INS42 INS42 MOV32 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS7 INS32 UPD42 INS42 INS42 INS43 INS43 INS43 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS40 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS32 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS40 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42
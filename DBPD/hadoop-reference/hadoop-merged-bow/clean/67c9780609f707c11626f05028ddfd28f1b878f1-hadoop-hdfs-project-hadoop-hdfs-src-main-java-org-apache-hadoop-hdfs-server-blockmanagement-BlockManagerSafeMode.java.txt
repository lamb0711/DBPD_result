HDFS-9498. Move code that tracks blocks with future generation stamps to BlockManagerSafeMode. (Contributed by Mingliang Liu)

+import org.apache.hadoop.hdfs.protocol.BlockListAsLongs.BlockReportReplica;
+import org.apache.hadoop.hdfs.server.common.HdfsServerConstants.RollingUpgradeStartupOption;
+import org.apache.hadoop.hdfs.server.common.HdfsServerConstants.StartupOption;
+  /** Keeps track of how many bytes are in Future Generation blocks. */
+  private final AtomicLong numberOfBytesInFutureBlocks = new AtomicLong();
+  /** Reports if Name node was started with Rollback option. */
+  private final boolean inRollBack;
+
-
+    this.inRollBack = isInRollBackMode(NameNode.getStartupOption(conf));
+
-    if (blockManager.getBytesInFuture() > 0) {
+    if (getBytesInFuture() > 0) {
-          "in future. This means that Name node metadata is inconsistent." +
+          "in future. This means that Name node metadata is inconsistent. " +
-          "replaced. Exiting safe mode will cause loss of " + blockManager
-          .getBytesInFuture() + " byte(s). Please restart name node with " +
-          "right metadata or use \"hdfs dfsadmin -safemode forceExit" +
-          "if you are certain that the NameNode was started with the" +
-          "correct FsImage and edit logs. If you encountered this during" +
+          "replaced. Exiting safe mode will cause loss of " +
+          getBytesInFuture() + " byte(s). Please restart name node with " +
+          "right metadata or use \"hdfs dfsadmin -safemode forceExit\" " +
+          "if you are certain that the NameNode was started with the " +
+          "correct FsImage and edit logs. If you encountered this during " +
+   *
+   * @return true if it leaves safe mode successfully else false
-  void leaveSafeMode(boolean force) {
+  boolean leaveSafeMode(boolean force) {
+    final long bytesInFuture = numberOfBytesInFutureBlocks.get();
+    if (bytesInFuture > 0) {
+      if (force) {
+        LOG.warn("Leaving safe mode due to forceExit. This will cause a data "
+            + "loss of {} byte(s).", bytesInFuture);
+        numberOfBytesInFutureBlocks.set(0);
+      } else {
+        LOG.error("Refusing to leave safe mode without a force flag. " +
+            "Exiting safe mode will cause a deletion of {} byte(s). Please " +
+            "use -forceExit flag to exit safe mode forcefully if data loss is" +
+            " acceptable.", bytesInFuture);
+        return false;
+      }
+    } else if (force) {
+      LOG.warn("forceExit used when normal exist would suffice. Treating " +
+          "force exit as normal safe mode exit.");
+    }
+
-    if (!force && blockManager.getBytesInFuture() > 0) {
-      LOG.error("Refusing to leave safe mode without a force flag. " +
-          "Exiting safe mode will cause a deletion of {} byte(s). Please use " +
-          "-forceExit flag to exit safe mode forcefully if data loss is " +
-          "acceptable.", blockManager.getBytesInFuture());
-      return;
-    }
-
+
+    return true;
+  /**
+   * Check if the block report replica has a generation stamp (GS) in future.
+   * If safe mode is not currently on, this is a no-op.
+   *
+   * @param brr block report replica which belongs to no file in BlockManager
+   */
+  void checkBlocksWithFutureGS(BlockReportReplica brr) {
+    assert namesystem.hasWriteLock();
+    if (status == BMSafeModeStatus.OFF) {
+      return;
+    }
+
+    if (!blockManager.getShouldPostponeBlocksFromFuture() &&
+        !inRollBack &&
+        namesystem.isGenStampInFuture(brr)) {
+      numberOfBytesInFutureBlocks.addAndGet(brr.getBytesOnDisk());
+    }
+  }
+
+  /**
+   * Returns the number of bytes that reside in blocks with Generation Stamps
+   * greater than generation stamp known to Namenode.
+   *
+   * @return Bytes in future
+   */
+  long getBytesInFuture() {
+    return numberOfBytesInFutureBlocks.get();
+  }
+
+  /**
+   * Returns true if Namenode was started with a RollBack option.
+   *
+   * @param option - StartupOption
+   * @return boolean
+   */
+  private static boolean isInRollBackMode(StartupOption option) {
+    return (option == StartupOption.ROLLBACK) ||
+        (option == StartupOption.ROLLINGUPGRADE &&
+            option.getRollingUpgradeStartupOption() ==
+                RollingUpgradeStartupOption.ROLLBACK);
+  }
+

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS39 INS59 UPD39 INS29 INS39 INS42 INS44 INS8 INS29 INS39 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS65 INS42 INS42 INS14 INS65 INS42 INS21 INS65 INS60 INS25 INS41 INS65 INS65 INS43 INS42 INS6 INS25 INS25 INS65 INS65 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS66 INS43 INS66 INS7 INS66 INS83 INS39 INS59 INS27 INS8 INS25 INS9 INS66 INS66 INS42 INS66 INS42 INS32 INS27 INS8 INS27 INS8 INS66 INS66 INS66 INS32 INS66 INS42 INS66 INS66 INS42 INS27 INS42 INS22 INS32 INS42 INS32 INS42 INS34 MOV25 INS42 INS8 INS42 INS42 INS42 INS40 INS41 INS38 INS38 INS32 INS21 INS42 INS42 INS36 INS36 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS8 INS21 INS32 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS42 INS42 INS42 INS21 INS21 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS40 INS27 INS27 UPD45 UPD45 UPD45 INS32 INS32 INS9 INS42 INS42 INS27 INS42 INS42 INS42 INS40 INS32 INS40 UPD45 UPD42 MOV42 INS42 INS27 UPD42 MOV42 INS42 INS42 INS34 UPD42 MOV42 INS45 INS45 INS42 INS42 INS45 INS45 UPD45 UPD45 UPD45 DEL42 DEL42 DEL42 DEL38 DEL32 DEL34 DEL27 DEL27 DEL42 DEL32
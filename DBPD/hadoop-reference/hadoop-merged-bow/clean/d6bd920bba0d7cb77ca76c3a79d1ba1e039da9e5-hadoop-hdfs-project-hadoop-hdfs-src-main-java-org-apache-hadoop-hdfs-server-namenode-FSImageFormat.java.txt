HDFS-5709. Improve NameNode upgrade with existing reserved paths and path components. Contributed by Andrew Wang.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564645 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collection;
+import java.util.TreeMap;
-import org.apache.hadoop.HadoopIllegalArgumentException;
+import org.apache.hadoop.hdfs.DFSUtil;
+import org.apache.hadoop.hdfs.protocol.LayoutFlags;
-import org.apache.hadoop.hdfs.protocol.LayoutFlags;
+import org.apache.hadoop.hdfs.server.common.HdfsServerConstants.StartupOption;
+import org.apache.hadoop.util.StringUtils;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
-   * load fsimage files assuming only local names are stored
+   * load fsimage files assuming only local names are stored. Used when
+   * snapshots are not supported by the layout version.
+     // Rename .snapshot paths if we're doing an upgrade
+     parentPath = renameReservedPathsOnUpgrade(parentPath, getLayoutVersion());
-    if (parent == fsDir.rootDir && FSDirectory.isReservedName(child)) {
-        throw new HadoopIllegalArgumentException("File name \""
-            + child.getLocalName() + "\" is reserved. Please "
-            + " change the name of the existing file or directory to another "
-            + "name before upgrading to this release.");
+    if (parent == fsDir.rootDir) {
+        child.setLocalName(renameReservedRootComponentOnUpgrade(
+            child.getLocalNameBytes(), getLayoutVersion()));
-      final byte[] localName = FSImageSerialization.readLocalName(in);
+      byte[] localName = FSImageSerialization.readLocalName(in);
+      localName =
+          renameReservedComponentOnUpgrade(localName, getLayoutVersion());
-  
+
+  @VisibleForTesting
+  public static TreeMap<String, String> renameReservedMap =
+      new TreeMap<String, String>();
+
+  /**
+   * Use the default key-value pairs that will be used to determine how to
+   * rename reserved paths on upgrade.
+   */
+  @VisibleForTesting
+  public static void useDefaultRenameReservedPairs() {
+    renameReservedMap.clear();
+    for (String key: HdfsConstants.RESERVED_PATH_COMPONENTS) {
+      renameReservedMap.put(
+          key,
+          key + "." + LayoutVersion.getCurrentLayoutVersion() + "."
+              + "UPGRADE_RENAMED");
+    }
+  }
+
+  /**
+   * Set the key-value pairs that will be used to determine how to rename
+   * reserved paths on upgrade.
+   */
+  @VisibleForTesting
+  public static void setRenameReservedPairs(String renameReserved) {
+    // Clear and set the default values
+    useDefaultRenameReservedPairs();
+    // Overwrite with provided values
+    setRenameReservedMapInternal(renameReserved);
+  }
+
+  private static void setRenameReservedMapInternal(String renameReserved) {
+    Collection<String> pairs =
+        StringUtils.getTrimmedStringCollection(renameReserved);
+    for (String p : pairs) {
+      String[] pair = StringUtils.split(p, '/', '=');
+      Preconditions.checkArgument(pair.length == 2,
+          "Could not parse key-value pair " + p);
+      String key = pair[0];
+      String value = pair[1];
+      Preconditions.checkArgument(DFSUtil.isReservedPathComponent(key),
+          "Unknown reserved path " + key);
+      Preconditions.checkArgument(DFSUtil.isValidNameForComponent(value),
+          "Invalid rename path for " + key + ": " + value);
+      LOG.info("Will rename reserved path " + key + " to " + value);
+      renameReservedMap.put(key, value);
+    }
+  }
+
+  /**
+   * When upgrading from an old version, the filesystem could contain paths
+   * that are now reserved in the new version (e.g. .snapshot). This renames
+   * these new reserved paths to a user-specified value to avoid collisions
+   * with the reserved name.
+   * 
+   * @param path Old path potentially containing a reserved path
+   * @return New path with reserved path components renamed to user value
+   */
+  static String renameReservedPathsOnUpgrade(String path,
+      final int layoutVersion) {
+    final String oldPath = path;
+    // If any known LVs aren't supported, we're doing an upgrade
+    if (!LayoutVersion.supports(Feature.ADD_INODE_ID, layoutVersion)) {
+      String[] components = INode.getPathNames(path);
+      // Only need to worry about the root directory
+      if (components.length > 1) {
+        components[1] = DFSUtil.bytes2String(
+            renameReservedRootComponentOnUpgrade(
+                DFSUtil.string2Bytes(components[1]),
+                layoutVersion));
+        path = DFSUtil.strings2PathString(components);
+      }
+    }
+    if (!LayoutVersion.supports(Feature.SNAPSHOT, layoutVersion)) {
+      String[] components = INode.getPathNames(path);
+      // Special case the root path
+      if (components.length == 0) {
+        return path;
+      }
+      for (int i=0; i<components.length; i++) {
+        components[i] = DFSUtil.bytes2String(
+            renameReservedComponentOnUpgrade(
+                DFSUtil.string2Bytes(components[i]),
+                layoutVersion));
+      }
+      path = DFSUtil.strings2PathString(components);
+    }
+
+    if (!path.equals(oldPath)) {
+      LOG.info("Upgrade process renamed reserved path " + oldPath + " to "
+          + path);
+    }
+    return path;
+  }
+
+  private final static String RESERVED_ERROR_MSG = 
+      FSDirectory.DOT_RESERVED_PATH_PREFIX + " is a reserved path and "
+      + HdfsConstants.DOT_SNAPSHOT_DIR + " is a reserved path component in"
+      + " this version of HDFS. Please rollback and delete or rename"
+      + " this path, or upgrade with the "
+      + StartupOption.RENAMERESERVED.getName()
+      + " [key-value pairs]"
+      + " option to automatically rename these paths during upgrade.";
+
+  /**
+   * Same as {@link #renameReservedPathsOnUpgrade(String)}, but for a single
+   * byte array path component.
+   */
+  private static byte[] renameReservedComponentOnUpgrade(byte[] component,
+      final int layoutVersion) {
+    // If the LV doesn't support snapshots, we're doing an upgrade
+    if (!LayoutVersion.supports(Feature.SNAPSHOT, layoutVersion)) {
+      if (Arrays.equals(component, HdfsConstants.DOT_SNAPSHOT_DIR_BYTES)) {
+        Preconditions.checkArgument(
+            renameReservedMap != null &&
+            renameReservedMap.containsKey(HdfsConstants.DOT_SNAPSHOT_DIR),
+            RESERVED_ERROR_MSG);
+        component =
+            DFSUtil.string2Bytes(renameReservedMap
+                .get(HdfsConstants.DOT_SNAPSHOT_DIR));
+      }
+    }
+    return component;
+  }
+
+  /**
+   * Same as {@link #renameReservedPathsOnUpgrade(String)}, but for a single
+   * byte array path component.
+   */
+  private static byte[] renameReservedRootComponentOnUpgrade(byte[] component,
+      final int layoutVersion) {
+    // If the LV doesn't support inode IDs, we're doing an upgrade
+    if (!LayoutVersion.supports(Feature.ADD_INODE_ID, layoutVersion)) {
+      if (Arrays.equals(component, FSDirectory.DOT_RESERVED)) {
+        Preconditions.checkArgument(
+            renameReservedMap != null &&
+            renameReservedMap.containsKey(FSDirectory.DOT_RESERVED_STRING),
+            RESERVED_ERROR_MSG);
+        final String renameString = renameReservedMap
+            .get(FSDirectory.DOT_RESERVED_STRING);
+        component =
+            DFSUtil.string2Bytes(renameString);
+        LOG.info("Renamed root path " + FSDirectory.DOT_RESERVED_STRING
+            + " to " + renameString);
+      }
+    }
+    return component;
+  }
+

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS78 INS83 INS83 INS74 INS59 INS29 INS78 INS83 INS83 INS39 INS42 INS8 INS29 INS78 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS42 INS43 INS43 INS43 INS42 INS14 INS65 INS42 INS21 INS70 INS65 INS42 INS43 INS42 INS21 INS21 INS43 INS42 INS60 INS70 INS65 INS65 INS65 INS42 INS43 INS42 INS83 INS39 INS42 INS60 INS25 INS25 INS25 INS41 INS42 INS42 INS27 INS65 INS39 INS85 INS5 INS42 INS83 INS39 INS42 INS25 INS41 INS65 INS39 INS85 INS5 INS42 INS83 INS39 INS42 INS25 INS41 INS21 INS21 INS42 INS42 INS42 INS74 INS66 INS66 INS32 INS44 INS40 INS8 INS66 INS66 INS42 INS32 INS32 INS42 INS74 INS59 INS44 INS42 INS8 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS83 INS43 INS59 INS38 INS8 INS38 INS8 INS38 INS8 INS42 INS40 INS45 INS40 INS45 INS45 INS45 INS32 INS45 INS45 INS66 INS65 INS66 INS66 INS39 INS85 INS38 INS8 INS42 INS66 INS65 INS66 INS66 INS39 INS85 INS38 INS8 INS42 UPD66 INS66 INS7 MOV27 INS8 INS7 INS43 INS43 INS43 INS42 INS42 INS43 INS42 INS21 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS43 INS42 INS60 INS21 INS60 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS32 INS60 INS25 INS32 INS60 INS25 INS24 INS21 INS32 INS21 INS40 INS42 INS68 INS32 INS25 INS68 INS32 INS25 INS42 INS32 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS59 INS32 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS40 INS42 INS5 INS59 INS27 INS8 INS42 INS42 INS40 INS42 INS5 INS59 INS27 INS8 INS58 INS27 INS37 INS8 INS7 INS42 INS42 INS42 INS32 INS42 INS69 INS42 INS42 INS40 INS42 INS32 INS8 INS42 INS69 INS42 INS42 INS40 INS42 INS32 INS8 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS43 INS85 INS42 INS32 INS42 INS42 INS27 INS27 INS42 INS42 INS2 INS42 INS42 INS2 INS42 INS42 INS32 INS27 INS42 INS42 INS32 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS32 INS40 INS34 INS21 INS21 INS43 INS85 INS42 INS32 INS40 INS34 INS41 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS32 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS40 INS21 INS21 INS43 INS42 INS42 INS42 INS40 INS21 INS60 INS21 INS21 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS45 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS13 INS13 INS40 INS34 INS45 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS7 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS32 INS7 INS42 INS32 INS83 INS43 INS59 INS7 INS32 INS42 INS32 INS32 INS42 INS42 INS2 INS32 INS42 INS32 INS2 INS32 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS27 MOV42 UPD42 MOV42 INS42 INS42 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS42 INS42 INS32 INS27 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS45 INS40 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS33 INS42 INS42 INS40 INS42 INS42 INS2 INS42 INS42 INS2 INS42 INS34 INS42 INS42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL45 DEL32 DEL45 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL83
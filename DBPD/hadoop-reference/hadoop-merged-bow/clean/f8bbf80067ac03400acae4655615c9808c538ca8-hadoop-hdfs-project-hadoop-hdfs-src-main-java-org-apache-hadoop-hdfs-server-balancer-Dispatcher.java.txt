Merge branch 'trunk' into HDFS-6581

Conflicts:
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/StorageType.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/HdfsFileStatus.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/HdfsLocatedFileStatus.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocolPB/PBHelper.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormatPBINode.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFileAttributes.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeLayoutVersion.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/web/JsonUtil.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/proto/fsimage.proto
	hadoop-hdfs-project/hadoop-hdfs/src/main/proto/hdfs.proto
	hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/DFSTestUtil.java
	hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/MiniDFSCluster.java
	hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestFsck.java

+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.hdfs.DFSConfigKeys;
+import org.apache.hadoop.hdfs.DistributedFileSystem;
-  private static final long DELAY_AFTER_ERROR = 10 * 1000L; // 10 seconds
+  /**
+   * the period of time to delay the usage of a DataNode after hitting
+   * errors when using it for migrating data
+   */
+  private static long delayAfterErrors = 10 * 1000;
-  private final StorageGroupMap storageGroupMap = new StorageGroupMap();
+  private final StorageGroupMap<StorageGroup> storageGroupMap
+      = new StorageGroupMap<StorageGroup>();
+
-  static class StorageGroupMap {
+  public static class StorageGroupMap<G extends StorageGroup> {
-    private final Map<String, StorageGroup> map = new HashMap<String, StorageGroup>();
+    private final Map<String, G> map = new HashMap<String, G>();
-    StorageGroup get(String datanodeUuid, StorageType storageType) {
+    public G get(String datanodeUuid, StorageType storageType) {
-    void put(StorageGroup g) {
+    public void put(G g) {
+
+    public Collection<G> values() {
+      return map.values();
+    }
-  private class PendingMove {
+  public class PendingMove {
-    private PendingMove() {
+    private PendingMove(Source source, StorageGroup target) {
+      this.source = source;
+      this.target = target;
-      final Block b = block.getBlock();
-      return b + " with size=" + b.getNumBytes() + " from "
-          + source.getDisplayName() + " to " + target.getDisplayName()
-          + " through " + proxySource.datanode;
+      final Block b = block != null ? block.getBlock() : null;
+      String bStr = b != null ? (b + " with size=" + b.getNumBytes() + " ")
+          : " ";
+      return bStr + "from " + source.getDisplayName() + " to " + target
+          .getDisplayName() + " through " + (proxySource != null ? proxySource
+          .datanode : "");
+      // source and target must have the same storage type
+      final StorageType t = source.getStorageType();
-        if (markMovedIfGoodBlock(i.next())) {
+        if (markMovedIfGoodBlock(i.next(), t)) {
-    private boolean markMovedIfGoodBlock(DBlock block) {
+    private boolean markMovedIfGoodBlock(DBlock block, StorageType targetStorageType) {
-          if (isGoodBlockCandidate(source, target, block)) {
+          if (isGoodBlockCandidate(source, target, targetStorageType, block)) {
+        target.getDDatanode().setHasFailure();
-        proxySource.activateDelay(DELAY_AFTER_ERROR);
-        target.getDDatanode().activateDelay(DELAY_AFTER_ERROR);
+        proxySource.activateDelay(delayAfterErrors);
+        target.getDDatanode().activateDelay(delayAfterErrors);
-  private static class DBlock extends MovedBlocks.Locations<StorageGroup> {
-    DBlock(Block block) {
+  public static class DBlock extends MovedBlocks.Locations<StorageGroup> {
+    public DBlock(Block block) {
+
+    @Override
+    public synchronized boolean isLocatedOn(StorageGroup loc) {
+      // currently we only check if replicas are located on the same DataNodes
+      // since we do not have the capability to store two replicas in the same
+      // DataNode even though they are on two different storage types
+      for (StorageGroup existing : locations) {
+        if (existing.getDatanodeInfo().equals(loc.getDatanodeInfo())) {
+          return true;
+        }
+      }
+      return false;
+    }
-  static class DDatanode {
+  public static class DDatanode {
-    class StorageGroup {
+    public class StorageGroup {
+      
+      public StorageType getStorageType() {
+        return storageType;
+      }
-      DatanodeInfo getDatanodeInfo() {
+      public DatanodeInfo getDatanodeInfo() {
-      synchronized boolean hasSpaceForScheduling() {
-        return availableSizeToMove() > 0L;
+      boolean hasSpaceForScheduling() {
+        return hasSpaceForScheduling(0L);
+      }
+
+      synchronized boolean hasSpaceForScheduling(long size) {
+        return availableSizeToMove() > size;
-      synchronized void incScheduledSize(long size) {
+      public synchronized void incScheduledSize(long size) {
+      private PendingMove addPendingMove(DBlock block, final PendingMove pm) {
+        if (getDDatanode().addPendingBlock(pm)) {
+          if (pm.markMovedIfGoodBlock(block, getStorageType())) {
+            incScheduledSize(pm.block.getNumBytes());
+            return pm;
+          } else {
+            getDDatanode().removePendingBlock(pm);
+          }
+        }
+        return null;
+      }
+
-    final EnumMap<StorageType, StorageGroup> storageMap
+    private final EnumMap<StorageType, Source> sourceMap
+        = new EnumMap<StorageType, Source>(StorageType.class);
+    private final EnumMap<StorageType, StorageGroup> targetMap
+    private volatile boolean hasFailure = false;
-      return getClass().getSimpleName() + ":" + datanode + ":" + storageMap.values();
+      return getClass().getSimpleName() + ":" + datanode;
-    private DDatanode(DatanodeStorageReport r, int maxConcurrentMoves) {
-      this.datanode = r.getDatanodeInfo();
+    private DDatanode(DatanodeInfo datanode, int maxConcurrentMoves) {
+      this.datanode = datanode;
-    private void put(StorageType storageType, StorageGroup g) {
-      final StorageGroup existing = storageMap.put(storageType, g);
+    public DatanodeInfo getDatanodeInfo() {
+      return datanode;
+    }
+
+    private static <G extends StorageGroup> void put(StorageType storageType,
+        G g, EnumMap<StorageType, G> map) {
+      final StorageGroup existing = map.put(storageType, g);
-    StorageGroup addStorageGroup(StorageType storageType, long maxSize2Move) {
+    public StorageGroup addTarget(StorageType storageType, long maxSize2Move) {
-      put(storageType, g);
+      put(storageType, g, targetMap);
-    Source addSource(StorageType storageType, long maxSize2Move, Dispatcher d) {
+    public Source addSource(StorageType storageType, long maxSize2Move, Dispatcher d) {
-      put(storageType, s);
+      put(storageType, s, sourceMap);
+
+    void setHasFailure() {
+      this.hasFailure = true;
+    }
-  class Source extends DDatanode.StorageGroup {
+  public class Source extends DDatanode.StorageGroup {
+      // source and target must have the same storage type
+      final StorageType sourceStorageType = getStorageType();
-        if (Dispatcher.this.isGoodBlockCandidate(this, t.target, block)) {
+        if (Dispatcher.this.isGoodBlockCandidate(this, t.target,
+            sourceStorageType, block)) {
-        PendingMove pendingBlock = new PendingMove();
+        final PendingMove pendingBlock = new PendingMove(this, task.target);
-          pendingBlock.source = this;
-          pendingBlock.target = task.target;
+    
+    /** Add a pending move */
+    public PendingMove addPendingMove(DBlock block, StorageGroup target) {
+      return target.addPendingMove(block, new PendingMove(this, target));
+    }
-          // move the block
-          moveExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-              p.dispatch();
-            }
-          });
+          executePendingMove(p);
-    this.dispatchExecutor = Executors.newFixedThreadPool(dispatcherThreads);
+    this.dispatchExecutor = dispatcherThreads == 0? null
+        : Executors.newFixedThreadPool(dispatcherThreads);
-  StorageGroupMap getStorageGroupMap() {
+  public DistributedFileSystem getDistributedFileSystem() {
+    return nnc.getDistributedFileSystem();
+  }
+
+  public StorageGroupMap<StorageGroup> getStorageGroupMap() {
-  NetworkTopology getCluster() {
+  public NetworkTopology getCluster() {
-  List<DatanodeStorageReport> init() throws IOException {
+  public List<DatanodeStorageReport> init() throws IOException {
-  public DDatanode newDatanode(DatanodeStorageReport r) {
-    return new DDatanode(r, maxConcurrentMovesPerNode);
+  public DDatanode newDatanode(DatanodeInfo datanode) {
+    return new DDatanode(datanode, maxConcurrentMovesPerNode);
+  }
+
+  public void executePendingMove(final PendingMove p) {
+    // move the block
+    moveExecutor.execute(new Runnable() {
+      @Override
+      public void run() {
+        p.dispatch();
+      }
+    });
-    waitForMoveCompletion();
+    waitForMoveCompletion(targets);
-  /** set the sleeping period for block move completion check */
-  static void setBlockMoveWaitTime(long time) {
-    blockMoveWaitTime = time;
-  }
-
-  /** Wait for all block move confirmations. */
-  private void waitForMoveCompletion() {
+  /**
+   * Wait for all block move confirmations.
+   * @return true if there is failed move execution
+   */
+  public static boolean waitForMoveCompletion(
+      Iterable<? extends StorageGroup> targets) {
+    boolean hasFailure = false;
+        } else {
+          hasFailure |= t.getDDatanode().hasFailure;
-        return; //all pending queues are empty
+        return hasFailure; // all pending queues are empty
-   * A block is a good candidate if 
+   * A block is a good candidate if
-  private boolean isGoodBlockCandidate(Source source, StorageGroup target,
-      DBlock block) {
-    if (source.storageType != target.storageType) {
+  private boolean isGoodBlockCandidate(StorageGroup source, StorageGroup target,
+      StorageType targetStorageType, DBlock block) {
+    if (target.storageType != targetStorageType) {
-        && isOnSameNodeGroupWithReplicas(target, block, source)) {
+        && isOnSameNodeGroupWithReplicas(source, target, block)) {
-  private boolean reduceNumOfRacks(Source source, StorageGroup target,
+  private boolean reduceNumOfRacks(StorageGroup source, StorageGroup target,
-   * 
+   *
-  private boolean isOnSameNodeGroupWithReplicas(
-      StorageGroup target, DBlock block, Source source) {
+  private boolean isOnSameNodeGroupWithReplicas(StorageGroup source,
+      StorageGroup target, DBlock block) {
+  /** set the sleeping period for block move completion check */
+  @VisibleForTesting
+  public static void setBlockMoveWaitTime(long time) {
+    blockMoveWaitTime = time;
+  }
+
+  @VisibleForTesting
+  public static void setDelayAfterErrors(long time) {
+    delayAfterErrors = time;
+  }
+
-  void shutdownNow() {
-    dispatchExecutor.shutdownNow();
+  public void shutdownNow() {
+    if (dispatchExecutor != null) {
+      dispatchExecutor.shutdownNow();
+    }

INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS31 INS31 MOV44 INS31 INS29 INS74 INS83 INS73 INS31 UPD83 UPD83 INS31 INS83 INS23 INS23 INS31 INS31 INS83 INS31 INS83 INS43 INS42 INS8 INS83 INS74 INS83 INS83 INS83 INS39 INS42 INS44 MOV8 UPD83 INS83 UPD39 INS44 INS44 INS78 INS83 INS78 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS65 UPD42 MOV43 INS43 INS42 MOV43 UPD74 INS83 INS43 INS83 INS44 INS83 INS74 INS42 INS8 INS44 INS44 INS44 INS83 INS78 INS83 INS83 INS39 INS42 MOV44 INS8 INS83 INS31 INS31 INS31 INS83 INS83 INS74 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS43 INS42 INS8 INS83 INS73 INS44 INS44 INS83 UPD42 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS42 INS41 MOV43 INS43 UPD43 UPD42 INS83 INS43 INS42 INS65 INS74 INS42 INS60 UPD43 INS43 INS42 UPD43 UPD43 INS42 INS42 INS39 INS42 INS21 INS25 INS66 INS66 UPD34 INS42 INS74 INS43 INS42 INS43 INS42 INS43 INS43 INS41 INS43 INS42 INS43 INS42 INS21 INS21 INS60 INS60 INS43 INS42 INS42 UPD42 INS70 INS41 INS83 INS43 INS42 INS8 INS83 MOV29 INS39 INS42 INS8 INS44 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS43 INS43 INS43 INS42 INS14 UPD42 INS42 INS9 UPD43 UPD42 INS42 INS41 INS42 MOV43 INS43 INS42 INS74 INS42 INS21 INS60 INS65 INS42 INS43 INS42 INS43 INS42 INS41 INS32 INS42 UPD42 INS42 UPD66 INS66 INS43 INS76 INS39 INS59 UPD66 UPD42 INS42 UPD42 UPD42 INS7 INS27 INS8 MOV43 INS43 INS42 UPD74 INS42 INS42 INS42 INS32 INS42 INS42 INS7 INS7 INS43 INS59 INS83 INS43 INS59 INS42 MOV44 INS42 INS8 INS9 INS42 INS41 INS41 INS39 INS42 INS42 INS43 INS42 INS83 INS43 INS42 INS25 INS41 INS42 INS42 INS42 INS74 INS57 UPD42 INS42 INS42 INS43 INS43 INS43 INS43 INS7 INS83 INS43 INS59 INS66 INS42 INS42 INS32 INS16 INS42 INS42 UPD42 INS42 INS42 MOV43 INS42 INS9 INS42 INS42 INS42 INS42 INS33 MOV21 INS42 UPD43 INS42 INS42 INS22 INS42 INS22 INS42 INS16 INS42 INS42 INS16 UPD42 UPD45 INS36 INS42 INS42 INS32 MOV21 UPD42 INS25 INS42 INS32 INS42 INS42 INS32 INS8 INS33 INS43 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS9 INS42 INS42 INS32 INS42 INS42 INS42 INS14 INS27 INS33 MOV32 INS42 UPD42 INS52 INS42 INS52 INS42 INS27 MOV32 INS33 INS27 INS36 INS45 INS16 INS42 INS42 INS21 INS32 INS8 INS42 INS34 INS42 INS32 INS42 INS42 INS25 INS42 INS42 INS42 INS42 UPD42 INS52 INS42 INS42 INS83 INS43 MOV43 INS52 INS42 INS8 INS42 INS34 INS42 INS33 INS42 INS33 INS27 INS27 INS40 INS45 INS42 INS32 INS32 INS42 INS32 INS41 INS42 INS32 INS8 INS8 INS42 INS42 MOV21 INS21 INS18 INS8 INS42 INS42 INS45 MOV32 INS45 INS42 INS33 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS32 INS21 INS41 INS21 INS52 INS40 INS32 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS7 INS42 INS32 INS32 INS42 INS42 INS42 INS22 INS40 INS42 INS42 INS32 INS42 INS42 INS42 DEL83 DEL45 DEL40 DEL42 DEL34 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL52 DEL7 DEL21 DEL40 DEL40 DEL7 DEL21 DEL18 DEL40 DEL42
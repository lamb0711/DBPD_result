Merge r1550130 through r1555020 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1555021 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.snapshot.DirectoryWithSnapshotFeature;
+import org.apache.hadoop.hdfs.server.namenode.snapshot.DirectoryWithSnapshotFeature.DirectoryDiffList;
-import org.apache.hadoop.hdfs.server.namenode.snapshot.INodeDirectoryWithSnapshot;
+import org.apache.hadoop.hdfs.util.Diff.ListType;
-  /** Directory related features such as quota and snapshots. */
-  public static abstract class Feature implements INode.Feature<Feature> {
-    private Feature nextFeature;
-
-    @Override
-    public Feature getNextFeature() {
-      return nextFeature;
-    }
-
-    @Override
-    public void setNextFeature(Feature next) {
-      this.nextFeature = next;
-    }
-  }
-  /** A linked list of {@link Feature}s. */
-  private Feature headFeature = null;
-
-      this.headFeature = other.headFeature;
+      this.features = other.features;
-    for(Feature f = headFeature; f != null; f = f.nextFeature) {
+    for (Feature f : features) {
-  private void addFeature(Feature f) {
-    headFeature = INode.Feature.Util.addFeature(f, headFeature);
-  }
-
-  private void removeFeature(Feature f) {
-    headFeature = INode.Feature.Util.removeFeature(f, headFeature);
-  }
-
-
+  
+  protected DirectoryWithSnapshotFeature addSnapshotFeature(
+      DirectoryDiffList diffs) {
+    Preconditions.checkState(!isWithSnapshot(), 
+        "Directory is already with snapshot");
+    DirectoryWithSnapshotFeature sf = new DirectoryWithSnapshotFeature(diffs);
+    addFeature(sf);
+    return sf;
+  }
+  
-   * Remove the specified child from this directory.
-   * 
-   * @param child the child inode to be removed
-   * @param latest See {@link INode#recordModification(Snapshot, INodeMap)}.
+   * If feature list contains a {@link DirectoryWithSnapshotFeature}, return it;
+   * otherwise, return null.
-  public boolean removeChild(INode child, Snapshot latest,
-      final INodeMap inodeMap) throws QuotaExceededException {
-    if (isInLatestSnapshot(latest)) {
-      return replaceSelf4INodeDirectoryWithSnapshot(inodeMap)
-          .removeChild(child, latest, inodeMap);
+  public final DirectoryWithSnapshotFeature getDirectoryWithSnapshotFeature() {
+    for (Feature f : features) {
+      if (f instanceof DirectoryWithSnapshotFeature) {
+        return (DirectoryWithSnapshotFeature) f;
+      }
-
-    return removeChild(child);
+    return null;
-  /** 
-   * Remove the specified child from this directory.
-   * The basic remove method which actually calls children.remove(..).
-   *
-   * @param child the child inode to be removed
-   * 
-   * @return true if the child is removed; false if the child is not found.
-   */
-  protected final boolean removeChild(final INode child) {
-    final int i = searchChildren(child.getLocalNameBytes());
-    if (i < 0) {
-      return false;
-    }
-
-    final INode removed = children.remove(i);
-    Preconditions.checkState(removed == child);
-    return true;
+  /** Is this file has the snapshot feature? */
+  public final boolean isWithSnapshot() {
+    return getDirectoryWithSnapshotFeature() != null;
+  }
+  
+  public DirectoryDiffList getDiffs() {
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    return sf != null ? sf.getDiffs() : null;
+  }
+  
+  @Override
+  public INodeDirectoryAttributes getSnapshotINode(Snapshot snapshot) {
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    return sf == null ? this : sf.getDiffs().getSnapshotINode(snapshot, this);
+  }
+  
+  @Override
+  public String toDetailString() {
+    DirectoryWithSnapshotFeature sf = this.getDirectoryWithSnapshotFeature();
+    return super.toDetailString() + (sf == null ? "" : ", " + sf.getDiffs()); 
-    replaceSelf(s, inodeMap).saveSelf2Snapshot(latest, this);
+    replaceSelf(s, inodeMap).getDirectoryWithSnapshotFeature().getDiffs()
+        .saveSelf2Snapshot(latest, s, this);
-  /** Replace itself with an {@link INodeDirectoryWithSnapshot}. */
-  public INodeDirectoryWithSnapshot replaceSelf4INodeDirectoryWithSnapshot(
-      final INodeMap inodeMap) {
-    return replaceSelf(new INodeDirectoryWithSnapshot(this), inodeMap);
-  }
-
-  /** Replace the given child with a new child. */
+  /** 
+   * Replace the given child with a new child. Note that we no longer need to
+   * replace an normal INodeDirectory or INodeFile into an
+   * INodeDirectoryWithSnapshot or INodeFileUnderConstruction. The only cases
+   * for child replacement is for {@link INodeDirectorySnapshottable} and 
+   * reference nodes.
+   */
-    if (oldChild.isReference() && !newChild.isReference()) {
-      // replace the referred inode, e.g., 
-      // INodeFileWithSnapshot -> INodeFileUnderConstructionWithSnapshot
-      final INode withCount = oldChild.asReference().getReferredINode();
-      withCount.asReference().setReferredINode(newChild);
-    } else {
-      if (oldChild.isReference()) {
-        // both are reference nodes, e.g., DstReference -> WithName
-        final INodeReference.WithCount withCount = 
-            (WithCount) oldChild.asReference().getReferredINode();
-        withCount.removeReference(oldChild.asReference());
-      }
-      children.set(i, newChild);
+    if (oldChild.isReference() && newChild.isReference()) {
+      // both are reference nodes, e.g., DstReference -> WithName
+      final INodeReference.WithCount withCount = 
+          (WithCount) oldChild.asReference().getReferredINode();
+      withCount.removeReference(oldChild.asReference());
+    children.set(i, newChild);
+    
+    // replace the instance in the created list of the diff list
+    DirectoryWithSnapshotFeature sf = this.getDirectoryWithSnapshotFeature();
+    if (sf != null) {
+      sf.getDiffs().replaceChild(ListType.CREATED, oldChild, newChild);
+    }
+    
-    }
+    }    
-  public INodeDirectory recordModification(Snapshot latest,
-      final INodeMap inodeMap) throws QuotaExceededException {
-    if (isInLatestSnapshot(latest)) {
-      return replaceSelf4INodeDirectoryWithSnapshot(inodeMap)
-          .recordModification(latest, inodeMap);
-    } else {
-      return this;
+  public INodeDirectory recordModification(Snapshot latest) 
+      throws QuotaExceededException {
+    if (isInLatestSnapshot(latest) && !shouldRecordInSrcSnapshot(latest)) {
+      // add snapshot feature if necessary
+      DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+      if (sf == null) {
+        sf = addSnapshotFeature(null);
+      }
+      // record self in the diff list if necessary
+      sf.getDiffs().saveSelf2Snapshot(latest, this, null);
+    return this;
-      final INode snapshotCopy, final INodeMap inodeMap)
-      throws QuotaExceededException {
+      final INode snapshotCopy) throws QuotaExceededException {
-    return replaceSelf4INodeDirectoryWithSnapshot(inodeMap)
-        .saveChild2Snapshot(child, latest, snapshotCopy, inodeMap);
+    
+    // add snapshot feature if necessary
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    if (sf == null) {
+      sf = this.addSnapshotFeature(null);
+    }
+    return sf.saveChild2Snapshot(this, child, latest, snapshotCopy);
-    final ReadOnlyList<INode> c = getChildrenList(snapshot);
-    final int i = ReadOnlyList.Util.binarySearch(c, name);
-    return i < 0? null: c.get(i);
+    DirectoryWithSnapshotFeature sf;
+    if (snapshot == null || (sf = getDirectoryWithSnapshotFeature()) == null) {
+      ReadOnlyList<INode> c = getCurrentChildrenList();
+      final int i = ReadOnlyList.Util.binarySearch(c, name);
+      return i < 0 ? null : c.get(i);
+    }
+    
+    return sf.getChild(this, name, snapshot);
+  }
+  
+  /**
+   * @param snapshot
+   *          if it is not null, get the result from the given snapshot;
+   *          otherwise, get the result from the current directory.
+   * @return the current children list if the specified snapshot is null;
+   *         otherwise, return the children list corresponding to the snapshot.
+   *         Note that the returned list is never null.
+   */
+  public ReadOnlyList<INode> getChildrenList(final Snapshot snapshot) {
+    DirectoryWithSnapshotFeature sf;
+    if (snapshot == null
+        || (sf = this.getDirectoryWithSnapshotFeature()) == null) {
+      return getCurrentChildrenList();
+    }
+    return sf.getChildrenList(this, snapshot);
+  }
+  
+  private ReadOnlyList<INode> getCurrentChildrenList() {
+    return children == null ? ReadOnlyList.Util.<INode> emptyList()
+        : ReadOnlyList.Util.asReadOnlyList(children);
+  
+  /**
+   * Remove the specified child from this directory.
+   */
+  public boolean removeChild(INode child, Snapshot latest)
+      throws QuotaExceededException {
+    if (isInLatestSnapshot(latest)) {
+      // create snapshot feature if necessary
+      DirectoryWithSnapshotFeature sf = this.getDirectoryWithSnapshotFeature();
+      if (sf == null) {
+        sf = this.addSnapshotFeature(null);
+      }
+      return sf.removeChild(this, child, latest);
+    }
+    return removeChild(child);
+  }
+  
+  /** 
+   * Remove the specified child from this directory.
+   * The basic remove method which actually calls children.remove(..).
+   *
+   * @param child the child inode to be removed
+   * 
+   * @return true if the child is removed; false if the child is not found.
+   */
+  public boolean removeChild(final INode child) {
+    final int i = searchChildren(child.getLocalNameBytes());
+    if (i < 0) {
+      return false;
+    }
+
+    final INode removed = children.remove(i);
+    Preconditions.checkState(removed == child);
+    return true;
+  }
-   * @param inodeMap update the inodeMap if the directory node gets replaced
-      final Snapshot latest, final INodeMap inodeMap)
-      throws QuotaExceededException {
+      final Snapshot latest) throws QuotaExceededException {
-      INodeDirectoryWithSnapshot sdir = 
-          replaceSelf4INodeDirectoryWithSnapshot(inodeMap);
-      boolean added = sdir.addChild(node, setModTime, latest, inodeMap);
-      return added;
+      // create snapshot feature if necessary
+      DirectoryWithSnapshotFeature sf = this.getDirectoryWithSnapshotFeature();
+      if (sf == null) {
+        sf = this.addSnapshotFeature(null);
+      }
+      return sf.addChild(this, node, setModTime, latest);
-      updateModificationTime(node.getModificationTime(), latest, inodeMap);
+      updateModificationTime(node.getModificationTime(), latest);
-
-  /** The same as addChild(node, false, null, false) */
-    final DirectoryWithQuotaFeature q = getDirectoryWithQuotaFeature();
-    if (q != null) {
-      if (useCache && isQuotaSet()) {
-        q.addNamespaceDiskspace(counts);
-      } else {
-        computeDirectoryQuotaUsage(counts, false, lastSnapshotId);
+    final DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    
+    // we are computing the quota usage for a specific snapshot here, i.e., the
+    // computation only includes files/directories that exist at the time of the
+    // given snapshot
+    if (sf != null && lastSnapshotId != Snapshot.INVALID_ID
+        && !(useCache && isQuotaSet())) {
+      Snapshot lastSnapshot = sf.getDiffs().getSnapshotById(lastSnapshotId);
+      ReadOnlyList<INode> childrenList = getChildrenList(lastSnapshot);
+      for (INode child : childrenList) {
+        child.computeQuotaUsage(counts, useCache, lastSnapshotId);
+      counts.add(Quota.NAMESPACE, 1);
+    }
+    
+    // compute the quota usage in the scope of the current directory tree
+    final DirectoryWithQuotaFeature q = getDirectoryWithQuotaFeature();
+    if (useCache && q != null && q.isQuotaSet()) { // use the cached quota
+      return q.addNamespaceDiskspace(counts);
+      useCache = q != null && !q.isQuotaSet() ? false : useCache;
-  Quota.Counts computeDirectoryQuotaUsage(Quota.Counts counts, boolean useCache,
-      int lastSnapshotId) {
+  private Quota.Counts computeDirectoryQuotaUsage(Quota.Counts counts,
+      boolean useCache, int lastSnapshotId) {
+    // include the diff list
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    if (sf != null) {
+      sf.computeQuotaUsage4CurrentDirectory(counts);
+    }
+    final DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    if (sf != null) {
+      sf.computeContentSummary4Snapshot(summary.getCounts());
+    }
-
-
-
-
-
+  
-   * @param snapshot
-   *          if it is not null, get the result from the given snapshot;
-   *          otherwise, get the result from the current directory.
-   * @return the current children list if the specified snapshot is null;
-   *         otherwise, return the children list corresponding to the snapshot.
-   *         Note that the returned list is never null.
+   * This method is usually called by the undo section of rename.
+   * 
+   * Before calling this function, in the rename operation, we replace the
+   * original src node (of the rename operation) with a reference node (WithName
+   * instance) in both the children list and a created list, delete the
+   * reference node from the children list, and add it to the corresponding
+   * deleted list.
+   * 
+   * To undo the above operations, we have the following steps in particular:
+   * 
+   * <pre>
+   * 1) remove the WithName node from the deleted list (if it exists) 
+   * 2) replace the WithName node in the created list with srcChild 
+   * 3) add srcChild back as a child of srcParent. Note that we already add 
+   * the node into the created list of a snapshot diff in step 2, we do not need
+   * to add srcChild to the created list of the latest snapshot.
+   * </pre>
+   * 
+   * We do not need to update quota usage because the old child is in the 
+   * deleted list before. 
+   * 
+   * @param oldChild
+   *          The reference node to be removed/replaced
+   * @param newChild
+   *          The node to be added back
+   * @param latestSnapshot
+   *          The latest snapshot. Note this may not be the last snapshot in the
+   *          diff list, since the src tree of the current rename operation
+   *          may be the dst tree of a previous rename.
+   * @throws QuotaExceededException should not throw this exception
-  public ReadOnlyList<INode> getChildrenList(final Snapshot snapshot) {
-    return children == null ? ReadOnlyList.Util.<INode>emptyList()
-        : ReadOnlyList.Util.asReadOnlyList(children);
+  public void undoRename4ScrParent(final INodeReference oldChild,
+      final INode newChild, Snapshot latestSnapshot)
+      throws QuotaExceededException {
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    Preconditions.checkState(sf != null,
+        "Directory does not have snapshot feature");
+    sf.getDiffs().removeChild(ListType.DELETED, oldChild);
+    sf.getDiffs().replaceChild(ListType.CREATED, oldChild, newChild);
+    addChild(newChild, true, null);
+  }
+  
+  /**
+   * Undo the rename operation for the dst tree, i.e., if the rename operation
+   * (with OVERWRITE option) removes a file/dir from the dst tree, add it back
+   * and delete possible record in the deleted list.  
+   */
+  public void undoRename4DstParent(final INode deletedChild,
+      Snapshot latestSnapshot) throws QuotaExceededException {
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    Preconditions.checkState(sf != null,
+        "Directory does not have snapshot feature");
+    boolean removeDeletedChild = sf.getDiffs().removeChild(ListType.DELETED,
+        deletedChild);
+    // pass null for inodeMap since the parent node will not get replaced when
+    // undoing rename
+    final boolean added = addChild(deletedChild, true, removeDeletedChild ? null
+        : latestSnapshot);
+    // update quota usage if adding is successfully and the old child has not
+    // been stored in deleted list before
+    if (added && !removeDeletedChild) {
+      final Quota.Counts counts = deletedChild.computeQuotaUsage();
+      addSpaceConsumed(counts.get(Quota.NAMESPACE),
+          counts.get(Quota.DISKSPACE), false);
+    }
-    // INodeDirectoryWithSnapshot#cleanSubtree)
+    // DirectoryWithSnapshotFeature)
+    final DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    if (sf != null) {
+      sf.clear(this, collectedBlocks, removedINodes);
+    }
+    DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature();
+    // there is snapshot data
+    if (sf != null) {
+      return sf.cleanDirectory(this, snapshot, prior, collectedBlocks,
+          removedINodes, countDiffChange);
+    }
+    // there is no snapshot data

MOV26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 UPD40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 MOV31 MOV31 INS31 INS31 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS83 INS43 INS42 INS8 MOV78 INS83 INS43 INS42 INS44 INS8 INS43 INS42 INS8 MOV78 MOV43 INS42 MOV44 MOV43 INS8 INS8 INS8 MOV29 INS83 MOV74 INS42 MOV44 INS8 UPD83 UPD42 INS29 UPD83 UPD39 INS42 MOV44 MOV44 MOV43 INS8 UPD83 MOV78 UPD83 MOV43 INS42 MOV44 MOV44 MOV44 INS8 INS83 UPD39 INS42 INS44 INS44 INS43 INS8 MOV29 MOV83 INS39 INS42 INS44 INS44 INS43 INS8 INS70 INS42 INS43 INS42 INS21 INS60 INS21 INS41 MOV65 INS42 INS70 INS41 INS65 INS41 INS42 INS60 INS41 INS42 INS43 INS42 INS60 INS41 INS42 INS60 MOV41 MOV25 MOV21 MOV60 INS25 INS25 MOV41 MOV25 INS60 INS25 MOV41 INS60 INS25 INS41 INS60 INS25 INS41 MOV65 INS25 MOV41 INS60 INS25 MOV60 INS25 INS60 INS25 INS60 INS25 INS65 INS65 INS65 INS83 INS43 INS42 UPD43 UPD42 INS43 INS42 INS42 INS60 INS21 INS21 INS21 INS21 MOV83 MOV43 INS42 UPD43 MOV43 UPD42 MOV42 INS42 INS60 INS21 INS60 INS60 MOV25 INS60 INS25 INS60 INS25 MOV44 INS42 MOV8 INS42 INS32 INS43 INS59 INS32 INS42 UPD66 INS65 INS66 INS66 MOV44 INS42 INS8 INS33 INS66 INS27 INS43 INS59 INS16 INS42 INS43 INS59 INS16 INS43 INS59 INS27 INS32 UPD66 INS66 INS66 INS66 INS65 INS66 INS66 MOV27 INS43 INS27 INS8 INS27 INS8 INS43 INS59 INS27 INS8 INS43 INS59 INS27 MOV8 INS32 INS43 INS59 INS27 INS8 INS32 MOV32 INS8 MOV32 INS83 INS43 INS59 INS27 INS8 INS27 MOV8 MOV8 INS43 INS59 INS27 INS8 INS83 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 UPD66 INS42 INS66 UPD42 INS66 UPD66 UPD66 INS42 INS66 INS42 UPD42 INS42 INS43 INS59 INS32 INS32 INS32 INS32 INS66 UPD66 UPD66 UPD42 INS43 INS59 INS32 INS39 INS59 INS83 INS39 INS59 INS27 INS83 INS43 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS43 INS42 INS42 INS42 INS38 INS45 INS42 INS42 INS14 INS42 INS42 INS42 INS25 INS32 INS33 UPD42 MOV42 INS42 INS32 INS27 INS32 INS33 UPD42 MOV42 INS42 INS32 INS27 INS52 INS32 UPD42 MOV42 INS42 INS32 INS48 INS36 INS32 INS42 INS42 INS42 INS52 INS42 MOV32 INS42 UPD42 INS42 INS33 MOV21 MOV32 INS38 INS60 INS25 INS21 UPD42 MOV42 INS42 INS32 INS42 INS33 INS21 UPD42 MOV42 INS52 INS42 INS42 INS27 INS27 INS42 INS42 INS52 INS42 INS42 UPD42 MOV42 INS42 INS27 INS27 INS41 INS42 INS42 INS52 INS42 INS60 INS25 INS41 INS25 INS41 INS42 INS42 INS32 INS27 INS38 INS60 INS60 INS70 INS21 MOV41 INS27 INS32 INS41 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS27 INS45 INS32 MOV42 INS40 UPD42 MOV42 INS32 INS42 INS40 INS42 INS42 INS42 INS42 INS9 INS33 UPD42 MOV42 INS42 INS32 INS42 INS42 INS27 INS45 INS42 INS32 INS42 INS32 INS42 INS38 INS60 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS41 MOV42 INS32 INS43 INS42 INS62 INS8 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS33 INS32 INS42 INS42 INS52 INS52 INS42 INS42 INS16 MOV32 INS42 INS52 UPD42 INS32 INS43 INS59 INS27 INS8 INS32 INS42 INS7 INS42 INS33 INS36 INS33 INS74 INS42 INS33 INS36 INS33 INS32 INS43 INS59 INS27 INS8 INS32 UPD43 INS27 INS8 INS32 INS42 INS27 INS27 INS36 MOV43 INS59 INS74 INS59 INS44 INS42 INS8 INS32 INS42 INS27 INS42 INS42 MOV32 INS7 INS42 INS32 INS42 INS32 INS42 INS42 INS33 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS33 MOV32 UPD42 MOV42 INS40 UPD42 MOV42 INS42 INS42 INS9 INS16 INS42 INS83 INS43 INS59 INS42 INS32 INS42 INS32 UPD40 INS42 INS42 INS42 INS43 INS41 INS42 INS42 INS27 INS45 INS27 UPD42 UPD42 INS40 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS33 MOV21 INS32 INS42 INS42 INS52 INS33 INS42 INS32 INS7 INS43 INS43 INS7 INS42 INS42 INS42 INS32 INS42 INS33 MOV21 INS42 INS42 INS52 INS42 INS42 UPD42 UPD42 INS42 INS33 INS21 UPD42 MOV42 MOV42 INS52 MOV42 MOV42 MOV42 INS42 INS33 INS42 INS40 MOV27 INS42 INS32 INS43 INS43 INS42 INS32 UPD43 MOV43 UPD42 MOV42 MOV21 INS42 INS42 INS40 INS34 INS42 INS33 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 INS42 INS33 INS42 INS40 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS11 INS42 INS33 INS45 INS32 UPD42 UPD42 INS42 INS42 INS42 INS52 INS42 INS33 INS42 INS32 INS42 INS42 UPD42 INS42 INS32 INS52 INS42 INS52 UPD42 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 INS27 INS9 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS40 MOV42 INS42 INS40 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS52 INS42 UPD42 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 MOV27 INS38 INS42 INS42 INS33 INS52 UPD42 INS33 INS52 INS42 INS33 INS32 INS42 INS42 DEL29 DEL83 DEL83 DEL83 DEL42 DEL40 DEL43 DEL43 DEL74 DEL83 DEL43 DEL42 DEL59 DEL23 DEL55 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL33 DEL59 DEL23 DEL43 DEL42 DEL42 DEL59 DEL58 DEL42 DEL33 DEL27 DEL42 DEL40 DEL7 DEL24 DEL42 DEL43 DEL42 DEL8 DEL42 DEL52 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL14 DEL42 DEL32 DEL41 DEL8 DEL31 DEL38 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL32 DEL8 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL39 DEL42 DEL43 DEL42 DEL44 DEL8 DEL83 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL41 DEL8 DEL8 DEL25 DEL8 DEL31 DEL83 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL8 DEL83 DEL42 DEL40 DEL42 DEL42 DEL42 DEL8 DEL83 DEL42 DEL66 DEL65 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL42 DEL66 DEL65 DEL29 DEL42 DEL40 DEL32 DEL7 DEL21 DEL39 DEL42 DEL8 DEL83 DEL42 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL32 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL65 DEL42
HADOOP-12483. Maintain wrapped SASL ordering for postponed IPC responses. (Daryn Sharp via yliu)

+    private Call(Call call) {
+      this(call.callId, call.retryCount, call.rpcRequest, call.connection,
+          call.rpcKind, call.clientId, call.traceScope);
+    }
+
-    public void setResponse(Throwable t) throws IOException {
-      setupResponse(new ByteArrayOutputStream(), this,
-          RpcStatusProto.FATAL, RpcErrorCodeProto.ERROR_RPC_SERVER,
-          null, t.getClass().getName(), StringUtils.stringifyException(t));
-    }
-
-        if (rpcResponse == null) {
-          // needed by postponed operations to indicate an exception has
-          // occurred.  it's too late to re-encode the response so just
-          // drop the connection.
-          connection.close();
-        } else {
-          connection.sendResponse(this);
-        }
+        connection.sendResponse(this);
+      }
+    }
+
+    @InterfaceStability.Unstable
+    @InterfaceAudience.LimitedPrivate({"HDFS"})
+    public void abortResponse(Throwable t) throws IOException {
+      // don't send response if the call was already sent or aborted.
+      if (responseWaitCount.getAndSet(-1) > 0) {
+        // clone the call to prevent a race with the other thread stomping
+        // on the response while being sent.  the original call is
+        // effectively discarded since the wait count won't hit zero
+        Call call = new Call(this);
+        setupResponse(new ByteArrayOutputStream(), call,
+            RpcStatusProto.FATAL, RpcErrorCodeProto.ERROR_RPC_SERVER,
+            null, t.getClass().getName(), StringUtils.stringifyException(t));
+        call.sendResponse();
+        // must only wrap before adding to the responseQueue to prevent
+        // postponed responses from being encrypted and sent out of order.
+        if (call.connection.useWrap) {
+          ByteArrayOutputStream response = new ByteArrayOutputStream();
+          wrapWithSasl(response, call);
+          call.setResponse(ByteBuffer.wrap(response.toByteArray()));
+        }
-            // setupResponse() needs to be sync'ed together with 
-            // responder.doResponse() since setupResponse may use
-            // SASL to encrypt response data and SASL enforces
-            // its own message ordering.
-            setupResponse(buf, call, returnStatus, detailedErr, 
+            setupResponse(buf, call, returnStatus, detailedErr,
-            
-            // Discard the large buf and reset it back to smaller size 
-            // to free up heap
+
+            // Discard the large buf and reset it back to smaller size
+            // to free up heap.
-    if (call.connection.useWrap) {
-      wrapWithSasl(responseBuf, call);
-    }
-
-    if (call.connection.useWrap) {
-      wrapWithSasl(response, call);
-    }
-      byte[] token = response.toByteArray();
+      byte[] token = call.rpcResponse.array();

MOV31 INS31 INS83 INS42 INS44 INS8 INS78 INS79 UPD42 INS8 INS43 INS42 INS17 MOV25 INS40 INS40 INS4 INS25 INS42 INS40 INS40 INS40 INS40 INS40 INS40 INS40 MOV27 INS45 INS27 MOV8 INS32 INS34 INS60 INS21 INS25 INS42 INS42 INS38 INS43 INS59 INS32 INS40 INS8 INS34 INS42 INS42 INS14 INS42 INS42 INS42 INS60 MOV21 INS21 INS40 UPD42 INS43 INS52 INS43 INS59 INS32 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS42 INS42 INS32 INS42 INS42 INS42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL8 DEL25 DEL52 DEL40 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL8 DEL25 DEL42
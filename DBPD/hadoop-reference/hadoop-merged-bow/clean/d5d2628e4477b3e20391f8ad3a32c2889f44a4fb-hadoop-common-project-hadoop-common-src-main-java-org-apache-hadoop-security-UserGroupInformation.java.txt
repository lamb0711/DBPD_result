Merge r1360400 through r1399945 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1399950 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.fs.CommonConfigurationKeys.HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN;
+import static org.apache.hadoop.fs.CommonConfigurationKeys.HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Iterator;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.util.Time;
+  /** Min time (in seconds) before relogin for Kerberos */
+  private static long kerberosMinSecondsBeforeRelogin;
-  /** Leave 10 minutes between relogin attempts. */
-  private static final long MIN_TIME_BEFORE_RELOGIN = 10 * 60 * 1000L;
-  
+    try {
+        kerberosMinSecondsBeforeRelogin = 1000L * conf.getLong(
+                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN,
+                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT);
+    }
+    catch(NumberFormatException nfe) {
+        throw new IllegalArgumentException("Invalid attribute value for " +
+                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN + " of " +
+                conf.get(HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN));
+    }
+    @Override
-  public static final HadoopConfiguration HADOOP_LOGIN_CONFIG =
-      new HadoopConfiguration();
-
-              subject, HADOOP_LOGIN_CONFIG);
+              subject, new HadoopConfiguration());
-              subject, HADOOP_LOGIN_CONFIG);
+              subject, new HadoopConfiguration());
-        if (fileLocation != null && isSecurityEnabled()) {
+        if (fileLocation != null) {
-          for (Token<?> token: cred.getAllTokens()) {
-            loginUser.addToken(token);
-          }
+          loginUser.addCredentials(cred);
+          @Override
-                long now = System.currentTimeMillis();
+                long now = Time.now();
-                                       now + MIN_TIME_BEFORE_RELOGIN);
+                                       now + kerberosMinSecondsBeforeRelogin);
-            subject, HADOOP_LOGIN_CONFIG);
-      start = System.currentTimeMillis();
+            subject, new HadoopConfiguration());
+      start = Time.now();
-      metrics.loginSuccess.add(System.currentTimeMillis() - start);
+      metrics.loginSuccess.add(Time.now() - start);
-        metrics.loginFailure.add(System.currentTimeMillis() - start);
+        metrics.loginFailure.add(Time.now() - start);
-    if (tgt != null && System.currentTimeMillis() < getRefreshTime(tgt)) {
+    if (tgt != null && Time.now() < getRefreshTime(tgt)) {
-    long now = System.currentTimeMillis();
+    long now = Time.now();
-            HADOOP_LOGIN_CONFIG);
+            new HadoopConfiguration());
-        start = System.currentTimeMillis();
+        start = Time.now();
-        metrics.loginSuccess.add(System.currentTimeMillis() - start);
+        metrics.loginSuccess.add(Time.now() - start);
-        metrics.loginFailure.add(System.currentTimeMillis() - start);
+        metrics.loginFailure.add(Time.now() - start);
-    long now = System.currentTimeMillis();
+    long now = Time.now();
-            getSubject(), HADOOP_LOGIN_CONFIG);
+            getSubject(), new HadoopConfiguration());
-          HADOOP_LOGIN_CONFIG);
+          new HadoopConfiguration());
-      start = System.currentTimeMillis();
+      start = Time.now();
-      metrics.loginSuccess.add(System.currentTimeMillis() - start);
+      metrics.loginSuccess.add(Time.now() - start);
-        metrics.loginFailure.add(System.currentTimeMillis() - start);
+        metrics.loginFailure.add(Time.now() - start);
-    if (now - user.getLastLogin() < MIN_TIME_BEFORE_RELOGIN ) {
+    if (now - user.getLastLogin() < kerberosMinSecondsBeforeRelogin ) {
-          "attempted less than " + (MIN_TIME_BEFORE_RELOGIN/1000) + " seconds"+
-          " before.");
+          "attempted less than " + (kerberosMinSecondsBeforeRelogin/1000) +
+          " seconds before.");
-    if (user == null || "".equals(user)) {
+    if (user == null || user.isEmpty()) {
-    if (user == null || "".equals(user)) {
+    if (user == null || user.isEmpty()) {
-    return subject.getPrivateCredentials().add(token);
+    return (token != null) ? addToken(token.getService(), token) : false;
+  }
+
+  /**
+   * Add a named token to this UGI
+   * 
+   * @param alias Name of the token
+   * @param token Token to be added
+   * @return true on successful add of new token
+   */
+  public synchronized boolean addToken(Text alias,
+                                       Token<? extends TokenIdentifier> token) {
+    getCredentialsInternal().addToken(alias, token);
+    return true;
-    Set<Object> creds = subject.getPrivateCredentials();
-    List<Token<?>> result = new ArrayList<Token<?>>(creds.size());
-    for(Object o: creds) {
-      if (o instanceof Token<?>) {
-        result.add((Token<?>) o);
-      }
+    return Collections.unmodifiableCollection(
+        getCredentialsInternal().getAllTokens());
+  }
+
+  /**
+   * Obtain the tokens in credentials form associated with this user.
+   * 
+   * @return Credentials of tokens associated with this user
+   */
+  public synchronized Credentials getCredentials() {
+    return new Credentials(getCredentialsInternal());
+  }
+  
+  /**
+   * Add the given Credentials to this user.
+   * @param credentials of tokens and secrets
+   */
+  public synchronized void addCredentials(Credentials credentials) {
+    getCredentialsInternal().addAll(credentials);
+  }
+
+  private synchronized Credentials getCredentialsInternal() {
+    final Credentials credentials;
+    final Set<Credentials> credentialsSet =
+      subject.getPrivateCredentials(Credentials.class);
+    if (!credentialsSet.isEmpty()){
+      credentials = credentialsSet.iterator().next();
+    } else {
+      credentials = new Credentials();
+      subject.getPrivateCredentials().add(credentials);
-    return Collections.unmodifiableList(result);
+    return credentials;

MOV26 MOV26 INS26 MOV23 UPD40 INS40 UPD40 UPD40 INS31 INS31 INS31 INS31 INS31 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 MOV29 MOV83 MOV83 MOV74 MOV42 INS8 INS29 INS83 INS83 INS43 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS8 UPD42 INS54 INS78 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS74 INS42 INS21 INS41 INS41 INS65 INS65 UPD42 MOV42 INS41 INS65 INS65 INS43 INS42 INS21 UPD42 MOV42 INS60 INS60 INS25 MOV41 UPD66 INS8 INS12 INS42 INS16 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS76 INS32 INS9 INS32 INS66 INS66 INS14 INS66 INS42 INS66 UPD42 MOV42 INS32 INS83 INS43 INS59 INS83 UPD74 MOV74 INS59 INS38 MOV8 MOV8 INS42 INS21 INS44 INS8 UPD42 INS36 INS32 INS9 UPD42 MOV42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS32 INS32 UPD42 MOV42 INS42 INS42 INS42 UPD43 INS42 INS32 INS32 INS21 INS21 INS7 INS43 INS42 INS53 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 INS42 INS42 INS57 INS42 INS42 INS7 INS7 MOV32 INS42 INS27 INS42 INS14 UPD42 UPD42 INS42 INS33 INS42 INS42 UPD42 MOV42 INS43 INS42 INS32 INS42 INS14 UPD42 INS34 INS32 INS43 INS27 MOV27 INS14 UPD42 UPD42 INS14 INS14 UPD42 UPD42 UPD45 UPD42 MOV42 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS32 MOV21 INS43 UPD42 UPD42 INS43 INS43 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS14 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 INS43 UPD42 UPD42 MOV14 INS14 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 INS43 INS78 INS42 INS42 UPD42 UPD42 UPD42 DEL83 DEL34 DEL34 DEL34 DEL27 DEL83 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL76 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL8 DEL70 DEL42 DEL42 DEL42 DEL42 DEL45 DEL45 DEL42 DEL45 DEL42 DEL42 DEL43 DEL76 DEL74 DEL42 DEL11 DEL32 DEL41 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL43 DEL43 DEL76 DEL74 DEL74 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL74 DEL32 DEL14 DEL59 DEL60 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL76 DEL74 DEL62 DEL25 DEL8 DEL70 DEL8 DEL31
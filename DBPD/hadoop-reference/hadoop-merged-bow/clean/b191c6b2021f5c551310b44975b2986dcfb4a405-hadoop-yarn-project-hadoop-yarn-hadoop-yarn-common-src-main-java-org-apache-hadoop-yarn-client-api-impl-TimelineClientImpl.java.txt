YARN-2928: YARN Timeline Service v.2: alpha 1 (sjlee)

For a list of commits and contributors, see the merge branch history.

+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+
-import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.yarn.api.records.ApplicationId;
+
+import com.sun.jersey.core.util.MultivaluedMapImpl;
-  private static final String RESOURCE_URI_STR = "/ws/v1/timeline/";
+  private static final String RESOURCE_URI_STR_V1 = "/ws/v1/timeline/";
+  private static final String RESOURCE_URI_STR_V2 = "/ws/v2/timeline/";
-  private URI resURI;
+  private volatile String timelineServiceAddress;
+
+  // Retry parameters for identifying new timeline service
+  // TODO consider to merge with connection retry
+  private int maxServiceRetries;
+  private long serviceRetryInterval;
+  private boolean timelineServiceV2 = false;
+
+  private TimelineEntityDispatcher entityDispatcher;
+
-    super(TimelineClientImpl.class.getName());
+    super(TimelineClientImpl.class.getName(), null);
+  }
+
+  public TimelineClientImpl(ApplicationId applicationId) {
+    super(TimelineClientImpl.class.getName(), applicationId);
+    this.timelineServiceV2 = true;
-    client.addFilter(retryFilter);
-
-    if (YarnConfiguration.useHttps(conf)) {
-      resURI = URI
-          .create(JOINER.join("https://", conf.get(
-              YarnConfiguration.TIMELINE_SERVICE_WEBAPP_HTTPS_ADDRESS,
-              YarnConfiguration.DEFAULT_TIMELINE_SERVICE_WEBAPP_HTTPS_ADDRESS),
-              RESOURCE_URI_STR));
-    } else {
-      resURI = URI.create(JOINER.join("http://", conf.get(
-          YarnConfiguration.TIMELINE_SERVICE_WEBAPP_ADDRESS,
-          YarnConfiguration.DEFAULT_TIMELINE_SERVICE_WEBAPP_ADDRESS),
-          RESOURCE_URI_STR));
+    // TODO need to cleanup filter retry later.
+    if (!timelineServiceV2) {
+      client.addFilter(retryFilter);
-    LOG.info("Timeline service address: " + resURI);
-    timelineServiceVersion =
-        conf.getFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION,
-          YarnConfiguration.DEFAULT_TIMELINE_SERVICE_VERSION);
+
+    // old version timeline service need to get address from configuration
+    // while new version need to auto discovery (with retry).
+    if (timelineServiceV2) {
+      maxServiceRetries = conf.getInt(
+          YarnConfiguration.TIMELINE_SERVICE_CLIENT_MAX_RETRIES,
+          YarnConfiguration.DEFAULT_TIMELINE_SERVICE_CLIENT_MAX_RETRIES);
+      serviceRetryInterval = conf.getLong(
+          YarnConfiguration.TIMELINE_SERVICE_CLIENT_RETRY_INTERVAL_MS,
+          YarnConfiguration.DEFAULT_TIMELINE_SERVICE_CLIENT_RETRY_INTERVAL_MS);
+      entityDispatcher = new TimelineEntityDispatcher(conf);
+    } else {
+      if (YarnConfiguration.useHttps(conf)) {
+        setTimelineServiceAddress(conf.get(
+            YarnConfiguration.TIMELINE_SERVICE_WEBAPP_HTTPS_ADDRESS,
+            YarnConfiguration.DEFAULT_TIMELINE_SERVICE_WEBAPP_HTTPS_ADDRESS));
+      } else {
+        setTimelineServiceAddress(conf.get(
+            YarnConfiguration.TIMELINE_SERVICE_WEBAPP_ADDRESS,
+            YarnConfiguration.DEFAULT_TIMELINE_SERVICE_WEBAPP_ADDRESS));
+      }
+      timelineServiceVersion =
+          conf.getFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION,
+              YarnConfiguration.DEFAULT_TIMELINE_SERVICE_VERSION);
+      LOG.info("Timeline service address: " + getTimelineServiceAddress());
+    }
-    timelineWriter = createTimelineWriter(
-        configuration, authUgi, client, resURI);
+    if (timelineServiceV2) {
+      entityDispatcher.start();
+    } else {
+      timelineWriter = createTimelineWriter(configuration, authUgi, client,
+          constructResURI(getConfig(), timelineServiceAddress, false));
+    }
+    if (timelineServiceV2) {
+      entityDispatcher.stop();
+    }
+  @Override
+  public void putEntities(
+      org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity...
+          entities) throws IOException, YarnException {
+    if (!timelineServiceV2) {
+      throw new YarnException("v.2 method is invoked on a v.1.x client");
+    }
+    entityDispatcher.dispatchEntities(true, entities);
+  }
+
+  @Override
+  public void putEntitiesAsync(
+      org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity...
+          entities) throws IOException, YarnException {
+    if (!timelineServiceV2) {
+      throw new YarnException("v.2 method is invoked on a v.1.x client");
+    }
+    entityDispatcher.dispatchEntities(false, entities);
+  }
+  // Used for new timeline service only
+  @Private
+  protected void putObjects(String path, MultivaluedMap<String, String> params,
+      Object obj) throws IOException, YarnException {
+
+    int retries = verifyRestEndPointAvailable();
+
+    // timelineServiceAddress could be stale, add retry logic here.
+    boolean needRetry = true;
+    while (needRetry) {
+      try {
+        URI uri = constructResURI(getConfig(), timelineServiceAddress, true);
+        putObjects(uri, path, params, obj);
+        needRetry = false;
+      } catch (IOException e) {
+        // handle exception for timelineServiceAddress being updated.
+        checkRetryWithSleep(retries, e);
+        retries--;
+      }
+    }
+  }
+
+  private int verifyRestEndPointAvailable() throws YarnException {
+    // timelineServiceAddress could haven't be initialized yet
+    // or stale (only for new timeline service)
+    int retries = pollTimelineServiceAddress(this.maxServiceRetries);
+    if (timelineServiceAddress == null) {
+      String errMessage = "TimelineClient has reached to max retry times : "
+          + this.maxServiceRetries
+          + ", but failed to fetch timeline service address. Please verify"
+          + " Timeline Auxillary Service is configured in all the NMs";
+      LOG.error(errMessage);
+      throw new YarnException(errMessage);
+    }
+    return retries;
+  }
+
+  /**
+   * Check if reaching to maximum of retries.
+   * @param retries
+   * @param e
+   */
+  private void checkRetryWithSleep(int retries, IOException e)
+      throws YarnException, IOException {
+    if (retries > 0) {
+      try {
+        Thread.sleep(this.serviceRetryInterval);
+      } catch (InterruptedException ex) {
+        Thread.currentThread().interrupt();
+        throw new YarnException("Interrupted while retrying to connect to ATS");
+      }
+    } else {
+      StringBuilder msg =
+          new StringBuilder("TimelineClient has reached to max retry times : ");
+      msg.append(this.maxServiceRetries);
+      msg.append(" for service address: ");
+      msg.append(timelineServiceAddress);
+      LOG.error(msg.toString());
+      throw new IOException(msg.toString(), e);
+    }
+  }
+
+  protected void putObjects(
+      URI base, String path, MultivaluedMap<String, String> params, Object obj)
+          throws IOException, YarnException {
+    ClientResponse resp;
+    try {
+      resp = client.resource(base).path(path).queryParams(params)
+          .accept(MediaType.APPLICATION_JSON)
+          .type(MediaType.APPLICATION_JSON)
+          .put(ClientResponse.class, obj);
+    } catch (RuntimeException re) {
+      // runtime exception is expected if the client cannot connect the server
+      String msg =
+          "Failed to get the response from the timeline server.";
+      LOG.error(msg, re);
+      throw new IOException(re);
+    }
+    if (resp == null ||
+        resp.getStatusInfo().getStatusCode() !=
+            ClientResponse.Status.OK.getStatusCode()) {
+      String msg = "Response from the timeline server is " +
+          ((resp == null) ? "null":
+          "not successful," + " HTTP error code: " + resp.getStatus()
+          + ", Server response:\n" + resp.getEntity(String.class));
+      LOG.error(msg);
+      throw new YarnException(msg);
+    }
+  }
+
+  @Override
+  public void setTimelineServiceAddress(String address) {
+    this.timelineServiceAddress = address;
+  }
+
+  private String getTimelineServiceAddress() {
+    return this.timelineServiceAddress;
+  }
+
-    PrivilegedExceptionAction<Token<TimelineDelegationTokenIdentifier>> getDTAction =
+    PrivilegedExceptionAction<Token<TimelineDelegationTokenIdentifier>>
+        getDTAction =
+            // TODO we should add retry logic here if timelineServiceAddress is
+            // not available immediately.
-                resURI.toURL(), token, renewer, doAsUser);
+                constructResURI(getConfig(),
+                    getTimelineServiceAddress(), false).toURL(),
+                token, renewer, doAsUser);
-            // Token to set every time for retry, because when exception happens,
-            // DelegationTokenAuthenticatedURL will reset it to null;
+            // Token to set every time for retry, because when exception
+            // happens, DelegationTokenAuthenticatedURL will reset it to null;
-            final URI serviceURI = isTokenServiceAddrEmpty ? resURI
+            final URI serviceURI = isTokenServiceAddrEmpty ?
+                constructResURI(getConfig(), getTimelineServiceAddress(), false)
-                address.getPort(), RESOURCE_URI_STR, null, null);
+                address.getPort(), RESOURCE_URI_STR_V1, null, null);
-            // If the timeline DT to cancel is different than cached, replace it.
-            // Token to set every time for retry, because when exception happens,
-            // DelegationTokenAuthenticatedURL will reset it to null;
+            // If the timeline DT to cancel is different than cached, replace
+            // it.
+            // Token to set every time for retry, because when exception
+            // happens, DelegationTokenAuthenticatedURL will reset it to null;
-            final URI serviceURI = isTokenServiceAddrEmpty ? resURI
+            final URI serviceURI = isTokenServiceAddrEmpty ?
+                constructResURI(getConfig(), getTimelineServiceAddress(), false)
-                address.getPort(), RESOURCE_URI_STR, null, null);
+                address.getPort(), RESOURCE_URI_STR_V1, null, null);
-    return super.toString() + " with timeline server " + resURI
+    return super.toString() + " with timeline server "
+        + constructResURI(getConfig(), getTimelineServiceAddress(), false)
+  /**
+   * Poll TimelineServiceAddress for maximum of retries times if it is null.
+   *
+   * @param retries
+   * @return the left retry times
+   * @throws IOException
+   */
+  private int pollTimelineServiceAddress(int retries) throws YarnException {
+    while (timelineServiceAddress == null && retries > 0) {
+      try {
+        Thread.sleep(this.serviceRetryInterval);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        throw new YarnException("Interrupted while trying to connect ATS");
+      }
+      retries--;
+    }
+    return retries;
+  }
+
+  private static URI constructResURI(
+      Configuration conf, String address, boolean v2) {
+    return URI.create(
+        JOINER.join(YarnConfiguration.useHttps(conf) ? "https://" : "http://",
+            address, v2 ? RESOURCE_URI_STR_V2 : RESOURCE_URI_STR_V1));
+  }
+
+  private final class EntitiesHolder extends FutureTask<Void> {
+    private final
+        org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntities
+            entities;
+    private final boolean isSync;
+
+    EntitiesHolder(
+        final
+            org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntities
+                entities,
+        final boolean isSync) {
+      super(new Callable<Void>() {
+        // publishEntities()
+        public Void call() throws Exception {
+          MultivaluedMap<String, String> params = new MultivaluedMapImpl();
+          params.add("appid", getContextAppId().toString());
+          params.add("async", Boolean.toString(!isSync));
+          putObjects("entities", params, entities);
+          return null;
+        }
+      });
+      this.entities = entities;
+      this.isSync = isSync;
+    }
+
+    public boolean isSync() {
+      return isSync;
+    }
+
+    public org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntities
+        getEntities() {
+      return entities;
+    }
+  }
+
+  /**
+   * This class is responsible for collecting the timeline entities and
+   * publishing them in async.
+   */
+  private class TimelineEntityDispatcher {
+    /**
+     * Time period for which the timelineclient will wait for draining after
+     * stop.
+     */
+    private static final long DRAIN_TIME_PERIOD = 2000L;
+
+    private int numberOfAsyncsToMerge;
+    private final BlockingQueue<EntitiesHolder> timelineEntityQueue;
+    private ExecutorService executor;
+
+    TimelineEntityDispatcher(Configuration conf) {
+      timelineEntityQueue = new LinkedBlockingQueue<EntitiesHolder>();
+      numberOfAsyncsToMerge =
+          conf.getInt(YarnConfiguration.NUMBER_OF_ASYNC_ENTITIES_TO_MERGE,
+              YarnConfiguration.DEFAULT_NUMBER_OF_ASYNC_ENTITIES_TO_MERGE);
+    }
+
+    Runnable createRunnable() {
+      return new Runnable() {
+        @Override
+        public void run() {
+          try {
+            EntitiesHolder entitiesHolder;
+            while (!Thread.currentThread().isInterrupted()) {
+              // Merge all the async calls and make one push, but if its sync
+              // call push immediately
+              try {
+                entitiesHolder = timelineEntityQueue.take();
+              } catch (InterruptedException ie) {
+                LOG.info("Timeline dispatcher thread was interrupted ");
+                Thread.currentThread().interrupt();
+                return;
+              }
+              if (entitiesHolder != null) {
+                publishWithoutBlockingOnQueue(entitiesHolder);
+              }
+            }
+          } finally {
+            if (!timelineEntityQueue.isEmpty()) {
+              LOG.info("Yet to publish " + timelineEntityQueue.size()
+                  + " timelineEntities, draining them now. ");
+            }
+            // Try to drain the remaining entities to be published @ the max for
+            // 2 seconds
+            long timeTillweDrain =
+                System.currentTimeMillis() + DRAIN_TIME_PERIOD;
+            while (!timelineEntityQueue.isEmpty()) {
+              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());
+              if (System.currentTimeMillis() > timeTillweDrain) {
+                // time elapsed stop publishing further....
+                if (!timelineEntityQueue.isEmpty()) {
+                  LOG.warn("Time to drain elapsed! Remaining "
+                      + timelineEntityQueue.size() + "timelineEntities will not"
+                      + " be published");
+                  // if some entities were not drained then we need interrupt
+                  // the threads which had put sync EntityHolders to the queue.
+                  EntitiesHolder nextEntityInTheQueue = null;
+                  while ((nextEntityInTheQueue =
+                      timelineEntityQueue.poll()) != null) {
+                    nextEntityInTheQueue.cancel(true);
+                  }
+                }
+                break;
+              }
+            }
+          }
+        }
+
+        /**
+         * Publishes the given EntitiesHolder and return immediately if sync
+         * call, else tries to fetch the EntitiesHolder from the queue in non
+         * blocking fashion and collate the Entities if possible before
+         * publishing through REST.
+         *
+         * @param entitiesHolder
+         */
+        private void publishWithoutBlockingOnQueue(
+            EntitiesHolder entitiesHolder) {
+          if (entitiesHolder.isSync()) {
+            entitiesHolder.run();
+            return;
+          }
+          int count = 1;
+          while (true) {
+            // loop till we find a sync put Entities or there is nothing
+            // to take
+            EntitiesHolder nextEntityInTheQueue = timelineEntityQueue.poll();
+            if (nextEntityInTheQueue == null) {
+              // Nothing in the queue just publish and get back to the
+              // blocked wait state
+              entitiesHolder.run();
+              break;
+            } else if (nextEntityInTheQueue.isSync()) {
+              // flush all the prev async entities first
+              entitiesHolder.run();
+              // and then flush the sync entity
+              nextEntityInTheQueue.run();
+              break;
+            } else {
+              // append all async entities together and then flush
+              entitiesHolder.getEntities().addEntities(
+                  nextEntityInTheQueue.getEntities().getEntities());
+              count++;
+              if (count == numberOfAsyncsToMerge) {
+                // Flush the entities if the number of the async
+                // putEntites merged reaches the desired limit. To avoid
+                // collecting multiple entities and delaying for a long
+                // time.
+                entitiesHolder.run();
+                break;
+              }
+            }
+          }
+        }
+      };
+    }
+
+    public void dispatchEntities(boolean sync,
+        org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity[]
+            entitiesTobePublished) throws YarnException {
+      if (executor.isShutdown()) {
+        throw new YarnException("Timeline client is in the process of stopping,"
+            + " not accepting any more TimelineEntities");
+      }
+
+      // wrap all TimelineEntity into TimelineEntities object
+      org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntities
+          entities =
+              new org.apache.hadoop.yarn.api.records.timelineservice.
+                  TimelineEntities();
+      for (org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity
+               entity : entitiesTobePublished) {
+        entities.addEntity(entity);
+      }
+
+      // created a holder and place it in queue
+      EntitiesHolder entitiesHolder = new EntitiesHolder(entities, sync);
+      try {
+        timelineEntityQueue.put(entitiesHolder);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        throw new YarnException(
+            "Failed while adding entity to the queue for publishing", e);
+      }
+
+      if (sync) {
+        // In sync call we need to wait till its published and if any error then
+        // throw it back
+        try {
+          entitiesHolder.get();
+        } catch (ExecutionException e) {
+          throw new YarnException("Failed while publishing entity",
+              e.getCause());
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          throw new YarnException("Interrupted while publishing entity", e);
+        }
+      }
+    }
+
+    public void start() {
+      executor = Executors.newSingleThreadExecutor();
+      executor.execute(createRunnable());
+    }
+
+    public void stop() {
+      LOG.info("Stopping TimelineClient.");
+      executor.shutdownNow();
+      try {
+        executor.awaitTermination(DRAIN_TIME_PERIOD, TimeUnit.MILLISECONDS);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        e.printStackTrace();
+      }
+    }
+  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS55 INS83 INS83 INS43 INS83 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS83 INS83 INS42 INS74 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS42 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 UPD42 INS42 UPD42 INS45 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS43 INS42 INS46 INS21 INS25 INS25 INS25 INS25 INS42 INS43 INS42 INS42 INS42 INS25 INS21 INS42 INS43 INS42 INS42 INS42 INS25 INS21 INS42 INS43 INS42 INS74 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS61 INS42 INS60 INS25 INS41 INS65 INS65 INS65 INS39 INS42 INS43 INS42 INS42 INS42 INS25 MOV43 INS42 INS43 INS42 INS74 INS42 INS43 INS42 INS42 INS42 INS60 INS54 INS25 INS42 INS43 INS42 INS21 INS42 INS41 INS65 INS65 INS65 INS65 INS39 INS42 INS42 INS61 INS41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS41 INS43 INS43 INS83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS43 INS42 INS8 INS65 INS29 INS83 INS83 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS83 INS74 INS59 INS83 INS43 INS59 INS42 INS44 INS8 INS43 INS42 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS33 INS42 INS32 INS42 INS7 INS38 INS8 INS42 INS8 INS8 INS42 INS8 INS8 INS42 INS8 INS40 INS38 INS8 INS32 INS40 INS38 INS8 INS32 INS42 INS43 INS43 INS43 INS42 INS39 INS59 INS39 INS59 INS42 INS8 INS39 INS59 INS27 INS8 INS42 INS66 INS42 INS42 INS42 INS27 INS8 INS8 INS42 INS43 INS43 INS43 INS42 INS43 INS59 INS8 INS12 INS27 INS8 INS42 INS7 INS22 INS66 INS42 INS66 INS42 INS27 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS46 INS21 INS21 INS41 INS40 INS41 INS66 INS66 INS65 INS42 INS34 INS42 INS43 INS43 INS42 INS42 INS42 INS43 INS42 INS21 INS21 INS42 INS41 INS39 INS42 INS5 INS42 INS42 INS25 INS60 INS70 INS60 INS54 INS25 INS21 INS21 INS21 INS21 INS54 INS57 INS42 INS22 INS9 INS42 MOV21 INS21 INS21 INS21 MOV25 MOV21 MOV21 INS21 MOV21 INS21 INS42 INS53 INS42 INS42 INS9 INS42 INS42 INS53 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS9 INS54 INS42 INS32 INS42 INS33 INS60 INS21 INS53 INS42 INS34 INS54 INS60 INS21 INS21 INS21 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS27 INS27 INS60 INS21 INS53 INS22 INS42 INS52 INS42 INS32 INS27 INS27 INS54 INS21 INS42 INS42 INS32 INS40 INS14 INS7 INS7 INS42 INS42 INS66 INS66 INS42 INS42 INS42 INS7 INS7 INS14 INS43 INS85 INS32 INS8 INS43 INS59 INS44 INS42 INS8 INS43 INS59 INS8 INS12 INS42 INS8 INS7 INS32 INS32 INS32 INS8 INS12 INS43 INS52 INS42 INS7 INS7 INS7 INS32 INS32 INS14 INS14 INS42 INS8 INS12 INS42 INS22 INS43 INS59 INS32 INS14 INS8 INS12 INS43 INS59 INS32 INS32 INS32 INS32 INS14 INS7 INS43 INS42 INS60 INS21 INS53 INS42 INS33 INS32 INS32 INS43 INS59 INS32 INS14 INS52 INS42 INS42 INS32 INS32 INS9 INS42 INS33 INS42 INS34 INS8 INS12 INS37 INS42 INS42 INS16 INS42 INS16 INS74 INS1 INS22 INS42 INS22 INS42 INS42 INS14 INS42 INS32 INS43 INS1 INS40 INS42 INS42 INS53 INS40 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS14 INS21 INS44 INS8 INS54 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS45 INS43 INS45 INS60 INS21 INS21 INS44 INS8 INS52 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS21 INS44 INS8 INS42 INS42 INS14 INS42 INS42 INS22 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS32 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS32 INS42 INS40 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS32 INS45 INS45 INS42 INS42 INS42 INS43 INS43 INS31 INS52 INS42 INS52 INS42 INS74 INS42 INS42 INS40 INS40 INS42 INS31 INS31 INS14 INS43 INS40 INS32 INS43 INS42 INS42 INS32 INS43 INS42 INS21 INS53 INS8 INS12 INS12 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS21 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS40 INS43 INS42 MOV32 MOV32 INS32 INS32 INS42 INS42 MOV43 INS59 INS32 INS7 INS43 INS42 INS21 INS21 INS45 INS22 INS45 INS45 INS42 INS32 INS43 INS42 INS21 INS53 INS43 INS45 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS57 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS45 INS36 INS42 INS32 INS43 INS42 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS83 INS43 INS42 INS43 INS8 INS43 INS43 INS78 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS43 INS27 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS14 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS42 INS40 INS42 INS32 INS32 INS42 UPD42 UPD42 INS42 UPD42 MOV42 INS32 INS42 INS9 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS37 INS52 INS42 INS42 INS42 INS22 INS42 INS32 INS14 INS42 INS32 INS42 INS40 INS43 INS42 INS16 INS60 MOV60 INS42 INS42 INS22 INS42 INS32 INS14 INS42 INS42 INS60 INS21 INS21 INS21 INS41 INS42 INS42 INS42 INS54 INS65 INS65 INS43 INS42 INS25 INS60 INS61 INS42 INS45 INS45 INS32 INS42 INS43 INS45 INS42 INS32 INS43 INS42 INS53 INS43 INS42 INS21 INS53 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS9 INS42 INS42 INS42 INS42 INS52 INS42 INS32 INS42 INS43 INS45 INS32 INS42 INS40 INS42 INS36 INS45 INS27 INS83 MOV43 INS59 INS52 INS42 INS32 INS42 INS43 INS45 INS74 INS59 INS32 INS32 INS32 INS33 INS8 INS8 INS66 INS66 INS66 INS66 INS42 INS42 INS32 INS8 INS39 INS59 INS9 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS27 INS32 INS45 INS32 INS42 INS16 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS32 INS42 INS45 INS42 INS42 INS60 INS61 INS25 INS60 INS61 INS42 INS42 INS21 INS41 INS42 INS34 INS60 INS25 INS43 INS45 INS32 INS32 INS42 INS43 INS45 INS42 INS32 INS42 INS42 INS42 INS33 INS45 INS45 INS42 INS42 INS42 INS42 INS57 INS42 INS32 INS14 INS32 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS38 INS43 INS59 INS38 INS8 INS38 INS8 INS39 INS59 INS38 INS8 INS32 INS43 INS59 INS27 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS32 INS32 INS9 MOV43 INS42 INS33 MOV32 MOV32 INS42 INS33 INS33 INS42 INS32 INS32 INS9 INS43 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS54 INS25 INS32 INS21 INS42 INS27 INS32 INS21 INS25 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS10 INS32 INS8 INS8 INS42 UPD42 MOV42 INS32 INS32 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS8 INS12 INS27 INS8 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS21 INS21 INS10 INS21 INS21 INS25 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS33 INS21 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS32 INS42 INS25 INS10 INS42 INS42 INS32 INS32 INS32 INS37 INS27 INS8 INS7 INS43 INS42 INS21 INS21 INS41 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS38 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS21 INS10 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS21 INS60 INS61 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS33 INS36 INS33 INS21 INS45 INS32 INS45 INS45 INS7 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL42 DEL8 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL33 DEL33 DEL14 DEL16 DEL59 DEL60 DEL42
HDFS-2147. Move cluster network topology to block management and fix some javac warnings.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1148112 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.net.Node;
-  // Default initial capacity and load factor of map
-  public static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;
+  static final Log LOG = LogFactory.getLog(BlockManager.class);
+
+  /** Default load factor of map */
-  CorruptReplicasMap corruptReplicas = new CorruptReplicasMap();
+  private final CorruptReplicasMap corruptReplicas = new CorruptReplicasMap();
-  Map<String, Collection<Block>> recentInvalidateSets =
+  private final Map<String, Collection<Block>> recentInvalidateSets =
-  public UnderReplicatedBlocks neededReplications = new UnderReplicatedBlocks();
-  private PendingReplicationBlocks pendingReplications;
+  public final UnderReplicatedBlocks neededReplications = new UnderReplicatedBlocks();
+  private final PendingReplicationBlocks pendingReplications;
-  public int maxReplication;
+  public final int maxReplication;
-  public int minReplication;
+  public final int minReplication;
-  public int defaultReplication;
+  public final int defaultReplication;
-  int maxCorruptFilesReturned;
+  final int maxCorruptFilesReturned;
-  boolean shouldCheckForEnoughRacks = true;
+  final boolean shouldCheckForEnoughRacks;
-  public BlockPlacementPolicy replicator;
+  public final BlockPlacementPolicy replicator;
-    this(fsn, conf, DEFAULT_INITIAL_MAP_CAPACITY);
-  }
-  
-  BlockManager(FSNamesystem fsn, Configuration conf, int capacity)
-      throws IOException {
+    datanodeManager = new DatanodeManager(fsn);
+
+    blocksMap = new BlocksMap(DEFAULT_MAP_LOAD_FACTOR);
+    replicator = BlockPlacementPolicy.getInstance(
+        conf, namesystem, datanodeManager.getNetworkTopology());
-    setConfigurationParameters(conf);
-    blocksMap = new BlocksMap(capacity, DEFAULT_MAP_LOAD_FACTOR);
-    datanodeManager = new DatanodeManager(fsn);
-  }
-
-  void setConfigurationParameters(Configuration conf) throws IOException {
-    this.replicator = BlockPlacementPolicy.getInstance(
-                         conf,
-                         namesystem,
-                         namesystem.clusterMap);
+  /** Remove a datanode. */
+  public void removeDatanode(final DatanodeDescriptor node) {
+    final Iterator<? extends Block> it = node.getBlockIterator();
+    while(it.hasNext()) {
+      removeStoredBlock(it.next(), node);
+    }
+
+    node.resetBlocks();
+    removeFromInvalidates(node.getStorageID());
+    datanodeManager.getNetworkTopology().remove(node);
+
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("remove datanode " + node.getName());
+    }
+  }
+  
+   * Choose target datanodes according to the replication policy.
+   * @throws IOException if the number of targets < minimum replication.
+   * @see BlockPlacementPolicy#chooseTarget(String, int, DatanodeDescriptor, HashMap, long)
+   */
+  public DatanodeDescriptor[] chooseTarget(final String src,
+      final int numOfReplicas, final DatanodeDescriptor client,
+      final HashMap<Node, Node> excludedNodes,
+      final long blocksize) throws IOException {
+    // choose targets for the new block to be allocated.
+    final DatanodeDescriptor targets[] = replicator.chooseTarget(
+        src, numOfReplicas, client, excludedNodes, blocksize);
+    if (targets.length < minReplication) {
+      throw new IOException("File " + src + " could only be replicated to " +
+                            targets.length + " nodes, instead of " +
+                            minReplication + ". There are "
+                            + getDatanodeManager().getNetworkTopology().getNumOfLeaves()
+                            + " datanode(s) running but "+excludedNodes.size() +
+                            " node(s) are excluded in this operation.");
+    }
+    return targets;
+  }
+
+  /**

INS26 INS26 INS26 INS26 MOV31 MOV31 INS40 INS40 INS40 INS40 INS43 INS29 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 UPD42 MOV44 INS29 INS39 UPD42 INS8 INS29 INS83 INS5 INS42 INS44 INS44 INS44 INS42 UPD42 INS32 INS65 MOV21 MOV21 MOV21 MOV21 INS65 INS83 UPD43 UPD42 INS60 INS61 INS21 INS21 INS21 INS25 INS65 INS65 INS65 INS43 INS85 INS83 UPD43 UPD42 INS83 UPD42 INS83 INS43 INS42 INS83 INS74 INS42 INS83 INS39 INS42 INS60 INS25 INS41 INS42 INS42 INS57 INS66 INS66 UPD42 INS83 INS74 INS59 INS32 INS8 INS32 INS32 INS32 INS32 INS8 INS66 INS42 INS66 INS68 INS42 UPD42 INS42 INS43 INS43 INS43 INS83 INS43 INS59 INS27 INS8 INS42 INS43 INS42 INS43 INS76 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS69 INS69 INS69 INS69 INS69 INS42 INS42 INS42 INS42 INS42 INS85 INS32 INS40 INS42 INS53 INS42 INS32 UPD42 MOV42 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS39 INS43 INS43 INS39 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 MOV43 INS27 INS42 INS42 INS45 INS32 INS45 INS42 INS45 INS40 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 DEL83 DEL39 DEL34 DEL9 DEL39 DEL42 DEL52 DEL42 DEL22 DEL40 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL17 DEL8 DEL42 DEL32 DEL21
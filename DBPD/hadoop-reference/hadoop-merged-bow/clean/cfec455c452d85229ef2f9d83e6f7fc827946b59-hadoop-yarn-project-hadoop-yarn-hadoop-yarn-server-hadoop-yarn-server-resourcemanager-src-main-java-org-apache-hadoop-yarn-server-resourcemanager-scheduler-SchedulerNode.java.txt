YARN-999. In case of long running tasks, reduce node resource should balloon out resource quickly by calling preemption API and suspending running task. Contributed by Inigo Goiri.

+import java.util.Collections;
+import org.apache.commons.lang3.builder.CompareToBuilder;
+  /** Time stamp for overcommitted resources to time out. */
+  private long overcommitTimeout = -1;
+   * Set the timeout for the node to stop overcommitting the resources. After
+   * this time the scheduler will start killing containers until the resources
+   * are not overcommitted anymore. This may reset a previous timeout.
+   * @param timeOut Time out in milliseconds.
+   */
+  public synchronized void setOvercommitTimeOut(long timeOut) {
+    if (timeOut >= 0) {
+      if (this.overcommitTimeout != -1) {
+        LOG.debug("The overcommit timeout for {} was already set to {}",
+            getNodeID(), this.overcommitTimeout);
+      }
+      this.overcommitTimeout = Time.now() + timeOut;
+    }
+  }
+
+  /**
+   * Check if the time out has passed.
+   * @return If the node is overcommitted.
+   */
+  public synchronized boolean isOvercommitTimedOut() {
+    return this.overcommitTimeout >= 0 && Time.now() >= this.overcommitTimeout;
+  }
+
+  /**
+   * Check if the node has a time out for overcommit resources.
+   * @return If the node has a time out for overcommit resources.
+   */
+  public synchronized boolean isOvercommitTimeOutSet() {
+    return this.overcommitTimeout >= 0;
+  }
+
+  /**
+   * Get the containers running on the node ordered by which to kill first. It
+   * tries to kill AMs last, then GUARANTEED containers, and it kills
+   * OPPORTUNISTIC first. If the same time, it uses the creation time.
+   * @return A copy of the running containers ordered by which to kill first.
+   */
+  public List<RMContainer> getContainersToKill() {
+    List<RMContainer> result = getLaunchedContainers();
+    Collections.sort(result, (c1, c2) -> {
+      return new CompareToBuilder()
+          .append(c1.isAMContainer(), c2.isAMContainer())
+          .append(c2.getExecutionType(), c1.getExecutionType()) // reversed
+          .append(c2.getCreationTime(), c1.getCreationTime()) // reversed
+          .toComparison();
+    });
+    return result;
+  }
+
+  /**
+   * Get the launched containers in the node.
+   * @return List of launched containers.
+   */
+  protected synchronized List<RMContainer> getLaunchedContainers() {
+    List<RMContainer> result = new ArrayList<>();
+    for (ContainerInfo info : launchedContainers.values()) {
+      result.add(info.container);
+    }
+    return result;
+  }
+
+  /**

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS74 INS42 INS8 INS29 INS83 INS83 INS74 INS42 INS8 INS65 INS42 INS38 INS65 INS65 INS39 INS42 INS25 INS65 INS65 INS41 INS65 INS65 INS41 INS65 INS65 INS43 INS43 INS60 INS21 INS41 INS65 INS65 INS43 INS43 INS60 INS70 INS41 INS66 INS34 INS66 INS66 INS66 INS42 INS66 INS27 INS8 INS66 INS66 INS27 INS66 INS66 INS27 INS66 INS66 INS66 INS66 INS42 INS42 INS74 INS59 INS32 INS42 INS66 INS66 INS42 INS42 INS74 INS59 INS44 INS32 INS8 INS42 INS42 INS34 INS25 INS21 INS27 INS27 INS22 INS34 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS86 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS42 INS21 INS27 INS8 INS7 INS22 INS34 INS32 INS22 INS52 INS42 INS42 INS42 INS42 INS59 INS59 INS8 INS42 INS42 INS74 INS42 INS32 INS22 INS38 INS21 INS22 INS27 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS41 INS43 INS42 INS42 INS40 INS52 INS42 INS34 INS32 INS52 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS45 INS32 INS22 INS42 INS42 INS32 INS42 INS42 INS52 INS42 INS32 INS42 INS32 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42
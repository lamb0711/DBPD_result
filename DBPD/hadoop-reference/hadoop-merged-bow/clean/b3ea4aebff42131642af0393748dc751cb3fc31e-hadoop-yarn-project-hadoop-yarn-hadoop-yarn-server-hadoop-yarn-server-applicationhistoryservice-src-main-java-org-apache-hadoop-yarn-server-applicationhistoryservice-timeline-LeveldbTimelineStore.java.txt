YARN-1717. Enabled periodically discarding old data in LeveldbTimelineStore. Contributed by Billie Rinaldi.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577693 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import org.iq80.leveldb.ReadOptions;
+import org.iq80.leveldb.WriteOptions;
- * An implementation of a timeline store backed by leveldb.
+ * <p>An implementation of an application timeline store backed by leveldb.</p>
+ *
+ * <p>There are three sections of the db, the start time section,
+ * the entity section, and the indexed entity section.</p>
+ *
+ * <p>The start time section is used to retrieve the unique start time for
+ * a given entity. Its values each contain a start time while its keys are of
+ * the form:</p>
+ * <pre>
+ *   START_TIME_LOOKUP_PREFIX + entity type + entity id</pre>
+ *
+ * <p>The entity section is ordered by entity type, then entity start time
+ * descending, then entity ID. There are four sub-sections of the entity
+ * section: events, primary filters, related entities,
+ * and other info. The event entries have event info serialized into their
+ * values. The other info entries have values corresponding to the values of
+ * the other info name/value map for the entry (note the names are contained
+ * in the key). All other entries have empty values. The key structure is as
+ * follows:</p>
+ * <pre>
+ *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id
+ *
+ *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +
+ *     EVENTS_COLUMN + reveventtimestamp + eventtype
+ *
+ *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +
+ *     PRIMARY_FILTERS_COLUMN + name + value
+ *
+ *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +
+ *     OTHER_INFO_COLUMN + name
+ *
+ *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +
+ *     RELATED_ENTITIES_COLUMN + relatedentity type + relatedentity id
+ *
+ *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +
+ *     INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN + relatedentity type +
+ *     relatedentity id</pre>
+ *
+ * <p>The indexed entity section contains a primary filter name and primary
+ * filter value as the prefix. Within a given name/value, entire entity
+ * entries are stored in the same format as described in the entity section
+ * above (below, "key" represents any one of the possible entity entry keys
+ * described above).</p>
+ * <pre>
+ *   INDEXED_ENTRY_PREFIX + primaryfilter name + primaryfilter value +
+ *     key</pre>
-  private static final byte[] PRIMARY_FILTER_COLUMN = "f".getBytes();
+  private static final byte[] EVENTS_COLUMN = "e".getBytes();
+  private static final byte[] PRIMARY_FILTERS_COLUMN = "f".getBytes();
-  private static final byte[] RELATED_COLUMN = "r".getBytes();
-  private static final byte[] TIME_COLUMN = "t".getBytes();
+  private static final byte[] RELATED_ENTITIES_COLUMN = "r".getBytes();
+  private static final byte[] INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN =
+      "z".getBytes();
-  private static final int DEFAULT_START_TIME_READ_CACHE_SIZE = 10000;
-  private static final int DEFAULT_START_TIME_WRITE_CACHE_SIZE = 10000;
-
+  private final ReentrantReadWriteLock deleteLock =
+      new ReentrantReadWriteLock();
+
+  private Thread deletionThread;
+
+    options.cacheSize(conf.getLong(
+        YarnConfiguration.TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,
+        YarnConfiguration.DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE));
-    if (!p.exists())
-      if (!p.mkdirs())
+    if (!p.exists()) {
+      if (!p.mkdirs()) {
+      }
+    }
+
+    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_TTL_ENABLE, true)) {
+      deletionThread = new EntityDeletionThread(conf);
+      deletionThread.start();
+    }
+
+    if (deletionThread != null) {
+      deletionThread.interrupt();
+      LOG.info("Waiting for deletion thread to complete its current action");
+      try {
+        deletionThread.join();
+      } catch (InterruptedException e) {
+        LOG.warn("Interrupted while waiting for deletion thread to complete," +
+            " closing db now", e);
+      }
+    }
+  private class EntityDeletionThread extends Thread {
+    private final long ttl;
+    private final long ttlInterval;
+
+    public EntityDeletionThread(Configuration conf) {
+      ttl  = conf.getLong(YarnConfiguration.TIMELINE_SERVICE_TTL_MS,
+          YarnConfiguration.DEFAULT_TIMELINE_SERVICE_TTL_MS);
+      ttlInterval = conf.getLong(
+          YarnConfiguration.TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS,
+          YarnConfiguration.DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS);
+      LOG.info("Starting deletion thread with ttl " + ttl + " and cycle " +
+          "interval " + ttlInterval);
+    }
+
+    @Override
+    public void run() {
+      while (true) {
+        long timestamp = System.currentTimeMillis() - ttl;
+        try {
+          discardOldEntities(timestamp);
+          Thread.sleep(ttlInterval);
+        } catch (IOException e) {
+          LOG.error(e);
+        } catch (InterruptedException e) {
+          LOG.info("Deletion thread received interrupt, exiting");
+          break;
+        }
+      }
+    }
+  }
+
+      private static final long serialVersionUID = 1L;
-      if (sep)
+      if (sep) {
+      }
-        if (i < index-1 && useSeparator[i])
+        if (i < index-1 && useSeparator[i]) {
+        }
-        if (useSeparator[i])
+        if (useSeparator[i]) {
+        }
-      if (offset >= b.length)
+      if (offset >= b.length) {
+      }
-      while (offset+i < b.length && b[offset+i] != 0x0)
+      while (offset+i < b.length && b[offset+i] != 0x0) {
+      }
-      if (offset+8 >= b.length)
+      if (offset+8 >= b.length) {
+      }
+    Long revStartTime = getStartTimeLong(entityId, entityType);
+    if (revStartTime == null) {
+      return null;
+    }
+    byte[] prefix = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)
+        .add(entityType).add(writeReverseOrderedLong(revStartTime))
+        .add(entityId).getBytesForLookup();
+
-      byte[] revStartTime = getStartTime(entityId, entityType);
-      if (revStartTime == null)
-        return null;
-      byte[] prefix = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)
-          .add(entityType).add(revStartTime).add(entityId).getBytesForLookup();
-
-      return getEntity(entityId, entityType,
-          readReverseOrderedLong(revStartTime, 0), fields, iterator, prefix,
-          prefix.length);
+      return getEntity(entityId, entityType, revStartTime, fields, iterator,
+          prefix, prefix.length);
-    if (fields == null)
+    if (fields == null) {
+    }
-      entity.setEvents(new ArrayList<TimelineEvent>());
-      entity.setEvents(new ArrayList<TimelineEvent>());
-    }
-    else {
+    } else {
-      entity.setOtherInfo(new HashMap<String, Object>());
-      if (!prefixMatches(prefix, prefixlen, key))
+      if (!prefixMatches(prefix, prefixlen, key)) {
-      if (key[prefixlen] == PRIMARY_FILTER_COLUMN[0]) {
+      }
+      if (key.length == prefixlen) {
+        continue;
+      }
+      if (key[prefixlen] == PRIMARY_FILTERS_COLUMN[0]) {
-              prefixlen + PRIMARY_FILTER_COLUMN.length);
+              prefixlen + PRIMARY_FILTERS_COLUMN.length);
-      } else if (key[prefixlen] == RELATED_COLUMN[0]) {
+      } else if (key[prefixlen] == RELATED_ENTITIES_COLUMN[0]) {
-              prefixlen + RELATED_COLUMN.length);
+              prefixlen + RELATED_ENTITIES_COLUMN.length);
-      } else if (key[prefixlen] == TIME_COLUMN[0]) {
-        if (events || (lastEvent && entity.getEvents().size() == 0)) {
+      } else if (key[prefixlen] == EVENTS_COLUMN[0]) {
+        if (events || (lastEvent &&
+            entity.getEvents().size() == 0)) {
-              TIME_COLUMN.length, iterator.peekNext().getValue());
+              EVENTS_COLUMN.length, iterator.peekNext().getValue());
-        LOG.warn(String.format("Found unexpected column for entity %s of " +
-            "type %s (0x%02x)", entityId, entityType, key[prefixlen]));
+        if (key[prefixlen] !=
+            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {
+          LOG.warn(String.format("Found unexpected column for entity %s of " +
+              "type %s (0x%02x)", entityId, entityType, key[prefixlen]));
+        }
-    if (entityIds == null || entityIds.isEmpty())
+    if (entityIds == null || entityIds.isEmpty()) {
+    }
-      for (String entity : entityIds) {
-        byte[] startTime = getStartTime(entity, entityType);
+      for (String entityId : entityIds) {
+        byte[] startTime = getStartTime(entityId, entityType);
-          entities.add(new EntityIdentifier(entity, entityType));
+          entities.add(new EntityIdentifier(entityId, entityType));
-        for (EntityIdentifier entityID : entry.getValue()) {
+        for (EntityIdentifier entityIdentifier : entry.getValue()) {
-          entity.setEntityId(entityID.getId());
+          entity.setEntityId(entityIdentifier.getId());
-              .add(entityType).add(revStartTime).add(entityID.getId())
-              .add(TIME_COLUMN);
+              .add(entityType).add(revStartTime).add(entityIdentifier.getId())
+              .add(EVENTS_COLUMN);
-                    last.length) > 0))
+                    last.length) > 0)) {
+            }
-            if (event != null)
+            if (event != null) {
+            }
-    if (b.length < prefixlen)
+    if (b.length < prefixlen) {
+    }
-                last.length) > 0))
+                last.length) > 0)) {
-        // read the start time and entityId from the current key
+        }
+        // read the start time and entity id from the current key
-        if (entity == null)
-          continue;
-        if (filterPassed)
+        if (filterPassed) {
+        }
-   * Put a single entity.  If there is an error, add a TimelinePutError to the given
-   * response.
+   * Put a single entity.  If there is an error, add a TimelinePutError to the
+   * given response.
+    List<EntityIdentifier> relatedEntitiesWithoutStartTimes =
+        new ArrayList<EntityIdentifier>();
+    byte[] revStartTime = null;
-      byte[] revStartTime = getAndSetStartTime(entity.getEntityId(),
-          entity.getEntityType(), entity.getStartTime(), events,
-          writeBatch);
+      revStartTime = getAndSetStartTime(entity.getEntityId(),
+          entity.getEntityType(), entity.getStartTime(), events);
-      Long revStartTimeLong = readReverseOrderedLong(revStartTime, 0);
+      // write entity marker
+      writeBatch.put(createEntityMarkerKey(entity.getEntityId(),
+          entity.getEntityType(), revStartTime), EMPTY_BYTES);
+
+            // invisible "reverse" entries (entity -> related entity)
+            byte[] key = createReverseRelatedEntityKey(entity.getEntityId(),
+                entity.getEntityType(), revStartTime, relatedEntityId,
+                relatedEntityType);
+            writeBatch.put(key, EMPTY_BYTES);
-            byte[] relatedEntityStartTime = getAndSetStartTime(relatedEntityId,
-                relatedEntityType, null, null, writeBatch);
+            byte[] relatedEntityStartTime = getStartTime(relatedEntityId,
+                relatedEntityType);
+            // delay writing the related entity if no start time is found
-              // if start time is not found, set start time of the related
-              // entity to the start time of this entity, and write it to the
-              // db and the cache
-              relatedEntityStartTime = revStartTime;
-              writeBatch.put(createStartTimeLookupKey(relatedEntityId,
-                  relatedEntityType), relatedEntityStartTime);
-              startTimeWriteCache.put(new EntityIdentifier(relatedEntityId,
-                  relatedEntityType), revStartTimeLong);
+              relatedEntitiesWithoutStartTimes.add(
+                  new EntityIdentifier(relatedEntityId, relatedEntityType));
+              continue;
-            // write reverse entry (related entity -> entity)
-            byte[] key = createReleatedEntityKey(relatedEntityId,
+            // write "forward" entry (related entity -> entity)
+            key = createRelatedEntityKey(relatedEntityId,
-            // TODO: write forward entry (entity -> related entity)?
+
+    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {
+      lock = writeLocks.getLock(relatedEntity);
+      lock.lock();
+      try {
+        byte[] relatedEntityStartTime = getAndSetStartTime(
+            relatedEntity.getId(), relatedEntity.getType(),
+            readReverseOrderedLong(revStartTime, 0), null);
+        if (relatedEntityStartTime == null) {
+          throw new IOException("Error setting start time for related entity");
+        }
+        db.put(createRelatedEntityKey(relatedEntity.getId(),
+            relatedEntity.getType(), relatedEntityStartTime,
+            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);
+        db.put(createEntityMarkerKey(relatedEntity.getId(),
+            relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);
+      } catch (IOException e) {
+        LOG.error("Error putting related entity " + relatedEntity.getId() +
+            " of type " + relatedEntity.getType() + " for entity " +
+            entity.getEntityId() + " of type " + entity.getEntityType(), e);
+        TimelinePutError error = new TimelinePutError();
+        error.setEntityId(entity.getEntityId());
+        error.setEntityType(entity.getEntityType());
+        error.setErrorCode(TimelinePutError.IO_EXCEPTION);
+        response.addError(error);
+      } finally {
+        lock.unlock();
+        writeLocks.returnLock(lock);
+      }
+    }
-    TimelinePutResponse response = new TimelinePutResponse();
-    for (TimelineEntity entity : entities.getEntities()) {
-      put(entity, response);
+    try {
+      deleteLock.readLock().lock();
+      TimelinePutResponse response = new TimelinePutResponse();
+      for (TimelineEntity entity : entities.getEntities()) {
+        put(entity, response);
+      }
+      return response;
+    } finally {
+      deleteLock.readLock().unlock();
-    return response;
-   * @return A byte array
+   * @return A byte array, null if not found
+    Long l = getStartTimeLong(entityId, entityType);
+    return l == null ? null : writeReverseOrderedLong(l);
+  }
+
+  /**
+   * Get the unique start time for a given entity as a Long.
+   *
+   * @param entityId The id of the entity
+   * @param entityType The type of the entity
+   * @return A Long, null if not found
+   * @throws IOException
+   */
+  private Long getStartTimeLong(String entityId, String entityType)
+      throws IOException {
-      return writeReverseOrderedLong(startTimeReadCache.get(entity));
+      return startTimeReadCache.get(entity);
-        startTimeReadCache.put(entity, readReverseOrderedLong(v, 0));
-        return v;
+        Long l = readReverseOrderedLong(v, 0);
+        startTimeReadCache.put(entity, l);
+        return l;
-   * doesn't exist, set it based on the information provided.
+   * doesn't exist, set it based on the information provided. Should only be
+   * called when a lock has been obtained on the entity.
-   * @param writeBatch A leveldb write batch, if the method is called by a
-   *                   put as opposed to a get
-      Long startTime, List<TimelineEvent> events, WriteBatch writeBatch)
+      Long startTime, List<TimelineEvent> events)
-        return checkStartTimeInDb(entity, startTime, writeBatch);
+        return checkStartTimeInDb(entity, startTime);
-        return checkStartTimeInDb(entity, startTime, writeBatch);
+        return checkStartTimeInDb(entity, startTime);
-   * so it adds it back into the cache if it is found.
+   * so it adds it back into the cache if it is found. Should only be called
+   * when a lock has been obtained on the entity.
-      Long suggestedStartTime, WriteBatch writeBatch) throws IOException {
+      Long suggestedStartTime) throws IOException {
-      writeBatch.put(b, revStartTime);
+      WriteOptions writeOptions = new WriteOptions();
+      writeOptions.sync(true);
+      db.put(b, revStartTime, writeOptions);
-   * of the form START_TIME_LOOKUP_PREFIX + entitytype + entity.
+   * of the form START_TIME_LOOKUP_PREFIX + entity type + entity id.
-  private static byte[] createStartTimeLookupKey(String entity,
-      String entitytype) throws IOException {
+  private static byte[] createStartTimeLookupKey(String entityId,
+      String entityType) throws IOException {
-        .add(entitytype).add(entity).getBytes();
+        .add(entityType).add(entityId).getBytes();
+  }
+
+  /**
+   * Creates an entity marker, serializing ENTITY_ENTRY_PREFIX + entity type +
+   * revstarttime + entity id.
+   */
+  private static byte[] createEntityMarkerKey(String entityId,
+      String entityType, byte[] revStartTime) throws IOException {
+    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)
+        .add(entityType).add(revStartTime).add(entityId).getBytesForLookup();
-   * Creates an event key, serializing ENTITY_ENTRY_PREFIX + entitytype +
-   * revstarttime + entity + TIME_COLUMN + reveventtimestamp + eventtype.
+   * Creates an event key, serializing ENTITY_ENTRY_PREFIX + entity type +
+   * revstarttime + entity id + EVENTS_COLUMN + reveventtimestamp + event type.
-  private static byte[] createEntityEventKey(String entity, String entitytype,
-      byte[] revStartTime, byte[] reveventtimestamp, String eventtype)
-      throws IOException {
+  private static byte[] createEntityEventKey(String entityId,
+      String entityType, byte[] revStartTime, byte[] revEventTimestamp,
+      String eventType) throws IOException {
-        .add(entitytype).add(revStartTime).add(entity).add(TIME_COLUMN)
-        .add(reveventtimestamp).add(eventtype).getBytes();
+        .add(entityType).add(revStartTime).add(entityId).add(EVENTS_COLUMN)
+        .add(revEventTimestamp).add(eventType).getBytes();
-  private static TimelineEvent getEntityEvent(Set<String> eventTypes, byte[] key,
-      int offset, byte[] value) throws IOException {
+  private static TimelineEvent getEntityEvent(Set<String> eventTypes,
+      byte[] key, int offset, byte[] value) throws IOException {
-   * entitytype + revstarttime + entity + PRIMARY_FILTER_COLUMN + name + value.
+   * entity type + revstarttime + entity id + PRIMARY_FILTERS_COLUMN + name +
+   * value.
-  private static byte[] createPrimaryFilterKey(String entity,
-      String entitytype, byte[] revStartTime, String name, Object value)
+  private static byte[] createPrimaryFilterKey(String entityId,
+      String entityType, byte[] revStartTime, String name, Object value)
-    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entitytype)
-        .add(revStartTime).add(entity).add(PRIMARY_FILTER_COLUMN).add(name)
+    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entityType)
+        .add(revStartTime).add(entityId).add(PRIMARY_FILTERS_COLUMN).add(name)
-   * Creates an other info key, serializing ENTITY_ENTRY_PREFIX + entitytype +
-   * revstarttime + entity + OTHER_INFO_COLUMN + name.
+   * Creates an other info key, serializing ENTITY_ENTRY_PREFIX + entity type +
+   * revstarttime + entity id + OTHER_INFO_COLUMN + name.
-  private static byte[] createOtherInfoKey(String entity, String entitytype,
+  private static byte[] createOtherInfoKey(String entityId, String entityType,
-    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entitytype)
-        .add(revStartTime).add(entity).add(OTHER_INFO_COLUMN).add(name)
+    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entityType)
+        .add(revStartTime).add(entityId).add(OTHER_INFO_COLUMN).add(name)
-   * entitytype + revstarttime + entity + RELATED_COLUMN + relatedentitytype +
-   * relatedentity.
+   * entity type + revstarttime + entity id + RELATED_ENTITIES_COLUMN +
+   * relatedentity type + relatedentity id.
-  private static byte[] createReleatedEntityKey(String entity,
-      String entitytype, byte[] revStartTime, String relatedEntity,
+  private static byte[] createRelatedEntityKey(String entityId,
+      String entityType, byte[] revStartTime, String relatedEntityId,
-    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entitytype)
-        .add(revStartTime).add(entity).add(RELATED_COLUMN)
-        .add(relatedEntityType).add(relatedEntity).getBytes();
+    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entityType)
+        .add(revStartTime).add(entityId).add(RELATED_ENTITIES_COLUMN)
+        .add(relatedEntityType).add(relatedEntityId).getBytes();
+   * Creates a reverse related entity key, serializing ENTITY_ENTRY_PREFIX +
+   * entity type + revstarttime + entity id +
+   * INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN +
+   * relatedentity type + relatedentity id.
+   */
+  private static byte[] createReverseRelatedEntityKey(String entityId,
+      String entityType, byte[] revStartTime, String relatedEntityId,
+      String relatedEntityType) throws IOException {
+    return KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX).add(entityType)
+        .add(revStartTime).add(entityId)
+        .add(INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN)
+        .add(relatedEntityType).add(relatedEntityId).getBytes();
+  }
+
+  /**
-        DEFAULT_START_TIME_READ_CACHE_SIZE);
+        YarnConfiguration.
+            DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE);
-        DEFAULT_START_TIME_WRITE_CACHE_SIZE);
+        YarnConfiguration.
+            DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE);
+  }
+
+  // warning is suppressed to prevent eclipse from noting unclosed resource
+  @SuppressWarnings("resource")
+  @VisibleForTesting
+  List<String> getEntityTypes() throws IOException {
+    DBIterator iterator = null;
+    try {
+      iterator = getDbIterator(false);
+      List<String> entityTypes = new ArrayList<String>();
+      iterator.seek(ENTITY_ENTRY_PREFIX);
+      while (iterator.hasNext()) {
+        byte[] key = iterator.peekNext().getKey();
+        if (key[0] != ENTITY_ENTRY_PREFIX[0]) {
+          break;
+        }
+        KeyParser kp = new KeyParser(key,
+            ENTITY_ENTRY_PREFIX.length);
+        String entityType = kp.getNextString();
+        entityTypes.add(entityType);
+        byte[] lookupKey = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)
+            .add(entityType).getBytesForLookup();
+        if (lookupKey[lookupKey.length - 1] != 0x0) {
+          throw new IOException("Found unexpected end byte in lookup key");
+        }
+        lookupKey[lookupKey.length - 1] = 0x1;
+        iterator.seek(lookupKey);
+      }
+      return entityTypes;
+    } finally {
+      IOUtils.cleanup(LOG, iterator);
+    }
+  }
+
+  /**
+   * Finds all keys in the db that have a given prefix and deletes them on
+   * the given write batch.
+   */
+  private void deleteKeysWithPrefix(WriteBatch writeBatch, byte[] prefix,
+      DBIterator iterator) {
+    for (iterator.seek(prefix); iterator.hasNext(); iterator.next()) {
+      byte[] key = iterator.peekNext().getKey();
+      if (!prefixMatches(prefix, prefix.length, key)) {
+        break;
+      }
+      writeBatch.delete(key);
+    }
+  }
+
+  // warning is suppressed to prevent eclipse from noting unclosed resource
+  @SuppressWarnings("resource")
+  @VisibleForTesting
+  boolean deleteNextEntity(String entityType, byte[] reverseTimestamp,
+      DBIterator iterator, DBIterator pfIterator, boolean seeked)
+      throws IOException {
+    WriteBatch writeBatch = null;
+    try {
+      KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)
+          .add(entityType);
+      byte[] typePrefix = kb.getBytesForLookup();
+      kb.add(reverseTimestamp);
+      if (!seeked) {
+        iterator.seek(kb.getBytesForLookup());
+      }
+      if (!iterator.hasNext()) {
+        return false;
+      }
+      byte[] entityKey = iterator.peekNext().getKey();
+      if (!prefixMatches(typePrefix, typePrefix.length, entityKey)) {
+        return false;
+      }
+
+      // read the start time and entity id from the current key
+      KeyParser kp = new KeyParser(entityKey, typePrefix.length + 8);
+      String entityId = kp.getNextString();
+      int prefixlen = kp.getOffset();
+      byte[] deletePrefix = new byte[prefixlen];
+      System.arraycopy(entityKey, 0, deletePrefix, 0, prefixlen);
+
+      writeBatch = db.createWriteBatch();
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Deleting entity type:" + entityType + " id:" + entityId);
+      }
+      // remove start time from cache and db
+      writeBatch.delete(createStartTimeLookupKey(entityId, entityType));
+      EntityIdentifier entityIdentifier =
+          new EntityIdentifier(entityId, entityType);
+      startTimeReadCache.remove(entityIdentifier);
+      startTimeWriteCache.remove(entityIdentifier);
+
+      // delete current entity
+      for (; iterator.hasNext(); iterator.next()) {
+        byte[] key = iterator.peekNext().getKey();
+        if (!prefixMatches(entityKey, prefixlen, key)) {
+          break;
+        }
+        writeBatch.delete(key);
+
+        if (key.length == prefixlen) {
+          continue;
+        }
+        if (key[prefixlen] == PRIMARY_FILTERS_COLUMN[0]) {
+          kp = new KeyParser(key,
+              prefixlen + PRIMARY_FILTERS_COLUMN.length);
+          String name = kp.getNextString();
+          Object value = GenericObjectMapper.read(key, kp.getOffset());
+          deleteKeysWithPrefix(writeBatch, addPrimaryFilterToKey(name, value,
+              deletePrefix), pfIterator);
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Deleting entity type:" + entityType + " id:" +
+                entityId + " primary filter entry " + name + " " +
+                value);
+          }
+        } else if (key[prefixlen] == RELATED_ENTITIES_COLUMN[0]) {
+          kp = new KeyParser(key,
+              prefixlen + RELATED_ENTITIES_COLUMN.length);
+          String type = kp.getNextString();
+          String id = kp.getNextString();
+          byte[] relatedEntityStartTime = getStartTime(id, type);
+          if (relatedEntityStartTime == null) {
+            LOG.warn("Found no start time for " +
+                "related entity " + id + " of type " + type + " while " +
+                "deleting " + entityId + " of type " + entityType);
+            continue;
+          }
+          writeBatch.delete(createReverseRelatedEntityKey(id, type,
+              relatedEntityStartTime, entityId, entityType));
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Deleting entity type:" + entityType + " id:" +
+                entityId + " from invisible reverse related entity " +
+                "entry of type:" + type + " id:" + id);
+          }
+        } else if (key[prefixlen] ==
+            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {
+          kp = new KeyParser(key, prefixlen +
+              INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN.length);
+          String type = kp.getNextString();
+          String id = kp.getNextString();
+          byte[] relatedEntityStartTime = getStartTime(id, type);
+          if (relatedEntityStartTime == null) {
+            LOG.warn("Found no start time for reverse " +
+                "related entity " + id + " of type " + type + " while " +
+                "deleting " + entityId + " of type " + entityType);
+            continue;
+          }
+          writeBatch.delete(createRelatedEntityKey(id, type,
+              relatedEntityStartTime, entityId, entityType));
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Deleting entity type:" + entityType + " id:" +
+                entityId + " from related entity entry of type:" +
+                type + " id:" + id);
+          }
+        }
+      }
+      WriteOptions writeOptions = new WriteOptions();
+      writeOptions.sync(true);
+      db.write(writeBatch, writeOptions);
+      return true;
+    } finally {
+      IOUtils.cleanup(LOG, writeBatch);
+    }
+  }
+
+  /**
+   * Discards entities with start timestamp less than or equal to the given
+   * timestamp.
+   */
+  @VisibleForTesting
+  void discardOldEntities(long timestamp)
+      throws IOException, InterruptedException {
+    byte[] reverseTimestamp = writeReverseOrderedLong(timestamp);
+    long totalCount = 0;
+    long t1 = System.currentTimeMillis();
+    try {
+      List<String> entityTypes = getEntityTypes();
+      for (String entityType : entityTypes) {
+        DBIterator iterator = null;
+        DBIterator pfIterator = null;
+        long typeCount = 0;
+        try {
+          deleteLock.writeLock().lock();
+          iterator = getDbIterator(false);
+          pfIterator = getDbIterator(false);
+
+          if (deletionThread != null && deletionThread.isInterrupted()) {
+            throw new InterruptedException();
+          }
+          boolean seeked = false;
+          while (deleteNextEntity(entityType, reverseTimestamp, iterator,
+              pfIterator, seeked)) {
+            typeCount++;
+            totalCount++;
+            seeked = true;
+            if (deletionThread != null && deletionThread.isInterrupted()) {
+              throw new InterruptedException();
+            }
+          }
+        } catch (IOException e) {
+          LOG.error("Got IOException while deleting entities for type " +
+              entityType + ", continuing to next type", e);
+        } finally {
+          IOUtils.cleanup(LOG, iterator, pfIterator);
+          deleteLock.writeLock().unlock();
+          if (typeCount > 0) {
+            LOG.info("Deleted " + typeCount + " entities of type " +
+                entityType);
+          }
+        }
+      }
+    } finally {
+      long t2 = System.currentTimeMillis();
+      LOG.info("Discarded " + totalCount + " entities for timestamp " +
+          timestamp + " and earlier in " + (t2 - t1) / 1000.0 + " seconds");
+    }
+  }
+
+  @VisibleForTesting
+  DBIterator getDbIterator(boolean fillCache) {
+    ReadOptions readOptions = new ReadOptions();
+    readOptions.fillCache(fillCache);
+    return db.iterator(readOptions);

INS26 INS26 INS26 MOV23 MOV23 MOV23 INS40 INS40 INS40 INS23 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS5 INS43 INS83 INS43 INS59 INS8 INS83 INS42 INS43 INS23 INS23 INS31 INS31 INS44 INS44 INS43 INS8 INS8 MOV29 INS83 MOV5 INS42 MOV44 MOV44 MOV43 INS8 INS29 INS43 UPD42 INS44 INS44 INS43 INS29 INS83 INS83 MOV5 INS42 MOV44 MOV44 MOV44 MOV43 INS8 MOV5 MOV44 MOV44 MOV43 MOV44 MOV5 UPD42 INS44 INS44 MOV43 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS8 MOV78 MOV44 MOV78 MOV44 INS79 INS78 INS74 INS42 INS43 INS8 INS29 INS83 INS39 INS42 MOV44 INS44 INS44 INS8 INS79 INS78 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS78 INS39 INS42 INS44 INS43 INS43 INS8 INS78 INS43 INS42 INS44 INS8 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 UPD42 UPD42 INS39 INS85 UPD42 INS32 INS42 UPD42 INS14 INS42 INS42 INS21 INS25 INS25 MOV21 MOV21 INS42 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS23 INS43 INS42 INS43 INS42 INS42 INS60 MOV25 MOV60 MOV60 INS54 INS60 INS60 INS70 INS54 INS60 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 UPD42 UPD42 INS65 INS41 INS43 UPD42 UPD42 UPD42 UPD42 INS43 UPD42 INS43 UPD42 INS43 UPD42 INS43 UPD42 INS43 UPD42 INS43 UPD42 INS5 INS42 INS43 INS42 INS65 INS39 INS85 INS43 INS42 INS43 INS42 INS5 INS42 INS43 INS42 INS43 INS42 INS42 INS41 INS42 INS45 INS42 INS43 MOV43 INS42 INS60 INS54 INS65 INS5 INS42 INS43 INS42 INS24 INS42 INS45 INS42 INS43 INS42 INS5 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS54 INS65 INS42 INS39 INS42 INS42 INS42 INS60 INS60 INS60 INS54 INS42 INS42 INS39 INS42 INS60 INS21 INS41 UPD45 INS45 INS42 INS43 INS32 INS8 INS32 INS8 INS27 INS8 INS42 INS42 INS43 INS42 INS21 INS21 INS21 INS42 INS61 INS83 INS83 INS83 INS39 INS59 INS42 INS42 INS43 INS59 INS8 MOV5 INS8 MOV8 INS8 INS8 INS8 UPD66 UPD66 INS74 INS59 MOV5 INS59 INS44 INS42 INS8 MOV8 INS8 UPD66 MOV43 INS59 INS16 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 UPD66 INS66 UPD66 INS66 UPD66 INS66 INS66 MOV32 UPD66 UPD66 INS42 UPD66 INS66 INS42 INS42 UPD66 UPD66 INS42 INS42 UPD66 UPD66 INS42 INS42 INS39 INS85 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS39 INS85 INS42 INS42 INS32 INS42 INS43 INS59 INS8 INS8 INS66 INS66 INS39 INS85 INS42 INS32 INS32 INS32 INS8 INS42 INS39 INS85 INS42 INS42 INS43 INS59 INS8 INS8 INS66 INS66 INS5 INS59 INS39 INS59 INS39 INS59 INS8 INS8 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS32 MOV25 INS42 INS42 INS40 INS9 INS21 INS21 INS42 INS33 INS21 INS21 INS54 INS42 INS7 INS7 INS32 INS9 INS8 INS42 INS34 INS8 INS8 INS8 INS8 INS42 INS42 INS32 INS41 MOV32 MOV21 MOV21 MOV41 MOV21 INS25 MOV41 MOV41 INS43 INS43 INS42 MOV14 INS42 INS33 INS21 INS21 INS43 INS42 INS21 INS21 INS54 INS21 INS21 INS42 INS32 INS27 INS33 INS32 INS60 INS21 INS32 INS42 INS40 INS40 INS42 INS42 INS33 INS21 INS60 INS21 INS61 INS41 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS21 INS42 INS42 INS33 INS60 INS60 INS21 INS25 INS25 INS60 INS25 INS60 INS60 INS60 INS60 INS21 INS21 INS25 INS21 INS60 INS21 INS21 INS24 INS60 INS21 INS21 INS41 INS21 INS39 INS85 INS42 INS32 INS42 INS34 INS42 INS32 INS60 INS70 INS60 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS8 INS7 INS32 INS32 INS32 INS8 INS12 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS60 INS54 MOV21 MOV53 MOV21 MOV53 INS42 INS42 INS42 MOV33 UPD42 INS8 INS27 INS8 MOV27 INS42 INS42 UPD74 INS7 INS32 INS42 INS7 INS32 INS8 INS12 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS33 INS42 INS42 MOV32 INS43 INS59 INS32 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS7 INS74 INS59 INS32 INS32 INS8 INS42 INS32 INS5 INS59 INS38 INS8 INS32 INS43 INS59 INS5 INS59 INS32 INS38 INS8 INS38 INS8 INS5 INS59 INS38 INS8 INS43 INS59 INS43 INS59 INS39 INS59 INS5 INS59 INS32 INS7 INS32 INS8 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS8 INS43 INS59 INS32 INS32 INS9 INS32 INS42 INS42 INS42 INS42 INS74 INS59 INS44 INS42 INS8 INS39 INS59 INS32 INS43 MOV53 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS21 INS44 INS8 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS40 INS45 INS42 INS45 INS45 INS42 INS39 INS59 INS8 INS12 INS12 INS8 INS8 UPD42 INS42 INS10 INS40 INS42 INS18 UPD42 MOV60 MOV25 UPD43 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS21 INS21 INS44 INS8 INS21 INS21 INS32 INS42 INS32 INS42 INS60 INS42 INS42 INS14 INS42 INS42 INS9 UPD42 INS42 UPD42 INS32 INS42 UPD42 INS32 INS42 INS42 INS42 INS32 INS43 MOV43 INS42 MOV14 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS60 INS60 INS21 INS60 INS25 INS21 INS21 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS32 INS32 INS10 INS42 INS42 INS42 INS42 INS42 MOV32 INS39 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS32 INS41 INS39 INS85 INS42 INS32 INS32 INS41 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS32 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS21 INS25 INS25 INS42 INS42 INS14 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 MOV43 INS42 INS32 INS43 INS42 INS60 INS60 INS60 INS54 INS42 INS32 INS42 INS42 INS27 INS42 INS43 INS42 INS32 INS43 INS42 INS21 INS42 INS27 INS21 INS21 INS44 INS8 INS44 INS8 MOV21 MOV21 INS32 UPD42 INS8 INS8 UPD42 UPD42 MOV42 INS32 INS32 MOV42 INS42 INS42 INS42 INS5 INS59 INS27 INS8 INS32 INS32 INS43 INS42 INS21 INS60 INS21 INS21 INS21 INS21 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS59 UPD42 INS43 INS32 INS42 INS42 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS42 INS9 INS42 UPD74 INS5 INS59 INS27 INS8 INS43 INS59 MOV43 INS59 INS32 INS5 INS59 INS27 INS8 INS7 INS32 INS32 INS42 INS42 INS42 INS40 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS9 INS32 INS42 INS42 INS42 INS40 INS42 INS9 INS43 INS42 INS27 INS42 INS42 INS42 INS42 INS5 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS5 INS59 INS38 INS8 INS32 INS27 INS8 INS27 INS8 INS25 INS43 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS39 INS59 INS8 INS12 INS8 INS42 INS42 INS27 INS45 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS43 INS42 INS21 INS43 INS42 INS21 INS10 UPD42 INS42 MOV42 MOV27 INS8 UPD42 MOV43 INS42 INS10 MOV21 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 UPD42 INS32 INS42 INS32 INS42 UPD42 INS32 INS42 INS42 UPD43 INS39 INS85 INS42 INS32 INS2 INS2 INS10 INS42 INS42 INS14 INS42 INS32 INS42 INS42 INS42 INS39 INS85 INS42 MOV32 INS2 INS34 INS53 INS2 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS34 INS39 INS85 INS42 INS42 INS27 INS42 INS39 INS85 INS42 INS32 INS32 INS10 INS42 INS42 INS42 INS40 INS42 INS18 INS2 INS2 INS21 INS60 INS60 INS21 INS25 INS27 INS8 INS25 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS34 INS21 INS21 INS21 INS25 INS60 INS61 INS44 INS8 INS21 INS21 INS25 INS45 INS42 INS45 INS42 INS45 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 UPD42 INS25 MOV21 INS42 INS32 INS32 MOV32 INS33 INS14 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 UPD42 INS32 INS42 INS42 INS34 INS42 INS34 INS43 INS42 INS40 INS42 INS42 UPD42 INS42 INS27 INS14 INS42 INS27 INS42 INS42 INS45 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS7 MOV43 INS59 MOV43 INS59 INS32 INS32 INS8 INS2 INS2 INS21 INS60 INS60 INS60 INS25 INS21 INS25 INS27 INS8 INS32 INS7 INS7 INS27 INS8 INS39 INS59 INS32 INS8 INS43 INS42 INS21 INS32 INS32 INS27 INS8 INS36 INS34 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS45 UPD42 INS27 MOV8 INS25 INS60 INS21 INS21 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS32 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 INS32 MOV42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 INS40 INS34 INS43 INS45 INS40 INS34 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS34 INS7 MOV43 INS59 MOV43 INS59 INS5 INS59 INS27 INS8 INS32 INS32 INS8 INS2 INS2 INS21 INS60 INS60 INS60 INS25 INS21 INS25 INS32 INS42 INS42 INS32 INS42 INS32 INS27 INS32 INS53 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS21 INS25 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS34 INS21 INS27 UPD40 INS2 INS2 MOV43 UPD42 UPD42 UPD42 MOV27 INS8 INS8 MOV5 INS59 MOV5 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV42 INS42 INS42 INS42 INS32 MOV42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS32 INS42 INS32 INS39 INS85 INS42 INS32 INS42 INS33 INS21 INS18 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS42 INS34 INS7 MOV43 INS59 MOV43 INS59 INS5 INS59 INS27 INS8 INS32 INS32 INS8 INS42 INS42 INS42 INS9 INS42 INS9 INS42 INS33 INS42 INS42 INS14 INS37 INS37 INS7 INS27 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS10 INS21 INS42 INS32 INS18 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS27 INS43 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS32 INS42 INS32 INS39 INS85 INS42 INS32 INS42 INS33 INS21 INS18 INS42 INS42 INS32 INS42 INS42 INS21 INS43 INS42 INS42 INS42 INS9 INS27 INS32 INS53 INS45 INS42 INS45 INS42 INS42 INS27 UPD40 UPD42 MOV32 INS42 INS32 INS32 INS42 INS42 INS42 UPD42 UPD42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS27 INS43 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS14 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS27 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS27 INS43 UPD40 INS45 INS45 INS27 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS45 DEL39 DEL34 DEL83 DEL39 DEL34 DEL8 DEL41 DEL42 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL32 DEL21 DEL10 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL21 DEL10 DEL10 DEL25 DEL42 DEL33 DEL27 DEL18 DEL25 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL32 DEL59 DEL60 DEL33 DEL33 DEL42 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL66 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL44 DEL42 DEL42 DEL42
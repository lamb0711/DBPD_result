HDFS-8760. Erasure Coding: reuse BlockReader when reading the same block in pread. Contributed by Jing Zhao.

-import com.google.common.base.Preconditions;
-   * Used when reading contiguous blocks
-   */
-  private void actualGetFromOneDataNode(final DNAddrPair datanode,
-      LocatedBlock block, final long start, final long end, byte[] buf,
-      int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap)
-      throws IOException {
-    final int length = (int) (end - start + 1);
-    actualGetFromOneDataNode(datanode, block, start, end, buf,
-        new int[]{offset}, new int[]{length}, corruptedBlockMap);
-  }
-
-  /**
-   * @param offsets the data may be read into multiple segments of the buf
-   *                (when reading a striped block). this array indicates the
-   *                offset of each buf segment.
-   * @param lengths the length of each buf segment
+   * @param offset the offset in buf
-  void actualGetFromOneDataNode(final DNAddrPair datanode,
-      LocatedBlock block, final long startInBlk, final long endInBlk,
-      byte[] buf, int[] offsets, int[] lengths,
+  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,
+      final long startInBlk, final long endInBlk, byte[] buf, int offset,
-    checkReadPortions(offsets, lengths, len);
-        for (int i = 0; i < offsets.length; i++) {
-          int nread = reader.readAll(buf, offsets[i], lengths[i]);
-          updateReadStatistics(readStatistics, nread, reader);
-          if (nread != lengths[i]) {
-            throw new IOException("truncated return from reader.read(): " +
-                "excpected " + lengths[i] + ", got " + nread);
-          }
+        int nread = reader.readAll(buf, offset, len);
+        updateReadStatistics(readStatistics, nread, reader);
+        if (nread != len) {
+          throw new IOException("truncated return from reader.read(): " +
+              "excpected " + len + ", got " + nread);
-   * This method verifies that the read portions are valid and do not overlap
-   * with each other.
-   */
-  private void checkReadPortions(int[] offsets, int[] lengths, int totalLen) {
-    Preconditions.checkArgument(offsets.length == lengths.length && offsets.length > 0);
-    int sum = 0;
-    for (int i = 0; i < lengths.length; i++) {
-      if (i > 0) {
-        int gap = offsets[i] - offsets[i - 1];
-        // make sure read portions do not overlap with each other
-        Preconditions.checkArgument(gap >= lengths[i - 1]);
-      }
-      sum += lengths[i];
-    }
-    Preconditions.checkArgument(sum == totalLen);
-  }
-
-  /**

MOV44 UPD42 UPD66 MOV60 MOV21 MOV25 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL42 DEL43 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL27 DEL34 DEL27 DEL36 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL39 DEL85 DEL5 DEL42 DEL4 DEL3 DEL39 DEL85 DEL5 DEL42 DEL4 DEL3 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL42 DEL66 DEL65 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL40 DEL40 DEL27 DEL40 DEL34 DEL27 DEL27 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL34 DEL27 DEL39 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL34 DEL27 DEL2 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL2 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL2 DEL7 DEL21 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL8 DEL31
HDFS-14402. Use FileChannel.transferTo() method for transferring block to SCM cache. Contributed by Feilong He.

+import com.google.common.base.Preconditions;
+import org.apache.commons.io.IOUtils;
+import org.apache.hadoop.hdfs.server.datanode.BlockMetadataHeader;
+import org.apache.hadoop.util.DataChecksum;
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+   * Verifies the block's checksum. This is an I/O intensive operation.
+   */
+  protected void verifyChecksum(long length, FileInputStream metaIn,
+                                FileChannel blockChannel, String blockFileName)
+      throws IOException {
+    // Verify the checksum from the block's meta file
+    // Get the DataChecksum from the meta file header
+    BlockMetadataHeader header =
+        BlockMetadataHeader.readHeader(new DataInputStream(
+            new BufferedInputStream(metaIn, BlockMetadataHeader
+                .getHeaderSize())));
+    FileChannel metaChannel = null;
+    try {
+      metaChannel = metaIn.getChannel();
+      if (metaChannel == null) {
+        throw new IOException(
+            "Block InputStream meta file has no FileChannel.");
+      }
+      DataChecksum checksum = header.getChecksum();
+      final int bytesPerChecksum = checksum.getBytesPerChecksum();
+      final int checksumSize = checksum.getChecksumSize();
+      final int numChunks = (8 * 1024 * 1024) / bytesPerChecksum;
+      ByteBuffer blockBuf = ByteBuffer.allocate(numChunks * bytesPerChecksum);
+      ByteBuffer checksumBuf = ByteBuffer.allocate(numChunks * checksumSize);
+      // Verify the checksum
+      int bytesVerified = 0;
+      while (bytesVerified < length) {
+        Preconditions.checkState(bytesVerified % bytesPerChecksum == 0,
+            "Unexpected partial chunk before EOF");
+        assert bytesVerified % bytesPerChecksum == 0;
+        int bytesRead = fillBuffer(blockChannel, blockBuf);
+        if (bytesRead == -1) {
+          throw new IOException("checksum verification failed: premature EOF");
+        }
+        blockBuf.flip();
+        // Number of read chunks, including partial chunk at end
+        int chunks = (bytesRead + bytesPerChecksum - 1) / bytesPerChecksum;
+        checksumBuf.limit(chunks * checksumSize);
+        fillBuffer(metaChannel, checksumBuf);
+        checksumBuf.flip();
+        checksum.verifyChunkedSums(blockBuf, checksumBuf, blockFileName,
+            bytesVerified);
+        // Success
+        bytesVerified += bytesRead;
+        blockBuf.clear();
+        checksumBuf.clear();
+      }
+    } finally {
+      IOUtils.closeQuietly(metaChannel);
+    }
+  }
+
+  /**

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS65 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS54 INS66 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS8 INS8 INS42 INS42 INS32 INS42 INS42 INS33 INS21 INS25 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS61 INS21 INS42 INS42 INS14 INS7 INS27 INS8 INS43 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS27 INS8 INS32 INS43 INS14 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS34 INS42 INS42 INS21 INS6 INS60 INS25 INS21 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS27 INS39 INS59 INS27 INS8 INS32 INS39 INS59 INS32 INS32 INS32 INS32 INS7 INS32 INS32 INS42 INS42 INS42 INS43 INS45 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS45 INS27 INS34 INS42 INS32 INS42 INS38 INS53 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS34 INS34 INS27 INS34 INS42 INS42 INS42 INS42 INS42 INS34 INS14 INS36 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS27 INS42 INS27 INS34 INS42 INS42
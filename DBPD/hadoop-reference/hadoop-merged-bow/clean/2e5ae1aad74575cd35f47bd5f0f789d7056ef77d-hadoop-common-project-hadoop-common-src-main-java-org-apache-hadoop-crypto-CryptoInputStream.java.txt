HADOOP-10628. Javadoc and few code style improvement for Crypto input and output streams. (yliu via clamb)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1598429 13f79535-47bb-0310-9956-ffa450edef68

+  
+  
+  
-   * Whether underlying stream supports 
+   * Whether the underlying stream supports 
+  
-   * before any other data goes in. The purpose of padding is to put input data
-   * at proper position.
+   * before any other data goes in. The purpose of padding is to put the input 
+   * data at proper position.
-    int remaining = outBuffer.remaining();
+    final int remaining = outBuffer.remaining();
-      /**
+      
+      /*
-  // Read data from underlying stream.
+  /** Read data from underlying stream. */
-    int toRead = inBuffer.remaining();
-    byte[] tmp = getTmpBuf();
-    int n = in.read(tmp, 0, toRead);
+    final int toRead = inBuffer.remaining();
+    final byte[] tmp = getTmpBuf();
+    final int n = in.read(tmp, 0, toRead);
-      /**
-       * The plain text and cipher text have 1:1 mapping, they start at same 
-       * position.
+      /*
+       * The plain text and cipher text have a 1:1 mapping, they start at the 
+       * same position.
-      /**
-       * Typically we will not get here. To improve performance in CTR mode,
-       * we rely on the decryptor maintaining context, for example calculating 
-       * the counter. Unfortunately, some bad implementations can't maintain 
-       * context so we need to re-init after doing decryption.
+      /*
+       * This code is generally not executed since the decryptor usually 
+       * maintains decryption context (e.g. the counter) internally. However, 
+       * some implementations can't maintain context so a re-init is necessary 
+       * after each decryption call.
-    long counter = streamOffset / codec.getAlgorithmBlockSize();
+    final long counter = streamOffset / codec.getAlgorithmBlockSize();
-   * Reset the underlying stream offset; and clear {@link #inBuffer} and 
-   * {@link #outBuffer}. Typically this happens when doing {@link #seek(long)} 
+   * Reset the underlying stream offset, and clear {@link #inBuffer} and 
+   * {@link #outBuffer}. This Typically happens during {@link #seek(long)} 
-  /**
-   * Free the direct buffer manually.
-   */
+  /** Forcibly free the direct buffer. */
-    sun.misc.Cleaner inBufferCleaner =
+    final sun.misc.Cleaner inBufferCleaner =
-    sun.misc.Cleaner outBufferCleaner =
+    final sun.misc.Cleaner outBufferCleaner =
-  // Positioned read.
+  /** Positioned read. */
-      int n = ((PositionedReadable) in).read(position, buffer, offset, length);
+      final int n = ((PositionedReadable) in).read(position, buffer, offset, 
+          length);
-        /** 
+        /*
-         * streamOffset should be not changed and we need to restore the 
-         * decryptor and outBuffer after decryption.
+         * streamOffset should not be changed. We need to restore the decryptor 
+         * and outBuffer after decryption.
-   * Decrypt given length of data in buffer: start from offset.
-   * Output is also buffer and start from same offset. Restore the 
-   * {@link #decryptor} and {@link #outBuffer} after decryption.
+   * Decrypt length bytes in buffer starting at offset. Output is also put 
+   * into buffer starting at offset. Restore the {@link #decryptor} and 
+   * {@link #outBuffer} after the decryption.
-    
-    byte[] tmp = getTmpBuf();
+    final byte[] tmp = getTmpBuf();
-    long curOffset = streamOffset;
+    final long curOffset = streamOffset;
-      int toDecrypt = Math.min(length - n, inBuffer.remaining());
+      final int toDecrypt = Math.min(length - n, inBuffer.remaining());
-  // Positioned read fully.
+  /** Positioned read fully. */
-        /** 
-         * Since this operation does not change the current offset of a file, 
-         * streamOffset should be not changed and we need to restore the decryptor 
+        /*
+         * Since this operation does not change the current offset of the file, 
+         * streamOffset should not be changed. We need to restore the decryptor 
-  // Seek to a position.
+  /** Seek to a position. */
-      // If target pos we have already read and decrypt.
+      /*
+       * If data of target pos in the underlying stream has already been read 
+       * and decrypted in outBuffer, we just need to re-position outBuffer.
+       */
-  // Skip n bytes
+  /** Skip n bytes */
-      /**
+      /*
-       * skip in underlying stream. We get real skipped bytes number of 
-       * underlying stream then add outBuffer.remaining() to get skipped
-       * bytes number from user's view.
+       * skip in the underlying stream. Add outBuffer.remaining() to the 
+       * actual number of skipped bytes in the underlying stream to get the 
+       * number of skipped bytes from the user's point of view.
-  // Get underlying stream position.
+  /** Get underlying stream position. */
-  // ByteBuffer read.
+  /** ByteBuffer read. */
-      int unread = outBuffer.remaining();
+      final int unread = outBuffer.remaining();
-          int limit = outBuffer.limit();
+          final int limit = outBuffer.limit();
-      int pos = buf.position();
-      int n = ((ByteBufferReadable) in).read(buf);
+      final int pos = buf.position();
+      final int n = ((ByteBufferReadable) in).read(buf);
-    int pos = buf.position();
-    int limit = buf.limit();
+    final int pos = buf.position();
+    final int limit = buf.limit();
-      ByteBuffer buffer = ((HasEnhancedByteBufferAccess) in).
+      final ByteBuffer buffer = ((HasEnhancedByteBufferAccess) in).
-        int n = buffer.remaining();
+        final int n = buffer.remaining();
-          int pos = buffer.position();
+          final int pos = buffer.position();

INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS65 INS65 INS65 INS65 INS65 INS65 INS65 MOV60 UPD66 UPD66 UPD66 INS83 INS66 INS83 INS83 INS83 INS83 UPD66 UPD66 UPD66 INS83 INS83 INS66 UPD66 UPD66 UPD66 INS83 INS83 INS66 INS66 INS66 INS66 INS66 INS83 INS83 INS60 INS83 INS83 INS83 INS83 INS39 MOV59 INS83 INS83 INS83 INS83 INS83 DEL39 DEL60
HADOOP-13197. Add non-decayed call metrics for DecayRpcScheduler. Contributed by Xiaoyu Yao.

+import java.util.ArrayList;
-  // Track the number of calls for each schedulable identity
-  private final ConcurrentHashMap<Object, AtomicLong> callCounts =
-    new ConcurrentHashMap<Object, AtomicLong>();
+  // Track the decayed and raw (no decay) number of calls for each schedulable
+  // identity from all previous decay windows: idx 0 for decayed call count and
+  // idx 1 for the raw call count
+  private final ConcurrentHashMap<Object, List<AtomicLong>> callCounts =
+      new ConcurrentHashMap<Object, List<AtomicLong>>();
-  // Should be the sum of all AtomicLongs in callCounts
-  private final AtomicLong totalCalls = new AtomicLong();
+  // Should be the sum of all AtomicLongs in decayed callCounts
+  private final AtomicLong totalDecayedCallCount = new AtomicLong();
+  // The sum of all AtomicLongs in raw callCounts
+  private final AtomicLong totalRawCallCount = new AtomicLong();
+
+  private static final double PRECISION = 0.0001;
-      long total = 0;
-      Iterator<Map.Entry<Object, AtomicLong>> it =
+      long totalDecayedCount = 0;
+      long totalRawCount = 0;
+      Iterator<Map.Entry<Object, List<AtomicLong>>> it =
-        Map.Entry<Object, AtomicLong> entry = it.next();
-        AtomicLong count = entry.getValue();
+        Map.Entry<Object, List<AtomicLong>> entry = it.next();
+        AtomicLong decayedCount = entry.getValue().get(0);
+        AtomicLong rawCount = entry.getValue().get(1);
+
-        long currentValue = count.get();
+        totalRawCount += rawCount.get();
+        long currentValue = decayedCount.get();
-        total += nextValue;
-        count.set(nextValue);
+        totalDecayedCount += nextValue;
+        decayedCount.set(nextValue);
-      totalCalls.set(total);
+      totalDecayedCallCount.set(totalDecayedCount);
+      totalRawCallCount.set(totalRawCount);
-    for (Map.Entry<Object, AtomicLong> entry : callCounts.entrySet()) {
+    for (Map.Entry<Object, List<AtomicLong>> entry : callCounts.entrySet()) {
-      AtomicLong value = entry.getValue();
+      AtomicLong value = entry.getValue().get(0);
-  private long getAndIncrement(Object identity) throws InterruptedException {
+  private long getAndIncrementCallCounts(Object identity)
+      throws InterruptedException {
-    AtomicLong count = this.callCounts.get(identity);
+    List<AtomicLong> count = this.callCounts.get(identity);
-      // Create the count since no such count exists.
-      count = new AtomicLong(0);
+      // Create the counts since no such count exists.
+      // idx 0 for decayed call count
+      // idx 1 for the raw call count
+      count = new ArrayList<AtomicLong>(2);
+      count.add(new AtomicLong(0));
+      count.add(new AtomicLong(0));
-      AtomicLong otherCount = callCounts.putIfAbsent(identity, count);
+      List<AtomicLong> otherCount = callCounts.putIfAbsent(identity, count);
-    totalCalls.getAndIncrement();
+    totalDecayedCallCount.getAndIncrement();
+    totalRawCallCount.getAndIncrement();
-    return count.getAndIncrement();
+    count.get(1).getAndIncrement();
+    return count.get(0).getAndIncrement();
-    long totalCallSnapshot = totalCalls.get();
+    long totalCallSnapshot = totalDecayedCallCount.get();
-      long occurrences = this.getAndIncrement(identity);
+      long occurrences = this.getAndIncrementCallCounts(identity);
-  // Update the cached average response time at the end of decay window
+  // Update the cached average response time at the end of the decay window
-      if (enableDecay && lastAvg > 0.0) {
-        final double decayed = decayFactor * lastAvg + averageResponseTime;
-        responseTimeAvgInLastWindow.set(i, decayed);
-      } else {
-        responseTimeAvgInLastWindow.set(i, averageResponseTime);
+      if (lastAvg > PRECISION || averageResponseTime > PRECISION) {
+        if (enableDecay) {
+          final double decayed = decayFactor * lastAvg + averageResponseTime;
+          responseTimeAvgInLastWindow.set(i, decayed);
+        } else {
+          responseTimeAvgInLastWindow.set(i, averageResponseTime);
+        }
-    for (Map.Entry<Object, AtomicLong> entry : callCounts.entrySet()) {
-      snapshot.put(entry.getKey(), entry.getValue().get());
+    for (Map.Entry<Object, List<AtomicLong>> entry : callCounts.entrySet()) {
+      snapshot.put(entry.getKey(), entry.getValue().get(0).get());
-    return totalCalls.get();
+    return totalDecayedCallCount.get();
-    return totalCalls.get();
+    return totalDecayedCallCount.get();
+  }
+
+  public long getTotalRawCallVolume() {
+    return totalRawCallCount.get();
-      addTotalCallVolume(rb);
+      addDecayedCallVolume(rb);
+      addRawCallVolume(rb);
-  // Key: CallVolume
-  private void addTotalCallVolume(MetricsRecordBuilder rb) {
-    rb.addCounter(Interns.info("CallVolume", "Total Call Volume"),
-        getTotalCallVolume());
+  // Key: DecayedCallVolume
+  private void addDecayedCallVolume(MetricsRecordBuilder rb) {
+    rb.addCounter(Interns.info("DecayedCallVolume", "Decayed Total " +
+        "incoming Call Volume"), getTotalCallVolume());
-  // Key: Priority.0.CallVolume
+  private void addRawCallVolume(MetricsRecordBuilder rb) {
+    rb.addCounter(Interns.info("CallVolume", "Raw Total " +
+        "incoming Call Volume"), getTotalRawCallVolume());
+  }
+
+  // Key: Priority.0.CompletedCallVolume
-      rb.addGauge(Interns.info("Priority." + i + ".CallVolume", "Call volume " +
+      rb.addGauge(Interns.info("Priority." + i + ".CompletedCallVolume",
+          "Completed Call volume " +
-  // Key: Top.0.Caller(xyz).Volume and Top.0.Caller(xyz).Priority
+  // Key: Caller(xyz).Volume and Caller(xyz).Priority
-    final int topCallerCount = 10;
-    TopN topNCallers = getTopCallers(topCallerCount);
+    TopN topNCallers = getTopCallers(topUsersCount);
-      String topCaller = "Top." + (actualCallerCount - i) + "." +
-          "Caller(" + entry.getName() + ")";
+      String topCaller = "Caller(" + entry.getName() + ")";
-  // Get the top N callers' call count and scheduler decision
+  // Get the top N callers' raw call count and scheduler decision
-    Iterator<Map.Entry<Object, AtomicLong>> it =
+    Iterator<Map.Entry<Object, List<AtomicLong>>> it =
-      Map.Entry<Object, AtomicLong> entry = it.next();
+      Map.Entry<Object, List<AtomicLong>> entry = it.next();
-      Long count = entry.getValue().get();
+      Long count = entry.getValue().get(1).get();

INS26 INS40 INS23 INS23 INS31 INS31 UPD74 INS83 INS83 MOV43 INS59 INS83 INS83 INS83 INS39 INS59 UPD42 INS83 INS39 INS42 INS8 INS83 INS39 INS42 MOV44 INS8 UPD42 INS44 INS74 UPD42 INS42 INS14 INS42 INS34 INS21 INS21 INS41 INS21 INS43 INS42 INS43 MOV43 UPD74 INS43 INS74 INS32 INS32 INS32 MOV21 INS32 INS42 UPD74 INS42 INS74 INS42 INS60 INS21 UPD74 INS43 MOV43 INS21 INS21 INS42 INS42 UPD42 INS32 INS42 INS32 INS25 UPD74 UPD42 UPD42 INS42 INS42 INS21 INS42 INS42 INS32 MOV32 INS32 INS74 INS43 INS43 INS39 INS59 UPD74 MOV60 INS32 INS74 INS42 MOV42 INS7 INS32 INS32 INS74 INS42 INS42 INS34 MOV42 INS42 INS34 UPD42 INS27 INS8 INS74 INS32 INS42 INS42 INS45 INS27 INS27 INS42 UPD42 MOV43 MOV43 INS74 UPD74 MOV74 INS42 INS42 INS42 INS34 UPD42 INS74 INS60 INS21 INS42 INS42 INS42 UPD42 UPD42 INS43 MOV43 INS32 INS42 INS14 INS42 INS42 MOV14 INS42 INS42 INS14 INS43 INS43 INS27 INS27 MOV25 INS43 MOV43 INS32 INS42 INS42 UPD42 INS45 INS45 INS45 INS45 INS43 MOV43 INS74 INS32 MOV43 MOV43 INS74 UPD74 MOV74 MOV59 INS43 INS59 INS7 INS42 MOV32 INS42 INS34 INS74 INS34 INS43 INS34 INS42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS43 MOV43 MOV32 INS42 INS43 MOV43 INS74 UPD42 INS32 MOV42 INS42 INS32 INS42 INS32 UPD42 UPD42 INS43 INS43 INS42 INS34 UPD45 UPD45 INS42 INS34 INS42 INS42 INS43 MOV43 MOV32 INS42 INS34 INS32 INS42 INS34 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 DEL74 DEL42 DEL7 DEL42 DEL42 DEL34 DEL27 DEL27 DEL45 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL45 DEL42 DEL42 DEL27 DEL36 DEL45 DEL74
HDFS-7496. Fix FsVolume removal race conditions on the DataNode by reference-counting the volume instances (lei via cmccabe)

+import java.nio.channels.ClosedChannelException;
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.server.datanode.fsdataset.FsVolumeReference;
+import org.apache.hadoop.util.CloseableReferenceCount;
+  private CloseableReferenceCount reference = new CloseableReferenceCount();
+    if (dataset.datanode == null) {
+      // FsVolumeImpl is used in test.
+      return null;
+    }
-  
+
+  private void printReferenceTraceInfo(String op) {
+    StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+    for (StackTraceElement ste : stack) {
+      switch (ste.getMethodName()) {
+      case "getDfsUsed":
+      case "getBlockPoolUsed":
+      case "getAvailable":
+      case "getVolumeMap":
+        return;
+      default:
+        break;
+      }
+    }
+    FsDatasetImpl.LOG.trace("Reference count: " + op + " " + this + ": " +
+        this.reference.getReferenceCount());
+    FsDatasetImpl.LOG.trace(
+        Joiner.on("\n").join(Thread.currentThread().getStackTrace()));
+  }
+
+  /**
+   * Increase the reference count. The caller must increase the reference count
+   * before issuing IOs.
+   *
+   * @throws IOException if the volume is already closed.
+   */
+  private void reference() throws ClosedChannelException {
+    this.reference.reference();
+    if (FsDatasetImpl.LOG.isTraceEnabled()) {
+      printReferenceTraceInfo("incr");
+    }
+  }
+
+  /**
+   * Decrease the reference count.
+   */
+  private void unreference() {
+    if (FsDatasetImpl.LOG.isTraceEnabled()) {
+      printReferenceTraceInfo("desc");
+    }
+    if (FsDatasetImpl.LOG.isDebugEnabled()) {
+      if (reference.getReferenceCount() <= 0) {
+        FsDatasetImpl.LOG.debug("Decrease reference count <= 0 on " + this +
+          Joiner.on("\n").join(Thread.currentThread().getStackTrace()));
+      }
+    }
+    checkReference();
+    this.reference.unreference();
+  }
+
+  private static class FsVolumeReferenceImpl implements FsVolumeReference {
+    private final FsVolumeImpl volume;
+
+    FsVolumeReferenceImpl(FsVolumeImpl volume) throws ClosedChannelException {
+      this.volume = volume;
+      volume.reference();
+    }
+
+    /**
+     * Decreases the reference count.
+     * @throws IOException it never throws IOException.
+     */
+    @Override
+    public void close() throws IOException {
+      volume.unreference();
+    }
+
+    @Override
+    public FsVolumeSpi getVolume() {
+      return this.volume;
+    }
+  }
+
+  @Override
+  public FsVolumeReference obtainReference() throws ClosedChannelException {
+    return new FsVolumeReferenceImpl(this);
+  }
+
+  private void checkReference() {
+    Preconditions.checkState(reference.getReferenceCount() > 0);
+  }
+
+  /**
+   * Close this volume and wait all other threads to release the reference count
+   * on this volume.
+   * @throws IOException if the volume is closed or the waiting is interrupted.
+   */
+  void closeAndWait() throws IOException {
+    try {
+      this.reference.setClosed();
+    } catch (ClosedChannelException e) {
+      throw new IOException("The volume has already closed.", e);
+    }
+    final int SLEEP_MILLIS = 500;
+    while (this.reference.getReferenceCount() > 0) {
+      if (FsDatasetImpl.LOG.isDebugEnabled()) {
+        FsDatasetImpl.LOG.debug(String.format(
+            "The reference count for %s is %d, wait to be 0.",
+            this, reference.getReferenceCount()));
+      }
+      try {
+        Thread.sleep(SLEEP_MILLIS);
+      } catch (InterruptedException e) {
+        throw new IOException(e);
+      }
+    }
+  }
+
+    checkReference();
+    checkReference();

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS55 INS31 INS31 INS31 INS83 INS43 INS59 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS8 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS78 INS83 INS43 INS42 INS43 INS8 INS83 INS39 INS42 INS8 INS29 INS39 INS42 INS43 INS8 INS42 INS42 INS14 INS25 INS43 INS42 INS60 INS70 INS21 INS21 INS65 INS65 INS42 INS21 INS25 INS65 INS25 INS25 INS21 INS21 INS42 INS83 INS83 INS43 INS59 INS42 INS44 INS43 INS8 INS29 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS43 INS42 INS8 INS42 INS42 INS42 INS41 INS21 INS65 INS65 INS42 INS54 INS60 INS61 INS21 INS21 INS43 INS27 INS8 INS42 INS5 INS59 INS44 INS42 INS8 INS32 INS32 INS66 INS66 INS42 INS66 INS32 INS32 INS8 INS66 INS32 INS8 INS32 INS8 INS32 INS32 INS42 INS42 INS43 INS42 INS42 INS21 INS21 INS65 INS65 INS42 INS42 INS21 INS42 INS42 INS41 INS14 INS32 INS66 INS66 INS42 INS66 INS8 INS12 INS83 INS39 INS59 INS27 INS8 INS32 INS32 INS42 INS40 INS33 INS41 INS43 INS85 INS42 INS32 INS43 INS42 INS50 INS40 INS42 INS27 INS40 INS42 INS32 INS22 INS42 INS40 INS42 INS21 INS40 INS42 INS21 INS40 INS42 INS25 INS42 INS22 INS42 INS42 INS7 INS32 INS66 INS42 INS66 INS32 INS22 INS43 INS52 INS42 INS42 INS27 INS21 INS44 INS8 INS42 INS34 INS32 INS34 INS25 INS54 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS32 INS49 INS49 INS49 INS49 INS41 INS49 INS10 INS45 INS42 INS45 INS52 INS45 INS32 INS32 INS42 INS32 INS52 INS42 INS32 INS32 INS27 INS8 INS52 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS32 INS34 INS32 INS43 INS42 INS53 INS22 INS42 INS32 INS8 INS8 INS12 INS42 INS42 INS42 INS42 INS45 INS45 INS45 INS45 INS22 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS42 INS45 INS32 INS34 INS21 INS52 INS42 INS42 INS42 INS22 INS42 INS42 INS14 INS52 INS42 INS40 INS42 INS21 INS21 INS44 INS8 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS43 INS45 INS42 INS32 INS32 INS43 INS42 INS53 INS40 INS42 INS27 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS14 INS45 INS52 INS32 INS42 INS42 INS45 INS52 INS32 INS43 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42
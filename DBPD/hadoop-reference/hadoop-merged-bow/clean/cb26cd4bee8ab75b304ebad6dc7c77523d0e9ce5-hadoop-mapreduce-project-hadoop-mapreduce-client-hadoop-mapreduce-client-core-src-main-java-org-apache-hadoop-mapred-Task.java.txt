MAPREDUCE-6489. Fail fast rogue tasks that write too much to local disk. Contributed by Maysam Yabandeh

+import org.apache.hadoop.fs.LocalFileSystem;
+import org.apache.hadoop.util.ExitUtil;
-    }  
-    /** 
-     * The communication thread handles communication with the parent (Task Tracker). 
-     * It sends progress updates if progress has been made or if the task needs to 
-     * let the parent know that it's alive. It also pings the parent to see if it's alive. 
+    }
+
+    /**
+     * exception thrown when the task exceeds some configured limits.
+     */
+    public class TaskLimitException extends IOException {
+      public TaskLimitException(String str) {
+        super(str);
+      }
+    }
+
+    /**
+     * check the counters to see whether the task has exceeded any configured
+     * limits.
+     * @throws TaskLimitException
+     */
+    protected void checkTaskLimits() throws TaskLimitException {
+      // check the limit for writing to local file system
+      long limit = conf.getLong(MRJobConfig.TASK_LOCAL_WRITE_LIMIT_BYTES,
+              MRJobConfig.DEFAULT_TASK_LOCAL_WRITE_LIMIT_BYTES);
+      if (limit >= 0) {
+        Counters.Counter localWritesCounter = null;
+        try {
+          LocalFileSystem localFS = FileSystem.getLocal(conf);
+          localWritesCounter = counters.findCounter(localFS.getScheme(),
+                  FileSystemCounter.BYTES_WRITTEN);
+        } catch (IOException e) {
+          LOG.warn("Could not get LocalFileSystem BYTES_WRITTEN counter");
+        }
+        if (localWritesCounter != null
+                && localWritesCounter.getCounter() > limit) {
+          throw new TaskLimitException("too much write to local file system." +
+                  " current value is " + localWritesCounter.getCounter() +
+                  " the limit is " + limit);
+        }
+      }
+    }
+
+    /**
+     * The communication thread handles communication with the parent (Task
+     * Tracker). It sends progress updates if progress has been made or if
+     * the task needs to let the parent know that it's alive. It also pings
+     * the parent to see if it's alive.
+            checkTaskLimits();
-                                    taskProgress.toString(), 
+                                    taskProgress.toString(),
-          sendProgress = resetProgressFlag(); 
+          sendProgress = resetProgressFlag();
-        } 
-        catch (Throwable t) {
+        } catch (TaskLimitException e) {
+          String errMsg = "Task exceeded the limits: " +
+                  StringUtils.stringifyException(e);
+          LOG.fatal(errMsg);
+          try {
+            umbilical.fatalError(taskId, errMsg);
+          } catch (IOException ioe) {
+            LOG.fatal("Failed to update failure diagnosis", ioe);
+          }
+          LOG.fatal("Killing " + taskId);
+          resetDoneFlag();
+          ExitUtil.terminate(69);
+        } catch (Throwable t) {

INS26 INS26 INS40 INS40 INS55 INS31 INS29 INS83 INS42 INS43 INS31 INS29 INS83 INS39 INS42 INS43 INS8 INS65 INS42 INS83 INS42 INS44 INS8 INS65 INS65 INS42 INS60 INS25 INS66 INS43 INS42 INS46 INS66 INS66 INS42 INS39 INS59 INS27 INS8 UPD66 UPD66 UPD66 INS66 INS42 INS42 INS42 INS32 INS42 INS34 INS60 INS54 INS25 INS42 INS42 INS40 INS40 INS43 INS59 INS8 INS12 INS27 INS8 INS12 INS40 INS42 INS33 INS60 INS21 INS44 INS8 INS27 INS27 INS53 INS44 INS8 INS43 INS59 INS7 INS43 INS42 INS21 INS42 INS33 INS32 INS42 INS14 INS43 INS42 INS60 INS21 INS54 INS21 INS21 INS21 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS43 INS27 INS21 INS42 INS43 INS59 INS32 INS8 INS12 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS45 INS42 INS27 INS32 INS45 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS34 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS45 INS32 INS32 INS43 INS42 INS21 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42
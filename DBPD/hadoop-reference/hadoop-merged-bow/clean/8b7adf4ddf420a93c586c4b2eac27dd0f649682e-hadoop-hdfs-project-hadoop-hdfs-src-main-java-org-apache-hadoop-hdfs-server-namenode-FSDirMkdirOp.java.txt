HDFS-10768. Optimize mkdir ops. Contributed by Daryn Sharp.

-import java.util.AbstractMap;
-import java.util.Map;
-
-      INodesInPath existing = lastINode != null ? iip : iip.getExistingINodes();
-        List<String> nonExisting = iip.getPath(existing.length(),
-            iip.length() - existing.length());
-        int length = nonExisting.size();
-        if (length > 1) {
-          List<String> ancestors = nonExisting.subList(0, length - 1);
-          // Ensure that the user can traversal the path by adding implicit
-          // u+wx permission to all ancestor directories
-          existing = createChildrenDirectories(fsd, existing, ancestors,
-              addImplicitUwx(permissions, permissions));
-          if (existing == null) {
-            throw new IOException("Failed to create directory: " + src);
-          }
+        // Ensure that the user can traversal the path by adding implicit
+        // u+wx permission to all ancestor directories.
+        INodesInPath existing =
+            createParentDirectories(fsd, iip, permissions, false);
+        if (existing != null) {
+          existing = createSingleDirectory(
+              fsd, existing, iip.getLastLocalName(), permissions);
-
-        if ((existing = createChildrenDirectories(fsd, existing,
-            nonExisting.subList(length - 1, length), permissions)) == null) {
+        if (existing == null) {
+        iip = existing;
-      return fsd.getAuditFileInfo(existing);
+      return fsd.getAuditFileInfo(iip);
-   * @return a tuple which contains both the new INodesInPath (with all the
-   * existing and newly created directories) and the last component in the
-   * relative path. Or return null if there are errors.
+   * @return a INodesInPath with all the existing and newly created
+   *         ancestor directories created.
+   *         Or return null if there are errors.
-  static Map.Entry<INodesInPath, String> createAncestorDirectories(
+  static INodesInPath createAncestorDirectories(
-    final String last = DFSUtil.bytes2String(iip.getLastLocalName());
-    INodesInPath existing = iip.getExistingINodes();
-    List<String> children = iip.getPath(existing.length(),
-        iip.length() - existing.length());
-    int size = children.size();
-    if (size > 1) { // otherwise all ancestors have been created
-      List<String> directories = children.subList(0, size - 1);
-      INode parentINode = existing.getLastINode();
-      // Ensure that the user can traversal the path by adding implicit
-      // u+wx permission to all ancestor directories
-      existing = createChildrenDirectories(fsd, existing, directories,
-          addImplicitUwx(parentINode.getPermissionStatus(), permission));
-      if (existing == null) {
-        return null;
-      }
-    }
-    return new AbstractMap.SimpleImmutableEntry<>(existing, last);
+    return createParentDirectories(fsd, iip, permission, true);
-   * Create the directory {@code parent} / {@code children} and all ancestors
-   * along the path.
+   * Create all ancestor directories and return the parent inodes.
+   * @param inheritPerms if the ancestor directories should inherit permissions
+   *                 or use the specified permissions.
-  private static INodesInPath createChildrenDirectories(FSDirectory fsd,
-      INodesInPath existing, List<String> children, PermissionStatus perm)
+  private static INodesInPath createParentDirectories(FSDirectory fsd,
+      INodesInPath iip, PermissionStatus perm, boolean inheritPerms)
-
-    for (String component : children) {
-      existing = createSingleDirectory(fsd, existing, component, perm);
-      if (existing == null) {
-        return null;
+    // this is the desired parent iip if the subsequent delta is 1.
+    INodesInPath existing = iip.getExistingINodes();
+    int missing = iip.length() - existing.length();
+    if (missing == 0) {  // full path exists, return parents.
+      existing = iip.getParentINodesInPath();
+    } else if (missing > 1) { // need to create at least one ancestor dir.
+      // Ensure that the user can traversal the path by adding implicit
+      // u+wx permission to all ancestor directories.
+      PermissionStatus basePerm = inheritPerms
+          ? existing.getLastINode().getPermissionStatus()
+          : perm;
+      perm = addImplicitUwx(basePerm, perm);
+      // create all the missing directories.
+      final int last = iip.length() - 2;
+      for (int i = existing.length(); existing != null && i <= last; i++) {
+        byte[] component = iip.getPathComponent(i);
+        existing = createSingleDirectory(fsd, existing, component, perm);
-      INodesInPath existing, String localName, PermissionStatus perm)
+      INodesInPath existing, byte[] localName, PermissionStatus perm)
-        DFSUtil.string2Bytes(localName), perm, null, now());
+        localName, perm, null, now());

INS31 INS31 MOV29 MOV83 MOV43 MOV42 MOV44 MOV44 MOV44 MOV43 INS8 MOV29 INS83 INS83 MOV43 INS42 MOV44 INS44 MOV44 INS44 MOV43 INS8 INS41 INS65 INS65 INS43 INS42 INS39 INS42 MOV6 MOV60 MOV60 INS25 MOV41 INS5 UPD66 UPD66 UPD66 INS32 UPD66 MOV66 INS42 UPD66 MOV66 UPD66 MOV66 INS42 INS39 UPD27 MOV27 INS8 INS25 INS39 INS85 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS9 UPD42 MOV27 UPD42 UPD34 INS21 INS27 INS8 INS7 UPD42 MOV42 MOV34 MOV60 MOV21 INS60 INS24 MOV42 MOV25 INS21 UPD42 INS42 INS32 UPD43 INS83 INS39 INS59 INS58 INS27 INS37 MOV8 MOV43 UPD27 INS7 INS42 UPD42 MOV42 UPD42 INS42 INS16 UPD42 INS32 INS42 INS27 INS39 INS59 INS27 INS27 INS42 INS60 UPD42 UPD42 INS33 UPD42 MOV42 INS42 INS42 INS32 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS34 INS42 MOV32 INS42 INS33 INS42 INS42 INS5 INS59 UPD42 UPD42 MOV42 UPD42 MOV42 INS9 MOV32 INS42 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS42 INS42 UPD42 MOV32 MOV42 UPD42 MOV42 UPD42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL34 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL27 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL42 DEL32 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL66 DEL65 DEL66 DEL66 DEL65 DEL65 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL40 DEL43 DEL42 DEL43 DEL74 DEL83 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL34 DEL27 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL8 DEL25 DEL40 DEL43 DEL74 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL70 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL32
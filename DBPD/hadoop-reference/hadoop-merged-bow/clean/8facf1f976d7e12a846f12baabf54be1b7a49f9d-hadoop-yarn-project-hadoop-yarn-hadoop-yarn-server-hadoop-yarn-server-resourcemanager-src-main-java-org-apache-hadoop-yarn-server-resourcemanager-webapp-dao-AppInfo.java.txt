YARN-6871. Add additional deSelects params in RMWebServices#getAppReport. Contributed by Tanuj Nayak.

-  protected AppTimeoutsInfo timeouts = new AppTimeoutsInfo();
+  private AppTimeoutsInfo timeouts;
-      amNodeLabelExpression = (unmanagedApplication) ? null
-          : app.getAMResourceRequests().get(0).getNodeLabelExpression();
+      /*
+       * When the deSelects parameter contains "amNodeLabelExpression", objects
+       * pertaining to the amNodeLabelExpression are not returned. By default,
+       * this is not skipped. (YARN-6871)
+       */
+      if(!deSelects.contains(DeSelectType.AM_NODE_LABEL_EXPRESSION)) {
+        amNodeLabelExpression = (unmanagedApplication) ?
+            null :
+            app.getAMResourceRequests().get(0).getNodeLabelExpression();
+      }
+      /*
+       * When the deSelects parameter contains "appNodeLabelExpression", objects
+       * pertaining to the appNodeLabelExpression are not returned. By default,
+       * this is not skipped. (YARN-6871)
+       */
+      if (!deSelects.contains(DeSelectType.APP_NODE_LABEL_EXPRESSION)) {
+        appNodeLabelExpression =
+            app.getApplicationSubmissionContext().getNodeLabelExpression();
+      }
+      /*
+       * When the deSelects parameter contains "amNodeLabelExpression", objects
+       * pertaining to the amNodeLabelExpression are not returned. By default,
+       * this is not skipped. (YARN-6871)
+       */
+      if (!deSelects.contains(DeSelectType.AM_NODE_LABEL_EXPRESSION)) {
+        amNodeLabelExpression = (unmanagedApplication) ?
+            null :
+            app.getAMResourceRequests().get(0).getNodeLabelExpression();
+      }
+      /*
+       * When the deSelects parameter contains "resourceInfo", ResourceInfo
+       * objects are not returned. Default behavior is no skipping. (YARN-6871)
+       */
-      ResourceScheduler scheduler = rm.getRMContext().getScheduler();
-      if (scheduler instanceof CapacityScheduler) {
-        RMAppAttempt attempt = app.getCurrentAppAttempt();
-        if (null != attempt) {
-          FiCaSchedulerApp ficaAppAttempt = ((CapacityScheduler) scheduler)
-              .getApplicationAttempt(attempt.getAppAttemptId());
-          resourceInfo = null != ficaAppAttempt
-              ? new ResourcesInfo(ficaAppAttempt.getSchedulingResourceUsage())
-              : null;
-        }
-      }
-
-      Map<ApplicationTimeoutType, Long> applicationTimeouts =
-          app.getApplicationTimeouts();
-      if (applicationTimeouts.isEmpty()) {
-        // If application is not set timeout, lifetime should be sent as default
-        // with expiryTime=UNLIMITED and remainingTime=-1
-        AppTimeoutInfo timeoutInfo = new AppTimeoutInfo();
-        timeoutInfo.setTimeoutType(ApplicationTimeoutType.LIFETIME);
-        timeouts.add(timeoutInfo);
-      } else {
-        for (Map.Entry<ApplicationTimeoutType, Long> entry : app
-            .getApplicationTimeouts().entrySet()) {
-          AppTimeoutInfo timeout = new AppTimeoutInfo();
-          timeout.setTimeoutType(entry.getKey());
-          long timeoutInMillis = entry.getValue().longValue();
-          timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));
-          if (app.isAppInCompletedStates()) {
-            timeout.setRemainingTime(0);
-          } else {
-            timeout.setRemainingTime(Math
-                .max((timeoutInMillis - System.currentTimeMillis()) / 1000, 0));
+      if (!deSelects.contains(DeSelectType.RESOURCE_INFO)) {
+        ResourceScheduler scheduler = rm.getRMContext().getScheduler();
+        if (scheduler instanceof CapacityScheduler) {
+          RMAppAttempt attempt = app.getCurrentAppAttempt();
+          if (null != attempt) {
+            FiCaSchedulerApp ficaAppAttempt = ((CapacityScheduler) scheduler)
+                .getApplicationAttempt(attempt.getAppAttemptId());
+            resourceInfo = null != ficaAppAttempt ?
+                new ResourcesInfo(ficaAppAttempt.getSchedulingResourceUsage()) :
+                null;
-          timeouts.add(timeout);
+      /*
+       * When the deSelects parameter contains "appTimeouts", objects pertaining
+       * to app timeouts are not returned. By default, this is not skipped.
+       * (YARN-6871)
+       */
+      if (!deSelects.contains(DeSelectType.TIMEOUTS)) {
+        Map<ApplicationTimeoutType, Long> applicationTimeouts =
+            app.getApplicationTimeouts();
+        if (applicationTimeouts.isEmpty()) {
+          // If application is not set timeout, lifetime should be sent
+          // as default with expiryTime=UNLIMITED and remainingTime=-1
+          AppTimeoutInfo timeoutInfo = new AppTimeoutInfo();
+          timeoutInfo.setTimeoutType(ApplicationTimeoutType.LIFETIME);
+          timeouts = new AppTimeoutsInfo();
+          timeouts.add(timeoutInfo);
+        } else {
+          for (Map.Entry<ApplicationTimeoutType, Long> entry : app
+              .getApplicationTimeouts().entrySet()) {
+            AppTimeoutInfo timeout = new AppTimeoutInfo();
+            timeout.setTimeoutType(entry.getKey());
+            long timeoutInMillis = entry.getValue().longValue();
+            timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));
+            if (app.isAppInCompletedStates()) {
+              timeout.setRemainingTime(0);
+            } else {
+              timeout.setRemainingTime(Math.max(
+                  (timeoutInMillis - System.currentTimeMillis()) / 1000, 0));
+            }
+            timeouts.add(timeout);
+          }
+        }
+      }

UPD83 INS25 INS25 INS25 INS25 INS25 INS38 INS8 INS38 INS8 INS38 INS8 INS38 INS8 INS38 INS8 INS32 MOV21 INS32 INS21 INS32 INS21 INS32 MOV60 MOV25 INS32 MOV60 MOV25 INS42 INS42 INS40 INS42 INS42 INS40 INS7 INS42 INS42 INS40 INS7 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS32 INS42 INS16 INS21 INS32 INS42 INS36 INS33 INS32 INS7 INS42 INS42 INS42 INS32 INS42 INS42 MOV14 INS32 INS42 INS34 INS42 INS42
HDDS-1317. KeyOutputStream#write throws ArrayIndexOutOfBoundsException when running RandomWrite MR examples. Contributed by Shashikant Banerjee.

+  /**
+   * Defines stream action while calling handleFlushOrClose.
+   */
+  enum StreamAction {
+    FLUSH, CLOSE, FULL
+  }
+
-        handleFlushOrClose(true);
-        currentStreamIndex += 1;
+        handleFlushOrClose(StreamAction.FULL);
-      closedContainerException = checkIfContainerIsClosed(exception);
+      closedContainerException = checkIfContainerIsClosed(t);
-        streamEntry.getTotalSuccessfulFlushedData();
+        streamEntry.getTotalAckDataLength();
-    LOG.warn("Encountered exception {}", exception);
-    LOG.info(
-        "The last committed block length is {}, uncommitted data length is {}",
+    LOG.warn("Encountered exception {}. The last committed block length is {}, "
+            + "uncommitted data length is {}", exception,
+    Preconditions.checkArgument(
+        streamEntry.getWrittenDataLength() - totalSuccessfulFlushedData
+            == bufferedDataLen);
-  private Throwable checkForException(IOException ioe) throws IOException {
+  public Throwable checkForException(IOException ioe) throws IOException {
-    return streamEntries.parallelStream().mapToLong(e -> e.getCurrentPosition())
+    return streamEntries.stream().mapToLong(e -> e.getCurrentPosition())
-    handleFlushOrClose(false);
+    handleFlushOrClose(StreamAction.FLUSH);
-   * Close or Flush the latest outputStream.
-   * @param close Flag which decides whether to call close or flush on the
+   * Close or Flush the latest outputStream depending upon the action.
+   * This function gets called when while write is going on, the current stream
+   * gets full or explicit flush or close request is made by client. when the
+   * stream gets full and we try to close the stream , we might end up hitting
+   * an exception in the exception handling path, we write the data residing in
+   * in the buffer pool to a new Block. In cases, as such, when the data gets
+   * written to new stream , it will be at max half full. In such cases, we
+   * should just write the data and not close the stream as the block won't be
+   * completely full.
+   * @param op Flag which decides whether to call close or flush on the
-  private void handleFlushOrClose(boolean close) throws IOException {
+  private void handleFlushOrClose(StreamAction op) throws IOException {
-          if (close) {
+          switch (op) {
+          case CLOSE:
-          } else {
+            break;
+          case FULL:
+            if (entry.getRemaining() == 0) {
+              entry.close();
+              currentStreamIndex++;
+            }
+            break;
+          case FLUSH:
+            break;
+          default:
+            throw new IOException("Invalid Operation");
-      handleFlushOrClose(true);
+      handleFlushOrClose(StreamAction.CLOSE);

INS71 INS29 INS42 INS72 INS72 INS72 MOV21 UPD83 INS65 INS42 INS42 INS42 INS43 INS42 INS66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 INS42 INS27 INS42 INS42 UPD42 UPD42 INS27 INS40 UPD42 INS45 INS45 INS27 INS42 INS32 INS42 UPD42 INS40 UPD42 INS42 INS42 INS40 INS50 INS42 INS49 INS21 INS10 INS49 INS25 INS10 INS49 MOV21 INS10 INS49 INS53 INS42 INS32 INS42 INS27 MOV8 INS42 INS14 INS42 INS42 INS32 INS34 INS21 INS43 INS45 INS42 INS42 INS37 INS42 INS42 DEL9 DEL42 DEL34 DEL7 DEL21 DEL45 DEL45 DEL42 DEL42 DEL9 DEL39 DEL42 DEL42 DEL8 DEL25 DEL9
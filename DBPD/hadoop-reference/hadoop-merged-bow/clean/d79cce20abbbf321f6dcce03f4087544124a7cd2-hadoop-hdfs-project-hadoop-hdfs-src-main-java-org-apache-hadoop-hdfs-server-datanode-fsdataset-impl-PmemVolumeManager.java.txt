HDFS-14740. Recover data blocks from persistent memory read cache during datanode restarts. Contributed by Feilong He.

+import org.apache.commons.io.filefilter.TrueFileFilter;
+import java.util.Collection;
-    private final long maxBytes;
+    private long maxBytes;
+
+    void setMaxBytes(long maxBytes) {
+      this.maxBytes = maxBytes;
+    }
+  private boolean cacheRecoveryEnabled;
-  private PmemVolumeManager(String[] pmemVolumesConfig) throws IOException {
+  private PmemVolumeManager(String[] pmemVolumesConfig,
+                            boolean cacheRecoveryEnabled) throws IOException {
-          DFSConfigKeys.DFS_DATANODE_CACHE_PMEM_DIRS_KEY +
+          DFSConfigKeys.DFS_DATANODE_PMEM_CACHE_DIRS_KEY +
+    this.cacheRecoveryEnabled = cacheRecoveryEnabled;
-  public synchronized static void init(String[] pmemVolumesConfig)
+  public synchronized static void init(
+      String[] pmemVolumesConfig, boolean cacheRecoveryEnabled)
-      pmemVolumeManager = new PmemVolumeManager(pmemVolumesConfig);
+      pmemVolumeManager = new PmemVolumeManager(pmemVolumesConfig,
+          cacheRecoveryEnabled);
+  public static void reset() {
+    pmemVolumeManager = null;
+  }
+
+  @VisibleForTesting
-        // Clean up the cache left before, if any.
-        cleanup(realPmemDir);
+        if (!cacheRecoveryEnabled) {
+          // Clean up the cache left before, if any.
+          cleanup(realPmemDir);
+        }
+  /**
+   * Recover cache from the cached files in the configured pmem volumes.
+   */
+  public Map<ExtendedBlockId, MappableBlock> recoverCache(
+      String bpid, MappableBlockLoader cacheLoader) throws IOException {
+    final Map<ExtendedBlockId, MappableBlock> keyToMappableBlock
+        = new ConcurrentHashMap<>();
+    for (byte volumeIndex = 0; volumeIndex < pmemVolumes.size();
+         volumeIndex++) {
+      long maxBytes = usedBytesCounts.get(volumeIndex).getMaxBytes();
+      long usedBytes = 0;
+      File cacheDir = new File(pmemVolumes.get(volumeIndex), bpid);
+      Collection<File> cachedFileList = FileUtils.listFiles(cacheDir,
+          TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE);
+      // Scan the cached files in pmem volumes for cache recovery.
+      for (File cachedFile : cachedFileList) {
+        MappableBlock mappableBlock = cacheLoader.
+            getRecoveredMappableBlock(cachedFile, bpid, volumeIndex);
+        ExtendedBlockId key = mappableBlock.getKey();
+        keyToMappableBlock.put(key, mappableBlock);
+        usedBytes += cachedFile.length();
+      }
+      // Update maxBytes and cache capacity according to cache space
+      // used by recovered cached files.
+      usedBytesCounts.get(volumeIndex).setMaxBytes(maxBytes + usedBytes);
+      cacheCapacity += usedBytes;
+      usedBytesCounts.get(volumeIndex).reserve(usedBytes);
+    }
+    return keyToMappableBlock;
+  }
+
+  public void recoverBlockKeyToVolume(ExtendedBlockId key, byte volumeIndex) {
+    blockKeyToVolume.put(key, volumeIndex);
+  }
+
+  /**
+   * Create cache subdirectory specified with blockPoolId.
+   */
+  public void createBlockPoolDir(String bpid) throws IOException {
+    for (String volume : pmemVolumes) {
+      File cacheDir = new File(volume, bpid);
+      if (!cacheDir.exists() && !cacheDir.mkdir()) {
+        throw new IOException("Failed to create " + cacheDir.getPath());
+      }
+    }
+  }
+
-  /**
-   * The cache file is named as BlockPoolId-BlockId.
-   * So its name can be inferred by BlockPoolId and BlockId.
-   */
-  public String getCacheFileName(ExtendedBlockId key) {
-    return key.getBlockPoolId() + "-" + key.getBlockId();
+  ArrayList<String> getVolumes() {
+    return pmemVolumes;
-   * Considering the pmem volume size is below TB level currently,
-   * it is tolerable to keep cache files under one directory.
-   * The strategy will be optimized, especially if one pmem volume
-   * has huge cache capacity.
+   * A cache file is named after the corresponding BlockId.
+   * Thus, cache file name can be inferred according to BlockId.
+   */
+  public String idToCacheFileName(ExtendedBlockId key) {
+    return String.valueOf(key.getBlockId());
+  }
+
+  /**
+   * Create and get the directory where a cache file with this key and
+   * volumeIndex should be stored. Use hierarchical strategy of storing
+   * blocks to avoid keeping cache files under one directory.
-  public String inferCacheFilePath(Byte volumeIndex, ExtendedBlockId key) {
-    return pmemVolumes.get(volumeIndex) + "/" + getCacheFileName(key);
+  public String idToCacheFilePath(Byte volumeIndex, ExtendedBlockId key)
+      throws IOException {
+    final String cacheSubdirPrefix = "subdir";
+    long blockId = key.getBlockId();
+    String bpid = key.getBlockPoolId();
+    int d1 = (int) ((blockId >> 16) & 0x1F);
+    int d2 = (int) ((blockId >> 8) & 0x1F);
+    String parentDir = pmemVolumes.get(volumeIndex) + "/" + bpid;
+    String subDir = cacheSubdirPrefix + d1 + "/" + cacheSubdirPrefix + d2;
+    File filePath = new File(parentDir, subDir);
+    if (!filePath.exists() && !filePath.mkdirs()) {
+      throw new IOException("Failed to create " + filePath.getPath());
+    }
+    return filePath.getAbsolutePath() + "/" + idToCacheFileName(key);
-   * The cache file path is pmemVolume/BlockPoolId-BlockId.
+   * The cache file path is pmemVolume/BlockPoolId/subdir#/subdir#/BlockId.
-  public String getCachePath(ExtendedBlockId key) {
+  public String getCachePath(ExtendedBlockId key) throws IOException {
-    return inferCacheFilePath(volumeIndex, key);
+    return idToCacheFilePath(volumeIndex, key);

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS39 INS59 INS44 INS44 INS78 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS74 INS42 INS8 INS43 UPD42 UPD42 INS43 INS43 INS39 INS42 INS44 INS8 INS42 INS39 INS42 INS21 INS39 INS42 INS42 INS21 INS65 INS43 INS43 INS43 INS43 INS42 INS43 INS42 INS42 INS60 INS24 INS41 INS43 INS42 INS39 INS42 INS21 INS65 INS43 INS42 INS42 INS70 INS43 INS43 INS41 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS25 INS42 INS39 INS42 INS21 INS7 INS7 INS66 INS42 INS42 INS42 INS42 INS42 INS83 INS74 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS32 INS66 INS42 INS44 INS42 INS8 INS42 INS42 INS42 UPD66 UPD66 INS32 UPD66 UPD66 UPD66 INS83 INS43 INS59 INS39 INS59 MOV43 INS59 INS39 INS59 INS39 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS27 UPD66 INS7 INS22 INS42 INS42 INS33 INS43 INS43 INS43 INS42 INS14 INS39 INS59 INS42 INS32 INS42 INS60 INS60 INS60 INS60 INS70 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS43 INS42 INS60 INS25 INS42 INS42 MOV32 INS42 INS42 INS45 INS42 INS32 INS42 MOV32 INS42 INS11 INS42 INS11 INS42 INS42 MOV27 INS42 INS42 INS27 INS42 INS42 INS14 INS38 INS38 INS53 INS32 INS45 INS32 UPD42 INS22 INS42 INS52 INS42 INS42 INS42 INS42 INS74 INS42 INS34 INS42 INS42 INS39 INS59 INS39 INS59 INS43 INS59 INS74 INS59 INS44 INS42 INS8 INS32 INS7 INS32 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS39 INS36 INS39 INS36 INS42 INS42 INS42 INS45 INS42 INS42 INS43 INS42 INS42 INS32 INS32 INS14 INS42 INS42 INS42 INS42 INS52 INS42 INS25 INS43 INS42 INS32 INS42 INS34 INS42 INS42 INS14 INS43 INS43 INS42 INS32 INS43 INS42 INS60 INS60 INS21 INS21 INS32 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS14 INS38 INS38 INS53 INS27 INS27 INS42 INS42 INS42 INS42 INS42 INS43 INS27 UPD40 INS42 INS38 INS8 INS42 INS32 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS43 INS59 INS43 INS59 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS32 INS14 INS36 INS34 INS36 INS34 INS42 INS45 INS32 INS42 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS27 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS34 INS42 INS34 INS42 INS42 DEL83 DEL45 DEL27 DEL66 DEL42 DEL42 DEL32
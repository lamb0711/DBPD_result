HDFS-15369. Refactor method VolumeScanner#runLoop(). Contributed by Yang Yun.

+   * Get next block and check if it's needed to scan.
+   *
+   * @return  the candidate block.
+   */
+  ExtendedBlock getNextBlockToScan() {
+    ExtendedBlock block;
+    try {
+      block = curBlockIter.nextBlock();
+    } catch (IOException e) {
+      // There was an error listing the next block in the volume.  This is a
+      // serious issue.
+      LOG.warn("{}: nextBlock error on {}", this, curBlockIter);
+      // On the next loop iteration, curBlockIter#eof will be set to true, and
+      // we will pick a different block iterator.
+      return null;
+    }
+    if (block == null) {
+      // The BlockIterator is at EOF.
+      LOG.info("{}: finished scanning block pool {}",
+          this, curBlockIter.getBlockPoolId());
+      saveBlockIterator(curBlockIter);
+      return null;
+    } else if (conf.skipRecentAccessed) {
+      // Check the access time of block file to avoid scanning recently
+      // changed blocks, reducing disk IO.
+      try {
+        BlockLocalPathInfo blockLocalPathInfo =
+            volume.getDataset().getBlockLocalPathInfo(block);
+        BasicFileAttributes attr = Files.readAttributes(
+            new File(blockLocalPathInfo.getBlockPath()).toPath(),
+            BasicFileAttributes.class);
+        if (System.currentTimeMillis() - attr.lastAccessTime().
+            to(TimeUnit.MILLISECONDS) < conf.scanPeriodMs) {
+          return null;
+        }
+      } catch (IOException ioe) {
+        LOG.debug("Failed to get access time of block {}",
+            block, ioe);
+      }
+    }
+    return block;
+  }
+
+  /**
-      // Find a usable block pool to scan.
+        // Find a usable block pool to scan.
-        try {
-          block = curBlockIter.nextBlock();
-        } catch (IOException e) {
-          // There was an error listing the next block in the volume.  This is a
-          // serious issue.
-          LOG.warn("{}: nextBlock error on {}", this, curBlockIter);
-          // On the next loop iteration, curBlockIter#eof will be set to true, and
-          // we will pick a different block iterator.
-          return 0L;
-        }
+        block = getNextBlockToScan();
-          // The BlockIterator is at EOF.
-          LOG.info("{}: finished scanning block pool {}",
-              this, curBlockIter.getBlockPoolId());
-          saveBlockIterator(curBlockIter);
-          return 0;
-        } else if (conf.skipRecentAccessed) {
-          // Check the access time of block file to avoid scanning recently
-          // changed blocks, reducing disk IO.
-          try {
-            BlockLocalPathInfo blockLocalPathInfo =
-                volume.getDataset().getBlockLocalPathInfo(block);
-            BasicFileAttributes attr = Files.readAttributes(
-                new File(blockLocalPathInfo.getBlockPath()).toPath(),
-                BasicFileAttributes.class);
-            if (System.currentTimeMillis() - attr.lastAccessTime().
-                to(TimeUnit.MILLISECONDS) < conf.scanPeriodMs) {
-              return 0;
-            }
-
-          } catch (IOException ioe) {
-            LOG.debug("Failed to get access time of block {}",
-                block, ioe);
-          }
+          return 0L;

INS31 INS29 INS43 INS42 MOV8 INS65 INS65 INS42 INS60 INS41 INS66 INS66 INS43 INS59 INS42 INS42 INS42 INS41 INS33 INS8 INS33 MOV25 INS21 INS25 INS7 INS27 INS8 INS42 INS32 INS42 INS33 MOV41 INS42 INS33 DEL34 DEL34
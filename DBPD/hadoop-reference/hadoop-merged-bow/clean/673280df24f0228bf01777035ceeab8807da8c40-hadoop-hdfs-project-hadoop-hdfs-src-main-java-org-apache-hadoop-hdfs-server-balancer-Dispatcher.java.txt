HDFS-7621. Erasure Coding: update the Balancer/Mover data migration logic. Contributed by Walter Su.

+import static org.apache.hadoop.hdfs.util.StripedBlockUtil.getInternalBlockLength;
+import org.apache.hadoop.hdfs.protocol.HdfsConstants;
+import org.apache.hadoop.hdfs.server.protocol.BlocksWithLocations.StripedBlockWithLocations;
-     * Get the block from the map;
-     * if the block is not found, create a new block and put it in the map.
+     * Put block in the map if it's not found
+     * @return the block which be put in the map the first time
-    private DBlock get(Block b) {
-      DBlock block = map.get(b);
-      if (block == null) {
-        block = new DBlock(b);
-        map.put(b, block);
+    private DBlock putIfAbsent(Block blk, DBlock dblk) {
+      if (!map.containsKey(blk)) {
+        map.put(blk, dblk);
+        return dblk;
-      return block;
+      return map.get(blk);
-    
+
-  /** This class keeps track of a scheduled block move */
+  /** This class keeps track of a scheduled reportedBlock move */
-    private DBlock block;
+    private DBlock reportedBlock;
-      final Block b = block != null ? block.getBlock() : null;
+      final Block b = reportedBlock != null ? reportedBlock.getBlock() : null;
-     * Choose a block & a proxy source for this pendingMove whose source &
-     * target have already been chosen.
+     * Choose a good block/blockGroup from source & Get reportedBlock from
+     * the block & Choose a proxy source for the reportedBlock.
-            this.block = block;
+            if (block instanceof DBlockStriped) {
+              reportedBlock = ((DBlockStriped) block).getInternalBlock(source);
+            } else {
+              reportedBlock = block;
+            }
-        for (StorageGroup loc : block.getLocations()) {
+        for (StorageGroup loc : reportedBlock.getLocations()) {
-      for (StorageGroup loc : block.getLocations()) {
+      for (StorageGroup loc : reportedBlock.getLocations()) {
-      for (StorageGroup loc : block.getLocations()) {
+      for (StorageGroup loc : reportedBlock.getLocations()) {
-    /** add to a proxy source for specific block movement */
+    /** add to a proxy source for specific reportedBlock movement */
+      assert !(reportedBlock instanceof DBlockStriped);
-            block.getBlock());
+            reportedBlock.getBlock());
-        nnc.getBytesMoved().addAndGet(block.getNumBytes());
+        nnc.getBytesMoved().addAndGet(reportedBlock.getNumBytes());
-    /** Send a block replace request to the output stream */
+    /** Send a reportedBlock replace request to the output stream */
-    /** Receive a block copy response from the input stream */
+    /** Receive a reportedBlock copy response from the input stream */
-      String logInfo = "block move is failed";
+      String logInfo = "reportedBlock move is failed";
-      block = null;
+      reportedBlock = null;
+
+    public long getNumBytes(StorageGroup storage) {
+      return super.getNumBytes();
+    }
+  }
+
+  public static class DBlockStriped extends DBlock {
+
+    final byte[] indices;
+    final short dataBlockNum;
+
+    public DBlockStriped(Block block, byte[] indices, short dataBlockNum) {
+      super(block);
+      this.indices = indices;
+      this.dataBlockNum = dataBlockNum;
+    }
+
+    public DBlock getInternalBlock(StorageGroup storage) {
+      int idxInLocs = locations.indexOf(storage);
+      if (idxInLocs == -1) {
+        return null;
+      }
+      byte idxInGroup = indices[idxInLocs];
+      long blkId = getBlock().getBlockId() + idxInGroup;
+      long numBytes = getInternalBlockLength(getNumBytes(),
+          HdfsConstants.BLOCK_STRIPED_CELL_SIZE, dataBlockNum, idxInGroup);
+      Block blk = new Block(getBlock());
+      blk.setBlockId(blkId);
+      blk.setNumBytes(numBytes);
+      DBlock dblk = new DBlock(blk);
+      dblk.addLocation(storage);
+      return dblk;
+    }
+
+    @Override
+    public long getNumBytes(StorageGroup storage) {
+      return getInternalBlock(storage).getNumBytes();
+    }
-            incScheduledSize(pm.block.getNumBytes());
+            incScheduledSize(pm.reportedBlock.getNumBytes());
-      final BlocksWithLocations newBlocks = nnc.getBlocks(getDatanodeInfo(), size);
+      final BlocksWithLocations newBlksLocs =
+          nnc.getBlocks(getDatanodeInfo(), size);
-      for (BlockWithLocations blk : newBlocks.getBlocks()) {
-        bytesReceived += blk.getBlock().getNumBytes();
+      for (BlockWithLocations blkLocs : newBlksLocs.getBlocks()) {
+
+        DBlock block;
+        if (blkLocs instanceof StripedBlockWithLocations) {
+          StripedBlockWithLocations sblkLocs =
+              (StripedBlockWithLocations) blkLocs;
+          // approximate size
+          bytesReceived += sblkLocs.getBlock().getNumBytes() /
+              sblkLocs.getDataBlockNum();
+          block = new DBlockStriped(sblkLocs.getBlock(), sblkLocs.getIndices(),
+              sblkLocs.getDataBlockNum());
+        } else{
+          bytesReceived += blkLocs.getBlock().getNumBytes();
+          block = new DBlock(blkLocs.getBlock());
+        }
+
-          final DBlock block = globalBlocks.get(blk.getBlock());
+          block = globalBlocks.putIfAbsent(blkLocs.getBlock(), block);
-            final String[] datanodeUuids = blk.getDatanodeUuids();
-            final StorageType[] storageTypes = blk.getStorageTypes();
+            final String[] datanodeUuids = blkLocs.getDatanodeUuids();
+            final StorageType[] storageTypes = blkLocs.getStorageTypes();
+     * If the block is a block group. Only the internal block on this source
+     * will be dispatched.
-            long blockSize = pendingBlock.block.getNumBytes();
+            long blockSize = pendingBlock.reportedBlock.getNumBytes(this);
-            LOG.warn("Exception while getting block list", e);
+            LOG.warn("Exception while getting reportedBlock list", e);
-    // move the block
+    // move the reportedBlock
-    // wait for all block moving to be done
+    // wait for all reportedBlock moving to be done
-  /** The sleeping period before checking if block move is completed again */
+  /** The sleeping period before checking if reportedBlock move is completed again */
-   * Wait for all block move confirmations.
+   * Wait for all reportedBlock move confirmations.
-   * Decide if the block is a good candidate to be moved from source to target.
-   * A block is a good candidate if
+   * Decide if the block/blockGroup is a good candidate to be moved from source
+   * to target. A block is a good candidate if
-   * 2. the block does not have a replica on the target;
+   * 2. the block does not have a replica/internalBlock on the target;
-      // the block is moved inside same DN
+      // the reportedBlock is moved inside same DN
-  /** set the sleeping period for block move completion check */
+  /** set the sleeping period for reportedBlock move completion check */

INS26 INS26 INS26 INS40 INS40 INS40 INS55 INS31 INS83 INS83 INS42 INS43 INS23 INS23 INS31 INS31 INS31 UPD42 INS44 INS8 INS43 INS59 INS83 INS39 INS42 INS44 INS8 INS42 INS83 INS5 INS59 INS83 INS39 INS59 INS83 INS42 INS44 INS44 INS44 INS8 INS83 MOV43 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS65 INS65 UPD42 MOV43 INS42 INS25 MOV41 UPD66 INS42 INS42 INS6 INS43 INS42 INS41 INS39 INS85 INS42 INS42 INS43 INS42 INS5 INS42 INS39 INS42 INS46 INS21 INS21 INS43 INS42 INS60 INS25 INS60 INS60 INS60 INS60 INS21 INS21 INS60 INS21 INS41 INS42 INS43 INS42 INS41 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV66 UPD66 MOV66 INS38 MOV8 INS32 UPD66 UPD66 UPD66 INS38 UPD66 UPD66 INS42 INS48 INS42 INS39 INS85 INS42 INS7 INS7 INS42 INS39 INS59 INS27 INS8 INS39 INS59 INS39 INS59 INS39 INS59 INS43 INS59 INS32 INS32 MOV43 INS59 INS32 INS42 INS42 INS32 INS66 INS66 INS32 INS41 INS42 INS42 INS42 UPD42 UPD42 INS36 UPD45 UPD42 INS42 INS22 INS42 INS22 INS42 INS42 INS32 INS42 INS38 INS41 INS42 INS2 INS42 INS27 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 UPD42 UPD42 UPD42 INS60 INS25 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS62 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS34 INS33 INS42 INS42 INS32 INS42 INS42 INS32 INS40 INS42 INS42 INS43 INS32 INS43 INS42 INS42 INS42 MOV43 MOV59 INS62 INS8 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS60 INS21 INS21 MOV21 INS21 INS21 INS42 UPD42 INS42 INS42 INS43 INS59 INS7 INS7 INS7 INS7 INS25 UPD42 INS42 INS42 INS11 INS42 INS27 INS42 INS14 INS42 INS14 INS42 INS32 INS62 INS8 INS8 INS43 INS42 INS32 INS32 INS43 INS32 INS32 INS32 INS43 INS32 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS43 MOV21 INS21 UPD40 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 INS42 INS7 INS42 INS42 UPD42 UPD42 UPD40 INS52 UPD45 INS42 INS32 INS42 INS42 INS36 INS42 INS42 INS11 INS43 INS42 INS42 DEL65 DEL42 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL8 DEL52 DEL42 DEL22 DEL42 DEL83 DEL42 DEL32 DEL59 DEL60
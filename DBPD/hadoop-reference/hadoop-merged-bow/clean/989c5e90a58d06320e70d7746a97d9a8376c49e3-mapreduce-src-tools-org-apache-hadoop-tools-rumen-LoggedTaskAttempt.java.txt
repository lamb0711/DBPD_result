MAPREDUCE-2037. Capture intermediate progress, CPU and memory usage for tasks. Contributed by Dick King. 


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1157253 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.List;
+  List<Integer> clockSplits = new ArrayList<Integer>();
+  List<Integer> cpuUsages = new ArrayList<Integer>();
+  List<Integer> vMemKbytes = new ArrayList<Integer>();
+  List<Integer> physMemKbytes = new ArrayList<Integer>();
+
+  // carries the kinds of splits vectors a LoggedTaskAttempt holds.
+  //
+  // Each enumeral has the following methods:
+  //   get(LoggedTaskAttempt attempt)
+  //    returns a List<Integer> with the corresponding value field
+  //   set(LoggedTaskAttempt attempt, List<Integer> newValue)
+  //    sets the value
+  // There is also a pair of methods get(List<List<Integer>>) and
+  //  set(List<List<Integer>>, List<Integer>) which correspondingly
+  //  delivers or sets the appropriate element of the
+  //  List<List<Integer>> .
+  // This makes it easier to add another kind in the future.
+  public enum SplitVectorKind {
+
+    WALLCLOCK_TIME {
+      @Override
+      public List<Integer> get(LoggedTaskAttempt attempt) {
+        return attempt.getClockSplits();
+      }
+      @Override
+      public void set(LoggedTaskAttempt attempt, List<Integer> newValue) {
+        attempt.setClockSplits(newValue);
+      }
+    },
+
+    CPU_USAGE {
+      @Override
+      public List<Integer> get(LoggedTaskAttempt attempt) {
+        return attempt.getCpuUsages();
+      }
+      @Override
+      public void set(LoggedTaskAttempt attempt, List<Integer> newValue) {
+        attempt.setCpuUsages(newValue);
+      }
+    },
+
+    VIRTUAL_MEMORY_KBYTES {
+      @Override
+      public List<Integer> get(LoggedTaskAttempt attempt) {
+        return attempt.getVMemKbytes();
+      }
+      @Override
+      public void set(LoggedTaskAttempt attempt, List<Integer> newValue) {
+        attempt.setVMemKbytes(newValue);
+      }
+    },
+
+    PHYSICAL_MEMORY_KBYTES {
+      @Override
+      public List<Integer> get(LoggedTaskAttempt attempt) {
+        return attempt.getPhysMemKbytes();
+      }
+      @Override
+      public void set(LoggedTaskAttempt attempt, List<Integer> newValue) {
+        attempt.setPhysMemKbytes(newValue);
+      }
+    };
+
+    static private final List<List<Integer>> NULL_SPLITS_VECTOR
+      = new ArrayList<List<Integer>>();
+
+    static {
+      for (SplitVectorKind kind : SplitVectorKind.values() ) {
+        NULL_SPLITS_VECTOR.add(new ArrayList<Integer>());
+      }
+    }
+
+    abstract public List<Integer> get(LoggedTaskAttempt attempt);
+
+    abstract public void set(LoggedTaskAttempt attempt, List<Integer> newValue);
+
+    public List<Integer> get(List<List<Integer>> listSplits) {
+      return listSplits.get(this.ordinal());
+    }
+
+    public void set(List<List<Integer>> listSplits, List<Integer> newValue) {
+      listSplits.set(this.ordinal(), newValue);
+    }
+
+    static public List<List<Integer>> getNullSplitsVector() {
+      return NULL_SPLITS_VECTOR;
+    }
+  }
+
+  /**
+   *
+   * @returns a list of all splits vectors, ordered in enumeral order
+   *           within {@link SplitVectorKind} .  Do NOT use hard-coded
+   *           indices within the return for this with a hard-coded
+   *           index to get individual values; use
+   *           {@code SplitVectorKind.get(LoggedTaskAttempt)} instead.
+   */
+  public List<List<Integer>> allSplitVectors() {
+    List<List<Integer>> result
+      = new ArrayList<List<Integer>>(SplitVectorKind.values().length);
+
+    for (SplitVectorKind kind : SplitVectorKind.values() ) {
+      result.add(kind.get(this));
+    }
+
+    return result;
+  }
+
+  public List<Integer> getClockSplits() {
+    return clockSplits;
+  }
+
+  void setClockSplits(List<Integer> clockSplits) {
+    this.clockSplits = clockSplits;
+  }
+
+  void arraySetClockSplits(int[] clockSplits) {
+    List<Integer> result = new ArrayList<Integer>();
+
+    for (int i = 0; i < clockSplits.length; ++i) {
+      result.add(clockSplits[i]);
+    }
+                 
+    this.clockSplits = result;
+  }
+
+  public List<Integer> getCpuUsages() {
+    return cpuUsages;
+  }
+
+  void setCpuUsages(List<Integer> cpuUsages) {
+    this.cpuUsages = cpuUsages;
+  }
+
+  void arraySetCpuUsages(int[] cpuUsages) {
+    List<Integer> result = new ArrayList<Integer>();
+
+    for (int i = 0; i < cpuUsages.length; ++i) {
+      result.add(cpuUsages[i]);
+    }
+                 
+    this.cpuUsages = result;
+  }
+
+  public List<Integer> getVMemKbytes() {
+    return vMemKbytes;
+  }
+
+  void setVMemKbytes(List<Integer> vMemKbytes) {
+    this.vMemKbytes = vMemKbytes;
+  }
+
+  void arraySetVMemKbytes(int[] vMemKbytes) {
+    List<Integer> result = new ArrayList<Integer>();
+
+    for (int i = 0; i < vMemKbytes.length; ++i) {
+      result.add(vMemKbytes[i]);
+    }
+                 
+    this.vMemKbytes = result;
+  }
+
+  public List<Integer> getPhysMemKbytes() {
+    return physMemKbytes;
+  }
+
+  void setPhysMemKbytes(List<Integer> physMemKbytes) {
+    this.physMemKbytes = physMemKbytes;
+  }
+
+  void arraySetPhysMemKbytes(int[] physMemKbytes) {
+    List<Integer> result = new ArrayList<Integer>();
+
+    for (int i = 0; i < physMemKbytes.length; ++i) {
+      result.add(physMemKbytes[i]);
+    }
+                 
+    this.physMemKbytes = result;
+  }
+
+  private void compare1(List<Integer> c1, List<Integer> c2, TreePath loc,
+                        String eltname)
+        throws DeepInequalityException {
+    if (c1 == null && c2 == null) {
+      return;
+    }
+
+    if (c1 == null || c2 == null || c1.size() != c2.size()) {
+      throw new DeepInequalityException
+              (eltname + " miscompared", new TreePath(loc, eltname));
+    }
+
+    for (int i = 0; i < c1.size(); ++i) {
+      if (!c1.get(i).equals(c2.get(i))) {
+        throw new DeepInequalityException("" + c1.get(i) + " != " + c2.get(i),
+                                          new TreePath(loc, eltname, i));
+      }
+    }
+  }    
+
+
+    compare1(clockSplits, other.clockSplits, loc, "clockSplits");
+    compare1(cpuUsages, other.cpuUsages, loc, "cpuUsages");
+    compare1(vMemKbytes, other.vMemKbytes, loc, "vMemKbytes");
+    compare1(physMemKbytes, other.physMemKbytes, loc, "physMemKbytes");

INS26 INS26 INS40 INS40 INS23 INS23 INS23 INS23 INS71 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS74 INS59 INS74 INS59 INS74 INS59 INS74 INS59 INS83 INS42 INS72 INS72 INS72 INS72 INS23 INS28 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS74 INS42 INS8 INS83 INS74 INS42 INS8 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS83 INS74 INS42 INS8 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS83 INS74 INS42 INS8 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS83 INS74 INS42 INS8 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS42 INS1 INS42 INS1 INS42 INS1 INS42 INS1 INS83 INS83 INS83 INS74 INS59 INS83 INS8 INS83 INS83 INS74 INS42 INS44 INS83 INS83 INS39 INS42 INS44 INS44 INS83 INS74 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS74 INS42 INS8 INS65 INS43 INS74 INS60 INS70 INS41 INS43 INS43 INS41 INS74 INS42 INS21 INS5 INS42 INS60 INS24 INS21 INS43 INS43 INS41 INS74 INS42 INS21 INS5 INS42 INS60 INS24 INS21 INS43 INS43 INS41 INS74 INS42 INS21 INS5 INS42 INS60 INS24 INS21 INS43 INS43 INS41 INS74 INS42 INS21 INS5 INS42 INS60 INS24 INS21 INS74 INS42 INS74 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS25 INS24 INS21 INS21 INS21 INS21 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS43 INS74 INS42 INS14 INS70 INS43 INS43 INS43 INS42 INS43 INS42 INS74 INS42 INS43 INS43 INS74 INS42 INS41 INS74 INS42 INS74 INS42 INS21 INS43 INS74 INS41 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS42 INS43 INS43 INS74 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS43 INS43 INS7 INS39 INS85 INS74 INS59 INS58 INS27 INS38 INS8 INS7 INS42 INS42 INS42 INS43 INS43 INS7 INS39 INS85 INS74 INS59 INS58 INS27 INS38 INS8 INS7 INS42 INS42 INS42 INS43 INS43 INS7 INS39 INS85 INS74 INS59 INS58 INS27 INS38 INS8 INS7 INS42 INS42 INS42 INS43 INS43 INS7 INS39 INS85 INS74 INS59 INS58 INS27 INS38 INS8 INS7 INS43 INS43 INS43 INS43 INS42 INS42 INS27 INS8 INS27 INS8 INS58 INS27 INS38 INS8 INS32 INS32 INS32 INS32 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS78 INS83 INS74 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS74 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS74 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS74 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS42 INS43 INS43 INS74 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS43 INS74 INS32 INS43 INS74 INS43 INS43 INS32 INS42 INS43 INS43 INS42 INS42 INS66 INS42 INS42 INS43 INS74 INS42 INS14 INS43 INS42 INS42 INS42 INS21 INS42 INS42 INS22 INS42 INS43 INS43 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS21 INS22 INS42 INS42 INS42 INS22 INS42 INS43 INS43 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS21 INS22 INS42 INS42 INS42 INS22 INS42 INS43 INS43 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS21 INS22 INS42 INS42 INS42 INS22 INS42 INS43 INS43 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS21 INS22 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS41 INS27 INS27 INS53 INS39 INS59 INS42 INS32 INS42 INS25 INS42 INS42 INS40 INS42 INS45 INS42 INS42 INS40 INS42 INS45 INS42 INS42 INS40 INS42 INS45 INS42 INS42 INS40 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS41 INS42 INS43 INS42 INS74 INS42 INS21 INS42 INS43 INS43 INS43 INS42 INS41 INS42 INS43 INS42 INS74 INS42 INS21 INS42 INS43 INS43 INS43 INS42 INS41 INS42 INS43 INS42 INS74 INS42 INS21 INS42 INS43 INS43 INS43 INS42 INS41 INS42 INS43 INS42 INS74 INS42 INS21 INS42 INS42 INS43 INS74 INS43 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS43 INS74 INS22 INS42 INS32 INS52 INS42 INS42 INS42 INS74 INS42 INS34 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS74 INS42 INS34 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS74 INS42 INS34 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS74 INS42 INS34 INS32 INS52 INS42 INS42 INS33 INS42 INS33 INS27 INS27 INS32 INS32 INS14 INS42 INS34 INS42 INS42 INS38 INS8 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS32 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS32 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS32 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS32 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS43 INS74 INS32 INS42 INS42 INS42 INS32 INS43 INS43 INS42 INS42 INS2 INS43 INS43 INS42 INS42 INS2 INS43 INS43 INS42 INS42 INS2 INS43 INS43 INS42 INS42 INS2 INS42 INS33 INS42 INS33 INS42 INS42 INS42 INS42 INS43 INS27 INS14 INS32 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS43 INS42 INS42 INS32 INS42 INS32 INS14 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS14 INS43 INS43 INS42 INS45 INS32 INS45 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42
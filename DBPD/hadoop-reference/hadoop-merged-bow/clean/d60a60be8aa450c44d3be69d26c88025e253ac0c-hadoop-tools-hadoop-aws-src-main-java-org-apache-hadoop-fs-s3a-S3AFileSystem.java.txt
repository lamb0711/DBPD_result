HADOOP-13823. s3a rename: fail if dest file exists. Contributed by Steve Loughran

+   * <pre>
+   * </pre>
+    } catch (RenameFailedException e) {
+      LOG.debug(e.getMessage());
+      return e.getExitCode();
+    } catch (FileNotFoundException e) {
+      LOG.debug(e.toString());
+      return false;
+   * This operation throws an exception on any failure which needs to be
+   * reported and downgraded to a failure. That is: if a rename
-   * @return true if rename is successful
+   * @throws RenameFailedException if some criteria for a state changing
+   * rename was not met. This means work didn't happen; it's not something
+   * which is reported upstream to the FileSystem APIs, for which the semantics
+   * of "false" are pretty vague.
+   * @throws FileNotFoundException there's no source file.
-  private boolean innerRename(Path src, Path dst) throws IOException,
-      AmazonClientException {
+  private boolean innerRename(Path src, Path dst)
+      throws RenameFailedException, FileNotFoundException, IOException,
+        AmazonClientException {
-    if (srcKey.isEmpty() || dstKey.isEmpty()) {
-      LOG.debug("rename: source {} or dest {}, is empty", srcKey, dstKey);
-      return false;
+    if (srcKey.isEmpty()) {
+      throw new RenameFailedException(src, dst, "source is root directory");
+    }
+    if (dstKey.isEmpty()) {
+      throw new RenameFailedException(src, dst, "dest is root directory");
-    S3AFileStatus srcStatus;
-    try {
-      srcStatus = getFileStatus(src);
-    } catch (FileNotFoundException e) {
-      LOG.error("rename: src not found {}", src);
-      return false;
-    }
+    // get the source file status; this raises a FNFE if there is no source
+    // file.
+    S3AFileStatus srcStatus = getFileStatus(src);
-      LOG.debug("rename: src and dst refer to the same file or directory: {}",
+      LOG.debug("rename: src and dest refer to the same file or directory: {}",
-      return srcStatus.isFile();
+      throw new RenameFailedException(src, dst,
+          "source and dest refer to the same file or directory")
+          .withExitCode(srcStatus.isFile());
-
-      if (srcStatus.isDirectory() && dstStatus.isFile()) {
-        LOG.debug("rename: src {} is a directory and dst {} is a file",
-            src, dst);
-        return false;
+      // if there is no destination entry, an exception is raised.
+      // hence this code sequence can assume that there is something
+      // at the end of the path; the only detail being what it is and
+      // whether or not it can be the destination of the rename.
+      if (srcStatus.isDirectory()) {
+        if (dstStatus.isFile()) {
+          throw new RenameFailedException(src, dst,
+              "source is a directory and dest is a file")
+              .withExitCode(srcStatus.isFile());
+        } else if (!dstStatus.isEmptyDirectory()) {
+          throw new RenameFailedException(src, dst,
+              "Destination is a non-empty directory")
+              .withExitCode(false);
+        }
+        // at this point the destination is an empty directory
+      } else {
+        // source is a file. The destination must be a directory,
+        // empty or not
+        if (dstStatus.isFile()) {
+          throw new RenameFailedException(src, dst,
+              "Cannot rename onto an existing file")
+              .withExitCode(false);
+        }
-      if (dstStatus.isDirectory() && !dstStatus.isEmptyDirectory()) {
-        return false;
-      }
-            return false;
+            throw new RenameFailedException(src, dst,
+                "destination parent is not a directory");
-          LOG.debug("rename: destination path {} has no parent {}",
-              dst, parent);
-          return false;
+          throw new RenameFailedException(src, dst,
+              "destination has no parent ");
-        LOG.debug("cannot rename a directory {}" +
-              " to a subdirectory of self: {}", srcKey, dstKey);
-        return false;
+        throw new RenameFailedException(srcKey, dstKey,
+            "cannot rename a directory to a subdirectory o fitself ");

INS43 INS43 UPD65 INS65 INS42 INS42 INS25 INS60 INS66 INS66 INS12 INS12 INS66 INS66 INS42 INS66 UPD66 INS66 INS66 INS42 INS66 MOV32 MOV32 INS8 MOV43 INS59 INS44 INS8 MOV44 INS8 INS53 INS53 INS42 MOV32 INS53 INS25 INS43 INS42 INS21 INS41 INS21 MOV41 INS14 INS14 INS32 MOV32 MOV8 INS8 INS42 INS32 INS32 INS42 INS32 INS43 INS42 INS42 INS45 INS43 INS42 INS42 INS45 UPD45 INS14 INS42 MOV32 INS25 MOV25 INS53 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV42 INS43 INS42 INS42 INS45 MOV32 INS8 INS25 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS53 MOV38 INS8 MOV42 UPD42 MOV42 INS53 INS43 INS42 INS42 INS45 INS32 INS53 INS32 INS42 INS14 INS42 INS32 INS32 INS14 INS42 INS9 INS53 INS43 INS42 INS42 INS45 INS42 INS42 INS14 INS42 INS9 INS43 INS42 INS42 INS45 INS53 INS14 INS42 INS43 INS42 INS42 INS45 INS42 INS14 INS43 INS42 INS42 INS45 INS42 INS43 INS42 INS42 INS45 INS42 INS42 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL12 DEL54 DEL41 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL32 DEL27 DEL9 DEL41 DEL27 DEL25 DEL9 DEL41 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41
HDFS-6268. Better sorting in NetworkTopology#pseudoSortByDistance when no local node is found. (wang)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599734 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
+import java.util.TreeMap;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+
-  final protected static Random r = new Random();
+  private static final ThreadLocal<Random> r = new ThreadLocal<Random>();
+
+  /**
+   * Getter for thread-local Random, which provides better performance than
+   * a shared Random (even though Random is thread-safe).
+   *
+   * @return Thread-local Random.
+   */
+  protected Random getRandom() {
+    Random rand = r.get();
+    if (rand == null) {
+      rand = new Random();
+      r.set(rand);
+    }
+    return rand;
+  }
+
-    int leaveIndex = r.nextInt(numOfDatanodes);
+    int leaveIndex = getRandom().nextInt(numOfDatanodes);
-  /** swap two array items */
-  static protected void swap(Node[] nodes, int i, int j) {
-    Node tempNode;
-    tempNode = nodes[j];
-    nodes[j] = nodes[i];
-    nodes[i] = tempNode;
-  }
-  
-  /** Sort nodes array by their distances to <i>reader</i>
-   * It linearly scans the array, if a local node is found, swap it with
-   * the first element of the array.
-   * If a local rack node is found, swap it with the first element following
-   * the local node.
-   * If neither local node or local rack node is found, put a random replica
-   * location at position 0.
-   * It leaves the rest nodes untouched.
-   * @param reader the node that wishes to read a block from one of the nodes
-   * @param nodes the list of nodes containing data for the reader
+  /**
+   * Returns an integer weight which specifies how far away {node} is away from
+   * {reader}. A lower value signifies that a node is closer.
+   * 
+   * @param reader Node where data will be read
+   * @param node Replica of data
+   * @return weight
-  public void pseudoSortByDistance( Node reader, Node[] nodes ) {
-    int tempIndex = 0;
-    int localRackNode = -1;
-    if (reader != null ) {
-      //scan the array to find the local node & local rack node
-      for(int i=0; i<nodes.length; i++) {
-        if(tempIndex == 0 && reader == nodes[i]) { //local node
-          //swap the local node and the node at position 0
-          if( i != 0 ) {
-            swap(nodes, tempIndex, i);
-          }
-          tempIndex=1;
-          if(localRackNode != -1 ) {
-            if(localRackNode == 0) {
-              localRackNode = i;
-            }
-            break;
-          }
-        } else if(localRackNode == -1 && isOnSameRack(reader, nodes[i])) {
-          //local rack
-          localRackNode = i;
-          if(tempIndex != 0 ) break;
+  protected int getWeight(Node reader, Node node) {
+    // 0 is local, 1 is same rack, 2 is off rack
+    // Start off by initializing to off rack
+    int weight = 2;
+    if (reader != null) {
+      if (reader == node) {
+        weight = 0;
+      } else if (isOnSameRack(reader, node)) {
+        weight = 1;
+      }
+    }
+    return weight;
+  }
+
+  /**
+   * Sort nodes array by network distance to <i>reader</i>.
+   * <p/>
+   * In a three-level topology, a node can be either local, on the same rack, or
+   * on a different rack from the reader. Sorting the nodes based on network
+   * distance from the reader reduces network traffic and improves performance.
+   * <p/>
+   * As an additional twist, we also randomize the nodes at each network
+   * distance using the provided random seed. This helps with load balancing
+   * when there is data skew.
+   * 
+   * @param reader Node where data will be read
+   * @param nodes Available replicas with the requested data
+   * @param seed Used to seed the pseudo-random generator that randomizes the
+   *          set of nodes at each network distance.
+   */
+  public void sortByDistance(Node reader, Node[] nodes, long seed) {
+    /** Sort weights for the nodes array */
+    int[] weights = new int[nodes.length];
+    for (int i=0; i<nodes.length; i++) {
+      weights[i] = getWeight(reader, nodes[i]);
+    }
+    // Add weight/node pairs to a TreeMap to sort
+    TreeMap<Integer, List<Node>> tree = new TreeMap<Integer, List<Node>>();
+    for (int i=0; i<nodes.length; i++) {
+      int weight = weights[i];
+      Node node = nodes[i];
+      List<Node> list = tree.get(weight);
+      if (list == null) {
+        list = Lists.newArrayListWithExpectedSize(1);
+        tree.put(weight, list);
+      }
+      list.add(node);
+    }
+
+    // Seed is normally the block id
+    // This means we use the same pseudo-random order for each block, for
+    // potentially better page cache usage.
+    Random rand = getRandom();
+    rand.setSeed(seed);
+    int idx = 0;
+    for (List<Node> list: tree.values()) {
+      if (list != null) {
+        Collections.shuffle(list, rand);
+        for (Node n: list) {
+          nodes[idx] = n;
+          idx++;
-
-      // swap the local rack node and the node at position tempIndex
-      if(localRackNode != -1 && localRackNode != tempIndex ) {
-        swap(nodes, tempIndex, localRackNode);
-        tempIndex++;
-      }
-    
-    // put a random node at position 0 if it is not a local/local-rack node
-    if(tempIndex == 0 && localRackNode == -1 && nodes.length != 0) {
-      swap(nodes, 0, r.nextInt(nodes.length));
-    }
+    Preconditions.checkState(idx == nodes.length,
+        "Sorted the wrong number of nodes!");
-  

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 UPD83 INS83 INS74 MOV29 MOV83 MOV43 UPD42 MOV42 INS8 INS29 INS83 INS39 INS42 MOV44 MOV44 MOV8 UPD42 INS44 INS44 INS43 INS43 INS14 INS65 INS60 INS25 INS41 INS65 INS65 INS65 INS65 MOV43 UPD42 INS25 INS41 INS65 INS43 INS42 INS39 INS42 INS24 INS24 INS60 MOV21 INS60 INS70 MOV21 INS42 INS42 INS74 UPD66 INS66 INS66 INS43 INS59 INS27 INS8 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS39 MOV27 INS8 INS42 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS66 INS66 INS42 INS5 MOV58 MOV27 MOV37 INS8 INS74 INS58 INS27 INS37 INS8 INS43 INS59 INS32 INS39 INS59 INS44 INS32 INS8 INS43 INS43 UPD42 MOV42 INS42 INS32 INS42 INS33 INS21 INS21 UPD42 INS34 INS25 INS39 INS85 UPD42 INS3 INS21 INS43 INS43 INS74 INS42 INS14 INS39 INS59 UPD42 MOV42 INS40 INS42 INS60 INS60 INS60 MOV25 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS74 INS42 INS42 INS42 MOV25 UPD42 UPD42 MOV42 INS27 INS45 INS42 INS42 INS42 INS42 INS7 INS32 INS32 INS27 INS8 INS25 INS5 INS40 INS7 INS42 INS42 INS43 INS43 INS74 INS42 INS34 INS39 INS59 INS43 INS59 INS74 INS59 INS32 INS42 INS43 INS43 INS27 INS8 INS42 INS40 INS42 MOV14 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 MOV21 INS32 INS8 INS39 INS85 INS2 MOV32 INS42 INS42 INS43 INS43 INS74 INS42 INS2 INS42 INS42 MOV2 INS43 INS43 INS42 INS32 UPD42 INS33 INS21 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS33 INS21 INS70 INS42 INS42 INS42 MOV21 INS42 INS42 UPD42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS44 INS42 INS8 UPD42 INS34 INS42 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 MOV21 MOV21 INS42 INS34 INS42 INS42 INS34 INS42 INS7 INS2 INS42 UPD42 INS42 INS42 DEL83 DEL39 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL7 DEL21 DEL83 DEL39 DEL43 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL31 DEL39 DEL34 DEL39 DEL42 DEL34 DEL38 DEL34 DEL42 DEL42 DEL42 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL38 DEL27 DEL42 DEL42 DEL27 DEL27 DEL8 DEL42 DEL34 DEL42 DEL40 DEL32 DEL42 DEL34 DEL27 DEL27 DEL27 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL38 DEL27 DEL10 DEL8 DEL25 DEL8 DEL42 DEL34 DEL38 DEL27 DEL27 DEL42 DEL34 DEL27 DEL10 DEL25 DEL8 DEL25 DEL25 DEL8 DEL24 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL34 DEL38 DEL27 DEL27 DEL40 DEL34 DEL27 DEL27 DEL8 DEL25
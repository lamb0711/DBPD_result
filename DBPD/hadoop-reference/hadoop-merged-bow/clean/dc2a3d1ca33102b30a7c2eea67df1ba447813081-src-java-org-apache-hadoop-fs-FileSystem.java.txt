HADOOP-6900. Make the iterator returned by FileSystem#listLocatedStatus to throw IOException rather than RuntimeException when there is an IO error fetching the next file. Contributed by Hairong Kuang. 



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@984301 13f79535-47bb-0310-9956-ffa450edef68

-   * @param filter path filter
-   * If any IO exception (for example the input directory gets deleted while
-   * listing is being executed), next() or hasNext() of the returned iterator
-   * may throw a RuntimeException with the IO exception as the cause.
-  public Iterator<LocatedFileStatus> listLocatedStatus(final Path f)
+  public RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f)
-  protected Iterator<LocatedFileStatus> listLocatedStatus(final Path f,
+  protected RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f,
-    return new Iterator<LocatedFileStatus>() {
+    return new RemoteIterator<LocatedFileStatus>() {
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDog} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       */
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDoc} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       *  @exception {@inheritDoc}
-       */
-      public LocatedFileStatus next() {
+      public LocatedFileStatus next() throws IOException {
-        try {
-          BlockLocation[] locs = result.isFile() ?
+        BlockLocation[] locs = result.isFile() ?
-          return new LocatedFileStatus(result, locs);
-        } catch (IOException ioe) {
-          throw (RuntimeException)new RuntimeException().initCause(ioe);
-        }
-      }
-      
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException("Remove is not supported");
+        return new LocatedFileStatus(result, locs);
-   * If any IO exception (for example a sub-directory gets deleted while
-   * listing is being executed), next() or hasNext() of the returned iterator
-   * may throw a RuntimeException with the IO exception as the cause.
-  public Iterator<LocatedFileStatus> listFiles(
+  public RemoteIterator<LocatedFileStatus> listFiles(
-    return new Iterator<LocatedFileStatus>() {
-      private Stack<Iterator<LocatedFileStatus>> itors = 
-        new Stack<Iterator<LocatedFileStatus>>();
-      Iterator<LocatedFileStatus> curItor = listLocatedStatus(f);
-      LocatedFileStatus curFile;
+    return new RemoteIterator<LocatedFileStatus>() {
+      private Stack<RemoteIterator<LocatedFileStatus>> itors = 
+        new Stack<RemoteIterator<LocatedFileStatus>>();
+      private RemoteIterator<LocatedFileStatus> curItor =
+        listLocatedStatus(f);
+      private LocatedFileStatus curFile;
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDog} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       */
-      public boolean hasNext() {
+      public boolean hasNext() throws IOException {
-       * If it is a directory, tranverse the directory if recursive is true;
+       * If it is a directory, traverse the directory if recursive is true;
-       * @throws RuntimeException if any io error occurs; the io exception
-       * is set as the cause of RuntimeException
+       * @throws IOException if any IO error occurs
-      private void handleFileStat(LocatedFileStatus stat) {
-        try {
-          if (stat.isFile()) { // file
-            curFile = stat;
-          } else if (recursive) { // directory
-            itors.push(curItor);
-            curItor = listLocatedStatus(stat.getPath());
-          }
-        } catch (IOException ioe) {
-          throw (RuntimeException)new RuntimeException().initCause(ioe);
+      private void handleFileStat(LocatedFileStatus stat) throws IOException {
+        if (stat.isFile()) { // file
+          curFile = stat;
+        } else if (recursive) { // directory
+          itors.push(curItor);
+          curItor = listLocatedStatus(stat.getPath());
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDoc} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       *  @exception {@inheritDoc}
-       */
-      public LocatedFileStatus next() {
+      public LocatedFileStatus next() throws IOException {
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException("Remove is not supported");
-      }

MOV31 UPD74 MOV29 UPD83 UPD74 MOV74 UPD42 MOV44 MOV44 MOV43 MOV43 UPD74 MOV74 UPD43 UPD43 INS41 UPD43 UPD42 UPD42 INS14 UPD42 UPD74 MOV74 INS1 UPD74 MOV74 UPD43 MOV23 MOV23 INS31 INS31 UPD43 UPD42 MOV78 INS83 INS39 INS42 MOV8 MOV78 INS83 MOV43 INS42 INS43 MOV8 UPD42 UPD74 INS83 UPD74 MOV74 INS83 MOV43 INS43 MOV8 MOV43 UPD42 MOV42 MOV25 MOV60 MOV43 UPD74 UPD43 UPD42 MOV42 UPD43 UPD74 UPD42 UPD66 UPD42 UPD66 UPD42 MOV43 UPD74 MOV74 UPD43 UPD42 DEL42 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL65 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL44 DEL42 DEL43 DEL43 DEL14 DEL42 DEL42 DEL32 DEL11 DEL53 DEL8 DEL12 DEL54 DEL83 DEL42 DEL65 DEL65 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL1 DEL14 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL65 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL66 DEL42 DEL44 DEL43 DEL42 DEL43 DEL14 DEL42 DEL42 DEL32 DEL11 DEL53 DEL8 DEL12 DEL54 DEL8 DEL65 DEL65 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31
YARN-6467. CSQueueMetrics needs to update the current metrics for default partition only. Contributed by Manikandan R.

+import org.apache.hadoop.yarn.server.resourcemanager.nodelabels.RMNodeLabelsManager;
-
-  @Metric("Allocated memory in MB") MutableGaugeLong allocatedMB;
-  @Metric("Allocated CPU in virtual cores") MutableGaugeInt allocatedVCores;
-  @Metric("# of allocated containers") MutableGaugeInt allocatedContainers;
-  @Metric("Aggregate # of allocated containers") MutableCounterLong aggregateContainersAllocated;
-  @Metric("Aggregate # of released containers") MutableCounterLong aggregateContainersReleased;
+  @Metric("# of active users") MutableGaugeInt activeUsers;
+  @Metric("# of active applications") MutableGaugeInt activeApplications;
+  @Metric("App Attempt First Container Allocation Delay")
+    MutableRate appAttemptFirstContainerAllocationDelay;
+
+  //Metrics updated only for "default" partition
+  @Metric("Allocated memory in MB") MutableGaugeLong allocatedMB;
+  @Metric("Allocated CPU in virtual cores") MutableGaugeInt allocatedVCores;
+  @Metric("# of allocated containers") MutableGaugeInt allocatedContainers;
+  @Metric("Aggregate # of allocated containers")
+    MutableCounterLong aggregateContainersAllocated;
+  @Metric("Aggregate # of released containers")
+    MutableCounterLong aggregateContainersReleased;
-  @Metric("Pending CPU allocation in virtual cores") MutableGaugeInt pendingVCores;
+  @Metric("Pending CPU allocation in virtual cores")
+    MutableGaugeInt pendingVCores;
-  @Metric("# of active users") MutableGaugeInt activeUsers;
-  @Metric("# of active applications") MutableGaugeInt activeApplications;
-  @Metric("App Attempt First Container Allocation Delay") MutableRate appAttemptFirstContainerAllocationDelay;
+
-  protected static final MetricsInfo QUEUE_INFO = info("Queue", "Metrics by queue");
+  protected static final MetricsInfo QUEUE_INFO =
+      info("Queue", "Metrics by queue");
+   * @param partition Node Partition
-  public void setAvailableResourcesToQueue(Resource limit) {
-    availableMB.set(limit.getMemorySize());
-    availableVCores.set(limit.getVirtualCores());
+  public void setAvailableResourcesToQueue(String partition, Resource limit) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      availableMB.set(limit.getMemorySize());
+      availableVCores.set(limit.getVirtualCores());
+    }
+   * @param limit resource limit
+   */
+  public void setAvailableResourcesToQueue(Resource limit) {
+    this.setAvailableResourcesToQueue(RMNodeLabelsManager.NO_LABEL, limit);
+  }
+
+  /**
+   * Set available resources. To be called by scheduler periodically as
+   * resources become available.
+   * @param partition Node Partition
-  public void setAvailableResourcesToUser(String user, Resource limit) {
-    QueueMetrics userMetrics = getUserMetrics(user);
-    if (userMetrics != null) {
-      userMetrics.setAvailableResourcesToQueue(limit);
+  public void setAvailableResourcesToUser(String partition,
+      String user, Resource limit) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      QueueMetrics userMetrics = getUserMetrics(user);
+      if (userMetrics != null) {
+        userMetrics.setAvailableResourcesToQueue(partition, limit);
+      }
+   * @param partition Node Partition
-  public void incrPendingResources(String user, int containers, Resource res) {
-    _incrPendingResources(containers, res);
-    QueueMetrics userMetrics = getUserMetrics(user);
-    if (userMetrics != null) {
-      userMetrics.incrPendingResources(user, containers, res);
-    }
-    if (parent != null) {
-      parent.incrPendingResources(user, containers, res);
+  public void incrPendingResources(String partition, String user,
+      int containers, Resource res) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      _incrPendingResources(containers, res);
+      QueueMetrics userMetrics = getUserMetrics(user);
+      if (userMetrics != null) {
+        userMetrics.incrPendingResources(partition, user, containers, res);
+      }
+      if (parent != null) {
+        parent.incrPendingResources(partition, user, containers, res);
+      }
-  public void decrPendingResources(String user, int containers, Resource res) {
-    _decrPendingResources(containers, res);
-    QueueMetrics userMetrics = getUserMetrics(user);
-    if (userMetrics != null) {
-      userMetrics.decrPendingResources(user, containers, res);
-    }
-    if (parent != null) {
-      parent.decrPendingResources(user, containers, res);
+
+  public void decrPendingResources(String partition, String user,
+      int containers, Resource res) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      _decrPendingResources(containers, res);
+      QueueMetrics userMetrics = getUserMetrics(user);
+      if (userMetrics != null) {
+        userMetrics.decrPendingResources(partition, user, containers, res);
+      }
+      if (parent != null) {
+        parent.decrPendingResources(partition, user, containers, res);
+      }
-  public void allocateResources(String user, int containers, Resource res,
-      boolean decrPending) {
-    allocatedContainers.incr(containers);
-    aggregateContainersAllocated.incr(containers);
+  public void allocateResources(String partition, String user,
+      int containers, Resource res, boolean decrPending) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      allocatedContainers.incr(containers);
+      aggregateContainersAllocated.incr(containers);
-    allocatedMB.incr(res.getMemorySize() * containers);
-    allocatedVCores.incr(res.getVirtualCores() * containers);
-    if (decrPending) {
-      _decrPendingResources(containers, res);
-    }
-    QueueMetrics userMetrics = getUserMetrics(user);
-    if (userMetrics != null) {
-      userMetrics.allocateResources(user, containers, res, decrPending);
-    }
-    if (parent != null) {
-      parent.allocateResources(user, containers, res, decrPending);
+      allocatedMB.incr(res.getMemorySize() * containers);
+      allocatedVCores.incr(res.getVirtualCores() * containers);
+      if (decrPending) {
+        _decrPendingResources(containers, res);
+      }
+      QueueMetrics userMetrics = getUserMetrics(user);
+      if (userMetrics != null) {
+        userMetrics.allocateResources(partition, user,
+            containers, res, decrPending);
+      }
+      if (parent != null) {
+        parent.allocateResources(partition, user, containers, res, decrPending);
+      }
-   *
+   * @param partition Node Partition
-  public void allocateResources(String user, Resource res) {
-    allocatedMB.incr(res.getMemorySize());
-    allocatedVCores.incr(res.getVirtualCores());
+  public void allocateResources(String partition, String user, Resource res) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      allocatedMB.incr(res.getMemorySize());
+      allocatedVCores.incr(res.getVirtualCores());
-    pendingMB.decr(res.getMemorySize());
-    pendingVCores.decr(res.getVirtualCores());
+      pendingMB.decr(res.getMemorySize());
+      pendingVCores.decr(res.getVirtualCores());
-    QueueMetrics userMetrics = getUserMetrics(user);
-    if (userMetrics != null) {
-      userMetrics.allocateResources(user, res);
-    }
-    if (parent != null) {
-      parent.allocateResources(user, res);
+      QueueMetrics userMetrics = getUserMetrics(user);
+      if (userMetrics != null) {
+        userMetrics.allocateResources(partition, user, res);
+      }
+      if (parent != null) {
+        parent.allocateResources(partition, user, res);
+      }
-  public void releaseResources(String user, int containers, Resource res) {
-    allocatedContainers.decr(containers);
-    aggregateContainersReleased.incr(containers);
-    allocatedMB.decr(res.getMemorySize() * containers);
-    allocatedVCores.decr(res.getVirtualCores() * containers);
-    QueueMetrics userMetrics = getUserMetrics(user);
-    if (userMetrics != null) {
-      userMetrics.releaseResources(user, containers, res);
-    }
-    if (parent != null) {
-      parent.releaseResources(user, containers, res);
+  public void releaseResources(String partition,
+      String user, int containers, Resource res) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      allocatedContainers.decr(containers);
+      aggregateContainersReleased.incr(containers);
+      allocatedMB.decr(res.getMemorySize() * containers);
+      allocatedVCores.decr(res.getVirtualCores() * containers);
+      QueueMetrics userMetrics = getUserMetrics(user);
+      if (userMetrics != null) {
+        userMetrics.releaseResources(partition, user, containers, res);
+      }
+      if (parent != null) {
+        parent.releaseResources(partition, user, containers, res);
+      }
+  public void reserveResource(String partition, String user, Resource res) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      reserveResource(user, res);
+    }
+  }
+
+  public void unreserveResource(String partition, String user, Resource res) {
+    if(partition == null || partition.equals(RMNodeLabelsManager.NO_LABEL)) {
+      unreserveResource(user, res);
+    }
+  }
+

INS26 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 INS40 INS31 INS31 INS31 INS29 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS8 INS44 INS44 INS8 INS44 INS8 INS44 INS44 INS8 INS44 INS8 INS44 INS8 INS83 INS39 INS42 INS44 MOV44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS65 INS65 INS65 INS43 INS42 INS25 INS43 INS42 INS21 INS65 INS43 INS42 INS43 INS42 INS25 INS65 INS43 INS42 INS25 INS43 INS42 INS25 INS43 INS42 INS25 INS65 INS43 INS42 INS25 INS43 INS42 INS25 INS43 INS42 INS43 INS42 INS25 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS27 MOV8 INS42 INS32 INS42 INS66 INS42 INS42 INS27 INS8 INS42 INS66 INS42 INS27 INS8 INS42 INS27 INS8 INS42 INS27 MOV8 INS42 INS66 INS42 INS27 MOV8 INS42 INS27 MOV8 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS27 INS8 INS27 INS32 INS52 INS42 INS40 INS42 INS27 INS32 MOV60 MOV25 INS27 INS32 MOV21 MOV60 MOV25 MOV25 INS27 INS32 MOV21 MOV60 INS25 MOV25 INS27 INS32 INS27 INS32 INS27 INS32 INS27 INS32 INS21 INS27 INS32 INS21 INS42 INS33 INS42 INS42 INS40 INS42 INS33 INS42 INS42 INS40 MOV27 INS42 INS33 INS42 INS42 INS40 MOV27 MOV27 UPD42 MOV42 MOV33 INS42 INS42 INS40 MOV27 MOV8 MOV27 INS42 INS33 INS42 INS42 INS40 INS27 INS27 INS42 INS33 INS42 INS42 INS40 MOV27 INS42 INS33 INS42 INS42 INS40 MOV27 MOV27 INS42 INS33 INS42 INS42 INS40 INS32 INS42 INS33 INS42 INS42 INS40 INS32 INS42 INS33 INS42 INS33 INS42 INS33 MOV42 MOV33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL8 DEL8 DEL25
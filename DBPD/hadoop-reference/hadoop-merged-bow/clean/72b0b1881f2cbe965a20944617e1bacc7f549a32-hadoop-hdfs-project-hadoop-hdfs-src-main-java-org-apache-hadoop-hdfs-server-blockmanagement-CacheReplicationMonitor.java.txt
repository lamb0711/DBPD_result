Merge trunk to HDFS-4685.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1552467 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+import com.google.common.base.Preconditions;
+
-   * True if we should rescan immediately, regardless of how much time
-   * elapsed since the previous scan.
+   * The CacheReplicationMonitor (CRM) lock. Used to synchronize starting and
+   * waiting for rescan operations.
-  private boolean rescanImmediately;
+  private final ReentrantLock lock = new ReentrantLock();
+
+  /**
+   * Notifies the scan thread that an immediate rescan is needed.
+   */
+  private final Condition doRescan = lock.newCondition();
+
+  /**
+   * Notifies waiting threads that a rescan has finished.
+   */
+  private final Condition scanFinished = lock.newCondition();
+
+  /**
+   * Whether there are pending CacheManager operations that necessitate a
+   * CacheReplicationMonitor rescan. Protected by the CRM lock.
+   */
+  private boolean needsRescan = true;
+
+  /**
+   * Whether we are currently doing a rescan. Protected by the CRM lock.
+   */
+  private boolean isScanning = false;
+
+  /**
+   * The number of rescans completed. Used to wait for scans to finish.
+   * Protected by the CacheReplicationMonitor lock.
+   */
+  private long scanCount = 0;
+
+  /**
+   * True if this monitor should terminate. Protected by the CRM lock.
+   */
+  private boolean shutdown = false;
-  private long scanTimeMs;
+  private long startTimeMs;
-   * True if this monitor should terminate.
-   */
-  private boolean shutdown;
-
-  /**
-  
+
-    shutdown = false;
-    rescanImmediately = true;
-    scanTimeMs = 0;
+    startTimeMs = 0;
-        synchronized(this) {
+        // Not all of the variables accessed here need the CRM lock, but take
+        // it anyway for simplicity
+        lock.lock();
+        try {
-            if (rescanImmediately) {
-              LOG.info("Rescanning on request");
-              rescanImmediately = false;
+            if (needsRescan) {
+              LOG.info("Rescanning because of pending operations");
-            long delta = (scanTimeMs + intervalMs) - curTimeMs;
+            long delta = (startTimeMs + intervalMs) - curTimeMs;
-              LOG.info("Rescanning after " + (curTimeMs - scanTimeMs) +
+              LOG.info("Rescanning after " + (curTimeMs - startTimeMs) +
-            this.wait(delta);
+            doRescan.await(delta, TimeUnit.MILLISECONDS);
+        } finally {
+          lock.unlock();
-        scanTimeMs = curTimeMs;
+        // Mark scan as started, clear needsRescan
+        lock.lock();
+        try {
+          isScanning = true;
+          needsRescan = false;
+        } finally {
+          lock.unlock();
+        }
+        startTimeMs = curTimeMs;
+        // Retake the CRM lock to update synchronization-related variables
+        lock.lock();
+        try {
+          isScanning = false;
+          scanCount++;
+          scanFinished.signalAll();
+        } finally {
+          lock.unlock();
+        }
-            scannedBlocks + " block(s) in " + (curTimeMs - scanTimeMs) + " " +
+            scannedBlocks + " block(s) in " + (curTimeMs - startTimeMs) + " " +
-   * Kick the monitor thread.
-   * 
-   * If it is sleeping, it will wake up and start scanning.
-   * If it is currently scanning, it will finish the scan and immediately do 
-   * another one.
+   * Similar to {@link CacheReplicationMonitor#waitForRescan()}, except it only
+   * waits if there are pending operations that necessitate a rescan as
+   * indicated by {@link #setNeedsRescan()}.
+   * <p>
+   * Note that this call may release the FSN lock, so operations before and
+   * after are not necessarily atomic.
-  public synchronized void kick() {
-    rescanImmediately = true;
-    this.notifyAll();
+  public void waitForRescanIfNeeded() {
+    lock.lock();
+    try {
+      if (!needsRescan) {
+        return;
+      }
+    } finally {
+      lock.unlock();
+    }
+    waitForRescan();
+  }
+
+  /**
+   * Waits for a rescan to complete. This doesn't guarantee consistency with
+   * pending operations, only relative recency, since it will not force a new
+   * rescan if a rescan is already underway.
+   * <p>
+   * Note that this call will release the FSN lock, so operations before and
+   * after are not atomic.
+   */
+  public void waitForRescan() {
+    // Drop the FSN lock temporarily and retake it after we finish waiting
+    // Need to handle both the read lock and the write lock
+    boolean retakeWriteLock = false;
+    if (namesystem.hasWriteLock()) {
+      namesystem.writeUnlock();
+      retakeWriteLock = true;
+    } else if (namesystem.hasReadLock()) {
+      namesystem.readUnlock();
+    } else {
+      // Expected to have at least one of the locks
+      Preconditions.checkState(false,
+          "Need to be holding either the read or write lock");
+    }
+    // try/finally for retaking FSN lock
+    try {
+      lock.lock();
+      // try/finally for releasing CRM lock
+      try {
+        // If no scan is already ongoing, mark the CRM as dirty and kick
+        if (!isScanning) {
+          needsRescan = true;
+          doRescan.signal();
+        }
+        // Wait until the scan finishes and the count advances
+        final long startCount = scanCount;
+        while (startCount >= scanCount) {
+          try {
+            scanFinished.await();
+          } catch (InterruptedException e) {
+            LOG.warn("Interrupted while waiting for CacheReplicationMonitor"
+                + " rescan", e);
+            break;
+          }
+        }
+      } finally {
+        lock.unlock();
+      }
+    } finally {
+      if (retakeWriteLock) {
+        namesystem.writeLock();
+      } else {
+        namesystem.readLock();
+      }
+    }
+  }
+
+  /**
+   * Indicates to the CacheReplicationMonitor that there have been CacheManager
+   * changes that require a rescan.
+   */
+  public void setNeedsRescan() {
+    lock.lock();
+    try {
+      this.needsRescan = true;
+    } finally {
+      lock.unlock();
+    }
-    synchronized(this) {
+    lock.lock();
+    try {
-      this.notifyAll();
+      doRescan.signalAll();
+      scanFinished.signalAll();
+    } finally {
+      lock.unlock();
-      LOG.info("Directive expiry is at " + directive.getExpiryTime());
+      if (LOG.isTraceEnabled()) {
+        LOG.trace("Directive expiry is at " + directive.getExpiryTime());
+      }
-              + now);
+              + now + ")");
-    long neededTotal = 0;
-    for (BlockInfo blockInfo : blockInfos) {
-      long neededByBlock = 
-          directive.getReplication() * blockInfo.getNumBytes();
-       neededTotal += neededByBlock;
-    }
+    // We don't cache UC blocks, don't add them to the total here
+    long neededTotal = file.computeFileSizeNotIncludingLastUcBlock() *
+        directive.getReplication();
-    // TODO: Enforce per-pool quotas
+    // The pool's bytesNeeded is incremented as we scan. If the demand
+    // thus far plus the demand of this file would exceed the pool's limit,
+    // do not cache this file.
+    CachePool pool = directive.getPool();
+    if (pool.getBytesNeeded() > pool.getLimit()) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug(String.format("Skipping directive id %d file %s because "
+            + "limit of pool %s would be exceeded (%d > %d)",
+            directive.getId(),
+            file.getFullPathName(),
+            pool.getPoolName(),
+            pool.getBytesNeeded(),
+            pool.getLimit()));
+      }
+      return;
+    }

INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 MOV29 INS83 INS39 INS59 INS29 INS83 INS39 INS42 INS8 INS42 INS8 INS29 INS83 INS39 INS42 INS8 MOV60 INS65 INS42 INS42 INS14 INS65 INS42 INS42 INS32 INS65 INS42 INS42 INS32 UPD42 INS9 INS65 INS42 INS9 INS65 UPD42 INS34 INS9 INS42 INS65 INS21 INS54 INS21 INS60 INS25 INS54 INS65 INS21 INS54 INS21 INS54 MOV60 INS25 INS66 INS66 INS43 INS66 INS42 INS42 INS66 INS42 INS42 UPD66 UPD66 INS66 INS66 INS66 UPD66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS32 INS8 INS8 INS32 UPD66 UPD66 INS66 INS66 UPD66 UPD66 INS39 INS59 INS32 INS8 INS25 INS8 INS8 INS66 INS66 INS32 INS8 INS8 INS32 MOV8 INS8 INS43 INS27 INS8 INS42 UPD42 INS68 INS68 INS42 INS42 INS25 INS21 INS42 INS42 INS9 INS42 INS42 INS21 INS21 INS32 INS8 INS8 INS21 INS54 INS25 INS42 INS42 INS21 INS21 INS42 INS42 INS21 INS21 INS25 UPD42 MOV32 INS42 UPD42 INS32 INS32 INS32 INS25 INS41 INS42 INS42 INS42 INS38 INS8 INS32 INS32 INS7 INS42 INS42 INS21 INS21 INS32 INS8 INS8 INS42 INS8 INS8 INS7 INS32 INS32 INS32 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS21 INS54 INS21 INS54 INS21 INS54 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS9 INS32 INS32 INS42 INS42 INS25 INS60 INS61 INS21 INS21 INS21 INS22 INS9 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 UPD42 UPD42 INS42 INS42 MOV21 INS32 INS8 INS8 INS32 INS8 INS8 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS9 INS45 INS38 INS8 INS83 INS39 INS59 INS27 INS8 INS32 INS32 INS32 INS52 INS42 INS32 INS42 INS42 MOV61 INS21 INS42 INS42 INS21 INS21 INS21 UPD42 INS42 INS42 INS21 INS21 INS21 INS21 INS42 MOV21 MOV21 INS42 INS42 INS42 INS42 INS54 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS32 INS7 INS7 INS32 INS7 INS37 INS32 INS32 INS8 INS12 INS42 INS42 INS27 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS9 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS21 INS44 INS8 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 INS43 INS42 INS21 INS10 INS45 INS42 UPD42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 UPD45 INS45 INS45 UPD42 UPD42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL52 DEL52 DEL8 DEL51 DEL83 DEL52 DEL42 DEL8 DEL52 DEL52 DEL51 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL39 DEL34 DEL42 DEL42 DEL7
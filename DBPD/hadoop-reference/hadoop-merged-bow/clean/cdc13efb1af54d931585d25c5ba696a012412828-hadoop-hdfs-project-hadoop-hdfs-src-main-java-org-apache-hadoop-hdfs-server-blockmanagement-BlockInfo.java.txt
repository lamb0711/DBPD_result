HDFS-8489. Subclass BlockInfo to represent contiguous blocks. Contributed by Zhe Zhang.

-public class BlockInfo extends Block
+public abstract class  BlockInfo extends Block
-  private Object[] triplets;
+  protected Object[] triplets;
-  private BlockInfo getPrevious(int index) {
+  BlockInfo getPrevious(int index) {
-  private void setStorageInfo(int index, DatanodeStorageInfo storage) {
+  void setStorageInfo(int index, DatanodeStorageInfo storage) {
-  private BlockInfo setPrevious(int index, BlockInfo to) {
+  BlockInfo setPrevious(int index, BlockInfo to) {
-  private BlockInfo setNext(int index, BlockInfo to) {
+  BlockInfo setNext(int index, BlockInfo to) {
-   * Ensure that there is enough  space to include num more triplets.
-   * @return first free triplet index.
-   */
-  private int ensureCapacity(int num) {
-    assert this.triplets != null : "BlockInfo is not initialized";
-    int last = numNodes();
-    if(triplets.length >= (last+num)*3)
-      return last;
-    /* Not enough space left. Create a new array. Should normally
-     * happen only when replication is manually increased by the user. */
-    Object[] old = triplets;
-    triplets = new Object[(last+num)*3];
-    System.arraycopy(old, 0, triplets, 0, last*3);
-    return last;
-  }
-
-  /**
-  public int numNodes() {
-    assert this.triplets != null : "BlockInfo is not initialized";
-    assert triplets.length % 3 == 0 : "Malformed BlockInfo";
-    for(int idx = getCapacity()-1; idx >= 0; idx--) {
-      if(getDatanode(idx) != null)
-        return idx+1;
-    }
-    return 0;
-  }
+  public abstract int numNodes();
-   * Add a {@link DatanodeStorageInfo} location for a block
+   * Add a {@link DatanodeStorageInfo} location for a block.
-  boolean addStorage(DatanodeStorageInfo storage) {
-    // find the last null node
-    int lastNode = ensureCapacity(1);
-    setStorageInfo(lastNode, storage);
-    setNext(lastNode, null);
-    setPrevious(lastNode, null);
-    return true;
-  }
+  abstract boolean addStorage(DatanodeStorageInfo storage);
-  boolean removeStorage(DatanodeStorageInfo storage) {
-    int dnIndex = findStorageInfo(storage);
-    if(dnIndex < 0) // the node is not found
-      return false;
-    assert getPrevious(dnIndex) == null && getNext(dnIndex) == null :
-      "Block is still in the list and must be removed first.";
-    // find the last not null node
-    int lastNode = numNodes()-1;
-    // replace current node triplet by the lastNode one
-    setStorageInfo(dnIndex, getStorageInfo(lastNode));
-    setNext(dnIndex, getNext(lastNode));
-    setPrevious(dnIndex, getPrevious(lastNode));
-    // set the last triplet to null
-    setStorageInfo(lastNode, null);
-    setNext(lastNode, null);
-    setPrevious(lastNode, null);
-    return true;
-  }
+  abstract boolean removeStorage(DatanodeStorageInfo storage);
+
+
+  /**
+   * Replace the current BlockInfo with the new one in corresponding
+   * DatanodeStorageInfo's linked list
+   */
+  abstract void replaceBlock(BlockInfo newBlock);

INS83 INS31 INS31 UPD83 INS83 INS83 MOV29 INS83 MOV39 MOV42 MOV44 INS29 INS83 INS39 INS42 INS44 INS65 INS43 INS42 UPD66 INS66 INS66 INS42 DEL83 DEL83 DEL83 DEL83 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL33 DEL27 DEL45 DEL6 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL42 DEL27 DEL36 DEL34 DEL27 DEL27 DEL42 DEL41 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL27 DEL36 DEL34 DEL27 DEL3 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL42 DEL34 DEL27 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL33 DEL27 DEL45 DEL6 DEL40 DEL34 DEL27 DEL34 DEL27 DEL45 DEL6 DEL39 DEL42 DEL42 DEL32 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL34 DEL27 DEL41 DEL25 DEL8 DEL24 DEL34 DEL41 DEL8 DEL39 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL33 DEL32 DEL21 DEL9 DEL41 DEL8 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL9 DEL41 DEL25 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL45 DEL6 DEL39 DEL42 DEL42 DEL32 DEL34 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL33 DEL32 DEL21 DEL9 DEL41 DEL8 DEL31
Merge commit '456e901a4c5c639267ee87b8e5f1319f256d20c2' (HDFS-6407. Add sorting and pagination in the datanode tab of the NN Web UI. Contributed by Haohui Mai.) into HDFS-7285-merge

-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadFactory;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.hadoop.io.MultipleIOException;
-  private URL activeNNAddress;
+  private List<URL> activeNNAddresses;
-  
+  private boolean isPrimaryCheckPointer = true;
+
-    Configuration confForActive = HAUtil.getConfForOtherNode(conf);
-    activeNNAddress = getHttpAddress(confForActive);
-    
+    List<Configuration> confForActive = HAUtil.getConfForOtherNodes(conf);
+    activeNNAddresses = new ArrayList<URL>(confForActive.size());
+    for (Configuration activeConf : confForActive) {
+      URL activeNNAddress = getHttpAddress(activeConf);
+
+      // sanity check each possible active NN
+      Preconditions.checkArgument(checkAddress(activeNNAddress),
+          "Bad address for active NN: %s", activeNNAddress);
+
+      activeNNAddresses.add(activeNNAddress);
+    }
+
-    Preconditions.checkArgument(checkAddress(activeNNAddress),
-        "Bad address for active NN: %s", activeNNAddress);
-    Preconditions.checkArgument(checkAddress(myNNAddress),
-        "Bad address for standby NN: %s", myNNAddress);
+    Preconditions.checkArgument(checkAddress(myNNAddress), "Bad address for standby NN: %s",
+        myNNAddress);
-        "Checkpointing active NN at " + activeNNAddress + "\n" +
+        "Checkpointing active NN to possible NNs: " + activeNNAddresses + "\n" +
-  private void doCheckpoint() throws InterruptedException, IOException {
+  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {
-    
-      
+
-      
+
-        thisCheckpointTxId + " but instead saved at txid=" + txid;
+          thisCheckpointTxId + " but instead saved at txid=" + txid;
-    
+
+    //early exit if we shouldn't actually send the checkpoint to the ANN
+    if(!sendCheckpoint){
+      return;
+    }
+
-    // Do this in a separate thread to avoid blocking transition to active
+    // Do this in a separate thread to avoid blocking transition to active, but don't allow more
+    // than the expected number of tasks to run or queue up
-    ExecutorService executor =
-        Executors.newSingleThreadExecutor(uploadThreadFactory);
-    Future<Void> upload = executor.submit(new Callable<Void>() {
-      @Override
-      public Void call() throws IOException {
-        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,
-            namesystem.getFSImage().getStorage(), imageType, txid, canceler);
-        return null;
+    ExecutorService executor = new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,
+        TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(activeNNAddresses.size()),
+        uploadThreadFactory);
+    // for right now, just match the upload to the nn address by convention. There is no need to
+    // directly tie them together by adding a pair class.
+    List<Future<TransferFsImage.TransferResult>> uploads =
+        new ArrayList<Future<TransferFsImage.TransferResult>>();
+    for (final URL activeNNAddress : activeNNAddresses) {
+      Future<TransferFsImage.TransferResult> upload =
+          executor.submit(new Callable<TransferFsImage.TransferResult>() {
+            @Override
+            public TransferFsImage.TransferResult call() throws IOException {
+              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem
+                  .getFSImage().getStorage(), imageType, txid, canceler);
+            }
+          });
+      uploads.add(upload);
+    }
+    InterruptedException ie = null;
+    IOException ioe= null;
+    int i = 0;
+    boolean success = false;
+    for (; i < uploads.size(); i++) {
+      Future<TransferFsImage.TransferResult> upload = uploads.get(i);
+      try {
+        // TODO should there be some smarts here about retries nodes that are not the active NN?
+        if (upload.get() == TransferFsImage.TransferResult.SUCCESS) {
+          success = true;
+          //avoid getting the rest of the results - we don't care since we had a successful upload
+          break;
+        }
+
+      } catch (ExecutionException e) {
+        ioe = new IOException("Exception during image upload: " + e.getMessage(),
+            e.getCause());
+        break;
+      } catch (InterruptedException e) {
+        ie = e;
+        break;
-    });
-    executor.shutdown();
-    try {
-      upload.get();
-    } catch (InterruptedException e) {
-      // The background thread may be blocked waiting in the throttler, so
-      // interrupt it.
-      upload.cancel(true);
-      throw e;
-    } catch (ExecutionException e) {
-      throw new IOException("Exception during image upload: " + e.getMessage(),
-          e.getCause());
+    }
+
+    // we are primary if we successfully updated the ANN
+    this.isPrimaryCheckPointer = success;
+
+    // cleaner than copying code for multiple catch statements and better than catching all
+    // exceptions, so we just handle the ones we expect.
+    if (ie != null || ioe != null) {
+
+      // cancel the rest of the tasks, and close the pool
+      for (; i < uploads.size(); i++) {
+        Future<TransferFsImage.TransferResult> upload = uploads.get(i);
+        // The background thread may be blocked waiting in the throttler, so
+        // interrupt it.
+        upload.cancel(true);
+      }
+
+      // shutdown so we interrupt anything running and don't start anything new
+      executor.shutdownNow();
+      // this is a good bit longer than the thread timeout, just to make sure all the threads
+      // that are not doing any work also stop
+      executor.awaitTermination(500, TimeUnit.MILLISECONDS);
+
+      // re-throw the exception we got, since one of these two must be non-null
+      if (ie != null) {
+        throw ie;
+      } else if (ioe != null) {
+        throw ioe;
+      }
-          
+
+          // if we need a rollback checkpoint, always attempt to checkpoint
+
-          
-          synchronized (cancelLock) {
-            if (now < preventCheckpointsUntil) {
-              LOG.info("But skipping this checkpoint since we are about to failover!");
-              canceledCount++;
-              continue;
-            }
-            assert canceler == null;
-            canceler = new Canceler();
-          }
-          
+
-            doCheckpoint();
+            synchronized (cancelLock) {
+              if (now < preventCheckpointsUntil) {
+                LOG.info("But skipping this checkpoint since we are about to failover!");
+                canceledCount++;
+                continue;
+              }
+              assert canceler == null;
+              canceler = new Canceler();
+            }
+
+            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a
+            // rollback request, are the checkpointer, are outside the quiet period.
+            boolean sendRequest = isPrimaryCheckPointer || secsSinceLast >= checkpointConf.getQuietPeriod();
+            doCheckpoint(sendRequest);
+
-  URL getActiveNNAddress() {
-    return activeNNAddress;
+  List<URL> getActiveNNAddresses() {
+    return activeNNAddresses;

MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 INS23 INS74 INS83 INS39 INS59 INS44 INS74 UPD42 INS43 MOV43 UPD42 INS42 INS9 INS70 INS39 INS42 INS25 INS60 INS70 INS60 INS60 INS60 INS60 INS24 INS21 INS25 INS43 MOV43 INS42 INS74 INS44 INS42 INS8 INS38 INS8 INS74 INS59 INS44 INS42 INS8 INS43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS37 INS8 INS7 INS27 INS8 INS42 UPD42 INS43 INS43 UPD42 INS14 MOV43 INS42 INS60 MOV21 INS21 INS42 INS41 INS14 INS43 UPD74 MOV74 INS42 INS14 INS83 INS43 INS42 MOV60 INS21 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS34 INS42 INS9 INS42 INS32 INS42 INS60 MOV54 MOV12 INS22 INS42 INS27 INS27 INS24 MOV21 INS21 INS25 INS42 INS42 UPD42 INS74 INS32 INS43 INS59 INS32 UPD42 INS43 INS34 INS32 INS34 INS40 INS14 INS42 INS42 UPD43 INS74 INS42 INS74 INS32 INS42 INS42 INS74 INS59 INS8 INS52 INS42 INS42 INS33 INS42 INS33 INS27 INS37 INS8 INS32 INS27 INS8 INS25 INS43 INS43 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 UPD45 INS42 INS42 INS42 INS74 INS32 INS40 INS43 INS74 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS25 INS42 INS32 INS42 INS60 MOV21 UPD42 INS42 INS42 INS34 INS40 INS42 INS33 INS53 INS27 INS8 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS42 INS40 INS42 INS40 INS42 INS42 INS42 INS27 INS8 INS21 INS10 INS21 INS10 INS42 INS42 INS74 INS59 INS42 INS42 INS33 INS53 INS42 INS42 INS42 INS40 UPD74 MOV32 INS40 MOV21 INS10 INS7 INS7 INS43 INS43 INS42 INS32 INS42 UPD43 INS7 INS42 MOV14 INS42 INS42 INS42 INS40 INS42 INS42 INS42 MOV51 INS60 INS40 UPD43 INS42 INS9 INS39 INS59 INS40 INS42 INS27 INS42 MOV32 INS42 INS27 INS42 INS32 INS42 INS42 DEL40 DEL26 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL21 DEL33 DEL8 DEL53 DEL42 DEL53
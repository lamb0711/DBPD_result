HADOOP-13761. S3Guard: implement retries for DDB failures and throttling; translate exceptions.
Contributed by Aaron Fabbri.

-import org.apache.hadoop.fs.FileSystem;
-  private final FileSystem.Statistics stats;
+  private final S3AReadOpContext context;
+  private final String pathStr;
-  private final Invoker invoker;
+   * @param ctx operation context
-   * @param stats statistics to update
-   * @param instrumentation instrumentation to update
-   * @param invoker preconfigured invoker
-  public S3AInputStream(S3ObjectAttributes s3Attributes,
-      long contentLength,
-      AmazonS3 client,
-      FileSystem.Statistics stats,
-      S3AInstrumentation instrumentation,
-      long readahead,
-      S3AInputPolicy inputPolicy,
-      Invoker invoker) {
+  public S3AInputStream(S3AReadOpContext ctx, S3ObjectAttributes s3Attributes,
+      long contentLength, AmazonS3 client, long readahead,
+      S3AInputPolicy inputPolicy) {
+    this.context = ctx;
+    this.pathStr = ctx.dstFileStatus.getPath().toString();
-    this.stats = stats;
-    this.streamStatistics = instrumentation.newInputStreamStatistics();
+    this.streamStatistics = ctx.instrumentation.newInputStreamStatistics();
-    this.invoker = invoker;
+  @Retries.OnceTranslated
-    S3Object object = invoker.retry(text, uri, true,
+    S3Object object = context.getReadInvoker().once(text, uri,
+  @Retries.OnceTranslated
+  @Retries.RetryTranslated
-    //For lazy seek
-    seekInStream(targetPos, len);
-    //re-open at specific location if needed
-    if (wrappedStream == null) {
-      reopen("read from new offset", targetPos, len);
-    }
+    // With S3Guard, the metadatastore gave us metadata for the file in
+    // open(), so we use a slightly different retry policy.
+    Invoker invoker = context.getReadInvoker();
+    invoker.retry("lazySeek", pathStr, true,
+        () -> {
+          //For lazy seek
+          seekInStream(targetPos, len);
+
+          //re-open at specific location if needed
+          if (wrappedStream == null) {
+            reopen("read from new offset", targetPos, len);
+          }
+        });
-    if (stats != null && bytesRead > 0) {
-      stats.incrementBytesRead(bytesRead);
+    if (context.stats != null && bytesRead > 0) {
+      context.stats.incrementBytesRead(bytesRead);
+  @Retries.RetryTranslated  // Some retries only happen w/ S3Guard, as intended.
-    int byteRead;
-      byteRead = wrappedStream.read();
-    } catch (IOException e) {
-      onReadFailure(e, 1);
-      byteRead = wrappedStream.read();
+    // With S3Guard, the metadatastore gave us metadata for the file in
+    // open(), so we use a slightly different retry policy.
+    // read() may not be likely to fail, but reopen() does a GET which
+    // certainly could.
+    Invoker invoker = context.getReadInvoker();
+    int byteRead = invoker.retry("read", pathStr, true,
+        () -> {
+          int b;
+          try {
+            b = wrappedStream.read();
+          } catch (EOFException e) {
+            return -1;
+          } catch (IOException e) {
+            onReadFailure(e, 1);
+            b = wrappedStream.read();
+          }
+          return b;
+        });
+
+  @Retries.OnceTranslated
-    LOG.info("Got exception while trying to read from stream {}"
-        + " trying to recover: "+ ioe, uri);
-    LOG.debug("While trying to read from stream {}", uri, ioe);
+
+    LOG.info("Got exception while trying to read from stream {}" +
+        " trying to recover: " + ioe, uri);
+  @Retries.RetryTranslated  // Some retries only happen w/ S3Guard, as intended.
-    int bytesRead;
-    try {
-      streamStatistics.readOperationStarted(nextReadPos, len);
-      bytesRead = wrappedStream.read(buf, off, len);
-    } catch (EOFException e) {
-      onReadFailure(e, len);
-      // the base implementation swallows EOFs.
-      return -1;
-    } catch (IOException e) {
-      onReadFailure(e, len);
-      bytesRead = wrappedStream.read(buf, off, len);
-    }
+    // With S3Guard, the metadatastore gave us metadata for the file in
+    // open(), so we use a slightly different retry policy.
+    // read() may not be likely to fail, but reopen() does a GET which
+    // certainly could.
+    Invoker invoker = context.getReadInvoker();
+
+    streamStatistics.readOperationStarted(nextReadPos, len);
+    int bytesRead = invoker.retry("read", pathStr, true,
+        () -> {
+          int bytes;
+          try {
+            bytes = wrappedStream.read(buf, off, len);
+          } catch (EOFException e) {
+            // the base implementation swallows EOFs.
+            return -1;
+          } catch (IOException e) {
+            onReadFailure(e, len);
+            bytes= wrappedStream.read(buf, off, len);
+          }
+          return bytes;
+        });
+  @Retries.OnceRaw
+  @Retries.RetryTranslated  // Some retries only happen w/ S3Guard, as intended.

MOV23 MOV44 UPD43 INS43 MOV65 MOV21 MOV21 INS78 INS78 INS78 INS8 INS78 INS78 INS78 INS78 INS78 INS42 UPD42 INS42 UPD42 UPD43 UPD42 INS40 INS40 INS40 INS60 INS21 INS40 INS54 INS60 INS40 INS40 INS60 MOV21 INS40 INS40 UPD42 UPD66 UPD42 MOV43 INS59 INS32 MOV8 MOV12 MOV43 INS59 INS43 INS59 UPD42 INS32 INS42 INS32 INS42 INS42 INS45 INS42 INS9 INS86 INS42 INS32 INS32 INS42 INS42 INS32 INS32 UPD42 UPD42 INS32 INS42 INS40 INS32 UPD42 INS42 INS42 MOV8 INS40 INS42 INS42 INS42 INS42 INS45 INS42 INS9 INS86 INS42 INS42 INS42 INS42 INS45 INS42 INS9 INS86 INS40 INS42 INS42 UPD42 MOV42 INS40 INS8 INS8 INS60 MOV54 INS41 INS60 MOV54 INS41 INS39 INS59 MOV8 INS12 INS42 INS39 INS59 MOV8 INS42 INS42 INS44 INS8 INS8 INS42 MOV8 INS43 INS42 INS41 MOV21 MOV21 MOV21 UPD42 INS42 INS38 UPD42 INS34 UPD42 UPD42 DEL40 DEL26 DEL40 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL40 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL42 DEL9 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21
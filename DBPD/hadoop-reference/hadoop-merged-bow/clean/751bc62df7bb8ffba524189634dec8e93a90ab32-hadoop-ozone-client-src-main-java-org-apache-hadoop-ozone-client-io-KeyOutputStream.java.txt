Merge branch 'HDDS-4' into trunk

-import org.apache.hadoop.hdds.client.BlockID;
+import org.apache.hadoop.hdds.scm.XceiverClientSpi;
-import org.apache.hadoop.hdds.scm.storage.BlockOutputStream;
-import org.apache.hadoop.hdds.scm.XceiverClientSpi;
+import org.apache.ratis.protocol.AlreadyClosedException;
-  /**
-   * For testing purpose only. Not building output stream from blocks, but
-   * taking from externally.
-   *
-   * @param outputStream
-   * @param length
-   */
-  @VisibleForTesting
-  public void addStream(OutputStream outputStream, long length) {
-    streamEntries.add(
-        new BlockOutputStreamEntry(outputStream, length, checksum));
-  }
-
-            .setXceiverClient(xceiverClient)
+            .setPipeline(containerWithPipeline.getPipeline())
-        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)) {
+        boolean retryFailure = checkForRetryFailure(ioe);
+        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)
+            || retryFailure) {
-          handleException(current, currentStreamIndex);
+          handleException(current, currentStreamIndex, retryFailure);
+   * @param retryFailure if true the xceiverClient needs to be invalidated in
+   *                     the client cache.
-      int streamIndex) throws IOException {
+      int streamIndex, boolean retryFailure) throws IOException {
-    streamEntry.cleanup();
+    streamEntry.cleanup(retryFailure);
-      return checkIfContainerNotOpenOrRaftRetryFailureException(ioe) || Optional
+      return checkForException(ioe, ContainerNotOpenException.class) || Optional
-  private boolean checkIfContainerNotOpenOrRaftRetryFailureException(
-      IOException ioe) {
+  /**
+   * Checks if the provided exception signifies retry failure in ratis client.
+   * In case of retry failure, ratis client throws RaftRetryFailureException
+   * and all succeeding operations are failed with AlreadyClosedException.
+   */
+  private boolean checkForRetryFailure(IOException ioe) {
+    return checkForException(ioe, RaftRetryFailureException.class,
+        AlreadyClosedException.class);
+  }
+
+  private boolean checkForException(IOException ioe, Class... classes) {
-      if (t instanceof ContainerNotOpenException
-          || t instanceof RaftRetryFailureException) {
-        return true;
+      for (Class cls : classes) {
+        if (cls.isInstance(t)) {
+          return true;
+        }
-        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)) {
+        boolean retryFailure = checkForRetryFailure(ioe);
+        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)
+            || retryFailure) {
-          handleException(entry, streamIndex);
+          handleException(entry, streamIndex, retryFailure);

MOV26 MOV26 MOV31 UPD40 INS44 UPD83 UPD39 UPD42 UPD42 INS44 INS65 INS39 INS42 UPD43 UPD42 INS41 INS43 INS42 INS42 INS66 INS66 INS66 UPD66 UPD66 UPD42 INS32 INS42 INS8 INS42 UPD42 MOV42 UPD42 MOV42 INS57 INS57 INS70 MOV21 MOV43 INS43 INS44 INS42 INS8 UPD42 MOV42 INS43 INS42 MOV25 INS60 UPD42 INS57 INS42 INS32 INS60 INS39 INS59 MOV43 INS42 INS42 INS42 INS39 INS59 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 UPD42 MOV42 INS42 DEL40 DEL26 DEL42 DEL65 DEL42 DEL65 DEL42 DEL78 DEL39 DEL42 DEL44 DEL43 DEL42 DEL42 DEL42 DEL14 DEL32 DEL21 DEL42 DEL62 DEL42 DEL62 DEL27 DEL8
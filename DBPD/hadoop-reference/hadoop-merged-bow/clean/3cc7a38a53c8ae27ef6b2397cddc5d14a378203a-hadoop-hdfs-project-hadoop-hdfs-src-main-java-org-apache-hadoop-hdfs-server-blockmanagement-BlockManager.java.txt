HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.base.Preconditions;
-public class BlockManager extends ReportProcessor {
+public class BlockManager {
-  private final InvalidateStoredBlocks invalidateBlocks;
+  private final InvalidateBlocks invalidateBlocks;
+  private final long maxNumBlocksToLog;
-    super(conf);
-    invalidateBlocks = new InvalidateStoredBlocks(datanodeManager);
+    invalidateBlocks = new InvalidateBlocks(datanodeManager);
-
+    
+    this.maxNumBlocksToLog =
+        conf.getLong(DFSConfigKeys.DFS_MAX_NUM_BLOCKS_TO_LOG_KEY,
+            DFSConfigKeys.DFS_MAX_NUM_BLOCKS_TO_LOG_DEFAULT);
+    
-  @Override  // ReportProcessor
-  @Override // ReportProcessor
-  void markBlockAsCorrupt(BlockToMarkCorrupt b,
+  private void markBlockAsCorrupt(BlockToMarkCorrupt b,
-      blockLogInfo("#markBlockAsCorrupt: " + b
+      blockLog.info("BLOCK markBlockAsCorrupt: " + b
-  public boolean shouldPostponeBlocksFromFuture() {
-    return this.shouldPostponeBlocksFromFuture;
-  }
+  
+  /**
+   * StatefulBlockInfo is used to build the "toUC" list, which is a list of
+   * updates to the information about under-construction blocks.
+   * Besides the block in question, it provides the ReplicaState
+   * reported by the datanode in the block report. 
+   */
+  private static class StatefulBlockInfo {
+    final BlockInfoUnderConstruction storedBlock;
+    final ReplicaState reportedState;
+    
+    StatefulBlockInfo(BlockInfoUnderConstruction storedBlock, 
+        ReplicaState reportedState) {
+      this.storedBlock = storedBlock;
+      this.reportedState = reportedState;
+    }
+  }
+  
+  /**
+   * BlockToMarkCorrupt is used to build the "toCorrupt" list, which is a
+   * list of blocks that should be considered corrupt due to a block report.
+   */
+  private static class BlockToMarkCorrupt {
+    /** The corrupted block in a datanode. */
+    final BlockInfo corrupted;
+    /** The corresponding block stored in the BlockManager. */
+    final BlockInfo stored;
+    /** The reason to mark corrupt. */
+    final String reason;
+    
+    BlockToMarkCorrupt(BlockInfo corrupted, BlockInfo stored, String reason) {
+      Preconditions.checkNotNull(corrupted, "corrupted is null");
+      Preconditions.checkNotNull(stored, "stored is null");
+
+      this.corrupted = corrupted;
+      this.stored = stored;
+      this.reason = reason;
+    }
+
+    BlockToMarkCorrupt(BlockInfo stored, String reason) {
+      this(stored, stored, reason);
+    }
+
+    BlockToMarkCorrupt(BlockInfo stored, long gs, String reason) {
+      this(new BlockInfo(stored), stored, reason);
+      //the corrupted block in datanode has a different generation stamp
+      corrupted.setGenerationStamp(gs);
+    }
+
+    @Override
+    public String toString() {
+      return corrupted + "("
+          + (corrupted == stored? "same as stored": "stored=" + stored) + ")";
+    }
+  }
+  private void processReport(final DatanodeDescriptor node,
+      final BlockListAsLongs report) throws IOException {
+    // Normal case:
+    // Modify the (block-->datanode) map, according to the difference
+    // between the old and new block report.
+    //
+    Collection<BlockInfo> toAdd = new LinkedList<BlockInfo>();
+    Collection<Block> toRemove = new LinkedList<Block>();
+    Collection<Block> toInvalidate = new LinkedList<Block>();
+    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<BlockToMarkCorrupt>();
+    Collection<StatefulBlockInfo> toUC = new LinkedList<StatefulBlockInfo>();
+    reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC);
+
+    // Process the blocks on each queue
+    for (StatefulBlockInfo b : toUC) { 
+      addStoredBlockUnderConstruction(b.storedBlock, node, b.reportedState);
+    }
+    for (Block b : toRemove) {
+      removeStoredBlock(b, node);
+    }
+    int numBlocksLogged = 0;
+    for (BlockInfo b : toAdd) {
+      addStoredBlock(b, node, null, numBlocksLogged < maxNumBlocksToLog);
+      numBlocksLogged++;
+    }
+    if (numBlocksLogged > maxNumBlocksToLog) {
+      blockLog.info("BLOCK* processReport: logged info for " + maxNumBlocksToLog
+          + " of " + numBlocksLogged + " reported.");
+    }
+    for (Block b : toInvalidate) {
+      blockLog.info("BLOCK* processReport: "
+          + b + " on " + node + " size " + b.getNumBytes()
+          + " does not belong to any file");
+      addToInvalidates(b, node);
+    }
+    for (BlockToMarkCorrupt b : toCorrupt) {
+      markBlockAsCorrupt(b, node);
+    }
+  }
+
+  private void reportDiff(DatanodeDescriptor dn, 
+      BlockListAsLongs newReport, 
+      Collection<BlockInfo> toAdd,              // add to DatanodeDescriptor
+      Collection<Block> toRemove,           // remove from DatanodeDescriptor
+      Collection<Block> toInvalidate,       // should be removed from DN
+      Collection<BlockToMarkCorrupt> toCorrupt, // add to corrupt replicas list
+      Collection<StatefulBlockInfo> toUC) { // add to under-construction list
+    // place a delimiter in the list which separates blocks 
+    // that have been reported from those that have not
+    BlockInfo delimiter = new BlockInfo(new Block(), 1);
+    boolean added = dn.addBlock(delimiter);
+    assert added : "Delimiting block cannot be present in the node";
+    int headIndex = 0; //currently the delimiter is in the head of the list
+    int curIndex;
+
+    if (newReport == null)
+      newReport = new BlockListAsLongs();
+    // scan the report and process newly reported blocks
+    BlockReportIterator itBR = newReport.getBlockReportIterator();
+    while(itBR.hasNext()) {
+      Block iblk = itBR.next();
+      ReplicaState iState = itBR.getCurrentReplicaState();
+      BlockInfo storedBlock = processReportedBlock(dn, iblk, iState,
+                                  toAdd, toInvalidate, toCorrupt, toUC);
+      // move block to the head of the list
+      if (storedBlock != null && (curIndex = storedBlock.findDatanode(dn)) >= 0) {
+        headIndex = dn.moveBlockToHead(storedBlock, curIndex, headIndex);
+      }
+    }
+    // collect blocks that have not been reported
+    // all of them are next to the delimiter
+    Iterator<? extends Block> it = new DatanodeDescriptor.BlockIterator(
+        delimiter.getNext(0), dn);
+    while(it.hasNext())
+      toRemove.add(it.next());
+    dn.removeBlock(delimiter);
+  }
+
-  @Override // ReportProcessor
-  BlockInfo processReportedBlock(final DatanodeDescriptor dn, 
+  private BlockInfo processReportedBlock(final DatanodeDescriptor dn, 
-  @Override // ReportProcessor
-  @Override // ReportProcessor
-  Block addStoredBlock(final BlockInfo block,
+  private Block addStoredBlock(final BlockInfo block,
-      blockLogInfo("#addStoredBlock: " + block + " on "
+      blockLog.info("BLOCK* addStoredBlock: " + block + " on "
-      blockLogWarn("#addStoredBlock: "
+      blockLog.warn("BLOCK* addStoredBlock: "
+  private void logAddStoredBlock(BlockInfo storedBlock, DatanodeDescriptor node) {
+    if (!blockLog.isInfoEnabled()) {
+      return;
+    }
+    
+    StringBuilder sb = new StringBuilder(500);
+    sb.append("BLOCK* addStoredBlock: blockMap updated: ")
+      .append(node)
+      .append(" is added to ");
+    storedBlock.appendStringTo(sb);
+    sb.append(" size " )
+      .append(storedBlock.getNumBytes());
+    blockLog.info(sb);
+  }
+  /**
+   * Get the replicas which are corrupt for a given block.
+   */
+  public Collection<DatanodeDescriptor> getCorruptReplicas(Block block) {
+    return corruptReplicas.getNodes(block);
+  }
+
-
-  @Override // ReportProcessor
-  int moveBlockToHead(DatanodeDescriptor dn, BlockInfo storedBlock,
-      int curIndex, int headIndex) {
-    return dn.moveBlockToHead(storedBlock, curIndex, headIndex);
-  }
-
-  @Override // ReportProcessor
-  boolean addBlock(DatanodeDescriptor dn, BlockInfo block) {
-    return dn.addBlock(block);
-  }
-
-  @Override // ReportProcessor
-  boolean removeBlock(DatanodeDescriptor dn, BlockInfo block) {
-    return dn.removeBlock(block);
-  }
-

INS26 INS40 INS23 INS55 INS55 INS31 INS31 INS31 INS31 UPD43 INS83 INS83 INS39 INS59 INS83 INS29 INS83 INS83 INS42 INS23 INS23 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS31 MOV31 INS31 INS83 UPD39 MOV39 UPD42 MOV42 MOV44 INS44 INS43 INS8 INS83 INS39 INS42 MOV44 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS83 INS83 INS83 INS39 INS42 MOV44 MOV44 INS8 INS29 INS83 INS74 INS42 MOV44 MOV8 UPD42 INS42 INS21 INS65 INS83 INS43 INS59 INS83 INS43 INS59 INS42 INS44 INS44 INS8 INS65 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS42 INS44 INS44 INS44 MOV8 INS42 INS44 INS44 INS8 INS42 INS44 INS8 MOV78 INS83 INS43 INS42 INS8 INS83 UPD42 INS83 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS70 INS70 INS60 INS70 INS25 INS70 INS70 INS43 INS42 INS74 INS42 INS74 INS42 INS74 INS42 INS74 INS42 INS74 INS42 INS60 INS60 INS6 INS60 INS60 INS25 INS60 INS61 INS60 INS61 INS21 UPD42 INS25 INS60 INS21 INS21 INS21 INS21 INS65 INS43 INS43 INS43 INS7 INS66 INS66 INS66 INS66 INS42 INS42 UPD42 MOV42 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS66 INS66 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS21 INS21 INS43 INS42 INS43 INS42 INS17 INS43 INS42 UPD39 UPD42 INS43 INS42 INS17 INS21 INS42 INS41 INS42 INS74 INS59 INS74 INS59 INS74 INS59 INS74 INS59 INS74 INS59 INS32 INS44 INS42 INS8 INS44 INS42 INS8 INS39 INS59 INS44 INS42 INS8 INS27 INS8 INS44 INS42 INS8 INS44 INS42 INS8 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS59 INS39 INS59 INS42 INS45 INS39 INS59 INS39 INS59 INS27 INS21 INS43 INS59 INS32 INS8 INS74 INS59 INS32 INS21 INS32 INS38 INS8 INS43 INS59 INS32 INS32 INS32 INS32 INS66 INS42 INS42 INS42 INS22 INS32 INS42 INS42 INS7 INS7 INS66 INS66 INS66 INS42 INS42 INS42 INS32 INS32 INS7 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS27 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS21 INS43 INS42 INS21 INS42 INS34 INS43 INS42 INS21 INS21 INS42 INS42 INS21 INS43 INS42 INS21 INS21 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS34 INS42 INS42 INS33 INS7 INS42 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS25 INS43 INS76 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS41 INS42 INS42 INS14 INS32 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD43 INS52 INS42 INS42 INS42 INS40 INS40 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS22 INS42 INS22 INS42 INS22 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS45 INS36 INS45 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS32 INS42 INS32 INS42 INS32 INS37 INS32 INS42 INS32 INS32 INS42 INS32 MOV43 INS14 INS34 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS43 INS59 INS43 INS59 MOV43 INS59 INS27 MOV8 INS42 INS43 INS43 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS34 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 UPD42 UPD42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV52 UPD42 MOV42 INS52 INS42 INS42 INS16 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS42 INS40 INS42 INS40 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS33 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS27 INS27 INS21 INS42 INS40 INS42 INS42 INS34 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS45 UPD45 INS27 INS45 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS36 INS34 INS7 UPD45 INS42 INS42 INS45 INS42 INS42 INS42 INS7 INS42 MOV32 UPD45 INS42 INS32 INS42 INS42 INS42 DEL43 DEL42 DEL46 DEL42 DEL78 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL22 DEL41 DEL42 DEL78 DEL39 DEL42 DEL39 DEL42 DEL41 DEL42 DEL78 DEL42 DEL78 DEL42 DEL78 DEL42 DEL44 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL39 DEL42 DEL31
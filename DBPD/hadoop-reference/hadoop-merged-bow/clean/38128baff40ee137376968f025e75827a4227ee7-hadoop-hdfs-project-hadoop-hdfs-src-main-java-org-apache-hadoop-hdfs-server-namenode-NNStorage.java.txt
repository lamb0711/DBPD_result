HDFS-10425. Clean up NNStorage and TestSaveNamespace. Contributed by Andras Bokor.

-  //
-  // The filenames used for storing the images
-  //
+  /**
+   * The filenames used for storing the images.
+   */
-    private NameNodeFile(String name) { this.fileName = name; }
+    NameNodeFile(String name) {
+      this.fileName = name;
+    }
+
-    public String getName() { return fileName; }
+    public String getName() {
+      return fileName;
+    }
-  public static enum NameNodeDirType implements StorageDirType {
+  public enum NameNodeDirType implements StorageDirType {
-      if ((this == IMAGE_AND_EDITS) && (type == IMAGE || type == EDITS))
-        return true;
-      return this == type;
+      return (this == IMAGE_AND_EDITS) && (type == IMAGE || type == EDITS) ||
+          this == type;
-  
+
-   * flag that controls if we try to restore failed storages
+   * Flag that controls if we try to restore failed storages.
-  protected volatile long mostRecentCheckpointTxId = HdfsServerConstants.INVALID_TXID;
+  protected volatile long mostRecentCheckpointTxId =
+      HdfsServerConstants.INVALID_TXID;
-   * list of failed (and thus removed) storages
+   * List of failed (and thus removed) storages.
-    = new CopyOnWriteArrayList<StorageDirectory>();
+      = new CopyOnWriteArrayList<>();
-    storageDirs = new CopyOnWriteArrayList<StorageDirectory>();
+    storageDirs = new CopyOnWriteArrayList<>();
-      if (oldVersion < LAST_PRE_UPGRADE_LAYOUT_VERSION)
+      if (oldVersion < LAST_PRE_UPGRADE_LAYOUT_VERSION) {
+      }
-    if(!restoreFailedStorage || removedStorageDirs.size() == 0)
+    if(!restoreFailedStorage || removedStorageDirs.size() == 0) {
-
+    }
-      for(Iterator<StorageDirectory> it
-            = this.removedStorageDirs.iterator(); it.hasNext();) {
-        StorageDirectory sd = it.next();
+      for (StorageDirectory sd : this.removedStorageDirs) {
-                 "; type="+sd.getStorageDirType() 
-                 + ";canwrite="+FileUtil.canWrite(root));
-        if(root.exists() && FileUtil.canWrite(root)) {
+            "; type=" + sd.getStorageDirType()
+            + ";canwrite=" + FileUtil.canWrite(root));
+        if (root.exists() && FileUtil.canWrite(root)) {
-   * See {@link NNStorage#setStorageDirectories(Collection, Collection, Collection)}
+   * See {@link NNStorage#setStorageDirectories(Collection, Collection, Collection)}.
-    setStorageDirectories(fsNameDirs, fsEditsDirs, new ArrayList<URI>());
+    setStorageDirectories(fsNameDirs, fsEditsDirs, new ArrayList<>());
-      if(dirName.getScheme().compareTo("file") == 0)
+      if(dirName.getScheme().compareTo("file") == 0) {
-                    NameNodeDirType.EDITS, sharedEditsDirs.contains(dirName)));
+            NameNodeDirType.EDITS, sharedEditsDirs.contains(dirName)));
+      }
-   * Return the storage directory corresponding to the passed URI
+   * Return the storage directory corresponding to the passed URI.
-      for (; it.hasNext(); ) {
+      while (it.hasNext()) {
-   * is specified 
+   * is specified.
-   * Retrieve current directories of type IMAGE
+   * Retrieve current directories of type IMAGE.
-   * Retrieve current directories of type EDITS
+   * Retrieve current directories of type EDITS.
-    if(dirType == null)
+    if(dirType == null) {
+    }
-    for(; it.hasNext(); it.next())
+    for(; it.hasNext(); it.next()) {
+    }
-    ArrayList<URI> list = new ArrayList<URI>();
+    ArrayList<URI> list = new ArrayList<>();
-    for ( ;it.hasNext(); ) {
+    for ( ; it.hasNext();) {
-  void writeTransactionIdFile(StorageDirectory sd, long txid) throws IOException {
+  void writeTransactionIdFile(StorageDirectory sd, long txid)
+      throws IOException {
-   * Set the transaction ID and time of the last checkpoint
+   * Set the transaction ID and time of the last checkpoint.
-   * checkpointing
+   * checkpointing.
-    ArrayList<File> list = new ArrayList<File>();
+    ArrayList<File> list = new ArrayList<>();
-        nsInfo.getLayoutVersion() == HdfsServerConstants.NAMENODE_LAYOUT_VERSION,
+        nsInfo.getLayoutVersion() ==
+            HdfsServerConstants.NAMENODE_LAYOUT_VERSION,
-    while(newID == 0)
+    while(newID == 0) {
+    }
-    if (HdfsServerConstants.RollingUpgradeStartupOption.ROLLBACK.matches
-        (startupOption)) {
+    if (HdfsServerConstants.RollingUpgradeStartupOption.ROLLBACK
+        .matches(startupOption)) {
-    deprecatedProperties = new HashMap<String, String>();
+    deprecatedProperties = new HashMap<>();
-                           StorageDirectory sd
-                           ) throws IOException {
+      StorageDirectory sd) throws IOException {
-  static File getStorageFile(StorageDirectory sd, NameNodeFile type, long imageTxId) {
+  static File getStorageFile(StorageDirectory sd, NameNodeFile type,
+      long imageTxId) {
-   * (e.g version, seen_txid)
+   * (e.g version, seen_txid).
-    return String.format("%s_%019d-%019d_%019d", NameNodeFile.EDITS_TMP.getName(),
-                         startTxId, endTxId, timestamp);
+    return String.format("%s_%019d-%019d_%019d",
+        NameNodeFile.EDITS_TMP.getName(), startTxId, endTxId, timestamp);
-   * null if no such image can be found
+   * null if no such image can be found.
-  void processStartupOptionsForUpgrade(StartupOption startOpt, int layoutVersion)
-      throws IOException {
-    if (startOpt == StartupOption.UPGRADE || startOpt == StartupOption.UPGRADEONLY) {
+  void processStartupOptionsForUpgrade(StartupOption startOpt,
+      int layoutVersion) throws IOException {
+    if (startOpt == StartupOption.UPGRADE ||
+        startOpt == StartupOption.UPGRADEONLY) {
-   * during the life cycle of the cluster.  When a new name node is formated, if 
-   * this is a new cluster, a new clusterID is geneated and stored.  Subsequent 
-   * name node must be given the same ClusterID during its format to be in the 
-   * same cluster.
+   * during the life cycle of the cluster.  When a new name node is formated,
+   * if this is a new cluster, a new clusterID is geneated and stored.
+   * Subsequent name node must be given the same ClusterID during its format to
+   * be in the same cluster.
-   * try to find current cluster id in the VERSION files
+   * Try to find current cluster id in the VERSION files.
-    String cid = null;
+    String cid;
-        if(cid != null && !cid.equals(""))
+        if(cid != null && !cid.equals("")) {
+        }
-    String ip = "unknownIP";
+    String ip;
-    String bpid = "BP-" + rand + "-"+ ip + "-" + Time.now();
-    return bpid;
+    return "BP-" + rand + "-"+ ip + "-" + Time.now();
-  /** Validate and set block pool ID */
+  /** Validate and set block pool ID. */
-  /** Validate and set block pool ID */
+  /** Validate and set block pool ID. */
-   * @throws IOException if no valid storage dirs are found or no valid layout version
+   * @throws IOException if no valid storage dirs are found or no valid layout
+   * version
-        FSImage.LOG.warn("Storage directory " + sd + " contains no VERSION file. Skipping...");
+        FSImage.LOG.warn("Storage directory " + sd +
+            " contains no VERSION file. Skipping...");
-        layoutVersion = Integer.valueOf(lv);
+        layoutVersion = lv;
-      layoutVersions.append("(").append(sd.getRoot()).append(", ").append(lv).append(") ");
+      layoutVersions.append("(").append(sd.getRoot()).append(", ").append(lv)
+          .append(") ");
-      throw new IOException("No storage directories contained VERSION information");
+      throw new IOException("No storage directories contained VERSION" +
+          " information");

INS29 INS65 INS66 INS41 UPD66 UPD66 UPD74 INS8 INS66 UPD66 UPD66 UPD66 UPD66 INS8 INS8 UPD66 UPD66 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV27 UPD66 UPD66 UPD66 INS66 INS27 INS41 INS70 INS61 MOV41 MOV21 MOV21 MOV27 MOV27 UPD74 INS8 INS44 MOV22 MOV8 UPD74 INS8 MOV32 MOV8 UPD74 UPD74 UPD74 MOV41 INS43 INS42 MOV21 INS27 MOV42 INS8 INS45 INS45 MOV41 INS42 DEL83 DEL83 DEL9 DEL41 DEL25 DEL41 DEL42 DEL43 DEL42 DEL43 DEL41 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL24 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL33 DEL45 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45
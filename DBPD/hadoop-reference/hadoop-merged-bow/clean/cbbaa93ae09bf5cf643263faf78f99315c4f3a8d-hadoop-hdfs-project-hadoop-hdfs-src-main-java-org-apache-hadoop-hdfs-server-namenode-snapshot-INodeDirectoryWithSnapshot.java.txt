HDFS-4317. Change INode and its subclasses to support HDFS-4103.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1422748 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.INodeDirectoryWithQuota;
+
+import com.google.common.base.Preconditions;
-public class INodeDirectoryWithSnapshot extends INodeDirectory {
+public class INodeDirectoryWithSnapshot extends INodeDirectoryWithQuota {
+    private static void remove(final List<INode> inodes, final int i,
+        final INode expected) {
+      final INode removed = inodes.remove(-i - 1);
+      Preconditions.checkState(removed == expected,
+          "removed != expected=%s, removed=%s.", expected, removed);
+    }
+
-    /** Create an inode in current state. */
-    void create(final INode inode) {
+    /**
+     * Create an inode in current state.
+     * @return the c-list insertion point for undo.
+     */
+    int create(final INode inode) {
+      return c;
-    /** Delete an inode from current state. */
-    void delete(final INode inode) {
+    void undoCreate(final INode inode, final int insertionPoint) {
+      remove(created, insertionPoint, inode);
+    }
+
+    /**
+     * Delete an inode from current state.
+     * @return a triple for undo.
+     */
+    Triple<Integer, INode, Integer> delete(final INode inode) {
+      INode previous = null;
+      Integer d = null;
-        created.remove(c);
+        previous = created.remove(c);
-        final int d = search(deleted, inode);
+        d = search(deleted, inode);
+      return new Triple<Integer, INode, Integer>(c, previous, d);
+    }
+    
+    void undoDelete(final INode inode,
+        final Triple<Integer, INode, Integer> undoInfo) {
+      final int c = undoInfo.left;
+      if (c >= 0) {
+        created.add(c, undoInfo.middle);
+      } else {
+        remove(deleted, undoInfo.right, inode);
+      }
-    /** Modify an inode in current state. */
-    void modify(final INode oldinode, final INode newinode) {
+    /**
+     * Modify an inode in current state.
+     * @return a triple for undo.
+     */
+    Triple<Integer, INode, Integer> modify(final INode oldinode, final INode newinode) {
+      INode previous = null;
+      Integer d = null;
-        created.set(c, newinode);
+        previous = created.set(c, newinode);
-        final int d = search(deleted, oldinode);
+        d = search(deleted, oldinode);
+      return new Triple<Integer, INode, Integer>(c, previous, d);
-    /**
-     * Given an inode in current state, find the corresponding inode in previous
-     * snapshot. The inodes in current state and previous snapshot can possibly
-     * be the same.
-     *
-     * @param inodeInCurrent The inode, possibly null, in current state.
-     * @return null if the inode is not found in previous snapshot;
-     *         otherwise, return the corresponding inode in previous snapshot.
-     */
-    INode accessPrevious(byte[] name, INode inodeInCurrent) {
-      return accessPrevious(name, inodeInCurrent, created, deleted);
-    }
-
-    private static INode accessPrevious(byte[] name, INode inodeInCurrent,
-        final List<INode> clist, final List<INode> dlist) {
-      final int d = search(dlist, name);
-      if (d >= 0) {
-        // the inode was in previous and was once deleted in current.
-        return dlist.get(d);
+    void undoModify(final INode oldinode, final INode newinode,
+        final Triple<Integer, INode, Integer> undoInfo) {
+      final int c = undoInfo.left;
+      if (c >= 0) {
+        created.set(c, undoInfo.middle);
-        final int c = search(clist, name);
-        // When c >= 0, the inode in current is a newly created inode.
-        return c >= 0? null: inodeInCurrent;
+        final int d = undoInfo.right;
+        if (d < 0) {
+          remove(created, c, newinode);
+          remove(deleted, d, oldinode);
+        }
-     * Given an inode in previous snapshot, find the corresponding inode in
-     * current state. The inodes in current state and previous snapshot can
-     * possibly be the same.
-     *
-     * @param inodeInPrevious The inode, possibly null, in previous snapshot.
-     * @return null if the inode is not found in current state;
-     *         otherwise, return the corresponding inode in current state.
+     * Find an inode in the previous snapshot.
+     * @return null if the inode cannot be determined in the previous snapshot
+     *         since no change is recorded and it should be determined in the
+     *         current snapshot; otherwise, return an array with size one
+     *         containing the inode in the previous snapshot. Note that the
+     *         inode can possibly be null which means that the inode is not
+     *         found in the previous snapshot.
-    INode accessCurrent(byte[] name, INode inodeInPrevious) {
-      return accessPrevious(name, inodeInPrevious, deleted, created);
+    INode[] accessPrevious(byte[] name) {
+      return accessPrevious(name, created, deleted);
+    }
+
+    private static INode[] accessPrevious(byte[] name,
+        final List<INode> clist, final List<INode> dlist) {
+      final int d = search(dlist, name);
+      if (d >= 0) {
+        // the inode was in previous and was once deleted in current.
+        return new INode[]{dlist.get(d)};
+      } else {
+        final int c = search(clist, name);
+        // When c >= 0, the inode in current is a newly created inode.
+        return c >= 0? new INode[]{null}: null;
+      }
+    }
+
+    /**
+     * Find an inode in the current snapshot.
+     * @return null if the inode cannot be determined in the current snapshot
+     *         since no change is recorded and it should be determined in the
+     *         previous snapshot; otherwise, return an array with size one
+     *         containing the inode in the current snapshot. Note that the
+     *         inode can possibly be null which means that the inode is not
+     *         found in the current snapshot.
+     */
+    INode[] accessCurrent(byte[] name) {
+      return accessPrevious(name, deleted, created);
-      if (inodes == null) {
-        return null;
-      } else if (inodes.isEmpty()) {
-        return "[]";
+      if (inodes == null || inodes.isEmpty()) {
+        return "<empty>";
-          .append(inodes.get(0).getLocalName());
+          .append(inodes.get(0));
-        b.append(", ").append(inodes.get(i).getLocalName());
+        b.append(", ").append(inodes.get(i));
-          + ":\n  created=" + toString(created)
-          + "\n  deleted=" + toString(deleted);
+          + "{created=" + toString(created)
+          + ", deleted=" + toString(deleted) + "}";
-  INodeDirectoryWithSnapshot(String name, INodeDirectory dir) {
-    super(name, dir.getPermissionStatus());
-    parent = dir;
+  public INodeDirectoryWithSnapshot(INodeDirectory that, boolean adopt) {
+    super(that, adopt, that.getNsQuota(), that.getDsQuota());

INS26 INS26 INS40 INS40 UPD43 MOV44 UPD42 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 UPD39 INS39 INS42 INS44 INS44 INS8 INS74 INS39 INS42 INS44 INS44 INS8 INS74 INS39 INS42 INS44 INS44 INS44 INS8 INS5 MOV44 INS5 INS5 INS42 MOV44 UPD42 INS39 INS42 INS46 INS83 INS74 INS42 INS83 INS39 INS42 INS83 MOV43 INS42 INS60 INS21 INS65 INS41 INS83 INS43 INS42 INS83 INS39 INS42 INS21 INS65 INS43 INS43 INS43 INS43 INS60 INS60 INS41 INS83 INS43 INS42 INS83 INS74 INS42 INS60 INS25 INS65 INS43 INS43 INS43 INS43 INS60 INS60 INS41 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS74 INS42 INS60 INS25 INS65 INS65 MOV43 INS85 INS43 INS85 INS65 INS65 INS43 INS85 UPD42 MOV42 INS42 MOV32 INS32 INS43 INS43 INS83 MOV43 INS59 INS32 UPD66 INS66 INS42 INS42 INS32 UPD66 INS66 INS42 INS42 INS42 INS42 MOV43 INS59 INS43 INS59 INS14 INS42 INS43 INS43 MOV43 INS43 INS83 INS39 INS59 MOV27 INS8 INS8 UPD66 INS66 INS42 INS42 INS42 INS42 MOV43 INS59 INS43 INS59 INS14 INS42 INS42 INS43 INS43 INS43 INS43 INS83 INS39 INS59 INS27 INS8 INS8 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS66 UPD66 MOV66 INS42 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS66 UPD66 MOV66 MOV42 INS27 MOV8 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS21 INS21 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS34 INS21 INS60 INS25 MOV27 MOV32 MOV32 MOV32 UPD45 UPD45 INS45 INS42 INS42 INS27 INS42 INS42 INS7 INS7 INS43 INS43 INS43 INS43 INS32 INS32 INS7 INS7 INS43 INS43 INS43 INS43 INS32 INS83 INS39 INS59 INS27 INS8 INS3 UPD45 MOV14 UPD42 MOV32 MOV32 INS38 INS34 INS42 MOV32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 MOV32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS42 INS34 INS21 INS21 INS5 INS4 INS27 INS3 INS33 MOV32 UPD42 INS42 INS32 INS32 INS43 INS85 MOV32 INS42 INS34 INS5 INS4 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS33 INS42 DEL39 DEL83 DEL39 DEL42 DEL59 DEL60 DEL39 DEL83 DEL39 DEL42 DEL59 DEL60 DEL65 DEL42 DEL65 DEL65 DEL42 DEL44 DEL42 DEL42 DEL44 DEL33 DEL42 DEL65 DEL42 DEL65 DEL65 DEL42 DEL42 DEL44 DEL42 DEL33 DEL41 DEL8 DEL25 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL46 DEL42 DEL42 DEL7 DEL21
HDFS-7384. getfacl command and getAclStatus output should be in sync. Contributed by Vinayakumar B.

+import com.google.common.base.Preconditions;
+  private final FsPermission permission;
+  /**
+   * Returns the permission set for the path
+   * @return {@link FsPermission} for the path
+   */
+  public FsPermission getPermission() {
+    return permission;
+  }
+
+    private FsPermission permission = null;
+     * Sets the permission for the file.
+     * @param permission
+     */
+    public Builder setPermission(FsPermission permission) {
+      this.permission = permission;
+      return this;
+    }
+
+    /**
-      return new AclStatus(owner, group, stickyBit, entries);
+      return new AclStatus(owner, group, stickyBit, entries, permission);
+   * @param permission permission of the path
-      Iterable<AclEntry> entries) {
+      Iterable<AclEntry> entries, FsPermission permission) {
+    this.permission = permission;
+  }
+
+  /**
+   * Get the effective permission for the AclEntry
+   * @param entry AclEntry to get the effective action
+   */
+  public FsAction getEffectivePermission(AclEntry entry) {
+    return getEffectivePermission(entry, permission);
+  }
+
+  /**
+   * Get the effective permission for the AclEntry. <br>
+   * Recommended to use this API ONLY if client communicates with the old
+   * NameNode, needs to pass the Permission for the path to get effective
+   * permission, else use {@link AclStatus#getEffectivePermission(AclEntry)}.
+   * @param entry AclEntry to get the effective action
+   * @param permArg Permission for the path. However if the client is NOT
+   *          communicating with old namenode, then this argument will not have
+   *          any preference.
+   * @return Returns the effective permission for the entry.
+   * @throws IllegalArgumentException If the client communicating with old
+   *           namenode and permission is not passed as an argument.
+   */
+  public FsAction getEffectivePermission(AclEntry entry, FsPermission permArg)
+      throws IllegalArgumentException {
+    // At least one permission bits should be available.
+    Preconditions.checkArgument(this.permission != null || permArg != null,
+        "Permission bits are not available to calculate effective permission");
+    if (this.permission != null) {
+      // permission bits from server response will have the priority for
+      // accuracy.
+      permArg = this.permission;
+    }
+    if ((entry.getName() != null || entry.getType() == AclEntryType.GROUP)) {
+      if (entry.getScope() == AclEntryScope.ACCESS) {
+        FsAction entryPerm = entry.getPermission();
+        return entryPerm.and(permArg.getGroupAction());
+      } else {
+        Preconditions.checkArgument(this.entries.contains(entry)
+            && this.entries.size() >= 3,
+            "Passed default ACL entry not found in the list of ACLs");
+        // default mask entry for effective permission calculation will be the
+        // penultimate entry. This can be mask entry in case of extended ACLs.
+        // In case of minimal ACL, this is the owner group entry, and we end up
+        // intersecting group FsAction with itself, which is a no-op.
+        FsAction defaultMask = this.entries.get(this.entries.size() - 2)
+            .getPermission();
+        FsAction entryPerm = entry.getPermission();
+        return entryPerm.and(defaultMask);
+      }
+    } else {
+      return entry.getPermission();
+    }

INS26 INS40 INS23 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS8 INS23 INS31 INS44 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS42 INS42 INS65 INS65 INS42 INS41 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS44 INS8 INS65 INS43 INS42 INS21 INS65 INS65 INS42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS25 INS25 INS66 INS66 INS65 INS66 INS42 INS42 INS42 INS33 INS65 INS65 INS42 INS43 INS42 INS21 INS41 INS42 INS66 INS42 INS7 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS27 INS8 INS36 INS8 INS8 INS42 INS66 INS42 INS42 INS7 INS52 INS22 INS42 INS42 INS42 INS42 INS68 INS42 INS42 INS27 INS45 INS22 INS33 INS21 INS27 INS25 INS41 INS22 INS42 INS42 INS52 INS42 INS42 INS42 INS69 INS27 INS27 INS52 INS42 INS7 INS27 INS27 INS27 INS8 INS8 INS32 INS52 INS42 INS43 INS22 INS33 INS42 INS33 INS42 INS22 INS32 INS33 INS32 INS40 INS32 INS40 INS60 INS41 INS21 INS60 INS60 INS41 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS43 INS59 INS43 INS59 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS32 INS34 INS22 INS42 INS27 INS52 INS42 INS22 INS42 INS52 INS42 INS32 INS34 INS52 INS42 INS22 INS42 INS52 INS42
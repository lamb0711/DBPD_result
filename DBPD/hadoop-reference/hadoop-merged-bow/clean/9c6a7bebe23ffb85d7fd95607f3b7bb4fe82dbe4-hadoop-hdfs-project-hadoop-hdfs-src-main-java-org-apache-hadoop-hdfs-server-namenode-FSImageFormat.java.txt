HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68

+      // Check if the whole subtree has been saved (for reference nodes)
+      boolean toLoadSubtree = referenceMap.toProcessSubtree(parent.getId());
+      if (!toLoadSubtree) {
+        return;
+      }
+      
-
+      
-
+      int dstSnapshotId = Snapshot.INVALID_ID;
+      if (!isWithName) {
+        dstSnapshotId = in.readInt();
+      }
-        final INodeReference ref = new INodeReference(null, withCount);
+        final INodeReference ref = new INodeReference.DstReference(null,
+            withCount, dstSnapshotId);
-        FSImageSerialization.saveINode2Image(fsDir.rootDir, out, false, referenceMap);
+        FSImageSerialization.saveINode2Image(fsDir.rootDir, out, false,
+            referenceMap);
-        saveImage(strbuf, fsDir.rootDir, out, null);
+        saveImage(strbuf, fsDir.rootDir, out, null, true);
+     * @param toSaveSubtree Whether or not to save the subtree to fsimage. For
+     *                      reference node, its subtree may already have been
+     *                      saved before.
-        DataOutputStream out, Snapshot snapshot)
+        DataOutputStream out, Snapshot snapshot, boolean toSaveSubtree)
-      final ReadOnlyList<INode> children = current.getChildrenList(null);
-      int dirNum = 0;
-      Map<Snapshot, List<INodeDirectory>> snapshotDirMap = null;
-      if (current instanceof INodeDirectoryWithSnapshot) {
-        snapshotDirMap = new HashMap<Snapshot, List<INodeDirectory>>();
-        dirNum += ((INodeDirectoryWithSnapshot) current).
-            getSnapshotDirectory(snapshotDirMap);
-      }
-      
+      if (!toSaveSubtree) {
+        return;
+      }
+      
+      final ReadOnlyList<INode> children = current.getChildrenList(null);
+      int dirNum = 0;
+      Map<Snapshot, List<INodeDirectory>> snapshotDirMap = null;
+      if (current instanceof INodeDirectoryWithSnapshot) {
+        snapshotDirMap = new HashMap<Snapshot, List<INodeDirectory>>();
+        dirNum += ((INodeDirectoryWithSnapshot) current).
+            getSnapshotDirectory(snapshotDirMap);
+      }
+      
-        if(!child.isDirectory())
+        if(!child.isDirectory()) {
-        currentDirName.put(PATH_SEPARATOR).put(child.getLocalNameBytes());
-        saveImage(currentDirName, child.asDirectory(), out, snapshot);
+        }
+        // make sure we only save the subtree under a reference node once
+        boolean toSave = child.isReference() ? 
+            referenceMap.toProcessSubtree(child.getId()) : true;
+        currentDirName.put(PATH_SEPARATOR).put(child.getLocalNameBytes()); 
+        saveImage(currentDirName, child.asDirectory(), out, snapshot, toSave);
+            // make sure we only save the subtree under a reference node once
+            boolean toSave = subDir.getParentReference() != null ? 
+                referenceMap.toProcessSubtree(subDir.getId()) : true;
-            saveImage(currentDirName, subDir, out, ss);
+            saveImage(currentDirName, subDir, out, ss, toSave);

INS44 MOV60 MOV25 INS60 INS25 INS65 INS39 INS42 INS25 INS39 INS59 INS38 INS8 INS42 INS66 INS66 INS66 INS38 INS8 INS42 INS32 INS42 INS41 INS42 INS41 INS60 INS42 INS42 INS32 INS8 INS39 INS59 INS42 INS42 INS9 INS18 INS42 INS16 INS42 INS60 INS25 INS32 INS32 INS9 INS39 INS59 INS38 INS8 INS42 INS42 INS42 INS42 INS32 INS60 INS42 INS40 INS42 INS21 INS42 INS42 INS39 INS59 INS7 INS42 INS16 INS42 INS42 INS32 INS27 INS32 INS9 INS42 INS42 UPD43 INS42 INS32 INS33 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS42 DEL42 DEL18
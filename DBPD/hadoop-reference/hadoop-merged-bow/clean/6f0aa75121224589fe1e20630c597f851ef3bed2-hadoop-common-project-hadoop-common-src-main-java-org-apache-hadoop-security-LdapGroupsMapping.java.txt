HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.

+import java.util.HashSet;
+import java.util.Collection;
+import java.util.Set;
- * The implementation also does not attempt to resolve group hierarchies. In
- * order to be considered a member of a group, the user must be an explicit
- * member in LDAP.
+ * The implementation attempts to resolve group hierarchies,
+ * to a configurable limit.
+ * If the limit is 0, in order to be considered a member of a group,
+ * the user must be an explicit member in LDAP.  Otherwise, it will traverse the
+ * group hierarchy n levels up.
+   * How many levels to traverse when checking for groups in the org hierarchy
+   */
+  public static final String GROUP_HIERARCHY_LEVELS_KEY =
+        LDAP_CONFIG_PREFIX + ".search.group.hierarchy.levels";
+  public static final int GROUP_HIERARCHY_LEVELS_DEFAULT = 0;
+
+  /*
+  private int    groupHierarchyLevels;
-        return doGetGroups(user);
+        return doGetGroups(user, groupHierarchyLevels);
-  private List<String> lookupGroup(SearchResult result, DirContext c)
+  private List<String> lookupGroup(SearchResult result, DirContext c,
+      int goUpHierarchy)
+    Set<String> groupDNs = new HashSet<String>();
-        Attribute groupName = groupResult.getAttributes().get(groupNameAttr);
-        if (groupName == null) {
-          throw new NamingException("The group object does not have " +
-              "attribute '" + groupNameAttr + "'.");
-        }
-        groups.add(groupName.get().toString());
+        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy > 0);
+      }
+      if (goUpHierarchy > 0 && !isPosix) {
+        // convert groups to a set to ensure uniqueness
+        Set<String> groupset = new HashSet<String>(groups);
+        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);
+        // convert set back to list for compatibility
+        groups = new ArrayList<String>(groupset);
-  List<String> doGetGroups(String user) throws NamingException {
+  List<String> doGetGroups(String user, int goUpHierarchy)
+      throws NamingException {
-        LOG.debug("doGetGroups(" + user + ") return no groups because the " +
+        LOG.debug("doGetGroups(" + user + ") returned no groups because the " +
-    if (groups == null || groups.isEmpty()) {
-      groups = lookupGroup(result, c);
+    if (groups == null || groups.isEmpty() || goUpHierarchy > 0) {
+      groups = lookupGroup(result, c, goUpHierarchy);
-      LOG.debug("doGetGroups(" + user + ") return " + groups);
+      LOG.debug("doGetGroups(" + user + ") returned " + groups);
+  /* Helper function to get group name from search results.
+  */
+  void getGroupNames(SearchResult groupResult, Collection<String> groups,
+                     Collection<String> groupDNs, boolean doGetDNs)
+                     throws NamingException  {
+    Attribute groupName = groupResult.getAttributes().get(groupNameAttr);
+    if (groupName == null) {
+      throw new NamingException("The group object does not have " +
+        "attribute '" + groupNameAttr + "'.");
+    }
+    groups.add(groupName.get().toString());
+    if (doGetDNs) {
+      groupDNs.add(groupResult.getNameInNamespace());
+    }
+  }
+
+  /* Implementation for walking up the ldap hierarchy
+   * This function will iteratively find the super-group memebership of
+   *    groups listed in groupDNs and add them to
+   * the groups set.  It will walk up the hierarchy goUpHierarchy levels.
+   * Note: This is an expensive operation and settings higher than 1
+   *    are NOT recommended as they will impact both the speed and
+   *    memory usage of all operations.
+   * The maximum time for this function will be bounded by the ldap query
+   * timeout and the number of ldap queries that it will make, which is
+   * max(Recur Depth in LDAP, goUpHierarcy) * DIRECTORY_SEARCH_TIMEOUT
+   *
+   * @param ctx - The context for contacting the ldap server
+   * @param groupDNs - the distinguished name of the groups whose parents we
+   *    want to look up
+   * @param goUpHierarchy - the number of levels to go up,
+   * @param groups - Output variable to store all groups that will be added
+  */
+  void goUpGroupHierarchy(Set<String> groupDNs,
+                          int goUpHierarchy,
+                          Set<String> groups)
+      throws NamingException {
+    if (goUpHierarchy <= 0 || groups.isEmpty()) {
+      return;
+    }
+    DirContext context = getDirContext();
+    Set<String> nextLevelGroups = new HashSet<String>();
+    StringBuilder filter = new StringBuilder();
+    filter.append("(&").append(groupSearchFilter).append("(|");
+    for (String dn : groupDNs) {
+      filter.append("(").append(groupMemberAttr).append("=")
+        .append(dn).append(")");
+    }
+    filter.append("))");
+    LOG.debug("Ldap group query string: " + filter.toString());
+    NamingEnumeration<SearchResult> groupResults =
+        context.search(baseDN,
+           filter.toString(),
+           SEARCH_CONTROLS);
+    while (groupResults.hasMoreElements()) {
+      SearchResult groupResult = groupResults.nextElement();
+      getGroupNames(groupResult, groups, nextLevelGroups, true);
+    }
+    goUpGroupHierarchy(nextLevelGroups, goUpHierarchy - 1, groups);
+  }
+
-
+    groupHierarchyLevels =
+        conf.getInt(GROUP_HIERARCHY_LEVELS_KEY, GROUP_HIERARCHY_LEVELS_DEFAULT);

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS39 INS59 INS44 INS44 INS39 INS42 INS44 INS44 INS44 INS44 INS43 MOV8 INS39 INS42 INS44 INS44 INS44 INS43 INS8 UPD66 INS66 UPD66 UPD66 INS66 INS42 INS42 INS27 INS42 INS34 INS42 INS39 INS42 INS60 INS39 INS42 INS43 INS42 INS74 INS42 INS74 INS42 INS39 INS42 INS42 INS25 INS74 INS42 INS39 INS42 INS74 INS42 INS42 INS25 INS60 INS60 INS60 INS21 INS70 INS21 INS21 INS60 INS61 INS21 INS21 INS42 INS45 INS74 INS59 INS27 INS42 INS43 INS43 INS43 INS43 INS42 INS8 INS43 INS43 INS43 INS43 INS27 INS8 INS43 INS59 INS74 INS59 INS43 INS59 INS32 INS44 INS42 INS8 INS32 INS32 INS74 INS59 INS32 INS8 INS32 INS7 INS43 INS43 INS42 INS14 INS25 MOV27 INS27 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS27 INS32 INS41 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS32 INS42 INS45 INS43 INS42 INS21 INS42 INS42 INS45 INS42 INS42 INS27 INS43 INS43 INS42 INS32 INS42 INS42 INS60 INS21 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS74 INS8 INS27 INS8 INS42 INS34 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS74 INS43 INS32 INS42 INS42 INS42 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS43 INS43 MOV60 INS21 INS27 INS38 INS60 INS21 INS21 INS42 INS42 INS32 INS43 INS43 INS42 INS42 INS42 INS45 INS32 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS34 INS42 INS74 INS59 INS32 INS7 INS42 UPD45 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS14 INS32 INS42 INS45 INS42 INS34 INS42 INS42 INS74 INS42 INS74 INS42 UPD45 INS32 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS42 INS45 INS42 INS42 INS42 INS42
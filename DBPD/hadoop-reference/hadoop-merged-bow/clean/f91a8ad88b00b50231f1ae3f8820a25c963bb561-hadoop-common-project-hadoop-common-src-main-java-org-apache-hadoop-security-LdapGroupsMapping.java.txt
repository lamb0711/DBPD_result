HADOOP-17079. Optimize UGI#getGroups by adding UGI#getGroupsSet. (#2085)


+import java.util.LinkedHashSet;
-  private Configuration conf;
+  private volatile Configuration conf;
-  private Iterator<String> ldapUrls;
+  private volatile Iterator<String> ldapUrls;
-  private boolean useSsl;
+  private volatile boolean useSsl;
-  private String userbaseDN;
+  private volatile String userbaseDN;
-  private String userSearchFilter;
-  private String memberOfAttr;
+  private volatile String userSearchFilter;
+  private volatile String memberOfAttr;
-  private String groupNameAttr;
-  private int groupHierarchyLevels;
-  private String posixUidAttr;
-  private String posixGidAttr;
+  private volatile String groupNameAttr;
+  private volatile int groupHierarchyLevels;
+  private volatile String posixUidAttr;
+  private volatile String posixGidAttr;
-  private boolean useOneQuery;
+  private volatile boolean useOneQuery;
-  private int numAttemptsBeforeFailover;
-  private String ldapCtxFactoryClassName;
+  private volatile int numAttemptsBeforeFailover;
+  private volatile String ldapCtxFactoryClassName;
-    /*
-     * Normal garbage collection takes care of removing Context instances when
-     * they are no longer in use. Connections used by Context instances being
-     * garbage collected will be closed automatically. So in case connection is
-     * closed and gets CommunicationException, retry some times with new new
-     * DirContext/connection.
-     */
-
-    // Tracks the number of attempts made using the same LDAP server
-    int atemptsBeforeFailover = 1;
-
-    for (int attempt = 1; attempt <= numAttempts; attempt++,
-        atemptsBeforeFailover++) {
-      try {
-        return doGetGroups(user, groupHierarchyLevels);
-      } catch (AuthenticationException e) {
-        switchBindUser(e);
-      } catch (NamingException e) {
-        LOG.warn("Failed to get groups for user {} (attempt={}/{}) using {}. " +
-            "Exception: ", user, attempt, numAttempts, currentLdapUrl, e);
-        LOG.trace("TRACE", e);
-
-        if (failover(atemptsBeforeFailover, numAttemptsBeforeFailover)) {
-          atemptsBeforeFailover = 0;
-        }
-      }
-
-      // Reset ctx so that new DirContext can be created with new connection
-      this.ctx = null;
-    }
-    
-    return Collections.emptyList();
+    return new ArrayList<>(getGroupsSet(user));
-  private List<String> lookupGroup(SearchResult result, DirContext c,
+  private Set<String> lookupGroup(SearchResult result, DirContext c,
-    List<String> groups = new ArrayList<>();
+    Set<String> groups = new LinkedHashSet<>();
-        // convert groups to a set to ensure uniqueness
-        Set<String> groupset = new HashSet<>(groups);
-        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);
-        // convert set back to list for compatibility
-        groups = new ArrayList<>(groupset);
+        goUpGroupHierarchy(groupDNs, goUpHierarchy, groups);
-  List<String> doGetGroups(String user, int goUpHierarchy)
+  Set<String> doGetGroups(String user, int goUpHierarchy)
-      return Collections.emptyList();
+      return Collections.emptySet();
-    List<String> groups = Collections.emptyList();
+    Set<String> groups = Collections.emptySet();
-        groups = new ArrayList<>();
+        groups = new LinkedHashSet<>();
+  public Set<String> getGroupsSet(String user) {
+    /*
+     * Normal garbage collection takes care of removing Context instances when
+     * they are no longer in use. Connections used by Context instances being
+     * garbage collected will be closed automatically. So in case connection is
+     * closed and gets CommunicationException, retry some times with new new
+     * DirContext/connection.
+     */
+
+    // Tracks the number of attempts made using the same LDAP server
+    int atemptsBeforeFailover = 1;
+
+    for (int attempt = 1; attempt <= numAttempts; attempt++,
+        atemptsBeforeFailover++) {
+      try {
+        return doGetGroups(user, groupHierarchyLevels);
+      } catch (AuthenticationException e) {
+        switchBindUser(e);
+      } catch (NamingException e) {
+        LOG.warn("Failed to get groups for user {} (attempt={}/{}) using {}. " +
+            "Exception: ", user, attempt, numAttempts, currentLdapUrl, e);
+        LOG.trace("TRACE", e);
+
+        if (failover(atemptsBeforeFailover, numAttemptsBeforeFailover)) {
+          atemptsBeforeFailover = 0;
+        }
+      }
+
+      // Reset ctx so that new DirContext can be created with new connection
+      this.ctx = null;
+    }
+
+    return Collections.emptySet();
+  }
+
+  @Override

INS26 MOV31 INS40 INS31 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 MOV29 INS78 INS83 INS83 MOV74 INS42 INS44 INS8 UPD74 UPD74 INS74 UPD42 INS42 INS43 INS42 INS41 UPD43 UPD43 INS43 INS43 INS42 MOV14 UPD42 UPD74 UPD42 MOV74 INS42 INS42 INS32 UPD43 INS14 UPD42 INS42 INS42 UPD42 INS74 UPD42 INS43 UPD42 INS42 UPD42 UPD74 UPD43 UPD42 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL83
YARN-5355: YARN Timeline Service v.2: alpha 2 (varunsaxena)

-import static org.apache.hadoop.fs.CommonConfigurationKeys.DEFAULT_HADOOP_HTTP_STATIC_USER;
-import static org.apache.hadoop.fs.CommonConfigurationKeys.HADOOP_HTTP_STATIC_USER;
-
-import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
-import org.apache.hadoop.http.lib.StaticUserWebFilter;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.net.NetUtils;
+import org.apache.hadoop.security.SecurityUtil;
+import org.apache.hadoop.security.token.Token;
+import org.apache.hadoop.util.Time;
+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.yarn.security.client.TimelineDelegationTokenIdentifier;
+import org.apache.hadoop.yarn.server.timelineservice.security.TimelineV2DelegationTokenSecretManagerService;
+import org.apache.hadoop.yarn.server.util.timeline.TimelineServerUtils;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+  private TimelineV2DelegationTokenSecretManagerService tokenMgrService;
+
+  private final boolean runningAsAuxService;
+
+  private UserGroupInformation loginUGI;
+
+  private ScheduledThreadPoolExecutor tokenRenewalExecutor;
+
+  private long tokenRenewInterval;
+
+  private static final long TIME_BEFORE_RENEW_DATE = 10 * 1000; // 10 seconds.
+
+  private static final long TIME_BEFORE_EXPIRY = 5 * 60 * 1000; // 5 minutes.
+
+    this(true);
+  }
+
+  protected NodeTimelineCollectorManager(boolean asAuxService) {
+    this.runningAsAuxService = asAuxService;
+  }
+
+  @Override
+  protected void serviceInit(Configuration conf) throws Exception {
+    tokenMgrService = createTokenManagerService();
+    addService(tokenMgrService);
+    this.loginUGI = UserGroupInformation.getCurrentUser();
+    tokenRenewInterval = conf.getLong(
+        YarnConfiguration.TIMELINE_DELEGATION_TOKEN_RENEW_INTERVAL,
+        YarnConfiguration.DEFAULT_TIMELINE_DELEGATION_TOKEN_RENEW_INTERVAL);
+    super.serviceInit(conf);
-    startWebApp();
+    if (UserGroupInformation.isSecurityEnabled()) {
+      // Do security login for cases where collector is running outside NM.
+      if (!runningAsAuxService) {
+        try {
+          doSecureLogin();
+        } catch(IOException ie) {
+          throw new YarnRuntimeException("Failed to login", ie);
+        }
+      }
+      this.loginUGI = UserGroupInformation.getLoginUser();
+    }
+    tokenRenewalExecutor = new ScheduledThreadPoolExecutor(
+        1, new ThreadFactoryBuilder().setNameFormat(
+            "App Collector Token Renewal thread").build());
+    startWebApp();
+  }
+
+  protected TimelineV2DelegationTokenSecretManagerService
+      createTokenManagerService() {
+    return new TimelineV2DelegationTokenSecretManagerService();
+  }
+
+  @VisibleForTesting
+  public TimelineV2DelegationTokenSecretManagerService
+      getTokenManagerService() {
+    return tokenMgrService;
+  }
+
+  private void doSecureLogin() throws IOException {
+    Configuration conf = getConfig();
+    InetSocketAddress addr = NetUtils.createSocketAddr(conf.getTrimmed(
+        YarnConfiguration.TIMELINE_SERVICE_BIND_HOST,
+            YarnConfiguration.DEFAULT_TIMELINE_SERVICE_BIND_HOST), 0,
+                YarnConfiguration.TIMELINE_SERVICE_BIND_HOST);
+    SecurityUtil.login(conf, YarnConfiguration.TIMELINE_SERVICE_KEYTAB,
+        YarnConfiguration.TIMELINE_SERVICE_PRINCIPAL, addr.getHostName());
+    if (tokenRenewalExecutor != null) {
+      tokenRenewalExecutor.shutdownNow();
+    }
+  @VisibleForTesting
+  public Token<TimelineDelegationTokenIdentifier> generateTokenForAppCollector(
+      String user) {
+    Token<TimelineDelegationTokenIdentifier> token  = tokenMgrService.
+        generateToken(UserGroupInformation.createRemoteUser(user),
+            loginUGI.getShortUserName());
+    token.setService(new Text(timelineRestServerBindAddress));
+    return token;
+  }
+
+  @VisibleForTesting
+  public long renewTokenForAppCollector(
+      AppLevelTimelineCollector appCollector) throws IOException {
+    if (appCollector.getDelegationTokenForApp() != null) {
+      return tokenMgrService.renewToken(appCollector.getDelegationTokenForApp(),
+          appCollector.getAppDelegationTokenRenewer());
+    } else {
+      LOG.info("Delegation token not available for renewal for app " +
+          appCollector.getTimelineEntityContext().getAppId());
+      return -1;
+    }
+  }
+
+  @VisibleForTesting
+  public void cancelTokenForAppCollector(
+      AppLevelTimelineCollector appCollector) throws IOException {
+    if (appCollector.getDelegationTokenForApp() != null) {
+      tokenMgrService.cancelToken(appCollector.getDelegationTokenForApp(),
+          appCollector.getAppUser());
+    }
+  }
+
+  private long getRenewalDelay(long renewInterval) {
+    return ((renewInterval > TIME_BEFORE_RENEW_DATE) ?
+        renewInterval - TIME_BEFORE_RENEW_DATE : renewInterval);
+  }
+
+  private long getRegenerationDelay(long tokenMaxDate) {
+    long regenerateTime = tokenMaxDate - Time.now();
+    return ((regenerateTime > TIME_BEFORE_EXPIRY) ?
+        regenerateTime - TIME_BEFORE_EXPIRY : regenerateTime);
+  }
+
+  private org.apache.hadoop.yarn.api.records.Token generateTokenAndSetTimer(
+      ApplicationId appId, AppLevelTimelineCollector appCollector)
+      throws IOException {
+    Token<TimelineDelegationTokenIdentifier> timelineToken =
+        generateTokenForAppCollector(appCollector.getAppUser());
+    TimelineDelegationTokenIdentifier tokenId =
+        timelineToken.decodeIdentifier();
+    long renewalDelay = getRenewalDelay(tokenRenewInterval);
+    long regenerationDelay = getRegenerationDelay(tokenId.getMaxDate());
+    if (renewalDelay > 0 || regenerationDelay > 0) {
+      boolean isTimerForRenewal = renewalDelay < regenerationDelay;
+      Future<?> renewalOrRegenerationFuture = tokenRenewalExecutor.schedule(
+          new CollectorTokenRenewer(appId, isTimerForRenewal),
+          isTimerForRenewal? renewalDelay : regenerationDelay,
+          TimeUnit.MILLISECONDS);
+      appCollector.setDelegationTokenAndFutureForApp(timelineToken,
+          renewalOrRegenerationFuture, tokenId.getMaxDate(),
+          tokenId.getRenewer().toString());
+    }
+    LOG.info("Generated a new token " + timelineToken + " for app " + appId);
+    return org.apache.hadoop.yarn.api.records.Token.newInstance(
+        timelineToken.getIdentifier(), timelineToken.getKind().toString(),
+        timelineToken.getPassword(), timelineToken.getService().toString());
+  }
+
+      // Generate token for app collector.
+      org.apache.hadoop.yarn.api.records.Token token = null;
+      if (UserGroupInformation.isSecurityEnabled() &&
+          collector instanceof AppLevelTimelineCollector) {
+        AppLevelTimelineCollector appCollector =
+            (AppLevelTimelineCollector) collector;
+        token = generateTokenAndSetTimer(appId, appCollector);
+      }
-      reportNewCollectorToNM(appId);
+      reportNewCollectorInfoToNM(appId, token);
+  @Override
+  protected void postRemove(ApplicationId appId, TimelineCollector collector) {
+    if (collector instanceof AppLevelTimelineCollector) {
+      try {
+        cancelTokenForAppCollector((AppLevelTimelineCollector) collector);
+      } catch (IOException e) {
+        LOG.warn("Failed to cancel token for app collector with appId " +
+            appId, e);
+      }
+    }
+  }
+
+    String initializers = conf.get("hadoop.http.filter.initializers", "");
+    Set<String> defaultInitializers = new LinkedHashSet<String>();
+    TimelineServerUtils.addTimelineAuthFilter(
+        initializers, defaultInitializers, tokenMgrService);
+    TimelineServerUtils.setTimelineFilters(
+        conf, initializers, defaultInitializers);
+      if (YarnConfiguration.useHttps(conf)) {
+        builder = WebAppUtils.loadSslConfiguration(builder, conf);
+      }
-      // TODO: replace this by an authentication filter in future.
-      HashMap<String, String> options = new HashMap<>();
-      String username = conf.get(HADOOP_HTTP_STATIC_USER,
-          DEFAULT_HADOOP_HTTP_STATIC_USER);
-      options.put(HADOOP_HTTP_STATIC_USER, username);
-      HttpServer2.defineFilter(timelineRestServer.getWebAppContext(),
-          "static_user_filter_timeline",
-          StaticUserWebFilter.StaticUserFilter.class.getName(),
-          options, new String[] {"/*"});
-  private void reportNewCollectorToNM(ApplicationId appId)
+  private void reportNewCollectorInfoToNM(ApplicationId appId,
+      org.apache.hadoop.yarn.api.records.Token token)
-            this.timelineRestServerBindAddress);
+            this.timelineRestServerBindAddress, token);
+
+  private final class CollectorTokenRenewer implements Runnable {
+    private ApplicationId appId;
+    // Indicates whether timer is for renewal or regeneration of token.
+    private boolean timerForRenewal = true;
+    private CollectorTokenRenewer(ApplicationId applicationId,
+        boolean forRenewal) {
+      appId = applicationId;
+      timerForRenewal = forRenewal;
+    }
+
+    private void renewToken(AppLevelTimelineCollector appCollector)
+        throws IOException {
+      long newExpirationTime = renewTokenForAppCollector(appCollector);
+      // Set renewal or regeneration timer based on delay.
+      long renewalDelay = 0;
+      if (newExpirationTime > 0) {
+        LOG.info("Renewed token for " + appId + " with new expiration " +
+            "timestamp = " + newExpirationTime);
+        renewalDelay = getRenewalDelay(newExpirationTime - Time.now());
+      }
+      long regenerationDelay =
+          getRegenerationDelay(appCollector.getAppDelegationTokenMaxDate());
+      if (renewalDelay > 0 || regenerationDelay > 0) {
+        this.timerForRenewal = renewalDelay < regenerationDelay;
+        Future<?> renewalOrRegenerationFuture = tokenRenewalExecutor.schedule(
+            this, timerForRenewal ? renewalDelay : regenerationDelay,
+            TimeUnit.MILLISECONDS);
+        appCollector.setRenewalOrRegenerationFutureForApp(
+            renewalOrRegenerationFuture);
+      }
+    }
+
+    private void regenerateToken(AppLevelTimelineCollector appCollector)
+        throws IOException {
+      org.apache.hadoop.yarn.api.records.Token token =
+          generateTokenAndSetTimer(appId, appCollector);
+      // Report to NM if a new collector is added.
+      try {
+        reportNewCollectorInfoToNM(appId, token);
+      } catch (YarnException e) {
+        LOG.warn("Unable to report regenerated token to NM for " + appId);
+      }
+    }
+
+    @Override
+    public void run() {
+      TimelineCollector collector = get(appId);
+      if (collector == null) {
+        LOG.info("Cannot find active collector while " + (timerForRenewal ?
+            "renewing" : "regenerating") + " token for " + appId);
+        return;
+      }
+      AppLevelTimelineCollector appCollector =
+          (AppLevelTimelineCollector) collector;
+
+      synchronized (collector) {
+        if (!collector.isStopped()) {
+          try {
+            if (timerForRenewal) {
+              renewToken(appCollector);
+            } else {
+              regenerateToken(appCollector);
+            }
+          } catch (Exception e) {
+            LOG.warn("Unable to " + (timerForRenewal ? "renew" : "regenerate") +
+                " token for " + appId, e);
+          }
+        }
+      }
+    }
+  }

MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS40 INS40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 MOV78 INS83 INS42 INS8 INS44 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS8 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS74 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 UPD42 INS44 INS83 INS83 INS42 INS43 INS23 INS23 INS31 INS31 INS31 INS31 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS17 INS39 INS42 INS21 INS42 INS43 INS42 INS42 INS21 INS21 INS21 INS21 INS21 INS25 INS21 MOV21 MOV21 INS42 INS41 INS42 INS42 INS41 INS42 INS60 INS60 INS21 INS25 INS42 INS43 INS43 MOV43 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS42 INS25 INS42 INS43 INS42 INS42 INS25 INS39 INS42 INS41 INS39 INS42 INS60 INS41 INS40 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS25 INS21 INS41 INS42 INS43 INS42 INS43 INS42 INS25 INS60 INS60 INS21 INS21 INS43 INS42 INS42 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS8 INS34 INS34 INS34 INS34 INS34 INS9 INS7 INS42 INS7 INS32 INS7 INS7 INS48 INS32 INS8 INS7 INS14 INS42 INS43 INS59 INS43 INS59 INS32 INS27 INS8 INS42 INS42 INS74 INS59 INS32 INS42 INS42 INS27 INS8 INS8 INS42 INS27 INS8 INS36 INS39 INS59 INS36 INS42 INS42 INS74 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS32 INS32 INS42 INS42 INS62 INS8 MOV43 INS59 INS74 INS59 INS32 INS32 INS40 INS42 INS42 INS42 INS9 INS43 INS42 INS39 INS42 INS21 INS21 INS43 INS42 INS42 INS60 INS60 INS25 INS60 INS25 INS43 INS42 INS42 INS60 INS54 INS42 INS60 INS25 INS60 INS51 INS22 INS42 INS42 INS32 INS42 INS42 INS22 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS25 INS21 INS42 INS14 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS40 INS32 INS42 INS33 INS21 INS43 INS43 INS42 INS32 INS42 INS42 INS14 INS32 INS33 INS41 INS21 INS41 INS32 INS33 INS21 INS16 INS42 INS27 INS16 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS27 INS27 INS60 INS60 INS21 INS42 INS42 INS27 INS40 INS42 INS32 INS32 INS32 INS32 INS60 INS25 INS42 INS43 INS54 INS42 INS32 INS43 MOV43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS42 INS7 INS7 INS42 INS39 INS59 INS39 INS59 INS27 INS8 INS39 INS59 INS27 INS8 INS42 INS43 INS59 INS8 INS12 INS43 INS59 INS27 INS8 INS43 INS59 INS42 INS8 INS52 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS38 INS8 INS7 INS43 INS34 INS32 INS42 INS42 INS42 INS42 INS32 INS34 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS42 INS42 INS32 INS32 INS38 INS42 INS42 INS32 INS36 INS27 INS42 INS42 INS32 INS36 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS42 INS34 INS39 INS59 INS74 INS59 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS27 INS8 INS42 INS8 INS12 INS42 INS42 INS45 INS45 INS42 INS74 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS42 INS34 INS21 INS21 INS42 INS32 INS27 INS27 INS21 INS60 INS21 INS40 INS42 INS32 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS33 INS21 INS41 INS42 INS42 INS11 INS25 INS42 INS54 INS22 INS32 INS42 INS32 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS27 INS34 INS42 INS42 INS32 INS32 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS76 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS33 INS32 INS62 INS60 INS21 UPD42 INS42 INS21 INS44 INS8 INS43 MOV43 INS42 INS42 MOV42 MOV21 INS42 INS42 INS32 INS7 INS42 INS32 INS42 INS34 INS42 INS34 INS7 INS74 INS59 INS32 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS42 INS42 INS32 INS43 INS42 INS38 INS8 INS8 INS12 INS52 INS42 INS42 INS42 INS14 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS16 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS43 INS59 INS7 INS32 INS43 INS42 INS21 INS42 INS7 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS22 INS27 INS43 INS76 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS32 INS54 INS21 INS44 INS8 INS43 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS11 INS42 INS32 INS42 INS32 INS45 INS42 INS45 INS45 INS42 INS42 INS27 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS16 INS40 INS42 INS42 INS27 INS45 INS36 INS45 INS42 INS42 INS42 INS8 INS12 INS32 INS43 INS42 INS53 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS27 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS45 INS42 INS16 INS25 INS44 INS8 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS8 INS8 INS43 INS42 INS21 INS43 INS45 INS42 INS21 INS21 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS36 INS45 INS42 INS16 INS42 INS45 INS45 DEL8 DEL42 DEL42 DEL32 DEL45 DEL40 DEL43 DEL57 DEL32 DEL85 DEL5 DEL45 DEL4 DEL3 DEL32 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21
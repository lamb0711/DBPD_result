HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.

+import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.server.common.HdfsServerConstants;
-public class BlockInfoContiguousUnderConstruction extends BlockInfoContiguous {
+public abstract class BlockInfoUnderConstruction extends BlockInfo {
-  private BlockUCState blockUCState;
+  protected BlockUCState blockUCState;
-  private List<ReplicaUnderConstruction> replicas;
+  protected List<ReplicaUnderConstruction> replicas;
-  private Block truncateBlock;
+  protected Block truncateBlock;
-   * The GS, the length and the state of the replica is as reported by 
+   * The GS, the length and the state of the replica is as reported by
-    
+
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication) {
+  public BlockInfoUnderConstruction(Block blk, short replication) {
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication,
+  public BlockInfoUnderConstruction(Block blk, short replication,
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "BlockInfoUnderConstruction cannot be in COMPLETE state";
+    Preconditions.checkState(getBlockUCState() != BlockUCState.COMPLETE,
+        "BlockInfoUnderConstruction cannot be in COMPLETE state");
-  /**
-   * Convert an under construction block to a complete block.
-   * 
-   * @return BlockInfo - a complete block.
-   * @throws IOException if the state of the block 
-   * (the generation stamp and the length) has not been committed by 
-   * the client or it does not have at least a minimal number of replicas 
-   * reported from data-nodes. 
-   */
-  BlockInfo convertToCompleteBlock() throws IOException {
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "Trying to convert a COMPLETE block";
-    return new BlockInfoContiguous(this);
-  }
-
-  /** Set expected locations */
-  public void setExpectedLocations(DatanodeStorageInfo[] targets) {
-    int numLocations = targets == null ? 0 : targets.length;
-    this.replicas = new ArrayList<ReplicaUnderConstruction>(numLocations);
-    for(int i = 0; i < numLocations; i++)
-      replicas.add(
-        new ReplicaUnderConstruction(this, targets[i], ReplicaState.RBW));
-  }
+  /** Set expected locations. */
+  public abstract void setExpectedLocations(DatanodeStorageInfo[] targets);
-    for(int i = 0; i < numLocations; i++)
+    for(int i = 0; i < numLocations; i++) {
+    }
-  /** Get the number of expected locations */
+  /** Get the number of expected locations. */
-  /** Get block recovery ID */
+  /** Get block recovery ID. */
-  /** Get recover block */
-  public Block getTruncateBlock() {
-    return truncateBlock;
-  }
+  /** Get recover block. */
+  public abstract Block getTruncateBlock();
-  public void setTruncateBlock(Block recoveryBlock) {
-    this.truncateBlock = recoveryBlock;
-  }
+  public abstract void setTruncateBlock(Block recoveryBlock);
-    if (replicas == null)
+    if (replicas == null) {
+    }
-   * @param block - contains client reported block length and generation 
+   * @param block - contains client reported block length and generation
-    if(getBlockId() != block.getBlockId())
+    if(getBlockId() != block.getBlockId()) {
+    }
-      NameNode.blockStateChangeLog.warn("BLOCK*"
-        + " BlockInfoUnderConstruction.initLeaseRecovery:"
-        + " No blocks found, lease removed.");
+      NameNode.blockStateChangeLog.warn("BLOCK* " +
+          "BlockInfoUnderConstruction.initLeaseRecovery: " +
+          "No blocks found, lease removed.");
-            (allLiveReplicasTriedAsPrimary && replicas.get(i).getChosenAsPrimary());
+            (allLiveReplicasTriedAsPrimary &&
+                replicas.get(i).getChosenAsPrimary());
-      if (!(replicas.get(i).isAlive() && !replicas.get(i).getChosenAsPrimary())) {
+      if (!(replicas.get(i).isAlive() &&
+          !replicas.get(i).getChosenAsPrimary())) {
-      primary.getExpectedStorageLocation().getDatanodeDescriptor().addBlockToBeRecovered(this);
+      primary.getExpectedStorageLocation().
+          getDatanodeDescriptor().addBlockToBeRecovered(this);
+  /**
+   * Convert an under construction block to a complete block.
+   *
+   * @return a complete block.
+   * @throws IOException
+   *           if the state of the block (the generation stamp and the length)
+   *           has not been committed by the client or it does not have at
+   *           least a minimal number of replicas reported from data-nodes.
+   */
+  public abstract BlockInfo convertToCompleteBlock();
+
+  @Override
+  BlockInfoUnderConstruction convertCompleteBlockToUC
+      (HdfsServerConstants.BlockUCState s, DatanodeStorageInfo[] targets) {
+    BlockManager.LOG.error("convertCompleteBlockToUC should only be applied " +
+        "on complete blocks.");
+    return null;
+  }
+

INS26 INS26 INS40 INS40 INS83 UPD42 UPD43 INS31 INS31 INS31 UPD42 UPD83 UPD83 UPD83 UPD42 UPD42 INS83 INS44 INS83 MOV83 INS83 MOV39 MOV42 MOV44 INS29 INS83 INS83 MOV43 INS42 INS78 INS43 INS42 INS44 MOV44 MOV8 INS21 INS5 INS42 MOV65 INS65 INS65 INS42 INS42 INS43 INS42 INS41 UPD66 INS32 UPD66 INS43 INS85 INS8 UPD66 UPD66 UPD66 INS8 UPD66 INS8 INS66 INS42 INS66 INS66 INS66 INS40 INS32 INS33 INS42 INS42 MOV27 INS45 UPD42 MOV42 MOV21 INS41 MOV53 INS40 INS42 INS27 INS45 INS45 UPD45 UPD45 UPD45 DEL45 DEL6 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL32 DEL40 DEL27 DEL45 DEL6 DEL42 DEL43 DEL52 DEL14 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL33 DEL27 DEL34 DEL40 DEL16 DEL59 DEL60 DEL52 DEL42 DEL22 DEL43 DEL42 DEL43 DEL74 DEL42 DEL14 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL43 DEL52 DEL42 DEL42 DEL2 DEL40 DEL14 DEL32 DEL21 DEL24 DEL8 DEL42 DEL41 DEL8 DEL31 DEL41 DEL52 DEL42 DEL22 DEL42 DEL7
Merge from trunk to fs-encryption branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1596873 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.yarn.api.records.ApplicationId;
+import org.apache.hadoop.yarn.api.records.Container;
+import org.apache.hadoop.yarn.api.records.ContainerId;
+import org.apache.hadoop.yarn.api.records.Priority;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainer;
+import org.apache.hadoop.yarn.server.resourcemanager.rmnode.RMNode;
+import org.apache.hadoop.yarn.util.resource.Resources;
+
+import com.google.common.base.Preconditions;
+  private static final Log LOG = LogFactory.getLog(SchedulerNode.class);
+
+  private Resource availableResource = Resource.newInstance(0, 0);
+  private Resource usedResource = Resource.newInstance(0, 0);
+  private Resource totalResourceCapability;
+  private RMContainer reservedContainer;
+  private volatile int numContainers;
+
+
+  /* set of containers that are allocated containers */
+  private final Map<ContainerId, RMContainer> launchedContainers =
+      new HashMap<ContainerId, RMContainer>();
+
+  private final RMNode rmNode;
+  private final String nodeName;
+
+  public SchedulerNode(RMNode node, boolean usePortForNodeName) {
+    this.rmNode = node;
+    this.availableResource = Resources.clone(node.getTotalCapability());
+    this.totalResourceCapability = Resources.clone(node.getTotalCapability());
+    if (usePortForNodeName) {
+      nodeName = rmNode.getHostName() + ":" + node.getNodeID().getPort();
+    } else {
+      nodeName = rmNode.getHostName();
+    }
+  }
+
+  public RMNode getRMNode() {
+    return this.rmNode;
+  }
+
+  /**
+   * Get the ID of the node which contains both its hostname and port.
+   * 
+   * @return the ID of the node
+   */
+  public NodeId getNodeID() {
+    return this.rmNode.getNodeID();
+  }
+
+  public String getHttpAddress() {
+    return this.rmNode.getHttpAddress();
+  }
+
-   * Typically this is the 'hostname' reported by the node, but it could be 
-   * configured to be 'hostname:port' reported by the node via the 
+   * Typically this is the 'hostname' reported by the node, but it could be
+   * configured to be 'hostname:port' reported by the node via the
-  public abstract String getNodeName();
-  
+  public String getNodeName() {
+    return nodeName;
+  }
+
+   * 
-  public abstract String getRackName();
-  
+  public String getRackName() {
+    return this.rmNode.getRackName();
+  }
+
-   * Get used resources on the node.
-   * @return used resources on the node
+   * The Scheduler has allocated containers on this node to the given
+   * application.
+   * 
+   * @param applicationId
+   *          application
+   * @param rmContainer
+   *          allocated container
-  public abstract Resource getUsedResource();
+  public synchronized void allocateContainer(ApplicationId applicationId,
+      RMContainer rmContainer) {
+    Container container = rmContainer.getContainer();
+    deductAvailableResource(container.getResource());
+    ++numContainers;
+
+    launchedContainers.put(container.getId(), rmContainer);
+
+    LOG.info("Assigned container " + container.getId() + " of capacity "
+        + container.getResource() + " on host " + rmNode.getNodeAddress()
+        + ", which currently has " + numContainers + " containers, "
+        + getUsedResource() + " used and " + getAvailableResource()
+        + " available");
+  }
+   * 
-  public abstract Resource getAvailableResource();
+  public synchronized Resource getAvailableResource() {
+    return this.availableResource;
+  }
-   * Get number of active containers on the node.
-   * @return number of active containers on the node
+   * Get used resources on the node.
+   * 
+   * @return used resources on the node
-  public abstract int getNumContainers();
-  
-  /**
-   * Apply delta resource on node's available resource.
-   * @param deltaResource the delta of resource need to apply to node
-   */
-  public abstract void applyDeltaOnAvailableResource(Resource deltaResource);
+  public synchronized Resource getUsedResource() {
+    return this.usedResource;
+  }
+   * 
-  public abstract Resource getTotalResource();
-  
-  /**
-   * Get the ID of the node which contains both its hostname and port.
-   * @return the ID of the node
-   */
-  public abstract NodeId getNodeID();
+  public Resource getTotalResource() {
+    return this.totalResourceCapability;
+  }
+  private synchronized boolean isValidContainer(Container c) {
+    if (launchedContainers.containsKey(c.getId())) {
+      return true;
+    }
+    return false;
+  }
+
+  private synchronized void updateResource(Container container) {
+    addAvailableResource(container.getResource());
+    --numContainers;
+  }
+
+  /**
+   * Release an allocated container on this node.
+   * 
+   * @param container
+   *          container to be released
+   */
+  public synchronized void releaseContainer(Container container) {
+    if (!isValidContainer(container)) {
+      LOG.error("Invalid container released " + container);
+      return;
+    }
+
+    /* remove the containers from the nodemanger */
+    if (null != launchedContainers.remove(container.getId())) {
+      updateResource(container);
+    }
+
+    LOG.info("Released container " + container.getId() + " of capacity "
+        + container.getResource() + " on host " + rmNode.getNodeAddress()
+        + ", which currently has " + numContainers + " containers, "
+        + getUsedResource() + " used and " + getAvailableResource()
+        + " available" + ", release resources=" + true);
+  }
+
+  private synchronized void addAvailableResource(Resource resource) {
+    if (resource == null) {
+      LOG.error("Invalid resource addition of null resource for "
+          + rmNode.getNodeAddress());
+      return;
+    }
+    Resources.addTo(availableResource, resource);
+    Resources.subtractFrom(usedResource, resource);
+  }
+
+  private synchronized void deductAvailableResource(Resource resource) {
+    if (resource == null) {
+      LOG.error("Invalid deduction of null resource for "
+          + rmNode.getNodeAddress());
+      return;
+    }
+    Resources.subtractFrom(availableResource, resource);
+    Resources.addTo(usedResource, resource);
+  }
+
+  /**
+   * Reserve container for the attempt on this node.
+   */
+  public abstract void reserveResource(SchedulerApplicationAttempt attempt,
+      Priority priority, RMContainer container);
+
+  /**
+   * Unreserve resources on this node.
+   */
+  public abstract void unreserveResource(SchedulerApplicationAttempt attempt);
+
+  @Override
+  public String toString() {
+    return "host: " + rmNode.getNodeAddress() + " #containers="
+        + getNumContainers() + " available="
+        + getAvailableResource().getMemory() + " used="
+        + getUsedResource().getMemory();
+  }
+
+  /**
+   * Get number of active containers on the node.
+   * 
+   * @return number of active containers on the node
+   */
+  public int getNumContainers() {
+    return numContainers;
+  }
+
+  public synchronized List<RMContainer> getRunningContainers() {
+    return new ArrayList<RMContainer>(launchedContainers.values());
+  }
+
+  public synchronized RMContainer getReservedContainer() {
+    return reservedContainer;
+  }
+
+  protected synchronized void
+      setReservedContainer(RMContainer reservedContainer) {
+    this.reservedContainer = reservedContainer;
+  }
+
+  /**
+   * Apply delta resource on node's available resource.
+   * 
+   * @param deltaResource
+   *          the delta of resource need to apply to node
+   */
+  public synchronized void
+      applyDeltaOnAvailableResource(Resource deltaResource) {
+    // we can only adjust available resource if total resource is changed.
+    Resources.addTo(this.availableResource, deltaResource);
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS74 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS8 INS8 INS83 INS43 INS42 INS8 MOV29 MOV83 MOV43 INS42 INS8 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 UPD83 INS8 UPD83 INS8 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 MOV83 INS39 INS42 INS44 INS44 INS44 INS29 INS83 INS83 INS39 INS42 INS44 INS78 INS83 INS43 INS42 INS8 INS8 INS83 INS83 INS74 INS42 INS8 INS83 INS83 INS43 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 UPD83 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS42 INS39 INS42 INS21 INS21 INS21 INS25 INS42 INS41 INS41 INS42 INS41 INS41 INS41 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS21 INS21 INS21 INS21 INS41 INS41 INS41 INS43 INS42 INS25 INS41 INS43 INS42 INS21 INS21 INS65 INS65 INS43 INS42 INS25 INS25 INS21 INS43 INS42 INS25 INS21 INS21 INS43 INS42 INS25 INS21 INS21 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS65 INS43 INS42 INS42 INS42 INS41 INS41 INS43 INS43 INS41 INS42 INS41 INS43 INS42 INS21 INS21 INS42 INS42 INS57 INS42 INS42 INS34 INS34 INS42 INS42 INS34 INS34 INS42 INS42 INS42 INS74 INS42 INS7 INS7 INS7 INS42 INS8 INS8 INS22 INS32 INS32 UPD66 UPD66 INS42 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS32 INS38 INS32 INS32 INS22 INS22 INS22 INS42 INS32 INS8 INS9 INS42 INS32 INS38 INS66 INS42 INS66 INS42 INS38 INS8 INS27 INS8 INS32 INS42 INS27 INS8 INS32 INS32 INS42 INS27 INS8 INS32 INS32 INS66 INS42 INS42 INS42 INS66 INS42 INS27 INS42 INS42 INS42 INS14 INS42 INS42 INS7 UPD66 INS32 INS43 INS43 INS43 INS43 INS22 INS42 INS22 INS32 INS22 INS32 INS21 INS21 INS52 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS32 INS41 INS42 INS32 INS42 INS32 INS21 INS41 INS33 INS32 INS21 INS42 INS42 INS27 INS42 INS33 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS32 INS74 INS32 INS22 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS32 INS52 INS42 INS42 INS42 INS32 INS7 INS7 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS45 INS9 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS45 INS32 INS42 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL83 DEL42 DEL31 DEL83 DEL83 DEL83
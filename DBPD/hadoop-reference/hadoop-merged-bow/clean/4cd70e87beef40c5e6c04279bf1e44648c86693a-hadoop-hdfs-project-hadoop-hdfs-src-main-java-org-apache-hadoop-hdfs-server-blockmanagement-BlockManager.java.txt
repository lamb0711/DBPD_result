Merge trunk into auto-HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1337645 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.server.namenode.INodeFile;
-import org.apache.hadoop.hdfs.server.namenode.INodeFileUnderConstruction;
-   * Mapping: Block -> { INode, datanodes, self ref }
+   * Mapping: Block -> { BlockCollection, datanodes, self ref }
-  /** The maximum number of entries returned by getCorruptInodes() */
+  /** value returned by MAX_CORRUPT_FILES_RETURNED */
-      String fileName = ((BlockInfo)block).getINode().getFullPathName();
+      String fileName = ((BlockInfo)block).getBlockCollection().getName();
-   * @param fileINode file inode
+   * @param bc block collection
-  public boolean commitOrCompleteLastBlock(INodeFileUnderConstruction fileINode, 
+  public boolean commitOrCompleteLastBlock(MutableBlockCollection bc, 
-    BlockInfo lastBlock = fileINode.getLastBlock();
+    BlockInfo lastBlock = bc.getLastBlock();
-      completeBlock(fileINode,fileINode.numBlocks()-1, false);
+      completeBlock(bc, bc.numBlocks()-1, false);
-   * @param fileINode file
+   * @param bc file
-  private BlockInfo completeBlock(final INodeFile fileINode,
+  private BlockInfo completeBlock(final MutableBlockCollection bc,
-    BlockInfo curBlock = fileINode.getBlocks()[blkIndex];
+    BlockInfo curBlock = bc.getBlocks()[blkIndex];
-    fileINode.setBlock(blkIndex, completeBlock);
+    bc.setBlock(blkIndex, completeBlock);
-  private BlockInfo completeBlock(final INodeFile fileINode,
+  private BlockInfo completeBlock(final MutableBlockCollection bc,
-    BlockInfo[] fileBlocks = fileINode.getBlocks();
+    BlockInfo[] fileBlocks = bc.getBlocks();
-        return completeBlock(fileINode, idx, force);
+        return completeBlock(bc, idx, force);
-  public BlockInfo forceCompleteBlock(final INodeFile fileINode,
+  public BlockInfo forceCompleteBlock(final MutableBlockCollection bc,
-    return completeBlock(fileINode, block, true);
+    return completeBlock(bc, block, true);
-   * @param fileINode file
+   * @param bc file
-      INodeFileUnderConstruction fileINode) throws IOException {
-    BlockInfo oldBlock = fileINode.getLastBlock();
+      MutableBlockCollection bc) throws IOException {
+    BlockInfo oldBlock = bc.getLastBlock();
-        fileINode.getPreferredBlockSize() == oldBlock.getNumBytes())
+        bc.getPreferredBlockSize() == oldBlock.getNumBytes())
-      fileINode.setLastBlock(oldBlock, targets);
+      bc.setLastBlock(oldBlock, targets);
-    final long fileLength = fileINode.computeContentSummary().getLength();
+    final long fileLength = bc.computeContentSummary().getLength();
-    INodeFile inode = storedBlock.getINode();
-    if (inode == null) {
+    BlockCollection bc = storedBlock.getBlockCollection();
+    if (bc == null) {
-    if (countNodes(storedBlock).liveReplicas() >= inode.getReplication()) {
+    if (countNodes(storedBlock).liveReplicas() >= bc.getReplication()) {
-    INodeFile fileINode = null;
+    BlockCollection bc = null;
-            fileINode = blocksMap.getINode(block);
+            bc = blocksMap.getBlockCollection(block);
-            if(fileINode == null || fileINode.isUnderConstruction()) {
+            if(bc == null || bc instanceof MutableBlockCollection) {
-            requiredReplication = fileINode.getReplication();
+            requiredReplication = bc.getReplication();
-            work.add(new ReplicationWork(block, fileINode, srcNode,
+            work.add(new ReplicationWork(block, bc, srcNode,
-      // so for now we pass in the Inode itself.
-      rw.targets = blockplacement.chooseTarget(rw.fileINode,
+      // so for now we pass in the block collection itself.
+      rw.targets = blockplacement.chooseTarget(rw.bc,
-          fileINode = blocksMap.getINode(block);
+          bc = blocksMap.getBlockCollection(block);
-          if(fileINode == null || fileINode.isUnderConstruction()) {
+          if(bc == null || bc instanceof MutableBlockCollection) {
-          requiredReplication = fileINode.getReplication();
+          requiredReplication = bc.getReplication();
-      completeBlock(storedBlock.getINode(), storedBlock, false);
+      completeBlock((MutableBlockCollection)storedBlock.getBlockCollection(), storedBlock, false);
-    if (storedBlock == null || storedBlock.getINode() == null) {
+    if (storedBlock == null || storedBlock.getBlockCollection() == null) {
-    INodeFile fileINode = storedBlock.getINode();
-    assert fileINode != null : "Block must belong to a file";
+    BlockCollection bc = storedBlock.getBlockCollection();
+    assert bc != null : "Block must belong to a file";
-      storedBlock = completeBlock(fileINode, storedBlock, false);
+      storedBlock = completeBlock((MutableBlockCollection)bc, storedBlock, false);
-    if (fileINode.isUnderConstruction()) {
+    if (bc instanceof MutableBlockCollection) {
-    short fileReplication = fileINode.getReplication();
+    short fileReplication = bc.getReplication();
-    INodeFile fileINode = block.getINode();
-    if (fileINode == null) {
+    BlockCollection bc = block.getBlockCollection();
+    if (bc == null) {
-    short expectedReplication = fileINode.getReplication();
+    short expectedReplication = bc.getReplication();
-    INodeFile inode = getINode(b);
+    BlockCollection bc = getBlockCollection(b);
-        cur = replicator.chooseReplicaToDelete(inode, b, replication,
+        cur = replicator.chooseReplicaToDelete(bc, b, replication,
-      INodeFile fileINode = blocksMap.getINode(block);
-      if (fileINode != null) {
+      BlockCollection bc = blocksMap.getBlockCollection(block);
+      if (bc != null) {
-    INodeFile fileINode = blocksMap.getINode(block);
+    BlockCollection bc = blocksMap.getBlockCollection(block);
-        + ", Is Open File: " + fileINode.isUnderConstruction()
+        + ", Is Open File: " + (bc instanceof MutableBlockCollection)
-      INodeFile fileINode = blocksMap.getINode(block);
-      short expectedReplication = fileINode.getReplication();
+      BlockCollection bc = blocksMap.getBlockCollection(block);
+      short expectedReplication = bc.getReplication();
-      INodeFile fileINode = blocksMap.getINode(block);
+      BlockCollection bc = blocksMap.getBlockCollection(block);
-      if (fileINode != null) {
+      if (bc != null) {
-            if (fileINode.isUnderConstruction()) {
+            if (bc instanceof MutableBlockCollection) {
-    INodeFile fileINode = blocksMap.getINode(block);
-    if (fileINode == null) { // block does not belong to any file
+    BlockCollection bc = blocksMap.getBlockCollection(block);
+    if (bc == null) { // block does not belong to any file
-    assert !fileINode.isDirectory() : "Block cannot belong to a directory.";
-    return fileINode.getReplication();
+    return bc.getReplication();
-  public BlockInfo addINode(BlockInfo block, INodeFile iNode) {
-    return blocksMap.addINode(block, iNode);
+  public BlockInfo addBlockCollection(BlockInfo block, BlockCollection bc) {
+    return blocksMap.addBlockCollection(block, bc);
-  public INodeFile getINode(Block b) {
-    return blocksMap.getINode(b);
+  public BlockCollection getBlockCollection(Block b) {
+    return blocksMap.getBlockCollection(b);
-    private INodeFile fileINode;
+    private BlockCollection bc;
-        INodeFile fileINode,
+        BlockCollection bc,
-      this.fileINode = fileINode;
+      this.bc = bc;

UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 UPD43 UPD66 UPD66 UPD42 UPD66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD43 INS62 UPD43 UPD43 UPD43 UPD43 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS36 UPD43 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 INS11 UPD42 UPD42 INS62 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD40 INS43 INS32 INS11 INS42 INS43 UPD42 UPD42 UPD42 UPD42 INS42 MOV42 UPD42 MOV42 INS43 INS42 INS42 INS42 UPD42 UPD42 INS62 UPD42 UPD42 INS42 INS43 UPD42 INS62 UPD42 INS62 INS42 INS42 INS43 UPD42 UPD42 INS42 INS43 UPD42 UPD42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL45 DEL6
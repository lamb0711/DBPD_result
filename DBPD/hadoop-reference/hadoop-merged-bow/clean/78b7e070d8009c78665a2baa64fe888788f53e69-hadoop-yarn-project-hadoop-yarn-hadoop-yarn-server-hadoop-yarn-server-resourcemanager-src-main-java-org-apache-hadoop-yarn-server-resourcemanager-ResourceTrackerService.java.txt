YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.

+import java.util.concurrent.atomic.AtomicLong;
+import org.apache.hadoop.yarn.server.api.records.AppCollectorData;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMAppImpl;
+  private final AtomicLong timelineCollectorVersion = new AtomicLong(0);
+
-      // TODO make sure it won't have race condition issue for AM failed over
-      // case that the older registration could possible override the newer
-      // one.
-    Map<ApplicationId, String> liveAppCollectorsMap = new
-        HashMap<ApplicationId, String>();
+    Map<ApplicationId, AppCollectorData> liveAppCollectorsMap = new
+        HashMap<>();
-      String appCollectorAddr = rmApps.get(appId).getCollectorAddr();
-      if (appCollectorAddr != null) {
-        liveAppCollectorsMap.put(appId, appCollectorAddr);
+      AppCollectorData appCollectorData = rmApps.get(appId).getCollectorData();
+      if (appCollectorData != null) {
+        liveAppCollectorsMap.put(appId, appCollectorData);
-    response.setAppCollectorsMap(liveAppCollectorsMap);
+    response.setAppCollectors(liveAppCollectorsMap);
-    Map<ApplicationId, String> registeredCollectorsMap =
-        request.getRegisteredCollectors();
-    if (registeredCollectorsMap != null
-        && !registeredCollectorsMap.isEmpty()) {
+    Map<ApplicationId, AppCollectorData> registeringCollectorsMap =
+        request.getRegisteringCollectors();
+    if (registeringCollectorsMap != null
+        && !registeringCollectorsMap.isEmpty()) {
-      for (Map.Entry<ApplicationId, String> entry:
-          registeredCollectorsMap.entrySet()) {
+      for (Map.Entry<ApplicationId, AppCollectorData> entry:
+          registeringCollectorsMap.entrySet()) {
-        String collectorAddr = entry.getValue();
-        if (collectorAddr != null && !collectorAddr.isEmpty()) {
+        AppCollectorData collectorData = entry.getValue();
+        if (collectorData != null) {
+          if (!collectorData.isStamped()) {
+            // Stamp the collector if we have not done so
+            collectorData.setRMIdentifier(
+                ResourceManager.getClusterTimeStamp());
+            collectorData.setVersion(
+                timelineCollectorVersion.getAndIncrement());
+          }
-            String previousCollectorAddr = rmApp.getCollectorAddr();
-            if (previousCollectorAddr == null
-                || !previousCollectorAddr.equals(collectorAddr)) {
-              rmApp.setCollectorAddr(collectorAddr);
+            AppCollectorData previousCollectorData = rmApp.getCollectorData();
+            if (AppCollectorData.happensBefore(previousCollectorData,
+                collectorData)) {
+              // Sending collector update event.
+              // Note: RM has to store the newly received collector data
+              // synchronously. Otherwise, the RM may send out stale collector
+              // data before this update is done, and the RM then crashes, the
+              // newly updated collector data will get lost.
+              LOG.info("Update collector information for application " + appId
+                  + " with new address: " + collectorData.getCollectorAddr());
+              ((RMAppImpl) rmApp).setCollectorData(collectorData);

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS83 INS83 INS43 INS59 INS42 INS42 INS14 INS43 INS34 UPD74 UPD74 INS42 MOV43 UPD43 UPD42 UPD43 UPD42 UPD42 UPD74 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD74 UPD42 UPD42 UPD43 UPD43 INS27 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV33 INS25 MOV60 MOV25 INS38 INS8 MOV32 INS21 INS21 UPD42 UPD42 INS32 INS32 UPD43 INS32 INS8 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS21 MOV21 INS42 INS42 INS42 INS42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS27 INS36 UPD42 UPD42 INS45 INS42 INS45 INS32 INS11 INS42 UPD42 MOV42 INS43 INS42 INS42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL33 DEL27 DEL32 DEL38 DEL27 DEL8 DEL27 DEL38 DEL27 DEL8
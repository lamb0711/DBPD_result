Merge trunk into HDFS-1623 branch.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1158072 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Map.Entry;
-import org.apache.hadoop.hdfs.DFSConfigKeys;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.*;
-import org.apache.hadoop.hdfs.protocol.BlockListAsLongs;
+import org.apache.hadoop.hdfs.protocol.FSConstants.DatanodeReportType;
+import org.apache.hadoop.hdfs.protocol.FSConstants.SafeModeAction;
+import org.apache.hadoop.hdfs.protocol.FSConstants.UpgradeAction;
-import org.apache.hadoop.hdfs.protocol.UnregisteredNodeException;
+import org.apache.hadoop.hdfs.security.token.block.BlockTokenSecretManager.AccessMode;
-import org.apache.hadoop.hdfs.server.blockmanagement.BlockPlacementPolicy;
-import org.apache.hadoop.hdfs.server.blockmanagement.UnderReplicatedBlocks;
+import org.apache.hadoop.hdfs.server.blockmanagement.DatanodeStatistics;
-import org.apache.hadoop.hdfs.server.protocol.BlocksWithLocations;
-import org.apache.hadoop.hdfs.server.protocol.KeyUpdateCommand;
-import org.apache.hadoop.hdfs.server.protocol.RemoteEditLogManifest;
+import org.apache.hadoop.hdfs.util.RwLock;
-public class FSNamesystem implements FSConstants, FSNamesystemMBean,
-    FSClusterStats, NameNodeMXBean {
+public class FSNamesystem implements RwLock, FSClusterStats,
+    FSNamesystemMBean, NameNodeMXBean {
-  private long capacityTotal = 0L, capacityUsed = 0L, capacityRemaining = 0L;
-  private long blockPoolUsed = 0L;
-  private int totalLoad = 0;
-  public FSDirectory dir;
+  FSDirectory dir;
-  
+  private DatanodeStatistics datanodeStatistics;
+
-  String blockPoolId;
+  private String blockPoolId;
-  /**
-   * Stores a subset of datanodeMap, containing nodes that are considered alive.
-   * The HeartbeatMonitor periodically checks for out-dated entries,
-   * and removes them from the list.
-   */
-  public ArrayList<DatanodeDescriptor> heartbeats = new ArrayList<DatanodeDescriptor>();
+  LeaseManager leaseManager = new LeaseManager(this); 
-  public LeaseManager leaseManager = new LeaseManager(this); 
-
-  //
-  // Threaded object that checks to see if we have been
-  // getting heartbeats from all clients. 
-  //
-  Daemon hbthread = null;   // HeartbeatMonitor thread
-  public Daemon lmthread = null;   // LeaseMonitor thread
+  Daemon lmthread = null;   // LeaseMonitor thread
-  // heartbeatRecheckInterval is how often namenode checks for expired datanodes
-  private long heartbeatRecheckInterval;
-
-    resourceRecheckInterval =
-        conf.getLong(DFSConfigKeys.DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY,
-        DFSConfigKeys.DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT);
+    resourceRecheckInterval = conf.getLong(
+        DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY,
+        DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT);
+    this.datanodeStatistics = blockManager.getDatanodeManager().getDatanodeStatistics();
-    setBlockTotal();
-    blockManager.activate(conf);
-    this.hbthread = new Daemon(new HeartbeatMonitor());
-    this.lmthread = new Daemon(leaseManager.new Monitor());
+    writeLock();
+    try {
+      setBlockTotal();
+      blockManager.activate(conf);
+
+      this.lmthread = new Daemon(leaseManager.new Monitor());
+      lmthread.start();
+      this.nnrmthread = new Daemon(new NameNodeResourceMonitor());
+      nnrmthread.start();
+    } finally {
+      writeUnlock();
+    }
-    hbthread.start();
-    lmthread.start();
-
-    this.nnrmthread = new Daemon(new NameNodeResourceMonitor());
-    nnrmthread.start();
-
-    return getStorageDirs(conf, DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY);
+    return getStorageDirs(conf, DFS_NAMENODE_NAME_DIR_KEY);
-  public static Collection<URI> getStorageDirs(Configuration conf,
+  private static Collection<URI> getStorageDirs(Configuration conf,
-    return getStorageDirs(conf, DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY);
+    return getStorageDirs(conf, DFS_NAMENODE_EDITS_DIR_KEY);
-  // utility methods to acquire and release read lock and write lock
+  @Override
-
+  @Override
-
+  @Override
-
+  @Override
-
+  @Override
-
-  boolean hasReadLock() {
+  @Override
+  public boolean hasReadLock() {
-
-  boolean hasReadOrWriteLock() {
+  @Override
+  public boolean hasReadOrWriteLock() {
-    this.supergroup = conf.get(DFSConfigKeys.DFS_PERMISSIONS_SUPERUSERGROUP_KEY, 
-                               DFSConfigKeys.DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT);
-    this.isPermissionEnabled = conf.getBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,
-                                               DFSConfigKeys.DFS_PERMISSIONS_ENABLED_DEFAULT);
+    this.supergroup = conf.get(DFS_PERMISSIONS_SUPERUSERGROUP_KEY, 
+                               DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT);
+    this.isPermissionEnabled = conf.getBoolean(DFS_PERMISSIONS_ENABLED_KEY,
+                                               DFS_PERMISSIONS_ENABLED_DEFAULT);
-    short filePermission = (short)conf.getInt(DFSConfigKeys.DFS_NAMENODE_UPGRADE_PERMISSION_KEY,
-                                              DFSConfigKeys.DFS_NAMENODE_UPGRADE_PERMISSION_DEFAULT);
+    short filePermission = (short)conf.getInt(DFS_NAMENODE_UPGRADE_PERMISSION_KEY,
+                                              DFS_NAMENODE_UPGRADE_PERMISSION_DEFAULT);
-
-    this.heartbeatRecheckInterval = conf.getInt(
-        DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY, 
-        DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT); // 5 minutes
-        conf.getLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY, DEFAULT_BLOCK_SIZE),
-        conf.getInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY, DEFAULT_BYTES_PER_CHECKSUM),
-        conf.getInt(DFSConfigKeys.DFS_CLIENT_WRITE_PACKET_SIZE_KEY, DEFAULT_WRITE_PACKET_SIZE),
-        (short) conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, DEFAULT_REPLICATION_FACTOR),
-        conf.getInt("io.file.buffer.size", DEFAULT_FILE_BUFFER_SIZE));
-    this.maxFsObjects = conf.getLong(DFSConfigKeys.DFS_NAMENODE_MAX_OBJECTS_KEY, 
-                                     DFSConfigKeys.DFS_NAMENODE_MAX_OBJECTS_DEFAULT);
+        conf.getLong(DFS_BLOCK_SIZE_KEY, DFS_BLOCK_SIZE_DEFAULT),
+        conf.getInt(DFS_BYTES_PER_CHECKSUM_KEY, DFS_BYTES_PER_CHECKSUM_DEFAULT),
+        conf.getInt(DFS_CLIENT_WRITE_PACKET_SIZE_KEY, DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT),
+        (short) conf.getInt(DFS_REPLICATION_KEY, DFS_REPLICATION_DEFAULT),
+        conf.getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT));
+    
+    this.maxFsObjects = conf.getLong(DFS_NAMENODE_MAX_OBJECTS_KEY, 
+                                     DFS_NAMENODE_MAX_OBJECTS_DEFAULT);
-    this.accessTimePrecision = conf.getLong(DFSConfigKeys.DFS_NAMENODE_ACCESSTIME_PRECISION_KEY, 0);
-    this.supportAppends = conf.getBoolean(DFSConfigKeys.DFS_SUPPORT_APPEND_KEY,
-                                      DFSConfigKeys.DFS_SUPPORT_APPEND_DEFAULT);
+    this.accessTimePrecision = conf.getLong(DFS_NAMENODE_ACCESSTIME_PRECISION_KEY, 0);
+    this.supportAppends = conf.getBoolean(DFS_SUPPORT_APPEND_KEY,
+        DFS_SUPPORT_APPEND_DEFAULT);
-          dir.fsImage.getStorage().getCTime(), getDistributedUpgradeVersion());
+          dir.fsImage.getStorage().getCTime(),
+          upgradeManager.getUpgradeVersion());
-  public void close() {
+  void close() {
-      if (hbthread != null) hbthread.interrupt();
-  
-      ArrayList<DatanodeDescriptor> live = new ArrayList<DatanodeDescriptor>();
-      ArrayList<DatanodeDescriptor> dead = new ArrayList<DatanodeDescriptor>();
-      this.DFSNodesStatus(live, dead);
-      
-      String str = totalInodes + " files and directories, " + totalBlocks
-          + " blocks = " + (totalInodes + totalBlocks) + " total";
-      out.println(str);
+      out.println(totalInodes + " files and directories, " + totalBlocks
+          + " blocks = " + (totalInodes + totalBlocks) + " total");
+
+      final List<DatanodeDescriptor> live = new ArrayList<DatanodeDescriptor>();
+      final List<DatanodeDescriptor> dead = new ArrayList<DatanodeDescriptor>();
+      blockManager.getDatanodeManager().fetchDatanodes(live, dead, false);
-  // These methods are called by secondary namenodes
-  //
-  /////////////////////////////////////////////////////////
-  /**
-   * return a list of blocks & their locations on <code>datanode</code> whose
-   * total size is <code>size</code>
-   * 
-   * @param datanode on which blocks are located
-   * @param size total size of blocks
-   */
-  BlocksWithLocations getBlocks(DatanodeID datanode, long size)
-      throws IOException {
-    readLock();
-    try {
-      checkSuperuserPrivilege();
-      return blockManager.getBlocksWithLocations(datanode, size);  
-    } finally {
-      readUnlock();
-    }
-  }
-
-
-  /////////////////////////////////////////////////////////
-  //
-  public void setPermission(String src, FsPermission permission)
+  void setPermission(String src, FsPermission permission)
-  public void setOwner(String src, String username, String group)
+  void setOwner(String src, String username, String group)
-        return getBlockLocationsInternal(inode, offset, length, needBlockToken);
+        return blockManager.createLocatedBlocks(inode.getBlocks(),
+            inode.computeFileSize(false), inode.isUnderConstruction(),
+            offset, length, needBlockToken);
-  
-  LocatedBlocks getBlockLocationsInternal(INodeFile inode,
-      long offset, long length, boolean needBlockToken)
-  throws IOException {
-    assert hasReadOrWriteLock();
-    final BlockInfo[] blocks = inode.getBlocks();
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("blocks = " + java.util.Arrays.asList(blocks));
-    }
-    if (blocks == null) {
-      return null;
-    }
-
-    if (blocks.length == 0) {
-      return new LocatedBlocks(0, inode.isUnderConstruction(),
-          Collections.<LocatedBlock>emptyList(), null, false);
-    } else {
-      final long n = inode.computeFileSize(false);
-      final List<LocatedBlock> locatedblocks = blockManager.getBlockLocations(
-          blocks, offset, length, Integer.MAX_VALUE);
-      final BlockInfo last = inode.getLastBlock();
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("last = " + last);
-      }
-      
-      LocatedBlock lastBlock = last.isComplete() ? blockManager
-          .getBlockLocation(last, n - last.getNumBytes()) : blockManager
-          .getBlockLocation(last, n);
-          
-      if (blockManager.isBlockTokenEnabled() && needBlockToken) {
-        blockManager.setBlockTokens(locatedblocks);
-        blockManager.setBlockToken(lastBlock);
-      }
-      return new LocatedBlocks(n, inode.isUnderConstruction(), locatedblocks,
-          lastBlock, last.isComplete());
-    }
-  }
-
-  /** Create a LocatedBlock. */
-  public LocatedBlock createLocatedBlock(final Block b, final DatanodeInfo[] locations,
-      final long offset, final boolean corrupt) throws IOException {
-    return new LocatedBlock(getExtendedBlock(b), locations, offset, corrupt);
-  }
-  
-  public void concat(String target, String [] srcs) 
+  void concat(String target, String [] srcs) 
-  public void concatInternal(String target, String [] srcs) 
+  private void concatInternal(String target, String [] srcs) 
-  public void setTimes(String src, long mtime, long atime) 
+  void setTimes(String src, long mtime, long atime) 
-  public void createSymlink(String target, String link,
+  void createSymlink(String target, String link,
-  public boolean setReplication(String src, short replication) 
-    throws IOException, UnresolvedLinkException {
-    boolean status = false;
+  boolean setReplication(final String src, final short replication
+      ) throws IOException {
+    blockManager.verifyReplication(src, replication, null);
+
+    final boolean isFile;
-      status = setReplicationInternal(src, replication);
+      if (isPermissionEnabled) {
+        checkPathAccess(src, FsAction.WRITE);
+      }
+
+      final short[] oldReplication = new short[1];
+      final Block[] blocks = dir.setReplication(src, replication, oldReplication);
+      isFile = blocks != null;
+      if (isFile) {
+        blockManager.setReplication(oldReplication[0], replication, src, blocks);
+      }
+
-    if (status && auditLog.isInfoEnabled() && isExternalInvocation()) {
+    if (isFile && auditLog.isInfoEnabled() && isExternalInvocation()) {
-    return status;
-  }
-
-  private boolean setReplicationInternal(String src,
-      short replication) throws AccessControlException, QuotaExceededException,
-      SafeModeException, UnresolvedLinkException, IOException {
-    assert hasWriteLock();
-    blockManager.verifyReplication(src, replication, null);
-    if (isPermissionEnabled) {
-      checkPathAccess(src, FsAction.WRITE);
-    }
-
-    int[] oldReplication = new int[1];
-    Block[] fileBlocks;
-    fileBlocks = dir.setReplication(src, replication, oldReplication);
-    if (fileBlocks == null)  // file not found or is a directory
-      return false;
-    int oldRepl = oldReplication[0];
-    if (oldRepl == replication) // the same replication
-      return true;
-
-    // update needReplication priority queues
-    for(int idx = 0; idx < fileBlocks.length; idx++)
-      blockManager.updateNeededReplications(fileBlocks[idx], 0, replication-oldRepl);
-      
-    if (oldRepl > replication) {  
-      // old replication > the new one; need to remove copies
-      LOG.info("Reducing replication for file " + src 
-               + ". New replication is " + replication);
-      for(int idx = 0; idx < fileBlocks.length; idx++)
-        blockManager.processOverReplicatedBlock(fileBlocks[idx], replication, null, null);
-    } else { // replication factor is increased
-      LOG.info("Increasing replication for file " + src 
-          + ". New replication is " + replication);
-    }
-    return true;
+    return isFile;
-        if (lb != null && blockManager.isBlockTokenEnabled()) {
-          lb.setBlockToken(blockManager.getBlockTokenSecretManager().generateToken(lb.getBlock(), 
-              EnumSet.of(BlockTokenSecretManager.AccessMode.WRITE)));
+        if (lb != null) {
+          blockManager.setBlockToken(lb, AccessMode.WRITE);
-                        false, (short)blockManager.maxReplication, (long)0);
+                        false, blockManager.maxReplication, (long)0);
-  public LocatedBlock getAdditionalBlock(String src,
+  LocatedBlock getAdditionalBlock(String src,
-    if (blockManager.isBlockTokenEnabled()) {
-      b.setBlockToken(blockManager.getBlockTokenSecretManager().generateToken(b.getBlock(), 
-          EnumSet.of(BlockTokenSecretManager.AccessMode.WRITE)));
-    }
+    blockManager.setBlockToken(b, BlockTokenSecretManager.AccessMode.WRITE);
-    if (blockManager.isBlockTokenEnabled()) {
-      lb.setBlockToken(blockManager.getBlockTokenSecretManager().generateToken(lb.getBlock(), 
-          EnumSet.of(BlockTokenSecretManager.AccessMode.COPY)));
-    }
+    blockManager.setBlockToken(lb, AccessMode.COPY);
-  public boolean abandonBlock(ExtendedBlock b, String src, String holder)
+  boolean abandonBlock(ExtendedBlock b, String src, String holder)
-  public boolean completeFile(String src, String holder, ExtendedBlock last) 
+  boolean completeFile(String src, String holder, ExtendedBlock last) 
-
-  /**
-   * Mark the block belonging to datanode as corrupt
-   * @param blk Block to be marked as corrupt
-   * @param dn Datanode which holds the corrupt replica
-   */
-  public void markBlockAsCorrupt(ExtendedBlock blk, DatanodeInfo dn)
-    throws IOException {
-    writeLock();
-    try {
-      blockManager.findAndMarkBlockAsCorrupt(blk.getLocalBlock(), dn);
-    } finally {
-      writeUnlock();
-    }
-  }
-
-
-    public boolean delete(String src, boolean recursive)
+    boolean delete(String src, boolean recursive)
-  public boolean mkdirs(String src, PermissionStatus permissions,
+  boolean mkdirs(String src, PermissionStatus permissions,
-  Lease reassignLease(Lease lease, String src, String newHolder,
+  private Lease reassignLease(Lease lease, String src, String newHolder,
+  /** Update disk space consumed. */
+  public void updateDiskSpaceConsumed(final INodeFileUnderConstruction fileINode,
+      final Block commitBlock) throws IOException {
+    assert hasWriteLock();
+
+    // Adjust disk space consumption if required
+    final long diff = fileINode.getPreferredBlockSize() - commitBlock.getNumBytes();    
+    if (diff > 0) {
+      try {
+        String path = leaseManager.findPath(fileINode);
+        dir.updateSpaceConsumed(path, 0, -diff * fileINode.getReplication());
+      } catch (IOException e) {
+        LOG.warn("Unexpected exception while updating disk space.", e);
+      }
+    }
+  }
-  public DirectoryListing getListing(String src, byte[] startAfter,
+  DirectoryListing getListing(String src, byte[] startAfter,
-  public void registerDatanode(DatanodeRegistration nodeReg)
-      throws IOException {
+  void registerDatanode(DatanodeRegistration nodeReg) throws IOException {
-  public String getRegistrationID() {
+  String getRegistrationID() {
-  public DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
+  DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
-      final int maxTransfer = blockManager.maxReplicationStreams - xmitsInProgress;
+      final int maxTransfer = blockManager.getMaxReplicationStreams()
+          - xmitsInProgress;
-      DatanodeCommand cmd = getDistributedUpgradeCommand();
+      DatanodeCommand cmd = upgradeManager.getBroadcastCommand();
-  public void addKeyUpdateCommand(final List<DatanodeCommand> cmds,
-      final DatanodeDescriptor nodeinfo) {
-    // check access key update
-    if (blockManager.isBlockTokenEnabled() && nodeinfo.needKeyUpdate) {
-      cmds.add(new KeyUpdateCommand(blockManager.getBlockTokenSecretManager().exportKeys()));
-      nodeinfo.needKeyUpdate = false;
-    }
-  }
-
-  public void updateStats(DatanodeDescriptor node, boolean isAdded) {
-    //
-    // The statistics are protected by the heartbeat lock
-    // For decommissioning/decommissioned nodes, only used capacity
-    // is counted.
-    //
-    assert(Thread.holdsLock(heartbeats));
-    if (isAdded) {
-      capacityUsed += node.getDfsUsed();
-      blockPoolUsed += node.getBlockPoolUsed();
-      totalLoad += node.getXceiverCount();
-      if (!(node.isDecommissionInProgress() || node.isDecommissioned())) {
-        capacityTotal += node.getCapacity();
-        capacityRemaining += node.getRemaining();
-      } else {
-        capacityTotal += node.getDfsUsed();
-      }
-    } else {
-      capacityUsed -= node.getDfsUsed();
-      blockPoolUsed -= node.getBlockPoolUsed();
-      totalLoad -= node.getXceiverCount();
-      if (!(node.isDecommissionInProgress() || node.isDecommissioned())) {
-        capacityTotal -= node.getCapacity();
-        capacityRemaining -= node.getRemaining();
-      } else {
-        capacityTotal -= node.getDfsUsed();
-      }
-    }
-  }
-
-
-
-  /**
-   * Periodically calls heartbeatCheck() and updateBlockKey()
-   */
-  class HeartbeatMonitor implements Runnable {
-    private long lastHeartbeatCheck;
-    private long lastBlockKeyUpdate;
-    /**
-     */
-    public void run() {
-      while (fsRunning) {
-        try {
-          long now = now();
-          if (lastHeartbeatCheck + heartbeatRecheckInterval < now) {
-            heartbeatCheck();
-            lastHeartbeatCheck = now;
-          }
-          if (blockManager.isBlockTokenEnabled()
-              && (lastBlockKeyUpdate + blockManager.getBlockKeyUpdateInterval() < now)) {
-            blockManager.updateBlockKey();
-            lastBlockKeyUpdate = now;
-          }
-        } catch (Exception e) {
-          FSNamesystem.LOG.error("Exception while checking heartbeat", e);
-        }
-        try {
-          Thread.sleep(5000);  // 5 seconds
-        } catch (InterruptedException ie) {
-        }
-      }
-    }
-  }
-
- 
-  public void setNodeReplicationLimit(int limit) {
-    blockManager.maxReplicationStreams = limit;
-  }
-
-  /**
-   * Remove a datanode descriptor.
-   * @param nodeID datanode ID.
-   * @throws UnregisteredNodeException 
-   */
-  public void removeDatanode(final DatanodeID nodeID
-      ) throws UnregisteredNodeException {
-    writeLock();
-    try {
-      DatanodeDescriptor nodeInfo = getBlockManager().getDatanodeManager(
-          ).getDatanode(nodeID);
-      if (nodeInfo != null) {
-        removeDatanode(nodeInfo);
-      } else {
-        NameNode.stateChangeLog.warn("BLOCK* NameSystem.removeDatanode: "
-                                     + nodeID.getName() + " does not exist");
-      }
-    } finally {
-      writeUnlock();
-    }
-  }
-  /**
-   * Remove a datanode descriptor.
-   * @param nodeInfo datanode descriptor.
-   */
-  public void removeDatanode(DatanodeDescriptor nodeInfo) {
-    assert hasWriteLock();
-    synchronized (heartbeats) {
-      if (nodeInfo.isAlive) {
-        updateStats(nodeInfo, false);
-        heartbeats.remove(nodeInfo);
-        nodeInfo.isAlive = false;
-      }
-    }
-
-    blockManager.removeDatanode(nodeInfo);
-
-    checkSafeMode();
-  }
-
-  }
-
-  /**
-   * Check if there are any expired heartbeats, and if so,
-   * whether any blocks have to be re-replicated.
-   * While removing dead datanodes, make sure that only one datanode is marked
-   * dead at a time within the synchronized section. Otherwise, a cascading
-   * effect causes more datanodes to be declared dead.
-   */
-  void heartbeatCheck() {
-    final DatanodeManager datanodeManager = getBlockManager().getDatanodeManager();
-    // It's OK to check safe mode w/o taking the lock here, we re-check
-    // for safe mode after taking the lock before removing a datanode.
-    if (isInSafeMode()) {
-      return;
-    }
-    boolean allAlive = false;
-    while (!allAlive) {
-      boolean foundDead = false;
-      DatanodeID nodeID = null;
-
-      // locate the first dead node.
-      synchronized(heartbeats) {
-        for (Iterator<DatanodeDescriptor> it = heartbeats.iterator();
-             it.hasNext();) {
-          DatanodeDescriptor nodeInfo = it.next();
-          if (datanodeManager.isDatanodeDead(nodeInfo)) {
-            expiredHeartbeats.incr();
-            foundDead = true;
-            nodeID = nodeInfo;
-            break;
-          }
-        }
-      }
-
-      // acquire the fsnamesystem lock, and then remove the dead node.
-      if (foundDead) {
-        writeLock();
-        if (isInSafeMode()) {
-          return;
-        }
-        try {
-          datanodeManager.removeDeadDatanode(nodeID);
-        } finally {
-          writeUnlock();
-        }
-      }
-      allAlive = !foundDead;
-    }
-  }
-    
-  /**
-   * The given node is reporting all its blocks.  Use this info to 
-   * update the (machine-->blocklist) and (block-->machinelist) tables.
-   */
-  public void processReport(DatanodeID nodeID, String poolId,
-      BlockListAsLongs newReport) throws IOException {
-    long startTime, endTime;
-
-    writeLock();
-    startTime = now(); //after acquiring write lock
-    try {
-      final DatanodeDescriptor node = blockManager.getDatanodeManager(
-          ).getDatanode(nodeID);
-      if (node == null || !node.isAlive) {
-        throw new IOException("ProcessReport from dead or unregistered node: "
-                              + nodeID.getName());
-      }
-      // To minimize startup time, we discard any second (or later) block reports
-      // that we receive while still in startup phase.
-      if (isInStartupSafeMode() && node.numBlocks() > 0) {
-        NameNode.stateChangeLog.info("BLOCK* NameSystem.processReport: "
-            + "discarded non-initial block report from " + nodeID.getName()
-            + " because namenode still in startup phase");
-        return;
-      }
-  
-      blockManager.processReport(node, newReport);
-    } finally {
-      endTime = now();
-      writeUnlock();
-    }
-
-    // Log the block report processing stats from Namenode perspective
-    NameNode.getNameNodeMetrics().addBlockReport((int) (endTime - startTime));
-    NameNode.stateChangeLog.info("BLOCK* NameSystem.processReport: from "
-        + nodeID.getName() + ", blocks: " + newReport.getNumberOfBlocks()
-        + ", processing time: " + (endTime - startTime) + " msecs");
-  }
-
-  /**
-   * We want "replication" replicates for the block, but we now have too many.  
-   * In this method, copy enough nodes from 'srcNodes' into 'dstNodes' such that:
-   *
-   * srcNodes.size() - dstNodes.size() == replication
-   *
-   * We pick node that make sure that replicas are spread across racks and
-   * also try hard to pick one with least free space.
-   * The algorithm is first to pick a node with least free space from nodes
-   * that are on a rack holding more than one replicas of the block.
-   * So removing such a replica won't remove a rack. 
-   * If no such a node is available,
-   * then pick a node with least free space
-   */
-  public void chooseExcessReplicates(Collection<DatanodeDescriptor> nonExcess, 
-                              Block b, short replication,
-                              DatanodeDescriptor addedNode,
-                              DatanodeDescriptor delNodeHint,
-                              BlockPlacementPolicy replicator) {
-    assert hasWriteLock();
-    // first form a rack to datanodes map and
-    INodeFile inode = blockManager.getINode(b);
-    HashMap<String, ArrayList<DatanodeDescriptor>> rackMap =
-      new HashMap<String, ArrayList<DatanodeDescriptor>>();
-    for (Iterator<DatanodeDescriptor> iter = nonExcess.iterator();
-         iter.hasNext();) {
-      DatanodeDescriptor node = iter.next();
-      String rackName = node.getNetworkLocation();
-      ArrayList<DatanodeDescriptor> datanodeList = rackMap.get(rackName);
-      if(datanodeList==null) {
-        datanodeList = new ArrayList<DatanodeDescriptor>();
-      }
-      datanodeList.add(node);
-      rackMap.put(rackName, datanodeList);
-    }
-    
-    // split nodes into two sets
-    // priSet contains nodes on rack with more than one replica
-    // remains contains the remaining nodes
-    ArrayList<DatanodeDescriptor> priSet = new ArrayList<DatanodeDescriptor>();
-    ArrayList<DatanodeDescriptor> remains = new ArrayList<DatanodeDescriptor>();
-    for( Iterator<Entry<String, ArrayList<DatanodeDescriptor>>> iter = 
-      rackMap.entrySet().iterator(); iter.hasNext(); ) {
-      Entry<String, ArrayList<DatanodeDescriptor>> rackEntry = iter.next();
-      ArrayList<DatanodeDescriptor> datanodeList = rackEntry.getValue(); 
-      if( datanodeList.size() == 1 ) {
-        remains.add(datanodeList.get(0));
-      } else {
-        priSet.addAll(datanodeList);
-      }
-    }
-    
-    // pick one node to delete that favors the delete hint
-    // otherwise pick one with least space from priSet if it is not empty
-    // otherwise one node with least space from remains
-    boolean firstOne = true;
-    while (nonExcess.size() - replication > 0) {
-      DatanodeInfo cur = null;
-
-      // check if we can del delNodeHint
-      if (firstOne && delNodeHint !=null && nonExcess.contains(delNodeHint) &&
-            (priSet.contains(delNodeHint) || (addedNode != null && !priSet.contains(addedNode))) ) {
-          cur = delNodeHint;
-      } else { // regular excessive replica removal
-        cur = replicator.chooseReplicaToDelete(inode, b, replication, priSet, remains);
-      }
-
-      firstOne = false;
-      // adjust rackmap, priSet, and remains
-      String rack = cur.getNetworkLocation();
-      ArrayList<DatanodeDescriptor> datanodes = rackMap.get(rack);
-      datanodes.remove(cur);
-      if(datanodes.isEmpty()) {
-        rackMap.remove(rack);
-      }
-      if( priSet.remove(cur) ) {
-        if (datanodes.size() == 1) {
-          priSet.remove(datanodes.get(0));
-          remains.add(datanodes.get(0));
-        }
-      } else {
-        remains.remove(cur);
-      }
-
-      nonExcess.remove(cur);
-      blockManager.addToExcessReplicate(cur, b);
-
-      //
-      // The 'excessblocks' tracks blocks until we get confirmation
-      // that the datanode has deleted them; the only way we remove them
-      // is when we get a "removeBlock" message.  
-      //
-      // The 'invalidate' list is used to inform the datanode the block 
-      // should be deleted.  Items are removed from the invalidate list
-      // upon giving instructions to the namenode.
-      //
-      blockManager.addToInvalidates(b, cur);
-      NameNode.stateChangeLog.info("BLOCK* NameSystem.chooseExcessReplicates: "
-                +"("+cur.getName()+", "+b+") is added to recentInvalidateSets");
-    }
-  }
-
-
-  /**
-   * The given node is reporting that it received a certain block.
-   */
-  public void blockReceived(DatanodeID nodeID,  
-                                         String poolId,
-                                         Block block,
-                                         String delHint
-                                         ) throws IOException {
-    writeLock();
-    try {
-      final DatanodeDescriptor node = blockManager.getDatanodeManager(
-          ).getDatanode(nodeID);
-      if (node == null || !node.isAlive) {
-        NameNode.stateChangeLog.warn("BLOCK* NameSystem.blockReceived: " + block
-            + " is received from dead or unregistered node " + nodeID.getName());
-        throw new IOException(
-            "Got blockReceived message from unregistered or dead node " + block);
-      }
-          
-      if (NameNode.stateChangeLog.isDebugEnabled()) {
-        NameNode.stateChangeLog.debug("BLOCK* NameSystem.blockReceived: "
-                                      +block+" is received from " + nodeID.getName());
-      }
-  
-      blockManager.addBlock(node, block, delHint);
-    } finally {
-      writeUnlock();
-    }
-  }
+  }    
+  /** Increment expired heartbeat counter. */
+  public void incrExpiredHeartbeats() {
+    expiredHeartbeats.incr();
+  }
+
+  /** @see ClientProtocol#getStats() */
-    synchronized(heartbeats) {
-      return new long[] {this.capacityTotal, this.capacityUsed, 
-                         this.capacityRemaining,
-                         getUnderReplicatedBlocks(),
-                         getCorruptReplicaBlocks(),
-                         getMissingBlocksCount(),
-                         getBlockPoolUsedSpace()};
-    }
+    final long[] stats = datanodeStatistics.getStats();
+    stats[ClientProtocol.GET_STATS_UNDER_REPLICATED_IDX] = getUnderReplicatedBlocks();
+    stats[ClientProtocol.GET_STATS_CORRUPT_BLOCKS_IDX] = getCorruptReplicaBlocks();
+    stats[ClientProtocol.GET_STATS_MISSING_BLOCKS_IDX] = getMissingBlocksCount();
+    return stats;
-    synchronized(heartbeats) {
-      return capacityTotal;
-    }
+    return datanodeStatistics.getCapacityTotal();
-    synchronized(heartbeats) {
-      return capacityUsed;
-    }
+    return datanodeStatistics.getCapacityUsed();
-  /**
-   * Total used space by data nodes as percentage of total capacity
-   */
-  public float getCapacityUsedPercent() {
-    synchronized(heartbeats){
-      return DFSUtil.getPercentUsed(capacityUsed, capacityTotal);
-    }
-  }
-  /**
-   * Total used space by data nodes for non DFS purposes such
-   * as storing temporary files on the local file system
-   */
-  public long getCapacityUsedNonDFS() {
-    long nonDFSUsed = 0;
-    synchronized(heartbeats){
-      nonDFSUsed = capacityTotal - capacityRemaining - capacityUsed;
-    }
-    return nonDFSUsed < 0 ? 0 : nonDFSUsed;
-  }
-  /**
-   * Total non-used raw bytes.
-   */
+  @Override
-    synchronized(heartbeats) {
-      return capacityRemaining;
-    }
+    return datanodeStatistics.getCapacityRemaining();
-   * Total remaining space by data nodes as percentage of total capacity
-   */
-  public float getCapacityRemainingPercent() {
-    synchronized(heartbeats){
-      return DFSUtil.getPercentRemaining(capacityRemaining, capacityTotal);
-    }
-  }
-  /**
-    synchronized (heartbeats) {
-      return this.totalLoad;
-    }
+    return datanodeStatistics.getXceiverCount();
-  /**
-   */
-  public void DFSNodesStatus(ArrayList<DatanodeDescriptor> live, 
-                                          ArrayList<DatanodeDescriptor> dead) {
-    readLock();
-    try {
-      getBlockManager().getDatanodeManager().fetchDatanodess(live, dead);
-    } finally {
-      readUnlock();
-    }
-  }
-
-  public Date getStartTime() {
+  Date getStartTime() {
-  short getMaxReplication()     { return (short)blockManager.maxReplication; }
-  short getMinReplication()     { return (short)blockManager.minReplication; }
-  short getDefaultReplication() { return (short)blockManager.defaultReplication; }
-
-  /**
-   * Clamp the specified replication between the minimum and maximum
-   * replication levels for this namesystem.
-   */
-  short adjustReplication(short replication) {
-    short minReplication = getMinReplication();
-    if (replication < minReplication) {
-      replication = minReplication;
-    }
-    short maxReplication = getMaxReplication();
-    if (replication > maxReplication) {
-      replication = maxReplication;
-    }
-    return replication;
-  }
-    
-  
-  /**
-   * Rereads the config to get hosts and exclude list file names.
-   * Rereads the files to update the hosts and exclude lists.  It
-   * checks if any of the hosts have changed states:
-   * 1. Added to hosts  --> no further work needed here.
-   * 2. Removed from hosts --> mark AdminState as decommissioned. 
-   * 3. Added to exclude --> start decommission.
-   * 4. Removed from exclude --> stop decommission.
-   */
-  public void refreshNodes(Configuration conf) throws IOException {
-    checkSuperuserPrivilege();
-    getBlockManager().getDatanodeManager().refreshHostsReader(conf);
-    writeLock();
-    try {
-      getBlockManager().getDatanodeManager().refreshDatanodes();
-    } finally {
-      writeUnlock();
-    }
-  }
-    
-      this.threshold = conf.getFloat(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY, DFSConfigKeys.DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT);
+      this.threshold = conf.getFloat(DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY,
+          DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT);
-        DFSConfigKeys.DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY,
-        DFSConfigKeys.DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT);
-      this.extension = conf.getInt(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_EXTENSION_KEY, 0);
-      this.safeReplication = conf.getInt(DFSConfigKeys.DFS_NAMENODE_REPLICATION_MIN_KEY, 
-                                         DFSConfigKeys.DFS_NAMENODE_REPLICATION_MIN_DEFAULT);
+        DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY,
+        DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT);
+      this.extension = conf.getInt(DFS_NAMENODE_SAFEMODE_EXTENSION_KEY, 0);
+      this.safeReplication = conf.getInt(DFS_NAMENODE_REPLICATION_MIN_KEY, 
+                                         DFS_NAMENODE_REPLICATION_MIN_DEFAULT);
-        conf.getFloat(DFSConfigKeys.DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY,
+        conf.getFloat(DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY,
-          needUpgrade = startDistributedUpgradeIfNeeded();
+          needUpgrade = upgradeManager.startUpgrade();
-                                   +blockManager.neededReplications.size()+" blocks");
+          + blockManager.numOfUnderReplicatedBlocks() + " blocks");
-        if(getDistributedUpgradeState())
+        if(upgradeManager.getUpgradeState())
-            getDistributedUpgradeStatus() + "%";
+            upgradeManager.getUpgradeStatus() + "%";
-  
-  private void checkSafeMode() {
+
+  /** Check and trigger safe mode. */
+  public void checkSafeMode() {
-  void setBlockTotal() {
+  private void setBlockTotal() {
-  long getCompleteBlocksTotal() {
+  private long getCompleteBlocksTotal() {
-      if(getDistributedUpgradeState())
+      if(upgradeManager.getUpgradeState())
-  
-  public RemoteEditLogManifest getEditLogManifest(long sinceTxId) throws IOException {
-    return getEditLog().getEditLogManifest(sinceTxId);
-  }
-  int getDistributedUpgradeVersion() {
-    return upgradeManager.getUpgradeVersion();
-  }
-
-  UpgradeCommand getDistributedUpgradeCommand() throws IOException {
-    return upgradeManager.getBroadcastCommand();
-  }
-
-  boolean getDistributedUpgradeState() {
-    return upgradeManager.getUpgradeState();
-  }
-
-  short getDistributedUpgradeStatus() {
-    return upgradeManager.getUpgradeStatus();
-  }
-
-  boolean startDistributedUpgradeIfNeeded() throws IOException {
-    return upgradeManager.startUpgrade();
-  }
-
-  private void checkSuperuserPrivilege() throws AccessControlException {
+  /** Check if the user has superuser privilege. */
+  public void checkSuperuserPrivilege() throws AccessControlException {
-  /** Return number of under-replicated but not missing blocks */
-  public long getUnderReplicatedNotMissingBlocks() {
-    return blockManager.getUnderReplicatedNotMissingBlocks();
-  }
-
-  void registerMBean() {
+  private void registerMBean() {
-  public void shutdown() {
+  void shutdown() {
-  public void setGenerationStamp(long stamp) {
+  void setGenerationStamp(long stamp) {
-  public long getGenerationStamp() {
+  long getGenerationStamp() {
-      if (blockManager.isBlockTokenEnabled()) {
-        locatedBlock.setBlockToken(blockManager.getBlockTokenSecretManager().generateToken(
-          block, EnumSet.of(BlockTokenSecretManager.AccessMode.WRITE)));
-      }
+      blockManager.setBlockToken(locatedBlock, AccessMode.WRITE);
-  void updatePipelineInternal(String clientName, ExtendedBlock oldBlock, 
+  private void updatePipelineInternal(String clientName, ExtendedBlock oldBlock, 
-  /**
-   * Return a range of corrupt replica block ids. Up to numExpectedBlocks 
-   * blocks starting at the next block after startingBlockId are returned
-   * (fewer if numExpectedBlocks blocks are unavailable). If startingBlockId 
-   * is null, up to numExpectedBlocks blocks are returned from the beginning.
-   * If startingBlockId cannot be found, null is returned.
-   *
-   * @param numExpectedBlocks Number of block ids to return.
-   *  0 <= numExpectedBlocks <= 100
-   * @param startingBlockId Block id from which to start. If null, start at
-   *  beginning.
-   * @return Up to numExpectedBlocks blocks from startingBlockId if it exists
-   *
-   */
-  long[] getCorruptReplicaBlockIds(int numExpectedBlocks,
-                                   Long startingBlockId) {  
-    return blockManager.getCorruptReplicaBlockIds(numExpectedBlocks,
-                                                  startingBlockId);
-  }
-  
-      UnderReplicatedBlocks.BlockIterator blkIterator = blockManager.getCorruptReplicaBlockIterator();
+
+      final Iterator<Block> blkIterator = blockManager.getCorruptReplicaBlockIterator();
-   * @return list of datanodes where decommissioning is in progress
-   */
-  public ArrayList<DatanodeDescriptor> getDecommissioningNodes() {
-    readLock();
-    try {
-      ArrayList<DatanodeDescriptor> decommissioningNodes = 
-        new ArrayList<DatanodeDescriptor>();
-      final List<DatanodeDescriptor> results = getBlockManager(
-          ).getDatanodeManager().getDatanodeListForReport(DatanodeReportType.LIVE);
-      for (Iterator<DatanodeDescriptor> it = results.iterator(); it.hasNext();) {
-        DatanodeDescriptor node = it.next();
-        if (node.isDecommissionInProgress()) {
-          decommissioningNodes.add(node);
-        }
-      }
-      return decommissioningNodes;
-    } finally {
-      readUnlock();
-    }
-  }
-
-  /**
-        DFSConfigKeys.DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY,
-        DFSConfigKeys.DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT),
-        conf.getLong(
-            DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY,
-            DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT),
-        conf.getLong(
-            DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY,
-            DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT),
+        DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY,
+        DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT),
+        conf.getLong(DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY,
+            DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT),
+        conf.getLong(DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY,
+            DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT),
-  public DelegationTokenSecretManager getDelegationTokenSecretManager() {
+  DelegationTokenSecretManager getDelegationTokenSecretManager() {
-  public Token<DelegationTokenIdentifier> getDelegationToken(Text renewer)
+  Token<DelegationTokenIdentifier> getDelegationToken(Text renewer)
-  public long renewDelegationToken(Token<DelegationTokenIdentifier> token)
+  long renewDelegationToken(Token<DelegationTokenIdentifier> token)
-  public void cancelDelegationToken(Token<DelegationTokenIdentifier> token)
+  void cancelDelegationToken(Token<DelegationTokenIdentifier> token)
-    return getCapacityUsedNonDFS();
+    return datanodeStatistics.getCapacityUsedNonDFS();
-    return getCapacityUsedPercent();
+    return datanodeStatistics.getCapacityUsedPercent();
-    synchronized(heartbeats) {
-      return blockPoolUsed;
-    }
+    return datanodeStatistics.getBlockPoolUsed();
-    synchronized(heartbeats) {
-      return DFSUtil.getPercentUsed(blockPoolUsed, capacityTotal);
-    }
+    return datanodeStatistics.getPercentBlockPoolUsed();
-    return getCapacityRemainingPercent();
+    return datanodeStatistics.getCapacityRemainingPercent();
-    final ArrayList<DatanodeDescriptor> liveNodeList = 
-      new ArrayList<DatanodeDescriptor>();
-    final ArrayList<DatanodeDescriptor> deadNodeList =
-      new ArrayList<DatanodeDescriptor>();
-    DFSNodesStatus(liveNodeList, deadNodeList);
-    removeDecomNodeFromList(liveNodeList);
-    for (DatanodeDescriptor node : liveNodeList) {
+    final List<DatanodeDescriptor> live = new ArrayList<DatanodeDescriptor>();
+    blockManager.getDatanodeManager().fetchDatanodes(live, null, true);
+    for (DatanodeDescriptor node : live) {
-    final ArrayList<DatanodeDescriptor> liveNodeList =
-    new ArrayList<DatanodeDescriptor>();
-    final ArrayList<DatanodeDescriptor> deadNodeList =
-    new ArrayList<DatanodeDescriptor>();
-    // we need to call DFSNodeStatus to filter out the dead data nodes
-    DFSNodesStatus(liveNodeList, deadNodeList);
-    removeDecomNodeFromList(deadNodeList);
-    for (DatanodeDescriptor node : deadNodeList) {
+    final List<DatanodeDescriptor> dead = new ArrayList<DatanodeDescriptor>();
+    blockManager.getDatanodeManager().fetchDatanodes(null, dead, true);
+    for (DatanodeDescriptor node : dead) {
-    final ArrayList<DatanodeDescriptor> decomNodeList = 
-      this.getDecommissioningNodes();
+    final List<DatanodeDescriptor> decomNodeList = blockManager.getDatanodeManager(
+        ).getDecommissioningNodes();
-  
-  void removeDecomNodeFromList(List<DatanodeDescriptor> nodeList) {
-    getBlockManager().getDatanodeManager().removeDecomNodeFromList(nodeList);
-  }
-
-  /**
-   * Tell all datanodes to use a new, non-persistent bandwidth value for
-   * dfs.datanode.balance.bandwidthPerSec.
-   * @param bandwidth Blanacer bandwidth in bytes per second for all datanodes.
-   * @throws IOException
-   */
-  public void setBalancerBandwidth(long bandwidth) throws IOException {
-    getBlockManager().getDatanodeManager().setBalancerBandwidth(bandwidth);
-  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV43 MOV23 MOV31 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD43 INS31 INS31 INS31 INS31 INS31 UPD42 INS43 INS83 UPD83 INS78 INS78 INS78 INS78 INS78 INS78 INS83 INS78 INS83 UPD83 INS83 INS29 INS83 INS39 INS42 INS44 MOV44 MOV43 INS8 INS42 MOV8 MOV29 MOV5 INS42 INS8 MOV29 MOV78 MOV83 MOV39 MOV42 INS8 INS78 MOV83 MOV39 MOV42 INS8 MOV29 MOV78 MOV78 MOV83 MOV39 MOV42 MOV8 INS29 UPD83 INS83 INS83 INS29 UPD83 INS83 INS83 MOV78 MOV78 MOV78 INS8 MOV78 INS42 UPD42 INS21 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS83 INS83 MOV21 MOV21 MOV21 MOV65 INS83 INS43 INS42 UPD42 MOV6 INS60 INS25 UPD65 UPD65 MOV60 MOV21 MOV21 MOV21 MOV41 INS41 MOV41 INS42 MOV41 INS65 INS65 INS41 MOV41 INS7 MOV32 INS8 MOV8 MOV21 INS83 UPD42 INS32 INS32 UPD66 UPD42 MOV42 MOV83 MOV39 INS59 INS27 INS8 UPD66 INS68 UPD66 MOV5 INS42 INS32 INS66 INS66 INS32 UPD74 MOV32 UPD42 MOV74 MOV32 UPD42 MOV74 INS22 INS32 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS42 INS42 INS21 UPD42 MOV25 INS60 INS60 INS21 INS25 UPD42 MOV42 UPD42 MOV42 MOV42 MOV40 MOV42 UPD42 MOV42 MOV42 UPD40 MOV40 UPD42 MOV42 INS27 UPD42 MOV42 INS34 INS54 INS42 INS42 UPD42 INS2 MOV32 INS2 MOV32 INS2 MOV32 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV21 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 UPD43 UPD42 UPD42 UPD42 INS33 INS9 UPD42 UPD42 INS33 UPD42 INS9 INS42 INS42 INS52 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS83 UPD74 INS83 UPD74 INS32 INS83 INS5 INS59 INS83 MOV5 INS59 INS7 INS42 INS8 INS32 INS32 INS8 MOV12 UPD42 MOV42 UPD42 INS42 INS40 INS42 INS40 INS42 INS40 INS32 INS83 INS74 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 MOV32 UPD42 UPD42 MOV27 UPD43 UPD43 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 INS39 INS85 INS42 INS3 INS42 MOV32 INS42 INS27 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD40 MOV40 MOV43 MOV43 INS42 INS42 INS42 UPD42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS5 INS34 INS42 MOV42 INS42 INS33 INS32 MOV27 INS40 MOV43 INS32 MOV43 INS32 MOV42 UPD42 UPD42 INS42 INS42 UPD42 INS42 INS42 MOV32 MOV32 MOV32 INS39 INS85 INS42 INS42 MOV2 INS42 INS42 INS42 UPD42 INS32 MOV42 UPD42 MOV42 INS42 MOV34 INS27 INS42 INS42 MOV32 UPD42 MOV42 MOV42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS38 INS32 UPD42 INS42 UPD45 MOV32 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD40 MOV40 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL34 DEL42 DEL34 DEL59 DEL29 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL40 DEL40 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL14 DEL14 DEL7 DEL42 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL52 DEL42 DEL22 DEL42 DEL42 DEL40 DEL40 DEL32 DEL7 DEL21 DEL40 DEL40 DEL40 DEL40 DEL45 DEL40 DEL40 DEL40 DEL40 DEL40 DEL83 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL25 DEL52 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL32 DEL21 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL6 DEL83 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL40 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL40 DEL34 DEL27 DEL42 DEL43 DEL34 DEL42 DEL42 DEL43 DEL42 DEL32 DEL33 DEL9 DEL14 DEL41 DEL8 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL9 DEL42 DEL32 DEL7 DEL21 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL6 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL33 DEL27 DEL9 DEL41 DEL25 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL27 DEL9 DEL41 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL27 DEL32 DEL21 DEL24 DEL42 DEL42 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL33 DEL33 DEL32 DEL21 DEL24 DEL8 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL39 DEL40 DEL11 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL32 DEL8 DEL25 DEL83 DEL83 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL83 DEL66 DEL66 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL16 DEL42 DEL43 DEL40 DEL83 DEL83 DEL83 DEL83 DEL40 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL32 DEL21 DEL40 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL36 DEL6 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL38 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL38 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL29 DEL83 DEL39 DEL42 DEL42 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL27 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL27 DEL36 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL54 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL31 DEL55 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL40 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL40 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL38 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL25 DEL8 DEL24 DEL8 DEL51 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL61 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL59 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL38 DEL27 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL40 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL42 DEL32 DEL42 DEL39 DEL42 DEL42 DEL27 DEL36 DEL11 DEL32 DEL21 DEL40 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL27 DEL36 DEL45 DEL27 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL6 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL74 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL27 DEL34 DEL27 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL36 DEL27 DEL36 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL8 DEL25 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL61 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL38 DEL27 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL40 DEL42 DEL32 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL10 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL40 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL66 DEL65 DEL42 DEL42 DEL43 DEL32 DEL42 DEL42 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL4 DEL3 DEL39 DEL85 DEL5 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL41 DEL8 DEL51 DEL42 DEL42 DEL42 DEL42 DEL41 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL27 DEL7 DEL21 DEL8 DEL51 DEL42 DEL34 DEL27 DEL34 DEL42 DEL16 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL42 DEL41 DEL8 DEL51 DEL8 DEL31 DEL32 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL51 DEL8 DEL31 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL40 DEL11 DEL41 DEL8 DEL31 DEL39 DEL42 DEL39 DEL40 DEL11 DEL41 DEL8 DEL31 DEL39 DEL42 DEL39 DEL40 DEL11 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL31 DEL39 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL41 DEL8 DEL31 DEL39 DEL42 DEL41 DEL8 DEL31 DEL39 DEL42 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL32 DEL8 DEL25 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL40 DEL43 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL83 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL41 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL41 DEL8 DEL51 DEL42 DEL42 DEL42 DEL8 DEL51 DEL8 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL52 DEL39 DEL42 DEL42 DEL44 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31
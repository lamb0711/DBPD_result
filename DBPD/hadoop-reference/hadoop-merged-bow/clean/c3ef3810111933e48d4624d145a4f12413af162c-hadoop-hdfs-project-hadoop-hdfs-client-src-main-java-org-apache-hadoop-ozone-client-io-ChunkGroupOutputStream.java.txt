HDFS-12543. Ozone : allow create key without specifying size. Contributed by Chen Liang.

+import org.apache.hadoop.ozone.ksm.helpers.KsmKeyArgs;
+import org.apache.hadoop.ozone.ksm.helpers.OpenKeySession;
+import org.apache.hadoop.ozone.ksm.protocolPB.KeySpaceManagerProtocolClientSideTranslatorPB;
-  private long totalSize;
+  private final KeySpaceManagerProtocolClientSideTranslatorPB ksmClient;
+  private final
+      StorageContainerLocationProtocolClientSideTranslatorPB scmClient;
+  private final KsmKeyArgs keyArgs;
+  private final int openID;
+  private final XceiverClientManager xceiverClientManager;
+  private final int chunkSize;
+  private final String requestID;
+  /**
+   * A constructor for testing purpose only.
+   */
+  @VisibleForTesting
+    streamEntries = new ArrayList<>();
+    ksmClient = null;
+    scmClient = null;
+    keyArgs = null;
+    openID = -1;
+    xceiverClientManager = null;
+    chunkSize = 0;
+    requestID = null;
+  }
+
+  /**
+   * For testing purpose only. Not building output stream from blocks, but
+   * taking from externally.
+   *
+   * @param outputStream
+   * @param length
+   */
+  @VisibleForTesting
+  public synchronized void addStream(OutputStream outputStream, long length) {
+    streamEntries.add(new ChunkOutputStreamEntry(outputStream, length));
+  }
+
+  public ChunkGroupOutputStream(
+      OpenKeySession handler, XceiverClientManager xceiverClientManager,
+      StorageContainerLocationProtocolClientSideTranslatorPB scmClient,
+      KeySpaceManagerProtocolClientSideTranslatorPB ksmClient,
+      int chunkSize, String requestId) throws IOException {
-    this.totalSize = 0;
+    this.ksmClient = ksmClient;
+    this.scmClient = scmClient;
+    KsmKeyInfo info = handler.getKeyInfo();
+    this.keyArgs = new KsmKeyArgs.Builder()
+        .setVolumeName(info.getVolumeName())
+        .setBucketName(info.getBucketName())
+        .setKeyName(info.getKeyName())
+        .setDataSize(info.getDataSize()).build();
+    this.openID = handler.getId();
+    this.xceiverClientManager = xceiverClientManager;
+    this.chunkSize = chunkSize;
+    this.requestID = requestId;
+    LOG.debug("Expecting open key with one block, but got" +
+        info.getKeyLocationList().size());
+    // server may return any number of blocks, (0 to any)
+    int idx = 0;
+    for (KsmKeyLocationInfo subKeyInfo : info.getKeyLocationList()) {
+      subKeyInfo.setIndex(idx++);
+      checkKeyLocationInfo(subKeyInfo);
+    }
+  private void checkKeyLocationInfo(KsmKeyLocationInfo subKeyInfo)
+      throws IOException {
+    String containerKey = subKeyInfo.getBlockID();
+    String containerName = subKeyInfo.getContainerName();
+    Pipeline pipeline = scmClient.getContainer(containerName);
+    XceiverClientSpi xceiverClient =
+        xceiverClientManager.acquireClient(pipeline);
+    // create container if needed
+    if (subKeyInfo.getShouldCreateContainer()) {
+      try {
+        scmClient.notifyObjectCreationStage(
+            NotifyObjectCreationStageRequestProto.Type.container,
+            containerName,
+            NotifyObjectCreationStageRequestProto.Stage.begin);
+        ContainerProtocolCalls.createContainer(xceiverClient, requestID);
+        scmClient.notifyObjectCreationStage(
+            NotifyObjectCreationStageRequestProto.Type.container,
+            containerName,
+            NotifyObjectCreationStageRequestProto.Stage.complete);
+      } catch (StorageContainerException ex) {
+        if (ex.getResult().equals(Result.CONTAINER_EXISTS)) {
+          //container already exist, this should never happen
+          LOG.debug("Container {} already exists.", containerName);
+        } else {
+          LOG.error("Container creation failed for {}.", containerName, ex);
+          throw ex;
+        }
+      }
+    }
+    streamEntries.add(new ChunkOutputStreamEntry(containerKey,
+        keyArgs.getKeyName(), xceiverClientManager, xceiverClient, requestID,
+        chunkSize, subKeyInfo.getLength()));
+  }
+
+
-  /**
-   * Append another stream to the end of the list. Note that the streams are not
-   * actually created to this point, only enough meta data about the stream is
-   * stored. When something is to be actually written to the stream, the stream
-   * will be created (if not already).
-   *
-   * @param containerKey the key to store in the container
-   * @param key the ozone key
-   * @param xceiverClientManager xceiver manager instance
-   * @param xceiverClient xceiver manager instance
-   * @param requestID the request id
-   * @param chunkSize the chunk size for this key chunks
-   * @param length the total length of this key
-   */
-  public synchronized void addStream(String containerKey, String key,
-      XceiverClientManager xceiverClientManager, XceiverClientSpi xceiverClient,
-      String requestID, int chunkSize, long length) {
-    streamEntries.add(new ChunkOutputStreamEntry(containerKey, key,
-        xceiverClientManager, xceiverClient, requestID, chunkSize, length));
-    totalSize += length;
-  }
-
-  @VisibleForTesting
-  public synchronized void addStream(OutputStream outputStream, long length) {
-    streamEntries.add(new ChunkOutputStreamEntry(outputStream, length));
-    totalSize += length;
-  }
-      throw new IndexOutOfBoundsException();
+      Preconditions.checkNotNull(ksmClient);
+      // allocate a new block, if a exception happens, log an error and
+      // throw exception to the caller directly, and the write fails.
+      try {
+        allocateNewBlock(currentStreamIndex);
+      } catch (IOException ioe) {
+        LOG.error("Allocate block fail when writing.");
+        throw ioe;
+      }
-    if (streamEntries.size() <= currentStreamIndex) {
-      throw new IOException("Write out of stream range! stream index:" +
-          currentStreamIndex);
-    }
-    if (totalSize - byteOffset < len) {
-      throw new IOException("Can not write " + len + " bytes with only " +
-          (totalSize - byteOffset) + " byte space");
-    }
+    int succeededAllocates = 0;
+      if (streamEntries.size() <= currentStreamIndex) {
+        Preconditions.checkNotNull(ksmClient);
+        // allocate a new block, if a exception happens, log an error and
+        // throw exception to the caller directly, and the write fails.
+        try {
+          allocateNewBlock(currentStreamIndex);
+          succeededAllocates += 1;
+        } catch (IOException ioe) {
+          LOG.error("Try to allocate more blocks for write failed, already " +
+              "allocated " + succeededAllocates + " blocks for this write.");
+          throw ioe;
+        }
+      }
+  /**
+   * Contact KSM to get a new block. Set the new block with the index (e.g.
+   * first block has index = 0, second has index = 1 etc.)
+   *
+   * The returned block is made to new ChunkOutputStreamEntry to write.
+   *
+   * @param index the index of the block.
+   * @throws IOException
+   */
+  private void allocateNewBlock(int index) throws IOException {
+    KsmKeyLocationInfo subKeyInfo = ksmClient.allocateBlock(keyArgs, openID);
+    subKeyInfo.setIndex(index);
+    checkKeyLocationInfo(subKeyInfo);
+  }
+
+  /**
+   * Commit the key to KSM, this will add the blocks as the new key blocks.
+   *
+   * @throws IOException
+   */
-      entry.close();
+      if (entry != null) {
+        entry.close();
+      }
+    }
+    if (keyArgs != null) {
+      // in test, this could be null
+      keyArgs.setDataSize(byteOffset);
+      ksmClient.commitKey(keyArgs, openID);
+    } else {
+      LOG.warn("Closing ChunkGroupOutputStream, but key args is null");
+    }
+  }
+
+  /**
+   * Builder class of ChunkGroupOutputStream.
+   */
+  public static class Builder {
+    private OpenKeySession openHandler;
+    private XceiverClientManager xceiverManager;
+    private StorageContainerLocationProtocolClientSideTranslatorPB scmClient;
+    private KeySpaceManagerProtocolClientSideTranslatorPB ksmClient;
+    private int chunkSize;
+    private String requestID;
+
+    public Builder setHandler(OpenKeySession handler) {
+      this.openHandler = handler;
+      return this;
+    }
+
+    public Builder setXceiverClientManager(XceiverClientManager manager) {
+      this.xceiverManager = manager;
+      return this;
+    }
+
+    public Builder setScmClient(
+        StorageContainerLocationProtocolClientSideTranslatorPB client) {
+      this.scmClient = client;
+      return this;
+    }
+
+    public Builder setKsmClient(
+        KeySpaceManagerProtocolClientSideTranslatorPB client) {
+      this.ksmClient = client;
+      return this;
+    }
+
+    public Builder setChunkSize(int size) {
+      this.chunkSize = size;
+      return this;
+    }
+
+    public Builder setRequestID(String id) {
+      this.requestID = id;
+      return this;
+    }
+
+    public ChunkGroupOutputStream build() throws IOException {
+      return new ChunkGroupOutputStream(openHandler, xceiverManager, scmClient,
+          ksmClient, chunkSize, requestID);
-
-  public static ChunkGroupOutputStream getFromKsmKeyInfo(
-      KsmKeyInfo keyInfo, XceiverClientManager xceiverClientManager,
-      StorageContainerLocationProtocolClientSideTranslatorPB
-          storageContainerLocationClient,
-      int chunkSize, String requestId) throws IOException {
-    // TODO: the following createContainer and key writes may fail, in which
-    // case we should revert the above allocateKey to KSM.
-    // check index as sanity check
-    int index = 0;
-    String blockID;
-    ChunkGroupOutputStream groupOutputStream = new ChunkGroupOutputStream();
-    for (KsmKeyLocationInfo subKeyInfo : keyInfo.getKeyLocationList()) {
-      blockID = subKeyInfo.getBlockID();
-
-      Preconditions.checkArgument(index++ == subKeyInfo.getIndex());
-      String containerName = subKeyInfo.getContainerName();
-      Pipeline pipeline =
-          storageContainerLocationClient.getContainer(containerName);
-      XceiverClientSpi xceiverClient =
-          xceiverClientManager.acquireClient(pipeline);
-      // create container if needed
-      if (subKeyInfo.getShouldCreateContainer()) {
-        try {
-          storageContainerLocationClient.notifyObjectCreationStage(
-              NotifyObjectCreationStageRequestProto.Type.container,
-              containerName,
-              NotifyObjectCreationStageRequestProto.Stage.begin);
-
-          ContainerProtocolCalls.createContainer(xceiverClient, requestId);
-
-          storageContainerLocationClient.notifyObjectCreationStage(
-              NotifyObjectCreationStageRequestProto.Type.container,
-              containerName,
-              NotifyObjectCreationStageRequestProto.Stage.complete);
-        } catch (StorageContainerException ex) {
-          if (ex.getResult().equals(Result.CONTAINER_EXISTS)) {
-            //container already exist, this should never happen
-            LOG.debug("Container {} already exists.", containerName);
-          } else {
-            LOG.error("Container creation failed for {}.", containerName, ex);
-            throw ex;
-          }
-        }
-      }
-
-      groupOutputStream.addStream(blockID, keyInfo.getKeyName(),
-          xceiverClientManager, xceiverClient, requestId, chunkSize,
-          subKeyInfo.getLength());
-    }
-    return groupOutputStream;
-  }

INS26 INS26 INS26 MOV23 MOV31 MOV31 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS55 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS83 UPD39 INS83 INS83 MOV43 INS59 INS29 INS78 INS29 INS83 INS42 INS44 MOV44 INS44 INS44 MOV44 MOV44 INS43 INS8 UPD83 INS39 INS42 MOV44 MOV8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 MOV78 MOV83 MOV83 MOV39 UPD42 MOV42 MOV43 INS8 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 MOV31 INS31 INS31 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS65 INS42 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 MOV21 MOV21 MOV21 INS21 INS21 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS60 INS70 INS60 INS60 MOV65 MOV65 UPD65 MOV65 INS39 INS42 INS42 INS60 INS21 INS21 INS65 UPD65 MOV65 MOV70 INS25 INS65 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS83 MOV43 INS59 INS83 INS43 INS42 MOV44 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 MOV44 INS8 INS83 INS43 INS42 INS44 INS8 INS43 INS42 INS44 INS83 INS43 INS42 INS44 INS8 INS83 MOV43 INS42 INS43 INS8 INS66 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS7 INS7 MOV43 INS59 INS7 INS7 INS7 INS7 INS7 INS32 INS39 INS59 INS44 INS32 INS8 MOV43 INS59 MOV27 INS39 INS59 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 INS43 INS59 INS32 INS32 UPD66 MOV66 UPD42 INS8 INS27 INS8 INS8 INS66 INS42 INS42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS21 INS41 INS42 INS43 INS42 INS21 INS41 INS42 UPD42 INS21 INS41 INS42 INS43 INS42 MOV21 INS41 INS42 INS39 INS42 INS21 INS41 INS42 MOV43 INS42 INS21 INS41 INS42 INS41 INS42 INS14 INS42 INS33 INS42 INS33 INS42 INS33 INS42 INS38 INS42 INS33 INS42 INS42 INS33 INS22 INS42 INS22 INS42 INS42 INS32 INS22 INS32 INS22 INS32 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS27 INS42 INS34 INS43 INS42 INS42 INS42 INS21 INS21 INS42 MOV32 UPD42 UPD42 INS14 INS21 INS54 INS42 INS34 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS25 INS42 INS33 INS21 INS21 INS21 INS42 INS7 INS52 INS42 INS7 INS52 INS7 INS52 INS42 UPD7 INS52 INS7 INS52 INS7 INS52 INS14 INS74 INS34 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS45 INS32 INS42 INS32 INS32 UPD42 MOV43 INS42 INS32 INS42 INS42 INS42 INS42 MOV32 INS32 INS8 INS12 MOV27 INS8 INS42 INS42 INS42 INS42 INS27 MOV8 INS32 INS32 INS32 INS22 INS42 INS22 INS42 INS22 INS42 INS22 UPD42 INS22 INS42 INS22 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS37 INS42 INS42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS21 INS44 INS8 INS21 INS54 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 MOV43 INS42 INS21 INS53 INS32 INS8 INS12 INS32 INS42 INS32 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS21 INS44 INS8 INS14 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS32 INS7 MOV43 INS42 INS21 INS53 INS43 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS42 INS40 INS42 INS42 INS27 INS27 INS42 INS45 INS45 INS45 DEL52 DEL42 DEL22 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL44 DEL42 DEL44 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL7 DEL21 DEL83 DEL42 DEL42 DEL44 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL37 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL70 DEL42 DEL41 DEL8 DEL43 DEL14 DEL53 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL27 DEL45 DEL42 DEL45 DEL42 DEL42 DEL27 DEL36 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL66 DEL66 DEL66 DEL39 DEL42 DEL42 DEL83 DEL39 DEL42
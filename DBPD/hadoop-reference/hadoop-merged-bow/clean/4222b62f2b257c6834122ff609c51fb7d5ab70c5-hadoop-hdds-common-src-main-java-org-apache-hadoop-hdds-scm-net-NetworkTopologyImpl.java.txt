HDDS-1879.  Support multiple excluded scopes when choosing datanodes in NetworkTopology (#1194)


+import org.apache.commons.collections.CollectionUtils;
-      return chooseRandom(ROOT, scope.substring(1), null, null,
+      ArrayList<String> excludedScopes = new ArrayList();
+      excludedScopes.add(scope.substring(1));
+      return chooseRandom(ROOT, excludedScopes, null, null,
-   * @param excludedScope the chosen node cannot be in this range. cannot
+   * @param excludedScopes the chosen node cannot be in these ranges. cannot
-  public Node chooseRandom(String scope, String excludedScope) {
-    return chooseRandom(scope, excludedScope, null, null,
+  public Node chooseRandom(String scope, List<String> excludedScopes) {
+    return chooseRandom(scope, excludedScopes, null, null,
-      return chooseRandom(ROOT, scope.substring(1), excludedNodes, null,
+      ArrayList<String> excludedScopes = new ArrayList();
+      excludedScopes.add(scope.substring(1));
+      return chooseRandom(ROOT, excludedScopes, excludedNodes, null,
-      return chooseRandom(ROOT, scope.substring(1), excludedNodes, null,
+      ArrayList<String> excludedScopes = new ArrayList();
+      excludedScopes.add(scope.substring(1));
+      return chooseRandom(ROOT, excludedScopes, excludedNodes, null,
-   * Randomly choose a leaf node.
-   *
-   * @param scope range from which a node will be chosen, cannot start with ~
-   * @param excludedNodes nodes to be excluded
-   * @param excludedScope excluded node range. Cannot start with ~
-   * @param ancestorGen matters when excludeNodes is not null. It means the
-   * ancestor generation that's not allowed to share between chosen node and the
-   * excludedNodes. For example, if ancestorGen is 1, means chosen node
-   * cannot share the same parent with excludeNodes. If value is 2, cannot
-   * share the same grand parent, and so on. If ancestorGen is 0, then no
-   * effect.
-   *
-   * @return the chosen node
-   */
-  public Node chooseRandom(String scope, String excludedScope,
-      Collection<Node> excludedNodes, int ancestorGen) {
-    return chooseRandom(scope, excludedScope, excludedNodes, null, ancestorGen);
-  }
-
-  /**
-   * @param excludedScope range of nodes to be excluded, cannot start with ~
+   * @param excludedScopes ranges of nodes to be excluded, cannot start with ~
-  public Node chooseRandom(String scope, String excludedScope,
+  public Node chooseRandom(String scope, List<String> excludedScopes,
-    checkExcludedScope(excludedScope);
+    checkExcludedScopes(excludedScopes);
-      return chooseNodeInternal(scope, -1, excludedScope,
+      return chooseNodeInternal(scope, -1, excludedScopes,
-   * @param excludedScope range of nodes to be excluded, cannot start with ~
+   * @param excludedScopes ranges of nodes to be excluded, cannot start with ~
-  public Node getNode(int leafIndex, String scope, String excludedScope,
+  public Node getNode(int leafIndex, String scope, List<String> excludedScopes,
-    checkExcludedScope(excludedScope);
+    checkExcludedScopes(excludedScopes);
-      return chooseNodeInternal(scope, leafIndex, excludedScope,
+      return chooseNodeInternal(scope, leafIndex, excludedScopes,
-      String excludedScope, Collection<Node> excludedNodes, Node affinityNode,
-      int ancestorGen) {
+      List<String> excludedScopes, Collection<Node> excludedNodes,
+      Node affinityNode, int ancestorGen) {
-    // check overlap of excludedScope and finalScope
-    if (excludedScope != null) {
-      // excludeScope covers finalScope
-      if (finalScope.startsWith(excludedScope)) {
-        return null;
-      }
-      // excludeScope and finalScope share nothing
-      if (!excludedScope.startsWith(finalScope)) {
-        excludedScope = null;
+    // check overlap of excludedScopes and finalScope
+    List<String> mutableExcludedScopes = null;
+    if (excludedScopes != null && !excludedScopes.isEmpty()) {
+      mutableExcludedScopes = new ArrayList<>();
+      for (String s: excludedScopes) {
+        // excludeScope covers finalScope
+        if (finalScope.startsWith(s)) {
+          return null;
+        }
+        // excludeScope and finalScope share nothing case
+        if (s.startsWith(finalScope)) {
+          if (!mutableExcludedScopes.stream().anyMatch(
+              e -> s.startsWith(e))) {
+            mutableExcludedScopes.add(s);
+          }
+        }
+
+    // Remove duplicate in excludedNodes
-      // Remove duplicate in excludedNodes
-    // remove duplicate in mutableExNodes and excludedScope, given ancestorGen
-    excludedScope = NetUtils.removeDuplicate(this, mutableExNodes,
-        excludedScope, ancestorGen);
+    // remove duplicate in mutableExNodes and mutableExcludedScopes
+    NetUtils.removeDuplicate(this, mutableExNodes, mutableExcludedScopes,
+        ancestorGen);
-        scopeNode.getNetworkFullPath(), excludedScope, mutableExNodes,
+        scopeNode.getNetworkFullPath(), mutableExcludedScopes, mutableExNodes,
-          scopeNode.getNetworkFullPath(), excludedScope, excludedNodes,
+          scopeNode.getNetworkFullPath(), excludedScopes, excludedNodes,
-      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, excludedScope,
+      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, mutableExcludedScopes,
-      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, excludedScope,
+      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, mutableExcludedScopes,
-        scopeNode.getNetworkFullPath(), excludedScope, excludedNodes);
+        scopeNode.getNetworkFullPath(), excludedScopes, excludedNodes);
-   * @param excludedScope excluded scope
+   * @param excludedScopes excluded scopes
-  private int getAvailableNodesCount(String scope, String excludedScope,
+  private int getAvailableNodesCount(String scope, List<String> excludedScopes,
-    if (excludedScope != null) {
-      Node excludedScopeNode = getNode(excludedScope);
-      if (excludedScopeNode != null) {
-        if (excludedScope.startsWith(scope)) {
-          excludedCount += excludedScopeNode.getNumOfLeaves();
-        } else if (scope.startsWith(excludedScope)) {
-          return 0;
+    if (excludedScopes != null) {
+      for (String excludedScope: excludedScopes) {
+        Node excludedScopeNode = getNode(excludedScope);
+        if (excludedScopeNode != null) {
+          if (excludedScope.startsWith(scope)) {
+            excludedCount += excludedScopeNode.getNumOfLeaves();
+          } else if (scope.startsWith(excludedScope)) {
+            return 0;
+          }
-  private void checkExcludedScope(String excludedScope) {
-    if (excludedScope != null &&
-        (excludedScope.startsWith(SCOPE_REVERSE_STR))) {
-      throw new IllegalArgumentException("excludedScope " + excludedScope +
-          " cannot start with " + SCOPE_REVERSE_STR);
+  private void checkExcludedScopes(List<String> excludedScopes) {
+    if (!CollectionUtils.isEmpty(excludedScopes)) {
+      excludedScopes.stream().forEach(scope -> {
+        if (scope.startsWith(SCOPE_REVERSE_STR)) {
+          throw new IllegalArgumentException("excludedScope " + scope +
+              " cannot start with " + SCOPE_REVERSE_STR);
+        }
+      });

INS26 INS40 INS31 INS44 UPD83 MOV83 INS39 UPD42 MOV42 INS44 INS8 INS74 UPD42 INS74 UPD42 INS74 UPD42 INS74 UPD42 INS60 MOV8 INS74 INS42 INS74 UPD42 MOV42 INS25 UPD42 UPD66 INS43 INS43 UPD42 UPD66 INS43 INS43 UPD42 UPD66 INS43 INS43 INS43 INS43 INS74 INS59 INS27 INS8 INS32 UPD42 UPD66 INS43 INS43 INS8 INS43 INS43 INS38 INS8 INS60 INS21 INS42 MOV42 UPD42 INS60 INS21 INS60 INS21 INS42 MOV42 UPD42 UPD42 INS42 MOV42 UPD42 UPD42 INS42 MOV42 INS43 INS43 INS42 INS33 INS27 INS38 INS21 INS70 MOV42 MOV42 MOV52 MOV42 UPD42 MOV42 MOV42 MOV21 MOV21 UPD42 INS42 INS42 UPD42 INS70 UPD42 MOV42 MOV42 INS32 INS21 INS74 INS59 MOV32 INS32 INS74 INS59 MOV32 MOV32 INS32 INS74 INS59 MOV32 MOV32 INS32 INS42 INS42 UPD42 MOV42 MOV33 INS32 INS7 INS44 INS42 INS8 UPD42 MOV44 INS42 MOV8 INS42 INS42 INS42 INS32 INS43 INS43 INS42 INS14 UPD42 UPD42 INS42 INS42 INS42 INS33 INS33 INS42 INS43 INS43 INS42 INS14 UPD42 UPD42 INS42 INS42 INS42 INS42 INS33 INS42 INS43 INS43 INS42 INS14 UPD42 UPD42 INS42 INS42 INS42 INS42 INS33 INS42 UPD42 UPD42 INS42 INS42 INS42 INS14 INS43 INS42 MOV25 INS25 UPD42 INS32 INS42 INS86 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS74 INS42 INS32 INS8 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS59 INS8 INS42 INS42 INS42 INS43 UPD42 INS42 INS42 INS42 MOV25 INS42 MOV25 INS42 INS32 UPD42 MOV42 MOV42 MOV42 INS32 INS42 INS86 INS32 UPD42 MOV42 INS42 INS59 INS32 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 DEL33 DEL33 DEL42 DEL43 DEL42 DEL42 DEL33 DEL42 DEL42 DEL33 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL43 DEL42 DEL44 DEL43 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL33 DEL42 DEL32 DEL41 DEL8 DEL31 DEL43 DEL43 DEL43 DEL42 DEL33 DEL7 DEL27 DEL8 DEL42 DEL32 DEL7 DEL42 DEL33 DEL27 DEL32 DEL36 DEL27 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31
YARN-6363. Extending SLS: Synthetic Load Generator. (Carlo Curino via wangda)

+import org.apache.commons.cli.ParseException;
+import org.apache.hadoop.conf.Configured;
+import org.apache.hadoop.mapreduce.TaskType;
+import org.apache.hadoop.tools.rumen.TaskAttemptInfo;
+import org.apache.hadoop.util.Tool;
+import org.apache.hadoop.util.ToolRunner;
+import org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionRequest;
+import org.apache.hadoop.yarn.api.records.ReservationId;
+import org.apache.hadoop.yarn.sls.synthetic.SynthJob;
+import org.apache.hadoop.yarn.sls.synthetic.SynthTraceJobProducer;
+import org.apache.hadoop.yarn.util.UTCClock;
-public class SLSRunner {
+public class SLSRunner extends Configured implements Tool {
-  private Configuration conf;
-  
+
-  
+
-  // input traces, input-rumen or input-sls
-  private boolean isSLS;
-  
-  public SLSRunner(boolean isSLS, String inputTraces[], String nodeFile,
-                   String outputDir, Set<String> trackedApps,
-                   boolean printsimulation)
-          throws IOException, ClassNotFoundException {
-    this.isSLS = isSLS;
-    this.inputTraces = inputTraces.clone();
-    this.nodeFile = nodeFile;
-    this.trackedApps = trackedApps;
-    this.printSimulation = printsimulation;
-    metricsOutputDir = outputDir;
-    
+  /**
+   * The type of trace in input.
+   */
+  public enum TraceType {
+    SLS, RUMEN, SYNTH
+  }
+
+  private TraceType inputType;
+  private SynthTraceJobProducer stjp;
+
+  public SLSRunner() throws ClassNotFoundException {
+    Configuration tempConf = new Configuration(false);
+    init(tempConf);
+  }
+
+  public SLSRunner(Configuration tempConf) throws ClassNotFoundException {
+    init(tempConf);
+  }
+
+  private void init(Configuration tempConf) throws ClassNotFoundException {
-    
+
-    conf = new Configuration(false);
-    conf.addResource("sls-runner.xml");
+    tempConf.addResource("sls-runner.xml");
+    super.setConf(tempConf);
+
-    int poolSize = conf.getInt(SLSConfiguration.RUNNER_POOL_SIZE, 
-                                SLSConfiguration.RUNNER_POOL_SIZE_DEFAULT); 
+    int poolSize = tempConf.getInt(SLSConfiguration.RUNNER_POOL_SIZE,
+        SLSConfiguration.RUNNER_POOL_SIZE_DEFAULT);
-    for (Map.Entry e : conf) {
+    for (Map.Entry e : tempConf) {
-        amClassMap.put(amType, Class.forName(conf.get(key)));
+        amClassMap.put(amType, Class.forName(tempConf.get(key)));
-  
-  public void start() throws Exception {
+
+  public void setSimulationParams(TraceType inType, String[] inTraces,
+      String nodes, String outDir, Set<String> trackApps,
+      boolean printsimulation) throws IOException, ClassNotFoundException {
+
+    this.inputType = inType;
+    this.inputTraces = inTraces.clone();
+    this.nodeFile = nodes;
+    this.trackedApps = trackApps;
+    this.printSimulation = printsimulation;
+    metricsOutputDir = outDir;
+
+  }
+
+  public void start() throws IOException, ClassNotFoundException, YarnException,
+      InterruptedException {
-                            .setQueueSet(this.queueAppNumMap.keySet());
+        .setQueueSet(this.queueAppNumMap.keySet());
-                            .setTrackedAppSet(this.trackedApps);
+        .setTrackedAppSet(this.trackedApps);
-  private void startRM() throws Exception {
-    Configuration rmConf = new YarnConfiguration();
+  private void startRM() throws ClassNotFoundException, YarnException {
+    Configuration rmConf = new YarnConfiguration(getConf());
-    if(Class.forName(schedulerClass) == CapacityScheduler.class) {
+    if (Class.forName(schedulerClass) == CapacityScheduler.class) {
-    } else if (Class.forName(schedulerClass) == FifoScheduler.class){
+    } else if (Class.forName(schedulerClass) == FifoScheduler.class) {
-      throw new Exception("Fifo Scheduler is not supported yet.");
+      throw new YarnException("Fifo Scheduler is not supported yet.");
-    nmMemoryMB = conf.getInt(SLSConfiguration.NM_MEMORY_MB,
-            SLSConfiguration.NM_MEMORY_MB_DEFAULT);
-    nmVCores = conf.getInt(SLSConfiguration.NM_VCORES,
-            SLSConfiguration.NM_VCORES_DEFAULT);
-    int heartbeatInterval = conf.getInt(
-            SLSConfiguration.NM_HEARTBEAT_INTERVAL_MS,
+    nmMemoryMB = getConf().getInt(SLSConfiguration.NM_MEMORY_MB,
+        SLSConfiguration.NM_MEMORY_MB_DEFAULT);
+    nmVCores = getConf().getInt(SLSConfiguration.NM_VCORES,
+        SLSConfiguration.NM_VCORES_DEFAULT);
+    int heartbeatInterval =
+        getConf().getInt(SLSConfiguration.NM_HEARTBEAT_INTERVAL_MS,
-      if (isSLS) {
-        for (String inputTrace : inputTraces) {
+      for (String inputTrace : inputTraces) {
+
+        switch (inputType) {
+        case SLS:
-        }
-      } else {
-        for (String inputTrace : inputTraces) {
+          break;
+        case RUMEN:
+          break;
+        case SYNTH:
+          stjp = new SynthTraceJobProducer(getConf(), new Path(inputTraces[0]));
+          nodeSet.addAll(SLSUtils.generateNodesFromSynth(stjp.getNumNodes(),
+              stjp.getNodesPerRack()));
+          break;
+        default:
+          throw new YarnException("Input configuration not recognized, "
+              + "trace type should be SLS, RUMEN, or SYNTH");
-
+
-      nm.init(hostName, nmMemoryMB, nmVCores, 
-          random.nextInt(heartbeatInterval), heartbeatInterval, rm);
+      nm.init(hostName, nmMemoryMB, nmVCores, random.nextInt(heartbeatInterval),
+          heartbeatInterval, rm);
-          numRunningNodes ++;
+          numRunningNodes++;
-      LOG.info(MessageFormat.format("SLSRunner is waiting for all " +
-              "nodes RUNNING. {0} of {1} NMs initialized.",
-              numRunningNodes, numNMs));
+      LOG.info(MessageFormat.format(
+          "SLSRunner is waiting for all "
+              + "nodes RUNNING. {0} of {1} NMs initialized.",
+          numRunningNodes, numNMs));
-            (System.currentTimeMillis() - startTimeMS)));
+        (System.currentTimeMillis() - startTimeMS)));
-    int heartbeatInterval = conf.getInt(
-            SLSConfiguration.AM_HEARTBEAT_INTERVAL_MS,
+    int heartbeatInterval =
+        getConf().getInt(SLSConfiguration.AM_HEARTBEAT_INTERVAL_MS,
-    int containerMemoryMB = conf.getInt(SLSConfiguration.CONTAINER_MEMORY_MB,
+    int containerMemoryMB =
+        getConf().getInt(SLSConfiguration.CONTAINER_MEMORY_MB,
-    int containerVCores = conf.getInt(SLSConfiguration.CONTAINER_VCORES,
-            SLSConfiguration.CONTAINER_VCORES_DEFAULT);
+    int containerVCores = getConf().getInt(SLSConfiguration.CONTAINER_VCORES,
+        SLSConfiguration.CONTAINER_VCORES_DEFAULT);
-            BuilderUtils.newResource(containerMemoryMB, containerVCores);
+        BuilderUtils.newResource(containerMemoryMB, containerVCores);
-    if (isSLS) {
+    switch (inputType) {
+    case SLS:
-    } else {
+      break;
+    case RUMEN:
+      break;
+    case SYNTH:
+      startAMFromSynthGenerator(heartbeatInterval);
+      break;
+    default:
+      throw new YarnException("Input configuration not recognized, "
+          + "trace type should be SLS, RUMEN, or SYNTH");
-                                    int heartbeatInterval) throws IOException {
+      int heartbeatInterval) throws IOException {
-        Iterator<Map> i = mapper.readValues(jsonF.createParser(input),
-                Map.class);
+        Iterator<Map> i =
+            mapper.readValues(jsonF.createParser(input), Map.class);
-          long jobStartTime = Long.parseLong(
-                  jsonJob.get("job.start.ms").toString());
-          long jobFinishTime = Long.parseLong(
-                  jsonJob.get("job.end.ms").toString());
+          long jobStartTime =
+              Long.parseLong(jsonJob.get("job.start.ms").toString());
+          long jobFinishTime =
+              Long.parseLong(jsonJob.get("job.end.ms").toString());
-          if (user == null)  user = "default";
+          if (user == null) {
+            user = "default";
+          }
-          int queueSize = queueAppNumMap.containsKey(queue) ?
-                  queueAppNumMap.get(queue) : 0;
-          queueSize ++;
+          int queueSize =
+              queueAppNumMap.containsKey(queue) ? queueAppNumMap.get(queue) : 0;
+          queueSize++;
-                  new ArrayList<ContainerSimulator>();
+              new ArrayList<ContainerSimulator>();
-            long taskStart = Long.parseLong(
-                    jsonTask.get("container.start.ms").toString());
-            long taskFinish = Long.parseLong(
-                    jsonTask.get("container.end.ms").toString());
+            long taskStart =
+                Long.parseLong(jsonTask.get("container.start.ms").toString());
+            long taskFinish =
+                Long.parseLong(jsonTask.get("container.end.ms").toString());
-              int containerMemory = Integer.parseInt(
-                  jsonTask.get("container.memory").toString());
+              int containerMemory =
+                  Integer.parseInt(jsonTask.get("container.memory").toString());
-              int containerVCores = Integer.parseInt(
-                  jsonTask.get("container.vcores").toString());
+              int containerVCores =
+                  Integer.parseInt(jsonTask.get("container.vcores").toString());
-            int priority = Integer.parseInt(
-                    jsonTask.get("container.priority").toString());
+            int priority =
+                Integer.parseInt(jsonTask.get("container.priority").toString());
-            containerList.add(new ContainerSimulator(res,
-                    lifeTime, hostname, priority, type));
+            containerList.add(new ContainerSimulator(res, lifeTime, hostname,
+                priority, type));
-          AMSimulator amSim = (AMSimulator) ReflectionUtils.newInstance(
-                  amClassMap.get(amType), new Configuration());
+          AMSimulator amSim = (AMSimulator) ReflectionUtils
+              .newInstance(amClassMap.get(amType), new Configuration());
-            amSim.init(AM_ID++, heartbeatInterval, containerList, rm,
-                    this, jobStartTime, jobFinishTime, user, queue,
-                    isTracked, oldAppId);
+            amSim.init(AM_ID++, heartbeatInterval, containerList, rm, this,
+                jobStartTime, jobFinishTime, user, queue, isTracked, oldAppId,
+                null, runner.getStartTimeMS());
-                                      int heartbeatInterval)
-          throws IOException {
+      int heartbeatInterval) throws IOException {
-      JobTraceReader reader = new JobTraceReader(
-              new Path(fin.getAbsolutePath()), conf);
+      JobTraceReader reader =
+          new JobTraceReader(new Path(fin.getAbsolutePath()), conf);
-          String user = job.getUser() == null ?
-                  "default" : job.getUser().getValue();
+          String user =
+              job.getUser() == null ? "default" : job.getUser().getValue();
-          int queueSize = queueAppNumMap.containsKey(jobQueue) ?
-                  queueAppNumMap.get(jobQueue) : 0;
-          queueSize ++;
+          int queueSize = queueAppNumMap.containsKey(jobQueue)
+              ? queueAppNumMap.get(jobQueue) : 0;
+          queueSize++;
-                  new ArrayList<ContainerSimulator>();
+              new ArrayList<ContainerSimulator>();
-          for(LoggedTask mapTask : job.getMapTasks()) {
+          for (LoggedTask mapTask : job.getMapTasks()) {
-            LoggedTaskAttempt taskAttempt = mapTask.getAttempts()
-                    .get(mapTask.getAttempts().size() - 1);
+            LoggedTaskAttempt taskAttempt =
+                mapTask.getAttempts().get(mapTask.getAttempts().size() - 1);
-            long containerLifeTime = taskAttempt.getFinishTime()
-                    - taskAttempt.getStartTime();
+            long containerLifeTime =
+                taskAttempt.getFinishTime() - taskAttempt.getStartTime();
-                    containerLifeTime, hostname, 10, "map"));
+                containerLifeTime, hostname, 10, "map"));
-          for(LoggedTask reduceTask : job.getReduceTasks()) {
+          for (LoggedTask reduceTask : job.getReduceTasks()) {
-                    .get(reduceTask.getAttempts().size() - 1);
+                .get(reduceTask.getAttempts().size() - 1);
-            long containerLifeTime = taskAttempt.getFinishTime()
-                    - taskAttempt.getStartTime();
+            long containerLifeTime =
+                taskAttempt.getFinishTime() - taskAttempt.getStartTime();
-                    containerLifeTime, hostname, 20, "reduce"));
+                containerLifeTime, hostname, 20, "reduce"));
-          AMSimulator amSim = (AMSimulator) ReflectionUtils.newInstance(
-                  amClassMap.get(jobType), conf);
+          AMSimulator amSim = (AMSimulator) ReflectionUtils
+              .newInstance(amClassMap.get(jobType), conf);
-            amSim.init(AM_ID ++, heartbeatInterval, containerList,
-                    rm, this, jobStartTimeMS, jobFinishTimeMS, user, jobQueue,
-                    isTracked, oldJobId);
+            amSim.init(AM_ID++, heartbeatInterval, containerList, rm, this,
+                jobStartTimeMS, jobFinishTimeMS, user, jobQueue, isTracked,
+                oldJobId, null, runner.getStartTimeMS());
-  
+
+  /**
+   * parse workload information from synth-generator trace files.
+   */
+  @SuppressWarnings("unchecked")
+  private void startAMFromSynthGenerator(int heartbeatInterval)
+      throws IOException {
+    Configuration localConf = new Configuration();
+    localConf.set("fs.defaultFS", "file:///");
+    long baselineTimeMS = 0;
+
+    // reservations use wall clock time, so need to have a reference for that
+    UTCClock clock = new UTCClock();
+    long now = clock.getTime();
+
+    try {
+
+      // if we use the nodeFile this could have been not initialized yet.
+      if (stjp == null) {
+        stjp = new SynthTraceJobProducer(getConf(), new Path(inputTraces[0]));
+      }
+
+      SynthJob job = null;
+      // we use stjp, a reference to the job producer instantiated during node
+      // creation
+      while ((job = (SynthJob) stjp.getNextJob()) != null) {
+        // only support MapReduce currently
+        String jobType = "mapreduce";
+        String user = job.getUser();
+        String jobQueue = job.getQueueName();
+        String oldJobId = job.getJobID().toString();
+        long jobStartTimeMS = job.getSubmissionTime();
+
+        // CARLO: Finish time is only used for logging, omit for now
+        long jobFinishTimeMS = -1L;
+
+        if (baselineTimeMS == 0) {
+          baselineTimeMS = jobStartTimeMS;
+        }
+        jobStartTimeMS -= baselineTimeMS;
+        jobFinishTimeMS -= baselineTimeMS;
+        if (jobStartTimeMS < 0) {
+          LOG.warn("Warning: reset job " + oldJobId + " start time to 0.");
+          jobFinishTimeMS = jobFinishTimeMS - jobStartTimeMS;
+          jobStartTimeMS = 0;
+        }
+
+        boolean isTracked = trackedApps.contains(oldJobId);
+        int queueSize = queueAppNumMap.containsKey(jobQueue)
+            ? queueAppNumMap.get(jobQueue) : 0;
+        queueSize++;
+        queueAppNumMap.put(jobQueue, queueSize);
+
+        List<ContainerSimulator> containerList =
+            new ArrayList<ContainerSimulator>();
+        ArrayList<NodeId> keyAsArray = new ArrayList<NodeId>(nmMap.keySet());
+        Random rand = new Random(stjp.getSeed());
+
+        Resource maxMapRes = Resource.newInstance(0, 0);
+        long maxMapDur = 0;
+        // map tasks
+        for (int i = 0; i < job.getNumberMaps(); i++) {
+          TaskAttemptInfo tai = job.getTaskAttemptInfo(TaskType.MAP, i, 0);
+          RMNode node = nmMap
+              .get(keyAsArray.get(rand.nextInt(keyAsArray.size()))).getNode();
+          String hostname = "/" + node.getRackName() + "/" + node.getHostName();
+          long containerLifeTime = tai.getRuntime();
+          Resource containerResource =
+              Resource.newInstance((int) tai.getTaskInfo().getTaskMemory(),
+                  (int) tai.getTaskInfo().getTaskVCores());
+          containerList.add(new ContainerSimulator(containerResource,
+              containerLifeTime, hostname, 10, "map"));
+          maxMapRes = Resources.componentwiseMax(maxMapRes, containerResource);
+          maxMapDur =
+              containerLifeTime > maxMapDur ? containerLifeTime : maxMapDur;
+
+        }
+
+        Resource maxRedRes = Resource.newInstance(0, 0);
+        long maxRedDur = 0;
+        // reduce tasks
+        for (int i = 0; i < job.getNumberReduces(); i++) {
+          TaskAttemptInfo tai = job.getTaskAttemptInfo(TaskType.REDUCE, i, 0);
+          RMNode node = nmMap
+              .get(keyAsArray.get(rand.nextInt(keyAsArray.size()))).getNode();
+          String hostname = "/" + node.getRackName() + "/" + node.getHostName();
+          long containerLifeTime = tai.getRuntime();
+          Resource containerResource =
+              Resource.newInstance((int) tai.getTaskInfo().getTaskMemory(),
+                  (int) tai.getTaskInfo().getTaskVCores());
+          containerList.add(new ContainerSimulator(containerResource,
+              containerLifeTime, hostname, 20, "reduce"));
+          maxRedRes = Resources.componentwiseMax(maxRedRes, containerResource);
+          maxRedDur =
+              containerLifeTime > maxRedDur ? containerLifeTime : maxRedDur;
+
+        }
+
+        // generating reservations for the jobs that require them
+
+        ReservationSubmissionRequest rr = null;
+        if (job.hasDeadline()) {
+          ReservationId reservationId =
+              ReservationId.newInstance(this.rm.getStartTime(), AM_ID);
+
+          rr = ReservationClientUtil.createMRReservation(reservationId,
+              "reservation_" + AM_ID, maxMapRes, job.getNumberMaps(), maxMapDur,
+              maxRedRes, job.getNumberReduces(), maxRedDur,
+              now + jobStartTimeMS, now + job.getDeadline(),
+              job.getQueueName());
+
+        }
+        // create a new AM
+        AMSimulator amSim = (AMSimulator) ReflectionUtils
+            .newInstance(amClassMap.get(jobType), localConf);
+        if (amSim != null) {
+          amSim.init(AM_ID++, heartbeatInterval, containerList, rm, this,
+              jobStartTimeMS, jobFinishTimeMS, user, jobQueue, isTracked,
+              oldJobId, rr, runner.getStartTimeMS());
+          runner.schedule(amSim);
+          maxRuntime = Math.max(maxRuntime, jobFinishTimeMS);
+          numTasks += containerList.size();
+          amMap.put(oldJobId, amSim);
+        }
+      }
+    } finally {
+      stjp.close();
+    }
+
+  }
+
-      LOG.info(MessageFormat.format("# nodes = {0}, # racks = {1}, capacity " +
-              "of each node {2} MB memory and {3} vcores.",
-              numNMs, numRacks, nmMemoryMB, nmVCores));
+      LOG.info(MessageFormat.format(
+          "# nodes = {0}, # racks = {1}, capacity "
+              + "of each node {2} MB memory and {3} vcores.",
+          numNMs, numRacks, nmMemoryMB, nmVCores));
-      LOG.info(MessageFormat.format("# applications = {0}, # total " +
-              "tasks = {1}, average # tasks per application = {2}",
-              numAMs, numTasks, (int)(Math.ceil((numTasks + 0.0) / numAMs))));
+      LOG.info(MessageFormat.format(
+          "# applications = {0}, # total "
+              + "tasks = {1}, average # tasks per application = {2}",
+          numAMs, numTasks, (int) (Math.ceil((numTasks + 0.0) / numAMs))));
-        LOG.info(entry.getKey() + "\t" + am.getQueue() + "\t" + am.getAMType() 
+        LOG.info(entry.getKey() + "\t" + am.getQueue() + "\t" + am.getAMType()
-      LOG.info(MessageFormat.format("number of queues = {0}  average " +
-              "number of apps = {1}", queueAppNumMap.size(),
-              (int)(Math.ceil((numAMs + 0.0) / queueAppNumMap.size()))));
+      LOG.info(MessageFormat.format(
+          "number of queues = {0}  average " + "number of apps = {1}",
+          queueAppNumMap.size(),
+          (int) (Math.ceil((numAMs + 0.0) / queueAppNumMap.size()))));
-      LOG.info(MessageFormat.format("estimated simulation time is {0}" +
-              " seconds", (long)(Math.ceil(maxRuntime / 1000.0))));
+      LOG.info(
+          MessageFormat.format("estimated simulation time is {0}" + " seconds",
+              (long) (Math.ceil(maxRuntime / 1000.0))));
-  public static TaskRunner getRunner() {
-    return runner;
-  }
-
-    remainingApps --;
+    remainingApps--;
-      System.exit(0);
-  public static void main(String args[]) throws Exception {
+  public void stop() throws InterruptedException {
+    rm.stop();
+    runner.stop();
+  }
+
+  public int run(final String[] argv) throws IOException, InterruptedException,
+      ParseException, ClassNotFoundException, YarnException {
+
+
+    // Left for compatibility
+
+    // New more general format
+    options.addOption("tracetype", true, "the type of trace");
+    options.addOption("tracelocation", true, "input trace files");
+
-            "jobs to be tracked during simulating");
+        "jobs to be tracked during simulating");
-            "print out simulation information");
-    
-    CommandLineParser parser = new GnuParser();
-    CommandLine cmd = parser.parse(options, args);
+        "print out simulation information");
-    String inputRumen = cmd.getOptionValue("inputrumen");
-    String inputSLS = cmd.getOptionValue("inputsls");
+    CommandLineParser parser = new GnuParser();
+    CommandLine cmd = parser.parse(options, argv);
+
+    String traceType = null;
+    String traceLocation = null;
+
+    // compatibility with old commandline
+    if (cmd.hasOption("inputrumen")) {
+      traceType = "RUMEN";
+      traceLocation = cmd.getOptionValue("inputrumen");
+    }
+    if (cmd.hasOption("inputsls")) {
+      traceType = "SLS";
+      traceLocation = cmd.getOptionValue("inputsls");
+    }
+
+    if (cmd.hasOption("tracetype")) {
+      traceType = cmd.getOptionValue("tracetype");
+      traceLocation = cmd.getOptionValue("tracelocation");
+    }
+
-    
-    if ((inputRumen == null && inputSLS == null) || output == null) {
-      System.err.println();
-      System.err.println("ERROR: Missing input or output file");
-      System.err.println();
-      System.err.println("Options: -inputrumen|-inputsls FILE,FILE... " +
-              "-output FILE [-nodes FILE] [-trackjobs JobId,JobId...] " +
-              "[-printsimulation]");
-      System.err.println();
-      System.exit(1);
-    }
-    
+
-    if (! outputFile.exists()
-            && ! outputFile.mkdirs()) {
+    if (!outputFile.exists() && !outputFile.mkdirs()) {
-              + outputFile.getAbsolutePath());
-      System.exit(1);
+          + outputFile.getAbsolutePath());
+      throw new YarnException("Cannot create output directory");
-    
+
-    
-    String nodeFile = cmd.hasOption("nodes") ? cmd.getOptionValue("nodes") : "";
-    boolean isSLS = inputSLS != null;
-    String inputFiles[] = isSLS ? inputSLS.split(",") : inputRumen.split(",");
-    SLSRunner sls = new SLSRunner(isSLS, inputFiles, nodeFile, output,
+    String tempNodeFile =
+        cmd.hasOption("nodes") ? cmd.getOptionValue("nodes") : "";
+
+    TraceType tempTraceType = TraceType.SLS;
+    switch (traceType) {
+    case "SLS":
+      tempTraceType = TraceType.SLS;
+      break;
+    case "RUMEN":
+      tempTraceType = TraceType.RUMEN;
+      break;
+
+    case "SYNTH":
+      tempTraceType = TraceType.SYNTH;
+      break;
+    default:
+      printUsage();
+      throw new YarnException("Misconfigured input");
+    }
+
+    String[] inputFiles = traceLocation.split(",");
+
+    setSimulationParams(tempTraceType, inputFiles, tempNodeFile, output,
-    sls.start();
+
+    start();
+
+    return 0;
+
+  public static void main(String[] argv) throws Exception {
+    ToolRunner.run(new Configuration(), new SLSRunner(), argv);
+  }
+
+  static void printUsage() {
+    System.err.println();
+    System.err.println("ERROR: Wrong tracetype");
+    System.err.println();
+    System.err.println(
+        "Options: -tracetype " + "SLS|RUMEN|SYNTH -tracelocation FILE,FILE... "
+            + "(deprecated alternative options --inputsls FILE, FILE,... "
+            + " | --inputrumen FILE,FILE,...)"
+            + "-output FILE [-nodes FILE] [-trackjobs JobId,JobId...] "
+            + "[-printsimulation]");
+    System.err.println();
+  }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS43 INS43 INS71 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS42 INS29 INS83 INS42 INS72 INS72 INS72 INS43 INS43 INS83 INS42 INS43 INS8 INS83 INS42 INS44 INS43 INS8 UPD83 INS39 UPD42 INS83 INS39 INS42 INS44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 INS43 INS8 UPD43 INS43 INS43 INS43 INS43 UPD43 MOV79 MOV83 MOV39 MOV42 MOV43 MOV43 INS8 INS29 INS79 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS43 INS8 UPD39 UPD42 INS43 INS43 INS43 INS43 INS43 INS39 INS42 INS44 MOV43 INS83 INS39 INS42 INS8 INS65 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS60 INS21 INS43 INS42 INS42 INS21 INS43 INS42 INS21 INS43 INS42 INS5 UPD42 UPD42 UPD42 UPD42 INS42 INS21 MOV21 MOV21 MOV21 MOV21 INS21 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV60 MOV60 MOV60 MOV60 INS50 MOV21 MOV21 INS65 INS42 INS45 INS39 INS42 INS42 INS60 INS21 INS60 INS60 INS60 INS54 INS42 INS21 INS21 INS83 INS5 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS25 INS25 INS25 INS50 INS60 INS21 INS41 INS5 INS42 INS21 MOV21 INS21 MOV21 INS21 MOV21 INS66 MOV43 INS59 INS32 INS42 INS32 INS42 INS48 UPD42 INS42 MOV43 INS85 INS7 INS7 INS8 INS42 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 INS21 INS10 INS49 INS53 INS66 INS43 INS59 INS32 INS39 INS59 INS43 INS59 INS39 INS59 INS8 INS8 INS32 INS32 INS43 INS85 INS32 INS32 INS43 INS43 INS32 INS8 INS32 INS8 INS32 INS8 INS43 INS59 INS42 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS53 INS5 INS59 INS32 INS34 INS43 INS85 INS32 INS32 INS32 INS42 MOV14 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS22 INS42 UPD42 UPD42 INS42 INS42 INS70 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS14 INS42 INS42 INS45 INS45 INS42 INS34 INS42 INS42 INS14 INS42 INS32 INS25 INS60 INS61 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS9 INS45 INS42 INS42 INS45 INS9 INS45 INS42 UPD42 INS33 INS42 UPD42 INS33 INS42 INS42 INS45 INS21 INS21 INS42 UPD42 MOV42 UPD45 MOV45 INS21 INS21 INS42 INS42 INS45 INS21 MOV21 INS53 UPD42 INS42 INS42 INS40 INS45 INS7 INS45 INS7 INS45 INS7 INS32 INS14 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 UPD42 MOV42 INS42 INS42 INS14 INS14 INS42 INS40 INS42 INS45 INS40 INS42 INS27 UPD42 INS52 INS42 UPD42 INS32 INS32 INS32 INS32 MOV44 INS42 INS8 INS32 INS32 INS32 INS42 INS42 INS43 INS27 INS43 INS43 INS42 INS42 INS27 MOV8 INS43 INS59 INS27 INS8 INS32 UPD42 INS7 INS7 INS7 INS7 INS7 INS7 INS14 INS42 INS40 INS42 INS40 INS42 INS40 INS42 INS43 INS45 INS42 UPD42 MOV42 MOV42 MOV45 INS43 MOV43 INS45 INS45 INS45 INS45 INS45 INS45 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS50 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS45 INS42 INS42 INS42 INS33 INS21 INS42 INS42 INS33 INS36 INS33 INS60 INS60 INS60 INS60 INS60 INS60 INS25 INS21 INS21 INS25 INS60 INS60 INS21 INS21 INS60 INS60 INS60 INS60 INS60 INS24 INS60 INS60 INS24 INS60 INS25 INS60 INS25 INS42 INS42 INS42 INS45 INS42 MOV32 INS42 INS45 INS42 MOV32 INS42 INS32 INS42 INS32 INS43 INS45 INS42 INS42 INS42 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 INS21 INS21 INS10 INS49 INS53 INS7 INS7 INS43 INS59 MOV43 INS59 MOV43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS27 MOV8 INS7 INS7 INS27 INS8 INS39 INS59 INS39 INS59 INS37 INS32 INS74 INS59 INS74 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS43 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS43 INS59 INS32 INS8 INS43 INS59 INS27 INS8 INS42 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS45 INS42 UPD43 INS42 INS42 INS42 INS7 INS32 INS14 INS42 INS14 INS42 INS11 INS42 INS42 INS45 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS38 INS42 INS34 INS21 INS42 INS42 INS42 INS42 INS42 INS34 INS21 INS21 INS21 INS42 INS32 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS34 INS39 INS59 INS42 INS32 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS21 INS21 INS42 INS42 INS32 INS42 INS34 INS39 INS59 INS42 INS32 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS21 INS21 INS42 INS42 INS33 INS42 INS42 INS60 INS21 INS42 INS42 INS11 INS42 INS33 INS21 INS21 INS21 INS21 INS21 UPD42 INS42 INS14 INS42 INS42 INS32 INS43 INS27 INS8 INS43 INS32 INS14 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS34 INS7 INS32 INS7 INS7 INS42 INS42 INS42 INS32 INS32 INS34 INS42 INS42 INS74 INS42 INS42 INS74 INS32 INS43 INS32 INS42 INS42 INS34 INS34 INS42 INS34 INS42 INS42 INS43 INS59 INS43 INS59 MOV43 INS59 INS39 INS59 INS43 INS59 INS32 INS7 INS7 INS42 INS42 INS34 INS34 INS42 INS34 INS42 INS42 INS43 INS59 INS43 INS59 MOV43 INS59 INS39 INS59 INS43 INS59 INS32 INS7 INS7 INS43 INS59 INS7 INS43 INS32 INS32 INS32 INS7 INS7 INS32 UPD42 INS43 INS32 INS14 INS42 INS42 INS32 INS32 INS42 INS45 INS45 MOV21 INS42 INS42 INS43 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS32 INS42 INS16 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS32 INS42 INS16 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS37 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS43 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS34 INS32 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS11 INS11 INS43 INS42 INS42 INS42 INS34 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS40 INS42 INS34 INS32 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS11 INS11 INS43 INS42 INS42 INS42 INS34 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS27 INS27 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS33 INS32 INS33 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS39 INS32 INS39 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS39 INS32 INS39 INS32 INS42 INS42 INS42 INS22 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL39 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL85 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL8 DEL42 DEL8 DEL70 DEL8 DEL25 DEL8 DEL42 DEL25 DEL8 DEL31 DEL42 DEL42 DEL34 DEL32 DEL21 DEL83 DEL42 DEL85 DEL34 DEL32 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL36 DEL42 DEL33 DEL27 DEL27 DEL40 DEL32 DEL21 DEL40 DEL42 DEL45 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL21 DEL39 DEL42 DEL42 DEL33 DEL27 DEL59 DEL42 DEL85 DEL42 DEL42 DEL42 DEL45 DEL32 DEL32 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL41
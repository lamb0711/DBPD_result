HDFS-4912. Cleanup FSNamesystem#startFileInternal. Contributed by Suresh Srinivas.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502634 13f79535-47bb-0310-9956-ffa450edef68

+    blockManager.verifyReplication(src, replication, clientMachine);
+    boolean create = flag.contains(CreateFlag.CREATE);
+    boolean overwrite = flag.contains(CreateFlag.OVERWRITE);
-      startFileInternal(pc, src, permissions, holder, clientMachine, flag,
-          createParent, replication, blockSize);
+      startFileInternal(pc, src, permissions, holder, clientMachine,
+          create, overwrite, createParent, replication, blockSize);
-   * Create new or open an existing file for append.<p>
+   * Create a new file or overwrite an existing file<br>
-   * In case of opening the file for append, the method returns the last
-   * block of the file if this is a partial block, which can still be used
-   * for writing more data. The client uses the returned block locations
-   * to form the data pipeline for this block.<br>
-   * The method returns null if the last block is full or if this is a 
-   * new file. The client then allocates a new block with the next call
-   * using {@link NameNode#addBlock()}.<p>
-   *
-   * For description of parameters and exceptions thrown see 
+   * Once the file is create the client then allocates a new block with the next
+   * call using {@link NameNode#addBlock()}.
+   * <p>
+   * For description of parameters and exceptions thrown see
-   * 
-   * @return the last block locations if the block is partial or null otherwise
-  private LocatedBlock startFileInternal(FSPermissionChecker pc, String src,
+  private void startFileInternal(FSPermissionChecker pc, String src,
-      EnumSet<CreateFlag> flag, boolean createParent, short replication,
-      long blockSize) throws SafeModeException, FileAlreadyExistsException,
+      boolean create, boolean overwrite, boolean createParent,
+      short replication, long blockSize) throws FileAlreadyExistsException,
-
-    boolean overwrite = flag.contains(CreateFlag.OVERWRITE);
-    boolean append = flag.contains(CreateFlag.APPEND);
-      if (append || (overwrite && myFile != null)) {
+      if (overwrite && myFile != null) {
-      blockManager.verifyReplication(src, replication, clientMachine);
-      boolean create = flag.contains(CreateFlag.CREATE);
-      
-          throw new FileNotFoundException("failed to overwrite or append to non-existent file "
+          throw new FileNotFoundException("failed to overwrite non-existent file "
-        // File exists - must be one of append or overwrite
-          delete(src, true);
+          delete(src, true); // File exists - delete if overwrite
-          // Opening an existing file for write - may need to recover lease.
+          // If lease soft limit time is expired, recover the lease
-
-          if (!append) {
-            throw new FileAlreadyExistsException("failed to create file " + src
-                + " on client " + clientMachine
-                + " because the file exists");
-          }
+          throw new FileAlreadyExistsException("failed to create file " + src
+              + " on client " + clientMachine + " because the file exists");
+      checkFsObjectLimit();
-      if (append && myFile != null) {
-        final INodeFile f = INodeFile.valueOf(myFile, src); 
-        return prepareFileForWrite(src, f, holder, clientMachine, clientNode,
-            true, iip.getLatestSnapshot());
-      } else {
-       // Now we can add the name to the filesystem. This file has no
-       // blocks associated with it.
-       //
-       checkFsObjectLimit();
+      INodeFileUnderConstruction newNode = dir.addFile(src, permissions,
+          replication, blockSize, holder, clientMachine, clientNode);
+      if (newNode == null) {
+        throw new IOException("DIR* NameSystem.startFile: " +
+                              "Unable to add file to namespace.");
+      }
+      leaseManager.addLease(newNode.getClientName(), src);
-        // increment global generation stamp
-        INodeFileUnderConstruction newNode = dir.addFile(src, permissions,
-            replication, blockSize, holder, clientMachine, clientNode);
-        if (newNode == null) {
-          throw new IOException("DIR* NameSystem.startFile: " +
-                                "Unable to add file to namespace.");
-        }
-        leaseManager.addLease(newNode.getClientName(), src);
-
-        // record file record in log, record new generation stamp
-        getEditLog().logOpenFile(src, newNode);
-        if (NameNode.stateChangeLog.isDebugEnabled()) {
-          NameNode.stateChangeLog.debug("DIR* NameSystem.startFile: "
-                                     +"add "+src+" to namespace for "+holder);
-        }
+      // record file record in log, record new generation stamp
+      getEditLog().logOpenFile(src, newNode);
+      if (NameNode.stateChangeLog.isDebugEnabled()) {
+        NameNode.stateChangeLog.debug("DIR* NameSystem.startFile: "
+                                   +"add "+src+" to namespace for "+holder);
-    return null;
+  }
+  
+  /**
+   * Append to an existing file for append.
+   * <p>
+   * 
+   * The method returns the last block of the file if this is a partial block,
+   * which can still be used for writing more data. The client uses the returned
+   * block locations to form the data pipeline for this block.<br>
+   * The method returns null if the last block is full. The client then
+   * allocates a new block with the next call using {@link NameNode#addBlock()}.
+   * <p>
+   * 
+   * For description of parameters and exceptions thrown see
+   * {@link ClientProtocol#append(String, String)}
+   * 
+   * @return the last block locations if the block is partial or null otherwise
+   */
+  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,
+      String holder, String clientMachine) throws AccessControlException,
+      UnresolvedLinkException, FileNotFoundException, IOException {
+    assert hasWriteLock();
+    // Verify that the destination does not exist as a directory already.
+    final INodesInPath iip = dir.getINodesInPath4Write(src);
+    final INode inode = iip.getLastINode();
+    if (inode != null && inode.isDirectory()) {
+      throw new FileAlreadyExistsException("Cannot append to directory " + src
+          + "; already exists as a directory.");
+    }
+    if (isPermissionEnabled) {
+      checkPathAccess(pc, src, FsAction.WRITE);
+    }
+
+    try {
+      if (inode == null) {
+        throw new FileNotFoundException("failed to append to non-existent file "
+          + src + " on client " + clientMachine);
+      }
+      final INodeFile myFile = INodeFile.valueOf(inode, src, true);
+      // Opening an existing file for write - may need to recover lease.
+      recoverLeaseInternal(myFile, src, holder, clientMachine, false);
+
+      final DatanodeDescriptor clientNode = 
+          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);
+      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,
+          true, iip.getLatestSnapshot());
+    } catch (IOException ie) {
+      NameNode.stateChangeLog.warn("DIR* NameSystem.append: " +ie.getMessage());
+      throw ie;
+    }
-    if (NameNode.stateChangeLog.isDebugEnabled()) {
-      NameNode.stateChangeLog.debug("DIR* NameSystem.appendFile: src=" + src
-          + ", holder=" + holder
-          + ", clientMachine=" + clientMachine);
-    }
-    if (!DFSUtil.isValidName(src)) {
-      throw new InvalidPathException(src);
-    }
-      lb = startFileInternal(pc, src, null, holder, clientMachine, 
-                        EnumSet.of(CreateFlag.APPEND), 
-                        false, blockManager.maxReplication, 0);
+      lb = appendFileInternal(pc, src, holder, clientMachine);

INS31 INS39 INS44 INS44 MOV8 INS29 INS83 MOV43 INS42 INS44 INS44 INS44 INS44 INS43 INS43 INS43 INS43 INS8 MOV21 MOV60 MOV60 MOV66 INS39 INS42 INS39 UPD42 MOV42 MOV6 MOV60 MOV60 MOV25 MOV60 MOV25 MOV25 INS54 INS65 MOV65 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS6 INS60 INS60 INS25 INS25 INS54 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV8 MOV12 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS42 INS42 INS42 INS42 INS32 INS83 INS43 INS59 INS83 INS43 INS59 INS27 INS8 INS42 INS8 INS8 INS12 MOV25 MOV60 INS68 INS68 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS32 INS53 INS21 INS25 INS60 INS21 INS60 INS41 INS44 INS8 INS40 MOV27 MOV27 INS8 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS14 INS32 INS27 INS8 INS83 INS43 INS59 INS32 INS83 INS43 INS59 INS32 INS43 INS42 INS21 INS53 UPD42 INS42 INS25 INS43 INS43 INS43 INS27 INS42 INS42 INS42 INS40 INS42 INS33 INS53 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 MOV32 INS42 INS32 INS42 MOV38 INS8 INS42 MOV8 INS42 INS42 INS42 INS45 INS42 INS45 INS14 INS42 INS42 INS42 INS42 INS9 INS32 INS42 INS42 INS40 INS42 INS27 UPD42 INS53 MOV21 UPD45 MOV45 INS43 INS27 INS42 INS42 INS45 INS32 INS14 UPD42 MOV42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 MOV43 INS27 INS45 INS42 INS45 INS42 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL36 DEL27 DEL42 DEL42 DEL38 DEL45 DEL42 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL8 DEL25 DEL42 DEL42 DEL33 DEL27 DEL27 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL41 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL54 DEL33 DEL41 DEL8 DEL40 DEL42 DEL32 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL33 DEL42 DEL42 DEL40 DEL32 DEL9 DEL40 DEL34
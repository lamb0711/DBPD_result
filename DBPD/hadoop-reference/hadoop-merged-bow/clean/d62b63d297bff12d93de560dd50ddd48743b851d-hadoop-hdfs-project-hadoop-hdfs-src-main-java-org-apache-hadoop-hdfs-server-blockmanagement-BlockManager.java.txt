HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.

-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_HA_NAMENODES_KEY_PREFIX;
-  private final Set<Block> postponedMisreplicatedBlocks = Sets.newHashSet();
+  private final Set<BlockInfo> postponedMisreplicatedBlocks = Sets.newHashSet();
-        conf.get(DFSConfigKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY) == null
-            ? false : true;
+        conf.get(DFSConfigKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY) != null;
-    return isBlockTokenEnabled()? blockTokenSecretManager.updateKeys(updateTime)
-        : false;
+    return isBlockTokenEnabled() && blockTokenSecretManager.updateKeys(updateTime);
-      for (Block block : neededReplications) {
+      for (BlockInfo block : neededReplications) {
-    for (Block block : postponedMisreplicatedBlocks) {
+    for (BlockInfo block : postponedMisreplicatedBlocks) {
-  private void dumpBlockMeta(Block block, PrintWriter out) {
-    List<DatanodeDescriptor> containingNodes =
-                                      new ArrayList<DatanodeDescriptor>();
-    List<DatanodeStorageInfo> containingLiveReplicasNodes =
-      new ArrayList<>();
+  private void dumpBlockMeta(BlockInfo block, PrintWriter out) {
+    List<DatanodeDescriptor> containingNodes = new ArrayList<>();
+    List<DatanodeStorageInfo> containingLiveReplicasNodes = new ArrayList<>();
-    // containingLiveReplicasNodes can include READ_ONLY_SHARED replicas which are 
-    // not included in the numReplicas.liveReplicas() count
+    // containingLiveReplicasNodes can include READ_ONLY_SHARED replicas which
+    // are not included in the numReplicas.liveReplicas() count
-    
-    if (block instanceof BlockInfo) {
-      BlockCollection bc = ((BlockInfo) block).getBlockCollection();
-      String fileName = (bc == null) ? "[orphaned]" : bc.getName();
-      out.print(fileName + ": ");
-    }
+
+    BlockCollection bc = block.getBlockCollection();
+    String fileName = (bc == null) ? "[orphaned]" : bc.getName();
+    out.print(fileName + ": ");
+
-    Collection<DatanodeDescriptor> corruptNodes = 
-                                  corruptReplicas.getNodes(block);
+    Collection<DatanodeDescriptor> corruptNodes =
+        corruptReplicas.getNodes(block);
-    long curPos = 0, blkSize = 0;
+    long curPos = 0;
+    long blkSize;
-   * 
-   * @param b
+   * Mark a replica (of a contiguous block) or an internal block (of a striped
+   * block group) as corrupt.
+   * @param b Indicating the reported bad block and the corresponding BlockInfo
+   *          stored in blocksMap.
-   * @throws IOException
-    corruptReplicas.addToCorruptReplicasMap(b.corrupted, node, b.reason,
+    corruptReplicas.addToCorruptReplicasMap(b.stored, node, b.reason,
-      invalidateBlock(b, node);
+      invalidateBlock(b, node, numberOfReplicas);
-   * Invalidates the given block on the given datanode.
-   * @return true if the block was successfully invalidated and no longer
-   * present in the BlocksMap
+   * Invalidates the given block on the given datanode. Note that before this
+   * call we have already checked the current live replicas of the block and
+   * make sure it's safe to invalidate the replica.
+   *
+   * @return true if the replica was successfully invalidated and no longer
+   *         associated with the DataNode.
-  private boolean invalidateBlock(BlockToMarkCorrupt b, DatanodeInfo dn
-      ) throws IOException {
+  private boolean invalidateBlock(BlockToMarkCorrupt b, DatanodeInfo dn,
+      NumberReplicas nr) throws IOException {
-    NumberReplicas nr = countNodes(b.stored);
-      postponeBlock(b.corrupted);
+      postponeBlock(b.stored);
-    } else if (nr.liveReplicas() >= 1) {
-      // If we have at least one copy on a live node, then we can delete it.
+    } else {
+      // we already checked the number of replicas in the caller of this
+      // function and we know there is at least one copy on a live node, so we
+      // can delete it.
-    } else {
-      blockLog.info("BLOCK* invalidateBlocks: {} on {} is the only copy and" +
-          " was not deleted", b, dn);
-      return false;
-
-
-  private void postponeBlock(Block blk) {
+  private void postponeBlock(BlockInfo blk) {
-    BlockCollection bc = null;
+    BlockCollection bc;
-          for (int k = 0; k < targets.length; k++) {
+          for (DatanodeStorageInfo target : targets) {
-            targetList.append(targets[k].getDatanodeDescriptor());
+            targetList.append(target.getDatanodeDescriptor());
-      for (int i = 0; i < nodes.size(); i++) {
-        DatanodeDescriptor node = datanodeManager.getDatanodeDescriptor(nodes.get(i));
+      for (String nodeStr : nodes) {
+        DatanodeDescriptor node = datanodeManager.getDatanodeDescriptor(nodeStr);
-   DatanodeDescriptor chooseSourceDatanode(Block block,
+   DatanodeDescriptor chooseSourceDatanode(BlockInfo block,
-        for (int i = 0; i < timedOutItems.length; i++) {
+        for (BlockInfo timedOutItem : timedOutItems) {
-          BlockInfo bi = getStoredBlock(timedOutItems[i]);
+          BlockInfo bi = getStoredBlock(timedOutItem);
-          NumberReplicas num = countNodes(timedOutItems[i]);
+          NumberReplicas num = countNodes(timedOutItem);
-    DatanodeDescriptor node = null;
+    DatanodeDescriptor node;
-      Iterator<Block> it = postponedMisreplicatedBlocks.iterator();
+      Iterator<BlockInfo> it = postponedMisreplicatedBlocks.iterator();
-    BlockToMarkCorrupt b = null;
+    BlockToMarkCorrupt b;
-      invalidateCorruptReplicas(storedBlock, reportedBlock);
+      invalidateCorruptReplicas(storedBlock, reportedBlock, num);
-  private void invalidateCorruptReplicas(BlockInfo blk, Block reported) {
+  private void invalidateCorruptReplicas(BlockInfo blk, Block reported,
+      NumberReplicas numberReplicas) {
-    DatanodeDescriptor[] nodesCopy = nodes.toArray(new DatanodeDescriptor[0]);
+    DatanodeDescriptor[] nodesCopy = nodes.toArray(
+        new DatanodeDescriptor[nodes.size()]);
-            Reason.ANY), node)) {
+            Reason.ANY), node, numberReplicas)) {
-        return;
-        boolean removed = false;
-        removed |= node.getPendingCached().remove(cblock);
+        boolean removed = node.getPendingCached().remove(cblock);
-    for(DatanodeStorageInfo storage : blocksMap.getStorages(b, State.NORMAL)) {
+    for (DatanodeStorageInfo storage : blocksMap.getStorages(b, State.NORMAL)) {
-    return new NumberReplicas(live, decommissioned, decommissioning, corrupt, excess, stale);
+    return new NumberReplicas(live, decommissioned, decommissioning, corrupt,
+        excess, stale);
-        final BlockInfoUnderConstruction uc =
-            (BlockInfoUnderConstruction)b;
-  public int numCorruptReplicas(Block block) {
-    return corruptReplicas.numCorruptReplicas(block);
-  }
-
-  public void removeBlockFromMap(Block block) {
+  public void removeBlockFromMap(BlockInfo block) {
-  private void removeFromExcessReplicateMap(Block block) {
+  private void removeFromExcessReplicateMap(BlockInfo block) {
-  public Collection<DatanodeDescriptor> getCorruptReplicas(Block block) {
+  public Collection<DatanodeDescriptor> getCorruptReplicas(BlockInfo block) {
- public String getCorruptReason(Block block, DatanodeDescriptor node) {
+ public String getCorruptReason(BlockInfo block, DatanodeDescriptor node) {
-  };
+  }

UPD74 INS44 INS44 UPD43 UPD43 MOV60 MOV60 MOV21 INS60 INS65 MOV43 INS42 MOV25 UPD43 UPD43 INS43 INS42 UPD43 UPD43 UPD43 UPD43 MOV42 INS27 UPD42 INS39 INS59 INS66 INS66 INS66 INS66 UPD66 INS66 INS66 UPD66 UPD66 MOV27 MOV8 UPD42 UPD42 INS42 MOV5 UPD42 UPD42 UPD42 UPD42 UPD27 MOV27 MOV32 MOV32 UPD43 INS42 UPD40 INS70 UPD42 UPD74 INS42 INS44 INS42 MOV8 UPD74 UPD43 INS42 UPD40 INS43 INS42 INS70 UPD43 INS42 MOV5 MOV32 UPD42 INS42 INS44 INS42 MOV8 UPD42 MOV32 INS70 MOV43 INS42 INS44 INS42 INS8 UPD42 MOV42 INS42 INS43 INS42 MOV21 MOV21 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL9 DEL9 DEL16 DEL9 DEL16 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL62 DEL8 DEL25 DEL42 DEL34 DEL59 DEL42 DEL65 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL25 DEL33 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL27 DEL42 DEL37 DEL24 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL33 DEL33 DEL34 DEL41 DEL9 DEL42 DEL7 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31
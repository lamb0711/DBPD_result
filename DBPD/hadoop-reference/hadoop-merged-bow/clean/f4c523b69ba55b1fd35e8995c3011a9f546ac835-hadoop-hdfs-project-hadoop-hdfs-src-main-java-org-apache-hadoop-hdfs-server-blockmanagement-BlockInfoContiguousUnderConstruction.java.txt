Revert "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang."

This reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.

+import java.util.ArrayList;
-import com.google.common.base.Preconditions;
-import org.apache.hadoop.hdfs.server.common.HdfsServerConstants;
-public abstract class BlockInfoUnderConstruction extends BlockInfo {
+public class BlockInfoContiguousUnderConstruction extends BlockInfoContiguous {
-  protected BlockUCState blockUCState;
+  private BlockUCState blockUCState;
-  protected List<ReplicaUnderConstruction> replicas;
+  private List<ReplicaUnderConstruction> replicas;
-  protected Block truncateBlock;
+  private Block truncateBlock;
-   * The GS, the length and the state of the replica is as reported by
+   * The GS, the length and the state of the replica is as reported by 
-
+    
-  public BlockInfoUnderConstruction(Block blk, short replication) {
+  public BlockInfoContiguousUnderConstruction(Block blk, short replication) {
-  public BlockInfoUnderConstruction(Block blk, short replication,
+  public BlockInfoContiguousUnderConstruction(Block blk, short replication,
-    Preconditions.checkState(getBlockUCState() != BlockUCState.COMPLETE,
-        "BlockInfoUnderConstruction cannot be in COMPLETE state");
+    assert getBlockUCState() != BlockUCState.COMPLETE :
+      "BlockInfoUnderConstruction cannot be in COMPLETE state";
-  /** Set expected locations. */
-  public abstract void setExpectedLocations(DatanodeStorageInfo[] targets);
+  /**
+   * Convert an under construction block to a complete block.
+   * 
+   * @return BlockInfo - a complete block.
+   * @throws IOException if the state of the block 
+   * (the generation stamp and the length) has not been committed by 
+   * the client or it does not have at least a minimal number of replicas 
+   * reported from data-nodes. 
+   */
+  BlockInfo convertToCompleteBlock() throws IOException {
+    assert getBlockUCState() != BlockUCState.COMPLETE :
+      "Trying to convert a COMPLETE block";
+    return new BlockInfoContiguous(this);
+  }
+
+  /** Set expected locations */
+  public void setExpectedLocations(DatanodeStorageInfo[] targets) {
+    int numLocations = targets == null ? 0 : targets.length;
+    this.replicas = new ArrayList<ReplicaUnderConstruction>(numLocations);
+    for(int i = 0; i < numLocations; i++)
+      replicas.add(
+        new ReplicaUnderConstruction(this, targets[i], ReplicaState.RBW));
+  }
-    for(int i = 0; i < numLocations; i++) {
+    for(int i = 0; i < numLocations; i++)
-    }
-  /** Get the number of expected locations. */
+  /** Get the number of expected locations */
-  /** Get block recovery ID. */
+  /** Get block recovery ID */
-  /** Get recover block. */
-  public abstract Block getTruncateBlock();
+  /** Get recover block */
+  public Block getTruncateBlock() {
+    return truncateBlock;
+  }
-  public abstract void setTruncateBlock(Block recoveryBlock);
+  public void setTruncateBlock(Block recoveryBlock) {
+    this.truncateBlock = recoveryBlock;
+  }
-    if (replicas == null) {
+    if (replicas == null)
-    }
-   * @param block - contains client reported block length and generation
+   * @param block - contains client reported block length and generation 
-    if(getBlockId() != block.getBlockId()) {
+    if(getBlockId() != block.getBlockId())
-    }
-      NameNode.blockStateChangeLog.warn("BLOCK* " +
-          "BlockInfoUnderConstruction.initLeaseRecovery: " +
-          "No blocks found, lease removed.");
+      NameNode.blockStateChangeLog.warn("BLOCK*"
+        + " BlockInfoUnderConstruction.initLeaseRecovery:"
+        + " No blocks found, lease removed.");
-            (allLiveReplicasTriedAsPrimary &&
-                replicas.get(i).getChosenAsPrimary());
+            (allLiveReplicasTriedAsPrimary && replicas.get(i).getChosenAsPrimary());
-      if (!(replicas.get(i).isAlive() &&
-          !replicas.get(i).getChosenAsPrimary())) {
+      if (!(replicas.get(i).isAlive() && !replicas.get(i).getChosenAsPrimary())) {
-      primary.getExpectedStorageLocation().
-          getDatanodeDescriptor().addBlockToBeRecovered(this);
+      primary.getExpectedStorageLocation().getDatanodeDescriptor().addBlockToBeRecovered(this);
-  /**
-   * Convert an under construction block to a complete block.
-   *
-   * @return a complete block.
-   * @throws IOException
-   *           if the state of the block (the generation stamp and the length)
-   *           has not been committed by the client or it does not have at
-   *           least a minimal number of replicas reported from data-nodes.
-   */
-  public abstract BlockInfo convertToCompleteBlock();
-
-  @Override
-  BlockInfoUnderConstruction convertCompleteBlockToUC
-      (HdfsServerConstants.BlockUCState s, DatanodeStorageInfo[] targets) {
-    BlockManager.LOG.error("convertCompleteBlockToUC should only be applied " +
-        "on complete blocks.");
-    return null;
-  }
-

MOV26 UPD40 UPD42 UPD43 INS31 INS31 UPD42 UPD83 UPD83 UPD83 UPD42 UPD42 INS29 MOV43 INS42 INS43 INS8 MOV44 INS8 INS8 MOV83 MOV39 MOV42 MOV44 MOV8 INS6 MOV65 INS65 INS65 INS42 INS6 INS41 INS60 INS21 INS24 INS41 UPD66 MOV27 INS45 INS66 INS42 INS66 INS66 INS66 INS66 INS27 INS45 INS14 UPD66 INS39 INS59 INS7 INS58 INS27 INS37 INS21 MOV21 UPD66 UPD66 UPD66 INS42 INS7 INS41 UPD66 MOV53 INS32 INS40 INS43 INS52 INS42 INS16 INS22 INS14 INS39 INS59 INS42 INS42 INS42 INS32 INS22 INS42 INS42 INS42 INS27 INS34 INS40 INS52 INS42 INS74 INS42 INS42 INS34 INS42 INS42 INS14 INS52 INS42 INS42 INS33 INS43 INS43 INS43 INS52 INS2 INS40 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD45 UPD45 UPD45 DEL40 DEL26 DEL83 DEL42 DEL42 DEL45 DEL32 DEL21 DEL83 DEL43 DEL85 DEL5 DEL42 DEL44 DEL8 DEL83 DEL40 DEL42 DEL45 DEL45 DEL27 DEL32 DEL33 DEL41 DEL83 DEL31 DEL41 DEL8 DEL8 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL31 DEL42 DEL78 DEL42 DEL43 DEL42 DEL40 DEL43 DEL42 DEL44 DEL31
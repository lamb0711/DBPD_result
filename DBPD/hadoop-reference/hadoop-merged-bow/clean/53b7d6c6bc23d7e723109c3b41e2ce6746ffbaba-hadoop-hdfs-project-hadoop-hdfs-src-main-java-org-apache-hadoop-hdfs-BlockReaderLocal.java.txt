Merge trunk into HA branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1245690 13f79535-47bb-0310-9956-ffa450edef68

+    if (n <= 0) {
+      return 0;
+    }
-    // Skip by reading the data so we stay in sync with checksums.
-    // This could be implemented more efficiently in the future to
-    // skip to the beginning of the appropriate checksum chunk
-    // and then only read to the middle of that chunk.
+  
+    // caller made sure newPosition is not beyond EOF.
+    int remaining = dataBuff.remaining();
+    int position = dataBuff.position();
+    int newPosition = position + (int)n;
+  
+    // if the new offset is already read into dataBuff, just reposition
+    if (n <= remaining) {
+      assert offsetFromChunkBoundary == 0;
+      dataBuff.position(newPosition);
+      return n;
+    }
+  
+    // for small gap, read through to keep the data/checksum in sync
+    if (n - remaining <= bytesPerChecksum) {
+      dataBuff.position(position + remaining);
+      if (skipBuf == null) {
+        skipBuf = new byte[bytesPerChecksum];
+      }
+      int ret = read(skipBuf, 0, (int)(n - remaining));
+      return ret;
+    }
+  
+    // optimize for big gap: discard the current buffer, skip to
+    // the beginning of the appropriate checksum chunk and then
+    // read to the middle of that chunk to be in sync with checksums.
+    this.offsetFromChunkBoundary = newPosition % bytesPerChecksum;
+    long toskip = n - remaining - this.offsetFromChunkBoundary;
+  
+    dataBuff.clear();
+    checksumBuff.clear();
+  
+    long dataSkipped = dataIn.skip(toskip);
+    if (dataSkipped != toskip) {
+      throw new IOException("skip error in data input stream");
+    }
+    long checkSumOffset = (dataSkipped / bytesPerChecksum) * checksumSize;
+    if (checkSumOffset > 0) {
+      long skipped = checksumIn.skip(checkSumOffset);
+      if (skipped != checkSumOffset) {
+        throw new IOException("skip error in checksum input stream");
+      }
+    }
+
+    // read into the middle of the chunk
-    long nSkipped = 0;
-    while ( nSkipped < n ) {
-      int toSkip = (int)Math.min(n-nSkipped, skipBuf.length);
-      int ret = read(skipBuf, 0, toSkip);
-      if ( ret <= 0 ) {
-        return nSkipped;
-      }
-      nSkipped += ret;
+    assert skipBuf.length == bytesPerChecksum;
+    assert this.offsetFromChunkBoundary < bytesPerChecksum;
+    int ret = read(skipBuf, 0, this.offsetFromChunkBoundary);
+    if (ret == -1) {  // EOS
+      return toskip;
+    } else {
+      return (toskip + ret);
-    return nSkipped;

MOV25 INS25 INS60 INS60 INS25 INS25 INS21 INS60 INS21 INS21 INS60 INS25 INS60 INS25 INS6 INS6 MOV60 INS25 INS27 INS8 UPD39 INS39 INS59 INS39 INS59 INS27 INS8 INS27 INS8 INS7 INS39 INS59 INS32 INS32 INS39 INS59 INS27 INS8 INS39 INS59 INS27 INS8 INS27 INS27 UPD27 MOV27 MOV8 INS8 INS42 INS34 INS41 UPD42 INS32 INS42 INS32 INS42 INS27 INS42 INS42 INS6 INS21 INS41 INS27 INS42 INS21 INS25 INS60 INS41 INS22 INS27 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS53 INS42 INS27 INS42 INS34 INS60 INS25 INS40 INS42 INS22 INS42 INS38 INS41 INS34 INS42 INS42 INS42 INS42 UPD42 MOV42 INS11 INS27 INS32 INS42 INS42 INS42 INS32 INS27 INS8 MOV39 INS59 INS42 INS52 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS22 INS42 INS42 INS42 INS14 INS36 INS42 INS39 INS59 INS27 INS8 INS52 INS42 INS22 INS34 UPD42 INS36 INS39 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS33 INS21 INS42 INS32 INS52 INS42 INS43 INS45 INS27 INS42 INS32 INS42 INS42 INS53 INS52 INS42 INS27 INS42 INS42 INS7 INS42 INS42 INS34 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS3 MOV39 INS36 INS43 INS45 INS5 INS42 INS27 INS42 INS39 INS85 INS42 INS42 DEL34 DEL42 DEL34 DEL42 DEL27 DEL42 DEL42 DEL42 DEL27 DEL40 DEL32 DEL11 DEL59 DEL60 DEL25 DEL42 DEL42 DEL7 DEL21 DEL8 DEL61 DEL42 DEL41
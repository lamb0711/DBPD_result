YARN-6163. FS Preemption is a trickle for severely starved applications. (kasha)

+  private long nextStarvationCheck;
-      Resources.subtractFrom(availableResources,
+      Resources.subtractFromNonNegative(availableResources,
-    if (availableResources.getMemorySize() < 0) {
-      availableResources.setMemorySize(0);
-    }
-    if (availableResources.getVirtualCores() < 0) {
-      availableResources.setVirtualCores(0);
-    }
+   * Get last computed fairshare starvation.
+   *
+   * @return last computed fairshare starvation
+   */
+  Resource getFairshareStarvation() {
+    return fairshareStarvation;
+  }
+
+  /**
-   * Helper method that computes the extent of fairshare fairshareStarvation.
+   * Helper method that computes the extent of fairshare starvation.
+   * @return freshly computed fairshare starvation
-    Resource starvation = Resources.subtractFrom(threshold, getResourceUsage());
+    Resource starvation = Resources.componentwiseMin(threshold, demand);
+    Resources.subtractFromNonNegative(starvation, getResourceUsage());
-    boolean starved = Resources.greaterThan(
-        fsQueue.getPolicy().getResourceCalculator(),
-        scheduler.getClusterResource(), starvation, Resources.none());
+    boolean starved = !Resources.isNone(starvation);
+  /**
+   * Fetch a list of RRs corresponding to the extent the app is starved
+   * (fairshare and minshare). This method considers the number of containers
+   * in a RR and also only one locality-level (the first encountered
+   * resourceName).
+   *
+   * @return list of {@link ResourceRequest}s corresponding to the amount of
+   * starvation.
+   */
+  List<ResourceRequest> getStarvedResourceRequests() {
+    // List of RRs we build in this method to return
+    List<ResourceRequest> ret = new ArrayList<>();
+
+    // Track visited RRs to avoid the same RR at multiple locality levels
+    VisitedResourceRequestTracker visitedRRs =
+        new VisitedResourceRequestTracker(scheduler.getNodeTracker());
+
+    // Start with current starvation and track the pending amount
+    Resource pending = getStarvation();
+    for (ResourceRequest rr : appSchedulingInfo.getAllResourceRequests()) {
+      if (Resources.isNone(pending)) {
+        // Found enough RRs to match the starvation
+        break;
+      }
+
+      // See if we have already seen this RR
+      if (!visitedRRs.visit(rr)) {
+        continue;
+      }
+
+      // A RR can have multiple containers of a capability. We need to
+      // compute the number of containers that fit in "pending".
+      int numContainersThatFit = (int) Math.floor(
+          Resources.ratio(scheduler.getResourceCalculator(),
+              pending, rr.getCapability()));
+      if (numContainersThatFit == 0) {
+        // This RR's capability is too large to fit in pending
+        continue;
+      }
+
+      // If the RR is only partially being satisfied, include only the
+      // partial number of containers.
+      if (numContainersThatFit < rr.getNumContainers()) {
+        rr = ResourceRequest.newInstance(rr.getPriority(),
+            rr.getResourceName(), rr.getCapability(), numContainersThatFit);
+      }
+
+      // Add the RR to return list and adjust "pending" accordingly
+      ret.add(rr);
+      Resources.subtractFromNonNegative(pending,
+          Resources.multiply(rr.getCapability(), rr.getNumContainers()));
+    }
+
+    return ret;
+  }
+
+  /**
+   * Notify this app that preemption has been triggered to make room for
+   * outstanding demand. The app should not be considered starved until after
+   * the specified delay.
+   *
+   * @param delayBeforeNextStarvationCheck duration to wait
+   */
+  void preemptionTriggered(long delayBeforeNextStarvationCheck) {
+    nextStarvationCheck =
+        scheduler.getClock().getTime() + delayBeforeNextStarvationCheck;
+  }
+
+  /**
+   * Whether this app's starvation should be considered.
+   */
+  boolean shouldCheckForStarvation() {
+    return scheduler.getClock().getTime() >= nextStarvationCheck;
+  }
+
+  /**
+   * Get the current app's unsatisfied demand.
+   */
+  Resource getPendingDemand() {
+    return Resources.subtract(demand, getResourceUsage());
+  }
+

INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS39 INS59 INS29 INS43 INS42 INS8 INS29 INS74 INS42 INS8 INS29 INS39 INS42 INS44 INS8 INS29 INS39 INS42 INS8 INS29 INS43 INS42 INS8 INS42 INS65 INS65 INS42 INS41 INS65 INS21 INS65 INS65 INS43 INS43 INS60 INS60 INS60 INS70 INS41 INS65 INS65 INS39 INS42 INS21 INS65 INS41 INS65 INS42 INS41 INS66 INS66 INS42 UPD66 INS66 INS32 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS42 INS74 INS59 INS43 INS59 INS43 INS59 INS44 INS32 INS8 INS42 INS66 INS66 INS66 INS42 INS66 INS7 INS66 INS27 INS66 INS32 INS42 INS42 INS42 MOV32 INS38 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS25 INS25 INS60 INS25 INS25 INS21 INS21 INS42 INS27 INS32 INS42 INS42 INS42 INS42 INS32 UPD42 INS42 INS32 INS42 INS42 INS74 INS43 INS32 INS42 INS42 INS32 INS8 INS38 INS8 INS39 INS59 INS27 INS8 INS27 INS8 INS32 INS32 INS32 INS42 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS10 INS32 INS18 INS42 INS11 INS42 INS34 INS18 INS42 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS32 INS42 INS42 INS7 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32
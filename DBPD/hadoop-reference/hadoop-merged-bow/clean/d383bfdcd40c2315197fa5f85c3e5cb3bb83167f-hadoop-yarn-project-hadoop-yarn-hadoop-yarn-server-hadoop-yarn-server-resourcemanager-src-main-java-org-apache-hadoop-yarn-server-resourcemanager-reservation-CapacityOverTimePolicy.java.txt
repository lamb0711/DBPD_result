YARN-5164. Use plan RLE to improve CapacityOverTimePolicy efficiency

- *   Licensed to the Apache Software Foundation (ASF) under one
- *   or more contributor license agreements.  See the NOTICE file
- *   distributed with this work for additional information
- *   regarding copyright ownership.  The ASF licenses this file
- *   to you under the Apache License, Version 2.0 (the
- *   "License"); you may not use this file except in compliance
- *   with the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership.  The ASF
+ * licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
- *       http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
-import java.util.Date;
-import java.util.NavigableMap;
-import java.util.TreeMap;
-
-import org.apache.hadoop.yarn.server.resourcemanager.reservation.exceptions.ResourceOverCommitException;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
- * 
+ *
- * 
+ *
-public class CapacityOverTimePolicy implements SharingPolicy {
+public class CapacityOverTimePolicy extends NoOverCommitPolicy {
-  };
+  }
+  /**
+   * The validation algorithm walks over the RLE encoded allocation and
+   * checks that for all transition points (when the start or end of the
+   * checking window encounters a value in the RLE). At this point it
+   * checkes whether the integral computed exceeds the quota limit. Note that
+   * this might not find the exact time of a violation, but if a violation
+   * exists it will find it. The advantage is a much lower number of checks
+   * as compared to time-slot by time-slot checks.
+   *
+   * @param plan the plan to validate against
+   * @param reservation the reservation allocation to test.
+   * @throws PlanningException if the validation fails.
+   */
-    // this is entire method invoked under a write-lock on the plan, no need
-    // to synchronize accesses to the plan further
-    // Try to verify whether there is already a reservation with this ID in
-    // the system (remove its contribution during validation to simulate a
-    // try-n-swap
-    // update).
-    ReservationAllocation oldReservation =
+    // rely on NoOverCommitPolicy to check for: 1) user-match, 2) physical
+    // cluster limits, and 3) maxInst (via override of available)
+    try {
+      super.validate(plan, reservation);
+    } catch (PlanningException p) {
+      //wrap it in proper quota exception
+      throw new PlanningQuotaException(p);
+    }
+
+    //---- check for integral violations of capacity --------
+
+    // Gather a view of what to check (curr allocation of user, minus old
+    // version of this reservation, plus new version)
+    RLESparseResourceAllocation consumptionForUserOverTime =
+        plan.getConsumptionForUserOverTime(reservation.getUser(),
+            reservation.getStartTime() - validWindow,
+            reservation.getEndTime() + validWindow);
+
+    ReservationAllocation old =
+    if (old != null) {
+      consumptionForUserOverTime = RLESparseResourceAllocation
+          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),
+              consumptionForUserOverTime, old.getResourcesOverTime(),
+              RLEOperator.add, reservation.getStartTime() - validWindow,
+              reservation.getEndTime() + validWindow);
+    }
-    long startTime = reservation.getStartTime();
-    long endTime = reservation.getEndTime();
-    long step = plan.getStep();
+    RLESparseResourceAllocation resRLE = reservation.getResourcesOverTime();
-    Resource planTotalCapacity = plan.getTotalCapacity();
+    RLESparseResourceAllocation toCheck = RLESparseResourceAllocation
+        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),
+            consumptionForUserOverTime, resRLE, RLEOperator.add, Long.MIN_VALUE,
+            Long.MAX_VALUE);
-    Resource maxAvgRes = Resources.multiply(planTotalCapacity, maxAvg);
-    Resource maxInsRes = Resources.multiply(planTotalCapacity, maxInst);
+    NavigableMap<Long, Resource> integralUp = new TreeMap<>();
+    NavigableMap<Long, Resource> integralDown = new TreeMap<>();
-    // define variable that will store integral of resources (need diff class to
-    // avoid overflow issues for long/large allocations)
+    long prevTime = toCheck.getEarliestStartTime();
+    IntegralResource prevResource = new IntegralResource(0L, 0L);
-    IntegralResource maxAllowed = new IntegralResource(maxAvgRes);
-    maxAllowed.multiplyBy(validWindow / step);
-    RLESparseResourceAllocation userCons =
-        plan.getConsumptionForUserOverTime(reservation.getUser(), startTime
-            - validWindow, endTime + validWindow);
+    // add intermediate points
+    Map<Long, Resource> temp = new TreeMap<>();
+    for (Map.Entry<Long, Resource> pointToCheck : toCheck.getCumulative()
+        .entrySet()) {
-    // check that the resources offered to the user during any window of length
-    // "validWindow" overlapping this allocation are within maxAllowed
-    // also enforce instantaneous and physical constraints during this pass
-    for (long t = startTime - validWindow; t < endTime + validWindow; t += step) {
+      Long timeToCheck = pointToCheck.getKey();
+      Resource resourceToCheck = pointToCheck.getValue();
-      Resource currExistingAllocTot = plan.getTotalCommittedResources(t);
-      Resource currExistingAllocForUser = userCons.getCapacityAtTime(t);
-      Resource currNewAlloc = reservation.getResourcesAtTime(t);
-      Resource currOldAlloc = Resources.none();
-      if (oldReservation != null) {
-        currOldAlloc = oldReservation.getResourcesAtTime(t);
+      Long nextPoint = toCheck.getCumulative().higherKey(timeToCheck);
+      if (nextPoint == null || toCheck.getCumulative().get(nextPoint) == null) {
+        continue;
-
-      // throw exception if the cluster is overcommitted
-      // tot_allocated - old + new > capacity
-      Resource inst =
-          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),
-              currOldAlloc);
-      if (Resources.greaterThan(plan.getResourceCalculator(),
-          planTotalCapacity, inst, planTotalCapacity)) {
-        throw new ResourceOverCommitException(" Resources at time " + t
-            + " would be overcommitted (" + inst + " over "
-            + plan.getTotalCapacity() + ") by accepting reservation: "
-            + reservation.getReservationId());
-      }
-
-      // throw exception if instantaneous limits are violated
-      // tot_alloc_to_this_user - old + new > inst_limit
-      if (Resources.greaterThan(plan.getResourceCalculator(),
-          planTotalCapacity, Resources.subtract(
-              Resources.add(currExistingAllocForUser, currNewAlloc),
-              currOldAlloc), maxInsRes)) {
-        throw new PlanningQuotaException("Instantaneous quota capacity "
-            + maxInst + " would be passed at time " + t
-            + " by accepting reservation: " + reservation.getReservationId());
-      }
-
-      // throw exception if the running integral of utilization over validWindow
-      // is violated. We perform a delta check, adding/removing instants at the
-      // boundary of the window from runningTot.
-
-      // runningTot = previous_runningTot + currExistingAllocForUser +
-      // currNewAlloc - currOldAlloc - pastNewAlloc - pastOldAlloc;
-
-      // Where:
-      // 1) currNewAlloc, currExistingAllocForUser represent the contribution of
-      // the instant in time added in this pass.
-      // 2) pastNewAlloc, pastOldAlloc are the contributions relative to time
-      // instants that are being retired from the the window
-      // 3) currOldAlloc is the contribution (if any) of the previous version of
-      // this reservation (the one we are updating)
-
-      runningTot.add(currExistingAllocForUser);
-      runningTot.add(currNewAlloc);
-      runningTot.subtract(currOldAlloc);
-
-      // expire contributions from instant in time before (t - validWindow)
-      if (t > startTime) {
-        Resource pastOldAlloc = userCons.getCapacityAtTime(t - validWindow);
-        Resource pastNewAlloc = reservation.getResourcesAtTime(t - validWindow);
-
-        // runningTot = runningTot - pastExistingAlloc - pastNewAlloc;
-        runningTot.subtract(pastOldAlloc);
-        runningTot.subtract(pastNewAlloc);
-      }
-
-      // check integral
-      // runningTot > maxAvg * validWindow
-      // NOTE: we need to use comparator of IntegralResource directly, as
-      // Resource and ResourceCalculator assume "int" amount of resources,
-      // which is not sufficient when comparing integrals (out-of-bound)
-      if (maxAllowed.compareTo(runningTot) < 0) {
-        throw new PlanningQuotaException(
-            "Integral (avg over time) quota capacity " + maxAvg
-                + " over a window of " + validWindow / 1000 + " seconds, "
-                + " would be passed at time " + t + "(" + new Date(t)
-                + ") by accepting reservation: "
-                + reservation.getReservationId());
+      for (int i = 1; i <= (nextPoint - timeToCheck) / validWindow; i++) {
+        temp.put(timeToCheck + (i * validWindow), resourceToCheck);
+    temp.putAll(toCheck.getCumulative());
+
+    // compute point-wise integral for the up-fronts and down-fronts
+    for (Map.Entry<Long, Resource> currPoint : temp.entrySet()) {
+
+      Long currTime = currPoint.getKey();
+      Resource currResource = currPoint.getValue();
+
+      //add to running total current contribution
+      prevResource.multiplyBy(currTime - prevTime);
+      runningTot.add(prevResource);
+      integralUp.put(currTime, normalizeToResource(runningTot, validWindow));
+      integralDown.put(currTime + validWindow,
+          normalizeToResource(runningTot, validWindow));
+
+      if (currResource != null) {
+        prevResource.memory = currResource.getMemorySize();
+        prevResource.vcores = currResource.getVirtualCores();
+      } else {
+        prevResource.memory = 0L;
+        prevResource.vcores = 0L;
+      }
+      prevTime = currTime;
+    }
+
+    // compute final integral as delta of up minus down transitions
+    RLESparseResourceAllocation intUp =
+        new RLESparseResourceAllocation(integralUp,
+            plan.getResourceCalculator());
+    RLESparseResourceAllocation intDown =
+        new RLESparseResourceAllocation(integralDown,
+            plan.getResourceCalculator());
+
+    RLESparseResourceAllocation integral = RLESparseResourceAllocation
+        .merge(plan.getResourceCalculator(), plan.getTotalCapacity(), intUp,
+            intDown, RLEOperator.subtract, Long.MIN_VALUE, Long.MAX_VALUE);
+
+    // define over-time integral limit
+    // note: this is aligned with the normalization done above
+    NavigableMap<Long, Resource> tlimit = new TreeMap<>();
+    Resource maxAvgRes = Resources.multiply(plan.getTotalCapacity(), maxAvg);
+    tlimit.put(toCheck.getEarliestStartTime() - validWindow, maxAvgRes);
+    RLESparseResourceAllocation targetLimit =
+        new RLESparseResourceAllocation(tlimit, plan.getResourceCalculator());
+
+    // compare using merge() limit with integral
+    try {
+      RLESparseResourceAllocation
+          .merge(plan.getResourceCalculator(), plan.getTotalCapacity(),
+              targetLimit, integral, RLEOperator.subtractTestNonNegative,
+              reservation.getStartTime() - validWindow,
+              reservation.getEndTime() + validWindow);
+    } catch (PlanningException p) {
+      throw new PlanningQuotaException(
+          "Integral (avg over time) quota capacity " + maxAvg
+              + " over a window of " + validWindow / 1000 + " seconds, "
+              + " would be exceeded by accepting reservation: " + reservation
+              .getReservationId(), p);
+    }
+  }
+
+  private Resource normalizeToResource(IntegralResource runningTot,
+      long window) {
+    // normalize to fit in windows. Rounding should not impact more than
+    // sub 1 core average allocations. This will all be removed once
+    // Resource moves to long.
+    int memory = (int) Math.round((double) runningTot.memory / window);
+    int vcores = (int) Math.round((double) runningTot.vcores / window);
+    return Resource.newInstance(memory, vcores);
-      used =
-          RLESparseResourceAllocation.merge(plan.getResourceCalculator(),
-              Resources.clone(plan.getTotalCapacity()), used,
-              old.getResourcesOverTime(), RLEOperator.subtract, start, end);
+      used = RLESparseResourceAllocation.merge(plan.getResourceCalculator(),
+          Resources.clone(plan.getTotalCapacity()), used,
+          old.getResourcesOverTime(), RLEOperator.subtract, start, end);
-    instRLEQuota =
-        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),
-            planTotalCapacity, instRLEQuota, used, RLEOperator.subtract, start,
-            end);
+    instRLEQuota = RLESparseResourceAllocation
+        .merge(plan.getResourceCalculator(), planTotalCapacity, instRLEQuota,
+            used, RLEOperator.subtract, start, end);
-    instRLEQuota =
-        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),
-            planTotalCapacity, available, instRLEQuota, RLEOperator.min, start,
-            end);
+    instRLEQuota = RLESparseResourceAllocation
+        .merge(plan.getResourceCalculator(), planTotalCapacity, available,
+            instRLEQuota, RLEOperator.min, start, end);
+    public void add(IntegralResource r) {
+      memory += r.memory;
+      vcores += r.vcores;
+    }
+
+    public IntegralResource negate() {
+      return new IntegralResource(-memory, -vcores);
+    }
+
+
-
-

MOV26 MOV26 MOV26 UPD40 UPD43 INS31 INS31 UPD42 INS29 MOV78 MOV83 MOV39 MOV42 MOV44 MOV44 MOV43 INS8 INS83 MOV43 INS42 INS44 INS44 INS8 INS31 INS31 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 INS65 INS65 INS65 INS54 MOV60 MOV60 INS25 MOV60 INS60 INS60 INS60 MOV60 MOV60 MOV60 INS60 INS70 INS21 INS70 INS60 INS60 INS60 INS60 INS60 INS21 INS60 INS54 INS43 INS42 INS39 INS42 MOV60 INS60 INS41 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS8 INS12 MOV43 INS27 INS8 INS43 INS43 INS59 INS74 INS59 INS74 INS59 MOV43 INS74 INS59 INS44 INS32 INS8 INS32 INS44 INS32 INS8 INS43 INS59 INS43 INS59 INS43 INS59 INS74 INS59 MOV43 INS59 INS32 INS43 INS59 INS8 INS12 INS42 INS39 INS39 INS59 INS32 INS43 INS42 INS21 INS21 INS42 INS41 INS21 INS44 INS8 UPD42 INS32 UPD42 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS43 MOV43 INS42 INS14 INS43 INS43 MOV43 INS42 INS14 UPD42 UPD42 INS43 INS43 MOV43 INS42 INS14 INS74 INS42 INS32 INS42 MOV60 MOV60 MOV60 INS25 INS24 INS42 INS42 INS32 INS74 INS42 INS42 INS42 MOV60 MOV60 INS21 INS21 INS21 INS21 MOV25 INS21 INS42 UPD42 MOV42 INS14 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS43 MOV43 INS42 INS14 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS42 INS14 INS21 INS44 MOV8 UPD42 INS11 INS42 INS11 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS7 INS7 INS14 INS48 INS43 INS42 INS53 INS42 INS42 MOV32 INS27 INS27 INS7 INS42 INS42 INS42 INS42 MOV32 MOV32 INS42 INS42 INS40 INS40 INS40 INS42 INS42 INS74 INS42 INS42 INS74 UPD42 UPD42 MOV43 INS34 INS34 INS42 INS42 INS74 INS43 INS43 MOV43 INS42 INS42 INS43 MOV43 INS43 INS27 INS8 INS58 INS27 INS37 INS8 INS42 INS42 INS43 INS43 MOV43 INS43 MOV43 INS32 INS32 INS32 INS32 INS8 INS7 INS43 INS42 INS32 INS43 INS42 INS32 INS42 INS42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS40 INS40 INS40 UPD42 MOV42 INS42 INS74 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS32 INS42 INS43 INS42 INS32 INS32 INS43 INS42 INS39 INS32 INS39 INS32 INS42 INS40 INS42 INS40 INS43 INS38 INS38 INS42 INS42 INS42 INS42 INS14 MOV32 INS42 MOV32 INS42 INS42 INS32 INS43 INS43 INS43 INS40 INS42 INS42 INS42 INS32 UPD42 INS42 UPD42 INS27 INS27 INS18 INS39 INS59 INS42 INS27 INS42 INS21 INS40 INS42 INS42 UPD42 UPD42 INS42 INS42 INS27 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS27 INS32 UPD42 INS21 INS21 INS21 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS40 INS27 INS27 INS42 UPD42 MOV42 UPD42 MOV42 UPD27 MOV27 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 MOV32 MOV32 INS42 INS32 INS40 INS27 INS27 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 UPD42 UPD42 INS42 INS33 INS32 INS33 UPD42 MOV42 INS34 INS36 MOV42 INS32 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS7 INS7 INS7 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS32 INS42 INS32 INS42 MOV27 INS42 INS11 UPD42 INS11 INS42 INS42 INS42 INS32 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS27 INS42 INS42 MOV27 INS42 INS40 INS40 INS32 INS40 INS34 INS40 INS34 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV32 INS39 INS40 INS39 INS40 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 INS36 UPD42 UPD42 INS42 INS42 UPD45 INS27 INS42 MOV42 DEL66 DEL40 DEL26 DEL39 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL27 DEL42 DEL43 DEL42 DEL14 DEL27 DEL45 DEL27 DEL27 DEL42 DEL32 DEL42 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL27 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL27 DEL59 DEL58 DEL42 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL7 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL32 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL32 DEL42 DEL32 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL45 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL32 DEL21 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL32 DEL34 DEL27 DEL25 DEL8 DEL24 DEL8 DEL31
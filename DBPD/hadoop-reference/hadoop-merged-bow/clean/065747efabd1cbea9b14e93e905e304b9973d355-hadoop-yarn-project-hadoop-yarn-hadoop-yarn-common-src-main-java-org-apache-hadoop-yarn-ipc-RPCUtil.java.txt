YARN-628. Fix the way YarnRemoteException is being unrolled to extract out the underlying exception. Contributed by Siddharth Seth.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483207 13f79535-47bb-0310-9956-ffa450edef68

-import java.lang.reflect.UndeclaredThrowableException;
+import java.lang.reflect.InvocationTargetException;
+  private static <T extends Throwable> T instantiateException(
+      Class<? extends T> cls, RemoteException re) throws RemoteException {
+    try {
+      Constructor<? extends T> cn = cls.getConstructor(String.class);
+      cn.setAccessible(true);
+      T ex = cn.newInstance(re.getMessage());
+      ex.initCause(re);
+      return ex;
+      // RemoteException contains useful information as against the
+      // java.lang.reflect exceptions.
+    } catch (NoSuchMethodException e) {
+      throw re;
+    } catch (IllegalArgumentException e) {
+      throw re;
+    } catch (SecurityException e) {
+      throw re;
+    } catch (InstantiationException e) {
+      throw re;
+    } catch (IllegalAccessException e) {
+      throw re;
+    } catch (InvocationTargetException e) {
+      throw re;
+    }
+  }
+
-   * Utility method that unwraps and throws appropriate exception.
+   * Utility method that unwraps and returns appropriate exceptions.
-   * @param se ServiceException
-   * @throws YarnRemoteException
-   * @throws UndeclaredThrowableException
+   * @param se
+   *          ServiceException
+   * @return An instance of the actual exception, which will be a subclass of
+   *         {@link YarnRemoteException} or {@link IOException}
-  public static YarnRemoteException unwrapAndThrowException(ServiceException se)
-      throws UndeclaredThrowableException {
-    if (se.getCause() instanceof RemoteException) {
-      try {
-        RemoteException re = (RemoteException) se.getCause();
-        Class<?> realClass = Class.forName(re.getClassName());
-        //YarnRemoteException is not rooted as IOException.
-        //Do the explicitly check if it is YarnRemoteException
-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {
-          Constructor<? extends YarnRemoteException> cn =
-              realClass.asSubclass(YarnRemoteException.class).getConstructor(
-                  String.class);
-          cn.setAccessible(true);
-          YarnRemoteException ex = cn.newInstance(re.getMessage());
-          ex.initCause(re);
-          return ex;
-        } else {
-          // TODO Fix in YARN-628.
-          throw new IOException((RemoteException) se.getCause());
-        }
-      } catch (IOException e1) {
-        throw new UndeclaredThrowableException(e1);
-      } catch (Exception ex) {
-        throw new UndeclaredThrowableException(
-            (RemoteException) se.getCause());
-      }
-    } else if (se.getCause() instanceof YarnRemoteException) {
-      return (YarnRemoteException) se.getCause();
-    } else if (se.getCause() instanceof UndeclaredThrowableException) {
-      throw (UndeclaredThrowableException) se.getCause();
+  public static Void unwrapAndThrowException(ServiceException se)
+      throws IOException, YarnRemoteException {
+    Throwable cause = se.getCause();
+    if (cause == null) {
+      // SE generated by the RPC layer itself.
+      throw new IOException(se);
-      throw new UndeclaredThrowableException(se);
+      if (cause instanceof RemoteException) {
+        RemoteException re = (RemoteException) cause;
+        Class<?> realClass = null;
+        try {
+          realClass = Class.forName(re.getClassName());
+        } catch (ClassNotFoundException cnf) {
+          // Assume this to be a new exception type added to YARN. This isn't
+          // absolutely correct since the RPC layer could add an exception as
+          // well.
+          throw instantiateException(YarnRemoteException.class, re);
+        }
+
+        if (YarnRemoteException.class.isAssignableFrom(realClass)) {
+          throw instantiateException(
+              realClass.asSubclass(YarnRemoteException.class), re);
+        } else if (IOException.class.isAssignableFrom(realClass)) {
+          throw instantiateException(realClass.asSubclass(IOException.class),
+              re);
+        } else {
+          throw re;
+        }
+        // RemoteException contains useful information as against the
+        // java.lang.reflect exceptions.
+
+      } else if (cause instanceof IOException) {
+        // RPC Client exception.
+        throw (IOException) cause;
+      } else {
+        // Should not be generated.
+        throw new IOException(se);
+      }

UPD40 INS31 MOV43 INS83 INS83 INS73 INS43 INS42 INS44 INS44 MOV43 INS8 INS43 UPD43 INS42 INS43 INS42 INS74 INS42 MOV43 INS42 INS54 INS65 INS42 UPD42 INS60 INS42 INS43 INS76 MOV8 INS12 INS12 INS12 INS12 INS12 INS12 UPD66 UPD66 INS66 INS65 INS66 INS65 INS43 INS59 INS27 INS8 INS8 INS42 INS43 INS44 INS8 INS44 INS8 INS44 INS8 INS44 INS8 INS44 INS8 INS44 INS8 MOV42 UPD42 MOV42 INS42 INS42 MOV32 INS42 INS33 INS53 INS25 INS42 UPD74 UPD43 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS14 MOV62 INS8 MOV25 UPD76 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS60 MOV60 INS54 INS25 UPD43 INS42 INS42 MOV57 MOV43 INS59 INS8 MOV12 MOV32 INS8 INS25 INS42 UPD43 UPD42 INS42 MOV11 INS33 INS21 INS53 INS32 INS8 INS8 UPD42 INS42 INS7 UPD43 UPD42 MOV32 MOV32 INS57 UPD42 MOV42 UPD42 MOV42 INS53 INS53 UPD43 INS42 UPD43 INS42 MOV32 UPD42 INS32 UPD42 INS42 MOV43 INS32 INS42 UPD42 UPD42 INS42 INS57 INS42 INS42 INS32 UPD42 MOV42 MOV43 INS42 INS42 INS57 INS43 UPD42 MOV42 DEL65 DEL65 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL11 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL32 DEL43 DEL62 DEL42 DEL32 DEL11 DEL41 DEL8 DEL25
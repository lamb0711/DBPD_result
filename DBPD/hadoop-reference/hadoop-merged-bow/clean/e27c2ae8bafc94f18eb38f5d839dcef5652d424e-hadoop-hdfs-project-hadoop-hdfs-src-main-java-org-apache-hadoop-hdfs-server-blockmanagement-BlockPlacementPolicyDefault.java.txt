HDFS-8647. Abstract BlockManager's rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)

-import org.apache.hadoop.hdfs.protocol.Block;
-import org.apache.hadoop.hdfs.protocol.LocatedBlock;
-  public BlockPlacementStatus verifyBlockPlacement(String srcPath,
-      LocatedBlock lBlk, int numberOfReplicas) {
-    DatanodeInfo[] locs = lBlk.getLocations();
+  public BlockPlacementStatus verifyBlockPlacement(DatanodeInfo[] locs,
+      int numberOfReplicas) {
-    int numRacks = clusterMap.getNumOfRacks();
-    if(numRacks <= 1) // only one rack
-      return new BlockPlacementStatusDefault(
-          Math.min(numRacks, numberOfReplicas), numRacks);
-    int minRacks = Math.min(2, numberOfReplicas);
+    if (!clusterMap.hasClusterEverBeenMultiRack()) {
+      // only one rack
+      return new BlockPlacementStatusDefault(1, 1);
+    }
+    int minRacks = 2;
+    minRacks = Math.min(minRacks, numberOfReplicas);
-
-  @Override
-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,
-      Block block, short replicationFactor,
-      Collection<DatanodeStorageInfo> first,
-      Collection<DatanodeStorageInfo> second,
+  /**
+   * Decide whether deleting the specified replica of the block still makes
+   * the block conform to the configured block placement policy.
+   * @param replicationFactor The required number of replicas for this block
+   * @param moreThanone The replica locations of this block that are present
+   *                    on more than one unique racks.
+   * @param exactlyOne Replica locations of this block that  are present
+   *                    on exactly one unique racks.
+   * @param excessTypes The excess {@link StorageType}s according to the
+   *                    {@link BlockStoragePolicy}.
+   *
+   * @return the replica that is the best candidate for deletion
+   */
+  @VisibleForTesting
+  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,
+      Collection<DatanodeStorageInfo> moreThanone, Collection<DatanodeStorageInfo> exactlyOne,
-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {
+    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {
+  @Override
+  public List<DatanodeStorageInfo> chooseReplicasToDelete(
+      Collection<DatanodeStorageInfo> candidates,
+      int expectedNumOfReplicas,
+      List<StorageType> excessTypes,
+      DatanodeDescriptor addedNode,
+      DatanodeDescriptor delNodeHint) {
+
+    List<DatanodeStorageInfo> excessReplicas = new ArrayList<>();
+
+    final Map<String, List<DatanodeStorageInfo>> rackMap = new HashMap<>();
+
+    final List<DatanodeStorageInfo> moreThanOne = new ArrayList<>();
+    final List<DatanodeStorageInfo> exactlyOne = new ArrayList<>();
+
+    // split nodes into two sets
+    // moreThanOne contains nodes on rack with more than one replica
+    // exactlyOne contains the remaining nodes
+    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);
+
+    // pick one node to delete that favors the delete hint
+    // otherwise pick one with least space from priSet if it is not empty
+    // otherwise one node with least space from remains
+    boolean firstOne = true;
+    final DatanodeStorageInfo delNodeHintStorage =
+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);
+    final DatanodeStorageInfo addedNodeStorage =
+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);
+
+    while (candidates.size() - expectedNumOfReplicas > excessReplicas.size()) {
+      final DatanodeStorageInfo cur;
+      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,
+          moreThanOne, excessTypes)) {
+        cur = delNodeHintStorage;
+      } else { // regular excessive replica removal
+        cur =
+            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,
+                excessTypes);
+      }
+      firstOne = false;
+
+      // adjust rackmap, moreThanOne, and exactlyOne
+      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);
+      excessReplicas.add(cur);
+    }
+    return excessReplicas;
+  }
+
+  /** Check if we can use delHint. */
+  @VisibleForTesting
+  static boolean useDelHint(boolean isFirst, DatanodeStorageInfo delHint,
+      DatanodeStorageInfo added, List<DatanodeStorageInfo> moreThan1Racks,
+      List<StorageType> excessTypes) {
+    if (!isFirst) {
+      return false; // only consider delHint for the first case
+    } else if (delHint == null) {
+      return false; // no delHint
+    } else if (!excessTypes.contains(delHint.getStorageType())) {
+      return false; // delHint storage type is not an excess type
+    } else {
+      // check if removing delHint reduces the number of racks
+      if (moreThan1Racks.contains(delHint)) {
+        return true; // delHint and some other nodes are under the same rack
+      } else if (added != null && !moreThan1Racks.contains(added)) {
+        return true; // the added node adds a new rack
+      }
+      return false; // removing delHint reduces the number of racks;
+    }
+  }
+

INS31 INS31 INS29 INS78 INS83 INS42 MOV78 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS29 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS8 MOV5 UPD42 INS25 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS42 UPD42 UPD42 INS43 INS43 INS74 INS42 INS39 INS42 INS74 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS60 INS60 INS21 INS60 INS60 INS60 INS61 INS41 INS65 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS74 INS42 INS25 INS38 INS8 INS7 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS42 INS74 INS59 INS83 INS74 INS59 INS83 INS74 INS59 INS83 INS74 INS59 INS32 INS39 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS27 INS8 INS42 INS66 INS42 INS42 INS43 INS43 INS43 INS43 INS38 INS8 INS25 INS32 INS41 UPD42 INS34 INS42 INS32 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS14 INS43 MOV43 INS74 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS32 INS60 INS25 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS41 INS27 INS8 INS25 UPD42 MOV42 UPD42 MOV42 INS14 MOV42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS74 INS42 INS43 INS43 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS83 INS43 INS59 INS32 INS8 INS8 INS7 INS32 INS32 INS9 INS42 INS33 INS41 INS38 INS8 INS8 MOV43 INS34 INS34 INS43 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS32 INS41 INS25 INS41 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS32 INS9 INS32 INS8 INS25 INS9 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS41 INS27 INS8 INS42 INS11 INS42 INS42 INS42 INS9 INS27 INS38 INS41 INS39 INS42 INS42 INS33 INS32 INS9 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL34 DEL27 DEL32 DEL42 DEL14 DEL41 DEL25 DEL39 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44
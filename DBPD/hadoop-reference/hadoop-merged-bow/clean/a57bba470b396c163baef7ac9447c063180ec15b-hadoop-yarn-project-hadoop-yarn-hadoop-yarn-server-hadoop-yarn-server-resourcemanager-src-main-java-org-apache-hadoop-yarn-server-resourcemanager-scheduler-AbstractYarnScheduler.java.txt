Merge branch 'trunk' into HADOOP-12756

+import java.util.concurrent.locks.ReentrantReadWriteLock;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
-    .LeafQueue;
-  protected RMContext rmContext;
+  protected volatile RMContext rmContext;
+  protected final ReentrantReadWriteLock.ReadLock readLock;
+
+  /*
+   * Use writeLock for any of operations below:
+   * - queue change (hierarchy / configuration / container allocation)
+   * - application(add/remove/allocate-container, but not include container
+   *   finish)
+   * - node (add/remove/change-resource/container-allocation, but not include
+   *   container finish)
+   */
+  protected final ReentrantReadWriteLock.WriteLock writeLock;
+
+    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+    readLock = lock.readLock();
+    writeLock = lock.writeLock();
+  /*
+   * YARN-3136 removed synchronized lock for this method for performance
+   * purposes
+   */
-    ContainerId amContainerId =
-        rmContext.getRMApps().get(appId).getCurrentAppAttempt()
-          .getMasterContainer().getId();
+    ContainerId amContainerId = rmContext.getRMApps().get(appId)
+        .getCurrentAppAttempt().getMasterContainer().getId();
-  protected synchronized void containerLaunchedOnNode(
+  protected void containerLaunchedOnNode(
-    // Get the application for the finished container
-    SchedulerApplicationAttempt application =
-        getCurrentAttemptForContainer(containerId);
-    if (application == null) {
-      LOG.info("Unknown application " + containerId.getApplicationAttemptId()
-          .getApplicationId() + " launched container " + containerId
-          + " on node: " + node);
-      this.rmContext.getDispatcher().getEventHandler()
-        .handle(new RMNodeCleanContainerEvent(node.getNodeID(), containerId));
-      return;
-    }
+    try {
+      readLock.lock();
+      // Get the application for the finished container
+      SchedulerApplicationAttempt application = getCurrentAttemptForContainer(
+          containerId);
+      if (application == null) {
+        LOG.info("Unknown application " + containerId.getApplicationAttemptId()
+            .getApplicationId() + " launched container " + containerId
+            + " on node: " + node);
+        this.rmContext.getDispatcher().getEventHandler().handle(
+            new RMNodeCleanContainerEvent(node.getNodeID(), containerId));
+        return;
+      }
-    application.containerLaunchedOnNode(containerId, node.getNodeID());
+      application.containerLaunchedOnNode(containerId, node.getNodeID());
+    } finally {
+      readLock.unlock();
+    }
+    /*
+     * No lock is required, as this method is protected by scheduler's writeLock
+     */
-    SchedulerApplicationAttempt application =
-        getCurrentAttemptForContainer(containerId);
+    SchedulerApplicationAttempt application = getCurrentAttemptForContainer(
+        containerId);
-      LOG.info("Unknown application "
-          + containerId.getApplicationAttemptId().getApplicationId()
-          + " increased container " + containerId + " on node: " + node);
-      this.rmContext.getDispatcher().getEventHandler()
-          .handle(new RMNodeCleanContainerEvent(node.getNodeID(), containerId));
+      LOG.info("Unknown application " + containerId.getApplicationAttemptId()
+          .getApplicationId() + " increased container " + containerId
+          + " on node: " + node);
+      this.rmContext.getDispatcher().getEventHandler().handle(
+          new RMNodeCleanContainerEvent(node.getNodeID(), containerId));
-    LeafQueue leafQueue = (LeafQueue) application.getQueue();
-    synchronized (leafQueue) {
-      RMContainer rmContainer = getRMContainer(containerId);
-      if (rmContainer == null) {
-        // Some unknown container sneaked into the system. Kill it.
-        this.rmContext.getDispatcher().getEventHandler()
-            .handle(new RMNodeCleanContainerEvent(
-                node.getNodeID(), containerId));
-        return;
-      }
-      rmContainer.handle(new RMContainerNMDoneChangeResourceEvent(
-          containerId, increasedContainerReportedByNM.getResource()));
+
+    RMContainer rmContainer = getRMContainer(containerId);
+    if (rmContainer == null) {
+      // Some unknown container sneaked into the system. Kill it.
+      this.rmContext.getDispatcher().getEventHandler().handle(
+          new RMNodeCleanContainerEvent(node.getNodeID(), containerId));
+      return;
+    rmContainer.handle(new RMContainerNMDoneChangeResourceEvent(containerId,
+        increasedContainerReportedByNM.getResource()));
-    SchedulerApplication<T> app =
-        applications.get(applicationAttemptId.getApplicationId());
+    SchedulerApplication<T> app = applications.get(
+        applicationAttemptId.getApplicationId());
-  public synchronized void recoverContainersOnNode(
+  public void recoverContainersOnNode(
-    if (!rmContext.isWorkPreservingRecoveryEnabled()
-        || containerReports == null
-        || (containerReports != null && containerReports.isEmpty())) {
-      return;
-    }
-
-    for (NMContainerStatus container : containerReports) {
-      ApplicationId appId =
-          container.getContainerId().getApplicationAttemptId().getApplicationId();
-      RMApp rmApp = rmContext.getRMApps().get(appId);
-      if (rmApp == null) {
-        LOG.error("Skip recovering container " + container
-            + " for unknown application.");
-        killOrphanContainerOnNode(nm, container);
-        continue;
+    try {
+      writeLock.lock();
+      if (!rmContext.isWorkPreservingRecoveryEnabled()
+          || containerReports == null || (containerReports != null
+          && containerReports.isEmpty())) {
+        return;
-      SchedulerApplication<T> schedulerApp = applications.get(appId);
-      if (schedulerApp == null) {
-        LOG.info("Skip recovering container  " + container
-            + " for unknown SchedulerApplication. Application current state is "
-            + rmApp.getState());
-        killOrphanContainerOnNode(nm, container);
-        continue;
-      }
-
-      LOG.info("Recovering container " + container);
-      SchedulerApplicationAttempt schedulerAttempt =
-          schedulerApp.getCurrentAppAttempt();
-
-      if (!rmApp.getApplicationSubmissionContext()
-        .getKeepContainersAcrossApplicationAttempts()) {
-        // Do not recover containers for stopped attempt or previous attempt.
-        if (schedulerAttempt.isStopped()
-            || !schedulerAttempt.getApplicationAttemptId().equals(
-              container.getContainerId().getApplicationAttemptId())) {
-          LOG.info("Skip recovering container " + container
-              + " for already stopped attempt.");
+      for (NMContainerStatus container : containerReports) {
+        ApplicationId appId =
+            container.getContainerId().getApplicationAttemptId()
+                .getApplicationId();
+        RMApp rmApp = rmContext.getRMApps().get(appId);
+        if (rmApp == null) {
+          LOG.error("Skip recovering container " + container
+              + " for unknown application.");
-      }
-      // create container
-      RMContainer rmContainer = recoverAndCreateContainer(container, nm);
-
-      // recover RMContainer
-      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),
-        container));
-
-      // recover scheduler node
-      SchedulerNode schedulerNode = nodeTracker.getNode(nm.getNodeID());
-      schedulerNode.recoverContainer(rmContainer);
-
-      // recover queue: update headroom etc.
-      Queue queue = schedulerAttempt.getQueue();
-      queue.recoverContainer(
-          getClusterResource(), schedulerAttempt, rmContainer);
-
-      // recover scheduler attempt
-      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);
-            
-      // set master container for the current running AMContainer for this
-      // attempt.
-      RMAppAttempt appAttempt = rmApp.getCurrentAppAttempt();
-      if (appAttempt != null) {
-        Container masterContainer = appAttempt.getMasterContainer();
-
-        // Mark current running AMContainer's RMContainer based on the master
-        // container ID stored in AppAttempt.
-        if (masterContainer != null
-            && masterContainer.getId().equals(rmContainer.getContainerId())) {
-          ((RMContainerImpl)rmContainer).setAMContainer(true);
+        SchedulerApplication<T> schedulerApp = applications.get(appId);
+        if (schedulerApp == null) {
+          LOG.info("Skip recovering container  " + container
+              + " for unknown SchedulerApplication. "
+              + "Application current state is " + rmApp.getState());
+          killOrphanContainerOnNode(nm, container);
+          continue;
-      }
-      synchronized (schedulerAttempt) {
-        Set<ContainerId> releases = schedulerAttempt.getPendingRelease();
-        if (releases.contains(container.getContainerId())) {
+        LOG.info("Recovering container " + container);
+        SchedulerApplicationAttempt schedulerAttempt =
+            schedulerApp.getCurrentAppAttempt();
+
+        if (!rmApp.getApplicationSubmissionContext()
+            .getKeepContainersAcrossApplicationAttempts()) {
+          // Do not recover containers for stopped attempt or previous attempt.
+          if (schedulerAttempt.isStopped() || !schedulerAttempt
+              .getApplicationAttemptId().equals(
+                  container.getContainerId().getApplicationAttemptId())) {
+            LOG.info("Skip recovering container " + container
+                + " for already stopped attempt.");
+            killOrphanContainerOnNode(nm, container);
+            continue;
+          }
+        }
+
+        // create container
+        RMContainer rmContainer = recoverAndCreateContainer(container, nm);
+
+        // recover RMContainer
+        rmContainer.handle(
+            new RMContainerRecoverEvent(container.getContainerId(), container));
+
+        // recover scheduler node
+        SchedulerNode schedulerNode = nodeTracker.getNode(nm.getNodeID());
+        schedulerNode.recoverContainer(rmContainer);
+
+        // recover queue: update headroom etc.
+        Queue queue = schedulerAttempt.getQueue();
+        queue.recoverContainer(getClusterResource(), schedulerAttempt,
+            rmContainer);
+
+        // recover scheduler attempt
+        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);
+
+        // set master container for the current running AMContainer for this
+        // attempt.
+        RMAppAttempt appAttempt = rmApp.getCurrentAppAttempt();
+        if (appAttempt != null) {
+          Container masterContainer = appAttempt.getMasterContainer();
+
+          // Mark current running AMContainer's RMContainer based on the master
+          // container ID stored in AppAttempt.
+          if (masterContainer != null && masterContainer.getId().equals(
+              rmContainer.getContainerId())) {
+            ((RMContainerImpl) rmContainer).setAMContainer(true);
+          }
+        }
+
+        if (schedulerAttempt.getPendingRelease().remove(
+            container.getContainerId())) {
-          rmContainer.handle(new RMContainerFinishedEvent(container
-            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(
-            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),
-            RMContainerEventType.RELEASED));
-          releases.remove(container.getContainerId());
+          rmContainer.handle(
+              new RMContainerFinishedEvent(container.getContainerId(),
+                  SchedulerUtils
+                      .createAbnormalContainerStatus(container.getContainerId(),
+                          SchedulerUtils.RELEASED_CONTAINER),
+                  RMContainerEventType.RELEASED));
+    } finally {
+      writeLock.unlock();
-        synchronized (attempt) {
-          for (ContainerId containerId : attempt.getPendingRelease()) {
-            RMAuditLogger.logFailure(app.getUser(),
-                AuditConstants.RELEASE_CONTAINER,
-                "Unauthorized access or invalid container", "Scheduler",
-                "Trying to release container not owned by app "
-                    + "or with invalid id.", attempt.getApplicationId(),
-                containerId, null);
-          }
-          attempt.getPendingRelease().clear();
+        for (ContainerId containerId : attempt.getPendingRelease()) {
+          RMAuditLogger.logFailure(app.getUser(),
+              AuditConstants.RELEASE_CONTAINER,
+              "Unauthorized access or invalid container", "Scheduler",
+              "Trying to release container not owned by app "
+                  + "or with invalid id.", attempt.getApplicationId(),
+              containerId, null);
+        attempt.getPendingRelease().clear();
-          synchronized (attempt) {
-            attempt.getPendingRelease().add(containerId);
-          }
+          attempt.getPendingRelease().add(containerId);
-  public synchronized void moveAllApps(String sourceQueue, String destQueue)
+  public void moveAllApps(String sourceQueue, String destQueue)
-    // check if destination queue is a valid leaf queue
-      getQueueInfo(destQueue, false, false);
-    } catch (IOException e) {
-      LOG.warn(e);
-      throw new YarnException(e);
-    }
-    // check if source queue is a valid
-    List<ApplicationAttemptId> apps = getAppsInQueue(sourceQueue);
-    if (apps == null) {
-      String errMsg = "The specified Queue: " + sourceQueue + " doesn't exist";
-      LOG.warn(errMsg);
-      throw new YarnException(errMsg);
-    }
-    // generate move events for each pending/running app
-    for (ApplicationAttemptId app : apps) {
-      SettableFuture<Object> future = SettableFuture.create();
-      this.rmContext
-          .getDispatcher()
-          .getEventHandler()
-          .handle(new RMAppMoveEvent(app.getApplicationId(), destQueue, future));
+      writeLock.lock();
+      // check if destination queue is a valid leaf queue
+      try {
+        getQueueInfo(destQueue, false, false);
+      } catch (IOException e) {
+        LOG.warn(e);
+        throw new YarnException(e);
+      }
+      // check if source queue is a valid
+      List<ApplicationAttemptId> apps = getAppsInQueue(sourceQueue);
+      if (apps == null) {
+        String errMsg =
+            "The specified Queue: " + sourceQueue + " doesn't exist";
+        LOG.warn(errMsg);
+        throw new YarnException(errMsg);
+      }
+      // generate move events for each pending/running app
+      for (ApplicationAttemptId app : apps) {
+        SettableFuture<Object> future = SettableFuture.create();
+        this.rmContext.getDispatcher().getEventHandler().handle(
+            new RMAppMoveEvent(app.getApplicationId(), destQueue, future));
+      }
+    } finally {
+      writeLock.unlock();
-  public synchronized void killAllAppsInQueue(String queueName)
+  public void killAllAppsInQueue(String queueName)
-    // check if queue is a valid
-    List<ApplicationAttemptId> apps = getAppsInQueue(queueName);
-    if (apps == null) {
-      String errMsg = "The specified Queue: " + queueName + " doesn't exist";
-      LOG.warn(errMsg);
-      throw new YarnException(errMsg);
-    }
-    // generate kill events for each pending/running app
-    for (ApplicationAttemptId app : apps) {
-      this.rmContext
-          .getDispatcher()
-          .getEventHandler()
-          .handle(new RMAppEvent(app.getApplicationId(), RMAppEventType.KILL,
-          "Application killed due to expiry of reservation queue " +
-          queueName + "."));
+    try {
+      writeLock.lock();
+      // check if queue is a valid
+      List<ApplicationAttemptId> apps = getAppsInQueue(queueName);
+      if (apps == null) {
+        String errMsg = "The specified Queue: " + queueName + " doesn't exist";
+        LOG.warn(errMsg);
+        throw new YarnException(errMsg);
+      }
+      // generate kill events for each pending/running app
+      for (ApplicationAttemptId app : apps) {
+        this.rmContext.getDispatcher().getEventHandler().handle(
+            new RMAppEvent(app.getApplicationId(), RMAppEventType.KILL,
+                "Application killed due to expiry of reservation queue "
+                    + queueName + "."));
+      }
+    } finally {
+      writeLock.unlock();
-  public synchronized void updateNodeResource(RMNode nm, 
+  public void updateNodeResource(RMNode nm,
-    SchedulerNode node = getSchedulerNode(nm.getNodeID());
-    Resource newResource = resourceOption.getResource();
-    Resource oldResource = node.getTotalResource();
-    if(!oldResource.equals(newResource)) {
-      // Notify NodeLabelsManager about this change
-      rmContext.getNodeLabelManager().updateNodeResource(nm.getNodeID(),
-          newResource);
-      
-      // Log resource change
-      LOG.info("Update resource on node: " + node.getNodeName()
-          + " from: " + oldResource + ", to: "
-          + newResource);
+    try {
+      writeLock.lock();
+      SchedulerNode node = getSchedulerNode(nm.getNodeID());
+      Resource newResource = resourceOption.getResource();
+      Resource oldResource = node.getTotalResource();
+      if (!oldResource.equals(newResource)) {
+        // Notify NodeLabelsManager about this change
+        rmContext.getNodeLabelManager().updateNodeResource(nm.getNodeID(),
+            newResource);
-      nodeTracker.removeNode(nm.getNodeID());
+        // Log resource change
+        LOG.info("Update resource on node: " + node.getNodeName() + " from: "
+            + oldResource + ", to: " + newResource);
-      // update resource to node
-      node.updateTotalResource(newResource);
+        nodeTracker.removeNode(nm.getNodeID());
-      nodeTracker.addNode((N) node);
-    } else {
-      // Log resource change
-      LOG.warn("Update resource on node: " + node.getNodeName() 
-          + " with the same resource: " + newResource);
+        // update resource to node
+        node.updateTotalResource(newResource);
+
+        nodeTracker.addNode((N) node);
+      } else{
+        // Log resource change
+        LOG.warn("Update resource on node: " + node.getNodeName()
+            + " with the same resource: " + newResource);
+      }
+    } finally {
+      writeLock.unlock();
-  public synchronized void setClusterMaxPriority(Configuration conf)
+  public void setClusterMaxPriority(Configuration conf)

MOV26 UPD40 INS23 INS23 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS8 MOV8 INS8 MOV8 MOV8 INS8 INS8 INS8 INS40 INS42 INS40 INS42 INS60 INS21 INS21 INS54 MOV60 MOV25 INS54 INS70 INS70 INS54 INS54 INS54 INS43 INS59 INS7 INS7 MOV8 INS8 MOV8 INS8 MOV44 MOV32 MOV8 MOV44 INS42 MOV8 MOV8 INS8 MOV8 INS8 MOV8 INS8 INS42 INS42 INS14 INS42 INS32 INS42 INS32 INS21 INS21 INS21 INS21 MOV60 INS25 MOV60 MOV21 INS21 INS21 INS21 INS21 INS21 INS21 INS43 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 MOV27 MOV8 MOV27 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV25 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 MOV27 MOV8 MOV8 MOV32 MOV21 UPD45 INS45 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL51 DEL8 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL8 DEL51 DEL42 DEL51 DEL25 DEL70 DEL8 DEL42 DEL51 DEL25 DEL42 DEL70 DEL8 DEL83 DEL83 DEL83 DEL83
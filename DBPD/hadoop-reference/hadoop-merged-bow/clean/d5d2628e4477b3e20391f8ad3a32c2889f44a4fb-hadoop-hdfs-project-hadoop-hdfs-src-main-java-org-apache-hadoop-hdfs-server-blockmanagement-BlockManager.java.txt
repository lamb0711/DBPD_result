Merge r1360400 through r1399945 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1399950 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.security.token.block.DataEncryptionKey;
-import org.apache.hadoop.hdfs.server.common.Util;
+import org.apache.hadoop.util.Time;
+  
+  // whether or not to issue block encryption keys.
+  final boolean encryptDataTransfer;
+
+  /**
+   * When running inside a Standby node, the node may receive block reports
+   * from datanodes before receiving the corresponding namespace edits from
+   * the active NameNode. Thus, it will postpone them for later processing,
+   * instead of marking the blocks as corrupt.
+   */
+  private boolean shouldPostponeBlocksFromFuture = false;
-    this.blocksInvalidateWorkPct = conf.getFloat(
-        DFSConfigKeys.DFS_NAMENODE_INVALIDATE_WORK_PCT_PER_ITERATION,
-        DFSConfigKeys.DFS_NAMENODE_INVALIDATE_WORK_PCT_PER_ITERATION_DEFAULT);
-    Preconditions.checkArgument(
-        (this.blocksInvalidateWorkPct > 0),
-        DFSConfigKeys.DFS_NAMENODE_INVALIDATE_WORK_PCT_PER_ITERATION +
-        " = '" + this.blocksInvalidateWorkPct + "' is invalid. " +
-        "It should be a positive, non-zero float value " +
-        "indicating a percentage.");
-    this.blocksReplWorkMultiplier = conf.getInt(
-        DFSConfigKeys.DFS_NAMENODE_REPLICATION_WORK_MULTIPLIER_PER_ITERATION,
-        DFSConfigKeys.DFS_NAMENODE_REPLICATION_WORK_MULTIPLIER_PER_ITERATION_DEFAULT);
-    Preconditions.checkArgument(
-        (this.blocksReplWorkMultiplier > 0),
-        DFSConfigKeys.DFS_NAMENODE_REPLICATION_WORK_MULTIPLIER_PER_ITERATION +
-        " = '" + this.blocksReplWorkMultiplier + "' is invalid. " +
-        "It should be a positive, non-zero integer value.");
+    this.blocksInvalidateWorkPct = DFSUtil.getInvalidateWorkPctPerIteration(conf);
+    this.blocksReplWorkMultiplier = DFSUtil.getReplWorkMultiplier(conf);
+    
+    this.encryptDataTransfer =
+        conf.getBoolean(DFSConfigKeys.DFS_ENCRYPT_DATA_TRANSFER_KEY,
+            DFSConfigKeys.DFS_ENCRYPT_DATA_TRANSFER_DEFAULT);
+    
+    LOG.info("encryptDataTransfer        = " + encryptDataTransfer);
+    final String encryptionAlgorithm = conf.get(
+        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);
-        + "=" + lifetimeMin + " min(s)");
+        + "=" + lifetimeMin + " min(s), "
+        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY
+        + "=" + encryptionAlgorithm);
-          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) < 0 ? 0 : 1);
+          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) < 0 ? 0 : 1, null,
+          encryptionAlgorithm);
-          lifetimeMin*60*1000L, 0);
+          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);
+    }
+  }
+  
+  public void setBlockPoolId(String blockPoolId) {
+    if (isBlockTokenEnabled()) {
+      blockTokenSecretManager.setBlockPoolId(blockPoolId);
-    if (pendingReplications != null) pendingReplications.stop();
-    blocksMap.close();
+    try {
+      if (replicationThread != null) {
+        replicationThread.interrupt();
+        replicationThread.join(3000);
+      }
+    } catch (InterruptedException ie) {
+    }
-    if (replicationThread != null) replicationThread.interrupt();
+    pendingReplications.stop();
+    blocksMap.close();
+  
+  public DataEncryptionKey generateDataEncryptionKey() {
+    if (isBlockTokenEnabled() && encryptDataTransfer) {
+      return blockTokenSecretManager.generateDataEncryptionKey();
+    } else {
+      return null;
+    }
+  }
-    if (countNodes(b.stored).liveReplicas() >= bc.getReplication()) {
+    if (countNodes(b.stored).liveReplicas() >= bc.getBlockReplication()) {
+
+  public void setPostponeBlocksFromFuture(boolean postpone) {
+    this.shouldPostponeBlocksFromFuture  = postpone;
+  }
+
+
-            requiredReplication = bc.getReplication();
+            requiredReplication = bc.getBlockReplication();
-          requiredReplication = bc.getReplication();
+          requiredReplication = bc.getBlockReplication();
-    final DatanodeDescriptor targets[] = blockplacement.chooseTarget(
-        src, numOfReplicas, client, excludedNodes, blocksize);
+    final DatanodeDescriptor targets[] = blockplacement.chooseTarget(src,
+        numOfReplicas, client, new ArrayList<DatanodeDescriptor>(), false,
+        excludedNodes, blocksize);
-    final long startTime = Util.now(); //after acquiring write lock
+    final long startTime = Time.now(); //after acquiring write lock
-      endTime = Util.now();
+      endTime = Time.now();
-    boolean isStandby = namesystem.isInStandbyState();
-    
-      if (isStandby &&
+      if (shouldPostponeBlocksFromFuture &&
-        if (namesystem.isInStandbyState()) {
+        if (shouldPostponeBlocksFromFuture) {
-    if (namesystem.isInStandbyState() &&
+    if (shouldPostponeBlocksFromFuture &&
-      if (namesystem.isInStandbyState()) {
+      if (shouldPostponeBlocksFromFuture) {
-    assert namesystem.isInStandbyState();
+    assert shouldPostponeBlocksFromFuture;
-    assert !namesystem.isInStandbyState() :
-      "processAllPendingDNMessages() should be called after exiting " +
-      "standby state!";
+    assert !shouldPostponeBlocksFromFuture :
+      "processAllPendingDNMessages() should be called after disabling " +
+      "block postponement.";
-    short fileReplication = bc.getReplication();
+    short fileReplication = bc.getBlockReplication();
-    short expectedReplication = bc.getReplication();
+    short expectedReplication = bc.getBlockReplication();
-      short expectedReplication = bc.getReplication();
+      short expectedReplication = bc.getBlockReplication();
-    return bc.getReplication();
+    return bc.getBlockReplication();
+    final List<Block> toInvalidate;
+    final DatanodeDescriptor dn;
+    
-      return invalidateBlocks.invalidateWork(nodeId);
+      dn = datanodeManager.getDatanode(nodeId);
+      if (dn == null) {
+        invalidateBlocks.remove(nodeId);
+        return 0;
+      }
+      toInvalidate = invalidateBlocks.invalidateWork(nodeId, dn);
+      if (toInvalidate == null) {
+        return 0;
+      }
+    if (NameNode.stateChangeLog.isInfoEnabled()) {
+      NameNode.stateChangeLog.info("BLOCK* " + getClass().getSimpleName()
+          + ": ask " + dn + " to delete " + toInvalidate);
+    }
+    return toInvalidate.size();
-          terminate(1);
+          terminate(1, t);

MOV26 INS26 INS40 UPD40 INS23 INS23 INS31 INS31 INS31 INS83 INS39 INS59 INS29 INS83 INS39 INS59 MOV21 MOV21 INS83 INS39 INS42 INS44 INS8 MOV21 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS8 INS42 INS65 INS42 INS9 INS60 INS43 INS42 INS25 INS54 MOV21 INS42 INS25 INS39 INS42 INS21 INS60 INS60 MOV21 MOV54 INS25 INS41 INS66 INS66 INS66 INS66 INS7 INS83 INS43 INS59 INS42 INS32 INS8 INS8 INS12 INS27 INS8 INS8 INS7 INS42 INS83 INS74 INS59 INS83 INS43 INS59 INS32 INS8 INS32 MOV22 INS32 MOV22 INS32 INS22 UPD42 UPD42 INS42 INS42 INS32 INS42 INS21 MOV25 INS44 INS8 INS32 INS42 INS41 INS41 INS22 INS42 INS42 INS42 UPD45 UPD45 UPD42 INS43 INS43 INS42 INS42 INS42 INS21 INS25 INS21 INS25 INS40 INS42 INS21 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS52 INS42 UPD42 UPD40 UPD40 UPD45 INS42 INS42 INS42 INS40 UPD45 INS40 INS45 INS42 INS32 INS8 INS43 INS42 INS42 INS32 INS33 UPD42 INS52 INS42 INS14 INS9 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS7 INS27 INS8 INS7 INS27 INS8 INS32 INS33 INS42 INS33 INS42 INS42 INS42 INS42 MOV21 INS21 INS42 INS42 INS42 INS74 UPD42 INS42 INS32 INS42 INS33 INS21 INS41 INS42 INS32 INS42 INS33 INS41 INS40 INS42 INS27 INS32 INS43 INS43 UPD42 INS42 UPD42 INS42 INS42 INS42 INS32 INS34 MOV42 MOV42 MOV42 INS42 INS34 INS45 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 DEL52 DEL42 DEL22 DEL42 DEL40 DEL40 DEL32 DEL34 DEL27 DEL36 DEL40 DEL45 DEL52 DEL42 DEL22 DEL45 DEL45 DEL45 DEL27 DEL32 DEL52 DEL42 DEL22 DEL34 DEL27 DEL36 DEL40 DEL52 DEL42 DEL22 DEL45 DEL45 DEL42 DEL33 DEL27 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8
HADOOP-10852 Fix thread safety issues in NetgroupCache. (Benoy Antony)

+import java.util.Collections;
+import java.util.HashSet;
-import java.util.Map;
-import java.util.HashSet;
-  private static boolean netgroupToUsersMapUpdated = true;
-  private static Map<String, Set<String>> netgroupToUsersMap =
+  private static ConcurrentHashMap<String, Set<String>> userToNetgroupsMap =
-  private static Map<String, Set<String>> userToNetgroupsMap =
-    new ConcurrentHashMap<String, Set<String>>();
-
-
-    if(netgroupToUsersMapUpdated) {
-      netgroupToUsersMapUpdated = false; // at the beginning to avoid race
-      //update userToNetgroupsMap
-      for(String netgroup : netgroupToUsersMap.keySet()) {
-        for(String netuser : netgroupToUsersMap.get(netgroup)) {
-          // add to userToNetgroupsMap
-          if(!userToNetgroupsMap.containsKey(netuser)) {
-            userToNetgroupsMap.put(netuser, new HashSet<String>());
-          }
-          userToNetgroupsMap.get(netuser).add(netgroup);
-        }
-      }
-    }
-    if(userToNetgroupsMap.containsKey(user)) {
-      groups.addAll(userToNetgroupsMap.get(user));
+    Set<String> userGroups = userToNetgroupsMap.get(user);
+    //ConcurrentHashMap does not allow null values; 
+    //So null value check can be used to check if the key exists
+    if (userGroups != null) {
+      groups.addAll(userGroups);
-    return new LinkedList<String>(netgroupToUsersMap.keySet());
+    return new LinkedList<String>(getGroups());
+  }
+
+  private static Set<String> getGroups() {
+    Set<String> allGroups = new HashSet<String> ();
+    for (Set<String> userGroups : userToNetgroupsMap.values()) {
+      allGroups.addAll(userGroups);
+    }
+    return allGroups;
-    return netgroupToUsersMap.containsKey(group);
+    return getGroups().contains(group);
-    netgroupToUsersMap.clear();
-    netgroupToUsersMap.put(group, new HashSet<String>(users));
-    netgroupToUsersMapUpdated = true; // at the end to avoid race
+    for (String user : users) {
+      Set<String> userGroups = userToNetgroupsMap.get(user);
+      // ConcurrentHashMap does not allow null values; 
+      // So null value check can be used to check if the key exists
+      if (userGroups == null) {
+        //Generate a ConcurrentHashSet (backed by the keyset of the ConcurrentHashMap)
+        userGroups =
+            Collections.newSetFromMap(new ConcurrentHashMap<String,Boolean>());
+        Set<String> currentSet = userToNetgroupsMap.putIfAbsent(user, userGroups);
+        if (currentSet != null) {
+          userGroups = currentSet;
+        }
+      }
+      userGroups.add(group);
+    }

MOV26 MOV26 UPD40 INS31 INS31 INS31 MOV74 MOV29 INS83 INS83 INS39 INS42 MOV44 MOV44 INS8 INS83 INS83 MOV74 INS42 INS8 MOV29 INS83 INS83 INS39 INS42 MOV44 MOV44 INS8 INS60 INS25 INS60 INS70 INS41 INS70 MOV74 INS59 INS27 INS8 INS74 INS59 INS44 MOV32 INS8 INS42 MOV44 INS42 INS8 INS42 INS32 INS42 INS33 INS21 UPD43 MOV43 MOV43 UPD42 MOV42 MOV14 INS74 UPD42 MOV42 UPD42 UPD42 INS21 INS32 UPD42 UPD42 INS60 INS25 MOV21 INS42 INS42 INS42 INS32 UPD42 UPD42 INS43 INS43 INS32 UPD42 MOV42 INS74 INS59 INS27 INS8 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS43 INS42 MOV32 INS42 INS33 INS21 INS60 INS25 UPD42 UPD42 INS42 INS42 INS7 INS74 INS59 INS27 MOV8 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS33 INS42 UPD42 MOV42 INS14 INS42 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS7 INS74 INS42 INS42 INS43 MOV43 INS43 INS42 INS42 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL74 DEL14 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL74 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL9 DEL7 DEL21 DEL43 DEL44 DEL32 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL70 DEL8 DEL25 DEL32 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL74 DEL42 DEL14 DEL83 DEL83 DEL39 DEL42 DEL42 DEL9 DEL7 DEL21 DEL8 DEL31
YARN-5932. Retrospect moveApplicationToQueue in align with YARN-5611. Contributed by Sunil G.

-    switch(event.getType()) {
-      case APP_COMPLETED: 
-      {
-        finishApplication(applicationId);
-        logApplicationSummary(applicationId);
-        checkAppNumCompletedLimit(); 
-      } 
+    switch (event.getType()) {
+    case APP_COMPLETED :
+      finishApplication(applicationId);
+      logApplicationSummary(applicationId);
+      checkAppNumCompletedLimit();
-      default:
-        LOG.error("Invalid eventtype " + event.getType() + ". Ignoring!");
+    case APP_MOVE :
+      // moveAllApps from scheduler will fire this event for each of
+      // those applications which needed to be moved to a new queue.
+      // Use the standard move application api to do the same.
+      try {
+        moveApplicationAcrossQueue(applicationId,
+            event.getTargetQueueForMove());
+      } catch (YarnException e) {
+        LOG.warn("Move Application has failed: " + e.getMessage());
+      break;
+    default :
+      LOG.error("Invalid eventtype " + event.getType() + ". Ignoring!");
+    }
+
+  /**
+   * moveToQueue will invoke scheduler api to perform move queue operation.
+   *
+   * @param applicationId
+   *          Application Id.
+   * @param targetQueue
+   *          Target queue to which this app has to be moved.
+   * @throws YarnException
+   *           Handle exceptions.
+   */
+  public void moveApplicationAcrossQueue(ApplicationId applicationId, String targetQueue)
+      throws YarnException {
+    RMApp app = this.rmContext.getRMApps().get(applicationId);
+
+    // Capacity scheduler will directly follow below approach.
+    // 1. Do a pre-validate check to ensure that changes are fine.
+    // 2. Update this information to state-store
+    // 3. Perform real move operation and update in-memory data structures.
+    synchronized (applicationId) {
+      if (app.isAppInCompletedStates()) {
+        return;
+      }
+
+      String sourceQueue = app.getQueue();
+      // 1. pre-validate move application request to check for any access
+      // violations or other errors. If there are any violations, YarnException
+      // will be thrown.
+      rmContext.getScheduler().preValidateMoveApplication(applicationId,
+          targetQueue);
+
+      // 2. Update to state store with new queue and throw exception is failed.
+      updateAppDataToStateStore(targetQueue, app, false);
+
+      // 3. Perform the real move application
+      String queue = "";
+      try {
+        queue = rmContext.getScheduler().moveApplication(applicationId,
+            targetQueue);
+      } catch (YarnException e) {
+        // Revert to source queue since in-memory move has failed. Chances
+        // of this is very rare as we have already done the pre-validation.
+        updateAppDataToStateStore(sourceQueue, app, true);
+        throw e;
+      }
+
+      // update in-memory
+      if (queue != null && !queue.isEmpty()) {
+        app.setQueue(queue);
+      }
+    }
+
+    rmContext.getSystemMetricsPublisher().appUpdated(app,
+        System.currentTimeMillis());
+  }
+
+  private void updateAppDataToStateStore(String queue, RMApp app,
+      boolean toSuppressException) throws YarnException {
+    // Create a future object to capture exceptions from StateStore.
+    SettableFuture<Object> future = SettableFuture.create();
+
+    // Update new queue in Submission Context to update to StateStore.
+    app.getApplicationSubmissionContext().setQueue(queue);
+
+    ApplicationStateData appState = ApplicationStateData.newInstance(
+        app.getSubmitTime(), app.getStartTime(),
+        app.getApplicationSubmissionContext(), app.getUser(),
+        app.getCallerContext());
+    appState.setApplicationTimeouts(app.getApplicationTimeouts());
+    rmContext.getStateStore().updateApplicationStateSynchronously(appState,
+        false, future);
+
+    try {
+      Futures.get(future, YarnException.class);
+    } catch (YarnException ex) {
+      if (!toSuppressException) {
+        throw ex;
+      }
+      LOG.error("Statestore update failed for move application '"
+          + app.getApplicationId() + "' to queue '" + queue
+          + "' with below exception:" + ex.getMessage());
+    }
+  }

INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS51 INS21 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS21 INS60 INS21 INS21 INS54 MOV21 MOV21 MOV21 INS10 INS49 INS54 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS42 INS8 INS32 INS42 INS42 INS74 INS59 INS32 INS43 INS59 INS32 INS32 INS8 INS12 INS42 INS8 INS12 INS42 INS42 INS32 INS25 INS60 INS21 INS21 INS60 INS54 INS25 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS9 INS42 INS21 INS44 INS8 INS21 INS44 INS8 INS32 INS42 INS42 INS32 INS8 INS43 INS59 INS32 INS32 INS43 INS59 INS8 INS12 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS25 INS21 INS32 INS43 INS42 INS21 INS22 INS42 INS42 INS42 INS41 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS45 INS21 INS44 INS8 INS27 INS38 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS57 INS42 INS38 INS8 INS32 INS42 INS42 INS32 INS42 INS32 INS52 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS42 INS21 INS53 INS42 INS33 INS32 INS32 INS43 INS42 INS53 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL8
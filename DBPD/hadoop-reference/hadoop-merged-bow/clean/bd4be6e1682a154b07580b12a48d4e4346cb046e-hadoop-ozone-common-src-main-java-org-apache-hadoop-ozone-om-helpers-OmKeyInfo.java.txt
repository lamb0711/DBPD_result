HDDS-1895. Support Key ACL operations for OM HA. (#1230)


+import java.util.BitSet;
+import com.google.protobuf.ByteString;
+import static org.apache.hadoop.ozone.OzoneAcl.ZERO_BITSET;
+
+   * Add an ozoneAcl to list of existing Acl set.
+   * @param ozoneAcl
+   * @return true - if successfully added, false if not added or acl is
+   * already existing in the acl list.
+   */
+  public boolean addAcl(OzoneAclInfo ozoneAcl) {
+    // Case 1: When we are adding more rights to existing user/group.
+    boolean addToExistingAcl = false;
+    for(OzoneAclInfo existingAcl: getAcls()) {
+      if(existingAcl.getName().equals(ozoneAcl.getName()) &&
+          existingAcl.getType().equals(ozoneAcl.getType())) {
+
+        // We need to do "or" before comparision because think of a case like
+        // existing acl is 777 and newly added acl is 444, we have already
+        // that acl set. In this case if we do direct check they will not
+        // be equal, but if we do or and then check, we shall know it
+        // has acl's already set or not.
+        BitSet newAclBits = BitSet.valueOf(
+            existingAcl.getRights().toByteArray());
+
+        newAclBits.or(BitSet.valueOf(ozoneAcl.getRights().toByteArray()));
+
+        if (newAclBits.equals(BitSet.valueOf(
+            existingAcl.getRights().toByteArray()))) {
+          return false;
+        } else {
+          OzoneAclInfo newAcl = OzoneAclInfo.newBuilder()
+              .setType(ozoneAcl.getType())
+              .setName(ozoneAcl.getName())
+              .setAclScope(ozoneAcl.getAclScope())
+              .setRights(ByteString.copyFrom(newAclBits.toByteArray()))
+              .build();
+          getAcls().remove(existingAcl);
+          getAcls().add(newAcl);
+          addToExistingAcl = true;
+          break;
+        }
+      }
+    }
+
+    // Case 2: When a completely new acl is added.
+    if(!addToExistingAcl) {
+      getAcls().add(ozoneAcl);
+    }
+    return true;
+  }
+
+  /**
+   * Remove acl from existing acl list.
+   * @param ozoneAcl
+   * @return true - if successfully removed, false if not able to remove due
+   * to that acl is not in the existing acl list.
+   */
+  public boolean removeAcl(OzoneAclInfo ozoneAcl) {
+    boolean removed = false;
+
+    // When we are removing subset of rights from existing acl.
+    for(OzoneAclInfo existingAcl: getAcls()) {
+      if (existingAcl.getName().equals(ozoneAcl.getName()) &&
+          existingAcl.getType().equals(ozoneAcl.getType())) {
+
+        BitSet bits = BitSet.valueOf(ozoneAcl.getRights().toByteArray());
+        BitSet existingAclBits =
+            BitSet.valueOf(existingAcl.getRights().toByteArray());
+        bits.and(existingAclBits);
+
+        // This happens when the acl bitset asked to remove is not set for
+        // matched name and type.
+        // Like a case we have 444 permission, 333 is asked to removed.
+        if (bits.equals(ZERO_BITSET)) {
+          return false;
+        }
+
+        // We have some matching. Remove them.
+        bits.xor(existingAclBits);
+
+        // If existing acl has same bitset as passed acl bitset, remove that
+        // acl from the list
+        if (bits.equals(ZERO_BITSET)) {
+          getAcls().remove(existingAcl);
+        } else {
+          // Remove old acl and add new acl.
+          OzoneAclInfo newAcl = OzoneAclInfo.newBuilder()
+              .setType(ozoneAcl.getType())
+              .setName(ozoneAcl.getName())
+              .setAclScope(ozoneAcl.getAclScope())
+              .setRights(ByteString.copyFrom(bits.toByteArray()))
+              .build();
+          getAcls().remove(existingAcl);
+          getAcls().add(newAcl);
+        }
+        removed = true;
+        break;
+      }
+    }
+
+    return removed;
+  }
+
+  /**
+   * Reset the existing acl list.
+   * @param ozoneAcls
+   * @return true - if successfully able to reset.
+   */
+  public boolean setAcls(List<OzoneAclInfo> ozoneAcls) {
+    this.acls.clear();
+    this.acls = ozoneAcls;
+    return true;
+  }
+
+
+
+  /**
-      this.acls = listOfAcls;
+      this.acls = new ArrayList<>();
+      this.acls.addAll(listOfAcls);
-    return new OmKeyInfo(
-        keyInfo.getVolumeName(),
-        keyInfo.getBucketName(),
-        keyInfo.getKeyName(),
-        keyInfo.getKeyLocationListList().stream()
+    return new OmKeyInfo.Builder()
+        .setVolumeName(keyInfo.getVolumeName())
+        .setBucketName(keyInfo.getBucketName())
+        .setKeyName(keyInfo.getKeyName())
+        .setOmKeyLocationInfos(keyInfo.getKeyLocationListList().stream()
-            .collect(Collectors.toList()),
-        keyInfo.getDataSize(),
-        keyInfo.getCreationTime(),
-        keyInfo.getModificationTime(),
-        keyInfo.getType(),
-        keyInfo.getFactor(),
-        KeyValueUtil.getFromProtobuf(keyInfo.getMetadataList()),
-        keyInfo.hasFileEncryptionInfo() ? OMPBHelper.convert(keyInfo
-            .getFileEncryptionInfo()): null,
-        keyInfo.getAclsList());
+            .collect(Collectors.toList()))
+        .setDataSize(keyInfo.getDataSize())
+        .setCreationTime(keyInfo.getCreationTime())
+        .setModificationTime(keyInfo.getModificationTime())
+        .setReplicationType(keyInfo.getType())
+        .setReplicationFactor(keyInfo.getFactor())
+        .addAllMetadata(KeyValueUtil.getFromProtobuf(keyInfo.getMetadataList()))
+        .setFileEncryptionInfo(keyInfo.hasFileEncryptionInfo() ?
+            OMPBHelper.convert(keyInfo.getFileEncryptionInfo()): null)
+        .setAcls(keyInfo.getAclsList()).build();

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 MOV8 INS65 INS65 INS65 INS43 INS42 INS60 INS70 INS25 INS41 INS65 INS65 INS65 INS43 INS42 INS60 INS70 INS41 INS65 INS65 INS65 INS74 INS42 INS21 INS41 INS8 INS66 INS42 INS66 INS66 INS42 INS39 INS59 INS44 INS32 INS8 INS38 INS8 INS9 INS66 INS42 INS66 INS66 INS42 INS39 INS59 INS44 INS32 INS8 INS42 INS66 INS42 INS66 INS43 INS43 INS32 INS9 INS21 INS21 MOV41 INS32 INS42 INS9 INS43 INS42 INS42 INS25 INS42 INS21 INS42 INS9 INS43 INS42 INS42 INS25 INS42 INS42 INS22 INS42 UPD42 INS7 INS32 INS32 INS42 INS42 INS27 INS8 INS32 INS42 INS27 INS8 INS52 INS42 INS22 INS14 INS22 INS42 INS42 INS32 INS42 MOV32 INS32 INS32 INS60 INS21 INS25 INS32 INS42 INS42 INS32 INS32 INS60 INS60 INS21 INS25 INS21 INS25 INS21 INS10 INS52 INS42 INS74 INS52 INS42 INS32 INS42 MOV16 INS32 INS42 INS32 INS32 INS42 INS32 INS43 INS59 INS32 INS32 INS8 INS8 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS43 INS59 INS43 INS59 INS32 INS32 INS8 INS32 INS32 INS8 INS8 INS7 INS43 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS41 INS60 INS21 INS21 INS21 INS10 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS60 INS21 INS21 INS42 INS9 INS42 INS32 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS9 INS43 INS59 INS32 INS32 INS7 INS42 INS42 INS32 INS42 INS42 INS32 INS9 INS32 INS43 INS59 INS32 INS32 INS32 INS42 MOV32 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS9 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 MOV32 INS32 INS42 INS32 INS32 INS42 INS32 INS32 INS42 MOV32 INS32 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS32 INS32 INS42 MOV32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 MOV32 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 MOV32 UPD43 MOV43 INS40 DEL42 DEL14
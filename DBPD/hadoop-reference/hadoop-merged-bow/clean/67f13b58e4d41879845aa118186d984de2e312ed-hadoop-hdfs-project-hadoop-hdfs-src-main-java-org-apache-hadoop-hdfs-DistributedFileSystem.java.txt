HADOOP-10987. Provide an iterator-based listing API for FileSystem. Contributed by Kihwal Lee.

-    final Path absF = fixRelativePart(p);
-    return new RemoteIterator<LocatedFileStatus>() {
-      private DirectoryListing thisListing;
-      private int i;
-      private String src;
-      private LocatedFileStatus curStat = null;
-
-      { // initializer
-        // Fully resolve symlinks in path first to avoid additional resolution
-        // round-trips as we fetch more batches of listings
-        src = getPathName(resolvePath(absF));
-        // fetch the first batch of entries in the directory
-        thisListing = dfs.listPaths(src, HdfsFileStatus.EMPTY_NAME, true);
-        statistics.incrementReadOps(1);
-        if (thisListing == null) { // the directory does not exist
-          throw new FileNotFoundException("File " + p + " does not exist.");
-        }
+    Path absF = fixRelativePart(p);
+    return new FileSystemLinkResolver<RemoteIterator<LocatedFileStatus>>() {
+      @Override
+      public RemoteIterator<LocatedFileStatus> doCall(final Path p)
+          throws IOException, UnresolvedLinkException {
+        return new DirListingIterator<LocatedFileStatus>(p, filter, true);
-      public boolean hasNext() throws IOException {
-        while (curStat == null && hasNextNoFilter()) {
-          LocatedFileStatus next = 
-              ((HdfsLocatedFileStatus)thisListing.getPartialListing()[i++])
-              .makeQualifiedLocated(getUri(), absF);
-          if (filter.accept(next.getPath())) {
-            curStat = next;
-          }
+      public RemoteIterator<LocatedFileStatus> next(final FileSystem fs, final Path p)
+          throws IOException {
+        if (fs instanceof DistributedFileSystem) {
+          return ((DistributedFileSystem)fs).listLocatedStatus(p, filter);
-        return curStat != null;
+        // symlink resolution for this methos does not work cross file systems
+        // because it is a protected method.
+        throw new IOException("Link resolution does not work with multiple " +
+            "file systems for listLocatedStatus(): " + p);
+    }.resolve(this, absF);
+  }
+
+
+  /**
+   * Returns a remote iterator so that followup calls are made on demand
+   * while consuming the entries. This reduces memory consumption during
+   * listing of a large directory.
+   *
+   * @param p target path
+   * @return remote iterator
+   */
+  @Override
+  public RemoteIterator<FileStatus> listStatusIterator(final Path p)
+  throws IOException {
+    Path absF = fixRelativePart(p);
+    return new FileSystemLinkResolver<RemoteIterator<FileStatus>>() {
+      @Override
+      public RemoteIterator<FileStatus> doCall(final Path p)
+          throws IOException, UnresolvedLinkException {
+        return new DirListingIterator<FileStatus>(p, false);
+      }
+
+      @Override
+      public RemoteIterator<FileStatus> next(final FileSystem fs, final Path p)
+          throws IOException {
+          return ((DistributedFileSystem)fs).listStatusIterator(p);
+      }
+    }.resolve(this, absF);
+
+  }
+
+  /**
+   * This class defines an iterator that returns
+   * the file status of each file/subdirectory of a directory
+   * 
+   * if needLocation, status contains block location if it is a file
+   * throws a RuntimeException with the error as its cause.
+   * 
+   * @param <T> the type of the file status
+   */
+  private class  DirListingIterator<T extends FileStatus>
+  implements RemoteIterator<T> {
+    private DirectoryListing thisListing;
+    private int i;
+    private Path p;
+    private String src;
+    private T curStat = null;
+    private PathFilter filter;
+    private boolean needLocation;
+
+    private DirListingIterator(Path p, PathFilter filter,
+        boolean needLocation) throws IOException {
+      this.p = p;
+      this.src = getPathName(p);
+      this.filter = filter;
+      this.needLocation = needLocation;
+      // fetch the first batch of entries in the directory
+      thisListing = dfs.listPaths(src, HdfsFileStatus.EMPTY_NAME,
+          needLocation);
+      statistics.incrementReadOps(1);
+      if (thisListing == null) { // the directory does not exist
+        throw new FileNotFoundException("File " + p + " does not exist.");
+      }
+      i = 0;
+    }
+
+    private DirListingIterator(Path p, boolean needLocation)
+        throws IOException {
+      this(p, null, needLocation);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public boolean hasNext() throws IOException {
+      while (curStat == null && hasNextNoFilter()) {
+        T next;
+        HdfsFileStatus fileStat = thisListing.getPartialListing()[i++];
+        if (needLocation) {
+          next = (T)((HdfsLocatedFileStatus)fileStat)
+              .makeQualifiedLocated(getUri(), p);
+        } else {
+          next = (T)fileStat.makeQualified(getUri(), p);
+        }
+          // apply filter if not null
+        if (filter == null || filter.accept(next.getPath())) {
+          curStat = next;
+        }
+      }
+      return curStat != null;
+    }
-      /** Check if there is a next item before applying the given filter */
-      private boolean hasNextNoFilter() throws IOException {
+    /** Check if there is a next item before applying the given filter */
+    private boolean hasNextNoFilter() throws IOException {
+      if (thisListing == null) {
+        return false;
+      }
+      if (i >= thisListing.getPartialListing().length
+          && thisListing.hasMore()) { 
+        // current listing is exhausted & fetch a new listing
+        thisListing = dfs.listPaths(src, thisListing.getLastName(),
+            needLocation);
+        statistics.incrementReadOps(1);
-        if (i>=thisListing.getPartialListing().length
-            && thisListing.hasMore()) { 
-          // current listing is exhausted & fetch a new listing
-          thisListing = dfs.listPaths(src, thisListing.getLastName(), true);
-          statistics.incrementReadOps(1);
-          if (thisListing == null) {
-            return false;
-          }
-          i = 0;
-        }
-        return (i<thisListing.getPartialListing().length);
+        i = 0;
+      return (i < thisListing.getPartialListing().length);
+    }
-      @Override
-      public LocatedFileStatus next() throws IOException {
-        if (hasNext()) {
-          LocatedFileStatus tmp = curStat;
-          curStat = null;
-          return tmp;
-        } 
-        throw new java.util.NoSuchElementException("No more entry in " + p);
-      }
-    };
+    @Override
+    public T next() throws IOException {
+      if (hasNext()) {
+        T tmp = curStat;
+        curStat = null;
+        return tmp;
+      } 
+      throw new java.util.NoSuchElementException("No more entry in " + p);
+    }

INS31 INS31 INS55 MOV78 MOV83 MOV74 MOV42 MOV44 MOV44 INS43 INS8 INS29 INS78 INS83 INS74 INS42 INS44 INS43 INS8 INS29 INS83 INS42 INS73 INS74 MOV23 MOV23 INS23 MOV23 MOV23 INS23 INS23 INS31 INS31 MOV31 MOV31 MOV31 INS42 MOV60 INS41 INS65 INS65 INS65 INS42 INS43 INS43 INS83 INS43 INS42 INS42 INS60 INS41 INS65 INS65 INS42 INS43 INS43 INS43 INS83 MOV43 INS59 INS43 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS42 INS44 INS44 INS44 MOV43 INS8 INS83 INS42 INS44 INS44 INS43 INS8 INS79 UPD43 INS43 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS43 INS59 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS21 MOV21 INS21 INS21 MOV21 MOV21 MOV25 INS21 INS43 INS42 INS39 INS42 INS42 INS17 INS42 INS45 UPD42 INS42 INS14 INS42 INS52 INS42 INS42 INS42 INS32 INS14 INS42 INS52 INS42 INS42 INS42 INS7 INS7 INS7 INS7 INS42 INS42 INS33 INS42 INS74 INS1 INS42 INS42 INS74 INS1 INS22 INS42 INS22 INS22 INS42 INS22 INS42 INS42 INS34 INS60 INS25 INS43 INS74 INS31 INS31 INS43 INS74 INS31 INS31 INS52 INS42 INS52 INS42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS42 INS43 INS59 UPD43 INS42 INS8 INS8 INS27 UPD43 INS42 INS43 INS43 INS78 INS83 MOV74 INS42 INS44 INS43 INS43 INS8 INS78 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS42 INS43 INS43 INS78 INS83 INS74 INS42 INS44 INS43 INS43 INS8 INS78 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS42 INS42 UPD42 UPD42 MOV2 INS21 INS21 INS27 MOV32 UPD42 INS42 INS42 INS42 INS83 INS43 INS42 INS42 INS42 INS41 INS42 INS43 INS43 INS83 INS43 INS42 INS83 INS43 INS42 INS42 INS25 INS53 INS42 INS42 INS42 INS43 INS43 INS83 INS43 INS42 INS42 INS42 INS41 INS42 INS43 INS43 INS83 INS43 INS42 INS83 INS43 INS42 INS42 INS41 INS7 INS7 INS42 INS33 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS62 INS8 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS11 INS42 INS11 INS74 INS42 INS42 INS9 INS42 INS43 INS41 INS43 INS27 INS74 INS42 INS9 INS36 INS42 INS42 INS43 INS32 INS43 INS32 INS43 MOV43 INS42 INS32 INS42 INS45 INS45 INS42 INS43 INS43 INS11 INS42 INS36 INS42 MOV32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS36 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS11 INS42 INS11 INS42 MOV43 INS42 INS43 INS42 INS42 DEL83 DEL42 DEL42 DEL32 DEL9 DEL11 DEL36 DEL42 DEL42 DEL32 DEL9 DEL8 DEL28 DEL1 DEL14 DEL41 DEL8 DEL31
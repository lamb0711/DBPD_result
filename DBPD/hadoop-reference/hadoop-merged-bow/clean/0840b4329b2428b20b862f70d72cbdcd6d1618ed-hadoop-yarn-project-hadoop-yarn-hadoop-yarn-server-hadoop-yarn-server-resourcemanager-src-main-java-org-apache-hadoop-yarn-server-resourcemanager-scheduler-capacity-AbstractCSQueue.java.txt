YARN-5756. Add state-machine implementation for scheduler queues. (Xuan Gong via wangda)

+import org.apache.hadoop.yarn.exceptions.YarnException;
-  volatile QueueState state;
+  private volatile QueueState state = null;
-      authorizer = YarnAuthorizationProvider.getInstance(csContext.getConf());
+      // initialized the queue state based on previous state, configured state
+      // and its parent state.
+      QueueState previous = getState();
+      QueueState configuredState = csContext.getConfiguration()
+          .getConfiguredState(getQueuePath());
+      QueueState parentState = (parent == null) ? null : parent.getState();
+      initializeQueueState(previous, configuredState, parentState);
-      initializeQueueState();
+      authorizer = YarnAuthorizationProvider.getInstance(csContext.getConf());
-  private void initializeQueueState() {
-    // inherit from parent if state not set, only do this when we are not root
-    if (parent != null) {
-      QueueState configuredState = csContext.getConfiguration()
-          .getConfiguredState(getQueuePath());
-      QueueState parentState = parent.getState();
-      if (configuredState == null) {
-        this.state = parentState;
-      } else if (configuredState == QueueState.RUNNING
-          && parentState == QueueState.STOPPED) {
-        throw new IllegalArgumentException(
-            "The parent queue:" + parent.getQueueName() + " state is STOPPED, "
-            + "child queue:" + queueName + " state cannot be RUNNING.");
+  private void initializeQueueState(QueueState previousState,
+      QueueState configuredState, QueueState parentState) {
+    // verify that we can not any value for State other than RUNNING/STOPPED
+    if (configuredState != null && configuredState != QueueState.RUNNING
+        && configuredState != QueueState.STOPPED) {
+      throw new IllegalArgumentException("Invalid queue state configuration."
+          + " We can only use RUNNING or STOPPED.");
+    }
+    // If we did not set state in configuration, use Running as default state
+    QueueState defaultState = QueueState.RUNNING;
+
+    if (previousState == null) {
+      // If current state of the queue is null, we would inherit the state
+      // from its parent. If this queue does not has parent, such as root queue,
+      // we would use the configured state.
+      if (parentState == null) {
+        updateQueueState((configuredState == null) ? defaultState
+            : configuredState);
-        this.state = configuredState;
+        if (configuredState == null) {
+          updateQueueState((parentState == QueueState.DRAINING) ?
+              QueueState.STOPPED : parentState);
+        } else if (configuredState == QueueState.RUNNING
+            && parentState != QueueState.RUNNING) {
+          throw new IllegalArgumentException(
+              "The parent queue:" + parent.getQueueName()
+              + " state is STOPPED, child queue:" + queueName
+              + " state cannot be RUNNING.");
+        } else {
+          updateQueueState(configuredState);
+        }
-      // if this is the root queue, get the state from the configuration.
-      // if the state is not set, use RUNNING as default state.
-      this.state = csContext.getConfiguration().getState(getQueuePath());
+      // when we get a refreshQueue request from AdminService,
+      if (previousState == QueueState.RUNNING) {
+        if (configuredState == QueueState.STOPPED) {
+          stopQueue();
+        }
+      } else {
+        if (configuredState == QueueState.RUNNING) {
+          try {
+            activeQueue();
+          } catch (YarnException ex) {
+            throw new IllegalArgumentException(ex.getMessage());
+          }
+        }
+      }
-    queueInfo.setQueueState(state);
+    queueInfo.setQueueState(getState());
+
+  @Override
+  public void updateQueueState(QueueState queueState) {
+    this.state = queueState;
+  }
+
+  @Override
+  public void activeQueue() throws YarnException {
+    try {
+      this.writeLock.lock();
+      if (getState() == QueueState.RUNNING) {
+        LOG.info("The specified queue:" + queueName
+            + " is already in the RUNNING state.");
+      } else if (getState() == QueueState.DRAINING) {
+        throw new YarnException(
+            "The queue:" + queueName + " is in the Stopping process. "
+            + "Please wait for the queue getting fully STOPPED.");
+      } else {
+        CSQueue parent = getParent();
+        if (parent == null || parent.getState() == QueueState.RUNNING) {
+          updateQueueState(QueueState.RUNNING);
+        } else {
+          throw new YarnException("The parent Queue:" + parent.getQueueName()
+              + " is not running. Please activate the parent queue first");
+        }
+      }
+    } finally {
+      this.writeLock.unlock();
+    }
+  }
+
+  protected void appFinished() {
+    try {
+      this.writeLock.lock();
+      if (getState() == QueueState.DRAINING) {
+        if (getNumApplications() == 0) {
+          updateQueueState(QueueState.STOPPED);
+        }
+      }
+    } finally {
+      this.writeLock.unlock();
+    }
+  }

INS26 INS40 INS31 INS31 INS31 INS31 INS83 MOV83 MOV39 MOV42 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS8 INS33 MOV43 INS42 INS43 INS42 INS43 INS42 INS25 INS60 INS25 INS42 INS43 INS42 INS21 INS42 INS42 INS54 INS54 MOV21 MOV42 INS42 INS27 INS8 INS43 INS59 INS27 INS8 INS8 INS42 INS7 INS8 INS8 INS8 INS8 INS60 MOV60 INS60 INS27 INS27 INS53 INS42 INS42 INS40 INS42 INS33 INS25 INS25 INS32 MOV22 INS42 INS21 INS25 INS21 INS21 INS25 INS21 INS43 INS59 INS43 INS59 INS27 INS27 INS42 INS40 INS14 INS27 INS8 INS8 INS27 INS8 INS8 UPD42 MOV42 INS32 INS27 INS8 INS25 INS32 INS32 INS27 INS8 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS16 INS42 INS42 INS42 INS42 INS33 INS42 INS40 MOV43 INS27 INS42 INS33 INS21 MOV25 INS42 INS40 INS25 INS25 INS22 UPD42 MOV42 INS32 INS40 INS21 INS27 INS8 INS8 INS22 INS42 INS22 INS42 INS32 INS40 INS25 INS22 INS42 INS42 INS36 INS33 MOV32 INS45 INS45 INS32 INS27 INS27 INS8 INS27 INS8 INS52 INS42 MOV42 INS32 INS32 INS40 INS53 INS60 INS25 INS52 INS42 INS52 INS42 INS42 INS27 INS8 INS52 INS42 INS27 INS42 UPD42 MOV42 INS16 INS42 INS33 INS42 INS40 INS21 INS42 INS40 INS54 INS42 INS42 INS27 INS42 INS14 INS43 INS59 INS27 INS8 INS8 INS32 INS34 INS21 INS42 INS33 INS36 INS42 INS42 INS32 UPD27 INS32 INS8 INS12 INS45 INS42 INS45 INS43 INS27 INS42 INS42 INS32 INS27 INS27 INS21 INS53 INS42 INS32 MOV27 INS42 INS16 UPD40 INS32 INS42 INS21 INS44 INS8 INS42 INS45 INS42 INS45 INS45 INS42 INS42 INS33 INS32 INS40 INS32 INS14 INS42 INS40 INS36 INS40 INS42 INS43 INS42 INS42 INS32 INS43 INS42 INS53 INS42 INS42 INS42 INS40 INS43 INS27 INS27 INS42 UPD45 INS42 INS42 INS14 INS42 INS45 INS32 INS45 INS42 INS40 INS43 INS32 INS42 UPD42 MOV42 INS42 INS42 INS42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL45 DEL52 DEL42 DEL22 DEL42 DEL7 DEL42 DEL33 DEL27 DEL42 DEL59 DEL60 DEL8 DEL42 DEL32 DEL32 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31
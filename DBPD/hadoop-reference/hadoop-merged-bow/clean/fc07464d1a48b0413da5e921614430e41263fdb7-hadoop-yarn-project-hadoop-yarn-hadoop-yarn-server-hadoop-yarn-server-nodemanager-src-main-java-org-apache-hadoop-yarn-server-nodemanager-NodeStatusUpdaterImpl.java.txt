YARN-2923. Support configuration based NodeLabelsProvider Service in Distributed Node Label Configuration Setup. (Naganarasimha G R)

-  private final NodeLabelsProvider nodeLabelsProvider;
-  private final boolean hasNodeLabelsProvider;
+  private NMNodeLabelsHandler nodeLabelsHandler;
-    this.nodeLabelsProvider = nodeLabelsProvider;
-    this.hasNodeLabelsProvider = (nodeLabelsProvider != null);
+    nodeLabelsHandler = createNMNodeLabelsHandler(nodeLabelsProvider);
-    Set<NodeLabel> nodeLabels = null;
-    if (hasNodeLabelsProvider) {
-      nodeLabels = nodeLabelsProvider.getNodeLabels();
-      nodeLabels =
-          (null == nodeLabels) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET
-              : nodeLabels;
-    }
+    Set<NodeLabel> nodeLabels = nodeLabelsHandler.getNodeLabelsForRegistration();
-    if (regNMResponse.getAreNodeLabelsAcceptedByRM()) {
-      successfullRegistrationMsg
-          .append(" and with following Node label(s) : {")
-          .append(StringUtils.join(",", nodeLabels)).append("}");
-    } else if (hasNodeLabelsProvider) {
-      //case where provider is set but RM did not accept the Node Labels
-      LOG.error(regNMResponse.getDiagnosticsMessage());
-    }
+    successfullRegistrationMsg.append(nodeLabelsHandler
+        .verifyRMRegistrationResponseForNodeLabels(regNMResponse));
-        Set<NodeLabel> lastUpdatedNodeLabelsToRM = null;
-        if (hasNodeLabelsProvider) {
-          lastUpdatedNodeLabelsToRM = nodeLabelsProvider.getNodeLabels();
-          lastUpdatedNodeLabelsToRM =
-              (null == lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET
-                  : lastUpdatedNodeLabelsToRM;
-        }
-            Set<NodeLabel> nodeLabelsForHeartbeat = null;
+            Set<NodeLabel> nodeLabelsForHeartbeat =
+                nodeLabelsHandler.getNodeLabelsForHeartbeat();
-            if (hasNodeLabelsProvider) {
-              nodeLabelsForHeartbeat = nodeLabelsProvider.getNodeLabels();
-              // if the provider returns null then consider empty labels are set
-              nodeLabelsForHeartbeat =
-                  (nodeLabelsForHeartbeat == null) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET
-                      : nodeLabelsForHeartbeat;
-              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,
-                  lastUpdatedNodeLabelsToRM)) {
-                // if nodelabels have not changed then no need to send
-                nodeLabelsForHeartbeat = null;
-              }
-            }
-
-              LOG
-                .warn("Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,"
-                    + " hence shutting down.");
+              LOG.warn("Recieved SHUTDOWN signal from Resourcemanager as part of"
+                  + " heartbeat, hence shutting down.");
-            if (response.getAreNodeLabelsAcceptedByRM()) {
-              lastUpdatedNodeLabelsToRM = nodeLabelsForHeartbeat;
-              LOG.info("Node Labels {"
-                  + StringUtils.join(",", nodeLabelsForHeartbeat)
-                  + "} were Accepted by RM ");
-            } else if (nodeLabelsForHeartbeat != null) {
-              // case where NodeLabelsProvider is set and updated labels were
-              // sent to RM and RM rejected the labels
-              LOG.error(response.getDiagnosticsMessage());
-            }
+            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);
-      /**
-       * Caller should take care of sending non null nodelabels for both
-       * arguments
-       * 
-       * @param nodeLabelsNew
-       * @param nodeLabelsOld
-       * @return if the New node labels are diff from the older one.
-       */
-      private boolean areNodeLabelsUpdated(Set<NodeLabel> nodeLabelsNew,
-          Set<NodeLabel> nodeLabelsOld) {
-        if (nodeLabelsNew.size() != nodeLabelsOld.size()
-            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {
-          return true;
-        }
-        return false;
-      }
-
+
+  private NMNodeLabelsHandler createNMNodeLabelsHandler(
+      NodeLabelsProvider nodeLabelsProvider) {
+    if (nodeLabelsProvider == null) {
+      return new NMCentralizedNodeLabelsHandler();
+    } else {
+      return new NMDistributedNodeLabelsHandler(nodeLabelsProvider);
+    }
+  }
+
+  private static interface NMNodeLabelsHandler {
+    /**
+     * validates nodeLabels From Provider and returns it to the caller. Also
+     * ensures that if provider returns null then empty label set is considered
+     */
+    Set<NodeLabel> getNodeLabelsForRegistration();
+
+    /**
+     * @return RMRegistration Success message and on failure will log
+     *         independently and returns empty string
+     */
+    String verifyRMRegistrationResponseForNodeLabels(
+        RegisterNodeManagerResponse regNMResponse);
+
+    /**
+     * If nodeLabels From Provider is different previous node labels then it
+     * will check the syntax correctness and throws exception if invalid. If
+     * valid, returns nodeLabels From Provider. Also ensures that if provider
+     * returns null then empty label set is considered and If labels are not
+     * modified it returns null.
+     */
+    Set<NodeLabel> getNodeLabelsForHeartbeat();
+
+    /**
+     * check whether if updated labels sent to RM was accepted or not
+     * @param response
+     */
+    void verifyRMHeartbeatResponseForNodeLabels(NodeHeartbeatResponse response);
+  }
+
+  /**
+   * In centralized configuration, NM need not send Node labels or process the
+   * response
+   */
+  private static class NMCentralizedNodeLabelsHandler
+      implements NMNodeLabelsHandler {
+    @Override
+    public Set<NodeLabel> getNodeLabelsForHeartbeat() {
+      return null;
+    }
+
+    @Override
+    public Set<NodeLabel> getNodeLabelsForRegistration() {
+      return null;
+    }
+
+    @Override
+    public void verifyRMHeartbeatResponseForNodeLabels(
+        NodeHeartbeatResponse response) {
+    }
+
+    @Override
+    public String verifyRMRegistrationResponseForNodeLabels(
+        RegisterNodeManagerResponse regNMResponse) {
+      return "";
+    }
+  }
+
+  private static class NMDistributedNodeLabelsHandler
+      implements NMNodeLabelsHandler {
+    private NMDistributedNodeLabelsHandler(
+        NodeLabelsProvider nodeLabelsProvider) {
+      this.nodeLabelsProvider = nodeLabelsProvider;
+    }
+
+    private final NodeLabelsProvider nodeLabelsProvider;
+    private Set<NodeLabel> previousNodeLabels;
+    private boolean updatedLabelsSentToRM;
+
+    @Override
+    public Set<NodeLabel> getNodeLabelsForRegistration() {
+      Set<NodeLabel> nodeLabels = nodeLabelsProvider.getNodeLabels();
+      nodeLabels = (null == nodeLabels)
+          ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET : nodeLabels;
+      previousNodeLabels = nodeLabels;
+      try {
+        validateNodeLabels(nodeLabels);
+      } catch (IOException e) {
+        nodeLabels = null;
+      }
+      return nodeLabels;
+    }
+
+    @Override
+    public String verifyRMRegistrationResponseForNodeLabels(
+        RegisterNodeManagerResponse regNMResponse) {
+      StringBuilder successfulNodeLabelsRegistrationMsg = new StringBuilder("");
+      if (regNMResponse.getAreNodeLabelsAcceptedByRM()) {
+        successfulNodeLabelsRegistrationMsg
+            .append(" and with following Node label(s) : {")
+            .append(StringUtils.join(",", previousNodeLabels)).append("}");
+      } else {
+        // case where provider is set but RM did not accept the Node Labels
+        LOG.error(regNMResponse.getDiagnosticsMessage());
+      }
+      return successfulNodeLabelsRegistrationMsg.toString();
+    }
+
+    @Override
+    public Set<NodeLabel> getNodeLabelsForHeartbeat() {
+      Set<NodeLabel> nodeLabelsForHeartbeat =
+          nodeLabelsProvider.getNodeLabels();
+      // if the provider returns null then consider empty labels are set
+      nodeLabelsForHeartbeat = (nodeLabelsForHeartbeat == null)
+          ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET
+          : nodeLabelsForHeartbeat;
+      // take some action only on modification of labels
+      boolean areNodeLabelsUpdated =
+          nodeLabelsForHeartbeat.size() != previousNodeLabels.size()
+              || !previousNodeLabels.containsAll(nodeLabelsForHeartbeat);
+
+      updatedLabelsSentToRM = false;
+      if (areNodeLabelsUpdated) {
+        previousNodeLabels = nodeLabelsForHeartbeat;
+        try {
+          validateNodeLabels(nodeLabelsForHeartbeat);
+          updatedLabelsSentToRM = true;
+        } catch (IOException e) {
+          // set previous node labels to invalid set, so that invalid
+          // labels are not verified for every HB, and send empty set
+          // to RM to have same nodeLabels which was earlier set.
+          nodeLabelsForHeartbeat = null;
+        }
+      } else {
+        // if nodelabels have not changed then no need to send
+        nodeLabelsForHeartbeat = null;
+      }
+      return nodeLabelsForHeartbeat;
+    }
+
+    private void validateNodeLabels(Set<NodeLabel> nodeLabelsForHeartbeat)
+        throws IOException {
+      Iterator<NodeLabel> iterator = nodeLabelsForHeartbeat.iterator();
+      boolean hasInvalidLabel = false;
+      StringBuilder errorMsg = new StringBuilder("");
+      while (iterator.hasNext()) {
+        try {
+          CommonNodeLabelsManager
+              .checkAndThrowLabelName(iterator.next().getName());
+        } catch (IOException e) {
+          errorMsg.append(e.getMessage());
+          errorMsg.append(" , ");
+          hasInvalidLabel = true;
+        }
+      }
+      if (hasInvalidLabel) {
+        LOG.error("Invalid Node Label(s) from Provider : " + errorMsg);
+        throw new IOException(errorMsg.toString());
+      }
+    }
+
+    @Override
+    public void verifyRMHeartbeatResponseForNodeLabels(
+        NodeHeartbeatResponse response) {
+      if (updatedLabelsSentToRM) {
+        if (response.getAreNodeLabelsAcceptedByRM()) {
+          LOG.info("Node Labels {" + StringUtils.join(",", previousNodeLabels)
+              + "} were Accepted by RM ");
+        } else {
+          // case where updated labels from NodeLabelsProvider is sent to RM and
+          // RM rejected the labels
+          LOG.error(
+              "NM node labels {" + StringUtils.join(",", previousNodeLabels)
+                  + "} were not accepted by RM and message from RM : "
+                  + response.getDiagnosticsMessage());
+        }
+      }
+    }
+  }

INS23 INS31 INS55 INS55 INS55 MOV83 INS43 INS59 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS42 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS43 INS31 INS31 INS31 INS31 INS83 INS83 INS42 INS43 INS31 MOV23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS42 INS42 MOV21 INS42 INS43 INS42 INS25 INS29 INS74 INS42 INS29 INS43 INS42 INS44 INS29 INS74 INS42 INS29 INS39 INS42 INS44 INS65 INS42 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS8 INS42 INS83 INS42 INS44 INS8 INS83 INS74 INS59 INS83 MOV39 INS59 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS74 INS42 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS32 INS42 INS27 INS8 INS8 INS65 INS43 INS43 INS65 INS42 INS43 INS42 INS65 INS43 INS43 INS65 INS65 INS43 INS42 INS66 INS66 INS42 INS43 INS43 INS41 INS42 INS43 INS43 INS41 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS41 INS43 INS42 MOV21 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS60 MOV21 INS21 INS54 INS41 INS42 INS42 INS43 INS42 INS60 INS25 INS41 INS42 INS43 INS43 INS60 MOV21 INS60 INS21 INS25 INS41 MOV74 INS42 INS42 INS60 INS60 INS60 INS61 INS25 INS42 INS43 INS42 INS25 INS42 INS32 INS32 MOV42 MOV42 MOV32 INS42 INS33 INS41 INS41 INS66 INS66 INS42 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS66 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 MOV74 INS59 INS7 INS8 INS12 INS42 INS42 INS43 INS59 MOV32 INS8 MOV8 INS32 INS42 INS42 MOV74 INS59 INS39 INS59 INS7 INS42 INS8 INS8 INS42 INS74 INS59 INS39 INS59 INS43 INS59 INS32 INS8 INS42 INS8 INS42 INS42 INS8 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS14 INS14 INS42 MOV32 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS14 INS21 INS42 INS42 INS42 MOV32 INS42 INS27 INS42 INS9 INS21 INS54 INS21 INS43 INS43 INS42 INS32 INS42 INS9 INS42 INS42 INS14 INS42 INS42 INS54 INS21 INS53 INS25 INS43 INS43 INS42 INS32 INS43 INS42 INS21 INS43 INS45 INS32 INS27 INS38 INS7 INS8 INS12 INS7 INS42 INS42 INS42 INS42 INS43 INS45 INS8 INS12 INS32 INS14 MOV32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS32 INS42 INS45 INS32 INS32 INS32 INS42 INS42 INS21 INS21 INS44 MOV8 INS42 INS33 INS42 INS21 INS44 INS8 INS42 INS42 INS27 INS43 INS32 INS21 INS21 INS42 INS33 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS43 INS42 INS32 INS43 INS42 INS21 INS21 INS21 INS45 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS7 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS9 INS45 INS32 INS45 INS45 INS32 INS45 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 MOV60 MOV21 INS42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD45 UPD45 DEL83 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL36 DEL33 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL45 DEL45 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL8 DEL42 DEL25 DEL25 DEL42 DEL42 DEL7 DEL21 DEL42 DEL33 DEL42 DEL27 DEL36 DEL40 DEL42 DEL16 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL38 DEL25 DEL8 DEL25 DEL42 DEL45 DEL45 DEL42 DEL32 DEL45 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL66 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31
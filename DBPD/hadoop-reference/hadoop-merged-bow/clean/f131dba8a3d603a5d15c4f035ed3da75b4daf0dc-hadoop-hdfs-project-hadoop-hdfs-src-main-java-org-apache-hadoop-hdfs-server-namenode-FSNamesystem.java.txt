HDFS-6294. Use INode IDs to avoid conflicts when a file open for write is renamed (cmccabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593634 13f79535-47bb-0310-9956-ffa450edef68

-      final INode[] inodes = analyzeFileState(
-          src, fileId, clientName, previous, onRetryBlock).getINodes();
-      final INodeFile pendingFile = inodes[inodes.length - 1].asFile();
+      final INodeFile pendingFile = analyzeFileState(
+          src, fileId, clientName, previous, onRetryBlock);
+      src = pendingFile.getFullPathName();
-      INodesInPath inodesInPath =
+      final INodeFile pendingFile =
-      INode[] inodes = inodesInPath.getINodes();
-      final INodeFile pendingFile = inodes[inodes.length - 1].asFile();
+      INodesInPath inodesInPath = INodesInPath.fromINode(pendingFile);
-  INodesInPath analyzeFileState(String src,
+  INodeFile analyzeFileState(String src,
-    final INodesInPath iip = dir.getINodesInPath4Write(src);
-    final INodeFile pendingFile
-        = checkLease(src, fileId, clientName, iip.getLastINode());
+    INode inode;
+    if (fileId == INodeId.GRANDFATHER_INODE_ID) {
+      // Older clients may not have given us an inode ID to work with.
+      // In this case, we have to try to resolve the path and hope it
+      // hasn't changed or been deleted since the file was opened for write.
+      final INodesInPath iip = dir.getINodesInPath4Write(src);
+      inode = iip.getLastINode();
+    } else {
+      // Newer clients pass the inode ID, so we can just get the inode
+      // directly.
+      inode = dir.getInode(fileId);
+      if (inode != null) src = inode.getFullPathName();
+    }
+    final INodeFile pendingFile = checkLease(src, clientName, inode, fileId);
-        return iip;
+        return pendingFile;
-    return iip;
+    return pendingFile;
-  LocatedBlock getAdditionalDatanode(String src, final ExtendedBlock blk,
-      final DatanodeInfo[] existings, final String[] storageIDs,
+  LocatedBlock getAdditionalDatanode(String src, long fileId,
+      final ExtendedBlock blk, final DatanodeInfo[] existings,
+      final String[] storageIDs,
-      final INodeFile file = checkLease(src, clientName);
+      final INode inode;
+      if (fileId == INodeId.GRANDFATHER_INODE_ID) {
+        // Older clients may not have given us an inode ID to work with.
+        // In this case, we have to try to resolve the path and hope it
+        // hasn't changed or been deleted since the file was opened for write.
+        inode = dir.getINode(src);
+      } else {
+        inode = dir.getInode(fileId);
+        if (inode != null) src = inode.getFullPathName();
+      }
+      final INodeFile file = checkLease(src, clientName, inode, fileId);
-  boolean abandonBlock(ExtendedBlock b, String src, String holder)
+  boolean abandonBlock(ExtendedBlock b, long fileId, String src, String holder)
-      checkNameNodeSafeMode("Cannot abandon block " + b + " for fle" + src);
+      checkNameNodeSafeMode("Cannot abandon block " + b + " for file" + src);
+      final INode inode;
+      if (fileId == INodeId.GRANDFATHER_INODE_ID) {
+        // Older clients may not have given us an inode ID to work with.
+        // In this case, we have to try to resolve the path and hope it
+        // hasn't changed or been deleted since the file was opened for write.
+        inode = dir.getINode(src);
+      } else {
+        inode = dir.getInode(fileId);
+        if (inode != null) src = inode.getFullPathName();
+      }
+      final INodeFile file = checkLease(src, holder, inode, fileId);
+
-      INodeFile file = checkLease(src, holder);
-  
-  /** make sure that we still have the lease on this file. */
-  private INodeFile checkLease(String src, String holder)
-      throws LeaseExpiredException, UnresolvedLinkException,
-      FileNotFoundException {
-    return checkLease(src, INodeId.GRANDFATHER_INODE_ID, holder,
-        dir.getINode(src));
-  }
-  
-  private INodeFile checkLease(String src, long fileId, String holder,
-      INode inode) throws LeaseExpiredException, FileNotFoundException {
+
+  private INodeFile checkLease(String src, String holder, INode inode,
+                               long fileId)
+      throws LeaseExpiredException, FileNotFoundException {
-    if (inode == null || !inode.isFile()) {
+    final String ident = src + " (inode " + fileId + ")";
+    if (inode == null) {
-          "No lease on " + src + ": File does not exist. "
+          "No lease on " + ident + ": File does not exist. "
+    if (!inode.isFile()) {
+      Lease lease = leaseManager.getLease(holder);
+      throw new LeaseExpiredException(
+          "No lease on " + ident + ": INode is not a regular file. "
+              + (lease != null ? lease.toString()
+              : "Holder " + holder + " does not have any open files."));
+    }
-          "No lease on " + src + ": File is not open for writing. "
+          "No lease on " + ident + ": File is not open for writing. "
-      throw new LeaseExpiredException("Lease mismatch on " + src + " owned by "
-          + clientName + " but is accessed by " + holder);
+      throw new LeaseExpiredException("Lease mismatch on " + ident +
+          " owned by " + clientName + " but is accessed by " + holder);
-    INodeId.checkId(fileId, file);
-    final INodesInPath iip = dir.getLastINodeInPath(src);
-      pendingFile = checkLease(src, fileId, holder, iip.getINode(0));
+      final INode inode;
+      if (fileId == INodeId.GRANDFATHER_INODE_ID) {
+        // Older clients may not have given us an inode ID to work with.
+        // In this case, we have to try to resolve the path and hope it
+        // hasn't changed or been deleted since the file was opened for write.
+        final INodesInPath iip = dir.getLastINodeInPath(src);
+        inode = iip.getINode(0);
+      } else {
+        inode = dir.getInode(fileId);
+        if (inode != null) src = inode.getFullPathName();
+      }
+      pendingFile = checkLease(src, holder, inode, fileId);
-              "request from " + holder + " to complete " + src +
-              " which is already closed. But, it appears to be an RPC " +
-              "retry. Returning success");
+              "request from " + holder + " to complete inode " + fileId +
+              "(" + src + ") which is already closed. But, it appears to be " +
+              "an RPC retry. Returning success");
-        iip.getLatestSnapshotId());
+        Snapshot.CURRENT_STATE_ID);
+   * @param fileId The inode ID that we're fsyncing.  Older clients will pass
+   *               INodeId.GRANDFATHER_INODE_ID here.
-  void fsync(String src, String clientName, long lastBlockLength) 
+  void fsync(String src, long fileId, String clientName, long lastBlockLength)
-      INodeFile pendingFile  = checkLease(src, clientName);
+      final INode inode;
+      if (fileId == INodeId.GRANDFATHER_INODE_ID) {
+        // Older clients may not have given us an inode ID to work with.
+        // In this case, we have to try to resolve the path and hope it
+        // hasn't changed or been deleted since the file was opened for write.
+        inode = dir.getINode(src);
+      } else {
+        inode = dir.getInode(fileId);
+        if (inode != null) src = inode.getFullPathName();
+      }
+      final INodeFile pendingFile = checkLease(src, clientName, inode, fileId);

MOV44 UPD43 INS44 INS44 MOV25 MOV60 INS44 UPD42 INS60 INS25 INS39 INS42 INS39 INS42 INS60 INS25 INS65 INS39 INS42 MOV60 MOV43 INS59 INS27 INS8 INS8 UPD42 INS83 INS43 INS59 MOV27 MOV38 MOV38 MOV27 INS8 INS8 INS42 INS66 INS66 INS21 INS42 INS42 INS40 MOV60 INS21 INS21 INS25 INS60 INS25 INS60 INS25 INS42 INS42 INS27 INS60 INS53 INS53 INS60 INS25 INS21 INS40 INS60 INS25 MOV43 INS7 INS83 MOV43 MOV43 INS7 INS7 INS27 INS21 UPD42 UPD42 INS42 INS83 MOV43 INS59 INS27 INS8 INS8 INS83 INS43 INS59 INS27 INS8 INS8 INS83 INS42 INS45 INS42 INS45 INS43 INS59 INS14 INS14 INS83 INS43 INS59 INS27 INS8 INS8 INS7 INS83 INS43 INS59 INS27 INS8 INS8 INS83 UPD42 MOV32 INS42 INS32 UPD42 UPD42 INS42 MOV32 INS42 INS32 INS42 INS33 INS7 INS42 INS42 INS40 INS21 INS21 INS25 INS42 INS42 INS42 INS40 INS21 INS21 INS25 MOV42 MOV43 UPD42 MOV42 INS42 INS32 MOV43 MOV27 MOV43 INS27 INS42 INS42 INS42 INS40 MOV60 MOV21 INS21 INS25 INS42 INS32 INS42 INS42 INS42 INS40 INS21 INS21 INS25 INS42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS7 INS27 INS21 INS42 INS42 UPD45 INS7 INS7 INS27 INS21 INS42 INS42 UPD42 UPD45 INS42 UPD42 UPD45 INS42 INS42 INS42 UPD45 UPD42 UPD45 INS36 INS45 INS42 INS45 INS42 INS45 INS42 INS7 INS27 INS21 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS27 INS21 INS42 INS42 INS42 INS42 UPD42 INS42 INS32 INS42 INS32 INS42 INS33 INS7 INS42 MOV32 INS42 INS32 INS42 INS33 INS7 INS16 INS42 MOV32 INS42 INS32 INS42 INS33 INS7 INS42 INS32 INS42 INS32 INS42 INS33 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS33 INS42 INS42 UPD45 MOV45 MOV42 INS45 INS42 INS42 INS42 INS42 UPD45 INS42 INS45 UPD45 UPD45 DEL85 DEL5 DEL42 DEL32 DEL83 DEL42 DEL42 DEL40 DEL34 DEL27 DEL2 DEL32 DEL59 DEL60 DEL83 DEL42 DEL42 DEL40 DEL34 DEL27 DEL2 DEL42 DEL32 DEL59 DEL60 DEL85 DEL5 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL41 DEL8 DEL31 DEL27 DEL14 DEL53 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL32
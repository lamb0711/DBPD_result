YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.

+import java.util.HashSet;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.yarn.nodelabels.CommonNodeLabelsManager;
+  private static final Log LOG = LogFactory.getLog(AbstractCSQueue.class);
-  protected Resource getCurrentResourceLimit(Resource clusterResource,
-      ResourceLimits currentResourceLimits) {
+  private Resource getCurrentLimitResource(String nodeLabel,
+      Resource clusterResource, ResourceLimits currentResourceLimits) {
-     * Queue's max available resource = min(my.max, my.limit)
-     * my.limit is set by my parent, considered used resource of my siblings
+     * Current limit resource: For labeled resource: limit = queue-max-resource
+     * (TODO, this part need update when we support labeled-limit) For
+     * non-labeled resource: limit = min(queue-max-resource,
+     * limit-set-by-parent)
-        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,
-            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);
-    Resource queueCurrentResourceLimit =
-        Resources.min(resourceCalculator, clusterResource, queueMaxResource,
-            currentResourceLimits.getLimit());
-    queueCurrentResourceLimit =
-        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,
-            minimumAllocation);
-    return queueCurrentResourceLimit;
+        Resources.multiplyAndNormalizeDown(resourceCalculator,
+            labelManager.getResourceByLabel(nodeLabel, clusterResource),
+            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);
+    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {
+      return Resources.min(resourceCalculator, clusterResource,
+          queueMaxResource, currentResourceLimits.getLimit());
+    }
+    return queueMaxResource;
+  }
+  
+  synchronized boolean canAssignToThisQueue(Resource clusterResource,
+      Set<String> nodeLabels, ResourceLimits currentResourceLimits,
+      Resource nowRequired, Resource resourceCouldBeUnreserved) {
+    // Get label of this queue can access, it's (nodeLabel AND queueLabel)
+    Set<String> labelCanAccess;
+    if (null == nodeLabels || nodeLabels.isEmpty()) {
+      labelCanAccess = new HashSet<String>();
+      // Any queue can always access any node without label
+      labelCanAccess.add(RMNodeLabelsManager.NO_LABEL);
+    } else {
+      labelCanAccess = new HashSet<String>(
+          accessibleLabels.contains(CommonNodeLabelsManager.ANY) ? nodeLabels
+              : Sets.intersection(accessibleLabels, nodeLabels));
+    }
+    
+    for (String label : labelCanAccess) {
+      // New total resource = used + required
+      Resource newTotalResource =
+          Resources.add(queueUsage.getUsed(label), nowRequired);
+
+      Resource currentLimitResource =
+          getCurrentLimitResource(label, clusterResource, currentResourceLimits);
+
+      // if reservation continous looking enabled, check to see if could we
+      // potentially use this node instead of a reserved node if the application
+      // has reserved containers.
+      // TODO, now only consider reservation cases when the node has no label
+      if (this.reservationsContinueLooking
+          && label.equals(RMNodeLabelsManager.NO_LABEL)
+          && Resources.greaterThan(resourceCalculator, clusterResource,
+              resourceCouldBeUnreserved, Resources.none())) {
+        // resource-without-reserved = used - reserved
+        Resource newTotalWithoutReservedResource =
+            Resources.subtract(newTotalResource, resourceCouldBeUnreserved);
+        
+        // when total-used-without-reserved-resource < currentLimit, we still
+        // have chance to allocate on this node by unreserving some containers
+        if (Resources.lessThan(resourceCalculator, clusterResource,
+            newTotalWithoutReservedResource, currentLimitResource)) {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("try to use reserved: " + getQueueName()
+                + " usedResources: " + queueUsage.getUsed()
+                + ", clusterResources: " + clusterResource
+                + ", reservedResources: " + resourceCouldBeUnreserved
+                + ", capacity-without-reserved: "
+                + newTotalWithoutReservedResource + ", maxLimitCapacity: "
+                + currentLimitResource); 
+          }
+          return true;
+        }
+      }
+      
+      // Otherwise, if any of the label of this node beyond queue limit, we
+      // cannot allocate on this node. Consider a small epsilon here.
+      if (Resources.greaterThan(resourceCalculator, clusterResource,
+          newTotalResource, currentLimitResource)) {
+        return false;
+      }
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug(getQueueName()
+            + "Check assign to queue, label=" + label
+            + " usedResources: " + queueUsage.getUsed(label)
+            + " clusterResources: " + clusterResource
+            + " currentUsedCapacity "
+            + Resources.divide(resourceCalculator, clusterResource,
+                queueUsage.getUsed(label),
+                labelManager.getResourceByLabel(label, clusterResource))
+            + " max-capacity: "
+            + queueCapacities.getAbsoluteMaximumCapacity(label)
+            + ")");
+      }
+      return true;
+    }
+    
+    // Actually, this will not happen, since labelCanAccess will be always
+    // non-empty
+    return false;

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 MOV43 UPD42 MOV42 INS44 MOV44 MOV44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS42 INS42 INS32 INS43 INS42 MOV60 INS25 INS41 INS43 INS42 INS74 INS42 INS43 INS42 MOV43 INS42 INS43 INS42 INS60 INS25 INS70 INS41 INS42 INS42 INS57 INS42 INS32 INS8 INS42 INS42 INS43 INS43 INS42 INS42 INS74 INS59 INS27 INS8 INS8 INS44 INS42 INS8 INS9 INS43 INS42 INS42 INS40 INS41 INS42 INS42 INS43 INS43 INS42 INS27 INS32 INS21 INS21 INS21 INS43 INS42 INS60 MOV60 INS25 INS25 INS25 MOV41 INS42 INS32 MOV32 INS42 INS42 INS33 INS42 INS42 INS42 INS7 INS32 INS7 INS42 INS43 INS59 INS43 INS27 INS8 INS32 INS8 INS32 INS8 INS9 INS42 INS42 INS42 MOV42 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS22 INS32 INS32 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 MOV21 INS74 INS74 INS16 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS9 INS32 INS43 INS43 INS43 INS43 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS41 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS9 INS32 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS21 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS27 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL7 DEL42 DEL83 DEL8 DEL31
HDFS-7912. Erasure Coding: track BlockInfo instead of Block in UnderReplicatedBlocks and PendingReplicationBlocks. Contributed by Jing Zhao.

-    List<List<Block>> blocksToReplicate = null;
+    List<List<BlockInfo>> blocksToReplicate = null;
-  int computeReplicationWorkForBlocks(List<List<Block>> blocksToReplicate) {
+  int computeReplicationWorkForBlocks(List<List<BlockInfo>> blocksToReplicate) {
-          for (Block block : blocksToReplicate.get(priority)) {
+          for (BlockInfo block : blocksToReplicate.get(priority)) {
-          Block block = rw.block;
+          BlockInfo block = rw.block;
-    Block[] timedOutItems = pendingReplications.getTimedOutBlocks();
+    BlockInfo[] timedOutItems = pendingReplications.getTimedOutBlocks();
-      final String src, final Block... blocks) {
+      final String src, final BlockInfoContiguous... blocks) {
-    for(Block b : blocks) {
+    for(BlockInfoContiguous b : blocks) {
-      for(Block b : blocks) {
+      for(BlockInfoContiguous b : blocks) {
-      if (!blocksMap.removeNode(block, node)) {
+      BlockInfo storedBlock = getStoredBlock(block);
+      if (storedBlock == null || !blocksMap.removeNode(storedBlock, node)) {
-        namesystem.decrementSafeBlockCount(block);
-        updateNeededReplications(block, -1, 0);
+        namesystem.decrementSafeBlockCount(storedBlock);
+        updateNeededReplications(storedBlock, -1, 0);
-    pendingReplications.decrement(block, node);
+    pendingReplications.decrement(getStoredBlock(block), node);
-  public NumberReplicas countNodes(Block b) {
+  public NumberReplicas countNodes(BlockInfo b) {
-   * Simpler, faster form of {@link #countNodes(Block)} that only returns the number
+   * Simpler, faster form of {@link #countNodes} that only returns the number
-   * If not in startup, then it calls {@link #countNodes(Block)} instead.
+   * If not in startup, then it calls {@link #countNodes} instead.
-    final Iterator<? extends Block> it = srcNode.getBlockIterator();
+    final Iterator<BlockInfo> it = srcNode.getBlockIterator();
-      final Block block = it.next();
+      final BlockInfo block = it.next();
-  public void removeBlock(Block block) {
+  public void removeBlock(BlockInfo block) {
-  private void updateNeededReplications(final Block block,
+  private void updateNeededReplications(final BlockInfo block,
-    for (Block block : bc.getBlocks()) {
+    for (BlockInfo block : bc.getBlocks()) {
-  public Iterator<Block> getCorruptReplicaBlockIterator() {
+  public Iterator<BlockInfo> getCorruptReplicaBlockIterator() {
-    private final Block block;
+    private final BlockInfo block;
-    public ReplicationWork(Block block,
+    public ReplicationWork(BlockInfo block,

UPD74 UPD74 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD74 UPD74 UPD5 UPD42 INS60 UPD42 UPD74 UPD42 UPD42 UPD42 UPD42 UPD43 UPD74 UPD43 UPD43 UPD43 INS43 INS59 INS27 INS32 INS67 INS67 INS43 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS27 INS38 INS42 MOV42 INS42 INS42 UPD42 MOV42 UPD43 UPD42 UPD42 UPD43 INS42 INS42 INS42 INS33 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 UPD42 DEL38 DEL42 DEL42 DEL43 DEL69 DEL68 DEL42 DEL42 DEL43 DEL69 DEL68 DEL43 DEL76
YARN-1781. Modified NodeManagers to allow admins to specify max disk utilization for local disks so as to be able to offline full disks. Contributed by Varun Vasudev.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575463 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+  
+  private float diskUtilizationPercentageCutoff;
+  private long diskUtilizationSpaceCutoff;
+  /**
+   * Create collection for the directories specified. No check for free space.
+   * 
+   * @param dirs
+   *          directories to be monitored
+   */
+    this(dirs, 100.0F, 0);
+  }
+
+  /**
+   * Create collection for the directories specified. Users must specify the
+   * maximum percentage of disk utilization allowed. Minimum amount of disk
+   * space is not checked.
+   * 
+   * @param dirs
+   *          directories to be monitored
+   * @param utilizationPercentageCutOff
+   *          percentage of disk that can be used before the dir is taken out of
+   *          the good dirs list
+   * 
+   */
+  public DirectoryCollection(String[] dirs, float utilizationPercentageCutOff) {
+    this(dirs, utilizationPercentageCutOff, 0);
+  }
+
+  /**
+   * Create collection for the directories specified. Users must specify the
+   * minimum amount of free space that must be available for the dir to be used.
+   * 
+   * @param dirs
+   *          directories to be monitored
+   * @param utilizationSpaceCutOff
+   *          minimum space, in MB, that must be available on the disk for the
+   *          dir to be marked as good
+   * 
+   */
+  public DirectoryCollection(String[] dirs, long utilizationSpaceCutOff) {
+    this(dirs, 100.0F, utilizationSpaceCutOff);
+  }
+
+  /**
+   * Create collection for the directories specified. Users must specify the
+   * maximum percentage of disk utilization allowed and the minimum amount of
+   * free space that must be available for the dir to be used. If either check
+   * fails the dir is removed from the good dirs list.
+   * 
+   * @param dirs
+   *          directories to be monitored
+   * @param utilizationPercentageCutOff
+   *          percentage of disk that can be used before the dir is taken out of
+   *          the good dirs list
+   * @param utilizationSpaceCutOff
+   *          minimum space, in MB, that must be available on the disk for the
+   *          dir to be marked as good
+   * 
+   */
+  public DirectoryCollection(String[] dirs, 
+      float utilizationPercentageCutOff,
+      long utilizationSpaceCutOff) {
+    diskUtilizationPercentageCutoff = utilizationPercentageCutOff;
+    diskUtilizationSpaceCutoff = utilizationSpaceCutOff;
+    diskUtilizationPercentageCutoff =
+        utilizationPercentageCutOff < 0.0F ? 0.0F
+            : (utilizationPercentageCutOff > 100.0F ? 100.0F
+                : utilizationPercentageCutOff);
+    diskUtilizationSpaceCutoff =
+        utilizationSpaceCutOff < 0 ? 0 : utilizationSpaceCutOff;
+    HashSet<String> checkFailedDirs = new HashSet<String>();
-        DiskChecker.checkDir(new File(dir));
+        File testDir = new File(dir);
+        DiskChecker.checkDir(testDir);
+        if (isDiskUsageUnderPercentageLimit(testDir)) {
+          LOG.warn("Directory " + dir
+              + " error, used space above threshold of "
+              + diskUtilizationPercentageCutoff
+              + "%, removing from the list of valid directories.");
+          checkFailedDirs.add(dir);
+        } else if (isDiskFreeSpaceWithinLimit(testDir)) {
+          LOG.warn("Directory " + dir + " error, free space below limit of "
+              + diskUtilizationSpaceCutoff
+              + "MB, removing from the list of valid directories.");
+          checkFailedDirs.add(dir);
+        }
-        LOG.warn("Directory " + dir + " error " +
-            de.getMessage() + ", removing from the list of valid directories.");
-        localDirs.remove(dir);
-        failedDirs.add(dir);
-        numFailures++;
+        LOG.warn("Directory " + dir + " error " + de.getMessage()
+            + ", removing from the list of valid directories.");
+        checkFailedDirs.add(dir);
+    for (String dir : checkFailedDirs) {
+      localDirs.remove(dir);
+      failedDirs.add(dir);
+      numFailures++;
+    }
+  
+  private boolean isDiskUsageUnderPercentageLimit(File dir) {
+    float freePercentage =
+        100 * (dir.getUsableSpace() / (float) dir.getTotalSpace());
+    float usedPercentage = 100.0F - freePercentage;
+    if (usedPercentage > diskUtilizationPercentageCutoff
+        || usedPercentage >= 100.0F) {
+      return true;
+    }
+    return false;
+  }
+
+  private boolean isDiskFreeSpaceWithinLimit(File dir) {
+    long freeSpace = dir.getUsableSpace() / (1024 * 1024);
+    if (freeSpace < this.diskUtilizationSpaceCutoff) {
+      return true;
+    }
+    return false;
+  }
+  
+  public float getDiskUtilizationPercentageCutoff() {
+    return diskUtilizationPercentageCutoff;
+  }
+
+  public void setDiskUtilizationPercentageCutoff(
+      float diskUtilizationPercentageCutoff) {
+    this.diskUtilizationPercentageCutoff =
+        diskUtilizationPercentageCutoff < 0.0F ? 0.0F
+            : (diskUtilizationPercentageCutoff > 100.0F ? 100.0F
+                : diskUtilizationPercentageCutoff);
+  }
+
+  public long getDiskUtilizationSpaceCutoff() {
+    return diskUtilizationSpaceCutoff;
+  }
+
+  public void setDiskUtilizationSpaceCutoff(long diskUtilizationSpaceCutoff) {
+    diskUtilizationSpaceCutoff =
+        diskUtilizationSpaceCutoff < 0 ? 0 : diskUtilizationSpaceCutoff;
+    this.diskUtilizationSpaceCutoff = diskUtilizationSpaceCutoff;
+  }

INS26 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS39 INS59 INS83 INS39 INS59 INS29 INS83 INS42 INS44 INS8 INS29 INS83 INS42 INS44 INS44 INS8 INS29 INS83 INS42 INS44 INS44 INS8 INS29 INS44 INS44 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS65 INS65 INS5 INS42 INS17 INS65 INS65 INS65 INS5 INS42 INS39 INS42 INS17 INS65 INS65 INS65 INS5 INS42 INS39 INS42 INS17 INS65 INS65 INS65 INS65 INS39 INS42 INS39 INS42 INS21 INS21 INS21 INS21 INS60 INS70 INS43 INS42 INS60 INS60 INS25 INS41 INS43 INS42 INS60 INS25 INS41 INS41 INS39 INS42 INS21 INS41 INS39 INS42 INS21 INS21 INS66 INS42 INS66 INS43 INS85 INS42 INS34 INS34 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS85 INS42 INS42 INS34 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS85 INS42 INS34 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS7 INS7 INS7 INS7 INS74 INS59 INS44 INS42 MOV8 INS42 INS39 INS59 INS39 INS59 INS27 INS8 INS9 INS42 INS39 INS59 INS27 INS8 INS9 INS42 INS7 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS16 INS42 INS16 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS27 INS42 INS27 INS27 INS27 INS41 INS42 INS27 INS42 INS22 INS41 INS22 INS16 INS42 INS16 INS22 INS42 INS27 INS34 INS36 INS27 INS34 INS42 INS42 INS42 INS74 INS42 INS34 INS36 INS34 INS42 INS42 INS42 INS42 INS34 INS9 INS32 INS36 INS52 INS42 INS9 INS52 INS42 INS27 INS34 INS36 INS27 INS34 INS42 INS52 INS42 INS42 INS34 INS16 INS42 INS34 INS43 INS43 INS60 INS25 INS8 INS27 INS42 INS42 INS27 INS42 INS34 INS16 INS42 INS34 INS27 INS34 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS25 MOV21 INS21 INS32 INS11 INS34 INS34 INS27 INS34 INS42 INS42 INS34 INS42 INS42 MOV14 INS42 INS42 INS42 INS21 INS21 INS32 INS8 INS32 INS42 INS42 INS39 INS32 INS42 INS34 INS32 INS32 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS32 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45
HADOOP-16127. In ipc.Client, put a new connection could happen after stop.

+import java.util.function.Consumer;
-  
-  private static final int STOP_SLEEP_TIME_MS = 10;
-  private ConcurrentMap<ConnectionId, Connection> connections =
+  private final ConcurrentMap<ConnectionId, Connection> connections =
+  private final Object putLock = new Object();
+  private final Object emptyCondition = new Object();
+  private final AtomicBoolean running = new AtomicBoolean(true);
-  private AtomicBoolean running = new AtomicBoolean(true); // if client runs
-  private int refCount = 1;
+  private final AtomicInteger refCount = new AtomicInteger(1);
-  };
+  }
+
-   *
-  synchronized void incCount() {
-    refCount++;
+  void incCount() {
+    refCount.incrementAndGet();
-   *
-  synchronized void decCount() {
-    refCount--;
-  }
-  
-  /**
-   * Return if this client has no reference
-   * 
-   * @return true if this client has no reference; false otherwise
-   */
-  synchronized boolean isZeroReference() {
-    return refCount==0;
+  int decAndGetCount() {
+    return refCount.decrementAndGet();
+    private final Consumer<Connection> removeMethod;
-    public Connection(ConnectionId remoteId, int serviceClass) throws IOException {
+    Connection(ConnectionId remoteId, int serviceClass,
+        Consumer<Connection> removeMethod) {
-      if (server.isUnresolved()) {
-        throw NetUtils.wrapException(server.getHostName(),
-            server.getPort(),
-            null,
-            0,
-            new UnknownHostException());
-      }
+
-        pingHeader.writeDelimitedTo(buf);
+        try {
+          pingHeader.writeDelimitedTo(buf);
+        } catch (IOException e) {
+          throw new IllegalStateException("Failed to write to buf for "
+              + remoteId + " in " + Client.this + " due to " + e, e);
+        }
+      this.removeMethod = removeMethod;
+
-      connections.remove(remoteId, this);
+      removeMethod.accept(this);
- 
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "-"
+        + StringUtils.byteToHexString(clientId);
+  }
+
-
-    if (!running.compareAndSet(true, false)) {
-      return;
+    synchronized (putLock) { // synchronized to avoid put after stop
+      if (!running.compareAndSet(true, false)) {
+        return;
+      }
-    
+
-    while (!connections.isEmpty()) {
-      try {
-        Thread.sleep(STOP_SLEEP_TIME_MS);
-      } catch (InterruptedException e) {
+    synchronized (emptyCondition) {
+      // synchronized the loop to guarantee wait must be notified.
+      while (!connections.isEmpty()) {
+        try {
+          emptyCondition.wait();
+        } catch (InterruptedException e) {
+        }
-    
-    if (!running.get()) {
-      // the client is stopped
-      throw new IOException("The client is stopped");
+    final InetSocketAddress address = remoteId.getAddress();
+    if (address.isUnresolved()) {
+      throw NetUtils.wrapException(address.getHostName(),
+          address.getPort(),
+          null,
+          0,
+          new UnknownHostException());
+
+    final Consumer<Connection> removeMethod = c -> {
+      final boolean removed = connections.remove(remoteId, c);
+      if (removed && connections.isEmpty()) {
+        synchronized (emptyCondition) {
+          emptyCondition.notify();
+        }
+      }
+    };
+
-      // These lines below can be shorten with computeIfAbsent in Java8
-      connection = connections.get(remoteId);
-      if (connection == null) {
-        connection = new Connection(remoteId, serviceClass);
-        Connection existing = connections.putIfAbsent(remoteId, connection);
-        if (existing != null) {
-          connection = existing;
+      synchronized (putLock) { // synchronized to avoid put after stop
+        if (!running.get()) {
+          throw new IOException("Failed to get connection for " + remoteId
+              + ", " + call + ": " + this + " is already stopped");
+        connection = connections.computeIfAbsent(remoteId,
+            id -> new Connection(id, serviceClass, removeMethod));
-        connections.remove(remoteId, connection);
+        removeMethod.accept(connection);

INS26 MOV23 MOV31 INS40 INS23 INS23 INS83 MOV83 UPD83 MOV83 INS43 INS59 INS83 MOV83 INS43 MOV59 INS83 INS83 INS43 UPD39 UPD42 INS23 INS78 UPD83 INS43 INS42 INS42 INS42 INS14 INS42 UPD42 INS14 INS42 INS14 INS41 INS83 INS83 INS74 INS59 INS44 INS42 INS42 INS51 INS51 INS60 INS60 INS61 INS43 INS43 INS43 INS34 INS32 INS32 INS43 INS43 INS42 INS74 INS42 INS21 UPD27 INS42 INS8 INS42 INS8 INS83 INS43 INS59 INS32 INS83 INS74 INS59 INS9 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS7 INS32 INS45 INS32 MOV25 MOV61 INS42 INS42 INS32 INS42 INS42 INS43 MOV43 INS42 INS86 INS51 MOV25 INS42 INS42 INS54 INS22 INS42 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS59 INS8 INS42 INS8 INS8 INS12 INS52 INS42 INS42 INS42 INS42 INS32 INS32 INS33 INS34 MOV14 INS42 INS60 INS25 INS25 INS21 MOV21 INS44 INS8 INS42 INS42 INS42 INS42 INS83 INS39 INS59 UPD27 MOV27 INS8 MOV38 INS8 INS7 MOV43 INS42 INS53 INS42 INS32 INS42 INS32 INS51 INS53 INS42 INS32 UPD42 UPD42 INS14 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS8 INS14 MOV42 UPD42 MOV42 MOV42 INS86 INS43 INS27 INS42 UPD42 UPD42 INS21 MOV43 INS27 INS59 INS14 INS42 INS45 INS42 INS45 INS52 INS45 INS42 INS32 INS45 INS42 INS45 INS42 INS45 INS52 INS45 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 DEL39 DEL23 DEL34 DEL39 DEL34 DEL83 DEL42 DEL37 DEL83 DEL42 DEL37 DEL21 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL33 DEL34 DEL32 DEL53 DEL8 DEL25 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL34 DEL42 DEL45 DEL14 DEL42 DEL33 DEL42 DEL9 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61
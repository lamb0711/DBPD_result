YARN-6093. Minor bugs with AMRMtoken renewal and state store availability when using FederationRMFailoverProxyProvider during RM failover. (Botong Huang via Subru).

(cherry picked from commit 66500f4fa6155d29435d7c92fd6d68079c4cab86)

-import java.util.Collection;
+import java.security.PrivilegedExceptionAction;
-import org.apache.hadoop.security.token.Token;
-import org.apache.hadoop.security.token.TokenIdentifier;
-import org.apache.hadoop.yarn.exceptions.YarnException;
+import org.apache.hadoop.yarn.exceptions.YarnRuntimeException;
+import com.google.common.annotations.VisibleForTesting;
-  private Collection<Token<? extends TokenIdentifier>> originalTokens;
+  private UserGroupInformation originalUser;
-      UserGroupInformation currentUser = UserGroupInformation.getCurrentUser();
-      originalTokens = currentUser.getTokens();
+      this.originalUser = UserGroupInformation.getCurrentUser();
-          currentUser.getUserName());
+          this.originalUser.getUserName());
+      this.originalUser = null;
-  private void addOriginalTokens(UserGroupInformation currentUser) {
-    if (originalTokens == null || originalTokens.isEmpty()) {
-      return;
-    }
-    for (Token<? extends TokenIdentifier> token : originalTokens) {
-      currentUser.addToken(token);
-    }
+  @VisibleForTesting
+  protected T createRMProxy(InetSocketAddress rmAddress) throws IOException {
+    return rmProxy.getProxy(conf, protocol, rmAddress);
-    UserGroupInformation currentUser = null;
+    // Use the existing proxy as a backup in case getting the new proxy fails.
+    // Note that if the first time it fails, the backup is also null. In that
+    // case we will hit NullPointerException and throw it back to AM.
+    T proxy = this.current;
-      // creations
-      // are based out of conf
+      // creations are based out of conf
-      currentUser = UserGroupInformation.getCurrentUser();
-      addOriginalTokens(currentUser);
-    } catch (YarnException e) {
+      if (this.originalUser == null) {
+        InetSocketAddress rmAddress = rmProxy.getRMAddress(conf, protocol);
+        LOG.info(
+            "Connecting to {} subClusterId {} with protocol {}"
+                + " without a proxy user",
+            rmAddress, subClusterId, protocol.getSimpleName());
+        proxy = createRMProxy(rmAddress);
+      } else {
+        // If the original ugi exists, always use that to create proxy because
+        // it contains up-to-date AMRMToken
+        proxy = this.originalUser.doAs(new PrivilegedExceptionAction<T>() {
+          @Override
+          public T run() throws IOException {
+            InetSocketAddress rmAddress = rmProxy.getRMAddress(conf, protocol);
+            LOG.info(
+                "Connecting to {} subClusterId {} with protocol {} as user {}",
+                rmAddress, subClusterId, protocol.getSimpleName(),
+                originalUser);
+            return createRMProxy(rmAddress);
+          }
+        });
+      }
+    } catch (Exception e) {
-      return null;
-    } catch (IOException e) {
-      LOG.warn("Could not get information of requester, ignoring for now.");
+      if (proxy == null) {
+        throw new YarnRuntimeException(
+            String.format("Create initial proxy to the ResourceManager for"
+                + " SubClusterId %s failed", subClusterId),
+            e);
+      }
-    try {
-      final InetSocketAddress rmAddress = rmProxy.getRMAddress(conf, protocol);
-      LOG.info("Connecting to {} with protocol {} as user: {}", rmAddress,
-          protocol.getSimpleName(), currentUser);
-      LOG.info("Failed over to the RM at {} for SubClusterId: {}", rmAddress,
-          subClusterId);
-      return rmProxy.getProxy(conf, protocol, rmAddress);
-    } catch (IOException ioe) {
-      LOG.error(
-          "IOException while trying to create proxy to the ResourceManager"
-              + " for SubClusterId: {}",
-          subClusterId, ioe);
-      return null;
-    }
+    return proxy;
-    closeInternal(currentProxy);
+    // It will not return null proxy here
+    if (current != currentProxy) {
+      closeInternal(currentProxy);
+    }

MOV26 MOV26 UPD40 UPD40 UPD40 INS23 INS31 INS31 MOV83 MOV43 INS59 INS78 INS83 INS43 INS42 INS44 INS43 INS8 MOV83 MOV43 UPD42 MOV42 MOV44 INS8 INS42 INS42 UPD42 MOV42 INS43 INS42 INS42 MOV41 MOV60 INS60 INS54 INS41 INS25 UPD42 MOV42 INS43 INS59 INS8 INS12 INS42 INS27 INS8 UPD42 MOV42 INS42 INS22 MOV21 MOV21 MOV21 INS25 MOV44 MOV8 INS42 INS42 MOV21 INS21 INS52 INS42 INS27 INS8 INS8 INS43 UPD42 INS25 INS22 MOV32 INS7 INS22 MOV33 INS60 INS21 MOV21 INS21 INS42 INS27 INS8 INS52 INS42 INS22 INS22 INS33 INS52 INS42 INS43 INS59 INS32 INS7 INS42 INS33 INS53 INS52 INS42 INS52 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS27 UPD42 MOV42 INS42 INS32 UPD42 INS42 INS32 INS14 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 UPD42 UPD42 INS22 UPD42 MOV42 INS14 INS43 INS32 INS42 INS52 INS42 INS74 INS1 INS42 INS42 INS42 INS27 INS42 INS43 INS43 INS31 INS45 INS45 UPD42 MOV42 UPD42 MOV42 INS78 INS83 INS43 INS42 MOV43 INS8 INS42 INS42 MOV60 MOV21 INS41 INS32 UPD45 INS42 UPD42 UPD42 MOV42 MOV42 DEL40 DEL26 DEL42 DEL43 DEL43 DEL43 DEL76 DEL74 DEL74 DEL42 DEL59 DEL23 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL83 DEL33 DEL41 DEL39 DEL43 DEL42 DEL44 DEL42 DEL27 DEL42 DEL42 DEL32 DEL27 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL44 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL43 DEL42 DEL44 DEL12 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL21 DEL33 DEL41 DEL8 DEL12 DEL54 DEL8 DEL31
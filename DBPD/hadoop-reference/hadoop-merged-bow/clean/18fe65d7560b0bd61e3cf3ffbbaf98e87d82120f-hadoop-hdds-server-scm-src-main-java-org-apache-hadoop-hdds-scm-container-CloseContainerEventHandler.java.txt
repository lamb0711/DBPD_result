HDDS-576. Move ContainerWithPipeline creation to RPC endpoint.
Contributed by Nanda kumar.

-import org.apache.hadoop.hdds.protocol.proto.HddsProtos;
-import org.apache.hadoop.hdds.scm.container.common.helpers.ContainerWithPipeline;
-import org.apache.hadoop.hdds.scm.pipeline.Pipeline;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import org.apache.hadoop.hdds.protocol.DatanodeDetails;
+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.LifeCycleEvent;
+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.LifeCycleState;
+import org.apache.hadoop.hdds.scm.pipeline.PipelineManager;
+import org.apache.hadoop.hdds.scm.pipeline.PipelineNotFoundException;
-
+  private final PipelineManager pipelineManager;
-  public CloseContainerEventHandler(ContainerManager containerManager) {
+  public CloseContainerEventHandler(final PipelineManager pipelineManager,
+      final ContainerManager containerManager) {
+    this.pipelineManager = pipelineManager;
-
-    LOG.info("Close container Event triggered for container : {}",
-        containerID.getId());
-    ContainerWithPipeline containerWithPipeline;
-    ContainerInfo info;
+    LOG.info("Close container Event triggered for container : {}", containerID);
-      containerWithPipeline =
-          containerManager.getContainerWithPipeline(containerID);
-      info = containerWithPipeline.getContainerInfo();
-      if (info == null) {
-        LOG.error("Failed to update the container state. Container with id : {}"
-            + " does not exist", containerID.getId());
-        return;
+      // If the container is in OPEN state, FINALIZE it.
+      if (containerManager.getContainer(containerID).getState()
+          == LifeCycleState.OPEN) {
+        containerManager.updateContainerState(
+            containerID, LifeCycleEvent.FINALIZE);
-    } catch (IOException e) {
-      LOG.error("Failed to update the container state. Container with id : {} "
-          + "does not exist", containerID.getId(), e);
-      return;
-    }
-    HddsProtos.LifeCycleState state = info.getState();
-    try {
-      switch (state) {
-      case OPEN:
-        containerManager.updateContainerState(containerID,
-            HddsProtos.LifeCycleEvent.FINALIZE);
-        fireCloseContainerEvents(containerWithPipeline, info, publisher);
-        break;
-      case CLOSING:
-        fireCloseContainerEvents(containerWithPipeline, info, publisher);
-        break;
-      case CLOSED:
-      case DELETING:
-      case DELETED:
-        LOG.info("Cannot close container #{}, it is already in {} state.",
-            containerID.getId(), state);
-        break;
-      default:
-        throw new IOException("Invalid container state for container #"
-            + containerID);
+      // ContainerInfo has to read again after the above state change.
+      final ContainerInfo container = containerManager
+          .getContainer(containerID);
+      // Send close command to datanodes, if the container is in CLOSING state
+      if (container.getState() == LifeCycleState.CLOSING) {
+
+        final CloseContainerCommand closeContainerCommand =
+            new CloseContainerCommand(containerID.getId(),
+                container.getReplicationType(), container.getPipelineID());
+
+        getNodes(container).forEach(node -> publisher.fireEvent(
+            DATANODE_COMMAND,
+            new CommandForDatanode<>(node.getUuid(), closeContainerCommand)));
+      } else {
+        LOG.warn("Cannot close container {}, which is in {} state.",
+            containerID, container.getState());
+
-      LOG.error("Failed to update the container state for container #{}"
-          + containerID, ex);
+      LOG.error("Failed to close the container {}.", containerID, ex);
-  private void fireCloseContainerEvents(
-      ContainerWithPipeline containerWithPipeline, ContainerInfo info,
-      EventPublisher publisher) {
-    ContainerID containerID = info.containerID();
-    // fire events.
-    CloseContainerCommand closeContainerCommand =
-        new CloseContainerCommand(containerID.getId(),
-            info.getReplicationType(), info.getPipelineID());
-
-    Pipeline pipeline = containerWithPipeline.getPipeline();
-    pipeline.getNodes().stream()
-        .map(node ->
-            new CommandForDatanode<>(node.getUuid(), closeContainerCommand))
-        .forEach(command -> publisher.fireEvent(DATANODE_COMMAND, command));
-
-    LOG.trace("Issuing {} on Pipeline {} for container", closeContainerCommand,
-        pipeline, containerID);
+  /**
+   * Returns the list of Datanodes where this container lives.
+   *
+   * @param container ContainerInfo
+   * @return list of DatanodeDetails
+   * @throws ContainerNotFoundException
+   */
+  private List<DatanodeDetails> getNodes(final ContainerInfo container)
+      throws ContainerNotFoundException {
+    try {
+      return pipelineManager.getPipeline(container.getPipelineID()).getNodes();
+    } catch (PipelineNotFoundException ex) {
+      // Use container replica if the pipeline is not available.
+      return containerManager.getContainerReplicas(container.containerID())
+          .stream()
+          .map(ContainerReplica::getDatanodeDetails)
+          .collect(Collectors.toList());
+    }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 UPD40 INS40 UPD40 UPD40 INS23 INS83 INS83 INS43 INS59 INS44 MOV44 INS29 INS74 INS42 INS43 INS8 INS42 INS42 INS83 INS43 INS42 INS83 INS21 INS54 INS65 INS65 INS65 INS65 INS43 INS43 INS83 UPD42 UPD42 MOV42 INS54 INS42 INS7 INS8 MOV12 INS66 INS42 INS66 INS66 INS42 INS42 UPD42 MOV42 INS8 INS12 INS22 INS42 MOV42 INS25 INS60 INS25 INS41 INS44 INS8 INS52 INS42 INS27 MOV8 INS83 MOV43 INS59 INS27 INS8 INS8 INS32 INS43 INS42 INS41 INS32 INS40 INS42 INS32 INS32 INS40 INS60 MOV21 INS21 INS32 UPD42 MOV42 UPD42 MOV42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 INS83 MOV43 INS59 MOV32 MOV32 INS45 INS42 INS42 UPD42 MOV42 INS32 INS32 UPD42 MOV42 INS32 MOV42 UPD42 MOV42 MOV42 UPD42 UPD42 MOV42 INS40 INS42 INS14 UPD42 UPD42 UPD45 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS90 INS42 INS42 MOV43 MOV32 INS32 INS32 MOV42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 MOV14 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL45 DEL45 DEL27 DEL42 DEL32 DEL41 DEL42 DEL32 DEL42 DEL42 DEL59 DEL42 DEL42 DEL42 DEL42 DEL32 DEL86 DEL32 DEL32 DEL45 DEL42 DEL27 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL45 DEL27 DEL42 DEL32 DEL42 DEL32 DEL21 DEL41 DEL8 DEL12 DEL54 DEL40 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL49 DEL42 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL10 DEL42 DEL49 DEL42 DEL42 DEL32 DEL21 DEL10 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL21 DEL10 DEL49 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL50 DEL8 DEL54 DEL39 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL14 DEL59 DEL60 DEL43 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8
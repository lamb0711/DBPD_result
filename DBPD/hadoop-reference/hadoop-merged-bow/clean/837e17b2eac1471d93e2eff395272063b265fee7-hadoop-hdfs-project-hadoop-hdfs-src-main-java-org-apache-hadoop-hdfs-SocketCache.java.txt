svn merge -c -1430507 . for reverting HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430662 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.Closeable;
+import java.net.Socket;
+import java.net.SocketAddress;
+
-import com.google.common.annotations.VisibleForTesting;
+import java.io.IOException;
+import org.apache.hadoop.HadoopIllegalArgumentException;
-import org.apache.hadoop.hdfs.protocol.DatanodeID;
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.hdfs.protocol.datatransfer.IOStreamPair;
-import org.apache.hadoop.hdfs.net.Peer;
+import org.apache.hadoop.util.StringUtils;
-class PeerCache {
-  private static final Log LOG = LogFactory.getLog(PeerCache.class);
-  
-  private static class Value {
-    private final Peer peer;
-    private final long time;
+class SocketCache {
+  private static final Log LOG = LogFactory.getLog(SocketCache.class);
-    Value(Peer peer, long time) {
-      this.peer = peer;
-      this.time = time;
+  @InterfaceAudience.Private
+  static class SocketAndStreams implements Closeable {
+    public final Socket sock;
+    public final IOStreamPair ioStreams;
+    long createTime;
+    
+    public SocketAndStreams(Socket s, IOStreamPair ioStreams) {
+      this.sock = s;
+      this.ioStreams = ioStreams;
+      this.createTime = Time.monotonicNow();
+    }
+    
+    @Override
+    public void close() {
+      if (ioStreams != null) { 
+        IOUtils.closeStream(ioStreams.in);
+        IOUtils.closeStream(ioStreams.out);
+      }
+      IOUtils.closeSocket(sock);
-    Peer getPeer() {
-      return peer;
-    }
-
-    long getTime() {
-      return time;
+    public long getCreateTime() {
+      return this.createTime;
-  private static LinkedListMultimap<DatanodeID, Value> multimap =
+  private static LinkedListMultimap<SocketAddress, SocketAndStreams> multimap =
-  private static PeerCache instance = new PeerCache();
+  private static SocketCache scInstance = new SocketCache();
-  public static synchronized PeerCache getInstance(int c, long e) {
+  public static synchronized SocketCache getInstance(int c, long e) {
-    return instance;
+    return scInstance;
-          PeerCache.this.run();
+          SocketCache.this.run();
-          PeerCache.this.clear();
+          SocketCache.this.clear();
-        return String.valueOf(PeerCache.this);
+        return String.valueOf(SocketCache.this);
-   * Get a cached peer connected to the given DataNode.
-   * @param dnId         The DataNode to get a Peer for.
-   * @return             An open Peer connected to the DN, or null if none
-   *                     was found. 
+   * Get a cached socket to the given address.
+   * @param remote  Remote address the socket is connected to.
+   * @return  A socket with unknown state, possibly closed underneath. Or null.
-  public synchronized Peer get(DatanodeID dnId) {
+  public synchronized SocketAndStreams get(SocketAddress remote) {
-    List<Value> sockStreamList = multimap.get(dnId);
+    List<SocketAndStreams> sockStreamList = multimap.get(remote);
-    Iterator<Value> iter = sockStreamList.iterator();
+    Iterator<SocketAndStreams> iter = sockStreamList.iterator();
-      Value candidate = iter.next();
+      SocketAndStreams candidate = iter.next();
-      if (!candidate.getPeer().isClosed()) {
-        return candidate.getPeer();
+      if (!candidate.sock.isClosed()) {
+        return candidate;
-  public synchronized void put(DatanodeID dnId, Peer peer) {
-    Preconditions.checkNotNull(dnId);
-    Preconditions.checkNotNull(peer);
-    if (peer.isClosed()) return;
+  public synchronized void put(Socket sock, IOStreamPair ioStreams) {
+
+    Preconditions.checkNotNull(sock);
+    SocketAndStreams s = new SocketAndStreams(sock, ioStreams);
-      IOUtils.cleanup(LOG, peer);
+      s.close();
+    SocketAddress remoteAddr = sock.getRemoteSocketAddress();
+    if (remoteAddr == null) {
+      LOG.warn("Cannot cache (unconnected) socket with no remote address: " +
+               sock);
+      IOUtils.closeSocket(sock);
+      return;
+    }
+
-    multimap.put(dnId, new Value(peer, Time.monotonicNow()));
+    multimap.put(remoteAddr, s);
-      Iterator<Entry<DatanodeID, Value>> iter =
+      Iterator<Entry<SocketAddress, SocketAndStreams>> iter =
-      Entry<DatanodeID, Value> entry = iter.next();
+      Entry<SocketAddress, SocketAndStreams> entry = iter.next();
-        Time.monotonicNow() - entry.getValue().getTime() <
+        Time.monotonicNow() - entry.getValue().getCreateTime() < 
-      IOUtils.cleanup(LOG, entry.getValue().getPeer());
+      SocketAndStreams s = entry.getValue();
+      s.close();
-    // We can get the oldest element immediately, because of an interesting
-    // property of LinkedListMultimap: its iterator traverses entries in the
-    // order that they were added.
-    Iterator<Entry<DatanodeID, Value>> iter =
+    Iterator<Entry<SocketAddress, SocketAndStreams>> iter =
-    Entry<DatanodeID, Value> entry = iter.next();
-    IOUtils.cleanup(LOG, entry.getValue().getPeer());
+    Entry<SocketAddress, SocketAndStreams> entry = iter.next();
+    SocketAndStreams s = entry.getValue();
+    s.close();
-  @VisibleForTesting
-  synchronized void clear() {
-    for (Value value : multimap.values()) {
-      IOUtils.cleanup(LOG, value.getPeer());
+  private synchronized void clear() {
+    for (SocketAndStreams sockAndStream : multimap.values()) {
+      sockAndStream.close();

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 UPD40 UPD42 INS78 INS42 INS43 INS23 INS23 UPD74 UPD43 UPD43 UPD43 MOV25 INS83 INS40 INS42 UPD83 UPD43 UPD83 MOV83 MOV83 INS43 INS59 MOV39 MOV59 INS83 UPD42 INS78 INS83 INS39 UPD42 INS8 INS83 UPD42 UPD43 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 INS60 INS60 MOV60 INS60 INS21 UPD42 UPD42 INS42 INS42 UPD42 UPD43 UPD42 INS43 INS42 INS21 INS42 INS25 INS21 UPD42 UPD42 UPD43 UPD42 UPD66 UPD42 UPD66 UPD66 UPD42 UPD74 UPD74 UPD42 UPD42 INS43 INS59 MOV27 INS8 INS43 INS59 INS27 MOV21 UPD74 UPD74 MOV59 INS43 INS59 INS32 UPD43 UPD42 INS42 INS7 INS27 INS8 INS32 INS22 UPD42 UPD43 UPD43 UPD42 INS42 INS42 INS14 INS21 INS41 INS42 INS42 INS32 INS42 INS33 INS21 UPD42 INS42 MOV60 INS60 UPD74 MOV43 UPD43 UPD43 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD43 UPD42 UPD42 UPD42 UPD42 INS22 MOV32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS52 INS42 UPD42 UPD42 UPD42 UPD43 INS43 INS42 INS42 INS32 INS42 INS42 INS32 UPD74 UPD74 MOV59 INS43 INS59 UPD43 UPD43 INS43 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 INS32 INS32 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS27 UPD42 UPD42 UPD74 MOV43 UPD43 UPD43 INS42 INS42 MOV32 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS40 INS42 INS42 INS40 INS40 INS42 INS45 INS42 MOV43 UPD43 UPD43 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 INS42 INS42 UPD42 UPD42 UPD42 DEL83 DEL42 DEL23 DEL39 DEL42 DEL42 DEL43 DEL42 DEL41 DEL8 DEL42 DEL66 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL32 DEL41 DEL42 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL78 DEL42 DEL42 DEL42 DEL32
HDFS-12387. Ozone: Support Ratis as a first class replication mechanism. Contributed by Anu Engineer.

+import com.google.common.base.Preconditions;
-import org.apache.hadoop.scm.XceiverClientSpi;
-import org.apache.hadoop.scm.protocolPB.StorageContainerLocationProtocolClientSideTranslatorPB;
+import org.apache.hadoop.scm.XceiverClientSpi;
+import org.apache.hadoop.scm.protocolPB
+    .StorageContainerLocationProtocolClientSideTranslatorPB;
+import static org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleState.ALLOCATED;
+import static org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleState.OPEN;
+
-
-      String traceID = UUID.randomUUID().toString();
-      storageContainerLocationClient.notifyObjectCreationStage(
-          NotifyObjectCreationStageRequestProto.Type.container,
-          containerId,
-          NotifyObjectCreationStageRequestProto.Stage.begin);
-      ContainerProtocolCalls.createContainer(client, traceID);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Created container " + containerId
-            + " leader:" + pipeline.getLeader()
-            + " machines:" + pipeline.getMachines());
+
+      // Allocated State means that SCM has allocated this pipeline in its
+      // namespace. The client needs to create the pipeline on the machines
+      // which was choosen by the SCM.
+      Preconditions.checkState(pipeline.getLifeCycleState() == ALLOCATED ||
+          pipeline.getLifeCycleState() == OPEN, "Unexpected pipeline state");
+      if (pipeline.getLifeCycleState() == ALLOCATED) {
+        createPipeline(client, pipeline);
-      storageContainerLocationClient.notifyObjectCreationStage(
-          NotifyObjectCreationStageRequestProto.Type.container,
-          containerId,
-          NotifyObjectCreationStageRequestProto.Stage.complete);
+      // TODO : Container Client State needs to be updated.
+      createContainer(containerId, client, pipeline);
+   * Create a container over pipeline specified by the SCM.
+   *
+   * @param containerId - Container ID
+   * @param client - Client to communicate with Datanodes
+   * @param pipeline - A pipeline that is already created.
+   * @throws IOException
+   */
+  public void createContainer(String containerId, XceiverClientSpi client,
+      Pipeline pipeline) throws IOException {
+    String traceID = UUID.randomUUID().toString();
+    storageContainerLocationClient.notifyObjectCreationStage(
+        NotifyObjectCreationStageRequestProto.Type.container,
+        containerId,
+        NotifyObjectCreationStageRequestProto.Stage.begin);
+    ContainerProtocolCalls.createContainer(client, traceID);
+    storageContainerLocationClient.notifyObjectCreationStage(
+        NotifyObjectCreationStageRequestProto.Type.container,
+        containerId,
+        NotifyObjectCreationStageRequestProto.Stage.complete);
+
+    // Let us log this info after we let SCM know that we have completed the
+    // creation state.
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Created container " + containerId
+          + " leader:" + pipeline.getLeader()
+          + " machines:" + pipeline.getMachines());
+    }
+  }
+
+  /**
+   * Creates a pipeline over the machines choosen by the SCM.
+   *
+   * @param client - Client
+   * @param pipeline - pipeline to be createdon Datanodes.
+   * @throws IOException
+   */
+  private void createPipeline(XceiverClientSpi client, Pipeline pipeline)
+      throws IOException {
+
+    Preconditions.checkNotNull(pipeline.getPipelineName(), "Pipeline " +
+        "name cannot be null when client create flag is set.");
+
+    // Pipeline creation is a three step process.
+    //
+    // 1. Notify SCM that this client is doing a create pipeline on
+    // datanodes.
+    //
+    // 2. Talk to Datanodes to create the pipeline.
+    //
+    // 3. update SCM that pipeline creation was successful.
+    storageContainerLocationClient.notifyObjectCreationStage(
+        NotifyObjectCreationStageRequestProto.Type.pipeline,
+        pipeline.getPipelineName(),
+        NotifyObjectCreationStageRequestProto.Stage.begin);
+
+    client.createPipeline(pipeline.getPipelineName(),
+        pipeline.getMachines());
+
+    storageContainerLocationClient.notifyObjectCreationStage(
+        NotifyObjectCreationStageRequestProto.Type.pipeline,
+        pipeline.getPipelineName(),
+        NotifyObjectCreationStageRequestProto.Stage.complete);
+
+    // TODO : Should we change the state on the client side ??
+    // That makes sense, but it is not needed for the client to work.
+    LOG.debug("Pipeline creation successful. Pipeline: {}",
+        pipeline.toString());
+  }
+
+  /**
+      client = xceiverClientManager.acquireClient(pipeline);
+
+      // Allocated State means that SCM has allocated this pipeline in its
+      // namespace. The client needs to create the pipeline on the machines
+      // which was choosen by the SCM.
+      if (pipeline.getLifeCycleState() == ALLOCATED) {
+        createPipeline(client, pipeline);
+      }
+
-      String traceID = UUID.randomUUID().toString();
-      storageContainerLocationClient.notifyObjectCreationStage(
-          NotifyObjectCreationStageRequestProto.Type.container,
-          containerId,
-          NotifyObjectCreationStageRequestProto.Stage.begin);
-
-      ContainerProtocolCalls.createContainer(client, traceID);
-      LOG.info("Created container " + containerId +
-          " leader:" + pipeline.getLeader() +
-          " machines:" + pipeline.getMachines() +
-          " replication factor:" + factor);
-
-      storageContainerLocationClient.notifyObjectCreationStage(
-          NotifyObjectCreationStageRequestProto.Type.container,
-          containerId,
-          NotifyObjectCreationStageRequestProto.Stage.complete);
+      createContainer(containerId, client, pipeline);
-      LOG.info("Deleted container {}, leader: {}, machines: {} ",
-          pipeline.getContainerName(),
-          pipeline.getLeader(),
-          pipeline.getMachines());
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Deleted container {}, leader: {}, machines: {} ",
+            pipeline.getContainerName(),
+            pipeline.getLeader(),
+            pipeline.getMachines());
+      }
-      LOG.info("Read container {}, leader: {}, machines: {} ",
-          pipeline.getContainerName(),
-          pipeline.getLeader(),
-          pipeline.getMachines());
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Read container {}, leader: {}, machines: {} ",
+            pipeline.getContainerName(),
+            pipeline.getLeader(),
+            pipeline.getMachines());
+      }

MOV26 MOV26 INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 MOV29 MOV78 INS83 MOV43 INS42 INS44 INS43 MOV8 INS29 INS39 INS44 INS44 MOV8 MOV25 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS43 INS42 INS42 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS21 INS21 INS21 INS21 INS42 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS32 MOV60 MOV21 INS21 INS25 INS21 MOV41 INS42 INS42 INS32 INS27 INS42 INS42 INS40 INS32 INS40 INS42 INS42 INS32 MOV32 INS42 INS42 INS40 INS32 INS40 INS42 INS42 INS45 INS32 INS25 INS25 INS25 INS32 INS27 INS8 INS32 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS7 INS32 INS8 INS32 INS8 INS42 INS42 INS27 INS45 INS32 INS42 INS21 INS42 INS42 INS42 INS42 INS32 INS42 MOV21 INS42 INS32 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS21 MOV42 UPD42 MOV42 MOV21 INS27 INS27 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS45 MOV32 MOV32 MOV32 UPD42 UPD45 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL42 DEL40 DEL32 DEL21 DEL42 DEL45 DEL42 DEL45 DEL42 DEL32 DEL45 DEL45 DEL42 DEL27 DEL32 DEL40 DEL40 DEL45 DEL32 DEL21
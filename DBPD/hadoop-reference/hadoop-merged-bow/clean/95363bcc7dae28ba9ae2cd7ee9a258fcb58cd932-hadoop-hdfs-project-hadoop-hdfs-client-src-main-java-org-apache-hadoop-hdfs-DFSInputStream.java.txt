HDFS-9646. ErasureCodingWorker may fail when recovering data blocks with length less than the first internal block. Contributed by Jing Zhao.

-import java.util.Map.Entry;
-  protected synchronized int readWithStrategy(ReaderStrategy strategy, int off, int len) throws IOException {
+  protected synchronized int readWithStrategy(ReaderStrategy strategy, int off,
+      int len) throws IOException {
-              currentLocatedBlock.getLocations().length);
+              currentLocatedBlock.getLocations().length, false);
-        reportCheckSumFailure(corruptedBlockMap, blk.getLocations().length);
+        reportCheckSumFailure(corruptedBlockMap, blk.getLocations().length,
+            false);
+   * For replicated blocks, we have the following logic:
+   *
+   * For erasure-coded blocks, each block in corruptedBlockMap is an internal
+   * block in a block group, and there is usually only one DataNode
+   * corresponding to each internal block. For this case we simply report the
+   * corrupted blocks to NameNode and ignore the above logic.
+   *
-      int dataNodeCount) {
+      int dataNodeCount, boolean isStriped) {
-    Iterator<Entry<ExtendedBlock, Set<DatanodeInfo>>> it = corruptedBlockMap
-        .entrySet().iterator();
-    Entry<ExtendedBlock, Set<DatanodeInfo>> entry = it.next();
-    ExtendedBlock blk = entry.getKey();
-    Set<DatanodeInfo> dnSet = entry.getValue();
-    if (((dnSet.size() < dataNodeCount) && (dnSet.size() > 0))
-        || ((dataNodeCount == 1) && (dnSet.size() == dataNodeCount))) {
-      DatanodeInfo[] locs = new DatanodeInfo[dnSet.size()];
-      int i = 0;
-      for (DatanodeInfo dn:dnSet) {
-        locs[i++] = dn;
+    List<LocatedBlock> reportList = new ArrayList<>(corruptedBlockMap.size());
+    for (Map.Entry<ExtendedBlock, Set<DatanodeInfo>> entry :
+        corruptedBlockMap.entrySet()) {
+      ExtendedBlock blk = entry.getKey();
+      Set<DatanodeInfo> dnSet = entry.getValue();
+      if (isStriped || ((dnSet.size() < dataNodeCount) && (dnSet.size() > 0))
+          || ((dataNodeCount == 1) && (dnSet.size() == dataNodeCount))) {
+        DatanodeInfo[] locs = new DatanodeInfo[dnSet.size()];
+        int i = 0;
+        for (DatanodeInfo dn:dnSet) {
+          locs[i++] = dn;
+        }
+        reportList.add(new LocatedBlock(blk, locs));
-      LocatedBlock [] lblocks = { new LocatedBlock(blk, locs) };
-      dfsClient.reportChecksumFailure(src, lblocks);
+    }
+    if (reportList.size() > 0) {
+      dfsClient.reportChecksumFailure(src,
+          reportList.toArray(new LocatedBlock[reportList.size()]));

INS44 INS39 INS42 INS70 INS25 INS66 INS66 INS66 INS66 INS66 INS74 INS59 INS44 MOV32 INS8 INS27 INS8 UPD43 MOV43 UPD43 MOV43 INS42 INS14 UPD74 MOV74 INS42 MOV60 MOV60 MOV25 INS32 INS34 INS21 UPD42 UPD42 INS74 INS32 UPD43 INS42 INS42 INS32 UPD43 MOV43 INS42 UPD42 MOV42 INS40 INS42 UPD42 MOV42 INS42 INS42 INS32 UPD42 UPD42 MOV42 INS42 INS3 INS9 UPD42 UPD42 MOV14 MOV5 INS32 INS42 INS42 INS9 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL74 DEL42 DEL32 DEL59 DEL42 DEL42 DEL4 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
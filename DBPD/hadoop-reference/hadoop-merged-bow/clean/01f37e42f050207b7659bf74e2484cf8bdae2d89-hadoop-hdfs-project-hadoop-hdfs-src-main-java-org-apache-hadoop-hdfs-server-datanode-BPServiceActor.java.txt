HDFS-5390. Send one incremental block report per storage directory.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1534891 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-  private final Map<Long, ReceivedDeletedBlockInfo> pendingIncrementalBR 
-    = Maps.newHashMap();
-  
+  private final Map<String, PerStoragePendingIncrementalBR>
+      pendingIncrementalBRperStorage = Maps.newConcurrentMap();
+
-
-    // check if there are newly received blocks
-    ReceivedDeletedBlockInfo[] receivedAndDeletedBlockArray = null;
-    synchronized (pendingIncrementalBR) {
-      int numBlocks = pendingIncrementalBR.size();
-      if (numBlocks > 0) {
-        //
-        // Send newly-received and deleted blockids to namenode
-        //
-        receivedAndDeletedBlockArray = pendingIncrementalBR
-            .values().toArray(new ReceivedDeletedBlockInfo[numBlocks]);
+    // For each storage, check if there are newly received blocks and if
+    // so then send an incremental report to the NameNode.
+    for (Map.Entry<String, PerStoragePendingIncrementalBR> entry :
+        pendingIncrementalBRperStorage.entrySet()) {
+      final String storageUuid = entry.getKey();
+      final PerStoragePendingIncrementalBR perStorageMap = entry.getValue();
+      ReceivedDeletedBlockInfo[] receivedAndDeletedBlockArray = null;
+      // TODO: We can probably use finer-grained synchronization now.
+      synchronized (pendingIncrementalBRperStorage) {
+        if (perStorageMap.getBlockInfoCount() > 0) {
+          // Send newly-received and deleted blockids to namenode
+          receivedAndDeletedBlockArray = perStorageMap.dequeueBlockInfos();
+          pendingReceivedRequests -= receivedAndDeletedBlockArray.length;
+        }
-      pendingIncrementalBR.clear();
-    }
-    if (receivedAndDeletedBlockArray != null) {
-      StorageReceivedDeletedBlocks[] report = { new StorageReceivedDeletedBlocks(
-          bpRegistration.getDatanodeUuid(), receivedAndDeletedBlockArray) };
-      boolean success = false;
-      try {
-        bpNamenode.blockReceivedAndDeleted(bpRegistration, bpos.getBlockPoolId(),
-            report);
-        success = true;
-      } finally {
-        synchronized (pendingIncrementalBR) {
-          if (!success) {
-            // If we didn't succeed in sending the report, put all of the
-            // blocks back onto our queue, but only in the case where we didn't
-            // put something newer in the meantime.
-            for (ReceivedDeletedBlockInfo rdbi : receivedAndDeletedBlockArray) {
-              if (!pendingIncrementalBR.containsKey(rdbi.getBlock().getBlockId())) {
-                pendingIncrementalBR.put(rdbi.getBlock().getBlockId(), rdbi);
-              }
+
+      if (receivedAndDeletedBlockArray != null) {
+        StorageReceivedDeletedBlocks[] report = { new StorageReceivedDeletedBlocks(
+            storageUuid, receivedAndDeletedBlockArray) };
+        boolean success = false;
+        try {
+          bpNamenode.blockReceivedAndDeleted(bpRegistration, bpos.getBlockPoolId(),
+              report);
+          success = true;
+        } finally {
+          synchronized (pendingIncrementalBRperStorage) {
+            if (!success) {
+              // If we didn't succeed in sending the report, put all of the
+              // blocks back onto our queue, but only in the case where we
+              // didn't put something newer in the meantime.
+              perStorageMap.putMissingBlockInfos(receivedAndDeletedBlockArray);
+              pendingReceivedRequests += perStorageMap.getBlockInfoCount();
-          pendingReceivedRequests = pendingIncrementalBR.size();
+  /**
+   * Retrieve the incremental BR state for a given storage UUID
+   * @param storageUuid
+   * @return
+   */
+  private PerStoragePendingIncrementalBR getIncrementalBRMapForStorage(
+      String storageUuid) {
+    PerStoragePendingIncrementalBR mapForStorage =
+        pendingIncrementalBRperStorage.get(storageUuid);
+
+    if (mapForStorage == null) {
+      // This is the first time we are adding incremental BR state for
+      // this storage so create a new map. This is required once per
+      // storage, per service actor.
+      mapForStorage = new PerStoragePendingIncrementalBR();
+      pendingIncrementalBRperStorage.put(storageUuid, mapForStorage);
+    }
+
+    return mapForStorage;
+  }
+
-  void notifyNamenodeBlockImmediately(ReceivedDeletedBlockInfo bInfo) {
-    synchronized (pendingIncrementalBR) {
-      pendingIncrementalBR.put(
-          bInfo.getBlock().getBlockId(), bInfo);
+  void notifyNamenodeBlockImmediately(
+      ReceivedDeletedBlockInfo bInfo, String storageUuid) {
+    synchronized (pendingIncrementalBRperStorage) {
+      getIncrementalBRMapForStorage(storageUuid).putBlockInfo(bInfo);
-      pendingIncrementalBR.notifyAll();
+      pendingIncrementalBRperStorage.notifyAll();
-  void notifyNamenodeDeletedBlock(ReceivedDeletedBlockInfo bInfo) {
-    synchronized (pendingIncrementalBR) {
-      pendingIncrementalBR.put(
-          bInfo.getBlock().getBlockId(), bInfo);
+  void notifyNamenodeDeletedBlock(
+      ReceivedDeletedBlockInfo bInfo, String storageUuid) {
+    synchronized (pendingIncrementalBRperStorage) {
+      getIncrementalBRMapForStorage(storageUuid).putBlockInfo(bInfo);
-    synchronized (pendingIncrementalBR) {
+    synchronized (pendingIncrementalBRperStorage) {
-      pendingIncrementalBR.notifyAll();
+      pendingIncrementalBRperStorage.notifyAll();
-          pendingIncrementalBR.wait(100);
+          pendingIncrementalBRperStorage.wait(100);
-    synchronized (pendingIncrementalBR) {
+    synchronized (pendingIncrementalBRperStorage) {
-      pendingIncrementalBR.notifyAll();
+      pendingIncrementalBRperStorage.notifyAll();
-          pendingIncrementalBR.wait(100);
+          pendingIncrementalBRperStorage.wait(100);
-    synchronized (pendingIncrementalBR) {
+    synchronized (pendingIncrementalBRperStorage) {
-      pendingIncrementalBR.notifyAll();
+      pendingIncrementalBRperStorage.notifyAll();
-          pendingIncrementalBR.wait(100);
+          pendingIncrementalBRperStorage.wait(100);
-        synchronized(pendingIncrementalBR) {
+        synchronized(pendingIncrementalBRperStorage) {
-              pendingIncrementalBR.wait(waitTime);
+              pendingIncrementalBRperStorage.wait(waitTime);
+  private static class PerStoragePendingIncrementalBR {
+    private Map<Long, ReceivedDeletedBlockInfo> pendingIncrementalBR =
+        Maps.newHashMap();
+
+    /**
+     * Return the number of blocks on this storage that have pending
+     * incremental block reports.
+     * @return
+     */
+    int getBlockInfoCount() {
+      return pendingIncrementalBR.size();
+    }
+
+    /**
+     * Dequeue and return all pending incremental block report state.
+     * @return
+     */
+    ReceivedDeletedBlockInfo[] dequeueBlockInfos() {
+      ReceivedDeletedBlockInfo[] blockInfos =
+          pendingIncrementalBR.values().toArray(
+              new ReceivedDeletedBlockInfo[getBlockInfoCount()]);
+
+      pendingIncrementalBR.clear();
+      return blockInfos;
+    }
+
+    /**
+     * Add blocks from blockArray to pendingIncrementalBR, unless the
+     * block already exists in pendingIncrementalBR.
+     * @param blockArray list of blocks to add.
+     */
+    void putMissingBlockInfos(ReceivedDeletedBlockInfo[] blockArray) {
+      for (ReceivedDeletedBlockInfo rdbi : blockArray) {
+        if (!pendingIncrementalBR.containsKey(rdbi.getBlock().getBlockId())) {
+          pendingIncrementalBR.put(rdbi.getBlock().getBlockId(), rdbi);
+        }
+      }
+    }
+
+    /**
+     * Add pending incremental block report for a single block.
+     * @param blockID
+     * @param blockInfo
+     */
+    void putBlockInfo(ReceivedDeletedBlockInfo blockInfo) {
+      pendingIncrementalBR.put(blockInfo.getBlock().getBlockId(), blockInfo);
+    }
+  }

MOV31 INS23 INS31 INS31 INS55 MOV29 INS83 INS83 INS74 INS59 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS44 MOV39 MOV42 MOV44 INS44 INS8 MOV29 MOV78 UPD42 MOV78 UPD42 MOV78 UPD42 INS83 INS83 INS42 MOV23 INS31 INS31 INS31 INS31 INS43 INS43 INS43 INS42 INS32 INS70 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS25 INS41 INS43 INS42 INS43 INS42 INS51 INS29 INS39 INS42 INS8 INS29 INS5 INS42 INS8 INS29 INS39 INS42 INS44 MOV8 INS29 INS39 INS42 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS44 INS32 MOV8 INS66 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS42 UPD42 INS42 UPD42 MOV42 INS8 UPD42 UPD42 UPD42 INS65 INS65 INS41 INS65 INS65 INS43 INS85 INS60 MOV21 INS41 INS65 INS65 INS5 INS42 INS65 INS65 INS65 INS43 INS42 MOV21 INS74 INS42 INS42 INS42 INS60 MOV60 INS51 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS21 MOV21 MOV21 MOV21 MOV21 INS66 INS66 MOV32 INS66 INS42 MOV5 INS59 INS42 INS66 INS66 INS42 INS66 INS43 INS85 UPD42 INS66 INS42 INS42 INS42 INS43 INS43 INS43 INS83 INS43 INS59 INS83 INS43 INS42 INS8 INS42 INS42 INS42 INS7 INS32 INS32 MOV27 MOV27 MOV27 INS42 INS32 INS42 UPD42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV25 INS42 INS14 INS42 INS42 INS42 INS42 MOV32 UPD42 MOV42 UPD42 INS32 INS42 INS42 UPD42 UPD42 UPD42 MOV32 INS42 INS3 INS42 INS42 UPD42 UPD42 INS43 UPD42 UPD42 INS42 INS42 UPD42 INS5 INS32 UPD42 INS32 INS21 INS42 INS43 INS85 INS42 INS42 INS42 INS7 UPD42 INS8 INS42 INS42 INS40 INS42 INS25 UPD42 UPD42 UPD42 UPD42 INS42 MOV38 INS8 INS21 MOV21 INS32 UPD7 INS42 INS42 INS42 INS32 UPD42 INS42 INS42 DEL40 DEL26 DEL39 DEL42 DEL42 DEL3 DEL42 DEL8 DEL51 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL8 DEL51 DEL8 DEL31 DEL83
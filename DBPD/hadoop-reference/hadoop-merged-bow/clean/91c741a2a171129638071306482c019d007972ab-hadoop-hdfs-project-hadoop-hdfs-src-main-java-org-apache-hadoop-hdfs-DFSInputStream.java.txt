HDFS-7782. Erasure coding: pread from files in striped layout. Contributed by Zhe Zhang and Jing Zhao

+import com.google.common.base.Preconditions;
-  private final DFSClient dfsClient;
+  protected final DFSClient dfsClient;
-  private LocatedBlock getBlockAt(long offset) throws IOException {
+  protected LocatedBlock getBlockAt(long offset) throws IOException {
-  private interface ReaderStrategy {
+  interface ReaderStrategy {
-  private void fetchBlockByteRange(long blockStartOffset, long start, long end,
+  protected void fetchBlockByteRange(long blockStartOffset, long start, long end,
+  /**
+   * Used when reading contiguous blocks
+   */
+    final int length = (int) (end - start + 1);
+    actualGetFromOneDataNode(datanode, block, start, end, buf,
+        new int[]{offset}, new int[]{length}, corruptedBlockMap);
+  }
+
+  /**
+   * Read data from one DataNode.
+   * @param datanode the datanode from which to read data
+   * @param block the block to read
+   * @param startInBlk the startInBlk offset of the block
+   * @param endInBlk the endInBlk offset of the block
+   * @param buf the given byte array into which the data is read
+   * @param offsets the data may be read into multiple segments of the buf
+   *                (when reading a striped block). this array indicates the
+   *                offset of each buf segment.
+   * @param lengths the length of each buf segment
+   * @param corruptedBlockMap map recording list of datanodes with corrupted
+   *                          block replica
+   */
+  void actualGetFromOneDataNode(final DNAddrPair datanode,
+      LocatedBlock block, final long startInBlk, final long endInBlk,
+      byte[] buf, int[] offsets, int[] lengths,
+      Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap)
+      throws IOException {
+    final int len = (int) (endInBlk - startInBlk + 1);
+    checkReadPortions(offsets, lengths, len);
-        int len = (int) (end - start + 1);
-        int nread = reader.readAll(buf, offset, len);
-        updateReadStatistics(readStatistics, nread, reader);
-
-        if (nread != len) {
-          throw new IOException("truncated return from reader.read(): " +
-                                "excpected " + len + ", got " + nread);
+        for (int i = 0; i < offsets.length; i++) {
+          int nread = reader.readAll(buf, offsets[i], lengths[i]);
+          updateReadStatistics(readStatistics, nread, reader);
+          if (nread != len) {
+            throw new IOException("truncated return from reader.read(): " +
+                "excpected " + len + ", got " + nread);
+          }
-   * Like {@link #fetchBlockByteRange} except we start up a second, parallel,
+   * This method verifies that the read portions are valid and do not overlap
+   * with each other.
+   */
+  private void checkReadPortions(int[] offsets, int[] lengths, int totalLen) {
+    Preconditions.checkArgument(offsets.length == lengths.length &&
+        offsets.length > 0);
+    int sum = 0;
+    for (int i = 0; i < lengths.length; i++) {
+      if (i > 0) {
+        int gap = offsets[i] - offsets[i - 1];
+        // make sure read portions do not overlap with each other
+        Preconditions.checkArgument(gap >= lengths[i - 1]);
+      }
+      sum += lengths[i];
+    }
+    Preconditions.checkArgument(sum == totalLen);
+  }
+
+  /**
+   * Like {@link #fetchBlockByteRange}except we start up a second, parallel,
-        if (dfsClient.isHedgedReadsEnabled()) {
+        if (dfsClient.isHedgedReadsEnabled() && !blk.isStriped()) {
-              targetStart + bytesToRead - 1, buffer, offset,
-              corruptedBlockMap);
+              targetStart + bytesToRead - 1, buffer, offset, corruptedBlockMap);
-  private static final class DNAddrPair {
+  static final class DNAddrPair {

INS26 INS40 INS31 INS31 UPD83 UPD83 UPD83 INS29 INS83 INS39 INS42 INS44 MOV44 MOV44 MOV44 INS44 MOV44 INS44 INS43 INS8 INS29 INS44 INS44 INS44 INS44 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS65 INS83 INS43 INS42 INS5 INS42 INS74 INS42 INS42 MOV60 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS5 INS42 INS5 INS42 INS60 INS21 INS65 INS5 INS42 INS5 INS42 INS39 INS42 INS21 INS60 INS24 INS21 INS66 INS42 INS39 INS85 INS43 INS43 INS74 INS83 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS39 INS85 INS39 INS85 INS83 INS39 INS59 INS32 INS66 INS66 INS39 INS85 INS39 INS85 INS32 INS39 INS59 INS58 INS27 INS37 INS8 INS32 UPD66 INS42 INS42 INS43 INS43 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS3 INS3 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS34 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS42 INS42 INS27 INS42 INS42 INS5 INS4 INS5 INS4 INS39 INS36 INS27 INS27 INS42 INS34 INS27 INS8 INS7 INS42 INS42 INS39 INS85 INS42 INS39 INS85 INS42 INS27 INS24 INS40 INS40 INS40 INS34 INS42 INS34 INS60 INS21 INS42 INS2 INS27 INS34 INS58 INS27 INS37 INS8 INS39 INS59 INS32 INS42 INS42 INS27 INS42 INS42 INS39 INS59 INS42 INS40 INS42 MOV60 MOV21 MOV25 INS42 INS27 INS42 INS42 INS27 MOV32 INS38 INS42 INS34 INS2 INS2 INS42 INS2 INS32 INS42 INS42 INS42 INS27 INS42 INS27 INS42 INS42 INS2 INS2 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS42 DEL83 DEL83 DEL42 DEL42 DEL83
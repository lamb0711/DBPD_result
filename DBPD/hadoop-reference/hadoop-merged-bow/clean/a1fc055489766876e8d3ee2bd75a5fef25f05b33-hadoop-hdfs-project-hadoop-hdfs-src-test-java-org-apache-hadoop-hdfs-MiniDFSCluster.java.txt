HDFS-1623. High Availability Framework for HDFS NN. Contributed by Todd Lipcon, Aaron T. Myers, Eli Collins, Uma Maheswara Rao G, Bikas Saha, Suresh Srinivas, Jitendra Nath Pandey, Hari Mankude, Brandon Li, Sanjay Radia, Mingjie Lai, and Gregory Chanan


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296534 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import org.apache.hadoop.fs.Path;
+
+
+import org.apache.hadoop.ha.HAServiceProtocol;
+import org.apache.hadoop.ha.HAServiceProtocolHelper;
+import org.apache.hadoop.ha.ServiceFailedException;
+import org.apache.hadoop.ha.protocolPB.HAServiceProtocolClientSideTranslatorPB;
+import org.apache.hadoop.hdfs.MiniDFSNNTopology.NNConf;
+import org.apache.hadoop.hdfs.protocol.ClientProtocol;
+import org.apache.hadoop.hdfs.server.datanode.DataNodeAdapter;
+import org.apache.hadoop.ipc.RPC;
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.google.common.io.Files;
+
-    private int numNameNodes = 1;
-    private boolean federation = false;
+    private MiniDFSNNTopology nnTopology = null;
-     * default false - non federated cluster
-     * @param val
-     * @return Builder object
-     */
-    public Builder federation (boolean val){
-      this.federation = val;
-      return this;
-    }
-    /**
-    public Builder numNameNodes(int val) {
-      this.numNameNodes = val;
-      return this;
-    }
-
-    /**
-     * Default: 1
-     */
+     * Default: a single namenode.
+     * See {@link MiniDFSNNTopology#simpleFederatedTopology(int)} to set up
+     * federated nameservices
+     */
+    public Builder nnTopology(MiniDFSNNTopology topology) {
+      this.nnTopology = topology;
+      return this;
+    }
+    
+    /**
-    LOG.info("starting cluster with " + builder.numNameNodes + " namenodes.");
-    nameNodes = new NameNodeInfo[builder.numNameNodes];
-    // try to determine if in federation mode
-    if(builder.numNameNodes > 1)
-      builder.federation = true;
+    if (builder.nnTopology == null) {
+      // If no topology is specified, build a single NN. 
+      builder.nnTopology = MiniDFSNNTopology.simpleSingleNN(
+          builder.nameNodePort, builder.nameNodeHttpPort);
+    }
+    
+    LOG.info("starting cluster with " + 
+        builder.nnTopology.countNameNodes() + " namenodes.");
+    nameNodes = new NameNodeInfo[builder.nnTopology.countNameNodes()];
-    initMiniDFSCluster(builder.nameNodePort,
-                       builder.nameNodeHttpPort,
-                       builder.conf,
+    initMiniDFSCluster(builder.conf,
-                       builder.federation);
+                       builder.nnTopology);
-  private boolean federation = false; 
+  private boolean federation;
+  
+  /**
+   * A unique instance identifier for the cluster. This
+   * is used to disambiguate HA filesystems in the case where
+   * multiple MiniDFSClusters are used in the same test suite. 
+   */
+  private int instanceId;
+  private static int instanceCount = 0;
-    NameNodeInfo(NameNode nn, Configuration conf) {
+    final String nameserviceId;
+    final String nnId;
+    NameNodeInfo(NameNode nn, String nameserviceId, String nnId,
+        Configuration conf) {
+      this.nameserviceId = nameserviceId;
+      this.nnId = nnId;
+    synchronized (MiniDFSCluster.class) {
+      instanceId = instanceCount++;
+    }
-    initMiniDFSCluster(nameNodePort, 0, conf, numDataNodes, format,
+    initMiniDFSCluster(conf, numDataNodes, format,
-        simulatedCapacities, null, true, false, false);
+        simulatedCapacities, null, true, false,
+        MiniDFSNNTopology.simpleSingleNN(nameNodePort, 0));
-  private void initMiniDFSCluster(int nameNodePort, int nameNodeHttpPort,
+  private void initMiniDFSCluster(
-      boolean waitSafeMode, boolean setupHostsFile, boolean federation) 
+      boolean waitSafeMode, boolean setupHostsFile,
+      MiniDFSNNTopology nnTopology)
+    synchronized (MiniDFSCluster.class) {
+      instanceId = instanceCount++;
+    }
+
-    this.federation = federation;
-    Collection<String> nameserviceIds = DFSUtil.getNameServiceIds(conf);
-    if(nameserviceIds.size() > 1)  
-      federation = true;
-  
-    if (!federation) {
-      conf.set(FS_DEFAULT_NAME_KEY, "127.0.0.1:" + nameNodePort);
-      conf.set(DFS_NAMENODE_HTTP_ADDRESS_KEY, "127.0.0.1:"
-          + nameNodeHttpPort);
-      NameNode nn = createNameNode(0, conf, numDataNodes, manageNameDfsDirs,
-          format, operation, clusterId);
-      nameNodes[0] = new NameNodeInfo(nn, conf);
-      FileSystem.setDefaultUri(conf, getURI(0));
-    } else {
-      if (nameserviceIds.isEmpty()) {
-        for (int i = 0; i < nameNodes.length; i++) {
-          nameserviceIds.add(NAMESERVICE_ID_PREFIX + i);
-        }
-      }
-      initFederationConf(conf, nameserviceIds, numDataNodes, nameNodePort);
-      createFederationNamenodes(conf, nameserviceIds, manageNameDfsDirs, format,
-          operation, clusterId);
+    // In an HA cluster, in order for the StandbyNode to perform checkpoints,
+    // it needs to know the HTTP port of the Active. So, if ephemeral ports
+    // are chosen, disable checkpoints for the test.
+    if (!nnTopology.allHttpPortsSpecified() &&
+        nnTopology.isHA()) {
+      LOG.info("MiniDFSCluster disabling checkpointing in the Standby node " +
+          "since no HTTP ports have been specified.");
+      conf.setBoolean(DFS_HA_STANDBY_CHECKPOINTS_KEY, false);
+    if (!nnTopology.allIpcPortsSpecified() &&
+        nnTopology.isHA()) {
+      LOG.info("MiniDFSCluster disabling log-roll triggering in the "
+          + "Standby node since no IPC ports have been specified.");
+      conf.setInt(DFS_HA_LOGROLL_PERIOD_KEY, -1);
+    }
+    
+    federation = nnTopology.isFederated();
+    createNameNodesAndSetConf(
+        nnTopology, manageNameDfsDirs, format, operation, clusterId, conf);
-  /** Initialize configuration for federated cluster */
-  private static void initFederationConf(Configuration conf,
-      Collection<String> nameserviceIds, int numDataNodes, int nnPort) {
-    String nameserviceIdList = "";
-    for (String nameserviceId : nameserviceIds) {
-      // Create comma separated list of nameserviceIds
-      if (nameserviceIdList.length() > 0) {
-        nameserviceIdList += ",";
+  private void createNameNodesAndSetConf(MiniDFSNNTopology nnTopology,
+      boolean manageNameDfsDirs, boolean format, StartupOption operation,
+      String clusterId,
+      Configuration conf) throws IOException {
+    Preconditions.checkArgument(nnTopology.countNameNodes() > 0,
+        "empty NN topology: no namenodes specified!");
+
+    if (!federation && nnTopology.countNameNodes() == 1) {
+      NNConf onlyNN = nnTopology.getOnlyNameNode();
+      // we only had one NN, set DEFAULT_NAME for it
+      conf.set(FS_DEFAULT_NAME_KEY, "127.0.0.1:" + onlyNN.getIpcPort());
+    }
+    
+    List<String> allNsIds = Lists.newArrayList();
+    for (MiniDFSNNTopology.NSConf nameservice : nnTopology.getNameservices()) {
+      if (nameservice.getId() != null) {
+        allNsIds.add(nameservice.getId());
-      nameserviceIdList += nameserviceId;
-      initFederatedNamenodeAddress(conf, nameserviceId, nnPort);
-      nnPort = nnPort == 0 ? 0 : nnPort + 2;
-    conf.set(DFS_FEDERATION_NAMESERVICES, nameserviceIdList);
-  }
-
-  /* For federated namenode initialize the address:port */
-  private static void initFederatedNamenodeAddress(Configuration conf,
-      String nameserviceId, int nnPort) {
-    // Set nameserviceId specific key
-    String key = DFSUtil.getNameServiceIdKey(
-        DFS_NAMENODE_HTTP_ADDRESS_KEY, nameserviceId);
-    conf.set(key, "127.0.0.1:0");
-
-    key = DFSUtil.getNameServiceIdKey(
-        DFS_NAMENODE_RPC_ADDRESS_KEY, nameserviceId);
-    conf.set(key, "127.0.0.1:" + nnPort);
-  }
-  
-  private void createFederationNamenodes(Configuration conf,
-      Collection<String> nameserviceIds, boolean manageNameDfsDirs,
-      boolean format, StartupOption operation, String clusterId)
-      throws IOException {
-    // Create namenodes in the cluster
+    if (!allNsIds.isEmpty()) {
+      conf.set(DFS_FEDERATION_NAMESERVICES, Joiner.on(",").join(allNsIds));
+    }
+    
-    for (String nameserviceId : nameserviceIds) {
-      createFederatedNameNode(nnCounter++, conf, numDataNodes, manageNameDfsDirs,
-          format, operation, clusterId, nameserviceId);
+    for (MiniDFSNNTopology.NSConf nameservice : nnTopology.getNameservices()) {
+      String nsId = nameservice.getId();
+      
+      Preconditions.checkArgument(
+          !federation || nsId != null,
+          "if there is more than one NS, they must have names");
+
+      // First set up the configuration which all of the NNs
+      // need to have - have to do this a priori before starting
+      // *any* of the NNs, so they know to come up in standby.
+      List<String> nnIds = Lists.newArrayList();
+      // Iterate over the NNs in this nameservice
+      for (NNConf nn : nameservice.getNNs()) {
+        nnIds.add(nn.getNnId());
+
+        initNameNodeAddress(conf, nameservice.getId(), nn);
+      }
+
+      // If HA is enabled on this nameservice, enumerate all the namenodes
+      // in the configuration. Also need to set a shared edits dir
+      if (nnIds.size() > 1) {
+        conf.set(DFSUtil.addKeySuffixes(DFS_HA_NAMENODES_KEY_PREFIX, nameservice.getId()),
+            Joiner.on(",").join(nnIds));
+        if (manageNameDfsDirs) {
+          URI sharedEditsUri = getSharedEditsDir(nnCounter, nnCounter+nnIds.size()-1); 
+          conf.set(DFS_NAMENODE_SHARED_EDITS_DIR_KEY, sharedEditsUri.toString());
+        }
+      }
+
+      // Now format first NN and copy the storage directory from that node to the others.
+      int i = 0;
+      Collection<URI> prevNNDirs = null;
+      int nnCounterForFormat = nnCounter;
+      for (NNConf nn : nameservice.getNNs()) {
+        initNameNodeConf(conf, nsId, nn.getNnId(), manageNameDfsDirs,
+            nnCounterForFormat);
+        Collection<URI> namespaceDirs = FSNamesystem.getNamespaceDirs(conf);
+        if (format) {
+          for (URI nameDirUri : namespaceDirs) {
+            File nameDir = new File(nameDirUri);
+            if (nameDir.exists() && !FileUtil.fullyDelete(nameDir)) {
+              throw new IOException("Could not fully delete " + nameDir);
+            }
+          }
+        }
+        
+        boolean formatThisOne = format;
+        if (format && i++ > 0) {
+          // Don't format the second NN in an HA setup - that
+          // would result in it having a different clusterID,
+          // block pool ID, etc. Instead, copy the name dirs
+          // from the first one.
+          formatThisOne = false;
+          assert (null != prevNNDirs);
+          copyNameDirs(prevNNDirs, namespaceDirs, conf);
+        }
+        
+        nnCounterForFormat++;
+        if (formatThisOne) {
+          DFSTestUtil.formatNameNode(conf);
+        }
+        prevNNDirs = namespaceDirs;
+      }
+
+      // Start all Namenodes
+      for (NNConf nn : nameservice.getNNs()) {
+        initNameNodeConf(conf, nsId, nn.getNnId(), manageNameDfsDirs, nnCounter);
+        createNameNode(nnCounter++, conf, numDataNodes, false, operation,
+            clusterId, nsId, nn.getNnId());
+      }
+      
+
-  private NameNode createNameNode(int nnIndex, Configuration conf,
-      int numDataNodes, boolean manageNameDfsDirs, boolean format,
-      StartupOption operation, String clusterId)
+  public URI getSharedEditsDir(int minNN, int maxNN) throws IOException {
+    return formatSharedEditsDir(base_dir, minNN, maxNN);
+  }
+  
+  public static URI formatSharedEditsDir(File baseDir, int minNN, int maxNN)
+    return fileAsURI(new File(baseDir, "shared-edits-" +
+        minNN + "-through-" + maxNN));
+  }
+  
+  public NameNodeInfo[] getNameNodeInfos() {
+    return this.nameNodes;
+  }
+
+  private void initNameNodeConf(Configuration conf,
+      String nameserviceId, String nnId,
+      boolean manageNameDfsDirs, int nnIndex)
+      throws IOException {
+    if (nameserviceId != null) {
+      conf.set(DFS_FEDERATION_NAMESERVICE_ID, nameserviceId);
+    }
+    if (nnId != null) {
+      conf.set(DFS_HA_NAMENODE_ID_KEY, nnId);
+    }
+    
-    
+  }
+
+  private void copyNameDirs(Collection<URI> srcDirs, Collection<URI> dstDirs,
+      Configuration dstConf) throws IOException {
+    URI srcDir = Lists.newArrayList(srcDirs).get(0);
+    FileSystem dstFS = FileSystem.getLocal(dstConf).getRaw();
+    for (URI dstDir : dstDirs) {
+      Preconditions.checkArgument(!dstDir.equals(srcDir));
+      File dstDirF = new File(dstDir);
+      if (dstDirF.exists()) {
+        Files.deleteRecursively(dstDirF);
+      }
+      LOG.info("Copying namedir from primary node dir "
+          + srcDir + " to " + dstDir);
+      FileUtil.copy(
+          new File(srcDir),
+          dstFS, new Path(dstDir), false, dstConf);
+    }
+  }
+
+  /**
+   * Initialize the address and port for this NameNode. In the
+   * non-federated case, the nameservice and namenode ID may be
+   * null.
+   */
+  private static void initNameNodeAddress(Configuration conf,
+      String nameserviceId, NNConf nnConf) {
+    // Set NN-specific specific key
+    String key = DFSUtil.addKeySuffixes(
+        DFS_NAMENODE_HTTP_ADDRESS_KEY, nameserviceId,
+        nnConf.getNnId());
+    conf.set(key, "127.0.0.1:" + nnConf.getHttpPort());
+
+    key = DFSUtil.addKeySuffixes(
+        DFS_NAMENODE_RPC_ADDRESS_KEY, nameserviceId,
+        nnConf.getNnId());
+    conf.set(key, "127.0.0.1:" + nnConf.getIpcPort());
+  }
+  
+  private void createNameNode(int nnIndex, Configuration conf,
+      int numDataNodes, boolean format, StartupOption operation,
+      String clusterId, String nameserviceId,
+      String nnId)
+      throws IOException {
-    return NameNode.createNameNode(args, conf);
-  }
-  
-  private void createFederatedNameNode(int nnIndex, Configuration conf,
-      int numDataNodes, boolean manageNameDfsDirs, boolean format,
-      StartupOption operation, String clusterId, String nameserviceId)
-      throws IOException {
-    conf.set(DFS_FEDERATION_NAMESERVICE_ID, nameserviceId);
-    NameNode nn = createNameNode(nnIndex, conf, numDataNodes, manageNameDfsDirs,
-        format, operation, clusterId);
-    conf.set(DFSUtil.getNameServiceIdKey(
-        DFS_NAMENODE_RPC_ADDRESS_KEY, nameserviceId), NetUtils
+    NameNode nn =  NameNode.createNameNode(args, conf);
+    
+    // After the NN has started, set back the bound ports into
+    // the conf
+    conf.set(DFSUtil.addKeySuffixes(
+        DFS_NAMENODE_RPC_ADDRESS_KEY, nameserviceId, nnId), NetUtils
-    conf.set(DFSUtil.getNameServiceIdKey(
-        DFS_NAMENODE_HTTP_ADDRESS_KEY, nameserviceId), NetUtils
+    conf.set(DFSUtil.addKeySuffixes(
+        DFS_NAMENODE_HTTP_ADDRESS_KEY, nameserviceId, nnId), NetUtils
-    DFSUtil.setGenericConf(conf, nameserviceId, 
+    DFSUtil.setGenericConf(conf, nameserviceId, nnId,
-    nameNodes[nnIndex] = new NameNodeInfo(nn, new Configuration(conf));
+    nameNodes[nnIndex] = new NameNodeInfo(nn, nameserviceId, nnId,
+        new Configuration(conf));
+  
+  public int getInstanceId() {
+    return instanceId;
+  }
-    return getNameNode(0).getRpcServer();
+    return getNameNodeRpc(0);
+  }
+  
+  /**
+   * Get an instance of the NameNode's RPC handler.
+   */
+  public NamenodeProtocols getNameNodeRpc(int nnIndex) {
+    return getNameNode(nnIndex).getRpcServer();
+      if (nnInfo == null) continue;
-      nameNodes[nnIndex] = new NameNodeInfo(null, conf);
+      nameNodes[nnIndex] = new NameNodeInfo(null, null, null, conf);
+    }
+  }
+  
+  /**
+   * Restart all namenodes.
+   */
+  public synchronized void restartNameNodes() throws IOException {
+    for (int i = 0; i < nameNodes.length; i++) {
+      restartNameNode(i);
+    String nameserviceId = nameNodes[nnIndex].nameserviceId;
+    String nnId = nameNodes[nnIndex].nnId;
-    nameNodes[nnIndex] = new NameNodeInfo(nn, conf);
+    nameNodes[nnIndex] = new NameNodeInfo(nn, nameserviceId, nnId, conf);
-    try {
-      sizes = nameNode.getRpcServer().getStats();
-    } catch (IOException ioe) {
-      // This method above should never throw.
-      // It only throws IOE since it is exposed via RPC
-      throw (AssertionError)(new AssertionError("Unexpected IOE thrown: "
-          + StringUtils.stringifyException(ioe)).initCause(ioe));
-    }
+    sizes = NameNodeAdapter.getStats(nameNode.getNamesystem());
-      isUp = ((!nameNode.isInSafeMode() || !waitSafeMode) && sizes[0] != 0);
+      isUp = ((!nameNode.isInSafeMode() || !waitSafeMode) &&
+          sizes[ClientProtocol.GET_STATS_CAPACITY_IDX] != 0);
-  public Collection<URI> getNameEditsDirs(int nnIndex) {
+  public Collection<URI> getNameEditsDirs(int nnIndex) throws IOException {
+  
+  private HAServiceProtocol getHaServiceClient(int nnIndex) throws IOException {
+    InetSocketAddress addr = nameNodes[nnIndex].nameNode.getServiceRpcAddress();
+    return new HAServiceProtocolClientSideTranslatorPB(addr, conf);
+  }
+  
+  public void transitionToActive(int nnIndex) throws IOException,
+      ServiceFailedException {
+    HAServiceProtocolHelper.transitionToActive(getHaServiceClient(nnIndex));
+  }
+  
+  public void transitionToStandby(int nnIndex) throws IOException,
+      ServiceFailedException {
+    HAServiceProtocolHelper.transitionToStandby(getHaServiceClient(nnIndex));
+  }
+  
+  
+  public void triggerBlockReports()
+      throws IOException {
+    for (DataNode dn : getDataNodes()) {
+      DataNodeAdapter.triggerBlockReport(dn);
+    }
+  }
+
+
+  public void triggerDeletionReports()
+      throws IOException {
+    for (DataNode dn : getDataNodes()) {
+      DataNodeAdapter.triggerDeletionReport(dn);
+    }
+  }
+
+  public void triggerHeartbeats()
+      throws IOException {
+    for (DataNode dn : getDataNodes()) {
+      DataNodeAdapter.triggerHeartbeat(dn);
+    }
+  }
+
+    assert addr.getPort() != 0;
-      if (!dn.datanode.isBPServiceAlive(addr)) {
-        LOG.warn("BPOfferService failed to start in datanode " + dn.datanode
-            + " for namenode at " + addr);
+      if (!dn.datanode.isConnectedToNN(addr)) {
+        LOG.warn("BPOfferService in datanode " + dn.datanode
+            + " failed to connect to namenode at " + addr);
+  
+  public void setWaitSafeMode(boolean wait) {
+    this.waitSafeMode = wait;
+  }
-    
+
-    
-    initFederatedNamenodeAddress(conf, nameserviceId, namenodePort);
-    createFederatedNameNode(nnIndex, conf, numDataNodes, true, true, null,
-        null, nameserviceId);
+  
+    String nnId = null;
+    initNameNodeAddress(conf, nameserviceId,
+        new NNConf(nnId).setIpcPort(namenodePort));
+    initNameNodeConf(conf, nameserviceId, nnId, true, nnIndex);
+    createNameNode(nnIndex, conf, numDataNodes, true, null, null,
+        nameserviceId, nnId);

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 MOV23 INS23 INS23 MOV44 INS31 INS31 INS31 INS31 MOV44 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS23 INS23 INS83 MOV39 UPD42 MOV42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 INS8 UPD83 MOV83 INS43 INS42 INS44 INS44 INS43 INS8 INS83 MOV83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS5 INS42 INS8 INS39 UPD42 MOV44 INS44 INS83 MOV39 UPD42 MOV42 INS44 INS44 MOV44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 MOV44 MOV44 INS44 MOV8 UPD42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 UPD83 MOV83 UPD39 MOV39 INS42 INS8 INS29 INS83 INS43 UPD42 MOV42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS43 MOV8 INS43 INS83 INS43 INS42 MOV44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS43 INS29 MOV83 MOV43 UPD42 MOV42 MOV44 MOV8 INS25 MOV65 INS42 INS42 INS34 INS83 INS43 INS59 INS83 MOV43 INS59 INS44 INS44 INS51 INS43 UPD42 INS51 INS25 INS25 MOV21 MOV21 INS43 UPD42 INS21 INS25 INS60 INS70 INS25 MOV60 INS70 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS43 INS85 INS41 MOV43 INS42 INS25 INS25 INS74 INS42 INS74 INS42 UPD42 INS42 INS60 INS60 INS70 INS65 INS43 UPD42 MOV42 INS43 UPD42 MOV25 MOV25 MOV60 INS60 INS21 MOV21 INS21 MOV21 INS41 INS65 INS42 UPD42 INS41 INS65 INS42 INS60 INS60 MOV21 INS42 INS42 UPD39 UPD42 UPD42 MOV42 INS60 INS41 INS39 INS42 UPD42 MOV42 INS42 MOV21 INS39 INS42 UPD42 MOV42 INS42 INS21 INS42 INS70 INS42 INS70 INS42 INS70 INS6 INS39 INS42 INS21 INS60 INS21 INS42 UPD42 INS33 INS65 INS43 INS42 INS27 INS8 UPD66 INS66 INS66 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS57 INS8 INS42 INS57 INS8 INS27 INS8 INS27 INS8 INS7 INS42 INS32 INS27 INS8 UPD74 MOV74 INS59 INS44 INS32 INS8 INS38 INS8 INS44 INS32 INS8 INS32 INS42 INS32 INS42 INS22 INS27 INS8 INS27 INS8 INS43 INS43 INS43 INS43 INS43 INS59 INS43 INS59 INS44 INS42 INS8 INS66 INS66 INS66 INS42 INS43 INS42 MOV43 INS59 INS32 INS32 INS42 INS32 INS66 INS32 INS66 INS43 INS59 INS43 INS59 INS43 INS59 INS14 INS32 INS44 INS32 INS8 INS44 INS32 INS8 INS44 INS32 INS8 INS27 INS7 INS43 INS59 INS32 UPD66 MOV66 UPD66 MOV66 INS65 UPD66 MOV66 INS66 INS42 INS40 INS33 INS21 UPD40 INS42 INS42 INS7 INS7 INS43 INS21 INS32 INS43 MOV21 INS38 MOV32 MOV21 MOV21 INS38 INS32 MOV21 MOV21 INS42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS27 INS45 MOV38 INS27 INS60 INS21 UPD43 INS42 INS32 INS43 UPD42 MOV42 INS42 INS42 INS25 INS32 INS21 INS43 UPD42 MOV42 INS42 INS42 MOV60 INS21 INS60 INS70 MOV25 INS60 INS60 INS60 INS70 INS70 INS42 INS42 INS42 INS42 INS42 INS14 INS52 INS42 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS21 INS60 INS25 INS21 INS21 INS42 INS27 INS42 MOV32 INS42 INS42 INS32 MOV32 UPD42 INS32 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV34 INS32 INS42 INS25 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS32 INS43 INS42 INS42 UPD42 UPD42 INS32 UPD42 MOV42 INS42 INS32 INS43 INS42 UPD42 MOV42 INS21 INS43 INS42 UPD42 MOV42 INS21 INS43 INS42 UPD42 MOV42 INS21 INS32 INS34 INS22 INS42 INS42 INS42 INS33 UPD42 INS32 INS42 INS42 INS42 INS42 INS9 INS42 UPD42 INS42 INS68 UPD42 INS7 INS32 INS32 INS22 INS42 INS22 INS42 INS42 INS7 INS42 INS42 INS42 INS34 INS42 INS32 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 INS34 INS32 INS34 INS43 INS59 INS32 UPD42 INS42 INS42 INS40 INS27 INS8 INS42 INS42 INS32 INS40 MOV43 INS32 UPD74 MOV74 INS59 MOV44 INS32 INS8 INS39 INS59 INS74 INS59 INS39 INS59 INS44 INS32 INS8 INS44 INS32 INS8 INS43 INS42 INS27 INS32 INS32 INS32 INS42 INS34 INS32 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS32 INS32 UPD42 INS32 INS45 INS32 UPD42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS27 INS18 MOV2 INS42 INS2 INS42 MOV43 INS42 INS42 UPD42 INS42 INS42 INS22 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS52 INS42 INS14 INS42 MOV42 INS42 INS42 INS69 UPD42 INS40 INS32 INS40 INS42 INS40 INS42 INS52 INS42 INS52 INS42 INS42 INS37 INS42 INS37 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS9 INS42 INS42 INS42 INS42 INS27 UPD42 UPD42 UPD42 INS38 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS32 INS33 INS21 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS45 UPD43 INS42 INS32 UPD43 UPD42 INS42 INS42 INS21 INS21 UPD34 INS25 INS42 INS34 INS43 INS43 INS42 INS33 INS42 INS42 INS43 INS42 INS42 INS42 MOV21 INS60 INS25 INS60 INS25 INS21 INS25 INS21 INS43 INS42 INS42 INS42 INS21 MOV21 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS42 INS42 INS14 INS42 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS14 INS42 INS14 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS2 UPD42 INS42 INS42 INS42 UPD42 INS2 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS42 INS39 INS42 INS42 INS40 INS40 INS42 INS42 INS45 UPD45 INS45 INS45 INS34 INS42 INS42 INS45 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS38 INS27 UPD42 INS42 INS42 UPD42 INS32 INS32 UPD42 UPD42 INS32 INS42 INS8 INS42 INS42 INS42 INS74 INS59 INS42 INS8 INS39 INS59 INS27 INS8 INS37 INS42 INS8 INS7 INS42 INS32 INS32 INS43 INS42 INS32 INS45 INS42 INS45 INS42 INS43 INS42 INS43 INS42 INS42 INS42 MOV43 INS33 INS33 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS60 INS21 UPD42 UPD42 INS32 INS42 INS42 INS43 INS43 INS42 INS32 INS70 INS42 INS42 UPD42 MOV42 INS27 INS21 INS6 INS21 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 MOV37 UPD42 INS9 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS43 INS59 INS32 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS44 INS42 INS8 INS37 MOV34 INS7 INS36 INS32 INS32 INS42 INS42 UPD42 MOV42 INS42 UPD45 UPD45 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS43 INS42 INS60 INS25 INS42 INS42 INS9 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS33 UPD42 MOV42 INS27 INS34 INS42 INS42 INS14 INS32 INS38 INS53 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS27 INS45 INS42 DEL39 DEL34 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL65 DEL42 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL41 DEL8 DEL31 DEL65 DEL29 DEL31 DEL39 DEL42 DEL40 DEL40 DEL40 DEL34 DEL27 DEL40 DEL9 DEL7 DEL21 DEL25 DEL40 DEL40 DEL9 DEL42 DEL34 DEL9 DEL39 DEL42 DEL44 DEL39 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL45 DEL42 DEL27 DEL42 DEL34 DEL2 DEL42 DEL43 DEL42 DEL42 DEL14 DEL7 DEL42 DEL34 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL34 DEL27 DEL42 DEL9 DEL7 DEL21 DEL25 DEL42 DEL43 DEL42 DEL42 DEL34 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL42 DEL32 DEL25 DEL8 DEL25 DEL42 DEL45 DEL42 DEL45 DEL7 DEL29 DEL83 DEL83 DEL39 DEL44 DEL39 DEL44 DEL42 DEL42 DEL42 DEL7 DEL21 DEL42 DEL27 DEL34 DEL34 DEL27 DEL16 DEL7 DEL21 DEL8 DEL70 DEL8 DEL31 DEL39 DEL44 DEL31 DEL41 DEL45 DEL42 DEL42 DEL42 DEL8 DEL70 DEL39 DEL42 DEL44 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL27 DEL42 DEL8 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL14 DEL42 DEL42 DEL32 DEL36 DEL11 DEL53 DEL8 DEL12 DEL54 DEL34 DEL9
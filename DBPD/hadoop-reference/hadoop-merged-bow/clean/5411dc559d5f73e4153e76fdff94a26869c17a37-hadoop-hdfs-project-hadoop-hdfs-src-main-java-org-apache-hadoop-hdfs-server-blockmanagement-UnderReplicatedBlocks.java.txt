HDFS-9205. Do not schedule corrupt blocks for replication.  (szetszwo)

+import java.util.LinkedList;
-import org.apache.hadoop.hdfs.util.LightWeightLinkedSet;
+
+import org.apache.hadoop.hdfs.util.LightWeightLinkedSet;
- * is implemented in {@link #getPriority(BlockInfo, int, int, int)}.
+ * is implemented in {@link #getPriority(BlockInfo, int, int, int, int)}.
+                          int readOnlyReplicas,
-      return getPriorityContiguous(curReplicas, decommissionedReplicas,
-          expectedReplicas);
+      return getPriorityContiguous(curReplicas, readOnlyReplicas,
+          decommissionedReplicas, expectedReplicas);
-  private int getPriorityContiguous(int curReplicas, int decommissionedReplicas,
-      int expectedReplicas) {
+  private int getPriorityContiguous(int curReplicas, int readOnlyReplicas,
+      int decommissionedReplicas, int expectedReplicas) {
+      if (readOnlyReplicas > 0) {
+        // only has read-only replicas, highest risk
+        // since the read-only replicas may go down all together.
+        return QUEUE_HIGHEST_PRIORITY;
+      }
+                           int readOnlyReplicas,
-    int priLevel = getPriority(block, curReplicas, decomissionedReplicas,
-                               expectedReplicas);
+    final int priLevel = getPriority(block, curReplicas, readOnlyReplicas,
+        decomissionedReplicas, expectedReplicas);
+                              int oldReadOnlyReplicas,
-    int priLevel = getPriority(block, oldReplicas,
-                               decommissionedReplicas,
-                               oldExpectedReplicas);
+    final int priLevel = getPriority(block, oldReplicas, oldReadOnlyReplicas,
+        decommissionedReplicas, oldExpectedReplicas);
-        if (priorityQueues.get(i).remove(block)) {
+        if (i != priLevel && priorityQueues.get(i).remove(block)) {
-                  " {} from priority queue {}", block, priLevel);
+                  " {} from priority queue {}", block, i);
-                           int decommissionedReplicas,
+                           int readOnlyReplicas, int decommissionedReplicas,
-    int curPri = getPriority(block, curReplicas, decommissionedReplicas,
-        curExpectedReplicas);
-    int oldPri = getPriority(block, oldReplicas, decommissionedReplicas,
-        oldExpectedReplicas);
+    int curPri = getPriority(block, curReplicas, readOnlyReplicas,
+        decommissionedReplicas, curExpectedReplicas);
+    int oldPri = getPriority(block, oldReplicas, readOnlyReplicas,
+        decommissionedReplicas, oldExpectedReplicas);
-  public synchronized List<List<BlockInfo>> chooseUnderReplicatedBlocks(
+  synchronized List<List<BlockInfo>> chooseUnderReplicatedBlocks(
-    // initialize data structure for the return value
-    List<List<BlockInfo>> blocksToReplicate = new ArrayList<>(LEVEL);
-    for (int i = 0; i < LEVEL; i++) {
-      blocksToReplicate.add(new ArrayList<BlockInfo>());
-    }
-
-    if (size() == 0) { // There are no blocks to collect.
-      return blocksToReplicate;
-    }
+    final List<List<BlockInfo>> blocksToReplicate = new ArrayList<>(LEVEL);
-    int blockCount = 0;
-    for (int priority = 0; priority < LEVEL; priority++) { 
-      // Go through all blocks that need replications with current priority.
-      BlockIterator neededReplicationsIterator = iterator(priority);
-      // Set the iterator to the first unprocessed block at this priority level.
-      neededReplicationsIterator.setToBookmark();
+    int count = 0;
+    int priority = 0;
+    for (; count < blocksToProcess && priority < LEVEL; priority++) {
+      if (priority == QUEUE_WITH_CORRUPT_BLOCKS) {
+        // do not choose corrupted blocks.
+        continue;
+      }
-      blocksToProcess = Math.min(blocksToProcess, size());
-      
-      if (blockCount == blocksToProcess) {
-        break;  // break if already expected blocks are obtained
-      }
-      
+      // Go through all blocks that need replications with current priority.
+      // Set the iterator to the first unprocessed block at this priority level.
+      final Iterator<BlockInfo> i = priorityQueues.get(priority).getBookmark();
+      final List<BlockInfo> blocks = new LinkedList<>();
+      blocksToReplicate.add(blocks);
-      while (blockCount < blocksToProcess
-          && neededReplicationsIterator.hasNext()) {
-        BlockInfo block = neededReplicationsIterator.next();
-        blocksToReplicate.get(priority).add(block);
-        blockCount++;
-      }
-      
-      if (!neededReplicationsIterator.hasNext()
-          && neededReplicationsIterator.getPriority() == LEVEL - 1) {
-        // Reset all priorities' bookmarks to the beginning because there were
-        // no recently added blocks in any list.
-        for (int i = 0; i < LEVEL; i++) {
-          this.priorityQueues.get(i).resetBookmark();
-        }
-        break;
+      for(; count < blocksToProcess && i.hasNext(); count++) {
+        blocks.add(i.next());
+
+    if (priority == LEVEL) {
+      // Reset all bookmarks because there were no recently added blocks.
+      for (LightWeightLinkedSet<BlockInfo> q : priorityQueues) {
+        q.resetBookmark();
+      }
+    }
+
-  synchronized BlockIterator iterator(int level) {
-    return new BlockIterator(level);
+  synchronized Iterator<BlockInfo> iterator(int level) {
+    return priorityQueues.get(level).iterator();
-  public synchronized BlockIterator iterator() {
-    return new BlockIterator();
-  }
+  public synchronized Iterator<BlockInfo> iterator() {
+    final Iterator<LightWeightLinkedSet<BlockInfo>> q = priorityQueues.iterator();
+    return new Iterator<BlockInfo>() {
+      private Iterator<BlockInfo> b = q.next().iterator();
-  /**
-   * An iterator over blocks.
-   */
-  class BlockIterator implements Iterator<BlockInfo> {
-    private int level;
-    private boolean isIteratorForLevel = false;
-    private final List<Iterator<BlockInfo>> iterators = new ArrayList<>();
-
-    /**
-     * Construct an iterator over all queues.
-     */
-    private BlockIterator() {
-      level=0;
-      for(int i=0; i<LEVEL; i++) {
-        iterators.add(priorityQueues.get(i).iterator());
+      @Override
+      public BlockInfo next() {
+        hasNext();
+        return b.next();
-    }
-    /**
-     * Constrict an iterator for a single queue level
-     * @param l the priority level to iterate over
-     */
-    private BlockIterator(int l) {
-      level = l;
-      isIteratorForLevel = true;
-      iterators.add(priorityQueues.get(level).iterator());
-    }
-
-    private void update() {
-      if (isIteratorForLevel) {
-        return;
-      }
-      while(level< LEVEL-1 && !iterators.get(level).hasNext()) {
-        level++;
-      }
-    }
-
-    @Override
-    public BlockInfo next() {
-      if (isIteratorForLevel) {
-        return iterators.get(0).next();
-      }
-      update();
-      return iterators.get(level).next();
-    }
-
-    @Override
-    public boolean hasNext() {
-      if (isIteratorForLevel) {
-        return iterators.get(0).hasNext();
-      }
-      update();
-      return iterators.get(level).hasNext();
-    }
-
-    @Override
-    public void remove() {
-      if (isIteratorForLevel) {
-        iterators.get(0).remove();
-      } else {
-        iterators.get(level).remove();
-      }
-    }
-
-    int getPriority() {
-      return level;
-    }
-
-    /**
-     * Sets iterator(s) to bookmarked elements.
-     */
-    private synchronized void setToBookmark() {
-      if (this.isIteratorForLevel) {
-        this.iterators.set(0, priorityQueues.get(this.level)
-            .getBookmark());
-      } else {
-        for(int i=0; i<LEVEL; i++) {
-          this.iterators.set(i, priorityQueues.get(i).getBookmark());
+      @Override
+      public boolean hasNext() {
+        for(; !b.hasNext() && q.hasNext(); ) {
+          b = q.next().iterator();
+        return b.hasNext();
-    }
+
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };

MOV26 INS26 INS40 INS31 INS44 INS44 INS44 INS44 INS44 MOV74 MOV8 MOV29 MOV78 MOV83 MOV83 INS74 INS42 INS8 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS60 INS60 INS24 MOV25 INS41 INS43 INS43 INS60 INS41 INS83 INS83 INS83 INS39 INS59 INS39 MOV59 INS27 MOV37 INS8 INS27 MOV32 UPD42 MOV42 UPD42 MOV42 INS83 INS74 INS59 INS14 INS69 INS25 UPD42 MOV42 MOV34 INS27 MOV27 MOV25 MOV60 INS60 MOV21 INS24 INS42 MOV42 INS70 UPD43 MOV43 INS74 INS42 INS32 INS74 INS1 INS39 INS27 INS8 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS83 INS74 INS83 UPD74 MOV74 INS59 INS32 INS27 INS37 INS8 INS44 INS42 INS8 UPD42 UPD43 MOV43 INS43 MOV42 MOV42 INS43 INS43 INS23 INS31 INS31 INS31 INS42 INS42 INS34 INS41 INS42 INS42 INS18 INS43 INS43 UPD42 INS32 UPD43 INS42 INS14 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV27 MOV32 INS42 MOV21 INS74 INS42 MOV21 UPD42 INS42 INS42 INS42 INS83 MOV74 INS59 MOV78 MOV83 MOV43 MOV42 MOV8 MOV78 MOV83 MOV39 MOV42 INS8 MOV78 UPD83 MOV83 MOV39 UPD42 MOV42 INS8 INS42 INS27 UPD42 MOV42 INS42 INS32 INS42 UPD42 INS74 UPD42 UPD42 INS43 MOV43 INS42 INS32 INS24 INS41 INS53 INS27 MOV32 UPD42 MOV42 INS42 MOV42 INS43 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 MOV32 UPD42 MOV42 INS27 INS8 INS32 INS14 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV42 INS38 INS32 MOV21 UPD42 MOV42 UPD42 MOV42 INS43 UPD42 INS32 UPD42 MOV42 MOV42 INS7 INS42 UPD42 MOV42 MOV42 INS42 INS32 MOV32 UPD42 MOV42 UPD42 UPD42 DEL83 DEL42 DEL32 DEL34 DEL42 DEL41 DEL43 DEL32 DEL42 DEL42 DEL32 DEL32 DEL7 DEL32 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL8 DEL24 DEL10 DEL39 DEL59 DEL58 DEL27 DEL42 DEL37 DEL42 DEL42 DEL14 DEL32 DEL21 DEL8 DEL24 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL58 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL27 DEL10 DEL8 DEL25 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL37 DEL21 DEL8 DEL61 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL32 DEL43 DEL42 DEL43 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL74 DEL42 DEL74 DEL14 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL34 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL34 DEL27 DEL27 DEL32 DEL38 DEL27 DEL42 DEL37 DEL21 DEL8 DEL61 DEL8 DEL31 DEL31 DEL42 DEL42 DEL34 DEL32 DEL32 DEL41 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL8 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL34 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL32 DEL21 DEL8 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL31 DEL55
HDDS-1753. Datanode unable to find chunk while replication data using ratis. (#1318)


+import org.apache.hadoop.hdds.scm.pipeline.PipelineID;
-import org.apache.hadoop.ozone.container.common.impl.ContainerSet;
+import org.apache.hadoop.ozone.container.common.transport.server.ratis.XceiverServerRatis;
+import org.apache.hadoop.ozone.container.ozoneimpl.OzoneContainer;
+import java.io.IOException;
+import java.util.UUID;
+import java.util.stream.Collectors;
-public class BlockDeletingService extends BackgroundService{
+public class BlockDeletingService extends BackgroundService {
-  private ContainerSet containerSet;
+  private OzoneContainer ozoneContainer;
-  public BlockDeletingService(ContainerSet containerSet, long serviceInterval,
-      long serviceTimeout, TimeUnit timeUnit, Configuration conf) {
+  public BlockDeletingService(OzoneContainer ozoneContainer,
+      long serviceInterval, long serviceTimeout, TimeUnit timeUnit,
+      Configuration conf) {
-    this.containerSet = containerSet;
+    this.ozoneContainer = ozoneContainer;
-    this.blockLimitPerTask = conf.getInt(
-        OZONE_BLOCK_DELETING_LIMIT_PER_CONTAINER,
-        OZONE_BLOCK_DELETING_LIMIT_PER_CONTAINER_DEFAULT);
-    this.containerLimitPerInterval = conf.getInt(
-        OZONE_BLOCK_DELETING_CONTAINER_LIMIT_PER_INTERVAL,
-        OZONE_BLOCK_DELETING_CONTAINER_LIMIT_PER_INTERVAL_DEFAULT);
+    this.blockLimitPerTask =
+        conf.getInt(OZONE_BLOCK_DELETING_LIMIT_PER_CONTAINER,
+            OZONE_BLOCK_DELETING_LIMIT_PER_CONTAINER_DEFAULT);
+    this.containerLimitPerInterval =
+        conf.getInt(OZONE_BLOCK_DELETING_CONTAINER_LIMIT_PER_INTERVAL,
+            OZONE_BLOCK_DELETING_CONTAINER_LIMIT_PER_INTERVAL_DEFAULT);
-      containers = containerSet.chooseContainerForBlockDeletion(
-          containerLimitPerInterval, containerDeletionPolicy);
+      containers = chooseContainerForBlockDeletion(containerLimitPerInterval,
+              containerDeletionPolicy);
+  public List<ContainerData> chooseContainerForBlockDeletion(int count,
+      ContainerDeletionChoosingPolicy deletionPolicy)
+      throws StorageContainerException {
+    Map<Long, ContainerData> containerDataMap =
+        ozoneContainer.getContainerSet().getContainerMap().entrySet().stream()
+            .filter(e -> isDeletionAllowed(e.getValue().getContainerData(),
+                deletionPolicy)).collect(Collectors
+            .toMap(Map.Entry::getKey, e -> e.getValue().getContainerData()));
+    return deletionPolicy
+        .chooseContainerForBlockDeletion(count, containerDataMap);
+  }
+
+  private boolean isDeletionAllowed(ContainerData containerData,
+      ContainerDeletionChoosingPolicy deletionPolicy) {
+    if (!deletionPolicy
+        .isValidContainerType(containerData.getContainerType())) {
+      return false;
+    } else if (!containerData.isClosed()) {
+      return false;
+    } else {
+      if (ozoneContainer.getWriteChannel() instanceof XceiverServerRatis) {
+        XceiverServerRatis ratisServer =
+            (XceiverServerRatis) ozoneContainer.getWriteChannel();
+        PipelineID pipelineID = PipelineID
+            .valueOf(UUID.fromString(containerData.getOriginPipelineId()));
+        // in case te ratis group does not exist, just mark it for deletion.
+        if (!ratisServer.isExist(pipelineID.getProtobuf())) {
+          return true;
+        }
+        try {
+          long minReplicatedIndex =
+              ratisServer.getMinReplicatedIndex(pipelineID);
+          long containerBCSID = containerData.getBlockCommitSequenceId();
+          if (minReplicatedIndex >= 0 && minReplicatedIndex < containerBCSID) {
+            LOG.warn("Close Container log Index {} is not replicated across all"
+                    + "the servers in the pipeline {} as the min replicated "
+                    + "index is {}. Deletion is not allowed in this container "
+                    + "yet.", containerBCSID,
+                containerData.getOriginPipelineId(), minReplicatedIndex);
+            return false;
+          } else {
+            return true;
+          }
+        } catch (IOException ioe) {
+          // in case of any exception check again whether the pipeline exist
+          // and in case the pipeline got destroyed, just mark it for deletion
+          if (!ratisServer.isExist(pipelineID.getProtobuf())) {
+            return true;
+          } else {
+            LOG.info(ioe.getMessage());
+            return false;
+          }
+        }
+      }
+      return true;
+    }
+  }
+

MOV26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS31 INS31 UPD43 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS8 UPD42 UPD42 UPD43 UPD42 INS43 INS43 INS39 INS42 INS43 INS42 INS42 INS60 INS41 INS43 INS42 INS43 INS42 INS25 UPD42 INS42 INS42 INS42 INS74 INS59 INS32 INS42 INS42 INS38 INS8 INS25 UPD42 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS41 INS38 INS8 INS8 UPD42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS9 INS32 INS41 INS25 INS41 INS32 INS42 INS86 INS42 INS42 INS90 INS86 INS42 INS42 INS42 INS42 INS9 INS62 INS8 INS9 INS32 INS42 INS59 INS32 INS40 INS42 INS59 INS32 INS32 INS43 INS60 INS60 INS25 INS54 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS38 INS8 INS8 INS12 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS32 INS41 INS60 INS60 INS25 INS44 INS8 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS9 INS39 INS59 INS39 INS59 INS27 INS8 INS8 INS43 INS42 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS27 INS27 INS21 INS41 INS41 INS42 INS38 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS32 INS9 INS9 INS32 INS41 INS21 INS41 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS32 INS9 INS32 INS9 INS45 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 DEL42
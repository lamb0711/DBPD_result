HDFS-5281. COMMIT request should not block. Contributed by Brandon Li

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.nfs.nfs3.response.COMMIT3Response;
-  public final static int COMMIT_FINISHED = 0;
-  public final static int COMMIT_WAIT = 1;
-  public final static int COMMIT_INACTIVE_CTX = 2;
-  public final static int COMMIT_INACTIVE_WITH_PENDING_WRITE = 3;
-  public final static int COMMIT_ERROR = 4;
+  static enum COMMIT_STATUS {
+    COMMIT_FINISHED,
+    COMMIT_WAIT,
+    COMMIT_INACTIVE_CTX,
+    COMMIT_INACTIVE_WITH_PENDING_WRITE,
+    COMMIT_ERROR,
+    COMMIT_DO_SYNC;
+  }
+  private final DFSClient client;
+  private final IdUserGroup iug;
+  
-  // TODO: make it mutable and update it after each writing back to HDFS
-  private final Nfs3FileAttributes latestAttr;
+  // It's updated after each sync to HDFS
+  private Nfs3FileAttributes latestAttr;
+  private final ConcurrentNavigableMap<Long, CommitCtx> pendingCommits;
+
+  static class CommitCtx {
+    private final long offset;
+    private final Channel channel;
+    private final int xid;
+    private final Nfs3FileAttributes preOpAttr;
+
+    // Remember time for debug purpose
+    private final long startTime;
+
+    long getOffset() {
+      return offset;
+    }
+
+    Channel getChannel() {
+      return channel;
+    }
+
+    int getXid() {
+      return xid;
+    }
+
+    Nfs3FileAttributes getPreOpAttr() {
+      return preOpAttr;
+    }
+
+    long getStartTime() {
+      return startTime;
+    }
+
+    CommitCtx(long offset, Channel channel, int xid,
+        Nfs3FileAttributes preOpAttr) {
+      this.offset = offset;
+      this.channel = channel;
+      this.xid = xid;
+      this.preOpAttr = preOpAttr;
+      this.startTime = System.currentTimeMillis();
+    }
+
+    @Override
+    public String toString() {
+      return String.format("offset: %d xid: %d startTime: %d", offset, xid,
+          startTime);
+    }
+  }
+  
-      String dumpFilePath) {
+      String dumpFilePath, DFSClient client, IdUserGroup iug) {
+    
+    pendingCommits = new ConcurrentSkipListMap<Long, CommitCtx>();
+    
+    this.client = client;
+    this.iug = iug;
-        if (request.getStableHow() == WriteStableHow.UNSTABLE) {
-          if (LOG.isDebugEnabled()) {
-            LOG.debug("UNSTABLE write request, send response for offset: "
-                + writeCtx.getOffset());
-          }
-          WccData fileWcc = new WccData(preOpAttr, latestAttr);
-          WRITE3Response response = new WRITE3Response(Nfs3Status.NFS3_OK,
-              fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);
-          Nfs3Utils
-              .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),
-                  xid, new VerifierNone()), xid);
-          writeCtx.setReplied(true);
+        if (stableHow != WriteStableHow.UNSTABLE) {
+          LOG.info("Have to change stable write to unstable write:"
+              + request.getStableHow());
+          stableHow = WriteStableHow.UNSTABLE;
+
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("UNSTABLE write request, send response for offset: "
+              + writeCtx.getOffset());
+        }
+        WccData fileWcc = new WccData(preOpAttr, latestAttr);
+        WRITE3Response response = new WRITE3Response(Nfs3Status.NFS3_OK,
+            fileWcc, count, stableHow, Nfs3Constant.WRITE_COMMIT_VERF);
+        Nfs3Utils
+            .writeChannel(channel, response.writeHeaderAndResponse(new XDR(),
+                xid, new VerifierNone()), xid);
+        writeCtx.setReplied(true);
+  public COMMIT_STATUS checkCommit(DFSClient dfsClient, long commitOffset,
+      Channel channel, int xid, Nfs3FileAttributes preOpAttr) {
+    // Keep stream active
+    updateLastAccessTime();
+    Preconditions.checkState(commitOffset >= 0);
+
+    COMMIT_STATUS ret = checkCommitInternal(commitOffset, channel, xid,
+        preOpAttr);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Got commit status: " + ret.name());
+    }
+    // Do the sync outside the lock
+    if (ret == COMMIT_STATUS.COMMIT_DO_SYNC) {
+      try {
+        // Sync file data and length
+        fos.hsync(EnumSet.of(SyncFlag.UPDATE_LENGTH));
+        // Nothing to do for metadata since attr related change is pass-through
+      } catch (ClosedChannelException cce) {
+        if (pendingWrites.isEmpty()) {
+          ret = COMMIT_STATUS.COMMIT_FINISHED;
+        } else {
+          ret = COMMIT_STATUS.COMMIT_ERROR;
+        }
+      } catch (IOException e) {
+        LOG.error("Got stream error during data sync:" + e);
+        // Do nothing. Stream will be closed eventually by StreamMonitor.
+        // status = Nfs3Status.NFS3ERR_IO;
+        ret = COMMIT_STATUS.COMMIT_ERROR;
+      }
+    }
+    return ret;
+  }
+
-   * COMMIT_INACTIVE_CTX, COMMIT_ERROR
+   * COMMIT_INACTIVE_CTX, COMMIT_INACTIVE_WITH_PENDING_WRITE, COMMIT_ERROR
-  public int checkCommit(long commitOffset) {
-    return activeState ? checkCommitInternal(commitOffset)
-        : COMMIT_INACTIVE_CTX;
-  }
-  
-  private int checkCommitInternal(long commitOffset) {
-    if (commitOffset == 0) {
-      // Commit whole file
-      commitOffset = nextOffset.get();
+  private synchronized COMMIT_STATUS checkCommitInternal(long commitOffset,
+      Channel channel, int xid, Nfs3FileAttributes preOpAttr) {
+    if (!activeState) {
+      if (pendingWrites.isEmpty()) {
+        return COMMIT_STATUS.COMMIT_INACTIVE_CTX;
+      } else {
+        // TODO: return success if already committed
+        return COMMIT_STATUS.COMMIT_INACTIVE_WITH_PENDING_WRITE;
+      }
-    if (flushed < commitOffset) {
-      // Keep stream active
-      updateLastAccessTime();
-      return COMMIT_WAIT;
-    }
-    int ret = COMMIT_WAIT;
-    try {
-      // Sync file data and length
-      fos.hsync(EnumSet.of(SyncFlag.UPDATE_LENGTH));
-      // Nothing to do for metadata since attr related change is pass-through
-      ret = COMMIT_FINISHED;
-    } catch (ClosedChannelException cce) { 
-      ret = COMMIT_INACTIVE_CTX;
-      if (pendingWrites.isEmpty()) {
-        ret = COMMIT_INACTIVE_CTX;
+    if (commitOffset > 0) {
+      if (commitOffset > flushed) {
+        CommitCtx commitCtx = new CommitCtx(commitOffset, channel, xid,
+            preOpAttr);
+        pendingCommits.put(commitOffset, commitCtx);
+        return COMMIT_STATUS.COMMIT_WAIT;
-        ret = COMMIT_INACTIVE_WITH_PENDING_WRITE;
+        return COMMIT_STATUS.COMMIT_DO_SYNC;
-    } catch (IOException e) {
-      LOG.error("Got stream error during data sync:" + e);
-      // Do nothing. Stream will be closed eventually by StreamMonitor.
-      ret = COMMIT_ERROR;
-    // Keep stream active
-    updateLastAccessTime();
-    return ret;
+    Entry<OffsetRange, WriteCtx> key = pendingWrites.firstEntry();
+
+    // Commit whole file, commitOffset == 0
+    if (pendingWrites.isEmpty()) {
+      // Note that, there is no guarantee data is synced. TODO: We could still
+      // do a sync here though the output stream might be closed.
+      return COMMIT_STATUS.COMMIT_FINISHED;
+    } else {
+      // Insert commit
+      long maxOffset = key.getKey().getMax() - 1;
+      Preconditions.checkState(maxOffset > 0);
+      CommitCtx commitCtx = new CommitCtx(maxOffset, channel, xid, preOpAttr);
+      pendingCommits.put(maxOffset, commitCtx);
+      return COMMIT_STATUS.COMMIT_WAIT;
+    }
+      // process pending commit again to handle this race: a commit is added
+      // to pendingCommits map just after the last doSingleWrite returns.
+      // There is no pending write and the commit should be handled by the
+      // last doSingleWrite. Due to the race, the commit is left along and
+      // can't be processed until cleanup. Therefore, we should do another
+      // processCommits to fix the race issue.
+      processCommits(nextOffset.get()); // nextOffset has same value as
+                                        // flushedOffset
-    } else {
+      return null;
+    } 
+    
+        processCommits(nextOffset.get()); // handle race
+        processCommits(nextOffset.get()); // handle race
-    }
+    
-            + +latestAttr.getFileId());
+            + latestAttr.getFileId());
+  private void processCommits(long offset) {
+    Preconditions.checkState(offset > 0);
+    long flushedOffset = getFlushedOffset();
+    Entry<Long, CommitCtx> entry = pendingCommits.firstEntry();
+
+    if (entry == null || entry.getValue().offset > flushedOffset) {
+      return;
+    }
+
+    // Now do sync for the ready commits
+    int status = Nfs3Status.NFS3ERR_IO;
+    try {
+      // Sync file data and length
+      fos.hsync(EnumSet.of(SyncFlag.UPDATE_LENGTH));
+      status = Nfs3Status.NFS3_OK;
+    } catch (ClosedChannelException cce) {
+      if (!pendingWrites.isEmpty()) {
+        LOG.error("Can't sync for fileId: " + latestAttr.getFileId()
+            + ". Channel closed with writes pending");
+      }
+      status = Nfs3Status.NFS3ERR_IO;
+    } catch (IOException e) {
+      LOG.error("Got stream error during data sync:" + e);
+      // Do nothing. Stream will be closed eventually by StreamMonitor.
+      status = Nfs3Status.NFS3ERR_IO;
+    }
+
+    // Update latestAttr
+    try {
+      latestAttr = Nfs3Utils.getFileAttr(client,
+          Nfs3Utils.getFileIdPath(latestAttr.getFileId()), iug);
+    } catch (IOException e) {
+      LOG.error("Can't get new file attr for fileId: " + latestAttr.getFileId());
+      status = Nfs3Status.NFS3ERR_IO;
+    }
+
+    if (latestAttr.getSize() != offset) {
+      LOG.error("After sync, the expect file size: " + offset
+          + ", however actual file size is: " + latestAttr.getSize());
+      status = Nfs3Status.NFS3ERR_IO;
+    }
+    WccData wccData = new WccData(Nfs3Utils.getWccAttr(latestAttr), latestAttr);
+
+    // Send response for the ready commits
+    while (entry != null && entry.getValue().offset <= flushedOffset) {
+      pendingCommits.remove(entry.getKey());
+      CommitCtx commit = entry.getValue();
+
+      COMMIT3Response response = new COMMIT3Response(status, wccData,
+          Nfs3Constant.WRITE_COMMIT_VERF);
+      Nfs3Utils.writeChannelCommit(commit.getChannel(), response
+          .writeHeaderAndResponse(new XDR(), commit.getXid(),
+              new VerifierNone()), commit.getXid());
+      
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("FileId: " + latestAttr.getFileid() + " Service time:"
+            + (System.currentTimeMillis() - commit.getStartTime())
+            + "ms. Sent response for commit:" + commit);
+      }
+      entry = pendingCommits.firstEntry();
+    }
+  }
+  
+      
+      // Handle the waiting commits without holding any lock
+      processCommits(writeCtx.getOffset() + writeCtx.getCount());
+     
+  
+  @VisibleForTesting
+  ConcurrentNavigableMap<OffsetRange, WriteCtx> getPendingWritesForTest(){
+    return pendingWrites;
+  }
+  
+  @VisibleForTesting
+  ConcurrentNavigableMap<Long, CommitCtx> getPendingCommitsForTest(){
+    return pendingCommits;
+  }
+  
+  @VisibleForTesting
+  long getNextOffsetForTest() {
+    return nextOffset.get();
+  }
+  
+  @VisibleForTesting
+  void setNextOffsetForTest(long newValue) {
+    nextOffset.set(newValue);
+  }
+  
+  @VisibleForTesting
+  void setActiveStatusForTest(boolean activeState) {
+    this.activeState = activeState;
+  }

INS26 MOV31 INS40 INS71 INS23 INS23 INS23 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS42 INS72 INS72 INS72 INS72 INS72 INS72 INS83 MOV83 INS43 INS59 UPD83 MOV83 INS83 INS43 MOV59 UPD83 MOV83 MOV83 INS74 INS59 INS83 INS42 INS23 MOV23 MOV23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS44 INS44 MOV8 INS83 INS43 INS42 INS44 MOV44 INS44 INS44 INS44 INS8 UPD83 INS83 INS43 INS42 MOV44 INS44 INS44 INS44 MOV8 INS39 INS42 INS44 INS8 INS78 INS74 INS42 INS8 INS78 INS74 INS42 INS8 INS78 INS39 INS42 INS8 INS78 INS39 INS42 INS44 INS8 INS78 INS39 INS42 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS43 INS43 INS43 INS42 INS83 INS83 UPD39 MOV39 MOV59 UPD83 INS43 UPD83 UPD83 MOV83 MOV83 INS43 INS59 UPD83 MOV83 INS83 INS39 INS59 INS39 INS42 INS8 INS43 INS42 INS8 INS39 INS42 INS8 INS43 INS42 INS8 INS39 INS42 INS8 INS42 INS44 INS44 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS43 INS42 INS43 INS42 INS21 INS21 INS21 MOV60 MOV60 MOV60 MOV60 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 MOV21 INS21 INS60 INS25 INS25 MOV41 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS25 MOV60 MOV25 INS25 INS60 INS25 INS25 MOV41 INS39 INS42 INS21 INS60 INS60 INS25 INS60 INS54 INS54 INS25 INS60 INS61 INS42 INS43 INS43 INS43 INS41 INS42 INS43 INS43 INS43 INS41 INS42 INS41 INS42 INS39 INS42 INS21 INS42 INS39 INS42 INS21 INS42 INS42 INS42 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS41 INS42 INS41 INS41 INS42 INS41 INS41 INS39 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS41 INS42 INS42 INS7 INS7 INS7 MOV27 MOV8 INS42 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS27 MOV8 UPD66 INS42 INS42 INS38 INS8 INS27 INS8 INS74 INS59 INS32 INS8 INS8 MOV32 MOV8 INS32 INS39 INS59 INS74 INS59 INS27 INS8 INS39 INS59 INS8 INS12 INS12 INS8 INS12 INS27 INS8 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS7 INS7 INS7 INS32 INS42 INS14 INS22 INS42 INS22 INS42 MOV60 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS40 INS42 INS25 INS42 INS34 INS25 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS41 INS60 INS21 INS60 INS21 INS41 MOV21 INS41 INS21 INS25 INS42 INS42 INS27 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS27 INS27 INS41 INS42 INS40 INS21 INS21 INS44 INS8 INS44 INS8 INS21 INS44 INS8 INS32 INS42 INS21 INS21 INS42 INS42 INS14 INS27 INS27 INS21 INS60 INS60 INS21 INS25 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS74 INS52 INS42 INS52 INS42 MOV38 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS8 INS8 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS40 INS39 INS59 INS32 INS43 INS59 INS32 INS40 INS32 INS33 INS32 INS21 MOV27 INS8 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS22 INS42 INS32 INS7 INS43 INS42 MOV25 INS21 INS43 INS42 INS21 INS21 INS7 INS43 INS42 INS21 INS21 INS42 INS42 INS32 INS7 INS43 INS32 INS42 INS42 INS33 INS22 INS42 INS32 INS43 INS59 INS43 INS59 INS32 INS32 INS8 INS7 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS43 INS43 INS43 MOV21 INS25 INS42 INS42 INS27 INS42 INS42 INS41 INS41 INS42 INS42 INS60 INS21 INS41 INS41 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS32 INS32 INS21 INS32 INS42 INS42 INS42 INS32 INS42 INS40 INS42 INS38 INS7 INS42 INS32 INS7 INS42 INS32 INS42 INS32 INS7 INS42 INS42 INS27 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS21 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS27 INS8 INS45 INS32 INS40 INS40 INS43 INS59 INS32 INS40 INS40 INS32 INS34 INS42 INS34 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS40 INS42 INS42 INS27 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS40 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS14 INS32 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS40 INS21 INS21 INS42 INS42 INS42 INS42 INS14 UPD42 MOV42 INS42 MOV42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS45 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS7 INS40 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS36 INS45 INS42 INS42 INS42 UPD27 MOV27 INS42 INS40 INS42 INS42 INS42 UPD45 MOV32 INS45 INS42 INS42 INS27 INS45 INS40 INS40 INS32 INS32 INS42 INS42 INS42 INS42 DEL34 DEL83 DEL39 DEL23 DEL83 DEL23 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL34 DEL83 DEL39 DEL34 DEL83 DEL34 DEL40 DEL25 DEL8 DEL42 DEL34 DEL27 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL41 DEL8 DEL25 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL32 DEL42 DEL16 DEL41 DEL42 DEL7 DEL25 DEL8 DEL38 DEL39 DEL42
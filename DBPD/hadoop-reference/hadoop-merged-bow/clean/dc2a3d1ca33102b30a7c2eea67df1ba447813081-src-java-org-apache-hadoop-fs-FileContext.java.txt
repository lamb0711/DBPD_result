HADOOP-6900. Make the iterator returned by FileSystem#listLocatedStatus to throw IOException rather than RuntimeException when there is an IO error fetching the next file. Contributed by Hairong Kuang. 



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@984301 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.LinkedList;
-import java.util.NoSuchElementException;
-  public Iterator<FileStatus> listStatus(final Path f) throws
+  public RemoteIterator<FileStatus> listStatus(final Path f) throws
-    return new FSLinkResolver<Iterator<FileStatus>>() {
-      public Iterator<FileStatus> next(final AbstractFileSystem fs, final Path p) 
+    return new FSLinkResolver<RemoteIterator<FileStatus>>() {
+      public RemoteIterator<FileStatus> next(
+          final AbstractFileSystem fs, final Path p) 
-  public Iterator<LocatedFileStatus> listLocatedStatus(final Path f) throws
+  public RemoteIterator<LocatedFileStatus> listLocatedStatus(
+      final Path f) throws
-    return new FSLinkResolver<Iterator<LocatedFileStatus>>() {
-      public Iterator<LocatedFileStatus> next(
+    return new FSLinkResolver<RemoteIterator<LocatedFileStatus>>() {
+      public RemoteIterator<LocatedFileStatus> next(
-      Iterator<FileStatus> statusIterator = FileContext.this.listStatus(f);
+      RemoteIterator<FileStatus> statusIterator = 
+        FileContext.this.listStatus(f);
-    public Iterator<LocatedFileStatus> listFiles(
+    public RemoteIterator<LocatedFileStatus> listFiles(
-      return new Iterator<LocatedFileStatus>() {
-        private Stack<Iterator<LocatedFileStatus>> itors = 
-          new Stack<Iterator<LocatedFileStatus>>();
-        Iterator<LocatedFileStatus> curItor = listLocatedStatus(f);
+      return new RemoteIterator<LocatedFileStatus>() {
+        private Stack<RemoteIterator<LocatedFileStatus>> itors = 
+          new Stack<RemoteIterator<LocatedFileStatus>>();
+        RemoteIterator<LocatedFileStatus> curItor = listLocatedStatus(f);
-       
+
-         *  {@inheritDoc}
-         *  @return {@inheritDog} 
-         *  @throws Runtimeexception if any IOException occurs during traversal;
-         *  the IOException is set as the cause of the RuntimeException
+         * Returns <tt>true</tt> if the iterator has more files.
+         *
+         * @return <tt>true</tt> if the iterator has more files.
+         * @throws AccessControlException if not allowed to access next
+         *                                file's status or locations
+         * @throws FileNotFoundException if next file does not exist any more
+         * @throws UnsupportedFileSystemException if next file's 
+         *                                        fs is unsupported
+         * @throws IOException for all other IO errors
+         *                     for example, NameNode is not avaialbe or
+         *                     NameNode throws IOException due to an error
+         *                     while getting the status or block locations
-        public boolean hasNext() {
+        public boolean hasNext() throws IOException {
-         * If it is a directory, tranverse the directory if recursive is true;
+         * If it is a directory, traverse the directory if recursive is true;
-         * @throws RuntimeException if any io error occurs; the io exception
-         * is set as the cause of RuntimeException
+         * @throws AccessControlException if access is denied
+         * @throws FileNotFoundException if file is not found
+         * @throws UnsupportedFileSystemException if fs is not supported
+         * @throws IOException for all other IO errors
-        private void handleFileStat(LocatedFileStatus stat) {
-          try {
-            if (stat.isFile()) { // file
-              curFile = stat;
-            } else if (stat.isSymlink()) { // symbolic link
-              // resolve symbolic link
-              FileStatus symstat = FileContext.this.getFileStatus(
-                  stat.getSymlink());
-              if (symstat.isFile() || (recursive && symstat.isDirectory())) {
-                itors.push(curItor);
-                curItor = listLocatedStatus(stat.getPath());
-              }
-            } else if (recursive) { // directory
+        private void handleFileStat(LocatedFileStatus stat)
+        throws IOException {
+          if (stat.isFile()) { // file
+            curFile = stat;
+          } else if (stat.isSymlink()) { // symbolic link
+            // resolve symbolic link
+            FileStatus symstat = FileContext.this.getFileStatus(
+                stat.getSymlink());
+            if (symstat.isFile() || (recursive && symstat.isDirectory())) {
-          } catch (IOException ioe) {
-            throw (RuntimeException)new RuntimeException().initCause(ioe);
+          } else if (recursive) { // directory
+            itors.push(curItor);
+            curItor = listLocatedStatus(stat.getPath());
-         *  {@inheritDoc}
-         *  @return {@inheritDoc} 
-         *  @throws Runtimeexception if any IOException occurs during traversal;
-         *  the IOException is set as the cause of the RuntimeException
-         *  @exception {@inheritDoc}
+         * Returns the next file's status with its block locations
+         *
+         * @throws AccessControlException if not allowed to access next
+         *                                file's status or locations
+         * @throws FileNotFoundException if next file does not exist any more
+         * @throws UnsupportedFileSystemException if next file's 
+         *                                        fs is unsupported
+         * @throws IOException for all other IO errors
+         *                     for example, NameNode is not avaialbe or
+         *                     NameNode throws IOException due to an error
+         *                     while getting the status or block locations
-        public LocatedFileStatus next() {
+        public LocatedFileStatus next() throws IOException {
-
-        @Override
-        public void remove() {
-          throw new UnsupportedOperationException("Remove is not supported");
-
-        }

UPD74 UPD74 UPD43 UPD43 UPD74 UPD42 UPD42 UPD43 UPD74 UPD42 UPD74 UPD74 UPD43 UPD74 UPD74 MOV74 UPD74 MOV74 UPD42 UPD43 UPD43 UPD74 MOV74 UPD43 UPD74 MOV74 UPD42 UPD74 UPD74 INS43 INS43 MOV8 MOV43 UPD42 UPD43 UPD42 UPD43 UPD74 UPD43 INS65 INS65 INS65 INS65 INS65 INS42 INS65 INS65 INS65 UPD42 MOV42 INS65 UPD65 INS65 UPD65 UPD42 UPD42 UPD43 UPD74 UPD42 INS66 INS66 INS42 UPD66 MOV66 INS66 INS42 INS66 INS42 UPD66 MOV66 INS66 UPD42 INS66 INS66 UPD66 UPD66 UPD66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 UPD66 INS66 INS42 UPD66 UPD66 INS42 INS66 UPD42 UPD66 UPD66 INS42 UPD66 INS66 INS66 INS66 UPD42 UPD74 UPD43 UPD42 DEL40 DEL26 DEL40 DEL26 DEL65 DEL65 DEL65 DEL65 DEL66 DEL42 DEL44 DEL43 DEL42 DEL43 DEL14 DEL42 DEL42 DEL32 DEL11 DEL53 DEL8 DEL12 DEL54 DEL8 DEL65 DEL65 DEL65 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31
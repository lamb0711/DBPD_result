Merge commit '456e901a4c5c639267ee87b8e5f1319f256d20c2' (HDFS-6407. Add sorting and pagination in the datanode tab of the NN Web UI. Contributed by Haohui Mai.) into HDFS-7285-merge

+import org.apache.hadoop.HadoopIllegalArgumentException;
-  private static final long GB = 1L << 30; //1GB
-  private static final long MAX_SIZE_TO_MOVE = 10*GB;
-
-      + "\tNumber of consecutive idle iterations (-1 for Infinite) before exit.";
-  
+      + "\tNumber of consecutive idle iterations (-1 for Infinite) before "
+      + "exit."
+      + "\n\t[-runDuringUpgrade]"
+      + "\tWhether to run the balancer during an ongoing HDFS upgrade."
+      + "This is usually not desired since it will not affect used space "
+      + "on over-utilized machines.";
+
+  private final NameNodeConnector nnc;
+  private final boolean runDuringUpgrade;
-  
+  private final long maxSizeToMove;
+
+  static long getLong(Configuration conf, String key, long defaultValue) {
+    final long v = conf.getLong(key, defaultValue);
+    LOG.info(key + " = " + v + " (default=" + defaultValue + ")");
+    if (v <= 0) {
+      throw new HadoopIllegalArgumentException(key + " = " + v  + " <= " + 0);
+    }
+    return v;
+  }
+
+  static int getInt(Configuration conf, String key, int defaultValue) {
+    final int v = conf.getInt(key, defaultValue);
+    LOG.info(key + " = " + v + " (default=" + defaultValue + ")");
+    if (v <= 0) {
+      throw new HadoopIllegalArgumentException(key + " = " + v  + " <= " + 0);
+    }
+    return v;
+  }
+
-    final long movedWinWidth = conf.getLong(
+    final long movedWinWidth = getLong(conf,
-    final int moverThreads = conf.getInt(
+    final int moverThreads = getInt(conf,
-    final int dispatcherThreads = conf.getInt(
+    final int dispatcherThreads = getInt(conf,
-    final int maxConcurrentMovesPerNode = conf.getInt(
+    final int maxConcurrentMovesPerNode = getInt(conf,
+    final long getBlocksSize = getLong(conf,
+        DFSConfigKeys.DFS_BALANCER_GETBLOCKS_SIZE_KEY,
+        DFSConfigKeys.DFS_BALANCER_GETBLOCKS_SIZE_DEFAULT);
+    final long getBlocksMinBlockSize = getLong(conf,
+        DFSConfigKeys.DFS_BALANCER_GETBLOCKS_MIN_BLOCK_SIZE_KEY,
+        DFSConfigKeys.DFS_BALANCER_GETBLOCKS_MIN_BLOCK_SIZE_DEFAULT);
+
+    this.nnc = theblockpool;
-        maxConcurrentMovesPerNode, conf);
+        maxConcurrentMovesPerNode, getBlocksSize, getBlocksMinBlockSize, conf);
+    this.runDuringUpgrade = p.runDuringUpgrade;
+
+    this.maxSizeToMove = getLong(conf,
+        DFSConfigKeys.DFS_BALANCER_MAX_SIZE_TO_MOVE_KEY,
+        DFSConfigKeys.DFS_BALANCER_MAX_SIZE_TO_MOVE_DEFAULT);
-            getRemaining(r, t), utilizationDiff, threshold);
+            getRemaining(r, t), utilizationDiff, threshold, maxSizeToMove);
-            overLoadedBytes += precentage2bytes(thresholdDiff, capacity);
+            overLoadedBytes += percentage2bytes(thresholdDiff, capacity);
-            underLoadedBytes += precentage2bytes(thresholdDiff, capacity);
+            underLoadedBytes += percentage2bytes(thresholdDiff, capacity);
-      final double utilizationDiff, final double threshold) {
+      final double utilizationDiff, final double threshold, final long max) {
-    long maxSizeToMove = precentage2bytes(diff, capacity);
+    long maxSizeToMove = percentage2bytes(diff, capacity);
-    return Math.min(MAX_SIZE_TO_MOVE, maxSizeToMove);
+    return Math.min(max, maxSizeToMove);
-  private static long precentage2bytes(double precentage, long capacity) {
-    Preconditions.checkArgument(precentage >= 0,
-        "precentage = " + precentage + " < 0");
-    return (long)(precentage * capacity / 100.0);
+  private static long percentage2bytes(double percentage, long capacity) {
+    Preconditions.checkArgument(percentage >= 0, "percentage = %s < 0",
+        percentage);
+    return (long)(percentage * capacity / 100.0);
+    LOG.info("chooseStorageGroups for " + matcher + ": overUtilized => underUtilized");
+    LOG.info("chooseStorageGroups for " + matcher + ": overUtilized => belowAvgUtilized");
+    LOG.info("chooseStorageGroups for " + matcher + ": underUtilized => aboveAvgUtilized");
-      
+
+      // Should not run the balancer during an unfinalized upgrade, since moved
+      // blocks are not deleted on the source datanode.
+      if (!runDuringUpgrade && nnc.isUpgrading()) {
+        return newResult(ExitStatus.UNFINALIZED_UPGRADE, bytesLeftToMove, -1);
+      }
+
-      
+
-        Collections.<String> emptySet(), Collections.<String> emptySet());
+        Collections.<String> emptySet(), Collections.<String> emptySet(),
+        false);
+    /**
+     * Whether to run the balancer during upgrade.
+     */
+    final boolean runDuringUpgrade;
-        Set<String> nodesToBeExcluded, Set<String> nodesToBeIncluded) {
+        Set<String> nodesToBeExcluded, Set<String> nodesToBeIncluded,
+        boolean runDuringUpgrade) {
+      this.runDuringUpgrade = runDuringUpgrade;
-      return Balancer.class.getSimpleName() + "." + getClass().getSimpleName()
-          + "[" + policy + ", threshold=" + threshold +
-          ", max idle iteration = " + maxIdleIteration +
-          ", number of nodes to be excluded = "+ nodesToBeExcluded.size() +
-          ", number of nodes to be included = "+ nodesToBeIncluded.size() +"]";
+      return String.format("%s.%s [%s,"
+              + " threshold = %s,"
+              + " max idle iteration = %s, "
+              + "number of nodes to be excluded = %s,"
+              + " number of nodes to be included = %s,"
+              + " run during upgrade = %s]",
+          Balancer.class.getSimpleName(), getClass().getSimpleName(),
+          policy, threshold, maxIdleIteration,
+          nodesToBeExcluded.size(), nodesToBeIncluded.size(),
+          runDuringUpgrade);
+      boolean runDuringUpgrade = Parameters.DEFAULT.runDuringUpgrade;
-                  "idleiterations value is missing: args = " + Arrays.toString(args));
+                  "idleiterations value is missing: args = " + Arrays
+                      .toString(args));
+            } else if ("-runDuringUpgrade".equalsIgnoreCase(args[i])) {
+              runDuringUpgrade = true;
+              LOG.info("Will run the balancer even during an ongoing HDFS "
+                  + "upgrade. Most users will not want to run the balancer "
+                  + "during an upgrade since it will not affect used space "
+                  + "on over-utilized machines.");
-      return new Parameters(policy, threshold, maxIdleIteration, nodesTobeExcluded, nodesTobeIncluded);
+      return new Parameters(policy, threshold, maxIdleIteration,
+          nodesTobeExcluded, nodesTobeIncluded, runDuringUpgrade);

INS26 INS40 INS23 INS23 INS23 INS31 INS31 MOV83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS44 UPD42 INS23 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS21 INS25 INS41 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS21 INS25 INS41 INS60 INS60 INS21 INS21 INS21 INS83 INS39 INS42 UPD42 INS21 INS21 INS21 INS29 INS83 INS39 INS59 INS44 UPD45 INS45 INS45 INS45 INS45 INS45 INS42 INS42 INS83 INS39 INS59 INS32 INS27 INS8 INS42 INS42 INS42 INS83 INS39 INS59 INS32 INS27 INS8 INS42 INS83 INS39 INS59 INS83 INS39 INS59 INS7 INS7 INS7 INS32 INS32 INS32 INS65 INS42 INS39 INS42 INS21 INS60 UPD42 MOV42 INS32 INS42 INS42 INS27 INS42 UPD34 MOV34 INS53 UPD42 MOV42 INS32 INS42 INS42 INS27 INS42 UPD34 MOV34 INS53 INS42 INS32 INS42 INS32 INS22 INS42 INS22 INS40 INS22 INS32 UPD42 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS25 INS9 INS66 INS7 INS32 INS39 INS59 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS14 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS40 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS40 INS40 UPD42 UPD42 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS27 INS8 INS22 INS42 INS42 INS42 INS27 MOV32 MOV32 INS42 INS42 INS42 MOV32 MOV32 INS42 INS42 INS40 INS42 INS43 INS27 INS43 INS27 INS38 INS32 INS41 INS52 INS42 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 INS42 INS42 INS45 INS42 INS45 INS34 INS42 INS42 INS45 INS42 INS45 INS34 UPD42 INS42 INS42 INS42 INS32 INS42 INS40 INS42 INS38 INS42 INS34 UPD42 UPD42 INS25 INS32 INS8 MOV8 INS45 INS42 INS2 INS21 INS21 INS42 INS42 INS7 INS32 INS42 INS9 INS42 INS42 INS27 INS45 INS45 INS45 INS45 DEL83 DEL83 DEL39 DEL34 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL27 DEL59 DEL23 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL45 DEL42 DEL42 DEL42 DEL27
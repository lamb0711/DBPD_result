HDDS-981. Block allocation should involve pipeline selection and then container selection.
Contributed by Lokesh Jain.

-import org.apache.hadoop.hdds.protocol.proto.HddsProtos;
-import java.util.Random;
-  private final int containerProvisionBatchSize;
-  private final Random rand;
-    this.containerProvisionBatchSize =
-        conf.getInt(
-            ScmConfigKeys.OZONE_SCM_CONTAINER_PROVISION_BATCH_SIZE,
-            ScmConfigKeys.OZONE_SCM_CONTAINER_PROVISION_BATCH_SIZE_DEFAULT);
-    rand = new Random();
-
-   * Pre allocate specified count of containers for block creation.
-   *
-   * @param count - Number of containers to allocate.
-   * @param type - Type of containers
-   * @param factor - how many copies needed for this container.
-   * @throws IOException
-   */
-  private synchronized void preAllocateContainers(int count,
-      ReplicationType type, ReplicationFactor factor, String owner) {
-    for (int i = 0; i < count; i++) {
-      ContainerInfo containerInfo;
-      try {
-        // TODO: Fix this later when Ratis is made the Default.
-        containerInfo = containerManager.allocateContainer(
-            type, factor, owner);
-
-        if (containerInfo == null) {
-          LOG.warn("Unable to allocate container.");
-        }
-      } catch (IOException ex) {
-        LOG.warn("Unable to allocate container.", ex);
-      }
-    }
-  }
-
-  /**
-      1. We try to find containers in open state.
+      1. We try to find pipelines in open state.
-      2. If there are no containers in open state, then we will pre-allocate a
-      bunch of containers in SCM and try again.
+      2. If there are no pipelines in OPEN state, then we try to create one.
-      TODO : Support random picking of two containers from the list. So we can
-             use different kind of policies.
+      3. We allocate a block from the available containers in the selected
+      pipeline.
+
+      TODO : #CLUTIL Support random picking of two containers from the list.
+      So we can use different kind of policies.
-    // look for OPEN containers that match the criteria.
-    containerInfo = containerManager
-        .getMatchingContainer(size, owner, type, factor,
-            HddsProtos.LifeCycleState.OPEN);
-
-    // We did not find OPEN Containers. This generally means
-    // that most of our containers are full or we have not allocated
-    // containers of the type and replication factor. So let us go and
-    // allocate some.
-
-    // Even though we have already checked the containers in OPEN
-    // state, we have to check again as we only hold a read lock.
-    // Some other thread might have pre-allocated container in meantime.
-    if (containerInfo == null) {
-      synchronized (this) {
-        if (!containerManager.getContainers(HddsProtos.LifeCycleState.OPEN)
-            .isEmpty()) {
-          containerInfo = containerManager
-              .getMatchingContainer(size, owner, type, factor,
-                  HddsProtos.LifeCycleState.OPEN);
+    while (true) {
+      List<Pipeline> availablePipelines = pipelineManager
+          .getPipelines(type, factor, Pipeline.PipelineState.OPEN);
+      Pipeline pipeline;
+      if (availablePipelines.size() == 0) {
+        try {
+          // TODO: #CLUTIL Remove creation logic when all replication types and
+          // factors are handled by pipeline creator
+          pipeline = pipelineManager.createPipeline(type, factor);
+        } catch (IOException e) {
+          break;
-
-        if (containerInfo == null) {
-          preAllocateContainers(containerProvisionBatchSize, type, factor,
-              owner);
-          containerInfo = containerManager
-              .getMatchingContainer(size, owner, type, factor,
-                  HddsProtos.LifeCycleState.OPEN);
-        }
+      } else {
+        // TODO: #CLUTIL Make the selection policy driven.
+        pipeline = availablePipelines
+            .get((int) (Math.random() * availablePipelines.size()));
-    }
-    if (containerInfo != null) {
-      return newBlock(containerInfo);
+      // look for OPEN containers that match the criteria.
+      containerInfo = containerManager
+          .getMatchingContainer(size, owner, pipeline);
+      if (containerInfo != null) {
+        return newBlock(containerInfo);
+      }

INS61 INS9 INS8 INS60 INS60 INS25 MOV21 MOV25 INS74 INS59 INS43 INS59 INS27 INS8 INS8 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS34 INS54 INS21 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 UPD40 MOV40 UPD42 MOV42 UPD42 MOV42 INS8 MOV12 INS7 UPD42 MOV21 INS42 INS32 UPD42 INS10 UPD42 MOV42 UPD42 MOV42 INS11 UPD42 INS39 INS36 UPD42 UPD42 INS27 INS32 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL42 DEL40 DEL40 DEL32 DEL7 DEL21 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL24 DEL8 DEL31 DEL42 DEL42 DEL40 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL52 DEL42 DEL40 DEL32 DEL32 DEL38 DEL8 DEL25 DEL42 DEL33 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL25
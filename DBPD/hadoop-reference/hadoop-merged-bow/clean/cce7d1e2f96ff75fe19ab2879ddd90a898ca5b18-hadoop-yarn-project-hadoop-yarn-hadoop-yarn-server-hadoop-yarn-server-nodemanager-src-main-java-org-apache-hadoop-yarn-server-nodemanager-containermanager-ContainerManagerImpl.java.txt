Merge remote-tracking branch 'origin/trunk' into MR-2841

Conflicts:
	hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java

+import java.io.DataInputStream;
+import org.apache.hadoop.io.DataOutputBuffer;
+import org.apache.hadoop.yarn.api.records.ApplicationAccessType;
+import org.apache.hadoop.yarn.api.records.impl.pb.ApplicationIdPBImpl;
+import org.apache.hadoop.yarn.api.records.impl.pb.ProtoUtils;
+import org.apache.hadoop.yarn.proto.YarnProtos.ApplicationACLMapProto;
+import org.apache.hadoop.yarn.proto.YarnServerNodemanagerRecoveryProtos.ContainerManagerApplicationProto;
+import org.apache.hadoop.yarn.server.nodemanager.recovery.NMStateStoreService.RecoveredApplicationsState;
+import org.apache.hadoop.yarn.server.nodemanager.recovery.NMStateStoreService.RecoveredContainerState;
+import org.apache.hadoop.yarn.server.nodemanager.recovery.NMStateStoreService.RecoveredContainerStatus;
+import com.google.protobuf.ByteString;
+  @SuppressWarnings("unchecked")
+
+      RecoveredApplicationsState appsState = stateStore.loadApplicationsState();
+      for (ContainerManagerApplicationProto proto :
+           appsState.getApplications()) {
+        recoverApplication(proto);
+      }
+
+      for (RecoveredContainerState rcs : stateStore.loadContainersState()) {
+        recoverContainer(rcs);
+      }
+
+      String diagnostic = "Application marked finished during recovery";
+      for (ApplicationId appId : appsState.getFinishedApplications()) {
+        dispatcher.getEventHandler().handle(
+            new ApplicationFinishEvent(appId, diagnostic));
+      }
+    }
+  }
+
+  private void recoverApplication(ContainerManagerApplicationProto p)
+      throws IOException {
+    ApplicationId appId = new ApplicationIdPBImpl(p.getId());
+    Credentials creds = new Credentials();
+    creds.readTokenStorageStream(
+        new DataInputStream(p.getCredentials().newInput()));
+
+    List<ApplicationACLMapProto> aclProtoList = p.getAclsList();
+    Map<ApplicationAccessType, String> acls =
+        new HashMap<ApplicationAccessType, String>(aclProtoList.size());
+    for (ApplicationACLMapProto aclProto : aclProtoList) {
+      acls.put(ProtoUtils.convertFromProtoFormat(aclProto.getAccessType()),
+          aclProto.getAcl());
+    }
+
+    LOG.info("Recovering application " + appId);
+    ApplicationImpl app = new ApplicationImpl(dispatcher, p.getUser(), appId,
+        creds, context);
+    context.getApplications().put(appId, app);
+    app.handle(new ApplicationInitEvent(appId, acls));
+  }
+
+  @SuppressWarnings("unchecked")
+  private void recoverContainer(RecoveredContainerState rcs)
+      throws IOException {
+    StartContainerRequest req = rcs.getStartRequest();
+    ContainerLaunchContext launchContext = req.getContainerLaunchContext();
+    ContainerTokenIdentifier token =
+        BuilderUtils.newContainerTokenIdentifier(req.getContainerToken());
+    ContainerId containerId = token.getContainerID();
+    ApplicationId appId =
+        containerId.getApplicationAttemptId().getApplicationId();
+
+    LOG.info("Recovering " + containerId + " in state " + rcs.getStatus()
+        + " with exit code " + rcs.getExitCode());
+
+    if (context.getApplications().containsKey(appId)) {
+      Credentials credentials = parseCredentials(launchContext);
+      Container container = new ContainerImpl(getConfig(), dispatcher,
+          context.getNMStateStore(), req.getContainerLaunchContext(),
+          credentials, metrics, token, rcs.getStatus(), rcs.getExitCode(),
+          rcs.getDiagnostics(), rcs.getKilled());
+      context.getContainers().put(containerId, container);
+      dispatcher.getEventHandler().handle(
+          new ApplicationContainerInitEvent(container));
+    } else {
+      if (rcs.getStatus() != RecoveredContainerStatus.COMPLETED) {
+        LOG.warn(containerId + " has no corresponding application!");
+      }
+      LOG.info("Adding " + containerId + " to recently stopped containers");
+      nodeStatusUpdater.addCompletedContainer(containerId);
+    }
+  }
+
+  private void waitForRecoveredContainers() throws InterruptedException {
+    final int sleepMsec = 100;
+    int waitIterations = 100;
+    List<ContainerId> newContainers = new ArrayList<ContainerId>();
+    while (--waitIterations >= 0) {
+      newContainers.clear();
+      for (Container container : context.getContainers().values()) {
+        if (container.getContainerState() == org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.NEW) {
+          newContainers.add(container.getContainerId());
+        }
+      }
+      if (newContainers.isEmpty()) {
+        break;
+      }
+      LOG.info("Waiting for containers: " + newContainers);
+      Thread.sleep(sleepMsec);
+    }
+    if (waitIterations < 0) {
+      LOG.warn("Timeout waiting for recovered containers");
+    final InetSocketAddress initialAddress = conf.getSocketAddr(
+        YarnConfiguration.NM_BIND_HOST,
+        YarnConfiguration.NM_ADDRESS,
+        YarnConfiguration.DEFAULT_NM_ADDRESS,
+        YarnConfiguration.DEFAULT_NM_PORT);
+    boolean usingEphemeralPort = (initialAddress.getPort() == 0);
+    if (context.getNMStateStore().canRecover() && usingEphemeralPort) {
+      throw new IllegalArgumentException("Cannot support recovery with an "
+          + "ephemeral server port. Check the setting of "
+          + YarnConfiguration.NM_ADDRESS);
+    }
+    // If recovering then delay opening the RPC service until the recovery
+    // of resources and containers have completed, otherwise requests from
+    // clients during recovery can interfere with the recovery process.
+    final boolean delayedRpcServerStart =
+        context.getNMStateStore().canRecover();
+
-    InetSocketAddress initialAddress = conf.getSocketAddr(
-        YarnConfiguration.NM_ADDRESS,
-        YarnConfiguration.DEFAULT_NM_ADDRESS,
-        YarnConfiguration.DEFAULT_NM_PORT);
-
-    server.start();
-    InetSocketAddress connectAddress = NetUtils.getConnectAddress(server);
-    NodeId nodeId = NodeId.newInstance(
-        connectAddress.getAddress().getCanonicalHostName(),
-        connectAddress.getPort());
+
+    String bindHost = conf.get(YarnConfiguration.NM_BIND_HOST);
+    String nmAddress = conf.getTrimmed(YarnConfiguration.NM_ADDRESS);
+    String hostOverride = null;
+    if (bindHost != null && !bindHost.isEmpty()
+        && nmAddress != null && !nmAddress.isEmpty()) {
+      //a bind-host case with an address, to support overriding the first
+      //hostname found when querying for our hostname with the specified
+      //address, combine the specified address with the actual port listened
+      //on by the server
+      hostOverride = nmAddress.split(":")[0];
+    }
+
+    // setup node ID
+    InetSocketAddress connectAddress;
+    if (delayedRpcServerStart) {
+      connectAddress = NetUtils.getConnectAddress(initialAddress);
+    } else {
+      server.start();
+      connectAddress = NetUtils.getConnectAddress(server);
+    }
+    NodeId nodeId = buildNodeId(connectAddress, hostOverride);
-    LOG.info("ContainerManager started at " + connectAddress);
+
+    // start remaining services
+
+    if (delayedRpcServerStart) {
+      waitForRecoveredContainers();
+      server.start();
+
+      // check that the node ID is as previously advertised
+      connectAddress = NetUtils.getConnectAddress(server);
+      NodeId serverNode = buildNodeId(connectAddress, hostOverride);
+      if (!serverNode.equals(nodeId)) {
+        throw new IOException("Node mismatch after server started, expected '"
+            + nodeId + "' but found '" + serverNode + "'");
+      }
+    }
+
+    LOG.info("ContainerManager started at " + connectAddress);
+    LOG.info("ContainerManager bound to " + initialAddress);
+  }
+
+  private NodeId buildNodeId(InetSocketAddress connectAddress,
+      String hostOverride) {
+    if (hostOverride != null) {
+      connectAddress = NetUtils.getConnectAddress(
+          new InetSocketAddress(hostOverride, connectAddress.getPort()));
+    }
+    return NodeId.newInstance(
+        connectAddress.getAddress().getCanonicalHostName(),
+        connectAddress.getPort());
+    if (this.context.getNMStateStore().canRecover()
+        && !this.context.getDecommissioned()) {
+      // do not cleanup apps as they can be recovered on restart
+      return;
+    }
+
+      messageBuilder.append("\nNote: System times on machines may be out of sync.")
+        .append(" Check system time and time zones.");
+  private ContainerManagerApplicationProto buildAppProto(ApplicationId appId,
+      String user, Credentials credentials,
+      Map<ApplicationAccessType, String> appAcls) {
+
+    ContainerManagerApplicationProto.Builder builder =
+        ContainerManagerApplicationProto.newBuilder();
+    builder.setId(((ApplicationIdPBImpl) appId).getProto());
+    builder.setUser(user);
+
+    builder.clearCredentials();
+    if (credentials != null) {
+      DataOutputBuffer dob = new DataOutputBuffer();
+      try {
+        credentials.writeTokenStorageToStream(dob);
+        builder.setCredentials(ByteString.copyFrom(dob.getData()));
+      } catch (IOException e) {
+        // should not occur
+        LOG.error("Cannot serialize credentials", e);
+      }
+    }
+
+    builder.clearAcls();
+    if (appAcls != null) {
+      for (Map.Entry<ApplicationAccessType, String> acl : appAcls.entrySet()) {
+        ApplicationACLMapProto p = ApplicationACLMapProto.newBuilder()
+            .setAccessType(ProtoUtils.convertToProtoFormat(acl.getKey()))
+            .setAcl(acl.getValue())
+            .build();
+        builder.addAcls(p);
+      }
+    }
+
+    return builder.build();
+  }
+
-        new ContainerImpl(getConfig(), this.dispatcher, launchContext,
+        new ContainerImpl(getConfig(), this.dispatcher,
+            context.getNMStateStore(), launchContext,
-
+          Map<ApplicationAccessType, String> appAcls =
+              container.getLaunchContext().getApplicationACLs();
+          context.getNMStateStore().storeApplication(applicationID,
+              buildAppProto(applicationID, user, credentials, appAcls));
-            new ApplicationInitEvent(applicationID, container.getLaunchContext()
-              .getApplicationACLs()));
+            new ApplicationInitEvent(applicationID, appAcls));
+        this.context.getNMStateStore().storeContainer(containerId, request);
-      throws YarnException {
+      throws IOException {
-      try {
-        credentials.readTokenStorageStream(buf);
-        if (LOG.isDebugEnabled()) {
-          for (Token<? extends TokenIdentifier> tk : credentials.getAllTokens()) {
-            LOG.debug(tk.getService() + " = " + tk.toString());
-          }
+      credentials.readTokenStorageStream(buf);
+      if (LOG.isDebugEnabled()) {
+        for (Token<? extends TokenIdentifier> tk : credentials.getAllTokens()) {
+          LOG.debug(tk.getService() + " = " + tk.toString());
-      } catch (IOException e) {
-        throw RPCUtil.getRemoteException(e);
-      ContainerId containerID) throws YarnException {
+      ContainerId containerID) throws YarnException, IOException {
+      context.getNMStateStore().storeContainerKilled(containerID);
+        try {
+          this.context.getNMStateStore().storeFinishedApplication(appID);
+        } catch (IOException e) {
+          LOG.error("Unable to update application state in store", e);
+        }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS79 INS83 INS39 INS42 INS44 INS43 INS8 INS79 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS43 INS8 MOV60 MOV21 INS83 MOV43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 UPD43 MOV8 INS43 INS42 INS45 INS43 INS42 INS42 INS60 INS60 INS21 INS60 INS60 INS70 INS21 INS60 INS21 INS21 INS42 INS45 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS25 INS42 INS60 INS60 INS60 INS61 INS25 INS60 INS25 INS60 INS60 INS60 INS60 INS25 INS25 INS25 INS21 MOV43 INS42 INS43 INS42 INS25 INS41 INS25 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS60 INS21 INS21 INS21 INS25 INS21 INS25 INS41 UPD42 MOV60 MOV60 INS25 MOV41 INS42 INS8 INS42 INS43 INS59 INS43 INS59 INS32 INS74 INS59 INS74 INS59 INS44 INS42 INS8 INS32 INS43 INS59 INS32 INS32 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS32 INS8 INS8 INS83 INS39 INS59 INS39 INS59 INS74 INS59 INS27 INS8 INS27 INS8 INS83 INS43 INS39 INS59 INS27 INS8 INS83 INS39 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS8 INS8 INS43 INS42 INS8 INS32 INS42 INS27 INS8 MOV32 INS27 INS8 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS59 INS32 INS32 INS32 INS27 INS8 INS32 INS27 INS8 INS32 MOV27 MOV8 MOV21 INS60 INS70 INS70 INS60 INS70 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS14 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS32 INS42 INS42 INS60 INS60 INS21 INS21 INS25 INS21 INS21 INS42 INS34 INS42 INS34 INS43 INS43 INS42 INS14 INS38 INS34 INS21 INS70 INS25 INS21 INS21 INS42 INS34 INS21 INS42 INS42 INS36 INS32 INS42 INS53 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS27 INS38 INS21 INS21 INS21 INS21 INS42 INS32 INS21 MOV21 INS21 INS60 INS25 INS42 INS42 INS27 INS42 INS33 INS21 INS32 INS38 INS41 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS60 INS54 INS42 INS42 INS42 INS33 INS70 INS42 INS42 MOV60 MOV21 MOV21 INS21 INS43 INS59 INS44 INS32 INS8 INS44 INS32 INS8 INS43 INS59 INS44 INS32 INS8 INS43 INS32 INS43 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS32 INS45 INS42 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS27 INS8 INS32 INS32 INS42 INS42 INS74 INS42 INS32 INS44 INS32 INS8 INS32 INS8 INS32 INS32 INS32 INS40 INS27 INS32 INS42 INS14 INS32 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS27 INS27 INS32 INS7 INS7 INS32 INS7 INS42 INS42 INS42 INS32 INS7 INS43 INS59 INS38 INS8 INS45 INS42 INS7 INS32 INS42 INS32 INS42 INS42 INS36 INS42 INS43 INS59 INS8 INS12 INS44 INS32 INS8 INS32 INS32 INS54 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS43 INS42 INS42 INS42 INS21 INS42 INS42 INS45 INS43 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS32 INS42 INS42 INS42 INS32 INS42 INS14 INS32 INS40 INS21 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS43 INS42 INS32 INS42 INS25 INS42 INS42 INS10 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS34 INS42 INS42 INS43 INS27 INS42 INS42 INS27 INS38 INS42 INS33 INS42 INS42 INS42 INS2 INS42 INS32 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS53 INS42 INS32 INS22 INS42 INS22 INS42 INS21 INS11 INS42 INS42 INS14 INS21 INS21 MOV44 INS8 INS74 INS42 INS42 INS42 INS60 INS21 INS42 INS42 INS21 INS32 INS42 INS42 INS8 INS12 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS45 INS42 INS42 INS42 INS42 INS45 INS45 INS40 INS42 INS33 INS32 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS52 INS42 INS52 INS42 INS32 INS43 INS42 INS43 INS32 INS32 INS21 INS43 INS43 INS43 INS43 INS59 INS32 INS32 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS40 INS21 INS42 INS42 INS42 INS42 INS45 INS43 INS27 INS43 INS42 INS32 INS32 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS60 INS21 INS32 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS42 INS42 INS43 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS32 INS42 INS74 INS59 INS32 INS22 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS43 INS43 INS43 INS42 MOV32 INS32 INS42 INS42 INS32 INS52 INS42 INS22 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 DEL8 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL54 DEL25 DEL8
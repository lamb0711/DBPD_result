YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).

+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.NavigableMap;
+import org.apache.hadoop.yarn.server.resourcemanager.reservation.RLESparseResourceAllocation.RLEOperator;
+import org.apache.hadoop.yarn.server.resourcemanager.reservation.exceptions.PlanningException;
- * considers intervals of the form: [stageDeadline - (n+1)*duration,
- * stageDeadline - n*duration) for an integer n. This guarantees that the
- * allocations are aligned (as opposed to overlapping duration intervals).
- *
- * The smoothnessFactor parameter controls the number of containers that are
- * simultaneously allocated in each iteration of the algorithm.
+ * considers non-overlapping intervals of length 'duration'. This guarantees
+ * that the allocations are aligned. If 'allocateLeft == true', the intervals
+ * considered by the algorithm are aligned to stageArrival; otherwise, they are
+ * aligned to stageDeadline. The smoothnessFactor parameter controls the number
+ * of containers that are simultaneously allocated in each iteration of the
+ * algorithm.
+  private final boolean allocateLeft;
-  public StageAllocatorLowCostAligned() {
+  public StageAllocatorLowCostAligned(boolean allocateLeft) {
+    this.allocateLeft = allocateLeft;
-  public StageAllocatorLowCostAligned(int smoothnessFactor) {
+  public StageAllocatorLowCostAligned(int smoothnessFactor,
+      boolean allocateLeft) {
+    this.allocateLeft = allocateLeft;
-  // computeJobAllocation()
-  public Map<ReservationInterval, Resource> computeStageAllocation(
-      Plan plan, Map<Long, Resource> planLoads,
+  public Map<ReservationInterval, Resource> computeStageAllocation(Plan plan,
+      RLESparseResourceAllocation planLoads,
-      long stageEarliestStart, long stageDeadline, String user,
-      ReservationId oldId) {
+      long stageArrival, long stageDeadline, String user, ReservationId oldId)
+      throws PlanningException {
+
+    RLESparseResourceAllocation netRLERes = plan
+        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);
+
-        (int) ((stageDeadline - stageEarliestStart) / duration);
+        (int) ((stageDeadline - stageArrival) / duration);
-    int maxGangsPerUnit =
-        (int) Math.max(
-            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);
+    int maxGangsPerUnit = (int) Math
+        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);
+    final int preferLeft = allocateLeft ? 1 : -1;
+
-            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());
+            return preferLeft
+                * Long.compare(val1.getEndTime(), val2.getEndTime());
+    List<Long> intervalEndTimes =
+        computeIntervalEndTimes(stageArrival, stageDeadline, duration);
+
-    for (long intervalEnd = stageDeadline; intervalEnd >= stageEarliestStart
-        + duration; intervalEnd -= duration) {
+    for (long intervalEnd : intervalEndTimes) {
-              planModifications, capacity, resCalc, step);
+              planModifications, capacity, netRLERes, resCalc, step, gang);
-      if (durationInterval.canAllocate(gang, capacity, resCalc)) {
+      if (durationInterval.canAllocate()) {
-          Math.min(numGangsToAllocate,
-              bestDurationInterval.numCanFit(gang, capacity, resCalc));
+          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());
-      Resource reservationRes =
-          Resources.multiply(rr.getCapability(), rr.getConcurrency()
-              * numGangsToAllocate);
+      Resource reservationRes = Resources.multiply(rr.getCapability(),
+          rr.getConcurrency() * numGangsToAllocate);
-              planModifications, capacity, resCalc, step);
+              planModifications, capacity, netRLERes, resCalc, step, gang);
-      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {
+      if (updatedDurationInterval.canAllocate()) {
-      // If we are here is because we did not manage to satisfy this request.
-      // We remove unwanted side-effect from planModifications (needed for ANY).
-      for (Map.Entry<ReservationInterval, Resource> tempAllocation
-          : allocations.entrySet()) {
+      // If we are here is because we did not manage to satisfy this
+      // request.
+      // We remove unwanted side-effect from planModifications (needed for
+      // ANY).
+      for (Map.Entry<ReservationInterval, Resource> tempAllocation : allocations
+          .entrySet()) {
-  protected DurationInterval getDurationInterval(long startTime, long endTime,
-      Map<Long, Resource> planLoads,
-      RLESparseResourceAllocation planModifications, Resource capacity,
-      ResourceCalculator resCalc, long step) {
+  private List<Long> computeIntervalEndTimes(long stageEarliestStart,
+      long stageDeadline, long duration) {
-    // Initialize the dominant loads structure
-    Resource dominantResources = Resource.newInstance(0, 0);
-
-    // Calculate totalCost and maxLoad
-    double totalCost = 0.0;
-    for (long t = startTime; t < endTime; t += step) {
-
-      // Get the load
-      Resource load = getLoadAtTime(t, planLoads, planModifications);
-
-      // Increase the total cost
-      totalCost += calcCostOfLoad(load, capacity, resCalc);
-
-      // Update the dominant resources
-      dominantResources = Resources.componentwiseMax(dominantResources, load);
-
+    List<Long> intervalEndTimes = new ArrayList<Long>();
+    if (!allocateLeft) {
+      for (long intervalEnd = stageDeadline; intervalEnd >= stageEarliestStart
+          + duration; intervalEnd -= duration) {
+        intervalEndTimes.add(intervalEnd);
+      }
+    } else {
+      for (long intervalStart =
+          stageEarliestStart; intervalStart <= stageDeadline
+              - duration; intervalStart += duration) {
+        intervalEndTimes.add(intervalStart + duration);
+      }
-    // Return the corresponding durationInterval
-    return new DurationInterval(startTime, endTime, totalCost,
-        dominantResources);
+    return intervalEndTimes;
+  }
+
+  protected static DurationInterval getDurationInterval(long startTime,
+      long endTime, RLESparseResourceAllocation planLoads,
+      RLESparseResourceAllocation planModifications, Resource capacity,
+      RLESparseResourceAllocation netRLERes, ResourceCalculator resCalc,
+      long step, Resource requestedResources) throws PlanningException {
+
+    // Get the total cost associated with the duration interval
+    double totalCost = getDurationIntervalTotalCost(startTime, endTime,
+        planLoads, planModifications, capacity, resCalc, step);
+
+    // Calculate how many gangs can fit, i.e., how many times can 'capacity'
+    // be allocated within the duration interval [startTime, endTime)
+    int gangsCanFit = getDurationIntervalGangsCanFit(startTime, endTime,
+        planModifications, capacity, netRLERes, resCalc, requestedResources);
+
+    // Return the desired durationInterval
+    return new DurationInterval(startTime, endTime, totalCost, gangsCanFit);
+  protected static double getDurationIntervalTotalCost(long startTime,
+      long endTime, RLESparseResourceAllocation planLoads,
+      RLESparseResourceAllocation planModifications, Resource capacity,
+      ResourceCalculator resCalc, long step) throws PlanningException {
+
+    // Compute the current resource load within the interval [startTime,endTime)
+    // by adding planLoads (existing load) and planModifications (load that
+    // corresponds to the current job).
+    RLESparseResourceAllocation currentLoad =
+        RLESparseResourceAllocation.merge(resCalc, capacity, planLoads,
+            planModifications, RLEOperator.add, startTime, endTime);
+
+    // Convert load from RLESparseResourceAllocation to a Map representation
+    NavigableMap<Long, Resource> mapCurrentLoad = currentLoad.getCumulative();
+
+    // Initialize auxiliary variables
+    double totalCost = 0.0;
+    Long tPrev = -1L;
+    Resource loadPrev = Resources.none();
+    double cost = 0.0;
+
+    // Iterate over time points. For each point 't', accumulate the total cost
+    // that corresponds to the interval [tPrev, t). The cost associated within
+    // this interval is fixed for each of the time steps, therefore the cost of
+    // a single step is multiplied by (t - tPrev) / step.
+    for (Entry<Long, Resource> e : mapCurrentLoad.entrySet()) {
+      Long t = e.getKey();
+      Resource load = e.getValue();
+      if (tPrev != -1L) {
+        tPrev = Math.max(tPrev, startTime);
+        cost = calcCostOfLoad(loadPrev, capacity, resCalc);
+        totalCost = totalCost + cost * (t - tPrev) / step;
+      }
+
+      tPrev = t;
+      loadPrev = load;
+    }
+
+    // Add the cost associated with the last interval (the for loop does not
+    // calculate it).
+    if (loadPrev != null) {
+
+      // This takes care of the corner case of a single entry
+      tPrev = Math.max(tPrev, startTime);
+      cost = calcCostOfLoad(loadPrev, capacity, resCalc);
+      totalCost = totalCost + cost * (endTime - tPrev) / step;
+    }
+
+    // Return the overall cost
+    return totalCost;
+  }
+
+  protected static int getDurationIntervalGangsCanFit(long startTime,
+      long endTime, RLESparseResourceAllocation planModifications,
+      Resource capacity, RLESparseResourceAllocation netRLERes,
+      ResourceCalculator resCalc, Resource requestedResources)
+      throws PlanningException {
+
+    // Initialize auxiliary variables
+    int gangsCanFit = Integer.MAX_VALUE;
+    int curGangsCanFit;
+
+    // Calculate the total amount of available resources between startTime
+    // and endTime, by subtracting planModifications from netRLERes
+    RLESparseResourceAllocation netAvailableResources =
+        RLESparseResourceAllocation.merge(resCalc, capacity, netRLERes,
+            planModifications, RLEOperator.subtractTestNonNegative, startTime,
+            endTime);
+
+    // Convert result to a map
+    NavigableMap<Long, Resource> mapAvailableCapacity =
+        netAvailableResources.getCumulative();
+
+    // Iterate over the map representation.
+    // At each point, calculate how many times does 'requestedResources' fit.
+    // The result is the minimum over all time points.
+    for (Entry<Long, Resource> e : mapAvailableCapacity.entrySet()) {
+      Long t = e.getKey();
+      Resource curAvailable = e.getValue();
+      if (t >= endTime) {
+        break;
+      }
+
+      if (curAvailable == null) {
+        gangsCanFit = 0;
+      } else {
+        curGangsCanFit = (int) Math.floor(Resources.divide(resCalc, capacity,
+            curAvailable, requestedResources));
+        if (curGangsCanFit < gangsCanFit) {
+          gangsCanFit = curGangsCanFit;
+        }
+      }
+    }
+    return gangsCanFit;
+  }
+
-      Map<Long, Resource> planLoads,
+      RLESparseResourceAllocation planLoads,
-  protected double calcCostOfTimeSlot(long t, Map<Long, Resource> planLoads,
+  protected double calcCostOfTimeSlot(long t,
+      RLESparseResourceAllocation planLoads,
-  protected Resource getLoadAtTime(long t, Map<Long, Resource> planLoads,
+  protected Resource getLoadAtTime(long t,
+      RLESparseResourceAllocation planLoads,
-    Resource planLoad = planLoads.get(t);
-    planLoad = (planLoad == null) ? Resource.newInstance(0, 0) : planLoad;
+    Resource planLoad = planLoads.getCapacityAtTime(t);
-  protected double calcCostOfLoad(Resource load, Resource capacity,
+  protected static double calcCostOfLoad(Resource load, Resource capacity,
-    private Resource maxLoad;
+    private final int gangsCanFit;
-        Resource maxLoad) {
+        int gangsCanfit) {
-      this.maxLoad = maxLoad;
+      this.gangsCanFit = gangsCanfit;
-    public boolean canAllocate(Resource requestedResources, Resource capacity,
-        ResourceCalculator resCalc) {
-
-      Resource updatedMaxLoad = Resources.add(maxLoad, requestedResources);
-      return (resCalc.compare(capacity, updatedMaxLoad, capacity) <= 0);
-
+    public boolean canAllocate() {
+      return (gangsCanFit > 0);
-    public int numCanFit(Resource requestedResources, Resource capacity,
-        ResourceCalculator resCalc) {
-      // Represents the largest resource demand that can be satisfied throughout
-      // the entire DurationInterval (i.e., during [startTime,endTime))
-      Resource availableResources = Resources.subtract(capacity, maxLoad);
-
-      // Maximal number of requestedResources that fit inside the interval
-      return (int) Math.floor(Resources.divide(resCalc, capacity,
-          availableResources, requestedResources));
-
+    public int numCanFit() {
+      return gangsCanFit;
-    public Resource getMaxLoad() {
-      return this.maxLoad;
-    }
-
-    public void setMaxLoad(Resource value) {
-      this.maxLoad = value;
-    }
-
+    @Override
+
+
-          .append(" cost: " + cost).append(" maxLoad: " + maxLoad);
+          .append(" cost: " + cost).append(" gangsCanFit: " + gangsCanFit);
+
+
+

INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS39 INS59 INS44 INS44 INS44 INS43 INS83 INS74 INS42 MOV44 INS44 INS44 INS8 MOV83 INS83 MOV43 MOV42 INS44 INS44 MOV44 INS44 MOV44 INS44 MOV44 INS44 MOV44 INS43 INS8 INS83 INS83 INS39 INS42 MOV44 MOV44 INS44 MOV44 MOV44 MOV44 MOV44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 MOV44 INS44 MOV44 MOV44 INS43 INS83 MOV43 INS42 MOV44 INS44 MOV44 INS8 INS83 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS42 INS39 INS42 INS21 INS39 INS42 INS21 INS43 INS39 INS42 INS42 INS60 INS60 INS60 INS70 INS43 MOV43 INS39 INS42 INS39 INS42 INS60 INS25 INS41 INS39 INS42 INS39 INS42 INS43 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS60 INS41 INS43 INS42 INS42 MOV60 INS60 MOV60 INS60 INS60 INS60 INS70 INS25 INS41 INS39 INS42 INS39 INS42 INS43 UPD42 INS43 INS42 INS42 INS60 INS60 INS60 INS70 INS41 INS43 INS43 INS43 INS42 INS60 MOV41 INS83 INS39 INS78 INS7 INS7 UPD42 MOV42 INS43 INS59 INS83 INS39 INS59 INS74 INS59 INS44 INS42 MOV8 INS42 INS74 INS59 INS38 INS8 INS8 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS39 MOV59 INS39 INS59 INS14 INS42 UPD43 UPD74 MOV74 INS59 INS43 INS59 MOV43 INS59 INS39 INS59 INS44 INS32 INS8 INS27 INS8 INS42 INS42 INS42 INS39 INS59 INS39 INS59 INS43 INS74 INS59 INS44 INS32 INS8 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV43 INS59 UPD42 INS39 UPD42 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS32 INS42 INS16 INS43 MOV43 INS42 INS32 INS39 INS42 INS43 MOV43 INS42 INS14 INS42 INS24 INS24 UPD42 UPD42 MOV42 INS32 MOV43 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD43 INS42 INS32 INS42 INS42 INS38 INS42 INS32 INS42 INS34 INS74 INS42 INS42 INS42 INS60 INS60 INS25 INS21 INS21 INS42 INS33 MOV21 INS21 INS21 INS42 INS40 INS42 INS42 UPD42 INS43 INS43 MOV43 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS60 INS25 INS25 INS42 INS32 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 MOV38 INS42 INS42 INS42 INS42 INS42 INS42 INS74 MOV58 MOV27 MOV7 INS8 INS58 INS27 INS7 INS8 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS40 INS42 INS42 UPD42 INS42 INS42 INS34 INS42 INS42 INS43 INS43 MOV43 INS43 INS59 MOV43 INS59 INS27 INS8 INS7 INS7 INS7 INS7 INS42 INS42 INS42 INS42 INS42 UPD42 INS40 UPD42 UPD42 INS42 INS42 INS42 INS42 INS43 INS43 MOV43 INS43 INS59 MOV43 INS59 INS27 INS8 INS27 INS8 INS8 INS42 INS42 INS42 UPD42 UPD27 INS43 MOV43 INS21 INS39 INS59 INS42 INS27 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS38 INS21 MOV21 INS21 INS42 INS42 INS42 INS42 UPD42 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS10 UPD42 MOV42 MOV33 INS21 INS21 INS25 UPD42 INS42 UPD45 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS7 UPD7 INS7 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS7 INS7 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 UPD42 INS42 INS27 INS27 INS42 INS42 INS34 INS42 INS11 INS42 INS42 INS21 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS27 INS42 INS36 INS39 INS32 INS7 INS27 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS36 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 DEL42 DEL43 DEL43 DEL74 DEL36 DEL42 DEL42 DEL42 DEL24 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL74 DEL34 DEL34 DEL42 DEL42 DEL27 DEL36 DEL34 DEL34 DEL32 DEL42 DEL16 DEL7 DEL21 DEL43 DEL60 DEL39 DEL42 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL42 DEL7 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL43 DEL74 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31
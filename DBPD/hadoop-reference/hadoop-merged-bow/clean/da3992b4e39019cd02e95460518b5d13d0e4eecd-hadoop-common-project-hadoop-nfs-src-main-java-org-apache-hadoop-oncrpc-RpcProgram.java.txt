HDFS-6406. Add capability for NFS gateway to reject connections from unprivileged ports. Contributed by Aaron T. Myers.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595351 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import org.apache.hadoop.oncrpc.security.VerifierNone;
-  private static final Log LOG = LogFactory.getLog(RpcProgram.class);
+  static final Log LOG = LogFactory.getLog(RpcProgram.class);
+  private final boolean allowInsecurePorts;
+   * @param DatagramSocket registrationSocket if not null, use this socket to
+   *        register with portmap daemon
+   * @param allowInsecurePorts true to allow client connections from
+   *        unprivileged ports, false otherwise
-      DatagramSocket registrationSocket) {
+      DatagramSocket registrationSocket, boolean allowInsecurePorts) {
+    this.allowInsecurePorts = allowInsecurePorts;
+    LOG.info("Will " + (allowInsecurePorts ? "" : "not ") + "accept client "
+        + "connections from unprivileged ports");
+    
+    SocketAddress remoteAddress = info.remoteAddress();
+    if (!allowInsecurePorts) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Will not allow connections from unprivileged ports. " +
+            "Checking for valid client port...");
+      }
+      if (remoteAddress instanceof InetSocketAddress) {
+        InetSocketAddress inetRemoteAddress = (InetSocketAddress) remoteAddress;
+        if (inetRemoteAddress.getPort() > 1023) {
+          LOG.warn("Connection attempted from '" + inetRemoteAddress + "' "
+              + "which is an unprivileged port. Rejecting connection.");
+          sendRejectedReply(call, remoteAddress, ctx);
+          return;
+        } else {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Accepting connection from '" + remoteAddress + "'");
+          }
+        }
+      } else {
+        LOG.warn("Could not determine remote port of socket address '" +
+            remoteAddress + "'. Rejecting connection.");
+        sendRejectedReply(call, remoteAddress, ctx);
+        return;
+      }
+    }
+    
-      RpcAcceptedReply reply = RpcAcceptedReply.getInstance(call.getXid(),
-          AcceptState.PROG_UNAVAIL, Verifier.VERIFIER_NONE);
-
-      XDR out = new XDR();
-      reply.write(out);
-      ChannelBuffer b = ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()
-          .buffer());
-      RpcResponse rsp = new RpcResponse(b, info.remoteAddress());
-      RpcUtil.sendRpcResponse(ctx, rsp);
+      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_UNAVAIL, ctx);
-      RpcAcceptedReply reply = RpcAcceptedReply.getInstance(call.getXid(),
-          AcceptState.PROG_MISMATCH, Verifier.VERIFIER_NONE);
-
-      XDR out = new XDR();
-      reply.write(out);
-      out.writeInt(lowProgVersion);
-      out.writeInt(highProgVersion);
-      ChannelBuffer b = ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()
-          .buffer());
-      RpcResponse rsp = new RpcResponse(b, info.remoteAddress());
-      RpcUtil.sendRpcResponse(ctx, rsp);
+      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_MISMATCH, ctx);
+  
+  private void sendAcceptedReply(RpcCall call, SocketAddress remoteAddress,
+      AcceptState acceptState, ChannelHandlerContext ctx) {
+    RpcAcceptedReply reply = RpcAcceptedReply.getInstance(call.getXid(),
+        acceptState, Verifier.VERIFIER_NONE);
+
+    XDR out = new XDR();
+    reply.write(out);
+    if (acceptState == AcceptState.PROG_MISMATCH) {
+      out.writeInt(lowProgVersion);
+      out.writeInt(highProgVersion);
+    }
+    ChannelBuffer b = ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()
+        .buffer());
+    RpcResponse rsp = new RpcResponse(b, remoteAddress);
+    RpcUtil.sendRpcResponse(ctx, rsp);
+  }
+  
+  private static void sendRejectedReply(RpcCall call,
+      SocketAddress remoteAddress, ChannelHandlerContext ctx) {
+    XDR out = new XDR();
+    RpcDeniedReply reply = new RpcDeniedReply(call.getXid(),
+        RpcReply.ReplyState.MSG_DENIED,
+        RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());
+    reply.write(out);
+    ChannelBuffer buf = ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()
+        .buffer());
+    RpcResponse rsp = new RpcResponse(buf, remoteAddress);
+    RpcUtil.sendRpcResponse(ctx, rsp);
+  }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS83 INS83 INS39 INS59 INS44 MOV78 MOV83 MOV39 MOV42 MOV44 MOV44 MOV43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS44 MOV8 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS42 INS65 INS65 INS39 INS42 INS21 INS21 MOV60 MOV60 MOV60 INS25 MOV25 INS25 MOV60 INS25 MOV21 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS43 INS42 INS43 INS42 INS43 INS42 MOV60 MOV60 MOV21 MOV60 INS60 MOV21 INS42 INS66 INS66 INS42 INS66 INS66 INS7 INS32 INS43 INS38 INS8 MOV27 INS8 MOV27 INS8 INS42 INS42 INS42 INS42 INS27 INS8 MOV43 INS42 INS42 INS42 UPD43 MOV43 INS59 INS22 INS42 INS42 INS42 INS27 INS42 UPD42 MOV32 INS42 INS25 INS25 MOV21 INS21 INS41 MOV21 INS21 INS41 INS42 INS40 MOV21 MOV21 UPD42 INS14 UPD42 INS42 INS14 INS52 INS42 INS45 INS36 INS45 INS45 INS32 INS8 INS62 INS8 INS8 INS32 INS32 INS42 MOV43 INS42 INS43 MOV32 INS40 INS40 INS14 MOV43 INS42 INS42 INS16 INS42 INS42 INS21 INS42 INS43 INS60 INS25 INS21 INS21 INS41 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS43 INS42 INS45 INS45 INS32 INS42 INS43 INS59 INS27 INS8 INS8 INS32 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS11 INS32 INS34 INS21 INS21 INS41 INS25 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS45 INS45 INS43 INS42 INS42 INS42 INS32 INS32 INS32 INS8 INS45 INS42 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS45 INS42 INS45 INS45 INS32 INS42 INS42 INS27 INS45 INS42 INS45 DEL83 DEL42 DEL14 DEL40 DEL42 DEL42 DEL32 DEL41 DEL42 DEL42 DEL40 DEL40 DEL32 DEL41 DEL8 DEL25 DEL25 DEL8 DEL31
Merge remote-tracking branch 'apache/trunk' into HDDS-48

-import org.apache.hadoop.yarn.client.AMRMClientUtils;
+import org.apache.hadoop.yarn.exceptions.ApplicationMasterNotRegisteredException;
+import org.apache.hadoop.yarn.server.AMRMClientRelayer;
-  /*
+  /**
-   * Registry. Otherwise if NM recovery is enabled, the UAM token are store in
+   * Registry. Otherwise if NM recovery is enabled, the UAM token are stored in
-  private ApplicationMasterProtocol homeRM;
+  private AMRMClientRelayer homeRMRelayer;
+  private volatile int lastHomeResponseId;
+
+  /**
+   * A flag for work preserving NM restart. If we just recovered, we need to
+   * generate an {@link ApplicationMasterNotRegisteredException} exception back
+   * to AM (similar to what RM will do after its restart/fail-over) in its next
+   * allocate to trigger AM re-register (which we will shield from RM and just
+   * return our saved register response) and a full pending requests re-send, so
+   * that all the {@link AMRMClientRelayer} will be re-populated with all
+   * pending requests.
+   *
+   * TODO: When split-merge is not idempotent, this can lead to some
+   * over-allocation without a full cancel to RM.
+   */
+  private volatile boolean justRecovered;
+  /**
+   * The rmProxy relayers for secondary sub-clusters that keep track of all
+   * pending requests.
+   */
+  private Map<String, AMRMClientRelayer> secondaryRelayers;
+
+    this.secondaryRelayers = new ConcurrentHashMap<>();
+    this.lastHomeResponseId = Integer.MAX_VALUE;
+    this.justRecovered = false;
-    this.homeRM = createHomeRMProxy(appContext, ApplicationMasterProtocol.class,
-        this.appOwner);
+    this.homeRMRelayer = new AMRMClientRelayer(createHomeRMProxy(appContext,
+        ApplicationMasterProtocol.class, this.appOwner));
-    LOG.info("Recovering data for FederationInterceptor");
+    ApplicationAttemptId attemptId =
+        getApplicationContext().getApplicationAttemptId();
+    LOG.info("Recovering data for FederationInterceptor for {}", attemptId);
-
-    ApplicationAttemptId attemptId =
-        getApplicationContext().getApplicationAttemptId();
+
+        // Give the register request to homeRMRelayer for future re-registration
+        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);
+        // Trigger re-register and full pending re-send only if we have a
+        // saved register response. This should always be true though.
+        this.justRecovered = true;
+          this.secondaryRelayers.put(subClusterId.getId(),
+              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));
+
-        this.homeRM.registerApplicationMaster(request);
+        this.homeRMRelayer.registerApplicationMaster(request);
+    if (this.justRecovered && this.lastHomeResponseId == Integer.MAX_VALUE) {
+      // Save the responseId home RM is expecting
+      this.lastHomeResponseId = request.getResponseId();
+
+      throw new ApplicationMasterNotRegisteredException(
+          "AMRMProxy just restarted and recovered for "
+              + getApplicationContext().getApplicationAttemptId()
+              + ". AM should re-register and full re-send pending requests.");
+    }
+
+    // Override responseId in the request in two cases:
+    //
+    // 1. After we just recovered after an NM restart and AM's responseId is
+    // reset due to the exception we generate. We need to override the
+    // responseId to the one homeRM expects.
+    //
+    // 2. After homeRM fail-over, the allocate response with reseted responseId
+    // might not be returned successfully back to AM because of RPC connection
+    // timeout between AM and AMRMProxy. In this case, we remember and reset the
+    // responseId for AM.
+    if (this.justRecovered
+        || request.getResponseId() > this.lastHomeResponseId) {
+      LOG.warn("Setting allocate responseId for {} from {} to {}",
+          getApplicationContext().getApplicationAttemptId(),
+          request.getResponseId(), this.lastHomeResponseId);
+      request.setResponseId(this.lastHomeResponseId);
+    }
+
-      AllocateResponse homeResponse = AMRMClientUtils.allocateWithReRegister(
-          requests.get(this.homeSubClusterId), this.homeRM,
-          this.amRegistrationRequest,
-          getApplicationContext().getApplicationAttemptId().getApplicationId());
+      AllocateRequest homeRequest = requests.get(this.homeSubClusterId);
+      LOG.info("{} heartbeating to home RM with responseId {}",
+          getApplicationContext().getApplicationAttemptId(),
+          homeRequest.getResponseId());
+
+      AllocateResponse homeResponse = this.homeRMRelayer.allocate(homeRequest);
+
+      // Reset the flag after the first successful homeRM allocate response,
+      // otherwise keep overriding the responseId of new allocate request
+      if (this.justRecovered) {
+        this.justRecovered = false;
+      }
+      LOG.info("{} heartbeat response from home RM with responseId {}",
+          getApplicationContext().getApplicationAttemptId(),
+          homeResponse.getResponseId());
+
+      // Update lastHomeResponseId in three cases:
+      // 1. The normal responseId increments
+      // 2. homeResponse.getResponseId() == 1. This happens when homeRM fails
+      // over, AMRMClientRelayer auto re-register and full re-send for homeRM.
+      // 3. lastHomeResponseId == MAX_INT. This is the initial case or
+      // responseId about to overflow and wrap around
+      if (homeResponse.getResponseId() == this.lastHomeResponseId + 1
+          || homeResponse.getResponseId() == 1
+          || this.lastHomeResponseId == Integer.MAX_VALUE) {
+        this.lastHomeResponseId = homeResponse.getResponseId();
+      }
+
+
+              if (uamResponse.getIsUnregistered()) {
+                secondaryRelayers.remove(subClusterId);
+
+                if (getNMStateStore() != null) {
+                  getNMStateStore().removeAMRMProxyAppContextEntry(
+                      getApplicationContext().getApplicationAttemptId(),
+                      NMSS_SECONDARY_SC_PREFIX + subClusterId);
+                }
+              }
-        AMRMClientUtils.finishAMWithReRegister(request, this.homeRM,
-            this.amRegistrationRequest, getApplicationContext()
-                .getApplicationAttemptId().getApplicationId());
+        this.homeRMRelayer.finishApplicationMaster(request);
-          } else if (getNMStateStore() != null) {
-            getNMStateStore().removeAMRMProxyAppContextEntry(
-                getApplicationContext().getApplicationAttemptId(),
-                NMSS_SECONDARY_SC_PREFIX + uamResponse.getSubClusterId());
+  @VisibleForTesting
+  protected int getLastHomeResponseId() {
+    return this.lastHomeResponseId;
+  }
+
+                secondaryRelayers.put(subClusterId.getId(),
+                    uamPool.getAMRMClientRelayer(subClusterId.getId()));
+
-                      homeSubClusterId.toString(), registryClient != null);
+                      homeSubClusterId.toString(), true);
+
+                  secondaryRelayers.put(subClusterId,
+                      uamPool.getAMRMClientRelayer(subClusterId));

MOV26 INS26 INS40 UPD40 INS23 INS23 INS23 INS31 INS29 UPD43 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS74 INS59 MOV60 INS78 INS83 INS39 INS42 INS8 INS65 UPD42 UPD42 INS42 INS65 INS42 INS65 INS43 INS43 INS43 INS42 INS21 INS21 INS21 INS25 INS25 INS42 INS41 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS7 INS7 INS7 INS27 INS8 INS27 INS8 INS22 INS42 INS42 INS22 INS14 INS22 INS40 INS22 INS9 INS14 UPD45 INS42 INS22 INS27 INS21 INS53 INS22 INS27 INS21 INS21 INS60 INS21 INS60 INS25 INS21 INS25 INS52 INS42 INS52 INS42 INS74 INS52 INS42 INS52 INS42 UPD42 INS43 MOV32 INS52 INS42 INS22 INS40 INS7 INS14 INS52 INS42 INS32 INS22 INS32 INS32 INS43 INS59 INS32 MOV43 INS59 INS22 INS8 INS32 INS27 INS8 UPD42 MOV42 UPD42 MOV42 INS43 INS42 INS21 INS21 UPD42 INS52 INS42 INS22 INS32 INS43 INS27 INS42 INS42 INS52 INS42 INS42 INS42 INS45 MOV32 INS32 INS22 INS42 INS42 INS22 INS42 INS42 MOV32 INS42 INS42 INS45 INS32 INS32 MOV42 INS32 MOV52 UPD42 MOV42 INS21 INS42 INS42 INS45 MOV32 INS32 INS27 INS27 INS21 UPD42 INS42 INS32 INS7 INS52 INS42 INS42 INS42 INS42 INS45 MOV32 INS45 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS32 INS42 INS42 INS42 INS22 UPD42 MOV42 INS42 INS7 INS32 UPD42 INS42 INS42 INS27 INS27 INS22 INS40 INS7 INS22 INS42 MOV22 INS22 INS9 INS21 INS42 INS42 INS52 INS42 INS22 INS9 INS42 INS32 INS27 INS32 INS34 INS52 INS42 INS22 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS32 MOV52 UPD42 MOV42 INS42 INS42 INS22 INS34 INS42 INS42 INS52 INS42 INS42 INS42 INS22 INS42 INS32 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS22 INS42 INS32 INS52 INS42 INS42 INS42 INS21 INS8 INS32 MOV21 INS25 INS42 INS42 INS32 INS32 INS21 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS32 MOV27 INS8 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS32 MOV32 INS42 MOV32 INS27 INS42 INS42 DEL42 DEL22 DEL32 DEL59 DEL60 DEL8 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27
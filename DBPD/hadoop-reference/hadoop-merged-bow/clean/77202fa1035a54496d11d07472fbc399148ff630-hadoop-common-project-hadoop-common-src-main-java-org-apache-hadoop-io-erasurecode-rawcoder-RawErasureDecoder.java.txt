HADOOP-13010. Refactor raw erasure coders. Contributed by Kai Zheng

+import org.apache.hadoop.io.erasurecode.ErasureCoderOptions;
- * RawErasureDecoder performs decoding given chunks of input data and generates
- * missing data that corresponds to an erasure code scheme, like XOR and
- * Reed-Solomon.
+ * An abstract raw erasure decoder that's to be inherited by new decoders.
- * It extends the {@link RawErasureCoder} interface.
+ * Raw erasure coder is part of erasure codec framework, where erasure coder is
+ * used to encode/decode a group of blocks (BlockGroup) according to the codec
+ * specific BlockGroup layout and logic. An erasure coder extracts chunks of
+ * data from the blocks and can employ various low level raw erasure coders to
+ * perform encoding/decoding against the chunks.
+ *
+ * To distinguish from erasure coder, here raw erasure coder is used to mean the
+ * low level constructs, since it only takes care of the math calculation with
+ * a group of byte buffers.
+ *
+ * Note it mainly provides decode() calls, which should be stateless and may be
+ * made thread-safe in future.
-public interface RawErasureDecoder extends RawErasureCoder {
+public abstract class RawErasureDecoder {
+
+  private final ErasureCoderOptions coderOptions;
+
+  public RawErasureDecoder(ErasureCoderOptions coderOptions) {
+    this.coderOptions = coderOptions;
+  }
-  void decode(ByteBuffer[] inputs, int[] erasedIndexes,
-                     ByteBuffer[] outputs);
+  public void decode(ByteBuffer[] inputs, int[] erasedIndexes,
+                     ByteBuffer[] outputs) {
+    ByteBufferDecodingState decodingState = new ByteBufferDecodingState(this,
+        inputs, erasedIndexes, outputs);
+
+    boolean usingDirectBuffer = decodingState.usingDirectBuffer;
+    int dataLen = decodingState.decodeLength;
+    if (dataLen == 0) {
+      return;
+    }
+
+    int[] inputPositions = new int[inputs.length];
+    for (int i = 0; i < inputPositions.length; i++) {
+      if (inputs[i] != null) {
+        inputPositions[i] = inputs[i].position();
+      }
+    }
+
+    if (usingDirectBuffer) {
+      doDecode(decodingState);
+    } else {
+      ByteArrayDecodingState badState = decodingState.convertToByteArrayState();
+      doDecode(badState);
+    }
+
+    for (int i = 0; i < inputs.length; i++) {
+      if (inputs[i] != null) {
+        // dataLen bytes consumed
+        inputs[i].position(inputPositions[i] + dataLen);
+      }
+    }
+  }
+
+  /**
+   * Perform the real decoding using Direct ByteBuffer.
+   * @param decodingState the decoding state
+   */
+  protected abstract void doDecode(ByteBufferDecodingState decodingState);
-  void decode(byte[][] inputs, int[] erasedIndexes, byte[][] outputs);
+  public void decode(byte[][] inputs, int[] erasedIndexes, byte[][] outputs) {
+    ByteArrayDecodingState decodingState = new ByteArrayDecodingState(this,
+        inputs, erasedIndexes, outputs);
+
+    if (decodingState.decodeLength == 0) {
+      return;
+    }
+
+    doDecode(decodingState);
+  }
+
+  /**
+   * Perform the real decoding using bytes array, supporting offsets and
+   * lengths.
+   * @param decodingState the decoding state
+   */
+  protected abstract void doDecode(ByteArrayDecodingState decodingState);
-  void decode(ECChunk[] inputs, int[] erasedIndexes, ECChunk[] outputs);
+  public void decode(ECChunk[] inputs, int[] erasedIndexes,
+                     ECChunk[] outputs) {
+    ByteBuffer[] newInputs = CoderUtil.toBuffers(inputs);
+    ByteBuffer[] newOutputs = CoderUtil.toBuffers(outputs);
+    decode(newInputs, erasedIndexes, newOutputs);
+  }
+  public int getNumDataUnits() {
+    return coderOptions.getNumDataUnits();
+  }
+
+  public int getNumParityUnits() {
+    return coderOptions.getNumParityUnits();
+  }
+
+  protected int getNumAllUnits() {
+    return coderOptions.getNumAllUnits();
+  }
+
+  /**
+   * Tell if direct buffer is preferred or not. It's for callers to
+   * decide how to allocate coding chunk buffers, using DirectByteBuffer or
+   * bytes array. It will return false by default.
+   * @return true if native buffer is preferred for performance consideration,
+   * otherwise false.
+   */
+  public boolean preferDirectBuffer() {
+    return false;
+  }
+
+  /**
+   * Allow change into input buffers or not while perform encoding/decoding.
+   * @return true if it's allowed to change inputs, false otherwise
+   */
+  public boolean allowChangeInputs() {
+    return coderOptions.allowChangeInputs();
+  }
+
+  /**
+   * Allow to dump verbose info during encoding/decoding.
+   * @return true if it's allowed to do verbose dump, false otherwise.
+   */
+  public boolean allowVerboseDump() {
+    return coderOptions.allowVerboseDump();
+  }
+
+  /**
+   * Should be called when release this coder. Good chance to release encoding
+   * or decoding buffers
+   */
+  public void release() {
+    // Nothing to do here.
+  }

INS26 INS40 INS83 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS83 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS83 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS83 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS66 INS66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 INS66 UPD66 UPD42 MOV42 INS42 INS43 INS42 INS21 INS60 INS60 INS60 INS25 INS60 INS24 INS25 INS24 INS65 INS65 INS43 INS42 INS60 INS25 INS21 INS65 INS65 INS43 INS42 INS60 INS60 INS21 INS41 INS41 INS41 INS65 INS65 INS41 INS65 INS65 INS41 INS65 INS65 INS41 INS65 INS42 INS7 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS8 INS8 INS58 INS27 INS37 INS8 INS66 INS42 INS66 INS42 INS43 INS59 INS27 INS8 INS32 INS66 INS66 INS42 INS66 INS42 INS5 INS59 INS5 INS59 INS32 INS32 INS32 INS32 INS66 INS66 INS66 INS66 INS66 INS9 INS66 INS66 INS32 INS66 INS66 INS32 INS66 INS66 INS22 INS42 INS42 INS42 INS14 INS42 INS40 INS42 INS40 INS42 INS34 INS41 INS39 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS60 INS21 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS42 INS14 INS40 INS34 INS41 INS42 INS42 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS43 INS52 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS27 INS8 INS32 INS43 INS59 INS32 INS42 INS34 INS27 INS8 INS43 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS2 INS33 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS2 INS33 INS21 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS32 INS2 INS32 INS2 INS42 INS27 INS42 INS42 INS2 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 DEL42 DEL65 DEL43
YARN-2975. FSLeafQueue app lists are accessed without required locks. (kasha)

+
+    // Remove app from runnable/nonRunnable list while holding the write lock
-      if (runnableApps.remove(app)) {
-        runnable = true;
-      } else if (nonRunnableApps.remove(app)) {
-        runnable = false; //nop, runnable is initialised to false already
-      } else {
-        throw new IllegalStateException("Given app to remove " + app +
-            " does not exist in queue " + this);
+      runnable = runnableApps.remove(app);
+      if (!runnable) {
+        // removeNonRunnableApp acquires the write lock again, which is fine
+        if (!removeNonRunnableApp(app)) {
+          throw new IllegalStateException("Given app to remove " + app +
+              " does not exist in queue " + this);
+        }
+
+
-  
-  public Collection<FSAppAttempt> getRunnableAppSchedulables() {
-    return runnableApps;
+
+  /**
+   * Removes the given app if it is non-runnable and belongs to this queue
+   * @return true if the app is removed, false otherwise
+   */
+  public boolean removeNonRunnableApp(FSAppAttempt app) {
+    writeLock.lock();
+    try {
+      return nonRunnableApps.remove(app);
+    } finally {
+      writeLock.unlock();
+    }
-  
-  public List<FSAppAttempt> getNonRunnableAppSchedulables() {
-    return nonRunnableApps;
+
+  public boolean isRunnableApp(FSAppAttempt attempt) {
+    readLock.lock();
+    try {
+      return runnableApps.contains(attempt);
+    } finally {
+      readLock.unlock();
+    }
-  
+
+  public boolean isNonRunnableApp(FSAppAttempt attempt) {
+    readLock.lock();
+    try {
+      return nonRunnableApps.contains(attempt);
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  public void resetPreemptedResources() {
+    readLock.lock();
+    try {
+      for (FSAppAttempt attempt : runnableApps) {
+        attempt.resetPreemptedResources();
+      }
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  public void clearPreemptedResources() {
+    readLock.lock();
+    try {
+      for (FSAppAttempt attempt : runnableApps) {
+        attempt.clearPreemptedResources();
+      }
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  public List<FSAppAttempt> getCopyOfNonRunnableAppSchedulables() {
+    List<FSAppAttempt> appsToReturn = new ArrayList<FSAppAttempt>();
+    readLock.lock();
+    try {
+      appsToReturn.addAll(nonRunnableApps);
+    } finally {
+      readLock.unlock();
+    }
+    return appsToReturn;
+  }
+
-    policy.computeShares(getRunnableAppSchedulables(), getFairShare());
+    readLock.lock();
+    try {
+      policy.computeShares(runnableApps, getFairShare());
+    } finally {
+      readLock.unlock();
+    }
-    return runnableApps.size();
+    readLock.lock();
+    try {
+      return runnableApps.size();
+    } finally {
+      readLock.unlock();
+    }
-  
+
+  public int getNumNonRunnableApps() {
+    readLock.lock();
+    try {
+      return nonRunnableApps.size();
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  public int getNumPendingApps() {
+    int numPendingApps = 0;
+    readLock.lock();
+    try {
+      for (FSAppAttempt attempt : runnableApps) {
+        if (attempt.isPending()) {
+          numPendingApps++;
+        }
+      }
+      numPendingApps += nonRunnableApps.size();
+    } finally {
+      readLock.unlock();
+    }
+    return numPendingApps;
+  }
+
+  /**
+   * TODO: Based on how frequently this is called, we might want to club
+   * counting pending and active apps in the same method.
+   */
+  public int getNumActiveApps() {
+    int numActiveApps = 0;
+    readLock.lock();
+    try {
+      for (FSAppAttempt attempt : runnableApps) {
+        if (!attempt.isPending()) {
+          numActiveApps++;
+        }
+      }
+    } finally {
+      readLock.unlock();
+    }
+    return numActiveApps;
+  }
+

INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS8 INS39 UPD42 INS44 INS8 INS39 UPD42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 MOV74 INS42 INS8 INS8 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS65 INS65 INS43 INS42 INS21 INS54 INS43 INS42 INS21 INS54 INS43 INS42 INS21 INS54 INS21 INS54 INS21 INS54 INS60 INS21 INS54 INS41 INS21 INS54 INS21 INS54 INS21 INS54 INS60 INS21 INS54 INS41 INS65 INS60 INS21 INS54 INS41 INS66 INS66 INS42 INS32 INS8 INS8 INS42 INS32 INS8 INS8 INS42 INS32 INS8 INS8 INS32 INS8 INS8 INS32 INS8 INS8 INS74 INS59 INS32 INS8 INS8 INS42 INS32 INS8 INS8 INS32 MOV8 INS8 INS32 INS8 INS8 INS39 INS59 INS32 INS8 INS8 INS42 INS66 INS66 INS39 INS59 INS32 INS8 INS8 INS42 INS21 INS42 INS42 INS41 INS21 INS42 INS42 MOV41 INS21 INS42 INS42 MOV41 INS21 INS42 INS42 INS70 INS21 INS42 INS42 INS70 INS21 INS43 INS43 INS42 INS14 INS42 INS42 INS21 INS21 INS42 INS42 MOV21 INS21 INS42 INS42 INS21 INS42 INS42 INS41 INS21 INS42 INS34 INS42 INS42 INS70 INS21 INS21 INS42 INS34 INS42 INS42 INS70 INS21 INS7 INS38 INS8 MOV32 INS32 INS32 INS32 INS32 INS32 INS44 INS42 INS8 INS32 INS44 INS42 INS8 INS32 INS42 INS42 UPD74 MOV74 INS32 INS32 INS32 INS32 INS32 INS32 INS44 INS42 INS8 INS7 INS32 INS44 INS42 INS8 INS32 INS42 MOV32 INS42 MOV25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS21 INS42 INS42 INS43 INS42 INS21 INS42 INS42 UPD43 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS25 INS42 INS32 INS42 INS42 INS43 INS42 INS25 INS42 INS42 INS38 INS42 INS32 INS42 INS32 UPD42 INS42 INS32 INS8 INS42 INS42 INS42 INS38 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS32 INS21 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL8 DEL42 DEL8 DEL32 DEL8
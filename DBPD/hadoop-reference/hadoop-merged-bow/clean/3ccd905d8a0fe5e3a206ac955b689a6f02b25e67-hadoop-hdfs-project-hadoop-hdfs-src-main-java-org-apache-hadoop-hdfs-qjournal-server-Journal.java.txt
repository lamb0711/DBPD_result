HDFS-3955. QJM: Make acceptRecovery() atomic. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1387706 13f79535-47bb-0310-9956-ffa450edef68

+    PersistedRecoveryPaxosData previouslyAccepted = getPersistedPaxosData(segmentTxId);
+    completeHalfDoneAcceptRecovery(previouslyAccepted);
+
-    
-    PersistedRecoveryPaxosData previouslyAccepted = getPersistedPaxosData(segmentTxId);
-
+  
-
+    
+    File syncedFile = null;
+    
-      syncLog(reqInfo, segment, fromUrl);
+      syncedFile = syncLog(reqInfo, segment, fromUrl);
-    // TODO: is it OK that this is non-atomic?
-    // we might be left with an older epoch recorded, but a newer log
-    
+    // This is one of the few places in the protocol where we have a single
+    // RPC that results in two distinct actions:
+    //
+    // - 1) Downloads the new log segment data (above)
+    // - 2) Records the new Paxos data about the synchronized segment (below)
+    //
+    // These need to be treated as a transaction from the perspective
+    // of any external process. We do this by treating the persistPaxosData()
+    // success as the "commit" of an atomic transaction. If we fail before
+    // this point, the downloaded edit log will only exist at a temporary
+    // path, and thus not change any externally visible state. If we fail
+    // after this point, then any future prepareRecovery() call will see
+    // the Paxos data, and by calling completeHalfDoneAcceptRecovery() will
+    // roll forward the rename of the referenced log file.
+    //
+    // See also: HDFS-3955
+    //
+    // The fault points here are exercised by the randomized fault injection
+    // test case to ensure that this atomic "transaction" operates correctly.
+    JournalFaultInjector.get().beforePersistPaxosData();
+    JournalFaultInjector.get().afterPersistPaxosData();
+
+    if (syncedFile != null) {
+      FileUtil.replaceFile(syncedFile,
+          storage.getInProgressEditLog(segmentTxId));
+    }
+
-   * Synchronize a log segment from another JournalNode.
-   * @param reqInfo the request info for the recovery IPC
-   * @param segment 
-   * @param url
-   * @throws IOException
+   * Synchronize a log segment from another JournalNode. The log is
+   * downloaded from the provided URL into a temporary location on disk,
+   * which is named based on the current request's epoch.
+   *
+   * @return the temporary location of the downloaded file
-  private void syncLog(RequestInfo reqInfo,
+  private File syncLog(RequestInfo reqInfo,
-    String tmpFileName =
-        "synclog_" + segment.getStartTxId() + "_" +
-        reqInfo.getEpoch() + "." + reqInfo.getIpcSerialNumber();
-    
-    final List<File> localPaths = storage.getFiles(null, tmpFileName);
-    assert localPaths.size() == 1;
-    final File tmpFile = localPaths.get(0);
+    final File tmpFile = storage.getSyncLogTemporaryFile(
+        segment.getStartTxId(), reqInfo.getEpoch());
+    final List<File> localPaths = ImmutableList.of(tmpFile);
-            TransferFsImage.doGetUrl(url, localPaths, storage, true);
-            assert tmpFile.exists();
-              success = tmpFile.renameTo(storage.getInProgressEditLog(
-                  segment.getStartTxId()));
+              TransferFsImage.doGetUrl(url, localPaths, storage, true);
+              assert tmpFile.exists();
+              success = true;
+    return tmpFile;
+  }
+  
+
+  /**
+   * In the case the node crashes in between downloading a log segment
+   * and persisting the associated paxos recovery data, the log segment
+   * will be left in its temporary location on disk. Given the paxos data,
+   * we can check if this was indeed the case, and &quot;roll forward&quot;
+   * the atomic operation.
+   * 
+   * See the inline comments in
+   * {@link #acceptRecovery(RequestInfo, SegmentStateProto, URL)} for more
+   * details.
+   *
+   * @throws IOException if the temporary file is unable to be renamed into
+   * place
+   */
+  private void completeHalfDoneAcceptRecovery(
+      PersistedRecoveryPaxosData paxosData) throws IOException {
+    if (paxosData == null) {
+      return;
+    }
+
+    long segmentId = paxosData.getSegmentState().getStartTxId();
+    long epoch = paxosData.getAcceptedInEpoch();
+    
+    File tmp = storage.getSyncLogTemporaryFile(segmentId, epoch);
+    
+    if (tmp.exists()) {
+      File dst = storage.getInProgressEditLog(segmentId);
+      LOG.info("Rolling forward previously half-completed synchronization: " +
+          tmp + " -> " + dst);
+      FileUtil.replaceFile(tmp, dst);
+    }

INS31 MOV60 INS43 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS21 INS60 INS21 INS21 INS25 INS65 UPD65 INS42 INS41 INS65 INS65 INS43 INS42 INS42 INS25 INS60 INS60 INS60 INS25 INS32 INS43 INS59 INS32 INS32 INS27 INS8 UPD66 MOV66 INS66 UPD66 MOV66 UPD66 INS83 UPD43 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS39 INS59 INS39 INS59 INS43 INS59 INS32 INS8 INS42 INS42 INS42 INS42 INS33 INS32 INS42 INS32 INS42 INS42 INS33 INS21 MOV42 UPD42 INS32 INS68 INS42 INS33 INS41 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS21 INS7 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV32 MOV32 UPD42 UPD42 UPD42 INS42 INS69 INS69 INS69 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS42 MOV32 INS42 INS42 INS42 INS32 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 MOV21 MOV6 INS9 DEL65 DEL42 DEL65 DEL42 DEL42 DEL65 DEL42 DEL65 DEL39 DEL45 DEL45 DEL45 DEL32 DEL27 DEL33 DEL42 DEL42 DEL32 DEL34 DEL27 DEL6 DEL83 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32
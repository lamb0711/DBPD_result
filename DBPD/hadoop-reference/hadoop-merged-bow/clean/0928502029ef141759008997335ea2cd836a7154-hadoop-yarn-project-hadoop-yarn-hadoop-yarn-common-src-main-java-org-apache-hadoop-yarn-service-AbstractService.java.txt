YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.
YARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.
MAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import com.google.common.annotations.VisibleForTesting;
+/**
+ * This is the base implementation class for YARN services.
+ */
-   * Service state: initially {@link STATE#NOTINITED}.
-   */
-  private STATE state = STATE.NOTINITED;
-
-  /**
+
+  /** service state */
+  private final ServiceStateModel stateModel;
+
-  private Configuration config;
+  private volatile Configuration config;
-  private List<ServiceStateChangeListener> listeners =
-    new ArrayList<ServiceStateChangeListener>();
+  private final ServiceOperations.ServiceListeners listeners
+    = new ServiceOperations.ServiceListeners();
+  /**
+   * Static listeners to all events across all services
+   */
+  private static ServiceOperations.ServiceListeners globalListeners
+    = new ServiceOperations.ServiceListeners();
+   * The cause of any failure -will be null.
+   * if a service did not stop due to a failure.
+   */
+  private Exception failureCause;
+
+  /**
+   * the state in which the service was when it failed.
+   * Only valid when the service is stopped due to a failure
+   */
+  private STATE failureState = null;
+
+  /**
+   * object used to co-ordinate {@link #waitForServiceToStop(long)}
+   * across threads.
+   */
+  private final AtomicBoolean terminationNotification =
+    new AtomicBoolean(false);
+
+  /**
+   * History of lifecycle transitions
+   */
+  private final List<LifecycleEvent> lifecycleHistory
+    = new ArrayList<LifecycleEvent>(5);
+
+  /**
+   * Map of blocking dependencies
+   */
+  private final Map<String,String> blockerMap = new HashMap<String, String>();
+
+  private final Object stateChangeLock = new Object();
+ 
+  /**
+    stateModel = new ServiceStateModel(name);
-  public synchronized STATE getServiceState() {
-    return state;
+  public final STATE getServiceState() {
+    return stateModel.getState();
+  }
+
+  @Override
+  public final synchronized Throwable getFailureCause() {
+    return failureCause;
+  }
+
+  @Override
+  public synchronized STATE getFailureState() {
+    return failureState;
-   * {@inheritDoc}
-   * @throws IllegalStateException if the current service state does not permit
-   * this action
+   * Set the configuration for this service.
+   * This method is called during {@link #init(Configuration)}
+   * and should only be needed if for some reason a service implementation
+   * needs to override that initial setting -for example replacing
+   * it with a new subclass of {@link Configuration}
+   * @param conf new configuration.
-  @Override
-  public synchronized void init(Configuration conf) {
-    ensureCurrentState(STATE.NOTINITED);
+  protected void setConfig(Configuration conf) {
-    changeState(STATE.INITED);
-    LOG.info("Service:" + getName() + " is inited.");
-   * @throws IllegalStateException if the current service state does not permit
-   * this action
+   * This invokes {@link #serviceInit}
+   * @param conf the configuration of the service. This must not be null
+   * @throws ServiceStateException if the configuration was null,
+   * the state change not permitted, or something else went wrong
-  public synchronized void start() {
-    startTime = System.currentTimeMillis();
-    ensureCurrentState(STATE.INITED);
-    changeState(STATE.STARTED);
-    LOG.info("Service:" + getName() + " is started.");
-  }
-
-  /**
-   * {@inheritDoc}
-   * @throws IllegalStateException if the current service state does not permit
-   * this action
-   */
-  @Override
-  public synchronized void stop() {
-    if (state == STATE.STOPPED ||
-        state == STATE.INITED ||
-        state == STATE.NOTINITED) {
-      // already stopped, or else it was never
-      // started (eg another service failing canceled startup)
+  public void init(Configuration conf) {
+    if (conf == null) {
+      throw new ServiceStateException("Cannot initialize service "
+                                      + getName() + ": null configuration");
+    }
+    if (isInState(STATE.INITED)) {
-    ensureCurrentState(STATE.STARTED);
-    changeState(STATE.STOPPED);
-    LOG.info("Service:" + getName() + " is stopped.");
+    synchronized (stateChangeLock) {
+      if (enterState(STATE.INITED) != STATE.INITED) {
+        setConfig(conf);
+        try {
+          serviceInit(config);
+          if (isInState(STATE.INITED)) {
+            //if the service ended up here during init,
+            //notify the listeners
+            notifyListeners();
+          }
+        } catch (Exception e) {
+          noteFailure(e);
+          ServiceOperations.stopQuietly(LOG, this);
+          throw ServiceStateException.convert(e);
+        }
+      }
+    }
+  }
+
+  /**
+   * {@inheritDoc}
+   * @throws ServiceStateException if the current service state does not permit
+   * this action
+   */
+  @Override
+  public void start() {
+    if (isInState(STATE.STARTED)) {
+      return;
+    }
+    //enter the started state
+    synchronized (stateChangeLock) {
+      if (stateModel.enterState(STATE.STARTED) != STATE.STARTED) {
+        try {
+          startTime = System.currentTimeMillis();
+          serviceStart();
+          if (isInState(STATE.STARTED)) {
+            //if the service started (and isn't now in a later state), notify
+            if (LOG.isDebugEnabled()) {
+              LOG.debug("Service " + getName() + " is started");
+            }
+            notifyListeners();
+          }
+        } catch (Exception e) {
+          noteFailure(e);
+          ServiceOperations.stopQuietly(LOG, this);
+          throw ServiceStateException.convert(e);
+        }
+      }
+    }
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void stop() {
+    if (isInState(STATE.STOPPED)) {
+      return;
+    }
+    synchronized (stateChangeLock) {
+      if (enterState(STATE.STOPPED) != STATE.STOPPED) {
+        try {
+          serviceStop();
+        } catch (Exception e) {
+          //stop-time exceptions are logged if they are the first one,
+          noteFailure(e);
+          throw ServiceStateException.convert(e);
+        } finally {
+          //report that the service has terminated
+          terminationNotification.set(true);
+          synchronized (terminationNotification) {
+            terminationNotification.notifyAll();
+          }
+          //notify anything listening for events
+          notifyListeners();
+        }
+      } else {
+        //already stopped: note it
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Ignoring re-entrant call to stop()");
+        }
+      }
+    }
+  }
+
+  /**
+   * Relay to {@link #stop()}
+   * @throws IOException
+   */
+  @Override
+  public final void close() throws IOException {
+    stop();
+  }
+
+  /**
+   * Failure handling: record the exception
+   * that triggered it -if there was not one already.
+   * Services are free to call this themselves.
+   * @param exception the exception
+   */
+  protected final void noteFailure(Exception exception) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("noteFailure " + exception, null);
+    }
+    if (exception == null) {
+      //make sure failure logic doesn't itself cause problems
+      return;
+    }
+    //record the failure details, and log it
+    synchronized (this) {
+      if (failureCause == null) {
+        failureCause = exception;
+        failureState = getServiceState();
+        LOG.info("Service " + getName()
+                 + " failed in state " + failureState
+                 + "; cause: " + exception,
+                 exception);
+      }
+    }
-  public synchronized void register(ServiceStateChangeListener l) {
+  public final boolean waitForServiceToStop(long timeout) {
+    boolean completed = terminationNotification.get();
+    while (!completed) {
+      try {
+        synchronized(terminationNotification) {
+          terminationNotification.wait(timeout);
+        }
+        // here there has been a timeout, the object has terminated,
+        // or there has been a spurious wakeup (which we ignore)
+        completed = true;
+      } catch (InterruptedException e) {
+        // interrupted; have another look at the flag
+        completed = terminationNotification.get();
+      }
+    }
+    return terminationNotification.get();
+  }
+
+  /* ===================================================================== */
+  /* Override Points */
+  /* ===================================================================== */
+
+  /**
+   * All initialization code needed by a service.
+   *
+   * This method will only ever be called once during the lifecycle of
+   * a specific service instance.
+   *
+   * Implementations do not need to be synchronized as the logic
+   * in {@link #init(Configuration)} prevents re-entrancy.
+   *
+   * The base implementation checks to see if the subclass has created
+   * a new configuration instance, and if so, updates the base class value
+   * @param conf configuration
+   * @throws Exception on a failure -these will be caught,
+   * possibly wrapped, and wil; trigger a service stop
+   */
+  protected void serviceInit(Configuration conf) throws Exception {
+    if (conf != config) {
+      LOG.debug("Config has been overridden during init");
+      setConfig(conf);
+    }
+  }
+
+  /**
+   * Actions called during the INITED to STARTED transition.
+   *
+   * This method will only ever be called once during the lifecycle of
+   * a specific service instance.
+   *
+   * Implementations do not need to be synchronized as the logic
+   * in {@link #start()} prevents re-entrancy.
+   *
+   * @throws Exception if needed -these will be caught,
+   * wrapped, and trigger a service stop
+   */
+  protected void serviceStart() throws Exception {
+
+  }
+
+  /**
+   * Actions called during the transition to the STOPPED state.
+   *
+   * This method will only ever be called once during the lifecycle of
+   * a specific service instance.
+   *
+   * Implementations do not need to be synchronized as the logic
+   * in {@link #stop()} prevents re-entrancy.
+   *
+   * Implementations MUST write this to be robust against failures, including
+   * checks for null references -and for the first failure to not stop other
+   * attempts to shut down parts of the service.
+   *
+   * @throws Exception if needed -these will be caught and logged.
+   */
+  protected void serviceStop() throws Exception {
+
+  }
+
+  @Override
+  public void register(ServiceStateChangeListener l) {
-  public synchronized void unregister(ServiceStateChangeListener l) {
+  public void unregister(ServiceStateChangeListener l) {
+  /**
+   * Register a global listener, which receives notifications
+   * from the state change events of all services in the JVM
+   * @param l listener
+   */
+  public static void registerGlobalListener(ServiceStateChangeListener l) {
+    globalListeners.add(l);
+  }
+
+  /**
+   * unregister a global listener.
+   * @param l listener to unregister
+   * @return true if the listener was found (and then deleted)
+   */
+  public static boolean unregisterGlobalListener(ServiceStateChangeListener l) {
+    return globalListeners.remove(l);
+  }
+
+  /**
+   * Package-scoped method for testing -resets the global listener list
+   */
+  @VisibleForTesting
+  static void resetGlobalListeners() {
+    globalListeners.reset();
+  }
+
-   * Verify that that a service is in a given state.
-   * @param currentState the desired state
-   * @throws IllegalStateException if the service state is different from
-   * the desired state
+   * Notify local and global listeners of state changes.
+   * Exceptions raised by listeners are NOT passed up.
-  private void ensureCurrentState(STATE currentState) {
-    ServiceOperations.ensureCurrentState(state, currentState);
+  private void notifyListeners() {
+    try {
+      listeners.notifyListeners(this);
+      globalListeners.notifyListeners(this);
+    } catch (Throwable e) {
+      LOG.warn("Exception while notifying listeners of " + this + ": " + e,
+               e);
+    }
-   * Change to a new state and notify all listeners.
-   * This is a private method that is only invoked from synchronized methods,
-   * which avoid having to clone the listener list. It does imply that
-   * the state change listener methods should be short lived, as they
-   * will delay the state transition.
-   * @param newState new service state
+   * Add a state change event to the lifecycle history
-  private void changeState(STATE newState) {
-    state = newState;
-    //notify listeners
-    for (ServiceStateChangeListener l : listeners) {
-      l.stateChanged(this);
+  private void recordLifecycleEvent() {
+    LifecycleEvent event = new LifecycleEvent();
+    event.time = System.currentTimeMillis();
+    event.state = getServiceState();
+    lifecycleHistory.add(event);
+  }
+
+  @Override
+  public synchronized List<LifecycleEvent> getLifecycleHistory() {
+    return new ArrayList<LifecycleEvent>(lifecycleHistory);
+  }
+
+  /**
+   * Enter a state; record this via {@link #recordLifecycleEvent}
+   * and log at the info level.
+   * @param newState the proposed new state
+   * @return the original state
+   * it wasn't already in that state, and the state model permits state re-entrancy.
+   */
+  private STATE enterState(STATE newState) {
+    assert stateModel != null : "null state in " + name + " " + this.getClass();
+    STATE oldState = stateModel.enterState(newState);
+    if (oldState != newState) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug(
+          "Service: " + getName() + " entered state " + getServiceState());
+      }
+      recordLifecycleEvent();
+    }
+    return oldState;
+  }
+
+  @Override
+  public final boolean isInState(Service.STATE expected) {
+    return stateModel.isInState(expected);
+  }
+
+  @Override
+  public String toString() {
+    return "Service " + name + " in state " + stateModel;
+  }
+
+  /**
+   * Put a blocker to the blocker map -replacing any
+   * with the same name.
+   * @param name blocker name
+   * @param details any specifics on the block. This must be non-null.
+   */
+  protected void putBlocker(String name, String details) {
+    synchronized (blockerMap) {
+      blockerMap.put(name, details);
+    }
+  }
+
+  /**
+   * Remove a blocker from the blocker map -
+   * this is a no-op if the blocker is not present
+   * @param name the name of the blocker
+   */
+  public void removeBlocker(String name) {
+    synchronized (blockerMap) {
+      blockerMap.remove(name);
+    }
+  }
+
+  @Override
+  public Map<String, String> getBlockers() {
+    synchronized (blockerMap) {
+      Map<String, String> map = new HashMap<String, String>(blockerMap);
+      return map;

INS26 INS26 INS26 INS26 INS26 MOV23 MOV31 INS40 INS40 INS40 INS40 INS40 INS29 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS65 INS29 INS83 INS83 INS43 INS59 INS83 MOV29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 MOV43 INS59 INS83 INS43 INS29 INS83 UPD74 INS29 INS83 INS83 INS74 INS59 INS83 INS83 INS43 INS59 MOV78 INS83 INS83 MOV43 INS42 INS8 INS78 INS83 INS83 INS83 INS43 INS42 INS8 INS78 INS43 UPD42 INS29 INS83 INS39 INS42 MOV44 INS8 INS29 MOV78 INS83 INS39 INS42 INS44 INS8 INS29 MOV78 MOV83 INS39 INS42 INS8 MOV29 MOV78 UPD83 MOV83 MOV39 UPD42 MOV42 MOV8 INS29 INS78 UPD83 INS42 INS43 INS8 UPD83 UPD83 UPD42 INS44 INS78 INS83 INS83 INS39 INS42 INS44 INS8 UPD83 UPD42 INS43 INS8 MOV29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS78 INS83 INS39 INS42 INS8 INS29 MOV83 MOV39 UPD42 MOV42 MOV8 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS83 INS74 INS42 INS8 INS29 INS83 INS43 INS42 MOV44 INS8 INS78 INS83 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS74 INS42 INS8 INS66 INS65 INS42 INS42 INS40 INS42 INS14 INS65 INS40 INS42 INS14 INS65 INS42 INS42 INS65 INS42 INS33 INS42 UPD42 INS14 INS65 UPD43 UPD42 INS65 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS21 INS41 INS42 INS42 INS41 INS42 INS42 INS65 INS65 MOV21 MOV65 INS65 INS65 INS43 INS42 INS25 INS25 INS51 MOV65 MOV65 INS25 INS51 INS25 INS51 INS65 INS65 INS42 INS42 INS21 INS65 UPD65 INS43 INS42 INS25 INS25 INS51 INS42 INS39 INS42 INS60 INS61 INS41 INS43 UPD42 INS42 INS25 UPD65 INS42 INS65 INS65 INS42 INS65 INS65 INS21 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS42 INS21 INS65 INS54 INS65 INS60 INS21 INS21 INS21 INS42 INS43 INS43 INS41 INS65 INS65 INS65 INS42 INS6 INS60 INS25 INS41 INS42 INS43 INS42 INS41 INS42 INS42 INS41 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS51 INS65 INS65 INS43 INS42 INS51 INS42 INS43 INS43 INS43 INS51 INS66 INS43 INS66 INS43 INS66 INS66 INS66 INS66 UPD66 UPD66 INS43 INS9 INS66 UPD42 UPD74 INS34 INS66 INS42 INS42 INS42 INS74 INS43 INS7 INS32 INS42 UPD42 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS42 INS66 INS66 INS65 INS42 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS32 MOV8 INS42 INS8 UPD42 INS32 INS8 INS42 INS8 INS32 INS8 INS42 INS8 INS66 INS65 INS42 INS32 INS66 INS66 INS66 UPD42 UPD66 INS42 INS32 INS8 INS27 INS8 INS52 INS8 INS39 INS59 INS38 INS8 INS32 INS66 INS66 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 UPD42 UPD66 UPD42 UPD66 UPD66 INS42 INS27 INS8 UPD66 UPD66 UPD66 UPD66 INS66 INS65 UPD66 UPD42 INS66 UPD66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS32 INS66 INS42 INS66 INS66 INS42 INS32 INS66 INS32 INS66 INS66 INS8 INS12 INS66 INS43 INS59 INS7 INS7 INS32 INS42 INS42 INS14 INS66 INS65 INS66 INS42 INS66 INS66 INS66 INS27 INS27 MOV43 INS59 INS27 INS8 INS42 INS40 INS32 INS27 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS8 INS66 INS66 INS42 INS66 INS42 INS42 INS8 INS42 INS42 INS42 INS42 INS8 INS40 INS40 INS68 INS42 UPD43 INS43 INS43 INS43 INS42 INS42 INS14 INS42 INS42 INS68 INS42 INS67 INS42 INS33 INS53 INS42 INS40 INS25 INS42 INS40 INS41 INS25 UPD42 MOV42 UPD40 MOV40 INS41 INS25 INS68 INS42 INS42 INS42 INS21 UPD42 MOV42 INS33 INS41 INS25 INS42 INS32 INS42 INS54 INS42 INS42 INS68 INS42 INS42 INS21 INS21 INS68 INS68 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 INS21 INS44 INS8 INS42 INS42 INS14 INS40 INS32 INS40 INS32 INS42 INS42 INS42 INS74 INS42 INS67 INS42 INS33 INS45 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS25 INS21 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS21 INS21 INS60 INS41 INS42 INS69 UPD42 INS42 INS42 INS42 INS43 INS42 INS42 INS69 INS42 INS14 INS27 INS8 INS27 INS8 INS27 INS8 INS8 INS42 INS32 INS27 INS8 INS42 INS42 INS8 INS12 INS42 INS69 INS32 INS32 INS42 INS42 INS32 INS32 INS43 INS42 MOV21 INS43 INS42 INS42 INS42 INS43 INS43 INS42 INS52 INS42 INS42 INS42 INS42 INS32 INS8 INS32 INS32 INS32 INS74 INS59 INS42 INS39 INS42 INS43 INS43 MOV27 INS32 INS40 INS21 INS54 INS32 INS40 INS54 INS32 INS40 INS54 INS25 INS42 INS42 INS27 INS33 UPD42 MOV42 INS33 MOV21 MOV21 MOV21 INS51 INS21 INS44 INS8 INS43 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS14 INS42 INS42 UPD45 UPD45 INS42 INS40 INS32 INS8 INS12 INS42 INS42 INS40 INS8 INS12 UPD42 MOV42 UPD40 MOV40 INS8 INS12 INS8 INS32 INS8 INS45 UPD42 MOV42 INS7 INS7 INS42 INS8 INS7 INS43 INS42 INS21 INS42 UPD42 UPD42 INS27 INS42 INS32 INS42 INS42 INS42 INS74 INS42 INS42 INS42 INS21 INS25 INS44 INS8 MOV21 INS21 INS25 INS44 INS8 INS21 INS44 INS8 INS21 INS51 INS21 INS42 INS42 MOV21 INS42 INS42 INS42 INS32 INS27 INS42 INS21 INS42 INS9 INS42 INS7 INS45 INS52 INS45 INS42 INS42 INS42 INS27 INS43 INS43 INS43 INS32 INS32 INS8 INS43 INS42 INS21 INS21 INS53 INS32 INS32 INS8 INS43 INS42 INS21 INS21 INS53 INS32 INS43 INS42 INS21 INS53 INS32 INS42 INS8 INS32 UPD42 MOV42 INS45 MOV32 INS45 INS42 INS45 INS42 INS32 INS42 INS32 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS21 INS42 INS32 INS32 INS32 INS42 INS42 INS40 INS25 INS21 INS42 INS32 INS32 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS9 INS21 INS42 UPD42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS32 MOV8 INS32 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD45 UPD45 DEL42 DEL42 DEL67 DEL40 DEL42 DEL40 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL42 DEL66 DEL66 DEL65 DEL45 DEL45 DEL27 DEL32 DEL21 DEL32 DEL21 DEL29 DEL31 DEL42 DEL66 DEL42 DEL40 DEL32 DEL40 DEL32 DEL40 DEL27 DEL40 DEL27 DEL27 DEL40 DEL27 DEL27 DEL25 DEL32 DEL21 DEL8 DEL83 DEL83 DEL42 DEL42 DEL7 DEL52 DEL42 DEL8 DEL70 DEL31
YARN-4025. Deal with byte representations of Longs in writer code. Contributed by Sangjin Lee and Vrushali C.

+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+  private static final Log LOG = LogFactory.getLog(ColumnHelper.class);
+            LOG.info("null prefix was specified; returning all columns");
-   *          columns are returned.
-   * @return the latest values of columns in the column family.
+   *        columns are returned.
+   * @return the latest values of columns in the column family. This assumes
+   *         that the column name parts are all Strings by default. If the
+   *         column name parts should be treated natively and not be converted
+   *         back and forth from Strings, you should use
+   *         {@link #readResultsHavingCompoundColumnQualifiers(Result, byte[])}
+   *         instead.
-  public Map<String, Object> readResults(Result result, byte[] columnPrefixBytes)
-      throws IOException {
+  public Map<String, Object> readResults(Result result,
+      byte[] columnPrefixBytes) throws IOException {
-        if (entry.getKey() != null && entry.getKey().length > 0) {
+        byte[] columnKey = entry.getKey();
+        if (columnKey != null && columnKey.length > 0) {
+            LOG.info("null prefix was specified; returning all columns");
-            columnName = Separator.decode(entry.getKey(), Separator.SPACE);
+            columnName = Separator.decode(columnKey, Separator.SPACE);
-                Separator.QUALIFIERS.split(entry.getKey(), 2);
+                Separator.QUALIFIERS.split(columnKey, 2);
+              // if the column name is a compound qualifier
+              // with non string datatypes, the following decode will not
+              // work correctly since it considers all components to be String
+              // invoke the readResultsHavingCompoundColumnQualifiers function
+   * @param result from which to read columns
+   * @param columnPrefixBytes optional prefix to limit columns. If null all
+   *        columns are returned.
+   * @return the latest values of columns in the column family. If the column
+   *         prefix is null, the column qualifier is returned as Strings. For a
+   *         non-null column prefix bytes, the column qualifier is returned as
+   *         a list of parts, each part a byte[]. This is to facilitate
+   *         returning byte arrays of values that were not Strings.
+   * @throws IOException
+   */
+  public Map<?, Object> readResultsHavingCompoundColumnQualifiers(Result result,
+      byte[] columnPrefixBytes) throws IOException {
+    // handle the case where the column prefix is null
+    // it is the same as readResults() so simply delegate to that implementation
+    if (columnPrefixBytes == null) {
+      return readResults(result, null);
+    }
+
+    Map<byte[][], Object> results = new HashMap<byte[][], Object>();
+
+    if (result != null) {
+      Map<byte[], byte[]> columns = result.getFamilyMap(columnFamilyBytes);
+      for (Entry<byte[], byte[]> entry : columns.entrySet()) {
+        byte[] columnKey = entry.getKey();
+        if (columnKey != null && columnKey.length > 0) {
+          // A non-null prefix means columns are actually of the form
+          // prefix!columnNameRemainder
+          // with a compound column qualifier, we are presuming existence of a
+          // prefix
+          byte[][] columnNameParts = Separator.QUALIFIERS.split(columnKey, 2);
+          if (columnNameParts.length > 0) {
+            byte[] actualColumnPrefixBytes = columnNameParts[0];
+            if (Bytes.equals(columnPrefixBytes, actualColumnPrefixBytes)
+                && columnNameParts.length == 2) {
+              // This is the prefix that we want
+              byte[][] columnQualifierParts =
+                  Separator.VALUES.split(columnNameParts[1]);
+              Object value = GenericObjectMapper.read(entry.getValue());
+              // we return the columnQualifier in parts since we don't know
+              // which part is of which data type
+              results.put(columnQualifierParts, value);
+            }
+          }
+        }
+      } // for entry
+    }
+    return results;
+  }
+
+  /**
+  /**
+   * @param columnPrefixBytes The byte representation for the column prefix.
+   *          Should not contain {@link Separator#QUALIFIERS}.
+   * @param qualifier the byte representation for the remainder of the column.
+   * @return fully sanitized column qualifier that is a combination of prefix
+   *         and qualifier. If prefix is null, the result is simply the encoded
+   *         qualifier without any separator.
+   */
+  public static byte[] getColumnQualifier(byte[] columnPrefixBytes,
+      byte[] qualifier) {
+
+    if (columnPrefixBytes == null) {
+      return qualifier;
+    }
+
+    byte[] columnQualifier =
+        Separator.QUALIFIERS.join(columnPrefixBytes, qualifier);
+    return columnQualifier;
+  }
+

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS42 INS42 INS32 INS65 INS65 INS65 INS65 INS43 INS76 INS43 INS43 INS42 INS5 INS42 INS42 INS25 INS60 INS25 INS41 INS65 INS65 INS65 INS39 INS85 INS5 INS42 INS5 INS42 INS25 INS60 INS41 INS42 INS42 INS57 UPD66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS39 INS85 INS27 INS8 INS74 INS59 INS27 INS8 INS42 INS42 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS66 INS66 INS39 INS85 INS39 INS85 INS27 INS8 INS5 INS59 INS42 INS43 INS68 INS42 INS33 INS41 INS43 INS5 INS43 INS42 INS14 INS42 INS33 INS60 INS70 INS67 INS42 INS33 INS41 INS39 INS85 INS42 INS32 INS42 INS42 INS69 INS69 INS32 INS42 INS39 INS85 INS85 INS42 INS74 INS74 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS43 INS5 INS60 INS42 INS42 INS33 INS43 INS5 INS43 INS43 INS5 INS5 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS25 INS42 INS39 INS85 INS5 INS59 INS42 INS39 INS85 INS85 INS42 INS42 INS39 INS85 INS39 INS85 INS42 INS42 INS42 INS43 INS5 INS5 INS5 INS59 INS27 INS8 INS39 INS85 INS42 MOV32 INS42 INS39 INS85 INS39 INS85 INS39 INS85 INS42 MOV32 INS27 INS27 INS60 INS25 INS42 INS40 INS42 INS33 INS40 INS34 INS5 INS59 INS27 INS8 INS21 INS21 INS39 INS85 INS85 INS42 INS32 INS40 INS34 INS60 INS25 INS32 INS32 INS40 INS42 INS42 INS34 INS5 INS59 INS27 INS8 INS42 INS42 INS45 INS42 INS42 INS45 INS39 INS85 INS42 INS2 INS32 INS27 INS60 INS60 INS21 UPD42 MOV42 UPD42 MOV42 INS42 INS34 INS42 INS42 INS42 INS42 INS40 INS34 INS5 INS59 INS43 INS59 INS32 INS39 INS85 INS85 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS2 INS42 INS42 INS32 INS42 INS34 INS42 INS42 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32
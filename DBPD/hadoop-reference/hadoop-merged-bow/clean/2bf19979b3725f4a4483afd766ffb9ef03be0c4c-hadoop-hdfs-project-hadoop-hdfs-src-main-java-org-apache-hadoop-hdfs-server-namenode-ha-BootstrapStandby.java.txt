Merge trunk into auto-failover branch.

Needs a few tweaks to fix compilation - will do in followup commit. This is just a straight merge


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1324567 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.ha.HAServiceProtocol;
+import org.apache.hadoop.ha.HAServiceStatus;
+import org.apache.hadoop.ha.HAServiceProtocol.HAServiceState;
+import org.apache.hadoop.ha.ServiceFailedException;
+import org.apache.hadoop.hdfs.HdfsConfiguration;
-import org.apache.hadoop.hdfs.NameNodeProxies.ProxyAndInfo;
+import org.apache.hadoop.hdfs.tools.NNHAServiceTarget;
+import org.apache.hadoop.security.AccessControlException;
-  private static final Log LOG = LogFactory.getLog(BootstrapStandby.class); 
+  private static final Log LOG = LogFactory.getLog(BootstrapStandby.class);
-  
+
+  // Exit/return codes.
+  static final int ERR_CODE_FAILED_CONNECT = 2;
+  static final int ERR_CODE_INVALID_VERSION = 3;
+  static final int ERR_CODE_OTHER_NN_NOT_ACTIVE = 4;
+  static final int ERR_CODE_ALREADY_FORMATTED = 5;
+  static final int ERR_CODE_LOGS_UNAVAILABLE = 6; 
+  
+  private NamenodeProtocol createNNProtocolProxy()
+      throws IOException {
+    return NameNodeProxies.createNonHAProxy(getConf(),
+        otherIpcAddr, NamenodeProtocol.class,
+        UserGroupInformation.getLoginUser(), true)
+        .getProxy();
+  }
+  
+  private HAServiceProtocol createHAProtocolProxy()
+      throws IOException {
+    return new NNHAServiceTarget(new HdfsConfiguration(conf),
+        nsId, otherNNId).getProxy(conf, 15000);
+  }
-    ProxyAndInfo<NamenodeProtocol> proxyAndInfo = NameNodeProxies.createNonHAProxy(getConf(),
-      otherIpcAddr, NamenodeProtocol.class,
-      UserGroupInformation.getLoginUser(), true);
-    NamenodeProtocol proxy = proxyAndInfo.getProxy();
+
+    NamenodeProtocol proxy = createNNProtocolProxy();
-      checkLayoutVersion(nsInfo);
-      return 1;
+      return ERR_CODE_FAILED_CONNECT;
+
+    if (!checkLayoutVersion(nsInfo)) {
+      LOG.fatal("Layout version on remote node (" +
+          nsInfo.getLayoutVersion() + ") does not match " +
+          "this node's layout version (" + HdfsConstants.LAYOUT_VERSION + ")");
+      return ERR_CODE_INVALID_VERSION;
+    }
+
+    // Ensure the other NN is active - we can't force it to roll edit logs
+    // below if it's not active.
+    if (!isOtherNNActive()) {
+      String err = "NameNode " + nsId + "." + nnId + " at " + otherIpcAddr +
+          " is not currently in ACTIVE state.";
+      if (!interactive) {
+        LOG.fatal(err + " Please transition it to " +
+            "active before attempting to bootstrap a standby node.");
+        return ERR_CODE_OTHER_NN_NOT_ACTIVE;
+      }
+      
+      System.err.println(err);
+      if (ToolRunner.confirmPrompt(
+            "Do you want to automatically transition it to active now?")) {
+        transitionOtherNNActive();
+      } else {
+        LOG.fatal("User aborted. Exiting without bootstrapping standby.");
+        return ERR_CODE_OTHER_NN_NOT_ACTIVE;
+      }
+    }
+    
+
+    
-      return 1;
+      return ERR_CODE_ALREADY_FORMATTED;
-      return 1;
+      return ERR_CODE_LOGS_UNAVAILABLE;
+  
+  private void transitionOtherNNActive()
+      throws AccessControlException, ServiceFailedException, IOException {
+    LOG.info("Transitioning the running namenode to active...");
+    createHAProtocolProxy().transitionToActive();    
+    LOG.info("Successful");
+  }
+
-  private void checkLayoutVersion(NamespaceInfo nsInfo) throws IOException {
-    if (nsInfo.getLayoutVersion() != HdfsConstants.LAYOUT_VERSION) {
-      throw new IOException("Layout version on remote node (" +
-          nsInfo.getLayoutVersion() + ") does not match " +
-          "this node's layout version (" + HdfsConstants.LAYOUT_VERSION + ")");
-    }
+  private boolean checkLayoutVersion(NamespaceInfo nsInfo) throws IOException {
+    return (nsInfo.getLayoutVersion() == HdfsConstants.LAYOUT_VERSION);
+  }
+  
+  private boolean isOtherNNActive()
+      throws AccessControlException, IOException {
+    HAServiceStatus status = createHAProtocolProxy().getServiceStatus();
+    return status.getState() == HAServiceState.ACTIVE;

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 MOV43 INS42 INS43 INS8 INS83 INS43 INS42 MOV43 INS8 INS83 INS39 INS42 INS43 INS43 INS43 INS8 UPD39 INS8 INS83 INS39 INS42 INS43 INS43 INS8 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS41 INS42 INS41 INS60 INS25 INS25 INS42 INS42 INS42 INS21 INS21 INS21 INS41 INS42 INS42 INS60 INS41 INS32 INS32 MOV43 INS59 INS38 INS8 INS38 INS8 INS32 INS32 INS32 INS36 INS43 INS59 INS27 MOV32 INS42 INS14 INS42 INS42 INS34 INS42 INS32 MOV32 INS21 INS41 INS32 MOV60 INS25 INS21 INS25 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS45 UPD27 MOV27 INS42 INS42 INS32 INS32 INS40 INS43 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS38 INS8 INS32 INS32 INS8 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 MOV27 UPD42 MOV42 UPD42 INS27 INS42 INS21 INS41 INS40 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS45 INS21 INS21 INS41 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS42 INS45 INS45 DEL42 DEL32 DEL59 DEL60 DEL21 DEL34 DEL43 DEL74 DEL34 DEL34 DEL14 DEL53 DEL8 DEL25 DEL8
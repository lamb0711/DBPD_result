Merge remote-tracking branch 'origin/trunk' into MR-2841

Conflicts:
	hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java

+import org.apache.hadoop.yarn.api.records.ResourceOption;
-import org.apache.hadoop.yarn.server.resourcemanager.RMAuditLogger;
-import org.apache.hadoop.yarn.server.resourcemanager.RMAuditLogger.AuditConstants;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.event.NodeResourceUpdateSchedulerEvent;
-    AbstractYarnScheduler<FSSchedulerApp, FSSchedulerNode> {
+    AbstractYarnScheduler<FSAppAttempt, FSSchedulerNode> {
-  private Thread updateThread;
-  private Thread schedulingThread;
+  @VisibleForTesting
+  Thread updateThread;
+
+  @VisibleForTesting
+  Thread schedulingThread;
+  FSOpDurations fsOpDurations;
-   * A runnable which calls {@link FairScheduler#update()} every
+   * Thread which calls {@link FairScheduler#update()} every
-  private class UpdateThread implements Runnable {
+  private class UpdateThread extends Thread {
+
+    @Override
-      while (true) {
+      while (!Thread.currentThread().isInterrupted()) {
+          long start = getClock().getTime();
+          long duration = getClock().getTime() - start;
+          fsOpDurations.addUpdateThreadRunDuration(duration);
+        } catch (InterruptedException ie) {
+          LOG.warn("Update thread interrupted. Exiting.");
+          return;
+   * Thread which attempts scheduling resources continuously,
+   * asynchronous to the node heartbeats.
+   */
+  private class ContinuousSchedulingThread extends Thread {
+
+    @Override
+    public void run() {
+      while (!Thread.currentThread().isInterrupted()) {
+        try {
+          continuousSchedulingAttempt();
+          Thread.sleep(getContinuousSchedulingSleepMs());
+        } catch (InterruptedException e) {
+          LOG.warn("Continuous scheduling thread interrupted. Exiting.", e);
+          return;
+        }
+      }
+    }
+  }
+
+  /**
+    long start = getClock().getTime();
+
+    long duration = getClock().getTime() - start;
+    fsOpDurations.addUpdateCallDuration(duration);
-    long now = clock.getTime();
+    long now = getClock().getTime();
-    Resource desiredFairShare = Resources.min(RESOURCE_CALCULATOR, clusterResource,
+    Resource desiredFairShare = Resources.min(RESOURCE_CALCULATOR,
+        clusterResource,
-    long curTime = clock.getTime();
+    long curTime = getClock().getTime();
+    long start = getClock().getTime();
-        for (AppSchedulable app : queue.getRunnableAppSchedulables()) {
-          app.getApp().resetPreemptedResources();
+        for (FSAppAttempt app : queue.getRunnableAppSchedulables()) {
+          app.resetPreemptedResources();
-        for (AppSchedulable app : queue.getRunnableAppSchedulables()) {
-          app.getApp().clearPreemptedResources();
+        for (FSAppAttempt app : queue.getRunnableAppSchedulables()) {
+          app.clearPreemptedResources();
+
+    long duration = getClock().getTime() - start;
+    fsOpDurations.addPreemptCallDuration(duration);
-    FSSchedulerApp app = getSchedulerApp(appAttemptId);
+    FSAppAttempt app = getSchedulerApp(appAttemptId);
-      if (time + waitTimeBeforeKill < clock.getTime()) {
+      if (time + waitTimeBeforeKill < getClock().getTime()) {
-            (clock.getTime() - time) + "ms)");
+            (getClock().getTime() - time) + "ms)");
-      // track the request in the FSSchedulerApp itself
-      app.addPreemption(container, clock.getTime());
+      // track the request in the FSAppAttempt itself
+      app.addPreemption(container, getClock().getTime());
-    String queue = sched.getName();
-    long minShareTimeout = allocConf.getMinSharePreemptionTimeout(queue);
-    long fairShareTimeout = allocConf.getFairSharePreemptionTimeout();
+    long minShareTimeout = sched.getMinSharePreemptionTimeout();
+    long fairShareTimeout = sched.getFairSharePreemptionTimeout();
-  public synchronized ResourceWeights getAppWeight(AppSchedulable app) {
+  public synchronized ResourceWeights getAppWeight(FSAppAttempt app) {
-    SchedulerApplication<FSSchedulerApp> application =
-        new SchedulerApplication<FSSchedulerApp>(queue, user);
+    SchedulerApplication<FSAppAttempt> application =
+        new SchedulerApplication<FSAppAttempt>(queue, user);
-    SchedulerApplication<FSSchedulerApp> application =
+    SchedulerApplication<FSAppAttempt> application =
-    FSSchedulerApp attempt =
-        new FSSchedulerApp(applicationAttemptId, user,
+    FSAppAttempt attempt =
+        new FSAppAttempt(this, applicationAttemptId, user,
-        .getCurrentAppAttempt());
+          .getCurrentAppAttempt());
-    SchedulerApplication<FSSchedulerApp> application =
+    SchedulerApplication<FSAppAttempt> application =
-    SchedulerApplication<FSSchedulerApp> application =
+    SchedulerApplication<FSAppAttempt> application =
-    FSSchedulerApp attempt = getSchedulerApp(applicationAttemptId);
+    FSAppAttempt attempt = getSchedulerApp(applicationAttemptId);
-  private synchronized void completedContainer(RMContainer rmContainer,
+  @Override
+  protected synchronized void completedContainer(RMContainer rmContainer,
-    FSSchedulerApp application =
+    FSAppAttempt application =
-      application.unreserve(node, rmContainer.getReservedPriority());
-      node.unreserveResource(application);
+      application.unreserve(rmContainer.getReservedPriority(), node);
+    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);
+    queueMgr.getRootQueue().recomputeSteadyShares();
+    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);
+    queueMgr.getRootQueue().recomputeSteadyShares();
-    FSSchedulerApp application = getSchedulerApp(appAttemptId);
+    FSAppAttempt application = getSchedulerApp(appAttemptId);
-    for (ContainerId releasedContainerId : release) {
-      RMContainer rmContainer = getRMContainer(releasedContainerId);
-      if (rmContainer == null) {
-        RMAuditLogger.logFailure(application.getUser(),
-            AuditConstants.RELEASE_CONTAINER,
-            "Unauthorized access or invalid container", "FairScheduler",
-            "Trying to release container not owned by app or with invalid id",
-            application.getApplicationId(), releasedContainerId);
-      }
-      completedContainer(rmContainer,
-          SchedulerUtils.createAbnormalContainerStatus(
-              releasedContainerId,
-              SchedulerUtils.RELEASED_CONTAINER),
-          RMContainerEventType.RELEASED);
-    }
+    releaseContainers(release, application);
-
+  
+    long start = getClock().getTime();
-
-    // Update resource if any change
-    SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);
+
+    long duration = getClock().getTime() - start;
+    fsOpDurations.addNodeUpdateDuration(duration);
-  void continuousSchedulingAttempt() {
+  void continuousSchedulingAttempt() throws InterruptedException {
+    long start = getClock().getTime();
+
+    long duration = getClock().getTime() - start;
+    fsOpDurations.addContinuousSchedulingRunDuration(duration);
-    AppSchedulable reservedAppSchedulable = node.getReservedAppSchedulable();
+    FSAppAttempt reservedAppSchedulable = node.getReservedAppSchedulable();
-            + reservedAppSchedulable.getApp().getApplicationAttemptId()
+            + reservedAppSchedulable.getApplicationAttemptId()
-              + reservedAppSchedulable.getApp().getApplicationAttemptId()
+              + reservedAppSchedulable.getApplicationAttemptId()
-  public FSSchedulerApp getSchedulerApp(ApplicationAttemptId appAttemptId) {
-    return (FSSchedulerApp) super.getApplicationAttempt(appAttemptId);
+  public FSAppAttempt getSchedulerApp(ApplicationAttemptId appAttemptId) {
+    return super.getApplicationAttempt(appAttemptId);
+      recoverContainersOnNode(nodeAddedEvent.getContainerReports(),
+          nodeAddedEvent.getAddedRMNode());
+    case NODE_RESOURCE_UPDATE:
+      if (!(event instanceof NodeResourceUpdateSchedulerEvent)) {
+        throw new RuntimeException("Unexpected event type: " + event);
+      }
+      NodeResourceUpdateSchedulerEvent nodeResourceUpdatedEvent = 
+          (NodeResourceUpdateSchedulerEvent)event;
+      updateNodeResource(nodeResourceUpdatedEvent.getRMNode(),
+            nodeResourceUpdatedEvent.getResourceOption());
+      break;
+    fsOpDurations = FSOpDurations.getInstance(true);
+
-    this.applications =
-        new ConcurrentHashMap<ApplicationId,SchedulerApplication<FSSchedulerApp>>();
+    this.applications = new ConcurrentHashMap<
+        ApplicationId, SchedulerApplication<FSAppAttempt>>();
-    updateThread = new Thread(new UpdateThread());
+    updateThread = new UpdateThread();
-      schedulingThread = new Thread(
-          new Runnable() {
-            @Override
-            public void run() {
-              while (!Thread.currentThread().isInterrupted()) {
-                try {
-                  continuousSchedulingAttempt();
-                  Thread.sleep(getContinuousSchedulingSleepMs());
-                } catch (InterruptedException e) {
-                  LOG.error("Continuous scheduling thread interrupted. Exiting. ",
-                      e);
-                  return;
-                }
-              }
-            }
-          }
-      );
-      schedulingThread.setName("ContinuousScheduling");
+      schedulingThread = new ContinuousSchedulingThread();
+      schedulingThread.setName("FairSchedulerContinuousScheduling");
-    UserGroupInformation user = null;
+    UserGroupInformation user;
-    SchedulerApplication<FSSchedulerApp> app = applications.get(appId);
+    SchedulerApplication<FSAppAttempt> app = applications.get(appId);
-    FSSchedulerApp attempt = (FSSchedulerApp) app.getCurrentAppAttempt();
+    FSAppAttempt attempt = (FSAppAttempt) app.getCurrentAppAttempt();
-      if (oldQueue.getRunnableAppSchedulables().contains(
-          attempt.getAppSchedulable())) {
+      if (oldQueue.getRunnableAppSchedulables().contains(attempt)) {
-  private void verifyMoveDoesNotViolateConstraints(FSSchedulerApp app,
+  private void verifyMoveDoesNotViolateConstraints(FSAppAttempt app,
-  private void executeMove(SchedulerApplication<FSSchedulerApp> app,
-      FSSchedulerApp attempt, FSLeafQueue oldQueue, FSLeafQueue newQueue) {
+  private void executeMove(SchedulerApplication<FSAppAttempt> app,
+      FSAppAttempt attempt, FSLeafQueue oldQueue, FSLeafQueue newQueue) {
+  
+  /**
+   * Process resource update on a node and update Queue.
+   */
+  @Override
+  public synchronized void updateNodeResource(RMNode nm, 
+      ResourceOption resourceOption) {
+    super.updateNodeResource(nm, resourceOption);
+    updateRootQueueMetrics();
+    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);
+    queueMgr.getRootQueue().recomputeSteadyShares();
+  }

MOV26 MOV26 UPD40 UPD40 UPD74 INS23 INS55 INS31 UPD43 INS78 INS78 INS43 INS59 UPD43 INS29 INS83 INS42 MOV43 MOV31 INS78 UPD83 INS43 UPD43 INS29 INS78 INS83 INS83 INS39 INS42 INS44 INS44 INS8 UPD42 INS42 INS42 INS42 INS42 UPD42 INS78 INS65 INS60 INS60 INS21 INS60 INS60 INS21 UPD43 INS42 INS21 INS21 INS21 INS21 MOV21 INS60 INS60 INS21 INS42 INS60 INS60 INS21 UPD42 MOV10 MOV10 MOV10 INS21 UPD43 UPD74 MOV74 UPD43 INS65 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS21 UPD66 INS42 INS66 INS66 INS39 INS59 INS39 INS59 INS32 INS39 INS59 INS8 INS39 INS59 INS32 UPD43 UPD42 INS74 UPD74 UPD43 UPD74 UPD74 MOV74 UPD43 UPD43 INS32 INS32 INS32 INS32 UPD43 INS39 INS59 INS39 INS59 INS32 INS39 INS59 INS39 INS59 INS32 UPD43 MOV48 INS21 INS49 INS25 INS60 INS21 INS10 INS7 INS74 UPD43 UPD42 UPD43 UPD42 INS66 INS42 INS42 INS48 INS32 INS32 INS32 INS38 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS70 MOV70 INS42 INS27 INS42 INS42 INS42 UPD42 INS43 INS43 UPD43 UPD42 UPD43 UPD43 UPD42 UPD42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS42 UPD42 INS32 INS42 INS38 INS8 INS43 INS59 INS32 INS42 INS32 MOV14 MOV43 INS43 UPD42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS32 INS32 INS32 INS42 MOV44 MOV32 INS8 INS32 INS42 UPD42 UPD42 INS42 INS42 UPD74 UPD42 UPD43 INS52 MOV42 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS32 INS36 INS53 INS42 INS42 INS11 INS42 INS32 INS32 INS42 INS42 INS9 UPD74 INS42 UPD43 INS42 INS42 INS42 INS42 INS32 INS42 INS12 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS70 INS32 INS42 UPD43 UPD42 UPD42 MOV42 INS32 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS62 INS14 INS43 INS42 INS42 INS42 INS42 INS42 UPD74 INS14 UPD45 UPD42 MOV42 INS42 INS42 INS60 INS60 INS21 INS44 INS8 INS42 INS44 MOV32 INS8 INS42 INS32 INS32 UPD42 INS42 INS42 INS42 INS43 INS43 INS27 INS42 UPD43 UPD43 MOV43 INS39 INS59 INS39 INS59 INS32 INS43 INS42 INS21 INS41 INS43 INS42 INS21 UPD43 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS45 INS42 UPD42 UPD42 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS32 UPD42 INS32 INS42 INS32 INS42 INS42 INS42 INS45 UPD42 UPD45 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS32 MOV42 UPD42 MOV42 DEL83 DEL83 DEL9 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL40 DEL45 DEL45 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL40 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL11 DEL14 DEL1 DEL14 DEL14 DEL33 DEL42 DEL32 DEL42 DEL43 DEL74
YARN-4702. FairScheduler: Allow setting maxResources for ad hoc queues. (Daniel Templeton via kasha)

+import java.util.Iterator;
+import java.util.Set;
+import org.apache.hadoop.yarn.api.records.Resource;
-   * Creates a leaf or parent queue based on what is specified in 'queueType' 
-   * and places it in the tree. Creates any parents that don't already exist.
+   * Create a leaf or parent queue based on what is specified in
+   * {@code queueType} and place it in the tree. Create any parents that don't
+   * already exist.
-   * @return
-   *    the created queue, if successful. null if not allowed (one of the parent
-   *    queues in the queue name is already a leaf queue)
+   * @return the created queue, if successful or null if not allowed (one of the
+   * parent queues in the queue name is already a leaf queue)
-  private FSQueue createQueue(String name, FSQueueType queueType) {
-    List<String> newQueueNames = new ArrayList<String>();
+  @VisibleForTesting
+  FSQueue createQueue(String name, FSQueueType queueType) {
+    List<String> newQueueNames = new ArrayList<>();
+    FSParentQueue parent = buildNewQueueList(name, newQueueNames);
+    FSQueue queue = null;
+
+    if (parent != null) {
+      // Now that we know everything worked out, make all the queues
+      // and add them to the map.
+      queue = createNewQueues(queueType, parent, newQueueNames);
+    }
+
+    return queue;
+  }
+
+  /**
+   * Compile a list of all parent queues of the given queue name that do not
+   * already exist. The queue names will be added to the {@code newQueueNames}
+   * list. The list will be in order of increasing queue depth. The first
+   * element of the list will be the parent closest to the root. The last
+   * element added will be the queue to be created. This method returns the
+   * deepest parent that does exist.
+   *
+   * @param name the fully qualified name of the queue to create
+   * @param newQueueNames the list to which to add non-existent queues
+   * @return the deepest existing parent queue
+   */
+  private FSParentQueue buildNewQueueList(String name,
+      List<String> newQueueNames) {
-      FSQueue queue;
-      String curName = null;
-      curName = name.substring(0, sepIndex);
-      queue = queues.get(curName);
+
+      String curName = name.substring(0, sepIndex);
+      FSQueue queue = queues.get(curName);
-        newQueueNames.add(curName);
+        newQueueNames.add(0, curName);
-          break;
-        } else {
-          return null;
-      }
-    }
-    
-    // At this point, parent refers to the deepest existing parent of the
-    // queue to create.
-    // Now that we know everything worked out, make all the queues
-    // and add them to the map.
-    AllocationConfiguration queueConf = scheduler.getAllocationConfiguration();
-    FSLeafQueue leafQueue = null;
-    for (int i = newQueueNames.size()-1; i >= 0; i--) {
-      String queueName = newQueueNames.get(i);
-      if (i == 0 && queueType != FSQueueType.PARENT) {
-        leafQueue = new FSLeafQueue(name, scheduler, parent);
-        try {
-          leafQueue.setPolicy(queueConf.getDefaultSchedulingPolicy());
-        } catch (AllocationConfigurationException ex) {
-          LOG.warn("Failed to set default scheduling policy "
-              + queueConf.getDefaultSchedulingPolicy() + " on new leaf queue.", ex);
-        }
-        parent.addChildQueue(leafQueue);
-        queues.put(leafQueue.getName(), leafQueue);
-        leafQueues.add(leafQueue);
-        leafQueue.updatePreemptionVariables();
-        return leafQueue;
-      } else {
-        FSParentQueue newParent = new FSParentQueue(queueName, scheduler, parent);
-        try {
-          newParent.setPolicy(queueConf.getDefaultSchedulingPolicy());
-        } catch (AllocationConfigurationException ex) {
-          LOG.warn("Failed to set default scheduling policy "
-              + queueConf.getDefaultSchedulingPolicy() + " on new parent queue.", ex);
-        }
-        parent.addChildQueue(newParent);
-        queues.put(newParent.getName(), newParent);
-        newParent.updatePreemptionVariables();
-        parent = newParent;
+
+        // If the queue isn't a parent queue, parent will still be null when
+        // we break
+
+        break;
+   * Create all queues in the {@code newQueueNames} list. The list must be in
+   * order of increasing depth. All but the last element in the list will be
+   * created as parent queues. The last element will be created as the type
+   * specified by the {@code queueType} parameter. The first queue will be
+   * created as a child of the {@code topParent} queue. All subsequent queues
+   * will be created as a child of the previously created queue.
+   *
+   * @param queueType the type of the last queue to create
+   * @param topParent the parent of the first queue to create
+   * @param newQueueNames the list of queues to create
+   * @return the last queue created
+   */
+  private FSQueue createNewQueues(FSQueueType queueType,
+      FSParentQueue topParent, List<String> newQueueNames) {
+    AllocationConfiguration queueConf = scheduler.getAllocationConfiguration();
+    Iterator<String> i = newQueueNames.iterator();
+    FSParentQueue parent = topParent;
+    FSQueue queue = null;
+
+    while (i.hasNext()) {
+      FSParentQueue newParent = null;
+      String queueName = i.next();
+
+      // Only create a leaf queue at the very end
+      if (!i.hasNext() && (queueType != FSQueueType.PARENT)) {
+        FSLeafQueue leafQueue = new FSLeafQueue(queueName, scheduler, parent);
+
+        try {
+          leafQueue.setPolicy(queueConf.getDefaultSchedulingPolicy());
+        } catch (AllocationConfigurationException ex) {
+          LOG.warn("Failed to set default scheduling policy "
+              + queueConf.getDefaultSchedulingPolicy()
+              + " on new leaf queue.", ex);
+        }
+
+        leafQueues.add(leafQueue);
+        queue = leafQueue;
+      } else {
+        newParent = new FSParentQueue(queueName, scheduler, parent);
+
+        try {
+          newParent.setPolicy(queueConf.getDefaultSchedulingPolicy());
+        } catch (AllocationConfigurationException ex) {
+          LOG.warn("Failed to set default scheduling policy "
+              + queueConf.getDefaultSchedulingPolicy()
+              + " on new parent queue.", ex);
+        }
+
+        queue = newParent;
+      }
+
+      parent.addChildQueue(queue);
+      setChildResourceLimits(parent, queue, queueConf);
+      queues.put(queue.getName(), queue);
+      queue.updatePreemptionVariables();
+
+      // If we just created a leaf node, the newParent is null, but that's OK
+      // because we only create a leaf node in the very last iteration.
+      parent = newParent;
+    }
+
+    return queue;
+  }
+
+  /**
+   * For the given child queue, set the max resources based on the
+   * parent queue's default child resource settings. This method assumes that
+   * the child queue is ad hoc and hence does not do any safety checks around
+   * overwriting existing max resource settings.
+   *
+   * @param parent the parent queue
+   * @param child the child queue
+   * @param queueConf the {@link AllocationConfiguration}
+   */
+  void setChildResourceLimits(FSParentQueue parent, FSQueue child,
+      AllocationConfiguration queueConf) {
+    Map<FSQueueType, Set<String>> configuredQueues =
+        queueConf.getConfiguredQueues();
+
+    // Ad hoc queues do not exist in the configured queues map
+    if (!configuredQueues.get(FSQueueType.LEAF).contains(child.getName()) &&
+        !configuredQueues.get(FSQueueType.PARENT).contains(child.getName())) {
+      // For ad hoc queues, set their max reource allocations based on
+      // their parents' default child settings.
+      Resource maxChild = queueConf.getMaxChildResources(parent.getName());
+
+      if (maxChild != null) {
+        queueConf.setMaxResources(child.getName(), maxChild);
+      }
+    }
+  }
+
+  /**

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS31 INS29 INS78 INS43 INS42 INS44 INS44 INS8 INS43 INS42 INS44 INS29 INS83 MOV43 INS42 MOV44 INS44 INS44 INS8 INS29 INS39 INS42 INS44 INS44 INS44 INS8 INS65 INS65 INS42 INS42 INS43 INS42 INS43 INS42 MOV60 INS60 INS60 INS25 INS41 INS65 INS65 INS42 INS74 INS42 INS65 INS65 INS65 INS65 INS65 MOV43 INS42 INS74 INS42 MOV60 INS60 INS60 INS60 INS61 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS42 INS43 INS59 MOV43 INS59 INS27 INS8 INS42 UPD66 INS66 INS65 INS66 INS66 INS66 UPD66 INS42 INS66 INS42 INS66 UPD66 INS43 INS43 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS43 INS74 INS59 INS43 INS59 INS43 INS59 INS32 MOV8 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS65 INS42 INS42 INS42 INS74 INS59 INS27 INS8 INS66 INS42 INS42 INS32 INS42 INS33 INS42 INS33 INS21 INS66 INS42 INS42 INS60 INS60 INS66 INS66 INS66 INS42 INS42 INS43 MOV43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS60 INS60 INS21 INS21 INS21 INS21 MOV21 INS42 INS43 INS43 INS74 INS42 INS32 INS38 INS38 INS60 INS25 UPD74 INS42 INS42 INS42 INS7 INS43 MOV59 INS43 INS59 INS42 INS42 INS42 UPD43 MOV43 INS59 MOV43 INS59 MOV21 MOV54 INS32 INS32 INS32 INS32 INS42 INS42 INS43 INS43 INS42 INS42 INS32 INS32 INS43 INS59 INS27 INS8 INS42 INS32 INS42 MOV32 INS42 INS42 MOV32 INS10 UPD42 INS42 INS33 MOV42 INS32 INS38 INS36 INS60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV27 MOV43 INS59 INS7 INS7 INS7 INS42 UPD42 MOV42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS34 INS42 INS42 INS42 INS14 INS42 INS42 INS42 MOV14 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV43 UPD42 MOV42 MOV42 MOV42 INS42 INS42 DEL66 DEL42 DEL33 DEL42 DEL59 DEL60 DEL60 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL10 DEL33 DEL41 DEL8 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL24 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21
HDFS-13051. Fix dead lock during async editlog rolling if edit queue is full. Contributed by Daryn Sharp.

-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+  // draining permits is intended to provide a high priority reservation.
+  // however, release of outstanding permits must be postponed until
+  // drained permits are restored to avoid starvation.  logic has some races
+  // but is good enough to serve its purpose.
+  private Semaphore overflowMutex = new Semaphore(8){
+    private AtomicBoolean draining = new AtomicBoolean();
+    private AtomicInteger pendingReleases = new AtomicInteger();
+    @Override
+    public int drainPermits() {
+      draining.set(true);
+      return super.drainPermits();
+    }
+    // while draining, count the releases until release(int)
+    private void tryRelease(int permits) {
+      pendingReleases.getAndAdd(permits);
+      if (!draining.get()) {
+        super.release(pendingReleases.getAndSet(0));
+      }
+    }
+    @Override
+    public void release() {
+      tryRelease(1);
+    }
+    @Override
+    public void release(int permits) {
+      draining.set(false);
+      tryRelease(permits);
+    }
+  };
+
-      if (!editPendingQ.offer(edit, 1, TimeUnit.SECONDS)) {
+      // not checking for overflow yet to avoid penalizing performance of
+      // the common case.  if there is persistent overflow, a mutex will be
+      // use to throttle contention on the queue.
+      if (!editPendingQ.offer(edit)) {
-        editPendingQ.put(edit);
+        if (Thread.holdsLock(this)) {
+          // if queue is full, synchronized caller must immediately relinquish
+          // the monitor before re-offering to avoid deadlock with sync thread
+          // which needs the monitor to write transactions.
+          int permits = overflowMutex.drainPermits();
+          try {
+            do {
+              this.wait(1000); // will be notified by next logSync.
+            } while (!editPendingQ.offer(edit));
+          } finally {
+            overflowMutex.release(permits);
+          }
+        } else {
+          // mutex will throttle contention during persistent overflow.
+          overflowMutex.acquire();
+          try {
+            editPendingQ.put(edit);
+          } finally {
+            overflowMutex.release();
+          }
+        }

INS26 INS26 UPD40 INS40 INS40 INS23 INS83 INS43 INS59 INS42 INS42 INS14 INS43 INS34 INS1 INS8 INS42 INS23 INS23 INS31 INS31 INS31 INS31 INS25 INS83 INS43 INS59 INS83 INS43 INS59 INS78 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS38 INS8 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS21 INS41 INS39 INS42 INS21 INS25 INS42 INS21 INS42 INS39 INS42 INS21 INS21 INS32 MOV21 MOV25 INS43 INS43 INS32 INS48 INS32 INS38 INS8 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS32 INS21 INS42 INS34 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS52 INS60 INS54 INS21 INS54 INS42 INS42 INS48 INS39 INS59 INS8 INS8 INS32 MOV8 INS8 INS42 INS32 INS42 INS32 INS19 INS21 INS42 INS42 INS21 INS42 INS42 INS34 INS42 INS42 INS8 INS38 INS32 INS32 INS21 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS34 DEL34 DEL40 DEL38 DEL8
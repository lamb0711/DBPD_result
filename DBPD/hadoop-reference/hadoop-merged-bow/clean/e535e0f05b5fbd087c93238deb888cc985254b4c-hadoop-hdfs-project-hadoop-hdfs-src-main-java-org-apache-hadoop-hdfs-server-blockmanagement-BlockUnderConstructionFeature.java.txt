HDFS-8801. Convert BlockInfoUnderConstruction as a feature. Contributed by Jing Zhao.

-import java.io.IOException;
-public class BlockInfoContiguousUnderConstruction extends BlockInfoContiguous {
+public class BlockUnderConstructionFeature {
-   * The GS, the length and the state of the replica is as reported by 
+   * The GS, the length and the state of the replica is as reported by
-  static class ReplicaUnderConstruction extends Block {
+  static class ReplicaUnderConstruction {
+    private long generationStamp;
-    ReplicaUnderConstruction(Block block,
-                             DatanodeStorageInfo target,
-                             ReplicaState state) {
-      super(block);
+    ReplicaUnderConstruction(long generationStamp, DatanodeStorageInfo target,
+        ReplicaState state) {
+      this.generationStamp = generationStamp;
+    long getGenerationStamp() {
+      return this.generationStamp;
+    }
+
+    void setGenerationStamp(long generationStamp) {
+      this.generationStamp = generationStamp;
+    }
+
-    private DatanodeStorageInfo getExpectedStorageLocation() {
+    DatanodeStorageInfo getExpectedStorageLocation() {
-    @Override // Block
-    public int hashCode() {
-      return super.hashCode();
-    }
-
-    @Override // Block
-    public boolean equals(Object obj) {
-      // Sufficient to rely on super's implementation
-      return (this == obj) || super.equals(obj);
-    }
-
-      final StringBuilder b = new StringBuilder(50);
-      appendStringTo(b);
+      final StringBuilder b = new StringBuilder(50)
+          .append("ReplicaUC[")
+          .append(expectedLocation)
+          .append("|")
+          .append(state)
+          .append("]");
-    
-    @Override
-    public void appendStringTo(StringBuilder sb) {
-      sb.append("ReplicaUC[")
-        .append(expectedLocation)
-        .append("|")
-        .append(state)
-        .append("]");
-    }
-  }
-
-  /**
-   * Create block and set its state to
-   * {@link BlockUCState#UNDER_CONSTRUCTION}.
-   */
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication) {
-    this(blk, replication, BlockUCState.UNDER_CONSTRUCTION, null);
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication,
-      BlockUCState state, DatanodeStorageInfo[] targets) {
-    super(blk, replication);
+  public BlockUnderConstructionFeature(Block block, BlockUCState state,
+      DatanodeStorageInfo[] targets) {
-    setExpectedLocations(targets);
-  }
-
-  /**
-   * Convert an under construction block to a complete block.
-   * 
-   * @return BlockInfo - a complete block.
-   * @throws IOException if the state of the block 
-   * (the generation stamp and the length) has not been committed by 
-   * the client or it does not have at least a minimal number of replicas 
-   * reported from data-nodes. 
-   */
-  BlockInfo convertToCompleteBlock() throws IOException {
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "Trying to convert a COMPLETE block";
-    return new BlockInfoContiguous(this);
+    setExpectedLocations(block.getGenerationStamp(), targets);
-  public void setExpectedLocations(DatanodeStorageInfo[] targets) {
+  public void setExpectedLocations(long generationStamp,
+      DatanodeStorageInfo[] targets) {
-    this.replicas = new ArrayList<ReplicaUnderConstruction>(numLocations);
-    for(int i = 0; i < numLocations; i++)
-      replicas.add(
-        new ReplicaUnderConstruction(this, targets[i], ReplicaState.RBW));
+    this.replicas = new ArrayList<>(numLocations);
+    for(int i = 0; i < numLocations; i++) {
+      replicas.add(new ReplicaUnderConstruction(generationStamp, targets[i],
+          ReplicaState.RBW));
+    }
-    for(int i = 0; i < numLocations; i++)
+    for (int i = 0; i < numLocations; i++) {
+    }
-  @Override // BlockInfo
-   * Process the recorded replicas. When about to commit or finish the
-   * pipeline recovery sort out bad replicas.
-   * @param genStamp  The final generation stamp for the block.
+   * Set {@link #blockUCState} to {@link BlockUCState#COMMITTED}.
-  public void setGenerationStampAndVerifyReplicas(long genStamp) {
-    // Set the generation stamp for the block.
-    setGenerationStamp(genStamp);
-    if (replicas == null)
-      return;
-
-    // Remove the replicas with wrong gen stamp.
-    // The replica list is unchanged.
-    for (ReplicaUnderConstruction r : replicas) {
-      if (genStamp != r.getGenerationStamp()) {
-        r.getExpectedStorageLocation().removeBlock(this);
-        NameNode.blockStateChangeLog.debug("BLOCK* Removing stale replica "
-            + "from location: {}", r.getExpectedStorageLocation());
-      }
-    }
+  void commit() {
+    blockUCState = BlockUCState.COMMITTED;
-  /**
-   * Commit block's length and generation stamp as reported by the client.
-   * Set block state to {@link BlockUCState#COMMITTED}.
-   * @param block - contains client reported block length and generation 
-   * @throws IOException if block ids are inconsistent.
-   */
-  void commitBlock(Block block) throws IOException {
-    if(getBlockId() != block.getBlockId())
-      throw new IOException("Trying to commit inconsistent block: id = "
-          + block.getBlockId() + ", expected id = " + getBlockId());
-    blockUCState = BlockUCState.COMMITTED;
-    this.set(getBlockId(), block.getNumBytes(), block.getGenerationStamp());
-    // Sort out invalid replicas.
-    setGenerationStampAndVerifyReplicas(block.getGenerationStamp());
+  List<ReplicaUnderConstruction> getStaleReplicas(long genStamp) {
+    List<ReplicaUnderConstruction> staleReplicas = new ArrayList<>();
+    if (replicas != null) {
+      // Remove replicas with wrong gen stamp. The replica list is unchanged.
+      for (ReplicaUnderConstruction r : replicas) {
+        if (genStamp != r.getGenerationStamp()) {
+          staleReplicas.add(r);
+        }
+      }
+    }
+    return staleReplicas;
-  public void initializeBlockRecovery(long recoveryId) {
+  public void initializeBlockRecovery(BlockInfo block, long recoveryId) {
-    for (int i = 0; i < replicas.size(); i++) {
+    for (ReplicaUnderConstruction replica : replicas) {
-      if (replicas.get(i).isAlive()) {
-        allLiveReplicasTriedAsPrimary =
-            (allLiveReplicasTriedAsPrimary && replicas.get(i).getChosenAsPrimary());
+      if (replica.isAlive()) {
+        allLiveReplicasTriedAsPrimary = allLiveReplicasTriedAsPrimary
+            && replica.getChosenAsPrimary();
-      for (int i = 0; i < replicas.size(); i++) {
-        replicas.get(i).setChosenAsPrimary(false);
+      for (ReplicaUnderConstruction replica : replicas) {
+        replica.setChosenAsPrimary(false);
-      primary.getExpectedStorageLocation().getDatanodeDescriptor().addBlockToBeRecovered(this);
+      primary.getExpectedStorageLocation().getDatanodeDescriptor()
+          .addBlockToBeRecovered(block);
-  void addReplicaIfNotPresent(DatanodeStorageInfo storage,
-                     Block block,
-                     ReplicaState rState) {
+  void addReplicaIfNotPresent(DatanodeStorageInfo storage, Block block,
+      ReplicaState rState) {
-      if(expectedLocation == storage) {
+      if (expectedLocation == storage) {
-
-    replicas.add(new ReplicaUnderConstruction(block, storage, rState));
-  }
-
-  @Override // BlockInfo
-  // BlockInfoUnderConstruction participates in maps the same way as BlockInfo
-  public int hashCode() {
-    return super.hashCode();
-  }
-
-  @Override // BlockInfo
-  public boolean equals(Object obj) {
-    // Sufficient to rely on super's implementation
-    return (this == obj) || super.equals(obj);
+    replicas.add(new ReplicaUnderConstruction(block.getGenerationStamp(), storage, rState));
-    appendStringTo(b);
+    appendUCParts(b);
-  @Override
-  public void appendStringTo(StringBuilder sb) {
-    super.appendStringTo(sb);
-    appendUCParts(sb);
-  }
-
-      .append(", truncateBlock=" + truncateBlock)
+      .append(", truncateBlock=").append(truncateBlock)
-        iter.next().appendStringTo(sb);
+        sb.append(iter.next());
-          iter.next().appendStringTo(sb);
+          sb.append(iter.next());

MOV31 UPD42 MOV31 MOV31 INS31 INS23 INS31 UPD42 INS44 MOV29 INS39 INS42 INS74 INS42 MOV44 INS8 INS44 MOV8 INS83 INS39 INS59 UPD39 UPD42 UPD39 UPD42 MOV78 MOV83 MOV43 MOV42 INS8 MOV42 INS39 INS42 MOV21 INS43 MOV43 INS60 INS25 MOV41 MOV43 INS42 INS70 MOV21 MOV21 UPD66 INS42 INS39 INS42 INS21 INS39 INS42 INS21 INS60 MOV41 MOV42 INS8 INS8 UPD66 INS65 UPD66 UPD42 MOV42 INS74 INS59 UPD27 MOV27 INS8 INS42 INS44 INS42 INS8 INS32 MOV27 INS7 INS22 INS7 MOV83 MOV43 INS59 MOV32 MOV21 MOV21 INS67 INS43 INS43 INS42 INS14 MOV70 INS43 INS42 MOV25 INS70 UPD42 MOV32 INS42 INS45 MOV60 INS25 INS22 INS42 INS52 INS42 INS22 INS42 MOV42 INS32 UPD74 INS42 UPD42 MOV42 INS42 INS74 INS42 INS44 INS42 INS8 MOV32 INS42 MOV32 MOV8 INS52 INS42 INS52 INS42 MOV32 MOV42 MOV45 INS43 UPD42 MOV42 INS43 INS42 MOV21 INS42 INS45 INS61 INS42 INS42 INS42 INS42 MOV32 MOV32 INS8 INS27 UPD42 MOV42 INS45 INS42 MOV21 MOV21 MOV42 MOV32 MOV32 MOV14 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 INS42 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL46 DEL42 DEL78 DEL83 DEL42 DEL48 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL27 DEL36 DEL42 DEL42 DEL48 DEL27 DEL41 DEL83 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL21 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL42 DEL46 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL32 DEL40 DEL27 DEL45 DEL6 DEL43 DEL52 DEL14 DEL41 DEL8 DEL31 DEL52 DEL42 DEL78 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL40 DEL33 DEL17 DEL32 DEL52 DEL40 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL32 DEL21 DEL52 DEL42 DEL27 DEL36 DEL42 DEL42 DEL48 DEL27 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL41 DEL25 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL32 DEL27 DEL14 DEL53 DEL25 DEL52 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL8 DEL24 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL8 DEL24 DEL52 DEL42 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL48 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL45 DEL42 DEL27 DEL45 DEL42 DEL45 DEL42 DEL42 DEL61 DEL25 DEL8
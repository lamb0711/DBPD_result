YARN-4752. Improved preemption in FairScheduler. (kasha)

Contains:
YARN-5605. Preempt containers (all on one node) to meet the requirement of starved applications
YARN-5821. Drop left-over preemption-related code and clean up method visibilities in the Schedulable hierarchy
YARN-5783. Verify identification of starved applications.
YARN-5819. Verify fairshare and minshare preemption
YARN-5885. Cleanup YARN-4752 branch for merge

Change-Id: Iee0962377d019dd64dc69a020725d2eaf360858c

-import java.io.Serializable;
-import java.util.Arrays;
-import java.util.Comparator;
+import java.util.Collections;
+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.Queue;
+  private FSQueue fsQueue;
-  private Resource preemptedResources = Resources.createResource(0);
-  private RMContainerComparator comparator = new RMContainerComparator();
-  private final Map<RMContainer, Long> preemptionMap = new HashMap<RMContainer, Long>();
+
+  // Preemption related variables
+  private final Resource preemptedResources = Resources.clone(Resources.none());
+  private final Set<RMContainer> containersToPreempt = new HashSet<>();
+  private Resource fairshareStarvation = Resources.none();
+  private long lastTimeAtFairShare;
+
+  // minShareStarvation attributed to this application by the leaf queue
+  private Resource minshareStarvation = Resources.none();
+    this.fsQueue = queue;
+    this.lastTimeAtFairShare = this.startTime;
-  public ResourceWeights getResourceWeights() {
+  ResourceWeights getResourceWeights() {
-  public void containerCompleted(RMContainer rmContainer,
+  void containerCompleted(RMContainer rmContainer,
+      untrackContainerForPreemption(rmContainer);
-      // remove from preemption map if it is completed
-      preemptionMap.remove(rmContainer);
-
-  public void resetAllowedLocalityLevel(
+  void resetAllowedLocalityLevel(
-  // related methods
-  public void addPreemption(RMContainer container, long time) {
-    assert preemptionMap.get(container) == null;
-    try {
-      writeLock.lock();
-      preemptionMap.put(container, time);
-      Resources.addTo(preemptedResources, container.getAllocatedResource());
-    } finally {
-      writeLock.unlock();
-    }
-  }
-
-  public Long getContainerPreemptionTime(RMContainer container) {
-    return preemptionMap.get(container);
-  }
-
-  public Set<RMContainer> getPreemptionContainers() {
-    return preemptionMap.keySet();
-  }
-  
-    return (FSLeafQueue)super.getQueue();
+    Queue queue = super.getQueue();
+    assert queue instanceof FSLeafQueue;
+    return (FSLeafQueue) queue;
-  public Resource getPreemptedResources() {
-    return preemptedResources;
+  // Preemption related methods
+
+  /**
+   * Get overall starvation - fairshare and attributed minshare.
+   *
+   * @return total starvation attributed to this application
+   */
+  Resource getStarvation() {
+    return Resources.add(fairshareStarvation, minshareStarvation);
-  public void resetPreemptedResources() {
-    preemptedResources = Resources.createResource(0);
-    for (RMContainer container : getPreemptionContainers()) {
+  /**
+   * Set the minshare attributed to this application. To be called only from
+   * {@link FSLeafQueue#updateStarvedApps}.
+   *
+   * @param starvation minshare starvation attributed to this app
+   */
+  void setMinshareStarvation(Resource starvation) {
+    this.minshareStarvation = starvation;
+  }
+
+  /**
+   * Reset the minshare starvation attributed to this application. To be
+   * called only from {@link FSLeafQueue#updateStarvedApps}
+   */
+  void resetMinshareStarvation() {
+    this.minshareStarvation = Resources.none();
+  }
+
+  void trackContainerForPreemption(RMContainer container) {
+    containersToPreempt.add(container);
+    synchronized (preemptedResources) {
-  public void clearPreemptedResources() {
-    preemptedResources.setMemorySize(0);
-    preemptedResources.setVirtualCores(0);
+  private void untrackContainerForPreemption(RMContainer container) {
+    synchronized (preemptedResources) {
+      Resources.subtractFrom(preemptedResources,
+          container.getAllocatedResource());
+    }
+    containersToPreempt.remove(container);
+  }
+
+  Set<RMContainer> getPreemptionContainers() {
+    return containersToPreempt;
+  }
+
+  private Resource getPreemptedResources() {
+    synchronized (preemptedResources) {
+      return preemptedResources;
+    }
+  }
+
+  boolean canContainerBePreempted(RMContainer container) {
+    // Sanity check that the app owns this container
+    if (!getLiveContainersMap().containsKey(container.getContainerId()) &&
+        !newlyAllocatedContainers.contains(container)) {
+      LOG.error("Looking to preempt container " + container +
+          ". Container does not belong to app " + getApplicationId());
+      return false;
+    }
+
+    if (containersToPreempt.contains(container)) {
+      // The container is already under consideration for preemption
+      return false;
+    }
+
+    // Check if any of the parent queues are not preemptable
+    // TODO (YARN-5831): Propagate the "preemptable" flag all the way down to
+    // the app to avoid recursing up every time.
+    for (FSQueue q = getQueue();
+        !q.getQueueName().equals("root");
+        q = q.getParent()) {
+      if (!q.isPreemptable()) {
+        return false;
+      }
+    }
+
+    // Check if the app's allocation will be over its fairshare even
+    // after preempting this container
+    Resource currentUsage = getResourceUsage();
+    Resource fairshare = getFairShare();
+    Resource overFairShareBy = Resources.subtract(currentUsage, fairshare);
+
+    return (Resources.fitsIn(container.getAllocatedResource(),
+        overFairShareBy));
-   * given appliction on the given node with the given capability and
+   * given application on the given node with the given capability and
+   *
-  public Container createContainer(FSSchedulerNode node, Resource capability,
+  private Container createContainer(FSSchedulerNode node, Resource capability,
-    Container container = BuilderUtils.newContainer(containerId, nodeId,
+    return BuilderUtils.newContainer(containerId, nodeId,
-
-    return container;
-        Arrays.asList(node.getReservedContainer().getReservedSchedulerKey()) :
+        Collections.singletonList(
+            node.getReservedContainer().getReservedSchedulerKey()) :
-  public boolean assignReservedContainer(FSSchedulerNode node) {
+  boolean assignReservedContainer(FSSchedulerNode node) {
-  static class RMContainerComparator implements Comparator<RMContainer>,
-      Serializable {
-    @Override
-    public int compare(RMContainer c1, RMContainer c2) {
-      int ret = c1.getContainer().getPriority().compareTo(
-          c2.getContainer().getPriority());
-      if (ret == 0) {
-        return c2.getContainerId().compareTo(c1.getContainerId());
-      }
-      return ret;
+  /**
+   * Helper method that computes the extent of fairshare fairshareStarvation.
+   */
+  Resource fairShareStarvation() {
+    Resource threshold = Resources.multiply(
+        getFairShare(), fsQueue.getFairSharePreemptionThreshold());
+    Resource starvation = Resources.subtractFrom(threshold, getResourceUsage());
+
+    long now = scheduler.getClock().getTime();
+    boolean starved = Resources.greaterThan(
+        fsQueue.getPolicy().getResourceCalculator(),
+        scheduler.getClusterResource(), starvation, Resources.none());
+
+    if (!starved) {
+      lastTimeAtFairShare = now;
+
+    if (starved &&
+        (now - lastTimeAtFairShare > fsQueue.getFairSharePreemptionTimeout())) {
+      this.fairshareStarvation = starvation;
+    } else {
+      this.fairshareStarvation = Resources.none();
+    }
+    return this.fairshareStarvation;
+  }
+
+  ResourceRequest getNextResourceRequest() {
+    return appSchedulingInfo.getNextResourceRequest();
+  }
+
+  /**
+   * Helper method that captures if this app is identified to be starved.
+   * @return true if the app is starved for fairshare, false otherwise
+   */
+  @VisibleForTesting
+  boolean isStarvedForFairShare() {
+    return !Resources.isNone(fairshareStarvation);
-    // Here the getPreemptedResources() always return zero, except in
-    // a preemption round
-    // In the common case where preempted resource is zero, return the
-    // current consumption Resource object directly without calling
-    // Resources.subtract which creates a new Resource object for each call.
-    return getPreemptedResources().equals(Resources.none()) ?
-        getCurrentConsumption() :
-        Resources.subtract(getCurrentConsumption(), getPreemptedResources());
+    /*
+     * getResourcesToPreempt() returns zero, except when there are containers
+     * to preempt. Avoid creating an object in the common case.
+     */
+    return getPreemptedResources().equals(Resources.none())
+        ? getCurrentConsumption()
+        : Resources.subtract(getCurrentConsumption(), getPreemptedResources());
-  /**
-   * Preempt a running container according to the priority
+  /*
+   * Overriding to appease findbugs
-  public RMContainer preemptContainer() {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("App " + getName() + " is going to preempt a running " +
-          "container");
-    }
+  public int hashCode() {
+    return super.hashCode();
+  }
-    RMContainer toBePreempted = null;
-    for (RMContainer container : getLiveContainers()) {
-      if (!getPreemptionContainers().contains(container) &&
-          (toBePreempted == null ||
-              comparator.compare(toBePreempted, container) > 0)) {
-        toBePreempted = container;
-      }
-    }
-    return toBePreempted;
+  /*
+   * Overriding to appease findbugs
+   */
+  @Override
+  public boolean equals(Object o) {
+    return super.equals(o);

MOV26 MOV26 MOV26 MOV23 MOV31 MOV31 MOV31 UPD40 UPD40 UPD40 INS23 INS23 INS23 INS31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 INS43 INS59 INS83 UPD43 UPD74 INS83 MOV43 INS59 INS83 INS39 INS59 INS83 INS43 INS59 INS29 UPD43 UPD42 INS29 MOV39 INS42 INS44 INS8 INS29 INS39 INS42 INS8 UPD42 MOV44 INS83 INS39 INS42 MOV44 INS8 UPD83 INS8 UPD39 INS42 MOV44 INS8 UPD83 UPD43 UPD42 INS43 INS42 INS8 INS29 INS78 INS39 INS42 INS8 MOV78 INS83 INS39 INS42 INS8 MOV78 INS83 INS39 INS42 INS44 INS8 INS42 INS42 UPD42 INS42 INS32 UPD43 UPD42 INS42 INS32 INS42 INS42 INS42 INS32 INS21 INS21 INS60 INS6 INS65 INS65 UPD42 INS65 INS65 INS43 INS42 MOV21 INS65 MOV21 INS51 INS51 INS21 INS51 INS25 INS25 INS24 INS60 INS60 INS60 MOV41 UPD42 INS60 INS60 INS60 INS25 INS25 INS42 INS41 INS65 INS65 INS42 INS41 INS41 INS43 INS42 INS41 INS42 INS42 INS32 UPD42 UPD74 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS7 INS7 MOV21 INS43 INS59 INS62 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS7 INS66 INS66 INS65 INS7 INS32 INS42 MOV8 INS42 MOV8 INS32 INS42 INS42 MOV8 INS27 INS8 INS32 INS8 INS58 INS38 INS7 INS8 INS43 INS59 INS43 INS59 INS43 INS59 INS36 UPD66 MOV32 UPD66 INS43 INS59 UPD43 INS39 INS59 INS39 INS59 INS38 INS8 INS27 MOV8 INS8 INS22 INS32 INS66 INS66 INS38 INS48 INS42 INS48 INS42 INS42 UPD43 INS22 INS42 INS22 INS22 INS42 INS42 MOV48 INS42 INS43 INS42 UPD42 UPD42 UPD42 INS42 INS67 INS22 INS42 INS67 INS22 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS38 INS38 INS21 INS41 INS42 UPD42 MOV42 UPD42 MOV42 INS41 INS43 INS59 INS32 INS42 INS32 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS32 UPD42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS21 UPD42 MOV42 INS36 INS21 INS52 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS52 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS32 INS9 INS9 INS42 INS42 INS32 MOV32 UPD42 MOV42 INS45 UPD42 MOV42 UPD42 MOV42 INS38 INS8 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 UPD42 MOV42 INS42 INS42 INS32 INS32 INS42 INS32 INS7 INS27 INS7 INS42 INS42 INS42 UPD42 UPD42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 UPD42 UPD42 INS32 INS41 INS42 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS22 UPD42 INS22 INS32 INS42 INS42 INS42 INS45 INS42 INS45 INS32 INS42 INS42 INS9 INS42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL42 DEL42 DEL43 DEL14 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL83 DEL83 DEL42 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL6 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL42 DEL42 DEL34 DEL32 DEL34 DEL32 DEL83 DEL42 DEL34 DEL32 DEL7 DEL42 DEL32 DEL70 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL32 DEL42 DEL32 DEL32 DEL41 DEL8 DEL25 DEL8 DEL83 DEL42 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL83 DEL83 DEL42 DEL42 DEL32 DEL45 DEL32 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL32 DEL38 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL36 DEL27 DEL25 DEL8 DEL70 DEL42 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL55
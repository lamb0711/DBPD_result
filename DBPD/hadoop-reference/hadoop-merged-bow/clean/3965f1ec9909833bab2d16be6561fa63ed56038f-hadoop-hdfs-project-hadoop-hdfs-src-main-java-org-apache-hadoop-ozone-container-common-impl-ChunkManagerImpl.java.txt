HDFS-12853. Ozone: Optimize chunk writes for Ratis by avoiding double writes.  Contributed by Mukul Kumar Singh

+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos;
+import org.apache.hadoop.ozone.OzoneConsts;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
-      byte[] data)
+      byte[] data, ContainerProtos.Stage stage)
-      long oldSize = chunkFile.length();
-      ChunkUtils.writeData(chunkFile, info, data);
-      containerManager.incrWriteBytes(containerName, info.getLen());
-      containerManager.incrWriteCount(containerName);
-      long newSize = chunkFile.length();
-      containerManager.incrBytesUsed(containerName, newSize - oldSize);
-    } catch (ExecutionException | NoSuchAlgorithmException e) {
+      File tmpChunkFile = getTmpChunkFile(chunkFile, info);
+
+      LOG.debug("writing chunk:{} chunk stage:{} chunk file:{} tmp chunk file",
+          info.getChunkName(), stage, chunkFile, tmpChunkFile);
+      switch (stage) {
+      case WRITE_DATA:
+        ChunkUtils.writeData(tmpChunkFile, info, data);
+        break;
+      case COMMIT_DATA:
+        commitChunk(tmpChunkFile, chunkFile, containerName, info.getLen());
+        break;
+      case COMBINED:
+        ChunkUtils.writeData(tmpChunkFile, info, data);
+        commitChunk(tmpChunkFile, chunkFile, containerName, info.getLen());
+        break;
+      }
+    } catch (ExecutionException | NoSuchAlgorithmException | IOException e) {
+  // Create a temporary file in the same container directory
+  // in the format "<chunkname>.tmp"
+  private static File getTmpChunkFile(File chunkFile, ChunkInfo info)
+      throws StorageContainerException {
+    return new File(chunkFile.getParent(),
+        chunkFile.getName() +
+            OzoneConsts.CONTAINER_CHUNK_NAME_DELIMITER +
+            OzoneConsts.CONTAINER_TEMPORARY_CHUNK_PREFIX);
+  }
+
+  // Commit the chunk by renaming the temporary chunk file to chunk file
+  private void commitChunk(File tmpChunkFile, File chunkFile,
+      String containerName, long chunkLen) throws IOException {
+    long sizeDiff = tmpChunkFile.length() - chunkFile.length();
+    // It is safe to replace here as the earlier chunk if existing should be
+    // caught as part of validateChunk
+    Files.move(tmpChunkFile.toPath(), chunkFile.toPath(),
+        StandardCopyOption.REPLACE_EXISTING);
+    containerManager.incrBytesUsed(containerName, sizeDiff);
+    containerManager.incrWriteCount(containerName);
+    containerManager.incrWriteBytes(containerName, chunkLen);
+  }
+

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS44 INS83 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS43 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 MOV60 INS21 INS21 MOV21 INS21 INS40 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS32 INS32 INS21 INS50 INS43 INS32 INS27 UPD42 INS27 INS42 INS42 INS32 INS32 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS49 INS21 INS10 INS49 MOV21 INS10 INS49 INS21 INS21 INS10 UPD84 INS42 INS42 INS42 INS32 INS40 INS40 INS32 MOV32 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 MOV32 INS43 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS32 INS42 INS42 INS42 DEL39 DEL42 DEL42 DEL27 DEL21 DEL21
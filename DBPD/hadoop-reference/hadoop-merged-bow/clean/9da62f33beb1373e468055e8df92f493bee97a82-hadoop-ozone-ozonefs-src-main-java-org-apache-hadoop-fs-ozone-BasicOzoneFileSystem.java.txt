Merge branch 'trunk' into HDDS-1535
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.LinkedList;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;
-  private class ListStatusIterator extends OzoneListingIterator {
-    // _fileStatuses_ maintains a list of file(s) which is either the input
-    // path itself or a child of the input directory path.
-    private List<FileStatus> fileStatuses = new ArrayList<>(LISTING_PAGE_SIZE);
-    // _subDirStatuses_ maintains a list of sub-dirs of the input directory
-    // path.
-    private Map<Path, FileStatus> subDirStatuses =
-        new HashMap<>(LISTING_PAGE_SIZE);
-    private Path f; // the input path
-
-    ListStatusIterator(Path f) throws IOException {
-      super(f);
-      this.f = f;
-    }
-
-    /**
-     * Add the key to the listStatus result if the key corresponds to the
-     * input path or is an immediate child of the input path.
-     *
-     * @param key key to be processed
-     * @return always returns true
-     * @throws IOException
-     */
-    @Override
-    boolean processKey(String key) throws IOException {
-      Path keyPath = new Path(OZONE_URI_DELIMITER + key);
-      if (key.equals(getPathKey())) {
-        if (pathIsDirectory()) {
-          // if input path is a directory, we add the sub-directories and
-          // files under this directory.
-          return true;
-        } else {
-          addFileStatus(keyPath);
-          return true;
-        }
-      }
-      // Left with only subkeys now
-      // We add only the immediate child files and sub-dirs i.e. we go only
-      // upto one level down the directory tree structure.
-      if (pathToKey(keyPath.getParent()).equals(pathToKey(f))) {
-        // This key is an immediate child. Can be file or directory
-        if (key.endsWith(OZONE_URI_DELIMITER)) {
-          // Key is a directory
-          addSubDirStatus(keyPath);
-        } else {
-          addFileStatus(keyPath);
-        }
-      } else {
-        // This key is not the immediate child of the input directory. So we
-        // traverse the parent tree structure of this key until we get the
-        // immediate child of the input directory.
-        Path immediateChildPath = getImmediateChildPath(keyPath.getParent());
-        if (immediateChildPath != null) {
-          addSubDirStatus(immediateChildPath);
-        }
-      }
-      return true;
-    }
-
-    /**
-     * Adds the FileStatus of keyPath to final result of listStatus.
-     *
-     * @param filePath path to the file
-     * @throws FileNotFoundException
-     */
-    void addFileStatus(Path filePath) throws IOException {
-      fileStatuses.add(getFileStatus(filePath));
-    }
-
-    /**
-     * Adds the FileStatus of the subdir to final result of listStatus, if not
-     * already included.
-     *
-     * @param dirPath path to the dir
-     * @throws FileNotFoundException
-     */
-    void addSubDirStatus(Path dirPath) throws IOException {
-      // Check if subdir path is already included in statuses.
-      if (!subDirStatuses.containsKey(dirPath)) {
-        subDirStatuses.put(dirPath, getFileStatus(dirPath));
-      }
-    }
-
-    /**
-     * Traverse the parent directory structure of keyPath to determine the
-     * which parent/ grand-parent/.. is the immediate child of the input path f.
-     *
-     * @param keyPath path whose parent directory structure should be traversed.
-     * @return immediate child path of the input path f.
-     */
-    Path getImmediateChildPath(Path keyPath) {
-      Path path = keyPath;
-      Path parent = path.getParent();
-      while (parent != null) {
-        if (pathToKey(parent).equals(pathToKey(f))) {
-          return path;
-        }
-        path = parent;
-        parent = path.getParent();
-      }
-      return null;
-    }
-
-    /**
-     * Return the result of listStatus operation. If the input path is a
-     * file, return the status for only that file. If the input path is a
-     * directory, return the statuses for all the child files and sub-dirs.
-     */
-    FileStatus[] getStatuses() {
-      List<FileStatus> result = Stream.concat(
-          fileStatuses.stream(), subDirStatuses.values().stream())
-          .collect(Collectors.toList());
-      return result.toArray(new FileStatus[result.size()]);
-    }
-  }
-
-    ListStatusIterator iterator = new ListStatusIterator(f);
-    iterator.iterate();
-    return iterator.getStatuses();
+    int numEntries = LISTING_PAGE_SIZE;
+    LinkedList<OzoneFileStatus> statuses = new LinkedList<>();
+    List<OzoneFileStatus> tmpStatusList;
+    String startKey = "";
+
+    do {
+      tmpStatusList =
+          adapter.listStatus(pathToKey(f), false, startKey, numEntries);
+      if (!tmpStatusList.isEmpty()) {
+        if (startKey.isEmpty()) {
+          statuses.addAll(tmpStatusList);
+        } else {
+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));
+        }
+        startKey = pathToKey(statuses.getLast().getPath());
+      }
+      // listStatus returns entries numEntries in size if available.
+      // Any lesser number of entries indicate that the required entries have
+      // exhausted.
+    } while (tmpStatusList.size() == numEntries);
+
+    for (OzoneFileStatus status : statuses) {
+      status.makeQualified(uri, status.getPath().makeQualified(uri, workingDir),
+          getUsername(), getUsername());
+    }
+    return statuses.toArray(new FileStatus[0]);

MOV26 MOV26 UPD40 UPD40 INS31 MOV78 INS83 MOV5 INS42 MOV44 MOV43 INS8 MOV21 MOV21 MOV21 INS60 INS60 INS60 MOV60 INS19 INS70 MOV41 INS39 INS59 INS74 INS59 UPD74 MOV74 INS59 MOV43 INS8 INS27 INS44 INS42 INS8 UPD42 MOV42 INS42 UPD43 MOV43 UPD43 MOV43 UPD42 MOV42 MOV14 UPD43 UPD42 MOV42 INS42 INS45 INS21 INS25 INS32 INS42 INS43 INS42 INS21 UPD42 UPD42 UPD42 UPD74 UPD42 INS7 INS38 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS34 UPD43 INS42 INS32 INS32 INS25 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 MOV32 INS9 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS8 INS8 INS7 MOV32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV21 INS21 INS42 INS32 UPD42 UPD42 INS32 INS42 INS32 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS34 MOV32 UPD42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL27 DEL14 DEL42 DEL32 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL43 DEL83 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL74 DEL59 DEL23 DEL83 DEL42 DEL43 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL46 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL78 DEL39 DEL42 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL9 DEL41 DEL8 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL38 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL32 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL33 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL32 DEL59 DEL60 DEL8 DEL31 DEL55 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL8 DEL31
YARN-62. Modified NodeManagers to avoid AMs from abusing container tokens for repetitive container launches. Contributed by Omkar Vinit Joshi.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503986 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.TreeMap;
-import org.apache.hadoop.yarn.api.records.ApplicationId;
+  private final TreeMap<Long, List<ContainerId>> recentlyStartedContainerTracker;
+
-  private final Map<ApplicationId, ConcurrentMap<ContainerId, MasterKeyData>> oldMasterKeys;
-    this.oldMasterKeys =
-        new HashMap<ApplicationId, ConcurrentMap<ContainerId, MasterKeyData>>();
+    recentlyStartedContainerTracker =
+        new TreeMap<Long, List<ContainerId>>();
-    ContainerId containerId = identifier.getContainerID();
-    ApplicationId appId =
-        containerId.getApplicationAttemptId().getApplicationId();
-    } else if (this.oldMasterKeys.containsKey(appId)
-        && this.oldMasterKeys.get(appId).containsKey(containerId)) {
-      // This means on the following happened:
-      // (1) a stopContainer() or a getStatus() happened for a container with
-      // token generated off a master-key that is neither current nor the
-      // previous one.
-      // (2) a container-relaunch has come in with a token generated off a
-      // master-key that is neither current nor the previous one.
-      // This basically lets stop and getStatus() calls with old-tokens to pass
-      // through without any issue, i.e. (1).
-      // Start-calls for repetitive launches (2) also pass through RPC here, but
-      // get thwarted at the app-layer as part of startContainer() call.
-      masterKeyToUse = this.oldMasterKeys.get(appId).get(containerId);
-   * Container start has gone through. Store the corresponding keys so that
-   * stopContainer() and getContainerStatus() can be authenticated long after
-   * the container-start went through.
+   * Container start has gone through. We need to store the containerId in order
+   * to block future container start requests with same container token. This
+   * container token needs to be saved till its container token expires.
-    int keyId = tokenId.getMasterKeyId();
-    if (currentMasterKey.getMasterKey().getKeyId() == keyId) {
-      addKeyForContainerId(tokenId.getContainerID(), currentMasterKey);
-    } else if (previousMasterKey != null
-        && previousMasterKey.getMasterKey().getKeyId() == keyId) {
-      addKeyForContainerId(tokenId.getContainerID(), previousMasterKey);
+
+    removeAnyContainerTokenIfExpired();
+    
+    Long expTime = tokenId.getExpiryTimeStamp();
+    // We might have multiple containers with same expiration time.
+    if (!recentlyStartedContainerTracker.containsKey(expTime)) {
+      recentlyStartedContainerTracker
+        .put(expTime, new ArrayList<ContainerId>());
+    }
+    recentlyStartedContainerTracker.get(expTime).add(tokenId.getContainerID());
+
+  }
+
+  protected synchronized void removeAnyContainerTokenIfExpired() {
+    // Trying to remove any container if its container token has expired.
+    Iterator<Entry<Long, List<ContainerId>>> containersI =
+        this.recentlyStartedContainerTracker.entrySet().iterator();
+    Long currTime = System.currentTimeMillis();
+    while (containersI.hasNext()) {
+      Entry<Long, List<ContainerId>> containerEntry = containersI.next();
+      if (containerEntry.getKey() < currTime) {
+        containersI.remove();
+      } else {
+        break;
+      }
-   * Ensure the startContainer call is not using an older cached key. Will
-   * return false once startContainerSuccessful is called. Does not check
-   * the actual key being current since that is verified by the security layer
-   * via retrievePassword.
+   * Container will be remembered based on expiration time of the container
+   * token used for starting the container. It is safe to use expiration time
+   * as there is one to many mapping between expiration time and containerId.
+   * @return true if the current token identifier is not present in cache.
-      ContainerId containerID) {
-    ApplicationId applicationId =
-        containerID.getApplicationAttemptId().getApplicationId();
-    return !this.oldMasterKeys.containsKey(applicationId)
-        || !this.oldMasterKeys.get(applicationId).containsKey(containerID);
-  }
+      ContainerTokenIdentifier containerTokenIdentifier) {
-  private synchronized void addKeyForContainerId(ContainerId containerId,
-      MasterKeyData masterKeyData) {
-    if (containerId != null) {
-      ApplicationId appId =
-          containerId.getApplicationAttemptId().getApplicationId();
-      if (!this.oldMasterKeys.containsKey(appId)) {
-        this.oldMasterKeys.put(appId,
-          new ConcurrentHashMap<ContainerId, MasterKeyData>());
-      }
-      ConcurrentMap<ContainerId, MasterKeyData> containerIdToKeysMapForThisApp =
-          this.oldMasterKeys.get(appId);
-      containerIdToKeysMapForThisApp.put(containerId, masterKeyData);
+    removeAnyContainerTokenIfExpired();
+
+    Long expTime = containerTokenIdentifier.getExpiryTimeStamp();
+    List<ContainerId> containers =
+        this.recentlyStartedContainerTracker.get(expTime);
+    if (containers == null
+        || !containers.contains(containerTokenIdentifier.getContainerID())) {
+      return true;
-      LOG.warn("Not adding key for null containerId");
+      return false;
-  // Holding on to master-keys corresponding to containers until the app is
-  // finished due to the multiple ways a container can finish. Avoid
-  // stopContainer calls seeing unnecessary authorization exceptions.
-  public synchronized void appFinished(ApplicationId appId) {
-    this.oldMasterKeys.remove(appId);
-  }
-  
-  } 
+  }

MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD74 UPD83 UPD39 INS42 INS29 UPD83 UPD39 UPD42 UPD43 UPD43 UPD74 UPD42 INS21 MOV21 INS60 INS61 INS65 INS65 UPD43 UPD42 INS21 MOV60 MOV60 INS25 UPD42 UPD42 UPD43 UPD66 UPD66 UPD66 INS32 INS43 INS38 MOV8 INS74 INS43 INS59 INS32 INS8 INS66 INS66 INS66 INS66 UPD42 INS32 UPD43 UPD74 INS27 INS8 INS8 UPD42 INS42 INS42 INS42 UPD42 INS32 INS32 INS42 INS43 INS74 UPD42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS60 INS25 INS42 UPD42 UPD42 UPD43 MOV43 UPD42 INS27 INS38 INS41 INS41 UPD74 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS43 INS43 INS74 UPD42 INS42 INS42 INS74 INS59 INS27 INS8 INS8 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS33 INS32 INS9 INS9 UPD43 UPD43 UPD74 UPD42 UPD42 MOV42 UPD42 MOV42 INS14 INS42 INS42 INS43 MOV43 INS22 UPD42 INS43 INS43 INS74 INS42 INS32 INS32 INS42 INS21 INS10 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 UPD42 UPD43 INS74 INS42 INS52 INS42 INS42 INS42 INS43 MOV43 INS42 INS42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 INS43 MOV43 INS42 UPD42 MOV42 INS42 INS42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL39 DEL32 DEL42 DEL32 DEL32 DEL42 DEL27 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL27 DEL27 DEL25 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL44 DEL43 DEL42 DEL52 DEL42 DEL22 DEL32 DEL38 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL32 DEL38 DEL27 DEL41 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL43 DEL42 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL38 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL45 DEL32 DEL21 DEL8 DEL25 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31
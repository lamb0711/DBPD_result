Revert "HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp."

This reverts commit d288a0ba8364d81aacda9f4a21022eecb6dc4e22.

-    return (call != null ) ? call.getHostInetAddress() : null;
+    return (call != null && call.connection != null) ? call.connection
+        .getHostInetAddress() : null;
-
+  
-    return (call != null) ? call.getRemoteUser() : null;
+    return (call != null && call.connection != null) ? call.connection.user
+        : null;
-
+ 
-        String client = CurCall.get().toString();
+        String client = CurCall.get().connection.toString();
-  /** A generic call queued for handling. */
-  public static class Call implements Schedulable,
-  PrivilegedExceptionAction<Void> {
-    final int callId;            // the client's call id
-    final int retryCount;        // the retry count of the call
-    long timestamp;              // time received when response is null
-                                 // time served when response is not null
+  /** A call queued for handling. */
+  public static class Call implements Schedulable {
+    private final int callId;             // the client's call id
+    private final int retryCount;        // the retry count of the call
+    private final Writable rpcRequest;    // Serialized Rpc request from client
+    private final Connection connection;  // connection to client
+    private long timestamp;               // time received when response is null
+                                          // time served when response is not null
+    private ByteBuffer rpcResponse;       // the response for this call
-    final RPC.RpcKind rpcKind;
-    final byte[] clientId;
+    private final RPC.RpcKind rpcKind;
+    private final byte[] clientId;
-    Call(Call call) {
-      this(call.callId, call.retryCount, call.rpcKind, call.clientId,
-          call.traceScope, call.callerContext);
+    private Call(Call call) {
+      this(call.callId, call.retryCount, call.rpcRequest, call.connection,
+          call.rpcKind, call.clientId, call.traceScope, call.callerContext);
-    Call(int id, int retryCount, RPC.RpcKind kind, byte[] clientId) {
-      this(id, retryCount, kind, clientId, null, null);
+    public Call(int id, int retryCount, Writable param, 
+        Connection connection) {
+      this(id, retryCount, param, connection, RPC.RpcKind.RPC_BUILTIN,
+          RpcConstants.DUMMY_CLIENT_ID);
-    @VisibleForTesting // primarily TestNamenodeRetryCache
-    public Call(int id, int retryCount, Void ignore1, Void ignore2,
+    public Call(int id, int retryCount, Writable param, Connection connection,
-      this(id, retryCount, kind, clientId, null, null);
+      this(id, retryCount, param, connection, kind, clientId, null, null);
-    Call(int id, int retryCount, RPC.RpcKind kind, byte[] clientId,
-        TraceScope traceScope, CallerContext callerContext) {
+    public Call(int id, int retryCount, Writable param, Connection connection,
+        RPC.RpcKind kind, byte[] clientId, TraceScope traceScope,
+        CallerContext callerContext) {
+      this.rpcRequest = param;
+      this.connection = connection;
+      this.rpcResponse = null;
-
+    
-      return "Call#" + callId + " Retry#" + retryCount;
+      return rpcRequest + " from " + connection + " Call#" + callId + " Retry#"
+          + retryCount;
-    public Void run() throws Exception {
-      return null;
-    }
-    // should eventually be abstract but need to avoid breaking tests
-    public UserGroupInformation getRemoteUser() {
-      return null;
-    }
-    public InetAddress getHostInetAddress() {
-      return null;
-    }
-    public String getHostAddress() {
-      InetAddress addr = getHostInetAddress();
-      return (addr != null) ? addr.getHostAddress() : null;
+    public void setResponse(ByteBuffer response) {
+      this.rpcResponse = response;
-    public final void postponeResponse() {
+    public void postponeResponse() {
-    public final void sendResponse() throws IOException {
+    public void sendResponse() throws IOException {
-        doResponse(null);
+        connection.sendResponse(this);
-    public final void abortResponse(Throwable t) throws IOException {
+    public void abortResponse(Throwable t) throws IOException {
-        doResponse(t);
+        connection.abortResponse(this, t);
-    void doResponse(Throwable t) throws IOException {}
-
-      return getRemoteUser();
+      return connection.user;
-  /** A RPC extended call queued for handling. */
-  private class RpcCall extends Call {
-    final Connection connection;  // connection to client
-    final Writable rpcRequest;    // Serialized Rpc request from client
-    ByteBuffer rpcResponse;       // the response for this call
-
-    RpcCall(RpcCall call) {
-      super(call);
-      this.connection = call.connection;
-      this.rpcRequest = call.rpcRequest;
-    }
-
-    RpcCall(Connection connection, int id) {
-      this(connection, id, RpcConstants.INVALID_RETRY_COUNT);
-    }
-
-    RpcCall(Connection connection, int id, int retryCount) {
-      this(connection, id, retryCount, null,
-          RPC.RpcKind.RPC_BUILTIN, RpcConstants.DUMMY_CLIENT_ID,
-          null, null);
-    }
-
-    RpcCall(Connection connection, int id, int retryCount,
-        Writable param, RPC.RpcKind kind, byte[] clientId,
-        TraceScope traceScope, CallerContext context) {
-      super(id, retryCount, kind, clientId, traceScope, context);
-      this.connection = connection;
-      this.rpcRequest = param;
-    }
-
-    @Override
-    public UserGroupInformation getRemoteUser() {
-      return connection.user;
-    }
-
-    @Override
-    public InetAddress getHostInetAddress() {
-      return connection.getHostInetAddress();
-    }
-
-    @Override
-    public Void run() throws Exception {
-      if (!connection.channel.isOpen()) {
-        Server.LOG.info(Thread.currentThread().getName() + ": skipped " + this);
-        return null;
-      }
-      String errorClass = null;
-      String error = null;
-      RpcStatusProto returnStatus = RpcStatusProto.SUCCESS;
-      RpcErrorCodeProto detailedErr = null;
-      Writable value = null;
-
-      try {
-        value = call(
-            rpcKind, connection.protocolName, rpcRequest, timestamp);
-      } catch (Throwable e) {
-        if (e instanceof UndeclaredThrowableException) {
-          e = e.getCause();
-        }
-        logException(Server.LOG, e, this);
-        if (e instanceof RpcServerException) {
-          RpcServerException rse = ((RpcServerException)e);
-          returnStatus = rse.getRpcStatusProto();
-          detailedErr = rse.getRpcErrorCodeProto();
-        } else {
-          returnStatus = RpcStatusProto.ERROR;
-          detailedErr = RpcErrorCodeProto.ERROR_APPLICATION;
-        }
-        errorClass = e.getClass().getName();
-        error = StringUtils.stringifyException(e);
-        // Remove redundant error class name from the beginning of the
-        // stack trace
-        String exceptionHdr = errorClass + ": ";
-        if (error.startsWith(exceptionHdr)) {
-          error = error.substring(exceptionHdr.length());
-        }
-      }
-      setupResponse(this, returnStatus, detailedErr,
-          value, errorClass, error);
-      sendResponse();
-      return null;
-    }
-
-    void setResponse(ByteBuffer response) throws IOException {
-      this.rpcResponse = response;
-    }
-
-    @Override
-    void doResponse(Throwable t) throws IOException {
-      RpcCall call = this;
-      if (t != null) {
-        // clone the call to prevent a race with another thread stomping
-        // on the response while being sent.  the original call is
-        // effectively discarded since the wait count won't hit zero
-        call = new RpcCall(this);
-        setupResponse(call,
-            RpcStatusProto.FATAL, RpcErrorCodeProto.ERROR_RPC_SERVER,
-            null, t.getClass().getName(), StringUtils.stringifyException(t));
-      }
-      connection.sendResponse(this);
-    }
-
-    @Override
-    public String toString() {
-      return super.toString() + " " + rpcRequest + " from " + connection;
-    }
-  }
-
-          ArrayList<RpcCall> calls;
+          ArrayList<Call> calls;
-            calls = new ArrayList<RpcCall>(writeSelector.keys().size());
+            calls = new ArrayList<Call>(writeSelector.keys().size());
-              RpcCall call = (RpcCall)key.attachment();
+              Call call = (Call)key.attachment();
-
-          for (RpcCall call : calls) {
+          
+          for(Call call : calls) {
-      RpcCall call = (RpcCall)key.attachment();
+      Call call = (Call)key.attachment();
-    private void doPurge(RpcCall call, long now) {
-      LinkedList<RpcCall> responseQueue = call.connection.responseQueue;
+    private void doPurge(Call call, long now) {
+      LinkedList<Call> responseQueue = call.connection.responseQueue;
-        Iterator<RpcCall> iter = responseQueue.listIterator(0);
+        Iterator<Call> iter = responseQueue.listIterator(0);
-    private boolean processResponse(LinkedList<RpcCall> responseQueue,
+    private boolean processResponse(LinkedList<Call> responseQueue,
-      RpcCall call = null;
+      Call call = null;
-    void doRespond(RpcCall call) throws IOException {
+    void doRespond(Call call) throws IOException {
-    private LinkedList<RpcCall> responseQueue;
+    private LinkedList<Call> responseQueue;
-    private final RpcCall authFailedCall =
-        new RpcCall(this, AUTHORIZATION_FAILED_CALL_ID);
+    private final Call authFailedCall = new Call(AUTHORIZATION_FAILED_CALL_ID,
+        RpcConstants.INVALID_RETRY_COUNT, null, this);
-      this.responseQueue = new LinkedList<RpcCall>();
+      this.responseQueue = new LinkedList<Call>();
-      final RpcCall saslCall = new RpcCall(this, AuthProtocol.SASL.callId);
+      final Call saslCall = new Call(AuthProtocol.SASL.callId,
+          RpcConstants.INVALID_RETRY_COUNT, null, this);
-        RpcCall fakeCall = new RpcCall(this, -1);
+        Call fakeCall = new Call(-1, RpcConstants.INVALID_RETRY_COUNT, null,
+            this);
-        RpcCall fakeCall = new RpcCall(this, -1);
+        Call fakeCall = new Call(-1, RpcConstants.INVALID_RETRY_COUNT, null,
+            this);
-        RpcCall fakeCall = new RpcCall(this, 0);
+        Call fakeCall = new Call(0, RpcConstants.INVALID_RETRY_COUNT, null,
+            this);
-      RpcCall fakeCall = new RpcCall(this, 0);
+      Call fakeCall = new Call(0, RpcConstants.INVALID_RETRY_COUNT, null, this);
-        final RpcCall call = new RpcCall(this, callId, retry);
+        final Call call = new Call(callId, retry, null, this);
-      RpcCall call = new RpcCall(this, header.getCallId(),
-          header.getRetryCount(), rpcRequest,
-          ProtoUtil.convert(header.getRpcKind()),
+      Call call = new Call(header.getCallId(), header.getRetryCount(),
+          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),
-    private void sendResponse(RpcCall call) throws IOException {
+    private void sendResponse(Call call) throws IOException {
+    private void abortResponse(Call call, Throwable t) throws IOException {
+      // clone the call to prevent a race with the other thread stomping
+      // on the response while being sent.  the original call is
+      // effectively discarded since the wait count won't hit zero
+      call = new Call(call);
+      setupResponse(call,
+          RpcStatusProto.FATAL, RpcErrorCodeProto.ERROR_RPC_SERVER,
+          null, t.getClass().getName(), StringUtils.stringifyException(t));
+      call.sendResponse();
+    }
+
+          if (!call.connection.channel.isOpen()) {
+            LOG.info(Thread.currentThread().getName() + ": skipped " + call);
+            continue;
+          }
+          String errorClass = null;
+          String error = null;
+          RpcStatusProto returnStatus = RpcStatusProto.SUCCESS;
+          RpcErrorCodeProto detailedErr = null;
+          Writable value = null;
+
-          UserGroupInformation remoteUser = call.getRemoteUser();
-          if (remoteUser != null) {
-            remoteUser.doAs(call);
-          } else {
-            call.run();
+
+          try {
+            // Make the call as the user via Subject.doAs, thus associating
+            // the call with the Subject
+            if (call.connection.user == null) {
+              value = call(call.rpcKind, call.connection.protocolName, call.rpcRequest, 
+                           call.timestamp);
+            } else {
+              value = 
+                call.connection.user.doAs
+                  (new PrivilegedExceptionAction<Writable>() {
+                     @Override
+                     public Writable run() throws Exception {
+                       // make the call
+                       return call(call.rpcKind, call.connection.protocolName, 
+                                   call.rpcRequest, call.timestamp);
+
+                     }
+                   }
+                  );
+            }
+          } catch (Throwable e) {
+            if (e instanceof UndeclaredThrowableException) {
+              e = e.getCause();
+            }
+            logException(LOG, e, call);
+            if (e instanceof RpcServerException) {
+              RpcServerException rse = ((RpcServerException)e); 
+              returnStatus = rse.getRpcStatusProto();
+              detailedErr = rse.getRpcErrorCodeProto();
+            } else {
+              returnStatus = RpcStatusProto.ERROR;
+              detailedErr = RpcErrorCodeProto.ERROR_APPLICATION;
+            }
+            errorClass = e.getClass().getName();
+            error = StringUtils.stringifyException(e);
+            // Remove redundant error class name from the beginning of the stack trace
+            String exceptionHdr = errorClass + ": ";
+            if (error.startsWith(exceptionHdr)) {
+              error = error.substring(exceptionHdr.length());
+            }
+          }
+          CurCall.set(null);
+          synchronized (call.connection.responseQueue) {
+            setupResponse(call, returnStatus, detailedErr,
+                value, errorClass, error);
+            call.sendResponse();
-          CurCall.set(null);
-      RpcCall call, RpcStatusProto status, RpcErrorCodeProto erCode,
+      Call call, RpcStatusProto status, RpcErrorCodeProto erCode,
-  private void setupResponse(RpcCall call,
+  private void setupResponse(Call call,
-                             RpcCall call,
+                             Call call,
-  private void wrapWithSasl(RpcCall call) throws IOException {
+  private void wrapWithSasl(Call call) throws IOException {

INS23 INS23 INS23 INS31 MOV31 MOV31 INS83 INS83 INS83 INS83 MOV43 MOV59 INS83 INS83 MOV43 MOV59 INS83 INS83 MOV43 MOV59 INS83 INS83 INS83 INS44 INS83 MOV44 MOV44 MOV44 INS83 MOV44 MOV44 MOV83 MOV39 UPD42 MOV42 MOV44 MOV8 MOV78 MOV43 MOV8 MOV44 UPD74 MOV74 MOV43 INS83 UPD42 INS44 MOV8 MOV78 INS39 INS42 INS8 UPD43 UPD43 UPD43 UPD43 UPD66 INS43 INS42 MOV39 MOV42 UPD43 UPD42 UPD42 MOV42 MOV39 MOV39 UPD43 UPD42 MOV43 MOV42 MOV21 MOV21 INS21 UPD43 MOV43 MOV42 MOV41 MOV60 UPD43 UPD74 MOV74 UPD43 UPD43 INS43 INS42 INS21 MOV42 MOV21 MOV21 INS61 MOV21 UPD42 UPD42 UPD42 UPD42 INS40 INS42 INS40 INS40 INS42 UPD42 UPD42 INS40 INS40 UPD42 UPD42 MOV42 INS42 INS42 INS7 MOV42 MOV40 UPD43 UPD42 INS74 UPD43 UPD43 UPD42 UPD43 INS40 INS33 INS52 UPD43 UPD43 UPD43 UPD42 UPD42 MOV42 INS32 INS42 INS8 INS27 INS40 INS27 INS22 INS33 INS42 INS45 INS42 UPD45 UPD42 MOV43 INS43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 MOV60 INS54 MOV27 INS27 MOV27 INS27 INS52 INS42 MOV32 UPD43 INS42 UPD74 UPD74 MOV74 UPD43 INS40 INS33 INS52 UPD43 UPD43 INS40 INS33 INS52 UPD43 INS52 UPD43 INS42 MOV8 MOV12 MOV12 INS8 INS40 INS33 INS40 INS33 UPD42 MOV42 INS42 UPD42 INS52 UPD42 UPD43 UPD43 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 MOV60 MOV25 MOV21 MOV25 MOV21 MOV21 INS51 MOV21 UPD74 MOV74 UPD42 UPD42 UPD43 MOV38 INS40 INS33 UPD42 UPD43 UPD42 INS8 INS40 INS8 INS22 UPD43 UPD43 UPD42 UPD43 MOV38 INS40 INS33 UPD42 UPD43 INS33 INS52 INS18 INS25 MOV21 MOV21 MOV32 INS42 UPD42 UPD42 UPD42 UPD43 INS40 INS33 INS52 UPD42 UPD40 INS27 INS8 INS8 INS60 UPD42 INS42 INS40 INS33 INS21 MOV21 INS42 INS42 UPD74 MOV74 INS43 INS59 INS42 INS7 INS42 INS42 UPD43 INS42 INS42 INS11 INS42 INS32 UPD42 INS43 MOV32 INS42 INS40 INS40 INS40 INS40 INS40 UPD42 INS14 INS42 UPD74 MOV74 INS1 UPD43 INS31 UPD42 MOV78 INS83 INS43 INS42 MOV43 INS8 INS42 INS41 INS32 UPD42 MOV42 INS40 INS40 INS40 INS40 DEL42 DEL42 DEL42 DEL32 DEL40 DEL39 DEL85 DEL5 DEL33 DEL33 DEL42 DEL78 DEL42 DEL43 DEL42 DEL42 DEL43 DEL33 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL33 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL33 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL32 DEL33 DEL16 DEL41 DEL8 DEL31 DEL83 DEL83 DEL33 DEL83 DEL42 DEL43 DEL8 DEL31 DEL42 DEL32 DEL66 DEL65 DEL29 DEL83 DEL42 DEL83 DEL23 DEL83 DEL23 DEL23 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL46 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL40 DEL17 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL33 DEL40 DEL40 DEL33 DEL33 DEL17 DEL8 DEL31 DEL42 DEL39 DEL42 DEL44 DEL40 DEL43 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL46 DEL8 DEL31 DEL83 DEL42 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL48 DEL45 DEL42 DEL45 DEL42 DEL27 DEL41 DEL8 DEL31 DEL55 DEL42 DEL43 DEL42 DEL42 DEL43 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL43 DEL74 DEL52 DEL52 DEL52 DEL52 DEL52 DEL42 DEL78 DEL52 DEL43 DEL42 DEL52 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL8 DEL40 DEL52 DEL33 DEL41 DEL42 DEL40 DEL42 DEL8 DEL40 DEL52 DEL52 DEL33 DEL41 DEL43 DEL42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL8 DEL54 DEL8 DEL61 DEL8 DEL31
HDFS-9574. Reduce client failures during datanode restart. Contributed by Kihwal Lee.

+import java.util.concurrent.TimeUnit;
+import org.apache.hadoop.util.StopWatch;
+    DataOutputStream out = getBufferedOutputStream();
+    checkAccess(out, true, blk, token,
+        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ);
-      } catch (InvalidToken e) {
-        bld.setStatus(ERROR_ACCESS_TOKEN);
-        bld.setMessage(e.getMessage());
+    updateCurrentThreadName("Sending block " + block);
-    DataOutputStream out = new DataOutputStream(new BufferedOutputStream(
-        baseStream, smallBufferSize));
+    DataOutputStream out = getBufferedOutputStream();
-    updateCurrentThreadName("Sending block " + block);
+    // reply to upstream datanode or client 
+    final DataOutputStream replyOut = getBufferedOutputStream();
+    checkAccess(replyOut, isClient, block, blockToken,
+        Op.WRITE_BLOCK, BlockTokenIdentifier.AccessMode.WRITE);
-    // reply to upstream datanode or client 
-    final DataOutputStream replyOut = getBufferedOutputStream();
-    checkAccess(replyOut, isClient, block, blockToken,
-        Op.WRITE_BLOCK, BlockTokenIdentifier.AccessMode.WRITE);
-
-    checkAccess(socketOut, true, blk, blockToken,
-        Op.TRANSFER_BLOCK, BlockTokenIdentifier.AccessMode.COPY);
+    checkAccess(out, true, blk, blockToken,
+        Op.TRANSFER_BLOCK, BlockTokenIdentifier.AccessMode.COPY);
+    updateCurrentThreadName("Getting checksum for block " + block);
-    updateCurrentThreadName("Reading metadata for block " + block);
-    updateCurrentThreadName("Getting checksum for block " + block);
-    // Read in the header
-    if (datanode.isBlockTokenEnabled) {
-      try {
-        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,
-            BlockTokenIdentifier.AccessMode.COPY);
-      } catch (InvalidToken e) {
-        LOG.warn("Invalid access token in request from " + remoteAddress
-            + " for OP_COPY_BLOCK for block " + block + " : "
-            + e.getLocalizedMessage());
-        sendResponse(ERROR_ACCESS_TOKEN, "Invalid access token");
-        return;
-      }
+    DataOutputStream reply = getBufferedOutputStream();
+    checkAccess(reply, true, block, blockToken,
+        Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);
-    }
-    
-    DataOutputStream reply = null;
-      // set up response stream
-      reply = new DataOutputStream(new BufferedOutputStream(
-          baseStream, smallBufferSize));
-
-    /* read header */
-    if (datanode.isBlockTokenEnabled) {
-      try {
-        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,
-            BlockTokenIdentifier.AccessMode.REPLACE);
-      } catch (InvalidToken e) {
-        LOG.warn("Invalid access token in request from " + remoteAddress
-            + " for OP_REPLACE_BLOCK for block " + block + " : "
-            + e.getLocalizedMessage());
-        sendResponse(ERROR_ACCESS_TOKEN, "Invalid access token");
-        return;
-      }
-    }
+    DataOutputStream replyOut = new DataOutputStream(getOutputStream());
+    checkAccess(replyOut, true, block, blockToken,
+        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);
-    DataOutputStream replyOut = new DataOutputStream(getOutputStream());
+  /**
+   * Wait until the BP is registered, upto the configured amount of time.
+   * Throws an exception if times out, which should fail the client request.
+   * @param the requested block
+   */
+  void checkAndWaitForBP(final ExtendedBlock block)
+      throws IOException {
+    String bpId = block.getBlockPoolId();
+
+    // The registration is only missing in relatively short time window.
+    // Optimistically perform this first.
+    try {
+      datanode.getDNRegistrationForBP(bpId);
+      return;
+    } catch (IOException ioe) {
+      // not registered
+    }
+
+    // retry
+    long bpReadyTimeout = dnConf.getBpReadyTimeout();
+    StopWatch sw = new StopWatch();
+    sw.start();
+    while (sw.now(TimeUnit.SECONDS) <= bpReadyTimeout) {
+      try {
+        datanode.getDNRegistrationForBP(bpId);
+        return;
+      } catch (IOException ioe) {
+        // not registered
+      }
+      // sleep before trying again
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException ie) {
+        throw new IOException("Interrupted while serving request. Aborting.");
+      }
+    }
+    // failed to obtain registration.
+    throw new IOException("Not ready to serve the block pool, " + bpId + ".");
+  }
+
+    checkAndWaitForBP(blk);

INS26 INS26 INS40 INS40 INS31 MOV21 MOV60 MOV21 MOV21 MOV21 MOV60 INS29 INS39 INS42 INS44 INS43 INS8 INS60 INS21 INS60 MOV21 MOV21 INS65 INS65 INS83 INS43 INS42 INS42 INS60 INS54 INS60 INS60 INS21 INS61 INS53 INS21 MOV43 INS59 INS32 MOV43 MOV43 INS59 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS8 INS12 INS39 INS59 INS43 INS59 INS32 INS27 INS8 INS14 INS32 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS40 INS40 INS32 UPD42 INS42 INS32 UPD42 INS42 INS9 INS42 UPD42 MOV42 INS40 INS40 INS42 INS9 UPD42 UPD42 INS40 INS42 INS42 INS32 INS21 INS41 INS44 INS8 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS54 INS54 INS43 INS27 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS40 INS8 INS12 INS8 INS12 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS21 INS41 INS44 INS8 INS21 INS44 INS8 INS32 INS43 INS42 INS32 INS43 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS14 INS43 INS45 INS42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL43 DEL42 DEL42 DEL14 DEL14 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL32 DEL27 DEL40 DEL40 DEL42 DEL33 DEL42 DEL40 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL32 DEL21 DEL41 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL14 DEL14 DEL7 DEL21 DEL40 DEL33 DEL40 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL21 DEL41 DEL8 DEL12 DEL54 DEL8 DEL25
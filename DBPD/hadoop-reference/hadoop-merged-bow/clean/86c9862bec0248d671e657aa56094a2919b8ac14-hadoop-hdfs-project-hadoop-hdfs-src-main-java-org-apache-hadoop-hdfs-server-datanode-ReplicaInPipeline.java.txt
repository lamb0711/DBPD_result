HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)

-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.RandomAccessFile;
-import java.util.concurrent.atomic.AtomicReference;
-import org.apache.hadoop.hdfs.protocol.Block;
-import org.apache.hadoop.hdfs.server.common.HdfsServerConstants.ReplicaState;
-import org.apache.hadoop.hdfs.server.datanode.fsdataset.FsVolumeSpi;
-import org.apache.hadoop.io.IOUtils;
-import org.apache.hadoop.util.StringUtils;
- * This class defines a replica in a pipeline, which
- * includes a persistent replica being written to by a dfs client or
- * a temporary replica being replicated by a source datanode or
- * being copied for the balancing purpose.
- * 
- * The base class implements a temporary replica
+ * This defines the interface of a replica in Pipeline that's being written to
-public class ReplicaInPipeline extends ReplicaInfo
-                        implements ReplicaInPipelineInterface {
-  private long bytesAcked;
-  private long bytesOnDisk;
-  private byte[] lastChecksum;  
-  private AtomicReference<Thread> writer = new AtomicReference<Thread>();
+public interface ReplicaInPipeline extends Replica {
+  /**
+   * Set the number of bytes received
+   * @param bytesReceived number of bytes received
+   */
+  void setNumBytes(long bytesReceived);
-   * Bytes reserved for this replica on the containing volume.
-   * Based off difference between the estimated maximum block length and
-   * the bytes already written to this block.
+   * Get the number of bytes acked
+   * @return the number of bytes acked
-  private long bytesReserved;
-  private final long originalBytesReserved;
+  long getBytesAcked();
-   * Constructor for a zero length replica
-   * @param blockId block id
-   * @param genStamp replica generation stamp
-   * @param vol volume where replica is located
-   * @param dir directory path where block and meta files are located
-   * @param bytesToReserve disk space to reserve for this replica, based on
-   *                       the estimated maximum block length.
+   * Set the number bytes that have acked
+   * @param bytesAcked number bytes acked
-  public ReplicaInPipeline(long blockId, long genStamp, 
-        FsVolumeSpi vol, File dir, long bytesToReserve) {
-    this(blockId, 0L, genStamp, vol, dir, Thread.currentThread(), bytesToReserve);
-  }
+  void setBytesAcked(long bytesAcked);
-   * Constructor
-   * @param block a block
-   * @param vol volume where replica is located
-   * @param dir directory path where block and meta files are located
-   * @param writer a thread that is writing to this replica
+   * Release any disk space reserved for this replica.
-  ReplicaInPipeline(Block block, 
-      FsVolumeSpi vol, File dir, Thread writer) {
-    this( block.getBlockId(), block.getNumBytes(), block.getGenerationStamp(),
-        vol, dir, writer, 0L);
-  }
+  public void releaseAllBytesReserved();
-   * Constructor
-   * @param blockId block id
-   * @param len replica length
-   * @param genStamp replica generation stamp
-   * @param vol volume where replica is located
-   * @param dir directory path where block and meta files are located
-   * @param writer a thread that is writing to this replica
-   * @param bytesToReserve disk space to reserve for this replica, based on
-   *                       the estimated maximum block length.
+   * store the checksum for the last chunk along with the data length
+   * @param dataLength number of bytes on disk
+   * @param lastChecksum - checksum bytes for the last chunk
-  ReplicaInPipeline(long blockId, long len, long genStamp,
-      FsVolumeSpi vol, File dir, Thread writer, long bytesToReserve) {
-    super( blockId, len, genStamp, vol, dir);
-    this.bytesAcked = len;
-    this.bytesOnDisk = len;
-    this.writer.set(writer);
-    this.bytesReserved = bytesToReserve;
-    this.originalBytesReserved = bytesToReserve;
-  }
+  public void setLastChecksumAndDataLen(long dataLength, byte[] lastChecksum);
+  
+  /**
+   * gets the last chunk checksum and the length of the block corresponding
+   * to that checksum
+   */
+  public ChunkChecksum getLastChecksumAndDataLen();
+  
+  /**
+   * Create output streams for writing to this replica,
+   * one for block file and one for CRC file
+   *
+   * @param isCreate if it is for creation
+   * @param requestedChecksum the checksum the writer would prefer to use
+   * @return output streams for writing
+   * @throws IOException if any error occurs
+   */
+  public ReplicaOutputStreams createStreams(boolean isCreate,
+      DataChecksum requestedChecksum) throws IOException;
-   * Copy constructor.
-   * @param from where to copy from
+   * Create an output stream to write restart metadata in case of datanode
+   * shutting down for quick restart.
+   *
+   * @return output stream for writing.
+   * @throws IOException if any error occurs
-  public ReplicaInPipeline(ReplicaInPipeline from) {
-    super(from);
-    this.bytesAcked = from.getBytesAcked();
-    this.bytesOnDisk = from.getBytesOnDisk();
-    this.writer.set(from.writer.get());
-    this.bytesReserved = from.bytesReserved;
-    this.originalBytesReserved = from.originalBytesReserved;
-  }
-
-  @Override
-  public long getVisibleLength() {
-    return -1;
-  }
+  public OutputStream createRestartMetaStream() throws IOException;
-  @Override  //ReplicaInfo
-  public ReplicaState getState() {
-    return ReplicaState.TEMPORARY;
-  }
+  ReplicaInfo getReplicaInfo();
-  @Override // ReplicaInPipelineInterface
-  public long getBytesAcked() {
-    return bytesAcked;
-  }
+  /**
+   * Set the thread that is writing to this replica
+   * @param writer a thread writing to this replica
+   */
+  void setWriter(Thread writer);
-  @Override // ReplicaInPipelineInterface
-  public void setBytesAcked(long bytesAcked) {
-    long newBytesAcked = bytesAcked - this.bytesAcked;
-    this.bytesAcked = bytesAcked;
-
-    // Once bytes are ACK'ed we can release equivalent space from the
-    // volume's reservedForRbw count. We could have released it as soon
-    // as the write-to-disk completed but that would be inefficient.
-    getVolume().releaseReservedSpace(newBytesAcked);
-    bytesReserved -= newBytesAcked;
-  }
-  
-  @Override // ReplicaInPipelineInterface
-  public long getBytesOnDisk() {
-    return bytesOnDisk;
-  }
-
-  @Override
-  public long getBytesReserved() {
-    return bytesReserved;
-  }
-  
-  @Override
-  public long getOriginalBytesReserved() {
-    return originalBytesReserved;
-  }
-
-  @Override
-  public void releaseAllBytesReserved() {  // ReplicaInPipelineInterface
-    getVolume().releaseReservedSpace(bytesReserved);
-    getVolume().releaseLockedMemory(bytesReserved);
-    bytesReserved = 0;
-  }
-
-  @Override // ReplicaInPipelineInterface
-  public synchronized void setLastChecksumAndDataLen(long dataLength, byte[] lastChecksum) {
-    this.bytesOnDisk = dataLength;
-    this.lastChecksum = lastChecksum;
-  }
-  
-  @Override // ReplicaInPipelineInterface
-  public synchronized ChunkChecksum getLastChecksumAndDataLen() {
-    return new ChunkChecksum(getBytesOnDisk(), lastChecksum);
-  }
-
-  public void interruptThread() {
-    Thread thread = writer.get();
-    if (thread != null && thread != Thread.currentThread() 
-        && thread.isAlive()) {
-      thread.interrupt();
-    }
-  }
-
-  @Override  // Object
-  public boolean equals(Object o) {
-    return super.equals(o);
-  }
+  void interruptThread();
-  public boolean attemptToSetWriter(Thread prevWriter, Thread newWriter) {
-    return writer.compareAndSet(prevWriter, newWriter);
-  }
+  boolean attemptToSetWriter(Thread prevWriter, Thread newWriter);
-   * Interrupt the writing thread and wait until it dies
+   * Interrupt the writing thread and wait until it dies.
-  public void stopWriter(long xceiverStopTimeout) throws IOException {
-    while (true) {
-      Thread thread = writer.get();
-      if ((thread == null) || (thread == Thread.currentThread()) ||
-          (!thread.isAlive())) {
-        if (writer.compareAndSet(thread, null) == true) {
-          return; // Done
-        }
-        // The writer changed.  Go back to the start of the loop and attempt to
-        // stop the new writer.
-        continue;
-      }
-      thread.interrupt();
-      try {
-        thread.join(xceiverStopTimeout);
-        if (thread.isAlive()) {
-          // Our thread join timed out.
-          final String msg = "Join on writer thread " + thread + " timed out";
-          DataNode.LOG.warn(msg + "\n" + StringUtils.getStackTrace(thread));
-          throw new IOException(msg);
-        }
-      } catch (InterruptedException e) {
-        throw new IOException("Waiting for writer thread is interrupted.");
-      }
-    }
-  }
-
-  @Override  // Object
-  public int hashCode() {
-    return super.hashCode();
-  }
-  
-  @Override // ReplicaInPipelineInterface
-  public ReplicaOutputStreams createStreams(boolean isCreate, 
-      DataChecksum requestedChecksum) throws IOException {
-    File blockFile = getBlockFile();
-    File metaFile = getMetaFile();
-    if (DataNode.LOG.isDebugEnabled()) {
-      DataNode.LOG.debug("writeTo blockfile is " + blockFile +
-                         " of size " + blockFile.length());
-      DataNode.LOG.debug("writeTo metafile is " + metaFile +
-                         " of size " + metaFile.length());
-    }
-    long blockDiskSize = 0L;
-    long crcDiskSize = 0L;
-    
-    // the checksum that should actually be used -- this
-    // may differ from requestedChecksum for appends.
-    final DataChecksum checksum;
-    
-    RandomAccessFile metaRAF = new RandomAccessFile(metaFile, "rw");
-    
-    if (!isCreate) {
-      // For append or recovery, we must enforce the existing checksum.
-      // Also, verify that the file has correct lengths, etc.
-      boolean checkedMeta = false;
-      try {
-        BlockMetadataHeader header = BlockMetadataHeader.readHeader(metaRAF);
-        checksum = header.getChecksum();
-        
-        if (checksum.getBytesPerChecksum() !=
-            requestedChecksum.getBytesPerChecksum()) {
-          throw new IOException("Client requested checksum " +
-              requestedChecksum + " when appending to an existing block " +
-              "with different chunk size: " + checksum);
-        }
-        
-        int bytesPerChunk = checksum.getBytesPerChecksum();
-        int checksumSize = checksum.getChecksumSize();
-        
-        blockDiskSize = bytesOnDisk;
-        crcDiskSize = BlockMetadataHeader.getHeaderSize() +
-          (blockDiskSize+bytesPerChunk-1)/bytesPerChunk*checksumSize;
-        if (blockDiskSize>0 && 
-            (blockDiskSize>blockFile.length() || crcDiskSize>metaFile.length())) {
-          throw new IOException("Corrupted block: " + this);
-        }
-        checkedMeta = true;
-      } finally {
-        if (!checkedMeta) {
-          // clean up in case of exceptions.
-          IOUtils.closeStream(metaRAF);
-        }
-      }
-    } else {
-      // for create, we can use the requested checksum
-      checksum = requestedChecksum;
-    }
-    
-    FileOutputStream blockOut = null;
-    FileOutputStream crcOut = null;
-    try {
-      blockOut = new FileOutputStream(
-          new RandomAccessFile( blockFile, "rw" ).getFD() );
-      crcOut = new FileOutputStream(metaRAF.getFD() );
-      if (!isCreate) {
-        blockOut.getChannel().position(blockDiskSize);
-        crcOut.getChannel().position(crcDiskSize);
-      }
-      return new ReplicaOutputStreams(blockOut, crcOut, checksum,
-          getVolume().isTransientStorage());
-    } catch (IOException e) {
-      IOUtils.closeStream(blockOut);
-      IOUtils.closeStream(metaRAF);
-      throw e;
-    }
-  }
-
-  @Override
-  public OutputStream createRestartMetaStream() throws IOException {
-    File blockFile = getBlockFile();
-    File restartMeta = new File(blockFile.getParent()  +
-        File.pathSeparator + "." + blockFile.getName() + ".restart");
-    if (restartMeta.exists() && !restartMeta.delete()) {
-      DataNode.LOG.warn("Failed to delete restart meta file: " +
-          restartMeta.getPath());
-    }
-    return new FileOutputStream(restartMeta);
-  }
-
-  @Override
-  public String toString() {
-    return super.toString()
-        + "\n  bytesAcked=" + bytesAcked
-        + "\n  bytesOnDisk=" + bytesOnDisk;
-  }
+  void stopWriter(long xceiverStopTimeout) throws IOException;

UPD43 INS31 INS31 INS31 INS31 INS31 INS31 UPD42 INS29 INS39 INS42 INS44 INS29 INS39 INS42 INS29 INS39 INS42 MOV44 INS29 MOV83 INS39 INS42 INS29 INS83 INS39 INS42 MOV44 MOV44 INS29 INS83 MOV43 INS42 INS83 MOV43 INS42 MOV44 MOV44 MOV43 MOV43 INS42 MOV43 MOV43 INS42 INS29 UPD42 MOV44 UPD66 INS65 INS65 INS39 INS42 MOV65 UPD65 MOV65 UPD65 MOV65 MOV65 INS65 MOV65 MOV65 MOV65 INS65 INS65 UPD65 UPD65 INS65 UPD65 UPD65 INS65 INS65 UPD66 MOV66 INS42 UPD66 MOV66 UPD66 UPD66 UPD66 UPD42 UPD66 UPD66 MOV66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD42 UPD66 UPD42 UPD66 UPD66 UPD42 UPD66 INS66 INS66 UPD66 UPD42 UPD66 INS66 INS42 INS66 UPD66 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL85 DEL5 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL34 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL17 DEL8 DEL31 DEL42 DEL65 DEL42 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL34 DEL17 DEL8 DEL31 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL46 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL46 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL34 DEL38 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL40 DEL41 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL52 DEL42 DEL22 DEL27 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL34 DEL7 DEL21 DEL8 DEL31 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL78 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL32 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL83 DEL9 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL42 DEL32 DEL27 DEL36 DEL42 DEL42 DEL32 DEL38 DEL36 DEL27 DEL42 DEL42 DEL42 DEL33 DEL32 DEL9 DEL27 DEL41 DEL8 DEL25 DEL18 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL40 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL32 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL40 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL45 DEL14 DEL59 DEL60 DEL42 DEL38 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL45 DEL42 DEL45 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL34 DEL27 DEL36 DEL42 DEL27 DEL42 DEL27 DEL27 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL27 DEL36 DEL27 DEL42 DEL43 DEL45 DEL52 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL45 DEL14 DEL42 DEL32 DEL14 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL42 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL40 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL40 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL48 DEL45 DEL42 DEL45 DEL42 DEL27 DEL41 DEL8 DEL31
HDFS-4446. Support file snapshots with diff lists.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1443825 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.server.namenode.INodeFile;
-
-import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.server.namenode.INodeFile;
+  /**
+   * The difference of an {@link INodeFile} between two snapshots.
+   */
+  static class FileDiff extends AbstractINodeDiff<INodeFile, FileDiff> {
+    /** The file size at snapshot creation time. */
+    final long fileSize;
+
+    FileDiff(Snapshot snapshot, INodeFile file) {
+      super(snapshot, null, null);
+      fileSize = file.computeFileSize(true, null);
+    }
+
+    @Override
+    INodeFile createSnapshotCopyOfCurrentINode(INodeFile currentINode) {
+      final INodeFile copy = new INodeFile(currentINode);
+      copy.setBlocks(null);
+      return copy;
+    }
+
+    @Override
+    void combinePosteriorAndCollectBlocks(INodeFile currentINode,
+        FileDiff posterior, BlocksMapUpdateInfo collectedBlocks) {
+      Util.collectBlocksAndClear((FileWithSnapshot)currentINode, collectedBlocks);
+    }
+    
+    @Override
+    public String toString() {
+      return super.toString() + " fileSize=" + fileSize + ", rep="
+          + (snapshotINode == null? "?": snapshotINode.getFileReplication());
+    }
+  }
+
-  
-  /** Utility methods for the classes which implement the interface. */
-  static class Util {
+  /** Is the current file deleted? */
+  public boolean isCurrentFileDeleted();
+
+  /** Are the current file and all snapshot copies deleted? */
+  public boolean isEverythingDeleted();
+
+  /** @return the max file replication in the inode and its snapshot copies. */
+  public short getMaxFileReplication();
+  
+  /** @return the max file size in the inode and its snapshot copies. */
+  public long computeMaxFileSize();
+
+  /** Utility methods for the classes which implement the interface. */
+  public static class Util {
+    /** @return the max file replication of the file in the diff list. */
+    static <N extends INodeFile, D extends AbstractINodeDiff<N, D>>
+        short getMaxFileReplication(short max,
+              final AbstractINodeDiffList<N, D> diffs) {
+      for(AbstractINodeDiff<N, D> d : diffs) {
+        if (d.snapshotINode != null) {
+          final short replication = d.snapshotINode.getFileReplication();
+          if (replication > max) {
+            max = replication;
+          }
+        }
+      }
+      return max;
+    }
+
-      short max = file.asINodeFile().getFileReplication();
+      short max = file.getMaxFileReplication();
-        final short replication = i.asINodeFile().getFileReplication();
+        final short replication = i.getMaxFileReplication();
-     * Remove the current inode from the circular linked list.
-     * any other inode, collect them and update the block list.
+     * any inode, collect them and update the block list.
-    static int collectSubtreeBlocksAndClear(final FileWithSnapshot file,
+    static void collectBlocksAndClear(final FileWithSnapshot file,
-      Preconditions.checkState(next != file, "this is the only remaining inode.");
-      // There are other inode(s) using the blocks.
-      // Compute max file size excluding this and find the last inode.
-      long max = next.asINodeFile().computeFileSize(true);
-      short maxReplication = next.asINodeFile().getFileReplication();
-      FileWithSnapshot last = next;
-      for(FileWithSnapshot i = next.getNext(); i != file; i = i.getNext()) {
-        final long size = i.asINodeFile().computeFileSize(true);
-        if (size > max) {
-          max = size;
+      // find max file size, max replication and the last inode.
+      long maxFileSize = file.computeMaxFileSize();
+      short maxReplication = file.getMaxFileReplication();
+      FileWithSnapshot last = null;
+      if (next != null && next != file) {
+        for(FileWithSnapshot i = next; i != file; i = i.getNext()) {
+          final long size = i.computeMaxFileSize();
+          if (size > maxFileSize) {
+            maxFileSize = size;
+          }
+          final short rep = i.getMaxFileReplication();
+          if (rep > maxReplication) {
+            maxReplication = rep;
+          }
+          last = i;
-        final short rep = i.asINodeFile().getFileReplication();
-        if (rep > maxReplication) {
-          maxReplication = rep;
-        }
-        last = i;
-      collectBlocksBeyondMaxAndClear(file, max, info);
-      
-      // remove this from the circular linked list.
-      last.setNext(next);
-      // Set the replication of the current INode to the max of all the other
-      // linked INodes, so that in case the current INode is retrieved from the
-      // blocksMap before it is removed or updated, the correct replication
-      // number can be retrieved.
-      file.asINodeFile().setFileReplication(maxReplication, null);
-      file.setNext(null);
-      // clear parent
-      file.asINodeFile().setParent(null);
-      return 1;
+      collectBlocksBeyondMax(file, maxFileSize, info);
+
+      if (file.isEverythingDeleted()) {
+        // Set the replication of the current INode to the max of all the other
+        // linked INodes, so that in case the current INode is retrieved from the
+        // blocksMap before it is removed or updated, the correct replication
+        // number can be retrieved.
+        if (maxReplication > 0) {
+          file.asINodeFile().setFileReplication(maxReplication, null);
+        }
+
+        // remove the file from the circular linked list.
+        if (last != null) {
+          last.setNext(next);
+        }
+        file.setNext(null);
+
+        file.asINodeFile().setBlocks(null);
+      }
-    static void collectBlocksBeyondMaxAndClear(final FileWithSnapshot file,
-            final long max, final BlocksMapUpdateInfo info) {
+    private static void collectBlocksBeyondMax(final FileWithSnapshot file,
+        final long max, final BlocksMapUpdateInfo collectedBlocks) {
-        // Replace the INode for all the remaining blocks in blocksMap
+        // collect update blocks
-        final BlocksMapINodeUpdateEntry entry = new BlocksMapINodeUpdateEntry(
-            file.asINodeFile(), next.asINodeFile());
-        if (info != null) {
+        if (next != null && next != file && file.isEverythingDeleted() && collectedBlocks != null) {
+          final BlocksMapINodeUpdateEntry entry = new BlocksMapINodeUpdateEntry(
+              file.asINodeFile(), next.asINodeFile());
-            info.addUpdateBlock(oldBlocks[i], entry);
+            collectedBlocks.addUpdateBlock(oldBlocks[i], entry);
-          for(FileWithSnapshot i = next; i != file; i = i.getNext()) {
+          
+          // set new blocks
+          file.asINodeFile().setBlocks(newBlocks);
+          for(FileWithSnapshot i = next; i != null && i != file; i = i.getNext()) {
-          if (info != null) {
+          if (collectedBlocks != null) {
-              info.addDeleteBlock(oldBlocks[n]);
+              collectedBlocks.addDeleteBlock(oldBlocks[n]);
-        file.asINodeFile().setBlocks(null);
+    
+    static String circularListString(final FileWithSnapshot file) {
+      final StringBuilder b = new StringBuilder("* -> ")
+          .append(file.asINodeFile().getObjectString());
+      FileWithSnapshot n = file.getNext();
+      for(; n != null && n != file; n = n.getNext()) {
+        b.append(" -> ").append(n.asINodeFile().getObjectString());
+      }
+      return b.append(n == null? " -> null": " -> *").toString();
+    }

MOV26 INS55 INS31 INS31 INS31 INS31 INS29 INS83 INS42 INS74 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS42 INS29 INS83 INS39 INS42 INS29 INS83 INS39 INS42 INS29 INS83 INS39 INS42 INS83 INS31 INS31 INS65 INS43 INS43 INS43 INS29 INS83 INS39 INS59 INS42 INS44 INS44 INS8 INS78 INS43 INS42 INS44 INS8 INS78 INS39 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS65 INS65 INS65 INS65 INS29 INS83 INS73 INS73 INS39 INS42 INS44 INS44 INS8 UPD39 UPD42 INS83 UPD42 INS83 INS43 INS42 INS44 INS8 INS66 INS65 INS66 INS42 INS42 INS42 INS65 INS42 INS43 INS42 INS43 INS42 INS46 INS21 INS42 INS42 INS43 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS42 INS42 INS41 INS66 INS66 INS66 INS66 INS65 INS42 INS43 INS42 INS74 INS39 INS42 INS83 INS74 INS42 INS70 INS41 INS60 INS60 INS25 INS25 UPD42 INS42 INS83 INS43 INS42 MOV60 INS60 INS24 INS41 INS42 INS66 INS42 INS42 INS42 INS33 INS33 INS7 INS42 INS83 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS32 INS27 INS66 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS44 INS42 INS8 INS42 INS39 INS59 INS8 UPD66 MOV43 INS59 INS27 INS8 INS32 INS8 INS42 INS83 INS43 INS43 INS59 INS27 INS7 INS8 INS32 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS33 INS42 INS42 INS11 INS42 INS48 INS45 INS42 INS45 INS36 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS25 INS42 INS32 INS60 INS25 UPD42 MOV42 INS33 INS27 MOV27 MOV24 UPD42 UPD42 INS42 INS42 INS25 INS25 MOV21 MOV21 INS42 UPD42 INS32 INS42 INS42 INS32 INS27 INS27 INS42 INS32 INS21 INS32 INS42 INS42 INS42 INS9 INS33 INS43 INS42 MOV43 INS42 INS42 INS16 INS43 INS43 INS43 INS27 MOV8 INS42 INS42 INS83 INS39 INS59 INS27 INS8 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 INS42 INS33 INS27 INS8 INS27 INS8 INS27 INS14 INS42 MOV32 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS16 INS42 INS27 INS45 INS32 INS42 INS42 INS42 INS40 INS33 INS42 INS32 INS42 INS42 INS21 INS43 INS42 INS34 MOV21 INS42 INS33 MOV21 INS27 INS27 MOV60 MOV21 INS43 INS45 UPD42 INS32 INS42 INS32 INS27 INS45 INS45 INS42 INS33 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS27 INS32 INS42 INS33 INS27 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS33 INS42 INS42 UPD42 INS27 INS27 INS42 INS42 UPD42 INS42 INS27 MOV27 UPD42 INS42 INS42 INS40 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 MOV33 INS42 INS42 INS42 INS33 UPD42 UPD42 UPD42 DEL40 DEL26 DEL42 DEL42 DEL32 DEL66 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL32 DEL9 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL9 DEL42 DEL32 DEL42 DEL59 DEL60 DEL34 DEL41 DEL27 DEL33 DEL39
HDFS-7035. Make adding a new data directory to the DataNode an atomic operation and improve error handling (Lei Xu via Colin P. McCabe)

+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.Maps;
+import org.apache.hadoop.classification.InterfaceStability;
-  
+
-   * {{@inheritDoc org.apache.hadoop.hdfs.server.common.Storage#writeAll()}}
+   * VolumeBuilder holds the metadata (e.g., the storage directories) of the
+   * prepared volume returned from {@link prepareVolume()}. Calling {@link build()}
+   * to add the metadata to {@link DataStorage} so that this prepared volume can
+   * be active.
-  private void writeAll(Collection<StorageDirectory> dirs) throws IOException {
-    this.layoutVersion = getServiceLayoutVersion();
-    for (StorageDirectory dir : dirs) {
-      writeProperties(dir);
+  @InterfaceAudience.Private
+  @InterfaceStability.Unstable
+  static public class VolumeBuilder {
+    private DataStorage storage;
+    /** Volume level storage directory. */
+    private StorageDirectory sd;
+    /** Mapping from block pool ID to an array of storage directories. */
+    private Map<String, List<StorageDirectory>> bpStorageDirMap =
+        Maps.newHashMap();
+
+    @VisibleForTesting
+    public VolumeBuilder(DataStorage storage, StorageDirectory sd) {
+      this.storage = storage;
+      this.sd = sd;
+
+    public final StorageDirectory getStorageDirectory() {
+      return this.sd;
+    }
+
+    private void addBpStorageDirectories(String bpid,
+        List<StorageDirectory> dirs) {
+      bpStorageDirMap.put(bpid, dirs);
+    }
+
+    /**
+     * Add loaded metadata of a data volume to {@link DataStorage}.
+     */
+    public void build() {
+      assert this.sd != null;
+      synchronized (storage) {
+        for (Map.Entry<String, List<StorageDirectory>> e :
+            bpStorageDirMap.entrySet()) {
+          final String bpid = e.getKey();
+          BlockPoolSliceStorage bpStorage = this.storage.bpStorageMap.get(bpid);
+          assert bpStorage != null;
+          for (StorageDirectory bpSd : e.getValue()) {
+            bpStorage.addStorageDir(bpSd);
+          }
+        }
+        storage.addStorageDir(sd);
+      }
+    }
+  }
+
+  private StorageDirectory loadStorageDirectory(DataNode datanode,
+      NamespaceInfo nsInfo, File dataDir, StartupOption startOpt)
+      throws IOException {
+    StorageDirectory sd = new StorageDirectory(dataDir, null, false);
+    try {
+      StorageState curState = sd.analyzeStorage(startOpt, this);
+      // sd is locked but not opened
+      switch (curState) {
+      case NORMAL:
+        break;
+      case NON_EXISTENT:
+        LOG.info("Storage directory " + dataDir + " does not exist");
+        throw new IOException("Storage directory " + dataDir
+            + " does not exist");
+      case NOT_FORMATTED: // format
+        LOG.info("Storage directory " + dataDir + " is not formatted for "
+            + nsInfo.getBlockPoolID());
+        LOG.info("Formatting ...");
+        format(sd, nsInfo, datanode.getDatanodeUuid());
+        break;
+      default:  // recovery part is common
+        sd.doRecover(curState);
+      }
+
+      // 2. Do transitions
+      // Each storage directory is treated individually.
+      // During startup some of them can upgrade or roll back
+      // while others could be up-to-date for the regular startup.
+      doTransition(datanode, sd, nsInfo, startOpt);
+
+      // 3. Update successfully loaded storage.
+      setServiceLayoutVersion(getServiceLayoutVersion());
+      writeProperties(sd);
+
+      return sd;
+    } catch (IOException ioe) {
+      sd.unlock();
+      throw ioe;
+    }
+  }
+
+  /**
+   * Prepare a storage directory. It creates a builder which can be used to add
+   * to the volume. If the volume cannot be added, it is OK to discard the
+   * builder later.
+   *
+   * @param datanode DataNode object.
+   * @param volume the root path of a storage directory.
+   * @param nsInfos an array of namespace infos.
+   * @return a VolumeBuilder that holds the metadata of this storage directory
+   * and can be added to DataStorage later.
+   * @throws IOException if encounters I/O errors.
+   *
+   * Note that if there is IOException, the state of DataStorage is not modified.
+   */
+  public VolumeBuilder prepareVolume(DataNode datanode, File volume,
+      List<NamespaceInfo> nsInfos) throws IOException {
+    if (containsStorageDir(volume)) {
+      final String errorMessage = "Storage directory is in use";
+      LOG.warn(errorMessage + ".");
+      throw new IOException(errorMessage);
+    }
+
+    StorageDirectory sd = loadStorageDirectory(
+        datanode, nsInfos.get(0), volume, StartupOption.HOTSWAP);
+    VolumeBuilder builder =
+        new VolumeBuilder(this, sd);
+    for (NamespaceInfo nsInfo : nsInfos) {
+      List<File> bpDataDirs = Lists.newArrayList();
+      bpDataDirs.add(BlockPoolSliceStorage.getBpRoot(
+          nsInfo.getBlockPoolID(), new File(volume, STORAGE_DIR_CURRENT)));
+      makeBlockPoolDataDir(bpDataDirs, null);
+
+      BlockPoolSliceStorage bpStorage;
+      final String bpid = nsInfo.getBlockPoolID();
+      synchronized (this) {
+        bpStorage = this.bpStorageMap.get(bpid);
+        if (bpStorage == null) {
+          bpStorage = new BlockPoolSliceStorage(
+              nsInfo.getNamespaceID(), bpid, nsInfo.getCTime(),
+              nsInfo.getClusterID());
+          addBlockPoolStorage(bpid, bpStorage);
+        }
+      }
+      builder.addBpStorageDirectories(
+          bpid, bpStorage.loadBpStorageDirectories(
+              datanode, nsInfo, bpDataDirs, StartupOption.HOTSWAP));
+    }
+    return builder;
+   * @return a list of successfully loaded volumes.
-  synchronized void addStorageLocations(DataNode datanode,
+  @VisibleForTesting
+  synchronized List<StorageLocation> addStorageLocations(DataNode datanode,
-      StartupOption startOpt)
-      throws IOException {
-    // Similar to recoverTransitionRead, it first ensures the datanode level
-    // format is completed.
-    List<StorageLocation> tmpDataDirs =
-        new ArrayList<StorageLocation>(dataDirs);
-    addStorageLocations(datanode, nsInfo, tmpDataDirs, startOpt, false, true);
-
-    Collection<File> bpDataDirs = new ArrayList<File>();
-    String bpid = nsInfo.getBlockPoolID();
-    for (StorageLocation dir : dataDirs) {
-      File dnRoot = dir.getFile();
-      File bpRoot = BlockPoolSliceStorage.getBpRoot(bpid, new File(dnRoot,
-          STORAGE_DIR_CURRENT));
-      bpDataDirs.add(bpRoot);
-    }
-    // mkdir for the list of BlockPoolStorage
-    makeBlockPoolDataDir(bpDataDirs, null);
-    BlockPoolSliceStorage bpStorage = this.bpStorageMap.get(bpid);
-    if (bpStorage == null) {
-      bpStorage = new BlockPoolSliceStorage(
-          nsInfo.getNamespaceID(), bpid, nsInfo.getCTime(),
-          nsInfo.getClusterID());
-    }
-
-    bpStorage.recoverTransitionRead(datanode, nsInfo, bpDataDirs, startOpt);
-    addBlockPoolStorage(bpid, bpStorage);
-  }
-
-  /**
-   * Add a list of volumes to be managed by this DataStorage. If the volume is
-   * empty, it formats the volume, otherwise it recovers it from previous
-   * transitions if required.
-   *
-   * If isInitialize is false, only the directories that have finished the
-   * doTransition() process will be added into DataStorage.
-   *
-   * @param datanode the reference to DataNode.
-   * @param nsInfo namespace information
-   * @param dataDirs array of data storage directories
-   * @param startOpt startup option
-   * @param isInitialize whether it is called when DataNode starts up.
-   * @throws IOException
-   */
-  private synchronized void addStorageLocations(DataNode datanode,
-      NamespaceInfo nsInfo, Collection<StorageLocation> dataDirs,
-      StartupOption startOpt, boolean isInitialize, boolean ignoreExistingDirs)
-      throws IOException {
-    Set<String> existingStorageDirs = new HashSet<String>();
-    for (int i = 0; i < getNumStorageDirs(); i++) {
-      existingStorageDirs.add(getStorageDir(i).getRoot().getAbsolutePath());
-    }
-
-    // 1. For each data directory calculate its state and check whether all is
-    // consistent before transitioning. Format and recover.
-    ArrayList<StorageState> dataDirStates =
-        new ArrayList<StorageState>(dataDirs.size());
-    List<StorageDirectory> addedStorageDirectories =
-        new ArrayList<StorageDirectory>();
-    for(Iterator<StorageLocation> it = dataDirs.iterator(); it.hasNext();) {
-      File dataDir = it.next().getFile();
-      if (existingStorageDirs.contains(dataDir.getAbsolutePath())) {
+      StartupOption startOpt) throws IOException {
+    final String bpid = nsInfo.getBlockPoolID();
+    List<StorageLocation> successVolumes = Lists.newArrayList();
+    for (StorageLocation dataDir : dataDirs) {
+      File root = dataDir.getFile();
+      if (!containsStorageDir(root)) {
+        try {
+          // It first ensures the datanode level format is completed.
+          StorageDirectory sd = loadStorageDirectory(
+              datanode, nsInfo, root, startOpt);
+          addStorageDir(sd);
+        } catch (IOException e) {
+          LOG.warn(e);
+          continue;
+        }
+      } else {
-        it.remove();
-        continue;
-      StorageDirectory sd = new StorageDirectory(dataDir);
-      StorageState curState;
+
+      List<File> bpDataDirs = new ArrayList<File>();
+      bpDataDirs.add(BlockPoolSliceStorage.getBpRoot(bpid, new File(root,
+              STORAGE_DIR_CURRENT)));
-        curState = sd.analyzeStorage(startOpt, this);
-        // sd is locked but not opened
-        switch (curState) {
-        case NORMAL:
-          break;
-        case NON_EXISTENT:
-          // ignore this storage
-          LOG.info("Storage directory " + dataDir + " does not exist");
-          it.remove();
-          continue;
-        case NOT_FORMATTED: // format
-          LOG.info("Storage directory " + dataDir + " is not formatted for "
-            + nsInfo.getBlockPoolID());
-          LOG.info("Formatting ...");
-          format(sd, nsInfo, datanode.getDatanodeUuid());
-          break;
-        default:  // recovery part is common
-          sd.doRecover(curState);
+        makeBlockPoolDataDir(bpDataDirs, null);
+        BlockPoolSliceStorage bpStorage = this.bpStorageMap.get(bpid);
+        if (bpStorage == null) {
+          bpStorage = new BlockPoolSliceStorage(
+              nsInfo.getNamespaceID(), bpid, nsInfo.getCTime(),
+              nsInfo.getClusterID());
-      } catch (IOException ioe) {
-        sd.unlock();
-        LOG.warn("Ignoring storage directory " + dataDir
-            + " due to an exception", ioe);
-        //continue with other good dirs
-        continue;
-      }
-      if (isInitialize) {
-        addStorageDir(sd);
-      }
-      addedStorageDirectories.add(sd);
-      dataDirStates.add(curState);
-    }
-    if (dataDirs.size() == 0 || dataDirStates.size() == 0) {
-      // none of the data dirs exist
-      if (ignoreExistingDirs) {
-        return;
-      }
-      throw new IOException(
-          "All specified directories are not accessible or do not exist.");
-    }
-
-    // 2. Do transitions
-    // Each storage directory is treated individually.
-    // During startup some of them can upgrade or rollback
-    // while others could be up-to-date for the regular startup.
-    for (Iterator<StorageDirectory> it = addedStorageDirectories.iterator();
-        it.hasNext(); ) {
-      StorageDirectory sd = it.next();
-      try {
-        doTransition(datanode, sd, nsInfo, startOpt);
-        createStorageID(sd);
+        bpStorage.recoverTransitionRead(datanode, nsInfo, bpDataDirs, startOpt);
+        addBlockPoolStorage(bpid, bpStorage);
-        if (!isInitialize) {
-          sd.unlock();
-          it.remove();
-          continue;
-        }
-        unlockAll();
-        throw e;
+        LOG.warn("Failed to add storage for block pool: " + bpid + " : "
+            + e.getMessage());
+        continue;
+      successVolumes.add(dataDir);
-
-    // 3. Update all successfully loaded storages. Some of them might have just
-    // been formatted.
-    this.writeAll(addedStorageDirectories);
-
-    // 4. Make newly loaded storage directories visible for service.
-    if (!isInitialize) {
-      this.storageDirs.addAll(addedStorageDirectories);
-    }
+    return successVolumes;
-   * Remove volumes from DataStorage.
+   * Remove volumes from DataStorage. All volumes are removed even when the
+   * IOException is thrown.
+   *
+   * @throws IOException if I/O error when unlocking storage directory.
-  synchronized void removeVolumes(Collection<StorageLocation> locations) {
+  synchronized void removeVolumes(Collection<StorageLocation> locations)
+      throws IOException {
+    StringBuilder errorMsgBuilder = new StringBuilder();
+          errorMsgBuilder.append(String.format("Failed to remove %s: %s\n",
+              sd.getRoot(), e.getMessage()));
+    if (errorMsgBuilder.length() > 0) {
+      throw new IOException(errorMsgBuilder.toString());
+    }
-   * Analyze storage directories.
+   * Analyze storage directories for a specific block pool.
-   * @param nsInfo namespace information
-   * @param dataDirs array of data storage directories
-   * @param startOpt startup option
-   * @throws IOException
-   */
-  synchronized void recoverTransitionRead(DataNode datanode,
-      NamespaceInfo nsInfo, Collection<StorageLocation> dataDirs,
-      StartupOption startOpt)
-      throws IOException {
-    if (initialized) {
-      // DN storage has been initialized, no need to do anything
-      return;
-    }
-    LOG.info("DataNode version: " + HdfsConstants.DATANODE_LAYOUT_VERSION
-        + " and NameNode layout version: " + nsInfo.getLayoutVersion());
-
-    this.storageDirs = new ArrayList<StorageDirectory>(dataDirs.size());
-    addStorageLocations(datanode, nsInfo, dataDirs, startOpt, true, false);
-    
-    // mark DN storage is initialized
-    this.initialized = true;
-  }
-
-  /**
-   * recoverTransitionRead for a specific block pool
-   * 
-   * @param bpID Block pool Id
-  void recoverTransitionRead(DataNode datanode, String bpID, NamespaceInfo nsInfo,
+  void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo,
-    // First ensure datanode level format/snapshot/rollback is completed
-    recoverTransitionRead(datanode, nsInfo, dataDirs, startOpt);
-
-    // Create list of storage directories for the block pool
-    Collection<File> bpDataDirs = new ArrayList<File>();
-    for(StorageLocation dir : dataDirs) {
-      File dnRoot = dir.getFile();
-      File bpRoot = BlockPoolSliceStorage.getBpRoot(bpID, new File(dnRoot,
-          STORAGE_DIR_CURRENT));
-      bpDataDirs.add(bpRoot);
+    if (this.initialized) {
+      LOG.info("DataNode version: " + HdfsConstants.DATANODE_LAYOUT_VERSION
+          + " and NameNode layout version: " + nsInfo.getLayoutVersion());
+      this.storageDirs = new ArrayList<StorageDirectory>(dataDirs.size());
+      // mark DN storage is initialized
+      this.initialized = true;
-    // mkdir for the list of BlockPoolStorage
-    makeBlockPoolDataDir(bpDataDirs, null);
-    BlockPoolSliceStorage bpStorage = new BlockPoolSliceStorage(
-        nsInfo.getNamespaceID(), bpID, nsInfo.getCTime(), nsInfo.getClusterID());
-    
-    bpStorage.recoverTransitionRead(datanode, nsInfo, bpDataDirs, startOpt);
-    addBlockPoolStorage(bpID, bpStorage);
+    if (addStorageLocations(datanode, nsInfo, dataDirs, startOpt).isEmpty()) {
+      throw new IOException("All specified directories are failed to load.");
+    }
-    if (this.layoutVersion == HdfsConstants.DATANODE_LAYOUT_VERSION)
+    if (this.layoutVersion == HdfsConstants.DATANODE_LAYOUT_VERSION) {
+      createStorageID(sd);
+    }
+      createStorageID(sd);

INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS55 INS31 INS29 INS78 INS78 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS83 MOV43 INS42 MOV44 MOV44 INS44 MOV44 MOV43 MOV8 INS83 INS43 INS42 INS44 INS8 INS78 INS74 INS8 MOV43 INS8 MOV65 INS40 INS40 INS83 INS43 INS59 INS29 INS83 MOV43 INS59 INS29 INS83 INS74 INS59 INS78 INS83 INS42 INS44 INS44 INS8 INS83 INS83 MOV43 INS42 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS8 MOV43 INS42 INS60 UPD65 UPD42 MOV42 MOV43 INS42 UPD74 UPD42 INS25 INS60 MOV60 INS70 INS41 INS65 INS42 INS43 INS43 INS60 INS60 INS70 INS41 INS65 INS60 INS25 INS65 MOV65 INS25 INS25 UPD66 INS66 INS65 INS66 UPD65 UPD66 INS65 INS66 INS66 UPD42 MOV42 INS42 UPD65 MOV65 INS42 UPD65 MOV65 UPD43 MOV43 UPD43 MOV43 INS74 INS42 INS32 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS41 MOV43 INS42 MOV74 INS42 INS21 INS65 INS6 INS51 INS43 MOV59 UPD66 INS66 INS66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD66 INS66 UPD66 INS66 UPD43 UPD43 INS32 INS8 MOV43 INS59 INS43 MOV44 UPD42 MOV42 INS8 INS42 INS66 INS42 INS42 INS83 MOV43 INS59 MOV74 INS59 INS44 INS42 INS8 INS42 UPD66 INS66 INS42 INS66 INS43 INS59 INS27 INS8 UPD66 INS42 INS66 UPD66 MOV42 UPD66 INS66 INS22 MOV8 INS32 INS8 INS8 INS66 UPD66 INS42 UPD66 UPD66 UPD42 UPD42 UPD43 MOV43 UPD43 MOV43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS7 INS7 INS22 INS32 INS66 INS65 INS66 INS27 INS42 INS8 INS42 INS60 MOV21 INS21 INS21 INS41 UPD42 UPD42 INS42 INS42 INS60 INS21 MOV53 INS42 INS32 UPD42 MOV42 UPD42 MOV60 INS21 MOV21 INS60 MOV60 INS51 MOV21 INS42 INS42 INS32 INS42 INS32 MOV43 INS42 INS60 INS25 INS60 INS21 INS54 INS21 INS42 INS42 INS14 INS32 INS34 INS53 INS52 INS42 INS32 INS42 INS53 INS21 INS41 MOV21 UPD42 UPD42 INS22 INS42 INS22 INS42 INS52 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS22 INS33 INS70 MOV21 MOV43 INS33 INS9 MOV43 INS59 INS53 INS32 INS32 INS42 INS53 INS83 MOV43 INS59 INS32 UPD42 MOV42 MOV42 INS32 UPD42 MOV42 INS40 INS43 INS52 INS42 UPD74 MOV74 INS32 MOV43 INS59 INS83 INS43 INS52 INS8 INS42 INS42 INS42 INS42 MOV43 INS59 INS38 INS8 INS8 INS74 INS59 INS32 MOV8 INS12 INS32 INS43 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS14 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS44 INS32 INS8 INS42 MOV32 INS14 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS27 INS42 UPD42 MOV42 UPD42 MOV42 INS34 UPD42 MOV42 UPD43 UPD42 INS42 INS42 INS32 INS42 INS42 MOV21 INS25 INS42 UPD42 UPD42 INS32 INS42 INS32 INS32 INS54 MOV21 INS43 MOV43 INS42 INS14 INS42 INS42 INS32 INS44 INS8 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS45 INS42 INS42 INS74 INS42 UPD42 MOV42 UPD42 MOV42 MOV60 INS60 INS6 INS70 UPD42 UPD42 INS42 INS43 INS27 INS42 INS45 UPD42 UPD42 UPD42 MOV42 MOV42 INS32 MOV14 INS7 INS27 INS8 MOV42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS8 INS12 INS42 MOV74 INS42 INS42 INS42 INS14 INS43 INS42 INS21 INS18 INS42 INS42 INS42 INS42 INS43 UPD43 MOV43 INS74 INS83 MOV43 INS43 INS59 INS27 MOV44 INS32 INS8 INS42 INS45 INS42 INS45 INS42 UPD42 MOV42 MOV43 INS42 INS42 INS32 INS42 INS33 INS21 MOV21 INS60 MOV21 MOV44 INS8 MOV43 INS42 INS42 INS42 INS32 INS40 UPD42 INS43 INS43 UPD42 INS42 INS42 INS32 INS42 INS33 UPD42 UPD42 MOV42 UPD42 MOV42 MOV21 INS22 UPD42 MOV42 UPD42 MOV42 INS7 INS43 INS59 INS21 INS18 INS42 INS42 INS42 INS27 INS21 INS42 INS42 UPD42 UPD42 INS22 UPD42 MOV42 INS42 INS52 INS42 INS42 MOV14 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS32 INS45 INS42 INS45 INS32 INS32 INS22 INS42 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL43 DEL52 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL21 DEL18 DEL8 DEL25 DEL60 DEL42 DEL59 DEL60 DEL42 DEL7 DEL42 DEL42 DEL32 DEL21 DEL18 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL42 DEL32 DEL21 DEL18 DEL42 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL45 DEL43 DEL74 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL44 DEL42 DEL32 DEL59 DEL60 DEL8 DEL70 DEL42 DEL59 DEL60 DEL8 DEL29 DEL83 DEL39 DEL42 DEL43 DEL74 DEL42 DEL44 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL74 DEL42 DEL74 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL43 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL24 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL25 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL8 DEL42 DEL38 DEL32 DEL21 DEL18 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL24 DEL42 DEL38 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL21 DEL41
YARN-8015. Support all types of placement constraint support for Capacity Scheduler. Contributed by Weiwei Yang.

-import com.google.common.collect.ImmutableSet;
-import org.apache.hadoop.util.StringUtils;
-import org.apache.hadoop.yarn.api.resource.PlacementConstraints;
-import java.util.HashSet;
+import static org.apache.hadoop.yarn.api.resource.PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE;
-  private Set<String> targetAllocationTags;
-    // Node partition
-    String nodePartition = null;
-    // Target allocation tags
-    Set<String> targetAllocationTags = null;
-
-    PlacementConstraint constraint =
-        newSchedulingRequest.getPlacementConstraint();
-
-    if (constraint != null) {
-      // We only accept SingleConstraint
-      PlacementConstraint.AbstractConstraint ac = constraint
-          .getConstraintExpr();
-      if (!(ac instanceof PlacementConstraint.SingleConstraint)) {
-        throwExceptionWithMetaInfo("Only accepts "
-            + PlacementConstraint.SingleConstraint.class.getName()
-                + " as constraint-expression. Rejecting the new added "
-            + "constraint-expression.class=" + ac.getClass().getName());
-      }
-
-      PlacementConstraint.SingleConstraint singleConstraint =
-          (PlacementConstraint.SingleConstraint) ac;
-
-      // Make sure it is an anti-affinity request (actually this implementation
-      // should be able to support both affinity / anti-affinity without much
-      // effort. Considering potential test effort required. Limit to
-      // anti-affinity to intra-app and scope is node.
-      if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {
-        throwExceptionWithMetaInfo(
-            "Only support scope=" + PlacementConstraints.NODE
-                + "now. PlacementConstraint=" + singleConstraint);
-      }
-
-      if (singleConstraint.getMinCardinality() != 0
-          || singleConstraint.getMaxCardinality() != 0) {
-        throwExceptionWithMetaInfo(
-            "Only support anti-affinity, which is: minCardinality=0, "
-                + "maxCardinality=1");
-      }
-
-      Set<PlacementConstraint.TargetExpression> targetExpressionSet =
-          singleConstraint.getTargetExpressions();
-      if (targetExpressionSet == null || targetExpressionSet.isEmpty()) {
-        throwExceptionWithMetaInfo(
-            "TargetExpression should not be null or empty");
-      }
-
-      for (PlacementConstraint.TargetExpression targetExpression :
-          targetExpressionSet) {
-        // Handle node partition
-        if (targetExpression.getTargetType().equals(
-            PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {
-          // For node attribute target, we only support Partition now. And once
-          // YARN-3409 is merged, we will support node attribute.
-          if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {
-            throwExceptionWithMetaInfo("When TargetType="
-                + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE
-                + " only " + NODE_PARTITION + " is accepted as TargetKey.");
-          }
-
-          if (nodePartition != null) {
-            // This means we have duplicated node partition entry
-            // inside placement constraint, which might be set by mistake.
-            throwExceptionWithMetaInfo(
-                "Only one node partition targetExpression is allowed");
-          }
-
-          Set<String> values = targetExpression.getTargetValues();
-          if (values == null || values.isEmpty()) {
-            nodePartition = RMNodeLabelsManager.NO_LABEL;
-            continue;
-          }
-
-          if (values.size() > 1) {
-            throwExceptionWithMetaInfo("Inside one targetExpression, we only "
-                + "support affinity to at most one node partition now");
-          }
-
-          nodePartition = values.iterator().next();
-        } else if (targetExpression.getTargetType().equals(
-            PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {
-          // Handle allocation tags
-          if (targetAllocationTags != null) {
-            // This means we have duplicated AllocationTag expressions entries
-            // inside placement constraint, which might be set by mistake.
-            throwExceptionWithMetaInfo(
-                "Only one AllocationTag targetExpression is allowed");
-          }
-
-          if (targetExpression.getTargetValues() == null ||
-              targetExpression.getTargetValues().isEmpty()) {
-            throwExceptionWithMetaInfo("Failed to find allocation tags from "
-                + "TargetExpressions or couldn't find self-app target.");
-          }
-
-          targetAllocationTags = new HashSet<>(
-              targetExpression.getTargetValues());
-        }
-      }
-
-      if (targetAllocationTags == null) {
-        // That means we don't have ALLOCATION_TAG specified
-        throwExceptionWithMetaInfo(
-            "Couldn't find target expression with type == ALLOCATION_TAG,"
-                + " it is required to include one and only one target"
-                + " expression with type == ALLOCATION_TAG");
-      }
-    }
-
-    // If this scheduling request doesn't contain a placement constraint,
-    // we set allocation tags an empty set.
-    if (targetAllocationTags == null) {
-      targetAllocationTags = ImmutableSet.of();
-    }
-
-    if (nodePartition == null) {
-      nodePartition = RMNodeLabelsManager.NO_LABEL;
-    }
-
-    // Validation is done. set local results:
-    this.targetNodePartition = nodePartition;
-    this.targetAllocationTags = targetAllocationTags;
-
+    this.targetNodePartition = validateAndGetTargetNodePartition(
+        newSchedulingRequest.getPlacementConstraint());
-    LOG.info("Successfully added SchedulingRequest to app=" + appSchedulingInfo
-        .getApplicationAttemptId() + " targetAllocationTags=[" + StringUtils
-        .join(",", targetAllocationTags) + "]. nodePartition="
-        + targetNodePartition);
+
+    LOG.info("Successfully added SchedulingRequest to app="
+        + appSchedulingInfo.getApplicationAttemptId()
+        + " placementConstraint=["
+        + schedulingRequest.getPlacementConstraint()
+        + "]. nodePartition=" + targetNodePartition);
+  }
+
+  // Tentatively find out potential exist node-partition in the placement
+  // constraint and set as the app's primary node-partition.
+  // Currently only single constraint is handled.
+  private String validateAndGetTargetNodePartition(
+      PlacementConstraint placementConstraint) {
+    String nodePartition = RMNodeLabelsManager.NO_LABEL;
+    if (placementConstraint != null &&
+        placementConstraint.getConstraintExpr() != null) {
+      PlacementConstraint.AbstractConstraint ac =
+          placementConstraint.getConstraintExpr();
+      if (ac != null && ac instanceof PlacementConstraint.SingleConstraint) {
+        PlacementConstraint.SingleConstraint singleConstraint =
+            (PlacementConstraint.SingleConstraint) ac;
+        for (PlacementConstraint.TargetExpression targetExpression :
+            singleConstraint.getTargetExpressions()) {
+          // Handle node partition
+          if (targetExpression.getTargetType().equals(NODE_ATTRIBUTE) &&
+              targetExpression.getTargetKey().equals(NODE_PARTITION)) {
+            Set<String> values = targetExpression.getTargetValues();
+            if (values == null || values.isEmpty()) {
+              continue;
+            }
+            if (values.size() > 1) {
+              throwExceptionWithMetaInfo(
+                  "Inside one targetExpression, we only support"
+                      + " affinity to at most one node partition now");
+            }
+            nodePartition = values.iterator().next();
+            if (nodePartition != null) {
+              break;
+            }
+          }
+        }
+      }
+    }
+    return nodePartition;
-  @VisibleForTesting
-  Set<String> getTargetAllocationTags() {
-    return targetAllocationTags;
-  }
-

MOV26 MOV31 UPD40 INS83 MOV43 UPD42 INS44 MOV8 MOV43 INS42 INS41 MOV43 UPD27 MOV8 INS42 INS32 UPD42 INS40 INS60 INS42 MOV32 UPD45 INS42 INS33 INS33 MOV43 INS59 UPD27 MOV27 MOV8 UPD42 UPD42 UPD42 UPD42 INS42 INS32 UPD27 MOV62 MOV60 INS70 INS42 INS42 INS42 MOV44 MOV32 MOV8 INS25 INS27 INS8 MOV32 MOV32 MOV60 MOV25 MOV25 MOV21 MOV25 INS42 INS10 UPD45 UPD45 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL74 DEL42 DEL33 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL45 DEL42 DEL78 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL36 DEL38 DEL42 DEL45 DEL40 DEL43 DEL57 DEL42 DEL32 DEL45 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL42 DEL45 DEL40 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL34 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL40 DEL42 DEL40 DEL7 DEL21 DEL42 DEL45 DEL32 DEL21 DEL38 DEL42 DEL45 DEL40 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL33 DEL27 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL42 DEL43 DEL40 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL70 DEL42 DEL33 DEL27 DEL42 DEL45 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8
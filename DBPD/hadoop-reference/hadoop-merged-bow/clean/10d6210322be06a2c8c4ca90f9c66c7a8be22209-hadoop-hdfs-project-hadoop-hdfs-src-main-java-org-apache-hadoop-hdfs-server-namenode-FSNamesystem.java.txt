Merge r1609845 through r1614231 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1614234 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_RANDOMIZE_BLOCK_LOCATIONS_PER_BLOCK;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_RANDOMIZE_BLOCK_LOCATIONS_PER_BLOCK_DEFAULT;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_RANDOMIZE_BLOCK_LOCATIONS_PER_BLOCK;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_RANDOMIZE_BLOCK_LOCATIONS_PER_BLOCK_DEFAULT;
-
+import org.apache.hadoop.hdfs.server.protocol.DatanodeStorageReport;
+    byte[][] pathComponents = FSDirectory.getPathComponentsForReservedPath(src);
+      src = FSDirectory.resolvePath(src, pathComponents, dir);
+  DatanodeStorageReport[] getDatanodeStorageReport(final DatanodeReportType type
+      ) throws AccessControlException, StandbyException {
+    checkSuperuserPrivilege();
+    checkOperation(OperationCategory.UNCHECKED);
+    readLock();
+    try {
+      checkOperation(OperationCategory.UNCHECKED);
+      final DatanodeManager dm = getBlockManager().getDatanodeManager();      
+      final List<DatanodeDescriptor> datanodes = dm.getDatanodeListForReport(type);
+
+      DatanodeStorageReport[] reports = new DatanodeStorageReport[datanodes.size()];
+      for (int i = 0; i < reports.length; i++) {
+        final DatanodeDescriptor d = datanodes.get(i);
+        reports[i] = new DatanodeStorageReport(new DatanodeInfo(d),
+            d.getStorageReports());
+      }
+      return reports;
+    } finally {
+      readUnlock();
+    }
+  }
+
+    byte[][] pathComponents = FSDirectory.getPathComponentsForReservedPath(src);
+      src = FSDirectory.resolvePath(src, pathComponents, dir);
-    List<XAttr> filteredXAttrs = null;
-      filteredXAttrs = XAttrPermissionFilter.filterXAttrsForApi(pc, xAttrs);
-      if (filteredXAttrs.isEmpty()) {
-        return filteredXAttrs;
+      try {
+        XAttrPermissionFilter.checkPermissionForApi(pc, xAttrs);
+      } catch (AccessControlException e) {
+        logAuditEvent(false, "getXAttrs", src);
+        throw e;
+    byte[][] pathComponents = FSDirectory.getPathComponentsForReservedPath(src);
+      src = FSDirectory.resolvePath(src, pathComponents, dir);
-        List<XAttr> toGet = Lists.newArrayListWithCapacity(filteredXAttrs.size());
-        for (XAttr xAttr : filteredXAttrs) {
+        List<XAttr> toGet = Lists.newArrayListWithCapacity(xAttrs.size());
+        for (XAttr xAttr : xAttrs) {
+          boolean foundIt = false;
+              foundIt = true;
+          if (!foundIt) {
+            throw new IOException(
+                "At least one of the attributes provided was not found.");
+          }
+    byte[][] pathComponents = FSDirectory.getPathComponentsForReservedPath(src);
+      src = FSDirectory.resolvePath(src, pathComponents, dir);
-  
+
+  /**
+   * Remove an xattr for a file or directory.
+   *
+   * @param src
+   *          - path to remove the xattr from
+   * @param xAttr
+   *          - xAttr to remove
+   * @throws AccessControlException
+   * @throws SafeModeException
+   * @throws UnresolvedLinkException
+   * @throws IOException
+   */
-    nnConf.checkXAttrsConfigFlag();
-    HdfsFileStatus resultingStat = null;
-    FSPermissionChecker pc = getPermissionChecker();
+    CacheEntry cacheEntry = RetryCache.waitForCompletion(retryCache);
+    if (cacheEntry != null && cacheEntry.isSuccess()) {
+      return; // Return previous response
+    }
+    boolean success = false;
-      XAttrPermissionFilter.checkPermissionForApi(pc, xAttr);
+      removeXAttrInt(src, xAttr, cacheEntry != null);
+      success = true;
+    } finally {
+      RetryCache.setState(cacheEntry, success);
+  }
+
+  void removeXAttrInt(String src, XAttr xAttr, boolean logRetryCache)
+      throws IOException {
+    nnConf.checkXAttrsConfigFlag();
+    HdfsFileStatus resultingStat = null;
+    FSPermissionChecker pc = getPermissionChecker();
+      XAttrPermissionFilter.checkPermissionForApi(pc, xAttr);
-        getEditLog().logRemoveXAttrs(src, removedXAttrs);
+        getEditLog().logRemoveXAttrs(src, removedXAttrs, logRetryCache);
+      } else {
+        throw new IOException(
+            "No matching attributes found for remove operation");
-    } catch (AccessControlException e) {
-      logAuditEvent(false, "removeXAttr", src);
-      throw e;

MOV26 MOV26 INS26 INS40 INS31 INS31 INS5 INS42 INS44 INS43 INS43 INS8 INS29 INS39 INS42 INS44 INS44 INS43 INS8 UPD42 INS44 INS60 INS43 INS85 INS83 INS43 INS42 INS42 INS42 INS21 INS21 INS21 INS54 INS60 INS60 INS60 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS25 INS60 INS54 INS39 INS42 MOV21 INS5 INS59 INS42 INS42 INS32 INS32 INS32 INS8 INS8 INS5 INS59 INS5 INS59 INS5 INS59 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS39 INS59 INS8 MOV12 INS8 INS39 INS85 INS85 INS42 INS32 INS21 INS42 INS42 INS40 INS42 INS21 INS60 INS60 INS60 INS24 INS41 INS21 INS39 INS85 INS85 INS42 INS32 INS21 INS54 INS39 INS85 INS85 INS42 INS32 INS21 INS39 INS85 INS85 INS42 INS32 INS21 INS42 INS42 INS32 INS27 INS32 INS41 INS42 INS9 INS21 INS21 INS21 INS42 INS42 INS42 INS7 INS32 INS83 INS43 INS59 INS83 INS74 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS32 INS42 INS42 INS42 INS7 INS8 INS12 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS32 INS7 INS32 INS8 INS42 INS32 INS42 INS40 INS42 INS42 INS32 INS43 INS43 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS60 INS21 INS42 INS42 INS32 MOV21 INS44 INS8 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS9 INS42 INS42 INS42 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS32 INS42 INS34 INS83 INS43 INS59 INS7 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS53 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS14 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS32 INS2 INS14 MOV42 UPD42 MOV42 MOV42 MOV42 INS42 INS32 INS42 INS60 INS25 INS42 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS14 INS32 UPD42 MOV42 INS9 INS45 UPD42 MOV42 INS39 INS59 INS38 INS8 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 INS42 INS9 INS42 INS53 INS42 INS14 INS21 INS43 INS45 INS7 INS42 INS42 INS9 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL33 DEL59 DEL60 DEL42 DEL32 DEL7 DEL32 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL45 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54
HDFS-5920. Support rollback of rolling upgrade in NameNode and JournalNodes. Contributed by Jing Zhao.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1568563 13f79535-47bb-0310-9956-ffa450edef68

-    final NameNodeFile nnf;
-    if (startOpt == StartupOption.ROLLINGUPGRADE
-        && startOpt.getRollingUpgradeStartupOption()
-              == RollingUpgradeStartupOption.ROLLBACK) {
-      nnf = NameNodeFile.IMAGE_ROLLBACK;
-    } else {
-      nnf = NameNodeFile.IMAGE; 
-    }
+    final boolean rollingRollback = startOpt == StartupOption.ROLLINGUPGRADE
+        && startOpt.getRollingUpgradeStartupOption() == 
+           RollingUpgradeStartupOption.ROLLBACK;
+    final NameNodeFile nnf = rollingRollback ? NameNodeFile.IMAGE_ROLLBACK
+        : NameNodeFile.IMAGE;
- 
-      long toAtLeastTxId = editLog.isOpenForWrite() ? inspector.getMaxSeenTxId() : 0;
+      // In the meanwhile, for HA upgrade, we will still write editlog thus need
+      // this toAtLeastTxId to be set to the max-seen txid
+      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to
+      // the txid right before the upgrade marker.  
+      long toAtLeastTxId = editLog.isOpenForWrite() ? inspector
+          .getMaxSeenTxId() : 0;
+      if (rollingRollback) {
+        // note that the first image in imageFiles is the special checkpoint
+        // for the rolling upgrade
+        toAtLeastTxId = imageFiles.get(0).getCheckpointTxId() + 2;
+      }
-    int maxOpSize = conf.getInt(DFSConfigKeys.
-          DFS_NAMENODE_MAX_OP_SIZE_KEY,
+    int maxOpSize = conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,
-    long txnsAdvanced = loadEdits(editStreams, target, startOpt, recovery);
-    needToSave |= needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),
-                                                    txnsAdvanced);
+    long txnsAdvanced = 0;
+    
+    loadEdits(editStreams, target, startOpt, recovery);
+    if (rollingRollback) {
+      // Trigger the rollback for rolling upgrade. 
+      // Here lastAppliedTxId == (markerTxId - 1), and we should decrease 1 from
+      // lastAppliedTxId for the start-segment transaction.
+      rollingRollback(lastAppliedTxId--, imageFiles.get(0).getCheckpointTxId());
+      needToSave = false;
+    } else {
+      needToSave |= needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),
+          txnsAdvanced);
+    }
+  /** rollback for rolling upgrade. */
+  private void rollingRollback(long discardSegmentTxId, long ckptId)
+      throws IOException {
+    // discard discard unnecessary editlog segments starting from the given id
+    this.editLog.discardSegments(discardSegmentTxId);
+    // rename the special checkpoint
+    renameCheckpoint(ckptId, NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);
+    // purge all the checkpoints after the marker
+    archivalManager.purgeCheckpoinsAfter(NameNodeFile.IMAGE, ckptId);
+  }
+
-          throws IOException {
+      throws IOException {
+        boolean rollingRollback = startOpt == StartupOption.ROLLINGUPGRADE && 
+            startOpt.getRollingUpgradeStartupOption() == 
+            RollingUpgradeStartupOption.ROLLBACK;
-        if (editIn.getLastTxId() != HdfsConstants.INVALID_TXID) {
+        if (editIn.getLastTxId() != HdfsConstants.INVALID_TXID
+            && !rollingRollback) {
-      updateCountForQuota(target.dir.rootDir);   
+      updateCountForQuota(target.dir.rootDir);
-  void saveFSImage(SaveNamespaceContext context, StorageDirectory sd)
-      throws IOException {
+  void saveFSImage(SaveNamespaceContext context, StorageDirectory sd,
+      NameNodeFile dstType) throws IOException {
-    File dstFile = NNStorage.getStorageFile(sd, NameNodeFile.IMAGE, txid);
+    File dstFile = NNStorage.getStorageFile(sd, dstType, txid);
+    private final NameNodeFile nnf;
-    public FSImageSaver(SaveNamespaceContext context, StorageDirectory sd) {
+    public FSImageSaver(SaveNamespaceContext context, StorageDirectory sd,
+        NameNodeFile nnf) {
+      this.nnf = nnf;
-        saveFSImage(context, sd);
+        saveFSImage(context, sd, nnf);
-        FSImageSaver saver = new FSImageSaver(ctx, sd);
+        FSImageSaver saver = new FSImageSaver(ctx, sd, nnf);

INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS44 INS23 INS60 INS21 INS25 INS65 INS39 INS42 INS39 INS42 INS42 INS21 INS21 INS21 INS43 INS42 INS83 INS83 MOV43 MOV59 INS44 INS39 INS59 INS83 INS43 INS59 MOV32 INS42 INS8 INS8 INS66 INS32 INS32 INS32 INS42 INS43 INS42 INS21 INS42 MOV27 INS42 INS42 INS16 INS25 INS34 INS21 INS21 MOV21 INS22 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS42 INS42 INS7 INS42 INS40 INS40 INS42 INS8 INS32 INS7 INS52 INS42 INS42 INS22 INS42 INS21 INS42 INS37 INS32 INS42 INS9 INS60 INS52 INS42 INS7 INS42 INS32 INS42 INS39 INS59 INS27 INS42 MOV43 INS42 INS27 INS42 INS42 INS34 INS42 INS27 MOV27 INS38 INS32 INS34 INS27 INS27 INS42 MOV43 INS42 INS32 INS42 INS42 INS40 INS32 INS40 INS42 INS42 INS34 INS42 INS42 DEL42 DEL40 DEL7 DEL21 DEL8 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL40
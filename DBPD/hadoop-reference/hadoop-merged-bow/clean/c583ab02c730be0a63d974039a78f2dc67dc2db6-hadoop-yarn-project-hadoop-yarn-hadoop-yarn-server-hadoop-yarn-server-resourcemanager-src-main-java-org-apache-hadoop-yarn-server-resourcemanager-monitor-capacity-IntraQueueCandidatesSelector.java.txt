YARN-2113. Add cross-user preemption within CapacityScheduler's leaf-queue. (Sunil G via wangda)

Change-Id: I9b19f69788068be05b3295247cdd7b972f8a573c

+import org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.ProportionalCapacityPreemptionPolicy.IntraQueuePreemptionOrderPolicy;
+import java.util.Collection;
-import java.util.Iterator;
+import java.util.HashMap;
-    public int compare(TempAppPerPartition tq1, TempAppPerPartition tq2) {
-      Priority p1 = Priority.newInstance(tq1.getPriority());
-      Priority p2 = Priority.newInstance(tq2.getPriority());
+    public int compare(TempAppPerPartition ta1, TempAppPerPartition ta2) {
+      Priority p1 = Priority.newInstance(ta1.getPriority());
+      Priority p2 = Priority.newInstance(ta2.getPriority());
-      return tq1.getApplicationId().compareTo(tq2.getApplicationId());
+      return ta1.getApplicationId().compareTo(ta2.getApplicationId());
-        // 6. Based on the selected resource demand per partition, select
+        // Default preemption iterator considers only FIFO+priority. For
+        // userlimit preemption, its possible that some lower priority apps
+        // needs from high priority app of another user. Hence use apps
+        // ordered by userlimit starvation as well.
+        Collection<FiCaSchedulerApp> apps = fifoPreemptionComputePlugin
+            .getPreemptableApps(queueName, partition);
+
+        // 6. Get user-limit to ensure that we do not preempt resources which
+        // will force user's resource to come under its UL.
+        Map<String, Resource> rollingResourceUsagePerUser = new HashMap<>();
+        initializeUsageAndUserLimitForCompute(clusterResource, partition,
+            leafQueue, rollingResourceUsagePerUser);
+
+        // 7. Based on the selected resource demand per partition, select
-          Iterator<FiCaSchedulerApp> desc = leafQueue.getOrderingPolicy()
-              .getPreemptionIterator();
-          while (desc.hasNext()) {
-            FiCaSchedulerApp app = desc.next();
-            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,
-                totalPreemptedResourceAllowed, resToObtainByPartition,
-                leafQueue, app);
+          for (FiCaSchedulerApp app : apps) {
+            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,
+                clusterResource, totalPreemptedResourceAllowed,
+                resToObtainByPartition, rollingResourceUsagePerUser);
-  private void preemptFromLeastStarvedApp(
+  private void initializeUsageAndUserLimitForCompute(Resource clusterResource,
+      String partition, LeafQueue leafQueue,
+      Map<String, Resource> rollingResourceUsagePerUser) {
+    for (String user : leafQueue.getAllUsers()) {
+      // Initialize used resource of a given user for rolling computation.
+      rollingResourceUsagePerUser.put(user, Resources.clone(
+          leafQueue.getUser(user).getResourceUsage().getUsed(partition)));
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Rolling resource usage for user:" + user + " is : "
+            + rollingResourceUsagePerUser.get(user));
+      }
+    }
+  }
+
+  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,
+      FiCaSchedulerApp app,
-      Map<String, Resource> resToObtainByPartition, LeafQueue leafQueue,
-      FiCaSchedulerApp app) {
+      Map<String, Resource> resToObtainByPartition,
+      Map<String, Resource> rollingResourceUsagePerUser) {
-    List<RMContainer> liveContainers = new ArrayList<>(
-        app.getLiveContainers());
+    List<RMContainer> liveContainers = new ArrayList<>(app.getLiveContainers());
+    Resource rollingUsedResourcePerUser = rollingResourceUsagePerUser
+        .get(app.getUser());
-      // Try to preempt this container
-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(
-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,
-          selectedCandidates, totalPreemptedResourceAllowed);
-    }
+      // If selected container brings down resource usage under its user's
+      // UserLimit (or equals to), we must skip such containers.
+      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,
+          clusterResource, rollingUsedResourcePerUser, c)) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(
+              "Skipping container: " + c.getContainerId() + " with resource:"
+                  + c.getAllocatedResource() + " as UserLimit for user:"
+                  + app.getUser() + " with resource usage: "
+                  + rollingUsedResourcePerUser + " is going under UL");
+        }
+        break;
+      }
+      // Try to preempt this container
+      boolean ret = CapacitySchedulerPreemptionUtils
+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,
+              resToObtainByPartition, c, clusterResource, selectedCandidates,
+              totalPreemptedResourceAllowed);
+
+      // Subtract from respective user's resource usage once a container is
+      // selected for preemption.
+      if (ret && preemptionContext.getIntraQueuePreemptionOrderPolicy()
+          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {
+        Resources.subtractFrom(rollingUsedResourcePerUser,
+            c.getAllocatedResource());
+      }
+    }
-      // 2. Its better to get partition based resource limit earlier before
-      // starting calculation
-      Resource partitionBasedResource =
-          context.getPartitionResource(partition);
-
-      // 3. loop through all queues corresponding to a partition.
+      // 2. loop through all queues corresponding to a partition.
-        // 4. Consider reassignableResource as (used - actuallyToBePreempted).
+        // 3. Consider reassignableResource as (used - actuallyToBePreempted).
-        // 5. Check queue's used capacity. Make sure that the used capacity is
+        // 4. Check queue's used capacity. Make sure that the used capacity is
-        // 6. compute the allocation of all apps based on queue's unallocated
+        // 5. compute the allocation of all apps based on queue's unallocated
-            partitionBasedResource, tq, selectedCandidates,
-            totalPreemptedResourceAllowed,
+            tq, selectedCandidates, totalPreemptedResourceAllowed,

INS26 INS26 INS40 INS40 UPD40 INS31 MOV44 MOV44 MOV44 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS44 INS43 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS70 INS74 INS42 INS60 UPD42 UPD42 INS42 INS42 INS42 INS43 INS43 INS43 INS44 INS32 INS8 INS43 INS43 INS43 MOV43 INS59 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS21 INS25 INS42 INS42 INS42 INS42 INS32 INS25 INS60 INS25 INS42 INS32 INS32 INS8 INS42 INS42 INS32 INS32 INS8 INS39 INS59 INS27 INS8 UPD42 UPD42 MOV60 INS60 INS21 INS54 INS42 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS10 INS42 MOV32 INS42 INS32 INS21 UPD42 UPD42 UPD74 INS74 INS59 INS32 INS8 MOV8 INS42 INS42 INS32 INS32 INS32 INS8 INS32 INS42 INS40 INS32 UPD43 UPD42 INS43 INS43 INS43 INS42 INS14 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 MOV21 INS70 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 MOV21 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS42 INS42 INS42 INS74 INS44 INS42 INS8 INS32 INS42 INS45 INS42 INS45 INS32 INS32 INS42 INS42 INS43 INS43 INS42 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 MOV42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 DEL32 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL8 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42
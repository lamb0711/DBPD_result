Merge branch 'trunk' into HADOOP-12756

-import java.io.FileInputStream;
-import java.io.RandomAccessFile;
-import org.apache.hadoop.fs.FileStatus;
-import org.apache.hadoop.fs.permission.FsPermission;
-import org.apache.hadoop.hdfs.server.datanode.FinalizedReplica;
-import org.apache.hadoop.hdfs.server.datanode.ReplicaBeingWritten;
+import org.apache.hadoop.hdfs.server.datanode.ReplicaBuilder;
-import org.apache.hadoop.hdfs.server.datanode.ReplicaInPipelineInterface;
-import org.apache.hadoop.hdfs.server.datanode.ReplicaUnderRecovery;
-import org.apache.hadoop.hdfs.server.datanode.ReplicaWaitingToBeRecovered;
-      File blockfile = getFile(bpid, blkid, false);
-      if (blockfile == null) {
+      ReplicaInfo r = volumeMap.get(bpid, blkid);
+      if (r == null) {
-      final File metafile = FsDatasetUtil.findMetaFile(blockfile);
-      final long gs = FsDatasetUtil.parseGenerationStamp(blockfile, metafile);
-      return new Block(blkid, blockfile.length(), gs);
+      return new Block(blkid, r.getBytesOnDisk(), r.getGenerationStamp());
-    if(r == null)
+    if (r == null) {
+    }
-      return new FinalizedReplica((FinalizedReplica)r);
-      return new ReplicaBeingWritten((ReplicaBeingWritten)r);
-      return new ReplicaWaitingToBeRecovered((ReplicaWaitingToBeRecovered)r);
-      return new ReplicaUnderRecovery((ReplicaUnderRecovery)r);
-      return new ReplicaInPipeline((ReplicaInPipeline)r);
+      return new ReplicaBuilder(r.getState()).from(r).build();
-    File meta = FsDatasetUtil.getMetaFile(getBlockFile(b), b.getGenerationStamp());
-    if (meta == null || !meta.exists()) {
+    ReplicaInfo info = getBlockReplica(b);
+    if (info == null || !info.metadataExists()) {
-    if (isNativeIOAvailable) {
-      return new LengthInputStream(
-          NativeIO.getShareDeleteFileInputStream(meta),
-          meta.length());
-    }
-    return new LengthInputStream(new FileInputStream(meta), meta.length());
+    return info.getMetadataInputStream(0);
-    return getBlockFile(b).length();
+    return getBlockReplica(b).getBlockDataLength();
-  private File getBlockFile(ExtendedBlock b) throws IOException {
-    return getBlockFile(b.getBlockPoolId(), b.getBlockId());
+  private ReplicaInfo getBlockReplica(ExtendedBlock b) throws IOException {
+    return getBlockReplica(b.getBlockPoolId(), b.getBlockId());
-  File getBlockFile(String bpid, long blockId) throws IOException {
-    File f = validateBlockFile(bpid, blockId);
-    if(f == null) {
+  ReplicaInfo getBlockReplica(String bpid, long blockId) throws IOException {
+    ReplicaInfo r = validateBlockFile(bpid, blockId);
+    if (r == null) {
-    return f;
-  }
-  
-  /**
-   * Return the File associated with a block, without first
-   * checking that it exists. This should be used when the
-   * next operation is going to open the file for read anyway,
-   * and thus the exists check is redundant.
-   *
-   * @param touch if true then update the last access timestamp of the
-   *              block. Currently used for blocks on transient storage.
-   */
-  private File getBlockFileNoExistsCheck(ExtendedBlock b,
-                                         boolean touch)
-      throws IOException {
-    final File f;
-    try (AutoCloseableLock lock = datasetLock.acquire()) {
-      f = getFile(b.getBlockPoolId(), b.getLocalBlock().getBlockId(), touch);
-    }
-    if (f == null) {
-      throw new IOException("Block " + b + " is not valid");
-    }
-    return f;
+    return r;
-    File blockFile = getBlockFileNoExistsCheck(b, true);
-    if (isNativeIOAvailable) {
-      return NativeIO.getShareDeleteFileInputStream(blockFile, seekOffset);
+
+    ReplicaInfo info;
+    synchronized(this) {
+      info = volumeMap.get(b.getBlockPoolId(), b.getLocalBlock());
+    }
+
+    if (info != null && info.getVolume().isTransientStorage()) {
+      ramDiskReplicaTracker.touch(b.getBlockPoolId(), b.getBlockId());
+      datanode.getMetrics().incrRamDiskBlocksReadHits();
+    }
+
+    if(info != null && info.blockDataExists()) {
+      return info.getDataInputStream(seekOffset);
-      try {
-        return openAndSeek(blockFile, seekOffset);
-      } catch (FileNotFoundException fnfe) {
-        throw new IOException("Block " + b + " is not valid. " +
-            "Expected block file at " + blockFile + " does not exist.");
-      }
+      throw new IOException("No data exists for block " + b);
-  
+
-  private ReplicaInfo getReplicaInfo(String bpid, long blkid)
+  @VisibleForTesting
+  ReplicaInfo getReplicaInfo(String bpid, long blkid)
-  
+
-        InputStream blockInStream = openAndSeek(info.getBlockFile(), blkOffset);
+        InputStream blockInStream = info.getDataInputStream(blkOffset);
-          InputStream metaInStream =
-              openAndSeek(info.getMetaFile(), metaOffset);
+          InputStream metaInStream = info.getMetadataInputStream(metaOffset);
-  private static FileInputStream openAndSeek(File file, long offset)
-      throws IOException {
-    RandomAccessFile raf = null;
-    try {
-      raf = new RandomAccessFile(file, "r");
-      if (offset > 0) {
-        raf.seek(offset);
-      }
-      return new FileInputStream(raf.getFD());
-    } catch(IOException ioe) {
-      IOUtils.cleanup(null, raf);
-      throw ioe;
-    }
-  }
-
-  static File moveBlockFiles(Block b, File srcfile, File destdir)
+  static File moveBlockFiles(Block b, ReplicaInfo replicaInfo, File destdir)
-    final File srcmeta = FsDatasetUtil.getMetaFile(srcfile, b.getGenerationStamp());
-      NativeIO.renameTo(srcmeta, dstmeta);
+      replicaInfo.renameMeta(dstmeta.toURI());
-          + " from " + srcmeta + " to " + dstmeta, e);
+          + " from " + replicaInfo.getMetadataURI() + " to " + dstmeta, e);
-      NativeIO.renameTo(srcfile, dstfile);
+      replicaInfo.renameData(dstfile.toURI());
-          + " from " + srcfile + " to " + dstfile.getAbsolutePath(), e);
+          + " from " + replicaInfo.getBlockURI() + " to "
+          + dstfile.getAbsolutePath(), e);
-      LOG.debug("addFinalizedBlock: Moved " + srcmeta + " to " + dstmeta
-          + " and " + srcfile + " to " + dstfile);
+      LOG.debug("addFinalizedBlock: Moved " + replicaInfo.getMetadataURI()
+          + " to " + dstmeta + " and " + replicaInfo.getBlockURI()
+          + " to " + dstfile);
-  static File[] copyBlockFiles(long blockId, long genStamp, File srcMeta,
-      File srcFile, File destRoot, boolean calculateChecksum,
+  static File[] copyBlockFiles(long blockId, long genStamp,
+      ReplicaInfo srcReplica, File destRoot, boolean calculateChecksum,
-    final File dstFile = new File(destDir, srcFile.getName());
+    // blockName is same as the filename for the block
+    final File dstFile = new File(destDir, srcReplica.getBlockName());
-    return copyBlockFiles(srcMeta, srcFile, dstMeta, dstFile, calculateChecksum,
+    return copyBlockFiles(srcReplica, dstMeta, dstFile, calculateChecksum,
-  static File[] copyBlockFiles(File srcMeta, File srcFile, File dstMeta,
+  static File[] copyBlockFiles(ReplicaInfo srcReplica, File dstMeta,
+
-      computeChecksum(srcMeta, dstMeta, srcFile, smallBufferSize, conf);
+      computeChecksum(srcReplica, dstMeta, smallBufferSize, conf);
-        Storage.nativeCopyFileUnbuffered(srcMeta, dstMeta, true);
+        srcReplica.copyMetadata(dstMeta.toURI());
-        throw new IOException("Failed to copy " + srcMeta + " to " + dstMeta, e);
+        throw new IOException("Failed to copy " + srcReplica + " metadata to "
+            + dstMeta, e);
-
-      Storage.nativeCopyFileUnbuffered(srcFile, dstFile, true);
+      srcReplica.copyBlockdata(dstFile.toURI());
-      throw new IOException("Failed to copy " + srcFile + " to " + dstFile, e);
+      throw new IOException("Failed to copy " + srcReplica + " block file to "
+          + dstFile, e);
-        LOG.debug("Copied " + srcMeta + " to " + dstMeta
-            + " and calculated checksum");
+        LOG.debug("Copied " + srcReplica.getMetadataURI() + " meta to "
+            + dstMeta + " and calculated checksum");
-        LOG.debug("Copied " + srcFile + " to " + dstFile);
+        LOG.debug("Copied " + srcReplica.getBlockURI() + " to " + dstFile);
-    File oldBlockFile = replicaInfo.getBlockFile();
-    File oldMetaFile = replicaInfo.getMetaFile();
+
-        block.getGenerationStamp(), oldMetaFile, oldBlockFile,
+        block.getGenerationStamp(), replicaInfo,
-    ReplicaInfo newReplicaInfo = new ReplicaInPipeline(
-        replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),
-        targetVolume, blockFiles[0].getParentFile(), 0);
+    ReplicaInfo newReplicaInfo = new ReplicaBuilder(ReplicaState.TEMPORARY)
+        .setBlockId(replicaInfo.getBlockId())
+        .setGenerationStamp(replicaInfo.getGenerationStamp())
+        .setFsVolume(targetVolume)
+        .setDirectoryToUse(blockFiles[0].getParentFile())
+        .setBytesToReserve(0)
+        .build();
-    removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,
-        oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());
+    removeOldReplica(replicaInfo, newReplicaInfo, block.getBlockPoolId());
-   * @param srcMeta source meta file, containing only the checksum header, not a
-   *     calculated checksum
+   * @param srcReplica source {@link ReplicaInfo}, containing only the checksum
+   *     header, not a calculated checksum
-   * @param blockFile block file for which the checksum will be computed
+   * @param smallBufferSize buffer size to use
+   * @param conf the {@link Configuration}
-  private static void computeChecksum(File srcMeta, File dstMeta,
-      File blockFile, int smallBufferSize, final Configuration conf)
+  private static void computeChecksum(ReplicaInfo srcReplica, File dstMeta,
+      int smallBufferSize, final Configuration conf)
+    File srcMeta = new File(srcReplica.getMetadataURI());
-      try (InputStream dataIn = isNativeIOAvailable ?
-          NativeIO.getShareDeleteFileInputStream(blockFile) :
-          new FileInputStream(blockFile)) {
+      try (InputStream dataIn = srcReplica.getDataInputStream(0)) {
-      IOUtils.cleanup(LOG, metaOut);
-    }
-  }
-
-  static private void truncateBlock(File blockFile, File metaFile,
-      long oldlen, long newlen) throws IOException {
-    LOG.info("truncateBlock: blockFile=" + blockFile
-        + ", metaFile=" + metaFile
-        + ", oldlen=" + oldlen
-        + ", newlen=" + newlen);
-
-    if (newlen == oldlen) {
-      return;
-    }
-    if (newlen > oldlen) {
-      throw new IOException("Cannot truncate block to from oldlen (=" + oldlen
-          + ") to newlen (=" + newlen + ")");
-    }
-
-    DataChecksum dcs = BlockMetadataHeader.readHeader(metaFile).getChecksum(); 
-    int checksumsize = dcs.getChecksumSize();
-    int bpc = dcs.getBytesPerChecksum();
-    long n = (newlen - 1)/bpc + 1;
-    long newmetalen = BlockMetadataHeader.getHeaderSize() + n*checksumsize;
-    long lastchunkoffset = (n - 1)*bpc;
-    int lastchunksize = (int)(newlen - lastchunkoffset); 
-    byte[] b = new byte[Math.max(lastchunksize, checksumsize)]; 
-
-    RandomAccessFile blockRAF = new RandomAccessFile(blockFile, "rw");
-    try {
-      //truncate blockFile 
-      blockRAF.setLength(newlen);
- 
-      //read last chunk
-      blockRAF.seek(lastchunkoffset);
-      blockRAF.readFully(b, 0, lastchunksize);
-    } finally {
-      blockRAF.close();
-    }
-
-    //compute checksum
-    dcs.update(b, 0, lastchunksize);
-    dcs.writeValue(b, 0, false);
-
-    //update metaFile 
-    RandomAccessFile metaRAF = new RandomAccessFile(metaFile, "rw");
-    try {
-      metaRAF.setLength(newmetalen);
-      metaRAF.seek(newmetalen - checksumsize);
-      metaRAF.write(b, 0, checksumsize);
-    } finally {
-      metaRAF.close();
+      IOUtils.cleanup(null, metaOut);
-      ReplicaBeingWritten replica = null;
+      ReplicaInPipeline replica = null;
-        replica = append(b.getBlockPoolId(),
-            (FinalizedReplica) replicaInfo, newGS,
+        replica = append(b.getBlockPoolId(), replicaInfo, newGS,
-  private ReplicaBeingWritten append(String bpid,
-      FinalizedReplica replicaInfo, long newGS, long estimateBlockLen)
+  private ReplicaInPipeline append(String bpid,
+      ReplicaInfo replicaInfo, long newGS, long estimateBlockLen)
+      if (replicaInfo.getState() != ReplicaState.FINALIZED) {
+        throw new IOException("Only a Finalized replica can be appended to; "
+            + "Replica with blk id " + replicaInfo.getBlockId() + " has state "
+            + replicaInfo.getState());
+      }
+      // If the block is cached, start uncaching it.
-      // If there are any hardlinks to the block, break them.  This ensures we
-      // are not appending to a file that is part of a previous/ directory.
+      // If there are any hardlinks to the block, break them.  This ensures
+      // we are not appending to a file that is part of a previous/ directory.
-      // construct a RBW replica with the new GS
-      File blkfile = replicaInfo.getBlockFile();
-      FsVolumeImpl v = (FsVolumeImpl) replicaInfo.getVolume();
-      long bytesReserved = estimateBlockLen - replicaInfo.getNumBytes();
-      if (v.getAvailable() < bytesReserved) {
-        throw new DiskOutOfSpaceException("Insufficient space for appending to "
-            + replicaInfo);
+      FsVolumeImpl v = (FsVolumeImpl)replicaInfo.getVolume();
+      ReplicaInPipeline rip = v.append(bpid, replicaInfo,
+          newGS, estimateBlockLen);
+      if (rip.getReplicaInfo().getState() != ReplicaState.RBW) {
+        throw new IOException("Append on block " + replicaInfo.getBlockId() +
+            " returned a replica of state " + rip.getReplicaInfo().getState()
+            + "; expected RBW");
-      File newBlkFile = new File(v.getRbwDir(bpid), replicaInfo.getBlockName());
-      File oldmeta = replicaInfo.getMetaFile();
-      ReplicaBeingWritten newReplicaInfo = new ReplicaBeingWritten(
-          replicaInfo.getBlockId(), replicaInfo.getNumBytes(), newGS,
-          v, newBlkFile.getParentFile(), Thread.currentThread(), bytesReserved);
-      File newmeta = newReplicaInfo.getMetaFile();
-
-      // rename meta file to rbw directory
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Renaming " + oldmeta + " to " + newmeta);
-      }
-      try {
-        NativeIO.renameTo(oldmeta, newmeta);
-      } catch (IOException e) {
-        throw new IOException("Block " + replicaInfo + " reopen failed. " +
-            " Unable to move meta file  " + oldmeta +
-            " to rbw dir " + newmeta, e);
-      }
-
-      // rename block file to rbw directory
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Renaming " + blkfile + " to " + newBlkFile
-            + ", file length=" + blkfile.length());
-      }
-      try {
-        NativeIO.renameTo(blkfile, newBlkFile);
-      } catch (IOException e) {
-        try {
-          NativeIO.renameTo(newmeta, oldmeta);
-        } catch (IOException ex) {
-          LOG.warn("Cannot move meta file " + newmeta +
-              "back to the finalized directory " + oldmeta, ex);
-        }
-        throw new IOException("Block " + replicaInfo + " reopen failed. " +
-            " Unable to move block file " + blkfile +
-            " to rbw dir " + newBlkFile, e);
-      }
-
-      volumeMap.add(bpid, newReplicaInfo);
-      v.reserveSpaceForReplica(bytesReserved);
-      return newReplicaInfo;
+      volumeMap.add(bpid, rip.getReplicaInfo());
+      return rip;
+  @SuppressWarnings("serial")
-    ReplicaInPipeline getReplica() {
+    ReplicaInPipeline getReplicaInPipeline() {
-      ReplicaBeingWritten rbw = (ReplicaBeingWritten)replicaInfo;
+      ReplicaInPipeline rbw = (ReplicaInPipeline) replicaInfo;
-
-          ReplicaBeingWritten replica;
+          ReplicaInPipeline replica;
-              replica = append(b.getBlockPoolId(), (FinalizedReplica) replicaInfo,
+              replica = append(b.getBlockPoolId(), replicaInfo,
-              bumpReplicaGS(replicaInfo, newGS);
-              replica = (ReplicaBeingWritten) replicaInfo;
+              replicaInfo.bumpReplicaGS(newGS);
+              replica = (ReplicaInPipeline) replicaInfo;
-        e.getReplica().stopWriter(datanode.getDnConf().getXceiverStopTimeout());
+        e.getReplicaInPipeline()
+            .stopWriter(datanode.getDnConf().getXceiverStopTimeout());
-          bumpReplicaGS(replicaInfo, newGS);
+          replicaInfo.bumpReplicaGS(newGS);
-        e.getReplica().stopWriter(datanode.getDnConf().getXceiverStopTimeout());
+        e.getReplicaInPipeline()
+            .stopWriter(datanode.getDnConf().getXceiverStopTimeout());
-  /**
-   * Bump a replica's generation stamp to a new one.
-   * Its on-disk meta file name is renamed to be the new one too.
-   * 
-   * @param replicaInfo a replica
-   * @param newGS new generation stamp
-   * @throws IOException if rename fails
-   */
-  private void bumpReplicaGS(ReplicaInfo replicaInfo, 
-      long newGS) throws IOException { 
-    long oldGS = replicaInfo.getGenerationStamp();
-    File oldmeta = replicaInfo.getMetaFile();
-    replicaInfo.setGenerationStamp(newGS);
-    File newmeta = replicaInfo.getMetaFile();
-
-    // rename meta file to new GS
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Renaming " + oldmeta + " to " + newmeta);
-    }
-    try {
-      NativeIO.renameTo(oldmeta, newmeta);
-    } catch (IOException e) {
-      replicaInfo.setGenerationStamp(oldGS); // restore old GS
-      throw new IOException("Block " + replicaInfo + " reopen failed. " +
-                            " Unable to move meta file  " + oldmeta +
-                            " to " + newmeta, e);
-    }
-  }
-
-      File f;
+      ReplicaInPipeline newReplicaInfo;
-        f = v.createRbwFile(b.getBlockPoolId(), b.getLocalBlock());
+        newReplicaInfo = v.createRbw(b);
+        if (newReplicaInfo.getReplicaInfo().getState() != ReplicaState.RBW) {
+          throw new IOException("CreateRBW returned a replica of state "
+              + newReplicaInfo.getReplicaInfo().getState()
+              + " for block " + b.getBlockId());
+        }
-      ReplicaBeingWritten newReplicaInfo =
-          new ReplicaBeingWritten(b.getBlockId(),
-          b.getGenerationStamp(), v, f.getParentFile(), b.getNumBytes());
-      volumeMap.add(b.getBlockPoolId(), newReplicaInfo);
+      volumeMap.add(b.getBlockPoolId(), newReplicaInfo.getReplicaInfo());
-          ReplicaInfo replicaInfo = getReplicaInfo(b.getBlockPoolId(), b.getBlockId());
-          
+          ReplicaInfo replicaInfo =
+              getReplicaInfo(b.getBlockPoolId(), b.getBlockId());
-          ReplicaBeingWritten rbw = (ReplicaBeingWritten)replicaInfo;
+          ReplicaInPipeline rbw = (ReplicaInPipeline)replicaInfo;
-        e.getReplica().stopWriter(datanode.getDnConf().getXceiverStopTimeout());
+        e.getReplicaInPipeline().stopWriter(
+            datanode.getDnConf().getXceiverStopTimeout());
-  private ReplicaHandler recoverRbwImpl(ReplicaBeingWritten rbw,
+  private ReplicaHandler recoverRbwImpl(ReplicaInPipeline rbw,
-      FsVolumeReference ref = rbw.getVolume().obtainReference();
+      FsVolumeReference ref = rbw.getReplicaInfo()
+          .getVolume().obtainReference();
-          final File replicafile = rbw.getBlockFile();
-          truncateBlock(replicafile, rbw.getMetaFile(), numBytes, bytesAcked);
+          rbw.getReplicaInfo().truncateBlock(bytesAcked);
-        bumpReplicaGS(rbw, newGS);
+        rbw.getReplicaInfo().bumpReplicaGS(newGS);
+
-      final ReplicaInPipeline temp;
-
-      // get replica
-      final ReplicaInfo r = volumeMap.get(b.getBlockPoolId(), blockId);
-      if (r == null) {
-        throw new ReplicaNotFoundException(
-            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);
+      final ReplicaInfo temp;
+      {
+        // get replica
+        final ReplicaInfo r = volumeMap.get(b.getBlockPoolId(), blockId);
+        if (r == null) {
+          throw new ReplicaNotFoundException(
+              ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);
+        }
+        // check the replica's state
+        if (r.getState() != ReplicaState.TEMPORARY) {
+          throw new ReplicaAlreadyExistsException(
+              "r.getState() != ReplicaState.TEMPORARY, r=" + r);
+        }
+        temp = r;
-      // check the replica's state
-      if (r.getState() != ReplicaState.TEMPORARY) {
-        throw new ReplicaAlreadyExistsException(
-            "r.getState() != ReplicaState.TEMPORARY, r=" + r);
-      }
-      temp = (ReplicaInPipeline) r;
-
-      // move block files to the rbw directory
-      BlockPoolSlice bpslice = v.getBlockPoolSlice(b.getBlockPoolId());
-      final File dest = moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(),
-          bpslice.getRbwDir());
-      // create RBW
-      final ReplicaBeingWritten rbw = new ReplicaBeingWritten(
-          blockId, numBytes, expectedGs,
-          v, dest.getParentFile(), Thread.currentThread(), 0);
-      rbw.setBytesAcked(visible);
+      final ReplicaInPipeline rbw = v.convertTemporaryToRbw(b, temp);
+
+      if(rbw.getState() != ReplicaState.RBW) {
+        throw new IOException("Expected replica state: " + ReplicaState.RBW
+            + " obtained " + rbw.getState() + " for converting block "
+            + b.getBlockId());
+      }
-      volumeMap.add(b.getBlockPoolId(), rbw);
+      volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());
-          // create a temporary file to hold block in the designated volume
-          File f;
+          ReplicaInPipeline newReplicaInfo;
-            f = v.createTmpFile(b.getBlockPoolId(), b.getLocalBlock());
+            newReplicaInfo = v.createTemporary(b);
-          ReplicaInPipeline newReplicaInfo =
-              new ReplicaInPipeline(b.getBlockId(), b.getGenerationStamp(), v,
-                  f.getParentFile(), b.getLocalBlock().getNumBytes());
-          volumeMap.add(b.getBlockPoolId(), newReplicaInfo);
+
+          volumeMap.add(b.getBlockPoolId(), newReplicaInfo.getReplicaInfo());
-          if (!(currentReplicaInfo.getGenerationStamp() < b
-              .getGenerationStamp() && currentReplicaInfo instanceof ReplicaInPipeline)) {
+          if (!(currentReplicaInfo.getGenerationStamp() < b.getGenerationStamp()
+                && (currentReplicaInfo.getState() == ReplicaState.TEMPORARY
+                    || currentReplicaInfo.getState() == ReplicaState.RBW))) {
-      ((ReplicaInPipeline) lastFoundReplicaInfo)
-          .stopWriter(writerStopTimeoutMs);
+      ((ReplicaInPipeline)lastFoundReplicaInfo).stopWriter(writerStopTimeoutMs);
-  
-  private FinalizedReplica finalizeReplica(String bpid,
+
+  private ReplicaInfo finalizeReplica(String bpid,
-      FinalizedReplica newReplicaInfo = null;
+      ReplicaInfo newReplicaInfo = null;
-          ((ReplicaUnderRecovery) replicaInfo).getOriginalReplica().getState()
-              == ReplicaState.FINALIZED) {
-        newReplicaInfo = (FinalizedReplica)
-            ((ReplicaUnderRecovery) replicaInfo).getOriginalReplica();
+          replicaInfo.getOriginalReplica().getState()
+          == ReplicaState.FINALIZED) {
+        newReplicaInfo = replicaInfo.getOriginalReplica();
-        FsVolumeImpl v = (FsVolumeImpl) replicaInfo.getVolume();
-        File f = replicaInfo.getBlockFile();
+        FsVolumeImpl v = (FsVolumeImpl)replicaInfo.getVolume();
-          throw new IOException("No volume for temporary file " + f +
-              " for block " + replicaInfo);
+          throw new IOException("No volume for block " + replicaInfo);
-        File dest = v.addFinalizedBlock(
-            bpid, replicaInfo, f, replicaInfo.getBytesReserved());
-        newReplicaInfo =
-            new FinalizedReplica(replicaInfo, v, dest.getParentFile());
-
+        newReplicaInfo = v.addFinalizedBlock(
+            bpid, replicaInfo, replicaInfo, replicaInfo.getBytesReserved());
+      assert newReplicaInfo.getState() == ReplicaState.FINALIZED
+          : "Replica should be finalized";
-
-      if (replicaInfo != null
-          && replicaInfo.getState() == ReplicaState.TEMPORARY) {
+      if (replicaInfo != null &&
+          replicaInfo.getState() == ReplicaState.TEMPORARY) {
-        if (delBlockFromDisk(replicaInfo.getBlockFile(),
-            replicaInfo.getMetaFile(), b.getLocalBlock())) {
+        if (delBlockFromDisk(replicaInfo)) {
-   * @param blockFile block file
-   * @param metaFile block meta file
-   * @param b a block
-   * @return true if on-disk files are deleted; false otherwise
+   * @param info the replica that needs to be deleted
+   * @return true if data for the replica are deleted; false otherwise
-  private boolean delBlockFromDisk(File blockFile, File metaFile, Block b) {
-    if (blockFile == null) {
-      LOG.warn("No file exists for block: " + b);
-      return true;
-    }
+  private boolean delBlockFromDisk(ReplicaInfo info) {
-    if (!blockFile.delete()) {
-      LOG.warn("Not able to delete the block file: " + blockFile);
+    if (!info.deleteBlockData()) {
+      LOG.warn("Not able to delete the block data for replica " + info);
-      if (metaFile != null && !metaFile.delete()) {
-        LOG.warn("Not able to delete the meta block file: " + metaFile);
+      if (!info.deleteMetadata()) {
+        LOG.warn("Not able to delete the meta data for replica " + info);
-          case FINALIZED:
-          case RBW:
-          case RWR:
-            builders.get(b.getVolume().getStorageID()).add(b);
-            break;
-          case RUR:
-            ReplicaUnderRecovery rur = (ReplicaUnderRecovery)b;
-            builders.get(rur.getVolume().getStorageID())
-                .add(rur.getOriginalReplica());
-            break;
-          case TEMPORARY:
-            break;
-          default:
-            assert false : "Illegal ReplicaInfo state.";
+        case FINALIZED:
+        case RBW:
+        case RWR:
+          builders.get(b.getVolume().getStorageID()).add(b);
+          break;
+        case RUR:
+          ReplicaInfo orig = b.getOriginalReplica();
+          builders.get(b.getVolume().getStorageID()).add(orig);
+          break;
+        case TEMPORARY:
+          break;
+        default:
+          assert false : "Illegal ReplicaInfo state.";
-  public List<FinalizedReplica> getFinalizedBlocks(String bpid) {
+  public List<ReplicaInfo> getFinalizedBlocks(String bpid) {
-      ArrayList<FinalizedReplica> finalized =
-          new ArrayList<FinalizedReplica>(volumeMap.size(bpid));
+      ArrayList<ReplicaInfo> finalized =
+          new ArrayList<ReplicaInfo>(volumeMap.size(bpid));
-          finalized.add(new FinalizedReplica((FinalizedReplica) b));
+          finalized.add(new ReplicaBuilder(ReplicaState.FINALIZED)
+              .from(b).build());
-  public List<FinalizedReplica> getFinalizedBlocksOnPersistentStorage(
+  public List<ReplicaInfo> getFinalizedBlocksOnPersistentStorage(
-      ArrayList<FinalizedReplica> finalized =
-          new ArrayList<FinalizedReplica>(volumeMap.size(bpid));
+      ArrayList<ReplicaInfo> finalized =
+          new ArrayList<ReplicaInfo>(volumeMap.size(bpid));
-        if (!b.getVolume().isTransientStorage() &&
+        if(!b.getVolume().isTransientStorage() &&
-          finalized.add(new FinalizedReplica((FinalizedReplica) b));
+          finalized.add(new ReplicaBuilder(ReplicaState.FINALIZED)
+              .from(b).build());
-    if (!replicaInfo.getBlockFile().exists()) {
-      throw new FileNotFoundException(replicaInfo.getBlockFile().getPath());
+    if (!replicaInfo.blockDataExists()) {
+      throw new FileNotFoundException(replicaInfo.getBlockURI().toString());
-  File validateBlockFile(String bpid, long blockId) {
+  ReplicaInfo validateBlockFile(String bpid, long blockId) {
-    final File f;
+    final ReplicaInfo r;
-      f = getFile(bpid, blockId, false);
+      r = volumeMap.get(bpid, blockId);
-    
-    if(f != null ) {
-      if(f.exists())
-        return f;
-   
+
+    if (r != null) {
+      if (r.blockDataExists()) {
+        return r;
+      }
-    
+
-      LOG.debug("blockId=" + blockId + ", f=" + f);
+      LOG.debug("blockId=" + blockId + ", replica=" + r);
-    //check replica's file
-    final File f = r.getBlockFile();
-    if (!f.exists()) {
-      throw new FileNotFoundException("File " + f + " not found, r=" + r);
+    //check replica's data exists
+    if (!r.blockDataExists()) {
+      throw new FileNotFoundException("Block data not found, r=" + r);
-    if (r.getBytesOnDisk() != f.length()) {
-      throw new IOException("File length mismatched.  The length of "
-          + f + " is " + f.length() + " but r=" + r);
+    if (r.getBytesOnDisk() != r.getBlockDataLength()) {
+      throw new IOException("Block length mismatch, len="
+          + r.getBlockDataLength() + " but r=" + r);
-    final File metafile = FsDatasetUtil.getMetaFile(f, r.getGenerationStamp());
-    if (!metafile.exists()) {
-      throw new IOException("Metafile " + metafile + " does not exist, r=" + r);
+    if (!r.metadataExists()) {
+      throw new IOException(r.getMetadataURI() + " does not exist, r=" + r);
-    if (metafile.length() == 0) {
-      throw new IOException("Metafile " + metafile + " is empty, r=" + r);
+    if (r.getMetadataLength() == 0) {
+      throw new IOException("Metafile is empty, r=" + r);
-      final File f;
+      final ReplicaInfo removing;
-        f = info.getBlockFile();
-              +  ". No volume for this replica, file=" + f);
+              +  ". No volume for replica " + info);
-        File parent = f.getParentFile();
-        if (parent == null) {
-          errors.add("Failed to delete replica " + invalidBlks[i]
-              +  ". Parent not found for file " + f);
-          continue;
+        try {
+          File blockFile = new File(info.getBlockURI());
+          if (blockFile != null && blockFile.getParentFile() == null) {
+            errors.add("Failed to delete replica " + invalidBlks[i]
+                +  ". Parent not found for block file: " + blockFile);
+            continue;
+          }
+        } catch(IllegalArgumentException e) {
+          LOG.warn("Parent directory check failed; replica " + info
+              + " is not backed by a local file");
-        ReplicaInfo removing = volumeMap.remove(bpid, invalidBlks[i]);
+        removing = volumeMap.remove(bpid, invalidBlks[i]);
-          LOG.debug("Block file " + removing.getBlockFile().getName()
+          LOG.debug("Block file " + removing.getBlockURI()
-        if (removing instanceof ReplicaInPipelineInterface) {
-          ((ReplicaInPipelineInterface) removing).releaseAllBytesReserved();
+        if (removing instanceof ReplicaInPipeline) {
+          ((ReplicaInPipeline) removing).releaseAllBytesReserved();
-        asyncDiskService.deleteAsync(v.obtainReference(), f,
-            FsDatasetUtil.getMetaFile(f, invalidBlks[i].getGenerationStamp()),
+        asyncDiskService.deleteAsync(v.obtainReference(), removing,
-            dataStorage.getTrashDirectoryForBlockFile(bpid, f));
+            dataStorage.getTrashDirectoryForReplica(bpid, removing));
-      blockFileName = info.getBlockFile().getAbsolutePath();
+      blockFileName = info.getBlockURI().toString();
-      return getFile(block.getBlockPoolId(), blockId, false) != null;
+      final String bpid = block.getBlockPoolId();
+      final ReplicaInfo r = volumeMap.get(bpid, blockId);
+      return (r != null && r.blockDataExists());
-   * Turn the block identifier into a filename
-   * @param bpid Block pool Id
-   * @param blockId a block's id
-   * @return on disk data file path; null if the replica does not exist
-   */
-  File getFile(final String bpid, final long blockId, boolean touch) {
-    ReplicaInfo info = volumeMap.get(bpid, blockId);
-    if (info != null) {
-      if (touch && info.getVolume().isTransientStorage()) {
-        ramDiskReplicaTracker.touch(bpid, blockId);
-        datanode.getMetrics().incrRamDiskBlocksReadHits();
-      }
-      return info.getBlockFile();
-    }
-    return null;    
-  }
-
-  /**
-        if (!memBlockInfo.getBlockFile().exists()) {
+        if (!memBlockInfo.blockDataExists()) {
-        ReplicaInfo diskBlockInfo = new FinalizedReplica(blockId, 
-            diskFile.length(), diskGS, vol, diskFile.getParentFile());
+        ReplicaInfo diskBlockInfo = new ReplicaBuilder(ReplicaState.FINALIZED)
+            .setBlockId(blockId)
+            .setLength(diskFile.length())
+            .setGenerationStamp(diskGS)
+            .setFsVolume(vol)
+            .setDirectoryToUse(diskFile.getParentFile())
+            .build();
-      File memFile = memBlockInfo.getBlockFile();
-      if (memFile.exists()) {
-        if (memFile.compareTo(diskFile) != 0) {
+      if (memBlockInfo.blockDataExists()) {
+        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) != 0) {
-            if (memBlockInfo.getMetaFile().exists()) {
+            if (memBlockInfo.metadataExists()) {
-              ReplicaInfo diskBlockInfo = new FinalizedReplica(
-                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());
-              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(
-                  memBlockInfo, diskBlockInfo, volumeMap);
+              ReplicaInfo diskBlockInfo =
+                  new ReplicaBuilder(ReplicaState.FINALIZED)
+                    .setBlockId(blockId)
+                    .setLength(diskFile.length())
+                    .setGenerationStamp(diskGS)
+                    .setFsVolume(vol)
+                    .setDirectoryToUse(diskFile.getParentFile())
+                    .build();
+              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid)
+                  .resolveDuplicateReplicas(
+                      memBlockInfo, diskBlockInfo, volumeMap);
-              LOG.warn("Failed to delete " + diskFile + ". Will retry on next scan");
+              LOG.warn("Failed to delete " + diskFile);
-        LOG.warn("Block file in volumeMap "
-            + memFile.getAbsolutePath()
+        LOG.warn("Block file in replica "
+            + memBlockInfo.getBlockURI()
-        memBlockInfo.setDir(diskFile.getParentFile());
-        memFile = diskFile;
+        memBlockInfo.updateWithReplica(
+            StorageLocation.parse(diskFile.toString()));
-          long gs = diskMetaFile != null && diskMetaFile.exists()
-              && diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS
-              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;
+          try {
+            File memFile = new File(memBlockInfo.getBlockURI());
+            long gs = diskMetaFile != null && diskMetaFile.exists()
+                && diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS
+                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;
-          LOG.warn("Updating generation stamp for block " + blockId
-              + " from " + memBlockInfo.getGenerationStamp() + " to " + gs);
+            LOG.warn("Updating generation stamp for block " + blockId
+                + " from " + memBlockInfo.getGenerationStamp() + " to " + gs);
-          memBlockInfo.setGenerationStamp(gs);
+            memBlockInfo.setGenerationStamp(gs);
+          } catch (IllegalArgumentException e) {
+            //exception arises because the URI cannot be converted to a file
+            LOG.warn("Block URI could not be resolved to a file", e);
+          }
-      if (memBlockInfo.getNumBytes() != memFile.length()) {
+      if (memBlockInfo.getNumBytes() != memBlockInfo.getBlockDataLength()) {
-            + memBlockInfo.getNumBytes() + " to " + memFile.length());
-        memBlockInfo.setNumBytes(memFile.length());
+            + memBlockInfo.getNumBytes() + " to "
+            + memBlockInfo.getBlockDataLength());
+        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());
-        e.getReplica().stopWriter(xceiverStopTimeout);
+        e.getReplicaInPipeline().stopWriter(xceiverStopTimeout);
-    if (replica instanceof ReplicaInPipeline) {
+    if (replica.getState() == ReplicaState.TEMPORARY ||
+        replica.getState() == ReplicaState.RBW) {
-      if (rip.getBytesOnDisk() < rip.getVisibleLength()) {
+      if (replica.getBytesOnDisk() < replica.getVisibleLength()) {
-            + " getBytesOnDisk() < getVisibleLength(), rip=" + rip);
+            + " getBytesOnDisk() < getVisibleLength(), rip=" + replica);
-      checkReplicaFiles(rip);
+      checkReplicaFiles(replica);
-    final ReplicaUnderRecovery rur;
+    final ReplicaInfo rur;
-      rur = (ReplicaUnderRecovery)replica;
+      rur = replica;
-      rur = new ReplicaUnderRecovery(replica, recoveryId);
+      rur = new ReplicaBuilder(ReplicaState.RUR)
+          .from(replica).setRecoveryId(recoveryId).build();
-      final FinalizedReplica finalized = updateReplicaUnderRecovery(oldBlock
-              .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,
+      final ReplicaInfo finalized = updateReplicaUnderRecovery(oldBlock
+          .getBlockPoolId(), replica, recoveryId,
-
-  private FinalizedReplica updateReplicaUnderRecovery(
+  private ReplicaInfo updateReplicaUnderRecovery(
-                                          ReplicaUnderRecovery rur,
+                                          ReplicaInfo rur,
-    File blockFile;
-    File metaFile;
-      bumpReplicaGS(rur, recoveryId);
-      blockFile = rur.getBlockFile();
-      metaFile = rur.getMetaFile();
-    } else {
-      File[] copiedReplicaFiles =
-          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);
-      blockFile = copiedReplicaFiles[1];
-      metaFile = copiedReplicaFiles[0];
+      rur.bumpReplicaGS(recoveryId);
+
-      rur.breakHardLinksIfNeeded();
-      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);
+        rur.breakHardLinksIfNeeded();
+        rur.truncateBlock(newlength);
-        FsVolumeSpi volume = rur.getVolume();
-        String blockPath = blockFile.getAbsolutePath();
-        String volumePath = volume.getBasePath();
-        assert blockPath.startsWith(volumePath) :
-            "New block file: " + blockPath + " must be on " +
-                "same volume as recovery replica: " + volumePath;
-        ReplicaBeingWritten newReplicaInfo = new ReplicaBeingWritten(
-            newBlockId, recoveryId, volume, blockFile.getParentFile(),
-            newlength);
-        newReplicaInfo.setNumBytes(newlength);
-        volumeMap.add(bpid, newReplicaInfo);
-        finalizeReplica(bpid, newReplicaInfo);
-      }
-   }
+        FsVolumeImpl volume = (FsVolumeImpl) rur.getVolume();
+        ReplicaInPipeline newReplicaInfo = volume.updateRURCopyOnTruncate(
+            rur, bpid, newBlockId, recoveryId, newlength);
+        if (newReplicaInfo.getState() != ReplicaState.RBW) {
+          throw new IOException("Append on block " + rur.getBlockId()
+              + " returned a replica of state " + newReplicaInfo.getState()
+              + "; expected RBW");
+        }
+        newReplicaInfo.setNumBytes(newlength);
+        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());
+        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());
+      }
+    }
-  private File[] copyReplicaWithNewBlockIdAndGS(
-      ReplicaUnderRecovery replicaInfo, String bpid, long newBlkId, long newGS)
-      throws IOException {
-    String blockFileName = Block.BLOCK_FILE_PREFIX + newBlkId;
-    FsVolumeImpl v = (FsVolumeImpl) replicaInfo.getVolume();
-    final File tmpDir = v.getBlockPoolSlice(bpid).getTmpDir();
-    final File destDir = DatanodeUtil.idToBlockDir(tmpDir, newBlkId);
-    final File dstBlockFile = new File(destDir, blockFileName);
-    final File dstMetaFile = FsDatasetUtil.getMetaFile(dstBlockFile, newGS);
-    return copyBlockFiles(replicaInfo.getMetaFile(),
-        replicaInfo.getBlockFile(),
-        dstMetaFile, dstBlockFile, true, smallBufferSize, conf);
-  }
-
-    File datafile = getBlockFile(block);
-    File metafile = FsDatasetUtil.getMetaFile(datafile, block.getGenerationStamp());
+    ReplicaInfo r = getBlockReplica(block);
+    File blockFile = new File(r.getBlockURI());
+    File metaFile = new File(r.getMetadataURI());
-        datafile.getAbsolutePath(), metafile.getAbsolutePath());
+        blockFile.getAbsolutePath(), metaFile.toString());
-      ReplicaInfo newReplicaInfo, File blockFile, File metaFile,
-      long blockFileUsed, long metaFileUsed, final String bpid) {
+      ReplicaInfo newReplicaInfo, final String bpid) {
-    if (blockFile.delete() || !blockFile.exists()) {
+    if (replicaInfo.deleteBlockData() || !replicaInfo.blockDataExists()) {
-      volume.onBlockFileDeletion(bpid, blockFileUsed);
-      if (metaFile.delete() || !metaFile.exists()) {
-        volume.onMetaFileDeletion(bpid, metaFileUsed);
+      volume.onBlockFileDeletion(bpid, replicaInfo.getBytesOnDisk());
+      if (replicaInfo.deleteMetadata() || !replicaInfo.metadataExists()) {
+        volume.onMetaFileDeletion(bpid, replicaInfo.getMetadataLength());
-                  replicaInfo.getMetaFile(), replicaInfo.getBlockFile(),
-                  targetReference);
+                  replicaInfo, targetReference);
-        File blockFile, metaFile;
-        long blockFileUsed, metaFileUsed;
-          blockFile = replicaInfo.getBlockFile();
-          metaFile = replicaInfo.getMetaFile();
-          blockFileUsed = blockFile.length();
-          metaFileUsed = metaFile.length();
-          File newBlockFile = bpSlice.activateSavedReplica(
-              replicaInfo, replicaState.getSavedMetaFile(),
-              replicaState.getSavedBlockFile());
-              new FinalizedReplica(replicaInfo.getBlockId(),
-                                   replicaInfo.getBytesOnDisk(),
-                                   replicaInfo.getGenerationStamp(),
-                                   replicaState.getLazyPersistVolume(),
-                                   newBlockFile.getParentFile());
+              bpSlice.activateSavedReplica(replicaInfo, replicaState);
-          removeOldReplica(replicaInfo, newReplicaInfo, blockFile, metaFile,
-              blockFileUsed, metaFileUsed, bpid);
+          removeOldReplica(replicaInfo, newReplicaInfo, bpid);
-
-    File f = getBlockFile(block);
-    Path p = new Path(f.getAbsolutePath());
-    FsPermission oldPermission = localFS.getFileStatus(
-        new Path(f.getAbsolutePath())).getPermission();
-    //sticky bit is used for pinning purpose
-    FsPermission permission = new FsPermission(oldPermission.getUserAction(),
-        oldPermission.getGroupAction(), oldPermission.getOtherAction(), true);
-    localFS.setPermission(p, permission);
+    ReplicaInfo r = getBlockReplica(block);
+    r.setPinning(localFS);
-    File f = getBlockFile(block);
-        
-    FileStatus fss = localFS.getFileStatus(new Path(f.getAbsolutePath()));
-    return fss.getPermission().getStickyBit();
+    ReplicaInfo r = getBlockReplica(block);
+    return r.getPinning(localFS);
-          if (replicaInfo instanceof ReplicaInPipeline
+          if ((replicaInfo.getState() == ReplicaState.TEMPORARY
+              || replicaInfo.getState() == ReplicaState.RBW)
-            ReplicaInPipeline replicaInPipeline
-                = (ReplicaInPipeline) replicaInfo;
+            ReplicaInPipeline replicaInPipeline =
+                (ReplicaInPipeline) replicaInfo;

UPD40 INS31 UPD43 UPD42 UPD43 UPD42 MOV78 UPD83 MOV83 MOV43 UPD42 MOV42 MOV44 MOV44 MOV43 INS8 INS78 MOV44 MOV43 INS79 UPD43 INS74 UPD74 MOV74 UPD43 UPD43 MOV41 UPD42 UPD42 MOV60 INS51 MOV25 INS25 INS42 UPD43 UPD42 UPD43 UPD42 INS60 INS65 UPD43 UPD42 INS60 UPD43 INS42 INS45 UPD42 MOV43 UPD42 UPD43 UPD42 MOV41 MOV43 INS43 UPD43 UPD42 UPD42 MOV43 INS25 INS25 INS60 INS60 INS8 INS41 UPD43 INS32 UPD43 UPD42 UPD43 INS52 INS8 INS27 MOV8 INS8 MOV32 UPD42 MOV43 UPD42 MOV32 MOV43 INS59 UPD42 INS66 INS65 UPD66 UPD66 INS42 INS66 UPD42 UPD66 INS65 UPD42 MOV43 INS59 UPD42 MOV25 UPD42 MOV42 UPD42 UPD66 UPD66 UPD42 INS42 UPD42 UPD43 MOV32 INS27 UPD43 MOV38 MOV8 MOV27 INS8 INS43 MOV43 INS59 MOV43 INS59 MOV43 UPD43 UPD43 INS41 INS32 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS34 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV27 INS27 INS32 MOV53 MOV44 UPD42 MOV44 INS42 INS32 INS42 INS42 INS42 INS14 INS25 INS54 INS8 INS25 INS6 MOV41 INS60 MOV60 UPD42 UPD42 UPD42 INS60 INS60 INS41 INS27 INS27 UPD42 INS25 INS42 UPD42 INS42 INS14 INS42 INS14 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD43 MOV33 INS32 INS42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD42 MOV42 MOV33 UPD42 MOV42 UPD42 MOV42 MOV43 UPD42 INS32 INS42 MOV43 INS32 MOV43 INS8 MOV12 UPD27 MOV43 INS27 INS8 UPD42 MOV43 INS12 UPD43 INS8 MOV12 MOV12 INS43 MOV60 MOV25 MOV25 MOV21 INS83 MOV43 INS27 INS8 UPD43 INS27 INS45 UPD42 UPD42 INS38 INS74 INS59 UPD74 MOV74 MOV42 UPD42 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 INS83 MOV43 INS59 INS83 INS43 INS59 INS36 INS32 INS40 INS32 INS40 UPD43 MOV38 MOV8 INS8 UPD42 MOV43 INS32 MOV43 INS32 MOV43 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 INS14 INS42 INS42 UPD42 UPD42 UPD42 INS32 MOV32 MOV32 UPD42 UPD42 MOV43 UPD42 UPD42 INS32 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 MOV44 UPD42 UPD42 INS32 INS32 INS42 INS34 INS42 INS42 INS33 INS21 INS40 UPD42 INS32 INS32 INS40 MOV53 INS32 MOV44 INS8 UPD42 UPD42 INS21 INS25 MOV32 INS32 INS42 UPD42 INS32 INS40 INS53 MOV32 INS32 UPD42 INS25 INS21 INS32 INS40 MOV32 MOV41 MOV43 INS43 INS42 INS14 UPD43 MOV43 UPD42 UPD42 UPD42 INS41 MOV43 MOV43 MOV43 UPD42 UPD42 INS54 INS21 INS42 MOV32 INS42 INS42 INS32 INS27 UPD42 UPD42 INS21 INS42 INS42 INS42 INS42 UPD42 INS42 INS32 UPD42 INS42 MOV21 INS21 MOV60 MOV60 INS25 MOV21 MOV21 MOV21 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV32 INS42 UPD42 UPD42 UPD42 UPD43 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 MOV32 MOV32 UPD45 MOV43 UPD42 MOV42 UPD42 MOV42 MOV43 UPD42 MOV42 UPD42 MOV42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 MOV43 INS32 INS42 MOV32 INS32 INS7 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS42 UPD42 MOV42 INS32 UPD42 MOV42 INS42 UPD42 MOV42 UPD43 INS21 INS7 INS27 INS8 INS42 INS42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS14 MOV42 INS42 MOV27 MOV8 INS7 INS42 INS42 UPD45 UPD42 UPD42 UPD42 INS42 INS74 MOV32 UPD42 UPD74 MOV74 UPD42 INS42 UPD42 UPD42 MOV42 UPD45 UPD42 UPD45 UPD45 INS32 UPD45 MOV27 INS8 INS12 INS7 MOV32 MOV62 UPD42 INS42 UPD42 MOV42 INS42 MOV42 INS27 INS32 MOV43 INS32 INS8 UPD42 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS32 UPD43 MOV43 INS27 INS8 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 UPD42 UPD45 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS34 INS42 INS32 MOV43 UPD42 MOV42 UPD42 MOV42 MOV43 UPD42 INS32 INS42 INS32 INS32 INS40 INS53 INS32 INS32 UPD42 MOV43 INS27 MOV54 INS32 INS33 INS42 INS32 MOV42 UPD43 MOV43 INS43 UPD43 UPD42 UPD42 UPD42 INS42 INS42 INS60 MOV25 INS44 INS8 INS42 MOV32 UPD42 UPD42 UPD42 INS42 MOV33 INS42 INS42 INS32 MOV42 UPD42 MOV42 INS32 INS54 MOV43 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 INS11 UPD42 MOV42 UPD42 INS32 INS40 INS53 INS32 INS32 UPD42 UPD42 INS32 MOV42 UPD42 MOV42 MOV43 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV43 INS32 UPD45 INS32 INS32 INS42 MOV32 INS42 MOV32 INS42 INS42 MOV32 INS27 MOV32 INS45 INS32 UPD45 MOV32 INS45 INS32 UPD45 UPD43 INS32 INS42 MOV32 INS42 INS42 MOV42 INS32 INS42 INS14 UPD43 MOV42 INS42 INS42 UPD42 MOV42 INS45 INS40 INS45 INS32 INS45 INS32 MOV43 INS42 INS42 MOV42 MOV42 MOV42 MOV42 MOV42 UPD42 MOV42 MOV32 UPD45 UPD42 UPD42 UPD42 INS32 UPD42 MOV42 INS42 UPD42 MOV43 INS59 INS27 INS43 INS42 INS21 UPD42 UPD42 MOV42 UPD42 INS32 INS42 INS32 INS32 UPD45 INS42 INS42 INS32 MOV8 INS12 UPD42 UPD42 UPD42 INS14 INS42 INS42 INS43 MOV32 INS42 UPD42 INS42 INS42 INS42 INS14 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 INS32 UPD42 UPD45 INS42 INS42 INS42 INS42 INS14 INS42 MOV32 UPD45 MOV45 INS45 INS42 INS42 INS32 INS42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 INS42 UPD42 MOV42 MOV43 INS27 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 MOV43 INS42 INS42 INS32 INS32 INS42 INS14 INS27 INS27 INS42 INS32 INS32 INS42 MOV32 UPD42 MOV42 INS42 MOV42 INS42 UPD42 UPD42 INS42 INS42 INS60 INS44 INS8 UPD42 UPD42 UPD42 UPD43 MOV43 INS40 INS42 MOV43 INS27 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS36 MOV42 UPD42 MOV42 INS43 INS40 MOV42 INS42 INS42 MOV8 INS45 INS32 INS45 MOV32 UPD43 UPD42 UPD42 UPD42 UPD45 INS32 INS42 INS32 INS42 UPD45 UPD42 MOV43 INS32 INS42 INS33 MOV32 MOV33 UPD42 MOV42 UPD42 MOV42 INS27 INS32 INS32 INS42 INS42 MOV43 INS59 INS43 INS42 INS21 UPD42 INS45 INS32 UPD45 MOV45 INS32 INS45 INS27 INS42 INS32 UPD42 MOV42 UPD42 UPD42 INS36 UPD42 INS14 INS42 INS42 INS14 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS45 INS42 INS45 MOV42 UPD42 MOV42 MOV43 INS32 INS42 INS42 MOV42 UPD42 INS42 INS14 INS42 INS32 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS27 INS27 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS27 UPD43 MOV43 INS40 UPD43 MOV43 INS40 UPD45 UPD42 INS32 INS42 MOV32 MOV43 MOV43 INS32 INS42 INS42 INS45 INS42 MOV42 INS32 INS40 INS32 INS40 UPD42 UPD42 INS27 INS27 UPD42 UPD42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD43 INS32 INS40 INS32 INS40 UPD43 MOV43 INS40 INS32 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS32 UPD42 MOV42 MOV32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 MOV32 INS14 INS42 UPD42 MOV42 UPD43 MOV43 INS40 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL9 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL41 DEL42 DEL43 DEL42 DEL11 DEL14 DEL41 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL41 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL41 DEL42 DEL11 DEL14 DEL41 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL42 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL32 DEL14 DEL41 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL45 DEL45 DEL42 DEL45 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL8 DEL54 DEL27 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL32 DEL42 DEL32 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL45 DEL14 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL42 DEL44 DEL42 DEL42 DEL33 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL44 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL42 DEL43 DEL9 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL14 DEL16 DEL42 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL27 DEL41 DEL8 DEL25 DEL42 DEL42 DEL27 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL34 DEL27 DEL36 DEL42 DEL27 DEL34 DEL27 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL27 DEL59 DEL60 DEL39 DEL42 DEL42 DEL34 DEL27 DEL36 DEL42 DEL27 DEL59 DEL60 DEL39 DEL42 DEL39 DEL42 DEL42 DEL27 DEL36 DEL11 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL45 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL9 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL45 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL32 DEL32 DEL14 DEL42 DEL45 DEL45 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL42 DEL27 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL32 DEL7 DEL21 DEL8 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL42 DEL27 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL42 DEL32 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL11 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL54 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL11 DEL45 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL25 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL44 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL38 DEL27 DEL9 DEL41 DEL42 DEL43 DEL42 DEL11 DEL42 DEL32 DEL42 DEL43 DEL42 DEL11 DEL14 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL11 DEL14 DEL42 DEL32 DEL9 DEL41 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL42 DEL45 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL59 DEL60 DEL32 DEL42 DEL32 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL32 DEL9 DEL32 DEL27 DEL41 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL33 DEL41 DEL8 DEL31 DEL42 DEL32 DEL42 DEL42 DEL42 DEL14 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL14 DEL45 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL62 DEL42 DEL43 DEL42 DEL11 DEL42 DEL42 DEL14 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL2 DEL7 DEL21 DEL42 DEL42 DEL34 DEL2 DEL7 DEL21 DEL8 DEL25 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL27 DEL6 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL40 DEL42 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL9 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL59 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL32 DEL59 DEL60 DEL32 DEL42 DEL62
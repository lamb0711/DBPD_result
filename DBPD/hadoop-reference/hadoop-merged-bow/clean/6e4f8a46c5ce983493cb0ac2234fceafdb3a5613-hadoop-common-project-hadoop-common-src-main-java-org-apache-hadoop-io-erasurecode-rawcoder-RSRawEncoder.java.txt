HADOOP-12047. Indicate preference not to affect input buffers during coding in erasure coder. (Contributed by Kai Zheng)

+import java.util.Arrays;
-    System.arraycopy(outputs, 0, all, 0, outputs.length);
-    System.arraycopy(inputs, 0, all, outputs.length, inputs.length);
+
+    if (isAllowingChangeInputs()) {
+      System.arraycopy(outputs, 0, all, 0, outputs.length);
+      System.arraycopy(inputs, 0, all, outputs.length, inputs.length);
+    } else {
+      System.arraycopy(outputs, 0, all, 0, outputs.length);
+
+      /**
+       * Note when this coder would be really (rarely) used in a production
+       * system, this can  be optimized to cache and reuse the new allocated
+       * buffers avoiding reallocating.
+       */
+      ByteBuffer tmp;
+      for (int i = 0; i < inputs.length; i++) {
+        tmp = ByteBuffer.allocate(inputs[i].remaining());
+        tmp.put(inputs[i]);
+        tmp.flip();
+        all[outputs.length + i] = tmp;
+      }
+    }
-    System.arraycopy(outputs, 0, all, 0, outputs.length);
-    System.arraycopy(inputs, 0, all, outputs.length, inputs.length);
+    int[] allOffsets = new int[outputOffsets.length + inputOffsets.length];
-    int[] offsets = new int[inputOffsets.length + outputOffsets.length];
-    System.arraycopy(outputOffsets, 0, offsets, 0, outputOffsets.length);
-    System.arraycopy(inputOffsets, 0, offsets,
-        outputOffsets.length, inputOffsets.length);
+    if (isAllowingChangeInputs()) {
+      System.arraycopy(outputs, 0, all, 0, outputs.length);
+      System.arraycopy(inputs, 0, all, outputs.length, inputs.length);
+
+      System.arraycopy(outputOffsets, 0, allOffsets, 0, outputOffsets.length);
+      System.arraycopy(inputOffsets, 0, allOffsets,
+          outputOffsets.length, inputOffsets.length);
+    } else {
+      System.arraycopy(outputs, 0, all, 0, outputs.length);
+      System.arraycopy(outputOffsets, 0, allOffsets, 0, outputOffsets.length);
+
+      for (int i = 0; i < inputs.length; i++) {
+        all[outputs.length + i] = Arrays.copyOfRange(inputs[i],
+            inputOffsets[i], inputOffsets[i] + dataLen);
+      }
+    }
-    RSUtil.GF.remainder(all, offsets, dataLen, generatingPolynomial);
+    RSUtil.GF.remainder(all, allOffsets, dataLen, generatingPolynomial);

INS26 INS40 INS8 MOV60 INS25 MOV21 INS25 INS32 INS8 INS8 MOV5 INS32 INS8 INS8 INS42 MOV21 INS21 INS21 INS60 INS24 UPD42 INS42 MOV21 MOV21 INS21 MOV21 MOV21 MOV21 INS24 UPD42 INS32 INS32 INS43 INS59 INS58 INS27 INS37 INS8 MOV5 INS32 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS34 INS42 INS40 INS40 INS42 INS42 INS42 INS34 INS42 INS34 INS40 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS21 INS21 INS21 INS21 UPD40 UPD40 INS42 INS42 INS42 INS34 INS42 INS34 INS40 UPD42 UPD42 UPD40 UPD40 UPD42 UPD42 UPD40 UPD42 UPD42 INS34 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS34 INS7 INS32 INS32 INS7 INS42 INS34 INS7 INS42 INS32 INS42 INS42 INS2 INS42 INS42 INS2 INS42 INS2 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS27 INS42 INS42 INS2 INS2 INS27 INS2 INS42 INS40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 DEL8 DEL40
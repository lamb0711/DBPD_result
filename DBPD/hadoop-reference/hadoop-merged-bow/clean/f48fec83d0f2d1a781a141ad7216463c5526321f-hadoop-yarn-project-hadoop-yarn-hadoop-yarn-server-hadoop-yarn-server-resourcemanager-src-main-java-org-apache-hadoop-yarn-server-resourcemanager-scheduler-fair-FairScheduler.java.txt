YARN-8248. Job hangs when a job requests a resource that its queue does not have. (Szilard Nemeth via Haibo Chen)

+import com.google.common.collect.Lists;
+import org.apache.hadoop.yarn.exceptions
+        .SchedulerInvalidResoureRequestException;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerUtils.MaxResourceValidationResult;
-      LOG.info(message);
-      rmContext.getDispatcher().getEventHandler().handle(
-          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,
-              message));
+      rejectApplicationWithMessage(applicationId, message);
-      LOG.info(message);
-      rmContext.getDispatcher().getEventHandler().handle(
-          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,
-              message));
+      rejectApplicationWithMessage(applicationId, message);
+      if (rmApp != null && rmApp.getAMResourceRequests() != null) {
+        // Resources.fitsIn would always return false when queueMaxShare is 0
+        // for any resource, but only using Resources.fitsIn is not enough
+        // is it would return false for such cases when the requested
+        // resource is smaller than the max resource but that max resource is
+        // not zero, e.g. requested vCores = 2, max vCores = 1.
+        // With this check, we only reject those applications where resource
+        // requested is greater than 0 and we have 0
+        // of that resource on the queue.
+        List<MaxResourceValidationResult> invalidAMResourceRequests =
+                validateResourceRequests(rmApp.getAMResourceRequests(), queue);
+
+        if (!invalidAMResourceRequests.isEmpty()) {
+          String msg = String.format(
+                  "Cannot submit application %s to queue %s because "
+                          + "it has zero amount of resource for a requested "
+                          + "resource! Invalid requested AM resources: %s, "
+                          + "maximum queue resources: %s",
+                  applicationId, queue.getName(),
+                  invalidAMResourceRequests, queue.getMaxShare());
+          rejectApplicationWithMessage(applicationId, msg);
+          return;
+        }
+      }
+
-        LOG.info(msg);
-        rmContext.getDispatcher().getEventHandler().handle(
-            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));
+        rejectApplicationWithMessage(applicationId, msg);
-      LOG.error(appRejectMsg);
-      rmContext.getDispatcher().getEventHandler().handle(
-          new RMAppEvent(rmApp.getApplicationId(),
-              RMAppEventType.APP_REJECTED, appRejectMsg));
+      rejectApplicationWithMessage(rmApp.getApplicationId(), appRejectMsg);
-
+    ApplicationId applicationId = application.getApplicationId();
+    FSLeafQueue queue = application.getQueue();
+    List<MaxResourceValidationResult> invalidAsks =
+            validateResourceRequests(ask, queue);
+
+    // We need to be fail-fast here if any invalid ask is detected.
+    // If we would have thrown exception later, this could be problematic as
+    // tokens and promoted / demoted containers would have been lost because
+    // scheduler would clear them right away and AM
+    // would not get this information.
+    if (!invalidAsks.isEmpty()) {
+      throw new SchedulerInvalidResoureRequestException(String.format(
+              "Resource request is invalid for application %s because queue %s "
+                      + "has 0 amount of resource for a resource type! "
+                      + "Validation result: %s",
+              applicationId, queue.getName(), invalidAsks));
+    }
+
+
+  private List<MaxResourceValidationResult> validateResourceRequests(
+      List<ResourceRequest> requests, FSLeafQueue queue) {
+    List<MaxResourceValidationResult> validationResults = Lists.newArrayList();
+
+    for (ResourceRequest resourceRequest : requests) {
+      if (LOG.isTraceEnabled()) {
+        LOG.trace("Validating resource request: " + resourceRequest);
+      }
+
+      MaxResourceValidationResult validationResult =
+              SchedulerUtils.validateResourceRequestsAgainstQueueMaxResource(
+                      resourceRequest, queue.getMaxShare());
+      if (!validationResult.isValid()) {
+        validationResults.add(validationResult);
+        LOG.warn(String.format("Queue %s cannot handle resource request" +
+                        "because it has zero available amount of resource " +
+                        "for a requested resource type, " +
+                        "so the resource request is ignored!"
+                        + " Requested resources: %s, " +
+                        "maximum queue resources: %s",
+                queue.getName(), resourceRequest.getCapability(),
+                queue.getMaxShare()));
+      }
+    }
+
+    return validationResults;
+  }
+
+
+
+            if (LOG.isDebugEnabled()) {
+              LOG.debug("No container is allocated on node " + node);
+            }
-          this.rmContext.getDispatcher().getEventHandler().handle(
-              new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,
-                  message));
+          rejectApplicationWithMessage(applicationId, message);
-          this.rmContext.getDispatcher().getEventHandler().handle(
-              new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,
-                  message));
+          rejectApplicationWithMessage(applicationId, message);
+  }
+  private void rejectApplicationWithMessage(ApplicationId applicationId,
+          String msg) {
+    LOG.info(msg);
+    rmContext.getDispatcher().getEventHandler().handle(new RMAppEvent(
+            applicationId, RMAppEventType.APP_REJECTED, msg));

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS83 INS74 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 MOV8 INS60 INS60 INS60 INS25 INS43 INS43 INS74 INS42 INS43 INS42 INS60 INS70 INS41 INS43 INS42 INS43 INS42 INS43 INS59 INS43 INS59 INS74 INS59 INS38 INS8 INS42 INS42 INS43 INS43 INS42 INS74 INS59 INS44 INS42 INS8 INS42 INS42 INS42 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS32 INS32 INS53 INS42 INS42 INS43 INS43 INS42 INS32 INS43 INS42 INS25 INS60 INS25 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS43 INS59 INS38 INS8 UPD42 INS42 INS42 UPD42 INS42 INS42 INS27 INS27 INS60 INS25 MOV60 INS21 INS41 UPD42 MOV32 INS42 INS43 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS32 INS21 INS21 INS42 INS33 INS32 INS33 INS74 INS59 INS38 INS8 INS32 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS43 INS43 INS42 INS32 INS32 INS60 INS21 INS41 INS42 INS42 INS42 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS32 INS45 INS42 INS42 INS42 INS27 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS45 INS45 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS25 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS32 INS8 INS45 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS32 INS42 INS42 INS27 INS45 INS42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL40 DEL42 DEL14 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL40 DEL42 DEL14 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL40 DEL42 DEL14 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL40 DEL42 DEL14 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL40 DEL42 DEL14 DEL41
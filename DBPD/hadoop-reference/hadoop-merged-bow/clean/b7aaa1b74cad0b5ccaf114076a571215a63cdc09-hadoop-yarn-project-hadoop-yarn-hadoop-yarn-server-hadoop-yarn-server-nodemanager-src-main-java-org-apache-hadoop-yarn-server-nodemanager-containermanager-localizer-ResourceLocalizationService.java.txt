Merge trunk into the HDFS-347 branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1467511 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Random;
+import org.apache.hadoop.util.DiskChecker;
+import org.apache.hadoop.yarn.server.nodemanager.api.ResourceLocalizationSpec;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.event.ResourceFailedLocalizationEvent;
+import org.apache.hadoop.yarn.server.nodemanager.util.NodeManagerBuilderUtils;
-  private final LocalResourcesTracker publicRsrc;
+  private LocalResourcesTracker publicRsrc;
-    this.publicRsrc = new LocalResourcesTrackerImpl(null, dispatcher);
+  private void validateConf(Configuration conf) {
+    int perDirFileLimit =
+        conf.getInt(YarnConfiguration.NM_LOCAL_CACHE_MAX_FILES_PER_DIRECTORY,
+          YarnConfiguration.DEFAULT_NM_LOCAL_CACHE_MAX_FILES_PER_DIRECTORY);
+    if (perDirFileLimit <= 36) {
+      LOG.error(YarnConfiguration.NM_LOCAL_CACHE_MAX_FILES_PER_DIRECTORY
+          + " parameter is configured with very low value.");
+      throw new YarnException(
+        YarnConfiguration.NM_LOCAL_CACHE_MAX_FILES_PER_DIRECTORY
+            + " parameter is configured with a value less than 37.");
+    } else {
+      LOG.info("per directory file limit = " + perDirFileLimit);
+    }
+  }
+
+    this.validateConf(conf);
+    this.publicRsrc =
+        new LocalResourcesTrackerImpl(null, dispatcher, true, conf);
+
-    privateRsrc.putIfAbsent(userName,
-        new LocalResourcesTrackerImpl(userName, dispatcher));
-    if (null != appRsrc.putIfAbsent(ConverterUtils.toString(app.getAppId()),
-        new LocalResourcesTrackerImpl(app.getUser(), dispatcher))) {
+    privateRsrc.putIfAbsent(userName, new LocalResourcesTrackerImpl(userName,
+      dispatcher, true, super.getConfig()));
+    if (null != appRsrc.putIfAbsent(
+      ConverterUtils.toString(app.getAppId()),
+      new LocalResourcesTrackerImpl(app.getUser(), dispatcher, false, super
+        .getConfig()))) {
-                    //   should appear in logs, but it's an internal error
-                    //   that should have no effect on applications
+                    // should appear in logs, but it's an internal error
+                    // that should have no effect on applications
+  private String getUserFileCachePath(String user) {
+    String path =
+        "." + Path.SEPARATOR + ContainerLocalizer.USERCACHE + Path.SEPARATOR
+            + user + Path.SEPARATOR + ContainerLocalizer.FILECACHE;
+    return path;
+  }
+
+  private String getUserAppCachePath(String user, String appId) {
+    String path =
+        "." + Path.SEPARATOR + ContainerLocalizer.USERCACHE + Path.SEPARATOR
+            + user + Path.SEPARATOR + ContainerLocalizer.APPCACHE
+            + Path.SEPARATOR + appId;
+    return path;
+  }
+
+            Path hierarchicalPath =
+              publicRsrc.getPathForLocalization(key, publicDirDestPath);
+            if (!hierarchicalPath.equals(publicDirDestPath)) {
+              publicDirDestPath = hierarchicalPath;
+              DiskChecker.checkDir(
+                new File(publicDirDestPath.toUri().getPath()));
+            }
+            publicDirDestPath =
+                new Path(publicDirDestPath, Long.toString(publicRsrc
+                  .nextUniqueNumber()));
-                lfs, null, conf, publicDirDestPath, resource, new Random())),
+                lfs, null, conf, publicDirDestPath, resource)),
-    @SuppressWarnings("unchecked") // dispatcher not typed
-              assoc.getResource().handle(
-                  new ResourceLocalizedEvent(key,
-                    local, FileUtil.getDU(new File(local.toUri()))));
+              publicRsrc.handle(new ResourceLocalizedEvent(key, local, FileUtil
+                .getDU(new File(local.toUri()))));
-              dispatcher.getEventHandler().handle(
-                  new ContainerResourceFailedEvent(
-                    assoc.getContext().getContainerId(),
-                    assoc.getResource().getRequest(), e.getCause()));
-              List<LocalizerResourceRequestEvent> reqs;
+              LocalResourceRequest req = assoc.getResource().getRequest();
+              publicRsrc.handle(new ResourceFailedLocalizationEvent(req, e
+                .getCause()));
-                LocalResourceRequest req = assoc.getResource().getRequest();
+                List<LocalizerResourceRequestEvent> reqs;
-              // let the other containers know about the localization failure
-              for (LocalizerResourceRequestEvent reqEvent : reqs) {
-                dispatcher.getEventHandler().handle(
-                    new ContainerResourceFailedEvent(
-                        reqEvent.getContext().getContainerId(),
-                        reqEvent.getResource().getRequest(), e.getCause()));
-              }
-    // TODO this sucks. Fix it later
-    @SuppressWarnings("unchecked") // dispatcher not typed
+      String user = context.getUser();
+      ApplicationId applicationId =
+          context.getContainerId().getApplicationAttemptId().getApplicationId();
-          response.addResource(next);
+          try {
+            ArrayList<ResourceLocalizationSpec> rsrcs =
+                new ArrayList<ResourceLocalizationSpec>();
+            ResourceLocalizationSpec rsrc =
+                NodeManagerBuilderUtils.newResourceLocalizationSpec(next,
+                  getPathForLocalization(next));
+            rsrcs.add(rsrc);
+            response.setResourceSpecs(rsrcs);
+          } catch (IOException e) {
+            LOG.error("local path for PRIVATE localization could not be found."
+                + "Disks might have failed.", e);
+          } catch (URISyntaxException e) {
+            // TODO fail? Already translated several times...
+          }
+      ArrayList<ResourceLocalizationSpec> rsrcs =
+          new ArrayList<ResourceLocalizationSpec>();
+       /*
+        * TODO : It doesn't support multiple downloads per ContainerLocalizer
+        * at the same time. We need to think whether we should support this.
+        */
-              assoc.getResource().handle(
-                  new ResourceLocalizedEvent(req,
-                    ConverterUtils.getPathFromYarnURL(stat.getLocalPath()),
-                    stat.getLocalSize()));
+            getLocalResourcesTracker(req.getVisibility(), user, applicationId)
+              .handle(
+                new ResourceLocalizedEvent(req, ConverterUtils
+                  .getPathFromYarnURL(stat.getLocalPath()), stat.getLocalSize()));
-              response.addResource(next);
+              try {
+                ResourceLocalizationSpec resource =
+                    NodeManagerBuilderUtils.newResourceLocalizationSpec(next,
+                      getPathForLocalization(next));
+                rsrcs.add(resource);
+              } catch (IOException e) {
+                LOG.error("local path for PRIVATE localization could not be " +
+                  "found. Disks might have failed.", e);
+              } catch (URISyntaxException e) {
+                  //TODO fail? Already translated several times...
+              }
-            // TODO: Why is this event going directly to the container. Why not
-            // the resource itself? What happens to the resource? Is it removed?
-            dispatcher.getEventHandler().handle(
-                new ContainerResourceFailedEvent(context.getContainerId(),
-                  req, stat.getException()));
+            getLocalResourcesTracker(req.getVisibility(), user, applicationId)
+              .handle(
+                new ResourceFailedLocalizationEvent(req, stat.getException()));
-            dispatcher.getEventHandler().handle(
-                new ContainerResourceFailedEvent(context.getContainerId(),
-                  req, stat.getException()));
+            getLocalResourcesTracker(req.getVisibility(), user, applicationId)
+              .handle(
+                new ResourceFailedLocalizationEvent(req, stat.getException()));
+      response.setResourceSpecs(rsrcs);
+    private Path getPathForLocalization(LocalResource rsrc) throws IOException,
+        URISyntaxException {
+      String user = context.getUser();
+      ApplicationId appId =
+          context.getContainerId().getApplicationAttemptId().getApplicationId();
+      LocalResourceVisibility vis = rsrc.getVisibility();
+      LocalResourcesTracker tracker =
+          getLocalResourcesTracker(vis, user, appId);
+      String cacheDirectory = null;
+      if (vis == LocalResourceVisibility.PRIVATE) {// PRIVATE Only
+        cacheDirectory = getUserFileCachePath(user);
+      } else {// APPLICATION ONLY
+        cacheDirectory = getUserAppCachePath(user, appId.toString());
+      }
+      Path dirPath =
+          dirsHandler.getLocalPathForWrite(cacheDirectory,
+            ContainerLocalizer.getEstimatedSize(rsrc), false);
+      dirPath = tracker.getPathForLocalization(new LocalResourceRequest(rsrc),
+        dirPath);
+      return new Path (dirPath, Long.toString(tracker.nextUniqueNumber()));
+    }
+

MOV26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS31 INS31 INS31 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS31 INS43 INS42 INS60 INS25 INS21 MOV21 INS42 INS43 INS42 INS60 INS41 INS42 INS43 INS42 INS43 INS42 INS60 INS41 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS42 INS39 INS59 INS27 INS8 INS8 INS32 INS42 INS43 INS59 INS42 INS42 INS42 INS43 INS59 INS42 INS60 INS60 INS60 INS21 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS25 INS60 INS21 INS41 INS42 INS32 INS42 INS34 INS21 INS53 INS21 INS52 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS43 INS59 INS43 INS59 INS74 INS59 INS32 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS43 INS59 INS7 INS14 INS42 INS42 INS40 INS40 INS32 INS14 INS32 INS9 INS42 INS9 INS48 INS45 INS40 INS40 INS40 INS42 INS40 INS40 INS45 INS40 INS40 INS40 INS42 INS40 INS40 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS40 INS21 INS21 INS42 INS42 INS32 INS42 INS32 INS43 INS42 INS32 INS42 INS42 INS27 INS43 INS27 INS42 INS42 INS27 INS42 INS9 INS48 INS42 INS42 INS32 INS42 INS8 INS42 INS42 INS74 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS32 INS9 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS40 INS45 INS42 INS40 INS45 INS45 INS42 INS42 MOV32 INS42 MOV21 INS54 INS43 INS43 INS8 MOV32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS8 INS12 INS12 INS42 INS42 INS54 INS42 INS42 INS42 INS42 INS32 INS42 INS60 INS25 INS21 INS60 INS60 INS21 MOV21 INS44 INS8 INS44 INS8 INS8 INS12 INS12 UPD42 INS32 INS42 INS42 UPD43 MOV32 UPD42 INS32 INS42 INS42 UPD43 MOV32 INS42 INS42 INS43 INS59 INS38 INS8 INS7 INS74 INS59 INS43 INS59 INS32 INS43 INS42 INS21 INS43 INS42 INS32 INS60 MOV21 INS44 INS8 INS44 INS8 INS42 UPD42 MOV42 UPD42 INS42 UPD42 MOV42 UPD42 INS42 INS42 INS32 INS32 INS21 INS21 INS42 INS14 INS43 INS43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS43 INS59 INS43 INS42 INS21 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS32 INS43 INS42 INS32 MOV60 MOV21 INS42 INS42 INS74 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 UPD42 UPD42 INS42 INS42 INS32 UPD42 UPD42 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS32 UPD42 MOV42 INS43 INS43 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS43 INS32 INS42 INS42 UPD42 MOV42 MOV60 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS32 INS42 UPD43 INS42 INS42 INS42 UPD42 DEL83 DEL42 DEL43 DEL14 DEL42 DEL45 DEL79 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL45 DEL79 DEL8 DEL8
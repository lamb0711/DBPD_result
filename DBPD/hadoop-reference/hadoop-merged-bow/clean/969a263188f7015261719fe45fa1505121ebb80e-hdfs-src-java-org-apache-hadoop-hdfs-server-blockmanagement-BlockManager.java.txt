HDFS-2191.  Move datanodeMap from FSNamesystem to DatanodeManager.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1151339 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.protocol.BlockListAsLongs.BlockReportIterator;
+import org.apache.hadoop.hdfs.protocol.DatanodeID;
-import org.apache.hadoop.hdfs.protocol.BlockListAsLongs.BlockReportIterator;
+import org.apache.hadoop.hdfs.protocol.UnregisteredNodeException;
+import org.apache.hadoop.hdfs.server.protocol.BlocksWithLocations;
+import org.apache.hadoop.hdfs.server.protocol.BlocksWithLocations.BlockWithLocations;
-  
+
-    //
-    //
-    //
-    //
+
+    // Dump all datanodes
+    getDatanodeManager().datanodeDump(out);
-  public ArrayList<String> getValidLocations(Block block) {
+  private List<String> getValidLocations(Block block) {
+   /** Get all blocks with location information from a datanode. */
+  public BlocksWithLocations getBlocksWithLocations(final DatanodeID datanode,
+      final long size) throws UnregisteredNodeException {
+    final DatanodeDescriptor node = getDatanodeManager().getDatanode(datanode);
+    if (node == null) {
+      NameNode.stateChangeLog.warn("BLOCK* NameSystem.getBlocks: "
+          + "Asking for blocks from an unrecorded node " + datanode.getName());
+      throw new HadoopIllegalArgumentException(
+          "Datanode " + datanode.getName() + " not found.");
+    }
+
+    int numBlocks = node.numBlocks();
+    if(numBlocks == 0) {
+      return new BlocksWithLocations(new BlockWithLocations[0]);
+    }
+    Iterator<BlockInfo> iter = node.getBlockIterator();
+    int startBlock = DFSUtil.getRandom().nextInt(numBlocks); // starting from a random block
+    // skip blocks
+    for(int i=0; i<startBlock; i++) {
+      iter.next();
+    }
+    List<BlockWithLocations> results = new ArrayList<BlockWithLocations>();
+    long totalSize = 0;
+    BlockInfo curBlock;
+    while(totalSize<size && iter.hasNext()) {
+      curBlock = iter.next();
+      if(!curBlock.isComplete())  continue;
+      totalSize += addBlock(curBlock, results);
+    }
+    if(totalSize<size) {
+      iter = node.getBlockIterator(); // start from the beginning
+      for(int i=0; i<startBlock&&totalSize<size; i++) {
+        curBlock = iter.next();
+        if(!curBlock.isComplete())  continue;
+        totalSize += addBlock(curBlock, results);
+      }
+    }
+
+    return new BlocksWithLocations(
+        results.toArray(new BlockWithLocations[results.size()]));
+  }
+
+   
-        out.println(namesystem.getDatanode(entry.getKey()).getName() + blocks);
+        out.println(datanodeManager.getDatanode(entry.getKey()).getName() + blocks);
-    DatanodeDescriptor node = namesystem.getDatanode(dn);
+    DatanodeDescriptor node = getDatanodeManager().getDatanode(dn);
-    DatanodeDescriptor node = namesystem.getDatanode(dn);
+    DatanodeDescriptor node = getDatanodeManager().getDatanode(dn);
-  public void updateState() {
+  void updateState() {
-  public void processPendingReplications() {
+  private void processPendingReplications() {
+
+   * Get all valid locations of the block & add the block to results
+   * return the length of the added block; 0 if the block is not added
+   */
+  private long addBlock(Block block, List<BlockWithLocations> results) {
+    final List<String> machineSet = getValidLocations(block);
+    if(machineSet.size() == 0) {
+      return 0;
+    } else {
+      results.add(new BlockWithLocations(block, 
+          machineSet.toArray(new String[machineSet.size()])));
+      return block.getNumBytes();
+    }
+  }
+
+  /**
-      delHintNode = namesystem.getDatanode(delHint);
+      delHintNode = datanodeManager.getDatanode(delHint);
-      DatanodeDescriptor dn = namesystem.getDatanode(nodeId);
+      final DatanodeDescriptor dn = datanodeManager.getDatanode(nodeId);
-          namesystem.blockInvalidateLimit);
+          getDatanodeManager().blockInvalidateLimit);
-      for (int blkCount = 0; blkCount < namesystem.blockInvalidateLimit
+      for (int blkCount = 0; blkCount < getDatanodeManager().blockInvalidateLimit

MOV26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 UPD83 INS74 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 UPD83 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS21 INS43 MOV43 INS65 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS42 INS60 INS25 INS60 INS25 INS60 INS60 INS24 INS60 INS60 INS60 INS61 INS25 INS41 INS65 INS43 INS42 INS74 INS42 INS60 INS25 INS32 INS42 INS66 INS42 INS83 INS43 INS59 INS27 INS8 INS39 INS59 INS27 INS8 INS74 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS74 INS59 INS39 INS59 INS43 INS59 INS27 INS8 INS27 INS8 INS14 MOV43 MOV43 INS66 INS66 INS42 INS43 INS43 INS83 INS74 INS59 INS27 INS8 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS53 INS42 INS32 INS42 INS34 INS41 INS43 INS43 INS42 INS32 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS21 INS43 INS43 INS42 INS14 INS42 INS34 INS42 INS42 INS27 INS32 INS21 INS25 INS21 INS42 INS42 INS21 INS24 INS43 INS32 INS42 INS42 INS43 INS43 INS42 INS32 INS32 INS34 INS41 INS21 INS41 INS42 INS32 INS42 INS42 INS32 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS34 INS32 INS42 INS42 UPD74 MOV74 INS42 INS42 INS42 INS42 INS7 INS38 INS18 INS7 INS7 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS3 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS32 INS83 MOV74 INS42 INS40 INS42 INS27 INS43 INS27 INS43 INS3 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS32 INS42 INS32 INS42 INS32 INS39 INS59 INS27 INS27 INS42 INS21 INS25 INS21 INS5 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS14 INS42 INS42 INS45 INS45 INS32 INS42 INS45 INS32 INS45 INS42 INS5 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS7 INS38 INS18 INS7 INS43 INS85 INS42 INS42 INS43 INS42 INS32 UPD42 UPD42 MOV74 INS22 INS22 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS3 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS32 INS42 INS42 INS43 INS85 INS42 INS42 UPD42 INS42 DEL83 DEL40 DEL40
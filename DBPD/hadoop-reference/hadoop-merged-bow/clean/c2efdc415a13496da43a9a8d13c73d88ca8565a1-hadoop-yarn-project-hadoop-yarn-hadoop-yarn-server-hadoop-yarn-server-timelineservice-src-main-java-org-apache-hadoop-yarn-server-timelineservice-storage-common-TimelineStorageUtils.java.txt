YARN-3863. Support complex filters in TimelineReader (Varun Saxena via sjlee)

+import java.io.IOException;
+import java.util.EnumSet;
+import java.util.HashMap;
-import java.io.IOException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineCompareFilter;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineCompareOp;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineKeyValueFilter;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineExistsFilter;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineFilter;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineFilter.TimelineFilterType;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineFilterList;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineKeyValuesFilter;
+import org.apache.hadoop.yarn.server.timelineservice.storage.TimelineReader.Field;
+  private static final Log LOG = LogFactory.getLog(TimelineStorageUtils.class);
+
+   * Check if we have a certain field amongst fields to retrieve. This method
+   * checks against {@link Field#ALL} as well because that would mean field
+   * passed needs to be matched.
+   *
+   * @param fieldsToRetrieve fields to be retrieved.
+   * @param requiredField fields to be checked in fieldsToRetrieve.
+   * @return true if has the required field, false otherwise.
+   */
+  public static boolean hasField(EnumSet<Field> fieldsToRetrieve,
+      Field requiredField) {
+    return fieldsToRetrieve.contains(Field.ALL) ||
+        fieldsToRetrieve.contains(requiredField);
+  }
+
+  /**
+   * Matches key-values filter. Used for relatesTo/isRelatedTo filters.
-   * @param entityRelations the relations of an entity
-   * @param relationFilters the relations for filtering
-   * @return a boolean flag to indicate if both match
+   * @param entity entity which holds relatesTo/isRelatedTo relations which we
+   *     will match against.
+   * @param keyValuesFilter key-values filter.
+   * @param entityFiltersType type of filters we are trying to match.
+   * @return true, if filter matches, false otherwise.
-  public static boolean matchRelations(
-      Map<String, Set<String>> entityRelations,
-      Map<String, Set<String>> relationFilters) {
-    for (Map.Entry<String, Set<String>> relation : relationFilters.entrySet()) {
-      Set<String> ids = entityRelations.get(relation.getKey());
-      if (ids == null) {
+  private static boolean matchKeyValuesFilter(TimelineEntity entity,
+      TimelineKeyValuesFilter keyValuesFilter,
+      TimelineEntityFiltersType entityFiltersType) {
+    Map<String, Set<String>> relations = null;
+    if (entityFiltersType == TimelineEntityFiltersType.IS_RELATED_TO) {
+      relations = entity.getIsRelatedToEntities();
+    } else if (entityFiltersType == TimelineEntityFiltersType.RELATES_TO) {
+      relations = entity.getRelatesToEntities();
+    }
+    if (relations == null) {
+      return false;
+    }
+    Set<String> ids = relations.get(keyValuesFilter.getKey());
+    if (ids == null) {
+      return false;
+    }
+    boolean matched = false;
+    for (Object id : keyValuesFilter.getValues()) {
+      // Matches if id is found amongst the relationships for an entity and
+      // filter's compare op is EQUAL.
+      // If compare op is NOT_EQUAL, for a match to occur, id should not be
+      // found amongst relationships for an entity.
+      matched = !(ids.contains(id) ^
+          keyValuesFilter.getCompareOp() == TimelineCompareOp.EQUAL);
+      if (!matched) {
-      for (String id : relation.getValue()) {
-        if (!ids.contains(id)) {
+    }
+    return true;
+  }
+
+  /**
+   * Matches relatesto.
+   *
+   * @param entity entity which holds relatesto relations.
+   * @param relatesTo the relations for filtering.
+   * @return true, if filter matches, false otherwise.
+   * @throws IOException if an unsupported filter for matching relations is
+   *     being matched.
+   */
+  public static boolean matchRelatesTo(TimelineEntity entity,
+      TimelineFilterList relatesTo) throws IOException {
+    return matchFilters(
+        entity, relatesTo, TimelineEntityFiltersType.RELATES_TO);
+  }
+
+  /**
+   * Matches isrelatedto.
+   *
+   * @param entity entity which holds isRelatedTo relations.
+   * @param isRelatedTo the relations for filtering.
+   * @return true, if filter matches, false otherwise.
+   * @throws IOException if an unsupported filter for matching relations is
+   *     being matched.
+   */
+  public static boolean matchIsRelatedTo(TimelineEntity entity,
+      TimelineFilterList isRelatedTo) throws IOException {
+    return matchFilters(
+        entity, isRelatedTo, TimelineEntityFiltersType.IS_RELATED_TO);
+  }
+
+  /**
+   * Matches key-value filter. Used for config and info filters.
+   *
+   * @param entity entity which holds the config/info which we will match
+   *     against.
+   * @param kvFilter a key-value filter.
+   * @param entityFiltersType type of filters we are trying to match.
+   * @return true, if filter matches, false otherwise.
+   */
+  private static boolean matchKeyValueFilter(TimelineEntity entity,
+      TimelineKeyValueFilter kvFilter,
+      TimelineEntityFiltersType entityFiltersType) {
+    Map<String, ? extends Object> map = null;
+    // Supported only for config and info filters.
+    if (entityFiltersType == TimelineEntityFiltersType.CONFIG) {
+      map = entity.getConfigs();
+    } else if (entityFiltersType == TimelineEntityFiltersType.INFO) {
+      map = entity.getInfo();
+    }
+    if (map == null) {
+      return false;
+    }
+    Object value = map.get(kvFilter.getKey());
+    if (value == null) {
+      return false;
+    }
+    // Matches if filter's value is equal to the value of the key and filter's
+    // compare op is EQUAL.
+    // If compare op is NOT_EQUAL, for a match to occur, value should not be
+    // equal to the value of the key.
+    return !(value.equals(kvFilter.getValue()) ^
+        kvFilter.getCompareOp() == TimelineCompareOp.EQUAL);
+  }
+
+  /**
+   * Matches config filters.
+   *
+   * @param entity entity which holds a map of config key-value pairs.
+   * @param configFilters list of info filters.
+   * @return a boolean flag to indicate if both match.
+   * @throws IOException if an unsupported filter for matching config filters is
+   *     being matched.
+   */
+  public static boolean matchConfigFilters(TimelineEntity entity,
+      TimelineFilterList configFilters) throws IOException {
+    return
+        matchFilters(entity, configFilters, TimelineEntityFiltersType.CONFIG);
+  }
+
+  /**
+   * Matches info filters.
+   *
+   * @param entity entity which holds a map of info key-value pairs.
+   * @param infoFilters list of info filters.
+   * @return a boolean flag to indicate if both match.
+   * @throws IOException if an unsupported filter for matching info filters is
+   *     being matched.
+   */
+  public static boolean matchInfoFilters(TimelineEntity entity,
+      TimelineFilterList infoFilters) throws IOException {
+    return matchFilters(entity, infoFilters, TimelineEntityFiltersType.INFO);
+  }
+
+  /**
+   * Matches exists filter. Used for event filters.
+   *
+   * @param entity entity which holds the events which we will match against.
+   * @param existsFilter exists filter.
+   * @param entityFiltersType type of filters we are trying to match.
+   * @return true, if filter matches, false otherwise.
+   */
+  private static boolean matchExistsFilter(TimelineEntity entity,
+      TimelineExistsFilter existsFilter,
+      TimelineEntityFiltersType entityFiltersType) {
+    // Currently exists filter is only supported for event filters.
+    if (entityFiltersType != TimelineEntityFiltersType.EVENT) {
+      return false;
+    }
+    Set<String> eventIds = new HashSet<String>();
+    for (TimelineEvent event : entity.getEvents()) {
+      eventIds.add(event.getId());
+    }
+    // Matches if filter's value is contained in the list of events filter's
+    // compare op is EQUAL.
+    // If compare op is NOT_EQUAL, for a match to occur, value should not be
+    // contained in the list of events.
+    return !(eventIds.contains(existsFilter.getValue()) ^
+        existsFilter.getCompareOp() == TimelineCompareOp.EQUAL);
+  }
+
+  /**
+   * Matches event filters.
+   *
+   * @param entity entity which holds a set of event objects.
+   * @param eventFilters the set of event Ids for filtering.
+   * @return a boolean flag to indicate if both match.
+   * @throws IOException if an unsupported filter for matching event filters is
+   *     being matched.
+   */
+  public static boolean matchEventFilters(TimelineEntity entity,
+      TimelineFilterList eventFilters) throws IOException {
+    return matchFilters(entity, eventFilters, TimelineEntityFiltersType.EVENT);
+  }
+
+  /**
+   * Compare two values based on comparison operator.
+   *
+   * @param compareOp comparison operator.
+   * @param val1 value 1.
+   * @param val2 value 2.
+   * @return true, if relation matches, false otherwise
+   */
+  private static boolean compareValues(TimelineCompareOp compareOp,
+      long val1, long val2) {
+    switch (compareOp) {
+    case LESS_THAN:
+      return val1 < val2;
+    case LESS_OR_EQUAL:
+      return val1 <= val2;
+    case EQUAL:
+      return val1 == val2;
+    case NOT_EQUAL:
+      return val1 != val2;
+    case GREATER_OR_EQUAL:
+      return val1 >= val2;
+    case GREATER_THAN:
+      return val1 > val2;
+    default:
+      throw new RuntimeException("Unknown TimelineCompareOp " +
+          compareOp.name());
+    }
+  }
+
+  /**
+   * Matches compare filter. Used for metric filters.
+   *
+   * @param entity entity which holds the metrics which we will match against.
+   * @param compareFilter compare filter.
+   * @param entityFiltersType type of filters we are trying to match.
+   * @return true, if filter matches, false otherwise.
+   * @throws IOException if metric filters holds non integral values.
+   */
+  private static boolean matchCompareFilter(TimelineEntity entity,
+      TimelineCompareFilter compareFilter,
+      TimelineEntityFiltersType entityFiltersType) throws IOException {
+    // Currently exists filter is only supported for metric filters.
+    if (entityFiltersType != TimelineEntityFiltersType.METRIC) {
+      return false;
+    }
+    // We expect only integral values(short/int/long) for metric filters.
+    if (!isIntegralValue(compareFilter.getValue())) {
+      throw new IOException("Metric filters has non integral values");
+    }
+    Map<String, TimelineMetric> metricMap =
+        new HashMap<String, TimelineMetric>();
+    for (TimelineMetric metric : entity.getMetrics()) {
+      metricMap.put(metric.getId(), metric);
+    }
+    TimelineMetric metric = metricMap.get(compareFilter.getKey());
+    if (metric == null) {
+      return false;
+    }
+    // We will be using the latest value of metric to compare.
+    return compareValues(compareFilter.getCompareOp(),
+        metric.getValuesJAXB().firstEntry().getValue().longValue(),
+        ((Number)compareFilter.getValue()).longValue());
+  }
+
+  /**
+   * Matches metric filters.
+   *
+   * @param entity entity which holds a set of metric objects.
+   * @param metricFilters list of metric filters.
+   * @return a boolean flag to indicate if both match.
+   * @throws IOException if an unsupported filter for matching metric filters is
+   *     being matched.
+   */
+  public static boolean matchMetricFilters(TimelineEntity entity,
+      TimelineFilterList metricFilters) throws IOException {
+    return matchFilters(
+        entity, metricFilters, TimelineEntityFiltersType.METRIC);
+  }
+
+  /**
+   * Common routine to match different filters. Iterates over a filter list and
+   * calls routines based on filter type.
+   *
+   * @param entity Timeline entity.
+   * @param filters filter list.
+   * @param entityFiltersType type of filters which are being matched.
+   * @return a boolean flag to indicate if filter matches.
+   * @throws IOException if an unsupported filter for matching this specific
+   *     filter is being matched.
+   */
+  private static boolean matchFilters(TimelineEntity entity,
+      TimelineFilterList filters, TimelineEntityFiltersType entityFiltersType)
+      throws IOException {
+    if (filters == null || filters.getFilterList().isEmpty()) {
+      return false;
+    }
+    TimelineFilterList.Operator operator = filters.getOperator();
+    for (TimelineFilter filter : filters.getFilterList()) {
+      TimelineFilterType filterType = filter.getFilterType();
+      if (!entityFiltersType.isValidFilter(filterType)) {
+        throw new IOException("Unsupported filter " + filterType);
+      }
+      boolean matched = false;
+      switch (filterType) {
+      case LIST:
+        matched = matchFilters(entity, (TimelineFilterList)filter,
+            entityFiltersType);
+        break;
+      case COMPARE:
+        matched = matchCompareFilter(entity, (TimelineCompareFilter)filter,
+            entityFiltersType);
+        break;
+      case EXISTS:
+        matched = matchExistsFilter(entity, (TimelineExistsFilter)filter,
+            entityFiltersType);
+        break;
+      case KEY_VALUE:
+        matched = matchKeyValueFilter(entity, (TimelineKeyValueFilter)filter,
+            entityFiltersType);
+        break;
+      case KEY_VALUES:
+        matched = matchKeyValuesFilter(entity, (TimelineKeyValuesFilter)filter,
+            entityFiltersType);
+        break;
+      default:
+        throw new IOException("Unsupported filter " + filterType);
+      }
+      if (!matched) {
+        if(operator == TimelineFilterList.Operator.AND) {
+      } else {
+        if(operator == TimelineFilterList.Operator.OR) {
+          return true;
+        }
-    return true;
-  }
-
-  /**
-   *
-   * @param map the map of key/value pairs in an entity
-   * @param filters the map of key/value pairs for filtering
-   * @return a boolean flag to indicate if both match
-   */
-  public static boolean matchFilters(Map<String, ? extends Object> map,
-      Map<String, ? extends Object> filters) {
-    for (Map.Entry<String, ? extends Object> filter : filters.entrySet()) {
-      Object value = map.get(filter.getKey());
-      if (value == null) {
-        return false;
-      }
-      if (!value.equals(filter.getValue())) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   *
-   * @param entityEvents the set of event objects in an entity
-   * @param eventFilters the set of event Ids for filtering
-   * @return a boolean flag to indicate if both match
-   */
-  public static boolean matchEventFilters(Set<TimelineEvent> entityEvents,
-      Set<String> eventFilters) {
-    Set<String> eventIds = new HashSet<String>();
-    for (TimelineEvent event : entityEvents) {
-      eventIds.add(event.getId());
-    }
-    for (String eventFilter : eventFilters) {
-      if (!eventIds.contains(eventFilter)) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   *
-   * @param metrics the set of metric objects in an entity
-   * @param metricFilters the set of metric Ids for filtering
-   * @return a boolean flag to indicate if both match
-   */
-  public static boolean matchMetricFilters(Set<TimelineMetric> metrics,
-      Set<String> metricFilters) {
-    Set<String> metricIds = new HashSet<String>();
-    for (TimelineMetric metric : metrics) {
-      metricIds.add(metric.getId());
-    }
-
-    for (String metricFilter : metricFilters) {
-      if (!metricIds.contains(metricFilter)) {
-        return false;
-      }
-    }
-    return true;
+    return operator == TimelineFilterList.Operator.AND;
+
+  /**
+   * Helper method for reading relationship.
+   *
+   * @param <T> Describes the type of column prefix.
+   * @param entity entity to fill.
+   * @param result result from HBase.
+   * @param prefix column prefix.
+   * @param isRelatedTo if true, means relationship is to be added to
+   *     isRelatedTo, otherwise its added to relatesTo.
+   * @throws IOException if any problem is encountered while reading result.
+   */
+  public static <T> void readRelationship(
+      TimelineEntity entity, Result result, ColumnPrefix<T> prefix,
+      boolean isRelatedTo) throws IOException {
+    // isRelatedTo and relatesTo are of type Map<String, Set<String>>
+    Map<String, Object> columns = prefix.readResults(result);
+    for (Map.Entry<String, Object> column : columns.entrySet()) {
+      for (String id : Separator.VALUES.splitEncoded(
+          column.getValue().toString())) {
+        if (isRelatedTo) {
+          entity.addIsRelatedToEntity(column.getKey(), id);
+        } else {
+          entity.addRelatesToEntity(column.getKey(), id);
+        }
+      }
+    }
+  }
+
+  /**
+   * Helper method for reading key-value pairs for either info or config.
+   *
+   * @param <T> Describes the type of column prefix.
+   * @param entity entity to fill.
+   * @param result result from HBase.
+   * @param prefix column prefix.
+   * @param isConfig if true, means we are reading configs, otherwise info.
+   * @throws IOException if any problem is encountered while reading result.
+   */
+  public static <T> void readKeyValuePairs(
+      TimelineEntity entity, Result result, ColumnPrefix<T> prefix,
+      boolean isConfig) throws IOException {
+    // info and configuration are of type Map<String, Object or String>
+    Map<String, Object> columns = prefix.readResults(result);
+    if (isConfig) {
+      for (Map.Entry<String, Object> column : columns.entrySet()) {
+        entity.addConfig(column.getKey(), column.getValue().toString());
+      }
+    } else {
+      entity.addInfo(columns);
+    }
+  }
+
+  /**
+   * Read events from the entity table or the application table. The column name
+   * is of the form "eventId=timestamp=infoKey" where "infoKey" may be omitted
+   * if there is no info associated with the event.
+   *
+   * @param <T> Describes the type of column prefix.
+   * @param entity entity to fill.
+   * @param result HBase Result.
+   * @param prefix column prefix.
+   * @throws IOException if any problem is encountered while reading result.
+   */
+  public static <T> void readEvents(TimelineEntity entity, Result result,
+      ColumnPrefix<T> prefix) throws IOException {
+    Map<String, TimelineEvent> eventsMap = new HashMap<>();
+    Map<?, Object> eventsResult =
+        prefix.readResultsHavingCompoundColumnQualifiers(result);
+    for (Map.Entry<?, Object> eventResult : eventsResult.entrySet()) {
+      byte[][] karr = (byte[][])eventResult.getKey();
+      // the column name is of the form "eventId=timestamp=infoKey"
+      if (karr.length == 3) {
+        String id = Bytes.toString(karr[0]);
+        long ts = TimelineStorageUtils.invertLong(Bytes.toLong(karr[1]));
+        String key = Separator.VALUES.joinEncoded(id, Long.toString(ts));
+        TimelineEvent event = eventsMap.get(key);
+        if (event == null) {
+          event = new TimelineEvent();
+          event.setId(id);
+          event.setTimestamp(ts);
+          eventsMap.put(key, event);
+        }
+        // handle empty info
+        String infoKey = karr[2].length == 0 ? null : Bytes.toString(karr[2]);
+        if (infoKey != null) {
+          event.addInfo(infoKey, eventResult.getValue());
+        }
+      } else {
+        LOG.warn("incorrectly formatted column name: it will be discarded");
+        continue;
+      }
+    }
+    Set<TimelineEvent> eventsSet = new HashSet<>(eventsMap.values());
+    entity.addEvents(eventsSet);
+  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 MOV29 MOV83 MOV83 MOV39 UPD42 MOV42 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 MOV44 MOV8 MOV29 MOV83 MOV83 MOV39 UPD42 MOV42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 MOV44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 MOV8 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 MOV29 MOV83 MOV83 MOV39 MOV42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS73 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS73 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS73 INS39 INS42 INS44 INS44 INS44 INS43 MOV8 INS42 INS42 INS32 INS65 INS74 INS42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 UPD42 MOV42 INS43 INS42 INS43 UPD42 INS60 INS25 INS25 INS60 MOV25 INS60 MOV70 INS65 INS65 INS43 INS42 INS43 INS42 UPD42 MOV42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS25 MOV60 MOV25 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS41 INS65 INS65 INS43 UPD42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS50 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS25 INS60 MOV70 INS60 INS25 INS41 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS60 INS70 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS42 INS60 INS70 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS42 INS60 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS42 INS60 INS60 INS21 INS42 INS42 INS57 INS66 INS66 INS65 INS66 INS66 UPD42 UPD66 UPD42 UPD66 UPD66 UPD43 MOV43 UPD43 MOV43 UPD42 MOV42 INS27 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 UPD42 MOV42 INS42 INS42 MOV74 INS59 INS27 INS8 INS25 INS27 MOV8 MOV74 MOV59 INS39 INS59 INS44 INS66 UPD42 UPD66 UPD42 UPD66 UPD66 INS42 INS66 INS66 UPD42 MOV42 UPD42 MOV42 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 MOV74 INS59 INS27 INS8 INS25 INS27 MOV8 MOV43 INS38 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS27 MOV8 INS32 INS38 INS66 UPD42 UPD66 UPD66 UPD66 INS42 INS66 INS66 INS42 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS53 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS27 INS8 INS38 INS8 INS74 INS59 INS32 INS43 INS59 INS27 INS8 INS32 INS66 UPD42 UPD66 UPD66 UPD66 INS42 INS66 INS66 INS42 INS42 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS27 INS8 INS43 INS59 INS44 INS32 INS8 INS27 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS43 INS43 INS74 INS59 INS44 INS32 INS8 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS43 INS74 INS59 INS42 INS8 INS8 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS43 UPD74 INS59 INS74 INS59 INS32 MOV74 MOV59 INS32 INS43 INS67 UPD42 UPD42 INS32 INS32 INS42 INS33 INS42 INS40 INS21 INS27 INS8 INS42 INS33 INS42 INS9 MOV43 INS42 UPD42 UPD42 INS21 MOV25 INS42 INS42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS42 INS33 INS42 INS40 INS21 INS27 INS8 INS42 INS33 INS36 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS40 INS42 INS42 INS36 INS42 INS42 INS42 INS40 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS14 INS42 INS40 INS41 INS32 INS53 INS43 MOV43 MOV43 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS40 INS27 INS32 INS41 INS40 INS42 INS32 INS43 INS42 INS42 INS42 INS60 INS25 INS60 INS50 INS25 INS42 INS40 INS42 INS42 INS43 MOV43 INS43 INS42 INS32 UPD74 MOV74 UPD42 MOV42 INS42 INS42 INS70 INS42 INS42 UPD43 MOV43 MOV43 INS43 INS42 INS32 INS70 INS21 INS42 INS42 UPD43 INS43 INS42 INS14 INS43 INS76 INS43 INS42 INS32 INS74 INS42 INS42 INS42 INS60 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS7 INS42 INS40 INS21 UPD42 INS7 INS7 INS42 INS40 INS21 INS27 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS9 INS42 INS32 INS14 INS42 INS74 INS42 INS42 INS32 INS9 INS42 INS42 INS32 INS42 INS36 INS42 INS42 INS33 INS32 INS42 INS9 INS42 INS42 INS42 INS43 INS59 INS38 INS8 INS39 INS59 INS42 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS53 INS38 INS8 INS8 INS42 INS42 INS42 INS42 INS42 MOV43 UPD43 INS43 MOV44 INS32 INS8 UPD42 INS42 INS42 INS42 INS42 INS44 INS32 INS8 INS32 UPD42 INS42 INS74 INS42 INS42 INS42 INS42 INS42 INS43 INS76 INS43 INS5 INS59 INS27 INS8 INS8 UPD74 INS32 INS42 INS32 INS7 UPD42 INS42 MOV38 INS42 INS42 INS32 INS7 UPD42 INS32 INS27 INS32 INS27 INS42 INS45 INS32 INS42 INS42 INS43 INS45 INS43 MOV43 INS43 UPD42 UPD42 INS42 INS42 INS42 INS32 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS32 INS53 INS42 INS9 INS42 INS7 INS42 INS7 INS42 INS7 INS42 INS7 INS42 INS7 INS14 INS42 INS25 INS25 UPD42 INS42 INS40 INS42 INS32 INS25 INS74 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS43 INS40 INS42 INS39 INS85 INS85 INS42 INS11 INS40 INS34 INS60 INS60 INS60 INS60 INS25 INS60 INS25 INS21 INS18 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS36 INS42 INS42 INS42 INS32 MOV42 MOV42 MOV32 INS32 INS40 INS42 INS42 INS32 INS32 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS43 INS27 INS27 INS8 INS27 INS8 INS32 INS42 INS42 INS8 INS8 MOV43 INS43 INS43 INS32 INS42 INS5 INS32 MOV43 INS59 INS39 INS59 MOV43 INS59 INS43 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS32 INS42 INS42 INS27 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS11 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS11 INS42 INS42 INS45 INS42 INS42 INS40 INS41 INS42 INS40 MOV41 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS32 INS39 INS85 INS85 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS21 INS21 INS42 INS42 INS16 INS42 INS33 INS21 INS42 INS42 INS45 MOV32 INS27 INS42 INS45 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS9 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS2 UPD42 MOV42 INS42 INS32 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS7 INS32 INS32 INS32 INS27 INS33 INS32 INS32 INS32 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS34 UPD42 MOV42 INS42 INS2 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS34 INS42 INS42 INS2 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS43 INS2 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS34 DEL42 DEL42 DEL42 DEL32 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL60 DEL8 DEL70 DEL42 DEL42 DEL42 DEL44 DEL42 DEL8 DEL70 DEL9 DEL41 DEL43 DEL43 DEL74 DEL74 DEL44 DEL31 DEL43 DEL43 DEL43 DEL76 DEL74 DEL42 DEL44 DEL76 DEL74 DEL42 DEL44 DEL32 DEL32 DEL38 DEL25 DEL8 DEL70 DEL8 DEL31 DEL42 DEL44 DEL74 DEL42 DEL44 DEL31 DEL42 DEL42 DEL42 DEL32 DEL38 DEL9 DEL41
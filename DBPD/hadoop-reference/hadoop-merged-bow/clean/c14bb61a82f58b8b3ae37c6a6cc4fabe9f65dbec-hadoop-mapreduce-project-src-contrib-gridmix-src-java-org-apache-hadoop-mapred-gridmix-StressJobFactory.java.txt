Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1242635 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.concurrent.locks.Condition;
+import java.util.concurrent.atomic.AtomicBoolean;
-  private final Condition condUnderloaded = this.lock.newCondition();
-          lock.lock();
-              //Wait while JT is overloaded.
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("Cluster overloaded in run! Sleeping...");
+              }
+              // sleep 
-                condUnderloaded.await();
+                Thread.sleep(1000);
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("Cluster underloaded in run! Stressing...");
+              }
+                //TODO This in-line read can block submission for large jobs.
+                if (LOG.isDebugEnabled()) {
+                  LOG.debug("Job Selected: " + job.getJobID());
+                }
-                loadStatus.mapSlotsBackfill -= 
-                  calcEffectiveIncompleteMapTasks(
-                    loadStatus.mapSlotCapacity, job.getNumberMaps(), 0.0f);
-                loadStatus.reduceSlotsBackfill -= 
-                  calcEffectiveIncompleteReduceTasks(
-                    loadStatus.reduceSlotCapacity, job.getNumberReduces(), 
-                    0.0f);
-                --loadStatus.numJobsBackfill;
+                
+                // Lock the loadjob as we are making updates
+                int incompleteMapTasks = (int) calcEffectiveIncompleteMapTasks(
+                                                 loadStatus.getMapCapacity(), 
+                                                 job.getNumberMaps(), 0.0f);
+                loadStatus.decrementMapLoad(incompleteMapTasks);
+                
+                int incompleteReduceTasks = 
+                  (int) calcEffectiveIncompleteReduceTasks(
+                          loadStatus.getReduceCapacity(), 
+                          job.getNumberReduces(), 0.0f);
+                loadStatus.decrementReduceLoad(incompleteReduceTasks);
+                  
+                loadStatus.decrementJobLoad(1);
-            lock.unlock();
+            // do nothing
-    lock.lock();
+    ClusterStatus clusterMetrics = item.getStatus();
-      ClusterStatus clusterMetrics = item.getStatus();
-      try {
-        checkLoadAndGetSlotsToBackfill(item,clusterMetrics);
-      } catch (Exception e) {
-        LOG.error("Couldn't get the new Status",e);
-      }
-      if (!loadStatus.overloaded()) {
-        condUnderloaded.signalAll();
-      }
-    } finally {
-      lock.unlock();
+      checkLoadAndGetSlotsToBackfill(item, clusterMetrics);
+    } catch (Exception e) {
+      LOG.error("Couldn't get the new Status",e);
-    loadStatus.mapSlotCapacity = clusterStatus.getMaxMapTasks();
-    loadStatus.reduceSlotCapacity = clusterStatus.getMaxReduceTasks();
+    // update the max cluster capacity incase its updated
+    int mapCapacity = clusterStatus.getMaxMapTasks();
+    loadStatus.updateMapCapacity(mapCapacity);
-    loadStatus.numJobsBackfill = 
-      (int) (maxJobTrackerRatio * clusterStatus.getTaskTrackers())
-        - stats.getNumRunningJob();
-    if (loadStatus.numJobsBackfill <= 0) {
+    int reduceCapacity = clusterStatus.getMaxReduceTasks();
+    
+    loadStatus.updateReduceCapacity(reduceCapacity);
+    
+    int numTrackers = clusterStatus.getTaskTrackers();
+    
+    int jobLoad = 
+      (int) (maxJobTrackerRatio * numTrackers) - stats.getNumRunningJob();
+    loadStatus.updateJobLoad(jobLoad);
+    if (loadStatus.getJobLoad() <= 0) {
-        LOG.debug(System.currentTimeMillis() + " Overloaded is "
+        LOG.debug(System.currentTimeMillis() + " [JobLoad] Overloaded is "
-                  + loadStatus.numJobsBackfill);
+                  + loadStatus.getJobLoad());
-        calcEffectiveIncompleteMapTasks(
-          clusterStatus.getMaxMapTasks(), noOfMaps, mapProgress);
+        calcEffectiveIncompleteMapTasks(mapCapacity, noOfMaps, mapProgress);
-    loadStatus.mapSlotsBackfill = 
-    (int) ((overloadMapTaskMapSlotRatio * clusterStatus.getMaxMapTasks()) 
-           - incompleteMapTasks);
-    if (loadStatus.mapSlotsBackfill <= 0) {
+    
+    int mapSlotsBackFill = 
+      (int) ((overloadMapTaskMapSlotRatio * mapCapacity) - incompleteMapTasks);
+    loadStatus.updateMapLoad(mapSlotsBackFill);
+    
+    if (loadStatus.getMapLoad() <= 0) {
-        LOG.debug(System.currentTimeMillis() + " Overloaded is "
+        LOG.debug(System.currentTimeMillis() + " [MAP-LOAD] Overloaded is "
-                  + loadStatus.mapSlotsBackfill);
+                  + loadStatus.getMapLoad());
-      int noOfReduces = job.getJob().getNumReduceTasks();
+      // Cached the num-reds value in JobStats
+      int noOfReduces = job.getNoOfReds();
-          calcEffectiveIncompleteReduceTasks(
-            clusterStatus.getMaxReduceTasks(), noOfReduces, reduceProgress);
+          calcEffectiveIncompleteReduceTasks(reduceCapacity, noOfReduces, 
+                                             reduceProgress);
-    loadStatus.reduceSlotsBackfill = 
-      (int) ((overloadReduceTaskReduceSlotRatio * clusterStatus.getMaxReduceTasks()) 
+    
+    int reduceSlotsBackFill = 
+      (int)((overloadReduceTaskReduceSlotRatio * reduceCapacity) 
-    if (loadStatus.reduceSlotsBackfill <= 0) {
+    loadStatus.updateReduceLoad(reduceSlotsBackFill);
+    if (loadStatus.getReduceLoad() <= 0) {
-        LOG.debug(System.currentTimeMillis() + " Overloaded is "
+        LOG.debug(System.currentTimeMillis() + " [REDUCE-LOAD] Overloaded is "
-                  + loadStatus.reduceSlotsBackfill);
+                  + loadStatus.getReduceLoad());
-      LOG.debug(System.currentTimeMillis() + " Overloaded is "
+      LOG.debug(System.currentTimeMillis() + " [OVERALL] Overloaded is "
-    int mapSlotsBackfill;
-    int mapSlotCapacity;
-    int reduceSlotsBackfill;
-    int reduceSlotCapacity;
-    int numJobsBackfill;
+    /**
+     * Additional number of map slots that can be requested before
+     * declaring (by Gridmix STRESS mode) the cluster as overloaded. 
+     */
+    private volatile int mapSlotsBackfill;
+    
+    /**
+     * Determines the total map slot capacity of the cluster.
+     */
+    private volatile int mapSlotCapacity;
+    
+    /**
+     * Additional number of reduce slots that can be requested before
+     * declaring (by Gridmix STRESS mode) the cluster as overloaded.
+     */
+    private volatile int reduceSlotsBackfill;
+    
+    /**
+     * Determines the total reduce slot capacity of the cluster.
+     */
+    private volatile int reduceSlotCapacity;
+
+    /**
+     * Determines the max count of running jobs in the cluster.
+     */
+    private volatile int numJobsBackfill;
+    
+    // set the default to true
+    private AtomicBoolean overloaded = new AtomicBoolean(true);
-    public boolean overloaded() {
-      return (mapSlotsBackfill <= 0) || (reduceSlotsBackfill <= 0)
-             || (numJobsBackfill <= 0);
+    public synchronized int getMapLoad() {
+      return mapSlotsBackfill;
-    public String toString() {
+    public synchronized int getMapCapacity() {
+      return mapSlotCapacity;
+    }
+    
+    public synchronized int getReduceLoad() {
+      return reduceSlotsBackfill;
+    }
+    
+    public synchronized int getReduceCapacity() {
+      return reduceSlotCapacity;
+    }
+    
+    public synchronized int getJobLoad() {
+      return numJobsBackfill;
+    }
+    
+    public synchronized void decrementMapLoad(int mapSlotsConsumed) {
+      this.mapSlotsBackfill -= mapSlotsConsumed;
+      updateOverloadStatus();
+    }
+    
+    public synchronized void decrementReduceLoad(int reduceSlotsConsumed) {
+      this.reduceSlotsBackfill -= reduceSlotsConsumed;
+      updateOverloadStatus();
+    }
+
+    public synchronized void decrementJobLoad(int numJobsConsumed) {
+      this.numJobsBackfill -= numJobsConsumed;
+      updateOverloadStatus();
+    }
+    
+    public synchronized void updateMapCapacity(int mapSlotsCapacity) {
+      this.mapSlotCapacity = mapSlotsCapacity;
+      updateOverloadStatus();
+    }
+    
+    public synchronized void updateReduceCapacity(int reduceSlotsCapacity) {
+      this.reduceSlotCapacity = reduceSlotsCapacity;
+      updateOverloadStatus();
+    }
+    
+    public synchronized void updateMapLoad(int mapSlotsBackfill) {
+      this.mapSlotsBackfill = mapSlotsBackfill;
+      updateOverloadStatus();
+    }
+    
+    public synchronized void updateReduceLoad(int reduceSlotsBackfill) {
+      this.reduceSlotsBackfill = reduceSlotsBackfill;
+      updateOverloadStatus();
+    }
+    
+    public synchronized void updateJobLoad(int numJobsBackfill) {
+      this.numJobsBackfill = numJobsBackfill;
+      updateOverloadStatus();
+    }
+    
+    private synchronized void updateOverloadStatus() {
+      overloaded.set((mapSlotsBackfill <= 0) || (reduceSlotsBackfill <= 0)
+                     || (numJobsBackfill <= 0));
+    }
+    
+    public synchronized boolean overloaded() {
+      return overloaded.get();
+    }
+    
+    public synchronized String toString() {

UPD40 INS55 MOV8 MOV25 MOV25 MOV25 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 INS31 MOV31 INS60 INS60 INS60 INS60 INS21 INS60 INS21 INS60 INS21 INS29 MOV83 UPD83 MOV83 INS39 MOV59 INS29 INS83 INS83 INS39 MOV59 INS29 INS83 INS83 INS39 MOV59 INS29 INS83 INS83 INS39 MOV59 INS29 INS83 INS83 INS39 MOV59 INS83 UPD43 MOV43 INS59 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 UPD83 INS83 UPD39 UPD42 INS83 INS83 INS39 INS42 INS8 INS83 INS39 INS59 INS32 INS39 INS59 INS32 INS39 INS59 INS39 INS59 INS32 INS39 INS59 INS32 INS39 INS59 INS32 INS65 INS65 INS65 INS65 INS65 UPD42 UPD42 MOV42 INS14 INS41 INS41 INS41 INS41 INS41 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS39 INS42 INS21 INS21 INS21 INS41 INS42 MOV32 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 MOV32 INS42 INS27 INS42 INS42 INS42 INS32 INS42 INS11 INS42 INS42 INS42 INS32 INS42 INS11 INS42 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS9 INS42 INS42 INS42 INS42 INS42 INS7 INS32 INS7 INS32 INS7 INS32 INS7 INS32 INS7 INS32 INS7 INS32 INS7 INS32 INS7 INS32 INS32 INS32 MOV11 MOV32 INS42 INS42 MOV39 MOV36 INS42 INS42 MOV39 MOV36 INS42 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS42 INS42 MOV27 INS42 INS42 MOV52 UPD42 MOV42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 MOV42 MOV42 UPD42 UPD45 INS42 UPD45 UPD45 INS32 INS42 UPD45 UPD45 INS32 UPD42 MOV42 INS42 UPD45 UPD45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS25 INS32 INS8 INS32 INS8 INS42 INS42 INS21 INS42 INS42 INS21 INS25 INS60 INS21 INS60 INS21 INS32 INS32 INS32 INS8 INS39 INS59 INS32 INS39 INS59 INS32 INS32 INS42 INS42 INS45 UPD42 UPD42 INS34 INS42 INS42 INS45 INS42 INS42 INS21 INS42 INS11 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS39 INS32 INS39 INS32 INS42 INS42 INS27 MOV42 INS32 MOV32 MOV34 MOV42 INS32 MOV32 MOV34 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL22 DEL42 DEL32 DEL59 DEL23 DEL42 DEL42 DEL32 DEL21 DEL40 DEL40 DEL32 DEL7 DEL21 DEL40 DEL40 DEL32 DEL7 DEL21 DEL40 DEL38 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL40 DEL7 DEL40 DEL7 DEL40 DEL40 DEL40 DEL27 DEL7 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL11 DEL7 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL11 DEL7 DEL21 DEL41 DEL83 DEL42 DEL39 DEL23 DEL39 DEL23 DEL39 DEL23 DEL39 DEL23 DEL39 DEL23 DEL55
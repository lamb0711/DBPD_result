YARN-3863. Support complex filters in TimelineReader (Varun Saxena via sjlee)

+import java.util.Set;
-import org.apache.hadoop.hbase.filter.BinaryPrefixComparator;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineFilterList;
+  /**
+   * This method is called only for multiple entity reads.
+   */
-  protected FilterList constructFilterListBasedOnFields() {
-    FilterList list = new FilterList(Operator.MUST_PASS_ONE);
-    TimelineDataToRetrieve dataToRetrieve = getDataToRetrieve();
-    // Fetch all the columns.
-    if (dataToRetrieve.getFieldsToRetrieve().contains(Field.ALL) &&
-        (dataToRetrieve.getConfsToRetrieve() == null ||
-        dataToRetrieve.getConfsToRetrieve().getFilterList().isEmpty()) &&
-        (dataToRetrieve.getMetricsToRetrieve() == null ||
-        dataToRetrieve.getMetricsToRetrieve().getFilterList().isEmpty())) {
-      return list;
+  protected FilterList constructFilterListBasedOnFilters() throws IOException {
+    // Filters here cannot be null for multiple entity reads as they are set in
+    // augmentParams if null.
+    TimelineEntityFilters filters = getFilters();
+    FilterList listBasedOnFilters = new FilterList();
+    // Create filter list based on created time range and add it to
+    // listBasedOnFilters.
+    long createdTimeBegin = filters.getCreatedTimeBegin();
+    long createdTimeEnd = filters.getCreatedTimeEnd();
+    if (createdTimeBegin != 0 || createdTimeEnd != Long.MAX_VALUE) {
+      listBasedOnFilters.addFilter(
+          TimelineFilterUtils.createSingleColValueFiltersByRange(
+          ApplicationColumn.CREATED_TIME, createdTimeBegin, createdTimeEnd));
+    // Create filter list based on metric filters and add it to
+    // listBasedOnFilters.
+    TimelineFilterList metricFilters = filters.getMetricFilters();
+    if (metricFilters != null && !metricFilters.getFilterList().isEmpty()) {
+      listBasedOnFilters.addFilter(
+          TimelineFilterUtils.createHBaseFilterList(
+              ApplicationColumnPrefix.METRIC, metricFilters));
+    }
+    // Create filter list based on config filters and add it to
+    // listBasedOnFilters.
+    TimelineFilterList configFilters = filters.getConfigFilters();
+    if (configFilters != null && !configFilters.getFilterList().isEmpty()) {
+      listBasedOnFilters.addFilter(
+          TimelineFilterUtils.createHBaseFilterList(
+              ApplicationColumnPrefix.CONFIG, configFilters));
+    }
+    // Create filter list based on info filters and add it to listBasedOnFilters
+    TimelineFilterList infoFilters = filters.getInfoFilters();
+    if (infoFilters != null && !infoFilters.getFilterList().isEmpty()) {
+      listBasedOnFilters.addFilter(
+          TimelineFilterUtils.createHBaseFilterList(
+              ApplicationColumnPrefix.INFO, infoFilters));
+    }
+    return listBasedOnFilters;
+  }
+
+  /**
+   * Add {@link QualifierFilter} filters to filter list for each column of
+   * application table.
+   *
+   * @param list filter list to which qualifier filters have to be added.
+   */
+  @Override
+  protected void updateFixedColumns(FilterList list) {
+    for (ApplicationColumn column : ApplicationColumn.values()) {
+      list.addFilter(new QualifierFilter(CompareOp.EQUAL,
+          new BinaryComparator(column.getColumnQualifierBytes())));
+    }
+  }
+
+  /**
+   * Creates a filter list which indicates that only some of the column
+   * qualifiers in the info column family will be returned in result.
+   *
+   * @return filter list.
+   * @throws IOException if any problem occurs while creating filter list.
+   */
+  private FilterList createFilterListForColsOfInfoFamily()
+      throws IOException {
+    FilterList infoFamilyColsFilter = new FilterList(Operator.MUST_PASS_ONE);
+    // Add filters for each column in entity table.
+    updateFixedColumns(infoFamilyColsFilter);
+    EnumSet<Field> fieldsToRetrieve = getDataToRetrieve().getFieldsToRetrieve();
+    // If INFO field has to be retrieved, add a filter for fetching columns
+    // with INFO column prefix.
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.EQUAL, ApplicationColumnPrefix.INFO));
+    }
+    TimelineFilterList relatesTo = getFilters().getRelatesTo();
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {
+      // If RELATES_TO field has to be retrieved, add a filter for fetching
+      // columns with RELATES_TO column prefix.
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.EQUAL, ApplicationColumnPrefix.RELATES_TO));
+    } else if (relatesTo != null && !relatesTo.getFilterList().isEmpty()) {
+      // Even if fields to retrieve does not contain RELATES_TO, we still
+      // need to have a filter to fetch some of the column qualifiers if
+      // relatesTo filters are specified. relatesTo filters will then be
+      // matched after fetching rows from HBase.
+      Set<String> relatesToCols =
+          TimelineFilterUtils.fetchColumnsFromFilterList(relatesTo);
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createFiltersFromColumnQualifiers(
+              ApplicationColumnPrefix.RELATES_TO, relatesToCols));
+    }
+    TimelineFilterList isRelatedTo = getFilters().getIsRelatedTo();
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {
+      // If IS_RELATED_TO field has to be retrieved, add a filter for fetching
+      // columns with IS_RELATED_TO column prefix.
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.EQUAL, ApplicationColumnPrefix.IS_RELATED_TO));
+    } else if (isRelatedTo != null && !isRelatedTo.getFilterList().isEmpty()) {
+      // Even if fields to retrieve does not contain IS_RELATED_TO, we still
+      // need to have a filter to fetch some of the column qualifiers if
+      // isRelatedTo filters are specified. isRelatedTo filters will then be
+      // matched after fetching rows from HBase.
+      Set<String> isRelatedToCols =
+          TimelineFilterUtils.fetchColumnsFromFilterList(isRelatedTo);
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createFiltersFromColumnQualifiers(
+              ApplicationColumnPrefix.IS_RELATED_TO, isRelatedToCols));
+    }
+    TimelineFilterList eventFilters = getFilters().getEventFilters();
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {
+      // If EVENTS field has to be retrieved, add a filter for fetching columns
+      // with EVENT column prefix.
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.EQUAL, ApplicationColumnPrefix.EVENT));
+    } else if (eventFilters != null && !eventFilters.getFilterList().isEmpty()){
+      // Even if fields to retrieve does not contain EVENTS, we still need to
+      // have a filter to fetch some of the column qualifiers on the basis of
+      // event filters specified. Event filters will then be matched after
+      // fetching rows from HBase.
+      Set<String> eventCols =
+          TimelineFilterUtils.fetchColumnsFromFilterList(eventFilters);
+      infoFamilyColsFilter.addFilter(
+          TimelineFilterUtils.createFiltersFromColumnQualifiers(
+              ApplicationColumnPrefix.EVENT, eventCols));
+    }
+    return infoFamilyColsFilter;
+  }
+
+  /**
+   * Exclude column prefixes via filters which are not required(based on fields
+   * to retrieve) from info column family. These filters are added to filter
+   * list which contains a filter for getting info column family.
+   *
+   * @param infoColFamilyList filter list for info column family.
+   */
+  private void excludeFieldsFromInfoColFamily(FilterList infoColFamilyList) {
+    EnumSet<Field> fieldsToRetrieve = getDataToRetrieve().getFieldsToRetrieve();
+    // Events not required.
+    if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {
+      infoColFamilyList.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.NOT_EQUAL, ApplicationColumnPrefix.EVENT));
+    }
+    // info not required.
+    if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {
+      infoColFamilyList.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.NOT_EQUAL, ApplicationColumnPrefix.INFO));
+    }
+    // is related to not required.
+    if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {
+      infoColFamilyList.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.NOT_EQUAL, ApplicationColumnPrefix.IS_RELATED_TO));
+    }
+    // relates to not required.
+    if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {
+      infoColFamilyList.addFilter(
+          TimelineFilterUtils.createHBaseQualifierFilter(
+              CompareOp.NOT_EQUAL, ApplicationColumnPrefix.RELATES_TO));
+    }
+  }
+
+  /**
+   * Updates filter list based on fields for confs and metrics to retrieve.
+   *
+   * @param listBasedOnFields filter list based on fields.
+   * @throws IOException if any problem occurs while updating filter list.
+   */
+  private void updateFilterForConfsAndMetricsToRetrieve(
+      FilterList listBasedOnFields) throws IOException {
+    TimelineDataToRetrieve dataToRetrieve = getDataToRetrieve();
+    // Please note that if confsToRetrieve is specified, we would have added
+    // CONFS to fields to retrieve in augmentParams() even if not specified.
+    if (dataToRetrieve.getFieldsToRetrieve().contains(Field.CONFIGS)) {
+      // Create a filter list for configs.
+      listBasedOnFields.addFilter(TimelineFilterUtils.
+          createFilterForConfsOrMetricsToRetrieve(
+              dataToRetrieve.getConfsToRetrieve(),
+              ApplicationColumnFamily.CONFIGS, ApplicationColumnPrefix.CONFIG));
+    }
+
+    // Please note that if metricsToRetrieve is specified, we would have added
+    // METRICS to fields to retrieve in augmentParams() even if not specified.
+    if (dataToRetrieve.getFieldsToRetrieve().contains(Field.METRICS)) {
+      // Create a filter list for metrics.
+      listBasedOnFields.addFilter(TimelineFilterUtils.
+          createFilterForConfsOrMetricsToRetrieve(
+              dataToRetrieve.getMetricsToRetrieve(),
+              ApplicationColumnFamily.METRICS, ApplicationColumnPrefix.METRIC));
+    }
+  }
+
+  @Override
+  protected FilterList constructFilterListBasedOnFields() throws IOException {
+    if (!needCreateFilterListBasedOnFields()) {
+      // Fetch all the columns. No need of a filter.
+      return null;
+    }
+    FilterList listBasedOnFields = new FilterList(Operator.MUST_PASS_ONE);
-           new BinaryComparator(ApplicationColumnFamily.INFO.getBytes()));
+            new BinaryComparator(ApplicationColumnFamily.INFO.getBytes()));
-    // Events not required.
-    TimelineEntityFilters filters = getFilters();
-    if (!dataToRetrieve.getFieldsToRetrieve().contains(Field.EVENTS) &&
-        !dataToRetrieve.getFieldsToRetrieve().contains(Field.ALL) &&
-        (isSingleEntityRead() || filters.getEventFilters() == null)) {
-      infoColFamilyList.addFilter(
-          new QualifierFilter(CompareOp.NOT_EQUAL,
-          new BinaryPrefixComparator(
-          ApplicationColumnPrefix.EVENT.getColumnPrefixBytes(""))));
+    if (!isSingleEntityRead() && fetchPartialColsFromInfoFamily()) {
+      // We can fetch only some of the columns from info family.
+      infoColFamilyList.addFilter(createFilterListForColsOfInfoFamily());
+    } else {
+      // Exclude column prefixes in info column family which are not required
+      // based on fields to retrieve.
+      excludeFieldsFromInfoColFamily(infoColFamilyList);
-    // info not required.
-    if (!dataToRetrieve.getFieldsToRetrieve().contains(Field.INFO) &&
-        !dataToRetrieve.getFieldsToRetrieve().contains(Field.ALL) &&
-        (isSingleEntityRead() || filters.getInfoFilters() == null)) {
-      infoColFamilyList.addFilter(
-          new QualifierFilter(CompareOp.NOT_EQUAL,
-          new BinaryPrefixComparator(
-          ApplicationColumnPrefix.INFO.getColumnPrefixBytes(""))));
-    }
-    // is releated to not required.
-    if (!dataToRetrieve.getFieldsToRetrieve().contains(Field.IS_RELATED_TO) &&
-        !dataToRetrieve.getFieldsToRetrieve().contains(Field.ALL) &&
-        (isSingleEntityRead() || filters.getIsRelatedTo() == null)) {
-      infoColFamilyList.addFilter(
-          new QualifierFilter(CompareOp.NOT_EQUAL,
-          new BinaryPrefixComparator(
-          ApplicationColumnPrefix.IS_RELATED_TO.getColumnPrefixBytes(""))));
-    }
-    // relates to not required.
-    if (!dataToRetrieve.getFieldsToRetrieve().contains(Field.RELATES_TO) &&
-        !dataToRetrieve.getFieldsToRetrieve().contains(Field.ALL) &&
-        (isSingleEntityRead() || filters.getRelatesTo() == null)) {
-      infoColFamilyList.addFilter(
-          new QualifierFilter(CompareOp.NOT_EQUAL,
-          new BinaryPrefixComparator(
-          ApplicationColumnPrefix.RELATES_TO.getColumnPrefixBytes(""))));
-    }
-    list.addFilter(infoColFamilyList);
-    if ((dataToRetrieve.getFieldsToRetrieve().contains(Field.CONFIGS) ||
-        (!isSingleEntityRead() && filters.getConfigFilters() != null)) ||
-        (dataToRetrieve.getConfsToRetrieve() != null &&
-        !dataToRetrieve.getConfsToRetrieve().getFilterList().isEmpty())) {
-      FilterList filterCfg =
-          new FilterList(new FamilyFilter(CompareOp.EQUAL,
-          new BinaryComparator(ApplicationColumnFamily.CONFIGS.getBytes())));
-      if (dataToRetrieve.getConfsToRetrieve() != null &&
-          !dataToRetrieve.getConfsToRetrieve().getFilterList().isEmpty()) {
-        filterCfg.addFilter(TimelineFilterUtils.createHBaseFilterList(
-            ApplicationColumnPrefix.CONFIG,
-            dataToRetrieve.getConfsToRetrieve()));
-      }
-      list.addFilter(filterCfg);
-    }
-    if ((dataToRetrieve.getFieldsToRetrieve().contains(Field.METRICS) ||
-        (!isSingleEntityRead() && filters.getMetricFilters() != null)) ||
-        (dataToRetrieve.getMetricsToRetrieve() != null &&
-        !dataToRetrieve.getMetricsToRetrieve().getFilterList().isEmpty())) {
-      FilterList filterMetrics =
-          new FilterList(new FamilyFilter(CompareOp.EQUAL,
-          new BinaryComparator(ApplicationColumnFamily.METRICS.getBytes())));
-      if (dataToRetrieve.getMetricsToRetrieve() != null &&
-          !dataToRetrieve.getMetricsToRetrieve().getFilterList().isEmpty()) {
-        filterMetrics.addFilter(TimelineFilterUtils.createHBaseFilterList(
-            ApplicationColumnPrefix.METRIC,
-            dataToRetrieve.getMetricsToRetrieve()));
-      }
-      list.addFilter(filterMetrics);
-    }
-    return list;
+    listBasedOnFields.addFilter(infoColFamilyList);
+
+    updateFilterForConfsAndMetricsToRetrieve(listBasedOnFields);
+    return listBasedOnFields;
+    Preconditions.checkNotNull(getContext(), "context shouldn't be null");
+    Preconditions.checkNotNull(
+        getDataToRetrieve(), "data to retrieve shouldn't be null");
+      // Get flow context information from AppToFlow table.
+    // Add configs/metrics to fields to retrieve if confsToRetrieve and/or
+    // metricsToRetrieve are specified.
+    if (!isSingleEntityRead()) {
+      createFiltersIfNull();
+    }
-    if (!isSingleEntityRead() &&
-        (entity.getCreatedTime() < filters.getCreatedTimeBegin() ||
-        entity.getCreatedTime() > filters.getCreatedTimeEnd())) {
-      return null;
-    }
+
-    // fetch is related to entities
+    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo
+    // filters do not match, entity would be dropped. We have to match filters
+    // locally as relevant HBase filters to filter out rows on the basis of
+    // isRelatedTo are not set in HBase scan.
-        filters != null && filters.getIsRelatedTo() != null &&
-        filters.getIsRelatedTo().size() > 0;
-    if (fieldsToRetrieve.contains(Field.ALL) ||
-        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {
-      readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,
-          true);
-      if (checkIsRelatedTo && !TimelineStorageUtils.matchRelations(
-          entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {
+        !isSingleEntityRead() && filters.getIsRelatedTo() != null &&
+        filters.getIsRelatedTo().getFilterList().size() > 0;
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO) ||
+        checkIsRelatedTo) {
+      TimelineStorageUtils.readRelationship(
+          entity, result, ApplicationColumnPrefix.IS_RELATED_TO, true);
+      if (checkIsRelatedTo && !TimelineStorageUtils.matchIsRelatedTo(entity,
+          filters.getIsRelatedTo())) {
-      if (!fieldsToRetrieve.contains(Field.ALL) &&
-          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {
+      if (!TimelineStorageUtils.hasField(fieldsToRetrieve,
+          Field.IS_RELATED_TO)) {
-    // fetch relates to entities
+    // fetch relates to entities and match relatesTo filter. If relatesTo
+    // filters do not match, entity would be dropped. We have to match filters
+    // locally as relevant HBase filters to filter out rows on the basis of
+    // relatesTo are not set in HBase scan.
-        filters != null && filters.getRelatesTo() != null &&
-        filters.getRelatesTo().size() > 0;
-    if (fieldsToRetrieve.contains(Field.ALL) ||
-        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {
-      readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,
-          false);
-      if (checkRelatesTo && !TimelineStorageUtils.matchRelations(
-          entity.getRelatesToEntities(), filters.getRelatesTo())) {
+        !isSingleEntityRead() && filters.getRelatesTo() != null &&
+        filters.getRelatesTo().getFilterList().size() > 0;
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO) ||
+        checkRelatesTo) {
+      TimelineStorageUtils.readRelationship(
+          entity, result, ApplicationColumnPrefix.RELATES_TO, false);
+      if (checkRelatesTo && !TimelineStorageUtils.matchRelatesTo(entity,
+          filters.getRelatesTo())) {
-      if (!fieldsToRetrieve.contains(Field.ALL) &&
-          !fieldsToRetrieve.contains(Field.RELATES_TO)) {
+      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {
-    // fetch info
-    boolean checkInfo = filters != null && filters.getInfoFilters() != null &&
-        filters.getInfoFilters().size() > 0;
-    if (fieldsToRetrieve.contains(Field.ALL) ||
-        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {
-      readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);
-      if (checkInfo &&
-          !TimelineStorageUtils.matchFilters(
-          entity.getInfo(), filters.getInfoFilters())) {
-        return null;
-      }
-      if (!fieldsToRetrieve.contains(Field.ALL) &&
-          !fieldsToRetrieve.contains(Field.INFO)) {
-        entity.getInfo().clear();
-      }
+    // fetch info if fieldsToRetrieve contains INFO or ALL.
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {
+      TimelineStorageUtils.readKeyValuePairs(
+          entity, result, ApplicationColumnPrefix.INFO, false);
-    // fetch configs
-    boolean checkConfigs =
-        filters != null && filters.getConfigFilters() != null &&
-        filters.getConfigFilters().size() > 0;
-    if (fieldsToRetrieve.contains(Field.ALL) ||
-        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {
-      readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);
-      if (checkConfigs && !TimelineStorageUtils.matchFilters(
-          entity.getConfigs(), filters.getConfigFilters())) {
-        return null;
-      }
-      if (!fieldsToRetrieve.contains(Field.ALL) &&
-          !fieldsToRetrieve.contains(Field.CONFIGS)) {
-        entity.getConfigs().clear();
-      }
+    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.CONFIGS)) {
+      TimelineStorageUtils.readKeyValuePairs(
+          entity, result, ApplicationColumnPrefix.CONFIG, true);
-    // fetch events
+    // fetch events and match event filters if they exist. If event filters do
+    // not match, entity would be dropped. We have to match filters locally
+    // as relevant HBase filters to filter out rows on the basis of events
+    // are not set in HBase scan.
-        filters != null && filters.getEventFilters() != null &&
-        filters.getEventFilters().size() > 0;
-    if (fieldsToRetrieve.contains(Field.ALL) ||
-        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {
-      readEvents(entity, result, true);
-      if (checkEvents && !TimelineStorageUtils.matchEventFilters(
-          entity.getEvents(), filters.getEventFilters())) {
+        !isSingleEntityRead() && filters.getEventFilters() != null &&
+        filters.getEventFilters().getFilterList().size() > 0;
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS) ||
+        checkEvents) {
+      TimelineStorageUtils.readEvents(
+          entity, result, ApplicationColumnPrefix.EVENT);
+      if (checkEvents && !TimelineStorageUtils.matchEventFilters(entity,
+          filters.getEventFilters())) {
-      if (!fieldsToRetrieve.contains(Field.ALL) &&
-          !fieldsToRetrieve.contains(Field.EVENTS)) {
+      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {
-    // fetch metrics
-    boolean checkMetrics =
-        filters != null && filters.getMetricFilters() != null &&
-        filters.getMetricFilters().size() > 0;
-    if (fieldsToRetrieve.contains(Field.ALL) ||
-        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {
+    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.
+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.METRICS)) {
-      if (checkMetrics && !TimelineStorageUtils.matchMetricFilters(
-          entity.getMetrics(), filters.getMetricFilters())) {
-        return null;
-      }
-      if (!fieldsToRetrieve.contains(Field.ALL) &&
-          !fieldsToRetrieve.contains(Field.METRICS)) {
-        entity.getMetrics().clear();
-      }

MOV26 INS26 INS40 UPD40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS78 MOV83 INS43 UPD42 MOV42 INS43 INS8 INS29 INS78 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 MOV78 INS83 MOV43 INS42 INS43 INS8 MOV78 INS83 MOV43 INS42 MOV44 MOV43 INS8 INS65 INS42 INS42 INS42 MOV60 INS60 INS60 INS60 INS25 INS60 INS25 INS60 INS25 INS60 MOV25 INS41 INS65 INS65 INS42 MOV43 INS42 INS70 INS65 INS65 INS65 INS42 INS42 MOV60 INS21 INS60 INS25 INS60 INS25 INS60 INS25 INS60 MOV25 INS41 INS65 INS65 MOV43 INS42 INS60 INS25 INS25 INS25 INS25 INS65 INS65 INS65 MOV43 INS42 INS42 MOV60 MOV25 MOV25 INS42 INS25 INS60 MOV60 MOV60 MOV21 INS25 INS21 INS21 INS41 INS21 INS21 INS25 MOV25 MOV60 MOV21 MOV60 MOV21 MOV60 MOV60 MOV21 MOV60 MOV60 MOV25 MOV60 INS25 INS25 INS25 MOV60 INS25 INS25 MOV41 INS66 MOV43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS43 INS59 INS27 MOV8 INS43 INS59 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS44 INS32 INS8 INS66 INS66 INS66 INS42 INS66 MOV43 INS32 INS74 INS59 INS32 INS8 INS43 INS59 INS32 MOV8 INS25 INS43 INS59 INS32 INS8 INS25 INS43 INS59 INS32 INS8 INS25 INS42 INS66 INS66 INS66 INS42 INS66 INS74 INS59 INS38 INS8 INS38 INS8 INS38 INS8 INS38 INS8 INS66 INS42 INS66 INS42 INS66 MOV32 MOV32 INS38 MOV8 INS43 INS59 MOV27 MOV8 INS8 INS32 INS32 INS42 INS32 INS32 MOV38 INS8 MOV27 INS8 INS32 INS8 INS32 INS8 INS27 INS8 INS32 MOV8 INS42 INS14 INS42 MOV32 INS42 MOV32 INS27 INS27 INS21 INS42 INS42 MOV32 UPD27 MOV27 INS38 INS21 INS42 INS42 MOV32 INS27 INS38 INS42 INS42 MOV32 INS27 INS42 INS43 INS42 UPD42 MOV42 UPD42 MOV42 MOV21 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS43 INS43 INS42 INS32 UPD42 MOV42 INS42 INS42 UPD40 MOV40 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS27 MOV8 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS21 INS27 MOV8 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 UPD40 MOV40 MOV21 MOV27 INS8 INS43 INS43 INS42 INS32 MOV32 INS21 MOV32 INS21 INS32 INS21 INS32 MOV21 MOV32 INS42 INS42 INS14 INS32 INS21 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS45 INS42 INS42 INS32 INS45 INS21 INS32 UPD42 INS32 UPD42 MOV21 MOV25 INS25 INS42 UPD42 MOV42 UPD42 MOV42 UPD40 MOV40 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS21 MOV32 UPD42 MOV42 INS21 MOV25 INS25 INS42 UPD42 MOV42 UPD42 MOV42 MOV40 MOV21 INS43 INS42 INS34 INS42 INS40 INS32 INS42 INS32 INS32 INS42 INS33 INS32 INS42 INS33 INS42 INS42 INS42 INS32 MOV42 INS32 INS32 MOV42 MOV27 MOV38 INS32 INS42 INS32 MOV27 MOV38 INS32 UPD42 MOV42 INS27 INS60 INS21 INS42 INS42 INS32 INS42 UPD42 UPD42 MOV42 INS40 INS32 INS42 UPD42 UPD42 UPD40 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD40 MOV40 UPD42 INS43 INS40 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 UPD40 MOV40 INS38 MOV8 UPD42 MOV42 UPD42 MOV42 MOV42 UPD40 MOV40 INS38 MOV8 INS32 INS32 INS42 UPD42 UPD42 UPD40 INS32 INS38 MOV8 INS42 UPD42 MOV42 UPD42 MOV42 MOV32 MOV32 MOV42 INS42 UPD42 MOV42 INS32 INS32 INS42 UPD42 INS32 UPD42 UPD42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 UPD42 INS32 INS42 INS74 INS42 INS42 INS42 INS32 INS42 INS74 INS59 UPD42 MOV42 UPD42 UPD42 INS32 UPD42 MOV42 INS33 INS74 INS59 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 INS42 INS32 UPD42 UPD42 INS32 UPD42 MOV40 UPD42 MOV40 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 MOV38 INS32 INS42 UPD42 UPD40 UPD42 MOV32 INS38 INS32 INS42 UPD42 INS40 UPD9 UPD42 MOV32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS40 INS9 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD40 MOV40 INS9 INS38 INS32 INS42 INS42 INS42 INS42 INS40 UPD42 MOV32 INS42 UPD42 INS40 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD40 MOV40 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD40 MOV40 UPD42 MOV42 UPD42 UPD42 INS42 INS42 MOV40 UPD42 MOV42 MOV43 UPD40 INS42 INS42 INS40 INS40 INS42 INS42 INS40 MOV40 INS43 INS43 INS42 INS32 UPD42 INS32 INS42 INS42 INS40 INS40 INS43 INS43 INS42 INS32 UPD42 INS32 UPD42 MOV42 INS42 INS40 UPD40 MOV40 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 INS42 UPD40 MOV40 INS40 UPD42 MOV42 UPD42 MOV42 INS40 INS40 UPD42 MOV42 INS42 UPD40 MOV40 INS40 UPD42 MOV42 INS42 INS40 UPD40 MOV40 UPD42 INS40 UPD42 INS40 UPD42 MOV42 MOV32 INS42 INS42 UPD42 UPD42 UPD40 INS32 MOV32 INS42 INS42 UPD42 UPD42 UPD40 INS32 MOV32 INS42 INS42 UPD42 UPD42 UPD40 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS40 INS42 UPD42 UPD42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD40 MOV40 INS42 UPD42 UPD42 MOV42 MOV32 INS42 UPD42 UPD42 MOV42 MOV32 INS42 UPD42 UPD42 MOV42 MOV32 INS42 UPD42 MOV42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL40 DEL42 DEL43 DEL45 DEL32 DEL14 DEL14 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL40 DEL42 DEL32 DEL33 DEL27 DEL27 DEL36 DEL40 DEL42 DEL43 DEL45 DEL32 DEL14 DEL14 DEL42 DEL43 DEL42 DEL43 DEL40 DEL45 DEL32 DEL42 DEL43 DEL40 DEL42 DEL43 DEL42 DEL45 DEL32 DEL14 DEL14 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL43 DEL40 DEL40 DEL32 DEL14 DEL14 DEL14 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL40 DEL42 DEL43 DEL40 DEL32 DEL14 DEL14 DEL14 DEL59 DEL9 DEL42 DEL42 DEL40 DEL32 DEL42 DEL32 DEL42 DEL27 DEL33 DEL41 DEL8 DEL25 DEL40 DEL32 DEL38 DEL32 DEL38 DEL27 DEL25 DEL8 DEL42 DEL32 DEL9 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL38 DEL27 DEL42 DEL40 DEL33 DEL27 DEL32 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL32 DEL33 DEL27 DEL42 DEL32 DEL42 DEL32 DEL27 DEL36 DEL32 DEL27 DEL36 DEL27 DEL42 DEL41 DEL8 DEL25 DEL32 DEL32 DEL38 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL42 DEL32 DEL32 DEL33 DEL27 DEL27 DEL36 DEL27 DEL25 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL38 DEL42 DEL32 DEL32 DEL33 DEL27 DEL27 DEL36 DEL27 DEL8 DEL25 DEL32 DEL42 DEL40 DEL32 DEL38 DEL32 DEL32 DEL38 DEL32 DEL32 DEL33 DEL27 DEL27 DEL36 DEL27 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL33 DEL27 DEL27 DEL36 DEL27 DEL36 DEL27 DEL36 DEL27 DEL25 DEL36 DEL27 DEL36 DEL27 DEL36 DEL27 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL33 DEL27 DEL40 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL40 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL42 DEL33 DEL27 DEL40 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL83 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL27 DEL27 DEL36 DEL27 DEL25 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL27 DEL42 DEL42 DEL40 DEL9 DEL32 DEL21 DEL42 DEL38 DEL27 DEL33 DEL41 DEL8 DEL25 DEL32 DEL38 DEL38 DEL27 DEL25 DEL8 DEL25 DEL39 DEL42 DEL42 DEL33 DEL27 DEL32 DEL33 DEL27 DEL27 DEL32 DEL32 DEL34 DEL27 DEL27 DEL59 DEL60 DEL32 DEL32 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL38 DEL27 DEL33 DEL41 DEL8 DEL25 DEL38 DEL42 DEL42 DEL40 DEL32 DEL38 DEL27 DEL25 DEL8 DEL25 DEL39 DEL42 DEL42 DEL33 DEL27 DEL32 DEL33 DEL27 DEL27 DEL32 DEL42 DEL32 DEL34 DEL27 DEL27 DEL59 DEL60 DEL38 DEL32 DEL38 DEL27 DEL25 DEL8 DEL25 DEL39 DEL42 DEL42 DEL33 DEL27 DEL32 DEL33 DEL27 DEL27 DEL32 DEL32 DEL34 DEL27 DEL27 DEL59 DEL60 DEL32 DEL27 DEL38 DEL32 DEL38 DEL27 DEL25 DEL8 DEL25 DEL8 DEL31
HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.

-  static INodesInPath resolve(final INodeDirectory startingDir,
-      final byte[][] components) throws UnresolvedLinkException {
-    return resolve(startingDir, components, components.length, false);
-  }
-
-   * Retrieve existing INodes from a path. If existing is big enough to store
-   * all path components (existing and non-existing), then existing INodes
-   * will be stored starting from the root INode into existing[0]; if
-   * existing is not big enough to store all path components, then only the
-   * last existing and non existing INodes will be stored so that
-   * existing[existing.length-1] refers to the INode of the final component.
+   * Retrieve existing INodes from a path. For non-snapshot path,
+   * the number of INodes is equal to the number of path components. For
+   * snapshot path (e.g., /foo/.snapshot/s1/bar), the number of INodes is
+   * (number_of_path_components - 1).
-   * following path components: ["","c1","c2","c3"],
+   * following path components: ["","c1","c2","c3"]
-   * <code>getExistingPathINodes(["","c1","c2"], [?])</code> should fill the
-   * array with [c2] <br>
-   * <code>getExistingPathINodes(["","c1","c2","c3"], [?])</code> should fill the
-   * array with [null]
-   * 
-   * <p>
-   * <code>getExistingPathINodes(["","c1","c2"], [?,?])</code> should fill the
-   * array with [c1,c2] <br>
-   * <code>getExistingPathINodes(["","c1","c2","c3"], [?,?])</code> should fill
-   * the array with [c2,null]
-   * 
-   * <p>
-   * <code>getExistingPathINodes(["","c1","c2"], [?,?,?,?])</code> should fill
-   * the array with [rootINode,c1,c2,null], <br>
-   * <code>getExistingPathINodes(["","c1","c2","c3"], [?,?,?,?])</code> should
+   * <code>getExistingPathINodes(["","c1","c2"])</code> should fill
+   * the array with [rootINode,c1,c2], <br>
+   * <code>getExistingPathINodes(["","c1","c2","c3"])</code> should
-   * @param numOfINodes number of INodes to return
-      final byte[][] components, final int numOfINodes,
-      final boolean resolveLink) throws UnresolvedLinkException {
+      final byte[][] components, final boolean resolveLink)
+      throws UnresolvedLinkException {
-    int index = numOfINodes <= components.length ?
-        numOfINodes - components.length : 0;
-    int capacity = numOfINodes;
-    INode[] inodes = new INode[numOfINodes];
+    INode[] inodes = new INode[components.length];
-      final boolean lastComp = (count == components.length - 1);      
-      if (index >= 0) {
-        inodes[inodeNum++] = curNode;
-      }
+      final boolean lastComp = (count == components.length - 1);
+      inodes[inodeNum++] = curNode;
-      final INodeDirectory dir = isDir? curNode.asDirectory(): null;  
+      final INodeDirectory dir = isDir? curNode.asDirectory(): null;
-        index++;
-        if (index >= 0) { // decrease the capacity by 1 to account for .snapshot
-          capacity--;
-        }
-      index++;
-    if (isSnapshot && capacity < numOfINodes &&
-        !isDotSnapshotDir(components[components.length - 1])) {
+    if (isSnapshot && !isDotSnapshotDir(components[components.length - 1])) {
-      INode[] newNodes = new INode[capacity];
-      System.arraycopy(inodes, 0, newNodes, 0, capacity);
+      INode[] newNodes = new INode[components.length - 1];
+      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);
+  /**
+   * Extend a given INodesInPath with a child INode. The child INode will be
+   * appended to the end of the new INodesInPath.
+   */
+  public static INodesInPath append(INodesInPath iip, INode child,
+      byte[] childName) {
+    Preconditions.checkArgument(!iip.isSnapshot && iip.length() > 0);
+    Preconditions.checkArgument(iip.getLastINode() != null && iip
+        .getLastINode().isDirectory());
+    INode[] inodes = new INode[iip.length() + 1];
+    System.arraycopy(iip.inodes, 0, inodes, 0, inodes.length - 1);
+    inodes[inodes.length - 1] = child;
+    byte[][] path = new byte[iip.path.length + 1][];
+    System.arraycopy(iip.path, 0, path, 0, path.length - 1);
+    path[path.length - 1] = childName;
+    return new INodesInPath(inodes, path, false, iip.snapshotId);
+  }
+
+  public byte[][] getPathComponents() {
+    return path;
+  }
+
+   * @param length number of ancestral INodes in the returned INodesInPath
+   *               instance
+   * @return the INodesInPath instance containing ancestral INodes
+   */
+  private INodesInPath getAncestorINodesInPath(int length) {
+    Preconditions.checkArgument(length >= 0 && length < inodes.length);
+    final INode[] anodes = new INode[length];
+    final byte[][] apath;
+    final boolean isSnapshot;
+    final int snapshotId;
+    int dotSnapshotIndex = getDotSnapshotIndex();
+    if (this.isSnapshot && length >= dotSnapshotIndex + 1) {
+      apath = new byte[length + 1][];
+      isSnapshot = true;
+      snapshotId = this.snapshotId;
+    } else {
+      apath = new byte[length][];
+      isSnapshot = false;
+      snapshotId = this.isSnapshot ? CURRENT_STATE_ID : this.snapshotId;
+    }
+    System.arraycopy(this.inodes, 0, anodes, 0, length);
+    System.arraycopy(this.path, 0, apath, 0, apath.length);
+    return new INodesInPath(anodes, apath, isSnapshot, snapshotId);
+  }
+
+  /**
+   * @return an INodesInPath instance containing all the INodes in the parent
+   *         path. We do a deep copy here.
+   */
+  public INodesInPath getParentINodesInPath() {
+    return inodes.length > 1 ? getAncestorINodesInPath(inodes.length - 1) :
+        null;
+  }
+
+  private int getDotSnapshotIndex() {
+    if (isSnapshot) {
+      for (int i = 0; i < path.length; i++) {
+        if (isDotSnapshotDir(path[i])) {
+          return i;
+        }
+      }
+      throw new IllegalStateException("The path " + getPath()
+          + " is a snapshot path but does not contain "
+          + HdfsConstants.DOT_SNAPSHOT_DIR);
+    } else {
+      return -1;
+    }
+  }
+
+  /**

INS31 INS31 INS31 INS31 INS31 INS29 INS83 MOV83 INS43 INS42 INS44 MOV44 INS44 INS8 INS83 INS5 INS42 INS8 INS29 INS83 UPD43 MOV43 INS42 INS44 MOV8 INS29 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS8 INS65 INS42 MOV43 INS42 UPD43 UPD42 INS5 INS42 INS21 INS21 INS60 INS21 INS21 INS60 INS21 INS21 INS41 MOV39 MOV85 MOV85 INS41 INS65 INS65 UPD42 INS39 INS42 INS21 INS60 INS60 INS60 INS60 INS60 INS25 INS21 INS21 INS41 INS65 INS42 INS41 INS25 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV5 INS66 INS66 UPD42 INS39 INS85 INS32 INS32 INS5 INS59 INS32 INS7 INS5 INS59 INS32 INS7 INS14 INS42 INS42 INS66 INS66 INS66 INS32 INS83 INS5 INS59 INS83 INS5 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS39 INS59 INS27 INS8 INS8 INS32 INS32 INS14 INS66 INS66 INS16 INS42 INS8 INS8 MOV21 MOV42 INS42 INS42 INS27 INS42 INS42 INS27 INS43 INS85 INS42 INS3 INS42 INS42 INS40 INS34 INS42 INS34 INS27 INS2 INS42 INS39 INS85 INS85 INS42 INS3 INS42 INS42 INS40 INS34 INS42 INS34 INS27 INS2 INS42 INS43 INS42 INS42 INS9 INS40 UPD42 MOV42 UPD42 MOV42 INS27 INS43 INS85 INS42 INS3 INS39 INS85 INS85 INS42 INS42 INS42 INS42 INS32 INS22 INS27 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS22 INS34 INS42 INS34 INS42 INS42 INS42 INS22 INS34 INS42 INS34 INS40 INS43 INS42 INS42 INS42 INS42 INS27 INS32 INS33 INS24 INS53 INS41 MOV5 INS40 MOV5 INS38 INS27 INS27 INS32 INS42 INS5 INS27 INS40 INS34 INS42 INS27 INS5 INS27 INS40 INS34 INS42 INS27 INS42 INS27 INS27 INS42 INS5 INS42 INS42 INS52 INS42 INS42 INS27 INS7 INS7 INS7 INS7 INS7 INS7 INS52 INS42 INS52 INS42 INS42 INS40 INS34 INS42 INS27 INS58 INS27 INS37 INS8 INS14 INS38 INS40 INS40 INS32 INS34 INS32 INS33 INS32 INS42 INS43 INS85 INS32 INS34 INS40 INS34 INS39 INS85 INS85 INS40 INS34 INS40 INS34 INS42 INS34 INS42 INS40 INS43 INS85 INS42 INS34 INS42 INS3 INS42 INS9 INS42 INS22 INS42 INS3 INS42 INS9 INS42 INS16 INS40 INS34 INS39 INS59 INS42 INS40 INS42 INS25 INS43 INS27 INS34 MOV5 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS27 INS52 INS42 INS5 INS42 INS22 INS42 INS22 INS42 INS34 INS32 INS8 INS42 INS45 INS32 INS45 INS40 INS40 INS34 INS39 INS85 INS85 INS42 INS34 INS39 INS85 INS85 INS52 INS42 INS52 INS42 INS42 INS2 INS41 INS42 INS42 INS42 INS42 DEL42 DEL83 DEL5 DEL42 DEL44 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL66 DEL65 DEL83 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL34 DEL16 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL27 DEL8 DEL25 DEL42 DEL37 DEL21 DEL42 DEL34 DEL27 DEL42 DEL37 DEL21 DEL8 DEL25 DEL42 DEL37 DEL21 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL83 DEL42 DEL40 DEL9 DEL32 DEL41
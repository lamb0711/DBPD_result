svn merge --reintegrate https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832 for merging Heterogeneous Storage feature branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550363 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.TreeSet;
+import org.apache.hadoop.hdfs.StorageType;
+import org.apache.hadoop.hdfs.server.protocol.DatanodeStorage;
+import org.apache.hadoop.hdfs.server.protocol.StorageReceivedDeletedBlocks;
-    List<DatanodeDescriptor> containingLiveReplicasNodes =
-      new ArrayList<DatanodeDescriptor>();
+    List<DatanodeStorageInfo> containingLiveReplicasNodes =
+      new ArrayList<DatanodeStorageInfo>();
-    for (Iterator<DatanodeDescriptor> jt = blocksMap.nodeIterator(block);
-         jt.hasNext();) {
-      DatanodeDescriptor node = jt.next();
+    for (DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-      if (node.areBlockContentsStale()) {
+      if (storage.areBlockContentsStale()) {
-    DatanodeDescriptor[] targets = getNodes(oldBlock);
+    DatanodeStorageInfo[] targets = getStorages(oldBlock);
-    BlockInfoUnderConstruction ucBlock =
-      bc.setLastBlock(oldBlock, targets);
+    BlockInfoUnderConstruction ucBlock = bc.setLastBlock(oldBlock, targets);
-    for (DatanodeDescriptor dd : targets) {
-      String datanodeId = dd.getStorageID();
-      invalidateBlocks.remove(datanodeId, oldBlock);
+    for (DatanodeStorageInfo storage : targets) {
+      invalidateBlocks.remove(storage.getStorageID(), oldBlock);
-  private List<String> getValidLocations(Block block) {
-    ArrayList<String> machineSet =
-      new ArrayList<String>(blocksMap.numNodes(block));
-    for(Iterator<DatanodeDescriptor> it =
-      blocksMap.nodeIterator(block); it.hasNext();) {
-      String storageID = it.next().getStorageID();
+  private List<DatanodeStorageInfo> getValidLocations(Block block) {
+    final List<DatanodeStorageInfo> locations
+        = new ArrayList<DatanodeStorageInfo>(blocksMap.numNodes(block));
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
+      final String storageID = storage.getStorageID();
-        machineSet.add(storageID);
+        locations.add(storage);
-    return machineSet;
+    return locations;
-      final DatanodeDescriptor[] locations = uc.getExpectedLocations();
+      final DatanodeStorageInfo[] storages = uc.getExpectedStorageLocations();
-      return new LocatedBlock(eb, locations, pos, false);
+      return new LocatedBlock(eb, storages, pos, false);
-    final DatanodeDescriptor[] machines = new DatanodeDescriptor[numMachines];
+    final DatanodeStorageInfo[] machines = new DatanodeStorageInfo[numMachines];
-      for(Iterator<DatanodeDescriptor> it = blocksMap.nodeIterator(blk);
-          it.hasNext();) {
-        final DatanodeDescriptor d = it.next();
+      for(DatanodeStorageInfo storage : blocksMap.getStorages(blk)) {
+        final DatanodeDescriptor d = storage.getDatanodeDescriptor();
-          machines[j++] = d;
+          machines[j++] = storage;
-    invalidateBlocks.remove(node.getStorageID());
+    invalidateBlocks.remove(node.getDatanodeUuid());
-    if (node.areBlockContentsStale()) {
+    boolean stale = false;
+    for(DatanodeStorageInfo storage : node.getStorageInfos()) {
+      if (storage.areBlockContentsStale()) {
+        stale = true;
+        break;
+      }
+    }
+    if (stale) {
-    for (Iterator<DatanodeDescriptor> it = blocksMap.nodeIterator(b); it
-        .hasNext();) {
-      DatanodeDescriptor node = it.next();
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(b)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-      final DatanodeInfo dn, String reason) throws IOException {
+      final DatanodeInfo dn, String storageID, String reason) throws IOException {
-        Reason.CORRUPTION_REPORTED), dn);
+        Reason.CORRUPTION_REPORTED), dn, storageID);
-                                  DatanodeInfo dn) throws IOException {
+      DatanodeInfo dn, String storageID) throws IOException {
-    node.addBlock(b.stored);
+    node.addBlock(storageID, b.stored);
-    List<DatanodeDescriptor> containingNodes, liveReplicaNodes;
+    List<DatanodeDescriptor> containingNodes;
-            liveReplicaNodes = new ArrayList<DatanodeDescriptor>();
+            List<DatanodeStorageInfo> liveReplicaNodes = new ArrayList<DatanodeStorageInfo>();
-        DatanodeDescriptor[] targets = rw.targets;
+        final DatanodeStorageInfo[] targets = rw.targets;
-            if (rw.srcNode.getNetworkLocation().equals(targets[0].getNetworkLocation())) {
+            if (rw.srcNode.getNetworkLocation().equals(
+                targets[0].getDatanodeDescriptor().getNetworkLocation())) {
-
-          for (DatanodeDescriptor dn : targets) {
-            dn.incBlocksScheduled();
-          }
+          DatanodeStorageInfo.incrementBlocksScheduled(targets);
-          pendingReplications.increment(block, targets);
+          pendingReplications.increment(block,
+              DatanodeStorageInfo.toDatanodeDescriptors(targets));
-        DatanodeDescriptor[] targets = rw.targets;
+        DatanodeStorageInfo[] targets = rw.targets;
-            targetList.append(targets[k]);
+            targetList.append(targets[k].getDatanodeDescriptor());
-  public DatanodeDescriptor[] chooseTarget(final String src,
+  public DatanodeStorageInfo[] chooseTarget(final String src,
-    final DatanodeDescriptor targets[] = blockplacement.chooseTarget(src,
+    final DatanodeStorageInfo[] targets = blockplacement.chooseTarget(src,
-        favoredDatanodeDescriptors);
+        // TODO: get storage type from file
+        favoredDatanodeDescriptors, StorageType.DEFAULT);
-   DatanodeDescriptor chooseSourceDatanode(
-                                    Block block,
-                                    List<DatanodeDescriptor> containingNodes,
-                                    List<DatanodeDescriptor> nodesContainingLiveReplicas,
-                                    NumberReplicas numReplicas,
-                                    int priority) {
+   DatanodeDescriptor chooseSourceDatanode(Block block,
+       List<DatanodeDescriptor> containingNodes,
+       List<DatanodeStorageInfo>  nodesContainingLiveReplicas,
+       NumberReplicas numReplicas,
+       int priority) {
-    Iterator<DatanodeDescriptor> it = blocksMap.nodeIterator(block);
+    
-    while(it.hasNext()) {
-      DatanodeDescriptor node = it.next();
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-        excessReplicateMap.get(node.getStorageID());
+        excessReplicateMap.get(node.getDatanodeUuid());
-        nodesContainingLiveReplicas.add(node);
+        nodesContainingLiveReplicas.add(storage);
-   * The given datanode is reporting all its blocks.
-   * Update the (machine-->blocklist) and (block-->machinelist) maps.
+   * The given storage is reporting all its blocks.
+   * Update the (storage-->block list) and (block-->storage list) maps.
-  public void processReport(final DatanodeID nodeID, final String poolId,
+  public void processReport(final DatanodeID nodeID,
+      final DatanodeStorage storage, final String poolId,
-      if (namesystem.isInStartupSafeMode() && !node.isFirstBlockReport()) {
+      final DatanodeStorageInfo storageInfo = node.updateStorage(storage);
+      if (namesystem.isInStartupSafeMode()
+          && storageInfo.getBlockReportCount() > 0) {
-      if (node.numBlocks() == 0) {
+      if (storageInfo.numBlocks() == 0) {
-        processFirstBlockReport(node, newReport);
+        processFirstBlockReport(node, storage.getStorageID(), newReport);
-        processReport(node, newReport);
+        processReport(node, storage, newReport);
-      boolean staleBefore = node.areBlockContentsStale();
-      node.receivedBlockReport();
-      if (staleBefore && !node.areBlockContentsStale()) {
+      boolean staleBefore = storageInfo.areBlockContentsStale();
+      storageInfo.receivedBlockReport();
+      if (staleBefore && !storageInfo.areBlockContentsStale()) {
+      final DatanodeStorage storage,
-    Collection<Block> toRemove = new LinkedList<Block>();
+    Collection<Block> toRemove = new TreeSet<Block>();
-    reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC);
+    reportDiff(node, storage, report,
+        toAdd, toRemove, toInvalidate, toCorrupt, toUC);
-      addStoredBlockUnderConstruction(b, node);
+      addStoredBlockUnderConstruction(b, node, storage.getStorageID());
-      addStoredBlock(b, node, null, numBlocksLogged < maxNumBlocksToLog);
+      addStoredBlock(b, node, storage.getStorageID(), null, numBlocksLogged < maxNumBlocksToLog);
-      markBlockAsCorrupt(b, node);
+      markBlockAsCorrupt(b, node, storage.getStorageID());
+      final String storageID,
-    assert (node.numBlocks() == 0);
+    assert (node.getStorageInfo(storageID).numBlocks() == 0);
-        queueReportedBlock(node, iblk, reportedState,
+        queueReportedBlock(node, storageID, iblk, reportedState,
-          queueReportedBlock(node, iblk, reportedState,
+          queueReportedBlock(node, storageID, iblk, reportedState,
-          markBlockAsCorrupt(c, node);
+          markBlockAsCorrupt(c, node, storageID);
-            node, iblk, reportedState);
+            node.getStorageInfo(storageID), iblk, reportedState);
-        addStoredBlockImmediate(storedBlock, node);
+        addStoredBlockImmediate(storedBlock, node, storageID);
-  private void reportDiff(DatanodeDescriptor dn, 
+  private void reportDiff(DatanodeDescriptor dn, DatanodeStorage storage, 
+
+    final DatanodeStorageInfo storageInfo = dn.updateStorage(storage);
+
-    boolean added = dn.addBlock(delimiter);
+    boolean added = storageInfo.addBlock(delimiter);
-      BlockInfo storedBlock = processReportedBlock(dn, iblk, iState,
-                                  toAdd, toInvalidate, toCorrupt, toUC);
+      BlockInfo storedBlock = processReportedBlock(dn, storage.getStorageID(),
+          iblk, iState, toAdd, toInvalidate, toCorrupt, toUC);
+
-        headIndex = dn.moveBlockToHead(storedBlock, curIndex, headIndex);
+        headIndex = storageInfo.moveBlockToHead(storedBlock, curIndex, headIndex);
+
-    Iterator<? extends Block> it = new DatanodeDescriptor.BlockIterator(
-        delimiter.getNext(0), dn);
+    Iterator<BlockInfo> it = storageInfo.new BlockIterator(delimiter.getNext(0));
-    dn.removeBlock(delimiter);
+    storageInfo.removeBlock(delimiter);
-  private BlockInfo processReportedBlock(final DatanodeDescriptor dn, 
+  private BlockInfo processReportedBlock(final DatanodeDescriptor dn,
+      final String storageID,
-      queueReportedBlock(dn, block, reportedState,
+      queueReportedBlock(dn, storageID, block, reportedState,
-    if(invalidateBlocks.contains(dn.getStorageID(), block)) {
+    if(invalidateBlocks.contains(dn.getDatanodeUuid(), block)) {
-        queueReportedBlock(dn, storedBlock, reportedState,
+        queueReportedBlock(dn, storageID, storedBlock, reportedState,
-  private void queueReportedBlock(DatanodeDescriptor dn, Block block,
+  private void queueReportedBlock(DatanodeDescriptor dn, String storageID, Block block,
-    pendingDNMessages.enqueueReportedBlock(dn, block, reportedState);
+    pendingDNMessages.enqueueReportedBlock(dn, storageID, block, reportedState);
-      processAndHandleReportedBlock(
-          rbi.getNode(), rbi.getBlock(), rbi.getReportedState(), null);
+      processAndHandleReportedBlock(rbi.getNode(), rbi.getStorageID(), 
+          rbi.getBlock(), rbi.getReportedState(), null);
-  
+
-      DatanodeDescriptor node) throws IOException {
+      DatanodeDescriptor node, String storageID) throws IOException {
-    block.addReplicaIfNotPresent(node, ucBlock.reportedBlock, ucBlock.reportedState);
+    block.addReplicaIfNotPresent(node.getStorageInfo(storageID),
+        ucBlock.reportedBlock, ucBlock.reportedState);
+
-      addStoredBlock(block, node, null, true);
+      addStoredBlock(block, node, storageID, null, true);
-  }
-  
+  } 
+
-   * {@link #addStoredBlock(BlockInfo, DatanodeDescriptor, DatanodeDescriptor, boolean)}
+   * {@link #addStoredBlock(BlockInfo, DatanodeDescriptor, String, DatanodeDescriptor, boolean)}
-                               DatanodeDescriptor node)
+      DatanodeDescriptor node, String storageID)
-      addStoredBlock(storedBlock, node, null, false);
+      addStoredBlock(storedBlock, node, storageID, null, false);
-    node.addBlock(storedBlock);
+    node.addBlock(storageID, storedBlock);
+                               String storageID,
-    boolean added = node.addBlock(storedBlock);
+    boolean added = node.addBlock(storageID, storedBlock);
-    for (Iterator<DatanodeDescriptor> it = blocksMap.nodeIterator(block);
-         it.hasNext();) {
-      DatanodeDescriptor cur = it.next();
-      if (cur.areBlockContentsStale()) {
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
+      final DatanodeDescriptor cur = storage.getDatanodeDescriptor();
+      if (storage.areBlockContentsStale()) {
-            block + " since datanode " + cur + " does not yet have up-to-date " +
+            block + " since storage + " + storage
+            + "datanode " + cur + " does not yet have up-to-date " +
-          .getStorageID());
+          .getDatanodeUuid());
-    LightWeightLinkedSet<Block> excessBlocks = excessReplicateMap.get(dn.getStorageID());
+    LightWeightLinkedSet<Block> excessBlocks = excessReplicateMap.get(dn.getDatanodeUuid());
-      excessReplicateMap.put(dn.getStorageID(), excessBlocks);
+      excessReplicateMap.put(dn.getDatanodeUuid(), excessBlocks);
-          .getStorageID());
+          .getDatanodeUuid());
-            excessReplicateMap.remove(node.getStorageID());
+            excessReplicateMap.remove(node.getDatanodeUuid());
-    final List<String> machineSet = getValidLocations(block);
-    if(machineSet.size() == 0) {
+    final List<DatanodeStorageInfo> locations = getValidLocations(block);
+    if(locations.size() == 0) {
-      results.add(new BlockWithLocations(block, 
-          machineSet.toArray(new String[machineSet.size()])));
+      final String[] datanodeUuids = new String[locations.size()];
+      final String[] storageIDs = new String[datanodeUuids.length];
+      for(int i = 0; i < locations.size(); i++) {
+        final DatanodeStorageInfo s = locations.get(i);
+        datanodeUuids[i] = s.getDatanodeDescriptor().getDatanodeUuid();
+        storageIDs[i] = s.getStorageID();
+      }
+      results.add(new BlockWithLocations(block, datanodeUuids, storageIDs));
-  void addBlock(DatanodeDescriptor node, Block block, String delHint)
+  void addBlock(DatanodeDescriptor node, String storageID, Block block, String delHint)
-    // decrement number of blocks scheduled to this datanode.
+    // Decrement number of blocks scheduled to this datanode.
-    node.decBlocksScheduled();
+    node.decrementBlocksScheduled();
-    processAndHandleReportedBlock(node, block, ReplicaState.FINALIZED,
+    processAndHandleReportedBlock(node, storageID, block, ReplicaState.FINALIZED,
-  private void processAndHandleReportedBlock(DatanodeDescriptor node, Block block,
+  private void processAndHandleReportedBlock(DatanodeDescriptor node,
+      String storageID, Block block,
-    processReportedBlock(node, block, reportedState,
+    processReportedBlock(node, storageID, block, reportedState,
-      addStoredBlockUnderConstruction(b, node);
+      addStoredBlockUnderConstruction(b, node, storageID);
-      addStoredBlock(b, node, delHintNode, numBlocksLogged < maxNumBlocksToLog);
+      addStoredBlock(b, node, storageID, delHintNode, numBlocksLogged < maxNumBlocksToLog);
-      markBlockAsCorrupt(b, node);
+      markBlockAsCorrupt(b, node, storageID);
-      final String poolId, final ReceivedDeletedBlockInfo blockInfos[])
+      final String poolId, final StorageReceivedDeletedBlocks srdb)
-    for (ReceivedDeletedBlockInfo rdbi : blockInfos) {
+    for (ReceivedDeletedBlockInfo rdbi : srdb.getBlocks()) {
-        addBlock(node, rdbi.getBlock(), rdbi.getDelHints());
+        addBlock(node, srdb.getStorageID(), rdbi.getBlock(), rdbi.getDelHints());
-        processAndHandleReportedBlock(node, rdbi.getBlock(),
+        processAndHandleReportedBlock(node, srdb.getStorageID(), rdbi.getBlock(),
-    Iterator<DatanodeDescriptor> nodeIter = blocksMap.nodeIterator(b);
-    while (nodeIter.hasNext()) {
-      DatanodeDescriptor node = nodeIter.next();
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(b)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-            .getStorageID());
+            .getDatanodeUuid());
-      if (node.areBlockContentsStale()) {
+      if (storage.areBlockContentsStale()) {
-    Iterator<DatanodeDescriptor> nodeIter = blocksMap.nodeIterator(b);
-    while (nodeIter.hasNext()) {
-      DatanodeDescriptor node = nodeIter.next();
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(b)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-    Iterator<DatanodeDescriptor> nodeIter = blocksMap.nodeIterator(block);
-    while (nodeIter.hasNext()) {
-      DatanodeDescriptor node = nodeIter.next();
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-  public DatanodeDescriptor[] getNodes(BlockInfo block) {
-    DatanodeDescriptor[] nodes =
-      new DatanodeDescriptor[block.numNodes()];
-    Iterator<DatanodeDescriptor> it = blocksMap.nodeIterator(block);
-    for (int i = 0; it != null && it.hasNext(); i++) {
-      nodes[i] = it.next();
+  public DatanodeStorageInfo[] getStorages(BlockInfo block) {
+    final DatanodeStorageInfo[] storages = new DatanodeStorageInfo[block.numNodes()];
+    int i = 0;
+    for(DatanodeStorageInfo s : blocksMap.getStorages(block)) {
+      storages[i++] = s;
-    return nodes;
+    return storages;
-    for (Iterator<DatanodeDescriptor> it = blocksMap.nodeIterator(b); 
-         it.hasNext();) {
-      DatanodeDescriptor cur = it.next();
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(b)) {
+      final DatanodeDescriptor cur = storage.getDatanodeDescriptor();
-  public Iterator<DatanodeDescriptor> datanodeIterator(final Block block) {
-    return blocksMap.nodeIterator(block);
+  public Iterable<DatanodeStorageInfo> getStorages(final Block block) {
+    return blocksMap.getStorages(block);
-    private List<DatanodeDescriptor> liveReplicaNodes;
+    private List<DatanodeStorageInfo> liveReplicaStorages;
-    private DatanodeDescriptor targets[];
+    private DatanodeStorageInfo targets[];
-        List<DatanodeDescriptor> liveReplicaNodes,
+        List<DatanodeStorageInfo> liveReplicaStorages,
-      this.liveReplicaNodes = liveReplicaNodes;
+      this.liveReplicaStorages = liveReplicaStorages;
-          additionalReplRequired, srcNode, liveReplicaNodes, false,
-          excludedNodes, block.getNumBytes());
+          additionalReplRequired, srcNode, liveReplicaStorages, false,
+          excludedNodes, block.getNumBytes(), StorageType.DEFAULT);

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD74 INS44 INS44 UPD5 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 UPD5 UPD42 UPD74 UPD42 INS70 INS43 INS70 INS60 INS70 INS70 MOV43 INS42 MOV43 INS42 UPD43 UPD74 INS70 INS83 INS43 INS42 INS83 INS43 INS42 INS83 MOV43 INS42 INS43 INS42 INS60 INS83 INS43 INS42 MOV43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS70 INS43 INS42 INS43 INS42 UPD43 UPD42 INS70 INS70 INS70 UPD43 INS60 INS70 INS70 UPD43 UPD43 UPD74 UPD43 UPD74 INS44 INS32 MOV8 UPD5 INS42 INS83 INS74 INS59 INS44 INS32 MOV8 UPD42 UPD5 INS39 INS59 INS44 INS32 INS8 INS42 INS44 INS32 MOV8 UPD42 INS5 UPD43 INS44 INS32 MOV8 UPD66 UPD66 INS42 INS42 INS42 INS83 INS43 INS59 UPD74 INS42 INS42 INS42 INS42 INS44 INS32 MOV8 MOV74 UPD74 INS42 INS42 UPD42 INS32 INS44 INS32 MOV8 INS44 INS32 MOV8 INS44 INS32 MOV8 UPD42 INS83 UPD5 INS39 INS59 INS44 INS32 INS8 UPD42 INS44 INS32 MOV8 UPD42 UPD42 UPD43 UPD42 UPD42 UPD74 UPD42 UPD43 INS43 INS42 MOV42 UPD42 MOV42 MOV42 UPD43 UPD43 UPD42 UPD43 MOV43 INS43 INS42 INS14 INS43 INS42 MOV42 UPD42 MOV42 MOV42 UPD43 INS70 INS42 INS9 INS43 INS42 INS42 INS42 INS25 INS43 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS43 INS85 UPD42 INS43 INS42 MOV42 UPD42 MOV42 MOV42 INS60 INS42 INS42 INS42 INS32 INS43 UPD42 INS42 INS32 INS42 INS43 INS42 MOV42 UPD42 MOV42 MOV42 MOV74 UPD43 UPD42 INS60 INS60 INS24 UPD42 INS42 INS42 INS42 INS42 INS43 INS42 MOV42 UPD42 MOV42 MOV42 INS43 INS42 MOV42 UPD42 MOV42 MOV42 INS43 INS42 MOV42 UPD42 MOV42 MOV42 UPD43 UPD42 INS42 INS34 INS43 INS42 MOV42 UPD42 MOV42 MOV42 MOV21 INS43 INS42 MOV42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD43 UPD42 UPD74 UPD42 MOV42 INS83 MOV43 UPD42 UPD42 UPD42 UPD42 INS42 UPD74 MOV74 MOV32 UPD42 MOV42 INS83 MOV43 UPD5 UPD42 UPD5 INS44 INS32 MOV8 UPD42 INS42 INS32 INS8 UPD42 MOV42 INS83 MOV43 UPD42 MOV42 INS40 UPD42 MOV42 INS83 MOV43 INS83 INS43 INS59 UPD74 INS42 INS42 INS42 UPD42 UPD42 MOV42 INS42 UPD43 UPD42 MOV42 INS42 INS42 INS69 INS42 UPD42 MOV42 INS83 MOV43 UPD42 UPD42 INS83 INS5 INS59 INS83 INS5 INS59 MOV58 INS27 MOV37 INS8 UPD42 MOV42 INS83 MOV43 UPD42 MOV42 INS83 MOV43 UPD42 MOV42 INS83 MOV43 UPD42 UPD5 UPD42 MOV42 UPD42 MOV42 INS83 UPD42 UPD42 UPD43 UPD42 INS32 INS43 UPD43 UPD42 UPD42 UPD43 INS43 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS21 INS10 INS42 INS42 INS32 INS27 UPD42 UPD43 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS42 INS43 INS42 UPD42 UPD42 INS43 INS85 INS42 MOV3 INS43 INS85 INS42 INS3 INS42 INS32 INS60 INS21 INS21 INS42 INS42 INS42 MOV42 UPD42 MOV42 MOV42 UPD43 INS42 UPD42 UPD42 INS40 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV43 INS7 UPD42 UPD42 INS83 UPD5 UPD5 UPD42 UPD42 INS42 INS42 INS42 INS32 INS34 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS5 INS40 INS42 INS42 INS83 INS43 INS59 INS7 INS7 INS42 INS42 INS32 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS37 UPD42 UPD42 UPD42 UPD42 INS42 INS9 UPD43 MOV21 UPD43 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS43 INS85 INS42 INS42 INS32 INS2 INS32 INS2 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 MOV42 INS42 INS42 UPD42 INS45 INS42 UPD45 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS60 UPD42 UPD42 INS42 INS32 UPD42 INS42 INS42 INS42 INS42 INS74 INS59 INS42 INS42 MOV42 INS32 UPD42 INS43 INS43 INS42 MOV14 INS32 INS42 INS42 MOV32 MOV42 UPD42 INS42 INS42 UPD74 MOV32 INS42 UPD42 UPD43 UPD42 UPD42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL74 DEL14 DEL59 DEL42 DEL32 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL32 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL59 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL43 DEL85 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL61 DEL32 DEL38 DEL43 DEL76 DEL40 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL32 DEL85 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL8 DEL24 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24
MAPREDUCE-3921. MR AM should act on node health status changes. Contributed by Bikas Saha.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1349065 13f79535-47bb-0310-9956-ffa450edef68

+    .addTransition(TaskState.SUCCEEDED, //only possible for map tasks
+        EnumSet.of(TaskState.SCHEDULED, TaskState.SUCCEEDED),
+        TaskEventType.T_ATTEMPT_KILLED, new MapRetroactiveKilledTransition())
-        EnumSet.of(TaskEventType.T_KILL,
-            TaskEventType.T_ADD_SPEC_ATTEMPT,
-            TaskEventType.T_ATTEMPT_LAUNCHED,
-            TaskEventType.T_ATTEMPT_KILLED))
+        EnumSet.of(TaskEventType.T_ADD_SPEC_ATTEMPT,
+            TaskEventType.T_ATTEMPT_LAUNCHED))
-    finishedAttempts++;
+  
+  private static void unSucceed(TaskImpl task) {
+    task.commitAttempt = null;
+    task.successfulAttempt = null;
+  }
+      task.finishedAttempts++;
+      task.finishedAttempts++;
+      task.finishedAttempts++;
+      task.finishedAttempts++;
-
-    protected void unSucceed(TaskImpl task) {
-      ++task.numberUncompletedAttempts;
-      task.commitAttempt = null;
-      task.successfulAttempt = null;
-    }
+      // fake increase in Uncomplete attempts for super.transition
+      ++task.numberUncompletedAttempts;
+  private static class MapRetroactiveKilledTransition implements
+    MultipleArcTransition<TaskImpl, TaskEvent, TaskState> {
+
+    @Override
+    public TaskState transition(TaskImpl task, TaskEvent event) {
+      // verify that this occurs only for map task
+      // TODO: consider moving it to MapTaskImpl
+      if (!TaskType.MAP.equals(task.getType())) {
+        LOG.error("Unexpected event for REDUCE task " + event.getType());
+        task.internalError(event.getType());
+      }
+
+      TaskTAttemptEvent attemptEvent = (TaskTAttemptEvent) event;
+      TaskAttemptId attemptId = attemptEvent.getTaskAttemptID();
+      if(task.successfulAttempt == attemptId) {
+        // successful attempt is now killed. reschedule
+        // tell the job about the rescheduling
+        unSucceed(task);
+        task.handleTaskAttemptCompletion(
+            attemptId, 
+            TaskAttemptCompletionEventStatus.KILLED);
+        task.eventHandler.handle(new JobMapTaskRescheduledEvent(task.taskId));
+        // typically we are here because this map task was run on a bad node and 
+        // we want to reschedule it on a different node.
+        // Depending on whether there are previous failed attempts or not this 
+        // can SCHEDULE or RESCHEDULE the container allocate request. If this
+        // SCHEDULE's then the dataLocal hosts of this taskAttempt will be used
+        // from the map splitInfo. So the bad node might be sent as a location 
+        // to the RM. But the RM would ignore that just like it would ignore 
+        // currently pending container requests affinitized to bad nodes.
+        task.addAndScheduleAttempt();
+        return TaskState.SCHEDULED;
+      } else {
+        // nothing to do
+        return TaskState.SUCCEEDED;
+      }
+    }
+  }
+
+      

MOV31 INS55 UPD83 INS83 INS83 INS83 INS42 INS74 INS31 INS43 INS43 INS43 INS43 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS21 INS21 INS21 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS25 INS60 INS60 INS25 INS37 INS37 INS37 INS37 INS42 INS42 INS38 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS32 INS42 INS40 INS40 INS40 INS40 INS32 INS21 INS21 INS42 INS42 INS11 INS42 INS42 INS32 INS40 INS42 INS21 INS21 INS21 INS21 INS41 INS41 MOV32 MOV42 INS40 INS40 INS32 INS40 INS42 INS32 INS32 INS32 INS43 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS40 INS40 INS32 MOV40 INS14 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS14 INS42 INS42 MOV42 MOV42 UPD40 MOV40 UPD40 MOV40 INS43 INS45 INS32 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 DEL40 DEL40 DEL32 DEL42 DEL37 DEL21
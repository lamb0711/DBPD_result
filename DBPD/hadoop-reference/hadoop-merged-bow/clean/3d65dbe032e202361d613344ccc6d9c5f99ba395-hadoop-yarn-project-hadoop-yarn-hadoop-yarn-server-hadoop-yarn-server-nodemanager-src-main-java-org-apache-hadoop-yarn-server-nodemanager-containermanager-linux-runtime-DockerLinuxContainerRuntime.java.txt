YARN-5366. Improve signal handling and delete delay for Docker on Yarn.
           (Contributed by Shane Kumpf)

+import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.runtime.docker.DockerCommandExecutor;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.runtime.docker.DockerKillCommand;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.runtime.docker.DockerRmCommand;
+ *   <li>
+ *     {@code YARN_CONTAINER_RUNTIME_DOCKER_DELAYED_REMOVAL} allows a user
+ *     to request delayed deletion of the Docker containers on a per
+ *     container basis. If true, Docker containers will not be removed until
+ *     the duration defined by {@code yarn.nodemanager.delete.debug-delay-sec}
+ *     has elapsed. Administrators can disable this feature through the
+ *     yarn-site property
+ *     {@code yarn.nodemanager.runtime.linux.docker.delayed-removal.allowed}.
+ *     This feature is disabled by default. When this feature is disabled or set
+ *     to false, the container will be removed as soon as it exits.
+ *   </li>
+  @InterfaceAudience.Private
+  public static final String ENV_DOCKER_CONTAINER_DELAYED_REMOVAL =
+      "YARN_CONTAINER_RUNTIME_DOCKER_DELAYED_REMOVAL";
+  private boolean delayedRemovalAllowed;
+
+    delayedRemovalAllowed = conf.getBoolean(
+        YarnConfiguration.NM_DOCKER_ALLOW_DELAYED_REMOVAL,
+        YarnConfiguration.DEFAULT_NM_DOCKER_ALLOW_DELAYED_REMOVAL);
+  /**
+   * Signal the docker container.
+   *
+   * Signals are used to check the liveliness of the container as well as to
+   * stop/kill the container. The following outlines the docker container
+   * signal handling.
+   *
+   * <ol>
+   *     <li>If the null signal is sent, run kill -0 on the pid. This is used
+   *     to check if the container is still alive, which is necessary for
+   *     reacquiring containers on NM restart.</li>
+   *     <li>If SIGTERM, SIGKILL is sent, attempt to stop and remove the docker
+   *     container.</li>
+   *     <li>If the docker container exists and is running, execute docker
+   *     stop.</li>
+   *     <li>If any other signal is sent, signal the container using docker
+   *     kill.</li>
+   * </ol>
+   *
+   * @param ctx the {@link ContainerRuntimeContext}.
+   * @throws ContainerExecutionException if the signaling fails.
+   */
-
-    PrivilegedOperation privOp = null;
-    // Handle liveliness checks, send null signal to pid
-    if(ContainerExecutor.Signal.NULL.equals(signal)) {
-      privOp = new PrivilegedOperation(
-          PrivilegedOperation.OperationType.SIGNAL_CONTAINER);
-      privOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),
-          ctx.getExecutionAttribute(USER),
-          Integer.toString(PrivilegedOperation.RunAsUserCommand
-              .SIGNAL_CONTAINER.getValue()),
-          ctx.getExecutionAttribute(PID),
-          Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));
-
-    // All other signals handled as docker stop
-    } else {
-      String containerId = ctx.getContainer().getContainerId().toString();
-      DockerStopCommand stopCommand = new DockerStopCommand(containerId);
-      String commandFile = dockerClient.writeCommandToTempFile(stopCommand,
-          containerId);
-      privOp = new PrivilegedOperation(
-          PrivilegedOperation.OperationType.RUN_DOCKER_CMD);
-      privOp.appendArgs(commandFile);
-    }
-
-    //Some failures here are acceptable. Let the calling executor decide.
-    privOp.disableFailureLogging();
-
+    String containerId = ctx.getContainer().getContainerId().toString();
+    Map<String, String> env =
+        ctx.getContainer().getLaunchContext().getEnvironment();
-      privilegedOperationExecutor.executePrivilegedOperation(null,
-          privOp, null, null, false, false);
-    } catch (PrivilegedOperationException e) {
-      throw new ContainerExecutionException("Signal container failed", e
-          .getExitCode(), e.getOutput(), e.getErrorOutput());
+      if (ContainerExecutor.Signal.NULL.equals(signal)) {
+        executeLivelinessCheck(ctx);
+      } else {
+        if (ContainerExecutor.Signal.KILL.equals(signal)
+            || ContainerExecutor.Signal.TERM.equals(signal)) {
+          handleContainerStop(containerId, env);
+        } else {
+          handleContainerKill(containerId, env, signal);
+        }
+      }
+    } catch (ContainerExecutionException e) {
+      LOG.warn("Signal docker container failed. Exception: ", e);
+      throw new ContainerExecutionException("Signal docker container failed",
+          e.getExitCode(), e.getOutput(), e.getErrorOutput());
+  /**
+   * Reap the docker container.
+   *
+   * @param ctx the {@link ContainerRuntimeContext}.
+   * @throws ContainerExecutionException if the removal fails.
+   */
+    // Clean up the Docker container
+    handleContainerRemove(ctx.getContainer().getContainerId().toString(),
+        ctx.getContainer().getLaunchContext().getEnvironment());
+
+
+  private void executeLivelinessCheck(ContainerRuntimeContext ctx)
+      throws ContainerExecutionException {
+    PrivilegedOperation signalOp = new PrivilegedOperation(
+        PrivilegedOperation.OperationType.SIGNAL_CONTAINER);
+    signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),
+        ctx.getExecutionAttribute(USER), Integer.toString(
+            PrivilegedOperation.RunAsUserCommand.SIGNAL_CONTAINER.getValue()),
+        ctx.getExecutionAttribute(PID),
+        Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));
+    signalOp.disableFailureLogging();
+    try {
+      privilegedOperationExecutor.executePrivilegedOperation(null, signalOp,
+          null, ctx.getContainer().getLaunchContext().getEnvironment(), false,
+          false);
+    } catch (PrivilegedOperationException e) {
+      String msg = "Liveliness check failed for PID: "
+          + ctx.getExecutionAttribute(PID)
+          + ". Container may have already completed.";
+      throw new ContainerExecutionException(msg, e.getExitCode(), e.getOutput(),
+          e.getErrorOutput());
+    }
+  }
+
+  private void handleContainerStop(String containerId, Map<String, String> env)
+      throws ContainerExecutionException {
+    DockerCommandExecutor.DockerContainerStatus containerStatus =
+        DockerCommandExecutor.getContainerStatus(containerId, conf,
+            privilegedOperationExecutor);
+    if (DockerCommandExecutor.isStoppable(containerStatus)) {
+      DockerStopCommand dockerStopCommand = new DockerStopCommand(containerId);
+      DockerCommandExecutor.executeDockerCommand(dockerStopCommand, containerId,
+          env, conf, privilegedOperationExecutor, false);
+    } else {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug(
+            "Container status is " + containerStatus.getName()
+                + ", skipping stop - " + containerId);
+      }
+    }
+  }
+
+  private void handleContainerKill(String containerId, Map<String, String> env,
+      ContainerExecutor.Signal signal) throws ContainerExecutionException {
+    DockerCommandExecutor.DockerContainerStatus containerStatus =
+        DockerCommandExecutor.getContainerStatus(containerId, conf,
+            privilegedOperationExecutor);
+    if (DockerCommandExecutor.isKillable(containerStatus)) {
+      DockerKillCommand dockerKillCommand =
+          new DockerKillCommand(containerId).setSignal(signal.name());
+      DockerCommandExecutor.executeDockerCommand(dockerKillCommand, containerId,
+          env, conf, privilegedOperationExecutor, false);
+    } else {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug(
+            "Container status is " + containerStatus.getName()
+                + ", skipping kill - " + containerId);
+      }
+    }
+  }
+
+  private void handleContainerRemove(String containerId,
+      Map<String, String> env) throws ContainerExecutionException {
+    String delayedRemoval = env.get(ENV_DOCKER_CONTAINER_DELAYED_REMOVAL);
+    if (delayedRemovalAllowed && delayedRemoval != null
+        && delayedRemoval.equalsIgnoreCase("true")) {
+      LOG.info("Delayed removal requested and allowed, skipping removal - "
+          + containerId);
+    } else {
+      DockerCommandExecutor.DockerContainerStatus containerStatus =
+          DockerCommandExecutor.getContainerStatus(containerId, conf,
+              privilegedOperationExecutor);
+      if (DockerCommandExecutor.isRemovable(containerStatus)) {
+        DockerRmCommand dockerRmCommand = new DockerRmCommand(containerId);
+        DockerCommandExecutor.executeDockerCommand(dockerRmCommand, containerId,
+            env, conf, privilegedOperationExecutor, false);
+      }
+    }
+  }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS78 INS83 INS83 INS83 INS43 INS59 INS83 INS39 INS59 INS29 MOV78 INS83 MOV39 MOV42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 MOV44 MOV43 MOV8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS40 INS42 INS42 INS45 INS42 INS21 INS65 INS65 INS65 INS43 INS42 INS42 MOV60 MOV60 MOV60 INS54 INS65 INS65 INS65 INS21 INS60 INS21 INS54 INS43 INS42 INS74 INS42 INS42 INS60 INS25 INS43 INS42 INS74 INS42 INS43 INS42 UPD42 MOV42 INS60 INS25 INS43 INS42 INS74 INS42 INS42 INS60 INS25 INS66 INS66 INS66 INS7 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS42 INS74 INS8 MOV12 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS32 MOV43 INS59 INS32 INS8 INS12 MOV42 INS43 INS43 INS43 INS43 INS59 INS32 INS8 INS8 INS42 INS43 INS43 INS43 INS40 INS43 INS59 INS32 INS8 INS8 INS42 INS43 INS43 INS43 INS43 INS59 INS27 INS8 INS8 INS42 INS32 INS42 INS43 INS43 INS43 UPD42 INS32 INS25 INS42 INS42 INS32 INS32 INS42 INS42 MOV14 UPD42 INS42 INS42 MOV21 INS44 INS8 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 MOV60 INS21 INS25 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS60 MOV21 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS21 INS60 INS25 INS42 INS42 INS40 INS40 UPD42 MOV42 INS42 INS42 INS32 INS42 MOV32 INS8 INS8 MOV43 INS21 INS32 INS42 INS32 INS42 INS32 MOV43 INS42 INS60 INS53 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS32 INS43 INS59 INS32 INS8 INS32 INS42 INS21 INS25 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS33 INS42 INS33 INS32 INS9 INS9 MOV43 INS59 INS14 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS9 INS42 INS42 INS21 INS42 INS42 INS32 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 MOV21 INS42 INS33 INS42 INS42 INS27 INS40 INS42 INS32 INS42 INS42 INS42 INS60 MOV21 INS42 INS42 INS32 INS27 INS8 INS8 INS42 INS42 INS45 INS42 INS43 UPD45 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS43 INS42 INS32 INS32 INS32 INS32 INS14 INS42 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS42 INS42 INS32 INS32 INS21 INS21 INS42 INS32 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS42 INS42 INS42 UPD42 UPD42 INS27 INS42 INS42 INS14 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS40 INS42 INS42 INS40 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS42 INS45 INS32 INS45 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL43 DEL33 DEL83 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL42 DEL7 DEL33 DEL33 DEL33 DEL9
HDFS-3702. Add an option for NOT writing the blocks locally if there is a datanode on the same box as the client. (Contributed by Lei (Eddy) Xu)

+import org.apache.hadoop.hdfs.AddBlockFlag;
-                                    final BlockStoragePolicy storagePolicy) {
+                                    final BlockStoragePolicy storagePolicy,
+                                    EnumSet<AddBlockFlag> flags) {
-        excludedNodes, blocksize, storagePolicy);
+        excludedNodes, blocksize, storagePolicy, flags);
-      BlockStoragePolicy storagePolicy) {
+      BlockStoragePolicy storagePolicy,
+      EnumSet<AddBlockFlag> flags) {
-            excludedNodes, blocksize, storagePolicy);
+            excludedNodes, blocksize, storagePolicy, flags);
-                favoriteAndExcludedNodes, blocksize, storagePolicy);
+                favoriteAndExcludedNodes, blocksize, storagePolicy, flags);
-          excludedNodes, blocksize, storagePolicy);
+          excludedNodes, blocksize, storagePolicy, flags);
-                                    final BlockStoragePolicy storagePolicy) {
+                                    final BlockStoragePolicy storagePolicy,
+                                    EnumSet<AddBlockFlag> addBlockFlags) {
-    final List<DatanodeStorageInfo> results = new ArrayList<>(chosenStorage);
+    List<DatanodeStorageInfo> results = null;
+    Node localNode = null;
-    final Node localNode = chooseTarget(numOfReplicas, writer, excludedNodes,
-        blocksize, maxNodesPerRack, results, avoidStaleNodes, storagePolicy,
-        EnumSet.noneOf(StorageType.class), results.isEmpty());
+    boolean avoidLocalNode = (addBlockFlags != null
+        && addBlockFlags.contains(AddBlockFlag.NO_LOCAL_WRITE)
+        && writer != null
+        && !excludedNodes.contains(writer));
+    // Attempt to exclude local node if the client suggests so. If no enough
+    // nodes can be obtained, it falls back to the default block placement
+    // policy.
+    if (avoidLocalNode) {
+      results = new ArrayList<>(chosenStorage);
+      Set<Node> excludedNodeCopy = new HashSet<>(excludedNodes);
+      excludedNodeCopy.add(writer);
+      localNode = chooseTarget(numOfReplicas, writer,
+          excludedNodeCopy, blocksize, maxNodesPerRack, results,
+          avoidStaleNodes, storagePolicy,
+          EnumSet.noneOf(StorageType.class), results.isEmpty());
+      if (results.size() < numOfReplicas) {
+        // not enough nodes; discard results and fall back
+        results = null;
+      }
+    }
+    if (results == null) {
+      results = new ArrayList<>(chosenStorage);
+      localNode = chooseTarget(numOfReplicas, writer, excludedNodes,
+          blocksize, maxNodesPerRack, results, avoidStaleNodes,
+          storagePolicy, EnumSet.noneOf(StorageType.class), results.isEmpty());
+    }
+

INS26 INS40 INS44 INS44 INS44 MOV60 MOV60 INS74 INS42 INS74 INS42 INS74 INS42 INS60 INS25 INS25 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS39 INS59 INS42 INS8 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS33 INS42 INS36 INS21 INS60 INS21 INS21 INS25 INS42 INS33 INS21 INS21 INS27 INS7 INS74 INS59 INS32 INS7 INS27 INS8 INS7 INS7 INS27 INS38 INS42 MOV14 INS43 MOV43 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS21 INS42 INS14 INS42 MOV32 INS42 INS27 INS27 INS32 INS42 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS7 INS74 INS42 INS42 INS27 INS32 INS42 INS33 INS42 INS42 INS42 INS43 INS42 INS42 INS57 INS42 INS42 INS42 INS33 INS43 INS42 INS42 INS33 INS42 INS42 INS40 INS42 INS43 INS42 INS42 DEL83 DEL83
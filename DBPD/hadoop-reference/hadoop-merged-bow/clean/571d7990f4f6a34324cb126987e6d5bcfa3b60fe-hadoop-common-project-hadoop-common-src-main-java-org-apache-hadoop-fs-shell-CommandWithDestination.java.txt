Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.InputStream;
+import org.apache.hadoop.fs.FSDataOutputStream;
+import org.apache.hadoop.fs.shell.PathExceptions.PathIsDirectoryException;
+import org.apache.hadoop.fs.shell.PathExceptions.PathOperationException;
+import org.apache.hadoop.io.IOUtils;
-  protected void processPaths(PathData parent, PathData ... items)
+  protected void processPathArgument(PathData src)
-    PathData savedDst = dst;
-    try {
-      // modify dst as we descend to append the basename of the
-      // current directory being processed
-      if (parent != null) dst = dst.getPathDataForChild(parent);
-      super.processPaths(parent, items);
-    } finally {
-      dst = savedDst;
+    if (src.stat.isDirectory() && src.fs.equals(dst.fs)) {
+      PathData target = getTargetPath(src);
+      String srcPath = src.fs.makeQualified(src.path).toString();
+      String dstPath = dst.fs.makeQualified(target.path).toString();
+      if (dstPath.equals(srcPath)) {
+        PathIOException e = new PathIOException(src.toString(),
+            "are identical");
+        e.setTargetPath(dstPath.toString());
+        throw e;
+      }
+      if (dstPath.startsWith(srcPath+Path.SEPARATOR)) {
+        PathIOException e = new PathIOException(src.toString(),
+            "is a subdirectory of itself");
+        e.setTargetPath(target.toString());
+        throw e;
+      }
+    super.processPathArgument(src);
-  
+
-    PathData target;
-    // if the destination is a directory, make target a child path,
-    // else use the destination as-is
-    if (dst.exists && dst.stat.isDirectory()) {
-      target = dst.getPathDataForChild(src);
-    } else {
-      target = dst;
-    }
-    if (target.exists && !overwrite) {
-      throw new PathExistsException(target.toString());
-    }
-
-    try { 
-      // invoke processPath with both a source and resolved target
-      processPath(src, target);
-    } catch (PathIOException e) {
-      // add the target unless it already has one
-      if (e.getTargetPath() == null) {
-        e.setTargetPath(target.toString());
-      }
-      throw e;
-    }
+    processPath(src, getTargetPath(src));
-
+  
-  protected abstract void processPath(PathData src, PathData target)
-  throws IOException;
+  protected void processPath(PathData src, PathData dst) throws IOException {
+    if (src.stat.isSymlink()) {
+      // TODO: remove when FileContext is supported, this needs to either
+      // copy the symlink or deref the symlink
+      throw new PathOperationException(src.toString());        
+    } else if (src.stat.isFile()) {
+      copyFileToTarget(src, dst);
+    } else if (src.stat.isDirectory() && !isRecursive()) {
+      throw new PathIsDirectoryException(src.toString());
+    }
+  }
+
+  @Override
+  protected void recursePath(PathData src) throws IOException {
+    PathData savedDst = dst;
+    try {
+      // modify dst as we descend to append the basename of the
+      // current directory being processed
+      dst = getTargetPath(src);
+      if (dst.exists) {
+        if (!dst.stat.isDirectory()) {
+          throw new PathIsNotDirectoryException(dst.toString());
+        }
+      } else {
+        if (!dst.fs.mkdirs(dst.path)) {
+          // too bad we have no clue what failed
+          PathIOException e = new PathIOException(dst.toString());
+          e.setOperation("mkdir");
+          throw e;
+        }    
+        dst.refreshStatus(); // need to update stat to know it exists now
+      }      
+      super.recursePath(src);
+    } finally {
+      dst = savedDst;
+    }
+  }
+  
+  protected PathData getTargetPath(PathData src) throws IOException {
+    PathData target;
+    // on the first loop, the dst may be directory or a file, so only create
+    // a child path if dst is a dir; after recursion, it's always a dir
+    if ((getDepth() > 0) || (dst.exists && dst.stat.isDirectory())) {
+      target = dst.getPathDataForChild(src);
+    } else {
+      target = dst;
+    }
+    return target;
+  }
+  
+  /**
+   * Copies the source file to the target.
+   * @param src item to copy
+   * @param target where to copy the item
+   * @throws IOException if copy fails
+   */ 
+  protected void copyFileToTarget(PathData src, PathData target) throws IOException {
+    copyStreamToTarget(src.fs.open(src.path), target);
+  }
+  
+  /**
+   * Copies the stream contents to a temporary file.  If the copy is
+   * successful, the temporary file will be renamed to the real path,
+   * else the temporary file will be deleted.
+   * @param in the input stream for the copy
+   * @param target where to store the contents of the stream
+   * @throws IOException if copy fails
+   */ 
+  protected void copyStreamToTarget(InputStream in, PathData target)
+  throws IOException {
+    if (target.exists && (target.stat.isDirectory() || !overwrite)) {
+      throw new PathExistsException(target.toString());
+    }
+    PathData tempFile = null;
+    try {
+      tempFile = target.createTempFile(target+"._COPYING_");
+      FSDataOutputStream out = target.fs.create(tempFile.path, true);
+      IOUtils.copyBytes(in, out, getConf(), true);
+      // the rename method with an option to delete the target is deprecated
+      if (target.exists && !target.fs.delete(target.path, false)) {
+        // too bad we don't know why it failed
+        PathIOException e = new PathIOException(target.toString());
+        e.setOperation("delete");
+        throw e;
+      }
+      if (!tempFile.fs.rename(tempFile.path, target.path)) {
+        // too bad we don't know why it failed
+        PathIOException e = new PathIOException(tempFile.toString());
+        e.setOperation("rename");
+        e.setTargetPath(target.toString());
+        throw e;
+      }
+      tempFile = null;
+    } finally {
+      if (tempFile != null) {
+        tempFile.fs.delete(tempFile.path, false);
+      }
+    }
+  }

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 MOV78 UPD42 INS43 INS8 INS78 MOV83 INS39 INS42 INS44 INS43 INS8 MOV29 UPD83 MOV83 MOV39 MOV42 MOV44 MOV44 MOV43 INS8 MOV78 INS83 INS39 INS42 INS44 MOV43 INS8 INS43 UPD42 INS29 INS83 INS39 INS42 INS44 MOV44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS43 INS42 INS42 MOV25 MOV21 INS42 INS43 INS42 INS42 INS21 UPD42 INS25 INS43 INS42 MOV60 INS54 INS42 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 MOV25 INS60 INS54 INS42 UPD27 INS8 INS42 INS32 INS32 INS8 INS25 INS42 INS8 MOV8 INS27 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS27 INS43 INS59 INS8 INS8 INS32 INS32 INS60 INS60 INS60 INS25 INS25 UPD42 UPD42 INS42 INS42 INS32 INS40 INS42 INS53 INS32 INS8 INS25 INS21 INS25 INS21 INS36 INS36 INS42 INS32 INS42 INS40 INS36 INS42 INS42 INS33 INS21 INS60 INS21 INS25 INS25 INS21 INS25 INS40 INS42 INS40 INS42 INS40 MOV43 INS59 INS43 INS59 INS43 INS59 INS32 INS8 INS32 MOV8 INS42 INS42 INS14 INS40 INS42 INS21 INS27 INS8 INS7 INS40 INS8 INS8 INS48 INS27 MOV27 INS40 INS42 INS40 UPD27 MOV27 INS7 INS43 INS59 INS32 INS27 INS8 INS38 INS8 INS7 INS27 INS8 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS60 INS21 INS53 INS42 INS42 INS27 INS60 MOV53 INS43 INS32 INS32 INS32 INS38 INS53 INS42 INS32 INS25 INS25 INS21 INS42 INS42 INS32 INS34 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS9 INS40 INS38 INS60 INS21 INS53 INS32 INS60 INS21 INS21 INS53 INS42 INS33 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS32 INS42 INS43 INS59 INS32 INS42 INS42 INS40 INS43 INS59 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS14 INS42 INS42 INS38 INS8 INS38 INS8 INS32 INS42 INS40 INS42 INS42 INS42 INS27 INS40 INS42 INS40 INS9 INS42 INS32 INS43 INS59 INS32 INS42 INS40 INS42 INS40 INS40 INS43 INS59 INS32 INS32 INS42 INS32 INS40 INS42 INS40 INS40 INS42 INS40 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS43 INS32 INS32 INS53 INS32 INS60 INS21 INS53 INS42 INS42 INS42 INS45 INS40 INS42 INS40 INS9 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS32 INS40 INS42 INS40 INS9 INS43 INS32 INS45 INS42 INS42 MOV43 INS32 INS45 INS42 INS42 INS42 INS40 INS42 INS14 INS40 INS42 INS40 INS43 INS59 INS32 INS42 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 DEL42 DEL42 DEL33 DEL42 DEL32 DEL7 DEL21 DEL42 DEL8 DEL54 DEL8 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL32 DEL33 DEL27 DEL25 DEL8 DEL12 DEL54 DEL40 DEL31
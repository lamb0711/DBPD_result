HDFS-5548. Use ConcurrentHashMap in portmap. Contributed by Haohui Mai

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545756 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
-final class RpcProgramPortmap extends IdleStateAwareChannelUpstreamHandler implements PortmapInterface {
+final class RpcProgramPortmap extends IdleStateAwareChannelUpstreamHandler {
+
+  static final int PMAPPROC_NULL = 0;
+  static final int PMAPPROC_SET = 1;
+  static final int PMAPPROC_UNSET = 2;
+  static final int PMAPPROC_GETPORT = 3;
+  static final int PMAPPROC_DUMP = 4;
+  static final int PMAPPROC_GETVERSADDR = 9;
+
-  /** Map synchronized usis monitor lock of this instance */
-  private final HashMap<String, PortmapMapping> map;
+  private final ConcurrentHashMap<String, PortmapMapping> map = new ConcurrentHashMap<String, PortmapMapping>();
-    map = new HashMap<String, PortmapMapping>(256);
-  
-  @Override
-  public XDR nullOp(int xid, XDR in, XDR out) {
+
+  /**
+   * This procedure does no work. By convention, procedure zero of any protocol
+   * takes no parameters and returns no results.
+   */
+  private XDR nullOp(int xid, XDR in, XDR out) {
-  @Override
-  public XDR set(int xid, XDR in, XDR out) {
+  /**
+   * When a program first becomes available on a machine, it registers itself
+   * with the port mapper program on the same machine. The program passes its
+   * program number "prog", version number "vers", transport protocol number
+   * "prot", and the port "port" on which it awaits service request. The
+   * procedure returns a boolean reply whose value is "TRUE" if the procedure
+   * successfully established the mapping and "FALSE" otherwise. The procedure
+   * refuses to establish a mapping if one already exists for the tuple
+   * "(prog, vers, prot)".
+   */
+  private XDR set(int xid, XDR in, XDR out) {
-    PortmapMapping value = null;
-    synchronized(this) {
-      map.put(key, mapping);
-      value = map.get(key);
-    }  
-    return PortmapResponse.intReply(out, xid, value.getPort());
+    map.put(key, mapping);
+    return PortmapResponse.intReply(out, xid, mapping.getPort());
-  @Override
-  public synchronized XDR unset(int xid, XDR in, XDR out) {
+  /**
+   * When a program becomes unavailable, it should unregister itself with the
+   * port mapper program on the same machine. The parameters and results have
+   * meanings identical to those of "PMAPPROC_SET". The protocol and port number
+   * fields of the argument are ignored.
+   */
+  private XDR unset(int xid, XDR in, XDR out) {
-    synchronized(this) {
-      map.remove(PortmapMapping.key(mapping));
-    }
+    String key = PortmapMapping.key(mapping);
+
+    if (LOG.isDebugEnabled())
+      LOG.debug("Portmap remove key=" + key);
+
+    map.remove(key);
-  @Override
-  public synchronized XDR getport(int xid, XDR in, XDR out) {
+  /**
+   * Given a program number "prog", version number "vers", and transport
+   * protocol number "prot", this procedure returns the port number on which the
+   * program is awaiting call requests. A port value of zeros means the program
+   * has not been registered. The "port" field of the argument is ignored.
+   */
+  private XDR getport(int xid, XDR in, XDR out) {
-    PortmapMapping value = null;
-    synchronized(this) {
-      value = map.get(key);
-    }
+    PortmapMapping value = map.get(key);
-  @Override
-  public synchronized XDR dump(int xid, XDR in, XDR out) {
-    PortmapMapping[] pmapList = null;
-    synchronized(this) {
-      pmapList = new PortmapMapping[map.values().size()];
-      map.values().toArray(pmapList);
-    }
+  /**
+   * This procedure enumerates all entries in the port mapper's database. The
+   * procedure takes no parameters and returns a list of program, version,
+   * protocol, and port values.
+   */
+  private XDR dump(int xid, XDR in, XDR out) {
+    PortmapMapping[] pmapList = map.values().toArray(new PortmapMapping[0]);
-    final Procedure portmapProc = Procedure.fromValue(rpcCall.getProcedure());
+    final int portmapProc = rpcCall.getProcedure();
-    if (portmapProc == Procedure.PMAPPROC_NULL) {
+    if (portmapProc == PMAPPROC_NULL) {
-    } else if (portmapProc == Procedure.PMAPPROC_SET) {
+    } else if (portmapProc == PMAPPROC_SET) {
-    } else if (portmapProc == Procedure.PMAPPROC_UNSET) {
+    } else if (portmapProc == PMAPPROC_UNSET) {
-    } else if (portmapProc == Procedure.PMAPPROC_DUMP) {
+    } else if (portmapProc == PMAPPROC_DUMP) {
-    } else if (portmapProc == Procedure.PMAPPROC_GETPORT) {
+    } else if (portmapProc == PMAPPROC_GETPORT) {
-    } else if (portmapProc == Procedure.PMAPPROC_GETVERSADDR) {
+    } else if (portmapProc == PMAPPROC_GETVERSADDR) {
-  
+

UPD40 INS23 INS23 INS23 INS23 INS23 INS23 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 UPD74 MOV74 INS29 UPD83 INS29 UPD83 INS29 UPD83 INS29 UPD83 INS29 UPD83 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 UPD43 INS14 INS65 INS65 MOV21 INS65 INS60 INS25 INS21 INS65 INS65 INS60 UPD42 UPD74 MOV74 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS59 INS32 INS21 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 MOV5 INS59 INS39 UPD43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 MOV32 INS42 INS32 MOV32 INS42 UPD42 UPD42 MOV42 MOV42 MOV42 INS42 INS42 INS27 MOV32 MOV42 INS3 INS42 INS45 INS42 MOV5 INS34 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL66 DEL65 DEL29 DEL42 DEL34 DEL14 DEL7 DEL21 DEL42 DEL78 DEL42 DEL78 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL51 DEL42 DEL78 DEL83 DEL52 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL51 DEL42 DEL78 DEL83 DEL33 DEL52 DEL42 DEL7 DEL21 DEL8 DEL51 DEL42 DEL78 DEL83 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL3 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL51 DEL42 DEL43 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40
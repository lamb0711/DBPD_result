YARN-3215. Respect labels in CapacityScheduler when computing headroom. (Naganarasimha G R via wangda)

-    return getHeadroom(user, queueCurrentLimit, clusterResource,
-        computeUserLimit(application, clusterResource, user,
-            RMNodeLabelsManager.NO_LABEL,
-            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));
+    return getHeadroom(user, queueCurrentLimit, clusterResource, application,
+        RMNodeLabelsManager.NO_LABEL);
-  
-  private Resource getHeadroom(User user, Resource currentResourceLimit,
-      Resource clusterResource, Resource userLimit) {
+
+  protected Resource getHeadroom(User user, Resource queueCurrentLimit,
+      Resource clusterResource, FiCaSchedulerApp application,
+      String partition) {
+    return getHeadroom(user, queueCurrentLimit, clusterResource,
+        computeUserLimit(application, clusterResource, user, partition,
+            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), partition);
+  }
+
+  private Resource getHeadroom(User user,
+      Resource currentPartitionResourceLimit, Resource clusterResource,
+      Resource userLimitResource, String partition) {
+     * sum of queue max capacities of multiple queue's will be greater than the
+     * actual capacity of a given partition, hence we need to ensure that the
+     * headroom is not greater than the available resource for a given partition
+     *
+     * headroom = min (unused resourcelimit of a label, calculated headroom )
-    Resource headroom = 
-      Resources.componentwiseMin(
-        Resources.subtract(userLimit, user.getUsed()),
-        Resources.subtract(currentResourceLimit, queueUsage.getUsed())
-        );
+    currentPartitionResourceLimit =
+        partition.equals(RMNodeLabelsManager.NO_LABEL)
+            ? currentPartitionResourceLimit
+            : getQueueMaxResource(partition, clusterResource);
+
+    Resource headroom = Resources.componentwiseMin(
+        Resources.subtract(userLimitResource, user.getUsed(partition)),
+        Resources.subtract(currentPartitionResourceLimit,
+            queueUsage.getUsed(partition)));
+
+    //headroom = min (unused resourcelimit of a label, calculated headroom )
+    Resource clusterPartitionResource =
+        labelManager.getResourceByLabel(partition, clusterResource);
+    Resource clusterFreePartitionResource =
+        Resources.subtract(clusterPartitionResource,
+            csContext.getClusterResourceUsage().getUsed(partition));
+    headroom = Resources.min(resourceCalculator, clusterPartitionResource,
+        clusterFreePartitionResource, headroom);
-    
+
-            clusterResource, userLimit);
+            clusterResource, userLimit, nodePartition);

INS31 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS44 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS41 MOV43 UPD42 UPD42 INS43 INS42 INS21 INS60 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS7 MOV43 INS43 INS59 INS43 INS59 INS7 MOV42 MOV40 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS16 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL40 DEL32
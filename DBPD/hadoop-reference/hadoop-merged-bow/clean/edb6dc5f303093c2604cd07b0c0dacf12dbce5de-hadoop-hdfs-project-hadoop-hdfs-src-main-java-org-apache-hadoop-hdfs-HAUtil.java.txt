HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.fs.UnresolvedLinkException;
+import org.apache.hadoop.hdfs.protocol.ClientProtocol;
+import org.apache.hadoop.ipc.RemoteException;
+import org.apache.hadoop.ipc.StandbyException;
+import org.apache.hadoop.security.AccessControlException;
+import java.io.FileNotFoundException;
+import java.util.List;
+  
+  /**
+   * Get an RPC proxy for each NN in an HA nameservice. Used when a given RPC
+   * call should be made on every NN in an HA nameservice, not just the active.
+   * 
+   * @param conf configuration
+   * @param nsId the nameservice to get all of the proxies for.
+   * @return a list of RPC proxies for each NN in the nameservice.
+   * @throws IOException in the event of error.
+   */
+  public static List<ClientProtocol> getProxiesForAllNameNodesInNameservice(
+      Configuration conf, String nsId) throws IOException {
+    Map<String, InetSocketAddress> nnAddresses =
+        DFSUtil.getRpcAddressesForNameserviceId(conf, nsId, null);
+    
+    List<ClientProtocol> namenodes = new ArrayList<ClientProtocol>();
+    for (InetSocketAddress nnAddress : nnAddresses.values()) {
+      NameNodeProxies.ProxyAndInfo<ClientProtocol> proxyInfo = null;
+      proxyInfo = NameNodeProxies.createNonHAProxy(conf,
+          nnAddress, ClientProtocol.class,
+          UserGroupInformation.getCurrentUser(), false);
+      namenodes.add(proxyInfo.getProxy());
+    }
+    return namenodes;
+  }
+  
+  /**
+   * Used to ensure that at least one of the given HA NNs is currently in the
+   * active state..
+   * 
+   * @param namenodes list of RPC proxies for each NN to check.
+   * @return true if at least one NN is active, false if all are in the standby state.
+   * @throws IOException in the event of error.
+   */
+  public static boolean isAtLeastOneActive(List<ClientProtocol> namenodes)
+      throws IOException {
+    for (ClientProtocol namenode : namenodes) {
+      try {
+        namenode.getFileInfo("/");
+        return true;
+      } catch (RemoteException re) {
+        IOException cause = re.unwrapRemoteException();
+        if (cause instanceof StandbyException) {
+          // This is expected to happen for a standby NN.
+        } else {
+          throw re;
+        }
+      }
+    }
+    return false;
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS29 INS83 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS70 INS41 INS65 INS65 INS65 INS65 INS74 INS42 INS42 INS70 INS41 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS74 INS59 INS74 INS59 INS44 INS32 INS8 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS43 INS44 INS42 INS8 INS9 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS42 INS60 INS21 INS21 INS42 INS42 INS43 INS42 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS74 INS42 INS74 INS59 INS7 INS32 INS42 INS8 INS12 INS43 INS43 INS43 INS43 INS42 INS33 INS42 INS32 INS42 INS42 INS32 INS21 INS41 INS44 INS8 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS57 INS32 INS9 INS42 INS42 INS32 INS9 INS43 INS42 INS60 INS25 INS43 INS42 INS42 INS42 INS42 INS45 INS42 INS43 INS59 INS62 INS8 INS8 INS42 INS42 INS42 INS32 INS42 INS43 INS53 INS42 INS42 INS42 INS42
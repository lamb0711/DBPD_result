Merge r1408927 through r1410997 from trunk


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1411007 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Collections;
-  // Minimum resource allocation for each queue
-  private Map<String, Resource> minQueueResources = new HashMap<String, Resource>();
-  // Maximum amount of resources per queue
-  private Map<String, Resource> maxQueueResources = new HashMap<String, Resource>();
-  // Sharing weights for each queue
-  private Map<String, Double> queueWeights = new HashMap<String, Double>();
-
-  // Max concurrent running applications for each queue and for each user; in addition,
-  // for users that have no max specified, we use the userMaxJobsDefault.
-  private Map<String, Integer> queueMaxApps = new HashMap<String, Integer>();
-  private Map<String, Integer> userMaxApps = new HashMap<String, Integer>();
-  private int userMaxAppsDefault = Integer.MAX_VALUE;
-  private int queueMaxAppsDefault = Integer.MAX_VALUE;
-
-  // ACL's for each queue. Only specifies non-default ACL's from configuration.
-  private Map<String, Map<QueueACL, AccessControlList>> queueAcls =
-      new HashMap<String, Map<QueueACL, AccessControlList>>();
-
-  // Min share preemption timeout for each queue in seconds. If a job in the queue
-  // waits this long without receiving its guaranteed share, it is allowed to
-  // preempt other jobs' tasks.
-  private Map<String, Long> minSharePreemptionTimeouts =
-    new HashMap<String, Long>();
-
-  // Default min share preemption timeout for queues where it is not set
-  // explicitly.
-  private long defaultMinSharePreemptionTimeout = Long.MAX_VALUE;
-
-  // Preemption timeout for jobs below fair share in seconds. If a job remains
-  // below half its fair share for this long, it is allowed to preempt tasks.
-  private long fairSharePreemptionTimeout = Long.MAX_VALUE;
-
-  SchedulingMode defaultSchedulingMode = SchedulingMode.FAIR;
-
+  private volatile QueueManagerInfo info = new QueueManagerInfo();
+  
-  // Monitor object for minQueueResources
-  private Object minQueueResourcesMO = new Object();
-  
-  //Monitor object for maxQueueResources
-  private Object maxQueueResourcesMO = new Object();
-  
-  //Monitor object for queueMaxApps
-  private Object queueMaxAppsMO = new Object();
-  
-  //Monitor object for userMaxApps
-  private Object userMaxAppsMO = new Object();
-  
-  //Monitor object for queueWeights
-  private Object queueWeightsMO = new Object();
-  
-  //Monitor object for minSharePreemptionTimeouts
-  private Object minSharePreemptionTimeoutsMO = new Object();
-  
-  //Monitor object for queueAcls
-  private Object queueAclsMO = new Object();
-  
-  //Monitor object for userMaxAppsDefault
-  private Object userMaxAppsDefaultMO = new Object();
-  
-  //Monitor object for queueMaxAppsDefault
-  private Object queueMaxAppsDefaultMO = new Object();
-  
-  //Monitor object for defaultSchedulingMode
-  private Object defaultSchedulingModeMO = new Object();
-  
-        synchronized (defaultSchedulingModeMO){
-          queue.setSchedulingMode(defaultSchedulingMode);
-        }
+        queue.setSchedulingMode(info.defaultSchedulingMode);
+    long fairSharePreemptionTimeout = Long.MAX_VALUE;
+    long defaultMinSharePreemptionTimeout = Long.MAX_VALUE;
-      setMinResources(minQueueResources);
-      setMaxResources(maxQueueResources);
-      setQueueMaxApps(queueMaxApps);
-      setUserMaxApps(userMaxApps);
-      setQueueWeights(queueWeights);
-      setUserMaxAppsDefault(userMaxAppsDefault);
-      setQueueMaxAppsDefault(queueMaxAppsDefault);
-      setDefaultSchedulingMode(defaultSchedulingMode);
-      setMinSharePreemptionTimeouts(minSharePreemptionTimeouts);
-      setQueueAcls(queueAcls);
+      info = new QueueManagerInfo(minQueueResources, maxQueueResources,
+          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,
+          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,
+          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);
-    synchronized(minQueueResourcesMO) {
-      if (minQueueResources.containsKey(queue)) {
-        return minQueueResources.get(queue);
-      } else {
-        return Resources.createResource(0);
-      }
+    Resource minQueueResource = info.minQueueResources.get(queue);
+    if (minQueueResource != null) {
+      return minQueueResource;
+    } else {
+      return Resources.createResource(0);
-  private void setMinResources(Map<String, Resource> resources) {
-    synchronized (minQueueResourcesMO) {
-      minQueueResources = resources;
-    }
-  }
+
-    synchronized (maxQueueResourcesMO) {
-      if (maxQueueResources.containsKey(queueName)) {
-        return maxQueueResources.get(queueName);
-      } else {
-        return Resources.createResource(Integer.MAX_VALUE);
-      }
+    Resource maxQueueResource = info.maxQueueResources.get(queueName);
+    if (maxQueueResource != null) {
+      return maxQueueResource;
+    } else {
+      return Resources.createResource(Integer.MAX_VALUE);
-  private void setMaxResources(Map<String, Resource> resources) {
-    synchronized (maxQueueResourcesMO) {
-      maxQueueResources = resources;
-    }
-  }
-  
-  /**
-   * Add an app in the appropriate queue
-   */
-  public synchronized void addApp(FSSchedulerApp app) {
-    getQueue(app.getQueueName()).addApp(app);
-  }
-
-  /**
-   * Remove an app
-   */
-  public synchronized void removeApp(FSSchedulerApp app) {
-    getQueue(app.getQueueName()).removeApp(app);
-  }
-
-      return queues.values();
+      return new ArrayList<FSQueue>(queues.values());
-  /**
-   * Get all queue names that have been seen either in the allocation file or in
-   * a submitted app.
-   */
-  public synchronized Collection<String> getQueueNames() {
-    List<String> list = new ArrayList<String>();
-    for (FSQueue queue: getQueues()) {
-      list.add(queue.getName());
-    }
-    Collections.sort(list);
-    return list;
-  }
-
-    synchronized (userMaxAppsMO) {
-      if (userMaxApps.containsKey(user)) {
-        return userMaxApps.get(user);
-      } else {
-        return getUserMaxAppsDefault();
-      }
+    // save current info in case it gets changed under us
+    QueueManagerInfo info = this.info;
+    if (info.userMaxApps.containsKey(user)) {
+      return info.userMaxApps.get(user);
+    } else {
+      return info.userMaxAppsDefault;
-  private void setUserMaxApps(Map<String, Integer> userApps) {
-    synchronized (userMaxAppsMO) {
-      userMaxApps = userApps;
-    }
-  }
-  
-  private int getUserMaxAppsDefault() {
-    synchronized (userMaxAppsDefaultMO){
-      return userMaxAppsDefault;
-    }
-  }
-  
-  private void setUserMaxAppsDefault(int userMaxApps) {
-    synchronized (userMaxAppsDefaultMO){
-      userMaxAppsDefault = userMaxApps;
-    }
-  }
-  
-    synchronized (queueMaxAppsMO) {
-      if (queueMaxApps.containsKey(queue)) {
-        return queueMaxApps.get(queue);
-      } else {
-        return getQueueMaxAppsDefault();
-      }
+    // save current info in case it gets changed under us
+    QueueManagerInfo info = this.info;
+    if (info.queueMaxApps.containsKey(queue)) {
+      return info.queueMaxApps.get(queue);
+    } else {
+      return info.queueMaxAppsDefault;
-  private void setQueueMaxApps(Map<String, Integer> queueApps) {
-    synchronized (queueMaxAppsMO) {
-      queueMaxApps = queueApps;
-    }
-  }
-  
-  private int getQueueMaxAppsDefault(){
-    synchronized (queueMaxAppsDefaultMO) {
-      return queueMaxAppsDefault;
-    }
-  }
-  
-  private void setQueueMaxAppsDefault(int queueMaxApps){
-    synchronized(queueMaxAppsDefaultMO) {
-      queueMaxAppsDefault = queueMaxApps;
-    }
-  }
-  
-  private void setDefaultSchedulingMode(SchedulingMode schedulingMode){
-    synchronized(defaultSchedulingModeMO) {
-      defaultSchedulingMode = schedulingMode;
-    }
-  }
-
-    synchronized (queueWeightsMO) {
-      if (queueWeights.containsKey(queue)) {
-        return queueWeights.get(queue);
-      } else {
-        return 1.0;
-      }
+    Double weight = info.queueWeights.get(queue);
+    if (weight != null) {
+      return weight;
+    } else {
+      return 1.0;
-  private void setQueueWeights(Map<String, Double> weights) {
-    synchronized (queueWeightsMO) {
-      queueWeights = weights;
-    }
-  }
-  
-    synchronized (minSharePreemptionTimeoutsMO) {
-      if (minSharePreemptionTimeouts.containsKey(queueName)) {
-        return minSharePreemptionTimeouts.get(queueName);
-      }
+    // save current info in case it gets changed under us
+    QueueManagerInfo info = this.info;
+    if (info.minSharePreemptionTimeouts.containsKey(queueName)) {
+      return info.minSharePreemptionTimeouts.get(queueName);
-    return defaultMinSharePreemptionTimeout;
+    return info.defaultMinSharePreemptionTimeout;
-  private void setMinSharePreemptionTimeouts(
-      Map<String, Long> sharePreemptionTimeouts){
-    synchronized (minSharePreemptionTimeoutsMO) {
-      minSharePreemptionTimeouts = sharePreemptionTimeouts;
-    }
-  }
-
-    return fairSharePreemptionTimeout;
+    return info.fairSharePreemptionTimeout;
-    synchronized (queueAclsMO) {
-      if (queueAcls.containsKey(queue)) {
-        out.putAll(queueAcls.get(queue));
-      }
+    Map<QueueACL, AccessControlList> queueAcl = info.queueAcls.get(queue);
+    if (queueAcl != null) {
+      out.putAll(queueAcl);
-  private void setQueueAcls(Map<String, Map<QueueACL, AccessControlList>> queue) {
-    synchronized (queueAclsMO) {
-      queueAcls = queue;
+  static class QueueManagerInfo {
+    // Minimum resource allocation for each queue
+    public final Map<String, Resource> minQueueResources;
+    // Maximum amount of resources per queue
+    public final Map<String, Resource> maxQueueResources;
+    // Sharing weights for each queue
+    public final Map<String, Double> queueWeights;
+    
+    // Max concurrent running applications for each queue and for each user; in addition,
+    // for users that have no max specified, we use the userMaxJobsDefault.
+    public final Map<String, Integer> queueMaxApps;
+    public final Map<String, Integer> userMaxApps;
+    public final int userMaxAppsDefault;
+    public final int queueMaxAppsDefault;
+
+    // ACL's for each queue. Only specifies non-default ACL's from configuration.
+    public final Map<String, Map<QueueACL, AccessControlList>> queueAcls;
+
+    // Min share preemption timeout for each queue in seconds. If a job in the queue
+    // waits this long without receiving its guaranteed share, it is allowed to
+    // preempt other jobs' tasks.
+    public final Map<String, Long> minSharePreemptionTimeouts;
+
+    // Default min share preemption timeout for queues where it is not set
+    // explicitly.
+    public final long defaultMinSharePreemptionTimeout;
+
+    // Preemption timeout for jobs below fair share in seconds. If a job remains
+    // below half its fair share for this long, it is allowed to preempt tasks.
+    public final long fairSharePreemptionTimeout;
+
+    public final SchedulingMode defaultSchedulingMode;
+    
+    public QueueManagerInfo(Map<String, Resource> minQueueResources, 
+        Map<String, Resource> maxQueueResources, 
+        Map<String, Integer> queueMaxApps, Map<String, Integer> userMaxApps,
+        Map<String, Double> queueWeights, int userMaxAppsDefault,
+        int queueMaxAppsDefault, SchedulingMode defaultSchedulingMode, 
+        Map<String, Long> minSharePreemptionTimeouts, 
+        Map<String, Map<QueueACL, AccessControlList>> queueAcls,
+        long fairSharePreemptionTimeout, long defaultMinSharePreemptionTimeout) {
+      this.minQueueResources = minQueueResources;
+      this.maxQueueResources = maxQueueResources;
+      this.queueMaxApps = queueMaxApps;
+      this.userMaxApps = userMaxApps;
+      this.queueWeights = queueWeights;
+      this.userMaxAppsDefault = userMaxAppsDefault;
+      this.queueMaxAppsDefault = queueMaxAppsDefault;
+      this.defaultSchedulingMode = defaultSchedulingMode;
+      this.minSharePreemptionTimeouts = minSharePreemptionTimeouts;
+      this.queueAcls = queueAcls;
+      this.fairSharePreemptionTimeout = fairSharePreemptionTimeout;
+      this.defaultMinSharePreemptionTimeout = defaultMinSharePreemptionTimeout;
+    }
+    
+    public QueueManagerInfo() {
+      minQueueResources = new HashMap<String, Resource>();
+      maxQueueResources = new HashMap<String, Resource>();
+      queueWeights = new HashMap<String, Double>();
+      queueMaxApps = new HashMap<String, Integer>();
+      userMaxApps = new HashMap<String, Integer>();
+      userMaxAppsDefault = Integer.MAX_VALUE;
+      queueMaxAppsDefault = Integer.MAX_VALUE;
+      queueAcls = new HashMap<String, Map<QueueACL, AccessControlList>>();
+      minSharePreemptionTimeouts = new HashMap<String, Long>();
+      defaultMinSharePreemptionTimeout = Long.MAX_VALUE;
+      fairSharePreemptionTimeout = Long.MAX_VALUE;
+      defaultSchedulingMode = SchedulingMode.FAIR;

MOV31 INS23 INS31 INS55 MOV83 UPD83 MOV83 UPD43 MOV43 MOV59 INS83 INS39 INS42 MOV44 INS8 UPD39 UPD42 MOV44 INS8 UPD39 UPD42 MOV44 INS8 MOV29 INS39 UPD42 MOV44 MOV29 UPD39 INS42 INS8 INS83 INS42 MOV23 MOV23 MOV23 MOV23 MOV23 INS23 INS23 MOV23 MOV23 INS23 INS23 INS23 INS31 INS31 UPD42 UPD42 INS60 INS60 INS60 INS25 INS60 INS25 INS60 INS25 INS60 INS25 INS60 INS25 INS25 MOV41 INS60 INS25 UPD83 INS83 UPD83 INS83 UPD83 INS83 UPD83 INS83 UPD83 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 UPD83 INS83 UPD83 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 MOV43 INS59 MOV83 INS42 MOV44 MOV44 MOV44 MOV44 MOV44 INS44 INS44 MOV44 MOV44 MOV44 INS44 INS44 INS8 MOV83 UPD42 MOV42 INS8 UPD43 INS39 MOV59 INS39 MOV59 INS43 INS59 INS27 MOV8 MOV8 INS43 INS59 INS27 MOV8 MOV8 INS43 INS59 INS32 INS8 INS8 INS43 INS59 INS32 INS8 INS8 INS43 INS59 INS27 INS8 MOV8 INS43 INS32 INS8 INS40 INS40 INS74 INS59 INS27 MOV8 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS39 INS42 INS39 INS42 UPD42 UPD42 UPD42 INS39 INS42 INS39 INS42 INS21 INS21 INS21 MOV21 INS21 INS21 MOV21 MOV21 INS21 INS21 INS21 MOV21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 MOV21 INS21 INS21 MOV21 UPD42 INS21 INS42 INS42 INS32 INS42 INS33 INS42 INS42 INS32 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS22 INS40 INS42 INS42 INS41 INS41 UPD42 MOV42 INS42 INS22 INS40 UPD42 MOV42 UPD42 MOV42 INS41 INS41 UPD42 MOV42 INS42 INS32 INS42 INS33 INS41 UPD42 MOV42 UPD42 INS22 INS40 INS42 INS42 INS41 INS43 INS43 INS43 INS42 INS32 INS42 INS33 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS40 UPD42 MOV42 MOV42 INS42 INS40 UPD42 MOV42 MOV42 INS42 INS14 INS52 INS42 INS32 INS40 INS52 INS42 INS32 INS40 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS52 INS42 INS32 INS42 INS42 INS42 INS40 UPD42 MOV42 MOV42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 UPD42 INS22 INS42 INS22 INS42 INS22 UPD42 INS22 UPD42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 UPD42 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 INS40 INS42 INS40 INS42 MOV14 MOV14 INS42 INS40 INS42 INS40 UPD42 INS40 MOV21 INS42 INS14 INS74 MOV32 INS40 INS42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 MOV43 INS40 INS42 DEL40 DEL26 DEL39 DEL42 DEL40 DEL59 DEL23 DEL39 DEL42 DEL40 DEL59 DEL23 DEL83 DEL39 DEL23 DEL83 DEL39 DEL23 DEL42 DEL40 DEL59 DEL23 DEL83 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL42 DEL42 DEL8 DEL51 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL25 DEL8 DEL51 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL25 DEL8 DEL51 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL44 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL44 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL8 DEL25 DEL8 DEL51 DEL8 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL41 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL41 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL51 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL25 DEL8 DEL51 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL83 DEL39 DEL42 DEL42 DEL8 DEL51 DEL8 DEL31
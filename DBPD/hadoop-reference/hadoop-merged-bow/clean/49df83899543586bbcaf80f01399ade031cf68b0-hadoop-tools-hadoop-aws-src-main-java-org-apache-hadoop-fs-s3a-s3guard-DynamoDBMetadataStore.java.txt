HADOOP-16697. Tune/audit S3A authoritative mode.

Contains:

HADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination
              dirirectory as authoritative on success.
HADOOP-16684. S3guard bucket info to list a bit more about
              authoritative paths.
HADOOP-16722. S3GuardTool to support FilterFileSystem.

This patch improves the marking of newly created/import directory
trees in S3Guard DynamoDB tables as authoritative.

Specific changes:

 * Renamed directories are marked as authoritative if the entire
   operation succeeded (HADOOP-16474).
 * When updating parent table entries as part of any table write,
   there's no overwriting of their authoritative flag.

s3guard import changes:

* new -verbose flag to print out what is going on.

* The "s3guard import" command lets you declare that a directory tree
is to be marked as authoritative

  hadoop s3guard import -authoritative -verbose s3a://bucket/path

When importing a listing and a file is found, the import tool queries
the metastore and only updates the entry if the file is different from
before, where different == new timestamp, etag, or length. S3Guard can get
timestamp differences due to clock skew in PUT operations.

As the recursive list performed by the import command doesn't retrieve the
versionID, the existing entry may in fact be more complete.
When updating an existing due to clock skew the existing version ID
is propagated to the new entry (note: the etags must match; this is needed
to deal with inconsistent listings).

There is a new s3guard command to audit a s3guard bucket/path's
authoritative state:

  hadoop s3guard authoritative -check-config s3a://bucket/path

This is primarily for testing/auditing.

The s3guard bucket-info command also provides some more details on the
authoritative state of a store (HADOOP-16684).

Change-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91

+import com.amazonaws.services.dynamodbv2.document.internal.IteratorSupport;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.hadoop.fs.impl.FunctionsRaisingIOE;
-import org.apache.hadoop.fs.s3a.S3AInstrumentation;
+import static org.apache.hadoop.fs.s3a.s3guard.PathOrderComparators.TOPMOST_PM_LAST;
-  private S3AInstrumentation.S3GuardInstrumentation instrumentation;
+  /**
+   * The instrumentation is never null -if/when bound to an owner file system
+   * That filesystem statistics will be updated as appropriate.
+   */
+  private MetastoreInstrumentation instrumentation
+      = new MetastoreInstrumentationImpl();
-        "DynamoDBMetadataStore only supports S3A filesystem.");
+        "DynamoDBMetadataStore only supports S3A filesystem - not %s",
+        fs);
-    if (wantEmptyDirectoryFlag && meta != null) {
+    if (wantEmptyDirectoryFlag && meta != null && !meta.isDeleted()) {
-      // for directory, we query its direct children to determine isEmpty bit
+      // for a non-deleted directory, we query its direct undeleted children
+      // to determine the isEmpty bit. There's no TTL checking going on here.
-            () -> table.query(spec).iterator().hasNext());
+            () -> {
+              // issue the query
+              final IteratorSupport<Item, QueryOutcome> it = table.query(
+                  spec).iterator();
+              // if non empty, log the result to aid with some debugging
+              if (it.hasNext()) {
+                if (LOG.isDebugEnabled()) {
+                  LOG.debug("Dir {} is non-empty", status.getPath());
+                  while(it.hasNext()) {
+                    LOG.debug("{}", itemToPathMetadata(it.next(), username));
+                  }
+                }
+                return true;
+              } else {
+                return false;
+              }
+          });
-        if(meta.isAuthoritativeDir()) {
+        if (meta.isAuthoritativeDir()) {
+   * Origin of entries in the ancestor map built up in
+   * {@link #completeAncestry(Collection, AncestorState)}.
+   * This is done to stop generated ancestor entries to overwriting those
+   * in the store, while allowing those requested in the API call to do this.
+   */
+  private enum EntryOrigin {
+    Requested,  // requested in method call
+    Retrieved,  // retrieved from DDB: do not resubmit
+    Generated   // generated ancestor.
+  }
+
+  /**
-      final AncestorState ancestorState) throws PathIOException {
+      final AncestorState ancestorState) throws IOException {
-    Map<Path, DDBPathMetadata> ancestry = new HashMap<>();
+    Map<Path, Pair<EntryOrigin, DDBPathMetadata>> ancestry = new HashMap<>();
-      ancestry.put(path, entry);
+      // add the entry to the ancestry map as an explicitly requested entry.
+      ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));
-          // don't add this entry, but carry on with the parents
-          LOG.debug("auto-create ancestor path {} for child path {}",
-              parent, path);
-          final S3AFileStatus status = makeDirStatus(parent, username);
-          DDBPathMetadata md = new DDBPathMetadata(status, Tristate.FALSE,
-              false, false, ttlTimeProvider.getNow());
+          // there is no entry in the ancestor state.
+          // look in the store
+          DDBPathMetadata md;
+          Pair<EntryOrigin, DDBPathMetadata> newEntry;
+          final Item item = getConsistentItem(parent);
+          if (item != null && !itemToPathMetadata(item, username).isDeleted()) {
+            // This is an undeleted entry found in the database.
+            // register it in ancestor state and in the map of entries to create
+            // as a retrieved entry
+            md = itemToPathMetadata(item, username);
+            LOG.debug("Found existing entry for parent: {}", md);
+            newEntry = Pair.of(EntryOrigin.Retrieved, md);
+          } else {
+            // A directory entry was not found in the DB. Create one.
+            LOG.debug("auto-create ancestor path {} for child path {}",
+                parent, path);
+            final S3AFileStatus status = makeDirStatus(parent, username);
+            md = new DDBPathMetadata(status, Tristate.FALSE,
+                false, false, ttlTimeProvider.getNow());
+            // declare to be a generated entry
+            newEntry =  Pair.of(EntryOrigin.Generated, md);
+          }
+          // insert into the ancestor state to avoid further checks
-          ancestry.put(parent, md);
+          ancestry.put(parent, newEntry);
-    return ancestry.values();
+    // we now have a list of entries which were not in the operation state.
+    // Filter out those which were retrieved, to produce a list of those
+    // which must be written to the database.
+    // TODO sort in reverse order of existence
+    return ancestry.values().stream()
+        .filter(p -> p.getLeft() != EntryOrigin.Retrieved)
+        .map(Pair::getRight)
+        .collect(Collectors.toList());
-        BulkOperationState.OperationType.Rename);
+        BulkOperationState.OperationType.Put);
-      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);
+      tombstones.sort(TOPMOST_PM_LAST);
+  /**
+   * Get the value of an optional boolean attribute, falling back to the
+   * default value if the attribute is absent.
+   * @param item Item
+   * @param attrName Attribute name
+   * @param defVal Default value
+   * @return The value or the default
+   */
+  private static boolean getBoolAttribute(Item item,
+      String attrName,
+      boolean defVal) {
+    return item.hasAttribute(attrName) ? item.getBoolean(attrName) : defVal;
+  }
+
-        tableName,
-    if (instrumentation != null) {
-      instrumentation.storeClosed();
-    }
+    instrumentation.storeClosed();
+      // filter all files under the given parent older than the modtime.
+      // this implicitly skips directories, because they lack a modtime field.
+      // however we explicitly exclude directories to make clear that
+      // directories are to be excluded and avoid any confusion
+      // see: HADOOP-16725.
+      // note: files lack the is_dir field entirely, so we use a `not` to
+      // filter out the directories.
-          "mod_time < :mod_time and begins_with(parent, :parent)";
+          "mod_time < :mod_time and begins_with(parent, :parent)"
+              + " and not is_dir = :is_dir";
-          .withString(":parent", keyPrefix);
+          .withString(":parent", keyPrefix)
+          .withBoolean(":is_dir", true);
-      projectionExpression = "parent,child";
+      projectionExpression = "parent,child,is_deleted";
-   * Prune files, in batches. There's a sleep between each batch.
+   * Prune files, in batches. There's optionally a sleep between each batch.
+   * @return count of pruned items.
-  public void prune(PruneMode pruneMode, long cutoff, String keyPrefix)
+  public long prune(PruneMode pruneMode, long cutoff, String keyPrefix)
-    innerPrune(keyPrefix, items);
+    return innerPrune(pruneMode, cutoff, keyPrefix, items);
-  private void innerPrune(String keyPrefix, ItemCollection<ScanOutcome> items)
+  /**
+   * Prune files, in batches. There's optionally a sleep between each batch.
+   *
+   * @param pruneMode The mode of operation for the prune For details see
+   *                  {@link MetadataStore#prune(PruneMode, long)}
+   * @param cutoff Oldest modification time to allow
+   * @param keyPrefix The prefix for the keys that should be removed
+   * @param items expired items
+   * @return count of pruned items.
+   * @throws IOException Any IO/DDB failure.
+   * @throws InterruptedIOException if the prune was interrupted
+   */
+  private int innerPrune(
+      final PruneMode pruneMode, final long cutoff, final String keyPrefix,
+      final ItemCollection<ScanOutcome> items)
+      // declare the operation to delete a batch as a function so
+      // as to keep the code consistent across multiple uses.
+      FunctionsRaisingIOE.CallableRaisingIOE<Void> deleteBatchOperation =
+          () -> {
+            // lowest path entries get deleted first.
+            deletionBatch.sort(PathOrderComparators.TOPMOST_PATH_LAST);
+            processBatchWriteRequest(state, pathToKey(deletionBatch), null);
+
+            // set authoritative false for each pruned dir listing
+            // if at least one entry was not a tombstone
+            removeAuthoritativeDirFlag(parentPathSet, state);
+            // already cleared parent paths.
+            clearedParentPathSet.addAll(parentPathSet);
+            parentPathSet.clear();
+            return null;
+          };
+            && !parentPath.isRoot()
-          // lowest path entries get deleted first.
-          deletionBatch.sort(PathOrderComparators.TOPMOST_PATH_LAST);
-          processBatchWriteRequest(state, pathToKey(deletionBatch), null);
-
-          // set authoritative false for each pruned dir listing
-          removeAuthoritativeDirFlag(parentPathSet, state);
-          // already cleared parent paths.
-          clearedParentPathSet.addAll(parentPathSet);
-          parentPathSet.clear();
-
+          deleteBatchOperation.apply();
-        processBatchWriteRequest(state, pathToKey(deletionBatch), null);
-
-        // set authoritative false for each pruned dir listing
-        removeAuthoritativeDirFlag(parentPathSet, state);
-        parentPathSet.clear();
+        deleteBatchOperation.apply();
+    return itemCount;
+        if (path.isRoot()) {
+          LOG.debug("ignoring root path");
+          return null;
+        }
+        ddbPathMetadata.setLastUpdated(ttlTimeProvider.getNow());
-      if (instrumentation != null) {
-        instrumentation.throttled();
-      }
+      instrumentation.throttled();
-    if (instrumentation != null) {
-      // note a retry
-      instrumentation.retrying();
-    }
+    // note a retry
+    instrumentation.retrying();
-    if (instrumentation != null) {
-      instrumentation.recordsWritten(count);
-    }
+    instrumentation.recordsWritten(count);
-    if (instrumentation != null) {
-      instrumentation.recordsRead(count);
-    }
+    instrumentation.recordsRead(count);
-    if (instrumentation != null) {
-      instrumentation.recordsDeleted(count);
-    }
+    instrumentation.recordsDeleted(count);
+  /**
+   * Mark the directories instantiated under the destination path
+   * as authoritative. That is: all entries in the
+   * operationState (which must be an AncestorState instance),
+   * that are under the destination path.
+   *
+   * The database update synchronized on the operationState, so all other
+   * threads trying to update that state will be blocked until completion.
+   *
+   * This operation is only used in import and at the end of a rename,
+   * so this is not considered an issue.
+   * @param dest destination path.
+   * @param operationState active state.
+   * @throws IOException failure.
+   * @return the number of directories marked.
+   */
+  @Override
+  public int markAsAuthoritative(
+      final Path dest,
+      final BulkOperationState operationState) throws IOException {
+    if (operationState == null) {
+      return 0;
+    }
+    Preconditions.checkArgument(operationState instanceof AncestorState,
+        "Not an AncestorState %s", operationState);
+    final AncestorState state = (AncestorState)operationState;
+    // only mark paths under the dest as auth
+    final String simpleDestKey = pathToParentKey(dest);
+    final String destPathKey = simpleDestKey + "/";
+    final String opId = AncestorState.stateAsString(state);
+    LOG.debug("{}: marking directories under {} as authoritative",
+        opId, destPathKey);
+
+    // the list of dirs to build up.
+    final List<DDBPathMetadata> dirsToUpdate = new ArrayList<>();
+    synchronized (state) {
+      for (Map.Entry<Path, DDBPathMetadata> entry :
+          state.getAncestry().entrySet()) {
+        final Path path = entry.getKey();
+        final DDBPathMetadata md = entry.getValue();
+        final String key = pathToParentKey(path);
+        if (md.getFileStatus().isDirectory()
+            && (key.equals(simpleDestKey) || key.startsWith(destPathKey))) {
+          // the updated entry is under the destination.
+          md.setAuthoritativeDir(true);
+          md.setLastUpdated(ttlTimeProvider.getNow());
+          LOG.debug("{}: added {}", opId, key);
+          dirsToUpdate.add(md);
+        }
+      }
+      processBatchWriteRequest(state,
+          null, pathMetadataToItem(dirsToUpdate));
+    }
+    return dirsToUpdate.size();
+  }
+
-        OPERATIONS_LOG.debug("{} {} {}",
+        boolean isDir = getBoolAttribute(item, IS_DIR, false);
+        boolean auth = getBoolAttribute(item, IS_AUTHORITATIVE, false);
+        OPERATIONS_LOG.debug("{} {} {}{}{}",
-            itemPrimaryKeyToString(item));
+            itemPrimaryKeyToString(item),
+            auth ? " [auth]" : "",
+            isDir ? " directory" : "");
+  @Override
+  public MetastoreInstrumentation getInstrumentation() {
+    return instrumentation;
+  }
+
+   *
+   * There is no thread safety: callers must synchronize as appropriate.
+    /**
+     * Get the ancestry. Not thread safe.
+     * @return the map of ancestors.
+     */
+    Map<Path, DDBPathMetadata> getAncestry() {
+      return ancestry;
+    }
+

MOV26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS71 INS31 INS31 INS31 INS29 UPD43 INS29 INS83 INS42 INS72 INS72 INS72 UPD43 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 UPD39 INS29 UPD39 INS44 INS44 MOV8 MOV8 MOV8 INS29 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS43 INS42 INS8 INS31 INS65 INS42 INS14 INS65 INS42 INS42 INS42 UPD42 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS41 MOV21 INS65 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS83 INS41 MOV21 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS42 INS25 INS21 INS60 INS60 INS60 INS60 INS21 INS60 INS51 INS41 INS42 INS42 INS41 INS29 MOV74 INS42 INS8 INS66 INS66 INS43 INS27 INS66 INS65 INS66 INS66 INS66 INS74 INS32 INS43 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS16 MOV42 UPD66 INS66 INS32 INS66 INS42 INS66 INS65 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS32 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS32 INS83 INS74 INS59 INS42 INS8 INS32 INS42 INS66 INS65 INS65 INS41 INS42 UPD45 INS42 MOV27 INS38 INS68 INS43 INS43 INS74 INS32 INS42 INS32 INS42 INS32 INS32 INS42 MOV42 INS42 INS42 MOV42 MOV42 INS68 INS60 INS25 MOV21 INS42 INS33 INS41 INS42 INS42 INS62 INS45 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS43 INS43 INS42 INS14 INS70 INS21 INS42 INS42 INS66 INS66 INS42 INS32 INS42 INS69 INS69 INS42 INS42 INS43 INS43 INS43 INS32 INS42 INS90 INS42 INS42 UPD40 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 UPD45 INS42 INS42 INS69 INS69 INS74 INS59 MOV38 INS8 INS34 INS42 MOV43 INS43 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS74 INS44 INS32 INS8 INS32 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS32 INS32 INS42 INS86 INS42 INS42 INS42 INS45 INS45 MOV32 INS42 INS45 INS9 INS43 INS39 INS43 INS43 INS42 INS86 MOV21 INS42 INS43 INS74 INS42 INS32 INS42 INS60 INS60 INS60 INS25 INS42 INS42 INS33 INS32 INS60 INS60 INS59 INS42 INS42 INS42 INS42 INS40 MOV42 INS8 MOV32 INS42 INS59 INS27 INS42 INS40 INS42 MOV8 INS8 INS42 INS43 INS43 INS43 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS27 INS8 INS42 INS42 INS39 INS59 INS39 INS59 INS42 INS32 INS60 INS60 INS60 INS25 MOV21 INS21 INS42 INS32 INS40 INS41 INS27 INS21 MOV21 MOV25 UPD42 UPD42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS36 INS21 INS21 INS21 INS21 INS42 INS32 INS42 INS32 UPD45 INS16 INS16 INS42 INS42 INS45 MOV32 INS9 INS86 MOV43 INS59 INS74 INS59 INS83 INS43 INS59 INS27 INS8 MOV8 INS32 INS42 INS42 INS33 MOV27 INS38 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS45 INS45 INS42 INS45 INS45 INS8 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS32 INS27 INS38 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS32 INS7 INS32 INS7 INS7 INS7 INS42 INS42 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS83 INS74 MOV59 INS32 INS8 INS8 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS32 INS42 MOV14 INS42 INS32 INS32 INS8 INS32 INS43 INS43 INS43 INS42 MOV32 INS42 INS42 INS25 INS41 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 UPD42 MOV42 UPD42 MOV42 INS40 MOV42 INS42 INS42 INS21 INS41 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS8 INS9 INS9 INS32 INS33 INS42 INS42 INS42 INS42 INS21 INS61 INS42 INS42 INS45 INS32 INS32 INS8 INS42 INS42 INS45 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS42 DEL40 DEL42 DEL42 DEL42 DEL45 DEL9 DEL42 DEL32 DEL86 DEL32 DEL42 DEL59 DEL60 DEL42 DEL32 DEL40 DEL42 DEL42 DEL33 DEL27 DEL8 DEL25 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL33 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL25 DEL8 DEL42 DEL33 DEL27 DEL25 DEL8 DEL42 DEL33 DEL27 DEL25 DEL8
HDFS-4434. Provide a mapping from INodeId to INode. Contributed by Suresh Srinivas.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469644 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import org.apache.hadoop.HadoopIllegalArgumentException;
+import org.apache.hadoop.hdfs.DFSUtil;
+import org.apache.hadoop.hdfs.util.GSet;
+import org.apache.hadoop.hdfs.util.LightWeightGSet;
-    return new INodeDirectoryWithQuota(namesystem.allocateNewInodeId(),
+    return new INodeDirectoryWithQuota(INodeId.ROOT_INODE_ID,
+  @VisibleForTesting
+  static boolean CHECK_RESERVED_FILE_NAMES = true;
+  public final static String DOT_RESERVED_STRING = ".reserved";
+  public final static String DOT_RESERVED_PATH_PREFIX = Path.SEPARATOR
+      + DOT_RESERVED_STRING;
+  public final static byte[] DOT_RESERVED = 
+      DFSUtil.string2Bytes(DOT_RESERVED_STRING);
+  public final static String DOT_INODES_STRING = ".inodes";
+  public final static byte[] DOT_INODES = 
+      DFSUtil.string2Bytes(DOT_INODES_STRING);
+  private GSet<INode, INode> inodeMap; // Synchronized by dirLock
+    inodeMap = initInodeMap(rootDir);
+  
+  @VisibleForTesting
+  static LightWeightGSet<INode, INode> initInodeMap(INodeDirectory rootDir) {
+    // Compute the map capacity by allocating 1% of total memory
+    int capacity = LightWeightGSet.computeCapacity(1, "INodeMap");
+    LightWeightGSet<INode, INode> map = new LightWeightGSet<INode, INode>(
+        capacity);
+    map.put(rootDir);
+    return map;
+  }
-    long id = namesystem.allocateNewInodeId();
-                                 id,
+                                 namesystem.allocateNewInodeId(),
+    remvoedAllFromInodesFromMap(targetNode);
-
+  
+    removeFromInodeMap(oldnode);
+    inodeMap.put(newnode);
-  INode unprotectedMkdir(long inodeId, String src, PermissionStatus permissions,
-                          long timestamp) throws QuotaExceededException,
-                          UnresolvedLinkException {
+  INode unprotectedMkdir(long inodeId, String src,
+      PermissionStatus permissions, long timestamp)
+      throws QuotaExceededException, UnresolvedLinkException {
+  private INode getFromINodeMap(INode inode) {
+    readLock();
+    try {
+      return inodeMap.get(inode);
+    } finally {
+      readUnlock();
+    }
+  }
+  
-  private boolean addINode(String src, INode child
-      ) throws QuotaExceededException, UnresolvedLinkException {
+  private boolean addINode(String src, INode child)
+      throws QuotaExceededException, UnresolvedLinkException {
+    // Disallow creation of /.reserved. This may be created when loading
+    // editlog/fsimage during upgrade since /.reserved was a valid name in older
+    // release. This may also be called when a user tries to create a file
+    // or directory /.reserved.
+    if (pos == 1 && inodes[0] == rootDir && isReservedName(child)) {
+      throw new HadoopIllegalArgumentException(
+          "File name \"" + child.getLocalName() + "\" is reserved and cannot "
+              + "be created. If this is during upgrade change the name of the "
+              + "existing file or directory to another name before upgrading "
+              + "to the new release.");
+    }
+    
+    } else {
+      inodeMap.put(child);
+      removeFromInodeMap(removedNode);
+  /** This method is always called with writeLock held */
+  final void addToInodeMapUnprotected(INode inode) {
+    inodeMap.put(inode);
+  }
+  
+  /* This method is always called with writeLock held */
+  private final void removeFromInodeMap(INode inode) {
+    inodeMap.remove(inode);
+  }
+  
+  /** Remove all the inodes under given inode from the map */
+  private void remvoedAllFromInodesFromMap(INode inode) {
+    removeFromInodeMap(inode);
+    if (!inode.isDirectory()) {
+      return;
+    }
+    INodeDirectory dir = (INodeDirectory) inode;
+    for (INode child : dir.getChildrenList()) {
+      remvoedAllFromInodesFromMap(child);
+    }
+    dir.clearChildren();
+  }
+
+  
-    updateCountForINodeWithQuota(rootDir, new INode.DirCounts(), 
+    updateCountForINodeWithQuota(this, rootDir, new INode.DirCounts(), 
-  private static void updateCountForINodeWithQuota(INodeDirectory dir, 
-                                               INode.DirCounts counts,
-                                               ArrayList<INode> nodesInPath) {
+  private static void updateCountForINodeWithQuota(FSDirectory fsd,
+      INodeDirectory dir, INode.DirCounts counts, ArrayList<INode> nodesInPath) {
+      fsd.inodeMap.put(child);
-        updateCountForINodeWithQuota((INodeDirectory)child, 
+        updateCountForINodeWithQuota(fsd, (INodeDirectory)child, 
-      status = unprotectedSetTimes(src, inode, mtime, atime, force);
+      status = unprotectedSetTimes(inode, mtime, atime, force);
-    return unprotectedSetTimes(src, inode, mtime, atime, force);
+    return unprotectedSetTimes(inode, mtime, atime, force);
-  private boolean unprotectedSetTimes(String src, INode inode, long mtime,
+  private boolean unprotectedSetTimes(INode inode, long mtime,
-      throws UnresolvedLinkException, FileAlreadyExistsException,
-      QuotaExceededException {
+      throws UnresolvedLinkException,
+      FileAlreadyExistsException, QuotaExceededException {
-      throws UnresolvedLinkException, QuotaExceededException {
+      throws UnresolvedLinkException,
+      QuotaExceededException {
+    inodeMap.clear();
+    inodeMap = null;
+  }
+  
+  @VisibleForTesting
+  INode getInode(long id) {
+    INode inode = new INode(id, new PermissionStatus("", "", new FsPermission(
+        (short) 0)), 0, 0) {
+      @Override
+      int collectSubtreeBlocksAndClear(BlocksMapUpdateInfo info) {
+        return 0;
+      }
+
+      @Override
+      long[] computeContentSummary(long[] summary) {
+        return null;
+      }
+
+      @Override
+      DirCounts spaceConsumedInTree(DirCounts counts) {
+        return null;
+      }
+    };
+    return getFromINodeMap(inode);
+  }
+  
+  /**
+   * Given an INode get all the path complents leading to it from the root.
+   * If an Inode corresponding to C is given in /A/B/C, the returned
+   * patch components will be {root, A, B, C}
+   */
+  static byte[][] getPathComponents(INode inode) {
+    List<byte[]> components = new ArrayList<byte[]>();
+    components.add(0, inode.getLocalNameBytes());
+    while(inode.getParent() != null) {
+      components.add(0, inode.getParent().getLocalNameBytes());
+      inode = inode.getParent();
+    }
+    return components.toArray(new byte[components.size()][]);
+  }
+  
+  /**
+   * @return path components for reserved path, else null.
+   */
+  static byte[][] getPathComponentsForReservedPath(String src) {
+    return !isReservedName(src) ? null : INode.getPathComponents(src);
+  }
+  
+  /**
+   * Resolve the path of /.reserved/.inodes/<inodeid>/... to a regular path
+   * 
+   * @param src path that is being processed
+   * @param pathComponents path components corresponding to the path
+   * @param fsd FSDirectory
+   * @return if the path indicates an inode, return path after replacing upto
+   *         <inodeid> with the corresponding path of the inode, else the path
+   *         in {@code src} as is.
+   * @throws FileNotFoundException if inodeid is invalid
+   */
+  static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)
+      throws FileNotFoundException {
+    if (pathComponents == null || pathComponents.length <= 3) {
+      return src;
+    }
+    // Not /.reserved/.inodes
+    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])
+        || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path
+      return src;
+    }
+    final String inodeId = DFSUtil.bytes2String(pathComponents[3]);
+    long id = 0;
+    try {
+      id = Long.valueOf(inodeId);
+    } catch (NumberFormatException e) {
+      throw new FileNotFoundException(
+          "File for given inode path does not exist: " + src);
+    }
+    if (id == INodeId.ROOT_INODE_ID && pathComponents.length == 4) {
+      return Path.SEPARATOR;
+    }
+    StringBuilder path = id == INodeId.ROOT_INODE_ID ? new StringBuilder()
+        : new StringBuilder(fsd.getInode(id).getFullPathName());
+    for (int i = 4; i < pathComponents.length; i++) {
+      path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));
+    }
+    if (NameNode.LOG.isDebugEnabled()) {
+      NameNode.LOG.debug("Resolved path is " + path);
+    }
+    return path.toString();
+  }
+  
+  @VisibleForTesting
+  int getInodeMapSize() {
+    return inodeMap.size();
+  }
+  
+  /** Check if a given inode name is reserved */
+  public static boolean isReservedName(INode inode) {
+    return CHECK_RESERVED_FILE_NAMES
+        && Arrays.equals(inode.getLocalNameBytes(), DOT_RESERVED);
+  }
+  
+  /** Check if a given path is reserved */
+  public static boolean isReservedName(String src) {
+    return src.startsWith(DOT_RESERVED_PATH_PREFIX);

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS78 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS5 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS5 INS59 INS83 INS74 INS59 INS78 INS83 INS74 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS44 INS78 INS43 INS42 INS44 INS8 INS29 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS5 INS42 MOV44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS78 INS39 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS9 INS42 INS42 INS45 INS42 INS42 INS27 INS39 INS85 INS42 INS32 INS42 INS42 INS45 INS39 INS85 INS42 INS32 INS43 INS43 INS43 INS42 INS21 INS42 INS43 INS43 INS43 INS43 INS42 INS60 INS60 INS21 INS41 INS21 INS21 INS21 INS42 INS43 INS42 INS21 INS54 INS25 INS65 INS43 INS42 INS21 INS43 INS42 INS21 INS65 INS43 INS42 INS21 INS25 INS60 INS70 INS21 INS43 INS42 INS21 INS21 INS42 INS42 INS39 INS42 INS60 INS41 INS65 INS39 INS85 INS85 INS43 INS42 INS60 INS21 INS61 INS41 INS65 INS39 INS85 INS85 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS5 INS42 INS43 INS42 INS42 INS25 INS25 INS60 INS60 INS54 INS25 INS60 INS24 INS25 INS41 INS42 INS41 INS65 INS43 INS42 INS41 INS65 INS43 INS42 INS41 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS39 INS59 INS74 INS59 INS32 INS42 MOV43 INS32 INS32 INS32 INS42 INS32 INS8 INS8 INS27 INS8 INS8 INS66 INS42 INS32 INS42 INS32 INS66 INS42 INS32 INS38 INS8 INS43 INS59 INS44 INS32 INS8 INS32 INS42 INS32 INS7 INS43 INS59 INS32 INS66 INS66 INS66 INS42 INS74 INS59 INS32 INS27 INS8 INS32 INS66 INS16 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS39 INS85 INS85 INS42 INS27 INS8 INS27 INS8 INS83 INS43 INS59 INS39 INS59 INS8 INS12 INS27 INS8 INS43 INS59 INS58 INS27 INS37 INS8 INS32 INS8 INS32 INS32 INS66 INS42 INS27 INS66 INS42 INS32 INS40 INS42 INS32 INS42 INS32 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS21 INS27 INS32 INS53 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS42 INS42 INS11 INS43 INS42 INS42 INS42 INS21 INS42 INS42 INS52 INS21 INS42 INS42 INS42 INS33 INS42 INS42 INS14 INS42 INS42 INS43 INS5 INS42 INS14 INS42 INS42 INS34 INS32 INS32 INS33 INS21 INS21 INS42 INS42 INS3 INS38 INS33 INS32 INS66 INS27 INS27 INS41 INS38 INS38 INS41 INS42 INS42 INS32 INS42 INS34 INS21 INS44 INS8 INS27 INS27 INS41 INS42 INS42 INS16 INS39 INS59 INS42 INS40 INS42 INS21 INS40 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS45 INS42 INS42 INS42 INS74 INS42 MOV43 MOV32 INS32 INS32 INS27 INS27 INS42 INS42 INS14 INS32 INS32 INS42 INS42 INS43 INS42 INS42 INS32 INS32 INS43 INS42 INS14 INS34 INS34 INS1 INS42 INS39 INS85 INS74 INS42 INS42 INS42 INS42 INS32 INS7 INS5 INS32 INS32 INS42 INS42 INS42 INS42 INS33 INS40 INS34 INS42 INS32 INS32 INS42 INS42 INS42 INS2 INS7 INS43 INS42 INS53 INS42 INS40 INS40 INS34 INS40 INS27 INS14 INS14 INS42 INS34 INS32 INS32 INS42 INS42 INS32 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS34 INS2 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS43 INS45 INS45 INS14 INS31 INS31 INS31 INS43 INS5 INS42 INS42 INS34 INS32 INS42 INS32 INS39 INS85 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS2 INS42 INS34 INS42 INS32 INS42 INS14 INS42 INS40 INS43 INS43 INS32 INS32 INS42 INS32 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS45 INS32 INS45 INS45 INS45 INS45 INS42 INS43 INS11 INS78 INS39 INS42 INS44 INS8 INS78 INS5 INS42 INS44 INS8 INS78 INS43 INS42 INS44 INS8 INS42 INS39 INS85 INS32 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS42 INS42 INS2 INS45 INS42 INS42 INS42 INS42 INS42 INS39 INS34 INS42 INS43 INS42 INS41 INS42 INS39 INS85 INS5 INS42 INS41 INS42 INS42 INS43 INS42 INS41 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS39 INS85 INS33 INS42 INS33 DEL42 DEL42 DEL32 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42
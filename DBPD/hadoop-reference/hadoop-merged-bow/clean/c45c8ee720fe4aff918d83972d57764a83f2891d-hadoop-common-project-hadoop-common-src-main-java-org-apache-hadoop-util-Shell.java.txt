Complete commit of prior merge.

The previous merge accidentally only committed the hdfs project instead of common and MR
as well.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1463203 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+  private static boolean IS_JAVA7_OR_ABOVE =
+      System.getProperty("java.version").substring(0, 3).compareTo("1.7") >= 0;
+
+  public static boolean isJava7OrAbove() {
+    return IS_JAVA7_OR_ABOVE;
+  }
+
+
+  /** Windows CreateProcess synchronization object */
+  public static final Object WindowsProcessLaunchLock = new Object();
+
-    return new String[]{"bash", "-c", "groups"};
+    return (WINDOWS)? new String[]{"cmd", "/c", "groups"}
+                    : new String[]{"bash", "-c", "groups"};
+
-    return new String [] {"bash", "-c", "id -Gn " + user};
+    return (WINDOWS)? new String[] { WINUTILS, "groups", "-F", "\"" + user + "\""}
+                    : new String [] {"bash", "-c", "id -Gn " + user};
+
-    return new String [] {"bash", "-c", "getent netgroup " + netgroup};
+    return (WINDOWS)? new String [] {"cmd", "/c", "getent netgroup " + netgroup}
+                    : new String [] {"bash", "-c", "getent netgroup " + netgroup};
+
+  /** Return a command to get permission information. */
+  public static String[] getGetPermissionCommand() {
+    return (WINDOWS) ? new String[] { WINUTILS, "ls", "-F" }
+                     : new String[] { "/bin/ls", "-ld" };
+  }
+
+  /** Return a command to set permission */
+  public static String[] getSetPermissionCommand(String perm, boolean recursive) {
+    if (recursive) {
+      return (WINDOWS) ? new String[] { WINUTILS, "chmod", "-R", perm }
+                         : new String[] { "chmod", "-R", perm };
+    } else {
+      return (WINDOWS) ? new String[] { WINUTILS, "chmod", perm }
+                       : new String[] { "chmod", perm };
+    }
+  }
+
+  /**
+   * Return a command to set permission for specific file.
+   * 
+   * @param perm String permission to set
+   * @param recursive boolean true to apply to all sub-directories recursively
+   * @param file String file to set
+   * @return String[] containing command and arguments
+   */
+  public static String[] getSetPermissionCommand(String perm, boolean recursive,
+                                                 String file) {
+    String[] baseCmd = getSetPermissionCommand(perm, recursive);
+    String[] cmdWithFile = Arrays.copyOf(baseCmd, baseCmd.length + 1);
+    cmdWithFile[cmdWithFile.length - 1] = file;
+    return cmdWithFile;
+  }
+
+  /** Return a command to set owner */
+  public static String[] getSetOwnerCommand(String owner) {
+    return (WINDOWS) ? new String[] { WINUTILS, "chown", "\"" + owner + "\"" }
+                     : new String[] { "chown", owner };
+  }
+  
+  /** Return a command to create symbolic links */
+  public static String[] getSymlinkCommand(String target, String link) {
+    return WINDOWS ? new String[] { WINUTILS, "symlink", link, target }
+                   : new String[] { "ln", "-s", target, link };
+  }
+
+
+  /** a Unix command to set the change user's groups list */
-  /** Return a Unix command to get permission information. */
-  public static String[] getGET_PERMISSION_COMMAND() {
-    //force /bin/ls, except on windows.
-    return new String[] {(WINDOWS ? "ls" : "/bin/ls"), "-ld"};
-  }
+
+  /** Centralized logic to discover and validate the sanity of the Hadoop 
+   *  home directory. Returns either NULL or a directory that exists and 
+   *  was specified via either -Dhadoop.home.dir or the HADOOP_HOME ENV 
+   *  variable.  This does a lot of work so it should only be called 
+   *  privately for initialization once per process.
+   **/
+  private static String checkHadoopHome() {
+
+    // first check the Dflag hadoop.home.dir with JVM scope
+    String home = System.getProperty("hadoop.home.dir");
+
+    // fall back to the system/user-global env variable
+    if (home == null) {
+      home = System.getenv("HADOOP_HOME");
+    }
+
+    try {
+       // couldn't find either setting for hadoop's home directory
+       if (home == null) {
+         throw new IOException("HADOOP_HOME or hadoop.home.dir are not set.");
+       }
+
+       if (home.startsWith("\"") && home.endsWith("\"")) {
+         home = home.substring(1, home.length()-1);
+       }
+
+       // check that the home setting is actually a directory that exists
+       File homedir = new File(home);
+       if (!homedir.isAbsolute() || !homedir.exists() || !homedir.isDirectory()) {
+         throw new IOException("Hadoop home directory " + homedir
+           + " does not exist, is not a directory, or is not an absolute path.");
+       }
+
+       home = homedir.getCanonicalPath();
+
+    } catch (IOException ioe) {
+       LOG.error("Failed to detect a valid hadoop home directory", ioe);
+       home = null;
+    }
+    
+    return home;
+  }
+  private static String HADOOP_HOME_DIR = checkHadoopHome();
+
+  // Public getter, throws an exception if HADOOP_HOME failed validation
+  // checks and is being referenced downstream.
+  public static final String getHadoopHome() throws IOException {
+    if (HADOOP_HOME_DIR == null) {
+      throw new IOException("Misconfigured HADOOP_HOME cannot be referenced.");
+    }
+
+    return HADOOP_HOME_DIR;
+  }
+
+  /** fully qualify the path to a binary that should be in a known hadoop 
+   *  bin location. This is primarily useful for disambiguating call-outs 
+   *  to executable sub-components of Hadoop to avoid clashes with other 
+   *  executables that may be in the path.  Caveat:  this call doesn't 
+   *  just format the path to the bin directory.  It also checks for file 
+   *  existence of the composed path. The output of this call should be 
+   *  cached by callers.
+   * */
+  public static final String getQualifiedBinPath(String executable) 
+  throws IOException {
+    // construct hadoop bin path to the specified executable
+    String fullExeName = HADOOP_HOME_DIR + File.separator + "bin" 
+      + File.separator + executable;
+
+    File exeFile = new File(fullExeName);
+    if (!exeFile.exists()) {
+      throw new IOException("Could not locate executable " + fullExeName
+        + " in the Hadoop binaries.");
+    }
+
+    return exeFile.getCanonicalPath();
+  }
+
+
+  public static final boolean LINUX
+                = System.getProperty("os.name").startsWith("Linux");
+  /** a Windows utility to emulate Unix commands */
+  public static final String WINUTILS = getWinUtilsPath();
+
+  public static final String getWinUtilsPath() {
+    String winUtilsPath = null;
+
+    try {
+      if (WINDOWS) {
+        winUtilsPath = getQualifiedBinPath("winutils.exe");
+      }
+    } catch (IOException ioe) {
+       LOG.error("Failed to locate the winutils binary in the hadoop binary path",
+         ioe);
+    }
+
+    return winUtilsPath;
+  }
+
+  /** Token separator regex used to parse Shell tool outputs */
+  public static final String TOKEN_SEPARATOR_REGEX
+                = WINDOWS ? "[|\n\r]" : "[ \t\n\r\f]";
+
-    process = builder.start();
+    if (Shell.WINDOWS) {
+      synchronized (WindowsProcessLaunchLock) {
+        // To workaround the race condition issue with child processes
+        // inheriting unintended handles during process launch that can
+        // lead to hangs on reading output and error streams, we
+        // serialize process creation. More info available at:
+        // http://support.microsoft.com/kb/315939
+        process = builder.start();
+      }
+    } else {
+      process = builder.start();
+    }
+

INS26 MOV31 INS40 INS23 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS23 INS23 INS31 INS23 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS83 INS43 INS59 UPD42 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS29 INS29 INS83 INS83 INS43 INS42 INS8 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS83 INS83 INS43 INS42 INS44 INS43 INS8 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS42 INS8 INS29 INS83 INS83 INS83 INS43 INS59 INS42 INS27 INS41 INS65 INS42 INS42 INS14 INS65 INS43 INS85 INS43 INS42 INS39 INS42 INS25 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS39 INS42 INS43 INS42 INS60 INS60 INS21 INS41 INS65 INS43 INS85 INS43 INS42 INS41 INS65 INS43 INS85 INS43 INS42 INS43 INS42 INS41 INS65 INS65 INS42 INS60 INS25 INS54 INS41 INS42 INS42 INS32 INS42 INS42 INS25 INS41 INS65 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS41 INS42 INS32 INS65 INS42 INS42 INS32 INS42 INS60 INS54 INS41 INS65 INS42 INS42 INS16 INS25 INS32 INS34 INS42 INS66 INS43 INS16 INS16 INS16 UPD66 INS16 INS66 INS42 INS42 INS42 INS8 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS5 INS59 INS5 INS59 INS7 INS42 INS66 INS42 INS42 INS16 INS66 INS42 INS42 INS42 INS16 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS59 INS27 INS8 INS8 INS12 INS42 INS42 INS27 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS43 INS59 INS43 INS59 INS38 INS8 INS32 INS32 INS42 INS45 INS66 INS42 INS43 INS59 INS8 INS12 INS42 INS66 INS42 INS45 INS45 INS40 INS8 INS8 INS32 INS42 INS45 INS42 INS36 INS3 MOV3 INS36 INS3 MOV3 INS36 INS3 MOV3 INS36 INS3 INS3 INS41 INS41 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS2 INS42 INS36 INS3 INS3 INS42 INS3 INS3 INS42 INS42 INS32 INS42 INS33 INS21 INS25 INS25 INS60 INS25 INS21 INS44 INS8 INS42 INS33 INS53 INS42 INS42 INS27 INS42 INS42 INS14 INS32 INS53 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS33 INS25 INS44 INS8 INS51 INS21 INS32 INS42 INS34 INS34 INS42 INS5 INS4 INS42 INS5 INS4 INS42 INS5 INS4 INS42 MOV5 INS4 INS5 INS4 INS16 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS42 INS5 INS4 INS5 INS4 INS5 INS4 INS5 INS4 INS42 INS42 INS45 INS7 INS27 INS8 INS27 INS8 INS43 INS59 INS27 INS8 INS7 INS43 INS42 INS21 INS21 INS14 INS42 INS40 INS45 INS40 INS42 INS43 INS42 INS42 INS42 INS14 INS42 INS8 INS43 INS42 INS21 INS42 INS8 INS7 INS42 INS42 INS45 INS43 INS85 INS45 INS45 INS45 INS43 INS85 INS42 INS45 INS45 INS27 INS43 INS85 INS45 INS45 INS27 INS42 INS45 INS45 INS43 INS85 INS45 MOV45 INS36 INS3 INS3 INS36 INS3 INS3 INS40 INS34 INS40 INS34 INS43 INS85 INS42 INS45 INS27 INS43 INS85 INS45 INS42 INS43 INS85 INS42 INS45 INS42 INS42 INS43 INS85 INS45 INS45 INS42 INS42 INS42 INS32 INS42 INS33 INS53 INS32 INS32 INS21 INS42 INS42 INS14 INS38 INS38 INS38 INS53 INS42 INS32 INS42 INS32 INS7 INS43 INS45 INS42 INS43 INS27 INS21 INS42 INS32 MOV21 INS42 INS32 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS5 INS4 INS5 INS4 INS42 INS5 INS4 INS5 INS4 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS14 INS42 INS42 INS45 INS42 INS42 INS45 INS7 INS43 INS42 INS32 INS32 INS32 INS14 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS33 INS42 INS42 INS45 INS42 INS45 INS7 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS85 INS42 INS45 INS45 INS42 INS43 INS85 INS45 INS45 INS42 INS43 INS85 INS42 INS45 INS42 INS43 INS85 INS45 INS42 INS43 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS34 INS42 INS42 DEL42 DEL45 DEL45 DEL16 DEL36 DEL4 DEL3
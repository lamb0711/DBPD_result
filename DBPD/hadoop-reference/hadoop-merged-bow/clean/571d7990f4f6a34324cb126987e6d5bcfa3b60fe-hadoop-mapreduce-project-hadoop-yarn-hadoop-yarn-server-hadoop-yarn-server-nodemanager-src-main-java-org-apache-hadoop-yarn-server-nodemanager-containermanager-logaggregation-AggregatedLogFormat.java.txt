Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.InputStreamReader;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.apache.commons.io.input.BoundedInputStream;
+import org.apache.hadoop.yarn.YarnException;
+import org.apache.hadoop.yarn.api.records.ApplicationAccessType;
+  private static final LogKey APPLICATION_ACL_KEY = new LogKey("APPLICATION_ACL");
+  private static final LogKey APPLICATION_OWNER_KEY = new LogKey("APPLICATION_OWNER");
+  private static final LogKey VERSION_KEY = new LogKey("VERSION");
+  private static final Map<String, LogKey> RESERVED_KEYS;
+  //Maybe write out the retention policy.
+  //Maybe write out a list of containerLogs skipped by the retention policy.
+  private static final int VERSION = 1;
+  static {
+    RESERVED_KEYS = new HashMap<String, AggregatedLogFormat.LogKey>();
+    RESERVED_KEYS.put(APPLICATION_ACL_KEY.toString(), APPLICATION_ACL_KEY);
+    RESERVED_KEYS.put(APPLICATION_OWNER_KEY.toString(), APPLICATION_OWNER_KEY);
+    RESERVED_KEYS.put(VERSION_KEY.toString(), VERSION_KEY);
+  }
+  
-    private String containerId;
+    private String keyString;
-      this.containerId = ConverterUtils.toString(containerId);
+      this.keyString = containerId.toString();
+    public LogKey(String keyString) {
+      this.keyString = keyString;
+    }
+    
-      out.writeUTF(this.containerId);
+      out.writeUTF(this.keyString);
-      this.containerId = in.readUTF();
+      this.keyString = in.readUTF();
-      return this.containerId;
+      return this.keyString;
+    // TODO Maybe add a version string here. Instead of changing the version of
+    // the entire k-v format
-                    EnumSet.of(CreateFlag.CREATE), new Options.CreateOpts[] {});
+                    EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),
+                    new Options.CreateOpts[] {});
+      //Write the version string
+      writeVersion();
+    }
+
+    private void writeVersion() throws IOException {
+      DataOutputStream out = this.writer.prepareAppendKey(-1);
+      VERSION_KEY.write(out);
+      out.close();
+      out = this.writer.prepareAppendValue(-1);
+      out.writeInt(VERSION);
+      out.close();
+      this.fsDataOStream.hflush();
+    }
+
+    public void writeApplicationOwner(String user) throws IOException {
+      DataOutputStream out = this.writer.prepareAppendKey(-1);
+      APPLICATION_OWNER_KEY.write(out);
+      out.close();
+      out = this.writer.prepareAppendValue(-1);
+      out.writeUTF(user);
+      out.close();
+    }
+
+    public void writeApplicationACLs(Map<ApplicationAccessType, String> appAcls)
+        throws IOException {
+      DataOutputStream out = this.writer.prepareAppendKey(-1);
+      APPLICATION_ACL_KEY.write(out);
+      out.close();
+      out = this.writer.prepareAppendValue(-1);
+      for (Entry<ApplicationAccessType, String> entry : appAcls.entrySet()) {
+        out.writeUTF(entry.getKey().toString());
+        out.writeUTF(entry.getValue());
+      }
+      out.close();
+    private final TFile.Reader reader;
-      TFile.Reader reader =
+      reader =
+     * Returns the owner of the application.
+     * 
+     * @return the application owner.
+     * @throws IOException
+     */
+    public String getApplicationOwner() throws IOException {
+      TFile.Reader.Scanner ownerScanner = reader.createScanner();
+      LogKey key = new LogKey();
+      while (!ownerScanner.atEnd()) {
+        TFile.Reader.Scanner.Entry entry = ownerScanner.entry();
+        key.readFields(entry.getKeyStream());
+        if (key.toString().equals(APPLICATION_OWNER_KEY.toString())) {
+          DataInputStream valueStream = entry.getValueStream();
+          return valueStream.readUTF();
+        }
+        ownerScanner.advance();
+      }
+      return null;
+    }
+
+    /**
+     * Returns ACLs for the application. An empty map is returned if no ACLs are
+     * found.
+     * 
+     * @return a map of the Application ACLs.
+     * @throws IOException
+     */
+    public Map<ApplicationAccessType, String> getApplicationAcls()
+        throws IOException {
+      // TODO Seek directly to the key once a comparator is specified.
+      TFile.Reader.Scanner aclScanner = reader.createScanner();
+      LogKey key = new LogKey();
+      Map<ApplicationAccessType, String> acls =
+          new HashMap<ApplicationAccessType, String>();
+      while (!aclScanner.atEnd()) {
+        TFile.Reader.Scanner.Entry entry = aclScanner.entry();
+        key.readFields(entry.getKeyStream());
+        if (key.toString().equals(APPLICATION_ACL_KEY.toString())) {
+          DataInputStream valueStream = entry.getValueStream();
+          while (true) {
+            String appAccessOp = null;
+            String aclString = null;
+            try {
+              appAccessOp = valueStream.readUTF();
+            } catch (EOFException e) {
+              // Valid end of stream.
+              break;
+            }
+            try {
+              aclString = valueStream.readUTF();
+            } catch (EOFException e) {
+              throw new YarnException("Error reading ACLs", e);
+            }
+            acls.put(ApplicationAccessType.valueOf(appAccessOp), aclString);
+          }
+
+        }
+        aclScanner.advance();
+      }
+      return acls;
+    }
+    
+    /**
+      // Skip META keys
+      if (RESERVED_KEYS.containsKey(key.toString())) {
+        return next(key);
+      }
+    
+    //TODO  Change Log format and interfaces to be containerId specific.
+    // Avoid returning completeValueStreams.
+//    public List<String> getTypesForContainer(DataInputStream valueStream){}
+//    
+//    /**
+//     * @param valueStream
+//     *          The Log stream for the container.
+//     * @param fileType
+//     *          the log type required.
+//     * @return An InputStreamReader for the required log type or null if the
+//     *         type is not found.
+//     * @throws IOException
+//     */
+//    public InputStreamReader getLogStreamForType(DataInputStream valueStream,
+//        String fileType) throws IOException {
+//      valueStream.reset();
+//      try {
+//        while (true) {
+//          String ft = valueStream.readUTF();
+//          String fileLengthStr = valueStream.readUTF();
+//          long fileLength = Long.parseLong(fileLengthStr);
+//          if (ft.equals(fileType)) {
+//            BoundedInputStream bis =
+//                new BoundedInputStream(valueStream, fileLength);
+//            return new InputStreamReader(bis);
+//          } else {
+//            long totalSkipped = 0;
+//            long currSkipped = 0;
+//            while (currSkipped != -1 && totalSkipped < fileLength) {
+//              currSkipped = valueStream.skip(fileLength - totalSkipped);
+//              totalSkipped += currSkipped;
+//            }
+//            // TODO Verify skip behaviour.
+//            if (currSkipped == -1) {
+//              return null;
+//            }
+//          }
+//        }
+//      } catch (EOFException e) {
+//        return null;
+//      }
+//    }
+
+    /**
+     * Writes all logs for a single container to the provided writer.
+     * @param valueStream
+     * @param writer
+     * @throws IOException
+     */
+    public static void readAcontainerLogs(DataInputStream valueStream,
+        Writer writer) throws IOException {
+      int bufferSize = 65536;
+      char[] cbuf = new char[bufferSize];
+      String fileType;
+      String fileLengthStr;
+      long fileLength;
+
+      while (true) {
+        try {
+          fileType = valueStream.readUTF();
+        } catch (EOFException e) {
+          // EndOfFile
+          return;
+        }
+        fileLengthStr = valueStream.readUTF();
+        fileLength = Long.parseLong(fileLengthStr);
+        writer.write("\n\nLogType:");
+        writer.write(fileType);
+        writer.write("\nLogLength:");
+        writer.write(fileLengthStr);
+        writer.write("\nLog Contents:\n");
+        // ByteLevel
+        BoundedInputStream bis =
+            new BoundedInputStream(valueStream, fileLength);
+        InputStreamReader reader = new InputStreamReader(bis);
+        int currentRead = 0;
+        int totalRead = 0;
+        while ((currentRead = reader.read(cbuf, 0, bufferSize)) != -1) {
+          writer.write(cbuf);
+          totalRead += currentRead;
+        }
+      }
+    }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS28 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS74 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS8 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS31 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS43 MOV43 INS43 INS42 INS42 INS34 INS21 INS21 INS21 INS21 INS43 INS83 INS42 INS44 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS83 MOV43 INS59 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS74 INS42 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS43 INS45 INS43 INS45 INS43 INS45 INS42 INS42 INS7 INS32 INS32 INS32 INS42 UPD42 INS43 INS42 INS21 INS21 INS42 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS43 INS42 INS42 INS60 INS21 INS21 INS21 INS21 INS21 INS74 INS42 INS42 INS60 INS21 INS21 INS21 INS70 INS21 INS42 INS21 INS65 INS65 INS65 INS42 INS42 INS60 INS60 INS61 INS41 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS60 INS60 INS60 INS61 INS41 INS25 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS61 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS7 INS32 INS43 INS59 INS32 INS32 INS7 INS32 INS32 INS32 INS42 INS43 INS59 INS32 INS32 INS7 INS32 INS32 INS43 INS43 INS43 INS43 INS59 INS32 INS32 INS7 INS44 INS32 INS8 INS32 INS7 INS66 INS66 INS42 INS43 INS59 INS43 INS59 INS38 INS8 INS33 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS74 INS59 INS38 INS8 INS42 INS32 INS8 INS66 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS5 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS9 INS8 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS74 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 MOV14 INS40 INS42 INS32 INS42 INS42 INS14 INS32 INS60 INS21 INS25 INS21 INS40 INS42 INS32 INS42 INS42 INS14 INS43 INS43 INS43 INS42 INS14 INS32 INS60 INS21 INS25 INS21 INS42 INS42 INS32 INS41 INS42 INS34 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS42 INS42 INS54 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS60 INS60 INS60 INS60 INS61 INS43 INS43 INS43 UPD42 UPD42 INS52 INS42 UPD42 UPD42 INS22 INS42 INS38 INS22 INS42 INS38 INS52 INS42 INS22 INS42 INS38 INS22 INS42 INS38 INS22 INS42 INS38 INS22 INS42 INS38 INS43 INS43 INS43 INS32 INS32 INS42 INS42 INS43 INS42 INS42 INS43 INS59 INS32 INS32 INS8 INS32 INS42 INS42 INS43 INS42 INS42 INS42 INS74 INS42 INS42 INS43 INS59 INS32 INS32 INS8 INS32 INS42 INS42 INS32 INS5 INS42 INS8 INS12 INS7 INS7 INS32 INS32 INS32 INS32 INS32 INS43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS42 INS42 INS40 INS52 INS42 INS34 INS52 INS42 INS34 INS52 INS42 INS34 INS52 INS42 INS34 INS52 INS42 INS34 INS52 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS40 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS60 INS41 INS42 INS42 INS42 INS43 INS43 INS43 INS40 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS60 INS61 INS42 INS42 INS42 INS42 INS39 INS85 INS21 INS44 INS8 INS42 INS32 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS34 INS42 INS34 INS36 INS38 INS21 INS21 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS9 INS8 INS7 INS43 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS7 INS34 INS32 INS7 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS60 INS60 INS54 INS54 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS8 INS12 INS8 INS12 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS44 INS8 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS7 INS43 INS42 INS10 INS7 INS43 INS42 INS53 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS40 INS42 DEL42 DEL42 DEL59 DEL60
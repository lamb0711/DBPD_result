HADOOP-12782. Faster LDAP group name resolution with ActiveDirectory. Contributed by Wei-Chiu Chuang

+import javax.naming.ldap.LdapName;
+import javax.naming.ldap.Rdn;
+     * LDAP attribute to use for determining group membership
+     */
+  public static final String MEMBEROF_ATTR_KEY =
+      LDAP_CONFIG_PREFIX + ".search.attr.memberof";
+  public static final String MEMBEROF_ATTR_DEFAULT = "";
+
+  /*
+  private String memberOfAttr;
+  private boolean useOneQuery;
-  
-  List<String> doGetGroups(String user) throws NamingException {
+
+  /**
+   * A helper method to get the Relative Distinguished Name (RDN) from
+   * Distinguished name (DN). According to Active Directory documentation,
+   * a group object's RDN is a CN.
+   *
+   * @param distinguishedName A string representing a distinguished name.
+   * @throws NamingException if the DN is malformed.
+   * @return a string which represents the RDN
+   */
+  private String getRelativeDistinguishedName(String distinguishedName)
+      throws NamingException {
+    LdapName ldn = new LdapName(distinguishedName);
+    List<Rdn> rdns = ldn.getRdns();
+    if (rdns.isEmpty()) {
+      throw new NamingException("DN is empty");
+    }
+    Rdn rdn = rdns.get(rdns.size()-1);
+    if (rdn.getType().equalsIgnoreCase(groupNameAttr)) {
+      String groupName = (String)rdn.getValue();
+      return groupName;
+    }
+    throw new NamingException("Unable to find RDN: The DN " +
+    distinguishedName + " is malformed.");
+  }
+
+  /**
+   * Look up groups using posixGroups semantics. Use posix gid/uid to find
+   * groups of the user.
+   *
+   * @param result the result object returned from the prior user lookup.
+   * @param c the context object of the LDAP connection.
+   * @return an object representing the search result.
+   *
+   * @throws NamingException if the server does not support posixGroups
+   * semantics.
+   */
+  private NamingEnumeration<SearchResult> lookupPosixGroup(SearchResult result,
+      DirContext c) throws NamingException {
+    String gidNumber = null;
+    String uidNumber = null;
+    Attribute gidAttribute = result.getAttributes().get(posixGidAttr);
+    Attribute uidAttribute = result.getAttributes().get(posixUidAttr);
+    String reason = "";
+    if (gidAttribute == null) {
+      reason = "Can't find attribute '" + posixGidAttr + "'.";
+    } else {
+      gidNumber = gidAttribute.get().toString();
+    }
+    if (uidAttribute == null) {
+      reason = "Can't find attribute '" + posixUidAttr + "'.";
+    } else {
+      uidNumber = uidAttribute.get().toString();
+    }
+    if (uidNumber != null && gidNumber != null) {
+      return c.search(baseDN,
+              "(&"+ groupSearchFilter + "(|(" + posixGidAttr + "={0})" +
+                  "(" + groupMemberAttr + "={1})))",
+              new Object[] {gidNumber, uidNumber},
+              SEARCH_CONTROLS);
+    }
+    throw new NamingException("The server does not support posixGroups " +
+        "semantics. Reason: " + reason +
+        " Returned user object: " + result.toString());
+  }
+
+  /**
+   * Perform the second query to get the groups of the user.
+   *
+   * If posixGroups is enabled, use use posix gid/uid to find.
+   * Otherwise, use the general group member attribute to find it.
+   *
+   * @param result the result object returned from the prior user lookup.
+   * @param c the context object of the LDAP connection.
+   * @return a list of strings representing group names of the user.
+   * @throws NamingException if unable to find group names
+   */
+  private List<String> lookupGroup(SearchResult result, DirContext c)
+      throws NamingException {
-    DirContext ctx = getDirContext();
-
-    // Search for the user. We'll only ever need to look at the first result
-    NamingEnumeration<SearchResult> results = ctx.search(baseDN,
-        userSearchFilter,
-        new Object[]{user},
-        SEARCH_CONTROLS);
-    if (results.hasMoreElements()) {
-      SearchResult result = results.nextElement();
+    NamingEnumeration<SearchResult> groupResults = null;
+    // perform the second LDAP query
+    if (isPosix) {
+      groupResults = lookupPosixGroup(result, c);
+    } else {
-
-      NamingEnumeration<SearchResult> groupResults = null;
-
-      if (isPosix) {
-        String gidNumber = null;
-        String uidNumber = null;
-        Attribute gidAttribute = result.getAttributes().get(posixGidAttr);
-        Attribute uidAttribute = result.getAttributes().get(posixUidAttr);
-        if (gidAttribute != null) {
-          gidNumber = gidAttribute.get().toString();
+      groupResults =
+          c.search(baseDN,
+              "(&" + groupSearchFilter + "(" + groupMemberAttr + "={0}))",
+              new Object[]{userDn},
+              SEARCH_CONTROLS);
+    }
+    // if the second query is successful, group objects of the user will be
+    // returned. Get group names from the returned objects.
+    if (groupResults != null) {
+      while (groupResults.hasMoreElements()) {
+        SearchResult groupResult = groupResults.nextElement();
+        Attribute groupName = groupResult.getAttributes().get(groupNameAttr);
+        if (groupName == null) {
+          throw new NamingException("The group object does not have " +
+              "attribute '" + groupNameAttr + "'.");
-        if (uidAttribute != null) {
-          uidNumber = uidAttribute.get().toString();
-        }
-        if (uidNumber != null && gidNumber != null) {
-          groupResults =
-              ctx.search(baseDN,
-                  "(&"+ groupSearchFilter + "(|(" + posixGidAttr + "={0})" +
-                      "(" + groupMemberAttr + "={1})))",
-                  new Object[] { gidNumber, uidNumber },
-                  SEARCH_CONTROLS);
-        }
-      } else {
-        groupResults =
-            ctx.search(baseDN,
-                "(&" + groupSearchFilter + "(" + groupMemberAttr + "={0}))",
-                new Object[]{userDn},
-                SEARCH_CONTROLS);
-      }
-      if (groupResults != null) {
-        while (groupResults.hasMoreElements()) {
-          SearchResult groupResult = groupResults.nextElement();
-          Attribute groupName = groupResult.getAttributes().get(groupNameAttr);
-          groups.add(groupName.get().toString());
-        }
+        groups.add(groupName.get().toString());
+    return groups;
+  }
+  /**
+   * Perform LDAP queries to get group names of a user.
+   *
+   * Perform the first LDAP query to get the user object using the user's name.
+   * If one-query is enabled, retrieve the group names from the user object.
+   * If one-query is disabled, or if it failed, perform the second query to
+   * get the groups.
+   *
+   * @param user user name
+   * @return a list of group names for the user. If the user can not be found,
+   * return an empty string array.
+   * @throws NamingException if unable to get group names
+   */
+  List<String> doGetGroups(String user) throws NamingException {
+    DirContext c = getDirContext();
+
+    // Search for the user. We'll only ever need to look at the first result
+    NamingEnumeration<SearchResult> results = c.search(baseDN,
+        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);
+    // return empty list if the user can not be found.
+    if (!results.hasMoreElements()) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("doGetGroups(" + user + ") return no groups because the " +
+            "user is not found.");
+      }
+      return new ArrayList<String>();
+    }
+    SearchResult result = results.nextElement();
+
+    List<String> groups = null;
+    if (useOneQuery) {
+      try {
+        /**
+         * For Active Directory servers, the user object has an attribute
+         * 'memberOf' that represents the DNs of group objects to which the
+         * user belongs. So the second query may be skipped.
+         */
+        Attribute groupDNAttr = result.getAttributes().get(memberOfAttr);
+        if (groupDNAttr == null) {
+          throw new NamingException("The user object does not have '" +
+              memberOfAttr + "' attribute." +
+              "Returned user object: " + result.toString());
+        }
+        groups = new ArrayList<String>();
+        NamingEnumeration groupEnumeration = groupDNAttr.getAll();
+        while (groupEnumeration.hasMore()) {
+          String groupDN = groupEnumeration.next().toString();
+          groups.add(getRelativeDistinguishedName(groupDN));
+        }
+      } catch (NamingException e) {
+        // If the first lookup failed, fall back to the typical scenario.
+        LOG.info("Failed to get groups from the first lookup. Initiating " +
+                "the second LDAP query using the user's DN.", e);
+      }
+    }
+    if (groups == null || groups.isEmpty()) {
+      groups = lookupGroup(result, c);
+    }
+    memberOfAttr =
+        conf.get(MEMBEROF_ATTR_KEY, MEMBEROF_ATTR_DEFAULT);
+    // if memberOf attribute is set, resolve group names from the attribute
+    // of user objects.
+    useOneQuery = !memberOfAttr.isEmpty();
-    SEARCH_CONTROLS.setReturningAttributes(
-        new String[] {groupNameAttr, posixUidAttr, posixGidAttr});
+    String[] returningAttributes;
+    if (useOneQuery) {
+      returningAttributes = new String[] {
+          groupNameAttr, posixUidAttr, posixGidAttr, memberOfAttr};
+    } else {
+      returningAttributes = new String[] {
+          groupNameAttr, posixUidAttr, posixGidAttr};
+    }
+    SEARCH_CONTROLS.setReturningAttributes(returningAttributes);

INS26 INS26 INS40 INS40 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS43 MOV8 INS29 INS83 UPD42 INS44 INS44 MOV8 INS29 INS74 INS42 MOV44 INS43 INS8 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS60 INS25 INS53 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS43 INS42 INS42 INS60 INS53 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 MOV60 MOV41 INS65 INS65 INS65 INS65 INS43 INS43 INS42 MOV60 MOV60 INS25 MOV60 INS60 INS25 INS25 MOV25 INS41 INS21 INS21 INS60 INS25 INS21 INS42 INS45 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS74 INS59 INS32 INS8 INS43 INS59 INS32 INS8 INS14 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS59 UPD27 INS8 UPD27 INS8 INS14 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS8 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS38 INS8 INS74 INS59 INS42 INS8 INS27 INS8 INS42 INS7 INS7 INS5 INS59 INS42 INS8 INS8 INS32 INS42 INS42 INS14 INS43 INS43 INS42 INS32 INS42 INS42 INS53 INS42 INS42 INS32 INS32 INS42 INS42 INS60 INS41 INS43 INS27 INS42 INS42 INS45 INS21 INS21 INS41 INS43 INS27 INS21 MOV60 UPD42 MOV32 INS25 INS41 INS43 INS43 INS42 INS33 INS54 INS27 INS32 INS21 INS42 INS32 INS42 INS38 INS43 INS85 INS42 INS21 MOV21 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS27 INS42 INS42 INS43 INS59 INS42 INS42 INS45 INS42 INS45 INS7 INS7 MOV32 INS42 INS27 INS42 INS45 INS32 INS7 UPD42 INS32 INS8 INS14 INS42 INS42 INS8 INS12 INS42 INS33 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS32 INS42 INS7 INS7 INS42 INS43 INS45 INS32 INS34 INS42 INS42 INS11 INS42 INS27 INS42 INS27 UPD42 INS45 INS45 INS42 INS42 INS42 INS32 INS25 INS42 INS42 INS21 INS74 INS60 INS25 INS21 INS60 INS61 INS44 INS8 INS42 INS32 INS42 INS42 INS42 INS3 INS42 MOV3 INS42 INS42 INS42 INS43 INS32 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS42 UPD42 INS27 INS8 INS32 INS43 INS43 INS43 INS59 INS27 INS8 INS7 INS43 INS59 INS32 INS8 INS43 INS42 INS21 INS42 INS42 INS42 INS5 INS4 INS42 INS42 INS42 INS42 INS33 INS53 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS53 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS42 INS32 INS43 INS85 INS42 INS42 INS42 INS42 INS14 INS45 INS42 INS45 INS45 INS32 INS42 INS42 INS14 INS74 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS27 INS42 INS42 INS43 INS27 INS42 INS42 INS43 INS27 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS45 INS45 INS42 INS27 INS42 INS45 INS42 INS45 INS42 INS45 INS45 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 DEL42 DEL7 DEL21 DEL25 DEL8 DEL42 DEL42 DEL32
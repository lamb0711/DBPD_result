YARN-8930. CGroup-based strict container memory enforcement does not work with CGroupElasticMemoryController (haibochen via rkanter)

-import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.MemoryResourceHandler;
-import java.util.Optional;
-      Optional<Boolean> isMemoryOverLimit = Optional.empty();
+      if (strictMemoryEnforcement && !elasticMemoryEnforcement) {
+        // When cgroup-based strict memory enforcement is used alone without
+        // elastic memory control, the oom-kill would take care of it.
+        // However, when elastic memory control is also enabled, the oom killer
+        // would be disabled at the root yarn container cgroup level (all child
+        // cgroups would inherit that setting). Hence, we fall back to the
+        // polling-based mechanism.
+        return;
+      }
+      boolean isMemoryOverLimit = false;
-      if (strictMemoryEnforcement && elasticMemoryEnforcement) {
-        // Both elastic memory control and strict memory control are enabled
-        // through cgroups. A container will be frozen by the elastic memory
-        // control mechanism if it exceeds its request, so we check for this
-        // here and kill it. Otherwise, the container will not be killed if
-        // the node never exceeds its limit and the procfs-based
-        // memory accounting is different from the cgroup-based accounting.
-
-        MemoryResourceHandler handler =
-            ResourceHandlerModule.getMemoryResourceHandler();
-        if (handler != null) {
-          isMemoryOverLimit = handler.isUnderOOM(containerId);
-          containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_PMEM;
-          msg = containerId + " is under oom because it exceeded its" +
-              " physical memory limit";
-        }
-      } else if (strictMemoryEnforcement || elasticMemoryEnforcement) {
-        // if cgroup-based memory control is enabled
-        isMemoryOverLimit = Optional.of(false);
+      long vmemLimit = ptInfo.getVmemLimit();
+      long pmemLimit = ptInfo.getPmemLimit();
+      // as processes begin with an age 1, we want to see if there
+      // are processes more than 1 iteration old.
+      long curMemUsageOfAgedProcesses = pTree.getVirtualMemorySize(1);
+      long curRssMemUsageOfAgedProcesses = pTree.getRssMemorySize(1);
+      if (isVmemCheckEnabled()
+          && isProcessTreeOverLimit(containerId.toString(),
+          currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {
+        // The current usage (age=0) is always higher than the aged usage. We
+        // do not show the aged size in the message, base the delta on the
+        // current usage
+        long delta = currentVmemUsage - vmemLimit;
+        // Container (the root process) is still alive and overflowing
+        // memory.
+        // Dump the process-tree and then clean it up.
+        msg = formatErrorMessage("virtual",
+            formatUsageString(currentVmemUsage, vmemLimit,
+                currentPmemUsage, pmemLimit),
+            pId, containerId, pTree, delta);
+        isMemoryOverLimit = true;
+        containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_VMEM;
+      } else if (isPmemCheckEnabled()
+          && isProcessTreeOverLimit(containerId.toString(),
+          currentPmemUsage, curRssMemUsageOfAgedProcesses,
+          pmemLimit)) {
+        // The current usage (age=0) is always higher than the aged usage. We
+        // do not show the aged size in the message, base the delta on the
+        // current usage
+        long delta = currentPmemUsage - pmemLimit;
+        // Container (the root process) is still alive and overflowing
+        // memory.
+        // Dump the process-tree and then clean it up.
+        msg = formatErrorMessage("physical",
+            formatUsageString(currentVmemUsage, vmemLimit,
+                currentPmemUsage, pmemLimit),
+            pId, containerId, pTree, delta);
+        isMemoryOverLimit = true;
+        containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_PMEM;
-      if (!isMemoryOverLimit.isPresent()) {
-        long vmemLimit = ptInfo.getVmemLimit();
-        long pmemLimit = ptInfo.getPmemLimit();
-        // as processes begin with an age 1, we want to see if there
-        // are processes more than 1 iteration old.
-        long curMemUsageOfAgedProcesses = pTree.getVirtualMemorySize(1);
-        long curRssMemUsageOfAgedProcesses = pTree.getRssMemorySize(1);
-        if (isVmemCheckEnabled()
-            && isProcessTreeOverLimit(containerId.toString(),
-            currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {
-          // The current usage (age=0) is always higher than the aged usage. We
-          // do not show the aged size in the message, base the delta on the
-          // current usage
-          long delta = currentVmemUsage - vmemLimit;
-          // Container (the root process) is still alive and overflowing
-          // memory.
-          // Dump the process-tree and then clean it up.
-          msg = formatErrorMessage("virtual",
-              formatUsageString(currentVmemUsage, vmemLimit,
-                  currentPmemUsage, pmemLimit),
-              pId, containerId, pTree, delta);
-          isMemoryOverLimit = Optional.of(true);
-          containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_VMEM;
-        } else if (isPmemCheckEnabled()
-            && isProcessTreeOverLimit(containerId.toString(),
-            currentPmemUsage, curRssMemUsageOfAgedProcesses,
-            pmemLimit)) {
-          // The current usage (age=0) is always higher than the aged usage. We
-          // do not show the aged size in the message, base the delta on the
-          // current usage
-          long delta = currentPmemUsage - pmemLimit;
-          // Container (the root process) is still alive and overflowing
-          // memory.
-          // Dump the process-tree and then clean it up.
-          msg = formatErrorMessage("physical",
-              formatUsageString(currentVmemUsage, vmemLimit,
-                  currentPmemUsage, pmemLimit),
-              pId, containerId, pTree, delta);
-          isMemoryOverLimit = Optional.of(true);
-          containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_PMEM;
-        }
-      }
-
-      if (isMemoryOverLimit.isPresent() && isMemoryOverLimit.get()) {
+      if (isMemoryOverLimit) {

MOV8 INS25 INS60 MOV60 MOV60 INS25 INS27 INS8 INS39 INS59 INS42 MOV8 INS42 INS38 INS41 INS42 INS9 INS42 INS9 INS9 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL9 DEL32 DEL42 DEL42 DEL9 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL42 DEL45 DEL45 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL9 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL32 DEL38 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL25 DEL8
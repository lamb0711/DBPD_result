HDFS-3056.  Add a new interface RollingLogs for DataBlockScanner logging.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1299139 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.BufferedReader;
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FileReader;
-import java.io.PrintStream;
+import java.util.Map;
+import java.util.SortedSet;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+  private static final String DATA_FORMAT = "yyyy-MM-dd HH:mm:ss,SSS";
+
-  
-  static final long DEFAULT_SCAN_PERIOD_HOURS = 21*24L; // three weeks
-  private final String blockPoolId;
-  
-  private static final String dateFormatString = "yyyy-MM-dd HH:mm:ss,SSS";
-  
-  static final String verificationLogFile = "dncp_block_verification.log";
-  static final int verficationLogLimit = 5; // * numBlocks.
+  private static final long DEFAULT_SCAN_PERIOD_HOURS = 21*24L; // three weeks
-  private long scanPeriod = DEFAULT_SCAN_PERIOD_HOURS * 3600 * 1000;
-  private DataNode datanode;
+  private static final String VERIFICATION_PREFIX = "dncp_block_verification.log";
+
+  private final String blockPoolId;
+  private final long scanPeriod;
+  private final AtomicLong lastScanTime = new AtomicLong();
+
+  private final DataNode datanode;
-  // sorted set
-  private TreeSet<BlockScanInfo> blockInfoSet;
-  private HashMap<Block, BlockScanInfo> blockMap;
+  private final SortedSet<BlockScanInfo> blockInfoSet
+      = new TreeSet<BlockScanInfo>();
+  private final Map<Block, BlockScanInfo> blockMap
+      = new HashMap<Block, BlockScanInfo>();
-  private HashMap<Long, Integer> processedBlocks;
+  private volatile HashMap<Long, Integer> processedBlocks;
-  private long totalBlocksScannedInLastRun = 0; // Used for test only
+  private final AtomicInteger totalBlocksScannedInLastRun = new AtomicInteger(); // Used for test only
-  private LogFileHandler verificationLog;
+  private final LogFileHandler verificationLog;
-  private DataTransferThrottler throttler = null;
+  private final DataTransferThrottler throttler = new DataTransferThrottler(
+       200, MAX_SCAN_RATE);
-  BlockPoolSliceScanner(DataNode datanode,
+  BlockPoolSliceScanner(String bpid, DataNode datanode,
-      Configuration conf, String bpid) {
+      Configuration conf) {
-    scanPeriod = conf.getInt(DFSConfigKeys.DFS_DATANODE_SCAN_PERIOD_HOURS_KEY, 
+    
+    long hours = conf.getInt(DFSConfigKeys.DFS_DATANODE_SCAN_PERIOD_HOURS_KEY, 
-    if ( scanPeriod <= 0 ) {
-      scanPeriod = DEFAULT_SCAN_PERIOD_HOURS;
+    if (hours <= 0) {
+      hours = DEFAULT_SCAN_PERIOD_HOURS;
-    scanPeriod *= 3600 * 1000;
-    LOG.info("Periodic Block Verification scan initialized with interval " + scanPeriod + ".");
+    this.scanPeriod = hours * 3600 * 1000;
+    LOG.info("Periodic Block Verification Scanner initialized with interval "
+        + hours + " hours for block pool " + bpid + ".");
+
+    // get the list of blocks and arrange them in random order
+    List<Block> arr = dataset.getFinalizedBlocks(blockPoolId);
+    Collections.shuffle(arr);
+    
+    long scanTime = -1;
+    for (Block block : arr) {
+      BlockScanInfo info = new BlockScanInfo( block );
+      info.lastScanTime = scanTime--; 
+      //still keep 'info.lastScanType' to NONE.
+      addBlockInfo(info);
+    }
+
+    RollingLogs rollingLogs = null;
+    try {
+       rollingLogs = dataset.createRollingLogs(blockPoolId, VERIFICATION_PREFIX);
+    } catch (IOException e) {
+      LOG.warn("Could not open verfication log. " +
+               "Verification times are not stored.");
+    }
+    verificationLog = rollingLogs == null? null: new LogFileHandler(rollingLogs);
-  synchronized boolean isInitialized() {
-    return throttler != null;
-  }
-  
-  void init() throws IOException {
-    // get the list of blocks and arrange them in random order
-    List<Block> arr = dataset.getFinalizedBlocks(blockPoolId);
-    Collections.shuffle(arr);
-    
-    blockInfoSet = new TreeSet<BlockScanInfo>();
-    blockMap = new HashMap<Block, BlockScanInfo>();
-    
-    long scanTime = -1;
-    for (Block block : arr) {
-      BlockScanInfo info = new BlockScanInfo( block );
-      info.lastScanTime = scanTime--; 
-      //still keep 'info.lastScanType' to NONE.
-      addBlockInfo(info);
-    }
-
-    /* Pick the first directory that has any existing scanner log.
-     * otherwise, pick the first directory.
-     */
-    File dir = null;
-    final List<? extends FSVolumeInterface> volumes = dataset.getVolumes();
-    for (FSVolumeInterface vol : volumes) {
-      File bpDir = vol.getDirectory(blockPoolId);
-      if (LogFileHandler.isFilePresent(bpDir, verificationLogFile)) {
-        dir = bpDir;
-        break;
-      }
-    }
-    if (dir == null) {
-      dir = volumes.get(0).getDirectory(blockPoolId);
-    }
-    
-    try {
-      // max lines will be updated later during initialization.
-      verificationLog = new LogFileHandler(dir, verificationLogFile, 100);
-    } catch (IOException e) {
-      LOG.warn("Could not open verfication log. " +
-               "Verification times are not stored.");
-    }
-    
-    synchronized (this) {
-      throttler = new DataTransferThrottler(200, MAX_SCAN_RATE);
-    }
-  }
-
-    if (!isInitialized()) {
-      return;
-    }
-    
-    if (!isInitialized()) {
-      return;
-    }
-  /** @return the last scan time */
+  /** @return the last scan time for the block pool. */
+  long getLastScanTime() {
+    return lastScanTime.get();
+  }
+
+  /** @return the last scan time the given block. */
-    if (!isInitialized()) {
-      return 0;
-    }
-    if (!isInitialized()) {
-      return;
-    }
-    LogFileHandler log = verificationLog;
-    if (log != null) {
-      log.appendLine(now, block.getGenerationStamp(), block.getBlockId());
+    if (verificationLog != null) {
+      verificationLog.append(now, block.getGenerationStamp(),
+          block.getBlockId());
+
+    static String toString(long verificationTime, long genStamp, long blockId,
+        DateFormat dateFormat) {
+      return "\ndate=\"" + dateFormat.format(new Date(verificationTime))
+          + "\"\t time=\"" + verificationTime
+          + "\"\t genstamp=\"" + genStamp
+          + "\"\t id=\"" + blockId + "\"";
+    }
+
-  long getBlocksScannedInLastRun() {
-    return totalBlocksScannedInLastRun;
+  int getBlocksScannedInLastRun() {
+    return totalBlocksScannedInLastRun.get();
-    int numBlocks = 1;
-    LogFileHandler log = null;
-    synchronized (this) {
-      log = verificationLog;
-      numBlocks = Math.max(blockMap.size(), 1);
-    }
-
-    long now = System.currentTimeMillis();
-    LogFileHandler.Reader logReader[] = new LogFileHandler.Reader[2];
-    try {
-      if (log != null) {
-        logReader[0] = log.getCurrentFileReader();
-        logReader[1] = log.getPreviousFileReader();
-      }
-    } catch (IOException e) {
-      LOG.warn("Could not read previous verification times", e);
-    }
-    
-    try {
-      for (LogFileHandler.Reader reader : logReader) {
-      // update verification times from the verificationLog.
-        while (logReader != null && reader.hasNext()) {
+    //First updates the last verification times from the log file.
+    if (verificationLog != null) {
+      long now = System.currentTimeMillis();
+      RollingLogs.LineIterator logIterator = null;
+      try {
+        logIterator = verificationLog.logs.iterator(false);
+        // update verification times from the verificationLog.
+        while (logIterator.hasNext()) {
-          LogEntry entry = LogEntry.parseEntry(reader.next());
+          LogEntry entry = LogEntry.parseEntry(logIterator.next());
-                if (reader.file == log.prevFile) {
+                if (logIterator.isPrevious()) {
-                  log.appendLine(entry.verificationTime, entry.genStamp,
+                  verificationLog.append(entry.verificationTime, entry.genStamp,
+      } catch (IOException e) {
+        LOG.warn("Failed to read previous verification times.", e);
+      } finally {
+        IOUtils.closeStream(logIterator);
-    } finally {
-      IOUtils.closeStream(logReader[0]);
-      IOUtils.closeStream(logReader[1]);
-    /* Initially spread the block reads over half of 
-     * MIN_SCAN_PERIOD so that we don't keep scanning the 
-     * blocks too quickly when restarted.
-     */
-    long verifyInterval = (long) (Math.min( scanPeriod/2.0/numBlocks,
-                                            10*60*1000 ));
-    long lastScanTime = System.currentTimeMillis() - scanPeriod;
+      final int numBlocks = Math.max(blockMap.size(), 1);
+      // Initially spread the block reads over half of scan period
+      // so that we don't keep scanning the blocks too quickly when restarted.
+      long verifyInterval = Math.min(scanPeriod/(2L * numBlocks), 10*60*1000L);
+      long lastScanTime = System.currentTimeMillis() - scanPeriod;
+
-
-  static File getCurrentFile(FSVolumeInterface vol, String bpid) throws IOException {
-    return LogFileHandler.getCurrentFile(vol.getDirectory(bpid),
-        BlockPoolSliceScanner.verificationLogFile);
-  }
-    if (processedBlocks != null) {
-      totalBlocksScannedInLastRun = processedBlocks.size();
-    }
-    if (verificationLog != null) {
-      try {
-        verificationLog.openCurFile();
-      } catch (FileNotFoundException ex) {
-        LOG.warn("Could not open current file");
-      }
-    }
-    scan();
+    try {
+      scan();
+    } finally {
+      totalBlocksScannedInLastRun.set(processedBlocks.size());
+      lastScanTime.set(System.currentTimeMillis());
+    }
-  public void scan() {
+  private void scan() {
-        verificationLog.roll();
+        verificationLog.logs.roll();
-    DateFormat dateFormat = new SimpleDateFormat(dateFormatString);
+    DateFormat dateFormat = new SimpleDateFormat(DATA_FORMAT);
-   * times of the blocks. It rolls the current file when it is too big etc.
-   * If there is an error while writing, it stops updating with an error
-   * message.
+   * times of the blocks.
-    
-    private static final String curFileSuffix = ".curr";
-    private static final String prevFileSuffix = ".prev";
-    private final DateFormat dateFormat = new SimpleDateFormat(dateFormatString);
-    
-    static File getCurrentFile(File dir, String filePrefix) {
-      return new File(dir, filePrefix + curFileSuffix);
-    }
-    
-    public Reader getPreviousFileReader() throws IOException {
-      return new Reader(prevFile);
-    }
-    
-    public Reader getCurrentFileReader() throws IOException {
-      return new Reader(curFile);
+    private final DateFormat dateFormat = new SimpleDateFormat(DATA_FORMAT);
+
+    private final RollingLogs logs;
+
+    private LogFileHandler(RollingLogs logs)  {
+      this.logs = logs;
-    static boolean isFilePresent(File dir, String filePrefix) {
-      return new File(dir, filePrefix + curFileSuffix).exists() ||
-             new File(dir, filePrefix + prevFileSuffix).exists();
-    }
-    private File curFile;
-    private File prevFile;
-    
-    private PrintStream out;
-        
-    /**
-     * Opens the log file for appending.
-     * Note that rolling will happen only after "updateLineCount()" is 
-     * called. This is so that line count could be updated in a separate
-     * thread without delaying start up.
-     * 
-     * @param dir where the logs files are located.
-     * @param filePrefix prefix of the file.
-     * @param maxNumLines max lines in a file (its a soft limit).
-     * @throws IOException
-     */
-    LogFileHandler(File dir, String filePrefix, int maxNumLines) 
-                                                throws IOException {
-      curFile = new File(dir, filePrefix + curFileSuffix);
-      prevFile = new File(dir, filePrefix + prevFileSuffix);
-    }
-    
-    /**
-     * Append "\n" + line.
-     * If the log file need to be rolled, it will done after 
-     * appending the text.
-     * This does not throw IOException when there is an error while 
-     * appending. Currently does not throw an error even if rolling 
-     * fails (may be it should?).
-     * return true if append was successful.
-     */
-    synchronized boolean appendLine(String line) {
-      if (out == null) {
-        return false;
+    void append(long verificationTime, long genStamp, long blockId) {
+      final String m = LogEntry.toString(verificationTime, genStamp, blockId,
+          dateFormat);
+      try {
+        logs.appender().append(m);
+      } catch (IOException e) {
+        LOG.warn("Failed to append to " + logs + ", m=" + m, e);
-      out.println();
-      out.print(line);
-      return true;
-    
-    boolean appendLine(long verificationTime, long genStamp, long blockId) {
-      return appendLine("date=\""
-          + dateFormat.format(new Date(verificationTime)) + "\"\t " + "time=\""
-          + verificationTime + "\"\t " + "genstamp=\"" + genStamp + "\"\t "
-          + "id=\"" + blockId + "\"");
-    }
-    
-    private synchronized void openCurFile() throws FileNotFoundException {
-      close();
-      out = new PrintStream(new FileOutputStream(curFile, true));
-    }
-    
-    private void roll() throws IOException {
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Rolling current file: " + curFile.getAbsolutePath()
-            + " to previous file: " + prevFile.getAbsolutePath());
-      }
-      if (!prevFile.delete() && prevFile.exists()) {
-        throw new IOException("Could not delete " + prevFile);
-      }
-      
-      close();
-
-      if (!curFile.renameTo(prevFile)) {
-        throw new IOException("Could not rename " + curFile + 
-                              " to " + prevFile);
+    void close() {
+      try {
+        logs.appender().close();
+      } catch (IOException e) {
+        LOG.warn("Failed to close the appender of " + logs, e);
-    
-    synchronized void close() {
-      if (out != null) {
-        out.close();
-        out = null;
-      }
-    }
-    
-    /**
-     * This is used to read the lines in order.
-     * If the data is not read completely (i.e, untill hasNext() returns
-     * false), it needs to be explicitly 
-     */
-    private static class Reader implements Iterator<String>, Closeable {
-      
-      BufferedReader reader;
-      File file;
-      String line;
-      boolean closed = false;
-      
-      private Reader(File file) throws IOException {
-        reader = null;
-        this.file = file;
-        readNext();        
-      }
-      
-      private boolean openFile() throws IOException {
-        if (file == null) {
-          return false;
-        }       
-        if (reader != null ) {
-          reader.close();
-          reader = null;
-        }
-        if (file.exists()) {
-          reader = new BufferedReader(new FileReader(file));
-          return true;
-        } else {
-          return false;
-        }
-      }
-      
-      // read next line if possible.
-      private void readNext() throws IOException {
-        line = null;
-        if (reader == null) {
-          openFile();
-        }
-        try {
-          if (reader != null && (line = reader.readLine()) != null) {
-            return;
-          }
-        } finally {
-          if (!hasNext()) {
-            close();
-          }
-        }
-      }
-      
-      public boolean hasNext() {
-        return line != null;
-      }
-
-      public String next() {
-        String curLine = line;
-        try {
-          readNext();
-        } catch (IOException e) {
-          LOG.info("Could not read next line in LogHandler", e);
-        }
-        return curLine;
-      }
-
-      public void remove() {
-        throw new RuntimeException("remove() is not supported.");
-      }
-
-      public void close() throws IOException {
-        if (!closed) {
-          try {
-            if (reader != null) {
-              reader.close();
-            }
-          } finally {
-            file = null;
-            reader = null;
-            closed = true;
-          }
-        }
-      }
-    } 

MOV26 MOV26 MOV26 MOV26 MOV23 MOV23 MOV31 MOV31 UPD40 UPD40 UPD40 UPD40 INS31 MOV43 INS83 INS83 MOV43 UPD83 UPD39 INS83 INS43 INS83 INS83 UPD74 INS83 UPD74 INS83 INS83 INS43 INS83 INS83 MOV42 MOV44 MOV44 MOV44 MOV44 INS8 INS29 UPD42 INS31 INS39 UPD42 UPD83 INS31 INS31 INS31 UPD42 UPD42 UPD42 INS42 UPD42 INS14 UPD43 MOV14 UPD43 MOV14 INS42 INS14 MOV14 MOV21 MOV21 MOV21 INS60 MOV25 MOV21 MOV21 MOV60 MOV21 MOV60 MOV70 MOV60 MOV54 MOV21 INS65 INS83 MOV43 INS42 INS44 INS44 INS44 INS44 INS8 MOV25 INS54 MOV43 MOV59 UPD43 INS83 MOV42 MOV44 MOV8 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 MOV44 INS8 MOV39 MOV42 INS8 INS43 UPD42 UPD42 INS43 INS39 INS59 UPD7 UPD43 INS66 INS32 UPD66 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS41 INS32 MOV8 INS8 INS8 INS59 UPD66 UPD42 UPD42 UPD43 UPD42 INS60 INS54 INS54 INS42 INS42 INS42 MOV32 UPD42 INS22 UPD42 UPD42 INS21 INS16 INS42 INS42 UPD42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 MOV42 MOV33 MOV60 INS60 INS54 INS60 INS60 MOV60 MOV21 MOV21 INS21 INS42 INS14 UPD42 UPD42 INS83 MOV43 INS59 INS8 INS12 INS8 MOV12 INS52 INS42 INS42 UPD45 INS42 INS45 UPD42 INS7 INS27 INS33 MOV14 INS45 MOV32 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS43 INS59 MOV8 INS12 INS8 INS83 INS39 INS59 INS39 INS59 INS32 INS32 MOV43 INS42 INS22 INS42 INS42 INS32 MOV21 INS44 INS8 MOV21 UPD42 INS42 INS32 INS42 INS33 UPD42 UPD42 UPD42 INS42 INS42 UPD40 MOV40 INS42 INS33 INS21 MOV44 INS8 INS21 INS42 MOV32 INS42 INS32 INS42 INS42 MOV32 UPD42 MOV42 INS42 INS32 INS52 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 MOV21 INS42 INS42 INS42 INS42 INS7 INS32 INS21 INS32 INS42 INS42 INS27 INS27 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 MOV42 INS32 INS42 INS32 UPD42 MOV42 MOV42 INS32 INS42 INS42 INS42 INS42 INS36 INS34 INS34 INS34 INS40 INS42 INS42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 INS27 INS40 INS42 INS9 INS42 INS42 INS45 INS42 INS27 UPD45 INS42 UPD45 INS42 INS45 INS42 INS34 INS42 UPD42 INS32 INS42 INS42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL34 DEL39 DEL42 DEL34 DEL34 DEL27 DEL39 DEL34 DEL33 DEL42 DEL42 DEL34 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL70 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL34 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL52 DEL42 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL34 DEL41 DEL8 DEL25 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL40 DEL32 DEL42 DEL33 DEL27 DEL32 DEL27 DEL40 DEL40 DEL27 DEL43 DEL42 DEL44 DEL42 DEL70 DEL42 DEL34 DEL2 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL34 DEL2 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL8 DEL51 DEL40 DEL43 DEL42 DEL85 DEL40 DEL43 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL8 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL34 DEL2 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL2 DEL32 DEL21 DEL8 DEL54 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL34 DEL42 DEL27 DEL34 DEL34 DEL34 DEL27 DEL32 DEL36 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL7 DEL42 DEL66 DEL66 DEL83 DEL42 DEL45 DEL59 DEL83 DEL45 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL14 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL14 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL9 DEL14 DEL14 DEL7 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL45 DEL83 DEL83 DEL42 DEL42 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL14 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL14 DEL42 DEL32 DEL27 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL45 DEL45 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL27 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL43 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL59 DEL23 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL14 DEL7 DEL21 DEL9 DEL41 DEL8 DEL9 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL27 DEL41 DEL8 DEL25 DEL8 DEL42 DEL32 DEL38 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL38 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL33 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL31 DEL55